<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;

  98 
  99     // The set of lint options currently in effect. It is initialized
 100     // from the context, and then is set/reset as needed by Attr as it
 101     // visits all the various parts of the trees during attribution.
 102     private Lint lint;
 103 
 104     // The method being analyzed in Attr - it is set/reset as needed by
 105     // Attr as it visits new method declarations.
 106     private MethodSymbol method;
 107 
 108     public static Check instance(Context context) {
 109         Check instance = context.get(checkKey);
 110         if (instance == null)
 111             instance = new Check(context);
 112         return instance;
 113     }
 114 
 115     protected Check(Context context) {
 116         context.put(checkKey, this);
 117 
 118         names = Names.instance(context);
 119         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 120             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 121             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 122         log = Log.instance(context);
 123         rs = Resolve.instance(context);
 124         syms = Symtab.instance(context);
 125         enter = Enter.instance(context);
 126         deferredAttr = DeferredAttr.instance(context);
 127         infer = Infer.instance(context);
 128         types = Types.instance(context);
 129         typeAnnotations = TypeAnnotations.instance(context);
 130         diags = JCDiagnostic.Factory.instance(context);
 131         Options options = Options.instance(context);
 132         lint = Lint.instance(context);
 133         fileManager = context.get(JavaFileManager.class);
 134 
 135         source = Source.instance(context);
 136         target = Target.instance(context);
 137         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
<span class="line-modified"> 138 </span>
 139         Target target = Target.instance(context);
 140         syntheticNameChar = target.syntheticNameChar();
 141 
 142         profile = Profile.instance(context);
 143         preview = Preview.instance(context);
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
</pre>
<hr />
<pre>
 479         uncheckedHandler.clear();
 480         sunApiHandler.clear();
 481     }
 482 
 483     public void putCompiled(ClassSymbol csym) {
 484         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 485     }
 486 
 487     public ClassSymbol getCompiled(ClassSymbol csym) {
 488         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 489     }
 490 
 491     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 492         return compiled.get(Pair.of(msym, flatname));
 493     }
 494 
 495     public void removeCompiled(ClassSymbol csym) {
 496         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 497     }
 498 
<span class="line-modified"> 499 /* *************************************************************************</span>
 500  * Type Checking
 501  **************************************************************************/
 502 
 503     /**
 504      * A check context is an object that can be used to perform compatibility
 505      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 506      * vary significantly.
 507      */
 508     public interface CheckContext {
 509         /**
 510          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 511          */
 512         boolean compatible(Type found, Type req, Warner warn);
 513         /**
 514          * Report a check error
 515          */
 516         void report(DiagnosticPosition pos, JCDiagnostic details);
 517         /**
 518          * Obtain a warner for this check context
 519          */
</pre>
<hr />
<pre>
 585         public String toString() {
 586             return &quot;CheckContext: basicHandler&quot;;
 587         }
 588     };
 589 
 590     /** Check that a given type is assignable to a given proto-type.
 591      *  If it is, return the type, otherwise return errType.
 592      *  @param pos        Position to be used for error reporting.
 593      *  @param found      The type that was found.
 594      *  @param req        The type that was required.
 595      */
 596     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 597         return checkType(pos, found, req, basicHandler);
 598     }
 599 
 600     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 601         final InferenceContext inferenceContext = checkContext.inferenceContext();
 602         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 603             inferenceContext.addFreeTypeListener(List.of(req, found),
 604                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));





 605         }
 606         if (req.hasTag(ERROR))
 607             return req;
 608         if (req.hasTag(NONE))
 609             return found;
 610         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {



 611             return found;
 612         } else {
 613             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 614                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 615                 return types.createErrorType(found);
 616             }
 617             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 618             return types.createErrorType(found);
 619         }
 620     }
 621 
 622     /** Check that a given type can be cast to a given target type.
 623      *  Return the result of the cast.
 624      *  @param pos        Position to be used for error reporting.
 625      *  @param found      The type that is being cast.
 626      *  @param req        The target type of the cast.
 627      */
 628     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 629         return checkCastable(pos, found, req, basicHandler);
 630     }
 631     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 632         if (types.isCastable(found, req, castWarner(pos, found, req))) {







 633             return req;
 634         } else {
 635             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 636             return types.createErrorType(found);
 637         }
 638     }
 639 
 640     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 641      * The problem should only be reported for non-292 cast
 642      */
 643     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 644         if (!tree.type.isErroneous()
 645                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 646                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 647                 &amp;&amp; !is292targetTypeCast(tree)) {
 648             deferredLintHandler.report(() -&gt; {
 649                 if (lint.isEnabled(LintCategory.CAST))
 650                     log.warning(LintCategory.CAST,
 651                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 652             });
</pre>
<hr />
<pre>
 715     /** Check that type is a class or interface type.
 716      *  @param pos           Position to be used for error reporting.
 717      *  @param t             The type to be checked.
 718      */
 719     Type checkClassType(DiagnosticPosition pos, Type t) {
 720         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 721             return typeTagError(pos,
 722                                 diags.fragment(Fragments.TypeReqClass),
 723                                 asTypeParam(t));
 724         } else {
 725             return t;
 726         }
 727     }
 728     //where
 729         private Object asTypeParam(Type t) {
 730             return (t.hasTag(TYPEVAR))
 731                                     ? diags.fragment(Fragments.TypeParameter(t))
 732                                     : t;
 733         }
 734 











































 735     /** Check that type is a valid qualifier for a constructor reference expression
 736      */
 737     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 738         t = checkClassOrArrayType(pos, t);
 739         if (t.hasTag(CLASS)) {
 740             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 741                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 742                 t = types.createErrorType(t);
 743             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 744                 log.error(pos, Errors.EnumCantBeInstantiated);
 745                 t = types.createErrorType(t);
 746             } else {
 747                 t = checkClassType(pos, t, true);
 748             }
 749         } else if (t.hasTag(ARRAY)) {
 750             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 751                 log.error(pos, Errors.GenericArrayCreation);
 752                 t = types.createErrorType(t);
 753             }
 754         }
</pre>
<hr />
<pre>
 762      */
 763     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 764         t = checkClassType(pos, t);
 765         if (noBounds &amp;&amp; t.isParameterized()) {
 766             List&lt;Type&gt; args = t.getTypeArguments();
 767             while (args.nonEmpty()) {
 768                 if (args.head.hasTag(WILDCARD))
 769                     return typeTagError(pos,
 770                                         diags.fragment(Fragments.TypeReqExact),
 771                                         args.head);
 772                 args = args.tail;
 773             }
 774         }
 775         return t;
 776     }
 777 
 778     /** Check that type is a reference type, i.e. a class, interface or array type
 779      *  or a type variable.
 780      *  @param pos           Position to be used for error reporting.
 781      *  @param t             The type to be checked.

 782      */
<span class="line-modified"> 783     Type checkRefType(DiagnosticPosition pos, Type t) {</span>
<span class="line-modified"> 784         if (t.isReference())</span>
 785             return t;
 786         else
 787             return typeTagError(pos,
 788                                 diags.fragment(Fragments.TypeReqRef),
 789                                 t);
 790     }
 791 









 792     /** Check that each type is a reference type, i.e. a class, interface or array type
 793      *  or a type variable.
 794      *  @param trees         Original trees, used for error reporting.
 795      *  @param types         The types to be checked.
 796      */
 797     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 798         List&lt;JCExpression&gt; tl = trees;
 799         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
<span class="line-modified"> 800             l.head = checkRefType(tl.head.pos(), l.head);</span>
 801             tl = tl.tail;
 802         }
 803         return types;
 804     }
 805 
 806     /** Check that type is a null or reference type.
 807      *  @param pos           Position to be used for error reporting.
 808      *  @param t             The type to be checked.
 809      */
 810     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 811         if (t.isReference() || t.hasTag(BOT))
 812             return t;
 813         else
 814             return typeTagError(pos,
 815                                 diags.fragment(Fragments.TypeReqRef),
 816                                 t);
 817     }
 818 
 819     /** Check that flag set does not contain elements of two conflicting sets. s
 820      *  Return true if it doesn&#39;t.
 821      *  @param pos           Position to be used for error reporting.
 822      *  @param flags         The set of flags to be checked.
 823      *  @param set1          Conflicting flags set #1.
 824      *  @param set2          Conflicting flags set #2.
 825      */
 826     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 827         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 828             log.error(pos,
 829                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 830                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 831             return false;
 832         } else
 833             return true;
 834     }
 835 
















































 836     /** Check that usage of diamond operator is correct (i.e. diamond should not
 837      * be used with non-generic classes or in anonymous class creation expressions)
 838      */
 839     Type checkDiamond(JCNewClass tree, Type t) {
 840         if (!TreeInfo.isDiamond(tree) ||
 841                 t.isErroneous()) {
 842             return checkClassType(tree.clazz.pos(), t, true);
 843         } else {
 844             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 845                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 846                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 847             }
 848             if (t.tsym.type.getTypeArguments().isEmpty()) {
 849                 log.error(tree.clazz.pos(),
 850                           Errors.CantApplyDiamond1(t,
 851                                                    Fragments.DiamondNonGeneric(t)));
 852                 return types.createErrorType(t);
 853             } else if (tree.typeargs != null &amp;&amp;
 854                     tree.typeargs.nonEmpty()) {
 855                 log.error(tree.clazz.pos(),
</pre>
<hr />
<pre>
 964     }
 965     //where
 966         private boolean isTrustMeAllowedOnMethod(Symbol s) {
 967             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
 968                 (s.isConstructor() ||
 969                     (s.flags() &amp; (STATIC | FINAL |
 970                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
 971         }
 972 
 973     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
 974         //check that resulting type is not the null type
 975         if (t.hasTag(BOT)) {
 976             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
 977             return types.createErrorType(t);
 978         } else if (t.hasTag(VOID)) {
 979             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
 980             return types.createErrorType(t);
 981         }
 982 
 983         //upward project the initializer type
<span class="line-modified"> 984         return types.upward(t, types.captures(t));</span>





































 985     }
 986 
 987     Type checkMethod(final Type mtype,
 988             final Symbol sym,
 989             final Env&lt;AttrContext&gt; env,
 990             final List&lt;JCExpression&gt; argtrees,
 991             final List&lt;Type&gt; argtypes,
 992             final boolean useVarargs,
 993             InferenceContext inferenceContext) {
 994         // System.out.println(&quot;call   : &quot; + env.tree);
 995         // System.out.println(&quot;method : &quot; + owntype);
 996         // System.out.println(&quot;actuals: &quot; + argtypes);
 997         if (inferenceContext.free(mtype)) {
 998             inferenceContext.addFreeTypeListener(List.of(mtype),
 999                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
1000             return mtype;
1001         }
1002         Type owntype = mtype;
1003         List&lt;Type&gt; formals = owntype.getParameterTypes();
1004         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
</pre>
<hr />
<pre>
1162      *  return modifiers together with any implicit modifiers for that symbol.
1163      *  Warning: we can&#39;t use flags() here since this method
1164      *  is called during class enter, when flags() would cause a premature
1165      *  completion.
1166      *  @param pos           Position to be used for error reporting.
1167      *  @param flags         The set of modifiers given in a definition.
1168      *  @param sym           The defined symbol.
1169      */
1170     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1171         long mask;
1172         long implicit = 0;
1173 
1174         switch (sym.kind) {
1175         case VAR:
1176             if (TreeInfo.isReceiverParam(tree))
1177                 mask = ReceiverParamFlags;
1178             else if (sym.owner.kind != TYP)
1179                 mask = LocalVarFlags;
1180             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1181                 mask = implicit = InterfaceVarFlags;
<span class="line-modified">1182             else</span>
1183                 mask = VarFlags;




1184             break;
1185         case MTH:
1186             if (sym.name == names.init) {
1187                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1188                     // enum constructors cannot be declared public or
1189                     // protected and must be implicitly or explicitly
1190                     // private
1191                     implicit = PRIVATE;
1192                     mask = PRIVATE;
1193                 } else
1194                     mask = ConstructorFlags;
1195             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1196                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1197                     mask = AnnotationTypeElementMask;
1198                     implicit = PUBLIC | ABSTRACT;
1199                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1200                     mask = InterfaceMethodMask;
1201                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1202                     if ((flags &amp; DEFAULT) != 0) {
1203                         implicit |= ABSTRACT;
1204                     }
1205                 } else {
1206                     mask = implicit = InterfaceMethodFlags;
1207                 }
1208             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1209                 mask = RecordMethodFlags;
1210             } else {
<span class="line-modified">1211                 mask = MethodFlags;</span>


1212             }
1213             // Imply STRICTFP if owner has STRICTFP set.
1214             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1215                 ((flags) &amp; Flags.DEFAULT) != 0)
1216                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1217             break;
1218         case TYP:
1219             if (sym.isLocal()) {
1220                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1221                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1222                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1223                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1224                 implicit = implicitlyStatic ? STATIC : implicit;
1225                 if (staticOrImplicitlyStatic) {
1226                     if (sym.owner.kind == TYP) {
1227                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1228                     }
1229                 }
1230             } else if (sym.owner.kind == TYP) {
1231                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : ExtendedMemberClassFlags;
1232                 if (sym.owner.owner.kind == PCK ||
1233                     (sym.owner.flags_field &amp; STATIC) != 0)
1234                     mask |= STATIC;
1235                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1236                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1237                 }
1238                 // Nested interfaces and enums are always STATIC (Spec ???)
1239                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1240             } else {
1241                 mask = ExtendedClassFlags;
1242             }
1243             // Interfaces are always ABSTRACT
1244             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1245 
1246             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1247                 // enums can&#39;t be declared abstract, final, sealed or non-sealed</span>
<span class="line-modified">1248                 mask &amp;= ~(ABSTRACT | FINAL | SEALED | NON_SEALED);</span>
1249                 implicit |= implicitEnumFinalFlag(tree);
1250             }
1251             if ((flags &amp; RECORD) != 0) {
1252                 // records can&#39;t be declared abstract
1253                 mask &amp;= ~ABSTRACT;
1254                 implicit |= FINAL;
1255             }
1256             // Imply STRICTFP if owner has STRICTFP set.
1257             implicit |= sym.owner.flags_field &amp; STRICTFP;
1258             break;
1259         default:
1260             throw new AssertionError();
1261         }
1262         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1263         if (illegal != 0) {
1264             if ((illegal &amp; INTERFACE) != 0) {
1265                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1266                 mask |= INTERFACE;
1267             }
1268             else {
1269                 log.error(pos,
1270                         Errors.ModNotAllowedHere(asFlagSet(illegal)));
1271             }
1272         }
1273         else if ((sym.kind == TYP ||
1274                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1275                   // in the presence of inner classes. Should it be deleted here?
1276                   checkDisjoint(pos, flags,
1277                                 ABSTRACT,
1278                                 PRIVATE | STATIC | DEFAULT))
1279                  &amp;&amp;
1280                  checkDisjoint(pos, flags,
1281                                 STATIC | PRIVATE,
1282                                 DEFAULT)
1283                  &amp;&amp;
1284                  checkDisjoint(pos, flags,
1285                                ABSTRACT | INTERFACE,
<span class="line-modified">1286                                FINAL | NATIVE | SYNCHRONIZED)</span>
1287                  &amp;&amp;
1288                  checkDisjoint(pos, flags,
1289                                PUBLIC,
1290                                PRIVATE | PROTECTED)
1291                  &amp;&amp;
1292                  checkDisjoint(pos, flags,
1293                                PRIVATE,
1294                                PUBLIC | PROTECTED)
1295                  &amp;&amp;
<span class="line-modified">1296                  checkDisjoint(pos, flags,</span>
1297                                FINAL,
1298                                VOLATILE)
1299                  &amp;&amp;
1300                  (sym.kind == TYP ||
1301                   checkDisjoint(pos, flags,
1302                                 ABSTRACT | NATIVE,
1303                                 STRICTFP))
1304                  &amp;&amp; checkDisjoint(pos, flags,
1305                                 FINAL,
1306                            SEALED | NON_SEALED)
1307                  &amp;&amp; checkDisjoint(pos, flags,
1308                                 SEALED,
1309                            FINAL | NON_SEALED)) {
1310             // skip
1311         }
1312         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1313     }
1314 
1315 
1316     /** Determine if this enum should be implicitly final.
</pre>
<hr />
<pre>
1450         @Override
1451         public void visitWildcard(JCWildcard tree) {
1452             if (tree.inner != null)
1453                 validateTree(tree.inner, true, isOuter);
1454         }
1455 
1456         @Override
1457         public void visitSelect(JCFieldAccess tree) {
1458             if (tree.type.hasTag(CLASS)) {
1459                 visitSelectInternal(tree);
1460 
1461                 // Check that this type is either fully parameterized, or
1462                 // not parameterized at all.
1463                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1464                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1465             }
1466         }
1467 
1468         public void visitSelectInternal(JCFieldAccess tree) {
1469             if (tree.type.tsym.isStatic() &amp;&amp;
<span class="line-modified">1470                 tree.selected.type.isParameterized()) {</span>

1471                 // The enclosing type is not a class, so we are
1472                 // looking at a static member type.  However, the
1473                 // qualifying expression is parameterized.


1474                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1475             } else {
1476                 // otherwise validate the rest of the expression
1477                 tree.selected.accept(this);
1478             }
1479         }
1480 
1481         @Override
1482         public void visitAnnotatedType(JCAnnotatedType tree) {
1483             tree.underlyingType.accept(this);
1484         }
1485 
1486         @Override
1487         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1488             if (that.type.hasTag(TypeTag.VOID)) {
1489                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1490             }
1491             super.visitTypeIdent(that);
1492         }
1493 
</pre>
<hr />
<pre>
1780             return;
1781         }
1782 
1783         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1784             // handled in validateAnnotationMethod
1785             return;
1786         }
1787 
1788         // Error if overriding method has weaker access (JLS 8.4.6.3).
1789         if (protection(m.flags()) &gt; protection(other.flags())) {
1790             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1791                       (other.flags() &amp; AccessFlags) == 0 ?
1792                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1793                                                           &quot;package&quot;) :
1794                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1795                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1796             m.flags_field |= BAD_OVERRIDE;
1797             return;
1798         }
1799 









1800         Type mt = types.memberType(origin.type, m);
1801         Type ot = types.memberType(origin.type, other);
1802         // Error if overriding result type is different
1803         // (or, in the case of generics mode, not a subtype) of
1804         // overridden result type. We have to rename any type parameters
1805         // before comparing types.
1806         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1807         List&lt;Type&gt; otvars = ot.getTypeArguments();
1808         Type mtres = mt.getReturnType();
1809         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1810 
1811         overrideWarner.clear();
1812         boolean resultTypesOK =
1813             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1814         if (!resultTypesOK) {
1815             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1816                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1817                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1818                                         other.location()), mtres, otres));
1819                 m.flags_field |= BAD_OVERRIDE;
</pre>
<hr />
<pre>
2092             if (recordComponent.isPresent()) {
2093                 return;
2094             }
2095         }
2096 
2097         for (Type t = origin.type; t.hasTag(CLASS);
2098              t = types.supertype(t)) {
2099             if (t != origin.type) {
2100                 checkOverride(tree, t, origin, m);
2101             }
2102             for (Type t2 : types.interfaces(t)) {
2103                 checkOverride(tree, t2, origin, m);
2104             }
2105         }
2106 
2107         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2108         // Check if this method must override a super method due to being annotated with @Override
2109         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2110         // be treated &quot;as if as they were annotated&quot; with @Override.
2111         boolean mustOverride = explicitOverride ||
<span class="line-modified">2112                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate());</span>

2113         if (mustOverride &amp;&amp; !isOverrider(m)) {
2114             DiagnosticPosition pos = tree.pos();
2115             for (JCAnnotation a : tree.getModifiers().annotations) {
2116                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2117                     pos = a.pos();
2118                     break;
2119                 }
2120             }
2121             log.error(pos,
2122                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2123                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2124         }
2125     }
2126 
2127     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2128         TypeSymbol c = site.tsym;
2129         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2130             if (m.overrides(sym, origin, types, false)) {
2131                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2132                     checkOverride(tree, m, (MethodSymbol)sym, origin);
</pre>
<hr />
<pre>
2218                 cf.accepts(s2) &amp;&amp;
2219                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2220     }
2221 
2222 
2223     /** Check that all abstract members of given class have definitions.
2224      *  @param pos          Position to be used for error reporting.
2225      *  @param c            The class.
2226      */
2227     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2228         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2229         if (undef != null) {
2230             MethodSymbol undef1 =
2231                 new MethodSymbol(undef.flags(), undef.name,
2232                                  types.memberType(c.type, undef), undef.owner);
2233             log.error(pos,
2234                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2235         }
2236     }
2237 







































2238     void checkNonCyclicDecl(JCClassDecl tree) {
2239         CycleChecker cc = new CycleChecker();
2240         cc.scan(tree);
2241         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2242             tree.sym.flags_field |= ACYCLIC;
2243         }
2244     }
2245 
2246     class CycleChecker extends TreeScanner {
2247 
2248         List&lt;Symbol&gt; seenClasses = List.nil();
2249         boolean errorFound = false;
2250         boolean partialCheck = false;
2251 
2252         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2253             if (sym != null &amp;&amp; sym.kind == TYP) {
2254                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2255                 if (classEnv != null) {
2256                     DiagnosticSource prevSource = log.currentSource();
2257                     try {
</pre>
<hr />
<pre>
2466     /** Check that all abstract methods implemented by a class are
2467      *  mutually compatible.
2468      *  @param pos          Position to be used for error reporting.
2469      *  @param c            The class whose interfaces are checked.
2470      */
2471     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2472         List&lt;Type&gt; supertypes = types.interfaces(c);
2473         Type supertype = types.supertype(c);
2474         if (supertype.hasTag(CLASS) &amp;&amp;
2475             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2476             supertypes = supertypes.prepend(supertype);
2477         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2478             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2479                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2480                 return;
2481             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2482                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2483                     return;
2484         }
2485         checkCompatibleConcretes(pos, c);




2486     }
2487 
2488     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2489      *  are mutually compatible (JLS 8.4.8/9.4.1).
2490      *
2491      *  @param pos  Position to be used for error reporting.
2492      *  @param site The class whose methods are checked.
2493      *  @param sym  The method symbol to be checked.
2494      */
2495     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2496          ClashFilter cf = new ClashFilter(site);
2497         //for each method m1 that is overridden (directly or indirectly)
2498         //by method &#39;sym&#39; in &#39;site&#39;...
2499 
2500         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2501         boolean overridesAny = false;
2502         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2503         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2504         for (Symbol m1 : symbolsByName) {
2505             if (!sym.overrides(m1, site.tsym, types, false)) {
</pre>
<hr />
<pre>
3025                                 }
3026                             }
3027                             modifiers.annotations = newAnnotations.toList();
3028                         }
3029                         // now lets remove it from the symbol
3030                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3031                     } else {
3032                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3033                     }
3034                 }
3035             }
3036         }
3037 
3038         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3039             if (s.kind != TYP) {
3040                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3041             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3042                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3043             }
3044         }







3045     }
3046 
3047     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3048         Assert.checkNonNull(a.type);
3049         validateAnnotationTree(a);
3050 
3051         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3052                 !a.annotationType.type.isErroneous() &amp;&amp;
3053                 !isTypeAnnotation(a, isTypeParameter)) {
3054             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3055         }
3056     }
3057 
3058     /**
3059      * Validate the proposed container &#39;repeatable&#39; on the
3060      * annotation type symbol &#39;s&#39;. Report errors at position
3061      * &#39;pos&#39;.
3062      *
3063      * @param s The (annotation)type declaration annotated with a @Repeatable
3064      * @param repeatable the @Repeatable on &#39;s&#39;
</pre>
</td>
<td>
<hr />
<pre>
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
<span class="line-added">  98     private final boolean allowValueBasedClasses;</span>
  99 
 100     // The set of lint options currently in effect. It is initialized
 101     // from the context, and then is set/reset as needed by Attr as it
 102     // visits all the various parts of the trees during attribution.
 103     private Lint lint;
 104 
 105     // The method being analyzed in Attr - it is set/reset as needed by
 106     // Attr as it visits new method declarations.
 107     private MethodSymbol method;
 108 
 109     public static Check instance(Context context) {
 110         Check instance = context.get(checkKey);
 111         if (instance == null)
 112             instance = new Check(context);
 113         return instance;
 114     }
 115 
 116     protected Check(Context context) {
 117         context.put(checkKey, this);
 118 
 119         names = Names.instance(context);
 120         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 121             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 122             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 123         log = Log.instance(context);
 124         rs = Resolve.instance(context);
 125         syms = Symtab.instance(context);
 126         enter = Enter.instance(context);
 127         deferredAttr = DeferredAttr.instance(context);
 128         infer = Infer.instance(context);
 129         types = Types.instance(context);
 130         typeAnnotations = TypeAnnotations.instance(context);
 131         diags = JCDiagnostic.Factory.instance(context);
 132         Options options = Options.instance(context);
 133         lint = Lint.instance(context);
 134         fileManager = context.get(JavaFileManager.class);
 135 
 136         source = Source.instance(context);
 137         target = Target.instance(context);
 138         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
<span class="line-modified"> 139         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);</span>
 140         Target target = Target.instance(context);
 141         syntheticNameChar = target.syntheticNameChar();
 142 
 143         profile = Profile.instance(context);
 144         preview = Preview.instance(context);
 145 
 146         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 147         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 148         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 149         boolean enforceMandatoryWarnings = true;
 150 
 151         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 152                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 153         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 154                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 155         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 156                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 157         sunApiHandler = new MandatoryWarningHandler(log, false,
 158                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 159 
</pre>
<hr />
<pre>
 480         uncheckedHandler.clear();
 481         sunApiHandler.clear();
 482     }
 483 
 484     public void putCompiled(ClassSymbol csym) {
 485         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 486     }
 487 
 488     public ClassSymbol getCompiled(ClassSymbol csym) {
 489         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 490     }
 491 
 492     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 493         return compiled.get(Pair.of(msym, flatname));
 494     }
 495 
 496     public void removeCompiled(ClassSymbol csym) {
 497         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 498     }
 499 
<span class="line-modified"> 500     /* *************************************************************************</span>
 501  * Type Checking
 502  **************************************************************************/
 503 
 504     /**
 505      * A check context is an object that can be used to perform compatibility
 506      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 507      * vary significantly.
 508      */
 509     public interface CheckContext {
 510         /**
 511          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 512          */
 513         boolean compatible(Type found, Type req, Warner warn);
 514         /**
 515          * Report a check error
 516          */
 517         void report(DiagnosticPosition pos, JCDiagnostic details);
 518         /**
 519          * Obtain a warner for this check context
 520          */
</pre>
<hr />
<pre>
 586         public String toString() {
 587             return &quot;CheckContext: basicHandler&quot;;
 588         }
 589     };
 590 
 591     /** Check that a given type is assignable to a given proto-type.
 592      *  If it is, return the type, otherwise return errType.
 593      *  @param pos        Position to be used for error reporting.
 594      *  @param found      The type that was found.
 595      *  @param req        The type that was required.
 596      */
 597     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 598         return checkType(pos, found, req, basicHandler);
 599     }
 600 
 601     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 602         final InferenceContext inferenceContext = checkContext.inferenceContext();
 603         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 604             inferenceContext.addFreeTypeListener(List.of(req, found),
 605                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
<span class="line-added"> 606         } else {</span>
<span class="line-added"> 607             if (found.hasTag(CLASS)) {</span>
<span class="line-added"> 608                 if (inferenceContext != infer.emptyContext)</span>
<span class="line-added"> 609                     checkParameterizationWithValues(pos, found);</span>
<span class="line-added"> 610             }</span>
 611         }
 612         if (req.hasTag(ERROR))
 613             return req;
 614         if (req.hasTag(NONE))
 615             return found;
 616         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
<span class="line-added"> 617             if (found.hasTag(BOT) &amp;&amp; types.isValueBased(req)) {</span>
<span class="line-added"> 618                 log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));</span>
<span class="line-added"> 619             }</span>
 620             return found;
 621         } else {
 622             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 623                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 624                 return types.createErrorType(found);
 625             }
 626             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 627             return types.createErrorType(found);
 628         }
 629     }
 630 
 631     /** Check that a given type can be cast to a given target type.
 632      *  Return the result of the cast.
 633      *  @param pos        Position to be used for error reporting.
 634      *  @param found      The type that is being cast.
 635      *  @param req        The target type of the cast.
 636      */
 637     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 638         return checkCastable(pos, found, req, basicHandler);
 639     }
 640     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 641         if (types.isCastable(found, req, castWarner(pos, found, req))) {
<span class="line-added"> 642             if (types.isValueBased(req)) {</span>
<span class="line-added"> 643                 if (found.hasTag(BOT)) {</span>
<span class="line-added"> 644                     log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));</span>
<span class="line-added"> 645                 } else if (!types.isValueBased(found)) {</span>
<span class="line-added"> 646                     log.warning(pos, Warnings.PotentialNullPollution(found));</span>
<span class="line-added"> 647                 }</span>
<span class="line-added"> 648             }</span>
 649             return req;
 650         } else {
 651             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 652             return types.createErrorType(found);
 653         }
 654     }
 655 
 656     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 657      * The problem should only be reported for non-292 cast
 658      */
 659     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 660         if (!tree.type.isErroneous()
 661                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 662                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 663                 &amp;&amp; !is292targetTypeCast(tree)) {
 664             deferredLintHandler.report(() -&gt; {
 665                 if (lint.isEnabled(LintCategory.CAST))
 666                     log.warning(LintCategory.CAST,
 667                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 668             });
</pre>
<hr />
<pre>
 731     /** Check that type is a class or interface type.
 732      *  @param pos           Position to be used for error reporting.
 733      *  @param t             The type to be checked.
 734      */
 735     Type checkClassType(DiagnosticPosition pos, Type t) {
 736         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 737             return typeTagError(pos,
 738                                 diags.fragment(Fragments.TypeReqClass),
 739                                 asTypeParam(t));
 740         } else {
 741             return t;
 742         }
 743     }
 744     //where
 745         private Object asTypeParam(Type t) {
 746             return (t.hasTag(TYPEVAR))
 747                                     ? diags.fragment(Fragments.TypeParameter(t))
 748                                     : t;
 749         }
 750 
<span class="line-added"> 751     void checkConstraintsOfInlineSuper(DiagnosticPosition pos, ClassSymbol c) {</span>
<span class="line-added"> 752         for(Type st = types.supertype(c.type); st != Type.noType; st = types.supertype(st)) {</span>
<span class="line-added"> 753             if (st == null || st.tsym == null || st.tsym.kind == ERR)</span>
<span class="line-added"> 754                 return;</span>
<span class="line-added"> 755             if  (st.tsym == syms.objectType.tsym)</span>
<span class="line-added"> 756                 return;</span>
<span class="line-added"> 757             if (!st.tsym.isAbstract()) {</span>
<span class="line-added"> 758                 log.error(pos, Errors.ConcreteSupertypeForInlineClass(c, st));</span>
<span class="line-added"> 759             }</span>
<span class="line-added"> 760             if ((st.tsym.flags() &amp; HASINITBLOCK) != 0) {</span>
<span class="line-added"> 761                 log.error(pos, Errors.SuperClassDeclaresInitBlock(c, st));</span>
<span class="line-added"> 762             }</span>
<span class="line-added"> 763             // No instance fields and no arged constructors both mean inner classes cannot be inline supers.</span>
<span class="line-added"> 764             Type encl = st.getEnclosingType();</span>
<span class="line-added"> 765             if (encl != null &amp;&amp; encl.hasTag(CLASS)) {</span>
<span class="line-added"> 766                 log.error(pos, Errors.SuperClassCannotBeInner(c, st));</span>
<span class="line-added"> 767             }</span>
<span class="line-added"> 768             for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {</span>
<span class="line-added"> 769                 switch (s.kind) {</span>
<span class="line-added"> 770                 case VAR:</span>
<span class="line-added"> 771                     if ((s.flags() &amp; STATIC) == 0) {</span>
<span class="line-added"> 772                         log.error(pos, Errors.SuperFieldNotAllowed(s, c, st));</span>
<span class="line-added"> 773                     }</span>
<span class="line-added"> 774                     break;</span>
<span class="line-added"> 775                 case MTH:</span>
<span class="line-added"> 776                     if ((s.flags() &amp; SYNCHRONIZED) != 0) {</span>
<span class="line-added"> 777                         log.error(pos, Errors.SuperMethodCannotBeSynchronized(s, c, st));</span>
<span class="line-added"> 778                     } else if (s.isConstructor()) {</span>
<span class="line-added"> 779                         MethodSymbol m = (MethodSymbol)s;</span>
<span class="line-added"> 780                         if (m.getParameters().size() &gt; 0) {</span>
<span class="line-added"> 781                             log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, c, st));</span>
<span class="line-added"> 782                         } else {</span>
<span class="line-added"> 783                             if ((m.flags() &amp; (GENERATEDCONSTR | EMPTYNOARGCONSTR)) == 0) {</span>
<span class="line-added"> 784                                 log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, c, st));</span>
<span class="line-added"> 785                             }</span>
<span class="line-added"> 786                         }</span>
<span class="line-added"> 787                     }</span>
<span class="line-added"> 788                     break;</span>
<span class="line-added"> 789                 }</span>
<span class="line-added"> 790             }</span>
<span class="line-added"> 791         }</span>
<span class="line-added"> 792     }</span>
<span class="line-added"> 793 </span>
 794     /** Check that type is a valid qualifier for a constructor reference expression
 795      */
 796     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 797         t = checkClassOrArrayType(pos, t);
 798         if (t.hasTag(CLASS)) {
 799             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 800                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 801                 t = types.createErrorType(t);
 802             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 803                 log.error(pos, Errors.EnumCantBeInstantiated);
 804                 t = types.createErrorType(t);
 805             } else {
 806                 t = checkClassType(pos, t, true);
 807             }
 808         } else if (t.hasTag(ARRAY)) {
 809             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 810                 log.error(pos, Errors.GenericArrayCreation);
 811                 t = types.createErrorType(t);
 812             }
 813         }
</pre>
<hr />
<pre>
 821      */
 822     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 823         t = checkClassType(pos, t);
 824         if (noBounds &amp;&amp; t.isParameterized()) {
 825             List&lt;Type&gt; args = t.getTypeArguments();
 826             while (args.nonEmpty()) {
 827                 if (args.head.hasTag(WILDCARD))
 828                     return typeTagError(pos,
 829                                         diags.fragment(Fragments.TypeReqExact),
 830                                         args.head);
 831                 args = args.tail;
 832             }
 833         }
 834         return t;
 835     }
 836 
 837     /** Check that type is a reference type, i.e. a class, interface or array type
 838      *  or a type variable.
 839      *  @param pos           Position to be used for error reporting.
 840      *  @param t             The type to be checked.
<span class="line-added"> 841      *  @param valueOK       If false, a value class does not qualify</span>
 842      */
<span class="line-modified"> 843     Type checkRefType(DiagnosticPosition pos, Type t, boolean valueOK) {</span>
<span class="line-modified"> 844         if (t.isReference() &amp;&amp; (valueOK || !types.isValue(t)))</span>
 845             return t;
 846         else
 847             return typeTagError(pos,
 848                                 diags.fragment(Fragments.TypeReqRef),
 849                                 t);
 850     }
 851 
<span class="line-added"> 852     /** Check that type is a reference type, i.e. a class, interface or array type</span>
<span class="line-added"> 853      *  or a type variable.</span>
<span class="line-added"> 854      *  @param pos           Position to be used for error reporting.</span>
<span class="line-added"> 855      *  @param t             The type to be checked.</span>
<span class="line-added"> 856      */</span>
<span class="line-added"> 857     Type checkRefType(DiagnosticPosition pos, Type t) {</span>
<span class="line-added"> 858         return checkRefType(pos, t, true);</span>
<span class="line-added"> 859     }</span>
<span class="line-added"> 860 </span>
 861     /** Check that each type is a reference type, i.e. a class, interface or array type
 862      *  or a type variable.
 863      *  @param trees         Original trees, used for error reporting.
 864      *  @param types         The types to be checked.
 865      */
 866     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 867         List&lt;JCExpression&gt; tl = trees;
 868         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
<span class="line-modified"> 869             l.head = checkRefType(tl.head.pos(), l.head, false);</span>
 870             tl = tl.tail;
 871         }
 872         return types;
 873     }
 874 
 875     /** Check that type is a null or reference type.
 876      *  @param pos           Position to be used for error reporting.
 877      *  @param t             The type to be checked.
 878      */
 879     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 880         if (t.isReference() || t.hasTag(BOT))
 881             return t;
 882         else
 883             return typeTagError(pos,
 884                                 diags.fragment(Fragments.TypeReqRef),
 885                                 t);
 886     }
 887 
 888     /** Check that flag set does not contain elements of two conflicting sets. s
 889      *  Return true if it doesn&#39;t.
 890      *  @param pos           Position to be used for error reporting.
 891      *  @param flags         The set of flags to be checked.
 892      *  @param set1          Conflicting flags set #1.
 893      *  @param set2          Conflicting flags set #2.
 894      */
 895     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 896         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 897             log.error(pos,
 898                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 899                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 900             return false;
 901         } else
 902             return true;
 903     }
 904 
<span class="line-added"> 905     void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {</span>
<span class="line-added"> 906         valueParameterizationChecker.visit(t, pos);</span>
<span class="line-added"> 907     }</span>
<span class="line-added"> 908 </span>
<span class="line-added"> 909     /** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types</span>
<span class="line-added"> 910      *  being used as type arguments and issues error against those usages.</span>
<span class="line-added"> 911      */</span>
<span class="line-added"> 912     private final Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt; valueParameterizationChecker = new Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt;() {</span>
<span class="line-added"> 913 </span>
<span class="line-added"> 914         @Override</span>
<span class="line-added"> 915         public Void visitType(Type t, DiagnosticPosition pos) {</span>
<span class="line-added"> 916             return null;</span>
<span class="line-added"> 917         }</span>
<span class="line-added"> 918 </span>
<span class="line-added"> 919         @Override</span>
<span class="line-added"> 920         public Void visitClassType(ClassType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 921             for (Type targ : t.allparams()) {</span>
<span class="line-added"> 922                 if (types.isValue(targ)) {</span>
<span class="line-added"> 923                     log.error(pos, Errors.GenericParameterizationWithValueType(t));</span>
<span class="line-added"> 924                 }</span>
<span class="line-added"> 925                 visit(targ, pos);</span>
<span class="line-added"> 926             }</span>
<span class="line-added"> 927             return null;</span>
<span class="line-added"> 928         }</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930         @Override</span>
<span class="line-added"> 931         public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {</span>
<span class="line-added"> 932              return null;</span>
<span class="line-added"> 933         }</span>
<span class="line-added"> 934 </span>
<span class="line-added"> 935         @Override</span>
<span class="line-added"> 936         public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 937             return null;</span>
<span class="line-added"> 938         }</span>
<span class="line-added"> 939 </span>
<span class="line-added"> 940         @Override</span>
<span class="line-added"> 941         public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 942             return visit(t.elemtype, pos);</span>
<span class="line-added"> 943         }</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945         @Override</span>
<span class="line-added"> 946         public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 947             return visit(t.type, pos);</span>
<span class="line-added"> 948         }</span>
<span class="line-added"> 949     };</span>
<span class="line-added"> 950 </span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952 </span>
 953     /** Check that usage of diamond operator is correct (i.e. diamond should not
 954      * be used with non-generic classes or in anonymous class creation expressions)
 955      */
 956     Type checkDiamond(JCNewClass tree, Type t) {
 957         if (!TreeInfo.isDiamond(tree) ||
 958                 t.isErroneous()) {
 959             return checkClassType(tree.clazz.pos(), t, true);
 960         } else {
 961             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 962                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 963                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 964             }
 965             if (t.tsym.type.getTypeArguments().isEmpty()) {
 966                 log.error(tree.clazz.pos(),
 967                           Errors.CantApplyDiamond1(t,
 968                                                    Fragments.DiamondNonGeneric(t)));
 969                 return types.createErrorType(t);
 970             } else if (tree.typeargs != null &amp;&amp;
 971                     tree.typeargs.nonEmpty()) {
 972                 log.error(tree.clazz.pos(),
</pre>
<hr />
<pre>
1081     }
1082     //where
1083         private boolean isTrustMeAllowedOnMethod(Symbol s) {
1084             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
1085                 (s.isConstructor() ||
1086                     (s.flags() &amp; (STATIC | FINAL |
1087                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
1088         }
1089 
1090     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
1091         //check that resulting type is not the null type
1092         if (t.hasTag(BOT)) {
1093             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
1094             return types.createErrorType(t);
1095         } else if (t.hasTag(VOID)) {
1096             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
1097             return types.createErrorType(t);
1098         }
1099 
1100         //upward project the initializer type
<span class="line-modified">1101         Type varType = types.upward(t, types.captures(t));</span>
<span class="line-added">1102         if (varType.hasTag(CLASS)) {</span>
<span class="line-added">1103             checkParameterizationWithValues(pos, varType);</span>
<span class="line-added">1104         }</span>
<span class="line-added">1105         return varType;</span>
<span class="line-added">1106     }</span>
<span class="line-added">1107 </span>
<span class="line-added">1108     public void checkForSuspectClassLiteralComparison(</span>
<span class="line-added">1109             final JCBinary tree,</span>
<span class="line-added">1110             final Type leftType,</span>
<span class="line-added">1111             final Type rightType) {</span>
<span class="line-added">1112 </span>
<span class="line-added">1113         if (lint.isEnabled(LintCategory.MIGRATION)) {</span>
<span class="line-added">1114             if (isInvocationOfGetClass(tree.lhs) &amp;&amp; isClassOfSomeInterface(rightType) ||</span>
<span class="line-added">1115                     isInvocationOfGetClass(tree.rhs) &amp;&amp; isClassOfSomeInterface(leftType)) {</span>
<span class="line-added">1116                 log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);</span>
<span class="line-added">1117             }</span>
<span class="line-added">1118         }</span>
<span class="line-added">1119     }</span>
<span class="line-added">1120     //where</span>
<span class="line-added">1121     private boolean isClassOfSomeInterface(Type someClass) {</span>
<span class="line-added">1122         if (someClass.tsym.flatName() == names.java_lang_Class) {</span>
<span class="line-added">1123             List&lt;Type&gt; arguments = someClass.getTypeArguments();</span>
<span class="line-added">1124             if (arguments.length() == 1) {</span>
<span class="line-added">1125                 return arguments.head.isInterface();</span>
<span class="line-added">1126             }</span>
<span class="line-added">1127         }</span>
<span class="line-added">1128         return false;</span>
<span class="line-added">1129     }</span>
<span class="line-added">1130     //where</span>
<span class="line-added">1131     private boolean isInvocationOfGetClass(JCExpression tree) {</span>
<span class="line-added">1132         tree = TreeInfo.skipParens(tree);</span>
<span class="line-added">1133         if (tree.hasTag(APPLY)) {</span>
<span class="line-added">1134             JCMethodInvocation apply = (JCMethodInvocation)tree;</span>
<span class="line-added">1135             MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);</span>
<span class="line-added">1136             return msym.name == names.getClass &amp;&amp; msym.implementedIn(syms.objectType.tsym, types) != null;</span>
<span class="line-added">1137         }</span>
<span class="line-added">1138         return false;</span>
1139     }
1140 
1141     Type checkMethod(final Type mtype,
1142             final Symbol sym,
1143             final Env&lt;AttrContext&gt; env,
1144             final List&lt;JCExpression&gt; argtrees,
1145             final List&lt;Type&gt; argtypes,
1146             final boolean useVarargs,
1147             InferenceContext inferenceContext) {
1148         // System.out.println(&quot;call   : &quot; + env.tree);
1149         // System.out.println(&quot;method : &quot; + owntype);
1150         // System.out.println(&quot;actuals: &quot; + argtypes);
1151         if (inferenceContext.free(mtype)) {
1152             inferenceContext.addFreeTypeListener(List.of(mtype),
1153                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
1154             return mtype;
1155         }
1156         Type owntype = mtype;
1157         List&lt;Type&gt; formals = owntype.getParameterTypes();
1158         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
</pre>
<hr />
<pre>
1316      *  return modifiers together with any implicit modifiers for that symbol.
1317      *  Warning: we can&#39;t use flags() here since this method
1318      *  is called during class enter, when flags() would cause a premature
1319      *  completion.
1320      *  @param pos           Position to be used for error reporting.
1321      *  @param flags         The set of modifiers given in a definition.
1322      *  @param sym           The defined symbol.
1323      */
1324     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1325         long mask;
1326         long implicit = 0;
1327 
1328         switch (sym.kind) {
1329         case VAR:
1330             if (TreeInfo.isReceiverParam(tree))
1331                 mask = ReceiverParamFlags;
1332             else if (sym.owner.kind != TYP)
1333                 mask = LocalVarFlags;
1334             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1335                 mask = implicit = InterfaceVarFlags;
<span class="line-modified">1336             else {</span>
1337                 mask = VarFlags;
<span class="line-added">1338                 if (types.isValue(sym.owner.type) &amp;&amp; (flags &amp; STATIC) == 0) {</span>
<span class="line-added">1339                     implicit |= FINAL;</span>
<span class="line-added">1340                 }</span>
<span class="line-added">1341             }</span>
1342             break;
1343         case MTH:
1344             if (sym.name == names.init) {
1345                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1346                     // enum constructors cannot be declared public or
1347                     // protected and must be implicitly or explicitly
1348                     // private
1349                     implicit = PRIVATE;
1350                     mask = PRIVATE;
1351                 } else
1352                     mask = ConstructorFlags;
1353             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1354                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1355                     mask = AnnotationTypeElementMask;
1356                     implicit = PUBLIC | ABSTRACT;
1357                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1358                     mask = InterfaceMethodMask;
1359                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1360                     if ((flags &amp; DEFAULT) != 0) {
1361                         implicit |= ABSTRACT;
1362                     }
1363                 } else {
1364                     mask = implicit = InterfaceMethodFlags;
1365                 }
1366             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1367                 mask = RecordMethodFlags;
1368             } else {
<span class="line-modified">1369                 // instance methods of value types do not have a monitor associated with their `this&#39;</span>
<span class="line-added">1370                 mask = ((sym.owner.flags_field &amp; VALUE) != 0 &amp;&amp; (flags &amp; Flags.STATIC) == 0) ?</span>
<span class="line-added">1371                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;</span>
1372             }
1373             // Imply STRICTFP if owner has STRICTFP set.
1374             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1375                 ((flags) &amp; Flags.DEFAULT) != 0)
1376                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1377             break;
1378         case TYP:
1379             if (sym.isLocal()) {
1380                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1381                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1382                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1383                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1384                 implicit = implicitlyStatic ? STATIC : implicit;
1385                 if (staticOrImplicitlyStatic) {
1386                     if (sym.owner.kind == TYP) {
1387                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1388                     }
1389                 }
1390             } else if (sym.owner.kind == TYP) {
1391                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : ExtendedMemberClassFlags;
1392                 if (sym.owner.owner.kind == PCK ||
1393                     (sym.owner.flags_field &amp; STATIC) != 0)
1394                     mask |= STATIC;
1395                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1396                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1397                 }
1398                 // Nested interfaces and enums are always STATIC (Spec ???)
1399                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1400             } else {
1401                 mask = ExtendedClassFlags;
1402             }
1403             // Interfaces are always ABSTRACT
1404             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1405 
1406             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1407                 // enums can&#39;t be declared abstract, final, sealed or non-sealed or value type</span>
<span class="line-modified">1408                 mask &amp;= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | VALUE);</span>
1409                 implicit |= implicitEnumFinalFlag(tree);
1410             }
1411             if ((flags &amp; RECORD) != 0) {
1412                 // records can&#39;t be declared abstract
1413                 mask &amp;= ~ABSTRACT;
1414                 implicit |= FINAL;
1415             }
1416             // Imply STRICTFP if owner has STRICTFP set.
1417             implicit |= sym.owner.flags_field &amp; STRICTFP;
1418             break;
1419         default:
1420             throw new AssertionError();
1421         }
1422         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1423         if (illegal != 0) {
1424             if ((illegal &amp; INTERFACE) != 0) {
1425                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1426                 mask |= INTERFACE;
1427             }
1428             else {
1429                 log.error(pos,
1430                         Errors.ModNotAllowedHere(asFlagSet(illegal)));
1431             }
1432         }
1433         else if ((sym.kind == TYP ||
1434                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1435                   // in the presence of inner classes. Should it be deleted here?
1436                   checkDisjoint(pos, flags,
1437                                 ABSTRACT,
1438                                 PRIVATE | STATIC | DEFAULT))
1439                  &amp;&amp;
1440                  checkDisjoint(pos, flags,
1441                                 STATIC | PRIVATE,
1442                                 DEFAULT)
1443                  &amp;&amp;
1444                  checkDisjoint(pos, flags,
1445                                ABSTRACT | INTERFACE,
<span class="line-modified">1446                                FINAL | NATIVE | SYNCHRONIZED | VALUE)</span>
1447                  &amp;&amp;
1448                  checkDisjoint(pos, flags,
1449                                PUBLIC,
1450                                PRIVATE | PROTECTED)
1451                  &amp;&amp;
1452                  checkDisjoint(pos, flags,
1453                                PRIVATE,
1454                                PUBLIC | PROTECTED)
1455                  &amp;&amp;
<span class="line-modified">1456                  checkDisjoint(pos, (flags | implicit), // complain against volatile &amp; implcitly final entities too.</span>
1457                                FINAL,
1458                                VOLATILE)
1459                  &amp;&amp;
1460                  (sym.kind == TYP ||
1461                   checkDisjoint(pos, flags,
1462                                 ABSTRACT | NATIVE,
1463                                 STRICTFP))
1464                  &amp;&amp; checkDisjoint(pos, flags,
1465                                 FINAL,
1466                            SEALED | NON_SEALED)
1467                  &amp;&amp; checkDisjoint(pos, flags,
1468                                 SEALED,
1469                            FINAL | NON_SEALED)) {
1470             // skip
1471         }
1472         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1473     }
1474 
1475 
1476     /** Determine if this enum should be implicitly final.
</pre>
<hr />
<pre>
1610         @Override
1611         public void visitWildcard(JCWildcard tree) {
1612             if (tree.inner != null)
1613                 validateTree(tree.inner, true, isOuter);
1614         }
1615 
1616         @Override
1617         public void visitSelect(JCFieldAccess tree) {
1618             if (tree.type.hasTag(CLASS)) {
1619                 visitSelectInternal(tree);
1620 
1621                 // Check that this type is either fully parameterized, or
1622                 // not parameterized at all.
1623                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1624                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1625             }
1626         }
1627 
1628         public void visitSelectInternal(JCFieldAccess tree) {
1629             if (tree.type.tsym.isStatic() &amp;&amp;
<span class="line-modified">1630                 tree.selected.type.isParameterized() &amp;&amp;</span>
<span class="line-added">1631                     (tree.name != names.ref || !tree.type.isReferenceProjection())) {</span>
1632                 // The enclosing type is not a class, so we are
1633                 // looking at a static member type.  However, the
1634                 // qualifying expression is parameterized.
<span class="line-added">1635                 // Tolerate the pseudo-select V.ref: V&lt;T&gt;.ref will be static if V&lt;T&gt; is and</span>
<span class="line-added">1636                 // should not be confused as selecting a static member of a parameterized type.</span>
1637                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1638             } else {
1639                 // otherwise validate the rest of the expression
1640                 tree.selected.accept(this);
1641             }
1642         }
1643 
1644         @Override
1645         public void visitAnnotatedType(JCAnnotatedType tree) {
1646             tree.underlyingType.accept(this);
1647         }
1648 
1649         @Override
1650         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1651             if (that.type.hasTag(TypeTag.VOID)) {
1652                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1653             }
1654             super.visitTypeIdent(that);
1655         }
1656 
</pre>
<hr />
<pre>
1943             return;
1944         }
1945 
1946         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1947             // handled in validateAnnotationMethod
1948             return;
1949         }
1950 
1951         // Error if overriding method has weaker access (JLS 8.4.6.3).
1952         if (protection(m.flags()) &gt; protection(other.flags())) {
1953             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1954                       (other.flags() &amp; AccessFlags) == 0 ?
1955                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1956                                                           &quot;package&quot;) :
1957                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1958                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1959             m.flags_field |= BAD_OVERRIDE;
1960             return;
1961         }
1962 
<span class="line-added">1963         if (origin.isValue() &amp;&amp; other.owner == syms.objectType.tsym &amp;&amp; m.type.getParameterTypes().size() == 0) {</span>
<span class="line-added">1964             if (m.name == names.clone || m.name == names.finalize) {</span>
<span class="line-added">1965                 log.error(TreeInfo.diagnosticPositionFor(m, tree),</span>
<span class="line-added">1966                         Errors.InlineClassMayNotOverride(m.name));</span>
<span class="line-added">1967                 m.flags_field |= BAD_OVERRIDE;</span>
<span class="line-added">1968                 return;</span>
<span class="line-added">1969             }</span>
<span class="line-added">1970         }</span>
<span class="line-added">1971 </span>
1972         Type mt = types.memberType(origin.type, m);
1973         Type ot = types.memberType(origin.type, other);
1974         // Error if overriding result type is different
1975         // (or, in the case of generics mode, not a subtype) of
1976         // overridden result type. We have to rename any type parameters
1977         // before comparing types.
1978         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1979         List&lt;Type&gt; otvars = ot.getTypeArguments();
1980         Type mtres = mt.getReturnType();
1981         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1982 
1983         overrideWarner.clear();
1984         boolean resultTypesOK =
1985             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1986         if (!resultTypesOK) {
1987             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1988                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1989                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1990                                         other.location()), mtres, otres));
1991                 m.flags_field |= BAD_OVERRIDE;
</pre>
<hr />
<pre>
2264             if (recordComponent.isPresent()) {
2265                 return;
2266             }
2267         }
2268 
2269         for (Type t = origin.type; t.hasTag(CLASS);
2270              t = types.supertype(t)) {
2271             if (t != origin.type) {
2272                 checkOverride(tree, t, origin, m);
2273             }
2274             for (Type t2 : types.interfaces(t)) {
2275                 checkOverride(tree, t2, origin, m);
2276             }
2277         }
2278 
2279         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2280         // Check if this method must override a super method due to being annotated with @Override
2281         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2282         // be treated &quot;as if as they were annotated&quot; with @Override.
2283         boolean mustOverride = explicitOverride ||
<span class="line-modified">2284                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate() &amp;&amp;</span>
<span class="line-added">2285                         (!m.owner.isValue() || (tree.body.flags &amp; SYNTHETIC) == 0));</span>
2286         if (mustOverride &amp;&amp; !isOverrider(m)) {
2287             DiagnosticPosition pos = tree.pos();
2288             for (JCAnnotation a : tree.getModifiers().annotations) {
2289                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2290                     pos = a.pos();
2291                     break;
2292                 }
2293             }
2294             log.error(pos,
2295                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2296                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2297         }
2298     }
2299 
2300     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2301         TypeSymbol c = site.tsym;
2302         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2303             if (m.overrides(sym, origin, types, false)) {
2304                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2305                     checkOverride(tree, m, (MethodSymbol)sym, origin);
</pre>
<hr />
<pre>
2391                 cf.accepts(s2) &amp;&amp;
2392                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2393     }
2394 
2395 
2396     /** Check that all abstract members of given class have definitions.
2397      *  @param pos          Position to be used for error reporting.
2398      *  @param c            The class.
2399      */
2400     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2401         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2402         if (undef != null) {
2403             MethodSymbol undef1 =
2404                 new MethodSymbol(undef.flags(), undef.name,
2405                                  types.memberType(c.type, undef), undef.owner);
2406             log.error(pos,
2407                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2408         }
2409     }
2410 
<span class="line-added">2411     // A value class cannot contain a field of its own type either or indirectly.</span>
<span class="line-added">2412     void checkNonCyclicMembership(JCClassDecl tree) {</span>
<span class="line-added">2413         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);</span>
<span class="line-added">2414         try {</span>
<span class="line-added">2415             tree.sym.flags_field |= LOCKED;</span>
<span class="line-added">2416             for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {</span>
<span class="line-added">2417                 if (l.head.hasTag(VARDEF)) {</span>
<span class="line-added">2418                     JCVariableDecl field = (JCVariableDecl) l.head;</span>
<span class="line-added">2419                     if (cyclePossible(field.sym)) {</span>
<span class="line-added">2420                         Type fieldType = field.sym.type;</span>
<span class="line-added">2421                         checkNonCyclicMembership((ClassSymbol) fieldType.tsym, field.pos());</span>
<span class="line-added">2422                     }</span>
<span class="line-added">2423                 }</span>
<span class="line-added">2424             }</span>
<span class="line-added">2425         } finally {</span>
<span class="line-added">2426             tree.sym.flags_field &amp;= ~LOCKED;</span>
<span class="line-added">2427         }</span>
<span class="line-added">2428 </span>
<span class="line-added">2429     }</span>
<span class="line-added">2430     // where</span>
<span class="line-added">2431     private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {</span>
<span class="line-added">2432         if ((c.flags_field &amp; LOCKED) != 0) {</span>
<span class="line-added">2433             log.error(pos, Errors.CyclicValueTypeMembership(c));</span>
<span class="line-added">2434             return;</span>
<span class="line-added">2435         }</span>
<span class="line-added">2436         try {</span>
<span class="line-added">2437             c.flags_field |= LOCKED;</span>
<span class="line-added">2438             for (Symbol fld : c.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; cyclePossible((VarSymbol) s), NON_RECURSIVE)) {</span>
<span class="line-added">2439                 checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);</span>
<span class="line-added">2440             }</span>
<span class="line-added">2441         } finally {</span>
<span class="line-added">2442             c.flags_field &amp;= ~LOCKED;</span>
<span class="line-added">2443         }</span>
<span class="line-added">2444     }</span>
<span class="line-added">2445         // where</span>
<span class="line-added">2446         private boolean cyclePossible(VarSymbol symbol) {</span>
<span class="line-added">2447             return (symbol.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(symbol.type);</span>
<span class="line-added">2448         }</span>
<span class="line-added">2449 </span>
2450     void checkNonCyclicDecl(JCClassDecl tree) {
2451         CycleChecker cc = new CycleChecker();
2452         cc.scan(tree);
2453         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2454             tree.sym.flags_field |= ACYCLIC;
2455         }
2456     }
2457 
2458     class CycleChecker extends TreeScanner {
2459 
2460         List&lt;Symbol&gt; seenClasses = List.nil();
2461         boolean errorFound = false;
2462         boolean partialCheck = false;
2463 
2464         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2465             if (sym != null &amp;&amp; sym.kind == TYP) {
2466                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2467                 if (classEnv != null) {
2468                     DiagnosticSource prevSource = log.currentSource();
2469                     try {
</pre>
<hr />
<pre>
2678     /** Check that all abstract methods implemented by a class are
2679      *  mutually compatible.
2680      *  @param pos          Position to be used for error reporting.
2681      *  @param c            The class whose interfaces are checked.
2682      */
2683     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2684         List&lt;Type&gt; supertypes = types.interfaces(c);
2685         Type supertype = types.supertype(c);
2686         if (supertype.hasTag(CLASS) &amp;&amp;
2687             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2688             supertypes = supertypes.prepend(supertype);
2689         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2690             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2691                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2692                 return;
2693             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2694                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2695                     return;
2696         }
2697         checkCompatibleConcretes(pos, c);
<span class="line-added">2698 </span>
<span class="line-added">2699         if (c.isValue() &amp;&amp; types.asSuper(c, syms.identityObjectType.tsym, true) != null) {</span>
<span class="line-added">2700             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));</span>
<span class="line-added">2701         }</span>
2702     }
2703 
2704     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2705      *  are mutually compatible (JLS 8.4.8/9.4.1).
2706      *
2707      *  @param pos  Position to be used for error reporting.
2708      *  @param site The class whose methods are checked.
2709      *  @param sym  The method symbol to be checked.
2710      */
2711     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2712          ClashFilter cf = new ClashFilter(site);
2713         //for each method m1 that is overridden (directly or indirectly)
2714         //by method &#39;sym&#39; in &#39;site&#39;...
2715 
2716         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2717         boolean overridesAny = false;
2718         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2719         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2720         for (Symbol m1 : symbolsByName) {
2721             if (!sym.overrides(m1, site.tsym, types, false)) {
</pre>
<hr />
<pre>
3241                                 }
3242                             }
3243                             modifiers.annotations = newAnnotations.toList();
3244                         }
3245                         // now lets remove it from the symbol
3246                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3247                     } else {
3248                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3249                     }
3250                 }
3251             }
3252         }
3253 
3254         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3255             if (s.kind != TYP) {
3256                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3257             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3258                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3259             }
3260         }
<span class="line-added">3261         if (a.annotationType.type.tsym == syms.valueBasedType.tsym) {</span>
<span class="line-added">3262             if (s.isInterface() || s.isEnum()) {</span>
<span class="line-added">3263                 log.error(a.pos(), Errors.BadValueBasedAnno);</span>
<span class="line-added">3264             } else if (allowValueBasedClasses) {</span>
<span class="line-added">3265                 s.flags_field |= VALUEBASED;</span>
<span class="line-added">3266             }</span>
<span class="line-added">3267         }</span>
3268     }
3269 
3270     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3271         Assert.checkNonNull(a.type);
3272         validateAnnotationTree(a);
3273 
3274         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3275                 !a.annotationType.type.isErroneous() &amp;&amp;
3276                 !isTypeAnnotation(a, isTypeParameter)) {
3277             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3278         }
3279     }
3280 
3281     /**
3282      * Validate the proposed container &#39;repeatable&#39; on the
3283      * annotation type symbol &#39;s&#39;. Report errors at position
3284      * &#39;pos&#39;.
3285      *
3286      * @param s The (annotation)type declaration annotated with a @Repeatable
3287      * @param repeatable the @Repeatable on &#39;s&#39;
</pre>
</td>
</tr>
</table>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
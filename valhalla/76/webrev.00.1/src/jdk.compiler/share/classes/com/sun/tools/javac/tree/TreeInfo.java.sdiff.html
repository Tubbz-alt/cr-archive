<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Pretty.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeMaker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  92         return isCanonicalConstructor(tree) &amp;&amp; (((JCMethodDecl)tree).sym.flags_field &amp; COMPACT_RECORD_CONSTRUCTOR) != 0;
  93     }
  94 
  95     public static boolean isReceiverParam(JCTree tree) {
  96         if (tree.hasTag(VARDEF)) {
  97             return ((JCVariableDecl)tree).nameexpr != null;
  98         } else {
  99             return false;
 100         }
 101     }
 102 
 103     /** Is there a constructor declaration in the given list of trees?
 104      */
 105     public static boolean hasConstructors(List&lt;JCTree&gt; trees) {
 106         for (List&lt;JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 107             if (isConstructor(l.head)) return true;
 108         return false;
 109     }
 110 
 111     /** Is there a constructor invocation in the given list of trees?

 112      */
<span class="line-modified"> 113     public static Name getConstructorInvocationName(List&lt;? extends JCTree&gt; trees, Names names) {</span>
 114         for (JCTree tree : trees) {
 115             if (tree.hasTag(EXEC)) {
 116                 JCExpressionStatement stat = (JCExpressionStatement)tree;
 117                 if (stat.expr.hasTag(APPLY)) {
 118                     JCMethodInvocation apply = (JCMethodInvocation)stat.expr;
<span class="line-modified"> 119                     Name methName = TreeInfo.name(apply.meth);</span>
<span class="line-modified"> 120                     if (methName == names._this ||</span>
<span class="line-modified"> 121                         methName == names._super) {</span>
<span class="line-modified"> 122                         return methName;</span>


 123                     }
 124                 }
 125             }
 126         }
 127         return names.empty;
 128     }
 129 
 130     public static boolean isMultiCatch(JCCatch catchClause) {
 131         return catchClause.param.vartype.hasTag(TYPEUNION);
 132     }
 133 
 134     /** Is statement an initializer for a synthetic field?
 135      */
 136     public static boolean isSyntheticInit(JCTree stat) {
 137         if (stat.hasTag(EXEC)) {
 138             JCExpressionStatement exec = (JCExpressionStatement)stat;
 139             if (exec.expr.hasTag(ASSIGN)) {
 140                 JCAssign assign = (JCAssign)exec.expr;
 141                 if (assign.lhs.hasTag(SELECT)) {
 142                     JCFieldAccess select = (JCFieldAccess)assign.lhs;
</pre>
<hr />
<pre>
 605             case SYNCHRONIZED:
 606                 return getEndPos(((JCSynchronized) tree).body, endPosTable);
 607             case TOPLEVEL:
 608                 return getEndPos(((JCCompilationUnit) tree).defs.last(), endPosTable);
 609             case TRY: {
 610                 JCTry node = (JCTry)tree;
 611                 if (node.finalizer != null) {
 612                     return getEndPos(node.finalizer, endPosTable);
 613                 } else if (!node.catchers.isEmpty()) {
 614                     return getEndPos(node.catchers.last(), endPosTable);
 615                 } else {
 616                     return getEndPos(node.body, endPosTable);
 617                 }
 618             }
 619             case WILDCARD:
 620                 return getEndPos(((JCWildcard) tree).inner, endPosTable);
 621             case TYPECAST:
 622                 return getEndPos(((JCTypeCast) tree).expr, endPosTable);
 623             case TYPETEST:
 624                 return getEndPos(((JCInstanceOf) tree).pattern, endPosTable);


 625             case WHILELOOP:
 626                 return getEndPos(((JCWhileLoop) tree).body, endPosTable);
 627             case ANNOTATED_TYPE:
 628                 return getEndPos(((JCAnnotatedType) tree).underlyingType, endPosTable);
 629             case ERRONEOUS: {
 630                 JCErroneous node = (JCErroneous)tree;
 631                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 632                     return getEndPos(node.errs.last(), endPosTable);
 633             }
 634         }
 635         return Position.NOPOS;
 636     }
 637 
 638 
 639     /** A DiagnosticPosition with the preferred position set to the
 640      *  end position of given tree, if it is a block with
 641      *  defined endpos.
 642      */
 643     public static DiagnosticPosition diagEndPos(final JCTree tree) {
 644         final int endPos = TreeInfo.endPos(tree);
</pre>
</td>
<td>
<hr />
<pre>
  92         return isCanonicalConstructor(tree) &amp;&amp; (((JCMethodDecl)tree).sym.flags_field &amp; COMPACT_RECORD_CONSTRUCTOR) != 0;
  93     }
  94 
  95     public static boolean isReceiverParam(JCTree tree) {
  96         if (tree.hasTag(VARDEF)) {
  97             return ((JCVariableDecl)tree).nameexpr != null;
  98         } else {
  99             return false;
 100         }
 101     }
 102 
 103     /** Is there a constructor declaration in the given list of trees?
 104      */
 105     public static boolean hasConstructors(List&lt;JCTree&gt; trees) {
 106         for (List&lt;JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 107             if (isConstructor(l.head)) return true;
 108         return false;
 109     }
 110 
 111     /** Is there a constructor invocation in the given list of trees?
<span class="line-added"> 112      *  Optionally, check only for no-arg ctor invocation</span>
 113      */
<span class="line-modified"> 114     public static Name getConstructorInvocationName(List&lt;? extends JCTree&gt; trees, Names names, boolean argsAllowed) {</span>
 115         for (JCTree tree : trees) {
 116             if (tree.hasTag(EXEC)) {
 117                 JCExpressionStatement stat = (JCExpressionStatement)tree;
 118                 if (stat.expr.hasTag(APPLY)) {
 119                     JCMethodInvocation apply = (JCMethodInvocation)stat.expr;
<span class="line-modified"> 120                     if (argsAllowed || apply.args.size() == 0) {</span>
<span class="line-modified"> 121                         Name methName = TreeInfo.name(apply.meth);</span>
<span class="line-modified"> 122                         if (methName == names._this ||</span>
<span class="line-modified"> 123                                 methName == names._super) {</span>
<span class="line-added"> 124                             return methName;</span>
<span class="line-added"> 125                         }</span>
 126                     }
 127                 }
 128             }
 129         }
 130         return names.empty;
 131     }
 132 
 133     public static boolean isMultiCatch(JCCatch catchClause) {
 134         return catchClause.param.vartype.hasTag(TYPEUNION);
 135     }
 136 
 137     /** Is statement an initializer for a synthetic field?
 138      */
 139     public static boolean isSyntheticInit(JCTree stat) {
 140         if (stat.hasTag(EXEC)) {
 141             JCExpressionStatement exec = (JCExpressionStatement)stat;
 142             if (exec.expr.hasTag(ASSIGN)) {
 143                 JCAssign assign = (JCAssign)exec.expr;
 144                 if (assign.lhs.hasTag(SELECT)) {
 145                     JCFieldAccess select = (JCFieldAccess)assign.lhs;
</pre>
<hr />
<pre>
 608             case SYNCHRONIZED:
 609                 return getEndPos(((JCSynchronized) tree).body, endPosTable);
 610             case TOPLEVEL:
 611                 return getEndPos(((JCCompilationUnit) tree).defs.last(), endPosTable);
 612             case TRY: {
 613                 JCTry node = (JCTry)tree;
 614                 if (node.finalizer != null) {
 615                     return getEndPos(node.finalizer, endPosTable);
 616                 } else if (!node.catchers.isEmpty()) {
 617                     return getEndPos(node.catchers.last(), endPosTable);
 618                 } else {
 619                     return getEndPos(node.body, endPosTable);
 620                 }
 621             }
 622             case WILDCARD:
 623                 return getEndPos(((JCWildcard) tree).inner, endPosTable);
 624             case TYPECAST:
 625                 return getEndPos(((JCTypeCast) tree).expr, endPosTable);
 626             case TYPETEST:
 627                 return getEndPos(((JCInstanceOf) tree).pattern, endPosTable);
<span class="line-added"> 628             case WITHFIELD:</span>
<span class="line-added"> 629                 return getEndPos(((JCWithField) tree).value, endPosTable);</span>
 630             case WHILELOOP:
 631                 return getEndPos(((JCWhileLoop) tree).body, endPosTable);
 632             case ANNOTATED_TYPE:
 633                 return getEndPos(((JCAnnotatedType) tree).underlyingType, endPosTable);
 634             case ERRONEOUS: {
 635                 JCErroneous node = (JCErroneous)tree;
 636                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 637                     return getEndPos(node.errs.last(), endPosTable);
 638             }
 639         }
 640         return Position.NOPOS;
 641     }
 642 
 643 
 644     /** A DiagnosticPosition with the preferred position set to the
 645      *  end position of given tree, if it is a block with
 646      *  defined endpos.
 647      */
 648     public static DiagnosticPosition diagEndPos(final JCTree tree) {
 649         final int endPos = TreeInfo.endPos(tree);
</pre>
</td>
</tr>
</table>
<center><a href="Pretty.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeMaker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
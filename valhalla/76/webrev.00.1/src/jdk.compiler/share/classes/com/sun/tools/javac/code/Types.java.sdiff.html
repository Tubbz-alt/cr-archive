<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;

  53 import com.sun.tools.javac.util.*;
  54 
  55 import static com.sun.tools.javac.code.BoundKind.*;
  56 import static com.sun.tools.javac.code.Flags.*;
  57 import static com.sun.tools.javac.code.Kinds.Kind.*;
  58 import static com.sun.tools.javac.code.Scope.*;
  59 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  60 import static com.sun.tools.javac.code.Symbol.*;
  61 import static com.sun.tools.javac.code.Type.*;
  62 import static com.sun.tools.javac.code.TypeTag.*;
  63 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  64 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  65 
  66 /**
  67  * Utility class containing various operations on types.
  68  *
  69  * &lt;p&gt;Unless other names are more illustrative, the following naming
  70  * conventions should be observed in this file:
  71  *
  72  * &lt;dl&gt;
</pre>
<hr />
<pre>
  76  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  77  * &lt;dt&gt;ts&lt;/dt&gt;
  78  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  79  * &lt;dt&gt;ss&lt;/dt&gt;
  80  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  81  * &lt;/dl&gt;
  82  *
  83  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  84  * If you write code that depends on this, you do so at your own risk.
  85  * This code and its internal interfaces are subject to change or
  86  * deletion without notice.&lt;/b&gt;
  87  */
  88 public class Types {
  89     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  90 
  91     final Symtab syms;
  92     final JavacMessages messages;
  93     final Names names;
  94     final boolean allowDefaultMethods;
  95     final boolean mapCapturesToBounds;

  96     final Check chk;
  97     final Enter enter;
  98     JCDiagnostic.Factory diags;
  99     List&lt;Warner&gt; warnStack = List.nil();
 100     final Name capturedName;
 101 
 102     public final Warner noWarnings;
 103 
 104     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 105     public static Types instance(Context context) {
 106         Types instance = context.get(typesKey);
 107         if (instance == null)
 108             instance = new Types(context);
 109         return instance;
 110     }
 111 
 112     protected Types(Context context) {
 113         context.put(typesKey, this);
 114         syms = Symtab.instance(context);
 115         names = Names.instance(context);
 116         Source source = Source.instance(context);
 117         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 118         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 119         chk = Check.instance(context);
 120         enter = Enter.instance(context);
 121         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 122         messages = JavacMessages.instance(context);
 123         diags = JCDiagnostic.Factory.instance(context);
 124         noWarnings = new Warner(null);


 125     }
 126     // &lt;/editor-fold&gt;
 127 
 128     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 129     /**
 130      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 131      * @param t a type argument, either a wildcard or a type
 132      */
 133     public Type wildUpperBound(Type t) {
 134         if (t.hasTag(WILDCARD)) {
 135             WildcardType w = (WildcardType) t;
 136             if (w.isSuperBound())
 137                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 138             else
 139                 return wildUpperBound(w.type);
 140         }
 141         else return t;
 142     }
 143 
 144     /**
</pre>
<hr />
<pre>
 584                 }
 585                 return res;
 586             }
 587 
 588             @Override
 589             public Type visitErrorType(ErrorType t, Symbol sym) {
 590                 return t;
 591             }
 592         };
 593     // &lt;/editor-fold&gt;
 594 
 595     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 596     /**
 597      * Is t a subtype of or convertible via boxing/unboxing
 598      * conversion to s?
 599      */
 600     public boolean isConvertible(Type t, Type s, Warner warn) {
 601         if (t.hasTag(ERROR)) {
 602             return true;
 603         }









 604         boolean tPrimitive = t.isPrimitive();
 605         boolean sPrimitive = s.isPrimitive();
 606         if (tPrimitive == sPrimitive) {
 607             return isSubtypeUnchecked(t, s, warn);
 608         }
 609         boolean tUndet = t.hasTag(UNDETVAR);
 610         boolean sUndet = s.hasTag(UNDETVAR);
 611 
 612         if (tUndet || sUndet) {
 613             return tUndet ?
 614                     isSubtype(t, boxedTypeOrType(s)) :
 615                     isSubtype(boxedTypeOrType(t), s);
 616         }
 617 
 618         return tPrimitive
 619             ? isSubtype(boxedClass(t).type, s)
 620             : isSubtype(unboxedType(t), s);
 621     }
 622 
 623     /**
</pre>
<hr />
<pre>
 977     * Scope filter used to skip methods that should be ignored (such as methods
 978     * overridden by j.l.Object) during function interface conversion interface check
 979     */
 980     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 981 
 982        TypeSymbol origin;
 983 
 984        DescriptorFilter(TypeSymbol origin) {
 985            this.origin = origin;
 986        }
 987 
 988        @Override
 989        public boolean accepts(Symbol sym) {
 990            return sym.kind == MTH &amp;&amp;
 991                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
 992                    !overridesObjectMethod(origin, sym) &amp;&amp;
 993                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
 994        }
 995     }
 996 








 997     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
 998     /**
 999      * Is t an unchecked subtype of s?
1000      */
1001     public boolean isSubtypeUnchecked(Type t, Type s) {
1002         return isSubtypeUnchecked(t, s, noWarnings);
1003     }
1004     /**
1005      * Is t an unchecked subtype of s?
1006      */
1007     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1008         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1009         if (result) {
1010             checkUnsafeVarargsConversion(t, s, warn);
1011         }
1012         return result;
1013     }
1014     //where
1015         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1016             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1017                 if (((ArrayType)t).elemtype.isPrimitive()) {
1018                     return isSameType(elemtype(t), elemtype(s));
1019                 } else {
<span class="line-modified">1020                     return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);</span>










1021                 }
1022             } else if (isSubtype(t, s, capture)) {
1023                 return true;
1024             } else if (t.hasTag(TYPEVAR)) {
1025                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1026             } else if (!s.isRaw()) {
1027                 Type t2 = asSuper(t, s.tsym);
1028                 if (t2 != null &amp;&amp; t2.isRaw()) {
1029                     if (isReifiable(s)) {
1030                         warn.silentWarn(LintCategory.UNCHECKED);
1031                     } else {
1032                         warn.warn(LintCategory.UNCHECKED);
1033                     }
1034                     return true;
1035                 }
1036             }
1037             return false;
1038         }
1039 
1040         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
</pre>
<hr />
<pre>
1097     }
1098     // where
1099         private TypeRelation isSubtype = new TypeRelation()
1100         {
1101             @Override
1102             public Boolean visitType(Type t, Type s) {
1103                 switch (t.getTag()) {
1104                  case BYTE:
1105                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1106                  case CHAR:
1107                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1108                  case SHORT: case INT: case LONG:
1109                  case FLOAT: case DOUBLE:
1110                      return t.getTag().isSubRangeOf(s.getTag());
1111                  case BOOLEAN: case VOID:
1112                      return t.hasTag(s.getTag());
1113                  case TYPEVAR:
1114                      return isSubtypeNoCapture(t.getUpperBound(), s);
1115                  case BOT:
1116                      return
<span class="line-modified">1117                          s.hasTag(BOT) || s.hasTag(CLASS) ||</span>
1118                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1119                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1120                  case NONE:
1121                      return false;
1122                  default:
1123                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1124                  }
1125             }
1126 
1127             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1128 
1129             private boolean containsTypeRecursive(Type t, Type s) {
1130                 TypePair pair = new TypePair(t, s);
1131                 if (cache.add(pair)) {
1132                     try {
1133                         return containsType(t.getTypeArguments(),
1134                                             s.getTypeArguments());
1135                     } finally {
1136                         cache.remove(pair);
1137                     }
</pre>
<hr />
<pre>
1175             }
1176 
1177             @Override
1178             public Boolean visitClassType(ClassType t, Type s) {
1179                 Type sup = asSuper(t, s.tsym);
1180                 if (sup == null) return false;
1181                 // If t is an intersection, sup might not be a class type
1182                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1183                 return sup.tsym == s.tsym
1184                      // Check type variable containment
1185                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1186                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1187                                           s.getEnclosingType());
1188             }
1189 
1190             @Override
1191             public Boolean visitArrayType(ArrayType t, Type s) {
1192                 if (s.hasTag(ARRAY)) {
1193                     if (t.elemtype.isPrimitive())
1194                         return isSameType(t.elemtype, elemtype(s));
<span class="line-modified">1195                     else</span>
<span class="line-modified">1196                         return isSubtypeNoCapture(t.elemtype, elemtype(s));</span>









1197                 }
1198 
1199                 if (s.hasTag(CLASS)) {
1200                     Name sname = s.tsym.getQualifiedName();
1201                     return sname == names.java_lang_Object
1202                         || sname == names.java_lang_Cloneable
<span class="line-modified">1203                         || sname == names.java_io_Serializable;</span>

1204                 }
1205 
1206                 return false;
1207             }
1208 
1209             @Override
1210             public Boolean visitUndetVar(UndetVar t, Type s) {
1211                 //todo: test against origin needed? or replace with substitution?
1212                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1213                     return true;
1214                 } else if (s.hasTag(BOT)) {
1215                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1216                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1217                     return false;
1218                 }
1219 
1220                 t.addBound(InferenceBound.UPPER, s, Types.this);
1221                 return true;
1222             }
1223 
</pre>
<hr />
<pre>
1561 //            void debugContainsType(WildcardType t, Type s) {
1562 //                System.err.println();
1563 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1564 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1565 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1566 //                                  t.isSuperBound()
1567 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1568 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1569 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1570 //                                  t.isExtendsBound()
1571 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1572 //                System.err.println();
1573 //            }
1574 
1575             @Override
1576             public Boolean visitWildcardType(WildcardType t, Type s) {
1577                 if (s.isPartial())
1578                     return containedBy(s, t);
1579                 else {
1580 //                    debugContainsType(t, s);









1581                     return isSameWildcard(t, s)
1582                         || isCaptureOf(s, t)
1583                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1584                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1585                 }
1586             }
1587 
1588             @Override
1589             public Boolean visitUndetVar(UndetVar t, Type s) {
1590                 if (!s.hasTag(WILDCARD)) {
1591                     return isSameType(t, s);
1592                 } else {
1593                     return false;
1594                 }
1595             }
1596 
1597             @Override
1598             public Boolean visitErrorType(ErrorType t, Type s) {
1599                 return true;
1600             }
</pre>
<hr />
<pre>
1666                 case DOUBLE:
1667                     return s.isNumeric();
1668                 case BOOLEAN:
1669                     return s.hasTag(BOOLEAN);
1670                 case VOID:
1671                     return false;
1672                 case BOT:
1673                     return isSubtype(t, s);
1674                 default:
1675                     throw new AssertionError();
1676                 }
1677             }
1678 
1679             @Override
1680             public Boolean visitWildcardType(WildcardType t, Type s) {
1681                 return isCastable(wildUpperBound(t), s, warnStack.head);
1682             }
1683 
1684             @Override
1685             public Boolean visitClassType(ClassType t, Type s) {
<span class="line-modified">1686                 if (s.hasTag(ERROR) || s.hasTag(BOT))</span>
1687                     return true;
1688 
1689                 if (s.hasTag(TYPEVAR)) {
1690                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1691                         warnStack.head.warn(LintCategory.UNCHECKED);
1692                         return true;
1693                     } else {
1694                         return false;
1695                     }
1696                 }
1697 
1698                 if (t.isCompound() || s.isCompound()) {
1699                     return !t.isCompound() ?
1700                             visitCompoundType((ClassType)s, t, true) :
1701                             visitCompoundType(t, s, false);
1702                 }
1703 
1704                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {








1705                     boolean upcast;
1706                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1707                         || isSubtype(erasure(s), erasure(t))) {
1708                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1709                             if (!isReifiable(s))
1710                                 warnStack.head.warn(LintCategory.UNCHECKED);
1711                             return true;
1712                         } else if (s.isRaw()) {
1713                             return true;
1714                         } else if (t.isRaw()) {
1715                             if (!isUnbounded(s))
1716                                 warnStack.head.warn(LintCategory.UNCHECKED);
1717                             return true;
1718                         }
1719                         // Assume |a| &lt;: |b|
1720                         final Type a = upcast ? t : s;
1721                         final Type b = upcast ? s : t;
1722                         final boolean HIGH = true;
1723                         final boolean LOW = false;
1724                         final boolean DONT_REWRITE_TYPEVARS = false;
</pre>
<hr />
<pre>
1790 
1791             @Override
1792             public Boolean visitArrayType(ArrayType t, Type s) {
1793                 switch (s.getTag()) {
1794                 case ERROR:
1795                 case BOT:
1796                     return true;
1797                 case TYPEVAR:
1798                     if (isCastable(s, t, noWarnings)) {
1799                         warnStack.head.warn(LintCategory.UNCHECKED);
1800                         return true;
1801                     } else {
1802                         return false;
1803                     }
1804                 case CLASS:
1805                     return isSubtype(t, s);
1806                 case ARRAY:
1807                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1808                         return elemtype(t).hasTag(elemtype(s).getTag());
1809                     } else {
<span class="line-modified">1810                         return visit(elemtype(t), elemtype(s));</span>




1811                     }
1812                 default:
1813                     return false;
1814                 }
1815             }
1816 
1817             @Override
1818             public Boolean visitTypeVar(TypeVar t, Type s) {
1819                 switch (s.getTag()) {
1820                 case ERROR:
1821                 case BOT:
1822                     return true;
1823                 case TYPEVAR:
1824                     if (isSubtype(t, s)) {
1825                         return true;
1826                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1827                         warnStack.head.warn(LintCategory.UNCHECKED);
1828                         return true;
1829                     } else {
1830                         return false;
</pre>
<hr />
<pre>
2082             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2083         }
2084         return new ArrayType(t, syms.arrayClass);
2085     }
2086     // &lt;/editor-fold&gt;
2087 
2088     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2089     /**
2090      * Return the (most specific) base type of t that starts with the
2091      * given symbol.  If none exists, return null.
2092      *
2093      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2094      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2095      * this method could yield surprising answers when invoked on arrays. For example when
2096      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2097      *
2098      * @param t a type
2099      * @param sym a symbol
2100      */
2101     public Type asSuper(Type t, Symbol sym) {

















2102         /* Some examples:
2103          *
2104          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2105          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2106          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2107          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2108          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2109          */








2110         if (sym.type == syms.objectType) { //optimization
<span class="line-modified">2111             return syms.objectType;</span>











2112         }
2113         return asSuper.visit(t, sym);
2114     }
2115     // where
2116         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2117 
2118             public Type visitType(Type t, Symbol sym) {
2119                 return null;
2120             }
2121 
2122             @Override
2123             public Type visitClassType(ClassType t, Symbol sym) {
2124                 if (t.tsym == sym)
2125                     return t;
2126 




2127                 Type st = supertype(t);
2128                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2129                     Type x = asSuper(st, sym);
2130                     if (x != null)
2131                         return x;
2132                 }
2133                 if ((sym.flags() &amp; INTERFACE) != 0) {
2134                     for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2135                         if (!l.head.hasTag(ERROR)) {
2136                             Type x = asSuper(l.head, sym);
2137                             if (x != null)
2138                                 return x;
2139                         }
2140                     }
2141                 }
2142                 return null;
2143             }
2144 
2145             @Override
2146             public Type visitArrayType(ArrayType t, Symbol sym) {
</pre>
<hr />
<pre>
2210         case ARRAY:
2211             return isSubtype(t, sym.type) ? sym.type : null;
2212         case TYPEVAR:
2213             return asSuper(t, sym);
2214         case ERROR:
2215             return t;
2216         default:
2217             return null;
2218         }
2219     }
2220     // &lt;/editor-fold&gt;
2221 
2222     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2223     /**
2224      * The type of given symbol, seen as a member of t.
2225      *
2226      * @param t a type
2227      * @param sym a symbol
2228      */
2229     public Type memberType(Type t, Symbol sym) {
<span class="line-modified">2230         return (sym.flags() &amp; STATIC) != 0</span>
<span class="line-modified">2231             ? sym.type</span>
<span class="line-modified">2232             : memberType.visit(t, sym);</span>












2233         }
2234     // where
2235         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2236 
2237             public Type visitType(Type t, Symbol sym) {
2238                 return sym.type;
2239             }
2240 
2241             @Override
2242             public Type visitWildcardType(WildcardType t, Symbol sym) {
2243                 return memberType(wildUpperBound(t), sym);
2244             }
2245 
2246             @Override
2247             public Type visitClassType(ClassType t, Symbol sym) {
2248                 Symbol owner = sym.owner;
2249                 long flags = sym.flags();
2250                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2251                     Type base = asOuterSuper(t, owner);
2252                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
</pre>
<hr />
<pre>
2422      */
2423     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2424         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2425     }
2426 
2427     /**
2428      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2429      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2430      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2431      * supertype is implicitly assumed to be &#39;Object&#39;.
2432      *
2433      * @param bounds        the types from which the intersection type is formed
2434      * @param allInterfaces are all bounds interface types?
2435      */
2436     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2437         Assert.check(bounds.nonEmpty());
2438         Type firstExplicitBound = bounds.head;
2439         if (allInterfaces) {
2440             bounds = bounds.prepend(syms.objectType);
2441         }



2442         ClassSymbol bc =
<span class="line-modified">2443             new ClassSymbol(ABSTRACT|PUBLIC|SYNTHETIC|COMPOUND|ACYCLIC,</span>
2444                             Type.moreInfo
2445                                 ? names.fromString(bounds.toString())
2446                                 : names.empty,
2447                             null,
2448                             syms.noSymbol);
2449         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2450         bc.type = intersectionType;
2451         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2452                 syms.objectType : // error condition, recover
2453                 erasure(firstExplicitBound);
2454         bc.members_field = WriteableScope.create(bc);
2455         return intersectionType;
2456     }
2457     // &lt;/editor-fold&gt;
2458 
2459     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2460     public Type supertype(Type t) {
2461         return supertype.visit(t);
2462     }
2463     // where
</pre>
<hr />
<pre>
3897 
3898     /**
3899      * Return the least upper bound of list of types.  if the lub does
3900      * not exist return null.
3901      */
3902     public Type lub(List&lt;Type&gt; ts) {
3903         return lub(ts.toArray(new Type[ts.length()]));
3904     }
3905 
3906     /**
3907      * Return the least upper bound (lub) of set of types.  If the lub
3908      * does not exist return the type of null (bottom).
3909      */
3910     public Type lub(Type... ts) {
3911         final int UNKNOWN_BOUND = 0;
3912         final int ARRAY_BOUND = 1;
3913         final int CLASS_BOUND = 2;
3914 
3915         int[] kinds = new int[ts.length];
3916 
















3917         int boundkind = UNKNOWN_BOUND;
3918         for (int i = 0 ; i &lt; ts.length ; i++) {
3919             Type t = ts[i];
3920             switch (t.getTag()) {
3921             case CLASS:
3922                 boundkind |= kinds[i] = CLASS_BOUND;
3923                 break;
3924             case ARRAY:
3925                 boundkind |= kinds[i] = ARRAY_BOUND;
3926                 break;
3927             case  TYPEVAR:
3928                 do {
3929                     t = t.getUpperBound();
3930                 } while (t.hasTag(TYPEVAR));
3931                 if (t.hasTag(ARRAY)) {
3932                     boundkind |= kinds[i] = ARRAY_BOUND;
3933                 } else {
3934                     boundkind |= kinds[i] = CLASS_BOUND;
3935                 }
3936                 break;
</pre>
<hr />
<pre>
4017     // where
4018         List&lt;Type&gt; erasedSupertypes(Type t) {
4019             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4020             for (Type sup : closure(t)) {
4021                 if (sup.hasTag(TYPEVAR)) {
4022                     buf.append(sup);
4023                 } else {
4024                     buf.append(erasure(sup));
4025                 }
4026             }
4027             return buf.toList();
4028         }
4029 
4030         private Type arraySuperType = null;
4031         private Type arraySuperType() {
4032             // initialized lazily to avoid problems during compiler startup
4033             if (arraySuperType == null) {
4034                 synchronized (this) {
4035                     if (arraySuperType == null) {
4036                         // JLS 10.8: all arrays implement Cloneable and Serializable.
<span class="line-modified">4037                         arraySuperType = makeIntersectionType(List.of(syms.serializableType,</span>
<span class="line-modified">4038                                 syms.cloneableType), true);</span>

4039                     }
4040                 }
4041             }
4042             return arraySuperType;
4043         }
4044     // &lt;/editor-fold&gt;
4045 
4046     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4047     public Type glb(List&lt;Type&gt; ts) {
4048         Type t1 = ts.head;
4049         for (Type t2 : ts.tail) {
4050             if (t1.isErroneous())
4051                 return t1;
4052             t1 = glb(t1, t2);
4053         }
4054         return t1;
4055     }
4056     //where
4057     public Type glb(Type t, Type s) {
4058         if (s == null)
</pre>
<hr />
<pre>
4797     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4798         if (bound.hasTag(BOT)) {
4799             return new WildcardType(syms.objectType,
4800                                     BoundKind.UNBOUND,
4801                                     syms.boundClass,
4802                                     formal);
4803         } else {
4804             return new WildcardType(bound,
4805                                     BoundKind.SUPER,
4806                                     syms.boundClass,
4807                                     formal);
4808         }
4809     }
4810 
4811     /**
4812      * A wrapper for a type that allows use in sets.
4813      */
4814     public static class UniqueType {
4815         public final Type type;
4816         final Types types;

4817 
<span class="line-modified">4818         public UniqueType(Type type, Types types) {</span>
4819             this.type = type;
4820             this.types = types;





4821         }
4822 
4823         public int hashCode() {
4824             return types.hashCode(type);
4825         }
4826 
4827         public boolean equals(Object obj) {
4828             return (obj instanceof UniqueType) &amp;&amp;
4829                 types.isSameType(type, ((UniqueType)obj).type);
4830         }
4831 




4832         public String toString() {
4833             return type.toString();
4834         }
4835 
4836     }
4837     // &lt;/editor-fold&gt;
4838 
4839     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4840     /**
4841      * A default visitor for types.  All visitor methods except
4842      * visitType are implemented by delegating to visitType.  Concrete
4843      * subclasses must provide an implementation of visitType and can
4844      * override other methods as needed.
4845      *
4846      * @param &lt;R&gt; the return type of the operation implemented by this
4847      * visitor; use Void if no return type is needed.
4848      * @param &lt;S&gt; the type of the second argument (the first being the
4849      * type itself) of the operation implemented by this visitor; use
4850      * Void if a second argument is not needed.
4851      */
</pre>
<hr />
<pre>
5044                     break;
5045                 case LONG:
5046                     append(&#39;J&#39;);
5047                     break;
5048                 case FLOAT:
5049                     append(&#39;F&#39;);
5050                     break;
5051                 case DOUBLE:
5052                     append(&#39;D&#39;);
5053                     break;
5054                 case BOOLEAN:
5055                     append(&#39;Z&#39;);
5056                     break;
5057                 case VOID:
5058                     append(&#39;V&#39;);
5059                     break;
5060                 case CLASS:
5061                     if (type.isCompound()) {
5062                         reportIllegalSignature(type);
5063                     }
<span class="line-modified">5064                     append(&#39;L&#39;);</span>



5065                     assembleClassSig(type);
5066                     append(&#39;;&#39;);
5067                     break;
5068                 case ARRAY:
5069                     ArrayType at = (ArrayType) type;
5070                     append(&#39;[&#39;);
5071                     assembleSig(at.elemtype);
5072                     break;
5073                 case METHOD:
5074                     MethodType mt = (MethodType) type;
5075                     append(&#39;(&#39;);
5076                     assembleSig(mt.argtypes);
5077                     append(&#39;)&#39;);
5078                     assembleSig(mt.restype);
5079                     if (hasTypeVar(mt.thrown)) {
5080                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5081                             append(&#39;^&#39;);
5082                             assembleSig(l.head);
5083                         }
5084                     }
</pre>
</td>
<td>
<hr />
<pre>
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;
<span class="line-added">  53 import com.sun.tools.javac.jvm.Target;</span>
  54 import com.sun.tools.javac.util.*;
  55 
  56 import static com.sun.tools.javac.code.BoundKind.*;
  57 import static com.sun.tools.javac.code.Flags.*;
  58 import static com.sun.tools.javac.code.Kinds.Kind.*;
  59 import static com.sun.tools.javac.code.Scope.*;
  60 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  61 import static com.sun.tools.javac.code.Symbol.*;
  62 import static com.sun.tools.javac.code.Type.*;
  63 import static com.sun.tools.javac.code.TypeTag.*;
  64 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  65 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  66 
  67 /**
  68  * Utility class containing various operations on types.
  69  *
  70  * &lt;p&gt;Unless other names are more illustrative, the following naming
  71  * conventions should be observed in this file:
  72  *
  73  * &lt;dl&gt;
</pre>
<hr />
<pre>
  77  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  78  * &lt;dt&gt;ts&lt;/dt&gt;
  79  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  80  * &lt;dt&gt;ss&lt;/dt&gt;
  81  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  82  * &lt;/dl&gt;
  83  *
  84  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  * If you write code that depends on this, you do so at your own risk.
  86  * This code and its internal interfaces are subject to change or
  87  * deletion without notice.&lt;/b&gt;
  88  */
  89 public class Types {
  90     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  91 
  92     final Symtab syms;
  93     final JavacMessages messages;
  94     final Names names;
  95     final boolean allowDefaultMethods;
  96     final boolean mapCapturesToBounds;
<span class="line-added">  97     final boolean allowValueBasedClasses;</span>
  98     final Check chk;
  99     final Enter enter;
 100     JCDiagnostic.Factory diags;
 101     List&lt;Warner&gt; warnStack = List.nil();
 102     final Name capturedName;
 103 
 104     public final Warner noWarnings;
 105 
 106     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 107     public static Types instance(Context context) {
 108         Types instance = context.get(typesKey);
 109         if (instance == null)
 110             instance = new Types(context);
 111         return instance;
 112     }
 113 
 114     protected Types(Context context) {
 115         context.put(typesKey, this);
 116         syms = Symtab.instance(context);
 117         names = Names.instance(context);
 118         Source source = Source.instance(context);
 119         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 120         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 121         chk = Check.instance(context);
 122         enter = Enter.instance(context);
 123         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 124         messages = JavacMessages.instance(context);
 125         diags = JCDiagnostic.Factory.instance(context);
 126         noWarnings = new Warner(null);
<span class="line-added"> 127         Options options = Options.instance(context);</span>
<span class="line-added"> 128         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);</span>
 129     }
 130     // &lt;/editor-fold&gt;
 131 
 132     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 133     /**
 134      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 135      * @param t a type argument, either a wildcard or a type
 136      */
 137     public Type wildUpperBound(Type t) {
 138         if (t.hasTag(WILDCARD)) {
 139             WildcardType w = (WildcardType) t;
 140             if (w.isSuperBound())
 141                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 142             else
 143                 return wildUpperBound(w.type);
 144         }
 145         else return t;
 146     }
 147 
 148     /**
</pre>
<hr />
<pre>
 588                 }
 589                 return res;
 590             }
 591 
 592             @Override
 593             public Type visitErrorType(ErrorType t, Symbol sym) {
 594                 return t;
 595             }
 596         };
 597     // &lt;/editor-fold&gt;
 598 
 599     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 600     /**
 601      * Is t a subtype of or convertible via boxing/unboxing
 602      * conversion to s?
 603      */
 604     public boolean isConvertible(Type t, Type s, Warner warn) {
 605         if (t.hasTag(ERROR)) {
 606             return true;
 607         }
<span class="line-added"> 608 </span>
<span class="line-added"> 609         boolean tValue = t.isValue();</span>
<span class="line-added"> 610         boolean sValue = s.isValue();</span>
<span class="line-added"> 611         if (tValue != sValue) {</span>
<span class="line-added"> 612             return tValue ?</span>
<span class="line-added"> 613                     isSubtype(t.referenceProjection(), s) :</span>
<span class="line-added"> 614                     (!t.hasTag(BOT) || isValueBased(s)) &amp;&amp; isSubtype(t, s.referenceProjection());</span>
<span class="line-added"> 615         }</span>
<span class="line-added"> 616 </span>
 617         boolean tPrimitive = t.isPrimitive();
 618         boolean sPrimitive = s.isPrimitive();
 619         if (tPrimitive == sPrimitive) {
 620             return isSubtypeUnchecked(t, s, warn);
 621         }
 622         boolean tUndet = t.hasTag(UNDETVAR);
 623         boolean sUndet = s.hasTag(UNDETVAR);
 624 
 625         if (tUndet || sUndet) {
 626             return tUndet ?
 627                     isSubtype(t, boxedTypeOrType(s)) :
 628                     isSubtype(boxedTypeOrType(t), s);
 629         }
 630 
 631         return tPrimitive
 632             ? isSubtype(boxedClass(t).type, s)
 633             : isSubtype(unboxedType(t), s);
 634     }
 635 
 636     /**
</pre>
<hr />
<pre>
 990     * Scope filter used to skip methods that should be ignored (such as methods
 991     * overridden by j.l.Object) during function interface conversion interface check
 992     */
 993     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 994 
 995        TypeSymbol origin;
 996 
 997        DescriptorFilter(TypeSymbol origin) {
 998            this.origin = origin;
 999        }
1000 
1001        @Override
1002        public boolean accepts(Symbol sym) {
1003            return sym.kind == MTH &amp;&amp;
1004                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
1005                    !overridesObjectMethod(origin, sym) &amp;&amp;
1006                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
1007        }
1008     }
1009 
<span class="line-added">1010     public boolean isValue(Type t) {</span>
<span class="line-added">1011         return t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags_field &amp; Flags.VALUE) != 0;</span>
<span class="line-added">1012     }</span>
<span class="line-added">1013 </span>
<span class="line-added">1014     public boolean isValueBased(Type t) {</span>
<span class="line-added">1015         return allowValueBasedClasses &amp;&amp; t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags() &amp; Flags.VALUEBASED) != 0;</span>
<span class="line-added">1016     }</span>
<span class="line-added">1017 </span>
1018     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
1019     /**
1020      * Is t an unchecked subtype of s?
1021      */
1022     public boolean isSubtypeUnchecked(Type t, Type s) {
1023         return isSubtypeUnchecked(t, s, noWarnings);
1024     }
1025     /**
1026      * Is t an unchecked subtype of s?
1027      */
1028     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1029         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1030         if (result) {
1031             checkUnsafeVarargsConversion(t, s, warn);
1032         }
1033         return result;
1034     }
1035     //where
1036         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1037             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1038                 if (((ArrayType)t).elemtype.isPrimitive()) {
1039                     return isSameType(elemtype(t), elemtype(s));
1040                 } else {
<span class="line-modified">1041                     // if T.ref &lt;: S, then T[] &lt;: S[]</span>
<span class="line-added">1042                     Type es = elemtype(s);</span>
<span class="line-added">1043                     Type et = elemtype(t);</span>
<span class="line-added">1044                     if (isValue(et)) {</span>
<span class="line-added">1045                         et = et.referenceProjection();</span>
<span class="line-added">1046                         if (isValue(es))</span>
<span class="line-added">1047                             es = es.referenceProjection();  // V &lt;: V, surely</span>
<span class="line-added">1048                     }</span>
<span class="line-added">1049                     if (!isSubtypeUncheckedInternal(et, es, false, warn))</span>
<span class="line-added">1050                         return false;</span>
<span class="line-added">1051                     return true;</span>
1052                 }
1053             } else if (isSubtype(t, s, capture)) {
1054                 return true;
1055             } else if (t.hasTag(TYPEVAR)) {
1056                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1057             } else if (!s.isRaw()) {
1058                 Type t2 = asSuper(t, s.tsym);
1059                 if (t2 != null &amp;&amp; t2.isRaw()) {
1060                     if (isReifiable(s)) {
1061                         warn.silentWarn(LintCategory.UNCHECKED);
1062                     } else {
1063                         warn.warn(LintCategory.UNCHECKED);
1064                     }
1065                     return true;
1066                 }
1067             }
1068             return false;
1069         }
1070 
1071         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
</pre>
<hr />
<pre>
1128     }
1129     // where
1130         private TypeRelation isSubtype = new TypeRelation()
1131         {
1132             @Override
1133             public Boolean visitType(Type t, Type s) {
1134                 switch (t.getTag()) {
1135                  case BYTE:
1136                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1137                  case CHAR:
1138                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1139                  case SHORT: case INT: case LONG:
1140                  case FLOAT: case DOUBLE:
1141                      return t.getTag().isSubRangeOf(s.getTag());
1142                  case BOOLEAN: case VOID:
1143                      return t.hasTag(s.getTag());
1144                  case TYPEVAR:
1145                      return isSubtypeNoCapture(t.getUpperBound(), s);
1146                  case BOT:
1147                      return
<span class="line-modified">1148                          s.hasTag(BOT) || (s.hasTag(CLASS) &amp;&amp; (!isValue(s) || isValueBased(s))) ||</span>
1149                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1150                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1151                  case NONE:
1152                      return false;
1153                  default:
1154                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1155                  }
1156             }
1157 
1158             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1159 
1160             private boolean containsTypeRecursive(Type t, Type s) {
1161                 TypePair pair = new TypePair(t, s);
1162                 if (cache.add(pair)) {
1163                     try {
1164                         return containsType(t.getTypeArguments(),
1165                                             s.getTypeArguments());
1166                     } finally {
1167                         cache.remove(pair);
1168                     }
</pre>
<hr />
<pre>
1206             }
1207 
1208             @Override
1209             public Boolean visitClassType(ClassType t, Type s) {
1210                 Type sup = asSuper(t, s.tsym);
1211                 if (sup == null) return false;
1212                 // If t is an intersection, sup might not be a class type
1213                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1214                 return sup.tsym == s.tsym
1215                      // Check type variable containment
1216                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1217                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1218                                           s.getEnclosingType());
1219             }
1220 
1221             @Override
1222             public Boolean visitArrayType(ArrayType t, Type s) {
1223                 if (s.hasTag(ARRAY)) {
1224                     if (t.elemtype.isPrimitive())
1225                         return isSameType(t.elemtype, elemtype(s));
<span class="line-modified">1226                     else {</span>
<span class="line-modified">1227                         // if T.ref &lt;: S, then T[] &lt;: S[]</span>
<span class="line-added">1228                         Type es = elemtype(s);</span>
<span class="line-added">1229                         Type et = elemtype(t);</span>
<span class="line-added">1230                         if (isValue(et)) {</span>
<span class="line-added">1231                             et = et.referenceProjection();</span>
<span class="line-added">1232                             if (isValue(es))</span>
<span class="line-added">1233                                 es = es.referenceProjection();  // V &lt;: V, surely</span>
<span class="line-added">1234                         }</span>
<span class="line-added">1235                         return isSubtypeNoCapture(et, es);</span>
<span class="line-added">1236                     }</span>
1237                 }
1238 
1239                 if (s.hasTag(CLASS)) {
1240                     Name sname = s.tsym.getQualifiedName();
1241                     return sname == names.java_lang_Object
1242                         || sname == names.java_lang_Cloneable
<span class="line-modified">1243                         || sname == names.java_io_Serializable</span>
<span class="line-added">1244                         || sname == names.java_lang_IdentityObject;</span>
1245                 }
1246 
1247                 return false;
1248             }
1249 
1250             @Override
1251             public Boolean visitUndetVar(UndetVar t, Type s) {
1252                 //todo: test against origin needed? or replace with substitution?
1253                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1254                     return true;
1255                 } else if (s.hasTag(BOT)) {
1256                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1257                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1258                     return false;
1259                 }
1260 
1261                 t.addBound(InferenceBound.UPPER, s, Types.this);
1262                 return true;
1263             }
1264 
</pre>
<hr />
<pre>
1602 //            void debugContainsType(WildcardType t, Type s) {
1603 //                System.err.println();
1604 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1605 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1606 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1607 //                                  t.isSuperBound()
1608 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1609 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1610 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1611 //                                  t.isExtendsBound()
1612 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1613 //                System.err.println();
1614 //            }
1615 
1616             @Override
1617             public Boolean visitWildcardType(WildcardType t, Type s) {
1618                 if (s.isPartial())
1619                     return containedBy(s, t);
1620                 else {
1621 //                    debugContainsType(t, s);
<span class="line-added">1622 </span>
<span class="line-added">1623                     // -----------------------------------  Unspecified behavior ----------------</span>
<span class="line-added">1624 </span>
<span class="line-added">1625                     /* If a value class V implements an interface I, then does &quot;? extends I&quot; contain V?</span>
<span class="line-added">1626                        It seems widening must be applied here to answer yes to compile some common code</span>
<span class="line-added">1627                        patterns.</span>
<span class="line-added">1628                     */</span>
<span class="line-added">1629 </span>
<span class="line-added">1630                     // ---------------------------------------------------------------------------</span>
1631                     return isSameWildcard(t, s)
1632                         || isCaptureOf(s, t)
1633                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1634                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1635                 }
1636             }
1637 
1638             @Override
1639             public Boolean visitUndetVar(UndetVar t, Type s) {
1640                 if (!s.hasTag(WILDCARD)) {
1641                     return isSameType(t, s);
1642                 } else {
1643                     return false;
1644                 }
1645             }
1646 
1647             @Override
1648             public Boolean visitErrorType(ErrorType t, Type s) {
1649                 return true;
1650             }
</pre>
<hr />
<pre>
1716                 case DOUBLE:
1717                     return s.isNumeric();
1718                 case BOOLEAN:
1719                     return s.hasTag(BOOLEAN);
1720                 case VOID:
1721                     return false;
1722                 case BOT:
1723                     return isSubtype(t, s);
1724                 default:
1725                     throw new AssertionError();
1726                 }
1727             }
1728 
1729             @Override
1730             public Boolean visitWildcardType(WildcardType t, Type s) {
1731                 return isCastable(wildUpperBound(t), s, warnStack.head);
1732             }
1733 
1734             @Override
1735             public Boolean visitClassType(ClassType t, Type s) {
<span class="line-modified">1736                 if (s.hasTag(ERROR) || (s.hasTag(BOT) &amp;&amp; !isValue(t)))</span>
1737                     return true;
1738 
1739                 if (s.hasTag(TYPEVAR)) {
1740                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1741                         warnStack.head.warn(LintCategory.UNCHECKED);
1742                         return true;
1743                     } else {
1744                         return false;
1745                     }
1746                 }
1747 
1748                 if (t.isCompound() || s.isCompound()) {
1749                     return !t.isCompound() ?
1750                             visitCompoundType((ClassType)s, t, true) :
1751                             visitCompoundType(t, s, false);
1752                 }
1753 
1754                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
<span class="line-added">1755                     if (isValue(t)) {</span>
<span class="line-added">1756                         // (s) Value ? == (s) Value.ref</span>
<span class="line-added">1757                         t = t.referenceProjection();</span>
<span class="line-added">1758                     }</span>
<span class="line-added">1759                     if (isValue(s)) {</span>
<span class="line-added">1760                         // (Value) t ? == (Value.ref) t</span>
<span class="line-added">1761                         s = s.referenceProjection();</span>
<span class="line-added">1762                     }</span>
1763                     boolean upcast;
1764                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1765                         || isSubtype(erasure(s), erasure(t))) {
1766                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1767                             if (!isReifiable(s))
1768                                 warnStack.head.warn(LintCategory.UNCHECKED);
1769                             return true;
1770                         } else if (s.isRaw()) {
1771                             return true;
1772                         } else if (t.isRaw()) {
1773                             if (!isUnbounded(s))
1774                                 warnStack.head.warn(LintCategory.UNCHECKED);
1775                             return true;
1776                         }
1777                         // Assume |a| &lt;: |b|
1778                         final Type a = upcast ? t : s;
1779                         final Type b = upcast ? s : t;
1780                         final boolean HIGH = true;
1781                         final boolean LOW = false;
1782                         final boolean DONT_REWRITE_TYPEVARS = false;
</pre>
<hr />
<pre>
1848 
1849             @Override
1850             public Boolean visitArrayType(ArrayType t, Type s) {
1851                 switch (s.getTag()) {
1852                 case ERROR:
1853                 case BOT:
1854                     return true;
1855                 case TYPEVAR:
1856                     if (isCastable(s, t, noWarnings)) {
1857                         warnStack.head.warn(LintCategory.UNCHECKED);
1858                         return true;
1859                     } else {
1860                         return false;
1861                     }
1862                 case CLASS:
1863                     return isSubtype(t, s);
1864                 case ARRAY:
1865                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1866                         return elemtype(t).hasTag(elemtype(s).getTag());
1867                     } else {
<span class="line-modified">1868                         Type et = elemtype(t);</span>
<span class="line-added">1869                         Type es = elemtype(s);</span>
<span class="line-added">1870                         if (!visit(et, es))</span>
<span class="line-added">1871                             return false;</span>
<span class="line-added">1872                         return true;</span>
1873                     }
1874                 default:
1875                     return false;
1876                 }
1877             }
1878 
1879             @Override
1880             public Boolean visitTypeVar(TypeVar t, Type s) {
1881                 switch (s.getTag()) {
1882                 case ERROR:
1883                 case BOT:
1884                     return true;
1885                 case TYPEVAR:
1886                     if (isSubtype(t, s)) {
1887                         return true;
1888                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1889                         warnStack.head.warn(LintCategory.UNCHECKED);
1890                         return true;
1891                     } else {
1892                         return false;
</pre>
<hr />
<pre>
2144             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2145         }
2146         return new ArrayType(t, syms.arrayClass);
2147     }
2148     // &lt;/editor-fold&gt;
2149 
2150     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2151     /**
2152      * Return the (most specific) base type of t that starts with the
2153      * given symbol.  If none exists, return null.
2154      *
2155      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2156      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2157      * this method could yield surprising answers when invoked on arrays. For example when
2158      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2159      *
2160      * @param t a type
2161      * @param sym a symbol
2162      */
2163     public Type asSuper(Type t, Symbol sym) {
<span class="line-added">2164         return asSuper(t, sym, false);</span>
<span class="line-added">2165     }</span>
<span class="line-added">2166 </span>
<span class="line-added">2167     /**</span>
<span class="line-added">2168      * Return the (most specific) base type of t that starts with the</span>
<span class="line-added">2169      * given symbol.  If none exists, return null.</span>
<span class="line-added">2170      *</span>
<span class="line-added">2171      * Caveat Emptor: Since javac represents the class of all arrays with a singleton</span>
<span class="line-added">2172      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,</span>
<span class="line-added">2173      * this method could yield surprising answers when invoked on arrays. For example when</span>
<span class="line-added">2174      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.</span>
<span class="line-added">2175      *</span>
<span class="line-added">2176      * @param t a type</span>
<span class="line-added">2177      * @param sym a symbol</span>
<span class="line-added">2178      * @param checkReferenceProjection if true, first compute reference projection of t</span>
<span class="line-added">2179      */</span>
<span class="line-added">2180     public Type asSuper(Type t, Symbol sym, boolean checkReferenceProjection) {</span>
2181         /* Some examples:
2182          *
2183          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2184          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2185          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2186          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2187          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2188          */
<span class="line-added">2189 </span>
<span class="line-added">2190         /* For a (value or identity) class V, whether it implements an interface I, boils down to whether</span>
<span class="line-added">2191            V.ref is a subtype of I. OIOW, whether asSuper(V.ref, sym) != null. (Likewise for an abstract</span>
<span class="line-added">2192            superclass)</span>
<span class="line-added">2193         */</span>
<span class="line-added">2194         if (checkReferenceProjection)</span>
<span class="line-added">2195             t = t.isValue() ? t.referenceProjection() : t;</span>
<span class="line-added">2196 </span>
2197         if (sym.type == syms.objectType) { //optimization
<span class="line-modified">2198             if (!isValue(t))</span>
<span class="line-added">2199                 return syms.objectType;</span>
<span class="line-added">2200         }</span>
<span class="line-added">2201         if (sym.type == syms.identityObjectType) {</span>
<span class="line-added">2202             // IdentityObject is super interface of every concrete identity class other than jlO</span>
<span class="line-added">2203             if (t.isValue() || t.tsym == syms.objectType.tsym)</span>
<span class="line-added">2204                 return null;</span>
<span class="line-added">2205             if (t.hasTag(ARRAY))</span>
<span class="line-added">2206                 return syms.identityObjectType;</span>
<span class="line-added">2207             if (t.hasTag(CLASS) &amp;&amp; !t.isReferenceProjection() &amp;&amp; !t.tsym.isInterface() &amp;&amp; !t.tsym.isAbstract()) {</span>
<span class="line-added">2208                 return syms.identityObjectType;</span>
<span class="line-added">2209             } // else fall through and look for explicit coded super interface</span>
2210         }
2211         return asSuper.visit(t, sym);
2212     }
2213     // where
2214         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2215 
2216             public Type visitType(Type t, Symbol sym) {
2217                 return null;
2218             }
2219 
2220             @Override
2221             public Type visitClassType(ClassType t, Symbol sym) {
2222                 if (t.tsym == sym)
2223                     return t;
2224 
<span class="line-added">2225                 // No man may be an island, but the bell tolls for a value.</span>
<span class="line-added">2226                 if (isValue(t))</span>
<span class="line-added">2227                     return null;</span>
<span class="line-added">2228 </span>
2229                 Type st = supertype(t);
2230                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2231                     Type x = asSuper(st, sym);
2232                     if (x != null)
2233                         return x;
2234                 }
2235                 if ((sym.flags() &amp; INTERFACE) != 0) {
2236                     for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2237                         if (!l.head.hasTag(ERROR)) {
2238                             Type x = asSuper(l.head, sym);
2239                             if (x != null)
2240                                 return x;
2241                         }
2242                     }
2243                 }
2244                 return null;
2245             }
2246 
2247             @Override
2248             public Type visitArrayType(ArrayType t, Symbol sym) {
</pre>
<hr />
<pre>
2312         case ARRAY:
2313             return isSubtype(t, sym.type) ? sym.type : null;
2314         case TYPEVAR:
2315             return asSuper(t, sym);
2316         case ERROR:
2317             return t;
2318         default:
2319             return null;
2320         }
2321     }
2322     // &lt;/editor-fold&gt;
2323 
2324     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2325     /**
2326      * The type of given symbol, seen as a member of t.
2327      *
2328      * @param t a type
2329      * @param sym a symbol
2330      */
2331     public Type memberType(Type t, Symbol sym) {
<span class="line-modified">2332 </span>
<span class="line-modified">2333         if ((sym.flags() &amp; STATIC) != 0)</span>
<span class="line-modified">2334             return sym.type;</span>
<span class="line-added">2335 </span>
<span class="line-added">2336         /* If any inline types are involved, switch over to the reference universe,</span>
<span class="line-added">2337            where the hierarchy is navigable. V and V.ref have identical membership</span>
<span class="line-added">2338            with no bridging needs.</span>
<span class="line-added">2339         */</span>
<span class="line-added">2340         if (t.isValue())</span>
<span class="line-added">2341             t = t.referenceProjection();</span>
<span class="line-added">2342 </span>
<span class="line-added">2343         if (sym.owner.isValue())</span>
<span class="line-added">2344             sym = sym.referenceProjection();</span>
<span class="line-added">2345 </span>
<span class="line-added">2346         return memberType.visit(t, sym);</span>
2347         }
2348     // where
2349         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2350 
2351             public Type visitType(Type t, Symbol sym) {
2352                 return sym.type;
2353             }
2354 
2355             @Override
2356             public Type visitWildcardType(WildcardType t, Symbol sym) {
2357                 return memberType(wildUpperBound(t), sym);
2358             }
2359 
2360             @Override
2361             public Type visitClassType(ClassType t, Symbol sym) {
2362                 Symbol owner = sym.owner;
2363                 long flags = sym.flags();
2364                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2365                     Type base = asOuterSuper(t, owner);
2366                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
</pre>
<hr />
<pre>
2536      */
2537     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2538         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2539     }
2540 
2541     /**
2542      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2543      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2544      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2545      * supertype is implicitly assumed to be &#39;Object&#39;.
2546      *
2547      * @param bounds        the types from which the intersection type is formed
2548      * @param allInterfaces are all bounds interface types?
2549      */
2550     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2551         Assert.check(bounds.nonEmpty());
2552         Type firstExplicitBound = bounds.head;
2553         if (allInterfaces) {
2554             bounds = bounds.prepend(syms.objectType);
2555         }
<span class="line-added">2556         long flags = ABSTRACT | PUBLIC | SYNTHETIC | COMPOUND | ACYCLIC;</span>
<span class="line-added">2557         if (isValue(bounds.head))</span>
<span class="line-added">2558             flags |= VALUE;</span>
2559         ClassSymbol bc =
<span class="line-modified">2560             new ClassSymbol(flags,</span>
2561                             Type.moreInfo
2562                                 ? names.fromString(bounds.toString())
2563                                 : names.empty,
2564                             null,
2565                             syms.noSymbol);
2566         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2567         bc.type = intersectionType;
2568         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2569                 syms.objectType : // error condition, recover
2570                 erasure(firstExplicitBound);
2571         bc.members_field = WriteableScope.create(bc);
2572         return intersectionType;
2573     }
2574     // &lt;/editor-fold&gt;
2575 
2576     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2577     public Type supertype(Type t) {
2578         return supertype.visit(t);
2579     }
2580     // where
</pre>
<hr />
<pre>
4014 
4015     /**
4016      * Return the least upper bound of list of types.  if the lub does
4017      * not exist return null.
4018      */
4019     public Type lub(List&lt;Type&gt; ts) {
4020         return lub(ts.toArray(new Type[ts.length()]));
4021     }
4022 
4023     /**
4024      * Return the least upper bound (lub) of set of types.  If the lub
4025      * does not exist return the type of null (bottom).
4026      */
4027     public Type lub(Type... ts) {
4028         final int UNKNOWN_BOUND = 0;
4029         final int ARRAY_BOUND = 1;
4030         final int CLASS_BOUND = 2;
4031 
4032         int[] kinds = new int[ts.length];
4033 
<span class="line-added">4034         boolean haveValues = false;</span>
<span class="line-added">4035         boolean haveRefs = false;</span>
<span class="line-added">4036         for (int i = 0 ; i &lt; ts.length ; i++) {</span>
<span class="line-added">4037             if (ts[i].isValue())</span>
<span class="line-added">4038                 haveValues = true;</span>
<span class="line-added">4039             else</span>
<span class="line-added">4040                 haveRefs = true;</span>
<span class="line-added">4041         }</span>
<span class="line-added">4042         if (haveRefs &amp;&amp; haveValues) {</span>
<span class="line-added">4043             System.arraycopy(ts, 0, ts = new Type[ts.length], 0, ts.length);</span>
<span class="line-added">4044             for (int i = 0; i &lt; ts.length; i++) {</span>
<span class="line-added">4045                 if (ts[i].isValue())</span>
<span class="line-added">4046                     ts[i] = ts[i].referenceProjection();</span>
<span class="line-added">4047             }</span>
<span class="line-added">4048         }</span>
<span class="line-added">4049 </span>
4050         int boundkind = UNKNOWN_BOUND;
4051         for (int i = 0 ; i &lt; ts.length ; i++) {
4052             Type t = ts[i];
4053             switch (t.getTag()) {
4054             case CLASS:
4055                 boundkind |= kinds[i] = CLASS_BOUND;
4056                 break;
4057             case ARRAY:
4058                 boundkind |= kinds[i] = ARRAY_BOUND;
4059                 break;
4060             case  TYPEVAR:
4061                 do {
4062                     t = t.getUpperBound();
4063                 } while (t.hasTag(TYPEVAR));
4064                 if (t.hasTag(ARRAY)) {
4065                     boundkind |= kinds[i] = ARRAY_BOUND;
4066                 } else {
4067                     boundkind |= kinds[i] = CLASS_BOUND;
4068                 }
4069                 break;
</pre>
<hr />
<pre>
4150     // where
4151         List&lt;Type&gt; erasedSupertypes(Type t) {
4152             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4153             for (Type sup : closure(t)) {
4154                 if (sup.hasTag(TYPEVAR)) {
4155                     buf.append(sup);
4156                 } else {
4157                     buf.append(erasure(sup));
4158                 }
4159             }
4160             return buf.toList();
4161         }
4162 
4163         private Type arraySuperType = null;
4164         private Type arraySuperType() {
4165             // initialized lazily to avoid problems during compiler startup
4166             if (arraySuperType == null) {
4167                 synchronized (this) {
4168                     if (arraySuperType == null) {
4169                         // JLS 10.8: all arrays implement Cloneable and Serializable.
<span class="line-modified">4170                         List&lt;Type&gt; ifaces =</span>
<span class="line-modified">4171                                 List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType);</span>
<span class="line-added">4172                         arraySuperType = makeIntersectionType(ifaces, true);</span>
4173                     }
4174                 }
4175             }
4176             return arraySuperType;
4177         }
4178     // &lt;/editor-fold&gt;
4179 
4180     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4181     public Type glb(List&lt;Type&gt; ts) {
4182         Type t1 = ts.head;
4183         for (Type t2 : ts.tail) {
4184             if (t1.isErroneous())
4185                 return t1;
4186             t1 = glb(t1, t2);
4187         }
4188         return t1;
4189     }
4190     //where
4191     public Type glb(Type t, Type s) {
4192         if (s == null)
</pre>
<hr />
<pre>
4931     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4932         if (bound.hasTag(BOT)) {
4933             return new WildcardType(syms.objectType,
4934                                     BoundKind.UNBOUND,
4935                                     syms.boundClass,
4936                                     formal);
4937         } else {
4938             return new WildcardType(bound,
4939                                     BoundKind.SUPER,
4940                                     syms.boundClass,
4941                                     formal);
4942         }
4943     }
4944 
4945     /**
4946      * A wrapper for a type that allows use in sets.
4947      */
4948     public static class UniqueType {
4949         public final Type type;
4950         final Types types;
<span class="line-added">4951         private boolean encodeTypeSig;</span>
4952 
<span class="line-modified">4953         public UniqueType(Type type, Types types, boolean encodeTypeSig) {</span>
4954             this.type = type;
4955             this.types = types;
<span class="line-added">4956             this.encodeTypeSig = encodeTypeSig;</span>
<span class="line-added">4957         }</span>
<span class="line-added">4958 </span>
<span class="line-added">4959         public UniqueType(Type type, Types types) {</span>
<span class="line-added">4960             this(type, types, true);</span>
4961         }
4962 
4963         public int hashCode() {
4964             return types.hashCode(type);
4965         }
4966 
4967         public boolean equals(Object obj) {
4968             return (obj instanceof UniqueType) &amp;&amp;
4969                 types.isSameType(type, ((UniqueType)obj).type);
4970         }
4971 
<span class="line-added">4972         public boolean encodeTypeSig() {</span>
<span class="line-added">4973             return encodeTypeSig;</span>
<span class="line-added">4974         }</span>
<span class="line-added">4975 </span>
4976         public String toString() {
4977             return type.toString();
4978         }
4979 
4980     }
4981     // &lt;/editor-fold&gt;
4982 
4983     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4984     /**
4985      * A default visitor for types.  All visitor methods except
4986      * visitType are implemented by delegating to visitType.  Concrete
4987      * subclasses must provide an implementation of visitType and can
4988      * override other methods as needed.
4989      *
4990      * @param &lt;R&gt; the return type of the operation implemented by this
4991      * visitor; use Void if no return type is needed.
4992      * @param &lt;S&gt; the type of the second argument (the first being the
4993      * type itself) of the operation implemented by this visitor; use
4994      * Void if a second argument is not needed.
4995      */
</pre>
<hr />
<pre>
5188                     break;
5189                 case LONG:
5190                     append(&#39;J&#39;);
5191                     break;
5192                 case FLOAT:
5193                     append(&#39;F&#39;);
5194                     break;
5195                 case DOUBLE:
5196                     append(&#39;D&#39;);
5197                     break;
5198                 case BOOLEAN:
5199                     append(&#39;Z&#39;);
5200                     break;
5201                 case VOID:
5202                     append(&#39;V&#39;);
5203                     break;
5204                 case CLASS:
5205                     if (type.isCompound()) {
5206                         reportIllegalSignature(type);
5207                     }
<span class="line-modified">5208                     if (types.isValue(type))</span>
<span class="line-added">5209                         append(&#39;Q&#39;);</span>
<span class="line-added">5210                     else</span>
<span class="line-added">5211                         append(&#39;L&#39;);</span>
5212                     assembleClassSig(type);
5213                     append(&#39;;&#39;);
5214                     break;
5215                 case ARRAY:
5216                     ArrayType at = (ArrayType) type;
5217                     append(&#39;[&#39;);
5218                     assembleSig(at.elemtype);
5219                     break;
5220                 case METHOD:
5221                     MethodType mt = (MethodType) type;
5222                     append(&#39;(&#39;);
5223                     assembleSig(mt.argtypes);
5224                     append(&#39;)&#39;);
5225                     assembleSig(mt.restype);
5226                     if (hasTypeVar(mt.thrown)) {
5227                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5228                             append(&#39;^&#39;);
5229                             assembleSig(l.head);
5230                         }
5231                     }
</pre>
</td>
</tr>
</table>
<center><a href="Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
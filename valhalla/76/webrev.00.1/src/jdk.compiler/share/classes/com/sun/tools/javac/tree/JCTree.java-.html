<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.util.*;
  31 
  32 import javax.lang.model.element.Modifier;
  33 import javax.lang.model.type.TypeKind;
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.source.tree.*;
  37 import com.sun.tools.javac.code.*;
  38 import com.sun.tools.javac.code.Directive.RequiresDirective;
  39 import com.sun.tools.javac.code.Scope.*;
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.DefinedBy.Api;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.List;
  45 
  46 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  47 
  48 import javax.tools.JavaFileManager.Location;
  49 
  50 import com.sun.source.tree.ModuleTree.ModuleKind;
  51 import com.sun.tools.javac.code.Directive.ExportsDirective;
  52 import com.sun.tools.javac.code.Directive.OpensDirective;
  53 import com.sun.tools.javac.code.Type.ModuleType;
  54 
  55 /**
  56  * Root class for abstract syntax tree nodes. It provides definitions
  57  * for specific tree nodes as subclasses nested inside.
  58  *
  59  * &lt;p&gt;Each subclass is highly standardized.  It generally contains
  60  * only tree fields for the syntactic subcomponents of the node.  Some
  61  * classes that represent identifier uses or definitions also define a
  62  * Symbol field that denotes the represented identifier.  Classes for
  63  * non-local jumps also carry the jump target as a field.  The root
  64  * class Tree itself defines fields for the tree&#39;s type and position.
  65  * No other fields are kept in a tree node; instead parameters are
  66  * passed to methods accessing the node.
  67  *
  68  * &lt;p&gt;Except for the methods defined by com.sun.source, the only
  69  * method defined in subclasses is `visit&#39; which applies a given
  70  * visitor to the tree. The actual tree processing is done by visitor
  71  * classes in other packages. The abstract class Visitor, as well as
  72  * an Factory interface for trees, are defined as inner classes in
  73  * Tree.
  74  *
  75  * &lt;p&gt;To avoid ambiguities with the Tree API in com.sun.source all sub
  76  * classes should, by convention, start with JC (javac).
  77  *
  78  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  79  * If you write code that depends on this, you do so at your own risk.
  80  * This code and its internal interfaces are subject to change or
  81  * deletion without notice.&lt;/b&gt;
  82  *
  83  * @see TreeMaker
  84  * @see TreeInfo
  85  * @see TreeTranslator
  86  * @see Pretty
  87  */
  88 public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition {
  89 
  90     /* Tree tag values, identifying kinds of trees */
  91     public enum Tag {
  92         /** For methods that return an invalid tag if a given condition is not met
  93          */
  94         NO_TAG,
  95 
  96         /** Toplevel nodes, of type TopLevel, representing entire source files.
  97         */
  98         TOPLEVEL,
  99 
 100         /** Package level definitions.
 101          */
 102         PACKAGEDEF,
 103 
 104         /** Import clauses, of type Import.
 105          */
 106         IMPORT,
 107 
 108         /** Class definitions, of type ClassDef.
 109          */
 110         CLASSDEF,
 111 
 112         /** Method definitions, of type MethodDef.
 113          */
 114         METHODDEF,
 115 
 116         /** Variable definitions, of type VarDef.
 117          */
 118         VARDEF,
 119 
 120         /** The no-op statement &quot;;&quot;, of type Skip
 121          */
 122         SKIP,
 123 
 124         /** Blocks, of type Block.
 125          */
 126         BLOCK,
 127 
 128         /** Do-while loops, of type DoLoop.
 129          */
 130         DOLOOP,
 131 
 132         /** While-loops, of type WhileLoop.
 133          */
 134         WHILELOOP,
 135 
 136         /** For-loops, of type ForLoop.
 137          */
 138         FORLOOP,
 139 
 140         /** Foreach-loops, of type ForeachLoop.
 141          */
 142         FOREACHLOOP,
 143 
 144         /** Labelled statements, of type Labelled.
 145          */
 146         LABELLED,
 147 
 148         /** Switch statements, of type Switch.
 149          */
 150         SWITCH,
 151 
 152         /** Case parts in switch statements/expressions, of type Case.
 153          */
 154         CASE,
 155 
 156         /** Switch expression statements, of type Switch.
 157          */
 158         SWITCH_EXPRESSION,
 159 
 160         /** Synchronized statements, of type Synchronized.
 161          */
 162         SYNCHRONIZED,
 163 
 164         /** Try statements, of type Try.
 165          */
 166         TRY,
 167 
 168         /** Catch clauses in try statements, of type Catch.
 169          */
 170         CATCH,
 171 
 172         /** Conditional expressions, of type Conditional.
 173          */
 174         CONDEXPR,
 175 
 176         /** Conditional statements, of type If.
 177          */
 178         IF,
 179 
 180         /** Expression statements, of type Exec.
 181          */
 182         EXEC,
 183 
 184         /** Break statements, of type Break.
 185          */
 186         BREAK,
 187 
 188         /** Yield statements, of type Yield.
 189          */
 190         YIELD,
 191 
 192         /** Continue statements, of type Continue.
 193          */
 194         CONTINUE,
 195 
 196         /** Return statements, of type Return.
 197          */
 198         RETURN,
 199 
 200         /** Throw statements, of type Throw.
 201          */
 202         THROW,
 203 
 204         /** Assert statements, of type Assert.
 205          */
 206         ASSERT,
 207 
 208         /** Method invocation expressions, of type Apply.
 209          */
 210         APPLY,
 211 
 212         /** Class instance creation expressions, of type NewClass.
 213          */
 214         NEWCLASS,
 215 
 216         /** Array creation expressions, of type NewArray.
 217          */
 218         NEWARRAY,
 219 
 220         /** Lambda expression, of type Lambda.
 221          */
 222         LAMBDA,
 223 
 224         /** Parenthesized subexpressions, of type Parens.
 225          */
 226         PARENS,
 227 
 228         /** Assignment expressions, of type Assign.
 229          */
 230         ASSIGN,
 231 
 232         /** Type cast expressions, of type TypeCast.
 233          */
 234         TYPECAST,
 235 
 236         /** Type test expressions, of type TypeTest.
 237          */
 238         TYPETEST,
 239 
 240         /** Patterns.
 241          */
 242         BINDINGPATTERN,
 243 
 244         /** Indexed array expressions, of type Indexed.
 245          */
 246         INDEXED,
 247 
 248         /** Selections, of type Select.
 249          */
 250         SELECT,
 251 
 252         /** Member references, of type Reference.
 253          */
 254         REFERENCE,
 255 
 256         /** Simple identifiers, of type Ident.
 257          */
 258         IDENT,
 259 
 260         /** Literals, of type Literal.
 261          */
 262         LITERAL,
 263 
 264         /** Basic type identifiers, of type TypeIdent.
 265          */
 266         TYPEIDENT,
 267 
 268         /** Array types, of type TypeArray.
 269          */
 270         TYPEARRAY,
 271 
 272         /** Parameterized types, of type TypeApply.
 273          */
 274         TYPEAPPLY,
 275 
 276         /** Union types, of type TypeUnion.
 277          */
 278         TYPEUNION,
 279 
 280         /** Intersection types, of type TypeIntersection.
 281          */
 282         TYPEINTERSECTION,
 283 
 284         /** Formal type parameters, of type TypeParameter.
 285          */
 286         TYPEPARAMETER,
 287 
 288         /** Type argument.
 289          */
 290         WILDCARD,
 291 
 292         /** Bound kind: extends, super, exact, or unbound
 293          */
 294         TYPEBOUNDKIND,
 295 
 296         /** metadata: Annotation.
 297          */
 298         ANNOTATION,
 299 
 300         /** metadata: Type annotation.
 301          */
 302         TYPE_ANNOTATION,
 303 
 304         /** metadata: Modifiers
 305          */
 306         MODIFIERS,
 307 
 308         /** An annotated type tree.
 309          */
 310         ANNOTATED_TYPE,
 311 
 312         /** Error trees, of type Erroneous.
 313          */
 314         ERRONEOUS,
 315 
 316         /** Unary operators, of type Unary.
 317          */
 318         POS,                             // +
 319         NEG,                             // -
 320         NOT,                             // !
 321         COMPL,                           // ~
 322         PREINC,                          // ++ _
 323         PREDEC,                          // -- _
 324         POSTINC,                         // _ ++
 325         POSTDEC,                         // _ --
 326 
 327         /** unary operator for null reference checks, only used internally.
 328          */
 329         NULLCHK,
 330 
 331         /** Binary operators, of type Binary.
 332          */
 333         OR,                              // ||
 334         AND,                             // &amp;&amp;
 335         BITOR,                           // |
 336         BITXOR,                          // ^
 337         BITAND,                          // &amp;
 338         EQ,                              // ==
 339         NE,                              // !=
 340         LT,                              // &lt;
 341         GT,                              // &gt;
 342         LE,                              // &lt;=
 343         GE,                              // &gt;=
 344         SL,                              // &lt;&lt;
 345         SR,                              // &gt;&gt;
 346         USR,                             // &gt;&gt;&gt;
 347         PLUS,                            // +
 348         MINUS,                           // -
 349         MUL,                             // *
 350         DIV,                             // /
 351         MOD,                             // %
 352 
 353         /** Assignment operators, of type Assignop.
 354          */
 355         BITOR_ASG(BITOR),                // |=
 356         BITXOR_ASG(BITXOR),              // ^=
 357         BITAND_ASG(BITAND),              // &amp;=
 358 
 359         SL_ASG(SL),                      // &lt;&lt;=
 360         SR_ASG(SR),                      // &gt;&gt;=
 361         USR_ASG(USR),                    // &gt;&gt;&gt;=
 362         PLUS_ASG(PLUS),                  // +=
 363         MINUS_ASG(MINUS),                // -=
 364         MUL_ASG(MUL),                    // *=
 365         DIV_ASG(DIV),                    // /=
 366         MOD_ASG(MOD),                    // %=
 367 
 368         MODULEDEF,
 369         EXPORTS,
 370         OPENS,
 371         PROVIDES,
 372         REQUIRES,
 373         USES,
 374 
 375         /** A synthetic let expression, of type LetExpr.
 376          */
 377         LETEXPR;                         // ala scheme
 378 
 379         private final Tag noAssignTag;
 380 
 381         private static final int numberOfOperators = MOD.ordinal() - POS.ordinal() + 1;
 382 
 383         private Tag(Tag noAssignTag) {
 384             this.noAssignTag = noAssignTag;
 385         }
 386 
 387         private Tag() {
 388             this(null);
 389         }
 390 
 391         public static int getNumberOfOperators() {
 392             return numberOfOperators;
 393         }
 394 
 395         public Tag noAssignOp() {
 396             if (noAssignTag != null)
 397                 return noAssignTag;
 398             throw new AssertionError(&quot;noAssignOp() method is not available for non assignment tags&quot;);
 399         }
 400 
 401         public boolean isPostUnaryOp() {
 402             return (this == POSTINC || this == POSTDEC);
 403         }
 404 
 405         public boolean isIncOrDecUnaryOp() {
 406             return (this == PREINC || this == PREDEC || this == POSTINC || this == POSTDEC);
 407         }
 408 
 409         public boolean isAssignop() {
 410             return noAssignTag != null;
 411         }
 412 
 413         public int operatorIndex() {
 414             return (this.ordinal() - POS.ordinal());
 415         }
 416     }
 417 
 418     /* The (encoded) position in the source file. @see util.Position.
 419      */
 420     public int pos;
 421 
 422     /* The type of this node.
 423      */
 424     public Type type;
 425 
 426     /* The tag of this node -- one of the constants declared above.
 427      */
 428     public abstract Tag getTag();
 429 
 430     /* Returns true if the tag of this node is equals to tag.
 431      */
 432     public boolean hasTag(Tag tag) {
 433         return tag == getTag();
 434     }
 435 
 436     /** Convert a tree to a pretty-printed string. */
 437     @Override
 438     public String toString() {
 439         StringWriter s = new StringWriter();
 440         try {
 441             new Pretty(s, false).printExpr(this);
 442         }
 443         catch (IOException e) {
 444             // should never happen, because StringWriter is defined
 445             // never to throw any IOExceptions
 446             throw new AssertionError(e);
 447         }
 448         return s.toString();
 449     }
 450 
 451     /** Set position field and return this tree.
 452      */
 453     public JCTree setPos(int pos) {
 454         this.pos = pos;
 455         return this;
 456     }
 457 
 458     /** Set type field and return this tree.
 459      */
 460     public JCTree setType(Type type) {
 461         this.type = type;
 462         return this;
 463     }
 464 
 465     /** Visit this tree with a given visitor.
 466      */
 467     public abstract void accept(Visitor v);
 468 
 469     @DefinedBy(Api.COMPILER_TREE)
 470     public abstract &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d);
 471 
 472     /** Return a shallow copy of this tree.
 473      */
 474     @Override
 475     public Object clone() {
 476         try {
 477             return super.clone();
 478         } catch(CloneNotSupportedException e) {
 479             throw new RuntimeException(e);
 480         }
 481     }
 482 
 483     /** Get a default position for this tree node.
 484      */
 485     public DiagnosticPosition pos() {
 486         return this;
 487     }
 488 
 489     // for default DiagnosticPosition
 490     public JCTree getTree() {
 491         return this;
 492     }
 493 
 494     // for default DiagnosticPosition
 495     public int getStartPosition() {
 496         return TreeInfo.getStartPos(this);
 497     }
 498 
 499     // for default DiagnosticPosition
 500     public int getPreferredPosition() {
 501         return pos;
 502     }
 503 
 504     // for default DiagnosticPosition
 505     public int getEndPosition(EndPosTable endPosTable) {
 506         return TreeInfo.getEndPos(this, endPosTable);
 507     }
 508 
 509     /**
 510      * Everything in one source file is kept in a {@linkplain JCCompilationUnit} structure.
 511      */
 512     public static class JCCompilationUnit extends JCTree implements CompilationUnitTree {
 513         /** All definitions in this file (ClassDef, Import, and Skip) */
 514         public List&lt;JCTree&gt; defs;
 515         /** The source file name. */
 516         public JavaFileObject sourcefile;
 517         /** The module to which this compilation unit belongs. */
 518         public ModuleSymbol modle;
 519         /** The location in which this compilation unit was found. */
 520         public Location locn;
 521         /** The package to which this compilation unit belongs. */
 522         public PackageSymbol packge;
 523         /** A scope containing top level classes. */
 524         public WriteableScope toplevelScope;
 525         /** A scope for all named imports. */
 526         public NamedImportScope namedImportScope;
 527         /** A scope for all import-on-demands. */
 528         public StarImportScope starImportScope;
 529         /** Line starting positions, defined only if option -g is set. */
 530         public Position.LineMap lineMap = null;
 531         /** A table that stores all documentation comments indexed by the tree
 532          * nodes they refer to. defined only if option -s is set. */
 533         public DocCommentTable docComments = null;
 534         /* An object encapsulating ending positions of source ranges indexed by
 535          * the tree nodes they belong to. Defined only if option -Xjcov is set. */
 536         public EndPosTable endPositions = null;
 537         protected JCCompilationUnit(List&lt;JCTree&gt; defs) {
 538             this.defs = defs;
 539         }
 540         @Override
 541         public void accept(Visitor v) { v.visitTopLevel(this); }
 542 
 543         @DefinedBy(Api.COMPILER_TREE)
 544         public Kind getKind() { return Kind.COMPILATION_UNIT; }
 545 
 546         public JCModuleDecl getModuleDecl() {
 547             for (JCTree tree : defs) {
 548                 if (tree.hasTag(MODULEDEF)) {
 549                     return (JCModuleDecl) tree;
 550                 }
 551             }
 552 
 553             return null;
 554         }
 555 
 556         @DefinedBy(Api.COMPILER_TREE)
 557         public JCPackageDecl getPackage() {
 558             // PackageDecl must be the first entry if it exists
 559             if (!defs.isEmpty() &amp;&amp; defs.head.hasTag(PACKAGEDEF))
 560                 return (JCPackageDecl)defs.head;
 561             return null;
 562         }
 563         @DefinedBy(Api.COMPILER_TREE)
 564         public List&lt;JCAnnotation&gt; getPackageAnnotations() {
 565             JCPackageDecl pd = getPackage();
 566             return pd != null ? pd.getAnnotations() : List.nil();
 567         }
 568         @DefinedBy(Api.COMPILER_TREE)
 569         public ExpressionTree getPackageName() {
 570             JCPackageDecl pd = getPackage();
 571             return pd != null ? pd.getPackageName() : null;
 572         }
 573 
 574         @DefinedBy(Api.COMPILER_TREE)
 575         public List&lt;JCImport&gt; getImports() {
 576             ListBuffer&lt;JCImport&gt; imports = new ListBuffer&lt;&gt;();
 577             for (JCTree tree : defs) {
 578                 if (tree.hasTag(IMPORT))
 579                     imports.append((JCImport)tree);
 580                 else if (!tree.hasTag(PACKAGEDEF) &amp;&amp; !tree.hasTag(SKIP))
 581                     break;
 582             }
 583             return imports.toList();
 584         }
 585         @DefinedBy(Api.COMPILER_TREE)
 586         public JavaFileObject getSourceFile() {
 587             return sourcefile;
 588         }
 589         @DefinedBy(Api.COMPILER_TREE)
 590         public Position.LineMap getLineMap() {
 591             return lineMap;
 592         }
 593         @DefinedBy(Api.COMPILER_TREE)
 594         public List&lt;JCTree&gt; getTypeDecls() {
 595             List&lt;JCTree&gt; typeDefs;
 596             for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail)
 597                 if (!typeDefs.head.hasTag(PACKAGEDEF) &amp;&amp; !typeDefs.head.hasTag(IMPORT))
 598                     break;
 599             return typeDefs;
 600         }
 601         @Override @DefinedBy(Api.COMPILER_TREE)
 602         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 603             return v.visitCompilationUnit(this, d);
 604         }
 605 
 606         @Override
 607         public Tag getTag() {
 608             return TOPLEVEL;
 609         }
 610     }
 611 
 612     /**
 613      * Package definition.
 614      */
 615     public static class JCPackageDecl extends JCTree implements PackageTree {
 616         public List&lt;JCAnnotation&gt; annotations;
 617         /** The tree representing the package clause. */
 618         public JCExpression pid;
 619         public PackageSymbol packge;
 620         public JCPackageDecl(List&lt;JCAnnotation&gt; annotations, JCExpression pid) {
 621             this.annotations = annotations;
 622             this.pid = pid;
 623         }
 624         @Override
 625         public void accept(Visitor v) { v.visitPackageDef(this); }
 626         @DefinedBy(Api.COMPILER_TREE)
 627         public Kind getKind() {
 628             return Kind.PACKAGE;
 629         }
 630         @DefinedBy(Api.COMPILER_TREE)
 631         public List&lt;JCAnnotation&gt; getAnnotations() {
 632             return annotations;
 633         }
 634         @DefinedBy(Api.COMPILER_TREE)
 635         public JCExpression getPackageName() {
 636             return pid;
 637         }
 638         @Override @DefinedBy(Api.COMPILER_TREE)
 639         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 640             return v.visitPackage(this, d);
 641         }
 642         @Override
 643         public Tag getTag() {
 644             return PACKAGEDEF;
 645         }
 646     }
 647 
 648     /**
 649      * An import clause.
 650      */
 651     public static class JCImport extends JCTree implements ImportTree {
 652         public boolean staticImport;
 653         /** The imported class(es). */
 654         public JCTree qualid;
 655         public com.sun.tools.javac.code.Scope importScope;
 656         protected JCImport(JCTree qualid, boolean importStatic) {
 657             this.qualid = qualid;
 658             this.staticImport = importStatic;
 659         }
 660         @Override
 661         public void accept(Visitor v) { v.visitImport(this); }
 662 
 663         @DefinedBy(Api.COMPILER_TREE)
 664         public boolean isStatic() { return staticImport; }
 665         @DefinedBy(Api.COMPILER_TREE)
 666         public JCTree getQualifiedIdentifier() { return qualid; }
 667 
 668         @DefinedBy(Api.COMPILER_TREE)
 669         public Kind getKind() { return Kind.IMPORT; }
 670         @Override @DefinedBy(Api.COMPILER_TREE)
 671         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 672             return v.visitImport(this, d);
 673         }
 674 
 675         @Override
 676         public Tag getTag() {
 677             return IMPORT;
 678         }
 679     }
 680 
 681     public static abstract class JCStatement extends JCTree implements StatementTree {
 682         @Override
 683         public JCStatement setType(Type type) {
 684             super.setType(type);
 685             return this;
 686         }
 687         @Override
 688         public JCStatement setPos(int pos) {
 689             super.setPos(pos);
 690             return this;
 691         }
 692     }
 693 
 694     public static abstract class JCExpression extends JCTree implements ExpressionTree {
 695         @Override
 696         public JCExpression setType(Type type) {
 697             super.setType(type);
 698             return this;
 699         }
 700         @Override
 701         public JCExpression setPos(int pos) {
 702             super.setPos(pos);
 703             return this;
 704         }
 705 
 706         public boolean isPoly() { return false; }
 707         public boolean isStandalone() { return true; }
 708     }
 709 
 710     /**
 711      * Common supertype for all poly expression trees (lambda, method references,
 712      * conditionals, method and constructor calls)
 713      */
 714     public static abstract class JCPolyExpression extends JCExpression {
 715 
 716         /**
 717          * A poly expression can only be truly &#39;poly&#39; in certain contexts
 718          */
 719         public enum PolyKind {
 720             /** poly expression to be treated as a standalone expression */
 721             STANDALONE,
 722             /** true poly expression */
 723             POLY
 724         }
 725 
 726         /** is this poly expression a &#39;true&#39; poly expression? */
 727         public PolyKind polyKind;
 728 
 729         @Override public boolean isPoly() { return polyKind == PolyKind.POLY; }
 730         @Override public boolean isStandalone() { return polyKind == PolyKind.STANDALONE; }
 731     }
 732 
 733     /**
 734      * Common supertype for all functional expression trees (lambda and method references)
 735      */
 736     public static abstract class JCFunctionalExpression extends JCPolyExpression {
 737 
 738         public JCFunctionalExpression() {
 739             //a functional expression is always a &#39;true&#39; poly
 740             polyKind = PolyKind.POLY;
 741         }
 742 
 743         /** list of target types inferred for this functional expression. */
 744         public Type target;
 745 
 746         public Type getDescriptorType(Types types) {
 747             return target != null ? types.findDescriptorType(target) : types.createErrorType(null);
 748         }
 749     }
 750 
 751     /**
 752      * A class definition.
 753      */
 754     public static class JCClassDecl extends JCStatement implements ClassTree {
 755         /** the modifiers */
 756         public JCModifiers mods;
 757         /** the name of the class */
 758         public Name name;
 759         /** formal class parameters */
 760         public List&lt;JCTypeParameter&gt; typarams;
 761         /** the classes this class extends */
 762         public JCExpression extending;
 763         /** the interfaces implemented by this class */
 764         public List&lt;JCExpression&gt; implementing;
 765         /** the subclasses allowed to extend this class, if sealed */
 766         public List&lt;JCExpression&gt; permitting;
 767         /** all variables and methods defined in this class */
 768         public List&lt;JCTree&gt; defs;
 769         /** the symbol */
 770         public ClassSymbol sym;
 771         protected JCClassDecl(JCModifiers mods,
 772                            Name name,
 773                            List&lt;JCTypeParameter&gt; typarams,
 774                            JCExpression extending,
 775                            List&lt;JCExpression&gt; implementing,
 776                            List&lt;JCExpression&gt; permitting,
 777                            List&lt;JCTree&gt; defs,
 778                            ClassSymbol sym)
 779         {
 780             this.mods = mods;
 781             this.name = name;
 782             this.typarams = typarams;
 783             this.extending = extending;
 784             this.implementing = implementing;
 785             this.permitting = permitting;
 786             this.defs = defs;
 787             this.sym = sym;
 788         }
 789         @Override
 790         public void accept(Visitor v) { v.visitClassDef(this); }
 791 
 792         @SuppressWarnings(&quot;preview&quot;)
 793         @DefinedBy(Api.COMPILER_TREE)
 794         public Kind getKind() {
 795             if ((mods.flags &amp; Flags.ANNOTATION) != 0)
 796                 return Kind.ANNOTATION_TYPE;
 797             else if ((mods.flags &amp; Flags.INTERFACE) != 0)
 798                 return Kind.INTERFACE;
 799             else if ((mods.flags &amp; Flags.ENUM) != 0)
 800                 return Kind.ENUM;
 801             else if ((mods.flags &amp; Flags.RECORD) != 0)
 802                 return Kind.RECORD;
 803             else
 804                 return Kind.CLASS;
 805         }
 806 
 807         @DefinedBy(Api.COMPILER_TREE)
 808         public JCModifiers getModifiers() { return mods; }
 809         @DefinedBy(Api.COMPILER_TREE)
 810         public Name getSimpleName() { return name; }
 811         @DefinedBy(Api.COMPILER_TREE)
 812         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 813             return typarams;
 814         }
 815         @DefinedBy(Api.COMPILER_TREE)
 816         public JCExpression getExtendsClause() { return extending; }
 817         @DefinedBy(Api.COMPILER_TREE)
 818         public List&lt;JCExpression&gt; getImplementsClause() {
 819             return implementing;
 820         }
 821         @SuppressWarnings(&quot;removal&quot;)
 822         @DefinedBy(Api.COMPILER_TREE)
 823         public List&lt;JCExpression&gt; getPermitsClause() {
 824             return permitting;
 825         }
 826         @DefinedBy(Api.COMPILER_TREE)
 827         public List&lt;JCTree&gt; getMembers() {
 828             return defs;
 829         }
 830         @Override @DefinedBy(Api.COMPILER_TREE)
 831         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 832             return v.visitClass(this, d);
 833         }
 834 
 835         @Override
 836         public Tag getTag() {
 837             return CLASSDEF;
 838         }
 839     }
 840 
 841     /**
 842      * A method definition.
 843      */
 844     public static class JCMethodDecl extends JCTree implements MethodTree {
 845         /** method modifiers */
 846         public JCModifiers mods;
 847         /** method name */
 848         public Name name;
 849         /** type of method return value */
 850         public JCExpression restype;
 851         /** type parameters */
 852         public List&lt;JCTypeParameter&gt; typarams;
 853         /** receiver parameter */
 854         public JCVariableDecl recvparam;
 855         /** value parameters */
 856         public List&lt;JCVariableDecl&gt; params;
 857         /** exceptions thrown by this method */
 858         public List&lt;JCExpression&gt; thrown;
 859         /** statements in the method */
 860         public JCBlock body;
 861         /** default value, for annotation types */
 862         public JCExpression defaultValue;
 863         /** method symbol */
 864         public MethodSymbol sym;
 865         /** does this method completes normally */
 866         public boolean completesNormally;
 867 
 868         protected JCMethodDecl(JCModifiers mods,
 869                             Name name,
 870                             JCExpression restype,
 871                             List&lt;JCTypeParameter&gt; typarams,
 872                             JCVariableDecl recvparam,
 873                             List&lt;JCVariableDecl&gt; params,
 874                             List&lt;JCExpression&gt; thrown,
 875                             JCBlock body,
 876                             JCExpression defaultValue,
 877                             MethodSymbol sym)
 878         {
 879             this.mods = mods;
 880             this.name = name;
 881             this.restype = restype;
 882             this.typarams = typarams;
 883             this.params = params;
 884             this.recvparam = recvparam;
 885             // TODO: do something special if the given type is null?
 886             // receiver != null ? receiver : List.&lt;JCTypeAnnotation&gt;nil());
 887             this.thrown = thrown;
 888             this.body = body;
 889             this.defaultValue = defaultValue;
 890             this.sym = sym;
 891         }
 892         @Override
 893         public void accept(Visitor v) { v.visitMethodDef(this); }
 894 
 895         @DefinedBy(Api.COMPILER_TREE)
 896         public Kind getKind() { return Kind.METHOD; }
 897         @DefinedBy(Api.COMPILER_TREE)
 898         public JCModifiers getModifiers() { return mods; }
 899         @DefinedBy(Api.COMPILER_TREE)
 900         public Name getName() { return name; }
 901         @DefinedBy(Api.COMPILER_TREE)
 902         public JCTree getReturnType() { return restype; }
 903         @DefinedBy(Api.COMPILER_TREE)
 904         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 905             return typarams;
 906         }
 907         @DefinedBy(Api.COMPILER_TREE)
 908         public List&lt;JCVariableDecl&gt; getParameters() {
 909             return params;
 910         }
 911         @DefinedBy(Api.COMPILER_TREE)
 912         public JCVariableDecl getReceiverParameter() { return recvparam; }
 913         @DefinedBy(Api.COMPILER_TREE)
 914         public List&lt;JCExpression&gt; getThrows() {
 915             return thrown;
 916         }
 917         @DefinedBy(Api.COMPILER_TREE)
 918         public JCBlock getBody() { return body; }
 919         @DefinedBy(Api.COMPILER_TREE)
 920         public JCTree getDefaultValue() { // for annotation types
 921             return defaultValue;
 922         }
 923         @Override @DefinedBy(Api.COMPILER_TREE)
 924         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 925             return v.visitMethod(this, d);
 926         }
 927 
 928         @Override
 929         public Tag getTag() {
 930             return METHODDEF;
 931         }
 932   }
 933 
 934     /**
 935      * A variable definition.
 936      */
 937     public static class JCVariableDecl extends JCStatement implements VariableTree {
 938         /** variable modifiers */
 939         public JCModifiers mods;
 940         /** variable name */
 941         public Name name;
 942         /** variable name expression */
 943         public JCExpression nameexpr;
 944         /** type of the variable */
 945         public JCExpression vartype;
 946         /** variable&#39;s initial value */
 947         public JCExpression init;
 948         /** symbol */
 949         public VarSymbol sym;
 950         /** explicit start pos */
 951         public int startPos = Position.NOPOS;
 952 
 953         protected JCVariableDecl(JCModifiers mods,
 954                          Name name,
 955                          JCExpression vartype,
 956                          JCExpression init,
 957                          VarSymbol sym) {
 958             this.mods = mods;
 959             this.name = name;
 960             this.vartype = vartype;
 961             this.init = init;
 962             this.sym = sym;
 963         }
 964 
 965         protected JCVariableDecl(JCModifiers mods,
 966                          JCExpression nameexpr,
 967                          JCExpression vartype) {
 968             this(mods, null, vartype, null, null);
 969             this.nameexpr = nameexpr;
 970             if (nameexpr.hasTag(Tag.IDENT)) {
 971                 this.name = ((JCIdent)nameexpr).name;
 972             } else {
 973                 // Only other option is qualified name x.y.this;
 974                 this.name = ((JCFieldAccess)nameexpr).name;
 975             }
 976         }
 977 
 978         public boolean isImplicitlyTyped() {
 979             return vartype == null;
 980         }
 981 
 982         @Override
 983         public void accept(Visitor v) { v.visitVarDef(this); }
 984 
 985         @DefinedBy(Api.COMPILER_TREE)
 986         public Kind getKind() { return Kind.VARIABLE; }
 987         @DefinedBy(Api.COMPILER_TREE)
 988         public JCModifiers getModifiers() { return mods; }
 989         @DefinedBy(Api.COMPILER_TREE)
 990         public Name getName() { return name; }
 991         @DefinedBy(Api.COMPILER_TREE)
 992         public JCExpression getNameExpression() { return nameexpr; }
 993         @DefinedBy(Api.COMPILER_TREE)
 994         public JCTree getType() { return vartype; }
 995         @DefinedBy(Api.COMPILER_TREE)
 996         public JCExpression getInitializer() {
 997             return init;
 998         }
 999         @Override @DefinedBy(Api.COMPILER_TREE)
1000         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1001             return v.visitVariable(this, d);
1002         }
1003 
1004         @Override
1005         public Tag getTag() {
1006             return VARDEF;
1007         }
1008     }
1009 
1010     /**
1011      * A no-op statement &quot;;&quot;.
1012      */
1013     public static class JCSkip extends JCStatement implements EmptyStatementTree {
1014         protected JCSkip() {
1015         }
1016         @Override
1017         public void accept(Visitor v) { v.visitSkip(this); }
1018 
1019         @DefinedBy(Api.COMPILER_TREE)
1020         public Kind getKind() { return Kind.EMPTY_STATEMENT; }
1021         @Override @DefinedBy(Api.COMPILER_TREE)
1022         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1023             return v.visitEmptyStatement(this, d);
1024         }
1025 
1026         @Override
1027         public Tag getTag() {
1028             return SKIP;
1029         }
1030     }
1031 
1032     /**
1033      * A statement block.
1034      */
1035     public static class JCBlock extends JCStatement implements BlockTree {
1036         /** flags */
1037         public long flags;
1038         /** statements */
1039         public List&lt;JCStatement&gt; stats;
1040         /** Position of closing brace, optional. */
1041         public int endpos = Position.NOPOS;
1042         protected JCBlock(long flags, List&lt;JCStatement&gt; stats) {
1043             this.stats = stats;
1044             this.flags = flags;
1045         }
1046         @Override
1047         public void accept(Visitor v) { v.visitBlock(this); }
1048 
1049         @DefinedBy(Api.COMPILER_TREE)
1050         public Kind getKind() { return Kind.BLOCK; }
1051         @DefinedBy(Api.COMPILER_TREE)
1052         public List&lt;JCStatement&gt; getStatements() {
1053             return stats;
1054         }
1055         @DefinedBy(Api.COMPILER_TREE)
1056         public boolean isStatic() { return (flags &amp; Flags.STATIC) != 0; }
1057         @Override @DefinedBy(Api.COMPILER_TREE)
1058         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1059             return v.visitBlock(this, d);
1060         }
1061 
1062         @Override
1063         public Tag getTag() {
1064             return BLOCK;
1065         }
1066     }
1067 
1068     /**
1069      * A do loop
1070      */
1071     public static class JCDoWhileLoop extends JCStatement implements DoWhileLoopTree {
1072         public JCStatement body;
1073         public JCExpression cond;
1074         protected JCDoWhileLoop(JCStatement body, JCExpression cond) {
1075             this.body = body;
1076             this.cond = cond;
1077         }
1078         @Override
1079         public void accept(Visitor v) { v.visitDoLoop(this); }
1080 
1081         @DefinedBy(Api.COMPILER_TREE)
1082         public Kind getKind() { return Kind.DO_WHILE_LOOP; }
1083         @DefinedBy(Api.COMPILER_TREE)
1084         public JCExpression getCondition() { return cond; }
1085         @DefinedBy(Api.COMPILER_TREE)
1086         public JCStatement getStatement() { return body; }
1087         @Override @DefinedBy(Api.COMPILER_TREE)
1088         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1089             return v.visitDoWhileLoop(this, d);
1090         }
1091 
1092         @Override
1093         public Tag getTag() {
1094             return DOLOOP;
1095         }
1096     }
1097 
1098     /**
1099      * A while loop
1100      */
1101     public static class JCWhileLoop extends JCStatement implements WhileLoopTree {
1102         public JCExpression cond;
1103         public JCStatement body;
1104         protected JCWhileLoop(JCExpression cond, JCStatement body) {
1105             this.cond = cond;
1106             this.body = body;
1107         }
1108         @Override
1109         public void accept(Visitor v) { v.visitWhileLoop(this); }
1110 
1111         @DefinedBy(Api.COMPILER_TREE)
1112         public Kind getKind() { return Kind.WHILE_LOOP; }
1113         @DefinedBy(Api.COMPILER_TREE)
1114         public JCExpression getCondition() { return cond; }
1115         @DefinedBy(Api.COMPILER_TREE)
1116         public JCStatement getStatement() { return body; }
1117         @Override @DefinedBy(Api.COMPILER_TREE)
1118         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1119             return v.visitWhileLoop(this, d);
1120         }
1121 
1122         @Override
1123         public Tag getTag() {
1124             return WHILELOOP;
1125         }
1126     }
1127 
1128     /**
1129      * A for loop.
1130      */
1131     public static class JCForLoop extends JCStatement implements ForLoopTree {
1132         public List&lt;JCStatement&gt; init;
1133         public JCExpression cond;
1134         public List&lt;JCExpressionStatement&gt; step;
1135         public JCStatement body;
1136         protected JCForLoop(List&lt;JCStatement&gt; init,
1137                           JCExpression cond,
1138                           List&lt;JCExpressionStatement&gt; update,
1139                           JCStatement body)
1140         {
1141             this.init = init;
1142             this.cond = cond;
1143             this.step = update;
1144             this.body = body;
1145         }
1146         @Override
1147         public void accept(Visitor v) { v.visitForLoop(this); }
1148 
1149         @DefinedBy(Api.COMPILER_TREE)
1150         public Kind getKind() { return Kind.FOR_LOOP; }
1151         @DefinedBy(Api.COMPILER_TREE)
1152         public JCExpression getCondition() { return cond; }
1153         @DefinedBy(Api.COMPILER_TREE)
1154         public JCStatement getStatement() { return body; }
1155         @DefinedBy(Api.COMPILER_TREE)
1156         public List&lt;JCStatement&gt; getInitializer() {
1157             return init;
1158         }
1159         @DefinedBy(Api.COMPILER_TREE)
1160         public List&lt;JCExpressionStatement&gt; getUpdate() {
1161             return step;
1162         }
1163         @Override @DefinedBy(Api.COMPILER_TREE)
1164         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1165             return v.visitForLoop(this, d);
1166         }
1167 
1168         @Override
1169         public Tag getTag() {
1170             return FORLOOP;
1171         }
1172     }
1173 
1174     /**
1175      * The enhanced for loop.
1176      */
1177     public static class JCEnhancedForLoop extends JCStatement implements EnhancedForLoopTree {
1178         public JCVariableDecl var;
1179         public JCExpression expr;
1180         public JCStatement body;
1181         protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
1182             this.var = var;
1183             this.expr = expr;
1184             this.body = body;
1185         }
1186         @Override
1187         public void accept(Visitor v) { v.visitForeachLoop(this); }
1188 
1189         @DefinedBy(Api.COMPILER_TREE)
1190         public Kind getKind() { return Kind.ENHANCED_FOR_LOOP; }
1191         @DefinedBy(Api.COMPILER_TREE)
1192         public JCVariableDecl getVariable() { return var; }
1193         @DefinedBy(Api.COMPILER_TREE)
1194         public JCExpression getExpression() { return expr; }
1195         @DefinedBy(Api.COMPILER_TREE)
1196         public JCStatement getStatement() { return body; }
1197         @Override @DefinedBy(Api.COMPILER_TREE)
1198         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1199             return v.visitEnhancedForLoop(this, d);
1200         }
1201         @Override
1202         public Tag getTag() {
1203             return FOREACHLOOP;
1204         }
1205     }
1206 
1207     /**
1208      * A labelled expression or statement.
1209      */
1210     public static class JCLabeledStatement extends JCStatement implements LabeledStatementTree {
1211         public Name label;
1212         public JCStatement body;
1213         protected JCLabeledStatement(Name label, JCStatement body) {
1214             this.label = label;
1215             this.body = body;
1216         }
1217         @Override
1218         public void accept(Visitor v) { v.visitLabelled(this); }
1219         @DefinedBy(Api.COMPILER_TREE)
1220         public Kind getKind() { return Kind.LABELED_STATEMENT; }
1221         @DefinedBy(Api.COMPILER_TREE)
1222         public Name getLabel() { return label; }
1223         @DefinedBy(Api.COMPILER_TREE)
1224         public JCStatement getStatement() { return body; }
1225         @Override @DefinedBy(Api.COMPILER_TREE)
1226         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1227             return v.visitLabeledStatement(this, d);
1228         }
1229         @Override
1230         public Tag getTag() {
1231             return LABELLED;
1232         }
1233     }
1234 
1235     /**
1236      * A &quot;switch ( ) { }&quot; construction.
1237      */
1238     public static class JCSwitch extends JCStatement implements SwitchTree {
1239         public JCExpression selector;
1240         public List&lt;JCCase&gt; cases;
1241         protected JCSwitch(JCExpression selector, List&lt;JCCase&gt; cases) {
1242             this.selector = selector;
1243             this.cases = cases;
1244         }
1245         @Override
1246         public void accept(Visitor v) { v.visitSwitch(this); }
1247 
1248         @DefinedBy(Api.COMPILER_TREE)
1249         public Kind getKind() { return Kind.SWITCH; }
1250         @DefinedBy(Api.COMPILER_TREE)
1251         public JCExpression getExpression() { return selector; }
1252         @DefinedBy(Api.COMPILER_TREE)
1253         public List&lt;JCCase&gt; getCases() { return cases; }
1254         @Override @DefinedBy(Api.COMPILER_TREE)
1255         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1256             return v.visitSwitch(this, d);
1257         }
1258         @Override
1259         public Tag getTag() {
1260             return SWITCH;
1261         }
1262     }
1263 
1264     /**
1265      * A &quot;case  :&quot; of a switch.
1266      */
1267     public static class JCCase extends JCStatement implements CaseTree {
1268         //as CaseKind is deprecated for removal (as it is part of a preview feature),
1269         //using indirection through these fields to avoid unnecessary @SuppressWarnings:
1270         public static final CaseKind STATEMENT = CaseKind.STATEMENT;
1271         public static final CaseKind RULE = CaseKind.RULE;
1272         public final CaseKind caseKind;
1273         public List&lt;JCExpression&gt; pats;
1274         public List&lt;JCStatement&gt; stats;
1275         public JCTree body;
1276         public boolean completesNormally;
1277         protected JCCase(CaseKind caseKind, List&lt;JCExpression&gt; pats,
1278                          List&lt;JCStatement&gt; stats, JCTree body) {
1279             Assert.checkNonNull(pats);
1280             Assert.check(pats.isEmpty() || pats.head != null);
1281             this.caseKind = caseKind;
1282             this.pats = pats;
1283             this.stats = stats;
1284             this.body = body;
1285         }
1286         @Override
1287         public void accept(Visitor v) { v.visitCase(this); }
1288 
1289         @Override @DefinedBy(Api.COMPILER_TREE)
1290         public Kind getKind() { return Kind.CASE; }
1291         @Override @Deprecated @DefinedBy(Api.COMPILER_TREE)
1292         public JCExpression getExpression() { return pats.head; }
1293         @Override @DefinedBy(Api.COMPILER_TREE)
1294         public List&lt;JCExpression&gt; getExpressions() { return pats; }
1295         @Override @DefinedBy(Api.COMPILER_TREE)
1296         public List&lt;JCStatement&gt; getStatements() {
1297             return caseKind == CaseKind.STATEMENT ? stats : null;
1298         }
1299         @Override @DefinedBy(Api.COMPILER_TREE)
1300         public JCTree getBody() { return body; }
1301         @Override @DefinedBy(Api.COMPILER_TREE)
1302         public CaseKind getCaseKind() {
1303             return caseKind;
1304         }
1305         @Override @DefinedBy(Api.COMPILER_TREE)
1306         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1307             return v.visitCase(this, d);
1308         }
1309         @Override
1310         public Tag getTag() {
1311             return CASE;
1312         }
1313     }
1314 
1315     /**
1316      * A &quot;switch ( ) { }&quot; construction.
1317      */
1318     public static class JCSwitchExpression extends JCPolyExpression implements SwitchExpressionTree {
1319         public JCExpression selector;
1320         public List&lt;JCCase&gt; cases;
1321         /** Position of closing brace, optional. */
1322         public int endpos = Position.NOPOS;
1323         protected JCSwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
1324             this.selector = selector;
1325             this.cases = cases;
1326         }
1327         @Override
1328         public void accept(Visitor v) { v.visitSwitchExpression(this); }
1329 
1330         @DefinedBy(Api.COMPILER_TREE)
1331         public Kind getKind() { return Kind.SWITCH_EXPRESSION; }
1332         @DefinedBy(Api.COMPILER_TREE)
1333         public JCExpression getExpression() { return selector; }
1334         @DefinedBy(Api.COMPILER_TREE)
1335         public List&lt;JCCase&gt; getCases() { return cases; }
1336         @Override @DefinedBy(Api.COMPILER_TREE)
1337         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1338             return v.visitSwitchExpression(this, d);
1339         }
1340         @Override
1341         public Tag getTag() {
1342             return SWITCH_EXPRESSION;
1343         }
1344     }
1345 
1346     /**
1347      * A synchronized block.
1348      */
1349     public static class JCSynchronized extends JCStatement implements SynchronizedTree {
1350         public JCExpression lock;
1351         public JCBlock body;
1352         protected JCSynchronized(JCExpression lock, JCBlock body) {
1353             this.lock = lock;
1354             this.body = body;
1355         }
1356         @Override
1357         public void accept(Visitor v) { v.visitSynchronized(this); }
1358 
1359         @DefinedBy(Api.COMPILER_TREE)
1360         public Kind getKind() { return Kind.SYNCHRONIZED; }
1361         @DefinedBy(Api.COMPILER_TREE)
1362         public JCExpression getExpression() { return lock; }
1363         @DefinedBy(Api.COMPILER_TREE)
1364         public JCBlock getBlock() { return body; }
1365         @Override @DefinedBy(Api.COMPILER_TREE)
1366         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1367             return v.visitSynchronized(this, d);
1368         }
1369         @Override
1370         public Tag getTag() {
1371             return SYNCHRONIZED;
1372         }
1373     }
1374 
1375     /**
1376      * A &quot;try { } catch ( ) { } finally { }&quot; block.
1377      */
1378     public static class JCTry extends JCStatement implements TryTree {
1379         public JCBlock body;
1380         public List&lt;JCCatch&gt; catchers;
1381         public JCBlock finalizer;
1382         public List&lt;JCTree&gt; resources;
1383         public boolean finallyCanCompleteNormally;
1384         protected JCTry(List&lt;JCTree&gt; resources,
1385                         JCBlock body,
1386                         List&lt;JCCatch&gt; catchers,
1387                         JCBlock finalizer) {
1388             this.body = body;
1389             this.catchers = catchers;
1390             this.finalizer = finalizer;
1391             this.resources = resources;
1392         }
1393         @Override
1394         public void accept(Visitor v) { v.visitTry(this); }
1395 
1396         @DefinedBy(Api.COMPILER_TREE)
1397         public Kind getKind() { return Kind.TRY; }
1398         @DefinedBy(Api.COMPILER_TREE)
1399         public JCBlock getBlock() { return body; }
1400         @DefinedBy(Api.COMPILER_TREE)
1401         public List&lt;JCCatch&gt; getCatches() {
1402             return catchers;
1403         }
1404         @DefinedBy(Api.COMPILER_TREE)
1405         public JCBlock getFinallyBlock() { return finalizer; }
1406         @Override @DefinedBy(Api.COMPILER_TREE)
1407         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1408             return v.visitTry(this, d);
1409         }
1410         @Override @DefinedBy(Api.COMPILER_TREE)
1411         public List&lt;JCTree&gt; getResources() {
1412             return resources;
1413         }
1414         @Override
1415         public Tag getTag() {
1416             return TRY;
1417         }
1418     }
1419 
1420     /**
1421      * A catch block.
1422      */
1423     public static class JCCatch extends JCTree implements CatchTree {
1424         public JCVariableDecl param;
1425         public JCBlock body;
1426         protected JCCatch(JCVariableDecl param, JCBlock body) {
1427             this.param = param;
1428             this.body = body;
1429         }
1430         @Override
1431         public void accept(Visitor v) { v.visitCatch(this); }
1432 
1433         @DefinedBy(Api.COMPILER_TREE)
1434         public Kind getKind() { return Kind.CATCH; }
1435         @DefinedBy(Api.COMPILER_TREE)
1436         public JCVariableDecl getParameter() { return param; }
1437         @DefinedBy(Api.COMPILER_TREE)
1438         public JCBlock getBlock() { return body; }
1439         @Override @DefinedBy(Api.COMPILER_TREE)
1440         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1441             return v.visitCatch(this, d);
1442         }
1443         @Override
1444         public Tag getTag() {
1445             return CATCH;
1446         }
1447     }
1448 
1449     /**
1450      * A ( ) ? ( ) : ( ) conditional expression
1451      */
1452     public static class JCConditional extends JCPolyExpression implements ConditionalExpressionTree {
1453         public JCExpression cond;
1454         public JCExpression truepart;
1455         public JCExpression falsepart;
1456         protected JCConditional(JCExpression cond,
1457                               JCExpression truepart,
1458                               JCExpression falsepart)
1459         {
1460             this.cond = cond;
1461             this.truepart = truepart;
1462             this.falsepart = falsepart;
1463         }
1464         @Override
1465         public void accept(Visitor v) { v.visitConditional(this); }
1466 
1467         @DefinedBy(Api.COMPILER_TREE)
1468         public Kind getKind() { return Kind.CONDITIONAL_EXPRESSION; }
1469         @DefinedBy(Api.COMPILER_TREE)
1470         public JCExpression getCondition() { return cond; }
1471         @DefinedBy(Api.COMPILER_TREE)
1472         public JCExpression getTrueExpression() { return truepart; }
1473         @DefinedBy(Api.COMPILER_TREE)
1474         public JCExpression getFalseExpression() { return falsepart; }
1475         @Override @DefinedBy(Api.COMPILER_TREE)
1476         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1477             return v.visitConditionalExpression(this, d);
1478         }
1479         @Override
1480         public Tag getTag() {
1481             return CONDEXPR;
1482         }
1483     }
1484 
1485     /**
1486      * An &quot;if ( ) { } else { }&quot; block
1487      */
1488     public static class JCIf extends JCStatement implements IfTree {
1489         public JCExpression cond;
1490         public JCStatement thenpart;
1491         public JCStatement elsepart;
1492         protected JCIf(JCExpression cond,
1493                      JCStatement thenpart,
1494                      JCStatement elsepart)
1495         {
1496             this.cond = cond;
1497             this.thenpart = thenpart;
1498             this.elsepart = elsepart;
1499         }
1500         @Override
1501         public void accept(Visitor v) { v.visitIf(this); }
1502 
1503         @DefinedBy(Api.COMPILER_TREE)
1504         public Kind getKind() { return Kind.IF; }
1505         @DefinedBy(Api.COMPILER_TREE)
1506         public JCExpression getCondition() { return cond; }
1507         @DefinedBy(Api.COMPILER_TREE)
1508         public JCStatement getThenStatement() { return thenpart; }
1509         @DefinedBy(Api.COMPILER_TREE)
1510         public JCStatement getElseStatement() { return elsepart; }
1511         @Override @DefinedBy(Api.COMPILER_TREE)
1512         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1513             return v.visitIf(this, d);
1514         }
1515         @Override
1516         public Tag getTag() {
1517             return IF;
1518         }
1519     }
1520 
1521     /**
1522      * an expression statement
1523      */
1524     public static class JCExpressionStatement extends JCStatement implements ExpressionStatementTree {
1525         /** expression structure */
1526         public JCExpression expr;
1527         protected JCExpressionStatement(JCExpression expr)
1528         {
1529             this.expr = expr;
1530         }
1531         @Override
1532         public void accept(Visitor v) { v.visitExec(this); }
1533 
1534         @DefinedBy(Api.COMPILER_TREE)
1535         public Kind getKind() { return Kind.EXPRESSION_STATEMENT; }
1536         @DefinedBy(Api.COMPILER_TREE)
1537         public JCExpression getExpression() { return expr; }
1538         @Override @DefinedBy(Api.COMPILER_TREE)
1539         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1540             return v.visitExpressionStatement(this, d);
1541         }
1542         @Override
1543         public Tag getTag() {
1544             return EXEC;
1545         }
1546 
1547         /** Convert a expression-statement tree to a pretty-printed string. */
1548         @Override
1549         public String toString() {
1550             StringWriter s = new StringWriter();
1551             try {
1552                 new Pretty(s, false).printStat(this);
1553             }
1554             catch (IOException e) {
1555                 // should never happen, because StringWriter is defined
1556                 // never to throw any IOExceptions
1557                 throw new AssertionError(e);
1558             }
1559             return s.toString();
1560         }
1561     }
1562 
1563     /**
1564      * A break from a loop or switch.
1565      */
1566     public static class JCBreak extends JCStatement implements BreakTree {
1567         public Name label;
1568         public JCTree target;
1569         protected JCBreak(Name label, JCTree target) {
1570             this.label = label;
1571             this.target = target;
1572         }
1573         @Override
1574         public void accept(Visitor v) { v.visitBreak(this); }
1575         public boolean isValueBreak() {
1576             return target != null &amp;&amp; target.hasTag(SWITCH_EXPRESSION);
1577         }
1578 
1579         @DefinedBy(Api.COMPILER_TREE)
1580         public Kind getKind() { return Kind.BREAK; }
1581         @DefinedBy(Api.COMPILER_TREE)
1582         public Name getLabel() {
1583             return label;
1584         }
1585         @Override @DefinedBy(Api.COMPILER_TREE)
1586         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1587             return v.visitBreak(this, d);
1588         }
1589         @Override
1590         public Tag getTag() {
1591             return BREAK;
1592         }
1593     }
1594 
1595     /**
1596      * A break-with from a switch expression.
1597      */
1598     public static class JCYield extends JCStatement implements YieldTree {
1599         public JCExpression value;
1600         public JCTree target;
1601         protected JCYield(JCExpression value, JCTree target) {
1602             this.value = value;
1603             this.target = target;
1604         }
1605         @Override
1606         public void accept(Visitor v) { v.visitYield(this); }
1607         @DefinedBy(Api.COMPILER_TREE)
1608         public Kind getKind() { return Kind.YIELD; }
1609         @DefinedBy(Api.COMPILER_TREE)
1610         public JCExpression getValue() { return value; }
1611         @Override @DefinedBy(Api.COMPILER_TREE)
1612         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1613             return v.visitYield(this, d);
1614         }
1615         @Override
1616         public Tag getTag() {
1617             return YIELD;
1618         }
1619     }
1620 
1621     /**
1622      * A continue of a loop.
1623      */
1624     public static class JCContinue extends JCStatement implements ContinueTree {
1625         public Name label;
1626         public JCTree target;
1627         protected JCContinue(Name label, JCTree target) {
1628             this.label = label;
1629             this.target = target;
1630         }
1631         @Override
1632         public void accept(Visitor v) { v.visitContinue(this); }
1633 
1634         @DefinedBy(Api.COMPILER_TREE)
1635         public Kind getKind() { return Kind.CONTINUE; }
1636         @DefinedBy(Api.COMPILER_TREE)
1637         public Name getLabel() { return label; }
1638         @Override @DefinedBy(Api.COMPILER_TREE)
1639         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1640             return v.visitContinue(this, d);
1641         }
1642         @Override
1643         public Tag getTag() {
1644             return CONTINUE;
1645         }
1646     }
1647 
1648     /**
1649      * A return statement.
1650      */
1651     public static class JCReturn extends JCStatement implements ReturnTree {
1652         public JCExpression expr;
1653         protected JCReturn(JCExpression expr) {
1654             this.expr = expr;
1655         }
1656         @Override
1657         public void accept(Visitor v) { v.visitReturn(this); }
1658 
1659         @DefinedBy(Api.COMPILER_TREE)
1660         public Kind getKind() { return Kind.RETURN; }
1661         @DefinedBy(Api.COMPILER_TREE)
1662         public JCExpression getExpression() { return expr; }
1663         @Override @DefinedBy(Api.COMPILER_TREE)
1664         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1665             return v.visitReturn(this, d);
1666         }
1667         @Override
1668         public Tag getTag() {
1669             return RETURN;
1670         }
1671     }
1672 
1673     /**
1674      * A throw statement.
1675      */
1676     public static class JCThrow extends JCStatement implements ThrowTree {
1677         public JCExpression expr;
1678         protected JCThrow(JCExpression expr) {
1679             this.expr = expr;
1680         }
1681         @Override
1682         public void accept(Visitor v) { v.visitThrow(this); }
1683 
1684         @DefinedBy(Api.COMPILER_TREE)
1685         public Kind getKind() { return Kind.THROW; }
1686         @DefinedBy(Api.COMPILER_TREE)
1687         public JCExpression getExpression() { return expr; }
1688         @Override @DefinedBy(Api.COMPILER_TREE)
1689         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1690             return v.visitThrow(this, d);
1691         }
1692         @Override
1693         public Tag getTag() {
1694             return THROW;
1695         }
1696     }
1697 
1698     /**
1699      * An assert statement.
1700      */
1701     public static class JCAssert extends JCStatement implements AssertTree {
1702         public JCExpression cond;
1703         public JCExpression detail;
1704         protected JCAssert(JCExpression cond, JCExpression detail) {
1705             this.cond = cond;
1706             this.detail = detail;
1707         }
1708         @Override
1709         public void accept(Visitor v) { v.visitAssert(this); }
1710 
1711         @DefinedBy(Api.COMPILER_TREE)
1712         public Kind getKind() { return Kind.ASSERT; }
1713         @DefinedBy(Api.COMPILER_TREE)
1714         public JCExpression getCondition() { return cond; }
1715         @DefinedBy(Api.COMPILER_TREE)
1716         public JCExpression getDetail() { return detail; }
1717         @Override @DefinedBy(Api.COMPILER_TREE)
1718         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1719             return v.visitAssert(this, d);
1720         }
1721         @Override
1722         public Tag getTag() {
1723             return ASSERT;
1724         }
1725     }
1726 
1727     /**
1728      * A method invocation
1729      */
1730     public static class JCMethodInvocation extends JCPolyExpression implements MethodInvocationTree {
1731         public List&lt;JCExpression&gt; typeargs;
1732         public JCExpression meth;
1733         public List&lt;JCExpression&gt; args;
1734         public Type varargsElement;
1735         protected JCMethodInvocation(List&lt;JCExpression&gt; typeargs,
1736                         JCExpression meth,
1737                         List&lt;JCExpression&gt; args)
1738         {
1739             this.typeargs = (typeargs == null) ? List.nil()
1740                                                : typeargs;
1741             this.meth = meth;
1742             this.args = args;
1743         }
1744         @Override
1745         public void accept(Visitor v) { v.visitApply(this); }
1746 
1747         @DefinedBy(Api.COMPILER_TREE)
1748         public Kind getKind() { return Kind.METHOD_INVOCATION; }
1749         @DefinedBy(Api.COMPILER_TREE)
1750         public List&lt;JCExpression&gt; getTypeArguments() {
1751             return typeargs;
1752         }
1753         @DefinedBy(Api.COMPILER_TREE)
1754         public JCExpression getMethodSelect() { return meth; }
1755         @DefinedBy(Api.COMPILER_TREE)
1756         public List&lt;JCExpression&gt; getArguments() {
1757             return args;
1758         }
1759         @Override @DefinedBy(Api.COMPILER_TREE)
1760         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1761             return v.visitMethodInvocation(this, d);
1762         }
1763         @Override
1764         public JCMethodInvocation setType(Type type) {
1765             super.setType(type);
1766             return this;
1767         }
1768         @Override
1769         public Tag getTag() {
1770             return(APPLY);
1771         }
1772     }
1773 
1774     /**
1775      * A new(...) operation.
1776      */
1777     public static class JCNewClass extends JCPolyExpression implements NewClassTree {
1778         public JCExpression encl;
1779         public List&lt;JCExpression&gt; typeargs;
1780         public JCExpression clazz;
1781         public List&lt;JCExpression&gt; args;
1782         public JCClassDecl def;
1783         public Symbol constructor;
1784         public Type varargsElement;
1785         public Type constructorType;
1786         protected JCNewClass(JCExpression encl,
1787                            List&lt;JCExpression&gt; typeargs,
1788                            JCExpression clazz,
1789                            List&lt;JCExpression&gt; args,
1790                            JCClassDecl def)
1791         {
1792             this.encl = encl;
1793             this.typeargs = (typeargs == null) ? List.nil()
1794                                                : typeargs;
1795             this.clazz = clazz;
1796             this.args = args;
1797             this.def = def;
1798         }
1799         @Override
1800         public void accept(Visitor v) { v.visitNewClass(this); }
1801 
1802         @DefinedBy(Api.COMPILER_TREE)
1803         public Kind getKind() { return Kind.NEW_CLASS; }
1804         @DefinedBy(Api.COMPILER_TREE)
1805         public JCExpression getEnclosingExpression() { // expr.new C&lt; ... &gt; ( ... )
1806             return encl;
1807         }
1808         @DefinedBy(Api.COMPILER_TREE)
1809         public List&lt;JCExpression&gt; getTypeArguments() {
1810             return typeargs;
1811         }
1812         @DefinedBy(Api.COMPILER_TREE)
1813         public JCExpression getIdentifier() { return clazz; }
1814         @DefinedBy(Api.COMPILER_TREE)
1815         public List&lt;JCExpression&gt; getArguments() {
1816             return args;
1817         }
1818         @DefinedBy(Api.COMPILER_TREE)
1819         public JCClassDecl getClassBody() { return def; }
1820         @Override @DefinedBy(Api.COMPILER_TREE)
1821         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1822             return v.visitNewClass(this, d);
1823         }
1824         @Override
1825         public Tag getTag() {
1826             return NEWCLASS;
1827         }
1828 
1829         public boolean classDeclRemoved() {
1830             return false;
1831         }
1832     }
1833 
1834     /**
1835      * A new[...] operation.
1836      */
1837     public static class JCNewArray extends JCExpression implements NewArrayTree {
1838         public JCExpression elemtype;
1839         public List&lt;JCExpression&gt; dims;
1840         // type annotations on inner-most component
1841         public List&lt;JCAnnotation&gt; annotations;
1842         // type annotations on dimensions
1843         public List&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations;
1844         public List&lt;JCExpression&gt; elems;
1845         protected JCNewArray(JCExpression elemtype,
1846                            List&lt;JCExpression&gt; dims,
1847                            List&lt;JCExpression&gt; elems)
1848         {
1849             this.elemtype = elemtype;
1850             this.dims = dims;
1851             this.annotations = List.nil();
1852             this.dimAnnotations = List.nil();
1853             this.elems = elems;
1854         }
1855         @Override
1856         public void accept(Visitor v) { v.visitNewArray(this); }
1857 
1858         @DefinedBy(Api.COMPILER_TREE)
1859         public Kind getKind() { return Kind.NEW_ARRAY; }
1860         @DefinedBy(Api.COMPILER_TREE)
1861         public JCExpression getType() { return elemtype; }
1862         @DefinedBy(Api.COMPILER_TREE)
1863         public List&lt;JCExpression&gt; getDimensions() {
1864             return dims;
1865         }
1866         @DefinedBy(Api.COMPILER_TREE)
1867         public List&lt;JCExpression&gt; getInitializers() {
1868             return elems;
1869         }
1870         @Override @DefinedBy(Api.COMPILER_TREE)
1871         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1872             return v.visitNewArray(this, d);
1873         }
1874         @Override
1875         public Tag getTag() {
1876             return NEWARRAY;
1877         }
1878 
1879         @Override @DefinedBy(Api.COMPILER_TREE)
1880         public List&lt;JCAnnotation&gt; getAnnotations() {
1881             return annotations;
1882         }
1883 
1884         @Override @DefinedBy(Api.COMPILER_TREE)
1885         public List&lt;List&lt;JCAnnotation&gt;&gt; getDimAnnotations() {
1886             return dimAnnotations;
1887         }
1888     }
1889 
1890     /**
1891      * A lambda expression.
1892      */
1893     public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {
1894 
1895         public enum ParameterKind {
1896             IMPLICIT,
1897             EXPLICIT
1898         }
1899 
1900         public List&lt;JCVariableDecl&gt; params;
1901         public JCTree body;
1902         public boolean canCompleteNormally = true;
1903         public ParameterKind paramKind;
1904 
1905         public JCLambda(List&lt;JCVariableDecl&gt; params,
1906                         JCTree body) {
1907             this.params = params;
1908             this.body = body;
1909             if (params.isEmpty() ||
1910                 params.head.vartype != null) {
1911                 paramKind = ParameterKind.EXPLICIT;
1912             } else {
1913                 paramKind = ParameterKind.IMPLICIT;
1914             }
1915         }
1916         @Override
1917         public Tag getTag() {
1918             return LAMBDA;
1919         }
1920         @Override
1921         public void accept(Visitor v) {
1922             v.visitLambda(this);
1923         }
1924         @Override @DefinedBy(Api.COMPILER_TREE)
1925         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
1926             return v.visitLambdaExpression(this, d);
1927         }
1928         @DefinedBy(Api.COMPILER_TREE)
1929         public Kind getKind() {
1930             return Kind.LAMBDA_EXPRESSION;
1931         }
1932         @DefinedBy(Api.COMPILER_TREE)
1933         public JCTree getBody() {
1934             return body;
1935         }
1936         @DefinedBy(Api.COMPILER_TREE)
1937         public java.util.List&lt;? extends VariableTree&gt; getParameters() {
1938             return params;
1939         }
1940         @Override
1941         public JCLambda setType(Type type) {
1942             super.setType(type);
1943             return this;
1944         }
1945         @Override @DefinedBy(Api.COMPILER_TREE)
1946         public BodyKind getBodyKind() {
1947             return body.hasTag(BLOCK) ?
1948                     BodyKind.STATEMENT :
1949                     BodyKind.EXPRESSION;
1950         }
1951     }
1952 
1953     /**
1954      * A parenthesized subexpression ( ... )
1955      */
1956     public static class JCParens extends JCExpression implements ParenthesizedTree {
1957         public JCExpression expr;
1958         protected JCParens(JCExpression expr) {
1959             this.expr = expr;
1960         }
1961         @Override
1962         public void accept(Visitor v) { v.visitParens(this); }
1963 
1964         @DefinedBy(Api.COMPILER_TREE)
1965         public Kind getKind() { return Kind.PARENTHESIZED; }
1966         @DefinedBy(Api.COMPILER_TREE)
1967         public JCExpression getExpression() { return expr; }
1968         @Override @DefinedBy(Api.COMPILER_TREE)
1969         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1970             return v.visitParenthesized(this, d);
1971         }
1972         @Override
1973         public Tag getTag() {
1974             return PARENS;
1975         }
1976     }
1977 
1978     /**
1979      * A assignment with &quot;=&quot;.
1980      */
1981     public static class JCAssign extends JCExpression implements AssignmentTree {
1982         public JCExpression lhs;
1983         public JCExpression rhs;
1984         protected JCAssign(JCExpression lhs, JCExpression rhs) {
1985             this.lhs = lhs;
1986             this.rhs = rhs;
1987         }
1988         @Override
1989         public void accept(Visitor v) { v.visitAssign(this); }
1990 
1991         @DefinedBy(Api.COMPILER_TREE)
1992         public Kind getKind() { return Kind.ASSIGNMENT; }
1993         @DefinedBy(Api.COMPILER_TREE)
1994         public JCExpression getVariable() { return lhs; }
1995         @DefinedBy(Api.COMPILER_TREE)
1996         public JCExpression getExpression() { return rhs; }
1997         @Override @DefinedBy(Api.COMPILER_TREE)
1998         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1999             return v.visitAssignment(this, d);
2000         }
2001         @Override
2002         public Tag getTag() {
2003             return ASSIGN;
2004         }
2005     }
2006 
2007     public static abstract class JCOperatorExpression extends JCExpression {
2008         public enum OperandPos {
2009             LEFT,
2010             RIGHT
2011         }
2012 
2013         protected Tag opcode;
2014         public OperatorSymbol operator;
2015 
2016         public OperatorSymbol getOperator() {
2017             return operator;
2018         }
2019 
2020         @Override
2021         public Tag getTag() {
2022             return opcode;
2023         }
2024 
2025         public abstract JCExpression getOperand(OperandPos pos);
2026     }
2027 
2028     /**
2029      * An assignment with &quot;+=&quot;, &quot;|=&quot; ...
2030      */
2031     public static class JCAssignOp extends JCOperatorExpression implements CompoundAssignmentTree {
2032         public JCExpression lhs;
2033         public JCExpression rhs;
2034         protected JCAssignOp(Tag opcode, JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2035             this.opcode = opcode;
2036             this.lhs = (JCExpression)lhs;
2037             this.rhs = (JCExpression)rhs;
2038             this.operator = operator;
2039         }
2040         @Override
2041         public void accept(Visitor v) { v.visitAssignop(this); }
2042 
2043         @DefinedBy(Api.COMPILER_TREE)
2044         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2045         @DefinedBy(Api.COMPILER_TREE)
2046         public JCExpression getVariable() { return lhs; }
2047         @DefinedBy(Api.COMPILER_TREE)
2048         public JCExpression getExpression() { return rhs; }
2049         @Override @DefinedBy(Api.COMPILER_TREE)
2050         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2051             return v.visitCompoundAssignment(this, d);
2052         }
2053         @Override
2054         public JCExpression getOperand(OperandPos pos) {
2055             return pos == OperandPos.LEFT ? lhs : rhs;
2056         }
2057     }
2058 
2059     /**
2060      * A unary operation.
2061      */
2062     public static class JCUnary extends JCOperatorExpression implements UnaryTree {
2063         public JCExpression arg;
2064         protected JCUnary(Tag opcode, JCExpression arg) {
2065             this.opcode = opcode;
2066             this.arg = arg;
2067         }
2068         @Override
2069         public void accept(Visitor v) { v.visitUnary(this); }
2070 
2071         @DefinedBy(Api.COMPILER_TREE)
2072         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2073         @DefinedBy(Api.COMPILER_TREE)
2074         public JCExpression getExpression() { return arg; }
2075         @Override @DefinedBy(Api.COMPILER_TREE)
2076         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2077             return v.visitUnary(this, d);
2078         }
2079         public void setTag(Tag tag) {
2080             opcode = tag;
2081         }
2082         @Override
2083         public JCExpression getOperand(OperandPos pos) {
2084             return arg;
2085         }
2086     }
2087 
2088     /**
2089      * A binary operation.
2090      */
2091     public static class JCBinary extends JCOperatorExpression implements BinaryTree {
2092         public JCExpression lhs;
2093         public JCExpression rhs;
2094         protected JCBinary(Tag opcode,
2095                          JCExpression lhs,
2096                          JCExpression rhs,
2097                          OperatorSymbol operator) {
2098             this.opcode = opcode;
2099             this.lhs = lhs;
2100             this.rhs = rhs;
2101             this.operator = operator;
2102         }
2103         @Override
2104         public void accept(Visitor v) { v.visitBinary(this); }
2105 
2106         @DefinedBy(Api.COMPILER_TREE)
2107         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2108         @DefinedBy(Api.COMPILER_TREE)
2109         public JCExpression getLeftOperand() { return lhs; }
2110         @DefinedBy(Api.COMPILER_TREE)
2111         public JCExpression getRightOperand() { return rhs; }
2112         @Override @DefinedBy(Api.COMPILER_TREE)
2113         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2114             return v.visitBinary(this, d);
2115         }
2116         @Override
2117         public JCExpression getOperand(OperandPos pos) {
2118             return pos == OperandPos.LEFT ? lhs : rhs;
2119         }
2120     }
2121 
2122     /**
2123      * A type cast.
2124      */
2125     public static class JCTypeCast extends JCExpression implements TypeCastTree {
2126         public JCTree clazz;
2127         public JCExpression expr;
2128         protected JCTypeCast(JCTree clazz, JCExpression expr) {
2129             this.clazz = clazz;
2130             this.expr = expr;
2131         }
2132         @Override
2133         public void accept(Visitor v) { v.visitTypeCast(this); }
2134 
2135         @DefinedBy(Api.COMPILER_TREE)
2136         public Kind getKind() { return Kind.TYPE_CAST; }
2137         @DefinedBy(Api.COMPILER_TREE)
2138         public JCTree getType() { return clazz; }
2139         @DefinedBy(Api.COMPILER_TREE)
2140         public JCExpression getExpression() { return expr; }
2141         @Override @DefinedBy(Api.COMPILER_TREE)
2142         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2143             return v.visitTypeCast(this, d);
2144         }
2145         @Override
2146         public Tag getTag() {
2147             return TYPECAST;
2148         }
2149     }
2150 
2151     /**
2152      * A type test.
2153      */
2154     public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
2155         public JCExpression expr;
2156         public JCTree pattern;
2157         protected JCInstanceOf(JCExpression expr, JCTree pattern) {
2158             this.expr = expr;
2159             this.pattern = pattern;
2160         }
2161         @Override
2162         public void accept(Visitor v) { v.visitTypeTest(this); }
2163 
2164         @DefinedBy(Api.COMPILER_TREE)
2165         public Kind getKind() { return Kind.INSTANCE_OF; }
2166         @DefinedBy(Api.COMPILER_TREE)
2167         public JCTree getType() { return pattern instanceof JCPattern ? pattern.hasTag(BINDINGPATTERN) ? ((JCBindingPattern) pattern).vartype : null : pattern; }
2168 
2169         @Override @DefinedBy(Api.COMPILER_TREE)
2170         public JCPattern getPattern() {
2171             return pattern instanceof JCPattern ? (JCPattern) pattern : null;
2172         }
2173 
2174         @DefinedBy(Api.COMPILER_TREE)
2175         public JCExpression getExpression() { return expr; }
2176         @Override @DefinedBy(Api.COMPILER_TREE)
2177         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2178             return v.visitInstanceOf(this, d);
2179         }
2180         @Override
2181         public Tag getTag() {
2182             return TYPETEST;
2183         }
2184     }
2185 
2186     /**
2187      * Pattern matching forms.
2188      */
2189     public static abstract class JCPattern extends JCTree
2190             implements PatternTree {
2191         public JCExpression constExpression() {
2192             return null;
2193         }
2194     }
2195 
2196     public static class JCBindingPattern extends JCPattern
2197             implements BindingPatternTree {
2198         public Name name;
2199         public BindingSymbol symbol;
2200         public JCTree vartype;
2201 
2202         protected JCBindingPattern(Name name, BindingSymbol symbol, JCTree vartype) {
2203             this.name = name;
2204             this.symbol = symbol;
2205             this.vartype = vartype;
2206         }
2207 
2208         @DefinedBy(Api.COMPILER_TREE)
2209         public Name getBinding() {
2210             return name;
2211         }
2212 
2213         @Override @DefinedBy(Api.COMPILER_TREE)
2214         public Tree getType() {
2215             return vartype;
2216         }
2217 
2218         @Override
2219         public void accept(Visitor v) {
2220             v.visitBindingPattern(this);
2221         }
2222 
2223         @DefinedBy(Api.COMPILER_TREE)
2224         public Kind getKind() {
2225             return Kind.BINDING_PATTERN;
2226         }
2227 
2228         @Override
2229         @DefinedBy(Api.COMPILER_TREE)
2230         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2231             return v.visitBindingPattern(this, d);
2232         }
2233 
2234         @Override
2235         public Tag getTag() {
2236             return BINDINGPATTERN;
2237         }
2238     }
2239 
2240     /**
2241      * An array selection
2242      */
2243     public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
2244         public JCExpression indexed;
2245         public JCExpression index;
2246         protected JCArrayAccess(JCExpression indexed, JCExpression index) {
2247             this.indexed = indexed;
2248             this.index = index;
2249         }
2250         @Override
2251         public void accept(Visitor v) { v.visitIndexed(this); }
2252 
2253         @DefinedBy(Api.COMPILER_TREE)
2254         public Kind getKind() { return Kind.ARRAY_ACCESS; }
2255         @DefinedBy(Api.COMPILER_TREE)
2256         public JCExpression getExpression() { return indexed; }
2257         @DefinedBy(Api.COMPILER_TREE)
2258         public JCExpression getIndex() { return index; }
2259         @Override @DefinedBy(Api.COMPILER_TREE)
2260         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2261             return v.visitArrayAccess(this, d);
2262         }
2263         @Override
2264         public Tag getTag() {
2265             return INDEXED;
2266         }
2267     }
2268 
2269     /**
2270      * Selects through packages and classes
2271      */
2272     public static class JCFieldAccess extends JCExpression implements MemberSelectTree {
2273         /** selected Tree hierarchy */
2274         public JCExpression selected;
2275         /** name of field to select thru */
2276         public Name name;
2277         /** symbol of the selected class */
2278         public Symbol sym;
2279         protected JCFieldAccess(JCExpression selected, Name name, Symbol sym) {
2280             this.selected = selected;
2281             this.name = name;
2282             this.sym = sym;
2283         }
2284         @Override
2285         public void accept(Visitor v) { v.visitSelect(this); }
2286 
2287         @DefinedBy(Api.COMPILER_TREE)
2288         public Kind getKind() { return Kind.MEMBER_SELECT; }
2289         @DefinedBy(Api.COMPILER_TREE)
2290         public JCExpression getExpression() { return selected; }
2291         @Override @DefinedBy(Api.COMPILER_TREE)
2292         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2293             return v.visitMemberSelect(this, d);
2294         }
2295         @DefinedBy(Api.COMPILER_TREE)
2296         public Name getIdentifier() { return name; }
2297         @Override
2298         public Tag getTag() {
2299             return SELECT;
2300         }
2301     }
2302 
2303     /**
2304      * Selects a member expression.
2305      */
2306     public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {
2307 
2308         public ReferenceMode mode;
2309         public ReferenceKind kind;
2310         public Name name;
2311         public JCExpression expr;
2312         public List&lt;JCExpression&gt; typeargs;
2313         public Symbol sym;
2314         public Type varargsElement;
2315         public PolyKind refPolyKind;
2316         public boolean ownerAccessible;
2317         private OverloadKind overloadKind;
2318         public Type referentType;
2319 
2320         public enum OverloadKind {
2321             OVERLOADED,
2322             UNOVERLOADED,
2323             ERROR
2324         }
2325 
2326         /**
2327          * Javac-dependent classification for member references, based
2328          * on relevant properties w.r.t. code-generation
2329          */
2330         public enum ReferenceKind {
2331             /** super # instMethod */
2332             SUPER(ReferenceMode.INVOKE, false),
2333             /** Type # instMethod */
2334             UNBOUND(ReferenceMode.INVOKE, true),
2335             /** Type # staticMethod */
2336             STATIC(ReferenceMode.INVOKE, false),
2337             /** Expr # instMethod */
2338             BOUND(ReferenceMode.INVOKE, false),
2339             /** Inner # new */
2340             IMPLICIT_INNER(ReferenceMode.NEW, false),
2341             /** Toplevel # new */
2342             TOPLEVEL(ReferenceMode.NEW, false),
2343             /** ArrayType # new */
2344             ARRAY_CTOR(ReferenceMode.NEW, false);
2345 
2346             final ReferenceMode mode;
2347             final boolean unbound;
2348 
2349             private ReferenceKind(ReferenceMode mode, boolean unbound) {
2350                 this.mode = mode;
2351                 this.unbound = unbound;
2352             }
2353 
2354             public boolean isUnbound() {
2355                 return unbound;
2356             }
2357         }
2358 
2359         public JCMemberReference(ReferenceMode mode, Name name, JCExpression expr, List&lt;JCExpression&gt; typeargs) {
2360             this.mode = mode;
2361             this.name = name;
2362             this.expr = expr;
2363             this.typeargs = typeargs;
2364         }
2365         @Override
2366         public void accept(Visitor v) { v.visitReference(this); }
2367 
2368         @DefinedBy(Api.COMPILER_TREE)
2369         public Kind getKind() { return Kind.MEMBER_REFERENCE; }
2370         @Override @DefinedBy(Api.COMPILER_TREE)
2371         public ReferenceMode getMode() { return mode; }
2372         @Override @DefinedBy(Api.COMPILER_TREE)
2373         public JCExpression getQualifierExpression() { return expr; }
2374         @Override @DefinedBy(Api.COMPILER_TREE)
2375         public Name getName() { return name; }
2376         @Override @DefinedBy(Api.COMPILER_TREE)
2377         public List&lt;JCExpression&gt; getTypeArguments() { return typeargs; }
2378 
2379         @Override @DefinedBy(Api.COMPILER_TREE)
2380         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2381             return v.visitMemberReference(this, d);
2382         }
2383         @Override
2384         public Tag getTag() {
2385             return REFERENCE;
2386         }
2387         public boolean hasKind(ReferenceKind kind) {
2388             return this.kind == kind;
2389         }
2390 
2391         /**
2392          * @return the overloadKind
2393          */
2394         public OverloadKind getOverloadKind() {
2395             return overloadKind;
2396         }
2397 
2398         /**
2399          * @param overloadKind the overloadKind to set
2400          */
2401         public void setOverloadKind(OverloadKind overloadKind) {
2402             this.overloadKind = overloadKind;
2403         }
2404     }
2405 
2406     /**
2407      * An identifier
2408      */
2409     public static class JCIdent extends JCExpression implements IdentifierTree {
2410         /** the name */
2411         public Name name;
2412         /** the symbol */
2413         public Symbol sym;
2414         protected JCIdent(Name name, Symbol sym) {
2415             this.name = name;
2416             this.sym = sym;
2417         }
2418         @Override
2419         public void accept(Visitor v) { v.visitIdent(this); }
2420 
2421         @DefinedBy(Api.COMPILER_TREE)
2422         public Kind getKind() { return Kind.IDENTIFIER; }
2423         @DefinedBy(Api.COMPILER_TREE)
2424         public Name getName() { return name; }
2425         @Override @DefinedBy(Api.COMPILER_TREE)
2426         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2427             return v.visitIdentifier(this, d);
2428         }
2429         @Override
2430         public Tag getTag() {
2431             return IDENT;
2432         }
2433     }
2434 
2435     /**
2436      * A constant value given literally.
2437      */
2438     public static class JCLiteral extends JCExpression implements LiteralTree {
2439         public TypeTag typetag;
2440         /** value representation */
2441         public Object value;
2442         protected JCLiteral(TypeTag typetag, Object value) {
2443             this.typetag = typetag;
2444             this.value = value;
2445         }
2446         @Override
2447         public void accept(Visitor v) { v.visitLiteral(this); }
2448 
2449         @DefinedBy(Api.COMPILER_TREE)
2450         public Kind getKind() {
2451             return typetag.getKindLiteral();
2452         }
2453 
2454         @DefinedBy(Api.COMPILER_TREE)
2455         public Object getValue() {
2456             switch (typetag) {
2457                 case BOOLEAN:
2458                     int bi = (Integer) value;
2459                     return (bi != 0);
2460                 case CHAR:
2461                     int ci = (Integer) value;
2462                     char c = (char) ci;
2463                     if (c != ci)
2464                         throw new AssertionError(&quot;bad value for char literal&quot;);
2465                     return c;
2466                 default:
2467                     return value;
2468             }
2469         }
2470         @Override @DefinedBy(Api.COMPILER_TREE)
2471         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2472             return v.visitLiteral(this, d);
2473         }
2474         @Override
2475         public JCLiteral setType(Type type) {
2476             super.setType(type);
2477             return this;
2478         }
2479         @Override
2480         public Tag getTag() {
2481             return LITERAL;
2482         }
2483     }
2484 
2485     /**
2486      * Identifies a basic type.
2487      * @see TypeTag
2488      */
2489     public static class JCPrimitiveTypeTree extends JCExpression implements PrimitiveTypeTree {
2490         /** the basic type id */
2491         public TypeTag typetag;
2492         protected JCPrimitiveTypeTree(TypeTag typetag) {
2493             this.typetag = typetag;
2494         }
2495         @Override
2496         public void accept(Visitor v) { v.visitTypeIdent(this); }
2497 
2498         @DefinedBy(Api.COMPILER_TREE)
2499         public Kind getKind() { return Kind.PRIMITIVE_TYPE; }
2500         @DefinedBy(Api.COMPILER_TREE)
2501         public TypeKind getPrimitiveTypeKind() {
2502             return typetag.getPrimitiveTypeKind();
2503         }
2504 
2505         @Override @DefinedBy(Api.COMPILER_TREE)
2506         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2507             return v.visitPrimitiveType(this, d);
2508         }
2509         @Override
2510         public Tag getTag() {
2511             return TYPEIDENT;
2512         }
2513     }
2514 
2515     /**
2516      * An array type, A[]
2517      */
2518     public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {
2519         public JCExpression elemtype;
2520         protected JCArrayTypeTree(JCExpression elemtype) {
2521             this.elemtype = elemtype;
2522         }
2523         @Override
2524         public void accept(Visitor v) { v.visitTypeArray(this); }
2525 
2526         @DefinedBy(Api.COMPILER_TREE)
2527         public Kind getKind() { return Kind.ARRAY_TYPE; }
2528         @DefinedBy(Api.COMPILER_TREE)
2529         public JCTree getType() { return elemtype; }
2530         @Override @DefinedBy(Api.COMPILER_TREE)
2531         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2532             return v.visitArrayType(this, d);
2533         }
2534         @Override
2535         public Tag getTag() {
2536             return TYPEARRAY;
2537         }
2538     }
2539 
2540     /**
2541      * A parameterized type, {@literal T&lt;...&gt;}
2542      */
2543     public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {
2544         public JCExpression clazz;
2545         public List&lt;JCExpression&gt; arguments;
2546         protected JCTypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
2547             this.clazz = clazz;
2548             this.arguments = arguments;
2549         }
2550         @Override
2551         public void accept(Visitor v) { v.visitTypeApply(this); }
2552 
2553         @DefinedBy(Api.COMPILER_TREE)
2554         public Kind getKind() { return Kind.PARAMETERIZED_TYPE; }
2555         @DefinedBy(Api.COMPILER_TREE)
2556         public JCTree getType() { return clazz; }
2557         @DefinedBy(Api.COMPILER_TREE)
2558         public List&lt;JCExpression&gt; getTypeArguments() {
2559             return arguments;
2560         }
2561         @Override @DefinedBy(Api.COMPILER_TREE)
2562         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2563             return v.visitParameterizedType(this, d);
2564         }
2565         @Override
2566         public Tag getTag() {
2567             return TYPEAPPLY;
2568         }
2569     }
2570 
2571     /**
2572      * A union type, T1 | T2 | ... Tn (used in multicatch statements)
2573      */
2574     public static class JCTypeUnion extends JCExpression implements UnionTypeTree {
2575 
2576         public List&lt;JCExpression&gt; alternatives;
2577 
2578         protected JCTypeUnion(List&lt;JCExpression&gt; components) {
2579             this.alternatives = components;
2580         }
2581         @Override
2582         public void accept(Visitor v) { v.visitTypeUnion(this); }
2583 
2584         @DefinedBy(Api.COMPILER_TREE)
2585         public Kind getKind() { return Kind.UNION_TYPE; }
2586 
2587         @DefinedBy(Api.COMPILER_TREE)
2588         public List&lt;JCExpression&gt; getTypeAlternatives() {
2589             return alternatives;
2590         }
2591         @Override @DefinedBy(Api.COMPILER_TREE)
2592         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2593             return v.visitUnionType(this, d);
2594         }
2595         @Override
2596         public Tag getTag() {
2597             return TYPEUNION;
2598         }
2599     }
2600 
2601     /**
2602      * An intersection type, {@code T1 &amp; T2 &amp; ... Tn} (used in cast expressions)
2603      */
2604     public static class JCTypeIntersection extends JCExpression implements IntersectionTypeTree {
2605 
2606         public List&lt;JCExpression&gt; bounds;
2607 
2608         protected JCTypeIntersection(List&lt;JCExpression&gt; bounds) {
2609             this.bounds = bounds;
2610         }
2611         @Override
2612         public void accept(Visitor v) { v.visitTypeIntersection(this); }
2613 
2614         @DefinedBy(Api.COMPILER_TREE)
2615         public Kind getKind() { return Kind.INTERSECTION_TYPE; }
2616 
2617         @DefinedBy(Api.COMPILER_TREE)
2618         public List&lt;JCExpression&gt; getBounds() {
2619             return bounds;
2620         }
2621         @Override @DefinedBy(Api.COMPILER_TREE)
2622         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2623             return v.visitIntersectionType(this, d);
2624         }
2625         @Override
2626         public Tag getTag() {
2627             return TYPEINTERSECTION;
2628         }
2629     }
2630 
2631     /**
2632      * A formal class parameter.
2633      */
2634     public static class JCTypeParameter extends JCTree implements TypeParameterTree {
2635         /** name */
2636         public Name name;
2637         /** bounds */
2638         public List&lt;JCExpression&gt; bounds;
2639         /** type annotations on type parameter */
2640         public List&lt;JCAnnotation&gt; annotations;
2641         protected JCTypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annotations) {
2642             this.name = name;
2643             this.bounds = bounds;
2644             this.annotations = annotations;
2645         }
2646         @Override
2647         public void accept(Visitor v) { v.visitTypeParameter(this); }
2648 
2649         @DefinedBy(Api.COMPILER_TREE)
2650         public Kind getKind() { return Kind.TYPE_PARAMETER; }
2651         @DefinedBy(Api.COMPILER_TREE)
2652         public Name getName() { return name; }
2653         @DefinedBy(Api.COMPILER_TREE)
2654         public List&lt;JCExpression&gt; getBounds() {
2655             return bounds;
2656         }
2657         @DefinedBy(Api.COMPILER_TREE)
2658         public List&lt;JCAnnotation&gt; getAnnotations() {
2659             return annotations;
2660         }
2661         @Override @DefinedBy(Api.COMPILER_TREE)
2662         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2663             return v.visitTypeParameter(this, d);
2664         }
2665         @Override
2666         public Tag getTag() {
2667             return TYPEPARAMETER;
2668         }
2669     }
2670 
2671     public static class JCWildcard extends JCExpression implements WildcardTree {
2672         public TypeBoundKind kind;
2673         public JCTree inner;
2674         protected JCWildcard(TypeBoundKind kind, JCTree inner) {
2675             this.kind = Assert.checkNonNull(kind);
2676             this.inner = inner;
2677         }
2678         @Override
2679         public void accept(Visitor v) { v.visitWildcard(this); }
2680 
2681         @DefinedBy(Api.COMPILER_TREE)
2682         public Kind getKind() {
2683             switch (kind.kind) {
2684             case UNBOUND:
2685                 return Kind.UNBOUNDED_WILDCARD;
2686             case EXTENDS:
2687                 return Kind.EXTENDS_WILDCARD;
2688             case SUPER:
2689                 return Kind.SUPER_WILDCARD;
2690             default:
2691                 throw new AssertionError(&quot;Unknown wildcard bound &quot; + kind);
2692             }
2693         }
2694         @DefinedBy(Api.COMPILER_TREE)
2695         public JCTree getBound() { return inner; }
2696         @Override @DefinedBy(Api.COMPILER_TREE)
2697         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2698             return v.visitWildcard(this, d);
2699         }
2700         @Override
2701         public Tag getTag() {
2702             return Tag.WILDCARD;
2703         }
2704     }
2705 
2706     public static class TypeBoundKind extends JCTree {
2707         public BoundKind kind;
2708         protected TypeBoundKind(BoundKind kind) {
2709             this.kind = kind;
2710         }
2711         @Override
2712         public void accept(Visitor v) { v.visitTypeBoundKind(this); }
2713 
2714         @DefinedBy(Api.COMPILER_TREE)
2715         public Kind getKind() {
2716             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2717         }
2718         @Override @DefinedBy(Api.COMPILER_TREE)
2719         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2720             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2721         }
2722         @Override
2723         public Tag getTag() {
2724             return TYPEBOUNDKIND;
2725         }
2726     }
2727 
2728     public static class JCAnnotation extends JCExpression implements AnnotationTree {
2729         // Either Tag.ANNOTATION or Tag.TYPE_ANNOTATION
2730         private Tag tag;
2731 
2732         public JCTree annotationType;
2733         public List&lt;JCExpression&gt; args;
2734         public Attribute.Compound attribute;
2735 
2736         protected JCAnnotation(Tag tag, JCTree annotationType, List&lt;JCExpression&gt; args) {
2737             this.tag = tag;
2738             this.annotationType = annotationType;
2739             this.args = args;
2740         }
2741 
2742         @Override
2743         public void accept(Visitor v) { v.visitAnnotation(this); }
2744 
2745         @DefinedBy(Api.COMPILER_TREE)
2746         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2747 
2748         @DefinedBy(Api.COMPILER_TREE)
2749         public JCTree getAnnotationType() { return annotationType; }
2750         @DefinedBy(Api.COMPILER_TREE)
2751         public List&lt;JCExpression&gt; getArguments() {
2752             return args;
2753         }
2754         @Override @DefinedBy(Api.COMPILER_TREE)
2755         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2756             return v.visitAnnotation(this, d);
2757         }
2758         @Override
2759         public Tag getTag() {
2760             return tag;
2761         }
2762     }
2763 
2764     public static class JCModifiers extends JCTree implements com.sun.source.tree.ModifiersTree {
2765         public long flags;
2766         public List&lt;JCAnnotation&gt; annotations;
2767         protected JCModifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
2768             this.flags = flags;
2769             this.annotations = annotations;
2770         }
2771         @Override
2772         public void accept(Visitor v) { v.visitModifiers(this); }
2773 
2774         @DefinedBy(Api.COMPILER_TREE)
2775         public Kind getKind() { return Kind.MODIFIERS; }
2776         @DefinedBy(Api.COMPILER_TREE)
2777         public Set&lt;Modifier&gt; getFlags() {
2778             return Flags.asModifierSet(flags);
2779         }
2780         @DefinedBy(Api.COMPILER_TREE)
2781         public List&lt;JCAnnotation&gt; getAnnotations() {
2782             return annotations;
2783         }
2784         @Override @DefinedBy(Api.COMPILER_TREE)
2785         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2786             return v.visitModifiers(this, d);
2787         }
2788         @Override
2789         public Tag getTag() {
2790             return MODIFIERS;
2791         }
2792     }
2793 
2794     public static class JCAnnotatedType extends JCExpression implements com.sun.source.tree.AnnotatedTypeTree {
2795         // type annotations
2796         public List&lt;JCAnnotation&gt; annotations;
2797         public JCExpression underlyingType;
2798 
2799         protected JCAnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
2800             Assert.check(annotations != null &amp;&amp; annotations.nonEmpty());
2801             this.annotations = annotations;
2802             this.underlyingType = underlyingType;
2803         }
2804         @Override
2805         public void accept(Visitor v) { v.visitAnnotatedType(this); }
2806 
2807         @DefinedBy(Api.COMPILER_TREE)
2808         public Kind getKind() { return Kind.ANNOTATED_TYPE; }
2809         @DefinedBy(Api.COMPILER_TREE)
2810         public List&lt;JCAnnotation&gt; getAnnotations() {
2811             return annotations;
2812         }
2813         @DefinedBy(Api.COMPILER_TREE)
2814         public JCExpression getUnderlyingType() {
2815             return underlyingType;
2816         }
2817         @Override @DefinedBy(Api.COMPILER_TREE)
2818         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2819             return v.visitAnnotatedType(this, d);
2820         }
2821         @Override
2822         public Tag getTag() {
2823             return ANNOTATED_TYPE;
2824         }
2825     }
2826 
2827     public static abstract class JCDirective extends JCTree
2828         implements DirectiveTree {
2829     }
2830 
2831     public static class JCModuleDecl extends JCTree implements ModuleTree {
2832         public JCModifiers mods;
2833         public ModuleType type;
2834         private final ModuleKind kind;
2835         public JCExpression qualId;
2836         public List&lt;JCDirective&gt; directives;
2837         public ModuleSymbol sym;
2838 
2839         protected JCModuleDecl(JCModifiers mods, ModuleKind kind,
2840                 JCExpression qualId, List&lt;JCDirective&gt; directives) {
2841             this.mods = mods;
2842             this.kind = kind;
2843             this.qualId = qualId;
2844             this.directives = directives;
2845         }
2846 
2847         @Override
2848         public void accept(Visitor v) { v.visitModuleDef(this); }
2849 
2850         @Override @DefinedBy(Api.COMPILER_TREE)
2851         public Kind getKind() {
2852             return Kind.MODULE;
2853         }
2854 
2855         @Override @DefinedBy(Api.COMPILER_TREE)
2856         public List&lt;? extends AnnotationTree&gt; getAnnotations() {
2857             return mods.annotations;
2858         }
2859 
2860         @Override @DefinedBy(Api.COMPILER_TREE)
2861         public ModuleKind getModuleType() {
2862             return kind;
2863         }
2864 
2865         @Override @DefinedBy(Api.COMPILER_TREE)
2866         public JCExpression getName() {
2867             return qualId;
2868         }
2869 
2870         @Override @DefinedBy(Api.COMPILER_TREE)
2871         public List&lt;JCDirective&gt; getDirectives() {
2872             return directives;
2873         }
2874 
2875         @Override @DefinedBy(Api.COMPILER_TREE)
2876         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2877             return v.visitModule(this, d);
2878         }
2879 
2880         @Override
2881         public Tag getTag() {
2882             return MODULEDEF;
2883         }
2884     }
2885 
2886     public static class JCExports extends JCDirective
2887             implements ExportsTree {
2888         public JCExpression qualid;
2889         public List&lt;JCExpression&gt; moduleNames;
2890         public ExportsDirective directive;
2891 
2892         protected JCExports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2893             this.qualid = qualId;
2894             this.moduleNames = moduleNames;
2895         }
2896 
2897         @Override
2898         public void accept(Visitor v) { v.visitExports(this); }
2899 
2900         @Override @DefinedBy(Api.COMPILER_TREE)
2901         public Kind getKind() {
2902             return Kind.EXPORTS;
2903         }
2904 
2905         @Override @DefinedBy(Api.COMPILER_TREE)
2906         public JCExpression getPackageName() {
2907             return qualid;
2908         }
2909 
2910         @Override @DefinedBy(Api.COMPILER_TREE)
2911         public List&lt;JCExpression&gt; getModuleNames() {
2912             return moduleNames;
2913         }
2914 
2915         @Override @DefinedBy(Api.COMPILER_TREE)
2916         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2917             return v.visitExports(this, d);
2918         }
2919 
2920         @Override
2921         public Tag getTag() {
2922             return Tag.EXPORTS;
2923         }
2924     }
2925 
2926     public static class JCOpens extends JCDirective
2927             implements OpensTree {
2928         public JCExpression qualid;
2929         public List&lt;JCExpression&gt; moduleNames;
2930         public OpensDirective directive;
2931 
2932         protected JCOpens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2933             this.qualid = qualId;
2934             this.moduleNames = moduleNames;
2935         }
2936 
2937         @Override
2938         public void accept(Visitor v) { v.visitOpens(this); }
2939 
2940         @Override @DefinedBy(Api.COMPILER_TREE)
2941         public Kind getKind() {
2942             return Kind.OPENS;
2943         }
2944 
2945         @Override @DefinedBy(Api.COMPILER_TREE)
2946         public JCExpression getPackageName() {
2947             return qualid;
2948         }
2949 
2950         @Override @DefinedBy(Api.COMPILER_TREE)
2951         public List&lt;JCExpression&gt; getModuleNames() {
2952             return moduleNames;
2953         }
2954 
2955         @Override @DefinedBy(Api.COMPILER_TREE)
2956         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2957             return v.visitOpens(this, d);
2958         }
2959 
2960         @Override
2961         public Tag getTag() {
2962             return Tag.OPENS;
2963         }
2964     }
2965 
2966     public static class JCProvides extends JCDirective
2967             implements ProvidesTree {
2968         public JCExpression serviceName;
2969         public List&lt;JCExpression&gt; implNames;
2970 
2971         protected JCProvides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
2972             this.serviceName = serviceName;
2973             this.implNames = implNames;
2974         }
2975 
2976         @Override
2977         public void accept(Visitor v) { v.visitProvides(this); }
2978 
2979         @Override @DefinedBy(Api.COMPILER_TREE)
2980         public Kind getKind() {
2981             return Kind.PROVIDES;
2982         }
2983 
2984         @Override @DefinedBy(Api.COMPILER_TREE)
2985         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2986             return v.visitProvides(this, d);
2987         }
2988 
2989         @Override @DefinedBy(Api.COMPILER_TREE)
2990         public JCExpression getServiceName() {
2991             return serviceName;
2992         }
2993 
2994         @Override @DefinedBy(Api.COMPILER_TREE)
2995         public List&lt;JCExpression&gt; getImplementationNames() {
2996             return implNames;
2997         }
2998 
2999         @Override
3000         public Tag getTag() {
3001             return PROVIDES;
3002         }
3003     }
3004 
3005     public static class JCRequires extends JCDirective
3006             implements RequiresTree {
3007         public boolean isTransitive;
3008         public boolean isStaticPhase;
3009         public JCExpression moduleName;
3010         public RequiresDirective directive;
3011 
3012         protected JCRequires(boolean isTransitive, boolean isStaticPhase, JCExpression moduleName) {
3013             this.isTransitive = isTransitive;
3014             this.isStaticPhase = isStaticPhase;
3015             this.moduleName = moduleName;
3016         }
3017 
3018         @Override
3019         public void accept(Visitor v) { v.visitRequires(this); }
3020 
3021         @Override @DefinedBy(Api.COMPILER_TREE)
3022         public Kind getKind() {
3023             return Kind.REQUIRES;
3024         }
3025 
3026         @Override @DefinedBy(Api.COMPILER_TREE)
3027         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3028             return v.visitRequires(this, d);
3029         }
3030 
3031         @Override @DefinedBy(Api.COMPILER_TREE)
3032         public boolean isTransitive() {
3033             return isTransitive;
3034         }
3035 
3036         @Override @DefinedBy(Api.COMPILER_TREE)
3037         public boolean isStatic() {
3038             return isStaticPhase;
3039         }
3040 
3041         @Override @DefinedBy(Api.COMPILER_TREE)
3042         public JCExpression getModuleName() {
3043             return moduleName;
3044         }
3045 
3046         @Override
3047         public Tag getTag() {
3048             return REQUIRES;
3049         }
3050     }
3051 
3052     public static class JCUses extends JCDirective
3053             implements UsesTree {
3054         public JCExpression qualid;
3055 
3056         protected JCUses(JCExpression qualId) {
3057             this.qualid = qualId;
3058         }
3059 
3060         @Override
3061         public void accept(Visitor v) { v.visitUses(this); }
3062 
3063         @Override @DefinedBy(Api.COMPILER_TREE)
3064         public Kind getKind() {
3065             return Kind.USES;
3066         }
3067 
3068         @Override @DefinedBy(Api.COMPILER_TREE)
3069         public JCExpression getServiceName() {
3070             return qualid;
3071         }
3072 
3073         @Override @DefinedBy(Api.COMPILER_TREE)
3074         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3075             return v.visitUses(this, d);
3076         }
3077 
3078         @Override
3079         public Tag getTag() {
3080             return USES;
3081         }
3082     }
3083 
3084     public static class JCErroneous extends JCExpression
3085             implements ErroneousTree {
3086         public List&lt;? extends JCTree&gt; errs;
3087         protected JCErroneous(List&lt;? extends JCTree&gt; errs) {
3088             this.errs = errs;
3089         }
3090         @Override
3091         public void accept(Visitor v) { v.visitErroneous(this); }
3092 
3093         @DefinedBy(Api.COMPILER_TREE)
3094         public Kind getKind() { return Kind.ERRONEOUS; }
3095 
3096         @DefinedBy(Api.COMPILER_TREE)
3097         public List&lt;? extends JCTree&gt; getErrorTrees() {
3098             return errs;
3099         }
3100 
3101         @Override @DefinedBy(Api.COMPILER_TREE)
3102         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3103             return v.visitErroneous(this, d);
3104         }
3105         @Override
3106         public Tag getTag() {
3107             return ERRONEOUS;
3108         }
3109     }
3110 
3111     /** (let int x = 3; in x+2) */
3112     public static class LetExpr extends JCExpression {
3113         public List&lt;JCStatement&gt; defs;
3114         public JCExpression expr;
3115         /**true if a expr should be run through Gen.genCond:*/
3116         public boolean needsCond;
3117         protected LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr) {
3118             this.defs = defs;
3119             this.expr = expr;
3120         }
3121         @Override
3122         public void accept(Visitor v) { v.visitLetExpr(this); }
3123 
3124         @DefinedBy(Api.COMPILER_TREE)
3125         public Kind getKind() {
3126             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3127         }
3128         @Override @DefinedBy(Api.COMPILER_TREE)
3129         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3130             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3131         }
3132         @Override
3133         public Tag getTag() {
3134             return LETEXPR;
3135         }
3136     }
3137 
3138     /** An interface for tree factories
3139      */
3140     public interface Factory {
3141         JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs);
3142         JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
3143                                   JCExpression pid);
3144         JCImport Import(JCTree qualid, boolean staticImport);
3145         JCClassDecl ClassDef(JCModifiers mods,
3146                           Name name,
3147                           List&lt;JCTypeParameter&gt; typarams,
3148                           JCExpression extending,
3149                           List&lt;JCExpression&gt; implementing,
3150                           List&lt;JCTree&gt; defs);
3151         JCMethodDecl MethodDef(JCModifiers mods,
3152                             Name name,
3153                             JCExpression restype,
3154                             List&lt;JCTypeParameter&gt; typarams,
3155                             JCVariableDecl recvparam,
3156                             List&lt;JCVariableDecl&gt; params,
3157                             List&lt;JCExpression&gt; thrown,
3158                             JCBlock body,
3159                             JCExpression defaultValue);
3160         JCVariableDecl VarDef(JCModifiers mods,
3161                       Name name,
3162                       JCExpression vartype,
3163                       JCExpression init);
3164         JCSkip Skip();
3165         JCBlock Block(long flags, List&lt;JCStatement&gt; stats);
3166         JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond);
3167         JCWhileLoop WhileLoop(JCExpression cond, JCStatement body);
3168         JCForLoop ForLoop(List&lt;JCStatement&gt; init,
3169                         JCExpression cond,
3170                         List&lt;JCExpressionStatement&gt; step,
3171                         JCStatement body);
3172         JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);
3173         JCLabeledStatement Labelled(Name label, JCStatement body);
3174         JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases);
3175         JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases);
3176         JCCase Case(CaseTree.CaseKind caseKind, List&lt;JCExpression&gt; pat,
3177                     List&lt;JCStatement&gt; stats, JCTree body);
3178         JCSynchronized Synchronized(JCExpression lock, JCBlock body);
3179         JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer);
3180         JCTry Try(List&lt;JCTree&gt; resources,
3181                   JCBlock body,
3182                   List&lt;JCCatch&gt; catchers,
3183                   JCBlock finalizer);
3184         JCCatch Catch(JCVariableDecl param, JCBlock body);
3185         JCConditional Conditional(JCExpression cond,
3186                                 JCExpression thenpart,
3187                                 JCExpression elsepart);
3188         JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart);
3189         JCExpressionStatement Exec(JCExpression expr);
3190         JCBreak Break(Name label);
3191         JCYield Yield(JCExpression value);
3192         JCContinue Continue(Name label);
3193         JCReturn Return(JCExpression expr);
3194         JCThrow Throw(JCExpression expr);
3195         JCAssert Assert(JCExpression cond, JCExpression detail);
3196         JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
3197                     JCExpression fn,
3198                     List&lt;JCExpression&gt; args);
3199         JCNewClass NewClass(JCExpression encl,
3200                           List&lt;JCExpression&gt; typeargs,
3201                           JCExpression clazz,
3202                           List&lt;JCExpression&gt; args,
3203                           JCClassDecl def);
3204         JCNewArray NewArray(JCExpression elemtype,
3205                           List&lt;JCExpression&gt; dims,
3206                           List&lt;JCExpression&gt; elems);
3207         JCParens Parens(JCExpression expr);
3208         JCAssign Assign(JCExpression lhs, JCExpression rhs);
3209         JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
3210         JCUnary Unary(Tag opcode, JCExpression arg);
3211         JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
3212         JCTypeCast TypeCast(JCTree expr, JCExpression type);
3213         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);
3214         JCBindingPattern BindingPattern(Name name, JCTree vartype);
3215         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3216         JCFieldAccess Select(JCExpression selected, Name selector);
3217         JCIdent Ident(Name idname);
3218         JCLiteral Literal(TypeTag tag, Object value);
3219         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3220         JCArrayTypeTree TypeArray(JCExpression elemtype);
3221         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3222         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3223         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3224         TypeBoundKind TypeBoundKind(BoundKind kind);
3225         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3226         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3227         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3228         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3229         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3230         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3231         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3232         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3233         JCUses Uses(JCExpression qualId);
3234         LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr);
3235     }
3236 
3237     /** A generic visitor class for trees.
3238      */
3239     public static abstract class Visitor {
3240         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3241         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3242         public void visitImport(JCImport that)               { visitTree(that); }
3243         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3244         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3245         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3246         public void visitSkip(JCSkip that)                   { visitTree(that); }
3247         public void visitBlock(JCBlock that)                 { visitTree(that); }
3248         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3249         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3250         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3251         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3252         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3253         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3254         public void visitCase(JCCase that)                   { visitTree(that); }
3255         public void visitSwitchExpression(JCSwitchExpression that)               { visitTree(that); }
3256         public void visitSynchronized(JCSynchronized that)   { visitTree(that); }
3257         public void visitTry(JCTry that)                     { visitTree(that); }
3258         public void visitCatch(JCCatch that)                 { visitTree(that); }
3259         public void visitConditional(JCConditional that)     { visitTree(that); }
3260         public void visitIf(JCIf that)                       { visitTree(that); }
3261         public void visitExec(JCExpressionStatement that)    { visitTree(that); }
3262         public void visitBreak(JCBreak that)                 { visitTree(that); }
3263         public void visitYield(JCYield that)                 { visitTree(that); }
3264         public void visitContinue(JCContinue that)           { visitTree(that); }
3265         public void visitReturn(JCReturn that)               { visitTree(that); }
3266         public void visitThrow(JCThrow that)                 { visitTree(that); }
3267         public void visitAssert(JCAssert that)               { visitTree(that); }
3268         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
3269         public void visitNewClass(JCNewClass that)           { visitTree(that); }
3270         public void visitNewArray(JCNewArray that)           { visitTree(that); }
3271         public void visitLambda(JCLambda that)               { visitTree(that); }
3272         public void visitParens(JCParens that)               { visitTree(that); }
3273         public void visitAssign(JCAssign that)               { visitTree(that); }
3274         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
3275         public void visitUnary(JCUnary that)                 { visitTree(that); }
3276         public void visitBinary(JCBinary that)               { visitTree(that); }
3277         public void visitTypeCast(JCTypeCast that)           { visitTree(that); }
3278         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }
3279         public void visitBindingPattern(JCBindingPattern that) { visitTree(that); }
3280         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
3281         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
3282         public void visitReference(JCMemberReference that)   { visitTree(that); }
3283         public void visitIdent(JCIdent that)                 { visitTree(that); }
3284         public void visitLiteral(JCLiteral that)             { visitTree(that); }
3285         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
3286         public void visitTypeArray(JCArrayTypeTree that)     { visitTree(that); }
3287         public void visitTypeApply(JCTypeApply that)         { visitTree(that); }
3288         public void visitTypeUnion(JCTypeUnion that)         { visitTree(that); }
3289         public void visitTypeIntersection(JCTypeIntersection that)  { visitTree(that); }
3290         public void visitTypeParameter(JCTypeParameter that) { visitTree(that); }
3291         public void visitWildcard(JCWildcard that)           { visitTree(that); }
3292         public void visitTypeBoundKind(TypeBoundKind that)   { visitTree(that); }
3293         public void visitAnnotation(JCAnnotation that)       { visitTree(that); }
3294         public void visitModifiers(JCModifiers that)         { visitTree(that); }
3295         public void visitAnnotatedType(JCAnnotatedType that) { visitTree(that); }
3296         public void visitErroneous(JCErroneous that)         { visitTree(that); }
3297         public void visitModuleDef(JCModuleDecl that)        { visitTree(that); }
3298         public void visitExports(JCExports that)             { visitTree(that); }
3299         public void visitOpens(JCOpens that)                 { visitTree(that); }
3300         public void visitProvides(JCProvides that)           { visitTree(that); }
3301         public void visitRequires(JCRequires that)           { visitTree(that); }
3302         public void visitUses(JCUses that)                   { visitTree(that); }
3303         public void visitLetExpr(LetExpr that)               { visitTree(that); }
3304 
3305         public void visitTree(JCTree that)                   { Assert.error(); }
3306     }
3307 
3308 }
    </pre>
  </body>
</html>
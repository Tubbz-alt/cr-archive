<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 
  29 
  30 import com.sun.source.tree.Tree;
  31 import com.sun.source.util.TreePath;
  32 import com.sun.tools.javac.code.*;
  33 import com.sun.tools.javac.comp.AttrContext;
  34 import com.sun.tools.javac.comp.Env;
  35 import com.sun.tools.javac.tree.JCTree.*;
  36 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  37 import com.sun.tools.javac.util.*;
  38 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  39 
  40 import static com.sun.tools.javac.code.Flags.*;
  41 import static com.sun.tools.javac.code.Kinds.Kind.*;
  42 import static com.sun.tools.javac.code.TypeTag.BOT;
  43 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  44 import static com.sun.tools.javac.tree.JCTree.Tag.BLOCK;
  45 import static com.sun.tools.javac.tree.JCTree.Tag.SYNCHRONIZED;
  46 
  47 import javax.tools.JavaFileObject;
  48 
  49 import java.util.function.ToIntFunction;
  50 
  51 import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.LEFT;
  52 import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.RIGHT;
  53 
  54 /** Utility class containing inspector methods for trees.
  55  *
  56  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  57  *  If you write code that depends on this, you do so at your own risk.
  58  *  This code and its internal interfaces are subject to change or
  59  *  deletion without notice.&lt;/b&gt;
  60  */
  61 public class TreeInfo {
  62 
  63     public static List&lt;JCExpression&gt; args(JCTree t) {
  64         switch (t.getTag()) {
  65             case APPLY:
  66                 return ((JCMethodInvocation)t).args;
  67             case NEWCLASS:
  68                 return ((JCNewClass)t).args;
  69             default:
  70                 return null;
  71         }
  72     }
  73 
  74     /** Is tree a constructor declaration?
  75      */
  76     public static boolean isConstructor(JCTree tree) {
  77         if (tree.hasTag(METHODDEF)) {
  78             Name name = ((JCMethodDecl) tree).name;
  79             return name == name.table.names.init;
  80         } else {
  81             return false;
  82         }
  83     }
  84 
  85     public static boolean isCanonicalConstructor(JCTree tree) {
  86         // the record flag is only set to the canonical constructor
  87         return isConstructor(tree) &amp;&amp; (((JCMethodDecl)tree).sym.flags_field &amp; RECORD) != 0;
  88     }
  89 
  90     public static boolean isCompactConstructor(JCTree tree) {
  91         // the record flag is only set to the canonical constructor
  92         return isCanonicalConstructor(tree) &amp;&amp; (((JCMethodDecl)tree).sym.flags_field &amp; COMPACT_RECORD_CONSTRUCTOR) != 0;
  93     }
  94 
  95     public static boolean isReceiverParam(JCTree tree) {
  96         if (tree.hasTag(VARDEF)) {
  97             return ((JCVariableDecl)tree).nameexpr != null;
  98         } else {
  99             return false;
 100         }
 101     }
 102 
 103     /** Is there a constructor declaration in the given list of trees?
 104      */
 105     public static boolean hasConstructors(List&lt;JCTree&gt; trees) {
 106         for (List&lt;JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 107             if (isConstructor(l.head)) return true;
 108         return false;
 109     }
 110 
 111     /** Is there a constructor invocation in the given list of trees?
<a name="1" id="anc1"></a><span class="line-added"> 112      *  Optionally, check only for no-arg ctor invocation</span>
 113      */
<a name="2" id="anc2"></a><span class="line-modified"> 114     public static Name getConstructorInvocationName(List&lt;? extends JCTree&gt; trees, Names names, boolean argsAllowed) {</span>
 115         for (JCTree tree : trees) {
 116             if (tree.hasTag(EXEC)) {
 117                 JCExpressionStatement stat = (JCExpressionStatement)tree;
 118                 if (stat.expr.hasTag(APPLY)) {
 119                     JCMethodInvocation apply = (JCMethodInvocation)stat.expr;
<a name="3" id="anc3"></a><span class="line-modified"> 120                     if (argsAllowed || apply.args.size() == 0) {</span>
<span class="line-modified"> 121                         Name methName = TreeInfo.name(apply.meth);</span>
<span class="line-modified"> 122                         if (methName == names._this ||</span>
<span class="line-modified"> 123                                 methName == names._super) {</span>
<span class="line-added"> 124                             return methName;</span>
<span class="line-added"> 125                         }</span>
 126                     }
 127                 }
 128             }
 129         }
 130         return names.empty;
 131     }
 132 
 133     public static boolean isMultiCatch(JCCatch catchClause) {
 134         return catchClause.param.vartype.hasTag(TYPEUNION);
 135     }
 136 
 137     /** Is statement an initializer for a synthetic field?
 138      */
 139     public static boolean isSyntheticInit(JCTree stat) {
 140         if (stat.hasTag(EXEC)) {
 141             JCExpressionStatement exec = (JCExpressionStatement)stat;
 142             if (exec.expr.hasTag(ASSIGN)) {
 143                 JCAssign assign = (JCAssign)exec.expr;
 144                 if (assign.lhs.hasTag(SELECT)) {
 145                     JCFieldAccess select = (JCFieldAccess)assign.lhs;
 146                     if (select.sym != null &amp;&amp;
 147                         (select.sym.flags() &amp; SYNTHETIC) != 0) {
 148                         Name selected = name(select.selected);
 149                         if (selected != null &amp;&amp; selected == selected.table.names._this)
 150                             return true;
 151                     }
 152                 }
 153             }
 154         }
 155         return false;
 156     }
 157 
 158     /** If the expression is a method call, return the method name, null
 159      *  otherwise. */
 160     public static Name calledMethodName(JCTree tree) {
 161         if (tree.hasTag(EXEC)) {
 162             JCExpressionStatement exec = (JCExpressionStatement)tree;
 163             if (exec.expr.hasTag(APPLY)) {
 164                 Name mname = TreeInfo.name(((JCMethodInvocation) exec.expr).meth);
 165                 return mname;
 166             }
 167         }
 168         return null;
 169     }
 170 
 171     /** Is this a call to this or super?
 172      */
 173     public static boolean isSelfCall(JCTree tree) {
 174         Name name = calledMethodName(tree);
 175         if (name != null) {
 176             Names names = name.table.names;
 177             return name==names._this || name==names._super;
 178         } else {
 179             return false;
 180         }
 181     }
 182 
 183     /** Is this tree a &#39;this&#39; identifier?
 184      */
 185     public static boolean isThisQualifier(JCTree tree) {
 186         switch (tree.getTag()) {
 187             case PARENS:
 188                 return isThisQualifier(skipParens(tree));
 189             case IDENT: {
 190                 JCIdent id = (JCIdent)tree;
 191                 return id.name == id.name.table.names._this;
 192             }
 193             default:
 194                 return false;
 195         }
 196     }
 197 
 198     /** Is this tree an identifier, possibly qualified by &#39;this&#39;?
 199      */
 200     public static boolean isIdentOrThisDotIdent(JCTree tree) {
 201         switch (tree.getTag()) {
 202             case PARENS:
 203                 return isIdentOrThisDotIdent(skipParens(tree));
 204             case IDENT:
 205                 return true;
 206             case SELECT:
 207                 return isThisQualifier(((JCFieldAccess)tree).selected);
 208             default:
 209                 return false;
 210         }
 211     }
 212 
 213     /** Is this a call to super?
 214      */
 215     public static boolean isSuperCall(JCTree tree) {
 216         Name name = calledMethodName(tree);
 217         if (name != null) {
 218             Names names = name.table.names;
 219             return name==names._super;
 220         } else {
 221             return false;
 222         }
 223     }
 224 
 225     public static List&lt;JCVariableDecl&gt; recordFields(JCClassDecl tree) {
 226         return tree.defs.stream()
 227                 .filter(t -&gt; t.hasTag(VARDEF))
 228                 .map(t -&gt; (JCVariableDecl)t)
 229                 .filter(vd -&gt; (vd.getModifiers().flags &amp; (Flags.RECORD)) == RECORD)
 230                 .collect(List.collector());
 231     }
 232 
 233     public static List&lt;Type&gt; recordFieldTypes(JCClassDecl tree) {
 234         return recordFields(tree).stream()
 235                 .map(vd -&gt; vd.type)
 236                 .collect(List.collector());
 237     }
 238 
 239     /** Is this a constructor whose first (non-synthetic) statement is not
 240      *  of the form this(...)?
 241      */
 242     public static boolean isInitialConstructor(JCTree tree) {
 243         JCMethodInvocation app = firstConstructorCall(tree);
 244         if (app == null) return false;
 245         Name meth = name(app.meth);
 246         return meth == null || meth != meth.table.names._this;
 247     }
 248 
 249     /** Return the first call in a constructor definition. */
 250     public static JCMethodInvocation firstConstructorCall(JCTree tree) {
 251         if (!tree.hasTag(METHODDEF)) return null;
 252         JCMethodDecl md = (JCMethodDecl) tree;
 253         Names names = md.name.table.names;
 254         if (md.name != names.init) return null;
 255         if (md.body == null) return null;
 256         List&lt;JCStatement&gt; stats = md.body.stats;
 257         // Synthetic initializations can appear before the super call.
 258         while (stats.nonEmpty() &amp;&amp; isSyntheticInit(stats.head))
 259             stats = stats.tail;
 260         if (stats.isEmpty()) return null;
 261         if (!stats.head.hasTag(EXEC)) return null;
 262         JCExpressionStatement exec = (JCExpressionStatement) stats.head;
 263         if (!exec.expr.hasTag(APPLY)) return null;
 264         return (JCMethodInvocation)exec.expr;
 265     }
 266 
 267     /** Return true if a tree represents a diamond new expr. */
 268     public static boolean isDiamond(JCTree tree) {
 269         switch(tree.getTag()) {
 270             case TYPEAPPLY: return ((JCTypeApply)tree).getTypeArguments().isEmpty();
 271             case NEWCLASS: return isDiamond(((JCNewClass)tree).clazz);
 272             case ANNOTATED_TYPE: return isDiamond(((JCAnnotatedType)tree).underlyingType);
 273             default: return false;
 274         }
 275     }
 276 
 277     public static boolean isEnumInit(JCTree tree) {
 278         switch (tree.getTag()) {
 279             case VARDEF:
 280                 return (((JCVariableDecl)tree).mods.flags &amp; ENUM) != 0;
 281             default:
 282                 return false;
 283         }
 284     }
 285 
 286     /** set &#39;polyKind&#39; on given tree */
 287     public static void setPolyKind(JCTree tree, PolyKind pkind) {
 288         switch (tree.getTag()) {
 289             case APPLY:
 290                 ((JCMethodInvocation)tree).polyKind = pkind;
 291                 break;
 292             case NEWCLASS:
 293                 ((JCNewClass)tree).polyKind = pkind;
 294                 break;
 295             case REFERENCE:
 296                 ((JCMemberReference)tree).refPolyKind = pkind;
 297                 break;
 298             default:
 299                 throw new AssertionError(&quot;Unexpected tree: &quot; + tree);
 300         }
 301     }
 302 
 303     /** set &#39;varargsElement&#39; on given tree */
 304     public static void setVarargsElement(JCTree tree, Type varargsElement) {
 305         switch (tree.getTag()) {
 306             case APPLY:
 307                 ((JCMethodInvocation)tree).varargsElement = varargsElement;
 308                 break;
 309             case NEWCLASS:
 310                 ((JCNewClass)tree).varargsElement = varargsElement;
 311                 break;
 312             case REFERENCE:
 313                 ((JCMemberReference)tree).varargsElement = varargsElement;
 314                 break;
 315             default:
 316                 throw new AssertionError(&quot;Unexpected tree: &quot; + tree);
 317         }
 318     }
 319 
 320     /** Return true if the tree corresponds to an expression statement */
 321     public static boolean isExpressionStatement(JCExpression tree) {
 322         switch(tree.getTag()) {
 323             case PREINC: case PREDEC:
 324             case POSTINC: case POSTDEC:
 325             case ASSIGN:
 326             case BITOR_ASG: case BITXOR_ASG: case BITAND_ASG:
 327             case SL_ASG: case SR_ASG: case USR_ASG:
 328             case PLUS_ASG: case MINUS_ASG:
 329             case MUL_ASG: case DIV_ASG: case MOD_ASG:
 330             case APPLY: case NEWCLASS:
 331             case ERRONEOUS:
 332                 return true;
 333             default:
 334                 return false;
 335         }
 336     }
 337 
 338     /** Return true if the tree corresponds to a statement */
 339     public static boolean isStatement(JCTree tree) {
 340         return (tree instanceof JCStatement) &amp;&amp;
 341                 !tree.hasTag(CLASSDEF) &amp;&amp;
 342                 !tree.hasTag(Tag.BLOCK) &amp;&amp;
 343                 !tree.hasTag(METHODDEF);
 344     }
 345 
 346     /**
 347      * Return true if the AST corresponds to a static select of the kind A.B
 348      */
 349     public static boolean isStaticSelector(JCTree base, Names names) {
 350         if (base == null)
 351             return false;
 352         switch (base.getTag()) {
 353             case IDENT:
 354                 JCIdent id = (JCIdent)base;
 355                 return id.name != names._this &amp;&amp;
 356                         id.name != names._super &amp;&amp;
 357                         isStaticSym(base);
 358             case SELECT:
 359                 return isStaticSym(base) &amp;&amp;
 360                     isStaticSelector(((JCFieldAccess)base).selected, names);
 361             case TYPEAPPLY:
 362             case TYPEARRAY:
 363                 return true;
 364             case ANNOTATED_TYPE:
 365                 return isStaticSelector(((JCAnnotatedType)base).underlyingType, names);
 366             default:
 367                 return false;
 368         }
 369     }
 370     //where
 371         private static boolean isStaticSym(JCTree tree) {
 372             Symbol sym = symbol(tree);
 373             return (sym.kind == TYP || sym.kind == PCK);
 374         }
 375 
 376     /** Return true if a tree represents the null literal. */
 377     public static boolean isNull(JCTree tree) {
 378         if (!tree.hasTag(LITERAL))
 379             return false;
 380         JCLiteral lit = (JCLiteral) tree;
 381         return (lit.typetag == BOT);
 382     }
 383 
 384     /** Return true iff this tree is a child of some annotation. */
 385     public static boolean isInAnnotation(Env&lt;?&gt; env, JCTree tree) {
 386         TreePath tp = TreePath.getPath(env.toplevel, tree);
 387         if (tp != null) {
 388             for (Tree t : tp) {
 389                 if (t.getKind() == Tree.Kind.ANNOTATION)
 390                     return true;
 391             }
 392         }
 393         return false;
 394     }
 395 
 396     public static String getCommentText(Env&lt;?&gt; env, JCTree tree) {
 397         DocCommentTable docComments = (tree.hasTag(JCTree.Tag.TOPLEVEL))
 398                 ? ((JCCompilationUnit) tree).docComments
 399                 : env.toplevel.docComments;
 400         return (docComments == null) ? null : docComments.getCommentText(tree);
 401     }
 402 
 403     public static DCTree.DCDocComment getCommentTree(Env&lt;?&gt; env, JCTree tree) {
 404         DocCommentTable docComments = (tree.hasTag(JCTree.Tag.TOPLEVEL))
 405                 ? ((JCCompilationUnit) tree).docComments
 406                 : env.toplevel.docComments;
 407         return (docComments == null) ? null : docComments.getCommentTree(tree);
 408     }
 409 
 410     /** The position of the first statement in a block, or the position of
 411      *  the block itself if it is empty.
 412      */
 413     public static int firstStatPos(JCTree tree) {
 414         if (tree.hasTag(BLOCK) &amp;&amp; ((JCBlock) tree).stats.nonEmpty())
 415             return ((JCBlock) tree).stats.head.pos;
 416         else
 417             return tree.pos;
 418     }
 419 
 420     /** The end position of given tree, if it is a block with
 421      *  defined endpos.
 422      */
 423     public static int endPos(JCTree tree) {
 424         if (tree.hasTag(BLOCK) &amp;&amp; ((JCBlock) tree).endpos != Position.NOPOS)
 425             return ((JCBlock) tree).endpos;
 426         else if (tree.hasTag(SYNCHRONIZED))
 427             return endPos(((JCSynchronized) tree).body);
 428         else if (tree.hasTag(TRY)) {
 429             JCTry t = (JCTry) tree;
 430             return endPos((t.finalizer != null) ? t.finalizer
 431                           : (t.catchers.nonEmpty() ? t.catchers.last().body : t.body));
 432         } else if (tree.hasTag(SWITCH_EXPRESSION) &amp;&amp;
 433                    ((JCSwitchExpression) tree).endpos != Position.NOPOS) {
 434             return ((JCSwitchExpression) tree).endpos;
 435         } else
 436             return tree.pos;
 437     }
 438 
 439 
 440     /** Get the start position for a tree node.  The start position is
 441      * defined to be the position of the first character of the first
 442      * token of the node&#39;s source text.
 443      * @param tree  The tree node
 444      */
 445     public static int getStartPos(JCTree tree) {
 446         if (tree == null)
 447             return Position.NOPOS;
 448 
 449         switch(tree.getTag()) {
 450             case MODULEDEF: {
 451                 JCModuleDecl md = (JCModuleDecl)tree;
 452                 return md.mods.annotations.isEmpty() ? md.pos :
 453                        md.mods.annotations.head.pos;
 454             }
 455             case PACKAGEDEF: {
 456                 JCPackageDecl pd = (JCPackageDecl)tree;
 457                 return pd.annotations.isEmpty() ? pd.pos :
 458                        pd.annotations.head.pos;
 459             }
 460             case APPLY:
 461                 return getStartPos(((JCMethodInvocation) tree).meth);
 462             case ASSIGN:
 463                 return getStartPos(((JCAssign) tree).lhs);
 464             case BITOR_ASG: case BITXOR_ASG: case BITAND_ASG:
 465             case SL_ASG: case SR_ASG: case USR_ASG:
 466             case PLUS_ASG: case MINUS_ASG: case MUL_ASG:
 467             case DIV_ASG: case MOD_ASG:
 468             case OR: case AND: case BITOR:
 469             case BITXOR: case BITAND: case EQ:
 470             case NE: case LT: case GT:
 471             case LE: case GE: case SL:
 472             case SR: case USR: case PLUS:
 473             case MINUS: case MUL: case DIV:
 474             case MOD:
 475             case POSTINC:
 476             case POSTDEC:
 477                 return getStartPos(((JCOperatorExpression) tree).getOperand(LEFT));
 478             case CLASSDEF: {
 479                 JCClassDecl node = (JCClassDecl)tree;
 480                 if (node.mods.pos != Position.NOPOS)
 481                     return node.mods.pos;
 482                 break;
 483             }
 484             case CONDEXPR:
 485                 return getStartPos(((JCConditional) tree).cond);
 486             case EXEC:
 487                 return getStartPos(((JCExpressionStatement) tree).expr);
 488             case INDEXED:
 489                 return getStartPos(((JCArrayAccess) tree).indexed);
 490             case METHODDEF: {
 491                 JCMethodDecl node = (JCMethodDecl)tree;
 492                 if (node.mods.pos != Position.NOPOS)
 493                     return node.mods.pos;
 494                 if (node.typarams.nonEmpty()) // List.nil() used for no typarams
 495                     return getStartPos(node.typarams.head);
 496                 return node.restype == null ? node.pos : getStartPos(node.restype);
 497             }
 498             case SELECT:
 499                 return getStartPos(((JCFieldAccess) tree).selected);
 500             case TYPEAPPLY:
 501                 return getStartPos(((JCTypeApply) tree).clazz);
 502             case TYPEARRAY:
 503                 return getStartPos(((JCArrayTypeTree) tree).elemtype);
 504             case TYPETEST:
 505                 return getStartPos(((JCInstanceOf) tree).expr);
 506             case ANNOTATED_TYPE: {
 507                 JCAnnotatedType node = (JCAnnotatedType) tree;
 508                 if (node.annotations.nonEmpty()) {
 509                     if (node.underlyingType.hasTag(TYPEARRAY) ||
 510                             node.underlyingType.hasTag(SELECT)) {
 511                         return getStartPos(node.underlyingType);
 512                     } else {
 513                         return getStartPos(node.annotations.head);
 514                     }
 515                 } else {
 516                     return getStartPos(node.underlyingType);
 517                 }
 518             }
 519             case NEWCLASS: {
 520                 JCNewClass node = (JCNewClass)tree;
 521                 if (node.encl != null)
 522                     return getStartPos(node.encl);
 523                 break;
 524             }
 525             case VARDEF: {
 526                 JCVariableDecl node = (JCVariableDecl)tree;
 527                 if (node.startPos != Position.NOPOS) {
 528                     return node.startPos;
 529                 } else if (node.mods.pos != Position.NOPOS) {
 530                     return node.mods.pos;
 531                 } else if (node.vartype == null || node.vartype.pos == Position.NOPOS) {
 532                     //if there&#39;s no type (partially typed lambda parameter)
 533                     //simply return node position
 534                     return node.pos;
 535                 } else {
 536                     return getStartPos(node.vartype);
 537                 }
 538             }
 539             case BINDINGPATTERN: {
 540                 JCBindingPattern node = (JCBindingPattern)tree;
 541                 return getStartPos(node.vartype);
 542             }
 543             case ERRONEOUS: {
 544                 JCErroneous node = (JCErroneous)tree;
 545                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 546                     return getStartPos(node.errs.head);
 547             }
 548         }
 549         return tree.pos;
 550     }
 551 
 552     /** The end position of given tree, given  a table of end positions generated by the parser
 553      */
 554     public static int getEndPos(JCTree tree, EndPosTable endPosTable) {
 555         if (tree == null)
 556             return Position.NOPOS;
 557 
 558         if (endPosTable == null) {
 559             // fall back on limited info in the tree
 560             return endPos(tree);
 561         }
 562 
 563         int mapPos = endPosTable.getEndPos(tree);
 564         if (mapPos != Position.NOPOS)
 565             return mapPos;
 566 
 567         switch(tree.getTag()) {
 568             case BITOR_ASG: case BITXOR_ASG: case BITAND_ASG:
 569             case SL_ASG: case SR_ASG: case USR_ASG:
 570             case PLUS_ASG: case MINUS_ASG: case MUL_ASG:
 571             case DIV_ASG: case MOD_ASG:
 572             case OR: case AND: case BITOR:
 573             case BITXOR: case BITAND: case EQ:
 574             case NE: case LT: case GT:
 575             case LE: case GE: case SL:
 576             case SR: case USR: case PLUS:
 577             case MINUS: case MUL: case DIV:
 578             case MOD:
 579             case POS:
 580             case NEG:
 581             case NOT:
 582             case COMPL:
 583             case PREINC:
 584             case PREDEC:
 585                 return getEndPos(((JCOperatorExpression) tree).getOperand(RIGHT), endPosTable);
 586             case CASE:
 587                 return getEndPos(((JCCase) tree).stats.last(), endPosTable);
 588             case CATCH:
 589                 return getEndPos(((JCCatch) tree).body, endPosTable);
 590             case CONDEXPR:
 591                 return getEndPos(((JCConditional) tree).falsepart, endPosTable);
 592             case FORLOOP:
 593                 return getEndPos(((JCForLoop) tree).body, endPosTable);
 594             case FOREACHLOOP:
 595                 return getEndPos(((JCEnhancedForLoop) tree).body, endPosTable);
 596             case IF: {
 597                 JCIf node = (JCIf)tree;
 598                 if (node.elsepart == null) {
 599                     return getEndPos(node.thenpart, endPosTable);
 600                 } else {
 601                     return getEndPos(node.elsepart, endPosTable);
 602                 }
 603             }
 604             case LABELLED:
 605                 return getEndPos(((JCLabeledStatement) tree).body, endPosTable);
 606             case MODIFIERS:
 607                 return getEndPos(((JCModifiers) tree).annotations.last(), endPosTable);
 608             case SYNCHRONIZED:
 609                 return getEndPos(((JCSynchronized) tree).body, endPosTable);
 610             case TOPLEVEL:
 611                 return getEndPos(((JCCompilationUnit) tree).defs.last(), endPosTable);
 612             case TRY: {
 613                 JCTry node = (JCTry)tree;
 614                 if (node.finalizer != null) {
 615                     return getEndPos(node.finalizer, endPosTable);
 616                 } else if (!node.catchers.isEmpty()) {
 617                     return getEndPos(node.catchers.last(), endPosTable);
 618                 } else {
 619                     return getEndPos(node.body, endPosTable);
 620                 }
 621             }
 622             case WILDCARD:
 623                 return getEndPos(((JCWildcard) tree).inner, endPosTable);
 624             case TYPECAST:
 625                 return getEndPos(((JCTypeCast) tree).expr, endPosTable);
 626             case TYPETEST:
 627                 return getEndPos(((JCInstanceOf) tree).pattern, endPosTable);
<a name="4" id="anc4"></a><span class="line-added"> 628             case WITHFIELD:</span>
<span class="line-added"> 629                 return getEndPos(((JCWithField) tree).value, endPosTable);</span>
 630             case WHILELOOP:
 631                 return getEndPos(((JCWhileLoop) tree).body, endPosTable);
 632             case ANNOTATED_TYPE:
 633                 return getEndPos(((JCAnnotatedType) tree).underlyingType, endPosTable);
 634             case ERRONEOUS: {
 635                 JCErroneous node = (JCErroneous)tree;
 636                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 637                     return getEndPos(node.errs.last(), endPosTable);
 638             }
 639         }
 640         return Position.NOPOS;
 641     }
 642 
 643 
 644     /** A DiagnosticPosition with the preferred position set to the
 645      *  end position of given tree, if it is a block with
 646      *  defined endpos.
 647      */
 648     public static DiagnosticPosition diagEndPos(final JCTree tree) {
 649         final int endPos = TreeInfo.endPos(tree);
 650         return new DiagnosticPosition() {
 651             public JCTree getTree() { return tree; }
 652             public int getStartPosition() { return TreeInfo.getStartPos(tree); }
 653             public int getPreferredPosition() { return endPos; }
 654             public int getEndPosition(EndPosTable endPosTable) {
 655                 return TreeInfo.getEndPos(tree, endPosTable);
 656             }
 657         };
 658     }
 659 
 660     public enum PosKind {
 661         START_POS(TreeInfo::getStartPos),
 662         FIRST_STAT_POS(TreeInfo::firstStatPos),
 663         END_POS(TreeInfo::endPos);
 664 
 665         final ToIntFunction&lt;JCTree&gt; posFunc;
 666 
 667         PosKind(ToIntFunction&lt;JCTree&gt; posFunc) {
 668             this.posFunc = posFunc;
 669         }
 670 
 671         int toPos(JCTree tree) {
 672             return posFunc.applyAsInt(tree);
 673         }
 674     }
 675 
 676     /** The position of the finalizer of given try/synchronized statement.
 677      */
 678     public static int finalizerPos(JCTree tree, PosKind posKind) {
 679         if (tree.hasTag(TRY)) {
 680             JCTry t = (JCTry) tree;
 681             Assert.checkNonNull(t.finalizer);
 682             return posKind.toPos(t.finalizer);
 683         } else if (tree.hasTag(SYNCHRONIZED)) {
 684             return endPos(((JCSynchronized) tree).body);
 685         } else {
 686             throw new AssertionError();
 687         }
 688     }
 689 
 690     /** Find the position for reporting an error about a symbol, where
 691      *  that symbol is defined somewhere in the given tree. */
 692     public static int positionFor(final Symbol sym, final JCTree tree) {
 693         JCTree decl = declarationFor(sym, tree);
 694         return ((decl != null) ? decl : tree).pos;
 695     }
 696 
 697     /** Find the position for reporting an error about a symbol, where
 698      *  that symbol is defined somewhere in the given tree. */
 699     public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final JCTree tree) {
 700         return diagnosticPositionFor(sym, tree, false);
 701     }
 702 
 703     public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final JCTree tree, boolean returnNullIfNotFound) {
 704         class DiagScanner extends DeclScanner {
 705             DiagScanner(Symbol sym) {
 706                 super(sym);
 707             }
 708 
 709             public void visitIdent(JCIdent that) {
 710                 if (that.sym == sym) result = that;
 711                 else super.visitIdent(that);
 712             }
 713             public void visitSelect(JCFieldAccess that) {
 714                 if (that.sym == sym) result = that;
 715                 else super.visitSelect(that);
 716             }
 717         }
 718         DiagScanner s = new DiagScanner(sym);
 719         tree.accept(s);
 720         JCTree decl = s.result;
 721         if (decl == null &amp;&amp; returnNullIfNotFound) { return null; }
 722         return ((decl != null) ? decl : tree).pos();
 723     }
 724 
 725     public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final List&lt;? extends JCTree&gt; trees) {
 726         return trees.stream().map(t -&gt; TreeInfo.diagnosticPositionFor(sym, t)).filter(t -&gt; t != null).findFirst().get();
 727     }
 728 
 729     private static class DeclScanner extends TreeScanner {
 730         final Symbol sym;
 731 
 732         DeclScanner(final Symbol sym) {
 733             this.sym = sym;
 734         }
 735 
 736         JCTree result = null;
 737         public void scan(JCTree tree) {
 738             if (tree!=null &amp;&amp; result==null)
 739                 tree.accept(this);
 740         }
 741         public void visitTopLevel(JCCompilationUnit that) {
 742             if (that.packge == sym) result = that;
 743             else super.visitTopLevel(that);
 744         }
 745         public void visitModuleDef(JCModuleDecl that) {
 746             if (that.sym == sym) result = that;
 747             // no need to scan within module declaration
 748         }
 749         public void visitPackageDef(JCPackageDecl that) {
 750             if (that.packge == sym) result = that;
 751             else super.visitPackageDef(that);
 752         }
 753         public void visitClassDef(JCClassDecl that) {
 754             if (that.sym == sym) result = that;
 755             else super.visitClassDef(that);
 756         }
 757         public void visitMethodDef(JCMethodDecl that) {
 758             if (that.sym == sym) result = that;
 759             else super.visitMethodDef(that);
 760         }
 761         public void visitVarDef(JCVariableDecl that) {
 762             if (that.sym == sym) result = that;
 763             else super.visitVarDef(that);
 764         }
 765         public void visitTypeParameter(JCTypeParameter that) {
 766             if (that.type != null &amp;&amp; that.type.tsym == sym) result = that;
 767             else super.visitTypeParameter(that);
 768         }
 769     }
 770 
 771     /** Find the declaration for a symbol, where
 772      *  that symbol is defined somewhere in the given tree. */
 773     public static JCTree declarationFor(final Symbol sym, final JCTree tree) {
 774         DeclScanner s = new DeclScanner(sym);
 775         tree.accept(s);
 776         return s.result;
 777     }
 778 
 779     public static Env&lt;AttrContext&gt; scopeFor(JCTree node, JCCompilationUnit unit) {
 780         return scopeFor(pathFor(node, unit));
 781     }
 782 
 783     public static Env&lt;AttrContext&gt; scopeFor(List&lt;JCTree&gt; path) {
 784         // TODO: not implemented yet
 785         throw new UnsupportedOperationException(&quot;not implemented yet&quot;);
 786     }
 787 
 788     public static List&lt;JCTree&gt; pathFor(final JCTree node, final JCCompilationUnit unit) {
 789         class Result extends Error {
 790             static final long serialVersionUID = -5942088234594905625L;
 791             List&lt;JCTree&gt; path;
 792             Result(List&lt;JCTree&gt; path) {
 793                 this.path = path;
 794             }
 795         }
 796         class PathFinder extends TreeScanner {
 797             List&lt;JCTree&gt; path = List.nil();
 798             public void scan(JCTree tree) {
 799                 if (tree != null) {
 800                     path = path.prepend(tree);
 801                     if (tree == node)
 802                         throw new Result(path);
 803                     super.scan(tree);
 804                     path = path.tail;
 805                 }
 806             }
 807         }
 808         try {
 809             new PathFinder().scan(unit);
 810         } catch (Result result) {
 811             return result.path;
 812         }
 813         return List.nil();
 814     }
 815 
 816     /** Return the statement referenced by a label.
 817      *  If the label refers to a loop or switch, return that switch
 818      *  otherwise return the labelled statement itself
 819      */
 820     public static JCTree referencedStatement(JCLabeledStatement tree) {
 821         JCTree t = tree;
 822         do t = ((JCLabeledStatement) t).body;
 823         while (t.hasTag(LABELLED));
 824         switch (t.getTag()) {
 825         case DOLOOP: case WHILELOOP: case FORLOOP: case FOREACHLOOP: case SWITCH:
 826             return t;
 827         default:
 828             return tree;
 829         }
 830     }
 831 
 832     /** Skip parens and return the enclosed expression
 833      */
 834     public static JCExpression skipParens(JCExpression tree) {
 835         while (tree.hasTag(PARENS)) {
 836             tree = ((JCParens) tree).expr;
 837         }
 838         return tree;
 839     }
 840 
 841     /** Skip parens and return the enclosed expression
 842      */
 843     public static JCTree skipParens(JCTree tree) {
 844         if (tree.hasTag(PARENS))
 845             return skipParens((JCParens)tree);
 846         else
 847             return tree;
 848     }
 849 
 850     /** Return the types of a list of trees.
 851      */
 852     public static List&lt;Type&gt; types(List&lt;? extends JCTree&gt; trees) {
 853         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 854         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 855             ts.append(l.head.type);
 856         return ts.toList();
 857     }
 858 
 859     /** If this tree is an identifier or a field or a parameterized type,
 860      *  return its name, otherwise return null.
 861      */
 862     public static Name name(JCTree tree) {
 863         switch (tree.getTag()) {
 864         case IDENT:
 865             return ((JCIdent) tree).name;
 866         case SELECT:
 867             return ((JCFieldAccess) tree).name;
 868         case TYPEAPPLY:
 869             return name(((JCTypeApply) tree).clazz);
 870         default:
 871             return null;
 872         }
 873     }
 874 
 875     /** If this tree is a qualified identifier, its return fully qualified name,
 876      *  otherwise return null.
 877      */
 878     public static Name fullName(JCTree tree) {
 879         tree = skipParens(tree);
 880         switch (tree.getTag()) {
 881         case IDENT:
 882             return ((JCIdent) tree).name;
 883         case SELECT:
 884             Name sname = fullName(((JCFieldAccess) tree).selected);
 885             return sname == null ? null : sname.append(&#39;.&#39;, name(tree));
 886         default:
 887             return null;
 888         }
 889     }
 890 
 891     public static Symbol symbolFor(JCTree node) {
 892         Symbol sym = symbolForImpl(node);
 893 
 894         return sym != null ? sym.baseSymbol() : null;
 895     }
 896 
 897     private static Symbol symbolForImpl(JCTree node) {
 898         node = skipParens(node);
 899         switch (node.getTag()) {
 900         case TOPLEVEL:
 901             JCCompilationUnit cut = (JCCompilationUnit) node;
 902             JCModuleDecl moduleDecl = cut.getModuleDecl();
 903             if (isModuleInfo(cut) &amp;&amp; moduleDecl != null)
 904                 return symbolFor(moduleDecl);
 905             return cut.packge;
 906         case MODULEDEF:
 907             return ((JCModuleDecl) node).sym;
 908         case PACKAGEDEF:
 909             return ((JCPackageDecl) node).packge;
 910         case CLASSDEF:
 911             return ((JCClassDecl) node).sym;
 912         case METHODDEF:
 913             return ((JCMethodDecl) node).sym;
 914         case VARDEF:
 915             return ((JCVariableDecl) node).sym;
 916         case IDENT:
 917             return ((JCIdent) node).sym;
 918         case SELECT:
 919             return ((JCFieldAccess) node).sym;
 920         case REFERENCE:
 921             return ((JCMemberReference) node).sym;
 922         case NEWCLASS:
 923             return ((JCNewClass) node).constructor;
 924         case APPLY:
 925             return symbolFor(((JCMethodInvocation) node).meth);
 926         case TYPEAPPLY:
 927             return symbolFor(((JCTypeApply) node).clazz);
 928         case ANNOTATION:
 929         case TYPE_ANNOTATION:
 930         case TYPEPARAMETER:
 931             if (node.type != null)
 932                 return node.type.tsym;
 933             return null;
 934         case BINDINGPATTERN:
 935             return ((JCBindingPattern) node).symbol;
 936         default:
 937             return null;
 938         }
 939     }
 940 
 941     public static boolean isDeclaration(JCTree node) {
 942         node = skipParens(node);
 943         switch (node.getTag()) {
 944         case PACKAGEDEF:
 945         case CLASSDEF:
 946         case METHODDEF:
 947         case VARDEF:
 948             return true;
 949         default:
 950             return false;
 951         }
 952     }
 953 
 954     /** If this tree is an identifier or a field, return its symbol,
 955      *  otherwise return null.
 956      */
 957     public static Symbol symbol(JCTree tree) {
 958         tree = skipParens(tree);
 959         switch (tree.getTag()) {
 960         case IDENT:
 961             return ((JCIdent) tree).sym;
 962         case SELECT:
 963             return ((JCFieldAccess) tree).sym;
 964         case TYPEAPPLY:
 965             return symbol(((JCTypeApply) tree).clazz);
 966         case ANNOTATED_TYPE:
 967             return symbol(((JCAnnotatedType) tree).underlyingType);
 968         case REFERENCE:
 969             return ((JCMemberReference) tree).sym;
 970         default:
 971             return null;
 972         }
 973     }
 974 
 975     /** If this tree has a modifiers field, return it otherwise return null
 976      */
 977     public static JCModifiers getModifiers(JCTree tree) {
 978         tree = skipParens(tree);
 979         switch (tree.getTag()) {
 980             case VARDEF:
 981                 return ((JCVariableDecl) tree).mods;
 982             case METHODDEF:
 983                 return ((JCMethodDecl) tree).mods;
 984             case CLASSDEF:
 985                 return ((JCClassDecl) tree).mods;
 986             case MODULEDEF:
 987                 return ((JCModuleDecl) tree).mods;
 988         default:
 989             return null;
 990         }
 991     }
 992 
 993     /** Return true if this is a nonstatic selection. */
 994     public static boolean nonstaticSelect(JCTree tree) {
 995         tree = skipParens(tree);
 996         if (!tree.hasTag(SELECT)) return false;
 997         JCFieldAccess s = (JCFieldAccess) tree;
 998         Symbol e = symbol(s.selected);
 999         return e == null || (e.kind != PCK &amp;&amp; e.kind != TYP);
1000     }
1001 
1002     /** If this tree is an identifier or a field, set its symbol, otherwise skip.
1003      */
1004     public static void setSymbol(JCTree tree, Symbol sym) {
1005         tree = skipParens(tree);
1006         switch (tree.getTag()) {
1007         case IDENT:
1008             ((JCIdent) tree).sym = sym; break;
1009         case SELECT:
1010             ((JCFieldAccess) tree).sym = sym; break;
1011         default:
1012         }
1013     }
1014 
1015     /** If this tree is a declaration or a block, return its flags field,
1016      *  otherwise return 0.
1017      */
1018     public static long flags(JCTree tree) {
1019         switch (tree.getTag()) {
1020         case VARDEF:
1021             return ((JCVariableDecl) tree).mods.flags;
1022         case METHODDEF:
1023             return ((JCMethodDecl) tree).mods.flags;
1024         case CLASSDEF:
1025             return ((JCClassDecl) tree).mods.flags;
1026         case BLOCK:
1027             return ((JCBlock) tree).flags;
1028         default:
1029             return 0;
1030         }
1031     }
1032 
1033     /** Return first (smallest) flag in `flags&#39;:
1034      *  pre: flags != 0
1035      */
1036     public static long firstFlag(long flags) {
1037         long flag = 1;
1038         while ((flag &amp; flags &amp; ExtendedStandardFlags) == 0)
1039             flag = flag &lt;&lt; 1;
1040         return flag;
1041     }
1042 
1043     /** Return flags as a string, separated by &quot; &quot;.
1044      */
1045     public static String flagNames(long flags) {
1046         return Flags.toString(flags &amp; ExtendedStandardFlags).trim();
1047     }
1048 
1049     /** Operator precedences values.
1050      */
1051     public static final int
1052         notExpression = -1,   // not an expression
1053         noPrec = 0,           // no enclosing expression
1054         assignPrec = 1,
1055         assignopPrec = 2,
1056         condPrec = 3,
1057         orPrec = 4,
1058         andPrec = 5,
1059         bitorPrec = 6,
1060         bitxorPrec = 7,
1061         bitandPrec = 8,
1062         eqPrec = 9,
1063         ordPrec = 10,
1064         shiftPrec = 11,
1065         addPrec = 12,
1066         mulPrec = 13,
1067         prefixPrec = 14,
1068         postfixPrec = 15,
1069         precCount = 16;
1070 
1071 
1072     /** Map operators to their precedence levels.
1073      */
1074     public static int opPrec(JCTree.Tag op) {
1075         switch(op) {
1076         case POS:
1077         case NEG:
1078         case NOT:
1079         case COMPL:
1080         case PREINC:
1081         case PREDEC: return prefixPrec;
1082         case POSTINC:
1083         case POSTDEC:
1084         case NULLCHK: return postfixPrec;
1085         case ASSIGN: return assignPrec;
1086         case BITOR_ASG:
1087         case BITXOR_ASG:
1088         case BITAND_ASG:
1089         case SL_ASG:
1090         case SR_ASG:
1091         case USR_ASG:
1092         case PLUS_ASG:
1093         case MINUS_ASG:
1094         case MUL_ASG:
1095         case DIV_ASG:
1096         case MOD_ASG: return assignopPrec;
1097         case OR: return orPrec;
1098         case AND: return andPrec;
1099         case EQ:
1100         case NE: return eqPrec;
1101         case LT:
1102         case GT:
1103         case LE:
1104         case GE: return ordPrec;
1105         case BITOR: return bitorPrec;
1106         case BITXOR: return bitxorPrec;
1107         case BITAND: return bitandPrec;
1108         case SL:
1109         case SR:
1110         case USR: return shiftPrec;
1111         case PLUS:
1112         case MINUS: return addPrec;
1113         case MUL:
1114         case DIV:
1115         case MOD: return mulPrec;
1116         case TYPETEST: return ordPrec;
1117         default: throw new AssertionError();
1118         }
1119     }
1120 
1121     static Tree.Kind tagToKind(JCTree.Tag tag) {
1122         switch (tag) {
1123         // Postfix expressions
1124         case POSTINC:           // _ ++
1125             return Tree.Kind.POSTFIX_INCREMENT;
1126         case POSTDEC:           // _ --
1127             return Tree.Kind.POSTFIX_DECREMENT;
1128 
1129         // Unary operators
1130         case PREINC:            // ++ _
1131             return Tree.Kind.PREFIX_INCREMENT;
1132         case PREDEC:            // -- _
1133             return Tree.Kind.PREFIX_DECREMENT;
1134         case POS:               // +
1135             return Tree.Kind.UNARY_PLUS;
1136         case NEG:               // -
1137             return Tree.Kind.UNARY_MINUS;
1138         case COMPL:             // ~
1139             return Tree.Kind.BITWISE_COMPLEMENT;
1140         case NOT:               // !
1141             return Tree.Kind.LOGICAL_COMPLEMENT;
1142 
1143         // Binary operators
1144 
1145         // Multiplicative operators
1146         case MUL:               // *
1147             return Tree.Kind.MULTIPLY;
1148         case DIV:               // /
1149             return Tree.Kind.DIVIDE;
1150         case MOD:               // %
1151             return Tree.Kind.REMAINDER;
1152 
1153         // Additive operators
1154         case PLUS:              // +
1155             return Tree.Kind.PLUS;
1156         case MINUS:             // -
1157             return Tree.Kind.MINUS;
1158 
1159         // Shift operators
1160         case SL:                // &lt;&lt;
1161             return Tree.Kind.LEFT_SHIFT;
1162         case SR:                // &gt;&gt;
1163             return Tree.Kind.RIGHT_SHIFT;
1164         case USR:               // &gt;&gt;&gt;
1165             return Tree.Kind.UNSIGNED_RIGHT_SHIFT;
1166 
1167         // Relational operators
1168         case LT:                // &lt;
1169             return Tree.Kind.LESS_THAN;
1170         case GT:                // &gt;
1171             return Tree.Kind.GREATER_THAN;
1172         case LE:                // &lt;=
1173             return Tree.Kind.LESS_THAN_EQUAL;
1174         case GE:                // &gt;=
1175             return Tree.Kind.GREATER_THAN_EQUAL;
1176 
1177         // Equality operators
1178         case EQ:                // ==
1179             return Tree.Kind.EQUAL_TO;
1180         case NE:                // !=
1181             return Tree.Kind.NOT_EQUAL_TO;
1182 
1183         // Bitwise and logical operators
1184         case BITAND:            // &amp;
1185             return Tree.Kind.AND;
1186         case BITXOR:            // ^
1187             return Tree.Kind.XOR;
1188         case BITOR:             // |
1189             return Tree.Kind.OR;
1190 
1191         // Conditional operators
1192         case AND:               // &amp;&amp;
1193             return Tree.Kind.CONDITIONAL_AND;
1194         case OR:                // ||
1195             return Tree.Kind.CONDITIONAL_OR;
1196 
1197         // Assignment operators
1198         case MUL_ASG:           // *=
1199             return Tree.Kind.MULTIPLY_ASSIGNMENT;
1200         case DIV_ASG:           // /=
1201             return Tree.Kind.DIVIDE_ASSIGNMENT;
1202         case MOD_ASG:           // %=
1203             return Tree.Kind.REMAINDER_ASSIGNMENT;
1204         case PLUS_ASG:          // +=
1205             return Tree.Kind.PLUS_ASSIGNMENT;
1206         case MINUS_ASG:         // -=
1207             return Tree.Kind.MINUS_ASSIGNMENT;
1208         case SL_ASG:            // &lt;&lt;=
1209             return Tree.Kind.LEFT_SHIFT_ASSIGNMENT;
1210         case SR_ASG:            // &gt;&gt;=
1211             return Tree.Kind.RIGHT_SHIFT_ASSIGNMENT;
1212         case USR_ASG:           // &gt;&gt;&gt;=
1213             return Tree.Kind.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT;
1214         case BITAND_ASG:        // &amp;=
1215             return Tree.Kind.AND_ASSIGNMENT;
1216         case BITXOR_ASG:        // ^=
1217             return Tree.Kind.XOR_ASSIGNMENT;
1218         case BITOR_ASG:         // |=
1219             return Tree.Kind.OR_ASSIGNMENT;
1220 
1221         // Null check (implementation detail), for example, __.getClass()
1222         case NULLCHK:
1223             return Tree.Kind.OTHER;
1224 
1225         case ANNOTATION:
1226             return Tree.Kind.ANNOTATION;
1227         case TYPE_ANNOTATION:
1228             return Tree.Kind.TYPE_ANNOTATION;
1229 
1230         case EXPORTS:
1231             return Tree.Kind.EXPORTS;
1232         case OPENS:
1233             return Tree.Kind.OPENS;
1234 
1235         default:
1236             return null;
1237         }
1238     }
1239 
1240     /**
1241      * Returns the underlying type of the tree if it is an annotated type,
1242      * or the tree itself otherwise.
1243      */
1244     public static JCExpression typeIn(JCExpression tree) {
1245         switch (tree.getTag()) {
1246         case ANNOTATED_TYPE:
1247             return ((JCAnnotatedType)tree).underlyingType;
1248         case IDENT: /* simple names */
1249         case TYPEIDENT: /* primitive name */
1250         case SELECT: /* qualified name */
1251         case TYPEARRAY: /* array types */
1252         case WILDCARD: /* wild cards */
1253         case TYPEPARAMETER: /* type parameters */
1254         case TYPEAPPLY: /* parameterized types */
1255         case ERRONEOUS: /* error tree TODO: needed for BadCast JSR308 test case. Better way? */
1256             return tree;
1257         default:
1258             throw new AssertionError(&quot;Unexpected type tree: &quot; + tree);
1259         }
1260     }
1261 
1262     /* Return the inner-most type of a type tree.
1263      * For an array that contains an annotated type, return that annotated type.
1264      * TODO: currently only used by Pretty. Describe behavior better.
1265      */
1266     public static JCTree innermostType(JCTree type, boolean skipAnnos) {
1267         JCTree lastAnnotatedType = null;
1268         JCTree cur = type;
1269         loop: while (true) {
1270             switch (cur.getTag()) {
1271             case TYPEARRAY:
1272                 lastAnnotatedType = null;
1273                 cur = ((JCArrayTypeTree)cur).elemtype;
1274                 break;
1275             case WILDCARD:
1276                 lastAnnotatedType = null;
1277                 cur = ((JCWildcard)cur).inner;
1278                 break;
1279             case ANNOTATED_TYPE:
1280                 lastAnnotatedType = cur;
1281                 cur = ((JCAnnotatedType)cur).underlyingType;
1282                 break;
1283             default:
1284                 break loop;
1285             }
1286         }
1287         if (!skipAnnos &amp;&amp; lastAnnotatedType!=null) {
1288             return lastAnnotatedType;
1289         } else {
1290             return cur;
1291         }
1292     }
1293 
1294     private static class TypeAnnotationFinder extends TreeScanner {
1295         public boolean foundTypeAnno = false;
1296 
1297         @Override
1298         public void scan(JCTree tree) {
1299             if (foundTypeAnno || tree == null)
1300                 return;
1301             super.scan(tree);
1302         }
1303 
1304         public void visitAnnotation(JCAnnotation tree) {
1305             foundTypeAnno = foundTypeAnno || tree.hasTag(TYPE_ANNOTATION);
1306         }
1307     }
1308 
1309     public static boolean containsTypeAnnotation(JCTree e) {
1310         TypeAnnotationFinder finder = new TypeAnnotationFinder();
1311         finder.scan(e);
1312         return finder.foundTypeAnno;
1313     }
1314 
1315     public static boolean isModuleInfo(JCCompilationUnit tree) {
1316         return tree.sourcefile.isNameCompatible(&quot;module-info&quot;, JavaFileObject.Kind.SOURCE)
1317                 &amp;&amp; tree.getModuleDecl() != null;
1318     }
1319 
1320     public static JCModuleDecl getModule(JCCompilationUnit t) {
1321         if (t.defs.nonEmpty()) {
1322             JCTree def = t.defs.head;
1323             if (def.hasTag(MODULEDEF))
1324                 return (JCModuleDecl) def;
1325         }
1326         return null;
1327     }
1328 
1329     public static boolean isPackageInfo(JCCompilationUnit tree) {
1330         return tree.sourcefile.isNameCompatible(&quot;package-info&quot;, JavaFileObject.Kind.SOURCE);
1331     }
1332 
1333 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Source.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Types.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 



























 417     public boolean isPublic() {
 418         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 419     }
 420 
 421     public boolean isEnum() {
 422         return (flags() &amp; ENUM) != 0;
 423     }
 424 
 425     public boolean isSealed() {
 426         return (flags_field &amp; SEALED) != 0;
 427     }
 428 
 429     public boolean isNonSealed() {
 430         return (flags_field &amp; NON_SEALED) != 0;
 431     }
 432 
 433     public boolean isFinal() {
 434         return (flags_field &amp; FINAL) != 0;
 435     }
 436 
</pre>
<hr />
<pre>
 438      *  to a method or variable initializer?
 439      *  Also includes fields of inner classes which are in
 440      *  turn local to a method or variable initializer.
 441      */
 442     public boolean isLocal() {
 443         return
 444             (owner.kind.matches(KindSelector.VAL_MTH) ||
 445              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 446     }
 447 
 448     /** Has this symbol an empty name? This includes anonymous
 449      *  inner classes.
 450      */
 451     public boolean isAnonymous() {
 452         return name.isEmpty();
 453     }
 454 
 455     /** Is this symbol a constructor?
 456      */
 457     public boolean isConstructor() {
<span class="line-modified"> 458         return name == name.table.names.init;</span>






 459     }
 460 
 461     public boolean isDynamic() {
 462         return false;
 463     }
 464 
 465     /** The fully qualified name of this symbol.
 466      *  This is the same as the symbol&#39;s name except for class symbols,
 467      *  which are handled separately.
 468      */
 469     public Name getQualifiedName() {
 470         return name;
 471     }
 472 
 473     /** The fully qualified name of this symbol after converting to flat
 474      *  representation. This is the same as the symbol&#39;s name except for
 475      *  class symbols, which are handled separately.
 476      */
 477     public Name flatName() {
 478         return getQualifiedName();
</pre>
<hr />
<pre>
 501     public boolean hasOuterInstance() {
 502         return
 503             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 504     }
 505 
 506     /** The closest enclosing class of this symbol&#39;s declaration.
 507      *  Warning: this (misnamed) method returns the receiver itself
 508      *  when the receiver is a class (as opposed to its enclosing
 509      *  class as one may be misled to believe.)
 510      */
 511     public ClassSymbol enclClass() {
 512         Symbol c = this;
 513         while (c != null &amp;&amp;
 514                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 515             c = c.owner;
 516         }
 517         return (ClassSymbol)c;
 518     }
 519 
 520     /** The outermost class which indirectly owns this symbol.


 521      */
 522     public ClassSymbol outermostClass() {
 523         Symbol sym = this;
 524         Symbol prev = null;
 525         while (sym.kind != PCK) {
 526             prev = sym;
 527             sym = sym.owner;
 528         }
<span class="line-modified"> 529         return (ClassSymbol) prev;</span>
 530     }
 531 
 532     /** The package which indirectly owns this symbol.
 533      */
 534     public PackageSymbol packge() {
 535         Symbol sym = this;
 536         while (sym.kind != PCK) {
 537             sym = sym.owner;
 538         }
 539         return (PackageSymbol) sym;
 540     }
 541 
 542     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 543      */
 544     public boolean isSubClass(Symbol base, Types types) {
 545         throw new AssertionError(&quot;isSubClass &quot; + this);
 546     }
 547 
 548     /** Fully check membership: hierarchy, protection, and hiding.
 549      *  Does not exclude methods not inherited due to overriding.
</pre>
<hr />
<pre>
1276         public JavaFileObject sourcefile;
1277 
1278         /** the classfile from where to load this class
1279          *  this will have extension .class or .java
1280          */
1281         public JavaFileObject classfile;
1282 
1283         /** the list of translated local classes (used for generating
1284          * InnerClasses attribute)
1285          */
1286         public List&lt;ClassSymbol&gt; trans_local;
1287 
1288         /** the annotation metadata attached to this class */
1289         private AnnotationTypeMetadata annotationTypeMetadata;
1290 
1291         /* the list of any of record components, only non empty if the class is a record
1292          * and it has at least one record component
1293          */
1294         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1295 






1296         // sealed classes related fields
1297         /** The classes, or interfaces, permitted to extend this class, or interface
1298          */
1299         public List&lt;Symbol&gt; permitted;
1300 
1301         public boolean isPermittedExplicit = false;
1302 
1303         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1304             super(TYP, flags, name, type, owner);
1305             this.members_field = null;
1306             this.fullname = formFullName(name, owner);
1307             this.flatname = formFlatName(name, owner);
1308             this.sourcefile = null;
1309             this.classfile = null;
1310             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1311             this.permitted = List.nil();
1312         }
1313 
1314         public ClassSymbol(long flags, Name name, Symbol owner) {
1315             this(
</pre>
<hr />
<pre>
1343         }
1344 
1345         @Override
1346         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1347             complete();
1348             return super.getRawTypeAttributes();
1349         }
1350 
1351         public Type erasure(Types types) {
1352             if (erasure_field == null)
1353                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1354                                               List.nil(), this,
1355                                               type.getMetadata());
1356             return erasure_field;
1357         }
1358 
1359         public String className() {
1360             if (name.isEmpty())
1361                 return
1362                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
<span class="line-modified">1363             else</span>
1364                 return fullname.toString();
1365         }
1366 
1367         @DefinedBy(Api.LANGUAGE_MODEL)
1368         public Name getQualifiedName() {
1369             return fullname;
1370         }
1371 
1372         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1373         public List&lt;Symbol&gt; getEnclosedElements() {
1374             List&lt;Symbol&gt; result = super.getEnclosedElements();
1375             if (!recordComponents.isEmpty()) {
1376                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1377                 for (RecordComponent rc : reversed) {
1378                     result = result.prepend(rc);
1379                 }
1380             }
1381             return result;
1382         }
1383 
</pre>
<hr />
<pre>
1601         @Override
1602         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1603             return annotationTypeMetadata;
1604         }
1605 
1606         @Override
1607         public boolean isAnnotationType() {
1608             return (flags_field &amp; Flags.ANNOTATION) != 0;
1609         }
1610 
1611         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1612             Assert.checkNonNull(a);
1613             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1614             this.annotationTypeMetadata = a;
1615         }
1616 
1617         public boolean isRecord() {
1618             return (flags_field &amp; RECORD) != 0;
1619         }
1620 























































1621         @DefinedBy(Api.LANGUAGE_MODEL)
1622         public List&lt;Type&gt; getPermittedSubclasses() {
1623             return permitted.map(s -&gt; s.type);
1624         }
1625     }
1626 
1627 
1628     /** A class for variable symbols
1629      */
1630     public static class VarSymbol extends Symbol implements VariableElement {
1631 
1632         /** The variable&#39;s declaration position.
1633          */
1634         public int pos = Position.NOPOS;
1635 
1636         /** The variable&#39;s address. Used for different purposes during
1637          *  flow analysis, translation and code generation.
1638          *  Flow analysis:
1639          *    If this is a blank final or local variable, its sequence number.
1640          *  Translation:
1641          *    If this is a private field, its access number.
1642          *  Code generation:
1643          *    If this is a local variable, its logical slot number.
1644          */
1645         public int adr = -1;
1646 





1647         /** Construct a variable symbol, given its flags, name, type and owner.
1648          */
1649         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1650             super(VAR, flags, name, type, owner);
1651         }
1652 
1653         @Override
1654         public int poolTag() {
1655             return ClassFile.CONSTANT_Fieldref;
1656         }
1657 
1658         public MethodHandleSymbol asMethodHandle(boolean getter) {
1659             return new MethodHandleSymbol(this, getter);
1660         }
1661 
1662         /** Clone this symbol with new owner.
1663          */
1664         public VarSymbol clone(Symbol newOwner) {
1665             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1666                 @Override
1667                 public Symbol baseSymbol() {
1668                     return VarSymbol.this;
1669                 }
1670 
1671                 @Override
1672                 public Object poolKey(Types types) {
1673                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1674                 }
1675             };
1676             v.pos = pos;
1677             v.adr = adr;
1678             v.data = data;

1679 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1680             return v;
1681         }
1682 
1683         public String toString() {
1684             return name.toString();
1685         }
1686 
1687         public Symbol asMemberOf(Type site, Types types) {
1688             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1689         }
1690 
1691         @DefinedBy(Api.LANGUAGE_MODEL)
1692         public ElementKind getKind() {
1693             long flags = flags();
1694             if ((flags &amp; PARAMETER) != 0) {
1695                 if (isExceptionParameter())
1696                     return ElementKind.EXCEPTION_PARAMETER;
1697                 else
1698                     return ElementKind.PARAMETER;
</pre>
<hr />
<pre>
1711             }
1712         }
1713 
1714         @DefinedBy(Api.LANGUAGE_MODEL)
1715         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1716             return v.visitVariable(this, p);
1717         }
1718 
1719         @DefinedBy(Api.LANGUAGE_MODEL)
1720         public Object getConstantValue() { // Mirror API
1721             return Constants.decode(getConstValue(), type);
1722         }
1723 
1724         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1725                                       final Attr attr,
1726                                       final JCVariableDecl variable)
1727         {
1728             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1729         }
1730 












1731         /**
1732          * The variable&#39;s constant value, if this is a constant.
1733          * Before the constant value is evaluated, it points to an
1734          * initializer environment.  If this is not a constant, it can
1735          * be used for other stuff.
1736          */
1737         private Object data;
1738 
1739         public boolean isExceptionParameter() {
1740             return data == ElementKind.EXCEPTION_PARAMETER;
1741         }
1742 
1743         public boolean isResourceVariable() {
1744             return data == ElementKind.RESOURCE_VARIABLE;
1745         }
1746 
1747         public Object getConstValue() {
1748             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1749             if (data == ElementKind.EXCEPTION_PARAMETER ||
1750                 data == ElementKind.RESOURCE_VARIABLE) {
</pre>
<hr />
<pre>
1872     public static class MethodSymbol extends Symbol implements ExecutableElement {
1873 
1874         /** The code of the method. */
1875         public Code code = null;
1876 
1877         /** The extra (synthetic/mandated) parameters of the method. */
1878         public List&lt;VarSymbol&gt; extraParams = List.nil();
1879 
1880         /** The captured local variables in an anonymous class */
1881         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1882 
1883         /** The parameters of the method. */
1884         public List&lt;VarSymbol&gt; params = null;
1885 
1886         /** For an annotation type element, its default value if any.
1887          *  The value is null if none appeared in the method
1888          *  declaration.
1889          */
1890         public Attribute defaultValue = null;
1891 





1892         /** Construct a method symbol, given its flags, name, type and owner.
1893          */
1894         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1895             super(MTH, flags, name, type, owner);
1896             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1897         }
1898 
1899         /** Clone this symbol with new owner.
1900          */
1901         public MethodSymbol clone(Symbol newOwner) {
1902             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1903                 @Override
1904                 public Symbol baseSymbol() {
1905                     return MethodSymbol.this;
1906                 }
1907 
1908                 @Override
1909                 public Object poolKey(Types types) {
1910                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1911                 }
1912             };
1913             m.code = code;

1914             return m;
1915         }
1916 
1917         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1918         public Set&lt;Modifier&gt; getModifiers() {
1919             long flags = flags();
1920             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
1921         }
1922 
1923         /** The Java source which this symbol represents.
1924          */
1925         public String toString() {
1926             if ((flags() &amp; BLOCK) != 0) {
1927                 return owner.name.toString();
1928             } else {
1929                 String s = (name == name.table.names.init)
1930                     ? owner.name.toString()
1931                     : name.toString();
1932                 if (type != null) {
1933                     if (type.hasTag(FORALL))
</pre>
<hr />
<pre>
2042             return overrides(_other, origin, types, checkResult, true);
2043         }
2044 
2045         /** Does this symbol override `other&#39; symbol, when both are seen as
2046          *  members of class `origin&#39;?  It is assumed that _other is a member
2047          *  of origin.
2048          *
2049          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2050          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2051          *  is false.
2052          *
2053          *  It is assumed that both symbols have the same name.  The static
2054          *  modifier is ignored for this test.
2055          *
2056          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2057          */
2058         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2059                                             boolean requireConcreteIfInherited) {
2060             if (isConstructor() || _other.kind != MTH) return false;
2061 










2062             if (this == _other) return true;
2063             MethodSymbol other = (MethodSymbol)_other;
2064 
2065             // check for a direct implementation
2066             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2067                 types.asSuper(owner.type, other.owner) != null) {
2068                 Type mt = types.memberType(owner.type, this);
2069                 Type ot = types.memberType(owner.type, other);
2070                 if (types.isSubSignature(mt, ot)) {
2071                     if (!checkResult)
2072                         return true;
2073                     if (types.returnTypeSubstitutable(mt, ot))
2074                         return true;
2075                 }
2076             }
2077 
2078             // check for an inherited implementation
2079             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2080                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2081                     !other.isOverridableIn(origin) ||
</pre>
<hr />
<pre>
2096             case Flags.PRIVATE:
2097                 return false;
2098             case Flags.PUBLIC:
2099                 return !this.owner.isInterface() ||
2100                         (flags_field &amp; STATIC) == 0;
2101             case Flags.PROTECTED:
2102                 return (origin.flags() &amp; INTERFACE) == 0;
2103             case 0:
2104                 // for package private: can only override in the same
2105                 // package
2106                 return
2107                     this.packge() == origin.packge() &amp;&amp;
2108                     (origin.flags() &amp; INTERFACE) == 0;
2109             default:
2110                 return false;
2111             }
2112         }
2113 
2114         @Override
2115         public boolean isInheritedIn(Symbol clazz, Types types) {









2116             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2117                 case PUBLIC:
2118                     return !this.owner.isInterface() ||
2119                             clazz == owner ||
2120                             (flags_field &amp; STATIC) == 0;
2121                 default:
2122                     return super.isInheritedIn(clazz, types);
2123             }
2124         }
2125 
2126         public boolean isLambdaMethod() {
2127             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2128         }
2129 












2130         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2131          *  lambda method
2132          */
2133         public MethodSymbol originalEnclosingMethod() {
2134             return this;
2135         }
2136 
2137         /** The implementation of this (abstract) symbol in class origin;
2138          *  null if none exists. Synthetic methods are not considered
2139          *  as possible implementations.
2140          */
2141         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2142             return implementation(origin, types, checkResult, implementation_filter);
2143         }
2144         // where
2145             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2146                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2147 
2148         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2149             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
</pre>
<hr />
<pre>
2403         private int accessCode = Integer.MIN_VALUE;
2404 
2405         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2406             super(PUBLIC | STATIC, name, type, owner);
2407             this.opcode = opcode;
2408         }
2409 
2410         @Override
2411         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2412             return v.visitOperatorSymbol(this, p);
2413         }
2414 
2415         public int getAccessCode(Tag tag) {
2416             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2417                 return accessCode;
2418             }
2419             accessCode = AccessCode.from(tag, opcode);
2420             return accessCode;
2421         }
2422 
<span class="line-modified">2423         /** Access codes for dereferencing, assignment,</span>
2424          *  and pre/post increment/decrement.
2425 
2426          *  All access codes for accesses to the current class are even.
2427          *  If a member of the superclass should be accessed instead (because
2428          *  access was via a qualified super), add one to the corresponding code
2429          *  for the current class, making the number odd.
2430          *  This numbering scheme is used by the backend to decide whether
2431          *  to issue an invokevirtual or invokespecial call.
2432          *
2433          *  @see Gen#visitSelect(JCFieldAccess tree)
2434          */
2435         public enum AccessCode {
2436             UNKNOWN(-1, Tag.NO_TAG),
2437             DEREF(0, Tag.NO_TAG),
2438             ASSIGN(2, Tag.ASSIGN),
2439             PREINC(4, Tag.PREINC),
2440             PREDEC(6, Tag.PREDEC),
2441             POSTINC(8, Tag.POSTINC),
2442             POSTDEC(10, Tag.POSTDEC),
<span class="line-modified">2443             FIRSTASGOP(12, Tag.NO_TAG);</span>

2444 
2445             public final int code;
2446             public final Tag tag;
2447             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2448 
2449             AccessCode(int code, Tag tag) {
2450                 this.code = code;
2451                 this.tag = tag;
2452             }
2453 
2454             static public AccessCode getFromCode(int code) {
2455                 for (AccessCode aCodes : AccessCode.values()) {
2456                     if (aCodes.code == code) {
2457                         return aCodes;
2458                     }
2459                 }
2460                 return UNKNOWN;
2461             }
2462 
2463             static int from(Tag tag, int opcode) {
2464                 /** Map bytecode of binary operation to access code of corresponding
2465                 *  assignment operation. This is always an even number.
2466                 */
2467                 switch (tag) {
2468                     case PREINC:
2469                         return AccessCode.PREINC.code;
2470                     case PREDEC:
2471                         return AccessCode.PREDEC.code;
2472                     case POSTINC:
2473                         return AccessCode.POSTINC.code;
2474                     case POSTDEC:
2475                         return AccessCode.POSTDEC.code;


2476                 }
2477                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2478                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2479                 } else if (opcode == string_add) {
2480                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2481                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2482                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2483                 }
2484                 return -1;
2485             }
2486         }
2487     }
2488 
2489     /** Symbol completer interface.
2490      */
2491     public static interface Completer {
2492 
2493         /** Dummy completer to be used when the symbol has been completed or
2494          * does not need completion.
2495          */
</pre>
</td>
<td>
<hr />
<pre>
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
<span class="line-added"> 417     public boolean isValue() {</span>
<span class="line-added"> 418         return (flags() &amp; VALUE) != 0;</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420 </span>
<span class="line-added"> 421     /**</span>
<span class="line-added"> 422      * Is this a *derived* reference projection symbol ??</span>
<span class="line-added"> 423      */</span>
<span class="line-added"> 424     public boolean isReferenceProjection() {</span>
<span class="line-added"> 425         return false;</span>
<span class="line-added"> 426     }</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428     /**</span>
<span class="line-added"> 429      * Return the value projection IFF &#39;this&#39; happens to be derived reference projection, null</span>
<span class="line-added"> 430      * otherwise.</span>
<span class="line-added"> 431      */</span>
<span class="line-added"> 432     public Symbol valueProjection() {</span>
<span class="line-added"> 433         return null;</span>
<span class="line-added"> 434     }</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436     /**</span>
<span class="line-added"> 437      * Return the reference projection IFF &#39;this&#39; happens to be value projection, null</span>
<span class="line-added"> 438      * otherwise.</span>
<span class="line-added"> 439      */</span>
<span class="line-added"> 440     public Symbol referenceProjection() {</span>
<span class="line-added"> 441         return null;</span>
<span class="line-added"> 442     }</span>
<span class="line-added"> 443 </span>
 444     public boolean isPublic() {
 445         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 446     }
 447 
 448     public boolean isEnum() {
 449         return (flags() &amp; ENUM) != 0;
 450     }
 451 
 452     public boolean isSealed() {
 453         return (flags_field &amp; SEALED) != 0;
 454     }
 455 
 456     public boolean isNonSealed() {
 457         return (flags_field &amp; NON_SEALED) != 0;
 458     }
 459 
 460     public boolean isFinal() {
 461         return (flags_field &amp; FINAL) != 0;
 462     }
 463 
</pre>
<hr />
<pre>
 465      *  to a method or variable initializer?
 466      *  Also includes fields of inner classes which are in
 467      *  turn local to a method or variable initializer.
 468      */
 469     public boolean isLocal() {
 470         return
 471             (owner.kind.matches(KindSelector.VAL_MTH) ||
 472              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 473     }
 474 
 475     /** Has this symbol an empty name? This includes anonymous
 476      *  inner classes.
 477      */
 478     public boolean isAnonymous() {
 479         return name.isEmpty();
 480     }
 481 
 482     /** Is this symbol a constructor?
 483      */
 484     public boolean isConstructor() {
<span class="line-modified"> 485         return name == name.table.names.init &amp;&amp; (flags() &amp; STATIC) == 0;</span>
<span class="line-added"> 486     }</span>
<span class="line-added"> 487 </span>
<span class="line-added"> 488     /** Is this symbol a value factory?</span>
<span class="line-added"> 489      */</span>
<span class="line-added"> 490     public boolean isValueFactory() {</span>
<span class="line-added"> 491         return ((name == name.table.names.init &amp;&amp; this.type.getReturnType().tsym == this.owner));</span>
 492     }
 493 
 494     public boolean isDynamic() {
 495         return false;
 496     }
 497 
 498     /** The fully qualified name of this symbol.
 499      *  This is the same as the symbol&#39;s name except for class symbols,
 500      *  which are handled separately.
 501      */
 502     public Name getQualifiedName() {
 503         return name;
 504     }
 505 
 506     /** The fully qualified name of this symbol after converting to flat
 507      *  representation. This is the same as the symbol&#39;s name except for
 508      *  class symbols, which are handled separately.
 509      */
 510     public Name flatName() {
 511         return getQualifiedName();
</pre>
<hr />
<pre>
 534     public boolean hasOuterInstance() {
 535         return
 536             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 537     }
 538 
 539     /** The closest enclosing class of this symbol&#39;s declaration.
 540      *  Warning: this (misnamed) method returns the receiver itself
 541      *  when the receiver is a class (as opposed to its enclosing
 542      *  class as one may be misled to believe.)
 543      */
 544     public ClassSymbol enclClass() {
 545         Symbol c = this;
 546         while (c != null &amp;&amp;
 547                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 548             c = c.owner;
 549         }
 550         return (ClassSymbol)c;
 551     }
 552 
 553     /** The outermost class which indirectly owns this symbol.
<span class="line-added"> 554      * &#39;outermost&#39; being a lexical construct, should transcend</span>
<span class="line-added"> 555      *  projections</span>
 556      */
 557     public ClassSymbol outermostClass() {
 558         Symbol sym = this;
 559         Symbol prev = null;
 560         while (sym.kind != PCK) {
 561             prev = sym;
 562             sym = sym.owner;
 563         }
<span class="line-modified"> 564         return (ClassSymbol) (prev!= null &amp;&amp; prev.isReferenceProjection() ? prev.valueProjection() : prev);</span>
 565     }
 566 
 567     /** The package which indirectly owns this symbol.
 568      */
 569     public PackageSymbol packge() {
 570         Symbol sym = this;
 571         while (sym.kind != PCK) {
 572             sym = sym.owner;
 573         }
 574         return (PackageSymbol) sym;
 575     }
 576 
 577     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 578      */
 579     public boolean isSubClass(Symbol base, Types types) {
 580         throw new AssertionError(&quot;isSubClass &quot; + this);
 581     }
 582 
 583     /** Fully check membership: hierarchy, protection, and hiding.
 584      *  Does not exclude methods not inherited due to overriding.
</pre>
<hr />
<pre>
1311         public JavaFileObject sourcefile;
1312 
1313         /** the classfile from where to load this class
1314          *  this will have extension .class or .java
1315          */
1316         public JavaFileObject classfile;
1317 
1318         /** the list of translated local classes (used for generating
1319          * InnerClasses attribute)
1320          */
1321         public List&lt;ClassSymbol&gt; trans_local;
1322 
1323         /** the annotation metadata attached to this class */
1324         private AnnotationTypeMetadata annotationTypeMetadata;
1325 
1326         /* the list of any of record components, only non empty if the class is a record
1327          * and it has at least one record component
1328          */
1329         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1330 
<span class="line-added">1331         /* the &#39;other&#39; projection: If &#39;this&#39; is an inline class then &#39;projection&#39; is its reference projection</span>
<span class="line-added">1332            and vice versa.</span>
<span class="line-added">1333          */</span>
<span class="line-added">1334         public ClassSymbol projection;</span>
<span class="line-added">1335 </span>
<span class="line-added">1336 </span>
1337         // sealed classes related fields
1338         /** The classes, or interfaces, permitted to extend this class, or interface
1339          */
1340         public List&lt;Symbol&gt; permitted;
1341 
1342         public boolean isPermittedExplicit = false;
1343 
1344         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1345             super(TYP, flags, name, type, owner);
1346             this.members_field = null;
1347             this.fullname = formFullName(name, owner);
1348             this.flatname = formFlatName(name, owner);
1349             this.sourcefile = null;
1350             this.classfile = null;
1351             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1352             this.permitted = List.nil();
1353         }
1354 
1355         public ClassSymbol(long flags, Name name, Symbol owner) {
1356             this(
</pre>
<hr />
<pre>
1384         }
1385 
1386         @Override
1387         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1388             complete();
1389             return super.getRawTypeAttributes();
1390         }
1391 
1392         public Type erasure(Types types) {
1393             if (erasure_field == null)
1394                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1395                                               List.nil(), this,
1396                                               type.getMetadata());
1397             return erasure_field;
1398         }
1399 
1400         public String className() {
1401             if (name.isEmpty())
1402                 return
1403                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
<span class="line-modified">1404 </span>
1405                 return fullname.toString();
1406         }
1407 
1408         @DefinedBy(Api.LANGUAGE_MODEL)
1409         public Name getQualifiedName() {
1410             return fullname;
1411         }
1412 
1413         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1414         public List&lt;Symbol&gt; getEnclosedElements() {
1415             List&lt;Symbol&gt; result = super.getEnclosedElements();
1416             if (!recordComponents.isEmpty()) {
1417                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1418                 for (RecordComponent rc : reversed) {
1419                     result = result.prepend(rc);
1420                 }
1421             }
1422             return result;
1423         }
1424 
</pre>
<hr />
<pre>
1642         @Override
1643         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1644             return annotationTypeMetadata;
1645         }
1646 
1647         @Override
1648         public boolean isAnnotationType() {
1649             return (flags_field &amp; Flags.ANNOTATION) != 0;
1650         }
1651 
1652         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1653             Assert.checkNonNull(a);
1654             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1655             this.annotationTypeMetadata = a;
1656         }
1657 
1658         public boolean isRecord() {
1659             return (flags_field &amp; RECORD) != 0;
1660         }
1661 
<span class="line-added">1662         @Override</span>
<span class="line-added">1663         public boolean isReferenceProjection() {</span>
<span class="line-added">1664             return projection != null &amp;&amp; projection.isValue();</span>
<span class="line-added">1665         }</span>
<span class="line-added">1666 </span>
<span class="line-added">1667         @Override</span>
<span class="line-added">1668         public ClassSymbol valueProjection() {</span>
<span class="line-added">1669             return isReferenceProjection() ? projection : null;</span>
<span class="line-added">1670         }</span>
<span class="line-added">1671 </span>
<span class="line-added">1672         @Override</span>
<span class="line-added">1673         public ClassSymbol referenceProjection() {</span>
<span class="line-added">1674             if (!isValue() || projection != null)</span>
<span class="line-added">1675                 return projection;</span>
<span class="line-added">1676 </span>
<span class="line-added">1677             ClassType ct = (ClassType) this.type;</span>
<span class="line-added">1678             ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);</span>
<span class="line-added">1679             projectedType.allparams_field = ct.allparams_field;</span>
<span class="line-added">1680             projectedType.supertype_field = ct.supertype_field;</span>
<span class="line-added">1681 </span>
<span class="line-added">1682             projectedType.interfaces_field = ct.interfaces_field;</span>
<span class="line-added">1683             projectedType.all_interfaces_field = ct.all_interfaces_field;</span>
<span class="line-added">1684             projectedType.projection = ct;</span>
<span class="line-added">1685             ct.projection = projectedType;</span>
<span class="line-added">1686 </span>
<span class="line-added">1687             Name projectionName = this.name.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1688             long projectionFlags = (this.flags() &amp; ~(VALUE | UNATTRIBUTED));</span>
<span class="line-added">1689 </span>
<span class="line-added">1690             projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);</span>
<span class="line-added">1691             projection.members_field = WriteableScope.create(projection);</span>
<span class="line-added">1692             for (Symbol s : this.members().getSymbols(s-&gt;(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {</span>
<span class="line-added">1693                 Symbol clone = null;</span>
<span class="line-added">1694                 if (s.kind == MTH) {</span>
<span class="line-added">1695                     MethodSymbol valMethod = (MethodSymbol)s;</span>
<span class="line-added">1696                     MethodSymbol refMethod = valMethod.clone(projection);</span>
<span class="line-added">1697                     valMethod.projection = refMethod;</span>
<span class="line-added">1698                     refMethod.projection = valMethod;</span>
<span class="line-added">1699                     clone = refMethod;</span>
<span class="line-added">1700                 } else if (s.kind == VAR) {</span>
<span class="line-added">1701                     VarSymbol valVar = (VarSymbol)s;</span>
<span class="line-added">1702                     VarSymbol refVar = valVar.clone(projection);</span>
<span class="line-added">1703                     valVar.projection = refVar;</span>
<span class="line-added">1704                     refVar.projection = valVar;</span>
<span class="line-added">1705                     clone = refVar;</span>
<span class="line-added">1706                 }</span>
<span class="line-added">1707                 projection.members_field.enter(clone);</span>
<span class="line-added">1708             }</span>
<span class="line-added">1709             projection.completer = Completer.NULL_COMPLETER;</span>
<span class="line-added">1710             projection.sourcefile = this.sourcefile;</span>
<span class="line-added">1711             projection.flatname = this.flatname.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1712             projection.projection = this;</span>
<span class="line-added">1713             projectedType.tsym = projection;</span>
<span class="line-added">1714             return projection;</span>
<span class="line-added">1715         }</span>
<span class="line-added">1716 </span>
1717         @DefinedBy(Api.LANGUAGE_MODEL)
1718         public List&lt;Type&gt; getPermittedSubclasses() {
1719             return permitted.map(s -&gt; s.type);
1720         }
1721     }
1722 
1723 
1724     /** A class for variable symbols
1725      */
1726     public static class VarSymbol extends Symbol implements VariableElement {
1727 
1728         /** The variable&#39;s declaration position.
1729          */
1730         public int pos = Position.NOPOS;
1731 
1732         /** The variable&#39;s address. Used for different purposes during
1733          *  flow analysis, translation and code generation.
1734          *  Flow analysis:
1735          *    If this is a blank final or local variable, its sequence number.
1736          *  Translation:
1737          *    If this is a private field, its access number.
1738          *  Code generation:
1739          *    If this is a local variable, its logical slot number.
1740          */
1741         public int adr = -1;
1742 
<span class="line-added">1743         /* The &#39;other&#39; projection: If &#39;this&#39; is a field of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">1744            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">1745         */</span>
<span class="line-added">1746         public VarSymbol projection;</span>
<span class="line-added">1747 </span>
1748         /** Construct a variable symbol, given its flags, name, type and owner.
1749          */
1750         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1751             super(VAR, flags, name, type, owner);
1752         }
1753 
1754         @Override
1755         public int poolTag() {
1756             return ClassFile.CONSTANT_Fieldref;
1757         }
1758 
1759         public MethodHandleSymbol asMethodHandle(boolean getter) {
1760             return new MethodHandleSymbol(this, getter);
1761         }
1762 
1763         /** Clone this symbol with new owner.
1764          */
1765         public VarSymbol clone(Symbol newOwner) {
1766             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1767                 @Override
1768                 public Symbol baseSymbol() {
1769                     return VarSymbol.this;
1770                 }
1771 
1772                 @Override
1773                 public Object poolKey(Types types) {
1774                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1775                 }
1776             };
1777             v.pos = pos;
1778             v.adr = adr;
1779             v.data = data;
<span class="line-added">1780             v.projection = projection;</span>
1781 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1782             return v;
1783         }
1784 
1785         public String toString() {
1786             return name.toString();
1787         }
1788 
1789         public Symbol asMemberOf(Type site, Types types) {
1790             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1791         }
1792 
1793         @DefinedBy(Api.LANGUAGE_MODEL)
1794         public ElementKind getKind() {
1795             long flags = flags();
1796             if ((flags &amp; PARAMETER) != 0) {
1797                 if (isExceptionParameter())
1798                     return ElementKind.EXCEPTION_PARAMETER;
1799                 else
1800                     return ElementKind.PARAMETER;
</pre>
<hr />
<pre>
1813             }
1814         }
1815 
1816         @DefinedBy(Api.LANGUAGE_MODEL)
1817         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1818             return v.visitVariable(this, p);
1819         }
1820 
1821         @DefinedBy(Api.LANGUAGE_MODEL)
1822         public Object getConstantValue() { // Mirror API
1823             return Constants.decode(getConstValue(), type);
1824         }
1825 
1826         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1827                                       final Attr attr,
1828                                       final JCVariableDecl variable)
1829         {
1830             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1831         }
1832 
<span class="line-added">1833         @Override</span>
<span class="line-added">1834         public VarSymbol referenceProjection() {</span>
<span class="line-added">1835             return this.owner.isValue() ?</span>
<span class="line-added">1836                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">1837                                : null;</span>
<span class="line-added">1838         }</span>
<span class="line-added">1839 </span>
<span class="line-added">1840         @Override</span>
<span class="line-added">1841         public VarSymbol valueProjection() {</span>
<span class="line-added">1842             return  projection != null ? projection.owner.isValue() ? projection : null: null;</span>
<span class="line-added">1843         }</span>
<span class="line-added">1844 </span>
1845         /**
1846          * The variable&#39;s constant value, if this is a constant.
1847          * Before the constant value is evaluated, it points to an
1848          * initializer environment.  If this is not a constant, it can
1849          * be used for other stuff.
1850          */
1851         private Object data;
1852 
1853         public boolean isExceptionParameter() {
1854             return data == ElementKind.EXCEPTION_PARAMETER;
1855         }
1856 
1857         public boolean isResourceVariable() {
1858             return data == ElementKind.RESOURCE_VARIABLE;
1859         }
1860 
1861         public Object getConstValue() {
1862             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1863             if (data == ElementKind.EXCEPTION_PARAMETER ||
1864                 data == ElementKind.RESOURCE_VARIABLE) {
</pre>
<hr />
<pre>
1986     public static class MethodSymbol extends Symbol implements ExecutableElement {
1987 
1988         /** The code of the method. */
1989         public Code code = null;
1990 
1991         /** The extra (synthetic/mandated) parameters of the method. */
1992         public List&lt;VarSymbol&gt; extraParams = List.nil();
1993 
1994         /** The captured local variables in an anonymous class */
1995         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1996 
1997         /** The parameters of the method. */
1998         public List&lt;VarSymbol&gt; params = null;
1999 
2000         /** For an annotation type element, its default value if any.
2001          *  The value is null if none appeared in the method
2002          *  declaration.
2003          */
2004         public Attribute defaultValue = null;
2005 
<span class="line-added">2006         /* The &#39;other&#39; projection: If &#39;this&#39; is a method of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">2007            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">2008         */</span>
<span class="line-added">2009         public MethodSymbol projection;</span>
<span class="line-added">2010 </span>
2011         /** Construct a method symbol, given its flags, name, type and owner.
2012          */
2013         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
2014             super(MTH, flags, name, type, owner);
2015             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
2016         }
2017 
2018         /** Clone this symbol with new owner.
2019          */
2020         public MethodSymbol clone(Symbol newOwner) {
2021             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
2022                 @Override
2023                 public Symbol baseSymbol() {
2024                     return MethodSymbol.this;
2025                 }
2026 
2027                 @Override
2028                 public Object poolKey(Types types) {
2029                     return new Pair&lt;&gt;(newOwner, baseSymbol());
2030                 }
2031             };
2032             m.code = code;
<span class="line-added">2033             m.projection = projection;</span>
2034             return m;
2035         }
2036 
2037         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2038         public Set&lt;Modifier&gt; getModifiers() {
2039             long flags = flags();
2040             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
2041         }
2042 
2043         /** The Java source which this symbol represents.
2044          */
2045         public String toString() {
2046             if ((flags() &amp; BLOCK) != 0) {
2047                 return owner.name.toString();
2048             } else {
2049                 String s = (name == name.table.names.init)
2050                     ? owner.name.toString()
2051                     : name.toString();
2052                 if (type != null) {
2053                     if (type.hasTag(FORALL))
</pre>
<hr />
<pre>
2162             return overrides(_other, origin, types, checkResult, true);
2163         }
2164 
2165         /** Does this symbol override `other&#39; symbol, when both are seen as
2166          *  members of class `origin&#39;?  It is assumed that _other is a member
2167          *  of origin.
2168          *
2169          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2170          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2171          *  is false.
2172          *
2173          *  It is assumed that both symbols have the same name.  The static
2174          *  modifier is ignored for this test.
2175          *
2176          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2177          */
2178         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2179                                             boolean requireConcreteIfInherited) {
2180             if (isConstructor() || _other.kind != MTH) return false;
2181 
<span class="line-added">2182 </span>
<span class="line-added">2183             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2184                where the hierarchy is navigable</span>
<span class="line-added">2185             */</span>
<span class="line-added">2186             if (origin.isValue())</span>
<span class="line-added">2187                 origin = (TypeSymbol) origin.referenceProjection();</span>
<span class="line-added">2188 </span>
<span class="line-added">2189             if (this.owner.isValue())</span>
<span class="line-added">2190                 return this.projection.overrides(_other, origin, types, checkResult, requireConcreteIfInherited);</span>
<span class="line-added">2191 </span>
2192             if (this == _other) return true;
2193             MethodSymbol other = (MethodSymbol)_other;
2194 
2195             // check for a direct implementation
2196             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2197                 types.asSuper(owner.type, other.owner) != null) {
2198                 Type mt = types.memberType(owner.type, this);
2199                 Type ot = types.memberType(owner.type, other);
2200                 if (types.isSubSignature(mt, ot)) {
2201                     if (!checkResult)
2202                         return true;
2203                     if (types.returnTypeSubstitutable(mt, ot))
2204                         return true;
2205                 }
2206             }
2207 
2208             // check for an inherited implementation
2209             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2210                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2211                     !other.isOverridableIn(origin) ||
</pre>
<hr />
<pre>
2226             case Flags.PRIVATE:
2227                 return false;
2228             case Flags.PUBLIC:
2229                 return !this.owner.isInterface() ||
2230                         (flags_field &amp; STATIC) == 0;
2231             case Flags.PROTECTED:
2232                 return (origin.flags() &amp; INTERFACE) == 0;
2233             case 0:
2234                 // for package private: can only override in the same
2235                 // package
2236                 return
2237                     this.packge() == origin.packge() &amp;&amp;
2238                     (origin.flags() &amp; INTERFACE) == 0;
2239             default:
2240                 return false;
2241             }
2242         }
2243 
2244         @Override
2245         public boolean isInheritedIn(Symbol clazz, Types types) {
<span class="line-added">2246 </span>
<span class="line-added">2247             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2248                where the hierarchy is navigable</span>
<span class="line-added">2249             */</span>
<span class="line-added">2250             if (clazz.isValue())</span>
<span class="line-added">2251                 clazz = clazz.referenceProjection();</span>
<span class="line-added">2252             if (this.owner.isValue())</span>
<span class="line-added">2253                 return this.projection.isInheritedIn(clazz, types);</span>
<span class="line-added">2254 </span>
2255             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2256                 case PUBLIC:
2257                     return !this.owner.isInterface() ||
2258                             clazz == owner ||
2259                             (flags_field &amp; STATIC) == 0;
2260                 default:
2261                     return super.isInheritedIn(clazz, types);
2262             }
2263         }
2264 
2265         public boolean isLambdaMethod() {
2266             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2267         }
2268 
<span class="line-added">2269         @Override</span>
<span class="line-added">2270         public MethodSymbol referenceProjection() {</span>
<span class="line-added">2271             return this.owner.isValue() ?</span>
<span class="line-added">2272                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">2273                     : null;</span>
<span class="line-added">2274         }</span>
<span class="line-added">2275 </span>
<span class="line-added">2276         @Override</span>
<span class="line-added">2277         public MethodSymbol valueProjection() {</span>
<span class="line-added">2278             return  projection != null ? projection.owner.isValue() ? projection : null : null;</span>
<span class="line-added">2279         }</span>
<span class="line-added">2280 </span>
2281         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2282          *  lambda method
2283          */
2284         public MethodSymbol originalEnclosingMethod() {
2285             return this;
2286         }
2287 
2288         /** The implementation of this (abstract) symbol in class origin;
2289          *  null if none exists. Synthetic methods are not considered
2290          *  as possible implementations.
2291          */
2292         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2293             return implementation(origin, types, checkResult, implementation_filter);
2294         }
2295         // where
2296             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2297                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2298 
2299         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2300             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
</pre>
<hr />
<pre>
2554         private int accessCode = Integer.MIN_VALUE;
2555 
2556         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2557             super(PUBLIC | STATIC, name, type, owner);
2558             this.opcode = opcode;
2559         }
2560 
2561         @Override
2562         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2563             return v.visitOperatorSymbol(this, p);
2564         }
2565 
2566         public int getAccessCode(Tag tag) {
2567             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2568                 return accessCode;
2569             }
2570             accessCode = AccessCode.from(tag, opcode);
2571             return accessCode;
2572         }
2573 
<span class="line-modified">2574         /** Access codes for dereferencing, assignment, withfield</span>
2575          *  and pre/post increment/decrement.
2576 
2577          *  All access codes for accesses to the current class are even.
2578          *  If a member of the superclass should be accessed instead (because
2579          *  access was via a qualified super), add one to the corresponding code
2580          *  for the current class, making the number odd.
2581          *  This numbering scheme is used by the backend to decide whether
2582          *  to issue an invokevirtual or invokespecial call.
2583          *
2584          *  @see Gen#visitSelect(JCFieldAccess tree)
2585          */
2586         public enum AccessCode {
2587             UNKNOWN(-1, Tag.NO_TAG),
2588             DEREF(0, Tag.NO_TAG),
2589             ASSIGN(2, Tag.ASSIGN),
2590             PREINC(4, Tag.PREINC),
2591             PREDEC(6, Tag.PREDEC),
2592             POSTINC(8, Tag.POSTINC),
2593             POSTDEC(10, Tag.POSTDEC),
<span class="line-modified">2594             WITHFIELD(12, Tag.WITHFIELD),</span>
<span class="line-added">2595             FIRSTASGOP(14, Tag.NO_TAG);</span>
2596 
2597             public final int code;
2598             public final Tag tag;
2599             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2600 
2601             AccessCode(int code, Tag tag) {
2602                 this.code = code;
2603                 this.tag = tag;
2604             }
2605 
2606             static public AccessCode getFromCode(int code) {
2607                 for (AccessCode aCodes : AccessCode.values()) {
2608                     if (aCodes.code == code) {
2609                         return aCodes;
2610                     }
2611                 }
2612                 return UNKNOWN;
2613             }
2614 
2615             static int from(Tag tag, int opcode) {
2616                 /** Map bytecode of binary operation to access code of corresponding
2617                 *  assignment operation. This is always an even number.
2618                 */
2619                 switch (tag) {
2620                     case PREINC:
2621                         return AccessCode.PREINC.code;
2622                     case PREDEC:
2623                         return AccessCode.PREDEC.code;
2624                     case POSTINC:
2625                         return AccessCode.POSTINC.code;
2626                     case POSTDEC:
2627                         return AccessCode.POSTDEC.code;
<span class="line-added">2628                     case WITHFIELD:</span>
<span class="line-added">2629                         return AccessCode.WITHFIELD.code;</span>
2630                 }
2631                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2632                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2633                 } else if (opcode == string_add) {
2634                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2635                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2636                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2637                 }
2638                 return -1;
2639             }
2640         }
2641     }
2642 
2643     /** Symbol completer interface.
2644      */
2645     public static interface Completer {
2646 
2647         /** Dummy completer to be used when the symbol has been completed or
2648          * does not need completion.
2649          */
</pre>
</td>
</tr>
</table>
<center><a href="Source.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Types.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
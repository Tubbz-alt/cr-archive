<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 




 108     /** Switch: allow sealed
 109      */
 110     boolean allowSealedTypes;
 111 
 112     /** Switch: allow records
 113      */
 114     boolean allowRecords;
 115 
 116    /** Lint option: warn about classfile issues
 117      */
 118     boolean lintClassfile;
 119 
 120     /** Switch: preserve parameter names from the variable table.
 121      */
 122     public boolean saveParameterNames;
 123 




 124     /**
 125      * The currently selected profile.
 126      */
 127     public final Profile profile;
 128 
 129     /** The log to use for verbose output
 130      */
 131     final Log log;
 132 
 133     /** The symbol table. */
 134     Symtab syms;
 135 
 136     Types types;
 137 
 138     /** The name table. */
 139     final Names names;
 140 
 141     /** Access to files
 142      */
 143     private final JavaFileManager fileManager;
</pre>
<hr />
<pre>
 255     protected ClassReader(Context context) {
 256         context.put(classReaderKey, this);
 257         annotate = Annotate.instance(context);
 258         names = Names.instance(context);
 259         syms = Symtab.instance(context);
 260         types = Types.instance(context);
 261         fileManager = context.get(JavaFileManager.class);
 262         if (fileManager == null)
 263             throw new AssertionError(&quot;FileManager initialization error&quot;);
 264         diagFactory = JCDiagnostic.Factory.instance(context);
 265         dcfh = DeferredCompletionFailureHandler.instance(context);
 266 
 267         log = Log.instance(context);
 268 
 269         Options options = Options.instance(context);
 270         verbose         = options.isSet(Option.VERBOSE);
 271 
 272         Source source = Source.instance(context);
 273         preview = Preview.instance(context);
 274         allowModules     = Feature.MODULES.allowedInSource(source);

 275         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 276                 Feature.RECORDS.allowedInSource(source);
 277         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 278                 Feature.SEALED_CLASSES.allowedInSource(source);
 279 
 280         saveParameterNames = options.isSet(PARAMETERS);

 281 
 282         profile = Profile.instance(context);
 283 
 284         typevars = WriteableScope.create(syms.noSymbol);
 285 
 286         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 287 
 288         initAttributeReaders();
 289     }
 290 
 291     /** Add member to class unless it is synthetic.
 292      */
 293     private void enterMember(ClassSymbol c, Symbol sym) {
 294         // Synthetic members are not entered -- reason lost to history (optimization?).
 295         // Lambda methods must be entered because they may have inner classes (which reference them)
 296         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 297             c.members_field.enter(sym);
 298     }
 299 
 300 /************************************************************************
</pre>
<hr />
<pre>
 452             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 453         }
 454         case &#39;B&#39;:
 455             sigp++;
 456             return syms.byteType;
 457         case &#39;C&#39;:
 458             sigp++;
 459             return syms.charType;
 460         case &#39;D&#39;:
 461             sigp++;
 462             return syms.doubleType;
 463         case &#39;F&#39;:
 464             sigp++;
 465             return syms.floatType;
 466         case &#39;I&#39;:
 467             sigp++;
 468             return syms.intType;
 469         case &#39;J&#39;:
 470             sigp++;
 471             return syms.longType;

 472         case &#39;L&#39;:
 473             {
 474                 // int oldsigp = sigp;
 475                 Type t = classSigToType();
 476                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 477                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 478                                        &quot;(please recompile from source)&quot;);
 479                 /*
 480                 System.err.println(&quot; decoded &quot; +
 481                                    new String(signature, oldsigp, sigp-oldsigp) +
 482                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 483                 */
 484                 return t;
 485             }
 486         case &#39;S&#39;:
 487             sigp++;
 488             return syms.shortType;
 489         case &#39;V&#39;:
 490             sigp++;
 491             return syms.voidType;
</pre>
<hr />
<pre>
 513             return new MethodType(argtypes,
 514                                   restype,
 515                                   thrown.reverse(),
 516                                   syms.methodClass);
 517         case &#39;&lt;&#39;:
 518             typevars = typevars.dup(currentOwner);
 519             Type poly = new ForAll(sigToTypeParams(), sigToType());
 520             typevars = typevars.leave();
 521             return poly;
 522         default:
 523             throw badClassFile(&quot;bad.signature&quot;,
 524                                Convert.utf2string(signature, sigp, 10));
 525         }
 526     }
 527 
 528     byte[] signatureBuffer = new byte[0];
 529     int sbp = 0;
 530     /** Convert class signature to type, where signature is implicit.
 531      */
 532     Type classSigToType() {
<span class="line-modified"> 533         if (signature[sigp] != &#39;L&#39;)</span>
 534             throw badClassFile(&quot;bad.class.signature&quot;,
 535                                Convert.utf2string(signature, sigp, 10));
 536         sigp++;
 537         Type outer = Type.noType;
 538         int startSbp = sbp;
 539 
 540         while (true) {
 541             final byte c = signature[sigp++];
 542             switch (c) {
 543 
 544             case &#39;;&#39;: {         // end
 545                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 546                                                          startSbp,
 547                                                          sbp - startSbp));
 548 
 549                 try {
 550                     return (outer == Type.noType) ?
 551                             t.erasure(types) :
 552                         new ClassType(outer, List.nil(), t);
 553                 } finally {
</pre>
<hr />
<pre>
 770         protected final Name name;
 771         protected final ClassFile.Version version;
 772         protected final Set&lt;AttributeKind&gt; kinds;
 773     }
 774 
 775     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 776             EnumSet.of(AttributeKind.CLASS);
 777     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 778             EnumSet.of(AttributeKind.MEMBER);
 779     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 780             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 781 
 782     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 783 
 784     private void initAttributeReaders() {
 785         AttributeReader[] readers = {
 786             // v45.3 attributes
 787 
 788             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 789                 protected void read(Symbol sym, int attrLen) {











 790                     if (saveParameterNames)
 791                         ((MethodSymbol)sym).code = readCode(sym);
 792                     else
 793                         bp = bp + attrLen;
 794                 }
 795             },
 796 
 797             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 798                 protected void read(Symbol sym, int attrLen) {
 799                     Object v = poolReader.getConstant(nextChar());
 800                     // Ignore ConstantValue attribute if field not final.
 801                     if ((sym.flags() &amp; FINAL) == 0) {
 802                         return;
 803                     }
 804                     VarSymbol var = (VarSymbol) sym;
 805                     switch (var.type.getTag()) {
 806                        case BOOLEAN:
 807                        case BYTE:
 808                        case CHAR:
 809                        case SHORT:
</pre>
<hr />
<pre>
1417         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1418         for (CompoundAnnotationProxy proxy : annotations) {
1419             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1420                 sym.flags_field |= PROPRIETARY;
1421             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1422                 if (profile != Profile.DEFAULT) {
1423                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1424                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1425                             Attribute.Constant c = (Attribute.Constant)v.snd;
1426                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1427                                 sym.flags_field |= NOT_IN_PROFILE;
1428                             }
1429                         }
1430                     }
1431                 }
1432             } else {
1433                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1434                     target = proxy;
1435                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1436                     repeatable = proxy;


1437                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1438                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1439                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1440                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1441                     sym.flags_field |= PREVIEW_API;
1442                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1443                 }
1444                 proxies.append(proxy);
1445             }
1446         }
1447         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1448     }
1449     //where:
1450         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1451             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1452                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1453                     Attribute.Constant c = (Attribute.Constant)v.snd;
1454                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1455                         sym.flags_field |= flag;
1456                     }
</pre>
<hr />
<pre>
2194      */
2195     MethodSymbol readMethod() {
2196         long flags = adjustMethodFlags(nextChar());
2197         Name name = poolReader.getName(nextChar());
2198         Type type = poolReader.getType(nextChar());
2199         if (currentOwner.isInterface() &amp;&amp;
2200                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2201             if (majorVersion &gt; Version.V52.major ||
2202                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2203                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2204                     currentOwner.flags_field |= DEFAULT;
2205                     flags |= DEFAULT | ABSTRACT;
2206                 }
2207             } else {
2208                 //protect against ill-formed classfiles
2209                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2210                                    Integer.toString(majorVersion),
2211                                    Integer.toString(minorVersion));
2212             }
2213         }







2214         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2215             // Sometimes anonymous classes don&#39;t have an outer
2216             // instance, however, there is no reliable way to tell so
2217             // we never strip this$n
2218             // ditto for local classes. Local classes that have an enclosing method set
2219             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2220             // enclosing method (i.e. from initializers) will pass that check.
2221             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2222             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2223                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2224                                       type.getReturnType(),
2225                                       type.getThrownTypes(),
2226                                       syms.methodClass);
2227         }
2228         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2229         if (types.isSignaturePolymorphic(m)) {
2230             m.flags_field |= SIGNATURE_POLYMORPHIC;
2231         }
2232         if (saveParameterNames)
2233             initParameterNames(m);
</pre>
<hr />
<pre>
2579         }
2580 
2581         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2582             if (!preview.isEnabled()) {
2583                 log.error(preview.disabledError(currentClassFile, majorVersion));
2584             } else {
2585                 preview.warnPreview(c.classfile, majorVersion);
2586             }
2587         }
2588 
2589         poolReader = new PoolReader(this, names, syms);
2590         bp = poolReader.readPool(buf, bp);
2591         if (signatureBuffer.length &lt; bp) {
2592             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2593             signatureBuffer = new byte[ns];
2594         }
2595         readClass(c);
2596     }
2597 
2598     public void readClassFile(ClassSymbol c) {


























2599         currentOwner = c;
2600         currentClassFile = c.classfile;
2601         warnedAttrs.clear();
2602         filling = true;
2603         target = null;
2604         repeatable = null;
2605         try {
2606             bp = 0;
2607             buf.reset();
2608             buf.appendStream(c.classfile.openInputStream());
2609             readClassBuffer(c);
2610             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2611                 List&lt;Type&gt; missing = missingTypeVariables;
2612                 List&lt;Type&gt; found = foundTypeVariables;
2613                 missingTypeVariables = List.nil();
2614                 foundTypeVariables = List.nil();
2615                 interimUses = List.nil();
2616                 interimProvides = List.nil();
2617                 filling = false;
2618                 ClassType ct = (ClassType)currentOwner.type;
</pre>
<hr />
<pre>
2674         return flags;
2675     }
2676 
2677     long adjustMethodFlags(long flags) {
2678         if ((flags &amp; ACC_BRIDGE) != 0) {
2679             flags &amp;= ~ACC_BRIDGE;
2680             flags |= BRIDGE;
2681         }
2682         if ((flags &amp; ACC_VARARGS) != 0) {
2683             flags &amp;= ~ACC_VARARGS;
2684             flags |= VARARGS;
2685         }
2686         return flags;
2687     }
2688 
2689     long adjustClassFlags(long flags) {
2690         if ((flags &amp; ACC_MODULE) != 0) {
2691             flags &amp;= ~ACC_MODULE;
2692             flags |= MODULE;
2693         }




2694         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2695     }
2696 
2697     /**
2698      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2699      * The attribute is only the last component of the original filename, so is unlikely
2700      * to be valid as is, so operations other than those to access the name throw
2701      * UnsupportedOperationException
2702      */
2703     private static class SourceFileObject implements JavaFileObject {
2704 
2705         /** The file&#39;s name.
2706          */
2707         private final Name name;
2708 
2709         public SourceFileObject(Name name) {
2710             this.name = name;
2711         }
2712 
2713         @Override @DefinedBy(Api.COMPILER)
</pre>
</td>
<td>
<hr />
<pre>
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
<span class="line-added"> 108     /** Switch: allow inline types.</span>
<span class="line-added"> 109      */</span>
<span class="line-added"> 110     boolean allowInlineTypes;</span>
<span class="line-added"> 111 </span>
 112     /** Switch: allow sealed
 113      */
 114     boolean allowSealedTypes;
 115 
 116     /** Switch: allow records
 117      */
 118     boolean allowRecords;
 119 
 120    /** Lint option: warn about classfile issues
 121      */
 122     boolean lintClassfile;
 123 
 124     /** Switch: preserve parameter names from the variable table.
 125      */
 126     public boolean saveParameterNames;
 127 
<span class="line-added"> 128     /** Switch: Should javac recongnize and handle value based classes specially ?</span>
<span class="line-added"> 129      */</span>
<span class="line-added"> 130     private boolean allowValueBasedClasses;</span>
<span class="line-added"> 131 </span>
 132     /**
 133      * The currently selected profile.
 134      */
 135     public final Profile profile;
 136 
 137     /** The log to use for verbose output
 138      */
 139     final Log log;
 140 
 141     /** The symbol table. */
 142     Symtab syms;
 143 
 144     Types types;
 145 
 146     /** The name table. */
 147     final Names names;
 148 
 149     /** Access to files
 150      */
 151     private final JavaFileManager fileManager;
</pre>
<hr />
<pre>
 263     protected ClassReader(Context context) {
 264         context.put(classReaderKey, this);
 265         annotate = Annotate.instance(context);
 266         names = Names.instance(context);
 267         syms = Symtab.instance(context);
 268         types = Types.instance(context);
 269         fileManager = context.get(JavaFileManager.class);
 270         if (fileManager == null)
 271             throw new AssertionError(&quot;FileManager initialization error&quot;);
 272         diagFactory = JCDiagnostic.Factory.instance(context);
 273         dcfh = DeferredCompletionFailureHandler.instance(context);
 274 
 275         log = Log.instance(context);
 276 
 277         Options options = Options.instance(context);
 278         verbose         = options.isSet(Option.VERBOSE);
 279 
 280         Source source = Source.instance(context);
 281         preview = Preview.instance(context);
 282         allowModules     = Feature.MODULES.allowedInSource(source);
<span class="line-added"> 283         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);</span>
 284         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 285                 Feature.RECORDS.allowedInSource(source);
 286         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 287                 Feature.SEALED_CLASSES.allowedInSource(source);
 288 
 289         saveParameterNames = options.isSet(PARAMETERS);
<span class="line-added"> 290         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);</span>
 291 
 292         profile = Profile.instance(context);
 293 
 294         typevars = WriteableScope.create(syms.noSymbol);
 295 
 296         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 297 
 298         initAttributeReaders();
 299     }
 300 
 301     /** Add member to class unless it is synthetic.
 302      */
 303     private void enterMember(ClassSymbol c, Symbol sym) {
 304         // Synthetic members are not entered -- reason lost to history (optimization?).
 305         // Lambda methods must be entered because they may have inner classes (which reference them)
 306         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 307             c.members_field.enter(sym);
 308     }
 309 
 310 /************************************************************************
</pre>
<hr />
<pre>
 462             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 463         }
 464         case &#39;B&#39;:
 465             sigp++;
 466             return syms.byteType;
 467         case &#39;C&#39;:
 468             sigp++;
 469             return syms.charType;
 470         case &#39;D&#39;:
 471             sigp++;
 472             return syms.doubleType;
 473         case &#39;F&#39;:
 474             sigp++;
 475             return syms.floatType;
 476         case &#39;I&#39;:
 477             sigp++;
 478             return syms.intType;
 479         case &#39;J&#39;:
 480             sigp++;
 481             return syms.longType;
<span class="line-added"> 482         case &#39;Q&#39;:</span>
 483         case &#39;L&#39;:
 484             {
 485                 // int oldsigp = sigp;
 486                 Type t = classSigToType();
 487                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 488                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 489                                        &quot;(please recompile from source)&quot;);
 490                 /*
 491                 System.err.println(&quot; decoded &quot; +
 492                                    new String(signature, oldsigp, sigp-oldsigp) +
 493                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 494                 */
 495                 return t;
 496             }
 497         case &#39;S&#39;:
 498             sigp++;
 499             return syms.shortType;
 500         case &#39;V&#39;:
 501             sigp++;
 502             return syms.voidType;
</pre>
<hr />
<pre>
 524             return new MethodType(argtypes,
 525                                   restype,
 526                                   thrown.reverse(),
 527                                   syms.methodClass);
 528         case &#39;&lt;&#39;:
 529             typevars = typevars.dup(currentOwner);
 530             Type poly = new ForAll(sigToTypeParams(), sigToType());
 531             typevars = typevars.leave();
 532             return poly;
 533         default:
 534             throw badClassFile(&quot;bad.signature&quot;,
 535                                Convert.utf2string(signature, sigp, 10));
 536         }
 537     }
 538 
 539     byte[] signatureBuffer = new byte[0];
 540     int sbp = 0;
 541     /** Convert class signature to type, where signature is implicit.
 542      */
 543     Type classSigToType() {
<span class="line-modified"> 544         if (signature[sigp] != &#39;L&#39; &amp;&amp; signature[sigp] != &#39;Q&#39;)</span>
 545             throw badClassFile(&quot;bad.class.signature&quot;,
 546                                Convert.utf2string(signature, sigp, 10));
 547         sigp++;
 548         Type outer = Type.noType;
 549         int startSbp = sbp;
 550 
 551         while (true) {
 552             final byte c = signature[sigp++];
 553             switch (c) {
 554 
 555             case &#39;;&#39;: {         // end
 556                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 557                                                          startSbp,
 558                                                          sbp - startSbp));
 559 
 560                 try {
 561                     return (outer == Type.noType) ?
 562                             t.erasure(types) :
 563                         new ClassType(outer, List.nil(), t);
 564                 } finally {
</pre>
<hr />
<pre>
 781         protected final Name name;
 782         protected final ClassFile.Version version;
 783         protected final Set&lt;AttributeKind&gt; kinds;
 784     }
 785 
 786     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 787             EnumSet.of(AttributeKind.CLASS);
 788     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 789             EnumSet.of(AttributeKind.MEMBER);
 790     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 791             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 792 
 793     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 794 
 795     private void initAttributeReaders() {
 796         AttributeReader[] readers = {
 797             // v45.3 attributes
 798 
 799             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 800                 protected void read(Symbol sym, int attrLen) {
<span class="line-added"> 801                     if (allowInlineTypes) {</span>
<span class="line-added"> 802                         if (sym.isConstructor()  &amp;&amp; ((MethodSymbol) sym).type.getParameterTypes().size() == 0) {</span>
<span class="line-added"> 803                             int code_length = buf.getInt(bp + 4);</span>
<span class="line-added"> 804                             if ((code_length == 1 &amp;&amp; buf.getByte( bp + 8) == (byte) ByteCodes.return_) ||</span>
<span class="line-added"> 805                                     (code_length == 5 &amp;&amp; buf.getByte(bp + 8) == ByteCodes.aload_0 &amp;&amp;</span>
<span class="line-added"> 806                                         buf.getByte( bp + 9) == (byte) ByteCodes.invokespecial &amp;&amp;</span>
<span class="line-added"> 807                                                 buf.getByte( bp + 12) == (byte) ByteCodes.return_)) {</span>
<span class="line-added"> 808                                     sym.flags_field |= EMPTYNOARGCONSTR;</span>
<span class="line-added"> 809                             }</span>
<span class="line-added"> 810                         }</span>
<span class="line-added"> 811                     }</span>
 812                     if (saveParameterNames)
 813                         ((MethodSymbol)sym).code = readCode(sym);
 814                     else
 815                         bp = bp + attrLen;
 816                 }
 817             },
 818 
 819             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 820                 protected void read(Symbol sym, int attrLen) {
 821                     Object v = poolReader.getConstant(nextChar());
 822                     // Ignore ConstantValue attribute if field not final.
 823                     if ((sym.flags() &amp; FINAL) == 0) {
 824                         return;
 825                     }
 826                     VarSymbol var = (VarSymbol) sym;
 827                     switch (var.type.getTag()) {
 828                        case BOOLEAN:
 829                        case BYTE:
 830                        case CHAR:
 831                        case SHORT:
</pre>
<hr />
<pre>
1439         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1440         for (CompoundAnnotationProxy proxy : annotations) {
1441             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1442                 sym.flags_field |= PROPRIETARY;
1443             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1444                 if (profile != Profile.DEFAULT) {
1445                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1446                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1447                             Attribute.Constant c = (Attribute.Constant)v.snd;
1448                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1449                                 sym.flags_field |= NOT_IN_PROFILE;
1450                             }
1451                         }
1452                     }
1453                 }
1454             } else {
1455                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1456                     target = proxy;
1457                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1458                     repeatable = proxy;
<span class="line-added">1459                 } else if (allowValueBasedClasses &amp;&amp; sym.kind == TYP &amp;&amp; proxy.type.tsym == syms.valueBasedType.tsym) {</span>
<span class="line-added">1460                     sym.flags_field |= VALUEBASED;</span>
1461                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1462                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1463                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1464                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1465                     sym.flags_field |= PREVIEW_API;
1466                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1467                 }
1468                 proxies.append(proxy);
1469             }
1470         }
1471         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1472     }
1473     //where:
1474         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1475             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1476                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1477                     Attribute.Constant c = (Attribute.Constant)v.snd;
1478                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1479                         sym.flags_field |= flag;
1480                     }
</pre>
<hr />
<pre>
2218      */
2219     MethodSymbol readMethod() {
2220         long flags = adjustMethodFlags(nextChar());
2221         Name name = poolReader.getName(nextChar());
2222         Type type = poolReader.getType(nextChar());
2223         if (currentOwner.isInterface() &amp;&amp;
2224                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2225             if (majorVersion &gt; Version.V52.major ||
2226                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2227                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2228                     currentOwner.flags_field |= DEFAULT;
2229                     flags |= DEFAULT | ABSTRACT;
2230                 }
2231             } else {
2232                 //protect against ill-formed classfiles
2233                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2234                                    Integer.toString(majorVersion),
2235                                    Integer.toString(minorVersion));
2236             }
2237         }
<span class="line-added">2238         if (name == names.init &amp;&amp; ((flags &amp; STATIC) != 0)) {</span>
<span class="line-added">2239             flags &amp;= ~STATIC;</span>
<span class="line-added">2240             type = new MethodType(type.getParameterTypes(),</span>
<span class="line-added">2241                     syms.voidType,</span>
<span class="line-added">2242                     type.getThrownTypes(),</span>
<span class="line-added">2243                     syms.methodClass);</span>
<span class="line-added">2244         }</span>
2245         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2246             // Sometimes anonymous classes don&#39;t have an outer
2247             // instance, however, there is no reliable way to tell so
2248             // we never strip this$n
2249             // ditto for local classes. Local classes that have an enclosing method set
2250             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2251             // enclosing method (i.e. from initializers) will pass that check.
2252             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2253             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2254                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2255                                       type.getReturnType(),
2256                                       type.getThrownTypes(),
2257                                       syms.methodClass);
2258         }
2259         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2260         if (types.isSignaturePolymorphic(m)) {
2261             m.flags_field |= SIGNATURE_POLYMORPHIC;
2262         }
2263         if (saveParameterNames)
2264             initParameterNames(m);
</pre>
<hr />
<pre>
2610         }
2611 
2612         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2613             if (!preview.isEnabled()) {
2614                 log.error(preview.disabledError(currentClassFile, majorVersion));
2615             } else {
2616                 preview.warnPreview(c.classfile, majorVersion);
2617             }
2618         }
2619 
2620         poolReader = new PoolReader(this, names, syms);
2621         bp = poolReader.readPool(buf, bp);
2622         if (signatureBuffer.length &lt; bp) {
2623             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2624             signatureBuffer = new byte[ns];
2625         }
2626         readClass(c);
2627     }
2628 
2629     public void readClassFile(ClassSymbol c) {
<span class="line-added">2630         readClassFileInternal(c);</span>
<span class="line-added">2631         if (c.isValue()) {</span>
<span class="line-added">2632             /* http://cr.openjdk.java.net/~briangoetz/valhalla/sov/04-translation.html</span>
<span class="line-added">2633                The relationship of value and reference projections differs between the language model</span>
<span class="line-added">2634                and the VM model. In the language, the value projection is not a subtype of the</span>
<span class="line-added">2635                reference projection; instead, the two are related by inline narrowing and widening</span>
<span class="line-added">2636                conversions, whereas in the VM, the two are related by actual subtyping.</span>
<span class="line-added">2637                Sever the subtyping relationship by rewiring the supertypes here and now.</span>
<span class="line-added">2638              */</span>
<span class="line-added">2639 </span>
<span class="line-added">2640             Name flatname = TypeSymbol.formFlatName(names.ref, c);</span>
<span class="line-added">2641             ClassSymbol referenceProjection = syms.getClass(currentModule, flatname);</span>
<span class="line-added">2642             if (referenceProjection != null) {</span>
<span class="line-added">2643                 if (referenceProjection.name != names.ref &amp;&amp; referenceProjection.owner.kind == PCK) {</span>
<span class="line-added">2644                     readClassFileInternal(referenceProjection);</span>
<span class="line-added">2645                     ClassType classType = (ClassType) c.type;</span>
<span class="line-added">2646                     classType.supertype_field = ((ClassType) referenceProjection.type).supertype_field;</span>
<span class="line-added">2647                     classType.interfaces_field = ((ClassType) referenceProjection.type).interfaces_field;</span>
<span class="line-added">2648                     // Discard the projection, it will be recomputed on the fly.</span>
<span class="line-added">2649                     referenceProjection.owner.members().remove(referenceProjection);</span>
<span class="line-added">2650                 }</span>
<span class="line-added">2651             }</span>
<span class="line-added">2652         }</span>
<span class="line-added">2653     }</span>
<span class="line-added">2654 </span>
<span class="line-added">2655     private void readClassFileInternal(ClassSymbol c) {</span>
2656         currentOwner = c;
2657         currentClassFile = c.classfile;
2658         warnedAttrs.clear();
2659         filling = true;
2660         target = null;
2661         repeatable = null;
2662         try {
2663             bp = 0;
2664             buf.reset();
2665             buf.appendStream(c.classfile.openInputStream());
2666             readClassBuffer(c);
2667             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2668                 List&lt;Type&gt; missing = missingTypeVariables;
2669                 List&lt;Type&gt; found = foundTypeVariables;
2670                 missingTypeVariables = List.nil();
2671                 foundTypeVariables = List.nil();
2672                 interimUses = List.nil();
2673                 interimProvides = List.nil();
2674                 filling = false;
2675                 ClassType ct = (ClassType)currentOwner.type;
</pre>
<hr />
<pre>
2731         return flags;
2732     }
2733 
2734     long adjustMethodFlags(long flags) {
2735         if ((flags &amp; ACC_BRIDGE) != 0) {
2736             flags &amp;= ~ACC_BRIDGE;
2737             flags |= BRIDGE;
2738         }
2739         if ((flags &amp; ACC_VARARGS) != 0) {
2740             flags &amp;= ~ACC_VARARGS;
2741             flags |= VARARGS;
2742         }
2743         return flags;
2744     }
2745 
2746     long adjustClassFlags(long flags) {
2747         if ((flags &amp; ACC_MODULE) != 0) {
2748             flags &amp;= ~ACC_MODULE;
2749             flags |= MODULE;
2750         }
<span class="line-added">2751         if ((flags &amp; ACC_VALUE) != 0) {</span>
<span class="line-added">2752             flags &amp;= ~ACC_VALUE;</span>
<span class="line-added">2753             flags |= allowInlineTypes ? VALUE : allowValueBasedClasses ? VALUEBASED : 0;</span>
<span class="line-added">2754         }</span>
2755         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2756     }
2757 
2758     /**
2759      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2760      * The attribute is only the last component of the original filename, so is unlikely
2761      * to be valid as is, so operations other than those to access the name throw
2762      * UnsupportedOperationException
2763      */
2764     private static class SourceFileObject implements JavaFileObject {
2765 
2766         /** The file&#39;s name.
2767          */
2768         private final Name name;
2769 
2770         public SourceFileObject(Name name) {
2771             this.name = name;
2772         }
2773 
2774         @Override @DefinedBy(Api.COMPILER)
</pre>
</td>
</tr>
</table>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
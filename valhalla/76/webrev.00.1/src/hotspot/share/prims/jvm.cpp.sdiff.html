<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiClassFileReconstituter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;

  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/jvmtiThreadState.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;prims/stackwalk.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/init.hpp&quot;
  67 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  68 #include &quot;runtime/deoptimization.hpp&quot;
  69 #include &quot;runtime/handshake.hpp&quot;
  70 #include &quot;runtime/java.hpp&quot;
  71 #include &quot;runtime/javaCalls.hpp&quot;
  72 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  73 #include &quot;runtime/jniHandles.inline.hpp&quot;
  74 #include &quot;runtime/os.inline.hpp&quot;
  75 #include &quot;runtime/perfData.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/synchronizer.hpp&quot;
</pre>
<hr />
<pre>
 694   JVMWrapper(&quot;JVM_Clone&quot;);
 695   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 696   Klass* klass = obj-&gt;klass();
 697   JvmtiVMObjectAllocEventCollector oam;
 698 
 699 #ifdef ASSERT
 700   // Just checking that the cloneable flag is set correct
 701   if (obj-&gt;is_array()) {
 702     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 703   } else {
 704     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 705     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 706     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 707   }
 708 #endif
 709 
 710   // Check if class of obj supports the Cloneable interface.
 711   // All arrays are considered to be cloneable (See JLS 20.1.5).
 712   // All j.l.r.Reference classes are considered non-cloneable.
 713   if (!klass-&gt;is_cloneable() ||

 714       (klass-&gt;is_instance_klass() &amp;&amp;
 715        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 716     ResourceMark rm(THREAD);
 717     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 718   }
 719 
 720   // Make shallow object copy
 721   const int size = obj-&gt;size();
 722   oop new_obj_oop = NULL;
 723   if (obj-&gt;is_array()) {
 724     const int length = ((arrayOop)obj())-&gt;length();
 725     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 726                                                    /* do_zero */ true, CHECK_NULL);
 727   } else {
 728     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 729   }
 730 
 731   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 732 
 733   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1237   return (jstring) JNIHandles::make_local(env, result);
1238 JVM_END
1239 
1240 
1241 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1242   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1243   JvmtiVMObjectAllocEventCollector oam;
1244   oop mirror = JNIHandles::resolve_non_null(cls);
1245 
1246   // Special handling for primitive objects
1247   if (java_lang_Class::is_primitive(mirror)) {
1248     // Primitive objects does not have any interfaces
1249     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1250     return (jobjectArray) JNIHandles::make_local(env, r);
1251   }
1252 
1253   Klass* klass = java_lang_Class::as_Klass(mirror);
1254   // Figure size of result array
1255   int size;
1256   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1257     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();</span>




1258   } else {
1259     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1260     size = 2;</span>
1261   }
1262 
1263   // Allocate result array
1264   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1265   objArrayHandle result (THREAD, r);
1266   // Fill in result
1267   if (klass-&gt;is_instance_klass()) {
1268     // Regular instance klass, fill in all local interfaces

1269     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1270       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-modified">1271       result-&gt;obj_at_put(index, k-&gt;java_mirror());</span>



1272     }
1273   } else {
<span class="line-modified">1274     // All arrays implement java.lang.Cloneable and java.io.Serializable</span>
1275     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1276     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());

1277   }
1278   return (jobjectArray) JNIHandles::make_local(env, result());
1279 JVM_END
1280 
1281 
1282 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1283   JVMWrapper(&quot;JVM_IsInterface&quot;);
1284   oop mirror = JNIHandles::resolve_non_null(cls);
1285   if (java_lang_Class::is_primitive(mirror)) {
1286     return JNI_FALSE;
1287   }
1288   Klass* k = java_lang_Class::as_Klass(mirror);
1289   jboolean result = k-&gt;is_interface();
1290   assert(!result || k-&gt;is_instance_klass(),
1291          &quot;all interfaces are instance types&quot;);
1292   // The compiler intrinsic for isInterface tests the
1293   // Klass::_access_flags bits in the same way.
1294   return result;
1295 JVM_END
1296 
</pre>
<hr />
<pre>
1876         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1877       objArrayHandle components_h (THREAD, record_components);
1878 
1879       for (int x = 0; x &lt; length; x++) {
1880         RecordComponent* component = components-&gt;at(x);
1881         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1882         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1883         components_h-&gt;obj_at_put(x, component_oop);
1884       }
1885       return (jobjectArray)JNIHandles::make_local(components_h());
1886     }
1887   }
1888 
1889   // Return empty array if ofClass is not a record.
1890   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1891   return (jobjectArray)JNIHandles::make_local(env, result);
1892 }
1893 JVM_END
1894 
1895 static bool select_method(const methodHandle&amp; method, bool want_constructor) {


1896   if (want_constructor) {
<span class="line-modified">1897     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());</span>
1898   } else {
<span class="line-modified">1899     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());</span>


1900   }
1901 }
1902 
1903 static jobjectArray get_class_declared_methods_helper(
1904                                   JNIEnv *env,
1905                                   jclass ofClass, jboolean publicOnly,
1906                                   bool want_constructor,
1907                                   Klass* klass, TRAPS) {
1908 
1909   JvmtiVMObjectAllocEventCollector oam;
1910 
1911   // Exclude primitive types and array types
1912   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1913       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1914     // Return empty array
1915     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1916     return (jobjectArray) JNIHandles::make_local(env, res);
1917   }
1918 
1919   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1941     }
1942   }
1943 
1944   // Allocate result
1945   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1946   objArrayHandle result (THREAD, r);
1947 
1948   // Now just put the methods that we selected above, but go by their idnum
1949   // in case of redefinition.  The methods can be redefined at any safepoint,
1950   // so above when allocating the oop array and below when creating reflect
1951   // objects.
1952   for (int i = 0; i &lt; num_methods; i++) {
1953     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1954     if (method.is_null()) {
1955       // Method may have been deleted and seems this API can handle null
1956       // Otherwise should probably put a method that throws NSME
1957       result-&gt;obj_at_put(i, NULL);
1958     } else {
1959       oop m;
1960       if (want_constructor) {


1961         m = Reflection::new_constructor(method, CHECK_NULL);
1962       } else {
1963         m = Reflection::new_method(method, false, CHECK_NULL);
1964       }
1965       result-&gt;obj_at_put(i, m);
1966     }
1967   }
1968 
1969   return (jobjectArray) JNIHandles::make_local(env, result());
1970 }
1971 
1972 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1973 {
1974   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1975   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1976                                            /*want_constructor*/ false,
1977                                            SystemDictionary::reflect_Method_klass(), THREAD);
1978 }
1979 JVM_END
1980 
</pre>
<hr />
<pre>
2198   constantTag tag = cp-&gt;tag_at(index);
2199   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2200     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2201   }
2202   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2203   Klass* k_o;
2204   if (force_resolution) {
2205     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2206   } else {
2207     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2208     if (k_o == NULL) return NULL;
2209   }
2210   InstanceKlass* k = InstanceKlass::cast(k_o);
2211   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2212   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2213   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2214   if (m.is_null()) {
2215     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2216   }
2217   oop method;
<span class="line-modified">2218   if (!m-&gt;is_initializer() || m-&gt;is_static()) {</span>
<span class="line-removed">2219     method = Reflection::new_method(m, true, CHECK_NULL);</span>
<span class="line-removed">2220   } else {</span>
2221     method = Reflection::new_constructor(m, CHECK_NULL);


2222   }
2223   return JNIHandles::make_local(method);
2224 }
2225 
2226 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2227 {
2228   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2229   JvmtiVMObjectAllocEventCollector oam;
2230   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2231   bounds_check(cp, index, CHECK_NULL);
2232   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2233   return res;
2234 }
2235 JVM_END
2236 
2237 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2238 {
2239   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2240   JvmtiVMObjectAllocEventCollector oam;
2241   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2489   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2490   if (!k-&gt;is_instance_klass()) return false;
2491 
2492   ResourceMark rm(THREAD);
2493   const char* name = k-&gt;name()-&gt;as_C_string();
2494   bool system_class = k-&gt;class_loader() == NULL;
2495   return JavaAssertions::enabled(name, system_class);
2496 
2497 JVM_END
2498 
2499 
2500 // Return a new AssertionStatusDirectives object with the fields filled in with
2501 // command-line assertion arguments (i.e., -ea, -da).
2502 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2503   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2504   JvmtiVMObjectAllocEventCollector oam;
2505   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2506   return JNIHandles::make_local(env, asd);
2507 JVM_END
2508 







































2509 // Verification ////////////////////////////////////////////////////////////////////////////////
2510 
2511 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2512 
2513 // RedefineClasses support: bug 6214132 caused verification to fail.
2514 // All functions from this section should call the jvmtiThreadSate function:
2515 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2516 // The function returns a Klass* of the _scratch_class if the verifier
2517 // was invoked in the middle of the class redefinition.
2518 // Otherwise it returns its argument value which is the _the_class Klass*.
2519 // Please, refer to the description in the jvmtiThreadSate.hpp.
2520 
2521 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2522   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2523   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2524   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2525   return k-&gt;name()-&gt;as_utf8();
2526 JVM_END
2527 
2528 
</pre>
<hr />
<pre>
2668   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2669   return method-&gt;size_of_parameters();
2670 JVM_END
2671 
2672 
2673 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2674   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2675   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2676   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2677   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2678   return method-&gt;verifier_max_stack();
2679 JVM_END
2680 
2681 
2682 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2683   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2684   ResourceMark rm(THREAD);
2685   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2686   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2687   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2688   return method-&gt;name() == vmSymbols::object_initializer_name();</span>
2689 JVM_END
2690 
2691 
2692 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2693   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2694   ResourceMark rm(THREAD);
2695   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2696   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2697   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2698   return method-&gt;is_overpass();
2699 JVM_END
2700 
2701 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2702   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2703   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2704   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2705   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2706   return method-&gt;name()-&gt;as_utf8();
2707 JVM_END
2708 
</pre>
<hr />
<pre>
3663   //   protection_domain. The protection_domain is passed as NULL by the java code
3664   //   if there is no security manager in 3-arg Class.forName().
3665   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3666 
3667   // Check if we should initialize the class
3668   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3669     klass-&gt;initialize(CHECK_NULL);
3670   }
3671   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3672 }
3673 
3674 
3675 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3676 
3677 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3678   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3679   Handle method_handle;
3680   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3681     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3682     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3683     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3684     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3685     jobject res = JNIHandles::make_local(env, result);
3686     if (JvmtiExport::should_post_vm_object_alloc()) {
3687       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3688       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3689       if (java_lang_Class::is_primitive(ret_type)) {
3690         // Only for primitive type vm allocates memory for java object.
3691         // See box() method.
3692         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3693       }
3694     }
3695     return res;
3696   } else {
3697     THROW_0(vmSymbols::java_lang_StackOverflowError());
3698   }
3699 JVM_END
3700 
3701 
3702 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3703   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);

3704   oop constructor_mirror = JNIHandles::resolve(c);
<span class="line-removed">3705   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3706   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3707   jobject res = JNIHandles::make_local(env, result);
3708   if (JvmtiExport::should_post_vm_object_alloc()) {
3709     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3710   }
3711   return res;
3712 JVM_END
3713 
3714 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3715 
3716 JVM_LEAF(jboolean, JVM_SupportsCX8())
3717   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3718   return VM_Version::supports_cx8();
3719 JVM_END
3720 
3721 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3722   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3723   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3724   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3725   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  58 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
  59 #include &quot;prims/jvm_misc.hpp&quot;
  60 #include &quot;prims/jvmtiExport.hpp&quot;
  61 #include &quot;prims/jvmtiThreadState.hpp&quot;
  62 #include &quot;prims/nativeLookup.hpp&quot;
  63 #include &quot;prims/stackwalk.hpp&quot;
  64 #include &quot;runtime/arguments.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/init.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/deoptimization.hpp&quot;
  70 #include &quot;runtime/handshake.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/os.inline.hpp&quot;
  76 #include &quot;runtime/perfData.hpp&quot;
  77 #include &quot;runtime/reflection.hpp&quot;
  78 #include &quot;runtime/synchronizer.hpp&quot;
</pre>
<hr />
<pre>
 695   JVMWrapper(&quot;JVM_Clone&quot;);
 696   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 697   Klass* klass = obj-&gt;klass();
 698   JvmtiVMObjectAllocEventCollector oam;
 699 
 700 #ifdef ASSERT
 701   // Just checking that the cloneable flag is set correct
 702   if (obj-&gt;is_array()) {
 703     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 704   } else {
 705     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 706     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 707     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 708   }
 709 #endif
 710 
 711   // Check if class of obj supports the Cloneable interface.
 712   // All arrays are considered to be cloneable (See JLS 20.1.5).
 713   // All j.l.r.Reference classes are considered non-cloneable.
 714   if (!klass-&gt;is_cloneable() ||
<span class="line-added"> 715        klass-&gt;is_value() ||</span>
 716       (klass-&gt;is_instance_klass() &amp;&amp;
 717        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 718     ResourceMark rm(THREAD);
 719     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 720   }
 721 
 722   // Make shallow object copy
 723   const int size = obj-&gt;size();
 724   oop new_obj_oop = NULL;
 725   if (obj-&gt;is_array()) {
 726     const int length = ((arrayOop)obj())-&gt;length();
 727     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 728                                                    /* do_zero */ true, CHECK_NULL);
 729   } else {
 730     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 731   }
 732 
 733   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 734 
 735   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1239   return (jstring) JNIHandles::make_local(env, result);
1240 JVM_END
1241 
1242 
1243 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1244   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1245   JvmtiVMObjectAllocEventCollector oam;
1246   oop mirror = JNIHandles::resolve_non_null(cls);
1247 
1248   // Special handling for primitive objects
1249   if (java_lang_Class::is_primitive(mirror)) {
1250     // Primitive objects does not have any interfaces
1251     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1252     return (jobjectArray) JNIHandles::make_local(env, r);
1253   }
1254 
1255   Klass* klass = java_lang_Class::as_Klass(mirror);
1256   // Figure size of result array
1257   int size;
1258   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1259     InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-added">1260     size = ik-&gt;local_interfaces()-&gt;length();</span>
<span class="line-added">1261     if (ik-&gt;has_injected_identityObject()) {</span>
<span class="line-added">1262       size--;</span>
<span class="line-added">1263     }</span>
1264   } else {
1265     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1266     size = 3;</span>
1267   }
1268 
1269   // Allocate result array
1270   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1271   objArrayHandle result (THREAD, r);
1272   // Fill in result
1273   if (klass-&gt;is_instance_klass()) {
1274     // Regular instance klass, fill in all local interfaces
<span class="line-added">1275     int cursor = 0;</span>
1276     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1277       InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-modified">1278       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-added">1279       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">1280         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());</span>
<span class="line-added">1281       }</span>
1282     }
1283   } else {
<span class="line-modified">1284     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject</span>
1285     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1286     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
<span class="line-added">1287     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());</span>
1288   }
1289   return (jobjectArray) JNIHandles::make_local(env, result());
1290 JVM_END
1291 
1292 
1293 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1294   JVMWrapper(&quot;JVM_IsInterface&quot;);
1295   oop mirror = JNIHandles::resolve_non_null(cls);
1296   if (java_lang_Class::is_primitive(mirror)) {
1297     return JNI_FALSE;
1298   }
1299   Klass* k = java_lang_Class::as_Klass(mirror);
1300   jboolean result = k-&gt;is_interface();
1301   assert(!result || k-&gt;is_instance_klass(),
1302          &quot;all interfaces are instance types&quot;);
1303   // The compiler intrinsic for isInterface tests the
1304   // Klass::_access_flags bits in the same way.
1305   return result;
1306 JVM_END
1307 
</pre>
<hr />
<pre>
1887         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1888       objArrayHandle components_h (THREAD, record_components);
1889 
1890       for (int x = 0; x &lt; length; x++) {
1891         RecordComponent* component = components-&gt;at(x);
1892         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1893         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1894         components_h-&gt;obj_at_put(x, component_oop);
1895       }
1896       return (jobjectArray)JNIHandles::make_local(components_h());
1897     }
1898   }
1899 
1900   // Return empty array if ofClass is not a record.
1901   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1902   return (jobjectArray)JNIHandles::make_local(env, result);
1903 }
1904 JVM_END
1905 
1906 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
<span class="line-added">1907   bool is_ctor = (method-&gt;is_object_constructor() ||</span>
<span class="line-added">1908                   method-&gt;is_static_init_factory());</span>
1909   if (want_constructor) {
<span class="line-modified">1910     return is_ctor;</span>
1911   } else {
<span class="line-modified">1912     return (!is_ctor &amp;&amp;</span>
<span class="line-added">1913             !method-&gt;is_class_initializer() &amp;&amp;</span>
<span class="line-added">1914             !method-&gt;is_overpass());</span>
1915   }
1916 }
1917 
1918 static jobjectArray get_class_declared_methods_helper(
1919                                   JNIEnv *env,
1920                                   jclass ofClass, jboolean publicOnly,
1921                                   bool want_constructor,
1922                                   Klass* klass, TRAPS) {
1923 
1924   JvmtiVMObjectAllocEventCollector oam;
1925 
1926   // Exclude primitive types and array types
1927   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1928       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1929     // Return empty array
1930     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1931     return (jobjectArray) JNIHandles::make_local(env, res);
1932   }
1933 
1934   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1956     }
1957   }
1958 
1959   // Allocate result
1960   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1961   objArrayHandle result (THREAD, r);
1962 
1963   // Now just put the methods that we selected above, but go by their idnum
1964   // in case of redefinition.  The methods can be redefined at any safepoint,
1965   // so above when allocating the oop array and below when creating reflect
1966   // objects.
1967   for (int i = 0; i &lt; num_methods; i++) {
1968     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1969     if (method.is_null()) {
1970       // Method may have been deleted and seems this API can handle null
1971       // Otherwise should probably put a method that throws NSME
1972       result-&gt;obj_at_put(i, NULL);
1973     } else {
1974       oop m;
1975       if (want_constructor) {
<span class="line-added">1976         assert(method-&gt;is_object_constructor() ||</span>
<span class="line-added">1977                method-&gt;is_static_init_factory(), &quot;must be&quot;);</span>
1978         m = Reflection::new_constructor(method, CHECK_NULL);
1979       } else {
1980         m = Reflection::new_method(method, false, CHECK_NULL);
1981       }
1982       result-&gt;obj_at_put(i, m);
1983     }
1984   }
1985 
1986   return (jobjectArray) JNIHandles::make_local(env, result());
1987 }
1988 
1989 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1990 {
1991   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1992   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1993                                            /*want_constructor*/ false,
1994                                            SystemDictionary::reflect_Method_klass(), THREAD);
1995 }
1996 JVM_END
1997 
</pre>
<hr />
<pre>
2215   constantTag tag = cp-&gt;tag_at(index);
2216   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2217     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2218   }
2219   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2220   Klass* k_o;
2221   if (force_resolution) {
2222     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2223   } else {
2224     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2225     if (k_o == NULL) return NULL;
2226   }
2227   InstanceKlass* k = InstanceKlass::cast(k_o);
2228   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2229   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2230   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2231   if (m.is_null()) {
2232     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2233   }
2234   oop method;
<span class="line-modified">2235   if (m-&gt;is_object_constructor()) {</span>


2236     method = Reflection::new_constructor(m, CHECK_NULL);
<span class="line-added">2237   } else {</span>
<span class="line-added">2238     method = Reflection::new_method(m, true, CHECK_NULL);</span>
2239   }
2240   return JNIHandles::make_local(method);
2241 }
2242 
2243 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2244 {
2245   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2246   JvmtiVMObjectAllocEventCollector oam;
2247   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2248   bounds_check(cp, index, CHECK_NULL);
2249   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2250   return res;
2251 }
2252 JVM_END
2253 
2254 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2255 {
2256   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2257   JvmtiVMObjectAllocEventCollector oam;
2258   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2506   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2507   if (!k-&gt;is_instance_klass()) return false;
2508 
2509   ResourceMark rm(THREAD);
2510   const char* name = k-&gt;name()-&gt;as_C_string();
2511   bool system_class = k-&gt;class_loader() == NULL;
2512   return JavaAssertions::enabled(name, system_class);
2513 
2514 JVM_END
2515 
2516 
2517 // Return a new AssertionStatusDirectives object with the fields filled in with
2518 // command-line assertion arguments (i.e., -ea, -da).
2519 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2520   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2521   JvmtiVMObjectAllocEventCollector oam;
2522   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2523   return JNIHandles::make_local(env, asd);
2524 JVM_END
2525 
<span class="line-added">2526 // Arrays support /////////////////////////////////////////////////////////////</span>
<span class="line-added">2527 </span>
<span class="line-added">2528 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2529   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);</span>
<span class="line-added">2530   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2531   Klass* k = o-&gt;klass();</span>
<span class="line-added">2532   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2533     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2534   }</span>
<span class="line-added">2535   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();</span>
<span class="line-added">2536 JVM_END</span>
<span class="line-added">2537 </span>
<span class="line-added">2538 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2539   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);</span>
<span class="line-added">2540   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2541   Klass* k = o-&gt;klass();</span>
<span class="line-added">2542   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2543     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2544   }</span>
<span class="line-added">2545   if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added">2546     ValueArrayKlass* vk = ValueArrayKlass::cast(k);</span>
<span class="line-added">2547     if (!vk-&gt;element_access_is_atomic()) {</span>
<span class="line-added">2548       /**</span>
<span class="line-added">2549        * Need to decide how to implement:</span>
<span class="line-added">2550        *</span>
<span class="line-added">2551        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so</span>
<span class="line-added">2552        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through</span>
<span class="line-added">2553        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;</span>
<span class="line-added">2554        *</span>
<span class="line-added">2555        * 2) Use extra header in the valueArrayOop to flag atomicity required and</span>
<span class="line-added">2556        * possibly per instance lock structure. Said info, could be placed in</span>
<span class="line-added">2557        * &quot;trailer&quot; rather than disturb the current arrayOop</span>
<span class="line-added">2558        */</span>
<span class="line-added">2559       Unimplemented();</span>
<span class="line-added">2560     }</span>
<span class="line-added">2561   }</span>
<span class="line-added">2562   return array;</span>
<span class="line-added">2563 JVM_END</span>
<span class="line-added">2564 </span>
2565 // Verification ////////////////////////////////////////////////////////////////////////////////
2566 
2567 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2568 
2569 // RedefineClasses support: bug 6214132 caused verification to fail.
2570 // All functions from this section should call the jvmtiThreadSate function:
2571 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2572 // The function returns a Klass* of the _scratch_class if the verifier
2573 // was invoked in the middle of the class redefinition.
2574 // Otherwise it returns its argument value which is the _the_class Klass*.
2575 // Please, refer to the description in the jvmtiThreadSate.hpp.
2576 
2577 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2578   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2579   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2580   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2581   return k-&gt;name()-&gt;as_utf8();
2582 JVM_END
2583 
2584 
</pre>
<hr />
<pre>
2724   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2725   return method-&gt;size_of_parameters();
2726 JVM_END
2727 
2728 
2729 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2730   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2731   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2732   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2733   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2734   return method-&gt;verifier_max_stack();
2735 JVM_END
2736 
2737 
2738 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2739   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2740   ResourceMark rm(THREAD);
2741   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2742   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2743   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2744   return method-&gt;is_object_constructor();</span>
2745 JVM_END
2746 
2747 
2748 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2749   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2750   ResourceMark rm(THREAD);
2751   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2752   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2753   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2754   return method-&gt;is_overpass();
2755 JVM_END
2756 
2757 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2758   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2759   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2760   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2761   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2762   return method-&gt;name()-&gt;as_utf8();
2763 JVM_END
2764 
</pre>
<hr />
<pre>
3719   //   protection_domain. The protection_domain is passed as NULL by the java code
3720   //   if there is no security manager in 3-arg Class.forName().
3721   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3722 
3723   // Check if we should initialize the class
3724   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3725     klass-&gt;initialize(CHECK_NULL);
3726   }
3727   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3728 }
3729 
3730 
3731 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3732 
3733 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3734   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3735   Handle method_handle;
3736   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3737     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3738     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3739     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3740     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3741     jobject res = JNIHandles::make_local(env, result);
3742     if (JvmtiExport::should_post_vm_object_alloc()) {
3743       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3744       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3745       if (java_lang_Class::is_primitive(ret_type)) {
3746         // Only for primitive type vm allocates memory for java object.
3747         // See box() method.
3748         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3749       }
3750     }
3751     return res;
3752   } else {
3753     THROW_0(vmSymbols::java_lang_StackOverflowError());
3754   }
3755 JVM_END
3756 
3757 
3758 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3759   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
<span class="line-added">3760   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3761   oop constructor_mirror = JNIHandles::resolve(c);

3762   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3763   jobject res = JNIHandles::make_local(env, result);
3764   if (JvmtiExport::should_post_vm_object_alloc()) {
3765     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3766   }
3767   return res;
3768 JVM_END
3769 
3770 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3771 
3772 JVM_LEAF(jboolean, JVM_SupportsCX8())
3773   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3774   return VM_Version::supports_cx8();
3775 JVM_END
3776 
3777 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3778   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3779   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3780   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3781   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
</tr>
</table>
<center><a href="../opto/type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiClassFileReconstituter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
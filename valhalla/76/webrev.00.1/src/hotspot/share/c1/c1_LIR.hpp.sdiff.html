<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 299   friend BasicType as_BasicType(OprType t);
 300 
 301   OprType type_field_valid() const               { assert(is_register() || is_stack(), &quot;should not be called otherwise&quot;); return (OprType)(value() &amp; type_mask); }
 302   OprType type_field() const                     { return is_illegal() ? unknown_type : (OprType)(value() &amp; type_mask); }
 303 
 304   static OprSize size_for(BasicType t) {
 305     switch (t) {
 306       case T_LONG:
 307       case T_DOUBLE:
 308         return double_size;
 309         break;
 310 
 311       case T_FLOAT:
 312       case T_BOOLEAN:
 313       case T_CHAR:
 314       case T_BYTE:
 315       case T_SHORT:
 316       case T_INT:
 317       case T_ADDRESS:
 318       case T_OBJECT:

 319       case T_ARRAY:
 320       case T_METADATA:
 321         return single_size;
 322         break;
 323 
 324       default:
 325         ShouldNotReachHere();
 326         return single_size;
 327       }
 328   }
 329 
 330 
 331   void validate_type() const PRODUCT_RETURN;
 332 
 333   BasicType type() const {
 334     if (is_pointer()) {
 335       return pointer()-&gt;type();
 336     }
 337     return as_BasicType(type_field());
 338   }
</pre>
<hr />
<pre>
 449 #endif
 450 
 451   jint      as_jint()    const { return as_constant_ptr()-&gt;as_jint(); }
 452   jlong     as_jlong()   const { return as_constant_ptr()-&gt;as_jlong(); }
 453   jfloat    as_jfloat()  const { return as_constant_ptr()-&gt;as_jfloat(); }
 454   jdouble   as_jdouble() const { return as_constant_ptr()-&gt;as_jdouble(); }
 455   jobject   as_jobject() const { return as_constant_ptr()-&gt;as_jobject(); }
 456 
 457   void print() const PRODUCT_RETURN;
 458   void print(outputStream* out) const PRODUCT_RETURN;
 459 };
 460 
 461 
 462 inline LIR_OprDesc::OprType as_OprType(BasicType type) {
 463   switch (type) {
 464   case T_INT:      return LIR_OprDesc::int_type;
 465   case T_LONG:     return LIR_OprDesc::long_type;
 466   case T_FLOAT:    return LIR_OprDesc::float_type;
 467   case T_DOUBLE:   return LIR_OprDesc::double_type;
 468   case T_OBJECT:

 469   case T_ARRAY:    return LIR_OprDesc::object_type;
 470   case T_ADDRESS:  return LIR_OprDesc::address_type;
 471   case T_METADATA: return LIR_OprDesc::metadata_type;
 472   case T_ILLEGAL:  // fall through
 473   default: ShouldNotReachHere(); return LIR_OprDesc::unknown_type;
 474   }
 475 }
 476 
 477 inline BasicType as_BasicType(LIR_OprDesc::OprType t) {
 478   switch (t) {
 479   case LIR_OprDesc::int_type:     return T_INT;
 480   case LIR_OprDesc::long_type:    return T_LONG;
 481   case LIR_OprDesc::float_type:   return T_FLOAT;
 482   case LIR_OprDesc::double_type:  return T_DOUBLE;
 483   case LIR_OprDesc::object_type:  return T_OBJECT;
 484   case LIR_OprDesc::address_type: return T_ADDRESS;
 485   case LIR_OprDesc::metadata_type:return T_METADATA;
 486   case LIR_OprDesc::unknown_type: // fall through
 487   default: ShouldNotReachHere();  return T_ILLEGAL;
 488   }
</pre>
<hr />
<pre>
 634     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 635                                LIR_OprDesc::float_type          |
 636                                LIR_OprDesc::fpu_register        |
 637                                LIR_OprDesc::single_size         |
 638                                LIR_OprDesc::is_xmm_mask);
 639   }
 640   static LIR_Opr double_xmm(int reg) {
 641     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 642                                (reg &lt;&lt; LIR_OprDesc::reg2_shift) |
 643                                LIR_OprDesc::double_type         |
 644                                LIR_OprDesc::fpu_register        |
 645                                LIR_OprDesc::double_size         |
 646                                LIR_OprDesc::is_xmm_mask);
 647   }
 648 #endif // X86
 649 
 650   static LIR_Opr virtual_register(int index, BasicType type) {
 651     LIR_Opr res;
 652     switch (type) {
 653       case T_OBJECT: // fall through

 654       case T_ARRAY:
 655         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 656                                             LIR_OprDesc::object_type  |
 657                                             LIR_OprDesc::cpu_register |
 658                                             LIR_OprDesc::single_size  |
 659                                             LIR_OprDesc::virtual_mask);
 660         break;
 661 
 662       case T_METADATA:
 663         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 664                                             LIR_OprDesc::metadata_type|
 665                                             LIR_OprDesc::cpu_register |
 666                                             LIR_OprDesc::single_size  |
 667                                             LIR_OprDesc::virtual_mask);
 668         break;
 669 
 670       case T_INT:
 671         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 672                                   LIR_OprDesc::int_type              |
 673                                   LIR_OprDesc::cpu_register          |
</pre>
<hr />
<pre>
 739                                t |
 740                                LIR_OprDesc::cpu_register |
 741                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 742 #else // __SOFTFP__
 743     LIR_Opr old_res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) | t |
 744                                           ((type == T_FLOAT || type == T_DOUBLE) ?  LIR_OprDesc::fpu_register : LIR_OprDesc::cpu_register) |
 745                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 746     assert(res == old_res, &quot;old and new method not equal&quot;);
 747 #endif // __SOFTFP__
 748 #endif // ASSERT
 749 
 750     return res;
 751   }
 752 
 753   // &#39;index&#39; is computed by FrameMap::local_stack_pos(index); do not use other parameters as
 754   // the index is platform independent; a double stack useing indeces 2 and 3 has always
 755   // index 2.
 756   static LIR_Opr stack(int index, BasicType type) {
 757     LIR_Opr res;
 758     switch (type) {

 759       case T_OBJECT: // fall through
 760       case T_ARRAY:
 761         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 762                                   LIR_OprDesc::object_type           |
 763                                   LIR_OprDesc::stack_value           |
 764                                   LIR_OprDesc::single_size);
 765         break;
 766 
 767       case T_METADATA:
 768         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 769                                   LIR_OprDesc::metadata_type         |
 770                                   LIR_OprDesc::stack_value           |
 771                                   LIR_OprDesc::single_size);
 772         break;
 773       case T_INT:
 774         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 775                                   LIR_OprDesc::int_type              |
 776                                   LIR_OprDesc::stack_value           |
 777                                   LIR_OprDesc::single_size);
 778         break;
</pre>
<hr />
<pre>
 851 //
 852 class  LIR_Op;
 853 class    LIR_Op0;
 854 class      LIR_OpLabel;
 855 class    LIR_Op1;
 856 class      LIR_OpBranch;
 857 class      LIR_OpConvert;
 858 class      LIR_OpAllocObj;
 859 class      LIR_OpRoundFP;
 860 class    LIR_Op2;
 861 class    LIR_OpDelay;
 862 class    LIR_Op3;
 863 class      LIR_OpAllocArray;
 864 class    LIR_OpCall;
 865 class      LIR_OpJavaCall;
 866 class      LIR_OpRTCall;
 867 class    LIR_OpArrayCopy;
 868 class    LIR_OpUpdateCRC32;
 869 class    LIR_OpLock;
 870 class    LIR_OpTypeCheck;



 871 class    LIR_OpCompareAndSwap;
 872 class    LIR_OpProfileCall;
 873 class    LIR_OpProfileType;
 874 #ifdef ASSERT
 875 class    LIR_OpAssert;
 876 #endif
 877 
 878 // LIR operation codes
 879 enum LIR_Code {
 880     lir_none
 881   , begin_op0
 882       , lir_label
 883       , lir_nop
 884       , lir_backwardbranch_target
 885       , lir_std_entry
 886       , lir_osr_entry
 887       , lir_fpop_raw
 888       , lir_breakpoint
 889       , lir_rtcall
 890       , lir_membar
 891       , lir_membar_acquire
 892       , lir_membar_release
 893       , lir_membar_loadload
 894       , lir_membar_storestore
 895       , lir_membar_loadstore
 896       , lir_membar_storeload
 897       , lir_get_thread
 898       , lir_on_spin_wait

 899   , end_op0
 900   , begin_op1
 901       , lir_fxch
 902       , lir_fld
 903       , lir_push
 904       , lir_pop
 905       , lir_null_check
 906       , lir_return
 907       , lir_leal
 908       , lir_branch
 909       , lir_cond_float_branch
 910       , lir_move
 911       , lir_convert
 912       , lir_alloc_object
 913       , lir_monaddr
 914       , lir_roundfp
 915       , lir_safepoint
 916       , lir_unwind
 917   , end_op1
 918   , begin_op2
</pre>
<hr />
<pre>
 958       , lir_dynamic_call
 959   , end_opJavaCall
 960   , begin_opArrayCopy
 961       , lir_arraycopy
 962   , end_opArrayCopy
 963   , begin_opUpdateCRC32
 964       , lir_updatecrc32
 965   , end_opUpdateCRC32
 966   , begin_opLock
 967     , lir_lock
 968     , lir_unlock
 969   , end_opLock
 970   , begin_delay_slot
 971     , lir_delay_slot
 972   , end_delay_slot
 973   , begin_opTypeCheck
 974     , lir_instanceof
 975     , lir_checkcast
 976     , lir_store_check
 977   , end_opTypeCheck









 978   , begin_opCompareAndSwap
 979     , lir_cas_long
 980     , lir_cas_obj
 981     , lir_cas_int
 982   , end_opCompareAndSwap
 983   , begin_opMDOProfile
 984     , lir_profile_call
 985     , lir_profile_type
 986   , end_opMDOProfile
 987   , begin_opAssert
 988     , lir_assert
 989   , end_opAssert
 990 };
 991 
 992 
 993 enum LIR_Condition {
 994     lir_cond_equal
 995   , lir_cond_notEqual
 996   , lir_cond_less
 997   , lir_cond_lessEqual
</pre>
<hr />
<pre>
1108 
1109   virtual bool is_patching() { return false; }
1110   virtual LIR_OpCall* as_OpCall() { return NULL; }
1111   virtual LIR_OpJavaCall* as_OpJavaCall() { return NULL; }
1112   virtual LIR_OpLabel* as_OpLabel() { return NULL; }
1113   virtual LIR_OpDelay* as_OpDelay() { return NULL; }
1114   virtual LIR_OpLock* as_OpLock() { return NULL; }
1115   virtual LIR_OpAllocArray* as_OpAllocArray() { return NULL; }
1116   virtual LIR_OpAllocObj* as_OpAllocObj() { return NULL; }
1117   virtual LIR_OpRoundFP* as_OpRoundFP() { return NULL; }
1118   virtual LIR_OpBranch* as_OpBranch() { return NULL; }
1119   virtual LIR_OpRTCall* as_OpRTCall() { return NULL; }
1120   virtual LIR_OpConvert* as_OpConvert() { return NULL; }
1121   virtual LIR_Op0* as_Op0() { return NULL; }
1122   virtual LIR_Op1* as_Op1() { return NULL; }
1123   virtual LIR_Op2* as_Op2() { return NULL; }
1124   virtual LIR_Op3* as_Op3() { return NULL; }
1125   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return NULL; }
1126   virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32() { return NULL; }
1127   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return NULL; }



1128   virtual LIR_OpCompareAndSwap* as_OpCompareAndSwap() { return NULL; }
1129   virtual LIR_OpProfileCall* as_OpProfileCall() { return NULL; }
1130   virtual LIR_OpProfileType* as_OpProfileType() { return NULL; }
1131 #ifdef ASSERT
1132   virtual LIR_OpAssert* as_OpAssert() { return NULL; }
1133 #endif
1134 
1135   virtual void verify() const {}
1136 };
1137 
1138 // for calls
1139 class LIR_OpCall: public LIR_Op {
1140  friend class LIR_OpVisitState;
1141 
1142  protected:
1143   address      _addr;
1144   LIR_OprList* _arguments;
1145  protected:
1146   LIR_OpCall(LIR_Code code, address addr, LIR_Opr result,
1147              LIR_OprList* arguments, CodeEmitInfo* info = NULL)
</pre>
<hr />
<pre>
1188   { assert(is_in_range(code, begin_opJavaCall, end_opJavaCall), &quot;code check&quot;); }
1189 
1190   LIR_Opr receiver() const                       { return _receiver; }
1191   ciMethod* method() const                       { return _method;   }
1192 
1193   // JSR 292 support.
1194   bool is_invokedynamic() const                  { return code() == lir_dynamic_call; }
1195   bool is_method_handle_invoke() const {
1196     return method()-&gt;is_compiled_lambda_form() ||   // Java-generated lambda form
1197            method()-&gt;is_method_handle_intrinsic();  // JVM-generated MH intrinsic
1198   }
1199 
1200   intptr_t vtable_offset() const {
1201     assert(_code == lir_virtual_call, &quot;only have vtable for real vcall&quot;);
1202     return (intptr_t) addr();
1203   }
1204 
1205   virtual void emit_code(LIR_Assembler* masm);
1206   virtual LIR_OpJavaCall* as_OpJavaCall() { return this; }
1207   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;


1208 };
1209 
1210 // --------------------------------------------------
1211 // LIR_OpLabel
1212 // --------------------------------------------------
1213 // Location where a branch can continue
1214 class LIR_OpLabel: public LIR_Op {
1215  friend class LIR_OpVisitState;
1216 
1217  private:
1218   Label* _label;
1219  public:
1220   LIR_OpLabel(Label* lbl)
1221    : LIR_Op(lir_label, LIR_OprFact::illegalOpr, NULL)
1222    , _label(lbl)                                 {}
1223   Label* label() const                           { return _label; }
1224 
1225   virtual void emit_code(LIR_Assembler* masm);
1226   virtual LIR_OpLabel* as_OpLabel() { return this; }
1227   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
</pre>
<hr />
<pre>
1239   LIR_Opr   _dst_pos;
1240   LIR_Opr   _length;
1241   LIR_Opr   _tmp;
1242   ciArrayKlass* _expected_type;
1243   int       _flags;
1244 
1245 public:
1246   enum Flags {
1247     src_null_check         = 1 &lt;&lt; 0,
1248     dst_null_check         = 1 &lt;&lt; 1,
1249     src_pos_positive_check = 1 &lt;&lt; 2,
1250     dst_pos_positive_check = 1 &lt;&lt; 3,
1251     length_positive_check  = 1 &lt;&lt; 4,
1252     src_range_check        = 1 &lt;&lt; 5,
1253     dst_range_check        = 1 &lt;&lt; 6,
1254     type_check             = 1 &lt;&lt; 7,
1255     overlapping            = 1 &lt;&lt; 8,
1256     unaligned              = 1 &lt;&lt; 9,
1257     src_objarray           = 1 &lt;&lt; 10,
1258     dst_objarray           = 1 &lt;&lt; 11,
<span class="line-modified">1259     all_flags              = (1 &lt;&lt; 12) - 1</span>



1260   };
1261 
1262   LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp,
1263                   ciArrayKlass* expected_type, int flags, CodeEmitInfo* info);
1264 
1265   LIR_Opr src() const                            { return _src; }
1266   LIR_Opr src_pos() const                        { return _src_pos; }
1267   LIR_Opr dst() const                            { return _dst; }
1268   LIR_Opr dst_pos() const                        { return _dst_pos; }
1269   LIR_Opr length() const                         { return _length; }
1270   LIR_Opr tmp() const                            { return _tmp; }
1271   int flags() const                              { return _flags; }
1272   ciArrayKlass* expected_type() const            { return _expected_type; }
1273   ArrayCopyStub* stub() const                    { return _stub; }
1274 
1275   virtual void emit_code(LIR_Assembler* masm);
1276   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return this; }
1277   void print_instr(outputStream* out) const PRODUCT_RETURN;
1278 };
1279 
</pre>
<hr />
<pre>
1529 };
1530 
1531 // LIR_OpTypeCheck
1532 class LIR_OpTypeCheck: public LIR_Op {
1533  friend class LIR_OpVisitState;
1534 
1535  private:
1536   LIR_Opr       _object;
1537   LIR_Opr       _array;
1538   ciKlass*      _klass;
1539   LIR_Opr       _tmp1;
1540   LIR_Opr       _tmp2;
1541   LIR_Opr       _tmp3;
1542   bool          _fast_check;
1543   CodeEmitInfo* _info_for_patch;
1544   CodeEmitInfo* _info_for_exception;
1545   CodeStub*     _stub;
1546   ciMethod*     _profiled_method;
1547   int           _profiled_bci;
1548   bool          _should_profile;

1549 
1550 public:
1551   LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
1552                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
<span class="line-modified">1553                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub);</span>
1554   LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array,
1555                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception);
1556 
1557   LIR_Opr object() const                         { return _object;         }
1558   LIR_Opr array() const                          { assert(code() == lir_store_check, &quot;not valid&quot;); return _array;         }
1559   LIR_Opr tmp1() const                           { return _tmp1;           }
1560   LIR_Opr tmp2() const                           { return _tmp2;           }
1561   LIR_Opr tmp3() const                           { return _tmp3;           }
1562   ciKlass* klass() const                         { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _klass;          }
1563   bool fast_check() const                        { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _fast_check;     }
1564   CodeEmitInfo* info_for_patch() const           { return _info_for_patch;  }
1565   CodeEmitInfo* info_for_exception() const       { return _info_for_exception; }
1566   CodeStub* stub() const                         { return _stub;           }
1567 
1568   // MethodData* profiling
1569   void set_profiled_method(ciMethod *method)     { _profiled_method = method; }
1570   void set_profiled_bci(int bci)                 { _profiled_bci = bci;       }
1571   void set_should_profile(bool b)                { _should_profile = b;       }
1572   ciMethod* profiled_method() const              { return _profiled_method;   }
1573   int       profiled_bci() const                 { return _profiled_bci;      }
1574   bool      should_profile() const               { return _should_profile;    }
<span class="line-modified">1575 </span>
1576   virtual bool is_patching() { return _info_for_patch != NULL; }
1577   virtual void emit_code(LIR_Assembler* masm);
1578   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return this; }
1579   void print_instr(outputStream* out) const PRODUCT_RETURN;
1580 };
1581 












































































1582 // LIR_Op2
1583 class LIR_Op2: public LIR_Op {
1584  friend class LIR_OpVisitState;
1585 
1586   int  _fpu_stack_size; // for sin/cos implementation on Intel
1587 
1588  protected:
1589   LIR_Opr   _opr1;
1590   LIR_Opr   _opr2;
1591   BasicType _type;
1592   LIR_Opr   _tmp1;
1593   LIR_Opr   _tmp2;
1594   LIR_Opr   _tmp3;
1595   LIR_Opr   _tmp4;
1596   LIR_Opr   _tmp5;
1597   LIR_Condition _condition;
1598 
1599   void verify() const;
1600 
1601  public:
</pre>
<hr />
<pre>
1754 
1755 //--------------------------------
1756 class LabelObj: public CompilationResourceObj {
1757  private:
1758   Label _label;
1759  public:
1760   LabelObj()                                     {}
1761   Label* label()                                 { return &amp;_label; }
1762 };
1763 
1764 
1765 class LIR_OpLock: public LIR_Op {
1766  friend class LIR_OpVisitState;
1767 
1768  private:
1769   LIR_Opr _hdr;
1770   LIR_Opr _obj;
1771   LIR_Opr _lock;
1772   LIR_Opr _scratch;
1773   CodeStub* _stub;

1774  public:
<span class="line-modified">1775   LIR_OpLock(LIR_Code code, LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info)</span>
1776     : LIR_Op(code, LIR_OprFact::illegalOpr, info)
1777     , _hdr(hdr)
1778     , _obj(obj)
1779     , _lock(lock)
1780     , _scratch(scratch)
<span class="line-modified">1781     , _stub(stub)                      {}</span>

1782 
1783   LIR_Opr hdr_opr() const                        { return _hdr; }
1784   LIR_Opr obj_opr() const                        { return _obj; }
1785   LIR_Opr lock_opr() const                       { return _lock; }
1786   LIR_Opr scratch_opr() const                    { return _scratch; }
1787   CodeStub* stub() const                         { return _stub; }

1788 
1789   virtual void emit_code(LIR_Assembler* masm);
1790   virtual LIR_OpLock* as_OpLock() { return this; }
1791   void print_instr(outputStream* out) const PRODUCT_RETURN;
1792 };
1793 
1794 
1795 class LIR_OpDelay: public LIR_Op {
1796  friend class LIR_OpVisitState;
1797 
1798  private:
1799   LIR_Op* _op;
1800 
1801  public:
1802   LIR_OpDelay(LIR_Op* op, CodeEmitInfo* info):
1803     LIR_Op(lir_delay_slot, LIR_OprFact::illegalOpr, info),
1804     _op(op) {
1805     assert(op-&gt;code() == lir_nop, &quot;should be filling with nops&quot;);
1806   }
1807   virtual void emit_code(LIR_Assembler* masm);
</pre>
<hr />
<pre>
2199   void unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp);
2200 
2201   void shift_left(LIR_Opr value, int count, LIR_Opr dst)       { shift_left(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2202   void shift_right(LIR_Opr value, int count, LIR_Opr dst)      { shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2203   void unsigned_shift_right(LIR_Opr value, int count, LIR_Opr dst) { unsigned_shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2204 
2205   void lcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst)        { append(new LIR_Op2(lir_cmp_l2i,  left, right, dst)); }
2206   void fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less);
2207 
2208   void call_runtime_leaf(address routine, LIR_Opr tmp, LIR_Opr result, LIR_OprList* arguments) {
2209     append(new LIR_OpRTCall(routine, tmp, result, arguments));
2210   }
2211 
2212   void call_runtime(address routine, LIR_Opr tmp, LIR_Opr result,
2213                     LIR_OprList* arguments, CodeEmitInfo* info) {
2214     append(new LIR_OpRTCall(routine, tmp, result, arguments, info));
2215   }
2216 
2217   void load_stack_address_monitor(int monitor_ix, LIR_Opr dst)  { append(new LIR_Op1(lir_monaddr, LIR_OprFact::intConst(monitor_ix), dst)); }
2218   void unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub);
<span class="line-modified">2219   void lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info);</span>
2220 
2221   void breakpoint()                                                  { append(new LIR_Op0(lir_breakpoint)); }
2222 
2223   void arraycopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info) { append(new LIR_OpArrayCopy(src, src_pos, dst, dst_pos, length, tmp, expected_type, flags, info)); }
2224 
2225   void update_crc32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)  { append(new LIR_OpUpdateCRC32(crc, val, res)); }
2226 
2227   void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci);
2228   void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci);






2229 
2230   void checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
2231                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
2232                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">2233                   ciMethod* profiled_method, int profiled_bci);</span>
2234   // MethodData* profiling
2235   void profile_call(ciMethod* method, int bci, ciMethod* callee, LIR_Opr mdo, LIR_Opr recv, LIR_Opr t1, ciKlass* cha_klass) {
2236     append(new LIR_OpProfileCall(method, bci, callee, mdo, recv, t1, cha_klass));
2237   }
2238   void profile_type(LIR_Address* mdp, LIR_Opr obj, ciKlass* exact_klass, intptr_t current_klass, LIR_Opr tmp, bool not_null, bool no_conflict) {
2239     append(new LIR_OpProfileType(LIR_OprFact::address(mdp), obj, exact_klass, current_klass, tmp, not_null, no_conflict));
2240   }
2241 
2242   void xadd(LIR_Opr src, LIR_Opr add, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xadd, src, add, res, tmp)); }
2243   void xchg(LIR_Opr src, LIR_Opr set, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xchg, src, set, res, tmp)); }
2244 #ifdef ASSERT
2245   void lir_assert(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, const char* msg, bool halt) { append(new LIR_OpAssert(condition, opr1, opr2, msg, halt)); }
2246 #endif
2247 };
2248 
2249 void print_LIR(BlockList* blocks);
2250 
2251 class LIR_InsertionBuffer : public CompilationResourceObj {
2252  private:
2253   LIR_List*   _lir;   // the lir list where ops of this buffer should be inserted later (NULL when uninitialized)
</pre>
</td>
<td>
<hr />
<pre>
 299   friend BasicType as_BasicType(OprType t);
 300 
 301   OprType type_field_valid() const               { assert(is_register() || is_stack(), &quot;should not be called otherwise&quot;); return (OprType)(value() &amp; type_mask); }
 302   OprType type_field() const                     { return is_illegal() ? unknown_type : (OprType)(value() &amp; type_mask); }
 303 
 304   static OprSize size_for(BasicType t) {
 305     switch (t) {
 306       case T_LONG:
 307       case T_DOUBLE:
 308         return double_size;
 309         break;
 310 
 311       case T_FLOAT:
 312       case T_BOOLEAN:
 313       case T_CHAR:
 314       case T_BYTE:
 315       case T_SHORT:
 316       case T_INT:
 317       case T_ADDRESS:
 318       case T_OBJECT:
<span class="line-added"> 319       case T_VALUETYPE:</span>
 320       case T_ARRAY:
 321       case T_METADATA:
 322         return single_size;
 323         break;
 324 
 325       default:
 326         ShouldNotReachHere();
 327         return single_size;
 328       }
 329   }
 330 
 331 
 332   void validate_type() const PRODUCT_RETURN;
 333 
 334   BasicType type() const {
 335     if (is_pointer()) {
 336       return pointer()-&gt;type();
 337     }
 338     return as_BasicType(type_field());
 339   }
</pre>
<hr />
<pre>
 450 #endif
 451 
 452   jint      as_jint()    const { return as_constant_ptr()-&gt;as_jint(); }
 453   jlong     as_jlong()   const { return as_constant_ptr()-&gt;as_jlong(); }
 454   jfloat    as_jfloat()  const { return as_constant_ptr()-&gt;as_jfloat(); }
 455   jdouble   as_jdouble() const { return as_constant_ptr()-&gt;as_jdouble(); }
 456   jobject   as_jobject() const { return as_constant_ptr()-&gt;as_jobject(); }
 457 
 458   void print() const PRODUCT_RETURN;
 459   void print(outputStream* out) const PRODUCT_RETURN;
 460 };
 461 
 462 
 463 inline LIR_OprDesc::OprType as_OprType(BasicType type) {
 464   switch (type) {
 465   case T_INT:      return LIR_OprDesc::int_type;
 466   case T_LONG:     return LIR_OprDesc::long_type;
 467   case T_FLOAT:    return LIR_OprDesc::float_type;
 468   case T_DOUBLE:   return LIR_OprDesc::double_type;
 469   case T_OBJECT:
<span class="line-added"> 470   case T_VALUETYPE:</span>
 471   case T_ARRAY:    return LIR_OprDesc::object_type;
 472   case T_ADDRESS:  return LIR_OprDesc::address_type;
 473   case T_METADATA: return LIR_OprDesc::metadata_type;
 474   case T_ILLEGAL:  // fall through
 475   default: ShouldNotReachHere(); return LIR_OprDesc::unknown_type;
 476   }
 477 }
 478 
 479 inline BasicType as_BasicType(LIR_OprDesc::OprType t) {
 480   switch (t) {
 481   case LIR_OprDesc::int_type:     return T_INT;
 482   case LIR_OprDesc::long_type:    return T_LONG;
 483   case LIR_OprDesc::float_type:   return T_FLOAT;
 484   case LIR_OprDesc::double_type:  return T_DOUBLE;
 485   case LIR_OprDesc::object_type:  return T_OBJECT;
 486   case LIR_OprDesc::address_type: return T_ADDRESS;
 487   case LIR_OprDesc::metadata_type:return T_METADATA;
 488   case LIR_OprDesc::unknown_type: // fall through
 489   default: ShouldNotReachHere();  return T_ILLEGAL;
 490   }
</pre>
<hr />
<pre>
 636     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 637                                LIR_OprDesc::float_type          |
 638                                LIR_OprDesc::fpu_register        |
 639                                LIR_OprDesc::single_size         |
 640                                LIR_OprDesc::is_xmm_mask);
 641   }
 642   static LIR_Opr double_xmm(int reg) {
 643     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 644                                (reg &lt;&lt; LIR_OprDesc::reg2_shift) |
 645                                LIR_OprDesc::double_type         |
 646                                LIR_OprDesc::fpu_register        |
 647                                LIR_OprDesc::double_size         |
 648                                LIR_OprDesc::is_xmm_mask);
 649   }
 650 #endif // X86
 651 
 652   static LIR_Opr virtual_register(int index, BasicType type) {
 653     LIR_Opr res;
 654     switch (type) {
 655       case T_OBJECT: // fall through
<span class="line-added"> 656       case T_VALUETYPE: // fall through</span>
 657       case T_ARRAY:
 658         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 659                                             LIR_OprDesc::object_type  |
 660                                             LIR_OprDesc::cpu_register |
 661                                             LIR_OprDesc::single_size  |
 662                                             LIR_OprDesc::virtual_mask);
 663         break;
 664 
 665       case T_METADATA:
 666         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 667                                             LIR_OprDesc::metadata_type|
 668                                             LIR_OprDesc::cpu_register |
 669                                             LIR_OprDesc::single_size  |
 670                                             LIR_OprDesc::virtual_mask);
 671         break;
 672 
 673       case T_INT:
 674         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 675                                   LIR_OprDesc::int_type              |
 676                                   LIR_OprDesc::cpu_register          |
</pre>
<hr />
<pre>
 742                                t |
 743                                LIR_OprDesc::cpu_register |
 744                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 745 #else // __SOFTFP__
 746     LIR_Opr old_res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) | t |
 747                                           ((type == T_FLOAT || type == T_DOUBLE) ?  LIR_OprDesc::fpu_register : LIR_OprDesc::cpu_register) |
 748                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 749     assert(res == old_res, &quot;old and new method not equal&quot;);
 750 #endif // __SOFTFP__
 751 #endif // ASSERT
 752 
 753     return res;
 754   }
 755 
 756   // &#39;index&#39; is computed by FrameMap::local_stack_pos(index); do not use other parameters as
 757   // the index is platform independent; a double stack useing indeces 2 and 3 has always
 758   // index 2.
 759   static LIR_Opr stack(int index, BasicType type) {
 760     LIR_Opr res;
 761     switch (type) {
<span class="line-added"> 762       case T_VALUETYPE: // fall through</span>
 763       case T_OBJECT: // fall through
 764       case T_ARRAY:
 765         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 766                                   LIR_OprDesc::object_type           |
 767                                   LIR_OprDesc::stack_value           |
 768                                   LIR_OprDesc::single_size);
 769         break;
 770 
 771       case T_METADATA:
 772         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 773                                   LIR_OprDesc::metadata_type         |
 774                                   LIR_OprDesc::stack_value           |
 775                                   LIR_OprDesc::single_size);
 776         break;
 777       case T_INT:
 778         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 779                                   LIR_OprDesc::int_type              |
 780                                   LIR_OprDesc::stack_value           |
 781                                   LIR_OprDesc::single_size);
 782         break;
</pre>
<hr />
<pre>
 855 //
 856 class  LIR_Op;
 857 class    LIR_Op0;
 858 class      LIR_OpLabel;
 859 class    LIR_Op1;
 860 class      LIR_OpBranch;
 861 class      LIR_OpConvert;
 862 class      LIR_OpAllocObj;
 863 class      LIR_OpRoundFP;
 864 class    LIR_Op2;
 865 class    LIR_OpDelay;
 866 class    LIR_Op3;
 867 class      LIR_OpAllocArray;
 868 class    LIR_OpCall;
 869 class      LIR_OpJavaCall;
 870 class      LIR_OpRTCall;
 871 class    LIR_OpArrayCopy;
 872 class    LIR_OpUpdateCRC32;
 873 class    LIR_OpLock;
 874 class    LIR_OpTypeCheck;
<span class="line-added"> 875 class    LIR_OpFlattenedArrayCheck;</span>
<span class="line-added"> 876 class    LIR_OpNullFreeArrayCheck;</span>
<span class="line-added"> 877 class    LIR_OpSubstitutabilityCheck;</span>
 878 class    LIR_OpCompareAndSwap;
 879 class    LIR_OpProfileCall;
 880 class    LIR_OpProfileType;
 881 #ifdef ASSERT
 882 class    LIR_OpAssert;
 883 #endif
 884 
 885 // LIR operation codes
 886 enum LIR_Code {
 887     lir_none
 888   , begin_op0
 889       , lir_label
 890       , lir_nop
 891       , lir_backwardbranch_target
 892       , lir_std_entry
 893       , lir_osr_entry
 894       , lir_fpop_raw
 895       , lir_breakpoint
 896       , lir_rtcall
 897       , lir_membar
 898       , lir_membar_acquire
 899       , lir_membar_release
 900       , lir_membar_loadload
 901       , lir_membar_storestore
 902       , lir_membar_loadstore
 903       , lir_membar_storeload
 904       , lir_get_thread
 905       , lir_on_spin_wait
<span class="line-added"> 906       , lir_check_orig_pc</span>
 907   , end_op0
 908   , begin_op1
 909       , lir_fxch
 910       , lir_fld
 911       , lir_push
 912       , lir_pop
 913       , lir_null_check
 914       , lir_return
 915       , lir_leal
 916       , lir_branch
 917       , lir_cond_float_branch
 918       , lir_move
 919       , lir_convert
 920       , lir_alloc_object
 921       , lir_monaddr
 922       , lir_roundfp
 923       , lir_safepoint
 924       , lir_unwind
 925   , end_op1
 926   , begin_op2
</pre>
<hr />
<pre>
 966       , lir_dynamic_call
 967   , end_opJavaCall
 968   , begin_opArrayCopy
 969       , lir_arraycopy
 970   , end_opArrayCopy
 971   , begin_opUpdateCRC32
 972       , lir_updatecrc32
 973   , end_opUpdateCRC32
 974   , begin_opLock
 975     , lir_lock
 976     , lir_unlock
 977   , end_opLock
 978   , begin_delay_slot
 979     , lir_delay_slot
 980   , end_delay_slot
 981   , begin_opTypeCheck
 982     , lir_instanceof
 983     , lir_checkcast
 984     , lir_store_check
 985   , end_opTypeCheck
<span class="line-added"> 986   , begin_opFlattenedArrayCheck</span>
<span class="line-added"> 987     , lir_flattened_array_check</span>
<span class="line-added"> 988   , end_opFlattenedArrayCheck</span>
<span class="line-added"> 989   , begin_opNullFreeArrayCheck</span>
<span class="line-added"> 990     , lir_null_free_array_check</span>
<span class="line-added"> 991   , end_opNullFreeArrayCheck</span>
<span class="line-added"> 992   , begin_opSubstitutabilityCheck</span>
<span class="line-added"> 993     , lir_substitutability_check</span>
<span class="line-added"> 994   , end_opSubstitutabilityCheck</span>
 995   , begin_opCompareAndSwap
 996     , lir_cas_long
 997     , lir_cas_obj
 998     , lir_cas_int
 999   , end_opCompareAndSwap
1000   , begin_opMDOProfile
1001     , lir_profile_call
1002     , lir_profile_type
1003   , end_opMDOProfile
1004   , begin_opAssert
1005     , lir_assert
1006   , end_opAssert
1007 };
1008 
1009 
1010 enum LIR_Condition {
1011     lir_cond_equal
1012   , lir_cond_notEqual
1013   , lir_cond_less
1014   , lir_cond_lessEqual
</pre>
<hr />
<pre>
1125 
1126   virtual bool is_patching() { return false; }
1127   virtual LIR_OpCall* as_OpCall() { return NULL; }
1128   virtual LIR_OpJavaCall* as_OpJavaCall() { return NULL; }
1129   virtual LIR_OpLabel* as_OpLabel() { return NULL; }
1130   virtual LIR_OpDelay* as_OpDelay() { return NULL; }
1131   virtual LIR_OpLock* as_OpLock() { return NULL; }
1132   virtual LIR_OpAllocArray* as_OpAllocArray() { return NULL; }
1133   virtual LIR_OpAllocObj* as_OpAllocObj() { return NULL; }
1134   virtual LIR_OpRoundFP* as_OpRoundFP() { return NULL; }
1135   virtual LIR_OpBranch* as_OpBranch() { return NULL; }
1136   virtual LIR_OpRTCall* as_OpRTCall() { return NULL; }
1137   virtual LIR_OpConvert* as_OpConvert() { return NULL; }
1138   virtual LIR_Op0* as_Op0() { return NULL; }
1139   virtual LIR_Op1* as_Op1() { return NULL; }
1140   virtual LIR_Op2* as_Op2() { return NULL; }
1141   virtual LIR_Op3* as_Op3() { return NULL; }
1142   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return NULL; }
1143   virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32() { return NULL; }
1144   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return NULL; }
<span class="line-added">1145   virtual LIR_OpFlattenedArrayCheck* as_OpFlattenedArrayCheck() { return NULL; }</span>
<span class="line-added">1146   virtual LIR_OpNullFreeArrayCheck* as_OpNullFreeArrayCheck() { return NULL; }</span>
<span class="line-added">1147   virtual LIR_OpSubstitutabilityCheck* as_OpSubstitutabilityCheck() { return NULL; }</span>
1148   virtual LIR_OpCompareAndSwap* as_OpCompareAndSwap() { return NULL; }
1149   virtual LIR_OpProfileCall* as_OpProfileCall() { return NULL; }
1150   virtual LIR_OpProfileType* as_OpProfileType() { return NULL; }
1151 #ifdef ASSERT
1152   virtual LIR_OpAssert* as_OpAssert() { return NULL; }
1153 #endif
1154 
1155   virtual void verify() const {}
1156 };
1157 
1158 // for calls
1159 class LIR_OpCall: public LIR_Op {
1160  friend class LIR_OpVisitState;
1161 
1162  protected:
1163   address      _addr;
1164   LIR_OprList* _arguments;
1165  protected:
1166   LIR_OpCall(LIR_Code code, address addr, LIR_Opr result,
1167              LIR_OprList* arguments, CodeEmitInfo* info = NULL)
</pre>
<hr />
<pre>
1208   { assert(is_in_range(code, begin_opJavaCall, end_opJavaCall), &quot;code check&quot;); }
1209 
1210   LIR_Opr receiver() const                       { return _receiver; }
1211   ciMethod* method() const                       { return _method;   }
1212 
1213   // JSR 292 support.
1214   bool is_invokedynamic() const                  { return code() == lir_dynamic_call; }
1215   bool is_method_handle_invoke() const {
1216     return method()-&gt;is_compiled_lambda_form() ||   // Java-generated lambda form
1217            method()-&gt;is_method_handle_intrinsic();  // JVM-generated MH intrinsic
1218   }
1219 
1220   intptr_t vtable_offset() const {
1221     assert(_code == lir_virtual_call, &quot;only have vtable for real vcall&quot;);
1222     return (intptr_t) addr();
1223   }
1224 
1225   virtual void emit_code(LIR_Assembler* masm);
1226   virtual LIR_OpJavaCall* as_OpJavaCall() { return this; }
1227   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
<span class="line-added">1228 </span>
<span class="line-added">1229   bool maybe_return_as_fields(ciValueKlass** vk = NULL) const;</span>
1230 };
1231 
1232 // --------------------------------------------------
1233 // LIR_OpLabel
1234 // --------------------------------------------------
1235 // Location where a branch can continue
1236 class LIR_OpLabel: public LIR_Op {
1237  friend class LIR_OpVisitState;
1238 
1239  private:
1240   Label* _label;
1241  public:
1242   LIR_OpLabel(Label* lbl)
1243    : LIR_Op(lir_label, LIR_OprFact::illegalOpr, NULL)
1244    , _label(lbl)                                 {}
1245   Label* label() const                           { return _label; }
1246 
1247   virtual void emit_code(LIR_Assembler* masm);
1248   virtual LIR_OpLabel* as_OpLabel() { return this; }
1249   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
</pre>
<hr />
<pre>
1261   LIR_Opr   _dst_pos;
1262   LIR_Opr   _length;
1263   LIR_Opr   _tmp;
1264   ciArrayKlass* _expected_type;
1265   int       _flags;
1266 
1267 public:
1268   enum Flags {
1269     src_null_check         = 1 &lt;&lt; 0,
1270     dst_null_check         = 1 &lt;&lt; 1,
1271     src_pos_positive_check = 1 &lt;&lt; 2,
1272     dst_pos_positive_check = 1 &lt;&lt; 3,
1273     length_positive_check  = 1 &lt;&lt; 4,
1274     src_range_check        = 1 &lt;&lt; 5,
1275     dst_range_check        = 1 &lt;&lt; 6,
1276     type_check             = 1 &lt;&lt; 7,
1277     overlapping            = 1 &lt;&lt; 8,
1278     unaligned              = 1 &lt;&lt; 9,
1279     src_objarray           = 1 &lt;&lt; 10,
1280     dst_objarray           = 1 &lt;&lt; 11,
<span class="line-modified">1281     always_slow_path       = 1 &lt;&lt; 12,</span>
<span class="line-added">1282     src_valuetype_check    = 1 &lt;&lt; 13,</span>
<span class="line-added">1283     dst_valuetype_check    = 1 &lt;&lt; 14,</span>
<span class="line-added">1284     all_flags              = (1 &lt;&lt; 15) - 1</span>
1285   };
1286 
1287   LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp,
1288                   ciArrayKlass* expected_type, int flags, CodeEmitInfo* info);
1289 
1290   LIR_Opr src() const                            { return _src; }
1291   LIR_Opr src_pos() const                        { return _src_pos; }
1292   LIR_Opr dst() const                            { return _dst; }
1293   LIR_Opr dst_pos() const                        { return _dst_pos; }
1294   LIR_Opr length() const                         { return _length; }
1295   LIR_Opr tmp() const                            { return _tmp; }
1296   int flags() const                              { return _flags; }
1297   ciArrayKlass* expected_type() const            { return _expected_type; }
1298   ArrayCopyStub* stub() const                    { return _stub; }
1299 
1300   virtual void emit_code(LIR_Assembler* masm);
1301   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return this; }
1302   void print_instr(outputStream* out) const PRODUCT_RETURN;
1303 };
1304 
</pre>
<hr />
<pre>
1554 };
1555 
1556 // LIR_OpTypeCheck
1557 class LIR_OpTypeCheck: public LIR_Op {
1558  friend class LIR_OpVisitState;
1559 
1560  private:
1561   LIR_Opr       _object;
1562   LIR_Opr       _array;
1563   ciKlass*      _klass;
1564   LIR_Opr       _tmp1;
1565   LIR_Opr       _tmp2;
1566   LIR_Opr       _tmp3;
1567   bool          _fast_check;
1568   CodeEmitInfo* _info_for_patch;
1569   CodeEmitInfo* _info_for_exception;
1570   CodeStub*     _stub;
1571   ciMethod*     _profiled_method;
1572   int           _profiled_bci;
1573   bool          _should_profile;
<span class="line-added">1574   bool          _need_null_check;</span>
1575 
1576 public:
1577   LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
1578                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
<span class="line-modified">1579                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub, bool need_null_check = true);</span>
1580   LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array,
1581                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception);
1582 
1583   LIR_Opr object() const                         { return _object;         }
1584   LIR_Opr array() const                          { assert(code() == lir_store_check, &quot;not valid&quot;); return _array;         }
1585   LIR_Opr tmp1() const                           { return _tmp1;           }
1586   LIR_Opr tmp2() const                           { return _tmp2;           }
1587   LIR_Opr tmp3() const                           { return _tmp3;           }
1588   ciKlass* klass() const                         { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _klass;          }
1589   bool fast_check() const                        { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _fast_check;     }
1590   CodeEmitInfo* info_for_patch() const           { return _info_for_patch;  }
1591   CodeEmitInfo* info_for_exception() const       { return _info_for_exception; }
1592   CodeStub* stub() const                         { return _stub;           }
1593 
1594   // MethodData* profiling
1595   void set_profiled_method(ciMethod *method)     { _profiled_method = method; }
1596   void set_profiled_bci(int bci)                 { _profiled_bci = bci;       }
1597   void set_should_profile(bool b)                { _should_profile = b;       }
1598   ciMethod* profiled_method() const              { return _profiled_method;   }
1599   int       profiled_bci() const                 { return _profiled_bci;      }
1600   bool      should_profile() const               { return _should_profile;    }
<span class="line-modified">1601   bool      need_null_check() const              { return _need_null_check;   }</span>
1602   virtual bool is_patching() { return _info_for_patch != NULL; }
1603   virtual void emit_code(LIR_Assembler* masm);
1604   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return this; }
1605   void print_instr(outputStream* out) const PRODUCT_RETURN;
1606 };
1607 
<span class="line-added">1608 // LIR_OpFlattenedArrayCheck</span>
<span class="line-added">1609 class LIR_OpFlattenedArrayCheck: public LIR_Op {</span>
<span class="line-added">1610  friend class LIR_OpVisitState;</span>
<span class="line-added">1611 </span>
<span class="line-added">1612  private:</span>
<span class="line-added">1613   LIR_Opr       _array;</span>
<span class="line-added">1614   LIR_Opr       _value;</span>
<span class="line-added">1615   LIR_Opr       _tmp;</span>
<span class="line-added">1616   CodeStub*     _stub;</span>
<span class="line-added">1617 public:</span>
<span class="line-added">1618   LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);</span>
<span class="line-added">1619   LIR_Opr array() const                          { return _array;         }</span>
<span class="line-added">1620   LIR_Opr value() const                          { return _value;         }</span>
<span class="line-added">1621   LIR_Opr tmp() const                            { return _tmp;           }</span>
<span class="line-added">1622   CodeStub* stub() const                         { return _stub;          }</span>
<span class="line-added">1623 </span>
<span class="line-added">1624   virtual void emit_code(LIR_Assembler* masm);</span>
<span class="line-added">1625   virtual LIR_OpFlattenedArrayCheck* as_OpFlattenedArrayCheck() { return this; }</span>
<span class="line-added">1626   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;</span>
<span class="line-added">1627 };</span>
<span class="line-added">1628 </span>
<span class="line-added">1629 // LIR_OpNullFreeArrayCheck</span>
<span class="line-added">1630 class LIR_OpNullFreeArrayCheck: public LIR_Op {</span>
<span class="line-added">1631  friend class LIR_OpVisitState;</span>
<span class="line-added">1632 </span>
<span class="line-added">1633  private:</span>
<span class="line-added">1634   LIR_Opr       _array;</span>
<span class="line-added">1635   LIR_Opr       _tmp;</span>
<span class="line-added">1636 public:</span>
<span class="line-added">1637   LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp);</span>
<span class="line-added">1638   LIR_Opr array() const                          { return _array;         }</span>
<span class="line-added">1639   LIR_Opr tmp() const                            { return _tmp;           }</span>
<span class="line-added">1640 </span>
<span class="line-added">1641   virtual void emit_code(LIR_Assembler* masm);</span>
<span class="line-added">1642   virtual LIR_OpNullFreeArrayCheck* as_OpNullFreeArrayCheck() { return this; }</span>
<span class="line-added">1643   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;</span>
<span class="line-added">1644 };</span>
<span class="line-added">1645 </span>
<span class="line-added">1646 class LIR_OpSubstitutabilityCheck: public LIR_Op {</span>
<span class="line-added">1647  friend class LIR_OpVisitState;</span>
<span class="line-added">1648 </span>
<span class="line-added">1649  private:</span>
<span class="line-added">1650   LIR_Opr       _left;</span>
<span class="line-added">1651   LIR_Opr       _right;</span>
<span class="line-added">1652   LIR_Opr       _equal_result;</span>
<span class="line-added">1653   LIR_Opr       _not_equal_result;</span>
<span class="line-added">1654   LIR_Opr       _tmp1;</span>
<span class="line-added">1655   LIR_Opr       _tmp2;</span>
<span class="line-added">1656   ciKlass*      _left_klass;</span>
<span class="line-added">1657   ciKlass*      _right_klass;</span>
<span class="line-added">1658   LIR_Opr       _left_klass_op;</span>
<span class="line-added">1659   LIR_Opr       _right_klass_op;</span>
<span class="line-added">1660   CodeStub*     _stub;</span>
<span class="line-added">1661 public:</span>
<span class="line-added">1662   LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added">1663                               LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added">1664                               ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added">1665                               CodeEmitInfo* info, CodeStub* stub);</span>
<span class="line-added">1666 </span>
<span class="line-added">1667   LIR_Opr left() const             { return _left; }</span>
<span class="line-added">1668   LIR_Opr right() const            { return _right; }</span>
<span class="line-added">1669   LIR_Opr equal_result() const     { return _equal_result; }</span>
<span class="line-added">1670   LIR_Opr not_equal_result() const { return _not_equal_result; }</span>
<span class="line-added">1671   LIR_Opr tmp1() const             { return _tmp1; }</span>
<span class="line-added">1672   LIR_Opr tmp2() const             { return _tmp2; }</span>
<span class="line-added">1673   ciKlass* left_klass() const      { return _left_klass; }</span>
<span class="line-added">1674   ciKlass* right_klass() const     { return _right_klass; }</span>
<span class="line-added">1675   LIR_Opr left_klass_op() const    { return _left_klass_op; }</span>
<span class="line-added">1676   LIR_Opr right_klass_op() const   { return _right_klass_op; }</span>
<span class="line-added">1677   CodeStub* stub() const           { return _stub; }</span>
<span class="line-added">1678 </span>
<span class="line-added">1679   virtual void emit_code(LIR_Assembler* masm);</span>
<span class="line-added">1680   virtual LIR_OpSubstitutabilityCheck* as_OpSubstitutabilityCheck() { return this; }</span>
<span class="line-added">1681   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;</span>
<span class="line-added">1682 };</span>
<span class="line-added">1683 </span>
1684 // LIR_Op2
1685 class LIR_Op2: public LIR_Op {
1686  friend class LIR_OpVisitState;
1687 
1688   int  _fpu_stack_size; // for sin/cos implementation on Intel
1689 
1690  protected:
1691   LIR_Opr   _opr1;
1692   LIR_Opr   _opr2;
1693   BasicType _type;
1694   LIR_Opr   _tmp1;
1695   LIR_Opr   _tmp2;
1696   LIR_Opr   _tmp3;
1697   LIR_Opr   _tmp4;
1698   LIR_Opr   _tmp5;
1699   LIR_Condition _condition;
1700 
1701   void verify() const;
1702 
1703  public:
</pre>
<hr />
<pre>
1856 
1857 //--------------------------------
1858 class LabelObj: public CompilationResourceObj {
1859  private:
1860   Label _label;
1861  public:
1862   LabelObj()                                     {}
1863   Label* label()                                 { return &amp;_label; }
1864 };
1865 
1866 
1867 class LIR_OpLock: public LIR_Op {
1868  friend class LIR_OpVisitState;
1869 
1870  private:
1871   LIR_Opr _hdr;
1872   LIR_Opr _obj;
1873   LIR_Opr _lock;
1874   LIR_Opr _scratch;
1875   CodeStub* _stub;
<span class="line-added">1876   CodeStub* _throw_imse_stub;</span>
1877  public:
<span class="line-modified">1878   LIR_OpLock(LIR_Code code, LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub=NULL)</span>
1879     : LIR_Op(code, LIR_OprFact::illegalOpr, info)
1880     , _hdr(hdr)
1881     , _obj(obj)
1882     , _lock(lock)
1883     , _scratch(scratch)
<span class="line-modified">1884     , _stub(stub)</span>
<span class="line-added">1885     , _throw_imse_stub(throw_imse_stub)                    {}</span>
1886 
1887   LIR_Opr hdr_opr() const                        { return _hdr; }
1888   LIR_Opr obj_opr() const                        { return _obj; }
1889   LIR_Opr lock_opr() const                       { return _lock; }
1890   LIR_Opr scratch_opr() const                    { return _scratch; }
1891   CodeStub* stub() const                         { return _stub; }
<span class="line-added">1892   CodeStub* throw_imse_stub() const              { return _throw_imse_stub; }</span>
1893 
1894   virtual void emit_code(LIR_Assembler* masm);
1895   virtual LIR_OpLock* as_OpLock() { return this; }
1896   void print_instr(outputStream* out) const PRODUCT_RETURN;
1897 };
1898 
1899 
1900 class LIR_OpDelay: public LIR_Op {
1901  friend class LIR_OpVisitState;
1902 
1903  private:
1904   LIR_Op* _op;
1905 
1906  public:
1907   LIR_OpDelay(LIR_Op* op, CodeEmitInfo* info):
1908     LIR_Op(lir_delay_slot, LIR_OprFact::illegalOpr, info),
1909     _op(op) {
1910     assert(op-&gt;code() == lir_nop, &quot;should be filling with nops&quot;);
1911   }
1912   virtual void emit_code(LIR_Assembler* masm);
</pre>
<hr />
<pre>
2304   void unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp);
2305 
2306   void shift_left(LIR_Opr value, int count, LIR_Opr dst)       { shift_left(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2307   void shift_right(LIR_Opr value, int count, LIR_Opr dst)      { shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2308   void unsigned_shift_right(LIR_Opr value, int count, LIR_Opr dst) { unsigned_shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2309 
2310   void lcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst)        { append(new LIR_Op2(lir_cmp_l2i,  left, right, dst)); }
2311   void fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less);
2312 
2313   void call_runtime_leaf(address routine, LIR_Opr tmp, LIR_Opr result, LIR_OprList* arguments) {
2314     append(new LIR_OpRTCall(routine, tmp, result, arguments));
2315   }
2316 
2317   void call_runtime(address routine, LIR_Opr tmp, LIR_Opr result,
2318                     LIR_OprList* arguments, CodeEmitInfo* info) {
2319     append(new LIR_OpRTCall(routine, tmp, result, arguments, info));
2320   }
2321 
2322   void load_stack_address_monitor(int monitor_ix, LIR_Opr dst)  { append(new LIR_Op1(lir_monaddr, LIR_OprFact::intConst(monitor_ix), dst)); }
2323   void unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub);
<span class="line-modified">2324   void lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub=NULL);</span>
2325 
2326   void breakpoint()                                                  { append(new LIR_Op0(lir_breakpoint)); }
2327 
2328   void arraycopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info) { append(new LIR_OpArrayCopy(src, src_pos, dst, dst_pos, length, tmp, expected_type, flags, info)); }
2329 
2330   void update_crc32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)  { append(new LIR_OpUpdateCRC32(crc, val, res)); }
2331 
2332   void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci);
2333   void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci);
<span class="line-added">2334   void check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);</span>
<span class="line-added">2335   void check_null_free_array(LIR_Opr array, LIR_Opr tmp);</span>
<span class="line-added">2336   void substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added">2337                               LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added">2338                               ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added">2339                               CodeEmitInfo* info, CodeStub* stub);</span>
2340 
2341   void checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
2342                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
2343                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">2344                   ciMethod* profiled_method, int profiled_bci, bool is_never_null);</span>
2345   // MethodData* profiling
2346   void profile_call(ciMethod* method, int bci, ciMethod* callee, LIR_Opr mdo, LIR_Opr recv, LIR_Opr t1, ciKlass* cha_klass) {
2347     append(new LIR_OpProfileCall(method, bci, callee, mdo, recv, t1, cha_klass));
2348   }
2349   void profile_type(LIR_Address* mdp, LIR_Opr obj, ciKlass* exact_klass, intptr_t current_klass, LIR_Opr tmp, bool not_null, bool no_conflict) {
2350     append(new LIR_OpProfileType(LIR_OprFact::address(mdp), obj, exact_klass, current_klass, tmp, not_null, no_conflict));
2351   }
2352 
2353   void xadd(LIR_Opr src, LIR_Opr add, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xadd, src, add, res, tmp)); }
2354   void xchg(LIR_Opr src, LIR_Opr set, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xchg, src, set, res, tmp)); }
2355 #ifdef ASSERT
2356   void lir_assert(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, const char* msg, bool halt) { append(new LIR_OpAssert(condition, opr1, opr2, msg, halt)); }
2357 #endif
2358 };
2359 
2360 void print_LIR(BlockList* blocks);
2361 
2362 class LIR_InsertionBuffer : public CompilationResourceObj {
2363  private:
2364   LIR_List*   _lir;   // the lir list where ops of this buffer should be inserted later (NULL when uninitialized)
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
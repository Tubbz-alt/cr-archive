<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;

  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 Register LIR_OprDesc::as_register() const {
  34   return FrameMap::cpu_rnr2reg(cpu_regnr());
  35 }
  36 
  37 Register LIR_OprDesc::as_register_lo() const {
  38   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  39 }
  40 
  41 Register LIR_OprDesc::as_register_hi() const {
  42   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  43 }
  44 
  45 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  46 
  47 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  48   ValueTag tag = type-&gt;tag();
  49   switch (tag) {
  50   case metaDataTag : {
</pre>
<hr />
<pre>
  75 //---------------------------------------------------
  76 
  77 
  78 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  79   int elem_size = type2aelembytes(type);
  80   switch (elem_size) {
  81   case 1: return LIR_Address::times_1;
  82   case 2: return LIR_Address::times_2;
  83   case 4: return LIR_Address::times_4;
  84   case 8: return LIR_Address::times_8;
  85   }
  86   ShouldNotReachHere();
  87   return LIR_Address::times_1;
  88 }
  89 
  90 //---------------------------------------------------
  91 
  92 char LIR_OprDesc::type_char(BasicType t) {
  93   switch (t) {
  94     case T_ARRAY:

  95       t = T_OBJECT;
  96     case T_BOOLEAN:
  97     case T_CHAR:
  98     case T_FLOAT:
  99     case T_DOUBLE:
 100     case T_BYTE:
 101     case T_SHORT:
 102     case T_INT:
 103     case T_LONG:
 104     case T_OBJECT:
 105     case T_ADDRESS:
 106     case T_VOID:
 107       return ::type2char(t);
 108     case T_METADATA:
 109       return &#39;M&#39;;
 110     case T_ILLEGAL:
 111       return &#39;?&#39;;
 112 
 113     default:
 114       ShouldNotReachHere();
</pre>
<hr />
<pre>
 133              ARM_ONLY(|| kindfield == cpu_register)
 134              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 135              size_field() == single_size, &quot;must match&quot;);
 136       break;
 137     case T_DOUBLE:
 138       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 139       assert((kindfield == fpu_register || kindfield == stack_value
 140              ARM_ONLY(|| kindfield == cpu_register)
 141              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 142              size_field() == double_size, &quot;must match&quot;);
 143       break;
 144     case T_BOOLEAN:
 145     case T_CHAR:
 146     case T_BYTE:
 147     case T_SHORT:
 148     case T_INT:
 149     case T_ADDRESS:
 150     case T_OBJECT:
 151     case T_METADATA:
 152     case T_ARRAY:

 153       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 154              size_field() == single_size, &quot;must match&quot;);
 155       break;
 156 
 157     case T_ILLEGAL:
 158       // XXX TKR also means unknown right now
 159       // assert(is_illegal(), &quot;must match&quot;);
 160       break;
 161 
 162     default:
 163       ShouldNotReachHere();
 164     }
 165   }
 166 #endif
 167 
 168 }
 169 #endif // PRODUCT
 170 
 171 
 172 bool LIR_OprDesc::is_oop() const {
</pre>
<hr />
<pre>
 276   assert(_ublock != NULL, &quot;must have old block&quot;);
 277   _ublock = b;
 278 }
 279 
 280 void LIR_OpBranch::negate_cond() {
 281   switch (_cond) {
 282     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 283     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 284     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 285     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 286     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 287     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 288     default: ShouldNotReachHere();
 289   }
 290 }
 291 
 292 
 293 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 294                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 295                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
<span class="line-modified"> 296                                  CodeStub* stub)</span>
 297 
 298   : LIR_Op(code, result, NULL)
 299   , _object(object)
 300   , _array(LIR_OprFact::illegalOpr)
 301   , _klass(klass)
 302   , _tmp1(tmp1)
 303   , _tmp2(tmp2)
 304   , _tmp3(tmp3)
 305   , _fast_check(fast_check)
 306   , _info_for_patch(info_for_patch)
 307   , _info_for_exception(info_for_exception)
 308   , _stub(stub)
 309   , _profiled_method(NULL)
 310   , _profiled_bci(-1)
 311   , _should_profile(false)

 312 {
 313   if (code == lir_checkcast) {
 314     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 315   } else if (code == lir_instanceof) {
 316     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 317   } else {
 318     ShouldNotReachHere();
 319   }
 320 }
 321 
 322 
 323 
 324 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 325   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 326   , _object(object)
 327   , _array(array)
 328   , _klass(NULL)
 329   , _tmp1(tmp1)
 330   , _tmp2(tmp2)
 331   , _tmp3(tmp3)
 332   , _fast_check(false)
 333   , _info_for_patch(NULL)
 334   , _info_for_exception(info_for_exception)
 335   , _stub(NULL)
 336   , _profiled_method(NULL)
 337   , _profiled_bci(-1)
 338   , _should_profile(false)

 339 {
 340   if (code == lir_store_check) {
 341     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 342     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 343   } else {
 344     ShouldNotReachHere();
 345   }
 346 }
 347 































 348 
 349 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 350                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 351   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 352   , _src(src)
 353   , _src_pos(src_pos)
 354   , _dst(dst)
 355   , _dst_pos(dst_pos)
 356   , _length(length)
 357   , _tmp(tmp)
 358   , _expected_type(expected_type)
 359   , _flags(flags) {
 360   _stub = new ArrayCopyStub(this);
 361 }
 362 
 363 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 364   : LIR_Op(lir_updatecrc32, res, NULL)
 365   , _crc(crc)
 366   , _val(val) {
 367 }
</pre>
<hr />
<pre>
 395 // switch that adds the operands for each instruction
 396 
 397 void LIR_OpVisitState::visit(LIR_Op* op) {
 398   // copy information from the LIR_Op
 399   reset();
 400   set_op(op);
 401 
 402   switch (op-&gt;code()) {
 403 
 404 // LIR_Op0
 405     case lir_backwardbranch_target:    // result and info always invalid
 406     case lir_fpop_raw:                 // result and info always invalid
 407     case lir_breakpoint:               // result and info always invalid
 408     case lir_membar:                   // result and info always invalid
 409     case lir_membar_acquire:           // result and info always invalid
 410     case lir_membar_release:           // result and info always invalid
 411     case lir_membar_loadload:          // result and info always invalid
 412     case lir_membar_storestore:        // result and info always invalid
 413     case lir_membar_loadstore:         // result and info always invalid
 414     case lir_membar_storeload:         // result and info always invalid

 415     case lir_on_spin_wait:
 416     {
 417       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 418       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 419       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 420       break;
 421     }
 422 
 423     case lir_nop:                      // may have info, result always invalid
 424     case lir_std_entry:                // may have result, info always invalid
 425     case lir_osr_entry:                // may have result, info always invalid
 426     case lir_get_thread:               // may have result, info always invalid
 427     {
 428       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 429       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 430       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 431       break;
 432     }
 433 
 434 
</pre>
<hr />
<pre>
 775 
 776 
 777 // LIR_OpLock
 778     case lir_lock:
 779     case lir_unlock: {
 780       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 781       LIR_OpLock* opLock = (LIR_OpLock*)op;
 782 
 783       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 784 
 785       // TODO: check if these operands really have to be temp
 786       // (or if input is sufficient). This may have influence on the oop map!
 787       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 788       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 789       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 790 
 791       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 792       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 793 
 794       do_stub(opLock-&gt;_stub);

 795 
 796       break;
 797     }
 798 
 799 
 800 // LIR_OpDelay
 801     case lir_delay_slot: {
 802       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 803       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 804 
 805       visit(opDelay-&gt;delay_op());
 806       break;
 807     }
 808 
 809 // LIR_OpTypeCheck
 810     case lir_instanceof:
 811     case lir_checkcast:
 812     case lir_store_check: {
 813       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 814       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 815 
 816       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 817       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 818       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 819       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 820         do_temp(opTypeCheck-&gt;_object);
 821       }
 822       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 823       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 824       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 825       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 826       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 827                                                   do_stub(opTypeCheck-&gt;_stub);
 828       break;
 829     }
 830 













































 831 // LIR_OpCompareAndSwap
 832     case lir_cas_long:
 833     case lir_cas_obj:
 834     case lir_cas_int: {
 835       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 836       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 837 
 838       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 839       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 840       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 841       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 842                                                       do_input(opCompareAndSwap-&gt;_addr);
 843                                                       do_temp(opCompareAndSwap-&gt;_addr);
 844                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 845                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 846                                                       do_input(opCompareAndSwap-&gt;_new_value);
 847                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 848       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 849       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 850       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
</pre>
<hr />
<pre>
 938 #ifdef ASSERT
 939 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
 940   visit(op);
 941 
 942   return opr_count(inputMode) == 0 &amp;&amp;
 943          opr_count(outputMode) == 0 &amp;&amp;
 944          opr_count(tempMode) == 0 &amp;&amp;
 945          info_count() == 0 &amp;&amp;
 946          !has_call() &amp;&amp;
 947          !has_slow_case();
 948 }
 949 #endif
 950 
 951 //---------------------------------------------------
 952 
 953 
 954 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
 955   masm-&gt;emit_call(this);
 956 }
 957 







































 958 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
 959   masm-&gt;emit_rtcall(this);
 960 }
 961 
 962 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
 963   masm-&gt;emit_opLabel(this);
 964 }
 965 
 966 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
 967   masm-&gt;emit_arraycopy(this);
 968   masm-&gt;append_code_stub(stub());
 969 }
 970 
 971 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
 972   masm-&gt;emit_updatecrc32(this);
 973 }
 974 
 975 void LIR_Op0::emit_code(LIR_Assembler* masm) {
 976   masm-&gt;emit_op0(this);
 977 }
</pre>
<hr />
<pre>
 998     masm-&gt;append_code_stub(stub());
 999   }
1000 }
1001 
1002 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1003   masm-&gt;emit_op2(this);
1004 }
1005 
1006 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1007   masm-&gt;emit_alloc_array(this);
1008   masm-&gt;append_code_stub(stub());
1009 }
1010 
1011 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1012   masm-&gt;emit_opTypeCheck(this);
1013   if (stub()) {
1014     masm-&gt;append_code_stub(stub());
1015   }
1016 }
1017 


















1018 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1019   masm-&gt;emit_compare_and_swap(this);
1020 }
1021 
1022 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1023   masm-&gt;emit_op3(this);
1024 }
1025 
1026 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1027   masm-&gt;emit_lock(this);
1028   if (stub()) {
1029     masm-&gt;append_code_stub(stub());
1030   }



1031 }
1032 
1033 #ifdef ASSERT
1034 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1035   masm-&gt;emit_assert(this);
1036 }
1037 #endif
1038 
1039 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1040   masm-&gt;emit_delay(this);
1041 }
1042 
1043 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1044   masm-&gt;emit_profile_call(this);
1045 }
1046 
1047 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1048   masm-&gt;emit_profile_type(this);
1049 }
1050 
</pre>
<hr />
<pre>
1312                     tmp));
1313 }
1314 
1315 
1316 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1317  append(new LIR_Op2(
1318                     lir_ushr,
1319                     value,
1320                     count,
1321                     dst,
1322                     tmp));
1323 }
1324 
1325 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1326   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1327                      left,
1328                      right,
1329                      dst));
1330 }
1331 
<span class="line-modified">1332 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info) {</span>
1333   append(new LIR_OpLock(
1334                     lir_lock,
1335                     hdr,
1336                     obj,
1337                     lock,
1338                     scratch,
1339                     stub,
<span class="line-modified">1340                     info));</span>

1341 }
1342 
1343 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1344   append(new LIR_OpLock(
1345                     lir_unlock,
1346                     hdr,
1347                     obj,
1348                     lock,
1349                     scratch,
1350                     stub,
1351                     NULL));
1352 }
1353 
1354 
1355 void check_LIR() {
1356   // cannot do the proper checking as PRODUCT and other modes return different results
1357   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1358 }
1359 
1360 
1361 
1362 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1363                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1364                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">1365                           ciMethod* profiled_method, int profiled_bci) {</span>



1366   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
<span class="line-modified">1367                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub);</span>

1368   if (profiled_method != NULL) {
1369     c-&gt;set_profiled_method(profiled_method);
1370     c-&gt;set_profiled_bci(profiled_bci);
1371     c-&gt;set_should_profile(true);
1372   }
1373   append(c);
1374 }
1375 
1376 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1377   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1378   if (profiled_method != NULL) {
1379     c-&gt;set_profiled_method(profiled_method);
1380     c-&gt;set_profiled_bci(profiled_bci);
1381     c-&gt;set_should_profile(true);
1382   }
1383   append(c);
1384 }
1385 
1386 
1387 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1388                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {

1389   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1390   if (profiled_method != NULL) {
1391     c-&gt;set_profiled_method(profiled_method);
1392     c-&gt;set_profiled_bci(profiled_bci);
1393     c-&gt;set_should_profile(true);
1394   }
1395   append(c);
1396 }
1397 
1398 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1399   if (deoptimize_on_null) {
1400     // Emit an explicit null check and deoptimize if opr is null
1401     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1402     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1403     branch(lir_cond_equal, deopt);
1404   } else {
1405     // Emit an implicit null check
1406     append(new LIR_Op1(lir_null_check, opr, info));
1407   }
1408 }
1409 





















1410 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1411                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1412   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1413 }
1414 
1415 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1416                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1417   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1418 }
1419 
1420 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1421                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1422   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1423 }
1424 
1425 
1426 #ifdef PRODUCT
1427 
1428 void print_LIR(BlockList* blocks) {
1429 }
</pre>
<hr />
<pre>
1607 const char * LIR_Op::name() const {
1608   const char* s = NULL;
1609   switch(code()) {
1610      // LIR_Op0
1611      case lir_membar:                s = &quot;membar&quot;;        break;
1612      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1613      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1614      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1615      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1616      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1617      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1618      case lir_label:                 s = &quot;label&quot;;         break;
1619      case lir_nop:                   s = &quot;nop&quot;;           break;
1620      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1621      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1622      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1623      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1624      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1625      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1626      case lir_get_thread:            s = &quot;get_thread&quot;;    break;

1627      // LIR_Op1
1628      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1629      case lir_fld:                   s = &quot;fld&quot;;           break;
1630      case lir_push:                  s = &quot;push&quot;;          break;
1631      case lir_pop:                   s = &quot;pop&quot;;           break;
1632      case lir_null_check:            s = &quot;null_check&quot;;    break;
1633      case lir_return:                s = &quot;return&quot;;        break;
1634      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1635      case lir_leal:                  s = &quot;leal&quot;;          break;
1636      case lir_branch:                s = &quot;branch&quot;;        break;
1637      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1638      case lir_move:                  s = &quot;move&quot;;          break;
1639      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1640      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1641      case lir_throw:                 s = &quot;throw&quot;;         break;
1642      case lir_unwind:                s = &quot;unwind&quot;;        break;
1643      case lir_convert:               s = &quot;convert&quot;;       break;
1644      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1645      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1646      // LIR_Op2
</pre>
<hr />
<pre>
1675      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1676      // LIR_OpJavaCall
1677      case lir_static_call:           s = &quot;static&quot;;        break;
1678      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1679      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1680      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1681      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1682      // LIR_OpArrayCopy
1683      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1684      // LIR_OpUpdateCRC32
1685      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1686      // LIR_OpLock
1687      case lir_lock:                  s = &quot;lock&quot;;          break;
1688      case lir_unlock:                s = &quot;unlock&quot;;        break;
1689      // LIR_OpDelay
1690      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1691      // LIR_OpTypeCheck
1692      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1693      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1694      case lir_store_check:           s = &quot;store_check&quot;;   break;






1695      // LIR_OpCompareAndSwap
1696      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1697      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1698      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1699      // LIR_OpProfileCall
1700      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1701      // LIR_OpProfileType
1702      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1703      // LIR_OpAssert
1704 #ifdef ASSERT
1705      case lir_assert:                s = &quot;assert&quot;;        break;
1706 #endif
1707      case lir_none:                  ShouldNotReachHere();break;
1708     default:                         s = &quot;illegal_op&quot;;    break;
1709   }
1710   return s;
1711 }
1712 
1713 // LIR_OpJavaCall
1714 void LIR_OpJavaCall::print_instr(outputStream* out) const {
</pre>
<hr />
<pre>
1920   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1921 }
1922 
1923 
1924 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
1925   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
1926   if (code() == lir_store_check) {
1927     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
1928   }
1929   if (code() != lir_store_check) {
1930     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
1931     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
1932   }
1933   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1934   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1935   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1936   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
1937   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
1938 }
1939 






























1940 
1941 // LIR_Op3
1942 void LIR_Op3::print_instr(outputStream* out) const {
1943   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1944   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1945   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1946   result_opr()-&gt;print(out);
1947 }
1948 
1949 
1950 void LIR_OpLock::print_instr(outputStream* out) const {
1951   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1952   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1953   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1954   if (_scratch-&gt;is_valid()) {
1955     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
1956   }
1957   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1958 }
1959 
</pre>
</td>
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;
<span class="line-added">  31 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  32 #include &quot;runtime/sharedRuntime.hpp&quot;
  33 
  34 Register LIR_OprDesc::as_register() const {
  35   return FrameMap::cpu_rnr2reg(cpu_regnr());
  36 }
  37 
  38 Register LIR_OprDesc::as_register_lo() const {
  39   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  40 }
  41 
  42 Register LIR_OprDesc::as_register_hi() const {
  43   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  44 }
  45 
  46 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  47 
  48 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  49   ValueTag tag = type-&gt;tag();
  50   switch (tag) {
  51   case metaDataTag : {
</pre>
<hr />
<pre>
  76 //---------------------------------------------------
  77 
  78 
  79 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  80   int elem_size = type2aelembytes(type);
  81   switch (elem_size) {
  82   case 1: return LIR_Address::times_1;
  83   case 2: return LIR_Address::times_2;
  84   case 4: return LIR_Address::times_4;
  85   case 8: return LIR_Address::times_8;
  86   }
  87   ShouldNotReachHere();
  88   return LIR_Address::times_1;
  89 }
  90 
  91 //---------------------------------------------------
  92 
  93 char LIR_OprDesc::type_char(BasicType t) {
  94   switch (t) {
  95     case T_ARRAY:
<span class="line-added">  96     case T_VALUETYPE:</span>
  97       t = T_OBJECT;
  98     case T_BOOLEAN:
  99     case T_CHAR:
 100     case T_FLOAT:
 101     case T_DOUBLE:
 102     case T_BYTE:
 103     case T_SHORT:
 104     case T_INT:
 105     case T_LONG:
 106     case T_OBJECT:
 107     case T_ADDRESS:
 108     case T_VOID:
 109       return ::type2char(t);
 110     case T_METADATA:
 111       return &#39;M&#39;;
 112     case T_ILLEGAL:
 113       return &#39;?&#39;;
 114 
 115     default:
 116       ShouldNotReachHere();
</pre>
<hr />
<pre>
 135              ARM_ONLY(|| kindfield == cpu_register)
 136              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 137              size_field() == single_size, &quot;must match&quot;);
 138       break;
 139     case T_DOUBLE:
 140       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 141       assert((kindfield == fpu_register || kindfield == stack_value
 142              ARM_ONLY(|| kindfield == cpu_register)
 143              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 144              size_field() == double_size, &quot;must match&quot;);
 145       break;
 146     case T_BOOLEAN:
 147     case T_CHAR:
 148     case T_BYTE:
 149     case T_SHORT:
 150     case T_INT:
 151     case T_ADDRESS:
 152     case T_OBJECT:
 153     case T_METADATA:
 154     case T_ARRAY:
<span class="line-added"> 155     case T_VALUETYPE:</span>
 156       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 157              size_field() == single_size, &quot;must match&quot;);
 158       break;
 159 
 160     case T_ILLEGAL:
 161       // XXX TKR also means unknown right now
 162       // assert(is_illegal(), &quot;must match&quot;);
 163       break;
 164 
 165     default:
 166       ShouldNotReachHere();
 167     }
 168   }
 169 #endif
 170 
 171 }
 172 #endif // PRODUCT
 173 
 174 
 175 bool LIR_OprDesc::is_oop() const {
</pre>
<hr />
<pre>
 279   assert(_ublock != NULL, &quot;must have old block&quot;);
 280   _ublock = b;
 281 }
 282 
 283 void LIR_OpBranch::negate_cond() {
 284   switch (_cond) {
 285     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 286     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 287     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 288     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 289     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 290     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 291     default: ShouldNotReachHere();
 292   }
 293 }
 294 
 295 
 296 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 297                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 298                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
<span class="line-modified"> 299                                  CodeStub* stub, bool need_null_check)</span>
 300 
 301   : LIR_Op(code, result, NULL)
 302   , _object(object)
 303   , _array(LIR_OprFact::illegalOpr)
 304   , _klass(klass)
 305   , _tmp1(tmp1)
 306   , _tmp2(tmp2)
 307   , _tmp3(tmp3)
 308   , _fast_check(fast_check)
 309   , _info_for_patch(info_for_patch)
 310   , _info_for_exception(info_for_exception)
 311   , _stub(stub)
 312   , _profiled_method(NULL)
 313   , _profiled_bci(-1)
 314   , _should_profile(false)
<span class="line-added"> 315   , _need_null_check(need_null_check)</span>
 316 {
 317   if (code == lir_checkcast) {
 318     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 319   } else if (code == lir_instanceof) {
 320     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 321   } else {
 322     ShouldNotReachHere();
 323   }
 324 }
 325 
 326 
 327 
 328 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 329   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 330   , _object(object)
 331   , _array(array)
 332   , _klass(NULL)
 333   , _tmp1(tmp1)
 334   , _tmp2(tmp2)
 335   , _tmp3(tmp3)
 336   , _fast_check(false)
 337   , _info_for_patch(NULL)
 338   , _info_for_exception(info_for_exception)
 339   , _stub(NULL)
 340   , _profiled_method(NULL)
 341   , _profiled_bci(-1)
 342   , _should_profile(false)
<span class="line-added"> 343   , _need_null_check(true)</span>
 344 {
 345   if (code == lir_store_check) {
 346     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 347     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 348   } else {
 349     ShouldNotReachHere();
 350   }
 351 }
 352 
<span class="line-added"> 353 LIR_OpFlattenedArrayCheck::LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub)</span>
<span class="line-added"> 354   : LIR_Op(lir_flattened_array_check, LIR_OprFact::illegalOpr, NULL)</span>
<span class="line-added"> 355   , _array(array)</span>
<span class="line-added"> 356   , _value(value)</span>
<span class="line-added"> 357   , _tmp(tmp)</span>
<span class="line-added"> 358   , _stub(stub) {}</span>
<span class="line-added"> 359 </span>
<span class="line-added"> 360 </span>
<span class="line-added"> 361 LIR_OpNullFreeArrayCheck::LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp)</span>
<span class="line-added"> 362   : LIR_Op(lir_null_free_array_check, LIR_OprFact::illegalOpr, NULL)</span>
<span class="line-added"> 363   , _array(array)</span>
<span class="line-added"> 364   , _tmp(tmp) {}</span>
<span class="line-added"> 365 </span>
<span class="line-added"> 366 </span>
<span class="line-added"> 367 LIR_OpSubstitutabilityCheck::LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added"> 368                                                          LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added"> 369                                                          ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added"> 370                                                          CodeEmitInfo* info, CodeStub* stub)</span>
<span class="line-added"> 371   : LIR_Op(lir_substitutability_check, result, info)</span>
<span class="line-added"> 372   , _left(left)</span>
<span class="line-added"> 373   , _right(right)</span>
<span class="line-added"> 374   , _equal_result(equal_result)</span>
<span class="line-added"> 375   , _not_equal_result(not_equal_result)</span>
<span class="line-added"> 376   , _tmp1(tmp1)</span>
<span class="line-added"> 377   , _tmp2(tmp2)</span>
<span class="line-added"> 378   , _left_klass(left_klass)</span>
<span class="line-added"> 379   , _right_klass(right_klass)</span>
<span class="line-added"> 380   , _left_klass_op(left_klass_op)</span>
<span class="line-added"> 381   , _right_klass_op(right_klass_op)</span>
<span class="line-added"> 382   , _stub(stub) {}</span>
<span class="line-added"> 383 </span>
 384 
 385 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 386                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 387   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 388   , _src(src)
 389   , _src_pos(src_pos)
 390   , _dst(dst)
 391   , _dst_pos(dst_pos)
 392   , _length(length)
 393   , _tmp(tmp)
 394   , _expected_type(expected_type)
 395   , _flags(flags) {
 396   _stub = new ArrayCopyStub(this);
 397 }
 398 
 399 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 400   : LIR_Op(lir_updatecrc32, res, NULL)
 401   , _crc(crc)
 402   , _val(val) {
 403 }
</pre>
<hr />
<pre>
 431 // switch that adds the operands for each instruction
 432 
 433 void LIR_OpVisitState::visit(LIR_Op* op) {
 434   // copy information from the LIR_Op
 435   reset();
 436   set_op(op);
 437 
 438   switch (op-&gt;code()) {
 439 
 440 // LIR_Op0
 441     case lir_backwardbranch_target:    // result and info always invalid
 442     case lir_fpop_raw:                 // result and info always invalid
 443     case lir_breakpoint:               // result and info always invalid
 444     case lir_membar:                   // result and info always invalid
 445     case lir_membar_acquire:           // result and info always invalid
 446     case lir_membar_release:           // result and info always invalid
 447     case lir_membar_loadload:          // result and info always invalid
 448     case lir_membar_storestore:        // result and info always invalid
 449     case lir_membar_loadstore:         // result and info always invalid
 450     case lir_membar_storeload:         // result and info always invalid
<span class="line-added"> 451     case lir_check_orig_pc:            // result and info always invalid</span>
 452     case lir_on_spin_wait:
 453     {
 454       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 455       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 456       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 457       break;
 458     }
 459 
 460     case lir_nop:                      // may have info, result always invalid
 461     case lir_std_entry:                // may have result, info always invalid
 462     case lir_osr_entry:                // may have result, info always invalid
 463     case lir_get_thread:               // may have result, info always invalid
 464     {
 465       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 466       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 467       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 468       break;
 469     }
 470 
 471 
</pre>
<hr />
<pre>
 812 
 813 
 814 // LIR_OpLock
 815     case lir_lock:
 816     case lir_unlock: {
 817       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 818       LIR_OpLock* opLock = (LIR_OpLock*)op;
 819 
 820       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 821 
 822       // TODO: check if these operands really have to be temp
 823       // (or if input is sufficient). This may have influence on the oop map!
 824       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 825       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 826       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 827 
 828       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 829       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 830 
 831       do_stub(opLock-&gt;_stub);
<span class="line-added"> 832       do_stub(opLock-&gt;_throw_imse_stub);</span>
 833 
 834       break;
 835     }
 836 
 837 
 838 // LIR_OpDelay
 839     case lir_delay_slot: {
 840       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 841       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 842 
 843       visit(opDelay-&gt;delay_op());
 844       break;
 845     }
 846 
 847 // LIR_OpTypeCheck
 848     case lir_instanceof:
 849     case lir_checkcast:
 850     case lir_store_check: {
 851       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 852       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 853 
 854       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 855       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 856       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 857       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 858         do_temp(opTypeCheck-&gt;_object);
 859       }
 860       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 861       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 862       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 863       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 864       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 865                                                   do_stub(opTypeCheck-&gt;_stub);
 866       break;
 867     }
 868 
<span class="line-added"> 869 // LIR_OpFlattenedArrayCheck</span>
<span class="line-added"> 870     case lir_flattened_array_check: {</span>
<span class="line-added"> 871       assert(op-&gt;as_OpFlattenedArrayCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 872       LIR_OpFlattenedArrayCheck* opFlattenedArrayCheck = (LIR_OpFlattenedArrayCheck*)op;</span>
<span class="line-added"> 873 </span>
<span class="line-added"> 874       if (opFlattenedArrayCheck-&gt;_array-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_array);</span>
<span class="line-added"> 875       if (opFlattenedArrayCheck-&gt;_value-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_value);</span>
<span class="line-added"> 876       if (opFlattenedArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opFlattenedArrayCheck-&gt;_tmp);</span>
<span class="line-added"> 877                                                      do_stub(opFlattenedArrayCheck-&gt;_stub);</span>
<span class="line-added"> 878 </span>
<span class="line-added"> 879       break;</span>
<span class="line-added"> 880     }</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882 // LIR_OpNullFreeArrayCheck</span>
<span class="line-added"> 883     case lir_null_free_array_check: {</span>
<span class="line-added"> 884       assert(op-&gt;as_OpNullFreeArrayCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 885       LIR_OpNullFreeArrayCheck* opNullFreeArrayCheck = (LIR_OpNullFreeArrayCheck*)op;</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887       if (opNullFreeArrayCheck-&gt;_array-&gt;is_valid()) do_input(opNullFreeArrayCheck-&gt;_array);</span>
<span class="line-added"> 888       if (opNullFreeArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opNullFreeArrayCheck-&gt;_tmp);</span>
<span class="line-added"> 889       break;</span>
<span class="line-added"> 890     }</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892 // LIR_OpSubstitutabilityCheck</span>
<span class="line-added"> 893     case lir_substitutability_check: {</span>
<span class="line-added"> 894       assert(op-&gt;as_OpSubstitutabilityCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 895       LIR_OpSubstitutabilityCheck* opSubstitutabilityCheck = (LIR_OpSubstitutabilityCheck*)op;</span>
<span class="line-added"> 896                                                                 do_input(opSubstitutabilityCheck-&gt;_left);</span>
<span class="line-added"> 897                                                                 do_temp (opSubstitutabilityCheck-&gt;_left);</span>
<span class="line-added"> 898                                                                 do_input(opSubstitutabilityCheck-&gt;_right);</span>
<span class="line-added"> 899                                                                 do_temp (opSubstitutabilityCheck-&gt;_right);</span>
<span class="line-added"> 900                                                                 do_input(opSubstitutabilityCheck-&gt;_equal_result);</span>
<span class="line-added"> 901                                                                 do_temp (opSubstitutabilityCheck-&gt;_equal_result);</span>
<span class="line-added"> 902                                                                 do_input(opSubstitutabilityCheck-&gt;_not_equal_result);</span>
<span class="line-added"> 903                                                                 do_temp (opSubstitutabilityCheck-&gt;_not_equal_result);</span>
<span class="line-added"> 904       if (opSubstitutabilityCheck-&gt;_tmp1-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp1);</span>
<span class="line-added"> 905       if (opSubstitutabilityCheck-&gt;_tmp2-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp2);</span>
<span class="line-added"> 906       if (opSubstitutabilityCheck-&gt;_left_klass_op-&gt;is_valid())  do_temp(opSubstitutabilityCheck-&gt;_left_klass_op);</span>
<span class="line-added"> 907       if (opSubstitutabilityCheck-&gt;_right_klass_op-&gt;is_valid()) do_temp(opSubstitutabilityCheck-&gt;_right_klass_op);</span>
<span class="line-added"> 908       if (opSubstitutabilityCheck-&gt;_result-&gt;is_valid())         do_output(opSubstitutabilityCheck-&gt;_result);</span>
<span class="line-added"> 909                                                                 do_info(opSubstitutabilityCheck-&gt;_info);</span>
<span class="line-added"> 910                                                                 do_stub(opSubstitutabilityCheck-&gt;_stub);</span>
<span class="line-added"> 911       break;</span>
<span class="line-added"> 912     }</span>
<span class="line-added"> 913 </span>
 914 // LIR_OpCompareAndSwap
 915     case lir_cas_long:
 916     case lir_cas_obj:
 917     case lir_cas_int: {
 918       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 919       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 920 
 921       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 922       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 923       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 924       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 925                                                       do_input(opCompareAndSwap-&gt;_addr);
 926                                                       do_temp(opCompareAndSwap-&gt;_addr);
 927                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 928                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 929                                                       do_input(opCompareAndSwap-&gt;_new_value);
 930                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 931       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 932       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 933       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
</pre>
<hr />
<pre>
1021 #ifdef ASSERT
1022 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
1023   visit(op);
1024 
1025   return opr_count(inputMode) == 0 &amp;&amp;
1026          opr_count(outputMode) == 0 &amp;&amp;
1027          opr_count(tempMode) == 0 &amp;&amp;
1028          info_count() == 0 &amp;&amp;
1029          !has_call() &amp;&amp;
1030          !has_slow_case();
1031 }
1032 #endif
1033 
1034 //---------------------------------------------------
1035 
1036 
1037 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
1038   masm-&gt;emit_call(this);
1039 }
1040 
<span class="line-added">1041 bool LIR_OpJavaCall::maybe_return_as_fields(ciValueKlass** vk_ret) const {</span>
<span class="line-added">1042   if (InlineTypeReturnedAsFields) {</span>
<span class="line-added">1043     if (method()-&gt;signature()-&gt;maybe_returns_never_null()) {</span>
<span class="line-added">1044       ciType* return_type = method()-&gt;return_type();</span>
<span class="line-added">1045       if (return_type-&gt;is_valuetype()) {</span>
<span class="line-added">1046         ciValueKlass* vk = return_type-&gt;as_value_klass();</span>
<span class="line-added">1047         if (vk-&gt;can_be_returned_as_fields()) {</span>
<span class="line-added">1048           if (vk_ret != NULL) {</span>
<span class="line-added">1049             *vk_ret = vk;</span>
<span class="line-added">1050           }</span>
<span class="line-added">1051           return true;</span>
<span class="line-added">1052         }</span>
<span class="line-added">1053       } else {</span>
<span class="line-added">1054         assert(return_type-&gt;is_instance_klass() &amp;&amp; !return_type-&gt;as_instance_klass()-&gt;is_loaded(), &quot;must be&quot;);</span>
<span class="line-added">1055         if (vk_ret != NULL) {</span>
<span class="line-added">1056           *vk_ret = NULL;</span>
<span class="line-added">1057         }</span>
<span class="line-added">1058         return true;</span>
<span class="line-added">1059       }</span>
<span class="line-added">1060     } else if (is_method_handle_invoke()) {</span>
<span class="line-added">1061       BasicType bt = method()-&gt;return_type()-&gt;basic_type();</span>
<span class="line-added">1062       if (bt == T_OBJECT || bt == T_VALUETYPE) {</span>
<span class="line-added">1063         // A value type might be returned from the call but we don&#39;t know its</span>
<span class="line-added">1064         // type. Either we get a buffered value (and nothing needs to be done)</span>
<span class="line-added">1065         // or one of the values being returned is the klass of the value type</span>
<span class="line-added">1066         // (RAX on x64, with LSB set to 1) and we need to allocate a value</span>
<span class="line-added">1067         // type instance of that type and initialize it with other values being</span>
<span class="line-added">1068         // returned (in other registers).</span>
<span class="line-added">1069         // type.</span>
<span class="line-added">1070         if (vk_ret != NULL) {</span>
<span class="line-added">1071           *vk_ret = NULL;</span>
<span class="line-added">1072         }</span>
<span class="line-added">1073         return true;</span>
<span class="line-added">1074       }</span>
<span class="line-added">1075     }</span>
<span class="line-added">1076   }</span>
<span class="line-added">1077   return false;</span>
<span class="line-added">1078 }</span>
<span class="line-added">1079 </span>
1080 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
1081   masm-&gt;emit_rtcall(this);
1082 }
1083 
1084 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
1085   masm-&gt;emit_opLabel(this);
1086 }
1087 
1088 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
1089   masm-&gt;emit_arraycopy(this);
1090   masm-&gt;append_code_stub(stub());
1091 }
1092 
1093 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
1094   masm-&gt;emit_updatecrc32(this);
1095 }
1096 
1097 void LIR_Op0::emit_code(LIR_Assembler* masm) {
1098   masm-&gt;emit_op0(this);
1099 }
</pre>
<hr />
<pre>
1120     masm-&gt;append_code_stub(stub());
1121   }
1122 }
1123 
1124 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1125   masm-&gt;emit_op2(this);
1126 }
1127 
1128 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1129   masm-&gt;emit_alloc_array(this);
1130   masm-&gt;append_code_stub(stub());
1131 }
1132 
1133 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1134   masm-&gt;emit_opTypeCheck(this);
1135   if (stub()) {
1136     masm-&gt;append_code_stub(stub());
1137   }
1138 }
1139 
<span class="line-added">1140 void LIR_OpFlattenedArrayCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1141   masm-&gt;emit_opFlattenedArrayCheck(this);</span>
<span class="line-added">1142   if (stub() != NULL) {</span>
<span class="line-added">1143     masm-&gt;append_code_stub(stub());</span>
<span class="line-added">1144   }</span>
<span class="line-added">1145 }</span>
<span class="line-added">1146 </span>
<span class="line-added">1147 void LIR_OpNullFreeArrayCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1148   masm-&gt;emit_opNullFreeArrayCheck(this);</span>
<span class="line-added">1149 }</span>
<span class="line-added">1150 </span>
<span class="line-added">1151 void LIR_OpSubstitutabilityCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1152   masm-&gt;emit_opSubstitutabilityCheck(this);</span>
<span class="line-added">1153   if (stub() != NULL) {</span>
<span class="line-added">1154     masm-&gt;append_code_stub(stub());</span>
<span class="line-added">1155   }</span>
<span class="line-added">1156 }</span>
<span class="line-added">1157 </span>
1158 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1159   masm-&gt;emit_compare_and_swap(this);
1160 }
1161 
1162 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1163   masm-&gt;emit_op3(this);
1164 }
1165 
1166 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1167   masm-&gt;emit_lock(this);
1168   if (stub()) {
1169     masm-&gt;append_code_stub(stub());
1170   }
<span class="line-added">1171   if (throw_imse_stub()) {</span>
<span class="line-added">1172     masm-&gt;append_code_stub(throw_imse_stub());</span>
<span class="line-added">1173   }</span>
1174 }
1175 
1176 #ifdef ASSERT
1177 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1178   masm-&gt;emit_assert(this);
1179 }
1180 #endif
1181 
1182 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1183   masm-&gt;emit_delay(this);
1184 }
1185 
1186 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1187   masm-&gt;emit_profile_call(this);
1188 }
1189 
1190 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1191   masm-&gt;emit_profile_type(this);
1192 }
1193 
</pre>
<hr />
<pre>
1455                     tmp));
1456 }
1457 
1458 
1459 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1460  append(new LIR_Op2(
1461                     lir_ushr,
1462                     value,
1463                     count,
1464                     dst,
1465                     tmp));
1466 }
1467 
1468 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1469   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1470                      left,
1471                      right,
1472                      dst));
1473 }
1474 
<span class="line-modified">1475 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub) {</span>
1476   append(new LIR_OpLock(
1477                     lir_lock,
1478                     hdr,
1479                     obj,
1480                     lock,
1481                     scratch,
1482                     stub,
<span class="line-modified">1483                     info,</span>
<span class="line-added">1484                     throw_imse_stub));</span>
1485 }
1486 
1487 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1488   append(new LIR_OpLock(
1489                     lir_unlock,
1490                     hdr,
1491                     obj,
1492                     lock,
1493                     scratch,
1494                     stub,
1495                     NULL));
1496 }
1497 
1498 
1499 void check_LIR() {
1500   // cannot do the proper checking as PRODUCT and other modes return different results
1501   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1502 }
1503 
1504 
1505 
1506 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1507                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1508                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">1509                           ciMethod* profiled_method, int profiled_bci, bool is_never_null) {</span>
<span class="line-added">1510   // If klass is non-nullable,  LIRGenerator::do_CheckCast has already performed null-check</span>
<span class="line-added">1511   // on the object.</span>
<span class="line-added">1512   bool need_null_check = !is_never_null;</span>
1513   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
<span class="line-modified">1514                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub,</span>
<span class="line-added">1515                                            need_null_check);</span>
1516   if (profiled_method != NULL) {
1517     c-&gt;set_profiled_method(profiled_method);
1518     c-&gt;set_profiled_bci(profiled_bci);
1519     c-&gt;set_should_profile(true);
1520   }
1521   append(c);
1522 }
1523 
1524 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1525   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1526   if (profiled_method != NULL) {
1527     c-&gt;set_profiled_method(profiled_method);
1528     c-&gt;set_profiled_bci(profiled_bci);
1529     c-&gt;set_should_profile(true);
1530   }
1531   append(c);
1532 }
1533 
1534 
1535 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1536                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
<span class="line-added">1537   // FIXME -- if the types of the array and/or the object are known statically, we can avoid loading the klass</span>
1538   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1539   if (profiled_method != NULL) {
1540     c-&gt;set_profiled_method(profiled_method);
1541     c-&gt;set_profiled_bci(profiled_bci);
1542     c-&gt;set_should_profile(true);
1543   }
1544   append(c);
1545 }
1546 
1547 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1548   if (deoptimize_on_null) {
1549     // Emit an explicit null check and deoptimize if opr is null
1550     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1551     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1552     branch(lir_cond_equal, deopt);
1553   } else {
1554     // Emit an implicit null check
1555     append(new LIR_Op1(lir_null_check, opr, info));
1556   }
1557 }
1558 
<span class="line-added">1559 void LIR_List::check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub) {</span>
<span class="line-added">1560   LIR_OpFlattenedArrayCheck* c = new LIR_OpFlattenedArrayCheck(array, value, tmp, stub);</span>
<span class="line-added">1561   append(c);</span>
<span class="line-added">1562 }</span>
<span class="line-added">1563 </span>
<span class="line-added">1564 void LIR_List::check_null_free_array(LIR_Opr array, LIR_Opr tmp) {</span>
<span class="line-added">1565   LIR_OpNullFreeArrayCheck* c = new LIR_OpNullFreeArrayCheck(array, tmp);</span>
<span class="line-added">1566   append(c);</span>
<span class="line-added">1567 }</span>
<span class="line-added">1568 </span>
<span class="line-added">1569 void LIR_List::substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added">1570                                       LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added">1571                                       ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added">1572                                       CodeEmitInfo* info, CodeStub* stub) {</span>
<span class="line-added">1573   LIR_OpSubstitutabilityCheck* c = new LIR_OpSubstitutabilityCheck(result, left, right, equal_result, not_equal_result,</span>
<span class="line-added">1574                                                                    tmp1, tmp2,</span>
<span class="line-added">1575                                                                    left_klass, right_klass, left_klass_op, right_klass_op,</span>
<span class="line-added">1576                                                                    info, stub);</span>
<span class="line-added">1577   append(c);</span>
<span class="line-added">1578 }</span>
<span class="line-added">1579 </span>
1580 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1581                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1582   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1583 }
1584 
1585 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1586                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1587   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1588 }
1589 
1590 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1591                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1592   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1593 }
1594 
1595 
1596 #ifdef PRODUCT
1597 
1598 void print_LIR(BlockList* blocks) {
1599 }
</pre>
<hr />
<pre>
1777 const char * LIR_Op::name() const {
1778   const char* s = NULL;
1779   switch(code()) {
1780      // LIR_Op0
1781      case lir_membar:                s = &quot;membar&quot;;        break;
1782      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1783      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1784      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1785      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1786      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1787      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1788      case lir_label:                 s = &quot;label&quot;;         break;
1789      case lir_nop:                   s = &quot;nop&quot;;           break;
1790      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1791      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1792      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1793      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1794      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1795      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1796      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
<span class="line-added">1797      case lir_check_orig_pc:         s = &quot;check_orig_pc&quot;; break;</span>
1798      // LIR_Op1
1799      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1800      case lir_fld:                   s = &quot;fld&quot;;           break;
1801      case lir_push:                  s = &quot;push&quot;;          break;
1802      case lir_pop:                   s = &quot;pop&quot;;           break;
1803      case lir_null_check:            s = &quot;null_check&quot;;    break;
1804      case lir_return:                s = &quot;return&quot;;        break;
1805      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1806      case lir_leal:                  s = &quot;leal&quot;;          break;
1807      case lir_branch:                s = &quot;branch&quot;;        break;
1808      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1809      case lir_move:                  s = &quot;move&quot;;          break;
1810      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1811      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1812      case lir_throw:                 s = &quot;throw&quot;;         break;
1813      case lir_unwind:                s = &quot;unwind&quot;;        break;
1814      case lir_convert:               s = &quot;convert&quot;;       break;
1815      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1816      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1817      // LIR_Op2
</pre>
<hr />
<pre>
1846      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1847      // LIR_OpJavaCall
1848      case lir_static_call:           s = &quot;static&quot;;        break;
1849      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1850      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1851      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1852      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1853      // LIR_OpArrayCopy
1854      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1855      // LIR_OpUpdateCRC32
1856      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1857      // LIR_OpLock
1858      case lir_lock:                  s = &quot;lock&quot;;          break;
1859      case lir_unlock:                s = &quot;unlock&quot;;        break;
1860      // LIR_OpDelay
1861      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1862      // LIR_OpTypeCheck
1863      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1864      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1865      case lir_store_check:           s = &quot;store_check&quot;;   break;
<span class="line-added">1866      // LIR_OpFlattenedArrayCheck</span>
<span class="line-added">1867      case lir_flattened_array_check: s = &quot;flattened_array_check&quot;; break;</span>
<span class="line-added">1868      // LIR_OpNullFreeArrayCheck</span>
<span class="line-added">1869      case lir_null_free_array_check: s = &quot;null_free_array_check&quot;; break;</span>
<span class="line-added">1870      // LIR_OpSubstitutabilityCheck</span>
<span class="line-added">1871      case lir_substitutability_check: s = &quot;substitutability_check&quot;; break;</span>
1872      // LIR_OpCompareAndSwap
1873      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1874      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1875      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1876      // LIR_OpProfileCall
1877      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1878      // LIR_OpProfileType
1879      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1880      // LIR_OpAssert
1881 #ifdef ASSERT
1882      case lir_assert:                s = &quot;assert&quot;;        break;
1883 #endif
1884      case lir_none:                  ShouldNotReachHere();break;
1885     default:                         s = &quot;illegal_op&quot;;    break;
1886   }
1887   return s;
1888 }
1889 
1890 // LIR_OpJavaCall
1891 void LIR_OpJavaCall::print_instr(outputStream* out) const {
</pre>
<hr />
<pre>
2097   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2098 }
2099 
2100 
2101 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
2102   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
2103   if (code() == lir_store_check) {
2104     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
2105   }
2106   if (code() != lir_store_check) {
2107     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
2108     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
2109   }
2110   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2111   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2112   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2113   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2114   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
2115 }
2116 
<span class="line-added">2117 void LIR_OpFlattenedArrayCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2118   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2119   value()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2120   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2121   if (stub() != NULL) {</span>
<span class="line-added">2122     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));</span>
<span class="line-added">2123   }</span>
<span class="line-added">2124 }</span>
<span class="line-added">2125 </span>
<span class="line-added">2126 void LIR_OpNullFreeArrayCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2127   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2128   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2129 }</span>
<span class="line-added">2130 </span>
<span class="line-added">2131 void LIR_OpSubstitutabilityCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2132   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2133   left()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2134   right()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2135   equal_result()-&gt;print(out);            out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2136   not_equal_result()-&gt;print(out);        out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2137   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2138   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2139   left_klass()-&gt;print(out);              out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2140   right_klass()-&gt;print(out);             out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2141   left_klass_op()-&gt;print(out);           out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2142   right_klass_op()-&gt;print(out);          out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2143   if (stub() != NULL) {</span>
<span class="line-added">2144     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));</span>
<span class="line-added">2145   }</span>
<span class="line-added">2146 }</span>
2147 
2148 // LIR_Op3
2149 void LIR_Op3::print_instr(outputStream* out) const {
2150   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2151   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2152   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2153   result_opr()-&gt;print(out);
2154 }
2155 
2156 
2157 void LIR_OpLock::print_instr(outputStream* out) const {
2158   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2159   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2160   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
2161   if (_scratch-&gt;is_valid()) {
2162     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
2163   }
2164   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2165 }
2166 
</pre>
</td>
</tr>
</table>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
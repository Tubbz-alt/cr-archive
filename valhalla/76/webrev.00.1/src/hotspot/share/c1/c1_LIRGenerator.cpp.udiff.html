<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/c1/c1_LIRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIR.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/ciField.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -32,10 +32,12 @@</span>
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
  #include &quot;ci/ciObjArray.hpp&quot;
  #include &quot;ci/ciUtilities.hpp&quot;
<span class="udiff-line-added">+ #include &quot;ci/ciValueArrayKlass.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;ci/ciValueKlass.hpp&quot;</span>
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -209,10 +211,12 @@</span>
  
    _result = opr;
  }
  
  void LIRItem::load_item() {
<span class="udiff-line-added">+   assert(!_gen-&gt;in_conditional_code(), &quot;LIRItem cannot be loaded in conditional code&quot;);</span>
<span class="udiff-line-added">+ </span>
    if (result()-&gt;is_illegal()) {
      // update the items result
      _result = value()-&gt;operand();
    }
    if (!result()-&gt;is_register()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -636,17 +640,18 @@</span>
      default: ShouldNotReachHere();
    }
  }
  
  
<span class="udiff-line-modified-removed">- void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info) {</span>
<span class="udiff-line-modified-added">+ void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no,</span>
<span class="udiff-line-added">+                                  CodeEmitInfo* info_for_exception, CodeEmitInfo* info, CodeStub* throw_imse_stub) {</span>
    if (!GenerateSynchronizationCode) return;
    // for slow path, use debug info for state after successful locking
<span class="udiff-line-modified-removed">-   CodeStub* slow_path = new MonitorEnterStub(object, lock, info);</span>
<span class="udiff-line-modified-added">+   CodeStub* slow_path = new MonitorEnterStub(object, lock, info, throw_imse_stub, scratch);</span>
    __ load_stack_address_monitor(monitor_no, lock);
    // for handling NullPointerException, use debug info representing just the lock stack before this monitorenter
<span class="udiff-line-modified-removed">-   __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception);</span>
<span class="udiff-line-modified-added">+   __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception, throw_imse_stub);</span>
  }
  
  
  void LIRGenerator::monitor_exit(LIR_Opr object, LIR_Opr lock, LIR_Opr new_hdr, LIR_Opr scratch, int monitor_no) {
    if (!GenerateSynchronizationCode) return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -784,10 +789,20 @@</span>
  
    // if a probable array type has been identified, figure out if any
    // of the required checks for a fast case can be elided.
    int flags = LIR_OpArrayCopy::all_flags;
  
<span class="udiff-line-added">+   if (!src-&gt;is_loaded_flattened_array() &amp;&amp; !dst-&gt;is_loaded_flattened_array()) {</span>
<span class="udiff-line-added">+     flags &amp;= ~LIR_OpArrayCopy::always_slow_path;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!src-&gt;maybe_flattened_array()) {</span>
<span class="udiff-line-added">+     flags &amp;= ~LIR_OpArrayCopy::src_valuetype_check;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!dst-&gt;maybe_flattened_array() &amp;&amp; !dst-&gt;maybe_null_free_array()) {</span>
<span class="udiff-line-added">+     flags &amp;= ~LIR_OpArrayCopy::dst_valuetype_check;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    if (!src_objarray)
      flags &amp;= ~LIR_OpArrayCopy::src_objarray;
    if (!dst_objarray)
      flags &amp;= ~LIR_OpArrayCopy::dst_objarray;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1426,15 +1441,23 @@</span>
      }
    }
  
    LIR_Opr result = new_register(t);
    __ move((LIR_Opr)c, result);
<span class="udiff-line-modified-removed">-   _constants.append(c);</span>
<span class="udiff-line-modified-removed">-   _reg_for_constants.append(result);</span>
<span class="udiff-line-modified-added">+   if (!in_conditional_code()) {</span>
<span class="udiff-line-modified-added">+     _constants.append(c);</span>
<span class="udiff-line-added">+     _reg_for_constants.append(result);</span>
<span class="udiff-line-added">+   }</span>
    return result;
  }
  
<span class="udiff-line-added">+ void LIRGenerator::set_in_conditional_code(bool v) {</span>
<span class="udiff-line-added">+   assert(v != _in_conditional_code, &quot;must change state&quot;);</span>
<span class="udiff-line-added">+   _in_conditional_code = v;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  //------------------------field access--------------------------------------
  
  void LIRGenerator::do_CompareAndSwap(Intrinsic* x, ValueType* type) {
    assert(x-&gt;number_of_arguments() == 4, &quot;wrong type&quot;);
    LIRItem obj   (x-&gt;argument_at(0), this);  // object
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1529,14 +1552,26 @@</span>
  #endif
  
    if (x-&gt;needs_null_check() &amp;&amp;
        (needs_patching ||
         MacroAssembler::needs_explicit_null_check(x-&gt;offset()))) {
<span class="udiff-line-modified-removed">-     // Emit an explicit null check because the offset is too large.</span>
<span class="udiff-line-modified-removed">-     // If the class is not loaded and the object is NULL, we need to deoptimize to throw a</span>
<span class="udiff-line-modified-removed">-     // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.</span>
<span class="udiff-line-modified-removed">-     __ null_check(object.result(), new CodeEmitInfo(info), /* deoptimize */ needs_patching);</span>
<span class="udiff-line-modified-added">+     if (needs_patching &amp;&amp; x-&gt;field()-&gt;is_flattenable()) {</span>
<span class="udiff-line-modified-added">+       // We are storing a field of type &quot;QT;&quot; into holder class H, but H is not yet</span>
<span class="udiff-line-modified-added">+       // loaded. (If H had been loaded, then T must also have already been loaded</span>
<span class="udiff-line-modified-added">+       // due to the &quot;Q&quot; signature, and needs_patching would be false).</span>
<span class="udiff-line-added">+       assert(!x-&gt;field()-&gt;holder()-&gt;is_loaded(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+       // We don&#39;t know the offset of this field. Let&#39;s deopt and recompile.</span>
<span class="udiff-line-added">+       CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),</span>
<span class="udiff-line-added">+                                           Deoptimization::Reason_unloaded,</span>
<span class="udiff-line-added">+                                           Deoptimization::Action_make_not_entrant);</span>
<span class="udiff-line-added">+       __ branch(lir_cond_always, stub);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       // Emit an explicit null check because the offset is too large.</span>
<span class="udiff-line-added">+       // If the class is not loaded and the object is NULL, we need to deoptimize to throw a</span>
<span class="udiff-line-added">+       // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.</span>
<span class="udiff-line-added">+       __ null_check(object.result(), new CodeEmitInfo(info), /* deoptimize */ needs_patching);</span>
<span class="udiff-line-added">+     }</span>
    }
  
    DecoratorSet decorators = IN_HEAP;
    if (is_volatile) {
      decorators |= MO_SEQ_CST;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1547,18 +1582,144 @@</span>
  
    access_store_at(decorators, field_type, object, LIR_OprFact::intConst(x-&gt;offset()),
                    value.result(), info != NULL ? new CodeEmitInfo(info) : NULL, info);
  }
  
<span class="udiff-line-added">+ // FIXME -- I can&#39;t find any other way to pass an address to access_load_at().</span>
<span class="udiff-line-added">+ class TempResolvedAddress: public Instruction {</span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+   TempResolvedAddress(ValueType* type, LIR_Opr addr) : Instruction(type) {</span>
<span class="udiff-line-added">+     set_operand(addr);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   virtual void input_values_do(ValueVisitor*) {}</span>
<span class="udiff-line-added">+   virtual void visit(InstructionVisitor* v)   {}</span>
<span class="udiff-line-added">+   virtual const char* name() const  { return &quot;TempResolvedAddress&quot;; }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIRGenerator::access_flattened_array(bool is_load, LIRItem&amp; array, LIRItem&amp; index, LIRItem&amp; obj_item) {</span>
<span class="udiff-line-added">+   // Find the starting address of the source (inside the array)</span>
<span class="udiff-line-added">+   ciType* array_type = array.value()-&gt;declared_type();</span>
<span class="udiff-line-added">+   ciValueArrayKlass* value_array_klass = array_type-&gt;as_value_array_klass();</span>
<span class="udiff-line-added">+   assert(value_array_klass-&gt;is_loaded(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ciValueKlass* elem_klass = value_array_klass-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="udiff-line-added">+   int array_header_size = value_array_klass-&gt;array_header_in_bytes();</span>
<span class="udiff-line-added">+   int shift = value_array_klass-&gt;log2_element_size();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef _LP64</span>
<span class="udiff-line-added">+   LIR_Opr index_op = new_register(T_INT);</span>
<span class="udiff-line-added">+   // FIXME -- on 32-bit, the shift below can overflow, so we need to check that</span>
<span class="udiff-line-added">+   // the top (shift+1) bits of index_op must be zero, or</span>
<span class="udiff-line-added">+   // else throw ArrayIndexOutOfBoundsException</span>
<span class="udiff-line-added">+   if (index.result()-&gt;is_constant()) {</span>
<span class="udiff-line-added">+     jint const_index = index.result()-&gt;as_jint();</span>
<span class="udiff-line-added">+     __ move(LIR_OprFact::intConst(const_index &lt;&lt; shift), index_op);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     __ shift_left(index_op, shift, index.result());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   LIR_Opr index_op = new_register(T_LONG);</span>
<span class="udiff-line-added">+   if (index.result()-&gt;is_constant()) {</span>
<span class="udiff-line-added">+     jint const_index = index.result()-&gt;as_jint();</span>
<span class="udiff-line-added">+     __ move(LIR_OprFact::longConst(const_index &lt;&lt; shift), index_op);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     __ convert(Bytecodes::_i2l, index.result(), index_op);</span>
<span class="udiff-line-added">+     // Need to shift manually, as LIR_Address can scale only up to 3.</span>
<span class="udiff-line-added">+     __ shift_left(index_op, shift, index_op);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   LIR_Opr elm_op = new_pointer_register();</span>
<span class="udiff-line-added">+   LIR_Address* elm_address = new LIR_Address(array.result(), index_op, array_header_size, T_ADDRESS);</span>
<span class="udiff-line-added">+   __ leal(LIR_OprFact::address(elm_address), elm_op);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; elem_klass-&gt;nof_nonstatic_fields(); i++) {</span>
<span class="udiff-line-added">+     ciField* inner_field = elem_klass-&gt;nonstatic_field_at(i);</span>
<span class="udiff-line-added">+     assert(!inner_field-&gt;is_flattened(), &quot;flattened fields must have been expanded&quot;);</span>
<span class="udiff-line-added">+     int obj_offset = inner_field-&gt;offset();</span>
<span class="udiff-line-added">+     int elm_offset = obj_offset - elem_klass-&gt;first_field_offset(); // object header is not stored in array.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BasicType field_type = inner_field-&gt;type()-&gt;basic_type();</span>
<span class="udiff-line-added">+     switch (field_type) {</span>
<span class="udiff-line-added">+     case T_BYTE:</span>
<span class="udiff-line-added">+     case T_BOOLEAN:</span>
<span class="udiff-line-added">+     case T_SHORT:</span>
<span class="udiff-line-added">+     case T_CHAR:</span>
<span class="udiff-line-added">+      field_type = T_INT;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LIR_Opr temp = new_register(field_type);</span>
<span class="udiff-line-added">+     TempResolvedAddress* elm_resolved_addr = new TempResolvedAddress(as_ValueType(field_type), elm_op);</span>
<span class="udiff-line-added">+     LIRItem elm_item(elm_resolved_addr, this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     DecoratorSet decorators = IN_HEAP;</span>
<span class="udiff-line-added">+     if (is_load) {</span>
<span class="udiff-line-added">+       access_load_at(decorators, field_type,</span>
<span class="udiff-line-added">+                      elm_item, LIR_OprFact::intConst(elm_offset), temp,</span>
<span class="udiff-line-added">+                      NULL, NULL);</span>
<span class="udiff-line-added">+       access_store_at(decorators, field_type,</span>
<span class="udiff-line-added">+                       obj_item, LIR_OprFact::intConst(obj_offset), temp,</span>
<span class="udiff-line-added">+                       NULL, NULL);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       access_load_at(decorators, field_type,</span>
<span class="udiff-line-added">+                      obj_item, LIR_OprFact::intConst(obj_offset), temp,</span>
<span class="udiff-line-added">+                      NULL, NULL);</span>
<span class="udiff-line-added">+       access_store_at(decorators, field_type,</span>
<span class="udiff-line-added">+                       elm_item, LIR_OprFact::intConst(elm_offset), temp,</span>
<span class="udiff-line-added">+                       NULL, NULL);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIRGenerator::check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path) {</span>
<span class="udiff-line-added">+   LIR_Opr tmp = new_register(T_METADATA);</span>
<span class="udiff-line-added">+   __ check_flattened_array(array, value, tmp, slow_path);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIRGenerator::check_null_free_array(LIRItem&amp; array, LIRItem&amp; value, CodeEmitInfo* info) {</span>
<span class="udiff-line-added">+   LabelObj* L_end = new LabelObj();</span>
<span class="udiff-line-added">+   LIR_Opr tmp = new_register(T_METADATA);</span>
<span class="udiff-line-added">+   __ check_null_free_array(array.result(), tmp);</span>
<span class="udiff-line-added">+   __ branch(lir_cond_equal, L_end-&gt;label());</span>
<span class="udiff-line-added">+   __ null_check(value.result(), info);</span>
<span class="udiff-line-added">+   __ branch_destination(L_end-&gt;label());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {</span>
<span class="udiff-line-added">+   if (x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_flattened_array()) {</span>
<span class="udiff-line-added">+     ciType* type = x-&gt;value()-&gt;declared_type();</span>
<span class="udiff-line-added">+     if (type != NULL &amp;&amp; type-&gt;is_klass()) {</span>
<span class="udiff-line-added">+       ciKlass* klass = type-&gt;as_klass();</span>
<span class="udiff-line-added">+       if (!klass-&gt;can_be_value_klass() || (klass-&gt;is_valuetype() &amp;&amp; !klass-&gt;as_value_klass()-&gt;flatten_array())) {</span>
<span class="udiff-line-added">+         // This is known to be a non-flattenable object. If the array is flattened,</span>
<span class="udiff-line-added">+         // it will be caught by the code generated by array_store_check().</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // We&#39;re not 100% sure, so let&#39;s do the flattened_array_store_check.</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool LIRGenerator::needs_null_free_array_store_check(StoreIndexed* x) {</span>
<span class="udiff-line-added">+   return x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_null_free_array();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void LIRGenerator::do_StoreIndexed(StoreIndexed* x) {
    assert(x-&gt;is_pinned(),&quot;&quot;);
<span class="udiff-line-added">+   assert(x-&gt;elt_type() != T_ARRAY, &quot;never used&quot;);</span>
<span class="udiff-line-added">+   bool is_loaded_flattened_array = x-&gt;array()-&gt;is_loaded_flattened_array();</span>
    bool needs_range_check = x-&gt;compute_needs_range_check();
    bool use_length = x-&gt;length() != NULL;
    bool obj_store = is_reference_type(x-&gt;elt_type());
<span class="udiff-line-modified-removed">-   bool needs_store_check = obj_store &amp;&amp; (x-&gt;value()-&gt;as_Constant() == NULL ||</span>
<span class="udiff-line-modified-removed">-                                          !get_jobject_constant(x-&gt;value())-&gt;is_null_object() ||</span>
<span class="udiff-line-modified-removed">-                                          x-&gt;should_profile());</span>
<span class="udiff-line-modified-added">+   bool needs_store_check = obj_store &amp;&amp; !(is_loaded_flattened_array &amp;&amp; x-&gt;is_exact_flattened_array_store()) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                                         (x-&gt;value()-&gt;as_Constant() == NULL ||</span>
<span class="udiff-line-modified-added">+                                          !get_jobject_constant(x-&gt;value())-&gt;is_null_object());</span>
  
    LIRItem array(x-&gt;array(), this);
    LIRItem index(x-&gt;index(), this);
    LIRItem value(x-&gt;value(), this);
    LIRItem length(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1567,12 +1728,13 @@</span>
    index.load_nonconstant();
  
    if (use_length &amp;&amp; needs_range_check) {
      length.set_instruction(x-&gt;length());
      length.load_item();
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   if (needs_store_check || x-&gt;check_boolean()</span>
        || is_loaded_flattened_array || needs_flattened_array_store_check(x) || needs_null_free_array_store_check(x)) {
      value.load_item();
    } else {
      value.load_for_store(x-&gt;elt_type());
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1597,22 +1759,60 @@</span>
        // range_check also does the null check
        null_check_info = NULL;
      }
    }
  
<span class="udiff-line-added">+   if (x-&gt;should_profile()) {</span>
<span class="udiff-line-added">+     ciMethodData* md = NULL;</span>
<span class="udiff-line-added">+     ciArrayLoadStoreData* load_store = NULL;</span>
<span class="udiff-line-added">+     profile_array_type(x, md, load_store);</span>
<span class="udiff-line-added">+     if (is_loaded_flattened_array) {</span>
<span class="udiff-line-added">+       int flag = ArrayLoadStoreData::flat_array_byte_constant() | ArrayLoadStoreData::null_free_array_byte_constant();</span>
<span class="udiff-line-added">+       assert(md != NULL, &quot;should have been initialized&quot;);</span>
<span class="udiff-line-added">+       profile_array_load_store_flags(md, load_store, flag);</span>
<span class="udiff-line-added">+     } else if (x-&gt;array()-&gt;maybe_null_free_array()) {</span>
<span class="udiff-line-added">+       profile_null_free_array(array, md, load_store);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     profile_element_type(x-&gt;value(), md, load_store);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    if (GenerateArrayStoreCheck &amp;&amp; needs_store_check) {
      CodeEmitInfo* store_check_info = new CodeEmitInfo(range_check_info);
<span class="udiff-line-modified-removed">-     array_store_check(value.result(), array.result(), store_check_info, x-&gt;profiled_method(), x-&gt;profiled_bci());</span>
<span class="udiff-line-modified-added">+     array_store_check(value.result(), array.result(), store_check_info, NULL, -1);</span>
    }
  
<span class="udiff-line-modified-removed">-   DecoratorSet decorators = IN_HEAP | IS_ARRAY;</span>
<span class="udiff-line-modified-removed">-   if (x-&gt;check_boolean()) {</span>
<span class="udiff-line-modified-removed">-     decorators |= C1_MASK_BOOLEAN;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   if (is_loaded_flattened_array) {</span>
<span class="udiff-line-modified-added">+     if (!x-&gt;value()-&gt;is_never_null()) {</span>
<span class="udiff-line-modified-added">+       __ null_check(value.result(), new CodeEmitInfo(range_check_info));</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+     access_flattened_array(false, array, index, value);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     StoreFlattenedArrayStub* slow_path = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (needs_flattened_array_store_check(x)) {</span>
<span class="udiff-line-added">+       // Check if we indeed have a flattened array</span>
<span class="udiff-line-added">+       index.load_item();</span>
<span class="udiff-line-added">+       slow_path = new StoreFlattenedArrayStub(array.result(), index.result(), value.result(), state_for(x, x-&gt;state_before()));</span>
<span class="udiff-line-added">+       check_flattened_array(array.result(), value.result(), slow_path);</span>
<span class="udiff-line-added">+       set_in_conditional_code(true);</span>
<span class="udiff-line-added">+     } else if (needs_null_free_array_store_check(x)) {</span>
<span class="udiff-line-added">+       CodeEmitInfo* info = new CodeEmitInfo(range_check_info);</span>
<span class="udiff-line-added">+       check_null_free_array(array, value, info);</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-   access_store_at(decorators, x-&gt;elt_type(), array, index.result(), value.result(),</span>
<span class="udiff-line-modified-removed">-                   NULL, null_check_info);</span>
<span class="udiff-line-modified-added">+     DecoratorSet decorators = IN_HEAP | IS_ARRAY;</span>
<span class="udiff-line-modified-added">+     if (x-&gt;check_boolean()) {</span>
<span class="udiff-line-added">+       decorators |= C1_MASK_BOOLEAN;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     access_store_at(decorators, x-&gt;elt_type(), array, index.result(), value.result(),</span>
<span class="udiff-line-added">+                     NULL, null_check_info);</span>
<span class="udiff-line-added">+     if (slow_path != NULL) {</span>
<span class="udiff-line-added">+       __ branch_destination(slow_path-&gt;continuation());</span>
<span class="udiff-line-added">+       set_in_conditional_code(false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  }
  
  void LIRGenerator::access_load_at(DecoratorSet decorators, BasicType type,
                                    LIRItem&amp; base, LIR_Opr offset, LIR_Opr result,
                                    CodeEmitInfo* patch_info, CodeEmitInfo* load_emit_info) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1698,10 +1898,84 @@</span>
    }
  
    return _barrier_set-&gt;resolve(this, decorators, obj);
  }
  
<span class="udiff-line-added">+ Constant* LIRGenerator::flattenable_load_field_prolog(LoadField* x, CodeEmitInfo* info) {</span>
<span class="udiff-line-added">+   ciField* field = x-&gt;field();</span>
<span class="udiff-line-added">+   ciInstanceKlass* holder = field-&gt;holder();</span>
<span class="udiff-line-added">+   Constant* default_value = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Unloaded &quot;QV;&quot; klasses are represented by a ciInstanceKlass</span>
<span class="udiff-line-added">+   bool field_type_unloaded = field-&gt;type()-&gt;is_instance_klass() &amp;&amp; !field-&gt;type()-&gt;as_instance_klass()-&gt;is_loaded();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Check for edge cases (1), (2) and (3) for getstatic and getfield</span>
<span class="udiff-line-added">+   bool deopt = false;</span>
<span class="udiff-line-added">+   bool need_default = false;</span>
<span class="udiff-line-added">+   if (field-&gt;is_static()) {</span>
<span class="udiff-line-added">+       // (1) holder is unloaded -- no problem: it will be loaded by patching, and field offset will be determined.</span>
<span class="udiff-line-added">+       // No check needed here.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (field_type_unloaded) {</span>
<span class="udiff-line-added">+       // (2) field type is unloaded -- problem: we don&#39;t know what the default value is. Let&#39;s deopt.</span>
<span class="udiff-line-added">+       //                               FIXME: consider getting the default value in patching code.</span>
<span class="udiff-line-added">+       deopt = true;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       need_default = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       // (3) field is not flattened -- we don&#39;t care: static fields are never flattened.</span>
<span class="udiff-line-added">+       // No check needed here.</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     if (!holder-&gt;is_loaded()) {</span>
<span class="udiff-line-added">+       // (1) holder is unloaded -- problem: we needed the field offset back in GraphBuilder::access_field()</span>
<span class="udiff-line-added">+       //                           FIXME: consider getting field offset in patching code (but only if the field</span>
<span class="udiff-line-added">+       //                           type was loaded at compilation time).</span>
<span class="udiff-line-added">+       deopt = true;</span>
<span class="udiff-line-added">+     } else if (field_type_unloaded) {</span>
<span class="udiff-line-added">+       // (2) field type is unloaded -- problem: we don&#39;t know whether it&#39;s flattened or not. Let&#39;s deopt</span>
<span class="udiff-line-added">+       deopt = true;</span>
<span class="udiff-line-added">+     } else if (!field-&gt;is_flattened()) {</span>
<span class="udiff-line-added">+       // (3) field is not flattened -- need default value in cases of uninitialized field</span>
<span class="udiff-line-added">+       need_default = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (deopt) {</span>
<span class="udiff-line-added">+     assert(!need_default, &quot;deopt and need_default cannot both be true&quot;);</span>
<span class="udiff-line-added">+     assert(x-&gt;needs_patching(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+     assert(info != NULL, &quot;must be&quot;);</span>
<span class="udiff-line-added">+     CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),</span>
<span class="udiff-line-added">+                                         Deoptimization::Reason_unloaded,</span>
<span class="udiff-line-added">+                                         Deoptimization::Action_make_not_entrant);</span>
<span class="udiff-line-added">+     __ branch(lir_cond_always, stub);</span>
<span class="udiff-line-added">+   } else if (need_default) {</span>
<span class="udiff-line-added">+     assert(!field_type_unloaded, &quot;must be&quot;);</span>
<span class="udiff-line-added">+     assert(field-&gt;type()-&gt;is_valuetype(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+     ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();</span>
<span class="udiff-line-added">+     assert(value_klass-&gt;is_loaded(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (field-&gt;is_static() &amp;&amp; holder-&gt;is_loaded()) {</span>
<span class="udiff-line-added">+       ciInstance* mirror = field-&gt;holder()-&gt;java_mirror();</span>
<span class="udiff-line-added">+       ciObject* val = mirror-&gt;field_value(field).as_object();</span>
<span class="udiff-line-added">+       if (val-&gt;is_null_object()) {</span>
<span class="udiff-line-added">+         // This is a non-nullable static field, but it&#39;s not initialized.</span>
<span class="udiff-line-added">+         // We need to do a null check, and replace it with the default value.</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         // No need to perform null check on this static field</span>
<span class="udiff-line-added">+         need_default = false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (need_default) {</span>
<span class="udiff-line-added">+       default_value = new Constant(new InstanceConstant(value_klass-&gt;default_value_instance()));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return default_value;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void LIRGenerator::do_LoadField(LoadField* x) {
    bool needs_patching = x-&gt;needs_patching();
    bool is_volatile = x-&gt;field()-&gt;is_volatile();
    BasicType field_type = x-&gt;field_type();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1727,10 +2001,15 @@</span>
      tty-&gt;print_cr(&quot;   ###class not loaded at load_%s bci %d&quot;,
                    x-&gt;is_static() ?  &quot;static&quot; : &quot;field&quot;, x-&gt;printable_bci());
    }
  #endif
  
<span class="udiff-line-added">+   Constant* default_value = NULL;</span>
<span class="udiff-line-added">+   if (x-&gt;field()-&gt;is_flattenable()) {</span>
<span class="udiff-line-added">+     default_value = flattenable_load_field_prolog(x, info);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    bool stress_deopt = StressLoopInvariantCodeMotion &amp;&amp; info &amp;&amp; info-&gt;deoptimize_on_exception();
    if (x-&gt;needs_null_check() &amp;&amp;
        (needs_patching ||
         MacroAssembler::needs_explicit_null_check(x-&gt;offset()) ||
         stress_deopt)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1755,10 +2034,20 @@</span>
  
    LIR_Opr result = rlock_result(x, field_type);
    access_load_at(decorators, field_type,
                   object, LIR_OprFact::intConst(x-&gt;offset()), result,
                   info ? new CodeEmitInfo(info) : NULL, info);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (default_value != NULL) {</span>
<span class="udiff-line-added">+     LabelObj* L_end = new LabelObj();</span>
<span class="udiff-line-added">+     __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));</span>
<span class="udiff-line-added">+     __ branch(lir_cond_notEqual, L_end-&gt;label());</span>
<span class="udiff-line-added">+     set_in_conditional_code(true);</span>
<span class="udiff-line-added">+     __ move(load_constant(default_value), result);</span>
<span class="udiff-line-added">+     __ branch_destination(L_end-&gt;label());</span>
<span class="udiff-line-added">+     set_in_conditional_code(false);</span>
<span class="udiff-line-added">+   }</span>
  }
  
  
  //------------------------java.nio.Buffer.checkIndex------------------------
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1869,18 +2158,87 @@</span>
        // The range check performs the null check, so clear it out for the load
        null_check_info = NULL;
      }
    }
  
<span class="udiff-line-modified-removed">-   DecoratorSet decorators = IN_HEAP | IS_ARRAY;</span>
<span class="udiff-line-modified-added">+   ciMethodData* md = NULL;</span>
<span class="udiff-line-added">+   ciArrayLoadStoreData* load_store = NULL;</span>
<span class="udiff-line-added">+   if (x-&gt;should_profile()) {</span>
<span class="udiff-line-added">+     profile_array_type(x, md, load_store);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Value element;</span>
<span class="udiff-line-added">+   if (x-&gt;vt() != NULL) {</span>
<span class="udiff-line-added">+     assert(x-&gt;array()-&gt;is_loaded_flattened_array(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+     // Find the destination address (of the NewValueTypeInstance).</span>
<span class="udiff-line-added">+     LIR_Opr obj = x-&gt;vt()-&gt;operand();</span>
<span class="udiff-line-added">+     LIRItem obj_item(x-&gt;vt(), this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     access_flattened_array(true, array, index, obj_item);</span>
<span class="udiff-line-added">+     set_no_result(x);</span>
<span class="udiff-line-added">+     element = x-&gt;vt();</span>
<span class="udiff-line-added">+     if (x-&gt;should_profile()) {</span>
<span class="udiff-line-added">+       int flag = ArrayLoadStoreData::flat_array_byte_constant() | ArrayLoadStoreData::null_free_array_byte_constant();</span>
<span class="udiff-line-added">+       profile_array_load_store_flags(md, load_store, flag);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     LIR_Opr result = rlock_result(x, x-&gt;elt_type());</span>
<span class="udiff-line-added">+     LoadFlattenedArrayStub* slow_path = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (x-&gt;should_profile() &amp;&amp; x-&gt;array()-&gt;maybe_null_free_array()) {</span>
<span class="udiff-line-added">+       profile_null_free_array(array, md, load_store);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_flattened_array()) {</span>
<span class="udiff-line-added">+       index.load_item();</span>
<span class="udiff-line-added">+       // if we are loading from flattened array, load it using a runtime call</span>
<span class="udiff-line-added">+       slow_path = new LoadFlattenedArrayStub(array.result(), index.result(), result, state_for(x, x-&gt;state_before()));</span>
<span class="udiff-line-added">+       check_flattened_array(array.result(), LIR_OprFact::illegalOpr, slow_path);</span>
<span class="udiff-line-added">+       set_in_conditional_code(true);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     DecoratorSet decorators = IN_HEAP | IS_ARRAY;</span>
<span class="udiff-line-added">+     access_load_at(decorators, x-&gt;elt_type(),</span>
<span class="udiff-line-added">+                    array, index.result(), result,</span>
<span class="udiff-line-added">+                    NULL, null_check_info);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (slow_path != NULL) {</span>
<span class="udiff-line-added">+       __ branch_destination(slow_path-&gt;continuation());</span>
<span class="udiff-line-added">+       set_in_conditional_code(false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     element = x;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (x-&gt;should_profile()) {</span>
<span class="udiff-line-added">+     profile_element_type(element, md, load_store);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   LIR_Opr result = rlock_result(x, x-&gt;elt_type());</span>
<span class="udiff-line-modified-removed">-   access_load_at(decorators, x-&gt;elt_type(),</span>
<span class="udiff-line-modified-removed">-                  array, index.result(), result,</span>
<span class="udiff-line-modified-removed">-                  NULL, null_check_info);</span>
<span class="udiff-line-modified-added">+ void LIRGenerator::do_WithField(WithField* x) {</span>
<span class="udiff-line-modified-added">+   // This happens only when a class X uses the withfield bytecode to refer to</span>
<span class="udiff-line-modified-added">+   // an inline class V, where V has not yet been loaded. This is not a common</span>
<span class="udiff-line-modified-added">+   // case. Let&#39;s just deoptimize.</span>
<span class="udiff-line-added">+   CodeEmitInfo* info = state_for(x, x-&gt;state_before());</span>
<span class="udiff-line-added">+   CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),</span>
<span class="udiff-line-added">+                                       Deoptimization::Reason_unloaded,</span>
<span class="udiff-line-added">+                                       Deoptimization::Action_make_not_entrant);</span>
<span class="udiff-line-added">+   __ branch(lir_cond_always, stub);</span>
<span class="udiff-line-added">+   LIR_Opr reg = rlock_result(x, T_OBJECT);</span>
<span class="udiff-line-added">+   __ move(LIR_OprFact::oopConst(NULL), reg);</span>
  }
  
<span class="udiff-line-added">+ void LIRGenerator::do_DefaultValue(DefaultValue* x) {</span>
<span class="udiff-line-added">+   // Same as withfield above. Let&#39;s deoptimize.</span>
<span class="udiff-line-added">+   CodeEmitInfo* info = state_for(x, x-&gt;state_before());</span>
<span class="udiff-line-added">+   CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),</span>
<span class="udiff-line-added">+                                       Deoptimization::Reason_unloaded,</span>
<span class="udiff-line-added">+                                       Deoptimization::Action_make_not_entrant);</span>
<span class="udiff-line-added">+   __ branch(lir_cond_always, stub);</span>
<span class="udiff-line-added">+   LIR_Opr reg = rlock_result(x, T_OBJECT);</span>
<span class="udiff-line-added">+   __ move(LIR_OprFact::oopConst(NULL), reg);</span>
<span class="udiff-line-added">+ }</span>
  
  void LIRGenerator::do_NullCheck(NullCheck* x) {
    if (x-&gt;can_trap()) {
      LIRItem value(x-&gt;obj(), this);
      value.load_item();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2540,11 +2898,11 @@</span>
    if (!do_null &amp;&amp; !do_update) {
      return result;
    }
  
    ciKlass* exact_signature_k = NULL;
<span class="udiff-line-modified-removed">-   if (do_update) {</span>
<span class="udiff-line-modified-added">+   if (do_update &amp;&amp; signature_at_call_k != NULL) {</span>
      // Is the type from the signature exact (the only one possible)?
      exact_signature_k = signature_at_call_k-&gt;exact_klass();
      if (exact_signature_k == NULL) {
        exact_signature_k = comp-&gt;cha_exact_type(signature_at_call_k);
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2625,10 +2983,57 @@</span>
        }
      }
    }
  }
  
<span class="udiff-line-added">+ void LIRGenerator::profile_array_load_store_flags(ciMethodData* md, ciArrayLoadStoreData* load_store, int flag, LIR_Opr mdp) {</span>
<span class="udiff-line-added">+   assert(md != NULL &amp;&amp; load_store != NULL, &quot;should have been initialized&quot;);</span>
<span class="udiff-line-added">+   if (mdp == NULL) {</span>
<span class="udiff-line-added">+     mdp = new_register(T_METADATA);</span>
<span class="udiff-line-added">+     __ metadata2reg(md-&gt;constant_encoding(), mdp);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   LIR_Address* addr = new LIR_Address(mdp, md-&gt;byte_offset_of_slot(load_store, DataLayout::flags_offset()), T_BYTE);</span>
<span class="udiff-line-added">+   LIR_Opr id = new_register(T_INT);</span>
<span class="udiff-line-added">+   __ move(addr, id);</span>
<span class="udiff-line-added">+   __ logical_or(id, LIR_OprFact::intConst(flag), id);</span>
<span class="udiff-line-added">+   __ store(id, addr);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIRGenerator::profile_null_free_array(LIRItem array, ciMethodData* md, ciArrayLoadStoreData* load_store) {</span>
<span class="udiff-line-added">+   LabelObj* L_end = new LabelObj();</span>
<span class="udiff-line-added">+   LIR_Opr tmp = new_register(T_METADATA);</span>
<span class="udiff-line-added">+   LIR_Opr mdp = new_register(T_METADATA);</span>
<span class="udiff-line-added">+   assert(md != NULL, &quot;should have been initialized&quot;);</span>
<span class="udiff-line-added">+   __ metadata2reg(md-&gt;constant_encoding(), mdp);</span>
<span class="udiff-line-added">+   __ check_null_free_array(array.result(), tmp);</span>
<span class="udiff-line-added">+   __ branch(lir_cond_equal, L_end-&gt;label());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   profile_array_load_store_flags(md, load_store, ArrayLoadStoreData::null_free_array_byte_constant(), mdp);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ branch_destination(L_end-&gt;label());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIRGenerator::profile_array_type(AccessIndexed* x, ciMethodData*&amp; md, ciArrayLoadStoreData*&amp; load_store) {</span>
<span class="udiff-line-added">+   int bci = x-&gt;profiled_bci();</span>
<span class="udiff-line-added">+   md = x-&gt;profiled_method()-&gt;method_data();</span>
<span class="udiff-line-added">+   assert(md != NULL, &quot;Sanity&quot;);</span>
<span class="udiff-line-added">+   ciProfileData* data = md-&gt;bci_to_data(bci);</span>
<span class="udiff-line-added">+   assert(data != NULL &amp;&amp; data-&gt;is_ArrayLoadStoreData(), &quot;incorrect profiling entry&quot;);</span>
<span class="udiff-line-added">+   load_store = (ciArrayLoadStoreData*)data;</span>
<span class="udiff-line-added">+   LIR_Opr mdp = LIR_OprFact::illegalOpr;</span>
<span class="udiff-line-added">+   profile_type(md, md-&gt;byte_offset_of_slot(load_store, ArrayLoadStoreData::array_offset()), 0,</span>
<span class="udiff-line-added">+                load_store-&gt;array()-&gt;type(), x-&gt;array(), mdp, true, NULL, NULL);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIRGenerator::profile_element_type(Value element, ciMethodData* md, ciArrayLoadStoreData* load_store) {</span>
<span class="udiff-line-added">+   assert(md != NULL &amp;&amp; load_store != NULL, &quot;should have been initialized&quot;);</span>
<span class="udiff-line-added">+   LIR_Opr mdp = LIR_OprFact::illegalOpr;</span>
<span class="udiff-line-added">+   profile_type(md, md-&gt;byte_offset_of_slot(load_store, ArrayLoadStoreData::element_offset()), 0,</span>
<span class="udiff-line-added">+                load_store-&gt;element()-&gt;type(), element, mdp, false, NULL, NULL);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  void LIRGenerator::do_Base(Base* x) {
    __ std_entry(LIR_OprFact::illegalOpr);
    // Emit moves from physical registers / stack slots to virtual registers
    CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
    IRScope* irScope = compilation()-&gt;hir()-&gt;top_scope();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2709,10 +3114,18 @@</span>
    if (!method()-&gt;is_accessor()) { // Accessors do not have MDOs, so no counting.
      profile_parameters(x);
      CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, SynchronizationEntryBCI), NULL, false);
      increment_invocation_counter(info);
    }
<span class="udiff-line-added">+   if (method()-&gt;has_scalarized_args()) {</span>
<span class="udiff-line-added">+     // Check if deoptimization was triggered (i.e. orig_pc was set) while buffering scalarized value type arguments</span>
<span class="udiff-line-added">+     // in the entry point (see comments in frame::deoptimize). If so, deoptimize only now that we have the right state.</span>
<span class="udiff-line-added">+     CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, 0), NULL, false);</span>
<span class="udiff-line-added">+     CodeStub* deopt_stub = new DeoptimizeStub(info, Deoptimization::Reason_none, Deoptimization::Action_none);</span>
<span class="udiff-line-added">+     __ append(new LIR_Op0(lir_check_orig_pc));</span>
<span class="udiff-line-added">+     __ branch(lir_cond_notEqual, deopt_stub);</span>
<span class="udiff-line-added">+   }</span>
  
    // all blocks with a successor must end with an unconditional jump
    // to the successor even if they are consecutive
    __ jump(x-&gt;default_sux());
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2724,31 +3137,36 @@</span>
    __ osr_entry(LIR_Assembler::osrBufferPointer());
    LIR_Opr result = rlock_result(x);
    __ move(LIR_Assembler::osrBufferPointer(), result);
  }
  
<span class="udiff-line-added">+ void LIRGenerator::invoke_load_one_argument(LIRItem* param, LIR_Opr loc) {</span>
<span class="udiff-line-added">+   if (loc-&gt;is_register()) {</span>
<span class="udiff-line-added">+     param-&gt;load_item_force(loc);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     LIR_Address* addr = loc-&gt;as_address_ptr();</span>
<span class="udiff-line-added">+     param-&gt;load_for_store(addr-&gt;type());</span>
<span class="udiff-line-added">+     assert(addr-&gt;type() != T_VALUETYPE, &quot;not supported yet&quot;);</span>
<span class="udiff-line-added">+     if (addr-&gt;type() == T_OBJECT) {</span>
<span class="udiff-line-added">+       __ move_wide(param-&gt;result(), addr);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       if (addr-&gt;type() == T_LONG || addr-&gt;type() == T_DOUBLE) {</span>
<span class="udiff-line-added">+         __ unaligned_move(param-&gt;result(), addr);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         __ move(param-&gt;result(), addr);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  void LIRGenerator::invoke_load_arguments(Invoke* x, LIRItemList* args, const LIR_OprList* arg_list) {
    assert(args-&gt;length() == arg_list-&gt;length(),
           &quot;args=%d, arg_list=%d&quot;, args-&gt;length(), arg_list-&gt;length());
    for (int i = x-&gt;has_receiver() ? 1 : 0; i &lt; args-&gt;length(); i++) {
      LIRItem* param = args-&gt;at(i);
      LIR_Opr loc = arg_list-&gt;at(i);
<span class="udiff-line-modified-removed">-     if (loc-&gt;is_register()) {</span>
<span class="udiff-line-removed">-       param-&gt;load_item_force(loc);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       LIR_Address* addr = loc-&gt;as_address_ptr();</span>
<span class="udiff-line-removed">-       param-&gt;load_for_store(addr-&gt;type());</span>
<span class="udiff-line-removed">-       if (addr-&gt;type() == T_OBJECT) {</span>
<span class="udiff-line-removed">-         __ move_wide(param-&gt;result(), addr);</span>
<span class="udiff-line-removed">-       } else</span>
<span class="udiff-line-removed">-         if (addr-&gt;type() == T_LONG || addr-&gt;type() == T_DOUBLE) {</span>
<span class="udiff-line-removed">-           __ unaligned_move(param-&gt;result(), addr);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           __ move(param-&gt;result(), addr);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     invoke_load_one_argument(param, loc);</span>
    }
  
    if (x-&gt;has_receiver()) {
      LIRItem* receiver = args-&gt;at(0);
      LIR_Opr loc = arg_list-&gt;at(0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2925,23 +3343,81 @@</span>
  #endif
  
    LIRItem left(x-&gt;x(), this);
    LIRItem right(x-&gt;y(), this);
    left.load_item();
<span class="udiff-line-modified-removed">-   if (can_inline_as_constant(right.value())) {</span>
<span class="udiff-line-modified-added">+   if (can_inline_as_constant(right.value()) &amp;&amp; !x-&gt;substitutability_check()) {</span>
      right.dont_load_item();
    } else {
<span class="udiff-line-added">+     // substitutability_check() needs to use right as a base register.</span>
      right.load_item();
    }
  
    LIRItem t_val(x-&gt;tval(), this);
    LIRItem f_val(x-&gt;fval(), this);
    t_val.dont_load_item();
    f_val.dont_load_item();
<span class="udiff-line-modified-removed">-   LIR_Opr reg = rlock_result(x);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   __ cmp(lir_cond(x-&gt;cond()), left.result(), right.result());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (x-&gt;substitutability_check()) {</span>
<span class="udiff-line-modified-added">+     substitutability_check(x, left, right, t_val, f_val);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     LIR_Opr reg = rlock_result(x);</span>
<span class="udiff-line-added">+     __ cmp(lir_cond(x-&gt;cond()), left.result(), right.result());</span>
<span class="udiff-line-added">+     __ cmove(lir_cond(x-&gt;cond()), t_val.result(), f_val.result(), reg, as_BasicType(x-&gt;x()-&gt;type()));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIRGenerator::substitutability_check(IfOp* x, LIRItem&amp; left, LIRItem&amp; right, LIRItem&amp; t_val, LIRItem&amp; f_val) {</span>
<span class="udiff-line-added">+   assert(x-&gt;cond() == If::eql || x-&gt;cond() == If::neq, &quot;must be&quot;);</span>
<span class="udiff-line-added">+   bool is_acmpeq = (x-&gt;cond() == If::eql);</span>
<span class="udiff-line-added">+   LIR_Opr equal_result     = is_acmpeq ? t_val.result() : f_val.result();</span>
<span class="udiff-line-added">+   LIR_Opr not_equal_result = is_acmpeq ? f_val.result() : t_val.result();</span>
<span class="udiff-line-added">+   LIR_Opr result = rlock_result(x);</span>
<span class="udiff-line-added">+   CodeEmitInfo* info = state_for(x, x-&gt;state_before());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   substitutability_check_common(x-&gt;x(), x-&gt;y(), left, right, equal_result, not_equal_result, result, info);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIRGenerator::substitutability_check(If* x, LIRItem&amp; left, LIRItem&amp; right) {</span>
<span class="udiff-line-added">+   LIR_Opr equal_result     = LIR_OprFact::intConst(1);</span>
<span class="udiff-line-added">+   LIR_Opr not_equal_result = LIR_OprFact::intConst(0);</span>
<span class="udiff-line-added">+   LIR_Opr result = new_register(T_INT);</span>
<span class="udiff-line-added">+   CodeEmitInfo* info = state_for(x, x-&gt;state_before());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   substitutability_check_common(x-&gt;x(), x-&gt;y(), left, right, equal_result, not_equal_result, result, info);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(x-&gt;cond() == If::eql || x-&gt;cond() == If::neq, &quot;must be&quot;);</span>
<span class="udiff-line-added">+   __ cmp(lir_cond(x-&gt;cond()), result, equal_result);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIRGenerator::substitutability_check_common(Value left_val, Value right_val, LIRItem&amp; left, LIRItem&amp; right,</span>
<span class="udiff-line-added">+                                                  LIR_Opr equal_result, LIR_Opr not_equal_result, LIR_Opr result,</span>
<span class="udiff-line-added">+                                                  CodeEmitInfo* info) {</span>
<span class="udiff-line-added">+   LIR_Opr tmp1 = LIR_OprFact::illegalOpr;</span>
<span class="udiff-line-added">+   LIR_Opr tmp2 = LIR_OprFact::illegalOpr;</span>
<span class="udiff-line-added">+   LIR_Opr left_klass_op = LIR_OprFact::illegalOpr;</span>
<span class="udiff-line-added">+   LIR_Opr right_klass_op = LIR_OprFact::illegalOpr;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ciKlass* left_klass  = left_val -&gt;as_loaded_klass_or_null();</span>
<span class="udiff-line-added">+   ciKlass* right_klass = right_val-&gt;as_loaded_klass_or_null();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if ((left_klass == NULL || right_klass == NULL) ||// The klass is still unloaded, or came from a Phi node.</span>
<span class="udiff-line-added">+       !left_klass-&gt;is_valuetype() || !right_klass-&gt;is_valuetype()) {</span>
<span class="udiff-line-added">+     init_temps_for_substitutability_check(tmp1, tmp2);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (left_klass != NULL &amp;&amp; left_klass-&gt;is_valuetype() &amp;&amp; left_klass == right_klass) {</span>
<span class="udiff-line-added">+     // No need to load klass -- the operands are statically known to be the same value klass.</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     BasicType t_klass = UseCompressedOops ? T_INT : T_METADATA;</span>
<span class="udiff-line-added">+     left_klass_op = new_register(t_klass);</span>
<span class="udiff-line-added">+     right_klass_op = new_register(t_klass);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   CodeStub* slow_path = new SubstitutabilityCheckStub(left.result(), right.result(), info);</span>
<span class="udiff-line-added">+   __ substitutability_check(result, left.result(), right.result(), equal_result, not_equal_result,</span>
<span class="udiff-line-added">+                             tmp1, tmp2,</span>
                              left_klass, right_klass, left_klass_op, right_klass_op, info, slow_path);
  }
  
  #ifdef JFR_HAVE_INTRINSICS
  void LIRGenerator::do_ClassIDIntrinsic(Intrinsic* x) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3250,11 +3726,11 @@</span>
    ciMethodData* md = x-&gt;method()-&gt;method_data_or_null();
    assert(md != NULL, &quot;Sanity&quot;);
    ciProfileData* data = md-&gt;bci_to_data(bci);
    if (data != NULL) {
      assert(data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData(), &quot;wrong profile data type&quot;);
<span class="udiff-line-modified-removed">-     ciReturnTypeEntry* ret = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;ret() : ((ciVirtualCallTypeData*)data)-&gt;ret();</span>
<span class="udiff-line-modified-added">+     ciSingleTypeEntry* ret = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;ret() : ((ciVirtualCallTypeData*)data)-&gt;ret();</span>
      LIR_Opr mdp = LIR_OprFact::illegalOpr;
  
      bool ignored_will_link;
      ciSignature* signature_at_call = NULL;
      x-&gt;method()-&gt;get_method_at_bci(bci, ignored_will_link, &amp;signature_at_call);
</pre>
<center><a href="c1_LIR.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/ciField.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
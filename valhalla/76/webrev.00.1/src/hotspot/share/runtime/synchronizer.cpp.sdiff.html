<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 143   // this list until after a handshake or a safepoint for platforms
 144   // that don&#39;t support handshakes. After the handshake or safepoint,
 145   // the deflated ObjectMonitors are prepended to free_list.
 146   ObjectMonitor* _wait_list;
 147   DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
 148 
 149   int _free_count;    // # on free_list
 150   DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));
 151 
 152   int _in_use_count;  // # on in_use_list
 153   DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));
 154 
 155   int _population;    // # Extant -- in circulation
 156   DEFINE_PAD_MINUS_SIZE(6, OM_CACHE_LINE_SIZE, sizeof(int));
 157 
 158   int _wait_count;    // # on wait_list
 159   DEFINE_PAD_MINUS_SIZE(7, OM_CACHE_LINE_SIZE, sizeof(int));
 160 };
 161 static ObjectMonitorListGlobals om_list_globals;
 162 













 163 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 164 
 165 
 166 // =====================&gt; Spin-lock functions
 167 
 168 // ObjectMonitors are not lockable outside of this file. We use spin-locks
 169 // implemented using a bit in the _next_om field instead of the heavier
 170 // weight locking mechanisms for faster list management.
 171 
 172 #define OM_LOCK_BIT 0x1
 173 
 174 // Return true if the ObjectMonitor is locked.
 175 // Otherwise returns false.
 176 static bool is_locked(ObjectMonitor* om) {
 177   return ((intptr_t)om-&gt;next_om() &amp; OM_LOCK_BIT) == OM_LOCK_BIT;
 178 }
 179 
 180 // Mark an ObjectMonitor* with OM_LOCK_BIT and return it.
 181 static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {
 182   return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);
</pre>
<hr />
<pre>
 420 // returns true  -- to indicate the call was satisfied.
 421 // returns false -- to indicate the call needs the services of the slow-path.
 422 // A no-loitering ordinance is in effect for code in the quick_* family
 423 // operators: safepoints or indefinite blocking (blocking that might span a
 424 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 425 // entry.
 426 //
 427 // Consider: An interesting optimization is to have the JIT recognize the
 428 // following common idiom:
 429 //   synchronized (someobj) { .... ; notify(); }
 430 // That is, we find a notify() or notifyAll() call that immediately precedes
 431 // the monitorexit operation.  In that case the JIT could fuse the operations
 432 // into a single notifyAndExit() runtime primitive.
 433 
 434 bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {
 435   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 436   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 437   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 438   NoSafepointVerifier nsv;
 439   if (obj == NULL) return false;  // slow-path for invalid obj

 440   const markWord mark = obj-&gt;mark();
 441 
 442   if (mark.has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark.locker())) {
 443     // Degenerate notify
 444     // stack-locked by caller so by definition the implied waitset is empty.
 445     return true;
 446   }
 447 
 448   if (mark.has_monitor()) {
 449     ObjectMonitor* const mon = mark.monitor();
 450     assert(mon-&gt;object() == obj, &quot;invariant&quot;);
 451     if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
 452 
 453     if (mon-&gt;first_waiter() != NULL) {
 454       // We have one or more waiters. Since this is an inflated monitor
 455       // that we own, we can transfer one or more threads from the waitset
 456       // to the entrylist here and now, avoiding the slow-path.
 457       if (all) {
 458         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
 459       } else {
</pre>
<hr />
<pre>
 470   }
 471 
 472   // biased locking and any other IMS exception states take the slow-path
 473   return false;
 474 }
 475 
 476 
 477 // The LockNode emitted directly at the synchronization site would have
 478 // been too big if it were to have included support for the cases of inflated
 479 // recursive enter and exit, so they go here instead.
 480 // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
 481 // quick_enter() as our thread state remains _in_Java.
 482 
 483 bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,
 484                                      BasicLock * lock) {
 485   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 486   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 487   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 488   NoSafepointVerifier nsv;
 489   if (obj == NULL) return false;       // Need to throw NPE
<span class="line-modified"> 490 </span>
 491   const markWord mark = obj-&gt;mark();
 492 
 493   if (mark.has_monitor()) {
 494     ObjectMonitor* const m = mark.monitor();
 495     if (AsyncDeflateIdleMonitors) {
 496       // An async deflation can race us before we manage to make the
 497       // ObjectMonitor busy by setting the owner below. If we detect
 498       // that race we just bail out to the slow-path here.
 499       if (m-&gt;object() == NULL) {
 500         return false;
 501       }
 502     } else {
 503       assert(m-&gt;object() == obj, &quot;invariant&quot;);
 504     }
 505     Thread* const owner = (Thread *) m-&gt;_owner;
 506 
 507     // Lock contention and Transactional Lock Elision (TLE) diagnostics
 508     // and observability
 509     // Case: light contention possibly amenable to TLE
 510     // Case: TLE inimical operations such as nested/recursive synchronization
</pre>
<hr />
<pre>
 532     }
 533   }
 534 
 535   // Note that we could inflate in quick_enter.
 536   // This is likely a useful optimization
 537   // Critically, in quick_enter() we must not:
 538   // -- perform bias revocation, or
 539   // -- block indefinitely, or
 540   // -- reach a safepoint
 541 
 542   return false;        // revert to slow-path
 543 }
 544 
 545 // -----------------------------------------------------------------------------
 546 // Monitor Enter/Exit
 547 // The interpreter and compiler assembly code tries to lock using the fast path
 548 // of this algorithm. Make sure to update that code if the following function is
 549 // changed. The implementation is extremely sensitive to race condition. Be careful.
 550 
 551 void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {

 552   if (UseBiasedLocking) {
 553     if (!SafepointSynchronize::is_at_safepoint()) {
 554       BiasedLocking::revoke(obj, THREAD);
 555     } else {
 556       BiasedLocking::revoke_at_safepoint(obj);
 557     }
 558   }
 559 
 560   markWord mark = obj-&gt;mark();
 561   assert(!mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 562 
 563   if (mark.is_neutral()) {
 564     // Anticipate successful CAS -- the ST of the displaced mark must
 565     // be visible &lt;= the ST performed by the CAS.
 566     lock-&gt;set_displaced_header(mark);
 567     if (mark == obj()-&gt;cas_set_mark(markWord::from_pointer(lock), mark)) {
 568       return;
 569     }
 570     // Fall through to inflate() ...
 571   } else if (mark.has_locker() &amp;&amp;
</pre>
<hr />
<pre>
 577   }
 578 
 579   // The object header will never be displaced to this lock,
 580   // so it does not matter what the value is, except that it
 581   // must be non-zero to avoid looking like a re-entrant lock,
 582   // and must not look locked either.
 583   lock-&gt;set_displaced_header(markWord::unused_mark());
 584   // An async deflation can race after the inflate() call and before
 585   // enter() can make the ObjectMonitor busy. enter() returns false if
 586   // we have lost the race to async deflation and we simply try again.
 587   while (true) {
 588     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_monitor_enter);
 589     if (monitor-&gt;enter(THREAD)) {
 590       return;
 591     }
 592   }
 593 }
 594 
 595 void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {
 596   markWord mark = object-&gt;mark();




 597   // We cannot check for Biased Locking if we are racing an inflation.
 598   assert(mark == markWord::INFLATING() ||
 599          !mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 600 
 601   markWord dhw = lock-&gt;displaced_header();
 602   if (dhw.value() == 0) {
 603     // If the displaced header is NULL, then this exit matches up with
 604     // a recursive enter. No real work to do here except for diagnostics.
 605 #ifndef PRODUCT
 606     if (mark != markWord::INFLATING()) {
 607       // Only do diagnostics if we are not racing an inflation. Simply
 608       // exiting a recursive enter of a Java Monitor that is being
 609       // inflated is safe; see the has_monitor() comment below.
 610       assert(!mark.is_neutral(), &quot;invariant&quot;);
 611       assert(!mark.has_locker() ||
 612              THREAD-&gt;is_lock_owned((address)mark.locker()), &quot;invariant&quot;);
 613       if (mark.has_monitor()) {
 614         // The BasicLock&#39;s displaced_header is marked as a recursive
 615         // enter and we have an inflated Java Monitor (ObjectMonitor).
 616         // This is a special case where the Java Monitor was inflated
</pre>
<hr />
<pre>
 640   // We have to take the slow-path of possible inflation and then exit.
 641   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 642   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 643   ObjectMonitor* monitor = inflate(THREAD, object, inflate_cause_vm_internal);
 644   monitor-&gt;exit(true, THREAD);
 645 }
 646 
 647 // -----------------------------------------------------------------------------
 648 // Class Loader  support to workaround deadlocks on the class loader lock objects
 649 // Also used by GC
 650 // complete_exit()/reenter() are used to wait on a nested lock
 651 // i.e. to give up an outer lock completely and then re-enter
 652 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 653 //  1) complete_exit lock1 - saving recursion count
 654 //  2) wait on lock2
 655 //  3) when notified on lock2, unlock lock2
 656 //  4) reenter lock1 with original recursion count
 657 //  5) lock lock2
 658 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 659 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {

 660   if (UseBiasedLocking) {
 661     BiasedLocking::revoke(obj, THREAD);
 662     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 663   }
 664 
 665   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 666   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 667   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 668   intptr_t ret_code = monitor-&gt;complete_exit(THREAD);
 669   return ret_code;
 670 }
 671 
 672 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 673 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {

 674   if (UseBiasedLocking) {
 675     BiasedLocking::revoke(obj, THREAD);
 676     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 677   }
 678 
 679   // An async deflation can race after the inflate() call and before
 680   // reenter() -&gt; enter() can make the ObjectMonitor busy. reenter() -&gt;
 681   // enter() returns false if we have lost the race to async deflation
 682   // and we simply try again.
 683   while (true) {
 684     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 685     if (monitor-&gt;reenter(recursions, THREAD)) {
 686       return;
 687     }
 688   }
 689 }
 690 
 691 // -----------------------------------------------------------------------------
 692 // JNI locks on java objects
 693 // NOTE: must use heavy weight monitor to handle jni monitor enter
 694 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 695   // the current locking is from JNI instead of Java code

 696   if (UseBiasedLocking) {
 697     BiasedLocking::revoke(obj, THREAD);
 698     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 699   }
 700   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 701   // An async deflation can race after the inflate() call and before
 702   // enter() can make the ObjectMonitor busy. enter() returns false if
 703   // we have lost the race to async deflation and we simply try again.
 704   while (true) {
 705     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_jni_enter);
 706     if (monitor-&gt;enter(THREAD)) {
 707       break;
 708     }
 709   }
 710   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
 711 }
 712 
 713 // NOTE: must use heavy weight monitor to handle jni monitor exit
 714 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {

 715   if (UseBiasedLocking) {
 716     Handle h_obj(THREAD, obj);
 717     BiasedLocking::revoke(h_obj, THREAD);
 718     obj = h_obj();
 719   }
 720   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 721 
 722   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 723   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 724   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
 725   // If this thread has locked the object, exit the monitor. We
 726   // intentionally do not use CHECK here because we must exit the
 727   // monitor even if an exception is pending.
 728   if (monitor-&gt;check_owner(THREAD)) {
 729     monitor-&gt;exit(true, THREAD);
 730   }
 731 }
 732 
 733 // -----------------------------------------------------------------------------
 734 // Internal VM locks on java objects
</pre>
<hr />
<pre>
 738   _thread = thread;
 739   _thread-&gt;check_for_valid_safepoint_state();
 740   _obj = obj;
 741 
 742   if (_dolock) {
 743     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);
 744   }
 745 }
 746 
 747 ObjectLocker::~ObjectLocker() {
 748   if (_dolock) {
 749     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);
 750   }
 751 }
 752 
 753 
 754 // -----------------------------------------------------------------------------
 755 //  Wait/Notify/NotifyAll
 756 // NOTE: must use heavy weight monitor to handle wait()
 757 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {

 758   if (UseBiasedLocking) {
 759     BiasedLocking::revoke(obj, THREAD);
 760     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 761   }
 762   if (millis &lt; 0) {
 763     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 764   }
 765   // The ObjectMonitor* can&#39;t be async deflated because the _waiters
 766   // field is incremented before ownership is dropped and decremented
 767   // after ownership is regained.
 768   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 769 
 770   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
 771   monitor-&gt;wait(millis, true, THREAD);
 772 
 773   // This dummy call is in place to get around dtrace bug 6254741.  Once
 774   // that&#39;s fixed we can uncomment the following line, remove the call
 775   // and change this function back into a &quot;void&quot; func.
 776   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 777   int ret_code = dtrace_waited_probe(monitor, obj, THREAD);
 778   return ret_code;
 779 }
 780 
 781 void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {

 782   if (UseBiasedLocking) {
 783     BiasedLocking::revoke(obj, THREAD);
 784     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 785   }
 786   if (millis &lt; 0) {
 787     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 788   }
 789   // The ObjectMonitor* can&#39;t be async deflated because the _waiters
 790   // field is incremented before ownership is dropped and decremented
 791   // after ownership is regained.
 792   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 793   monitor-&gt;wait(millis, false, THREAD);
 794 }
 795 
 796 void ObjectSynchronizer::notify(Handle obj, TRAPS) {

 797   if (UseBiasedLocking) {
 798     BiasedLocking::revoke(obj, THREAD);
 799     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 800   }
 801 
 802   markWord mark = obj-&gt;mark();
 803   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 804     return;
 805   }
 806   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 807   // dropped by the calling thread.
 808   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);
 809   monitor-&gt;notify(THREAD);
 810 }
 811 
 812 // NOTE: see comment of notify()
 813 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {

 814   if (UseBiasedLocking) {
 815     BiasedLocking::revoke(obj, THREAD);
 816     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 817   }
 818 
 819   markWord mark = obj-&gt;mark();
 820   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 821     return;
 822   }
 823   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 824   // dropped by the calling thread.
 825   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);
 826   monitor-&gt;notifyAll(THREAD);
 827 }
 828 
 829 // -----------------------------------------------------------------------------
 830 // Hash Code handling
 831 //
 832 // Performance concern:
 833 // OrderAccess::storestore() calls release() which at one time stored 0
</pre>
<hr />
<pre>
 968     // This is probably the best overall implementation -- we&#39;ll
 969     // likely make this the default in future releases.
 970     unsigned t = self-&gt;_hashStateX;
 971     t ^= (t &lt;&lt; 11);
 972     self-&gt;_hashStateX = self-&gt;_hashStateY;
 973     self-&gt;_hashStateY = self-&gt;_hashStateZ;
 974     self-&gt;_hashStateZ = self-&gt;_hashStateW;
 975     unsigned v = self-&gt;_hashStateW;
 976     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
 977     self-&gt;_hashStateW = v;
 978     value = v;
 979   }
 980 
 981   value &amp;= markWord::hash_mask;
 982   if (value == 0) value = 0xBAD;
 983   assert(value != markWord::no_hash, &quot;invariant&quot;);
 984   return value;
 985 }
 986 
 987 intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {








 988   if (UseBiasedLocking) {
 989     // NOTE: many places throughout the JVM do not expect a safepoint
 990     // to be taken here, in particular most operations on perm gen
 991     // objects. However, we only ever bias Java instances and all of
 992     // the call sites of identity_hash that might revoke biases have
 993     // been checked to make sure they can handle a safepoint. The
 994     // added check of the bias pattern is to avoid useless calls to
 995     // thread-local storage.
 996     if (obj-&gt;mark().has_bias_pattern()) {
 997       // Handle for oop obj in case of STW safepoint
 998       Handle hobj(self, obj);
 999       // Relaxing assertion for bug 6320749.
1000       assert(Universe::verify_in_progress() ||
1001              !SafepointSynchronize::is_at_safepoint(),
1002              &quot;biases should not be seen by VM thread here&quot;);
1003       BiasedLocking::revoke(hobj, JavaThread::current());
1004       obj = hobj();
1005       assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1006     }
1007   }
</pre>
<hr />
<pre>
1110         // If we add any new usages of the header/dmw field, this code
1111         // will need to be updated.
1112         hash = test.hash();
1113         assert(test.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, test.value());
1114         assert(hash != 0, &quot;should only have lost the race to a thread that set a non-zero hash&quot;);
1115       }
1116       if (monitor-&gt;is_being_async_deflated()) {
1117         // If we detect that async deflation has occurred, then we
1118         // attempt to restore the header/dmw to the object&#39;s header
1119         // so that we only retry once if the deflater thread happens
1120         // to be slow.
1121         monitor-&gt;install_displaced_markword_in_object(obj);
1122         continue;
1123       }
1124     }
1125     // We finally get the hash.
1126     return hash;
1127   }
1128 }
1129 
<span class="line-removed">1130 // Deprecated -- use FastHashCode() instead.</span>
<span class="line-removed">1131 </span>
<span class="line-removed">1132 intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) {</span>
<span class="line-removed">1133   return FastHashCode(Thread::current(), obj());</span>
<span class="line-removed">1134 }</span>
<span class="line-removed">1135 </span>
1136 
1137 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
1138                                                    Handle h_obj) {



1139   if (UseBiasedLocking) {
1140     BiasedLocking::revoke(h_obj, thread);
1141     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1142   }
1143 
1144   assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
1145   oop obj = h_obj();
1146 
1147   markWord mark = read_stable_mark(obj);
1148 
1149   // Uncontended case, header points to stack
1150   if (mark.has_locker()) {
1151     return thread-&gt;is_lock_owned((address)mark.locker());
1152   }
1153   // Contended case, header points to ObjectMonitor (tagged pointer)
1154   if (mark.has_monitor()) {
1155     // The first stage of async deflation does not affect any field
1156     // used by this comparison so the ObjectMonitor* is usable here.
1157     ObjectMonitor* monitor = mark.monitor();
1158     return monitor-&gt;is_entered(thread) != 0;
</pre>
<hr />
<pre>
1761 // Fast path code shared by multiple functions
1762 void ObjectSynchronizer::inflate_helper(oop obj) {
1763   markWord mark = obj-&gt;mark();
1764   if (mark.has_monitor()) {
1765     ObjectMonitor* monitor = mark.monitor();
1766     assert(ObjectSynchronizer::verify_objmon_isinpool(monitor), &quot;monitor=&quot; INTPTR_FORMAT &quot; is invalid&quot;, p2i(monitor));
1767     markWord dmw = monitor-&gt;header();
1768     assert(dmw.is_neutral(), &quot;sanity check: header=&quot; INTPTR_FORMAT, dmw.value());
1769     return;
1770   }
1771   (void)inflate(Thread::current(), obj, inflate_cause_vm_internal);
1772 }
1773 
1774 ObjectMonitor* ObjectSynchronizer::inflate(Thread* self, oop object,
1775                                            const InflateCause cause) {
1776   // Inflate mutates the heap ...
1777   // Relaxing assertion for bug 6320749.
1778   assert(Universe::verify_in_progress() ||
1779          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1780 




1781   EventJavaMonitorInflate event;
1782 
1783   for (;;) {
1784     const markWord mark = object-&gt;mark();
1785     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);
1786 
1787     // The mark can be in one of the following states:
1788     // *  Inflated     - just return
1789     // *  Stack-locked - coerce it to inflated
1790     // *  INFLATING    - busy wait for conversion to complete
1791     // *  Neutral      - aggressively inflate the object.
1792     // *  BIASED       - Illegal.  We should never see this
1793 
1794     // CASE: inflated
1795     if (mark.has_monitor()) {
1796       ObjectMonitor* inf = mark.monitor();
1797       markWord dmw = inf-&gt;header();
1798       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1799       assert(AsyncDeflateIdleMonitors || inf-&gt;object() == object, &quot;invariant&quot;);
1800       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 143   // this list until after a handshake or a safepoint for platforms
 144   // that don&#39;t support handshakes. After the handshake or safepoint,
 145   // the deflated ObjectMonitors are prepended to free_list.
 146   ObjectMonitor* _wait_list;
 147   DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
 148 
 149   int _free_count;    // # on free_list
 150   DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));
 151 
 152   int _in_use_count;  // # on in_use_list
 153   DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));
 154 
 155   int _population;    // # Extant -- in circulation
 156   DEFINE_PAD_MINUS_SIZE(6, OM_CACHE_LINE_SIZE, sizeof(int));
 157 
 158   int _wait_count;    // # on wait_list
 159   DEFINE_PAD_MINUS_SIZE(7, OM_CACHE_LINE_SIZE, sizeof(int));
 160 };
 161 static ObjectMonitorListGlobals om_list_globals;
 162 
<span class="line-added"> 163 #define CHECK_THROW_NOSYNC_IMSE(obj)  \</span>
<span class="line-added"> 164   if ((obj)-&gt;mark().is_always_locked()) {  \</span>
<span class="line-added"> 165     ResourceMark rm(THREAD);                \</span>
<span class="line-added"> 166     THROW_MSG(vmSymbols::java_lang_IllegalMonitorStateException(), obj-&gt;klass()-&gt;external_name()); \</span>
<span class="line-added"> 167   }</span>
<span class="line-added"> 168 </span>
<span class="line-added"> 169 #define CHECK_THROW_NOSYNC_IMSE_0(obj)  \</span>
<span class="line-added"> 170     if ((obj)-&gt;mark().is_always_locked()) {  \</span>
<span class="line-added"> 171     ResourceMark rm(THREAD);                  \</span>
<span class="line-added"> 172     THROW_MSG_0(vmSymbols::java_lang_IllegalMonitorStateException(), obj-&gt;klass()-&gt;external_name()); \</span>
<span class="line-added"> 173   }</span>
<span class="line-added"> 174 </span>
<span class="line-added"> 175 </span>
 176 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 177 
 178 
 179 // =====================&gt; Spin-lock functions
 180 
 181 // ObjectMonitors are not lockable outside of this file. We use spin-locks
 182 // implemented using a bit in the _next_om field instead of the heavier
 183 // weight locking mechanisms for faster list management.
 184 
 185 #define OM_LOCK_BIT 0x1
 186 
 187 // Return true if the ObjectMonitor is locked.
 188 // Otherwise returns false.
 189 static bool is_locked(ObjectMonitor* om) {
 190   return ((intptr_t)om-&gt;next_om() &amp; OM_LOCK_BIT) == OM_LOCK_BIT;
 191 }
 192 
 193 // Mark an ObjectMonitor* with OM_LOCK_BIT and return it.
 194 static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {
 195   return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);
</pre>
<hr />
<pre>
 433 // returns true  -- to indicate the call was satisfied.
 434 // returns false -- to indicate the call needs the services of the slow-path.
 435 // A no-loitering ordinance is in effect for code in the quick_* family
 436 // operators: safepoints or indefinite blocking (blocking that might span a
 437 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 438 // entry.
 439 //
 440 // Consider: An interesting optimization is to have the JIT recognize the
 441 // following common idiom:
 442 //   synchronized (someobj) { .... ; notify(); }
 443 // That is, we find a notify() or notifyAll() call that immediately precedes
 444 // the monitorexit operation.  In that case the JIT could fuse the operations
 445 // into a single notifyAndExit() runtime primitive.
 446 
 447 bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {
 448   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 449   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 450   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 451   NoSafepointVerifier nsv;
 452   if (obj == NULL) return false;  // slow-path for invalid obj
<span class="line-added"> 453   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 454   const markWord mark = obj-&gt;mark();
 455 
 456   if (mark.has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark.locker())) {
 457     // Degenerate notify
 458     // stack-locked by caller so by definition the implied waitset is empty.
 459     return true;
 460   }
 461 
 462   if (mark.has_monitor()) {
 463     ObjectMonitor* const mon = mark.monitor();
 464     assert(mon-&gt;object() == obj, &quot;invariant&quot;);
 465     if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
 466 
 467     if (mon-&gt;first_waiter() != NULL) {
 468       // We have one or more waiters. Since this is an inflated monitor
 469       // that we own, we can transfer one or more threads from the waitset
 470       // to the entrylist here and now, avoiding the slow-path.
 471       if (all) {
 472         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
 473       } else {
</pre>
<hr />
<pre>
 484   }
 485 
 486   // biased locking and any other IMS exception states take the slow-path
 487   return false;
 488 }
 489 
 490 
 491 // The LockNode emitted directly at the synchronization site would have
 492 // been too big if it were to have included support for the cases of inflated
 493 // recursive enter and exit, so they go here instead.
 494 // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
 495 // quick_enter() as our thread state remains _in_Java.
 496 
 497 bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,
 498                                      BasicLock * lock) {
 499   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 500   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 501   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 502   NoSafepointVerifier nsv;
 503   if (obj == NULL) return false;       // Need to throw NPE
<span class="line-modified"> 504   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 505   const markWord mark = obj-&gt;mark();
 506 
 507   if (mark.has_monitor()) {
 508     ObjectMonitor* const m = mark.monitor();
 509     if (AsyncDeflateIdleMonitors) {
 510       // An async deflation can race us before we manage to make the
 511       // ObjectMonitor busy by setting the owner below. If we detect
 512       // that race we just bail out to the slow-path here.
 513       if (m-&gt;object() == NULL) {
 514         return false;
 515       }
 516     } else {
 517       assert(m-&gt;object() == obj, &quot;invariant&quot;);
 518     }
 519     Thread* const owner = (Thread *) m-&gt;_owner;
 520 
 521     // Lock contention and Transactional Lock Elision (TLE) diagnostics
 522     // and observability
 523     // Case: light contention possibly amenable to TLE
 524     // Case: TLE inimical operations such as nested/recursive synchronization
</pre>
<hr />
<pre>
 546     }
 547   }
 548 
 549   // Note that we could inflate in quick_enter.
 550   // This is likely a useful optimization
 551   // Critically, in quick_enter() we must not:
 552   // -- perform bias revocation, or
 553   // -- block indefinitely, or
 554   // -- reach a safepoint
 555 
 556   return false;        // revert to slow-path
 557 }
 558 
 559 // -----------------------------------------------------------------------------
 560 // Monitor Enter/Exit
 561 // The interpreter and compiler assembly code tries to lock using the fast path
 562 // of this algorithm. Make sure to update that code if the following function is
 563 // changed. The implementation is extremely sensitive to race condition. Be careful.
 564 
 565 void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {
<span class="line-added"> 566   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 567   if (UseBiasedLocking) {
 568     if (!SafepointSynchronize::is_at_safepoint()) {
 569       BiasedLocking::revoke(obj, THREAD);
 570     } else {
 571       BiasedLocking::revoke_at_safepoint(obj);
 572     }
 573   }
 574 
 575   markWord mark = obj-&gt;mark();
 576   assert(!mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 577 
 578   if (mark.is_neutral()) {
 579     // Anticipate successful CAS -- the ST of the displaced mark must
 580     // be visible &lt;= the ST performed by the CAS.
 581     lock-&gt;set_displaced_header(mark);
 582     if (mark == obj()-&gt;cas_set_mark(markWord::from_pointer(lock), mark)) {
 583       return;
 584     }
 585     // Fall through to inflate() ...
 586   } else if (mark.has_locker() &amp;&amp;
</pre>
<hr />
<pre>
 592   }
 593 
 594   // The object header will never be displaced to this lock,
 595   // so it does not matter what the value is, except that it
 596   // must be non-zero to avoid looking like a re-entrant lock,
 597   // and must not look locked either.
 598   lock-&gt;set_displaced_header(markWord::unused_mark());
 599   // An async deflation can race after the inflate() call and before
 600   // enter() can make the ObjectMonitor busy. enter() returns false if
 601   // we have lost the race to async deflation and we simply try again.
 602   while (true) {
 603     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_monitor_enter);
 604     if (monitor-&gt;enter(THREAD)) {
 605       return;
 606     }
 607   }
 608 }
 609 
 610 void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {
 611   markWord mark = object-&gt;mark();
<span class="line-added"> 612   if (EnableValhalla &amp;&amp; mark.is_always_locked()) {</span>
<span class="line-added"> 613     return;</span>
<span class="line-added"> 614   }</span>
<span class="line-added"> 615   assert(!EnableValhalla || !object-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 616   // We cannot check for Biased Locking if we are racing an inflation.
 617   assert(mark == markWord::INFLATING() ||
 618          !mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 619 
 620   markWord dhw = lock-&gt;displaced_header();
 621   if (dhw.value() == 0) {
 622     // If the displaced header is NULL, then this exit matches up with
 623     // a recursive enter. No real work to do here except for diagnostics.
 624 #ifndef PRODUCT
 625     if (mark != markWord::INFLATING()) {
 626       // Only do diagnostics if we are not racing an inflation. Simply
 627       // exiting a recursive enter of a Java Monitor that is being
 628       // inflated is safe; see the has_monitor() comment below.
 629       assert(!mark.is_neutral(), &quot;invariant&quot;);
 630       assert(!mark.has_locker() ||
 631              THREAD-&gt;is_lock_owned((address)mark.locker()), &quot;invariant&quot;);
 632       if (mark.has_monitor()) {
 633         // The BasicLock&#39;s displaced_header is marked as a recursive
 634         // enter and we have an inflated Java Monitor (ObjectMonitor).
 635         // This is a special case where the Java Monitor was inflated
</pre>
<hr />
<pre>
 659   // We have to take the slow-path of possible inflation and then exit.
 660   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 661   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 662   ObjectMonitor* monitor = inflate(THREAD, object, inflate_cause_vm_internal);
 663   monitor-&gt;exit(true, THREAD);
 664 }
 665 
 666 // -----------------------------------------------------------------------------
 667 // Class Loader  support to workaround deadlocks on the class loader lock objects
 668 // Also used by GC
 669 // complete_exit()/reenter() are used to wait on a nested lock
 670 // i.e. to give up an outer lock completely and then re-enter
 671 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 672 //  1) complete_exit lock1 - saving recursion count
 673 //  2) wait on lock2
 674 //  3) when notified on lock2, unlock lock2
 675 //  4) reenter lock1 with original recursion count
 676 //  5) lock lock2
 677 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 678 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {
<span class="line-added"> 679   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 680   if (UseBiasedLocking) {
 681     BiasedLocking::revoke(obj, THREAD);
 682     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 683   }
 684 
 685   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 686   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 687   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 688   intptr_t ret_code = monitor-&gt;complete_exit(THREAD);
 689   return ret_code;
 690 }
 691 
 692 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 693 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {
<span class="line-added"> 694   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 695   if (UseBiasedLocking) {
 696     BiasedLocking::revoke(obj, THREAD);
 697     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 698   }
 699 
 700   // An async deflation can race after the inflate() call and before
 701   // reenter() -&gt; enter() can make the ObjectMonitor busy. reenter() -&gt;
 702   // enter() returns false if we have lost the race to async deflation
 703   // and we simply try again.
 704   while (true) {
 705     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 706     if (monitor-&gt;reenter(recursions, THREAD)) {
 707       return;
 708     }
 709   }
 710 }
 711 
 712 // -----------------------------------------------------------------------------
 713 // JNI locks on java objects
 714 // NOTE: must use heavy weight monitor to handle jni monitor enter
 715 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 716   // the current locking is from JNI instead of Java code
<span class="line-added"> 717   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 718   if (UseBiasedLocking) {
 719     BiasedLocking::revoke(obj, THREAD);
 720     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 721   }
 722   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 723   // An async deflation can race after the inflate() call and before
 724   // enter() can make the ObjectMonitor busy. enter() returns false if
 725   // we have lost the race to async deflation and we simply try again.
 726   while (true) {
 727     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_jni_enter);
 728     if (monitor-&gt;enter(THREAD)) {
 729       break;
 730     }
 731   }
 732   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
 733 }
 734 
 735 // NOTE: must use heavy weight monitor to handle jni monitor exit
 736 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
<span class="line-added"> 737   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 738   if (UseBiasedLocking) {
 739     Handle h_obj(THREAD, obj);
 740     BiasedLocking::revoke(h_obj, THREAD);
 741     obj = h_obj();
 742   }
 743   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 744 
 745   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 746   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 747   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
 748   // If this thread has locked the object, exit the monitor. We
 749   // intentionally do not use CHECK here because we must exit the
 750   // monitor even if an exception is pending.
 751   if (monitor-&gt;check_owner(THREAD)) {
 752     monitor-&gt;exit(true, THREAD);
 753   }
 754 }
 755 
 756 // -----------------------------------------------------------------------------
 757 // Internal VM locks on java objects
</pre>
<hr />
<pre>
 761   _thread = thread;
 762   _thread-&gt;check_for_valid_safepoint_state();
 763   _obj = obj;
 764 
 765   if (_dolock) {
 766     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);
 767   }
 768 }
 769 
 770 ObjectLocker::~ObjectLocker() {
 771   if (_dolock) {
 772     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);
 773   }
 774 }
 775 
 776 
 777 // -----------------------------------------------------------------------------
 778 //  Wait/Notify/NotifyAll
 779 // NOTE: must use heavy weight monitor to handle wait()
 780 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
<span class="line-added"> 781   CHECK_THROW_NOSYNC_IMSE_0(obj);</span>
 782   if (UseBiasedLocking) {
 783     BiasedLocking::revoke(obj, THREAD);
 784     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 785   }
 786   if (millis &lt; 0) {
 787     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 788   }
 789   // The ObjectMonitor* can&#39;t be async deflated because the _waiters
 790   // field is incremented before ownership is dropped and decremented
 791   // after ownership is regained.
 792   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 793 
 794   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
 795   monitor-&gt;wait(millis, true, THREAD);
 796 
 797   // This dummy call is in place to get around dtrace bug 6254741.  Once
 798   // that&#39;s fixed we can uncomment the following line, remove the call
 799   // and change this function back into a &quot;void&quot; func.
 800   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 801   int ret_code = dtrace_waited_probe(monitor, obj, THREAD);
 802   return ret_code;
 803 }
 804 
 805 void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {
<span class="line-added"> 806   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 807   if (UseBiasedLocking) {
 808     BiasedLocking::revoke(obj, THREAD);
 809     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 810   }
 811   if (millis &lt; 0) {
 812     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 813   }
 814   // The ObjectMonitor* can&#39;t be async deflated because the _waiters
 815   // field is incremented before ownership is dropped and decremented
 816   // after ownership is regained.
 817   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 818   monitor-&gt;wait(millis, false, THREAD);
 819 }
 820 
 821 void ObjectSynchronizer::notify(Handle obj, TRAPS) {
<span class="line-added"> 822   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 823   if (UseBiasedLocking) {
 824     BiasedLocking::revoke(obj, THREAD);
 825     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 826   }
 827 
 828   markWord mark = obj-&gt;mark();
 829   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 830     return;
 831   }
 832   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 833   // dropped by the calling thread.
 834   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);
 835   monitor-&gt;notify(THREAD);
 836 }
 837 
 838 // NOTE: see comment of notify()
 839 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
<span class="line-added"> 840   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 841   if (UseBiasedLocking) {
 842     BiasedLocking::revoke(obj, THREAD);
 843     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 844   }
 845 
 846   markWord mark = obj-&gt;mark();
 847   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 848     return;
 849   }
 850   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 851   // dropped by the calling thread.
 852   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);
 853   monitor-&gt;notifyAll(THREAD);
 854 }
 855 
 856 // -----------------------------------------------------------------------------
 857 // Hash Code handling
 858 //
 859 // Performance concern:
 860 // OrderAccess::storestore() calls release() which at one time stored 0
</pre>
<hr />
<pre>
 995     // This is probably the best overall implementation -- we&#39;ll
 996     // likely make this the default in future releases.
 997     unsigned t = self-&gt;_hashStateX;
 998     t ^= (t &lt;&lt; 11);
 999     self-&gt;_hashStateX = self-&gt;_hashStateY;
1000     self-&gt;_hashStateY = self-&gt;_hashStateZ;
1001     self-&gt;_hashStateZ = self-&gt;_hashStateW;
1002     unsigned v = self-&gt;_hashStateW;
1003     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
1004     self-&gt;_hashStateW = v;
1005     value = v;
1006   }
1007 
1008   value &amp;= markWord::hash_mask;
1009   if (value == 0) value = 0xBAD;
1010   assert(value != markWord::no_hash, &quot;invariant&quot;);
1011   return value;
1012 }
1013 
1014 intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {
<span class="line-added">1015   if (EnableValhalla &amp;&amp; obj-&gt;klass()-&gt;is_value()) {</span>
<span class="line-added">1016     // Expected tooling to override hashCode for value type, just don&#39;t crash</span>
<span class="line-added">1017     if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="line-added">1018       ResourceMark rm;</span>
<span class="line-added">1019       log_debug(monitorinflation)(&quot;FastHashCode for value type: %s&quot;, obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added">1020     }</span>
<span class="line-added">1021     return obj-&gt;klass()-&gt;java_mirror()-&gt;identity_hash();</span>
<span class="line-added">1022   }</span>
1023   if (UseBiasedLocking) {
1024     // NOTE: many places throughout the JVM do not expect a safepoint
1025     // to be taken here, in particular most operations on perm gen
1026     // objects. However, we only ever bias Java instances and all of
1027     // the call sites of identity_hash that might revoke biases have
1028     // been checked to make sure they can handle a safepoint. The
1029     // added check of the bias pattern is to avoid useless calls to
1030     // thread-local storage.
1031     if (obj-&gt;mark().has_bias_pattern()) {
1032       // Handle for oop obj in case of STW safepoint
1033       Handle hobj(self, obj);
1034       // Relaxing assertion for bug 6320749.
1035       assert(Universe::verify_in_progress() ||
1036              !SafepointSynchronize::is_at_safepoint(),
1037              &quot;biases should not be seen by VM thread here&quot;);
1038       BiasedLocking::revoke(hobj, JavaThread::current());
1039       obj = hobj();
1040       assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1041     }
1042   }
</pre>
<hr />
<pre>
1145         // If we add any new usages of the header/dmw field, this code
1146         // will need to be updated.
1147         hash = test.hash();
1148         assert(test.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, test.value());
1149         assert(hash != 0, &quot;should only have lost the race to a thread that set a non-zero hash&quot;);
1150       }
1151       if (monitor-&gt;is_being_async_deflated()) {
1152         // If we detect that async deflation has occurred, then we
1153         // attempt to restore the header/dmw to the object&#39;s header
1154         // so that we only retry once if the deflater thread happens
1155         // to be slow.
1156         monitor-&gt;install_displaced_markword_in_object(obj);
1157         continue;
1158       }
1159     }
1160     // We finally get the hash.
1161     return hash;
1162   }
1163 }
1164 






1165 
1166 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
1167                                                    Handle h_obj) {
<span class="line-added">1168   if (EnableValhalla &amp;&amp; h_obj-&gt;mark().is_always_locked()) {</span>
<span class="line-added">1169     return false;</span>
<span class="line-added">1170   }</span>
1171   if (UseBiasedLocking) {
1172     BiasedLocking::revoke(h_obj, thread);
1173     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1174   }
1175 
1176   assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
1177   oop obj = h_obj();
1178 
1179   markWord mark = read_stable_mark(obj);
1180 
1181   // Uncontended case, header points to stack
1182   if (mark.has_locker()) {
1183     return thread-&gt;is_lock_owned((address)mark.locker());
1184   }
1185   // Contended case, header points to ObjectMonitor (tagged pointer)
1186   if (mark.has_monitor()) {
1187     // The first stage of async deflation does not affect any field
1188     // used by this comparison so the ObjectMonitor* is usable here.
1189     ObjectMonitor* monitor = mark.monitor();
1190     return monitor-&gt;is_entered(thread) != 0;
</pre>
<hr />
<pre>
1793 // Fast path code shared by multiple functions
1794 void ObjectSynchronizer::inflate_helper(oop obj) {
1795   markWord mark = obj-&gt;mark();
1796   if (mark.has_monitor()) {
1797     ObjectMonitor* monitor = mark.monitor();
1798     assert(ObjectSynchronizer::verify_objmon_isinpool(monitor), &quot;monitor=&quot; INTPTR_FORMAT &quot; is invalid&quot;, p2i(monitor));
1799     markWord dmw = monitor-&gt;header();
1800     assert(dmw.is_neutral(), &quot;sanity check: header=&quot; INTPTR_FORMAT, dmw.value());
1801     return;
1802   }
1803   (void)inflate(Thread::current(), obj, inflate_cause_vm_internal);
1804 }
1805 
1806 ObjectMonitor* ObjectSynchronizer::inflate(Thread* self, oop object,
1807                                            const InflateCause cause) {
1808   // Inflate mutates the heap ...
1809   // Relaxing assertion for bug 6320749.
1810   assert(Universe::verify_in_progress() ||
1811          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1812 
<span class="line-added">1813   if (EnableValhalla) {</span>
<span class="line-added">1814     guarantee(!object-&gt;klass()-&gt;is_value(), &quot;Attempt to inflate value type&quot;);</span>
<span class="line-added">1815   }</span>
<span class="line-added">1816 </span>
1817   EventJavaMonitorInflate event;
1818 
1819   for (;;) {
1820     const markWord mark = object-&gt;mark();
1821     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);
1822 
1823     // The mark can be in one of the following states:
1824     // *  Inflated     - just return
1825     // *  Stack-locked - coerce it to inflated
1826     // *  INFLATING    - busy wait for conversion to complete
1827     // *  Neutral      - aggressively inflate the object.
1828     // *  BIASED       - Illegal.  We should never see this
1829 
1830     // CASE: inflated
1831     if (mark.has_monitor()) {
1832       ObjectMonitor* inf = mark.monitor();
1833       markWord dmw = inf-&gt;header();
1834       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1835       assert(AsyncDeflateIdleMonitors || inf-&gt;object() == object, &quot;invariant&quot;);
1836       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/nmethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/nmethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 616     _consts_offset           = data_offset();
 617     _stub_offset             = data_offset();
 618     _oops_offset             = data_offset();
 619     _metadata_offset         = _oops_offset         + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 620     scopes_data_offset       = _metadata_offset     + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 621     _scopes_pcs_offset       = scopes_data_offset;
 622     _dependencies_offset     = _scopes_pcs_offset;
 623     _handler_table_offset    = _dependencies_offset;
 624     _nul_chk_table_offset    = _handler_table_offset;
 625 #if INCLUDE_JVMCI
 626     _speculations_offset     = _nul_chk_table_offset;
 627     _jvmci_data_offset       = _speculations_offset;
 628     _nmethod_end_offset      = _jvmci_data_offset;
 629 #else
 630     _nmethod_end_offset      = _nul_chk_table_offset;
 631 #endif
 632     _compile_id              = compile_id;
 633     _comp_level              = CompLevel_none;
 634     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 635     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);






 636     _osr_entry_point         = NULL;
 637     _exception_cache         = NULL;
 638     _pc_desc_container.reset_to(NULL);
 639     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 640 
 641     _scopes_data_begin = (address) this + scopes_data_offset;
 642     _deopt_handler_begin = (address) this + deoptimize_offset;
 643     _deopt_mh_handler_begin = (address) this + deoptimize_mh_offset;
 644 
 645     code_buffer-&gt;copy_code_and_locs_to(this);
 646     code_buffer-&gt;copy_values_to(this);
 647 
 648     clear_unloading_state();
 649 
 650     Universe::heap()-&gt;register_nmethod(this);
 651     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 652 
 653     CodeCache::commit(this);
 654   }
 655 
</pre>
<hr />
<pre>
 787       _unwind_handler_offset = -1;
 788     }
 789 
 790     _oops_offset             = data_offset();
 791     _metadata_offset         = _oops_offset          + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 792     int scopes_data_offset   = _metadata_offset      + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 793 
 794     _scopes_pcs_offset       = scopes_data_offset    + align_up(debug_info-&gt;data_size       (), oopSize);
 795     _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info-&gt;pcs_size());
 796     _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies-&gt;size_in_bytes (), oopSize);
 797     _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table-&gt;size_in_bytes(), oopSize);
 798 #if INCLUDE_JVMCI
 799     _speculations_offset     = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 800     _jvmci_data_offset       = _speculations_offset  + align_up(speculations_len, oopSize);
 801     _nmethod_end_offset      = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize);
 802 #else
 803     _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 804 #endif
 805     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 806     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);



 807     _osr_entry_point         = code_begin()          + offsets-&gt;value(CodeOffsets::OSR_Entry);
 808     _exception_cache         = NULL;
 809     _scopes_data_begin       = (address) this + scopes_data_offset;
 810 
 811     _pc_desc_container.reset_to(scopes_pcs_begin());
 812 
 813     code_buffer-&gt;copy_code_and_locs_to(this);
 814     // Copy contents of ScopeDescRecorder to nmethod
 815     code_buffer-&gt;copy_values_to(this);
 816     debug_info-&gt;copy_to(this);
 817     dependencies-&gt;copy_to(this);
 818     clear_unloading_state();
 819 
 820     Universe::heap()-&gt;register_nmethod(this);
 821     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 822 
 823     CodeCache::commit(this);
 824 
 825     // Copy contents of ExceptionHandlerTable to nmethod
 826     handler_table-&gt;copy_to(this);
</pre>
<hr />
<pre>
 903 // Print out more verbose output usually for a newly created nmethod.
 904 void nmethod::print_on(outputStream* st, const char* msg) const {
 905   if (st != NULL) {
 906     ttyLocker ttyl;
 907     if (WizardMode) {
 908       CompileTask::print(st, this, msg, /*short_form:*/ true);
 909       st-&gt;print_cr(&quot; (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
 910     } else {
 911       CompileTask::print(st, this, msg, /*short_form:*/ false);
 912     }
 913   }
 914 }
 915 
 916 void nmethod::maybe_print_nmethod(DirectiveSet* directive) {
 917   bool printnmethods = directive-&gt;PrintAssemblyOption || directive-&gt;PrintNMethodsOption;
 918   if (printnmethods || PrintDebugInfo || PrintRelocations || PrintDependencies || PrintExceptionHandlers) {
 919     print_nmethod(printnmethods);
 920   }
 921 }
 922 



 923 void nmethod::print_nmethod(bool printmethod) {






 924   ttyLocker ttyl;  // keep the following output all in one block



 925   if (xtty != NULL) {
 926     xtty-&gt;begin_head(&quot;print_nmethod&quot;);
 927     log_identity(xtty);
 928     xtty-&gt;stamp();
 929     xtty-&gt;end_head();
 930   }
 931   // Print the header part, then print the requested information.
 932   // This is both handled in decode2().
 933   if (printmethod) {
 934     HandleMark hm;
 935     ResourceMark m;
 936     if (is_compiled_by_c1()) {
 937       tty-&gt;cr();
 938       tty-&gt;print_cr(&quot;============================= C1-compiled nmethod ==============================&quot;);
 939     }
 940     if (is_compiled_by_jvmci()) {
 941       tty-&gt;cr();
 942       tty-&gt;print_cr(&quot;=========================== JVMCI-compiled nmethod =============================&quot;);
 943     }
 944     tty-&gt;print_cr(&quot;----------------------------------- Assembly -----------------------------------&quot;);
</pre>
<hr />
<pre>
 981     }
 982     if (printmethod || PrintExceptionHandlers) {
 983       print_handler_table();
 984       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 985       print_nul_chk_table();
 986       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 987     }
 988 
 989     if (printmethod) {
 990       print_recorded_oops();
 991       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 992       print_recorded_metadata();
 993       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 994     }
 995   }
 996 #endif
 997 
 998   if (xtty != NULL) {
 999     xtty-&gt;tail(&quot;print_nmethod&quot;);
1000   }



1001 }
1002 
1003 
1004 // Promote one word from an assembly-time handle to a live embedded oop.
1005 inline void nmethod::initialize_immediate_oop(oop* dest, jobject handle) {
1006   if (handle == NULL ||
1007       // As a special case, IC oops are initialized to 1 or -1.
1008       handle == (jobject) Universe::non_oop_word()) {
1009     (*dest) = (oop) handle;
1010   } else {
1011     (*dest) = JNIHandles::resolve_non_null(handle);
1012   }
1013 }
1014 
1015 
1016 // Have to have the same name because it&#39;s called by a template
1017 void nmethod::copy_values(GrowableArray&lt;jobject&gt;* array) {
1018   int length = array-&gt;length();
1019   assert((address)(oops_begin() + length) &lt;= (address)oops_end(), &quot;oops big enough&quot;);
1020   oop* dest = oops_begin();
</pre>
<hr />
<pre>
2400   VerifyMetadataClosure vmc;
2401   metadata_do(&amp;vmc);
2402 }
2403 
2404 
2405 void nmethod::verify_interrupt_point(address call_site) {
2406   // Verify IC only when nmethod installation is finished.
2407   if (!is_not_installed()) {
2408     if (CompiledICLocker::is_safe(this)) {
2409       CompiledIC_at(this, call_site);
2410     } else {
2411       CompiledICLocker ml_verify(this);
2412       CompiledIC_at(this, call_site);
2413     }
2414   }
2415 
2416   PcDesc* pd = pc_desc_at(nativeCall_at(call_site)-&gt;return_address());
2417   assert(pd != NULL, &quot;PcDesc must exist&quot;);
2418   for (ScopeDesc* sd = new ScopeDesc(this, pd-&gt;scope_decode_offset(),
2419                                      pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
<span class="line-modified">2420                                      pd-&gt;return_oop());</span>
2421        !sd-&gt;is_top(); sd = sd-&gt;sender()) {
2422     sd-&gt;verify();
2423   }
2424 }
2425 
2426 void nmethod::verify_scopes() {
2427   if( !method() ) return;       // Runtime stubs have no scope
2428   if (method()-&gt;is_native()) return; // Ignore stub methods.
2429   // iterate through all interrupt point
2430   // and verify the debug information is valid.
2431   RelocIterator iter((nmethod*)this);
2432   while (iter.next()) {
2433     address stub = NULL;
2434     switch (iter.type()) {
2435       case relocInfo::virtual_call_type:
2436         verify_interrupt_point(iter.addr());
2437         break;
2438       case relocInfo::opt_virtual_call_type:
2439         stub = iter.opt_virtual_call_reloc()-&gt;static_stub(false);
2440         verify_interrupt_point(iter.addr());
</pre>
<hr />
<pre>
3040         case relocInfo::internal_word_type:    return &quot;internal_word&quot;;
3041         case relocInfo::section_word_type:     return &quot;section_word&quot;;
3042         case relocInfo::poll_type:             return &quot;poll&quot;;
3043         case relocInfo::poll_return_type:      return &quot;poll_return&quot;;
3044         case relocInfo::trampoline_stub_type:  return &quot;trampoline_stub&quot;;
3045         case relocInfo::type_mask:             return &quot;type_bit_mask&quot;;
3046 
3047         default:
3048           break;
3049     }
3050   }
3051   return have_one ? &quot;other&quot; : NULL;
3052 }
3053 
3054 // Return a the last scope in (begin..end]
3055 ScopeDesc* nmethod::scope_desc_in(address begin, address end) {
3056   PcDesc* p = pc_desc_near(begin+1);
3057   if (p != NULL &amp;&amp; p-&gt;real_pc(this) &lt;= end) {
3058     return new ScopeDesc(this, p-&gt;scope_decode_offset(),
3059                          p-&gt;obj_decode_offset(), p-&gt;should_reexecute(), p-&gt;rethrow_exception(),
<span class="line-modified">3060                          p-&gt;return_oop());</span>
3061   }
3062   return NULL;
3063 }
3064 
3065 const char* nmethod::nmethod_section_label(address pos) const {
3066   const char* label = NULL;
3067   if (pos == code_begin())                                              label = &quot;[Instructions begin]&quot;;
3068   if (pos == entry_point())                                             label = &quot;[Entry Point]&quot;;

3069   if (pos == verified_entry_point())                                    label = &quot;[Verified Entry Point]&quot;;


3070   if (has_method_handle_invokes() &amp;&amp; (pos == deopt_mh_handler_begin())) label = &quot;[Deopt MH Handler Code]&quot;;
3071   if (pos == consts_begin() &amp;&amp; pos != insts_begin())                    label = &quot;[Constants]&quot;;
3072   // Check stub_code before checking exception_handler or deopt_handler.
3073   if (pos == this-&gt;stub_begin())                                        label = &quot;[Stub Code]&quot;;
3074   if (JVMCI_ONLY(_exception_offset &gt;= 0 &amp;&amp;) pos == exception_begin())           label = &quot;[Exception Handler]&quot;;
3075   if (JVMCI_ONLY(_deopt_handler_begin != NULL &amp;&amp;) pos == deopt_handler_begin()) label = &quot;[Deopt Handler Code]&quot;;
3076   return label;
3077 }
3078 










3079 void nmethod::print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels) const {
3080   if (print_section_labels) {
<span class="line-modified">3081     const char* label = nmethod_section_label(block_begin);</span>
<span class="line-modified">3082     if (label != NULL) {</span>
<span class="line-modified">3083       stream-&gt;bol();</span>
<span class="line-modified">3084       stream-&gt;print_cr(&quot;%s&quot;, label);</span>









3085     }
3086   }
3087 
<span class="line-modified">3088   if (block_begin == entry_point()) {</span>
<span class="line-modified">3089     Method* m = method();</span>
<span class="line-modified">3090     if (m != NULL) {</span>
<span class="line-modified">3091       stream-&gt;print(&quot;  # &quot;);</span>
<span class="line-modified">3092       m-&gt;print_value_on(stream);</span>
<span class="line-modified">3093       stream-&gt;cr();</span>




























3094     }
<span class="line-modified">3095     if (m != NULL &amp;&amp; !is_osr_method()) {</span>
<span class="line-modified">3096       ResourceMark rm;</span>
<span class="line-modified">3097       int sizeargs = m-&gt;size_of_parameters();</span>
<span class="line-modified">3098       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);</span>
<span class="line-modified">3099       VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);</span>
<span class="line-modified">3100       {</span>
<span class="line-modified">3101         int sig_index = 0;</span>
<span class="line-modified">3102         if (!m-&gt;is_static())</span>
<span class="line-modified">3103           sig_bt[sig_index++] = T_OBJECT; // &#39;this&#39;</span>
<span class="line-modified">3104         for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-modified">3105           BasicType t = ss.type();</span>
<span class="line-modified">3106           sig_bt[sig_index++] = t;</span>
<span class="line-modified">3107           if (type2size[t] == 2) {</span>
<span class="line-modified">3108             sig_bt[sig_index++] = T_VOID;</span>
<span class="line-modified">3109           } else {</span>
<span class="line-modified">3110             assert(type2size[t] == 1, &quot;size is 1 or 2&quot;);</span>
<span class="line-modified">3111           }</span>



























3112         }
<span class="line-modified">3113         assert(sig_index == sizeargs, &quot;&quot;);</span>





3114       }
<span class="line-modified">3115       const char* spname = &quot;sp&quot;; // make arch-specific?</span>
<span class="line-modified">3116       intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs, false);</span>
<span class="line-modified">3117       int stack_slot_offset = this-&gt;frame_size() * wordSize;</span>
<span class="line-modified">3118       int tab1 = 14, tab2 = 24;</span>
<span class="line-modified">3119       int sig_index = 0;</span>
<span class="line-modified">3120       int arg_index = (m-&gt;is_static() ? 0 : -1);</span>
<span class="line-modified">3121       bool did_old_sp = false;</span>
<span class="line-modified">3122       for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ) {</span>
<span class="line-modified">3123         bool at_this = (arg_index == -1);</span>
<span class="line-modified">3124         bool at_old_sp = false;</span>
<span class="line-modified">3125         BasicType t = (at_this ? T_OBJECT : ss.type());</span>
<span class="line-removed">3126         assert(t == sig_bt[sig_index], &quot;sigs in sync&quot;);</span>
<span class="line-removed">3127         if (at_this)</span>
<span class="line-removed">3128           stream-&gt;print(&quot;  # this: &quot;);</span>
<span class="line-removed">3129         else</span>
<span class="line-removed">3130           stream-&gt;print(&quot;  # parm%d: &quot;, arg_index);</span>
<span class="line-removed">3131         stream-&gt;move_to(tab1);</span>
<span class="line-removed">3132         VMReg fst = regs[sig_index].first();</span>
<span class="line-removed">3133         VMReg snd = regs[sig_index].second();</span>
<span class="line-removed">3134         if (fst-&gt;is_reg()) {</span>
<span class="line-removed">3135           stream-&gt;print(&quot;%s&quot;, fst-&gt;name());</span>
<span class="line-removed">3136           if (snd-&gt;is_valid())  {</span>
<span class="line-removed">3137             stream-&gt;print(&quot;:%s&quot;, snd-&gt;name());</span>
<span class="line-removed">3138           }</span>
<span class="line-removed">3139         } else if (fst-&gt;is_stack()) {</span>
<span class="line-removed">3140           int offset = fst-&gt;reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;</span>
<span class="line-removed">3141           if (offset == stack_slot_offset)  at_old_sp = true;</span>
<span class="line-removed">3142           stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, offset);</span>
<span class="line-removed">3143         } else {</span>
<span class="line-removed">3144           stream-&gt;print(&quot;reg%d:%d??&quot;, (int)(intptr_t)fst, (int)(intptr_t)snd);</span>
3145         }
<span class="line-modified">3146         stream-&gt;print(&quot; &quot;);</span>
<span class="line-modified">3147         stream-&gt;move_to(tab2);</span>
<span class="line-modified">3148         stream-&gt;print(&quot;= &quot;);</span>
<span class="line-modified">3149         if (at_this) {</span>
<span class="line-modified">3150           m-&gt;method_holder()-&gt;print_value_on(stream);</span>
<span class="line-modified">3151         } else {</span>
<span class="line-removed">3152           bool did_name = false;</span>
<span class="line-removed">3153           if (!at_this &amp;&amp; ss.is_reference()) {</span>
<span class="line-removed">3154             Symbol* name = ss.as_symbol();</span>
<span class="line-removed">3155             name-&gt;print_value_on(stream);</span>
<span class="line-removed">3156             did_name = true;</span>
<span class="line-removed">3157           }</span>
<span class="line-removed">3158           if (!did_name)</span>
<span class="line-removed">3159             stream-&gt;print(&quot;%s&quot;, type2name(t));</span>
3160         }
<span class="line-modified">3161         if (at_old_sp) {</span>
<span class="line-modified">3162           stream-&gt;print(&quot;  (%s of caller)&quot;, spname);</span>
<span class="line-removed">3163           did_old_sp = true;</span>
3164         }
<span class="line-modified">3165         stream-&gt;cr();</span>
<span class="line-removed">3166         sig_index += type2size[t];</span>
<span class="line-removed">3167         arg_index += 1;</span>
<span class="line-removed">3168         if (!at_this)  ss.next();</span>
3169       }
<span class="line-modified">3170       if (!did_old_sp) {</span>
<span class="line-removed">3171         stream-&gt;print(&quot;  # &quot;);</span>
<span class="line-removed">3172         stream-&gt;move_to(tab1);</span>
<span class="line-removed">3173         stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, stack_slot_offset);</span>
3174         stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
<span class="line-modified">3175         stream-&gt;cr();</span>
3176       }











3177     }
3178   }
3179 }
3180 
3181 // Returns whether this nmethod has code comments.
3182 bool nmethod::has_code_comment(address begin, address end) {
3183   // scopes?
3184   ScopeDesc* sd  = scope_desc_in(begin, end);
3185   if (sd != NULL) return true;
3186 
3187   // relocations?
3188   const char* str = reloc_string_for(begin, end);
3189   if (str != NULL) return true;
3190 
3191   // implicit exceptions?
3192   int cont_offset = ImplicitExceptionTable(this).continuation_offset(begin - code_begin());
3193   if (cont_offset != 0) return true;
3194 
3195   return false;
3196 }
</pre>
<hr />
<pre>
3281             else
3282               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3283             break;
3284           }
3285         case Bytecodes::_getfield:
3286         case Bytecodes::_putfield:
3287         case Bytecodes::_getstatic:
3288         case Bytecodes::_putstatic:
3289           {
3290             Bytecode_field field(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());
3291             st-&gt;print(&quot; &quot;);
3292             if (field.name() != NULL)
3293               field.name()-&gt;print_symbol_on(st);
3294             else
3295               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3296           }
3297         default:
3298           break;
3299         }
3300       }
<span class="line-modified">3301       st-&gt;print(&quot; {reexecute=%d rethrow=%d return_oop=%d}&quot;, sd-&gt;should_reexecute(), sd-&gt;rethrow_exception(), sd-&gt;return_oop());</span>
3302     }
3303 
3304     // Print all scopes
3305     for (;sd != NULL; sd = sd-&gt;sender()) {
3306       st-&gt;move_to(column, 6, 0);
3307       st-&gt;print(&quot;; -&quot;);
3308       if (sd-&gt;should_reexecute()) {
3309         st-&gt;print(&quot; (reexecute)&quot;);
3310       }
3311       if (sd-&gt;method() == NULL) {
3312         st-&gt;print(&quot;method is NULL&quot;);
3313       } else {
3314         sd-&gt;method()-&gt;print_short_name(st);
3315       }
3316       int lineno = sd-&gt;method()-&gt;line_number_from_bci(sd-&gt;bci());
3317       if (lineno != -1) {
3318         st-&gt;print(&quot;@%d (line %d)&quot;, sd-&gt;bci(), lineno);
3319       } else {
3320         st-&gt;print(&quot;@%d&quot;, sd-&gt;bci());
3321       }
</pre>
</td>
<td>
<hr />
<pre>
 616     _consts_offset           = data_offset();
 617     _stub_offset             = data_offset();
 618     _oops_offset             = data_offset();
 619     _metadata_offset         = _oops_offset         + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 620     scopes_data_offset       = _metadata_offset     + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 621     _scopes_pcs_offset       = scopes_data_offset;
 622     _dependencies_offset     = _scopes_pcs_offset;
 623     _handler_table_offset    = _dependencies_offset;
 624     _nul_chk_table_offset    = _handler_table_offset;
 625 #if INCLUDE_JVMCI
 626     _speculations_offset     = _nul_chk_table_offset;
 627     _jvmci_data_offset       = _speculations_offset;
 628     _nmethod_end_offset      = _jvmci_data_offset;
 629 #else
 630     _nmethod_end_offset      = _nul_chk_table_offset;
 631 #endif
 632     _compile_id              = compile_id;
 633     _comp_level              = CompLevel_none;
 634     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 635     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
<span class="line-added"> 636 </span>
<span class="line-added"> 637     assert(!method-&gt;has_scalarized_args(), &quot;scalarized native wrappers not supported yet&quot;); // for the next 3 fields</span>
<span class="line-added"> 638     _value_entry_point       = _entry_point;</span>
<span class="line-added"> 639     _verified_value_entry_point = _verified_entry_point;</span>
<span class="line-added"> 640     _verified_value_ro_entry_point = _verified_entry_point;</span>
<span class="line-added"> 641 </span>
 642     _osr_entry_point         = NULL;
 643     _exception_cache         = NULL;
 644     _pc_desc_container.reset_to(NULL);
 645     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 646 
 647     _scopes_data_begin = (address) this + scopes_data_offset;
 648     _deopt_handler_begin = (address) this + deoptimize_offset;
 649     _deopt_mh_handler_begin = (address) this + deoptimize_mh_offset;
 650 
 651     code_buffer-&gt;copy_code_and_locs_to(this);
 652     code_buffer-&gt;copy_values_to(this);
 653 
 654     clear_unloading_state();
 655 
 656     Universe::heap()-&gt;register_nmethod(this);
 657     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 658 
 659     CodeCache::commit(this);
 660   }
 661 
</pre>
<hr />
<pre>
 793       _unwind_handler_offset = -1;
 794     }
 795 
 796     _oops_offset             = data_offset();
 797     _metadata_offset         = _oops_offset          + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 798     int scopes_data_offset   = _metadata_offset      + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 799 
 800     _scopes_pcs_offset       = scopes_data_offset    + align_up(debug_info-&gt;data_size       (), oopSize);
 801     _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info-&gt;pcs_size());
 802     _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies-&gt;size_in_bytes (), oopSize);
 803     _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table-&gt;size_in_bytes(), oopSize);
 804 #if INCLUDE_JVMCI
 805     _speculations_offset     = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 806     _jvmci_data_offset       = _speculations_offset  + align_up(speculations_len, oopSize);
 807     _nmethod_end_offset      = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize);
 808 #else
 809     _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 810 #endif
 811     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 812     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
<span class="line-added"> 813     _value_entry_point       = code_begin()          + offsets-&gt;value(CodeOffsets::Value_Entry);</span>
<span class="line-added"> 814     _verified_value_entry_point = code_begin()       + offsets-&gt;value(CodeOffsets::Verified_Value_Entry);</span>
<span class="line-added"> 815     _verified_value_ro_entry_point = code_begin()    + offsets-&gt;value(CodeOffsets::Verified_Value_Entry_RO);</span>
 816     _osr_entry_point         = code_begin()          + offsets-&gt;value(CodeOffsets::OSR_Entry);
 817     _exception_cache         = NULL;
 818     _scopes_data_begin       = (address) this + scopes_data_offset;
 819 
 820     _pc_desc_container.reset_to(scopes_pcs_begin());
 821 
 822     code_buffer-&gt;copy_code_and_locs_to(this);
 823     // Copy contents of ScopeDescRecorder to nmethod
 824     code_buffer-&gt;copy_values_to(this);
 825     debug_info-&gt;copy_to(this);
 826     dependencies-&gt;copy_to(this);
 827     clear_unloading_state();
 828 
 829     Universe::heap()-&gt;register_nmethod(this);
 830     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 831 
 832     CodeCache::commit(this);
 833 
 834     // Copy contents of ExceptionHandlerTable to nmethod
 835     handler_table-&gt;copy_to(this);
</pre>
<hr />
<pre>
 912 // Print out more verbose output usually for a newly created nmethod.
 913 void nmethod::print_on(outputStream* st, const char* msg) const {
 914   if (st != NULL) {
 915     ttyLocker ttyl;
 916     if (WizardMode) {
 917       CompileTask::print(st, this, msg, /*short_form:*/ true);
 918       st-&gt;print_cr(&quot; (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
 919     } else {
 920       CompileTask::print(st, this, msg, /*short_form:*/ false);
 921     }
 922   }
 923 }
 924 
 925 void nmethod::maybe_print_nmethod(DirectiveSet* directive) {
 926   bool printnmethods = directive-&gt;PrintAssemblyOption || directive-&gt;PrintNMethodsOption;
 927   if (printnmethods || PrintDebugInfo || PrintRelocations || PrintDependencies || PrintExceptionHandlers) {
 928     print_nmethod(printnmethods);
 929   }
 930 }
 931 
<span class="line-added"> 932 static nmethod* _nmethod_to_print = NULL;</span>
<span class="line-added"> 933 static const CompiledEntrySignature* _nmethod_to_print_ces = NULL;</span>
<span class="line-added"> 934 </span>
 935 void nmethod::print_nmethod(bool printmethod) {
<span class="line-added"> 936   ResourceMark rm;</span>
<span class="line-added"> 937   CompiledEntrySignature ces(method());</span>
<span class="line-added"> 938   ces.compute_calling_conventions();</span>
<span class="line-added"> 939   // ces.compute_calling_conventions() needs to grab the ProtectionDomainSet_lock, so we</span>
<span class="line-added"> 940   // can&#39;t do that (inside nmethod::print_entry_parameters) while holding the ttyLocker.</span>
<span class="line-added"> 941   // Hence we have do compute it here and pass via a global. Yuck.</span>
 942   ttyLocker ttyl;  // keep the following output all in one block
<span class="line-added"> 943   assert(_nmethod_to_print == NULL &amp;&amp; _nmethod_to_print_ces == NULL, &quot;no nesting&quot;);</span>
<span class="line-added"> 944   _nmethod_to_print = this;</span>
<span class="line-added"> 945   _nmethod_to_print_ces = &amp;ces;</span>
 946   if (xtty != NULL) {
 947     xtty-&gt;begin_head(&quot;print_nmethod&quot;);
 948     log_identity(xtty);
 949     xtty-&gt;stamp();
 950     xtty-&gt;end_head();
 951   }
 952   // Print the header part, then print the requested information.
 953   // This is both handled in decode2().
 954   if (printmethod) {
 955     HandleMark hm;
 956     ResourceMark m;
 957     if (is_compiled_by_c1()) {
 958       tty-&gt;cr();
 959       tty-&gt;print_cr(&quot;============================= C1-compiled nmethod ==============================&quot;);
 960     }
 961     if (is_compiled_by_jvmci()) {
 962       tty-&gt;cr();
 963       tty-&gt;print_cr(&quot;=========================== JVMCI-compiled nmethod =============================&quot;);
 964     }
 965     tty-&gt;print_cr(&quot;----------------------------------- Assembly -----------------------------------&quot;);
</pre>
<hr />
<pre>
1002     }
1003     if (printmethod || PrintExceptionHandlers) {
1004       print_handler_table();
1005       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1006       print_nul_chk_table();
1007       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1008     }
1009 
1010     if (printmethod) {
1011       print_recorded_oops();
1012       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1013       print_recorded_metadata();
1014       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1015     }
1016   }
1017 #endif
1018 
1019   if (xtty != NULL) {
1020     xtty-&gt;tail(&quot;print_nmethod&quot;);
1021   }
<span class="line-added">1022 </span>
<span class="line-added">1023   _nmethod_to_print = NULL;</span>
<span class="line-added">1024   _nmethod_to_print_ces = NULL;</span>
1025 }
1026 
1027 
1028 // Promote one word from an assembly-time handle to a live embedded oop.
1029 inline void nmethod::initialize_immediate_oop(oop* dest, jobject handle) {
1030   if (handle == NULL ||
1031       // As a special case, IC oops are initialized to 1 or -1.
1032       handle == (jobject) Universe::non_oop_word()) {
1033     (*dest) = (oop) handle;
1034   } else {
1035     (*dest) = JNIHandles::resolve_non_null(handle);
1036   }
1037 }
1038 
1039 
1040 // Have to have the same name because it&#39;s called by a template
1041 void nmethod::copy_values(GrowableArray&lt;jobject&gt;* array) {
1042   int length = array-&gt;length();
1043   assert((address)(oops_begin() + length) &lt;= (address)oops_end(), &quot;oops big enough&quot;);
1044   oop* dest = oops_begin();
</pre>
<hr />
<pre>
2424   VerifyMetadataClosure vmc;
2425   metadata_do(&amp;vmc);
2426 }
2427 
2428 
2429 void nmethod::verify_interrupt_point(address call_site) {
2430   // Verify IC only when nmethod installation is finished.
2431   if (!is_not_installed()) {
2432     if (CompiledICLocker::is_safe(this)) {
2433       CompiledIC_at(this, call_site);
2434     } else {
2435       CompiledICLocker ml_verify(this);
2436       CompiledIC_at(this, call_site);
2437     }
2438   }
2439 
2440   PcDesc* pd = pc_desc_at(nativeCall_at(call_site)-&gt;return_address());
2441   assert(pd != NULL, &quot;PcDesc must exist&quot;);
2442   for (ScopeDesc* sd = new ScopeDesc(this, pd-&gt;scope_decode_offset(),
2443                                      pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
<span class="line-modified">2444                                      pd-&gt;return_oop(), pd-&gt;return_vt());</span>
2445        !sd-&gt;is_top(); sd = sd-&gt;sender()) {
2446     sd-&gt;verify();
2447   }
2448 }
2449 
2450 void nmethod::verify_scopes() {
2451   if( !method() ) return;       // Runtime stubs have no scope
2452   if (method()-&gt;is_native()) return; // Ignore stub methods.
2453   // iterate through all interrupt point
2454   // and verify the debug information is valid.
2455   RelocIterator iter((nmethod*)this);
2456   while (iter.next()) {
2457     address stub = NULL;
2458     switch (iter.type()) {
2459       case relocInfo::virtual_call_type:
2460         verify_interrupt_point(iter.addr());
2461         break;
2462       case relocInfo::opt_virtual_call_type:
2463         stub = iter.opt_virtual_call_reloc()-&gt;static_stub(false);
2464         verify_interrupt_point(iter.addr());
</pre>
<hr />
<pre>
3064         case relocInfo::internal_word_type:    return &quot;internal_word&quot;;
3065         case relocInfo::section_word_type:     return &quot;section_word&quot;;
3066         case relocInfo::poll_type:             return &quot;poll&quot;;
3067         case relocInfo::poll_return_type:      return &quot;poll_return&quot;;
3068         case relocInfo::trampoline_stub_type:  return &quot;trampoline_stub&quot;;
3069         case relocInfo::type_mask:             return &quot;type_bit_mask&quot;;
3070 
3071         default:
3072           break;
3073     }
3074   }
3075   return have_one ? &quot;other&quot; : NULL;
3076 }
3077 
3078 // Return a the last scope in (begin..end]
3079 ScopeDesc* nmethod::scope_desc_in(address begin, address end) {
3080   PcDesc* p = pc_desc_near(begin+1);
3081   if (p != NULL &amp;&amp; p-&gt;real_pc(this) &lt;= end) {
3082     return new ScopeDesc(this, p-&gt;scope_decode_offset(),
3083                          p-&gt;obj_decode_offset(), p-&gt;should_reexecute(), p-&gt;rethrow_exception(),
<span class="line-modified">3084                          p-&gt;return_oop(), p-&gt;return_vt());</span>
3085   }
3086   return NULL;
3087 }
3088 
3089 const char* nmethod::nmethod_section_label(address pos) const {
3090   const char* label = NULL;
3091   if (pos == code_begin())                                              label = &quot;[Instructions begin]&quot;;
3092   if (pos == entry_point())                                             label = &quot;[Entry Point]&quot;;
<span class="line-added">3093   if (pos == value_entry_point())                                       label = &quot;[Value Entry Point]&quot;;</span>
3094   if (pos == verified_entry_point())                                    label = &quot;[Verified Entry Point]&quot;;
<span class="line-added">3095   if (pos == verified_value_entry_point())                              label = &quot;[Verified Value Entry Point]&quot;;</span>
<span class="line-added">3096   if (pos == verified_value_ro_entry_point())                           label = &quot;[Verified Value Entry Point (RO)]&quot;;</span>
3097   if (has_method_handle_invokes() &amp;&amp; (pos == deopt_mh_handler_begin())) label = &quot;[Deopt MH Handler Code]&quot;;
3098   if (pos == consts_begin() &amp;&amp; pos != insts_begin())                    label = &quot;[Constants]&quot;;
3099   // Check stub_code before checking exception_handler or deopt_handler.
3100   if (pos == this-&gt;stub_begin())                                        label = &quot;[Stub Code]&quot;;
3101   if (JVMCI_ONLY(_exception_offset &gt;= 0 &amp;&amp;) pos == exception_begin())           label = &quot;[Exception Handler]&quot;;
3102   if (JVMCI_ONLY(_deopt_handler_begin != NULL &amp;&amp;) pos == deopt_handler_begin()) label = &quot;[Deopt Handler Code]&quot;;
3103   return label;
3104 }
3105 
<span class="line-added">3106 static int maybe_print_entry_label(outputStream* stream, address pos, address entry, const char* label) {</span>
<span class="line-added">3107   if (pos == entry) {</span>
<span class="line-added">3108     stream-&gt;bol();</span>
<span class="line-added">3109     stream-&gt;print_cr(&quot;%s&quot;, label);</span>
<span class="line-added">3110     return 1;</span>
<span class="line-added">3111   } else {</span>
<span class="line-added">3112     return 0;</span>
<span class="line-added">3113   }</span>
<span class="line-added">3114 }</span>
<span class="line-added">3115 </span>
3116 void nmethod::print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels) const {
3117   if (print_section_labels) {
<span class="line-modified">3118     int n = 0;</span>
<span class="line-modified">3119     // Multiple entry points may be at the same position. Print them all.</span>
<span class="line-modified">3120     n += maybe_print_entry_label(stream, block_begin, entry_point(),                   &quot;[Entry Point]&quot;);</span>
<span class="line-modified">3121     n += maybe_print_entry_label(stream, block_begin, value_entry_point(),             &quot;[Value Entry Point]&quot;);</span>
<span class="line-added">3122     n += maybe_print_entry_label(stream, block_begin, verified_entry_point(),          &quot;[Verified Entry Point]&quot;);</span>
<span class="line-added">3123     n += maybe_print_entry_label(stream, block_begin, verified_value_entry_point(),    &quot;[Verified Value Entry Point]&quot;);</span>
<span class="line-added">3124     n += maybe_print_entry_label(stream, block_begin, verified_value_ro_entry_point(), &quot;[Verified Value Entry Point (RO)]&quot;);</span>
<span class="line-added">3125     if (n == 0) {</span>
<span class="line-added">3126       const char* label = nmethod_section_label(block_begin);</span>
<span class="line-added">3127       if (label != NULL) {</span>
<span class="line-added">3128         stream-&gt;bol();</span>
<span class="line-added">3129         stream-&gt;print_cr(&quot;%s&quot;, label);</span>
<span class="line-added">3130       }</span>
3131     }
3132   }
3133 
<span class="line-modified">3134   if (_nmethod_to_print != this) {</span>
<span class="line-modified">3135     return;</span>
<span class="line-modified">3136   }</span>
<span class="line-modified">3137   Method* m = method();</span>
<span class="line-modified">3138   if (m == NULL || is_osr_method()) {</span>
<span class="line-modified">3139     return;</span>
<span class="line-added">3140   }</span>
<span class="line-added">3141 </span>
<span class="line-added">3142   // Print the name of the method (only once)</span>
<span class="line-added">3143   address low = MIN4(entry_point(), verified_entry_point(), verified_value_entry_point(), verified_value_ro_entry_point());</span>
<span class="line-added">3144   low = MIN2(low, value_entry_point());</span>
<span class="line-added">3145   assert(low != 0, &quot;sanity&quot;);</span>
<span class="line-added">3146   if (block_begin == low) {</span>
<span class="line-added">3147     stream-&gt;print(&quot;  # &quot;);</span>
<span class="line-added">3148     m-&gt;print_value_on(stream);</span>
<span class="line-added">3149     stream-&gt;cr();</span>
<span class="line-added">3150   }</span>
<span class="line-added">3151 </span>
<span class="line-added">3152   // Print the arguments for the 3 types of verified entry points</span>
<span class="line-added">3153   {</span>
<span class="line-added">3154     const CompiledEntrySignature* ces = _nmethod_to_print_ces;</span>
<span class="line-added">3155     const GrowableArray&lt;SigEntry&gt;* sig_cc;</span>
<span class="line-added">3156     const VMRegPair* regs;</span>
<span class="line-added">3157     if (block_begin == verified_entry_point()) {</span>
<span class="line-added">3158       sig_cc = &amp;ces-&gt;sig_cc();</span>
<span class="line-added">3159       regs = ces-&gt;regs_cc();</span>
<span class="line-added">3160     } else if (block_begin == verified_value_entry_point()) {</span>
<span class="line-added">3161       sig_cc = &amp;ces-&gt;sig();</span>
<span class="line-added">3162       regs = ces-&gt;regs();</span>
<span class="line-added">3163     } else if (block_begin == verified_value_ro_entry_point()) {</span>
<span class="line-added">3164       sig_cc = &amp;ces-&gt;sig_cc_ro();</span>
<span class="line-added">3165       regs = ces-&gt;regs_cc_ro();</span>
<span class="line-added">3166     } else {</span>
<span class="line-added">3167       return;</span>
3168     }
<span class="line-modified">3169 </span>
<span class="line-modified">3170     ResourceMark rm;</span>
<span class="line-modified">3171     int sizeargs = 0;</span>
<span class="line-modified">3172     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, 256);</span>
<span class="line-modified">3173     bool has_scalarized_args = ces-&gt;has_scalarized_args();</span>
<span class="line-modified">3174     TempNewSymbol sig = SigEntry::create_symbol(sig_cc);</span>
<span class="line-modified">3175     for (SignatureStream ss(sig); !ss.at_return_type(); ss.next()) {</span>
<span class="line-modified">3176       BasicType t = ss.type();</span>
<span class="line-modified">3177       sig_bt[sizeargs++] = t;</span>
<span class="line-modified">3178       if (type2size[t] == 2) {</span>
<span class="line-modified">3179         sig_bt[sizeargs++] = T_VOID;</span>
<span class="line-modified">3180       } else {</span>
<span class="line-modified">3181         assert(type2size[t] == 1, &quot;size is 1 or 2&quot;);</span>
<span class="line-modified">3182       }</span>
<span class="line-modified">3183     }</span>
<span class="line-modified">3184     bool has_this = !m-&gt;is_static();</span>
<span class="line-modified">3185     if (ces-&gt;has_value_recv() &amp;&amp; block_begin == verified_entry_point()) {</span>
<span class="line-added">3186       // &lt;this&gt; argument is scalarized for verified_entry_point()</span>
<span class="line-added">3187       has_this = false;</span>
<span class="line-added">3188     }</span>
<span class="line-added">3189     const char* spname = &quot;sp&quot;; // make arch-specific?</span>
<span class="line-added">3190     int stack_slot_offset = this-&gt;frame_size() * wordSize;</span>
<span class="line-added">3191     int tab1 = 14, tab2 = 24;</span>
<span class="line-added">3192     int sig_index = 0;</span>
<span class="line-added">3193     int sig_index_cc = 0;</span>
<span class="line-added">3194     int arg_index = has_this ? -1 : 0;</span>
<span class="line-added">3195     bool did_old_sp = false;</span>
<span class="line-added">3196     for (SignatureStream ss(sig); !ss.at_return_type(); ) {</span>
<span class="line-added">3197       bool at_this = (arg_index == -1);</span>
<span class="line-added">3198       bool at_old_sp = false;</span>
<span class="line-added">3199       BasicType t = ss.type();</span>
<span class="line-added">3200       assert(t == sig_bt[sig_index], &quot;sigs in sync&quot;);</span>
<span class="line-added">3201       if (at_this) {</span>
<span class="line-added">3202         stream-&gt;print(&quot;  # this: &quot;);</span>
<span class="line-added">3203       } else {</span>
<span class="line-added">3204         stream-&gt;print(&quot;  # parm%d: &quot;, arg_index);</span>
<span class="line-added">3205       }</span>
<span class="line-added">3206       stream-&gt;move_to(tab1);</span>
<span class="line-added">3207       VMReg fst = regs[sig_index].first();</span>
<span class="line-added">3208       VMReg snd = regs[sig_index].second();</span>
<span class="line-added">3209       if (fst-&gt;is_reg()) {</span>
<span class="line-added">3210         stream-&gt;print(&quot;%s&quot;, fst-&gt;name());</span>
<span class="line-added">3211         if (snd-&gt;is_valid())  {</span>
<span class="line-added">3212           stream-&gt;print(&quot;:%s&quot;, snd-&gt;name());</span>
3213         }
<span class="line-modified">3214       } else if (fst-&gt;is_stack()) {</span>
<span class="line-added">3215         int offset = fst-&gt;reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;</span>
<span class="line-added">3216         if (offset == stack_slot_offset)  at_old_sp = true;</span>
<span class="line-added">3217         stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, offset);</span>
<span class="line-added">3218       } else {</span>
<span class="line-added">3219         stream-&gt;print(&quot;reg%d:%d??&quot;, (int)(intptr_t)fst, (int)(intptr_t)snd);</span>
3220       }
<span class="line-modified">3221       stream-&gt;print(&quot; &quot;);</span>
<span class="line-modified">3222       stream-&gt;move_to(tab2);</span>
<span class="line-modified">3223       stream-&gt;print(&quot;= &quot;);</span>
<span class="line-modified">3224       if (at_this) {</span>
<span class="line-modified">3225         m-&gt;method_holder()-&gt;print_value_on(stream);</span>
<span class="line-modified">3226       } else {</span>
<span class="line-modified">3227         bool did_name = false;</span>
<span class="line-modified">3228         if (ss.is_reference()) {</span>
<span class="line-modified">3229           Symbol* name = ss.as_symbol();</span>
<span class="line-modified">3230           name-&gt;print_value_on(stream);</span>
<span class="line-modified">3231           did_name = true;</span>



















3232         }
<span class="line-modified">3233         if (!did_name)</span>
<span class="line-modified">3234           stream-&gt;print(&quot;%s&quot;, type2name(t));</span>
<span class="line-modified">3235       }</span>
<span class="line-modified">3236       if (has_scalarized_args) {</span>
<span class="line-modified">3237         while (!SigEntry::skip_value_delimiters(sig_cc, sig_index_cc)) {</span>
<span class="line-modified">3238           sig_index_cc++;</span>








3239         }
<span class="line-modified">3240         if (SigEntry::is_reserved_entry(sig_cc, sig_index_cc)) {</span>
<span class="line-modified">3241           stream-&gt;print(&quot; [RESERVED]&quot;);</span>

3242         }
<span class="line-modified">3243         sig_index_cc += type2size[t];</span>



3244       }
<span class="line-modified">3245       if (at_old_sp) {</span>



3246         stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
<span class="line-modified">3247         did_old_sp = true;</span>
3248       }
<span class="line-added">3249       stream-&gt;cr();</span>
<span class="line-added">3250       sig_index += type2size[t];</span>
<span class="line-added">3251       arg_index += 1;</span>
<span class="line-added">3252       ss.next();</span>
<span class="line-added">3253     }</span>
<span class="line-added">3254     if (!did_old_sp) {</span>
<span class="line-added">3255       stream-&gt;print(&quot;  # &quot;);</span>
<span class="line-added">3256       stream-&gt;move_to(tab1);</span>
<span class="line-added">3257       stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, stack_slot_offset);</span>
<span class="line-added">3258       stream-&gt;print(&quot;  (%s of caller)&quot;, spname);</span>
<span class="line-added">3259       stream-&gt;cr();</span>
3260     }
3261   }
3262 }
3263 
3264 // Returns whether this nmethod has code comments.
3265 bool nmethod::has_code_comment(address begin, address end) {
3266   // scopes?
3267   ScopeDesc* sd  = scope_desc_in(begin, end);
3268   if (sd != NULL) return true;
3269 
3270   // relocations?
3271   const char* str = reloc_string_for(begin, end);
3272   if (str != NULL) return true;
3273 
3274   // implicit exceptions?
3275   int cont_offset = ImplicitExceptionTable(this).continuation_offset(begin - code_begin());
3276   if (cont_offset != 0) return true;
3277 
3278   return false;
3279 }
</pre>
<hr />
<pre>
3364             else
3365               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3366             break;
3367           }
3368         case Bytecodes::_getfield:
3369         case Bytecodes::_putfield:
3370         case Bytecodes::_getstatic:
3371         case Bytecodes::_putstatic:
3372           {
3373             Bytecode_field field(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());
3374             st-&gt;print(&quot; &quot;);
3375             if (field.name() != NULL)
3376               field.name()-&gt;print_symbol_on(st);
3377             else
3378               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3379           }
3380         default:
3381           break;
3382         }
3383       }
<span class="line-modified">3384       st-&gt;print(&quot; {reexecute=%d rethrow=%d return_oop=%d return_vt=%d}&quot;, sd-&gt;should_reexecute(), sd-&gt;rethrow_exception(), sd-&gt;return_oop(), sd-&gt;return_vt());</span>
3385     }
3386 
3387     // Print all scopes
3388     for (;sd != NULL; sd = sd-&gt;sender()) {
3389       st-&gt;move_to(column, 6, 0);
3390       st-&gt;print(&quot;; -&quot;);
3391       if (sd-&gt;should_reexecute()) {
3392         st-&gt;print(&quot; (reexecute)&quot;);
3393       }
3394       if (sd-&gt;method() == NULL) {
3395         st-&gt;print(&quot;method is NULL&quot;);
3396       } else {
3397         sd-&gt;method()-&gt;print_short_name(st);
3398       }
3399       int lineno = sd-&gt;method()-&gt;line_number_from_bci(sd-&gt;bci());
3400       if (lineno != -1) {
3401         st-&gt;print(&quot;@%d (line %d)&quot;, sd-&gt;bci(), lineno);
3402       } else {
3403         st-&gt;print(&quot;@%d&quot;, sd-&gt;bci());
3404       }
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
  57 #include &quot;oops/methodData.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;


  62 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/os.hpp&quot;
  65 #include &quot;runtime/safepointVerifiers.hpp&quot;
  66 #include &quot;runtime/signature.hpp&quot;
  67 #include &quot;runtime/timerTrace.hpp&quot;
  68 #include &quot;runtime/vmThread.hpp&quot;
  69 #include &quot;runtime/vmOperations.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/bitMap.inline.hpp&quot;
  72 #include &quot;utilities/ostream.hpp&quot;
  73 #include &quot;utilities/defaultStream.hpp&quot;
  74 #include &quot;utilities/hashtable.inline.hpp&quot;
  75 #if INCLUDE_G1GC
  76 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  77 #endif
  78 
  79 ReservedSpace MetaspaceShared::_shared_rs;
  80 VirtualSpace MetaspaceShared::_shared_vs;
  81 ReservedSpace MetaspaceShared::_symbol_rs;
</pre>
<hr />
<pre>
 742     fp.fingerprint();
 743   }
 744 }
 745 
 746 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 747 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 748 //
 749 // Addresses of the vtables and the methods may be different across JVM runs,
 750 // if libjvm.so is dynamically loaded at a different base address.
 751 //
 752 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 753 //
 754 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 755 //                  the CDS image
 756 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 757 //                  into our own tables.
 758 
 759 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 760 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 761   f(ConstantPool) \
<span class="line-modified"> 762   f(InstanceKlass) \</span>
 763   f(InstanceClassLoaderKlass) \
 764   f(InstanceMirrorKlass) \
 765   f(InstanceRefKlass) \
 766   f(Method) \
 767   f(ObjArrayKlass) \
<span class="line-modified"> 768   f(TypeArrayKlass)</span>


 769 
 770 class CppVtableInfo {
 771   intptr_t _vtable_size;
 772   intptr_t _cloned_vtable[1];
 773 public:
 774   static int num_slots(int vtable_size) {
 775     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 776   }
 777   int vtable_size()           { return int(uintx(_vtable_size)); }
 778   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 779   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 780   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 781   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 782   static size_t byte_size(int vtable_size) {
 783     CppVtableInfo i;
 784     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 785   }
 786 };
 787 
 788 template &lt;class T&gt; class CppVtableCloner : public T {
</pre>
<hr />
<pre>
 936   Arguments::assert_is_dumping_archive();
 937   int kind = -1;
 938   switch (msotype) {
 939   case MetaspaceObj::SymbolType:
 940   case MetaspaceObj::TypeArrayU1Type:
 941   case MetaspaceObj::TypeArrayU2Type:
 942   case MetaspaceObj::TypeArrayU4Type:
 943   case MetaspaceObj::TypeArrayU8Type:
 944   case MetaspaceObj::TypeArrayOtherType:
 945   case MetaspaceObj::ConstMethodType:
 946   case MetaspaceObj::ConstantPoolCacheType:
 947   case MetaspaceObj::AnnotationsType:
 948   case MetaspaceObj::MethodCountersType:
 949   case MetaspaceObj::RecordComponentType:
 950     // These have no vtables.
 951     break;
 952   case MetaspaceObj::ClassType:
 953     {
 954       Klass* k = (Klass*)obj;
 955       assert(k-&gt;is_klass(), &quot;must be&quot;);
<span class="line-modified"> 956       if (k-&gt;is_instance_klass()) {</span>


 957         InstanceKlass* ik = InstanceKlass::cast(k);
 958         if (ik-&gt;is_class_loader_instance_klass()) {
 959           kind = InstanceClassLoaderKlass_Kind;
 960         } else if (ik-&gt;is_reference_instance_klass()) {
 961           kind = InstanceRefKlass_Kind;
 962         } else if (ik-&gt;is_mirror_instance_klass()) {
 963           kind = InstanceMirrorKlass_Kind;
 964         } else {
 965           kind = InstanceKlass_Kind;
 966         }
 967       } else if (k-&gt;is_typeArray_klass()) {
 968         kind = TypeArrayKlass_Kind;
 969       } else {
 970         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
 971         kind = ObjArrayKlass_Kind;
 972       }
 973     }
 974     break;
 975 
 976   case MetaspaceObj::MethodType:
</pre>
<hr />
<pre>
1364     ShallowCopier(bool read_only) : _read_only(read_only) {}
1365 
1366     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1367       if (read_only == _read_only) {
1368         allocate(ref, read_only);
1369       }
1370       return true; // recurse into ref.obj()
1371     }
1372   };
1373 
1374   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1375   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1376   public:
1377     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1378       address new_loc = get_new_loc(ref);
1379       RefRelocator refer;
1380       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1381       return true; // recurse into ref.obj()
1382     }
1383     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
<span class="line-modified">1384       assert(type == _method_entry_ref, &quot;only special type allowed for now&quot;);</span>

1385       address obj = ref-&gt;obj();
1386       address new_obj = get_new_loc(ref);
1387       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1388       intptr_t* new_p = (intptr_t*)(new_obj + offset);
<span class="line-modified">1389       assert(*p == *new_p, &quot;must be a copy&quot;);</span>













1390       ArchivePtrMarker::mark_pointer((address*)new_p);
1391     }
1392   };
1393 
1394   // Relocate a reference to point to its shallow copy
1395   class RefRelocator: public MetaspaceClosure {
1396   public:
1397     virtual bool do_ref(Ref* ref, bool read_only) {
1398       if (ref-&gt;not_null()) {
1399         ref-&gt;update(get_new_loc(ref));
1400         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1401       }
1402       return false; // Do not recurse.
1403     }
1404   };
1405 
1406 #ifdef ASSERT
1407   class IsRefInArchiveChecker: public MetaspaceClosure {
1408   public:
1409     virtual bool do_ref(Ref* ref, bool read_only) {
</pre>
</td>
<td>
<hr />
<pre>
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
  57 #include &quot;oops/methodData.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  63 #include &quot;oops/valueKlass.hpp&quot;</span>
  64 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/os.hpp&quot;
  67 #include &quot;runtime/safepointVerifiers.hpp&quot;
  68 #include &quot;runtime/signature.hpp&quot;
  69 #include &quot;runtime/timerTrace.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;runtime/vmOperations.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/bitMap.inline.hpp&quot;
  74 #include &quot;utilities/ostream.hpp&quot;
  75 #include &quot;utilities/defaultStream.hpp&quot;
  76 #include &quot;utilities/hashtable.inline.hpp&quot;
  77 #if INCLUDE_G1GC
  78 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  79 #endif
  80 
  81 ReservedSpace MetaspaceShared::_shared_rs;
  82 VirtualSpace MetaspaceShared::_shared_vs;
  83 ReservedSpace MetaspaceShared::_symbol_rs;
</pre>
<hr />
<pre>
 744     fp.fingerprint();
 745   }
 746 }
 747 
 748 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 749 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 750 //
 751 // Addresses of the vtables and the methods may be different across JVM runs,
 752 // if libjvm.so is dynamically loaded at a different base address.
 753 //
 754 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 755 //
 756 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 757 //                  the CDS image
 758 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 759 //                  into our own tables.
 760 
 761 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 762 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 763   f(ConstantPool) \
<span class="line-modified"> 764   f(InstanceClassLoaderKlass) \</span>
 765   f(InstanceKlass) \
 766   f(InstanceMirrorKlass) \
 767   f(InstanceRefKlass) \
 768   f(Method) \
 769   f(ObjArrayKlass) \
<span class="line-modified"> 770   f(TypeArrayKlass) \</span>
<span class="line-added"> 771   f(ValueArrayKlass) \</span>
<span class="line-added"> 772   f(ValueKlass)</span>
 773 
 774 class CppVtableInfo {
 775   intptr_t _vtable_size;
 776   intptr_t _cloned_vtable[1];
 777 public:
 778   static int num_slots(int vtable_size) {
 779     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 780   }
 781   int vtable_size()           { return int(uintx(_vtable_size)); }
 782   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 783   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 784   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 785   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 786   static size_t byte_size(int vtable_size) {
 787     CppVtableInfo i;
 788     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 789   }
 790 };
 791 
 792 template &lt;class T&gt; class CppVtableCloner : public T {
</pre>
<hr />
<pre>
 940   Arguments::assert_is_dumping_archive();
 941   int kind = -1;
 942   switch (msotype) {
 943   case MetaspaceObj::SymbolType:
 944   case MetaspaceObj::TypeArrayU1Type:
 945   case MetaspaceObj::TypeArrayU2Type:
 946   case MetaspaceObj::TypeArrayU4Type:
 947   case MetaspaceObj::TypeArrayU8Type:
 948   case MetaspaceObj::TypeArrayOtherType:
 949   case MetaspaceObj::ConstMethodType:
 950   case MetaspaceObj::ConstantPoolCacheType:
 951   case MetaspaceObj::AnnotationsType:
 952   case MetaspaceObj::MethodCountersType:
 953   case MetaspaceObj::RecordComponentType:
 954     // These have no vtables.
 955     break;
 956   case MetaspaceObj::ClassType:
 957     {
 958       Klass* k = (Klass*)obj;
 959       assert(k-&gt;is_klass(), &quot;must be&quot;);
<span class="line-modified"> 960       if (k-&gt;is_value()) {</span>
<span class="line-added"> 961         kind = ValueKlass_Kind;</span>
<span class="line-added"> 962       } else if (k-&gt;is_instance_klass()) {</span>
 963         InstanceKlass* ik = InstanceKlass::cast(k);
 964         if (ik-&gt;is_class_loader_instance_klass()) {
 965           kind = InstanceClassLoaderKlass_Kind;
 966         } else if (ik-&gt;is_reference_instance_klass()) {
 967           kind = InstanceRefKlass_Kind;
 968         } else if (ik-&gt;is_mirror_instance_klass()) {
 969           kind = InstanceMirrorKlass_Kind;
 970         } else {
 971           kind = InstanceKlass_Kind;
 972         }
 973       } else if (k-&gt;is_typeArray_klass()) {
 974         kind = TypeArrayKlass_Kind;
 975       } else {
 976         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
 977         kind = ObjArrayKlass_Kind;
 978       }
 979     }
 980     break;
 981 
 982   case MetaspaceObj::MethodType:
</pre>
<hr />
<pre>
1370     ShallowCopier(bool read_only) : _read_only(read_only) {}
1371 
1372     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1373       if (read_only == _read_only) {
1374         allocate(ref, read_only);
1375       }
1376       return true; // recurse into ref.obj()
1377     }
1378   };
1379 
1380   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1381   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1382   public:
1383     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1384       address new_loc = get_new_loc(ref);
1385       RefRelocator refer;
1386       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1387       return true; // recurse into ref.obj()
1388     }
1389     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
<span class="line-modified">1390       assert_valid(type);</span>
<span class="line-added">1391 </span>
1392       address obj = ref-&gt;obj();
1393       address new_obj = get_new_loc(ref);
1394       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1395       intptr_t* new_p = (intptr_t*)(new_obj + offset);
<span class="line-modified">1396       switch (type) {</span>
<span class="line-added">1397       case _method_entry_ref:</span>
<span class="line-added">1398         assert(*p == *new_p, &quot;must be a copy&quot;);</span>
<span class="line-added">1399         break;</span>
<span class="line-added">1400       case _internal_pointer_ref:</span>
<span class="line-added">1401         {</span>
<span class="line-added">1402           size_t off = pointer_delta(*((address*)p), obj, sizeof(u1));</span>
<span class="line-added">1403           assert(0 &lt;= intx(off) &amp;&amp; intx(off) &lt; ref-&gt;size() * BytesPerWord, &quot;must point to internal address&quot;);</span>
<span class="line-added">1404           *((address*)new_p) = new_obj + off;</span>
<span class="line-added">1405         }</span>
<span class="line-added">1406         break;</span>
<span class="line-added">1407       default:</span>
<span class="line-added">1408         ShouldNotReachHere();</span>
<span class="line-added">1409       }</span>
1410       ArchivePtrMarker::mark_pointer((address*)new_p);
1411     }
1412   };
1413 
1414   // Relocate a reference to point to its shallow copy
1415   class RefRelocator: public MetaspaceClosure {
1416   public:
1417     virtual bool do_ref(Ref* ref, bool read_only) {
1418       if (ref-&gt;not_null()) {
1419         ref-&gt;update(get_new_loc(ref));
1420         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1421       }
1422       return false; // Do not recurse.
1423     }
1424   };
1425 
1426 #ifdef ASSERT
1427   class IsRefInArchiveChecker: public MetaspaceClosure {
1428   public:
1429     virtual bool do_ref(Ref* ref, bool read_only) {
</pre>
</td>
</tr>
</table>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
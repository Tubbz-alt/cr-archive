<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  56   f(java_lang_invoke_MethodType) \
  57   f(java_lang_invoke_CallSite) \
  58   f(java_lang_invoke_ConstantCallSite) \
  59   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  60   f(java_security_AccessControlContext) \
  61   f(java_lang_reflect_AccessibleObject) \
  62   f(java_lang_reflect_Method) \
  63   f(java_lang_reflect_Constructor) \
  64   f(java_lang_reflect_Field) \
  65   f(java_lang_reflect_RecordComponent) \
  66   f(java_nio_Buffer) \
  67   f(reflect_ConstantPool) \
  68   f(reflect_UnsafeStaticFieldAccessorImpl) \
  69   f(java_lang_reflect_Parameter) \
  70   f(java_lang_Module) \
  71   f(java_lang_StackTraceElement) \
  72   f(java_lang_StackFrameInfo) \
  73   f(java_lang_LiveStackFrameInfo) \
  74   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  75   f(jdk_internal_misc_UnsafeConstants) \

  76   f(java_lang_boxing_object) \
  77   //end
  78 
  79 #define BASIC_JAVA_CLASSES_DO(f) \
  80         BASIC_JAVA_CLASSES_DO_PART1(f) \
  81         BASIC_JAVA_CLASSES_DO_PART2(f)
  82 
  83 #define CHECK_INIT(offset)  assert(offset != 0, &quot;should be initialized&quot;); return offset;
  84 
  85 // Interface to java.lang.Object objects
  86 
  87 class java_lang_Object : AllStatic {
  88  public:
  89   static void register_natives(TRAPS);
  90 };
  91 
  92 // Interface to java.lang.String objects
  93 
  94 class java_lang_String : AllStatic {
  95  private:
</pre>
<hr />
<pre>
 225   friend class JVMCIVMStructs;
 226 
 227  private:
 228 
 229   // The fake offsets are added by the class loader when java.lang.Class is loaded
 230 
 231   static int _klass_offset;
 232   static int _array_klass_offset;
 233 
 234   static int _oop_size_offset;
 235   static int _static_oop_field_count_offset;
 236 
 237   static int _protection_domain_offset;
 238   static int _init_lock_offset;
 239   static int _signers_offset;
 240   static int _class_loader_offset;
 241   static int _module_offset;
 242   static int _component_mirror_offset;
 243   static int _name_offset;
 244   static int _source_file_offset;


 245   static int _classData_offset;
 246   static int _classRedefinedCount_offset;
 247 
 248   static bool _offsets_computed;
 249 
 250   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 251   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 252 
 253   static void set_init_lock(oop java_class, oop init_lock);
 254   static void set_protection_domain(oop java_class, oop protection_domain);
 255   static void set_class_loader(oop java_class, oop class_loader);
 256   static void set_component_mirror(oop java_class, oop comp_mirror);
 257   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
 258                                        Handle classData, TRAPS);
 259   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 260  public:
 261   static void allocate_fixup_lists();
 262   static void compute_offsets();
 263 
 264   // Instance creation
</pre>
<hr />
<pre>
 284   // Conversion
 285   static Klass* as_Klass(oop java_class);
 286   static Klass* as_Klass_raw(oop java_class);
 287   static void set_klass(oop java_class, Klass* klass);
 288   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 289   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 290   static void print_signature(oop java_class, outputStream *st);
 291   static const char* as_external_name(oop java_class);
 292   // Testing
 293   static bool is_instance(oop obj);
 294 
 295   static bool is_primitive(oop java_class);
 296   static BasicType primitive_type(oop java_class);
 297   static oop primitive_mirror(BasicType t);
 298   // JVM_NewArray support
 299   static Klass* array_klass_acquire(oop java_class);
 300   static void release_set_array_klass(oop java_class, Klass* klass);
 301   // compiler support for class operations
 302   static int klass_offset()                { CHECK_INIT(_klass_offset); }
 303   static int array_klass_offset()          { CHECK_INIT(_array_klass_offset); }

 304   // Support for classRedefinedCount field
 305   static int classRedefinedCount(oop the_class_mirror);
 306   static void set_classRedefinedCount(oop the_class_mirror, int value);
 307 
 308   // Support for embedded per-class oops
 309   static oop  protection_domain(oop java_class);
 310   static oop  init_lock(oop java_class);
 311   static void clear_init_lock(oop java_class) {
 312     set_init_lock(java_class, NULL);
 313   }
 314   static oop  component_mirror(oop java_class);
 315   static objArrayOop  signers(oop java_class);
 316   static void set_signers(oop java_class, objArrayOop signers);
 317   static oop  class_data(oop java_class);
 318   static void set_class_data(oop java_class, oop classData);
 319 
 320   static oop class_loader(oop java_class);
 321   static void set_module(oop java_class, oop module);
 322   static oop module(oop java_class);
 323 






 324   static oop name(Handle java_class, TRAPS);
 325 
 326   static oop source_file(oop java_class);
 327   static void set_source_file(oop java_class, oop source_file);
 328 
 329   static int oop_size(oop java_class);
 330   static int oop_size_raw(oop java_class);
 331   static void set_oop_size(HeapWord* java_class, int size);
 332   static int static_oop_field_count(oop java_class);
 333   static int static_oop_field_count_raw(oop java_class);
 334   static void set_static_oop_field_count(oop java_class, int size);
 335 
 336   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 337     return _fixup_mirror_list;
 338   }
 339   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 340     _fixup_mirror_list = v;
 341   }
 342 
 343   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
</pre>
<hr />
<pre>
1100   static void       set_flags(oop mname, int flags);
1101 
1102   // Link through ResolvedMethodName field to get Method*
1103   static Method*        vmtarget(oop mname);
1104   static void       set_method(oop mname, oop method);
1105 
1106   static intptr_t       vmindex(oop mname);
1107   static void       set_vmindex(oop mname, intptr_t index);
1108 
1109   // Testers
1110   static bool is_subclass(Klass* klass) {
1111     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1112   }
1113   static bool is_instance(oop obj);
1114 
1115   static bool is_method(oop obj);
1116 
1117   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1118   enum {
1119     MN_IS_METHOD             = 0x00010000, // method (not constructor)
<span class="line-modified">1120     MN_IS_CONSTRUCTOR        = 0x00020000, // constructor</span>
1121     MN_IS_FIELD              = 0x00040000, // field
1122     MN_IS_TYPE               = 0x00080000, // nested type
1123     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1124     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1125     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1126     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1127     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
1128     MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces
1129     MN_NESTMATE_CLASS        = 0x00000001,
1130     MN_HIDDEN_CLASS          = 0x00000002,
1131     MN_STRONG_LOADER_LINK    = 0x00000004,
1132     MN_ACCESS_VM_ANNOTATIONS = 0x00000008
1133   };
1134 
1135   // Accessors for code generation:
1136   static int clazz_offset()   { CHECK_INIT(_clazz_offset); }
1137   static int type_offset()    { CHECK_INIT(_type_offset); }
1138   static int flags_offset()   { CHECK_INIT(_flags_offset); }
1139   static int method_offset()  { CHECK_INIT(_method_offset); }
1140   static int vmindex_offset() { CHECK_INIT(_vmindex_offset); }
</pre>
<hr />
<pre>
1624 class java_lang_Short_ShortCache : AllStatic {
1625  private:
1626   static int _static_cache_offset;
1627  public:
1628   static Symbol* symbol();
1629   static void compute_offsets(InstanceKlass* k);
1630   static objArrayOop  cache(InstanceKlass *k);
1631   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1632 };
1633 
1634 class java_lang_Byte_ByteCache : AllStatic {
1635  private:
1636   static int _static_cache_offset;
1637  public:
1638   static Symbol* symbol();
1639   static void compute_offsets(InstanceKlass* k);
1640   static objArrayOop  cache(InstanceKlass *k);
1641   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1642 };
1643 
























1644 // Use to declare fields that need to be injected into Java classes
1645 // for the JVM to use.  The name_index and signature_index are
1646 // declared in vmSymbols.  The may_be_java flag is used to declare
1647 // fields that might already exist in Java but should be injected if
1648 // they don&#39;t.  Otherwise the field is unconditionally injected and
1649 // the JVM uses the injected one.  This is to ensure that name
1650 // collisions don&#39;t occur.  In general may_be_java should be false
1651 // unless there&#39;s a good reason.
1652 
1653 class InjectedField {
1654  public:
1655   const SystemDictionary::WKID klass_id;
1656   const vmSymbols::SID name_index;
1657   const vmSymbols::SID signature_index;
1658   const bool           may_be_java;
1659 
1660 
1661   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1662   Symbol* name() const      { return lookup_symbol(name_index); }
1663   Symbol* signature() const { return lookup_symbol(signature_index); }
</pre>
</td>
<td>
<hr />
<pre>
  56   f(java_lang_invoke_MethodType) \
  57   f(java_lang_invoke_CallSite) \
  58   f(java_lang_invoke_ConstantCallSite) \
  59   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  60   f(java_security_AccessControlContext) \
  61   f(java_lang_reflect_AccessibleObject) \
  62   f(java_lang_reflect_Method) \
  63   f(java_lang_reflect_Constructor) \
  64   f(java_lang_reflect_Field) \
  65   f(java_lang_reflect_RecordComponent) \
  66   f(java_nio_Buffer) \
  67   f(reflect_ConstantPool) \
  68   f(reflect_UnsafeStaticFieldAccessorImpl) \
  69   f(java_lang_reflect_Parameter) \
  70   f(java_lang_Module) \
  71   f(java_lang_StackTraceElement) \
  72   f(java_lang_StackFrameInfo) \
  73   f(java_lang_LiveStackFrameInfo) \
  74   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  75   f(jdk_internal_misc_UnsafeConstants) \
<span class="line-added">  76   f(jdk_internal_vm_jni_SubElementSelector) \</span>
  77   f(java_lang_boxing_object) \
  78   //end
  79 
  80 #define BASIC_JAVA_CLASSES_DO(f) \
  81         BASIC_JAVA_CLASSES_DO_PART1(f) \
  82         BASIC_JAVA_CLASSES_DO_PART2(f)
  83 
  84 #define CHECK_INIT(offset)  assert(offset != 0, &quot;should be initialized&quot;); return offset;
  85 
  86 // Interface to java.lang.Object objects
  87 
  88 class java_lang_Object : AllStatic {
  89  public:
  90   static void register_natives(TRAPS);
  91 };
  92 
  93 // Interface to java.lang.String objects
  94 
  95 class java_lang_String : AllStatic {
  96  private:
</pre>
<hr />
<pre>
 226   friend class JVMCIVMStructs;
 227 
 228  private:
 229 
 230   // The fake offsets are added by the class loader when java.lang.Class is loaded
 231 
 232   static int _klass_offset;
 233   static int _array_klass_offset;
 234 
 235   static int _oop_size_offset;
 236   static int _static_oop_field_count_offset;
 237 
 238   static int _protection_domain_offset;
 239   static int _init_lock_offset;
 240   static int _signers_offset;
 241   static int _class_loader_offset;
 242   static int _module_offset;
 243   static int _component_mirror_offset;
 244   static int _name_offset;
 245   static int _source_file_offset;
<span class="line-added"> 246   static int _val_type_mirror_offset;</span>
<span class="line-added"> 247   static int _ref_type_mirror_offset;</span>
 248   static int _classData_offset;
 249   static int _classRedefinedCount_offset;
 250 
 251   static bool _offsets_computed;
 252 
 253   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 254   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 255 
 256   static void set_init_lock(oop java_class, oop init_lock);
 257   static void set_protection_domain(oop java_class, oop protection_domain);
 258   static void set_class_loader(oop java_class, oop class_loader);
 259   static void set_component_mirror(oop java_class, oop comp_mirror);
 260   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
 261                                        Handle classData, TRAPS);
 262   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 263  public:
 264   static void allocate_fixup_lists();
 265   static void compute_offsets();
 266 
 267   // Instance creation
</pre>
<hr />
<pre>
 287   // Conversion
 288   static Klass* as_Klass(oop java_class);
 289   static Klass* as_Klass_raw(oop java_class);
 290   static void set_klass(oop java_class, Klass* klass);
 291   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 292   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 293   static void print_signature(oop java_class, outputStream *st);
 294   static const char* as_external_name(oop java_class);
 295   // Testing
 296   static bool is_instance(oop obj);
 297 
 298   static bool is_primitive(oop java_class);
 299   static BasicType primitive_type(oop java_class);
 300   static oop primitive_mirror(BasicType t);
 301   // JVM_NewArray support
 302   static Klass* array_klass_acquire(oop java_class);
 303   static void release_set_array_klass(oop java_class, Klass* klass);
 304   // compiler support for class operations
 305   static int klass_offset()                { CHECK_INIT(_klass_offset); }
 306   static int array_klass_offset()          { CHECK_INIT(_array_klass_offset); }
<span class="line-added"> 307   static int component_mirror_offset()     { CHECK_INIT(_component_mirror_offset); }</span>
 308   // Support for classRedefinedCount field
 309   static int classRedefinedCount(oop the_class_mirror);
 310   static void set_classRedefinedCount(oop the_class_mirror, int value);
 311 
 312   // Support for embedded per-class oops
 313   static oop  protection_domain(oop java_class);
 314   static oop  init_lock(oop java_class);
 315   static void clear_init_lock(oop java_class) {
 316     set_init_lock(java_class, NULL);
 317   }
 318   static oop  component_mirror(oop java_class);
 319   static objArrayOop  signers(oop java_class);
 320   static void set_signers(oop java_class, objArrayOop signers);
 321   static oop  class_data(oop java_class);
 322   static void set_class_data(oop java_class, oop classData);
 323 
 324   static oop class_loader(oop java_class);
 325   static void set_module(oop java_class, oop module);
 326   static oop module(oop java_class);
 327 
<span class="line-added"> 328   static void set_ref_type_mirror(oop java_class, oop mirror);</span>
<span class="line-added"> 329   static oop ref_type_mirror(oop java_class);</span>
<span class="line-added"> 330 </span>
<span class="line-added"> 331   static void set_val_type_mirror(oop java_class, oop mirror);</span>
<span class="line-added"> 332   static oop val_type_mirror(oop java_class);</span>
<span class="line-added"> 333 </span>
 334   static oop name(Handle java_class, TRAPS);
 335 
 336   static oop source_file(oop java_class);
 337   static void set_source_file(oop java_class, oop source_file);
 338 
 339   static int oop_size(oop java_class);
 340   static int oop_size_raw(oop java_class);
 341   static void set_oop_size(HeapWord* java_class, int size);
 342   static int static_oop_field_count(oop java_class);
 343   static int static_oop_field_count_raw(oop java_class);
 344   static void set_static_oop_field_count(oop java_class, int size);
 345 
 346   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 347     return _fixup_mirror_list;
 348   }
 349   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 350     _fixup_mirror_list = v;
 351   }
 352 
 353   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
</pre>
<hr />
<pre>
1110   static void       set_flags(oop mname, int flags);
1111 
1112   // Link through ResolvedMethodName field to get Method*
1113   static Method*        vmtarget(oop mname);
1114   static void       set_method(oop mname, oop method);
1115 
1116   static intptr_t       vmindex(oop mname);
1117   static void       set_vmindex(oop mname, intptr_t index);
1118 
1119   // Testers
1120   static bool is_subclass(Klass* klass) {
1121     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1122   }
1123   static bool is_instance(oop obj);
1124 
1125   static bool is_method(oop obj);
1126 
1127   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1128   enum {
1129     MN_IS_METHOD             = 0x00010000, // method (not constructor)
<span class="line-modified">1130     MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, // constructor</span>
1131     MN_IS_FIELD              = 0x00040000, // field
1132     MN_IS_TYPE               = 0x00080000, // nested type
1133     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1134     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1135     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1136     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1137     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
1138     MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces
1139     MN_NESTMATE_CLASS        = 0x00000001,
1140     MN_HIDDEN_CLASS          = 0x00000002,
1141     MN_STRONG_LOADER_LINK    = 0x00000004,
1142     MN_ACCESS_VM_ANNOTATIONS = 0x00000008
1143   };
1144 
1145   // Accessors for code generation:
1146   static int clazz_offset()   { CHECK_INIT(_clazz_offset); }
1147   static int type_offset()    { CHECK_INIT(_type_offset); }
1148   static int flags_offset()   { CHECK_INIT(_flags_offset); }
1149   static int method_offset()  { CHECK_INIT(_method_offset); }
1150   static int vmindex_offset() { CHECK_INIT(_vmindex_offset); }
</pre>
<hr />
<pre>
1634 class java_lang_Short_ShortCache : AllStatic {
1635  private:
1636   static int _static_cache_offset;
1637  public:
1638   static Symbol* symbol();
1639   static void compute_offsets(InstanceKlass* k);
1640   static objArrayOop  cache(InstanceKlass *k);
1641   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1642 };
1643 
1644 class java_lang_Byte_ByteCache : AllStatic {
1645  private:
1646   static int _static_cache_offset;
1647  public:
1648   static Symbol* symbol();
1649   static void compute_offsets(InstanceKlass* k);
1650   static objArrayOop  cache(InstanceKlass *k);
1651   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1652 };
1653 
<span class="line-added">1654 class jdk_internal_vm_jni_SubElementSelector : AllStatic {</span>
<span class="line-added">1655  private:</span>
<span class="line-added">1656   static int _arrayElementType_offset;</span>
<span class="line-added">1657   static int _subElementType_offset;</span>
<span class="line-added">1658   static int _offset_offset;</span>
<span class="line-added">1659   static int _isFlattened_offset;</span>
<span class="line-added">1660   static int _isFlattenable_offset;</span>
<span class="line-added">1661  public:</span>
<span class="line-added">1662   static Symbol* symbol();</span>
<span class="line-added">1663   static void compute_offsets();</span>
<span class="line-added">1664   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1665 </span>
<span class="line-added">1666   static oop getArrayElementType(oop obj);</span>
<span class="line-added">1667   static void setArrayElementType(oop obj, oop type);</span>
<span class="line-added">1668   static oop getSubElementType(oop obj);</span>
<span class="line-added">1669   static void setSubElementType(oop obj, oop type);</span>
<span class="line-added">1670   static int getOffset(oop obj);</span>
<span class="line-added">1671   static void setOffset(oop obj, int offset);</span>
<span class="line-added">1672   static bool getIsFlattened(oop obj);</span>
<span class="line-added">1673   static void setIsFlattened(oop obj, bool b);</span>
<span class="line-added">1674   static bool getIsFlattenable(oop obj);</span>
<span class="line-added">1675   static void setIsFlattenable(oop obj, bool b);</span>
<span class="line-added">1676 };</span>
<span class="line-added">1677 </span>
1678 // Use to declare fields that need to be injected into Java classes
1679 // for the JVM to use.  The name_index and signature_index are
1680 // declared in vmSymbols.  The may_be_java flag is used to declare
1681 // fields that might already exist in Java but should be injected if
1682 // they don&#39;t.  Otherwise the field is unconditionally injected and
1683 // the JVM uses the injected one.  This is to ensure that name
1684 // collisions don&#39;t occur.  In general may_be_java should be false
1685 // unless there&#39;s a good reason.
1686 
1687 class InjectedField {
1688  public:
1689   const SystemDictionary::WKID klass_id;
1690   const vmSymbols::SID name_index;
1691   const vmSymbols::SID signature_index;
1692   const bool           may_be_java;
1693 
1694 
1695   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1696   Symbol* name() const      { return lookup_symbol(name_index); }
1697   Symbol* signature() const { return lookup_symbol(signature_index); }
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
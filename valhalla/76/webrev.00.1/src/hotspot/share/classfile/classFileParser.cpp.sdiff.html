<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciInstanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */

  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/packageEntry.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/verificationType.hpp&quot;
  40 #include &quot;classfile/verifier.hpp&quot;
  41 #include &quot;classfile/vmSymbols.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/annotations.hpp&quot;
  50 #include &quot;oops/constantPool.inline.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  54 #include &quot;oops/klass.inline.hpp&quot;
  55 #include &quot;oops/klassVtable.hpp&quot;
  56 #include &quot;oops/metadata.hpp&quot;
  57 #include &quot;oops/method.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/recordComponent.hpp&quot;
  60 #include &quot;oops/symbol.hpp&quot;

  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/os.hpp&quot;
  68 #include &quot;runtime/perfData.hpp&quot;
  69 #include &quot;runtime/reflection.hpp&quot;
  70 #include &quot;runtime/safepointVerifiers.hpp&quot;
  71 #include &quot;runtime/signature.hpp&quot;
  72 #include &quot;runtime/timer.hpp&quot;
  73 #include &quot;services/classLoadingService.hpp&quot;
  74 #include &quot;services/threadService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/bitMap.inline.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/exceptions.hpp&quot;
  79 #include &quot;utilities/globalDefinitions.hpp&quot;
  80 #include &quot;utilities/growableArray.hpp&quot;
  81 #include &quot;utilities/macros.hpp&quot;
  82 #include &quot;utilities/ostream.hpp&quot;
  83 #include &quot;utilities/resourceHash.hpp&quot;

  84 #include &quot;utilities/utf8.hpp&quot;
  85 
  86 #if INCLUDE_CDS
  87 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  88 #endif
  89 #if INCLUDE_JFR
  90 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  91 #endif
  92 
  93 // We generally try to create the oops directly when parsing, rather than
  94 // allocating temporary data structures and copying the bytes twice. A
  95 // temporary area is only needed when parsing utf8 entries in the constant
  96 // pool and when parsing line number tables.
  97 
  98 // We add assert in debug mode when class format is not checked.
  99 
 100 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 101 #define JAVA_MIN_SUPPORTED_VERSION        45
 102 #define JAVA_PREVIEW_MINOR_VERSION        65535
 103 
</pre>
<hr />
<pre>
 115 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 116 #define JAVA_7_VERSION                    51
 117 
 118 // Extension method support.
 119 #define JAVA_8_VERSION                    52
 120 
 121 #define JAVA_9_VERSION                    53
 122 
 123 #define JAVA_10_VERSION                   54
 124 
 125 #define JAVA_11_VERSION                   55
 126 
 127 #define JAVA_12_VERSION                   56
 128 
 129 #define JAVA_13_VERSION                   57
 130 
 131 #define JAVA_14_VERSION                   58
 132 
 133 #define JAVA_15_VERSION                   59
 134 


 135 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 136   assert((bad_constant == JVM_CONSTANT_Module ||
 137           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 138          &quot;Unexpected bad constant pool entry&quot;);
 139   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 140 }
 141 
 142 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 143                                                   ConstantPool* cp,
 144                                                   const int length,
 145                                                   TRAPS) {
 146   assert(stream != NULL, &quot;invariant&quot;);
 147   assert(cp != NULL, &quot;invariant&quot;);
 148 
 149   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 150   // this function (_current can be allocated in a register, with scalar
 151   // replacement of aggregates). The _current pointer is copied back to
 152   // stream() when this function returns. DON&#39;T call another method within
 153   // this method that uses stream().
 154   const ClassFileStream cfs1 = *stream;
 155   const ClassFileStream* const cfs = &amp;cfs1;
 156 
 157   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 158   debug_only(const u1* const old_current = stream-&gt;current();)
 159 
 160   // Used for batching symbol allocations.
 161   const char* names[SymbolTable::symbol_alloc_batch_size];
 162   int lengths[SymbolTable::symbol_alloc_batch_size];
 163   int indices[SymbolTable::symbol_alloc_batch_size];
 164   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 165   int names_count = 0;
 166 
 167   // parsing  Index 0 is unused
 168   for (int index = 1; index &lt; length; index++) {
 169     // Each of the following case guarantees one more byte in the stream
 170     // for the following tag or the access_flags following constant pool,
 171     // so we don&#39;t need bounds-check for reading tag.
 172     const u1 tag = cfs-&gt;get_u1_fast();
 173     switch (tag) {
<span class="line-modified"> 174       case JVM_CONSTANT_Class : {</span>
 175         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 176         const u2 name_index = cfs-&gt;get_u2_fast();
 177         cp-&gt;klass_index_at_put(index, name_index);
 178         break;
 179       }
 180       case JVM_CONSTANT_Fieldref: {
 181         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 182         const u2 class_index = cfs-&gt;get_u2_fast();
 183         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 184         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 185         break;
 186       }
 187       case JVM_CONSTANT_Methodref: {
 188         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 189         const u2 class_index = cfs-&gt;get_u2_fast();
 190         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 191         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 192         break;
 193       }
 194       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 484         check_property(valid_symbol_at(name_ref_index),
 485           &quot;Invalid constant pool index %u in class file %s&quot;,
 486           name_ref_index, CHECK);
 487         check_property(valid_symbol_at(signature_ref_index),
 488           &quot;Invalid constant pool index %u in class file %s&quot;,
 489           signature_ref_index, CHECK);
 490         break;
 491       }
 492       case JVM_CONSTANT_Utf8:
 493         break;
 494       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 495       case JVM_CONSTANT_UnresolvedClassInError: {
 496         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 497         break;
 498       }
 499       case JVM_CONSTANT_ClassIndex: {
 500         const int class_index = cp-&gt;klass_index_at(index);
 501         check_property(valid_symbol_at(class_index),
 502           &quot;Invalid constant pool index %u in class file %s&quot;,
 503           class_index, CHECK);
<span class="line-modified"> 504         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>







 505         break;
 506       }
 507       case JVM_CONSTANT_StringIndex: {
 508         const int string_index = cp-&gt;string_index_at(index);
 509         check_property(valid_symbol_at(string_index),
 510           &quot;Invalid constant pool index %u in class file %s&quot;,
 511           string_index, CHECK);
 512         Symbol* const sym = cp-&gt;symbol_at(string_index);
 513         cp-&gt;unresolved_string_at_put(index, sym);
 514         break;
 515       }
 516       case JVM_CONSTANT_MethodHandle: {
 517         const int ref_index = cp-&gt;method_handle_index_at(index);
 518         check_property(valid_cp_range(ref_index, length),
 519           &quot;Invalid constant pool index %u in class file %s&quot;,
 520           ref_index, CHECK);
 521         const constantTag tag = cp-&gt;tag_at(ref_index);
 522         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 523 
 524         switch (ref_kind) {
</pre>
<hr />
<pre>
 738             classfile_parse_error(
 739               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 740               name_ref_index, CHECK);
 741           }
 742         }
 743         break;
 744       }
 745       case JVM_CONSTANT_MethodHandle: {
 746         const int ref_index = cp-&gt;method_handle_index_at(index);
 747         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 748         switch (ref_kind) {
 749           case JVM_REF_invokeVirtual:
 750           case JVM_REF_invokeStatic:
 751           case JVM_REF_invokeSpecial:
 752           case JVM_REF_newInvokeSpecial: {
 753             const int name_and_type_ref_index =
 754               cp-&gt;name_and_type_ref_index_at(ref_index);
 755             const int name_ref_index =
 756               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 757             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 758             if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-modified"> 759               if (name != vmSymbols::object_initializer_name()) {</span>
 760                 classfile_parse_error(
 761                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 762                     name_ref_index, CHECK);
 763               }
 764             } else {
<span class="line-modified"> 765               if (name == vmSymbols::object_initializer_name()) {</span>











 766                 classfile_parse_error(
 767                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 768                   name_ref_index, CHECK);
 769               }
 770             }
 771             break;
 772           }
 773           // Other ref_kinds are already fully checked in previous pass.
 774         } // switch(ref_kind)
 775         break;
 776       }
 777       case JVM_CONSTANT_MethodType: {
 778         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 779         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 780         verify_legal_method_signature(no_name, signature, CHECK);
 781         break;
 782       }
 783       case JVM_CONSTANT_Utf8: {
 784         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 785       }
</pre>
<hr />
<pre>
 904   while (entry != NULL) {
 905     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 906       return false;
 907     }
 908     entry = entry-&gt;_next;
 909   }
 910 
 911   // No duplicate is found, allocate a new entry and fill it.
 912   entry = new NameSigHash();
 913   entry-&gt;_name = name;
 914   entry-&gt;_sig = sig;
 915 
 916   // Insert into hash table
 917   entry-&gt;_next = table[index];
 918   table[index] = entry;
 919 
 920   return true;
 921 }
 922 
 923 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 924 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified"> 925                                        const int itfs_len,</span>
<span class="line-modified"> 926                                        ConstantPool* const cp,</span>

 927                                        bool* const has_nonstatic_concrete_methods,







 928                                        TRAPS) {
 929   assert(stream != NULL, &quot;invariant&quot;);
 930   assert(cp != NULL, &quot;invariant&quot;);
 931   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 932 
 933   if (itfs_len == 0) {
<span class="line-modified"> 934     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
 935   } else {
 936     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 937     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-modified"> 938 </span>
<span class="line-removed"> 939     int index;</span>
 940     for (index = 0; index &lt; itfs_len; index++) {
 941       const u2 interface_index = stream-&gt;get_u2(CHECK);
 942       Klass* interf;
 943       check_property(
 944         valid_klass_reference_at(interface_index),
 945         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 946         interface_index, CHECK);
 947       if (cp-&gt;tag_at(interface_index).is_klass()) {
 948         interf = cp-&gt;resolved_klass_at(interface_index);
 949       } else {
 950         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 951 
 952         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 953         // But need to make sure it&#39;s not an array type.
 954         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 955                            &quot;Bad interface name in class file %s&quot;, CHECK);
 956 
<span class="line-modified"> 957         // Call resolve_super so classcircularity is checked</span>
 958         interf = SystemDictionary::resolve_super_or_fail(
 959                                                   _class_name,
 960                                                   unresolved_klass,
 961                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 962                                                   _protection_domain,
 963                                                   false,
 964                                                   CHECK);
 965       }
 966 
 967       if (!interf-&gt;is_interface()) {
 968         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 969                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 970                           _class_name-&gt;as_klass_external_name(),
 971                           interf-&gt;external_name(),
 972                           interf-&gt;class_in_module_of_loader()));
 973       }
 974 
<span class="line-modified"> 975       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>













 976         *has_nonstatic_concrete_methods = true;
 977       }
<span class="line-modified"> 978       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>






 979     }
 980 
 981     if (!_need_verify || itfs_len &lt;= 1) {
 982       return;
 983     }
 984 
 985     // Check if there&#39;s any duplicates in interfaces
 986     ResourceMark rm(THREAD);
 987     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 988                                                                  NameSigHash*,
 989                                                                  HASH_ROW_SIZE);
 990     initialize_hashtable(interface_names);
 991     bool dup = false;
 992     const Symbol* name = NULL;
 993     {
 994       debug_only(NoSafepointVerifier nsv;)
 995       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified"> 996         const InstanceKlass* const k = _local_interfaces-&gt;at(index);</span>
 997         name = k-&gt;name();
 998         // If no duplicates, add (name, NULL) in hashtable interface_names.
 999         if (!put_after_lookup(name, NULL, interface_names)) {
1000           dup = true;
1001           break;
1002         }
1003       }
1004     }
1005     if (dup) {
1006       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1007                              name-&gt;as_C_string(), CHECK);
1008     }
1009   }
1010 }
1011 
1012 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1013                                            int constantvalue_index,
1014                                            int signature_index,
1015                                            TRAPS) const {
1016   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1452                                             CHECK);
1453   parsed_annotations-&gt;set_field_annotations(a);
1454   a = assemble_annotations(runtime_visible_type_annotations,
1455                            runtime_visible_type_annotations_length,
1456                            runtime_invisible_type_annotations,
1457                            runtime_invisible_type_annotations_length,
1458                            CHECK);
1459   parsed_annotations-&gt;set_field_type_annotations(a);
1460   return;
1461 }
1462 
1463 
1464 // Field allocation types. Used for computing field offsets.
1465 
1466 enum FieldAllocationType {
1467   STATIC_OOP,           // Oops
1468   STATIC_BYTE,          // Boolean, Byte, char
1469   STATIC_SHORT,         // shorts
1470   STATIC_WORD,          // ints
1471   STATIC_DOUBLE,        // aligned long or double

1472   NONSTATIC_OOP,
1473   NONSTATIC_BYTE,
1474   NONSTATIC_SHORT,
1475   NONSTATIC_WORD,
1476   NONSTATIC_DOUBLE,

1477   MAX_FIELD_ALLOCATION_TYPE,
1478   BAD_ALLOCATION_TYPE = -1
1479 };
1480 
1481 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1482   BAD_ALLOCATION_TYPE, // 0
1483   BAD_ALLOCATION_TYPE, // 1
1484   BAD_ALLOCATION_TYPE, // 2
1485   BAD_ALLOCATION_TYPE, // 3
1486   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1487   NONSTATIC_SHORT,     // T_CHAR        =  5,
1488   NONSTATIC_WORD,      // T_FLOAT       =  6,
1489   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1490   NONSTATIC_BYTE,      // T_BYTE        =  8,
1491   NONSTATIC_SHORT,     // T_SHORT       =  9,
1492   NONSTATIC_WORD,      // T_INT         = 10,
1493   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1494   NONSTATIC_OOP,       // T_OBJECT      = 12,
1495   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1496   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1497   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1498   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1499   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1500   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1501   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1502   BAD_ALLOCATION_TYPE, // 0
1503   BAD_ALLOCATION_TYPE, // 1
1504   BAD_ALLOCATION_TYPE, // 2
1505   BAD_ALLOCATION_TYPE, // 3
1506   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1507   STATIC_SHORT,        // T_CHAR        =  5,
1508   STATIC_WORD,         // T_FLOAT       =  6,
1509   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1510   STATIC_BYTE,         // T_BYTE        =  8,
1511   STATIC_SHORT,        // T_SHORT       =  9,
1512   STATIC_WORD,         // T_INT         = 10,
1513   STATIC_DOUBLE,       // T_LONG        = 11,
1514   STATIC_OOP,          // T_OBJECT      = 12,
1515   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1516   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1517   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1518   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1519   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1520   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1521   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1522 };
1523 
<span class="line-modified">1524 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {</span>
1525   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1526   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1527   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);



1528   return result;
1529 }
1530 
1531 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1532  public:
1533   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1534 
1535   FieldAllocationCount() {
1536     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1537       count[i] = 0;
1538     }
1539   }
1540 
<span class="line-modified">1541   FieldAllocationType update(bool is_static, BasicType type) {</span>
<span class="line-modified">1542     FieldAllocationType atype = basic_type_to_atype(is_static, type);</span>
1543     if (atype != BAD_ALLOCATION_TYPE) {
1544       // Make sure there is no overflow with injected fields.
1545       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1546       count[atype]++;
1547     }
1548     return atype;
1549   }
1550 };
1551 
1552 // Side-effects: populates the _fields, _fields_annotations,
1553 // _fields_type_annotations fields
1554 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1555                                    bool is_interface,

1556                                    FieldAllocationCount* const fac,
1557                                    ConstantPool* cp,
1558                                    const int cp_size,
1559                                    u2* const java_fields_count_ptr,
1560                                    TRAPS) {
1561 
1562   assert(cfs != NULL, &quot;invariant&quot;);
1563   assert(fac != NULL, &quot;invariant&quot;);
1564   assert(cp != NULL, &quot;invariant&quot;);
1565   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1566 
1567   assert(NULL == _fields, &quot;invariant&quot;);
1568   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1569   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1570 
1571   cfs-&gt;guarantee_more(2, CHECK);  // length
1572   const u2 length = cfs-&gt;get_u2_fast();
1573   *java_fields_count_ptr = length;
1574 
1575   int num_injected = 0;
1576   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1577                                                                   &amp;num_injected);
<span class="line-modified">1578   const int total_fields = length + num_injected;</span>




1579 
1580   // The field array starts with tuples of shorts
1581   // [access, name index, sig index, initial value index, byte offset].
1582   // A generic signature slot only exists for field with generic
1583   // signature attribute. And the access flag is set with
1584   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1585   // signature slots are at the end of the field array and after all
1586   // other fields data.
1587   //
1588   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1589   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1590   //       ...
1591   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1592   //       [generic signature index]
1593   //       [generic signature index]
1594   //       ...
1595   //
1596   // Allocate a temporary resource array for field data. For each field,
1597   // a slot is reserved in the temporary array for the generic signature
1598   // index. After parsing all fields, the data are copied to a permanent
1599   // array and any unused slots will be discarded.
1600   ResourceMark rm(THREAD);
1601   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1602                                               u2,
1603                                               total_fields * (FieldInfo::field_slots + 1));
1604 
1605   // The generic signature slots start after all other fields&#39; data.
1606   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1607   int num_generic_signature = 0;

1608   for (int n = 0; n &lt; length; n++) {
1609     // access_flags, name_index, descriptor_index, attributes_count
1610     cfs-&gt;guarantee_more(8, CHECK);
1611 




1612     AccessFlags access_flags;
<span class="line-removed">1613     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-removed">1614     verify_legal_field_modifiers(flags, is_interface, CHECK);</span>
1615     access_flags.set_flags(flags);
1616 
1617     const u2 name_index = cfs-&gt;get_u2_fast();
1618     check_property(valid_symbol_at(name_index),
1619       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1620       name_index, CHECK);
1621     const Symbol* const name = cp-&gt;symbol_at(name_index);
1622     verify_legal_field_name(name, CHECK);
1623 
1624     const u2 signature_index = cfs-&gt;get_u2_fast();
1625     check_property(valid_symbol_at(signature_index),
1626       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1627       signature_index, CHECK);
1628     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1629     verify_legal_field_signature(name, sig, CHECK);

















1630 
1631     u2 constantvalue_index = 0;
1632     bool is_synthetic = false;
1633     u2 generic_signature_index = 0;
1634     const bool is_static = access_flags.is_static();
1635     FieldAnnotationCollector parsed_annotations(_loader_data);
1636 
1637     const u2 attributes_count = cfs-&gt;get_u2_fast();
1638     if (attributes_count &gt; 0) {
1639       parse_field_attributes(cfs,
1640                              attributes_count,
1641                              is_static,
1642                              signature_index,
1643                              &amp;constantvalue_index,
1644                              &amp;is_synthetic,
1645                              &amp;generic_signature_index,
1646                              &amp;parsed_annotations,
1647                              CHECK);
1648 
1649       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1669 
1670       if (is_synthetic) {
1671         access_flags.set_is_synthetic();
1672       }
1673       if (generic_signature_index != 0) {
1674         access_flags.set_field_has_generic_signature();
1675         fa[generic_signature_slot] = generic_signature_index;
1676         generic_signature_slot ++;
1677         num_generic_signature ++;
1678       }
1679     }
1680 
1681     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1682     field-&gt;initialize(access_flags.as_short(),
1683                       name_index,
1684                       signature_index,
1685                       constantvalue_index);
1686     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1687 
1688     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1689     const FieldAllocationType atype = fac-&gt;update(is_static, type);</span>
1690     field-&gt;set_allocation_type(atype);
1691 
1692     // After field is initialized with type, we can augment it with aux info
1693     if (parsed_annotations.has_any_annotations()) {
1694       parsed_annotations.apply_to(field);
1695       if (field-&gt;is_contended()) {
1696         _has_contended_fields = true;
1697       }
1698     }
1699   }
1700 
1701   int index = length;
1702   if (num_injected != 0) {
1703     for (int n = 0; n &lt; num_injected; n++) {
1704       // Check for duplicates
1705       if (injected[n].may_be_java) {
1706         const Symbol* const name      = injected[n].name();
1707         const Symbol* const signature = injected[n].signature();
1708         bool duplicate = false;
1709         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1714             duplicate = true;
1715             break;
1716           }
1717         }
1718         if (duplicate) {
1719           // These will be removed from the field array at the end
1720           continue;
1721         }
1722       }
1723 
1724       // Injected field
1725       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1726       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1727                         injected[n].name_index,
1728                         injected[n].signature_index,
1729                         0);
1730 
1731       const BasicType type = Signature::basic_type(injected[n].signature());
1732 
1733       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1734       const FieldAllocationType atype = fac-&gt;update(false, type);</span>
1735       field-&gt;set_allocation_type(atype);
1736       index++;
1737     }
1738   }
1739 





























1740   assert(NULL == _fields, &quot;invariant&quot;);
1741 
1742   _fields =
1743     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1744                                    index * FieldInfo::field_slots + num_generic_signature,
1745                                    CHECK);
1746   // Sometimes injected fields already exist in the Java source so
1747   // the fields array could be too long.  In that case the
1748   // fields array is trimed. Also unused slots that were reserved
1749   // for generic signature indexes are discarded.
1750   {
1751     int i = 0;
1752     for (; i &lt; index * FieldInfo::field_slots; i++) {
1753       _fields-&gt;at_put(i, fa[i]);
1754     }
1755     for (int j = total_fields * FieldInfo::field_slots;
1756          j &lt; generic_signature_slot; j++) {
1757       _fields-&gt;at_put(i++, fa[j]);
1758     }
1759     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2035         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2036         checked_exception, CHECK_NULL);
2037     }
2038   }
2039   // check exceptions attribute length
2040   if (_need_verify) {
2041     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2042                                                    sizeof(u2) * size),
2043                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2044   }
2045   return checked_exceptions_start;
2046 }
2047 
2048 void ClassFileParser::throwIllegalSignature(const char* type,
2049                                             const Symbol* name,
2050                                             const Symbol* sig,
2051                                             TRAPS) const {
2052   assert(name != NULL, &quot;invariant&quot;);
2053   assert(sig != NULL, &quot;invariant&quot;);
2054 





2055   ResourceMark rm(THREAD);
2056   Exceptions::fthrow(THREAD_AND_LOCATION,
2057       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2058       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2059       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());</span>
2060 }
2061 
2062 AnnotationCollector::ID
2063 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2064                                       const Symbol* name,
2065                                       const bool can_access_vm_annotations) {
2066   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2067   // Privileged code can use all annotations.  Other code silently drops some.
2068   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2069                           loader_data-&gt;is_platform_class_loader_data() ||
2070                           can_access_vm_annotations;
2071   switch (sid) {
2072     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2073       if (_location != _in_method)  break;  // only allow for methods
2074       if (!privileged)              break;  // only allow in privileged code
2075       return _method_CallerSensitive;
2076     }
2077     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2078       if (_location != _in_method)  break;  // only allow for methods
2079       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2304                              runtime_visible_type_annotations_length,
2305                              runtime_invisible_type_annotations,
2306                              runtime_invisible_type_annotations_length,
2307                              CHECK);
2308     cm-&gt;set_type_annotations(a);
2309   }
2310 }
2311 
2312 
2313 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2314 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2315 // Method* to save footprint, so we only know the size of the resulting Method* when the
2316 // entire method attribute is parsed.
2317 //
2318 // The promoted_flags parameter is used to pass relevant access_flags
2319 // from the method back up to the containing klass. These flag values
2320 // are added to klass&#39;s access_flags.
2321 
2322 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2323                                       bool is_interface,

2324                                       const ConstantPool* cp,
2325                                       AccessFlags* const promoted_flags,
2326                                       TRAPS) {
2327   assert(cfs != NULL, &quot;invariant&quot;);
2328   assert(cp != NULL, &quot;invariant&quot;);
2329   assert(promoted_flags != NULL, &quot;invariant&quot;);
2330 
2331   ResourceMark rm(THREAD);
2332   // Parse fixed parts:
2333   // access_flags, name_index, descriptor_index, attributes_count
2334   cfs-&gt;guarantee_more(8, CHECK_NULL);
2335 
2336   int flags = cfs-&gt;get_u2_fast();
2337   const u2 name_index = cfs-&gt;get_u2_fast();
2338   const int cp_size = cp-&gt;length();
2339   check_property(
2340     valid_symbol_at(name_index),
2341     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2342     name_index, CHECK_NULL);
2343   const Symbol* const name = cp-&gt;symbol_at(name_index);
2344   verify_legal_method_name(name, CHECK_NULL);
2345 
2346   const u2 signature_index = cfs-&gt;get_u2_fast();
2347   guarantee_property(
2348     valid_symbol_at(signature_index),
2349     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2350     signature_index, CHECK_NULL);
2351   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2352 
2353   if (name == vmSymbols::class_initializer_name()) {
2354     // We ignore the other access flags for a valid class initializer.
2355     // (JVM Spec 2nd ed., chapter 4.6)
2356     if (_major_version &lt; 51) { // backward compatibility
2357       flags = JVM_ACC_STATIC;
2358     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2359       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2360     } else {
2361       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2362     }
2363   } else {
<span class="line-modified">2364     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);</span>
<span class="line-modified">2365   }</span>
<span class="line-modified">2366 </span>
<span class="line-modified">2367   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {</span>
<span class="line-modified">2368     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>










































2369   }
2370 
2371   int args_size = -1;  // only used when _need_verify is true
2372   if (_need_verify) {
2373     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2374                  verify_legal_method_signature(name, signature, CHECK_NULL);
2375     if (args_size &gt; MAX_ARGS_SIZE) {
2376       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2377     }
2378   }
2379 
2380   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2381 
2382   // Default values for code and exceptions attribute elements
2383   u2 max_stack = 0;
2384   u2 max_locals = 0;
2385   u4 code_length = 0;
2386   const u1* code_start = 0;
2387   u2 exception_table_length = 0;
2388   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
2899       _has_finalizer = true;
2900     }
2901   }
2902   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2903       signature == vmSymbols::void_method_signature() &amp;&amp;
2904       m-&gt;is_vanilla_constructor()) {
2905     _has_vanilla_constructor = true;
2906   }
2907 
2908   NOT_PRODUCT(m-&gt;verify());
2909   return m;
2910 }
2911 
2912 
2913 // The promoted_flags parameter is used to pass relevant access_flags
2914 // from the methods back up to the containing klass. These flag values
2915 // are added to klass&#39;s access_flags.
2916 // Side-effects: populates the _methods field in the parser
2917 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2918                                     bool is_interface,

2919                                     AccessFlags* promoted_flags,
2920                                     bool* has_final_method,
2921                                     bool* declares_nonstatic_concrete_methods,
2922                                     TRAPS) {
2923   assert(cfs != NULL, &quot;invariant&quot;);
2924   assert(promoted_flags != NULL, &quot;invariant&quot;);
2925   assert(has_final_method != NULL, &quot;invariant&quot;);
2926   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2927 
2928   assert(NULL == _methods, &quot;invariant&quot;);
2929 
2930   cfs-&gt;guarantee_more(2, CHECK);  // length
2931   const u2 length = cfs-&gt;get_u2_fast();
2932   if (length == 0) {
2933     _methods = Universe::the_empty_method_array();
2934   } else {
2935     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2936                                                    length,
2937                                                    NULL,
2938                                                    CHECK);
2939 
2940     for (int index = 0; index &lt; length; index++) {
2941       Method* method = parse_method(cfs,
2942                                     is_interface,

2943                                     _cp,
2944                                     promoted_flags,
2945                                     CHECK);
2946 
2947       if (method-&gt;is_final()) {
2948         *has_final_method = true;
2949       }
2950       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2951       // used for interface initialization, and default method inheritance analysis
2952       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2953         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2954         *declares_nonstatic_concrete_methods = true;
2955       }
2956       _methods-&gt;at_put(index, method);
2957     }
2958 
2959     if (_need_verify &amp;&amp; length &gt; 1) {
2960       // Check duplicated methods
2961       ResourceMark rm(THREAD);
2962       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3115       valid_klass_reference_at(inner_class_info_index),
3116       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3117       inner_class_info_index, CHECK_0);
3118     // Outer class index
3119     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3120     check_property(
3121       outer_class_info_index == 0 ||
3122         valid_klass_reference_at(outer_class_info_index),
3123       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3124       outer_class_info_index, CHECK_0);
3125     // Inner class name
3126     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3127     check_property(
3128       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3129       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3130       inner_name_index, CHECK_0);
3131     if (_need_verify) {
3132       guarantee_property(inner_class_info_index != outer_class_info_index,
3133                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3134     }
<span class="line-modified">3135     // Access flags</span>
<span class="line-modified">3136     jint flags;</span>
3137     // JVM_ACC_MODULE is defined in JDK-9 and later.
3138     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3139       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">3140     } else {</span>
<span class="line-modified">3141       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;</span>


3142     }




3143     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3144       // Set abstract bit for old class files for backward compatibility
3145       flags |= JVM_ACC_ABSTRACT;
3146     }
3147     verify_legal_class_modifiers(flags, CHECK_0);
3148     AccessFlags inner_access_flags(flags);
3149 
3150     inner_classes-&gt;at_put(index++, inner_class_info_index);
3151     inner_classes-&gt;at_put(index++, outer_class_info_index);
3152     inner_classes-&gt;at_put(index++, inner_name_index);
3153     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3154   }
3155 
3156   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3157   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3158     for(int i = 0; i &lt; length * 4; i += 4) {
3159       for(int j = i + 4; j &lt; length * 4; j += 4) {
3160         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3161                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3162                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
3982       }
3983     }
3984     if (runtime_invisible_annotations != NULL) {
3985       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3986         int append = runtime_visible_annotations_length+i;
3987         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3988       }
3989     }
3990   }
3991   return annotations;
3992 }
3993 
3994 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3995                                                         const int super_class_index,
3996                                                         const bool need_verify,
3997                                                         TRAPS) {
3998   assert(cp != NULL, &quot;invariant&quot;);
3999   const InstanceKlass* super_klass = NULL;
4000 
4001   if (super_class_index == 0) {
<span class="line-modified">4002     check_property(_class_name == vmSymbols::java_lang_Object(),</span>

4003                    &quot;Invalid superclass index %u in class file %s&quot;,
4004                    super_class_index,
4005                    CHECK_NULL);
4006   } else {
4007     check_property(valid_klass_reference_at(super_class_index),
4008                    &quot;Invalid superclass index %u in class file %s&quot;,
4009                    super_class_index,
4010                    CHECK_NULL);
4011     // The class name should be legal because it is checked when parsing constant pool.
4012     // However, make sure it is not an array type.
4013     bool is_array = false;
4014     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4015       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4016       if (need_verify)
4017         is_array = super_klass-&gt;is_array_klass();
4018     } else if (need_verify) {
4019       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4020     }
4021     if (need_verify) {
4022       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4162 }
4163 
4164 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4165   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4166   if (_nonstatic_oop_map_count &gt; 0) {
4167     OopMapBlock* map = _nonstatic_oop_maps;
4168     OopMapBlock* last_map = last_oop_map();
4169     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4170     while (map &lt;= last_map) {
4171       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4172                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4173       map++;
4174     }
4175   }
4176 }
4177 
4178 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4179   print_on(st);
4180 }
4181 



















4182 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4183 void ClassFileParser::layout_fields(ConstantPool* cp,
4184                                     const FieldAllocationCount* fac,
4185                                     const ClassAnnotationCollector* parsed_annotations,
4186                                     FieldLayoutInfo* info,
4187                                     TRAPS) {
4188 
4189   assert(cp != NULL, &quot;invariant&quot;);
4190 
4191   // Field size and offset computation
4192   int nonstatic_field_size = _super_klass == NULL ? 0 :
4193                                _super_klass-&gt;nonstatic_field_size();






4194 
4195   // Count the contended fields by type.
4196   //
4197   // We ignore static fields, because @Contended is not supported for them.
4198   // The layout code below will also ignore the static fields.
4199   int nonstatic_contended_count = 0;
4200   FieldAllocationCount fac_contended;
4201   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4202     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4203     if (fs.is_contended()) {
4204       fac_contended.count[atype]++;
4205       if (!fs.access_flags().is_static()) {
4206         nonstatic_contended_count++;
4207       }
4208     }
4209   }
4210 
4211 
4212   // Calculate the starting byte offsets
4213   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();

4214   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4215                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);</span>
4216   if (fac-&gt;count[STATIC_DOUBLE]) {
4217     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4218   }
4219 
4220   int next_static_word_offset   = next_static_double_offset +
4221                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4222   int next_static_short_offset  = next_static_word_offset +
4223                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4224   int next_static_byte_offset   = next_static_short_offset +
4225                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4226 
4227   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4228                                 nonstatic_field_size * heapOopSize;
4229 










4230   int next_nonstatic_field_offset = nonstatic_fields_start;
4231 
4232   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4233 
4234   // Class is contended, pad before all the fields
4235   if (is_contended_class) {
4236     next_nonstatic_field_offset += ContendedPaddingWidth;
4237   }
4238 








4239   // Compute the non-contended fields count.
4240   // The packing code below relies on these counts to determine if some field
4241   // can be squeezed into the alignment gap. Contended fields are obviously
4242   // exempt from that.
4243   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4244   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4245   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4246   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4247   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4248 









































































4249   // Total non-static fields count, including every contended field
4250   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4251                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4252                                         fac-&gt;count[NONSTATIC_OOP];</span>
4253 
4254   const bool super_has_nonstatic_fields =
4255           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4256   const bool has_nonstatic_fields =
4257     super_has_nonstatic_fields || (nonstatic_fields_count != 0);

4258 





4259 
4260   // Prepare list of oops for oop map generation.
4261   //
4262   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4263   // regions. offset[i] is the start of the i-th region, which then has
4264   // count[i] oops following. Before we know how many regions are required,
4265   // we pessimistically allocate the maps to fit all the oops into the
4266   // distinct regions.
<span class="line-modified">4267 </span>
4268   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4269   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];</span>




4270 
4271   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4272   if (super_oop_map_count &gt; 0) {
4273     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4274                                                     _super_klass-&gt;nonstatic_oop_map_count());
4275   }
4276 
4277   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4278 
4279   bool compact_fields  = true;
4280   bool allocate_oops_first = false;
4281 
4282   int next_nonstatic_oop_offset = 0;
4283   int next_nonstatic_double_offset = 0;
4284 
4285   // Rearrange fields for a given allocation style
4286   if (allocate_oops_first) {
4287     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4288     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4289     next_nonstatic_double_offset = next_nonstatic_oop_offset +
</pre>
<hr />
<pre>
4344   }
4345 
4346   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4347                                      (nonstatic_double_count * BytesPerLong);
4348   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4349                                       (nonstatic_word_count * BytesPerInt);
4350   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4351                                      (nonstatic_short_count * BytesPerShort);
4352   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4353                                        nonstatic_byte_count;
4354 
4355   // let oops jump before padding with this allocation style
4356   if (!allocate_oops_first) {
4357     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4358     if( nonstatic_oop_count &gt; 0 ) {
4359       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4360     }
4361     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4362   }
4363 










4364   // Iterate over fields again and compute correct offsets.
4365   // The field allocation type was temporarily stored in the offset slot.
4366   // oop fields are located before non-oop fields (static and non-static).
4367   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4368 
4369     // skip already laid out fields
4370     if (fs.is_offset_set()) continue;
4371 
4372     // contended instance fields are handled below
4373     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4374 
4375     int real_offset = 0;
4376     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4377 
4378     // pack the rest of the fields
4379     switch (atype) {


4380       case STATIC_OOP:
4381         real_offset = next_static_oop_offset;
4382         next_static_oop_offset += heapOopSize;
4383         break;
4384       case STATIC_BYTE:
4385         real_offset = next_static_byte_offset;
4386         next_static_byte_offset += 1;
4387         break;
4388       case STATIC_SHORT:
4389         real_offset = next_static_short_offset;
4390         next_static_short_offset += BytesPerShort;
4391         break;
4392       case STATIC_WORD:
4393         real_offset = next_static_word_offset;
4394         next_static_word_offset += BytesPerInt;
4395         break;
4396       case STATIC_DOUBLE:
4397         real_offset = next_static_double_offset;
4398         next_static_double_offset += BytesPerLong;
4399         break;

























4400       case NONSTATIC_OOP:
4401         if( nonstatic_oop_space_count &gt; 0 ) {
4402           real_offset = nonstatic_oop_space_offset;
4403           nonstatic_oop_space_offset += heapOopSize;
4404           nonstatic_oop_space_count  -= 1;
4405         } else {
4406           real_offset = next_nonstatic_oop_offset;
4407           next_nonstatic_oop_offset += heapOopSize;
4408         }
4409         nonstatic_oop_maps-&gt;add(real_offset, 1);
4410         break;
4411       case NONSTATIC_BYTE:
4412         if( nonstatic_byte_space_count &gt; 0 ) {
4413           real_offset = nonstatic_byte_space_offset;
4414           nonstatic_byte_space_offset += 1;
4415           nonstatic_byte_space_count  -= 1;
4416         } else {
4417           real_offset = next_nonstatic_byte_offset;
4418           next_nonstatic_byte_offset += 1;
4419         }
</pre>
<hr />
<pre>
4498             break;
4499 
4500           case NONSTATIC_SHORT:
4501             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4502             real_offset = next_nonstatic_padded_offset;
4503             next_nonstatic_padded_offset += BytesPerShort;
4504             break;
4505 
4506           case NONSTATIC_WORD:
4507             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4508             real_offset = next_nonstatic_padded_offset;
4509             next_nonstatic_padded_offset += BytesPerInt;
4510             break;
4511 
4512           case NONSTATIC_DOUBLE:
4513             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4514             real_offset = next_nonstatic_padded_offset;
4515             next_nonstatic_padded_offset += BytesPerLong;
4516             break;
4517 






4518           case NONSTATIC_OOP:
4519             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4520             real_offset = next_nonstatic_padded_offset;
4521             next_nonstatic_padded_offset += heapOopSize;
4522             nonstatic_oop_maps-&gt;add(real_offset, 1);
4523             break;
4524 
4525           default:
4526             ShouldNotReachHere();
4527         }
4528 
4529         if (fs.contended_group() == 0) {
4530           // Contended group defines the equivalence class over the fields:
4531           // the fields within the same contended group are not inter-padded.
4532           // The only exception is default group, which does not incur the
4533           // equivalence, and so requires intra-padding.
4534           next_nonstatic_padded_offset += ContendedPaddingWidth;
4535         }
4536 
4537         fs.set_offset(real_offset);
4538       } // for
4539 
4540       // Start laying out the next group.
4541       // Note that this will effectively pad the last group in the back;
4542       // this is expected to alleviate memory contention effects for
4543       // subclass fields and/or adjacent object.
4544       // If this was the default group, the padding is already in place.
4545       if (current_group != 0) {
4546         next_nonstatic_padded_offset += ContendedPaddingWidth;
4547       }
4548     }
4549 
4550     // handle static fields
4551   }
4552 
4553   // Entire class is contended, pad in the back.
4554   // This helps to alleviate memory contention effects for subclass fields
4555   // and/or adjacent object.
4556   if (is_contended_class) {

4557     next_nonstatic_padded_offset += ContendedPaddingWidth;
4558   }
4559 
<span class="line-modified">4560   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>





4561 
<span class="line-modified">4562   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);</span>






4563   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4564   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4565 
4566   int static_field_size         = (static_fields_end -
4567                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4568   nonstatic_field_size          = nonstatic_field_size +
4569                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4570 
4571   int instance_size             = align_object_size(instance_end / wordSize);
4572 
4573   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4574          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),</span>
<span class="line-modified">4575           wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>

4576 
4577   // Invariant: nonstatic_field end/start should only change if there are
4578   // nonstatic fields in the class, or if the class is contended. We compare
4579   // against the non-aligned value, so that end alignment will not fail the
4580   // assert without actually having the fields.
4581   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4582          is_contended_class ||
4583          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4584 
4585   // Number of non-static oop map blocks allocated at end of klass.
4586   nonstatic_oop_maps-&gt;compact();
4587 
4588 #ifndef PRODUCT
<span class="line-modified">4589   if (PrintFieldLayout) {</span>

4590     print_field_layout(_class_name,
4591           _fields,
4592           cp,
4593           instance_size,
4594           nonstatic_fields_start,
4595           nonstatic_fields_end,
4596           static_fields_end);







4597   }
4598 
4599 #endif
4600   // Pass back information needed for InstanceKlass creation
4601   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4602   info-&gt;_instance_size = instance_size;
4603   info-&gt;_static_field_size = static_field_size;
4604   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4605   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;













4606 }
4607 
4608 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4609   assert(ik != NULL, &quot;invariant&quot;);
4610 
4611   const Klass* const super = ik-&gt;super();
4612 
4613   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4614   // in which case we don&#39;t have to register objects as finalizable
4615   if (!_has_empty_finalizer) {
4616     if (_has_finalizer ||
4617         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4618       ik-&gt;set_has_finalizer();
4619     }
4620   }
4621 
4622 #ifdef ASSERT
4623   bool f = false;
4624   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4625                                            vmSymbols::void_method_signature());
4626   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4627       f = true;
4628   }
4629 
4630   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4631   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4632   // will not work as expected we shouldn&#39;t abort vm in this case
4633   if (!ik-&gt;has_redefined_this_or_super()) {
4634     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4635   }
4636 #endif
4637 
4638   // Check if this klass supports the java.lang.Cloneable interface
4639   if (SystemDictionary::Cloneable_klass_loaded()) {
4640     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {





4641       ik-&gt;set_is_cloneable();
4642     }
4643   }
4644 
4645   // Check if this klass has a vanilla default constructor
4646   if (super == NULL) {
4647     // java.lang.Object has empty default constructor
4648     ik-&gt;set_has_vanilla_constructor();
4649   } else {
4650     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4651         _has_vanilla_constructor) {
4652       ik-&gt;set_has_vanilla_constructor();
4653     }
4654 #ifdef ASSERT
4655     bool v = false;
4656     if (super-&gt;has_vanilla_constructor()) {
4657       const Method* const constructor =
4658         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4659                        vmSymbols::void_method_signature());
4660       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4661         v = true;
4662       }
4663     }
4664     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4665 #endif
4666   }
4667 
4668   // If it cannot be fast-path allocated, set a bit in the layout helper.
4669   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4670   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4671   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4672       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4673       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4674       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4675     // Forbid fast-path allocation.
4676     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4677     ik-&gt;set_layout_helper(lh);
4678   }
4679 }
4680 





4681 // utility methods for appending an array with check for duplicates
4682 
4683 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4684                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4685   // iterate over new interfaces
4686   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4687     InstanceKlass* const e = ifs-&gt;at(i);
4688     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4689     // add new interface
4690     result-&gt;append_if_missing(e);
4691   }
4692 }
4693 
4694 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4695                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4696                                                             ClassLoaderData* loader_data,
4697                                                             TRAPS) {
4698   assert(local_ifs != NULL, &quot;invariant&quot;);
4699   assert(loader_data != NULL, &quot;invariant&quot;);
4700 
</pre>
<hr />
<pre>
4704   // Add superclass transitive interfaces size
4705   if (super != NULL) {
4706     super_size = super-&gt;transitive_interfaces()-&gt;length();
4707     max_transitive_size += super_size;
4708   }
4709   // Add local interfaces&#39; super interfaces
4710   const int local_size = local_ifs-&gt;length();
4711   for (int i = 0; i &lt; local_size; i++) {
4712     InstanceKlass* const l = local_ifs-&gt;at(i);
4713     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4714   }
4715   // Finally add local interfaces
4716   max_transitive_size += local_size;
4717   // Construct array
4718   if (max_transitive_size == 0) {
4719     // no interfaces, use canonicalized array
4720     return Universe::the_empty_instance_klass_array();
4721   } else if (max_transitive_size == super_size) {
4722     // no new local interfaces added, share superklass&#39; transitive interface array
4723     return super-&gt;transitive_interfaces();
<span class="line-modified">4724   } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">4725     // only local interfaces added, share local interface array</span>
<span class="line-modified">4726     return local_ifs;</span>

4727   } else {
4728     ResourceMark rm;
4729     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4730 
4731     // Copy down from superclass
4732     if (super != NULL) {
4733       append_interfaces(result, super-&gt;transitive_interfaces());
4734     }
4735 
4736     // Copy down from local interfaces&#39; superinterfaces
4737     for (int i = 0; i &lt; local_size; i++) {
4738       InstanceKlass* const l = local_ifs-&gt;at(i);
4739       append_interfaces(result, l-&gt;transitive_interfaces());
4740     }
4741     // Finally add local interfaces
4742     append_interfaces(result, local_ifs);
4743 
4744     // length will be less than the max_transitive_size if duplicates were removed
4745     const int length = result-&gt;length();
4746     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);





4747     Array&lt;InstanceKlass*&gt;* const new_result =
4748       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4749     for (int i = 0; i &lt; length; i++) {
4750       InstanceKlass* const e = result-&gt;at(i);
4751       assert(e != NULL, &quot;just checking&quot;);
4752       new_result-&gt;at_put(i, e);
4753     }
4754     return new_result;
4755   }
4756 }
4757 
4758 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4759   assert(this_klass != NULL, &quot;invariant&quot;);
4760   const Klass* const super = this_klass-&gt;super();
4761 
4762   if (super != NULL) {
4763     const InstanceKlass* super_ik = InstanceKlass::cast(super);
4764 
4765     if (super-&gt;is_final()) {
4766       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
4959     const Method* const m = methods-&gt;at(index);
4960     // if m is static and not the init method, throw a verify error
4961     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4962       ResourceMark rm(THREAD);
4963       Exceptions::fthrow(
4964         THREAD_AND_LOCATION,
4965         vmSymbols::java_lang_VerifyError(),
4966         &quot;Illegal static method %s in interface %s&quot;,
4967         m-&gt;name()-&gt;as_C_string(),
4968         this_klass-&gt;external_name()
4969       );
4970       return;
4971     }
4972   }
4973 }
4974 
4975 // utility methods for format checking
4976 
4977 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4978   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;

4979   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);

4980   if (is_module) {
4981     ResourceMark rm(THREAD);
4982     Exceptions::fthrow(
4983       THREAD_AND_LOCATION,
4984       vmSymbols::java_lang_NoClassDefFoundError(),
4985       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4986       _class_name-&gt;as_C_string());
4987     return;
4988   }
4989 










4990   if (!_need_verify) { return; }
4991 
4992   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4993   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4994   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4995   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4996   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4997   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4998   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4999   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5000 
5001   if ((is_abstract &amp;&amp; is_final) ||
5002       (is_interface &amp;&amp; !is_abstract) ||
5003       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">5004       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>

5005     ResourceMark rm(THREAD);


5006     Exceptions::fthrow(
5007       THREAD_AND_LOCATION,
5008       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5009       &quot;Illegal class modifiers in class %s: 0x%X&quot;,</span>
<span class="line-modified">5010       _class_name-&gt;as_C_string(), flags</span>
5011     );
5012     return;
5013   }
5014 }
5015 
5016 static bool has_illegal_visibility(jint flags) {
5017   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5018   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5019   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5020 
5021   return ((is_public &amp;&amp; is_protected) ||
5022           (is_public &amp;&amp; is_private) ||
5023           (is_protected &amp;&amp; is_private));
5024 }
5025 
5026 // A legal major_version.minor_version must be one of the following:
5027 //
5028 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5029 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5030 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
5069     if (!Arguments::enable_preview()) {
5070       Exceptions::fthrow(
5071         THREAD_AND_LOCATION,
5072         vmSymbols::java_lang_UnsupportedClassVersionError(),
5073         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5074         class_name-&gt;as_C_string(), major, minor);
5075       return;
5076     }
5077 
5078   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5079     Exceptions::fthrow(
5080         THREAD_AND_LOCATION,
5081         vmSymbols::java_lang_UnsupportedClassVersionError(),
5082         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5083         class_name-&gt;as_C_string(), major, minor);
5084   }
5085 }
5086 
5087 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5088                                                    bool is_interface,

5089                                                    TRAPS) const {
5090   if (!_need_verify) { return; }
5091 
5092   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5093   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5094   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5095   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5096   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5097   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5098   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5099   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5100   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5101 
5102   bool is_illegal = false;
5103 
5104   if (is_interface) {
5105     if (!is_public || !is_static || !is_final || is_private ||
5106         is_protected || is_volatile || is_transient ||
5107         (major_gte_1_5 &amp;&amp; is_enum)) {
5108       is_illegal = true;
5109     }
5110   } else { // not interface
5111     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5112       is_illegal = true;




5113     }
5114   }
5115 
5116   if (is_illegal) {
5117     ResourceMark rm(THREAD);
5118     Exceptions::fthrow(
5119       THREAD_AND_LOCATION,
5120       vmSymbols::java_lang_ClassFormatError(),
5121       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5122       _class_name-&gt;as_C_string(), flags);
5123     return;
5124   }
5125 }
5126 
5127 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5128                                                     bool is_interface,

5129                                                     const Symbol* name,
5130                                                     TRAPS) const {
5131   if (!_need_verify) { return; }
5132 
5133   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5134   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5135   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5136   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5137   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5138   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5139   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5140   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5141   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5142   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5143   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5144   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5145   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5146 
5147   bool is_illegal = false;
5148 


5149   if (is_interface) {
5150     if (major_gte_8) {
5151       // Class file version is JAVA_8_VERSION or later Methods of
5152       // interfaces may set any of the flags except ACC_PROTECTED,
5153       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5154       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5155       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5156           (is_native || is_protected || is_final || is_synchronized) ||
5157           // If a specific method of a class or interface has its
5158           // ACC_ABSTRACT flag set, it must not have any of its
5159           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5160           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5161           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5162           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5163           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5164         is_illegal = true;
5165       }
5166     } else if (major_gte_1_5) {
5167       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5168       if (!is_public || is_private || is_protected || is_static || is_final ||
5169           is_synchronized || is_native || !is_abstract || is_strict) {
5170         is_illegal = true;
5171       }
5172     } else {
5173       // Class file version is pre-JAVA_1_5_VERSION
5174       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5175         is_illegal = true;
5176       }
5177     }
5178   } else { // not interface
5179     if (has_illegal_visibility(flags)) {
5180       is_illegal = true;
5181     } else {
5182       if (is_initializer) {
<span class="line-modified">5183         if (is_static || is_final || is_synchronized || is_native ||</span>
5184             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5185           is_illegal = true;
5186         }









5187       } else { // not initializer
<span class="line-modified">5188         if (is_abstract) {</span>
<span class="line-modified">5189           if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-modified">5190               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-modified">5191             is_illegal = true;</span>





5192           }
5193         }
5194       }
5195     }
5196   }
5197 
5198   if (is_illegal) {
5199     ResourceMark rm(THREAD);
5200     Exceptions::fthrow(
5201       THREAD_AND_LOCATION,
5202       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5203       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5204       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);</span>
5205     return;
5206   }
5207 }
5208 
5209 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5210                                         int length,
5211                                         TRAPS) const {
5212   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5213   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5214     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5215   }
5216 }
5217 
5218 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5219 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5220 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5221 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5222 // method.  Because these names have been checked as special cases before
5223 // calling this method in verify_legal_method_name.
5224 //
</pre>
<hr />
<pre>
5342 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5343 // Return a pointer to just past the signature.
5344 // Return NULL if no legal signature is found.
5345 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5346                                                        bool void_ok,
5347                                                        unsigned int length,
5348                                                        TRAPS) const {
5349   unsigned int array_dim = 0;
5350   while (length &gt; 0) {
5351     switch (signature[0]) {
5352     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5353     case JVM_SIGNATURE_BOOLEAN:
5354     case JVM_SIGNATURE_BYTE:
5355     case JVM_SIGNATURE_CHAR:
5356     case JVM_SIGNATURE_SHORT:
5357     case JVM_SIGNATURE_INT:
5358     case JVM_SIGNATURE_FLOAT:
5359     case JVM_SIGNATURE_LONG:
5360     case JVM_SIGNATURE_DOUBLE:
5361       return signature + 1;
<span class="line-modified">5362     case JVM_SIGNATURE_CLASS: {</span>









5363       if (_major_version &lt; JAVA_1_5_VERSION) {
5364         // Skip over the class name if one is there
5365         const char* const p = skip_over_field_name(signature + 1, true, --length);
5366 
5367         // The next character better be a semicolon
5368         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5369           return p + 1;
5370         }
5371       }
5372       else {
<span class="line-modified">5373         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;</span>
5374         signature++;
5375         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5376         // Format check signature
5377         if (c != NULL) {
5378           int newlen = c - (char*) signature;
5379           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5380           if (!legal) {
5381             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5382                                   &quot;in descriptor in class file %s&quot;,
5383                                   CHECK_NULL);
5384             return NULL;
5385           }
5386           return signature + newlen + 1;
5387         }
5388       }
5389       return NULL;
5390     }
5391     case JVM_SIGNATURE_ARRAY:
5392       array_dim++;
5393       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5408 
5409 // Checks if name is a legal class name.
5410 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5411   if (!_need_verify || _relax_verify) { return; }
5412 
5413   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5414   char* bytes = (char*)name-&gt;bytes();
5415   unsigned int length = name-&gt;utf8_length();
5416   bool legal = false;
5417 
5418   if (length &gt; 0) {
5419     const char* p;
5420     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5421       p = skip_over_field_signature(bytes, false, length, CHECK);
5422       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5423     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5424       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5425         p = skip_over_field_name(bytes, true, length);
5426         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5427       }



5428     } else {
5429       // 4900761: relax the constraints based on JSR202 spec
5430       // Class names may be drawn from the entire Unicode character set.
5431       // Identifiers between &#39;/&#39; must be unqualified names.
5432       // The utf8 string has been verified when parsing cpool entries.
5433       legal = verify_unqualified_name(bytes, length, LegalClass);
5434     }
5435   }
5436   if (!legal) {
5437     ResourceMark rm(THREAD);
5438     assert(_class_name != NULL, &quot;invariant&quot;);
5439     Exceptions::fthrow(
5440       THREAD_AND_LOCATION,
5441       vmSymbols::java_lang_ClassFormatError(),
5442       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5443       _class_name-&gt;as_C_string()
5444     );
5445     return;
5446   }
5447 }
</pre>
<hr />
<pre>
5557   const char* nextp;
5558 
5559   // The first character must be a &#39;(&#39;
5560   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5561     length--;
5562     // Skip over legal field signatures
5563     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5564     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5565       args_size++;
5566       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5567         args_size++;
5568       }
5569       length -= nextp - p;
5570       p = nextp;
5571       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5572     }
5573     // The first non-signature thing better be a &#39;)&#39;
5574     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5575       length--;
5576       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5577         // All internal methods must return void</span>
5578         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5579           return args_size;
5580         }
















5581       } else {
5582         // Now we better just have a return value
5583         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5584         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5585           return args_size;
5586         }
5587       }
5588     }
5589   }
5590   // Report error
5591   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5592   return 0;
5593 }
5594 
5595 int ClassFileParser::static_field_size() const {
5596   assert(_field_info != NULL, &quot;invariant&quot;);
5597   return _field_info-&gt;_static_field_size;
5598 }
5599 
5600 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
5718 
5719 
5720   if (ik-&gt;should_store_fingerprint()) {
5721     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5722   }
5723 
5724   ik-&gt;set_has_passed_fingerprint_check(false);
5725   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5726     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5727     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5728     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5729       // This class matches with a class saved in an AOT library
5730       ik-&gt;set_has_passed_fingerprint_check(true);
5731     } else {
5732       ResourceMark rm;
5733       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5734                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5735     }
5736   }
5737 






5738   return ik;
5739 }
5740 


































5741 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
5742                                           bool changed_by_loadhook,
5743                                           const ClassInstanceInfo&amp; cl_inst_info,
5744                                           TRAPS) {
5745   assert(ik != NULL, &quot;invariant&quot;);
5746 
5747   // Set name and CLD before adding to CLD
5748   ik-&gt;set_class_loader_data(_loader_data);
5749   ik-&gt;set_name(_class_name);
5750 
5751   // Add all classes to our internal class loader list here,
5752   // including classes in the bootstrap (NULL) class loader.
5753   const bool publicize = !is_internal();
5754 
5755   _loader_data-&gt;add_class(ik, publicize);
5756 
5757   set_klass_to_deallocate(ik);
5758 
5759   assert(_field_info != NULL, &quot;invariant&quot;);
5760   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
5761   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
5762          &quot;sanity&quot;);
5763 
5764   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5765   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
5766 
5767   // Fill in information already parsed
5768   ik-&gt;set_should_verify_class(_need_verify);
5769 
5770   // Not yet: supers are done below to support the new subtype-checking fields
5771   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
5772   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);















5773   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">5774   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);</span>
5775 
5776   // this transfers ownership of a lot of arrays from
5777   // the parser onto the InstanceKlass*
5778   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5779 
5780   // can only set dynamic nest-host after static nest information is set
5781   if (cl_inst_info.dynamic_nest_host() != NULL) {
5782     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
5783   }
5784 
5785   // note that is not safe to use the fields in the parser from this point on
5786   assert(NULL == _cp, &quot;invariant&quot;);
5787   assert(NULL == _fields, &quot;invariant&quot;);
5788   assert(NULL == _methods, &quot;invariant&quot;);
5789   assert(NULL == _inner_classes, &quot;invariant&quot;);
5790   assert(NULL == _nest_members, &quot;invariant&quot;);
5791   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5792   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5793   assert(NULL == _record_components, &quot;invariant&quot;);
5794   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
</pre>
<hr />
<pre>
5805   // has to be changed accordingly.
5806   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5807 
5808   ik-&gt;set_this_class_index(_this_class_index);
5809 
5810   if (_is_hidden || is_unsafe_anonymous()) {
5811     // _this_class_index is a CONSTANT_Class entry that refers to this
5812     // hidden or anonymous class itself. If this class needs to refer to its own
5813     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
5814     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
5815     // not stored in SystemDictionary), _this_class_index cannot be resolved
5816     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5817     // Therefore, we must eagerly resolve _this_class_index now.
5818     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5819   }
5820 
5821   ik-&gt;set_minor_version(_minor_version);
5822   ik-&gt;set_major_version(_major_version);
5823   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5824   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);



5825 
5826   if (_unsafe_anonymous_host != NULL) {
5827     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5828     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5829   }
5830   if (_is_hidden) {
5831     ik-&gt;set_is_hidden();
5832   }
5833 
5834   // Set PackageEntry for this_klass
5835   oop cl = ik-&gt;class_loader();
5836   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5837   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5838   ik-&gt;set_package(cld, NULL, CHECK);
5839 
5840   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5841   assert(methods != NULL, &quot;invariant&quot;);
5842   const int methods_len = methods-&gt;length();
5843 
5844   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
5914 
5915   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5916 
5917   // Generate any default methods - default methods are public interface methods
5918   // that have a default implementation.  This is new with Java 8.
5919   if (_has_nonstatic_concrete_methods) {
5920     DefaultMethods::generate_default_methods(ik,
5921                                              _all_mirandas,
5922                                              CHECK);
5923   }
5924 
5925   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5926   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5927       !module_entry-&gt;has_default_read_edges()) {
5928     if (!module_entry-&gt;set_has_default_read_edges()) {
5929       // We won a potential race
5930       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5931     }
5932   }
5933 


































5934   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5935 
5936   if (!is_internal()) {
5937     if (log_is_enabled(Info, class, load)) {
5938       ResourceMark rm;
5939       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5940       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5941     }
5942 
5943     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5944         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5945         log_is_enabled(Info, class, preview)) {
5946       ResourceMark rm;
5947       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5948                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5949     }
5950 
5951     if (log_is_enabled(Debug, class, resolve))  {
5952       ResourceMark rm;
5953       // print out the superclass.
</pre>
<hr />
<pre>
5963         const int length = local_interfaces-&gt;length();
5964         for (int i = 0; i &lt; length; i++) {
5965           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5966           const char * to = k-&gt;external_name();
5967           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5968         }
5969       }
5970     }
5971   }
5972 
5973   JFR_ONLY(INIT_ID(ik);)
5974 
5975   // If we reach here, all is well.
5976   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5977   // in order for it to not be destroyed in the ClassFileParser destructor.
5978   set_klass_to_deallocate(NULL);
5979 
5980   // it&#39;s official
5981   set_klass(ik);
5982 




5983   debug_only(ik-&gt;verify();)
5984 }
5985 
5986 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5987   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5988   _class_name-&gt;decrement_refcount();
5989 
5990   _class_name = new_class_name;
5991   // Increment the refcount of the new name.
5992   // Now the ClassFileParser owns this name and will decrement in
5993   // the destructor.
5994   _class_name-&gt;increment_refcount();
5995 }
5996 
5997 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5998 // package by prepending its host class&#39;s package name to its class name and setting
5999 // its _class_name field.
6000 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6001   ResourceMark rm(THREAD);
6002   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
6065   _stream(stream),
6066   _class_name(NULL),
6067   _loader_data(loader_data),
6068   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6069   _cp_patches(cl_info-&gt;cp_patches()),
6070   _is_hidden(cl_info-&gt;is_hidden()),
6071   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6072   _num_patched_klasses(0),
6073   _max_num_patched_klasses(0),
6074   _orig_cp_size(0),
6075   _first_patched_klass_resolved_index(0),
6076   _super_klass(),
6077   _cp(NULL),
6078   _fields(NULL),
6079   _methods(NULL),
6080   _inner_classes(NULL),
6081   _nest_members(NULL),
6082   _nest_host(0),
6083   _permitted_subclasses(NULL),
6084   _record_components(NULL),

6085   _local_interfaces(NULL),
6086   _transitive_interfaces(NULL),
6087   _combined_annotations(NULL),
6088   _class_annotations(NULL),
6089   _class_type_annotations(NULL),
6090   _fields_annotations(NULL),
6091   _fields_type_annotations(NULL),
6092   _klass(NULL),
6093   _klass_to_deallocate(NULL),
6094   _parsed_annotations(NULL),
6095   _fac(NULL),
6096   _field_info(NULL),
6097   _method_ordering(NULL),
6098   _all_mirandas(NULL),
6099   _vtable_size(0),
6100   _itable_size(0),
6101   _num_miranda_methods(0),
6102   _rt(REF_NONE),
6103   _protection_domain(cl_info-&gt;protection_domain()),
6104   _access_flags(),
6105   _pub_level(pub_level),
6106   _bad_constant_seen(0),
6107   _synthetic_flag(false),
6108   _sde_length(false),
6109   _sde_buffer(NULL),
6110   _sourcefile_index(0),
6111   _generic_signature_index(0),
6112   _major_version(0),
6113   _minor_version(0),
6114   _this_class_index(0),
6115   _super_class_index(0),
6116   _itfs_len(0),
6117   _java_fields_count(0),
6118   _need_verify(false),
6119   _relax_verify(false),
6120   _has_nonstatic_concrete_methods(false),
6121   _declares_nonstatic_concrete_methods(false),
6122   _has_final_method(false),
6123   _has_contended_fields(false),









6124   _has_finalizer(false),
6125   _has_empty_finalizer(false),
6126   _has_vanilla_constructor(false),
6127   _max_bootstrap_specifier_index(-1) {
6128 
6129   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6130   _class_name-&gt;increment_refcount();
6131 
6132   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6133   assert(_loader_data != NULL, &quot;invariant&quot;);
6134   assert(stream != NULL, &quot;invariant&quot;);
6135   assert(_stream != NULL, &quot;invariant&quot;);
6136   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6137   assert(_class_name != NULL, &quot;invariant&quot;);
6138   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6139 
6140   // Figure out whether we can skip format checking (matching classic VM behavior)
6141   if (DumpSharedSpaces) {
6142     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6143     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6314   } else {
6315     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6316       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6317     }
6318     cp_size += _max_num_patched_klasses;
6319   }
6320 
6321   _cp = ConstantPool::allocate(_loader_data,
6322                                cp_size,
6323                                CHECK);
6324 
6325   ConstantPool* const cp = _cp;
6326 
6327   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6328 
6329   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6330 
6331   // ACCESS FLAGS
6332   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6333 
<span class="line-modified">6334   // Access flags</span>
<span class="line-removed">6335   jint flags;</span>
6336   // JVM_ACC_MODULE is defined in JDK-9 and later.
6337   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6338     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">6339   } else {</span>
<span class="line-modified">6340     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;</span>


6341   }
6342 



6343   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6344     // Set abstract bit for old class files for backward compatibility
6345     flags |= JVM_ACC_ABSTRACT;
6346   }
6347 
6348   verify_legal_class_modifiers(flags, CHECK);
6349 
6350   short bad_constant = class_bad_constant_seen();
6351   if (bad_constant != 0) {
6352     // Do not throw CFE until after the access_flags are checked because if
6353     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6354     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6355   }
6356 
6357   _access_flags.set_flags(flags);
6358 
6359   // This class and superclass
6360   _this_class_index = stream-&gt;get_u2_fast();
6361   check_property(
6362     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6480           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6481           classlist_file-&gt;flush();
6482         }
6483       }
6484     }
6485 #endif
6486   }
6487 
6488   // SUPERKLASS
6489   _super_class_index = stream-&gt;get_u2_fast();
6490   _super_klass = parse_super_class(cp,
6491                                    _super_class_index,
6492                                    _need_verify,
6493                                    CHECK);
6494 
6495   // Interfaces
6496   _itfs_len = stream-&gt;get_u2_fast();
6497   parse_interfaces(stream,
6498                    _itfs_len,
6499                    cp,

6500                    &amp;_has_nonstatic_concrete_methods,

6501                    CHECK);
6502 
<span class="line-modified">6503   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
6504 
6505   // Fields (offsets are filled in later)
6506   _fac = new FieldAllocationCount();
6507   parse_fields(stream,
<span class="line-modified">6508                _access_flags.is_interface(),</span>

6509                _fac,
6510                cp,
6511                cp_size,
6512                &amp;_java_fields_count,
6513                CHECK);
6514 
6515   assert(_fields != NULL, &quot;invariant&quot;);
6516 
6517   // Methods
6518   AccessFlags promoted_flags;
6519   parse_methods(stream,
<span class="line-modified">6520                 _access_flags.is_interface(),</span>

6521                 &amp;promoted_flags,
6522                 &amp;_has_final_method,
6523                 &amp;_declares_nonstatic_concrete_methods,
6524                 CHECK);
6525 
6526   assert(_methods != NULL, &quot;invariant&quot;);
6527 
6528   // promote flags from parse_methods() to the klass&#39; flags
6529   _access_flags.add_promoted_flags(promoted_flags.as_int());
6530 
6531   if (_declares_nonstatic_concrete_methods) {
6532     _has_nonstatic_concrete_methods = true;
6533   }
6534 
6535   // Additional attributes/annotations
6536   _parsed_annotations = new ClassAnnotationCollector();
6537   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6538 
6539   assert(_inner_classes != NULL, &quot;invariant&quot;);
6540 
</pre>
<hr />
<pre>
6571 
6572   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
6573   // We have to update the resolved_klass_index and the name_index together
6574   // so extract the existing resolved_klass_index first.
6575   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
6576   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
6577   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
6578   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
6579          &quot;Bad name_index&quot;);
6580 }
6581 
6582 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6583                                                  ConstantPool* cp,
6584                                                  TRAPS) {
6585   assert(stream != NULL, &quot;invariant&quot;);
6586   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6587   assert(cp != NULL, &quot;invariant&quot;);
6588   assert(_loader_data != NULL, &quot;invariant&quot;);
6589 
6590   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6591     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),</span>
<span class="line-modified">6592                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6593                    CHECK);</span>
6594   }
6595   // We check super class after class file is parsed and format is checked
6596   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6597     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6598     if (_access_flags.is_interface()) {</span>
6599       // Before attempting to resolve the superclass, check for class format
6600       // errors not checked yet.
6601       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6602         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6603         CHECK);
6604     }
6605     Handle loader(THREAD, _loader_data-&gt;class_loader());
6606     _super_klass = (const InstanceKlass*)
6607                        SystemDictionary::resolve_super_or_fail(_class_name,
6608                                                                super_class_name,
6609                                                                loader,
6610                                                                _protection_domain,
6611                                                                true,
6612                                                                CHECK);
6613   }
6614 
6615   if (_super_klass != NULL) {
6616     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6617       _has_nonstatic_concrete_methods = true;
6618     }



6619 
6620     if (_super_klass-&gt;is_interface()) {
6621       ResourceMark rm(THREAD);
6622       Exceptions::fthrow(
6623         THREAD_AND_LOCATION,
6624         vmSymbols::java_lang_IncompatibleClassChangeError(),
6625         &quot;class %s has interface %s as super class&quot;,
6626         _class_name-&gt;as_klass_external_name(),
6627         _super_klass-&gt;external_name()
6628       );
6629       return;
6630     }





































6631   }
6632 



















6633   // Compute the transitive list of all unique interfaces implemented by this class
6634   _transitive_interfaces =
6635     compute_transitive_interfaces(_super_klass,
6636                                   _local_interfaces,
6637                                   _loader_data,
6638                                   CHECK);
6639 
6640   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6641 
6642   // sort methods
6643   _method_ordering = sort_methods(_methods);
6644 
6645   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6646 
6647   Handle loader(THREAD, _loader_data-&gt;class_loader());
6648   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6649                                                     &amp;_num_miranda_methods,
6650                                                     _all_mirandas,
6651                                                     _super_klass,
6652                                                     _methods,
6653                                                     _access_flags,
6654                                                     _major_version,
6655                                                     loader,
6656                                                     _class_name,
6657                                                     _local_interfaces,
6658                                                     CHECK);
6659 
6660   // Size of Java itable (in words)
<span class="line-modified">6661   _itable_size = _access_flags.is_interface() ? 0 :</span>
6662     klassItable::compute_itable_size(_transitive_interfaces);
6663 
6664   assert(_fac != NULL, &quot;invariant&quot;);
6665   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6666 













6667   _field_info = new FieldLayoutInfo();
6668   if (UseNewFieldLayout) {
6669     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">6670                           _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-modified">6671     lb.build_layout();</span>






6672   } else {
6673     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6674   }
6675 
<span class="line-modified">6676   // Compute reference typ</span>
6677   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
<span class="line-removed">6678 </span>
6679 }
6680 
6681 void ClassFileParser::set_klass(InstanceKlass* klass) {
6682 
6683 #ifdef ASSERT
6684   if (klass != NULL) {
6685     assert(NULL == _klass, &quot;leaking?&quot;);
6686   }
6687 #endif
6688 
6689   _klass = klass;
6690 }
6691 
6692 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6693 
6694 #ifdef ASSERT
6695   if (klass != NULL) {
6696     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6697   }
6698 #endif
6699 
6700   _klass_to_deallocate = klass;
6701 }
6702 
6703 // Caller responsible for ResourceMark
6704 // clone stream with rewound position
6705 const ClassFileStream* ClassFileParser::clone_stream() const {
6706   assert(_stream != NULL, &quot;invariant&quot;);
6707 
6708   return _stream-&gt;clone();
6709 }

6710 // ----------------------------------------------------------------------------
6711 // debugging
6712 
6713 #ifdef ASSERT
6714 
6715 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6716 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6717   if (class_name != NULL) {
6718     ResourceMark rm;
6719     char* name = class_name-&gt;as_C_string();
6720     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6721   } else {
6722     return true;
6723   }
6724 }
6725 
6726 #endif
</pre>
</td>
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
<span class="line-added">  24 </span>
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/defaultMethods.hpp&quot;
  33 #include &quot;classfile/dictionary.hpp&quot;
  34 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/moduleEntry.hpp&quot;
  37 #include &quot;classfile/packageEntry.hpp&quot;
  38 #include &quot;classfile/symbolTable.hpp&quot;
  39 #include &quot;classfile/systemDictionary.hpp&quot;
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
  52 #include &quot;oops/fieldStreams.inline.hpp&quot;
  53 #include &quot;oops/instanceKlass.hpp&quot;
  54 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  55 #include &quot;oops/klass.inline.hpp&quot;
  56 #include &quot;oops/klassVtable.hpp&quot;
  57 #include &quot;oops/metadata.hpp&quot;
  58 #include &quot;oops/method.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/recordComponent.hpp&quot;
  61 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">  86 #include &quot;utilities/stringUtils.hpp&quot;</span>
  87 #include &quot;utilities/utf8.hpp&quot;
  88 
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
</pre>
<hr />
<pre>
 118 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 119 #define JAVA_7_VERSION                    51
 120 
 121 // Extension method support.
 122 #define JAVA_8_VERSION                    52
 123 
 124 #define JAVA_9_VERSION                    53
 125 
 126 #define JAVA_10_VERSION                   54
 127 
 128 #define JAVA_11_VERSION                   55
 129 
 130 #define JAVA_12_VERSION                   56
 131 
 132 #define JAVA_13_VERSION                   57
 133 
 134 #define JAVA_14_VERSION                   58
 135 
 136 #define JAVA_15_VERSION                   59
 137 
<span class="line-added"> 138 #define CONSTANT_CLASS_DESCRIPTORS        59</span>
<span class="line-added"> 139 </span>
 140 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 141   assert((bad_constant == JVM_CONSTANT_Module ||
 142           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 143          &quot;Unexpected bad constant pool entry&quot;);
 144   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 145 }
 146 
 147 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 148                                                   ConstantPool* cp,
 149                                                   const int length,
 150                                                   TRAPS) {
 151   assert(stream != NULL, &quot;invariant&quot;);
 152   assert(cp != NULL, &quot;invariant&quot;);
 153 
 154   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 155   // this function (_current can be allocated in a register, with scalar
 156   // replacement of aggregates). The _current pointer is copied back to
 157   // stream() when this function returns. DON&#39;T call another method within
 158   // this method that uses stream().
 159   const ClassFileStream cfs1 = *stream;
 160   const ClassFileStream* const cfs = &amp;cfs1;
 161 
 162   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 163   debug_only(const u1* const old_current = stream-&gt;current();)
 164 
 165   // Used for batching symbol allocations.
 166   const char* names[SymbolTable::symbol_alloc_batch_size];
 167   int lengths[SymbolTable::symbol_alloc_batch_size];
 168   int indices[SymbolTable::symbol_alloc_batch_size];
 169   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 170   int names_count = 0;
 171 
 172   // parsing  Index 0 is unused
 173   for (int index = 1; index &lt; length; index++) {
 174     // Each of the following case guarantees one more byte in the stream
 175     // for the following tag or the access_flags following constant pool,
 176     // so we don&#39;t need bounds-check for reading tag.
 177     const u1 tag = cfs-&gt;get_u1_fast();
 178     switch (tag) {
<span class="line-modified"> 179       case JVM_CONSTANT_Class: {</span>
 180         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 181         const u2 name_index = cfs-&gt;get_u2_fast();
 182         cp-&gt;klass_index_at_put(index, name_index);
 183         break;
 184       }
 185       case JVM_CONSTANT_Fieldref: {
 186         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 187         const u2 class_index = cfs-&gt;get_u2_fast();
 188         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 189         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 190         break;
 191       }
 192       case JVM_CONSTANT_Methodref: {
 193         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 194         const u2 class_index = cfs-&gt;get_u2_fast();
 195         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 196         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 197         break;
 198       }
 199       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 489         check_property(valid_symbol_at(name_ref_index),
 490           &quot;Invalid constant pool index %u in class file %s&quot;,
 491           name_ref_index, CHECK);
 492         check_property(valid_symbol_at(signature_ref_index),
 493           &quot;Invalid constant pool index %u in class file %s&quot;,
 494           signature_ref_index, CHECK);
 495         break;
 496       }
 497       case JVM_CONSTANT_Utf8:
 498         break;
 499       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 500       case JVM_CONSTANT_UnresolvedClassInError: {
 501         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 502         break;
 503       }
 504       case JVM_CONSTANT_ClassIndex: {
 505         const int class_index = cp-&gt;klass_index_at(index);
 506         check_property(valid_symbol_at(class_index),
 507           &quot;Invalid constant pool index %u in class file %s&quot;,
 508           class_index, CHECK);
<span class="line-modified"> 509 </span>
<span class="line-added"> 510         Symbol* const name = cp-&gt;symbol_at(class_index);</span>
<span class="line-added"> 511         const unsigned int name_len = name-&gt;utf8_length();</span>
<span class="line-added"> 512         if (name-&gt;is_Q_signature()) {</span>
<span class="line-added"> 513           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 514         } else {</span>
<span class="line-added"> 515           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 516         }</span>
 517         break;
 518       }
 519       case JVM_CONSTANT_StringIndex: {
 520         const int string_index = cp-&gt;string_index_at(index);
 521         check_property(valid_symbol_at(string_index),
 522           &quot;Invalid constant pool index %u in class file %s&quot;,
 523           string_index, CHECK);
 524         Symbol* const sym = cp-&gt;symbol_at(string_index);
 525         cp-&gt;unresolved_string_at_put(index, sym);
 526         break;
 527       }
 528       case JVM_CONSTANT_MethodHandle: {
 529         const int ref_index = cp-&gt;method_handle_index_at(index);
 530         check_property(valid_cp_range(ref_index, length),
 531           &quot;Invalid constant pool index %u in class file %s&quot;,
 532           ref_index, CHECK);
 533         const constantTag tag = cp-&gt;tag_at(ref_index);
 534         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 535 
 536         switch (ref_kind) {
</pre>
<hr />
<pre>
 750             classfile_parse_error(
 751               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 752               name_ref_index, CHECK);
 753           }
 754         }
 755         break;
 756       }
 757       case JVM_CONSTANT_MethodHandle: {
 758         const int ref_index = cp-&gt;method_handle_index_at(index);
 759         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 760         switch (ref_kind) {
 761           case JVM_REF_invokeVirtual:
 762           case JVM_REF_invokeStatic:
 763           case JVM_REF_invokeSpecial:
 764           case JVM_REF_newInvokeSpecial: {
 765             const int name_and_type_ref_index =
 766               cp-&gt;name_and_type_ref_index_at(ref_index);
 767             const int name_ref_index =
 768               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 769             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 770             if (name != vmSymbols::object_initializer_name()) {</span>
<span class="line-modified"> 771               if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
 772                 classfile_parse_error(
 773                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 774                     name_ref_index, CHECK);
 775               }
 776             } else {
<span class="line-modified"> 777               // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="line-added"> 778               // This test corresponds to verify_invoke_instructions in the verifier.</span>
<span class="line-added"> 779               const int signature_ref_index =</span>
<span class="line-added"> 780                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);</span>
<span class="line-added"> 781               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);</span>
<span class="line-added"> 782               if (signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 783                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-added"> 784                 // OK, could be a constructor call</span>
<span class="line-added"> 785               } else if (!signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 786                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {</span>
<span class="line-added"> 787                 // also OK, could be a static factory call</span>
<span class="line-added"> 788               } else {</span>
 789                 classfile_parse_error(
 790                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 791                   name_ref_index, CHECK);
 792               }
 793             }
 794             break;
 795           }
 796           // Other ref_kinds are already fully checked in previous pass.
 797         } // switch(ref_kind)
 798         break;
 799       }
 800       case JVM_CONSTANT_MethodType: {
 801         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 802         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 803         verify_legal_method_signature(no_name, signature, CHECK);
 804         break;
 805       }
 806       case JVM_CONSTANT_Utf8: {
 807         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 808       }
</pre>
<hr />
<pre>
 927   while (entry != NULL) {
 928     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 929       return false;
 930     }
 931     entry = entry-&gt;_next;
 932   }
 933 
 934   // No duplicate is found, allocate a new entry and fill it.
 935   entry = new NameSigHash();
 936   entry-&gt;_name = name;
 937   entry-&gt;_sig = sig;
 938 
 939   // Insert into hash table
 940   entry-&gt;_next = table[index];
 941   table[index] = entry;
 942 
 943   return true;
 944 }
 945 
 946 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,</span>
<span class="line-modified"> 948                                        int itfs_len,</span>
<span class="line-modified"> 949                                        ConstantPool* cp,</span>
<span class="line-added"> 950                                        bool is_inline_type,</span>
 951                                        bool* const has_nonstatic_concrete_methods,
<span class="line-added"> 952                                        // FIXME: lots of these functions</span>
<span class="line-added"> 953                                        // declare their parameters as const,</span>
<span class="line-added"> 954                                        // which adds only noise to the code.</span>
<span class="line-added"> 955                                        // Remove the spurious const modifiers.</span>
<span class="line-added"> 956                                        // Many are of the form &quot;const int x&quot;</span>
<span class="line-added"> 957                                        // or &quot;T* const x&quot;.</span>
<span class="line-added"> 958                                        bool* const is_declared_atomic,</span>
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
<span class="line-modified"> 965     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);</span>
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 968     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);</span>
<span class="line-modified"> 969     int index = 0;</span>

 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
 978         interf = cp-&gt;resolved_klass_at(interface_index);
 979       } else {
 980         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 981 
 982         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 983         // But need to make sure it&#39;s not an array type.
 984         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
<span class="line-modified"> 987         // Call resolve_super so class circularity is checked</span>
 988         interf = SystemDictionary::resolve_super_or_fail(
 989                                                   _class_name,
 990                                                   unresolved_klass,
 991                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 992                                                   _protection_domain,
 993                                                   false,
 994                                                   CHECK);
 995       }
 996 
 997       if (!interf-&gt;is_interface()) {
 998         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 999                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1000                           _class_name-&gt;as_klass_external_name(),
1001                           interf-&gt;external_name(),
1002                           interf-&gt;class_in_module_of_loader()));
1003       }
1004 
<span class="line-modified">1005       InstanceKlass* ik = InstanceKlass::cast(interf);</span>
<span class="line-added">1006       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1007         ResourceMark rm(THREAD);</span>
<span class="line-added">1008         Exceptions::fthrow(</span>
<span class="line-added">1009           THREAD_AND_LOCATION,</span>
<span class="line-added">1010           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">1011           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,</span>
<span class="line-added">1012           _class_name-&gt;as_klass_external_name());</span>
<span class="line-added">1013         return;</span>
<span class="line-added">1014       }</span>
<span class="line-added">1015       if (ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1016         set_invalid_inline_super();</span>
<span class="line-added">1017       }</span>
<span class="line-added">1018       if (ik-&gt;has_nonstatic_concrete_methods()) {</span>
1019         *has_nonstatic_concrete_methods = true;
1020       }
<span class="line-modified">1021       if (ik-&gt;is_declared_atomic()) {</span>
<span class="line-added">1022         *is_declared_atomic = true;</span>
<span class="line-added">1023       }</span>
<span class="line-added">1024       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">1025         _implements_identityObject = true;</span>
<span class="line-added">1026       }</span>
<span class="line-added">1027       _temp_local_interfaces-&gt;append(ik);</span>
1028     }
1029 
1030     if (!_need_verify || itfs_len &lt;= 1) {
1031       return;
1032     }
1033 
1034     // Check if there&#39;s any duplicates in interfaces
1035     ResourceMark rm(THREAD);
1036     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1037                                                                  NameSigHash*,
1038                                                                  HASH_ROW_SIZE);
1039     initialize_hashtable(interface_names);
1040     bool dup = false;
1041     const Symbol* name = NULL;
1042     {
1043       debug_only(NoSafepointVerifier nsv;)
1044       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">1045         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);</span>
1046         name = k-&gt;name();
1047         // If no duplicates, add (name, NULL) in hashtable interface_names.
1048         if (!put_after_lookup(name, NULL, interface_names)) {
1049           dup = true;
1050           break;
1051         }
1052       }
1053     }
1054     if (dup) {
1055       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1056                              name-&gt;as_C_string(), CHECK);
1057     }
1058   }
1059 }
1060 
1061 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1062                                            int constantvalue_index,
1063                                            int signature_index,
1064                                            TRAPS) const {
1065   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1501                                             CHECK);
1502   parsed_annotations-&gt;set_field_annotations(a);
1503   a = assemble_annotations(runtime_visible_type_annotations,
1504                            runtime_visible_type_annotations_length,
1505                            runtime_invisible_type_annotations,
1506                            runtime_invisible_type_annotations_length,
1507                            CHECK);
1508   parsed_annotations-&gt;set_field_type_annotations(a);
1509   return;
1510 }
1511 
1512 
1513 // Field allocation types. Used for computing field offsets.
1514 
1515 enum FieldAllocationType {
1516   STATIC_OOP,           // Oops
1517   STATIC_BYTE,          // Boolean, Byte, char
1518   STATIC_SHORT,         // shorts
1519   STATIC_WORD,          // ints
1520   STATIC_DOUBLE,        // aligned long or double
<span class="line-added">1521   STATIC_FLATTENABLE,   // flattenable field</span>
1522   NONSTATIC_OOP,
1523   NONSTATIC_BYTE,
1524   NONSTATIC_SHORT,
1525   NONSTATIC_WORD,
1526   NONSTATIC_DOUBLE,
<span class="line-added">1527   NONSTATIC_FLATTENABLE,</span>
1528   MAX_FIELD_ALLOCATION_TYPE,
1529   BAD_ALLOCATION_TYPE = -1
1530 };
1531 
1532 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1533   BAD_ALLOCATION_TYPE, // 0
1534   BAD_ALLOCATION_TYPE, // 1
1535   BAD_ALLOCATION_TYPE, // 2
1536   BAD_ALLOCATION_TYPE, // 3
1537   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1538   NONSTATIC_SHORT,     // T_CHAR        =  5,
1539   NONSTATIC_WORD,      // T_FLOAT       =  6,
1540   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1541   NONSTATIC_BYTE,      // T_BYTE        =  8,
1542   NONSTATIC_SHORT,     // T_SHORT       =  9,
1543   NONSTATIC_WORD,      // T_INT         = 10,
1544   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1545   NONSTATIC_OOP,       // T_OBJECT      = 12,
1546   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1547   NONSTATIC_OOP,       // T_VALUETYPE   = 14,</span>
<span class="line-modified">1548   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1549   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1550   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1551   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1552   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1553   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,</span>
1554   BAD_ALLOCATION_TYPE, // 0
1555   BAD_ALLOCATION_TYPE, // 1
1556   BAD_ALLOCATION_TYPE, // 2
1557   BAD_ALLOCATION_TYPE, // 3
1558   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1559   STATIC_SHORT,        // T_CHAR        =  5,
1560   STATIC_WORD,         // T_FLOAT       =  6,
1561   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1562   STATIC_BYTE,         // T_BYTE        =  8,
1563   STATIC_SHORT,        // T_SHORT       =  9,
1564   STATIC_WORD,         // T_INT         = 10,
1565   STATIC_DOUBLE,       // T_LONG        = 11,
1566   STATIC_OOP,          // T_OBJECT      = 12,
1567   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1568   STATIC_OOP,          // T_VALUETYPE   = 14,</span>
<span class="line-modified">1569   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1570   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1571   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1572   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1573   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1574   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20</span>
1575 };
1576 
<span class="line-modified">1577 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_flattenable) {</span>
1578   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1579   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1580   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<span class="line-added">1581   if (is_flattenable) {</span>
<span class="line-added">1582     result = is_static ? STATIC_FLATTENABLE : NONSTATIC_FLATTENABLE;</span>
<span class="line-added">1583   }</span>
1584   return result;
1585 }
1586 
1587 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1588  public:
1589   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1590 
1591   FieldAllocationCount() {
1592     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1593       count[i] = 0;
1594     }
1595   }
1596 
<span class="line-modified">1597   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {</span>
<span class="line-modified">1598     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);</span>
1599     if (atype != BAD_ALLOCATION_TYPE) {
1600       // Make sure there is no overflow with injected fields.
1601       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1602       count[atype]++;
1603     }
1604     return atype;
1605   }
1606 };
1607 
1608 // Side-effects: populates the _fields, _fields_annotations,
1609 // _fields_type_annotations fields
1610 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1611                                    bool is_interface,
<span class="line-added">1612                                    bool is_inline_type,</span>
1613                                    FieldAllocationCount* const fac,
1614                                    ConstantPool* cp,
1615                                    const int cp_size,
1616                                    u2* const java_fields_count_ptr,
1617                                    TRAPS) {
1618 
1619   assert(cfs != NULL, &quot;invariant&quot;);
1620   assert(fac != NULL, &quot;invariant&quot;);
1621   assert(cp != NULL, &quot;invariant&quot;);
1622   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1623 
1624   assert(NULL == _fields, &quot;invariant&quot;);
1625   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1626   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1627 
1628   cfs-&gt;guarantee_more(2, CHECK);  // length
1629   const u2 length = cfs-&gt;get_u2_fast();
1630   *java_fields_count_ptr = length;
1631 
1632   int num_injected = 0;
1633   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1634                                                                   &amp;num_injected);
<span class="line-modified">1635 </span>
<span class="line-added">1636   // two more slots are required for inline classes:</span>
<span class="line-added">1637   // one for the static field with a reference to the pre-allocated default value</span>
<span class="line-added">1638   // one for the field the JVM injects when detecting an empty inline class</span>
<span class="line-added">1639   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);</span>
1640 
1641   // The field array starts with tuples of shorts
1642   // [access, name index, sig index, initial value index, byte offset].
1643   // A generic signature slot only exists for field with generic
1644   // signature attribute. And the access flag is set with
1645   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1646   // signature slots are at the end of the field array and after all
1647   // other fields data.
1648   //
1649   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1650   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1651   //       ...
1652   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1653   //       [generic signature index]
1654   //       [generic signature index]
1655   //       ...
1656   //
1657   // Allocate a temporary resource array for field data. For each field,
1658   // a slot is reserved in the temporary array for the generic signature
1659   // index. After parsing all fields, the data are copied to a permanent
1660   // array and any unused slots will be discarded.
1661   ResourceMark rm(THREAD);
1662   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1663                                               u2,
1664                                               total_fields * (FieldInfo::field_slots + 1));
1665 
1666   // The generic signature slots start after all other fields&#39; data.
1667   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1668   int num_generic_signature = 0;
<span class="line-added">1669   int instance_fields_count = 0;</span>
1670   for (int n = 0; n &lt; length; n++) {
1671     // access_flags, name_index, descriptor_index, attributes_count
1672     cfs-&gt;guarantee_more(8, CHECK);
1673 
<span class="line-added">1674     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-added">1675 </span>
<span class="line-added">1676     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">1677     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);</span>
1678     AccessFlags access_flags;


1679     access_flags.set_flags(flags);
1680 
1681     const u2 name_index = cfs-&gt;get_u2_fast();
1682     check_property(valid_symbol_at(name_index),
1683       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1684       name_index, CHECK);
1685     const Symbol* const name = cp-&gt;symbol_at(name_index);
1686     verify_legal_field_name(name, CHECK);
1687 
1688     const u2 signature_index = cfs-&gt;get_u2_fast();
1689     check_property(valid_symbol_at(signature_index),
1690       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1691       signature_index, CHECK);
1692     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1693     verify_legal_field_signature(name, sig, CHECK);
<span class="line-added">1694     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);</span>
<span class="line-added">1695     if (sig-&gt;is_Q_signature()) {</span>
<span class="line-added">1696       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);</span>
<span class="line-added">1697       access_flags.set_is_flattenable();</span>
<span class="line-added">1698     }</span>
<span class="line-added">1699     if (access_flags.is_flattenable()) {</span>
<span class="line-added">1700       // Array flattenability cannot be specified.  Arrays of value classes are</span>
<span class="line-added">1701       // are always flattenable.  Arrays of other classes are not flattenable.</span>
<span class="line-added">1702       if (sig-&gt;utf8_length() &gt; 1 &amp;&amp; sig-&gt;char_at(0) == &#39;[&#39;) {</span>
<span class="line-added">1703         classfile_parse_error(</span>
<span class="line-added">1704             &quot;Field \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s is invalid.&quot;</span>
<span class="line-added">1705             &quot; ACC_FLATTENABLE cannot be specified for an array&quot;,</span>
<span class="line-added">1706             name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);</span>
<span class="line-added">1707       }</span>
<span class="line-added">1708       _has_flattenable_fields = true;</span>
<span class="line-added">1709     }</span>
<span class="line-added">1710     if (!access_flags.is_static()) instance_fields_count++;</span>
1711 
1712     u2 constantvalue_index = 0;
1713     bool is_synthetic = false;
1714     u2 generic_signature_index = 0;
1715     const bool is_static = access_flags.is_static();
1716     FieldAnnotationCollector parsed_annotations(_loader_data);
1717 
1718     const u2 attributes_count = cfs-&gt;get_u2_fast();
1719     if (attributes_count &gt; 0) {
1720       parse_field_attributes(cfs,
1721                              attributes_count,
1722                              is_static,
1723                              signature_index,
1724                              &amp;constantvalue_index,
1725                              &amp;is_synthetic,
1726                              &amp;generic_signature_index,
1727                              &amp;parsed_annotations,
1728                              CHECK);
1729 
1730       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1750 
1751       if (is_synthetic) {
1752         access_flags.set_is_synthetic();
1753       }
1754       if (generic_signature_index != 0) {
1755         access_flags.set_field_has_generic_signature();
1756         fa[generic_signature_slot] = generic_signature_index;
1757         generic_signature_slot ++;
1758         num_generic_signature ++;
1759       }
1760     }
1761 
1762     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1763     field-&gt;initialize(access_flags.as_short(),
1764                       name_index,
1765                       signature_index,
1766                       constantvalue_index);
1767     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1768 
1769     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1770     const FieldAllocationType atype = fac-&gt;update(is_static, type, access_flags.is_flattenable());</span>
1771     field-&gt;set_allocation_type(atype);
1772 
1773     // After field is initialized with type, we can augment it with aux info
1774     if (parsed_annotations.has_any_annotations()) {
1775       parsed_annotations.apply_to(field);
1776       if (field-&gt;is_contended()) {
1777         _has_contended_fields = true;
1778       }
1779     }
1780   }
1781 
1782   int index = length;
1783   if (num_injected != 0) {
1784     for (int n = 0; n &lt; num_injected; n++) {
1785       // Check for duplicates
1786       if (injected[n].may_be_java) {
1787         const Symbol* const name      = injected[n].name();
1788         const Symbol* const signature = injected[n].signature();
1789         bool duplicate = false;
1790         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1795             duplicate = true;
1796             break;
1797           }
1798         }
1799         if (duplicate) {
1800           // These will be removed from the field array at the end
1801           continue;
1802         }
1803       }
1804 
1805       // Injected field
1806       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1807       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1808                         injected[n].name_index,
1809                         injected[n].signature_index,
1810                         0);
1811 
1812       const BasicType type = Signature::basic_type(injected[n].signature());
1813 
1814       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1815       const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
1816       field-&gt;set_allocation_type(atype);
1817       index++;
1818     }
1819   }
1820 
<span class="line-added">1821   if (is_inline_type) {</span>
<span class="line-added">1822     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1823     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,</span>
<span class="line-added">1824                       vmSymbols::default_value_name_enum,</span>
<span class="line-added">1825                       vmSymbols::object_signature_enum,</span>
<span class="line-added">1826                       0);</span>
<span class="line-added">1827     const BasicType type = Signature::basic_type(vmSymbols::object_signature());</span>
<span class="line-added">1828     const FieldAllocationType atype = fac-&gt;update(true, type, false);</span>
<span class="line-added">1829     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1830     index++;</span>
<span class="line-added">1831   }</span>
<span class="line-added">1832 </span>
<span class="line-added">1833   if (is_inline_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-added">1834     _is_empty_inline_type = true;</span>
<span class="line-added">1835     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1836     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,</span>
<span class="line-added">1837         vmSymbols::empty_marker_name_enum,</span>
<span class="line-added">1838         vmSymbols::byte_signature_enum,</span>
<span class="line-added">1839         0);</span>
<span class="line-added">1840     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());</span>
<span class="line-added">1841     const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
<span class="line-added">1842     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1843     index++;</span>
<span class="line-added">1844   }</span>
<span class="line-added">1845 </span>
<span class="line-added">1846   if (instance_fields_count &gt; 0) {</span>
<span class="line-added">1847     _has_nonstatic_fields = true;</span>
<span class="line-added">1848   }</span>
<span class="line-added">1849 </span>
1850   assert(NULL == _fields, &quot;invariant&quot;);
1851 
1852   _fields =
1853     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1854                                    index * FieldInfo::field_slots + num_generic_signature,
1855                                    CHECK);
1856   // Sometimes injected fields already exist in the Java source so
1857   // the fields array could be too long.  In that case the
1858   // fields array is trimed. Also unused slots that were reserved
1859   // for generic signature indexes are discarded.
1860   {
1861     int i = 0;
1862     for (; i &lt; index * FieldInfo::field_slots; i++) {
1863       _fields-&gt;at_put(i, fa[i]);
1864     }
1865     for (int j = total_fields * FieldInfo::field_slots;
1866          j &lt; generic_signature_slot; j++) {
1867       _fields-&gt;at_put(i++, fa[j]);
1868     }
1869     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2145         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2146         checked_exception, CHECK_NULL);
2147     }
2148   }
2149   // check exceptions attribute length
2150   if (_need_verify) {
2151     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2152                                                    sizeof(u2) * size),
2153                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2154   }
2155   return checked_exceptions_start;
2156 }
2157 
2158 void ClassFileParser::throwIllegalSignature(const char* type,
2159                                             const Symbol* name,
2160                                             const Symbol* sig,
2161                                             TRAPS) const {
2162   assert(name != NULL, &quot;invariant&quot;);
2163   assert(sig != NULL, &quot;invariant&quot;);
2164 
<span class="line-added">2165   const char* class_note = &quot;&quot;;</span>
<span class="line-added">2166   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2167     class_note = &quot; (an inline class)&quot;;</span>
<span class="line-added">2168   }</span>
<span class="line-added">2169 </span>
2170   ResourceMark rm(THREAD);
2171   Exceptions::fthrow(THREAD_AND_LOCATION,
2172       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2173       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2174       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());</span>
2175 }
2176 
2177 AnnotationCollector::ID
2178 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2179                                       const Symbol* name,
2180                                       const bool can_access_vm_annotations) {
2181   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2182   // Privileged code can use all annotations.  Other code silently drops some.
2183   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2184                           loader_data-&gt;is_platform_class_loader_data() ||
2185                           can_access_vm_annotations;
2186   switch (sid) {
2187     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2188       if (_location != _in_method)  break;  // only allow for methods
2189       if (!privileged)              break;  // only allow in privileged code
2190       return _method_CallerSensitive;
2191     }
2192     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2193       if (_location != _in_method)  break;  // only allow for methods
2194       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2419                              runtime_visible_type_annotations_length,
2420                              runtime_invisible_type_annotations,
2421                              runtime_invisible_type_annotations_length,
2422                              CHECK);
2423     cm-&gt;set_type_annotations(a);
2424   }
2425 }
2426 
2427 
2428 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2429 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2430 // Method* to save footprint, so we only know the size of the resulting Method* when the
2431 // entire method attribute is parsed.
2432 //
2433 // The promoted_flags parameter is used to pass relevant access_flags
2434 // from the method back up to the containing klass. These flag values
2435 // are added to klass&#39;s access_flags.
2436 
2437 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2438                                       bool is_interface,
<span class="line-added">2439                                       bool is_inline_type,</span>
2440                                       const ConstantPool* cp,
2441                                       AccessFlags* const promoted_flags,
2442                                       TRAPS) {
2443   assert(cfs != NULL, &quot;invariant&quot;);
2444   assert(cp != NULL, &quot;invariant&quot;);
2445   assert(promoted_flags != NULL, &quot;invariant&quot;);
2446 
2447   ResourceMark rm(THREAD);
2448   // Parse fixed parts:
2449   // access_flags, name_index, descriptor_index, attributes_count
2450   cfs-&gt;guarantee_more(8, CHECK_NULL);
2451 
2452   int flags = cfs-&gt;get_u2_fast();
2453   const u2 name_index = cfs-&gt;get_u2_fast();
2454   const int cp_size = cp-&gt;length();
2455   check_property(
2456     valid_symbol_at(name_index),
2457     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2458     name_index, CHECK_NULL);
2459   const Symbol* const name = cp-&gt;symbol_at(name_index);
2460   verify_legal_method_name(name, CHECK_NULL);
2461 
2462   const u2 signature_index = cfs-&gt;get_u2_fast();
2463   guarantee_property(
2464     valid_symbol_at(signature_index),
2465     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2466     signature_index, CHECK_NULL);
2467   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2468 
2469   if (name == vmSymbols::class_initializer_name()) {
2470     // We ignore the other access flags for a valid class initializer.
2471     // (JVM Spec 2nd ed., chapter 4.6)
2472     if (_major_version &lt; 51) { // backward compatibility
2473       flags = JVM_ACC_STATIC;
2474     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2475       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2476     } else {
2477       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2478     }
2479   } else {
<span class="line-modified">2480     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);</span>
<span class="line-modified">2481   }</span>
<span class="line-modified">2482 </span>
<span class="line-modified">2483   if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">2484     if (is_interface) {</span>
<span class="line-added">2485       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>
<span class="line-added">2486     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2487       // OK, a constructor</span>
<span class="line-added">2488     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2489       // also OK, a static factory, as long as the return value is good</span>
<span class="line-added">2490       bool ok = false;</span>
<span class="line-added">2491       SignatureStream ss((Symbol*) signature, true);</span>
<span class="line-added">2492       while (!ss.at_return_type())  ss.next();</span>
<span class="line-added">2493       if (ss.is_reference()) {</span>
<span class="line-added">2494         Symbol* ret = ss.as_symbol();</span>
<span class="line-added">2495         const Symbol* required = class_name();</span>
<span class="line-added">2496         if (is_unsafe_anonymous()) {</span>
<span class="line-added">2497           // The original class name in the UAC byte stream gets changed.  So</span>
<span class="line-added">2498           // using the original name in the return type is no longer valid.</span>
<span class="line-added">2499           required = vmSymbols::java_lang_Object();</span>
<span class="line-added">2500         }</span>
<span class="line-added">2501         ok = (ret == required);</span>
<span class="line-added">2502       }</span>
<span class="line-added">2503       if (!ok) {</span>
<span class="line-added">2504         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2505       }</span>
<span class="line-added">2506     } else {</span>
<span class="line-added">2507       // not OK, so throw the same error as in verify_legal_method_signature.</span>
<span class="line-added">2508       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2509     }</span>
<span class="line-added">2510     // A declared &lt;init&gt; method must always be either a non-static</span>
<span class="line-added">2511     // object constructor, with a void return, or else it must be a</span>
<span class="line-added">2512     // static factory method, with a non-void return.  No other</span>
<span class="line-added">2513     // definition of &lt;init&gt; is possible.</span>
<span class="line-added">2514     //</span>
<span class="line-added">2515     // The verifier (in verify_invoke_instructions) will inspect the</span>
<span class="line-added">2516     // signature of any attempt to invoke &lt;init&gt;, and ensures that it</span>
<span class="line-added">2517     // returns non-void if and only if it is being invoked by</span>
<span class="line-added">2518     // invokestatic, and void if and only if it is being invoked by</span>
<span class="line-added">2519     // invokespecial.</span>
<span class="line-added">2520     //</span>
<span class="line-added">2521     // When a symbolic reference to &lt;init&gt; is resolved for a</span>
<span class="line-added">2522     // particular invocation mode (special or static), the mode is</span>
<span class="line-added">2523     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.</span>
<span class="line-added">2524     // Thus, it is impossible to statically invoke a constructor, and</span>
<span class="line-added">2525     // impossible to &quot;new + invokespecial&quot; a static factory, either</span>
<span class="line-added">2526     // through bytecode or through reflection.</span>
2527   }
2528 
2529   int args_size = -1;  // only used when _need_verify is true
2530   if (_need_verify) {
2531     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2532                  verify_legal_method_signature(name, signature, CHECK_NULL);
2533     if (args_size &gt; MAX_ARGS_SIZE) {
2534       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2535     }
2536   }
2537 
2538   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2539 
2540   // Default values for code and exceptions attribute elements
2541   u2 max_stack = 0;
2542   u2 max_locals = 0;
2543   u4 code_length = 0;
2544   const u1* code_start = 0;
2545   u2 exception_table_length = 0;
2546   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
3057       _has_finalizer = true;
3058     }
3059   }
3060   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3061       signature == vmSymbols::void_method_signature() &amp;&amp;
3062       m-&gt;is_vanilla_constructor()) {
3063     _has_vanilla_constructor = true;
3064   }
3065 
3066   NOT_PRODUCT(m-&gt;verify());
3067   return m;
3068 }
3069 
3070 
3071 // The promoted_flags parameter is used to pass relevant access_flags
3072 // from the methods back up to the containing klass. These flag values
3073 // are added to klass&#39;s access_flags.
3074 // Side-effects: populates the _methods field in the parser
3075 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3076                                     bool is_interface,
<span class="line-added">3077                                     bool is_inline_type,</span>
3078                                     AccessFlags* promoted_flags,
3079                                     bool* has_final_method,
3080                                     bool* declares_nonstatic_concrete_methods,
3081                                     TRAPS) {
3082   assert(cfs != NULL, &quot;invariant&quot;);
3083   assert(promoted_flags != NULL, &quot;invariant&quot;);
3084   assert(has_final_method != NULL, &quot;invariant&quot;);
3085   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3086 
3087   assert(NULL == _methods, &quot;invariant&quot;);
3088 
3089   cfs-&gt;guarantee_more(2, CHECK);  // length
3090   const u2 length = cfs-&gt;get_u2_fast();
3091   if (length == 0) {
3092     _methods = Universe::the_empty_method_array();
3093   } else {
3094     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3095                                                    length,
3096                                                    NULL,
3097                                                    CHECK);
3098 
3099     for (int index = 0; index &lt; length; index++) {
3100       Method* method = parse_method(cfs,
3101                                     is_interface,
<span class="line-added">3102                                     is_inline_type,</span>
3103                                     _cp,
3104                                     promoted_flags,
3105                                     CHECK);
3106 
3107       if (method-&gt;is_final()) {
3108         *has_final_method = true;
3109       }
3110       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3111       // used for interface initialization, and default method inheritance analysis
3112       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3113         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3114         *declares_nonstatic_concrete_methods = true;
3115       }
3116       _methods-&gt;at_put(index, method);
3117     }
3118 
3119     if (_need_verify &amp;&amp; length &gt; 1) {
3120       // Check duplicated methods
3121       ResourceMark rm(THREAD);
3122       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3275       valid_klass_reference_at(inner_class_info_index),
3276       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3277       inner_class_info_index, CHECK_0);
3278     // Outer class index
3279     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3280     check_property(
3281       outer_class_info_index == 0 ||
3282         valid_klass_reference_at(outer_class_info_index),
3283       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3284       outer_class_info_index, CHECK_0);
3285     // Inner class name
3286     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3287     check_property(
3288       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3289       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3290       inner_name_index, CHECK_0);
3291     if (_need_verify) {
3292       guarantee_property(inner_class_info_index != outer_class_info_index,
3293                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3294     }
<span class="line-modified">3295 </span>
<span class="line-modified">3296     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
3297     // JVM_ACC_MODULE is defined in JDK-9 and later.
3298     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3299       recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">3300     }</span>
<span class="line-modified">3301     // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">3302     if (supports_inline_types()) {</span>
<span class="line-added">3303       recognized_modifiers |= JVM_ACC_VALUE;</span>
3304     }
<span class="line-added">3305 </span>
<span class="line-added">3306     // Access flags</span>
<span class="line-added">3307     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">3308 </span>
3309     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3310       // Set abstract bit for old class files for backward compatibility
3311       flags |= JVM_ACC_ABSTRACT;
3312     }
3313     verify_legal_class_modifiers(flags, CHECK_0);
3314     AccessFlags inner_access_flags(flags);
3315 
3316     inner_classes-&gt;at_put(index++, inner_class_info_index);
3317     inner_classes-&gt;at_put(index++, outer_class_info_index);
3318     inner_classes-&gt;at_put(index++, inner_name_index);
3319     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3320   }
3321 
3322   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3323   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3324     for(int i = 0; i &lt; length * 4; i += 4) {
3325       for(int j = i + 4; j &lt; length * 4; j += 4) {
3326         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3327                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3328                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
4148       }
4149     }
4150     if (runtime_invisible_annotations != NULL) {
4151       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
4152         int append = runtime_visible_annotations_length+i;
4153         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
4154       }
4155     }
4156   }
4157   return annotations;
4158 }
4159 
4160 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
4161                                                         const int super_class_index,
4162                                                         const bool need_verify,
4163                                                         TRAPS) {
4164   assert(cp != NULL, &quot;invariant&quot;);
4165   const InstanceKlass* super_klass = NULL;
4166 
4167   if (super_class_index == 0) {
<span class="line-modified">4168     check_property(_class_name == vmSymbols::java_lang_Object()</span>
<span class="line-added">4169                    || (_access_flags.get_flags() &amp; JVM_ACC_VALUE),</span>
4170                    &quot;Invalid superclass index %u in class file %s&quot;,
4171                    super_class_index,
4172                    CHECK_NULL);
4173   } else {
4174     check_property(valid_klass_reference_at(super_class_index),
4175                    &quot;Invalid superclass index %u in class file %s&quot;,
4176                    super_class_index,
4177                    CHECK_NULL);
4178     // The class name should be legal because it is checked when parsing constant pool.
4179     // However, make sure it is not an array type.
4180     bool is_array = false;
4181     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4182       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4183       if (need_verify)
4184         is_array = super_klass-&gt;is_array_klass();
4185     } else if (need_verify) {
4186       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4187     }
4188     if (need_verify) {
4189       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4329 }
4330 
4331 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4332   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4333   if (_nonstatic_oop_map_count &gt; 0) {
4334     OopMapBlock* map = _nonstatic_oop_maps;
4335     OopMapBlock* last_map = last_oop_map();
4336     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4337     while (map &lt;= last_map) {
4338       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4339                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4340       map++;
4341     }
4342   }
4343 }
4344 
4345 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4346   print_on(st);
4347 }
4348 
<span class="line-added">4349 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-added">4350                                                 const char* msg,</span>
<span class="line-added">4351                                                 const Symbol* name,</span>
<span class="line-added">4352                                                 const Symbol* sig) const {</span>
<span class="line-added">4353 </span>
<span class="line-added">4354   ResourceMark rm(THREAD);</span>
<span class="line-added">4355   if (name == NULL || sig == NULL) {</span>
<span class="line-added">4356     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4357         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4358         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4359   }</span>
<span class="line-added">4360   else {</span>
<span class="line-added">4361     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4362         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4363         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),</span>
<span class="line-added">4364         _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4365   }</span>
<span class="line-added">4366 }</span>
<span class="line-added">4367 </span>
4368 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4369 void ClassFileParser::layout_fields(ConstantPool* cp,
4370                                     const FieldAllocationCount* fac,
4371                                     const ClassAnnotationCollector* parsed_annotations,
4372                                     FieldLayoutInfo* info,
4373                                     TRAPS) {
4374 
4375   assert(cp != NULL, &quot;invariant&quot;);
4376 
4377   // Field size and offset computation
4378   int nonstatic_field_size = _super_klass == NULL ? 0 :
4379                                _super_klass-&gt;nonstatic_field_size();
<span class="line-added">4380   int next_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">4381   int first_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">4382 </span>
<span class="line-added">4383   // Fields that are inline types are handled differently depending if they are static or not:</span>
<span class="line-added">4384   // - static fields are oops</span>
<span class="line-added">4385   // - non-static fields are embedded</span>
4386 
4387   // Count the contended fields by type.
4388   //
4389   // We ignore static fields, because @Contended is not supported for them.
4390   // The layout code below will also ignore the static fields.
4391   int nonstatic_contended_count = 0;
4392   FieldAllocationCount fac_contended;
4393   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4394     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4395     if (fs.is_contended()) {
4396       fac_contended.count[atype]++;
4397       if (!fs.access_flags().is_static()) {
4398         nonstatic_contended_count++;
4399       }
4400     }
4401   }
4402 
4403 
4404   // Calculate the starting byte offsets
4405   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-added">4406   // Inline types in static fields are not embedded, they are handled with oops</span>
4407   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4408                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);</span>
4409   if (fac-&gt;count[STATIC_DOUBLE]) {
4410     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4411   }
4412 
4413   int next_static_word_offset   = next_static_double_offset +
4414                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4415   int next_static_short_offset  = next_static_word_offset +
4416                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4417   int next_static_byte_offset   = next_static_short_offset +
4418                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4419 
4420   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4421                                 nonstatic_field_size * heapOopSize;
4422 
<span class="line-added">4423   // First field of inline types is aligned on a long boundary in order to ease</span>
<span class="line-added">4424   // in-lining of inline types (with header removal) in packed arrays and</span>
<span class="line-added">4425   // flatten inline types</span>
<span class="line-added">4426   int initial_inline_type_padding = 0;</span>
<span class="line-added">4427   if (is_inline_type()) {</span>
<span class="line-added">4428     int old = nonstatic_fields_start;</span>
<span class="line-added">4429     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);</span>
<span class="line-added">4430     initial_inline_type_padding = nonstatic_fields_start - old;</span>
<span class="line-added">4431   }</span>
<span class="line-added">4432 </span>
4433   int next_nonstatic_field_offset = nonstatic_fields_start;
4434 
4435   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4436 
4437   // Class is contended, pad before all the fields
4438   if (is_contended_class) {
4439     next_nonstatic_field_offset += ContendedPaddingWidth;
4440   }
4441 
<span class="line-added">4442   // Temporary inline types restrictions</span>
<span class="line-added">4443   if (is_inline_type()) {</span>
<span class="line-added">4444     if (is_contended_class) {</span>
<span class="line-added">4445       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
<span class="line-added">4446       return;</span>
<span class="line-added">4447     }</span>
<span class="line-added">4448   }</span>
<span class="line-added">4449 </span>
4450   // Compute the non-contended fields count.
4451   // The packing code below relies on these counts to determine if some field
4452   // can be squeezed into the alignment gap. Contended fields are obviously
4453   // exempt from that.
4454   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4455   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4456   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4457   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4458   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4459 
<span class="line-added">4460   int static_inline_type_count = 0;</span>
<span class="line-added">4461   int nonstatic_inline_type_count = 0;</span>
<span class="line-added">4462   int* nonstatic_inline_type_indexes = NULL;</span>
<span class="line-added">4463   Klass** nonstatic_inline_type_klasses = NULL;</span>
<span class="line-added">4464   unsigned int inline_type_oop_map_count = 0;</span>
<span class="line-added">4465   int not_flattened_inline_types = 0;</span>
<span class="line-added">4466   int not_atomic_inline_types = 0;</span>
<span class="line-added">4467 </span>
<span class="line-added">4468   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
<span class="line-added">4469 </span>
<span class="line-added">4470   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-added">4471                                                                max_nonstatic_inline_type);</span>
<span class="line-added">4472   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {</span>
<span class="line-added">4473     nonstatic_inline_type_indexes[i] = -1;</span>
<span class="line-added">4474   }</span>
<span class="line-added">4475   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-added">4476                                                                max_nonstatic_inline_type);</span>
<span class="line-added">4477 </span>
<span class="line-added">4478   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {</span>
<span class="line-added">4479     if (fs.allocation_type() == STATIC_FLATTENABLE) {</span>
<span class="line-added">4480       ResourceMark rm;</span>
<span class="line-added">4481       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4482         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4483       }</span>
<span class="line-added">4484       static_inline_type_count++;</span>
<span class="line-added">4485     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {</span>
<span class="line-added">4486       // Pre-resolve the flattenable field and check for inline type circularity issues.</span>
<span class="line-added">4487       ResourceMark rm;</span>
<span class="line-added">4488       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4489         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4490       }</span>
<span class="line-added">4491       Klass* klass =</span>
<span class="line-added">4492         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">4493                                                             Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">4494                                                             _protection_domain, true, CHECK);</span>
<span class="line-added">4495       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">4496       if (!klass-&gt;access_flags().is_inline_type()) {</span>
<span class="line-added">4497         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">4498       }</span>
<span class="line-added">4499       ValueKlass* vk = ValueKlass::cast(klass);</span>
<span class="line-added">4500       // Conditions to apply flattening or not should be defined in a single place</span>
<span class="line-added">4501       bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-added">4502                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
<span class="line-added">4503       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();</span>
<span class="line-added">4504       bool too_volatile_to_flatten = fs.access_flags().is_volatile();</span>
<span class="line-added">4505       if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-added">4506         too_atomic_to_flatten = false;</span>
<span class="line-added">4507         //too_volatile_to_flatten = false; //FIXME</span>
<span class="line-added">4508         // volatile fields are currently never flattened, this could change in the future</span>
<span class="line-added">4509       }</span>
<span class="line-added">4510       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {</span>
<span class="line-added">4511         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();</span>
<span class="line-added">4512         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;</span>
<span class="line-added">4513         nonstatic_inline_type_count++;</span>
<span class="line-added">4514 </span>
<span class="line-added">4515         ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4516         if (vklass-&gt;contains_oops()) {</span>
<span class="line-added">4517           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4518         }</span>
<span class="line-added">4519         fs.set_flattened(true);</span>
<span class="line-added">4520         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-added">4521           not_atomic_inline_types++;</span>
<span class="line-added">4522         }</span>
<span class="line-added">4523       } else {</span>
<span class="line-added">4524         not_flattened_inline_types++;</span>
<span class="line-added">4525         fs.set_flattened(false);</span>
<span class="line-added">4526       }</span>
<span class="line-added">4527     }</span>
<span class="line-added">4528   }</span>
<span class="line-added">4529 </span>
<span class="line-added">4530   // Adjusting non_static_oop_count to take into account not flattened inline types;</span>
<span class="line-added">4531   nonstatic_oop_count += not_flattened_inline_types;</span>
<span class="line-added">4532 </span>
4533   // Total non-static fields count, including every contended field
4534   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4535                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4536                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];</span>
4537 
4538   const bool super_has_nonstatic_fields =
4539           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4540   const bool has_nonstatic_fields =
4541     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-added">4542   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;</span>
4543 
<span class="line-added">4544   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
<span class="line-added">4545     // There are a number of fixes required throughout the type system and JIT</span>
<span class="line-added">4546     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
<span class="line-added">4547     return;</span>
<span class="line-added">4548   }</span>
4549 
4550   // Prepare list of oops for oop map generation.
4551   //
4552   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4553   // regions. offset[i] is the start of the i-th region, which then has
4554   // count[i] oops following. Before we know how many regions are required,
4555   // we pessimistically allocate the maps to fit all the oops into the
4556   // distinct regions.
<span class="line-modified">4557   //</span>
4558   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4559   int max_oop_map_count =</span>
<span class="line-added">4560       super_oop_map_count +</span>
<span class="line-added">4561       fac-&gt;count[NONSTATIC_OOP] +</span>
<span class="line-added">4562       inline_type_oop_map_count +</span>
<span class="line-added">4563       not_flattened_inline_types;</span>
4564 
4565   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4566   if (super_oop_map_count &gt; 0) {
4567     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4568                                                     _super_klass-&gt;nonstatic_oop_map_count());
4569   }
4570 
4571   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4572 
4573   bool compact_fields  = true;
4574   bool allocate_oops_first = false;
4575 
4576   int next_nonstatic_oop_offset = 0;
4577   int next_nonstatic_double_offset = 0;
4578 
4579   // Rearrange fields for a given allocation style
4580   if (allocate_oops_first) {
4581     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4582     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4583     next_nonstatic_double_offset = next_nonstatic_oop_offset +
</pre>
<hr />
<pre>
4638   }
4639 
4640   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4641                                      (nonstatic_double_count * BytesPerLong);
4642   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4643                                       (nonstatic_word_count * BytesPerInt);
4644   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4645                                      (nonstatic_short_count * BytesPerShort);
4646   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4647                                        nonstatic_byte_count;
4648 
4649   // let oops jump before padding with this allocation style
4650   if (!allocate_oops_first) {
4651     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4652     if( nonstatic_oop_count &gt; 0 ) {
4653       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4654     }
4655     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4656   }
4657 
<span class="line-added">4658   // Aligning embedded inline types</span>
<span class="line-added">4659   // bug below, the current algorithm to layout embedded inline types always put them at the</span>
<span class="line-added">4660   // end of the layout, which doesn&#39;t match the different allocation policies the VM is</span>
<span class="line-added">4661   // supposed to provide =&gt; FixMe</span>
<span class="line-added">4662   // Note also that the current alignment policy is to make each inline type starting on a</span>
<span class="line-added">4663   // 64 bits boundary. This could be optimized later. For instance, it could be nice to</span>
<span class="line-added">4664   // align inline types according to their most constrained internal type.</span>
<span class="line-added">4665   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-added">4666   int next_inline_type_index = 0;</span>
<span class="line-added">4667 </span>
4668   // Iterate over fields again and compute correct offsets.
4669   // The field allocation type was temporarily stored in the offset slot.
4670   // oop fields are located before non-oop fields (static and non-static).
4671   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4672 
4673     // skip already laid out fields
4674     if (fs.is_offset_set()) continue;
4675 
4676     // contended instance fields are handled below
4677     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4678 
4679     int real_offset = 0;
4680     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4681 
4682     // pack the rest of the fields
4683     switch (atype) {
<span class="line-added">4684       // Inline types in static fields are handled with oops</span>
<span class="line-added">4685       case STATIC_FLATTENABLE:   // Fallthrough</span>
4686       case STATIC_OOP:
4687         real_offset = next_static_oop_offset;
4688         next_static_oop_offset += heapOopSize;
4689         break;
4690       case STATIC_BYTE:
4691         real_offset = next_static_byte_offset;
4692         next_static_byte_offset += 1;
4693         break;
4694       case STATIC_SHORT:
4695         real_offset = next_static_short_offset;
4696         next_static_short_offset += BytesPerShort;
4697         break;
4698       case STATIC_WORD:
4699         real_offset = next_static_word_offset;
4700         next_static_word_offset += BytesPerInt;
4701         break;
4702       case STATIC_DOUBLE:
4703         real_offset = next_static_double_offset;
4704         next_static_double_offset += BytesPerLong;
4705         break;
<span class="line-added">4706       case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">4707         if (fs.is_flattened()) {</span>
<span class="line-added">4708           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];</span>
<span class="line-added">4709           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);</span>
<span class="line-added">4710           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);</span>
<span class="line-added">4711           ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4712           real_offset = next_nonstatic_inline_type_offset;</span>
<span class="line-added">4713           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-added">4714           // aligning next inline type on a 64 bits boundary</span>
<span class="line-added">4715           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);</span>
<span class="line-added">4716           next_inline_type_index += 1;</span>
<span class="line-added">4717 </span>
<span class="line-added">4718           if (vklass-&gt;contains_oops()) { // add flatten oop maps</span>
<span class="line-added">4719             int diff = real_offset - vklass-&gt;first_field_offset();</span>
<span class="line-added">4720             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">4721             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4722             while (map &lt; last_map) {</span>
<span class="line-added">4723               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());</span>
<span class="line-added">4724               map++;</span>
<span class="line-added">4725             }</span>
<span class="line-added">4726           }</span>
<span class="line-added">4727           break;</span>
<span class="line-added">4728         } else {</span>
<span class="line-added">4729           // Fall through</span>
<span class="line-added">4730         }</span>
4731       case NONSTATIC_OOP:
4732         if( nonstatic_oop_space_count &gt; 0 ) {
4733           real_offset = nonstatic_oop_space_offset;
4734           nonstatic_oop_space_offset += heapOopSize;
4735           nonstatic_oop_space_count  -= 1;
4736         } else {
4737           real_offset = next_nonstatic_oop_offset;
4738           next_nonstatic_oop_offset += heapOopSize;
4739         }
4740         nonstatic_oop_maps-&gt;add(real_offset, 1);
4741         break;
4742       case NONSTATIC_BYTE:
4743         if( nonstatic_byte_space_count &gt; 0 ) {
4744           real_offset = nonstatic_byte_space_offset;
4745           nonstatic_byte_space_offset += 1;
4746           nonstatic_byte_space_count  -= 1;
4747         } else {
4748           real_offset = next_nonstatic_byte_offset;
4749           next_nonstatic_byte_offset += 1;
4750         }
</pre>
<hr />
<pre>
4829             break;
4830 
4831           case NONSTATIC_SHORT:
4832             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4833             real_offset = next_nonstatic_padded_offset;
4834             next_nonstatic_padded_offset += BytesPerShort;
4835             break;
4836 
4837           case NONSTATIC_WORD:
4838             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4839             real_offset = next_nonstatic_padded_offset;
4840             next_nonstatic_padded_offset += BytesPerInt;
4841             break;
4842 
4843           case NONSTATIC_DOUBLE:
4844             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4845             real_offset = next_nonstatic_padded_offset;
4846             next_nonstatic_padded_offset += BytesPerLong;
4847             break;
4848 
<span class="line-added">4849             // Inline types in static fields are handled with oops</span>
<span class="line-added">4850           case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">4851             throwInlineTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-added">4852                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
<span class="line-added">4853             return;</span>
<span class="line-added">4854 </span>
4855           case NONSTATIC_OOP:
4856             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4857             real_offset = next_nonstatic_padded_offset;
4858             next_nonstatic_padded_offset += heapOopSize;
4859             nonstatic_oop_maps-&gt;add(real_offset, 1);
4860             break;
4861 
4862           default:
4863             ShouldNotReachHere();
4864         }
4865 
4866         if (fs.contended_group() == 0) {
4867           // Contended group defines the equivalence class over the fields:
4868           // the fields within the same contended group are not inter-padded.
4869           // The only exception is default group, which does not incur the
4870           // equivalence, and so requires intra-padding.
4871           next_nonstatic_padded_offset += ContendedPaddingWidth;
4872         }
4873 
4874         fs.set_offset(real_offset);
4875       } // for
4876 
4877       // Start laying out the next group.
4878       // Note that this will effectively pad the last group in the back;
4879       // this is expected to alleviate memory contention effects for
4880       // subclass fields and/or adjacent object.
4881       // If this was the default group, the padding is already in place.
4882       if (current_group != 0) {
4883         next_nonstatic_padded_offset += ContendedPaddingWidth;
4884       }
4885     }
4886 
4887     // handle static fields
4888   }
4889 
4890   // Entire class is contended, pad in the back.
4891   // This helps to alleviate memory contention effects for subclass fields
4892   // and/or adjacent object.
4893   if (is_contended_class) {
<span class="line-added">4894     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);</span>
4895     next_nonstatic_padded_offset += ContendedPaddingWidth;
4896   }
4897 
<span class="line-modified">4898   int notaligned_nonstatic_fields_end;</span>
<span class="line-added">4899   if (nonstatic_inline_type_count != 0) {</span>
<span class="line-added">4900     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;</span>
<span class="line-added">4901   } else {</span>
<span class="line-added">4902     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>
<span class="line-added">4903   }</span>
4904 
<span class="line-modified">4905   int nonstatic_field_sz_align = heapOopSize;</span>
<span class="line-added">4906   if (is_inline_type()) {</span>
<span class="line-added">4907     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {</span>
<span class="line-added">4908       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy</span>
<span class="line-added">4909     }</span>
<span class="line-added">4910   }</span>
<span class="line-added">4911   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);</span>
4912   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4913   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4914 
4915   int static_field_size         = (static_fields_end -
4916                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4917   nonstatic_field_size          = nonstatic_field_size +
4918                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4919 
4920   int instance_size             = align_object_size(instance_end / wordSize);
4921 
4922   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4923          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)</span>
<span class="line-modified">4924          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
<span class="line-added">4925 </span>
4926 
4927   // Invariant: nonstatic_field end/start should only change if there are
4928   // nonstatic fields in the class, or if the class is contended. We compare
4929   // against the non-aligned value, so that end alignment will not fail the
4930   // assert without actually having the fields.
4931   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4932          is_contended_class ||
4933          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4934 
4935   // Number of non-static oop map blocks allocated at end of klass.
4936   nonstatic_oop_maps-&gt;compact();
4937 
4938 #ifndef PRODUCT
<span class="line-modified">4939   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||</span>
<span class="line-added">4940       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {</span>
4941     print_field_layout(_class_name,
4942           _fields,
4943           cp,
4944           instance_size,
4945           nonstatic_fields_start,
4946           nonstatic_fields_end,
4947           static_fields_end);
<span class="line-added">4948     nonstatic_oop_maps-&gt;print_on(tty);</span>
<span class="line-added">4949     tty-&gt;print(&quot;\n&quot;);</span>
<span class="line-added">4950     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);</span>
<span class="line-added">4951     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);</span>
<span class="line-added">4952     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);</span>
<span class="line-added">4953     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);</span>
<span class="line-added">4954     tty-&gt;print_cr(&quot;---&quot;);</span>
4955   }
4956 
4957 #endif
4958   // Pass back information needed for InstanceKlass creation
4959   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4960   info-&gt;_instance_size = instance_size;
4961   info-&gt;_static_field_size = static_field_size;
4962   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4963   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<span class="line-added">4964 </span>
<span class="line-added">4965   // An inline type is naturally atomic if it has just one field, and</span>
<span class="line-added">4966   // that field is simple enough.</span>
<span class="line-added">4967   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;</span>
<span class="line-added">4968                                 !super_has_nonstatic_fields &amp;&amp;</span>
<span class="line-added">4969                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;</span>
<span class="line-added">4970                                 (not_atomic_inline_types == 0) &amp;&amp;</span>
<span class="line-added">4971                                 (nonstatic_contended_count == 0));</span>
<span class="line-added">4972   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="line-added">4973   // bits we could make the decision to align instances of this class</span>
<span class="line-added">4974   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="line-added">4975   // And on machines which supported larger atomics we could similarly</span>
<span class="line-added">4976   // allow larger values to be atomic, if properly aligned.</span>
4977 }
4978 
4979 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4980   assert(ik != NULL, &quot;invariant&quot;);
4981 
4982   const Klass* const super = ik-&gt;super();
4983 
4984   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4985   // in which case we don&#39;t have to register objects as finalizable
4986   if (!_has_empty_finalizer) {
4987     if (_has_finalizer ||
4988         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4989       ik-&gt;set_has_finalizer();
4990     }
4991   }
4992 
4993 #ifdef ASSERT
4994   bool f = false;
4995   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4996                                            vmSymbols::void_method_signature());
4997   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4998       f = true;
4999   }
5000 
5001   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
5002   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
5003   // will not work as expected we shouldn&#39;t abort vm in this case
5004   if (!ik-&gt;has_redefined_this_or_super()) {
5005     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
5006   }
5007 #endif
5008 
5009   // Check if this klass supports the java.lang.Cloneable interface
5010   if (SystemDictionary::Cloneable_klass_loaded()) {
5011     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
<span class="line-added">5012       if (ik-&gt;is_value()) {</span>
<span class="line-added">5013         Thread *THREAD = Thread::current();</span>
<span class="line-added">5014         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
<span class="line-added">5015         return;</span>
<span class="line-added">5016       }</span>
5017       ik-&gt;set_is_cloneable();
5018     }
5019   }
5020 
5021   // Check if this klass has a vanilla default constructor
5022   if (super == NULL) {
5023     // java.lang.Object has empty default constructor
5024     ik-&gt;set_has_vanilla_constructor();
5025   } else {
5026     if (super-&gt;has_vanilla_constructor() &amp;&amp;
5027         _has_vanilla_constructor) {
5028       ik-&gt;set_has_vanilla_constructor();
5029     }
5030 #ifdef ASSERT
5031     bool v = false;
5032     if (super-&gt;has_vanilla_constructor()) {
5033       const Method* const constructor =
5034         ik-&gt;find_method(vmSymbols::object_initializer_name(),
5035                        vmSymbols::void_method_signature());
5036       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
5037         v = true;
5038       }
5039     }
5040     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
5041 #endif
5042   }
5043 
5044   // If it cannot be fast-path allocated, set a bit in the layout helper.
5045   // See documentation of InstanceKlass::can_be_fastpath_allocated().
5046   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
5047   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
5048       || ik-&gt;is_abstract() || ik-&gt;is_interface()
5049       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
5050       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
5051     // Forbid fast-path allocation.
5052     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
5053     ik-&gt;set_layout_helper(lh);
5054   }
5055 }
5056 
<span class="line-added">5057 bool ClassFileParser::supports_inline_types() const {</span>
<span class="line-added">5058   // Inline types are only supported by class file version 55 and later</span>
<span class="line-added">5059   return _major_version &gt;= JAVA_11_VERSION;</span>
<span class="line-added">5060 }</span>
<span class="line-added">5061 </span>
5062 // utility methods for appending an array with check for duplicates
5063 
5064 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
5065                               const Array&lt;InstanceKlass*&gt;* const ifs) {
5066   // iterate over new interfaces
5067   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
5068     InstanceKlass* const e = ifs-&gt;at(i);
5069     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
5070     // add new interface
5071     result-&gt;append_if_missing(e);
5072   }
5073 }
5074 
5075 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
5076                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
5077                                                             ClassLoaderData* loader_data,
5078                                                             TRAPS) {
5079   assert(local_ifs != NULL, &quot;invariant&quot;);
5080   assert(loader_data != NULL, &quot;invariant&quot;);
5081 
</pre>
<hr />
<pre>
5085   // Add superclass transitive interfaces size
5086   if (super != NULL) {
5087     super_size = super-&gt;transitive_interfaces()-&gt;length();
5088     max_transitive_size += super_size;
5089   }
5090   // Add local interfaces&#39; super interfaces
5091   const int local_size = local_ifs-&gt;length();
5092   for (int i = 0; i &lt; local_size; i++) {
5093     InstanceKlass* const l = local_ifs-&gt;at(i);
5094     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5095   }
5096   // Finally add local interfaces
5097   max_transitive_size += local_size;
5098   // Construct array
5099   if (max_transitive_size == 0) {
5100     // no interfaces, use canonicalized array
5101     return Universe::the_empty_instance_klass_array();
5102   } else if (max_transitive_size == super_size) {
5103     // no new local interfaces added, share superklass&#39; transitive interface array
5104     return super-&gt;transitive_interfaces();
<span class="line-modified">5105     // The three lines below are commented to work around bug JDK-8245487</span>
<span class="line-modified">5106 //  } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">5107 //    // only local interfaces added, share local interface array</span>
<span class="line-added">5108 //    return local_ifs;</span>
5109   } else {
5110     ResourceMark rm;
5111     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5112 
5113     // Copy down from superclass
5114     if (super != NULL) {
5115       append_interfaces(result, super-&gt;transitive_interfaces());
5116     }
5117 
5118     // Copy down from local interfaces&#39; superinterfaces
5119     for (int i = 0; i &lt; local_size; i++) {
5120       InstanceKlass* const l = local_ifs-&gt;at(i);
5121       append_interfaces(result, l-&gt;transitive_interfaces());
5122     }
5123     // Finally add local interfaces
5124     append_interfaces(result, local_ifs);
5125 
5126     // length will be less than the max_transitive_size if duplicates were removed
5127     const int length = result-&gt;length();
5128     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
<span class="line-added">5129 </span>
<span class="line-added">5130     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">5131       return Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">5132     }</span>
<span class="line-added">5133 </span>
5134     Array&lt;InstanceKlass*&gt;* const new_result =
5135       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5136     for (int i = 0; i &lt; length; i++) {
5137       InstanceKlass* const e = result-&gt;at(i);
5138       assert(e != NULL, &quot;just checking&quot;);
5139       new_result-&gt;at_put(i, e);
5140     }
5141     return new_result;
5142   }
5143 }
5144 
5145 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5146   assert(this_klass != NULL, &quot;invariant&quot;);
5147   const Klass* const super = this_klass-&gt;super();
5148 
5149   if (super != NULL) {
5150     const InstanceKlass* super_ik = InstanceKlass::cast(super);
5151 
5152     if (super-&gt;is_final()) {
5153       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
5346     const Method* const m = methods-&gt;at(index);
5347     // if m is static and not the init method, throw a verify error
5348     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5349       ResourceMark rm(THREAD);
5350       Exceptions::fthrow(
5351         THREAD_AND_LOCATION,
5352         vmSymbols::java_lang_VerifyError(),
5353         &quot;Illegal static method %s in interface %s&quot;,
5354         m-&gt;name()-&gt;as_C_string(),
5355         this_klass-&gt;external_name()
5356       );
5357       return;
5358     }
5359   }
5360 }
5361 
5362 // utility methods for format checking
5363 
5364 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5365   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-added">5366   const bool is_inline_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
5367   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-added">5368   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
5369   if (is_module) {
5370     ResourceMark rm(THREAD);
5371     Exceptions::fthrow(
5372       THREAD_AND_LOCATION,
5373       vmSymbols::java_lang_NoClassDefFoundError(),
5374       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5375       _class_name-&gt;as_C_string());
5376     return;
5377   }
5378 
<span class="line-added">5379   if (is_inline_type &amp;&amp; !EnableValhalla) {</span>
<span class="line-added">5380     ResourceMark rm(THREAD);</span>
<span class="line-added">5381     Exceptions::fthrow(</span>
<span class="line-added">5382       THREAD_AND_LOCATION,</span>
<span class="line-added">5383       vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">5384       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,</span>
<span class="line-added">5385       _class_name-&gt;as_C_string()</span>
<span class="line-added">5386     );</span>
<span class="line-added">5387   }</span>
<span class="line-added">5388 </span>
5389   if (!_need_verify) { return; }
5390 
5391   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5392   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5393   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5394   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5395   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5396   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5397   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5398   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5399 
5400   if ((is_abstract &amp;&amp; is_final) ||
5401       (is_interface &amp;&amp; !is_abstract) ||
5402       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">5403       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||</span>
<span class="line-added">5404       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
5405     ResourceMark rm(THREAD);
<span class="line-added">5406     const char* class_note = &quot;&quot;;</span>
<span class="line-added">5407     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;</span>
5408     Exceptions::fthrow(
5409       THREAD_AND_LOCATION,
5410       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5411       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,</span>
<span class="line-modified">5412       _class_name-&gt;as_C_string(), class_note, flags</span>
5413     );
5414     return;
5415   }
5416 }
5417 
5418 static bool has_illegal_visibility(jint flags) {
5419   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5420   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5421   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5422 
5423   return ((is_public &amp;&amp; is_protected) ||
5424           (is_public &amp;&amp; is_private) ||
5425           (is_protected &amp;&amp; is_private));
5426 }
5427 
5428 // A legal major_version.minor_version must be one of the following:
5429 //
5430 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5431 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5432 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
5471     if (!Arguments::enable_preview()) {
5472       Exceptions::fthrow(
5473         THREAD_AND_LOCATION,
5474         vmSymbols::java_lang_UnsupportedClassVersionError(),
5475         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5476         class_name-&gt;as_C_string(), major, minor);
5477       return;
5478     }
5479 
5480   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5481     Exceptions::fthrow(
5482         THREAD_AND_LOCATION,
5483         vmSymbols::java_lang_UnsupportedClassVersionError(),
5484         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5485         class_name-&gt;as_C_string(), major, minor);
5486   }
5487 }
5488 
5489 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5490                                                    bool is_interface,
<span class="line-added">5491                                                    bool is_inline_type,</span>
5492                                                    TRAPS) const {
5493   if (!_need_verify) { return; }
5494 
5495   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5496   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5497   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5498   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5499   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5500   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5501   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5502   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5503   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5504 
5505   bool is_illegal = false;
5506 
5507   if (is_interface) {
5508     if (!is_public || !is_static || !is_final || is_private ||
5509         is_protected || is_volatile || is_transient ||
5510         (major_gte_1_5 &amp;&amp; is_enum)) {
5511       is_illegal = true;
5512     }
5513   } else { // not interface
5514     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5515       is_illegal = true;
<span class="line-added">5516     } else {</span>
<span class="line-added">5517       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
<span class="line-added">5518         is_illegal = true;</span>
<span class="line-added">5519       }</span>
5520     }
5521   }
5522 
5523   if (is_illegal) {
5524     ResourceMark rm(THREAD);
5525     Exceptions::fthrow(
5526       THREAD_AND_LOCATION,
5527       vmSymbols::java_lang_ClassFormatError(),
5528       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5529       _class_name-&gt;as_C_string(), flags);
5530     return;
5531   }
5532 }
5533 
5534 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5535                                                     bool is_interface,
<span class="line-added">5536                                                     bool is_inline_type,</span>
5537                                                     const Symbol* name,
5538                                                     TRAPS) const {
5539   if (!_need_verify) { return; }
5540 
5541   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5542   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5543   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5544   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5545   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5546   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5547   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5548   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5549   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5550   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5551   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5552   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5553   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5554 
5555   bool is_illegal = false;
5556 
<span class="line-added">5557   const char* class_note = &quot;&quot;;</span>
<span class="line-added">5558 </span>
5559   if (is_interface) {
5560     if (major_gte_8) {
5561       // Class file version is JAVA_8_VERSION or later Methods of
5562       // interfaces may set any of the flags except ACC_PROTECTED,
5563       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5564       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5565       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5566           (is_native || is_protected || is_final || is_synchronized) ||
5567           // If a specific method of a class or interface has its
5568           // ACC_ABSTRACT flag set, it must not have any of its
5569           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5570           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5571           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5572           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5573           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5574         is_illegal = true;
5575       }
5576     } else if (major_gte_1_5) {
5577       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5578       if (!is_public || is_private || is_protected || is_static || is_final ||
5579           is_synchronized || is_native || !is_abstract || is_strict) {
5580         is_illegal = true;
5581       }
5582     } else {
5583       // Class file version is pre-JAVA_1_5_VERSION
5584       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5585         is_illegal = true;
5586       }
5587     }
5588   } else { // not interface
5589     if (has_illegal_visibility(flags)) {
5590       is_illegal = true;
5591     } else {
5592       if (is_initializer) {
<span class="line-modified">5593         if (is_final || is_synchronized || is_native ||</span>
5594             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5595           is_illegal = true;
5596         }
<span class="line-added">5597         if (!is_static &amp;&amp; !is_inline_type) {</span>
<span class="line-added">5598           // OK, an object constructor in a regular class</span>
<span class="line-added">5599         } else if (is_static &amp;&amp; is_inline_type) {</span>
<span class="line-added">5600           // OK, a static init factory in an inline class</span>
<span class="line-added">5601         } else {</span>
<span class="line-added">5602           // but no other combinations are allowed</span>
<span class="line-added">5603           is_illegal = true;</span>
<span class="line-added">5604           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
<span class="line-added">5605         }</span>
5606       } else { // not initializer
<span class="line-modified">5607         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
<span class="line-modified">5608           is_illegal = true;</span>
<span class="line-modified">5609           class_note = &quot; (an inline class)&quot;;</span>
<span class="line-modified">5610         } else {</span>
<span class="line-added">5611           if (is_abstract) {</span>
<span class="line-added">5612             if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-added">5613                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-added">5614               is_illegal = true;</span>
<span class="line-added">5615             }</span>
5616           }
5617         }
5618       }
5619     }
5620   }
5621 
5622   if (is_illegal) {
5623     ResourceMark rm(THREAD);
5624     Exceptions::fthrow(
5625       THREAD_AND_LOCATION,
5626       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5627       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5628       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);</span>
5629     return;
5630   }
5631 }
5632 
5633 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5634                                         int length,
5635                                         TRAPS) const {
5636   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5637   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5638     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5639   }
5640 }
5641 
5642 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5643 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5644 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5645 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5646 // method.  Because these names have been checked as special cases before
5647 // calling this method in verify_legal_method_name.
5648 //
</pre>
<hr />
<pre>
5766 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5767 // Return a pointer to just past the signature.
5768 // Return NULL if no legal signature is found.
5769 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5770                                                        bool void_ok,
5771                                                        unsigned int length,
5772                                                        TRAPS) const {
5773   unsigned int array_dim = 0;
5774   while (length &gt; 0) {
5775     switch (signature[0]) {
5776     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5777     case JVM_SIGNATURE_BOOLEAN:
5778     case JVM_SIGNATURE_BYTE:
5779     case JVM_SIGNATURE_CHAR:
5780     case JVM_SIGNATURE_SHORT:
5781     case JVM_SIGNATURE_INT:
5782     case JVM_SIGNATURE_FLOAT:
5783     case JVM_SIGNATURE_LONG:
5784     case JVM_SIGNATURE_DOUBLE:
5785       return signature + 1;
<span class="line-modified">5786     case JVM_SIGNATURE_VALUETYPE:</span>
<span class="line-added">5787       // Can&#39;t enable this check until JDK upgrades the bytecode generators</span>
<span class="line-added">5788       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {</span>
<span class="line-added">5789       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;</span>
<span class="line-added">5790       //                                    &quot;in descriptor in class file %s&quot;,</span>
<span class="line-added">5791       //                                    CHECK_0);</span>
<span class="line-added">5792       // }</span>
<span class="line-added">5793       // fall through</span>
<span class="line-added">5794     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added">5795     {</span>
5796       if (_major_version &lt; JAVA_1_5_VERSION) {
5797         // Skip over the class name if one is there
5798         const char* const p = skip_over_field_name(signature + 1, true, --length);
5799 
5800         // The next character better be a semicolon
5801         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5802           return p + 1;
5803         }
5804       }
5805       else {
<span class="line-modified">5806         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;</span>
5807         signature++;
5808         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5809         // Format check signature
5810         if (c != NULL) {
5811           int newlen = c - (char*) signature;
5812           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5813           if (!legal) {
5814             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5815                                   &quot;in descriptor in class file %s&quot;,
5816                                   CHECK_NULL);
5817             return NULL;
5818           }
5819           return signature + newlen + 1;
5820         }
5821       }
5822       return NULL;
5823     }
5824     case JVM_SIGNATURE_ARRAY:
5825       array_dim++;
5826       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5841 
5842 // Checks if name is a legal class name.
5843 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5844   if (!_need_verify || _relax_verify) { return; }
5845 
5846   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5847   char* bytes = (char*)name-&gt;bytes();
5848   unsigned int length = name-&gt;utf8_length();
5849   bool legal = false;
5850 
5851   if (length &gt; 0) {
5852     const char* p;
5853     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5854       p = skip_over_field_signature(bytes, false, length, CHECK);
5855       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5856     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5857       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5858         p = skip_over_field_name(bytes, true, length);
5859         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5860       }
<span class="line-added">5861     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {</span>
<span class="line-added">5862       // Support for L...; and Q...; descriptors</span>
<span class="line-added">5863       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);</span>
5864     } else {
5865       // 4900761: relax the constraints based on JSR202 spec
5866       // Class names may be drawn from the entire Unicode character set.
5867       // Identifiers between &#39;/&#39; must be unqualified names.
5868       // The utf8 string has been verified when parsing cpool entries.
5869       legal = verify_unqualified_name(bytes, length, LegalClass);
5870     }
5871   }
5872   if (!legal) {
5873     ResourceMark rm(THREAD);
5874     assert(_class_name != NULL, &quot;invariant&quot;);
5875     Exceptions::fthrow(
5876       THREAD_AND_LOCATION,
5877       vmSymbols::java_lang_ClassFormatError(),
5878       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5879       _class_name-&gt;as_C_string()
5880     );
5881     return;
5882   }
5883 }
</pre>
<hr />
<pre>
5993   const char* nextp;
5994 
5995   // The first character must be a &#39;(&#39;
5996   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5997     length--;
5998     // Skip over legal field signatures
5999     nextp = skip_over_field_signature(p, false, length, CHECK_0);
6000     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
6001       args_size++;
6002       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
6003         args_size++;
6004       }
6005       length -= nextp - p;
6006       p = nextp;
6007       nextp = skip_over_field_signature(p, false, length, CHECK_0);
6008     }
6009     // The first non-signature thing better be a &#39;)&#39;
6010     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
6011       length--;
6012       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">6013         // All constructor methods must return void</span>
6014         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
6015           return args_size;
6016         }
<span class="line-added">6017         // All static init methods must return the current class</span>
<span class="line-added">6018         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)</span>
<span class="line-added">6019             &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">6020           nextp = skip_over_field_signature(p, true, length, CHECK_0);</span>
<span class="line-added">6021           if (nextp &amp;&amp; ((int)length == (nextp - p))) {</span>
<span class="line-added">6022             // The actual class will be checked against current class</span>
<span class="line-added">6023             // when the method is defined (see parse_method).</span>
<span class="line-added">6024             // A reference to a static init with a bad return type</span>
<span class="line-added">6025             // will load and verify OK, but will fail to link.</span>
<span class="line-added">6026             return args_size;</span>
<span class="line-added">6027           }</span>
<span class="line-added">6028         }</span>
<span class="line-added">6029         // The distinction between static factory methods and</span>
<span class="line-added">6030         // constructors depends on the JVM_ACC_STATIC modifier.</span>
<span class="line-added">6031         // This distinction must be reflected in a void or non-void</span>
<span class="line-added">6032         // return. For declared methods, the check is in parse_method.</span>
6033       } else {
6034         // Now we better just have a return value
6035         nextp = skip_over_field_signature(p, true, length, CHECK_0);
6036         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
6037           return args_size;
6038         }
6039       }
6040     }
6041   }
6042   // Report error
6043   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
6044   return 0;
6045 }
6046 
6047 int ClassFileParser::static_field_size() const {
6048   assert(_field_info != NULL, &quot;invariant&quot;);
6049   return _field_info-&gt;_static_field_size;
6050 }
6051 
6052 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
6170 
6171 
6172   if (ik-&gt;should_store_fingerprint()) {
6173     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6174   }
6175 
6176   ik-&gt;set_has_passed_fingerprint_check(false);
6177   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6178     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6179     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6180     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6181       // This class matches with a class saved in an AOT library
6182       ik-&gt;set_has_passed_fingerprint_check(true);
6183     } else {
6184       ResourceMark rm;
6185       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6186                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6187     }
6188   }
6189 
<span class="line-added">6190   if (ik-&gt;is_value()) {</span>
<span class="line-added">6191     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6192     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">6193     vk-&gt;set_default_value(val);</span>
<span class="line-added">6194   }</span>
<span class="line-added">6195 </span>
6196   return ik;
6197 }
6198 
<span class="line-added">6199 // Return true if the specified class is not a valid super class for an inline type.</span>
<span class="line-added">6200 // A valid super class for an inline type is abstract, has no instance fields,</span>
<span class="line-added">6201 // does not implement interface java.lang.IdentityObject (checked elsewhere), has</span>
<span class="line-added">6202 // an empty body-less no-arg constructor, and no synchronized instance methods.</span>
<span class="line-added">6203 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks</span>
<span class="line-added">6204 // are done elsewhere.  The final determination of whether or not a class is an</span>
<span class="line-added">6205 // invalid super type for an inline class is done in fill_instance_klass().</span>
<span class="line-added">6206 bool ClassFileParser::is_invalid_super_for_inline_type() {</span>
<span class="line-added">6207   if (class_name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6208     return true;</span>
<span class="line-added">6209   }</span>
<span class="line-added">6210   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {</span>
<span class="line-added">6211     return false;</span>
<span class="line-added">6212   }</span>
<span class="line-added">6213   if (!access_flags().is_abstract() || _has_nonstatic_fields) {</span>
<span class="line-added">6214     return true;</span>
<span class="line-added">6215   } else {</span>
<span class="line-added">6216     // Look at each method</span>
<span class="line-added">6217     for (int x = 0; x &lt; _methods-&gt;length(); x++) {</span>
<span class="line-added">6218       const Method* const method = _methods-&gt;at(x);</span>
<span class="line-added">6219       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {</span>
<span class="line-added">6220         return true;</span>
<span class="line-added">6221 </span>
<span class="line-added">6222       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">6223         if (method-&gt;signature() != vmSymbols::void_method_signature() ||</span>
<span class="line-added">6224             !method-&gt;is_vanilla_constructor()) {</span>
<span class="line-added">6225           return true;</span>
<span class="line-added">6226         }</span>
<span class="line-added">6227       }</span>
<span class="line-added">6228     }</span>
<span class="line-added">6229   }</span>
<span class="line-added">6230   return false;</span>
<span class="line-added">6231 }</span>
<span class="line-added">6232 </span>
6233 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
6234                                           bool changed_by_loadhook,
6235                                           const ClassInstanceInfo&amp; cl_inst_info,
6236                                           TRAPS) {
6237   assert(ik != NULL, &quot;invariant&quot;);
6238 
6239   // Set name and CLD before adding to CLD
6240   ik-&gt;set_class_loader_data(_loader_data);
6241   ik-&gt;set_name(_class_name);
6242 
6243   // Add all classes to our internal class loader list here,
6244   // including classes in the bootstrap (NULL) class loader.
6245   const bool publicize = !is_internal();
6246 
6247   _loader_data-&gt;add_class(ik, publicize);
6248 
6249   set_klass_to_deallocate(ik);
6250 
6251   assert(_field_info != NULL, &quot;invariant&quot;);
6252   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6253   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6254          &quot;sanity&quot;);
6255 
6256   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6257   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6258 
6259   // Fill in information already parsed
6260   ik-&gt;set_should_verify_class(_need_verify);
6261 
6262   // Not yet: supers are done below to support the new subtype-checking fields
6263   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6264   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<span class="line-added">6265   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {</span>
<span class="line-added">6266     ik-&gt;set_is_naturally_atomic();</span>
<span class="line-added">6267   }</span>
<span class="line-added">6268   if (_is_empty_inline_type) {</span>
<span class="line-added">6269     ik-&gt;set_is_empty_inline_type();</span>
<span class="line-added">6270   }</span>
<span class="line-added">6271 </span>
<span class="line-added">6272   if (this-&gt;_invalid_inline_super) {</span>
<span class="line-added">6273     ik-&gt;set_invalid_inline_super();</span>
<span class="line-added">6274   }</span>
<span class="line-added">6275 </span>
<span class="line-added">6276   if (_has_injected_identityObject) {</span>
<span class="line-added">6277     ik-&gt;set_has_injected_identityObject();</span>
<span class="line-added">6278   }</span>
<span class="line-added">6279 </span>
6280   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">6281   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);</span>
6282 
6283   // this transfers ownership of a lot of arrays from
6284   // the parser onto the InstanceKlass*
6285   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6286 
6287   // can only set dynamic nest-host after static nest information is set
6288   if (cl_inst_info.dynamic_nest_host() != NULL) {
6289     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6290   }
6291 
6292   // note that is not safe to use the fields in the parser from this point on
6293   assert(NULL == _cp, &quot;invariant&quot;);
6294   assert(NULL == _fields, &quot;invariant&quot;);
6295   assert(NULL == _methods, &quot;invariant&quot;);
6296   assert(NULL == _inner_classes, &quot;invariant&quot;);
6297   assert(NULL == _nest_members, &quot;invariant&quot;);
6298   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6299   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6300   assert(NULL == _record_components, &quot;invariant&quot;);
6301   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
</pre>
<hr />
<pre>
6312   // has to be changed accordingly.
6313   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6314 
6315   ik-&gt;set_this_class_index(_this_class_index);
6316 
6317   if (_is_hidden || is_unsafe_anonymous()) {
6318     // _this_class_index is a CONSTANT_Class entry that refers to this
6319     // hidden or anonymous class itself. If this class needs to refer to its own
6320     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
6321     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
6322     // not stored in SystemDictionary), _this_class_index cannot be resolved
6323     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6324     // Therefore, we must eagerly resolve _this_class_index now.
6325     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6326   }
6327 
6328   ik-&gt;set_minor_version(_minor_version);
6329   ik-&gt;set_major_version(_major_version);
6330   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6331   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<span class="line-added">6332   if (_is_declared_atomic) {</span>
<span class="line-added">6333     ik-&gt;set_is_declared_atomic();</span>
<span class="line-added">6334   }</span>
6335 
6336   if (_unsafe_anonymous_host != NULL) {
6337     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6338     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6339   }
6340   if (_is_hidden) {
6341     ik-&gt;set_is_hidden();
6342   }
6343 
6344   // Set PackageEntry for this_klass
6345   oop cl = ik-&gt;class_loader();
6346   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6347   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6348   ik-&gt;set_package(cld, NULL, CHECK);
6349 
6350   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6351   assert(methods != NULL, &quot;invariant&quot;);
6352   const int methods_len = methods-&gt;length();
6353 
6354   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
6424 
6425   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6426 
6427   // Generate any default methods - default methods are public interface methods
6428   // that have a default implementation.  This is new with Java 8.
6429   if (_has_nonstatic_concrete_methods) {
6430     DefaultMethods::generate_default_methods(ik,
6431                                              _all_mirandas,
6432                                              CHECK);
6433   }
6434 
6435   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6436   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6437       !module_entry-&gt;has_default_read_edges()) {
6438     if (!module_entry-&gt;set_has_default_read_edges()) {
6439       // We won a potential race
6440       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6441     }
6442   }
6443 
<span class="line-added">6444   int nfields = ik-&gt;java_fields_count();</span>
<span class="line-added">6445   if (ik-&gt;is_value()) nfields++;</span>
<span class="line-added">6446   for (int i = 0; i &lt; nfields; i++) {</span>
<span class="line-added">6447     if (ik-&gt;field_is_flattenable(i)) {</span>
<span class="line-added">6448       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);</span>
<span class="line-added">6449       // Inline classes for instance fields must have been pre-loaded</span>
<span class="line-added">6450       // Inline classes for static fields might not have been loaded yet</span>
<span class="line-added">6451       Klass* klass = SystemDictionary::find(klass_name,</span>
<span class="line-added">6452           Handle(THREAD, ik-&gt;class_loader()),</span>
<span class="line-added">6453           Handle(THREAD, ik-&gt;protection_domain()), CHECK);</span>
<span class="line-added">6454       if (klass != NULL) {</span>
<span class="line-added">6455         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">6456         ik-&gt;set_value_field_klass(i, klass);</span>
<span class="line-added">6457       }</span>
<span class="line-added">6458       klass_name-&gt;decrement_refcount();</span>
<span class="line-added">6459     } else</span>
<span class="line-added">6460       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
<span class="line-added">6461         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {</span>
<span class="line-added">6462       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));</span>
<span class="line-added">6463     }</span>
<span class="line-added">6464   }</span>
<span class="line-added">6465 </span>
<span class="line-added">6466   if (is_inline_type()) {</span>
<span class="line-added">6467     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6468     if (UseNewFieldLayout) {</span>
<span class="line-added">6469       vk-&gt;set_alignment(_alignment);</span>
<span class="line-added">6470       vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="line-added">6471       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
<span class="line-added">6472     } else {</span>
<span class="line-added">6473       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());</span>
<span class="line-added">6474     }</span>
<span class="line-added">6475     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">6476   }</span>
<span class="line-added">6477 </span>
6478   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6479 
6480   if (!is_internal()) {
6481     if (log_is_enabled(Info, class, load)) {
6482       ResourceMark rm;
6483       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6484       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6485     }
6486 
6487     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
6488         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
6489         log_is_enabled(Info, class, preview)) {
6490       ResourceMark rm;
6491       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
6492                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
6493     }
6494 
6495     if (log_is_enabled(Debug, class, resolve))  {
6496       ResourceMark rm;
6497       // print out the superclass.
</pre>
<hr />
<pre>
6507         const int length = local_interfaces-&gt;length();
6508         for (int i = 0; i &lt; length; i++) {
6509           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6510           const char * to = k-&gt;external_name();
6511           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6512         }
6513       }
6514     }
6515   }
6516 
6517   JFR_ONLY(INIT_ID(ik);)
6518 
6519   // If we reach here, all is well.
6520   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6521   // in order for it to not be destroyed in the ClassFileParser destructor.
6522   set_klass_to_deallocate(NULL);
6523 
6524   // it&#39;s official
6525   set_klass(ik);
6526 
<span class="line-added">6527   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6528     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);</span>
<span class="line-added">6529   }</span>
<span class="line-added">6530 </span>
6531   debug_only(ik-&gt;verify();)
6532 }
6533 
6534 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6535   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6536   _class_name-&gt;decrement_refcount();
6537 
6538   _class_name = new_class_name;
6539   // Increment the refcount of the new name.
6540   // Now the ClassFileParser owns this name and will decrement in
6541   // the destructor.
6542   _class_name-&gt;increment_refcount();
6543 }
6544 
6545 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6546 // package by prepending its host class&#39;s package name to its class name and setting
6547 // its _class_name field.
6548 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6549   ResourceMark rm(THREAD);
6550   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
6613   _stream(stream),
6614   _class_name(NULL),
6615   _loader_data(loader_data),
6616   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6617   _cp_patches(cl_info-&gt;cp_patches()),
6618   _is_hidden(cl_info-&gt;is_hidden()),
6619   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6620   _num_patched_klasses(0),
6621   _max_num_patched_klasses(0),
6622   _orig_cp_size(0),
6623   _first_patched_klass_resolved_index(0),
6624   _super_klass(),
6625   _cp(NULL),
6626   _fields(NULL),
6627   _methods(NULL),
6628   _inner_classes(NULL),
6629   _nest_members(NULL),
6630   _nest_host(0),
6631   _permitted_subclasses(NULL),
6632   _record_components(NULL),
<span class="line-added">6633   _temp_local_interfaces(NULL),</span>
6634   _local_interfaces(NULL),
6635   _transitive_interfaces(NULL),
6636   _combined_annotations(NULL),
6637   _class_annotations(NULL),
6638   _class_type_annotations(NULL),
6639   _fields_annotations(NULL),
6640   _fields_type_annotations(NULL),
6641   _klass(NULL),
6642   _klass_to_deallocate(NULL),
6643   _parsed_annotations(NULL),
6644   _fac(NULL),
6645   _field_info(NULL),
6646   _method_ordering(NULL),
6647   _all_mirandas(NULL),
6648   _vtable_size(0),
6649   _itable_size(0),
6650   _num_miranda_methods(0),
6651   _rt(REF_NONE),
6652   _protection_domain(cl_info-&gt;protection_domain()),
6653   _access_flags(),
6654   _pub_level(pub_level),
6655   _bad_constant_seen(0),
6656   _synthetic_flag(false),
6657   _sde_length(false),
6658   _sde_buffer(NULL),
6659   _sourcefile_index(0),
6660   _generic_signature_index(0),
6661   _major_version(0),
6662   _minor_version(0),
6663   _this_class_index(0),
6664   _super_class_index(0),
6665   _itfs_len(0),
6666   _java_fields_count(0),
6667   _need_verify(false),
6668   _relax_verify(false),
6669   _has_nonstatic_concrete_methods(false),
6670   _declares_nonstatic_concrete_methods(false),
6671   _has_final_method(false),
6672   _has_contended_fields(false),
<span class="line-added">6673   _has_flattenable_fields(false),</span>
<span class="line-added">6674   _has_nonstatic_fields(false),</span>
<span class="line-added">6675   _is_empty_inline_type(false),</span>
<span class="line-added">6676   _is_naturally_atomic(false),</span>
<span class="line-added">6677   _is_declared_atomic(false),</span>
<span class="line-added">6678   _invalid_inline_super(false),</span>
<span class="line-added">6679   _invalid_identity_super(false),</span>
<span class="line-added">6680   _implements_identityObject(false),</span>
<span class="line-added">6681   _has_injected_identityObject(false),</span>
6682   _has_finalizer(false),
6683   _has_empty_finalizer(false),
6684   _has_vanilla_constructor(false),
6685   _max_bootstrap_specifier_index(-1) {
6686 
6687   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6688   _class_name-&gt;increment_refcount();
6689 
6690   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6691   assert(_loader_data != NULL, &quot;invariant&quot;);
6692   assert(stream != NULL, &quot;invariant&quot;);
6693   assert(_stream != NULL, &quot;invariant&quot;);
6694   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6695   assert(_class_name != NULL, &quot;invariant&quot;);
6696   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6697 
6698   // Figure out whether we can skip format checking (matching classic VM behavior)
6699   if (DumpSharedSpaces) {
6700     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6701     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6872   } else {
6873     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6874       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6875     }
6876     cp_size += _max_num_patched_klasses;
6877   }
6878 
6879   _cp = ConstantPool::allocate(_loader_data,
6880                                cp_size,
6881                                CHECK);
6882 
6883   ConstantPool* const cp = _cp;
6884 
6885   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6886 
6887   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6888 
6889   // ACCESS FLAGS
6890   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6891 
<span class="line-modified">6892   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;</span>

6893   // JVM_ACC_MODULE is defined in JDK-9 and later.
6894   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6895     recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">6896   }</span>
<span class="line-modified">6897   // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">6898   if (supports_inline_types()) {</span>
<span class="line-added">6899     recognized_modifiers |= JVM_ACC_VALUE;</span>
6900   }
6901 
<span class="line-added">6902   // Access flags</span>
<span class="line-added">6903   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">6904 </span>
6905   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6906     // Set abstract bit for old class files for backward compatibility
6907     flags |= JVM_ACC_ABSTRACT;
6908   }
6909 
6910   verify_legal_class_modifiers(flags, CHECK);
6911 
6912   short bad_constant = class_bad_constant_seen();
6913   if (bad_constant != 0) {
6914     // Do not throw CFE until after the access_flags are checked because if
6915     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6916     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6917   }
6918 
6919   _access_flags.set_flags(flags);
6920 
6921   // This class and superclass
6922   _this_class_index = stream-&gt;get_u2_fast();
6923   check_property(
6924     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
7042           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
7043           classlist_file-&gt;flush();
7044         }
7045       }
7046     }
7047 #endif
7048   }
7049 
7050   // SUPERKLASS
7051   _super_class_index = stream-&gt;get_u2_fast();
7052   _super_klass = parse_super_class(cp,
7053                                    _super_class_index,
7054                                    _need_verify,
7055                                    CHECK);
7056 
7057   // Interfaces
7058   _itfs_len = stream-&gt;get_u2_fast();
7059   parse_interfaces(stream,
7060                    _itfs_len,
7061                    cp,
<span class="line-added">7062                    is_inline_type(),</span>
7063                    &amp;_has_nonstatic_concrete_methods,
<span class="line-added">7064                    &amp;_is_declared_atomic,</span>
7065                    CHECK);
7066 
<span class="line-modified">7067   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);</span>
7068 
7069   // Fields (offsets are filled in later)
7070   _fac = new FieldAllocationCount();
7071   parse_fields(stream,
<span class="line-modified">7072                is_interface(),</span>
<span class="line-added">7073                is_inline_type(),</span>
7074                _fac,
7075                cp,
7076                cp_size,
7077                &amp;_java_fields_count,
7078                CHECK);
7079 
7080   assert(_fields != NULL, &quot;invariant&quot;);
7081 
7082   // Methods
7083   AccessFlags promoted_flags;
7084   parse_methods(stream,
<span class="line-modified">7085                 is_interface(),</span>
<span class="line-added">7086                 is_inline_type(),</span>
7087                 &amp;promoted_flags,
7088                 &amp;_has_final_method,
7089                 &amp;_declares_nonstatic_concrete_methods,
7090                 CHECK);
7091 
7092   assert(_methods != NULL, &quot;invariant&quot;);
7093 
7094   // promote flags from parse_methods() to the klass&#39; flags
7095   _access_flags.add_promoted_flags(promoted_flags.as_int());
7096 
7097   if (_declares_nonstatic_concrete_methods) {
7098     _has_nonstatic_concrete_methods = true;
7099   }
7100 
7101   // Additional attributes/annotations
7102   _parsed_annotations = new ClassAnnotationCollector();
7103   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
7104 
7105   assert(_inner_classes != NULL, &quot;invariant&quot;);
7106 
</pre>
<hr />
<pre>
7137 
7138   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
7139   // We have to update the resolved_klass_index and the name_index together
7140   // so extract the existing resolved_klass_index first.
7141   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
7142   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
7143   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
7144   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
7145          &quot;Bad name_index&quot;);
7146 }
7147 
7148 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
7149                                                  ConstantPool* cp,
7150                                                  TRAPS) {
7151   assert(stream != NULL, &quot;invariant&quot;);
7152   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
7153   assert(cp != NULL, &quot;invariant&quot;);
7154   assert(_loader_data != NULL, &quot;invariant&quot;);
7155 
7156   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">7157     check_property(_temp_local_interfaces-&gt;length() == 0,</span>
<span class="line-modified">7158         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">7159         CHECK);</span>
7160   }
7161   // We check super class after class file is parsed and format is checked
7162   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
7163     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">7164     if (is_interface()) {</span>
7165       // Before attempting to resolve the superclass, check for class format
7166       // errors not checked yet.
7167       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
7168         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
7169         CHECK);
7170     }
7171     Handle loader(THREAD, _loader_data-&gt;class_loader());
7172     _super_klass = (const InstanceKlass*)
7173                        SystemDictionary::resolve_super_or_fail(_class_name,
7174                                                                super_class_name,
7175                                                                loader,
7176                                                                _protection_domain,
7177                                                                true,
7178                                                                CHECK);
7179   }
7180 
7181   if (_super_klass != NULL) {
7182     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
7183       _has_nonstatic_concrete_methods = true;
7184     }
<span class="line-added">7185     if (_super_klass-&gt;is_declared_atomic()) {</span>
<span class="line-added">7186       _is_declared_atomic = true;</span>
<span class="line-added">7187     }</span>
7188 
7189     if (_super_klass-&gt;is_interface()) {
7190       ResourceMark rm(THREAD);
7191       Exceptions::fthrow(
7192         THREAD_AND_LOCATION,
7193         vmSymbols::java_lang_IncompatibleClassChangeError(),
7194         &quot;class %s has interface %s as super class&quot;,
7195         _class_name-&gt;as_klass_external_name(),
7196         _super_klass-&gt;external_name()
7197       );
7198       return;
7199     }
<span class="line-added">7200 </span>
<span class="line-added">7201     // For an inline class, only java/lang/Object or special abstract classes</span>
<span class="line-added">7202     // are acceptable super classes.</span>
<span class="line-added">7203     if (is_inline_type()) {</span>
<span class="line-added">7204       const InstanceKlass* super_ik = _super_klass;</span>
<span class="line-added">7205       if (super_ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">7206         ResourceMark rm(THREAD);</span>
<span class="line-added">7207         Exceptions::fthrow(</span>
<span class="line-added">7208           THREAD_AND_LOCATION,</span>
<span class="line-added">7209           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">7210           &quot;inline class %s has an invalid super class %s&quot;,</span>
<span class="line-added">7211           _class_name-&gt;as_klass_external_name(),</span>
<span class="line-added">7212           _super_klass-&gt;external_name());</span>
<span class="line-added">7213         return;</span>
<span class="line-added">7214       }</span>
<span class="line-added">7215     }</span>
<span class="line-added">7216   }</span>
<span class="line-added">7217 </span>
<span class="line-added">7218   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {</span>
<span class="line-added">7219     // This is the original source of this condition.</span>
<span class="line-added">7220     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.</span>
<span class="line-added">7221     _is_declared_atomic = true;</span>
<span class="line-added">7222   } else if (*ForceNonTearable != &#39;\0&#39;) {</span>
<span class="line-added">7223     // Allow a command line switch to force the same atomicity property:</span>
<span class="line-added">7224     const char* class_name_str = _class_name-&gt;as_C_string();</span>
<span class="line-added">7225     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {</span>
<span class="line-added">7226       _is_declared_atomic = true;</span>
<span class="line-added">7227     }</span>
<span class="line-added">7228   }</span>
<span class="line-added">7229 </span>
<span class="line-added">7230   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-added">7231   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-added">7232   // returns true</span>
<span class="line-added">7233   if (invalid_inline_super() ||</span>
<span class="line-added">7234       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-added">7235       is_invalid_super_for_inline_type()) {</span>
<span class="line-added">7236     set_invalid_inline_super();</span>
7237   }
7238 
<span class="line-added">7239   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
<span class="line-added">7240       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">7241     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());</span>
<span class="line-added">7242     _has_injected_identityObject = true;</span>
<span class="line-added">7243   }</span>
<span class="line-added">7244   int itfs_len = _temp_local_interfaces-&gt;length();</span>
<span class="line-added">7245   if (itfs_len == 0) {</span>
<span class="line-added">7246     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
<span class="line-added">7247   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">7248     _local_interfaces = Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">7249   } else {</span>
<span class="line-added">7250     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-added">7251     for (int i = 0; i &lt; itfs_len; i++) {</span>
<span class="line-added">7252       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));</span>
<span class="line-added">7253     }</span>
<span class="line-added">7254   }</span>
<span class="line-added">7255   _temp_local_interfaces = NULL;</span>
<span class="line-added">7256   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
<span class="line-added">7257 </span>
7258   // Compute the transitive list of all unique interfaces implemented by this class
7259   _transitive_interfaces =
7260     compute_transitive_interfaces(_super_klass,
7261                                   _local_interfaces,
7262                                   _loader_data,
7263                                   CHECK);
7264 
7265   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7266 
7267   // sort methods
7268   _method_ordering = sort_methods(_methods);
7269 
7270   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7271 
7272   Handle loader(THREAD, _loader_data-&gt;class_loader());
7273   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7274                                                     &amp;_num_miranda_methods,
7275                                                     _all_mirandas,
7276                                                     _super_klass,
7277                                                     _methods,
7278                                                     _access_flags,
7279                                                     _major_version,
7280                                                     loader,
7281                                                     _class_name,
7282                                                     _local_interfaces,
7283                                                     CHECK);
7284 
7285   // Size of Java itable (in words)
<span class="line-modified">7286   _itable_size = is_interface() ? 0 :</span>
7287     klassItable::compute_itable_size(_transitive_interfaces);
7288 
7289   assert(_fac != NULL, &quot;invariant&quot;);
7290   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7291 
<span class="line-added">7292 </span>
<span class="line-added">7293   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-added">7294     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {</span>
<span class="line-added">7295       // Pre-load value class</span>
<span class="line-added">7296       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">7297           Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">7298           _protection_domain, true, CHECK);</span>
<span class="line-added">7299       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">7300       assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">7301       _has_flattenable_fields = true;</span>
<span class="line-added">7302     }</span>
<span class="line-added">7303   }</span>
<span class="line-added">7304 </span>
7305   _field_info = new FieldLayoutInfo();
7306   if (UseNewFieldLayout) {
7307     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">7308         _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="line-modified">7309         loader_data(), _protection_domain, _field_info);</span>
<span class="line-added">7310     lb.build_layout(CHECK);</span>
<span class="line-added">7311     if (is_inline_type()) {</span>
<span class="line-added">7312       _alignment = lb.get_alignment();</span>
<span class="line-added">7313       _first_field_offset = lb.get_first_field_offset();</span>
<span class="line-added">7314       _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
<span class="line-added">7315     }</span>
7316   } else {
7317     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7318   }
7319 
<span class="line-modified">7320   // Compute reference type</span>
7321   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();

7322 }
7323 
7324 void ClassFileParser::set_klass(InstanceKlass* klass) {
7325 
7326 #ifdef ASSERT
7327   if (klass != NULL) {
7328     assert(NULL == _klass, &quot;leaking?&quot;);
7329   }
7330 #endif
7331 
7332   _klass = klass;
7333 }
7334 
7335 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7336 
7337 #ifdef ASSERT
7338   if (klass != NULL) {
7339     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
7340   }
7341 #endif
7342 
7343   _klass_to_deallocate = klass;
7344 }
7345 
7346 // Caller responsible for ResourceMark
7347 // clone stream with rewound position
7348 const ClassFileStream* ClassFileParser::clone_stream() const {
7349   assert(_stream != NULL, &quot;invariant&quot;);
7350 
7351   return _stream-&gt;clone();
7352 }
<span class="line-added">7353 </span>
7354 // ----------------------------------------------------------------------------
7355 // debugging
7356 
7357 #ifdef ASSERT
7358 
7359 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
7360 bool ClassFileParser::is_internal_format(Symbol* class_name) {
7361   if (class_name != NULL) {
7362     ResourceMark rm;
7363     char* name = class_name-&gt;as_C_string();
7364     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
7365   } else {
7366     return true;
7367   }
7368 }
7369 
7370 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciInstanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
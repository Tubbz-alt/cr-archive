<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58   unsigned int _max_nonstatic_oop_maps;
 59 
 60   OopMapBlocksBuilder(unsigned int  max_blocks);
 61   OopMapBlock* last_oop_map() const;
 62   void initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks);
 63   void add(int offset, int count);
 64   void copy(OopMapBlock* dst);
 65   void compact();
 66   void print_on(outputStream* st) const;
 67   void print_value_on(outputStream* st) const;
 68 };
 69 
 70 // Values needed for oopmap and InstanceKlass creation
 71 class FieldLayoutInfo : public ResourceObj {
 72  public:
 73   OopMapBlocksBuilder* oop_map_blocks;
 74   int _instance_size;
 75   int _nonstatic_field_size;
 76   int _static_field_size;
 77   bool  _has_nonstatic_fields;

 78 };
 79 
 80 // Parser for for .class files
 81 //
 82 // The bytes describing the class file structure is read from a Stream object
 83 
 84 class ClassFileParser {
 85   friend class FieldLayoutBuilder;
 86   friend class FieldLayout;
 87 
 88   class ClassAnnotationCollector;
 89   class FieldAllocationCount;
 90   class FieldAnnotationCollector;
 91 
 92  public:
 93   // The ClassFileParser has an associated &quot;publicity&quot; level
 94   // It is used to control which subsystems (if any)
 95   // will observe the parsing (logging, events, tracing).
 96   // Default level is &quot;BROADCAST&quot;, which is equivalent to
 97   // a &quot;public&quot; parsing attempt.
</pre>
<hr />
<pre>
117   GrowableArray&lt;Handle&gt;* _cp_patches; // overrides for CP entries
118   const bool _is_hidden;
119   const bool _can_access_vm_annotations;
120   int _num_patched_klasses;
121   int _max_num_patched_klasses;
122   int _orig_cp_size;
123   int _first_patched_klass_resolved_index;
124 
125   // Metadata created before the instance klass is created.  Must be deallocated
126   // if not transferred to the InstanceKlass upon successful class loading
127   // in which case these pointers have been set to NULL.
128   const InstanceKlass* _super_klass;
129   ConstantPool* _cp;
130   Array&lt;u2&gt;* _fields;
131   Array&lt;Method*&gt;* _methods;
132   Array&lt;u2&gt;* _inner_classes;
133   Array&lt;u2&gt;* _nest_members;
134   u2 _nest_host;
135   Array&lt;u2&gt;* _permitted_subclasses;
136   Array&lt;RecordComponent*&gt;* _record_components;

137   Array&lt;InstanceKlass*&gt;* _local_interfaces;
138   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
139   Annotations* _combined_annotations;
140   AnnotationArray* _class_annotations;
141   AnnotationArray* _class_type_annotations;
142   Array&lt;AnnotationArray*&gt;* _fields_annotations;
143   Array&lt;AnnotationArray*&gt;* _fields_type_annotations;
144   InstanceKlass* _klass;  // InstanceKlass* once created.
145   InstanceKlass* _klass_to_deallocate; // an InstanceKlass* to be destroyed
146 
147   ClassAnnotationCollector* _parsed_annotations;
148   FieldAllocationCount* _fac;
149   FieldLayoutInfo* _field_info;
150   const intArray* _method_ordering;
151   GrowableArray&lt;Method*&gt;* _all_mirandas;
152 
153   enum { fixed_buffer_size = 128 };
154   u_char _linenumbertable_buffer[fixed_buffer_size];
155 
156   // Size of Java vtable (in words)
157   int _vtable_size;
158   int _itable_size;
159 
160   int _num_miranda_methods;
161 




162   ReferenceType _rt;
163   Handle _protection_domain;
164   AccessFlags _access_flags;
165 
166   // for tracing and notifications
167   Publicity _pub_level;
168 
169   // Used to keep track of whether a constant pool item 19 or 20 is found.  These
170   // correspond to CONSTANT_Module and CONSTANT_Package tags and are not allowed
171   // in regular class files.  For class file version &gt;= 53, a CFE cannot be thrown
172   // immediately when these are seen because a NCDFE must be thrown if the class&#39;s
173   // access_flags have ACC_MODULE set.  But, the access_flags haven&#39;t been looked
174   // at yet.  So, the bad constant pool item is cached here.  A value of zero
175   // means that no constant pool item 19 or 20 was found.
176   short _bad_constant_seen;
177 
178   // class attributes parsed before the instance klass is created:
179   bool _synthetic_flag;
180   int _sde_length;
181   const char* _sde_buffer;
182   u2 _sourcefile_index;
183   u2 _generic_signature_index;
184 
185   u2 _major_version;
186   u2 _minor_version;
187   u2 _this_class_index;
188   u2 _super_class_index;
189   u2 _itfs_len;
190   u2 _java_fields_count;
191 
192   bool _need_verify;
193   bool _relax_verify;
194 
195   bool _has_nonstatic_concrete_methods;
196   bool _declares_nonstatic_concrete_methods;
197   bool _has_final_method;
198   bool _has_contended_fields;
199 










200   // precomputed flags
201   bool _has_finalizer;
202   bool _has_empty_finalizer;
203   bool _has_vanilla_constructor;
204   int _max_bootstrap_specifier_index;  // detects BSS values
205 
206   void parse_stream(const ClassFileStream* const stream, TRAPS);
207 
208   void mangle_hidden_class_name(InstanceKlass* const ik);
209 
210   void post_process_parsed_stream(const ClassFileStream* const stream,
211                                   ConstantPool* cp,
212                                   TRAPS);
213 
214   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
215   void fix_unsafe_anonymous_class_name(TRAPS);
216 
217   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH,
218                            const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
219 
</pre>
<hr />
<pre>
229   void create_combined_annotations(TRAPS);
230   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
231   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
232   void clear_class_metadata();
233 
234   // Constant pool parsing
235   void parse_constant_pool_entries(const ClassFileStream* const stream,
236                                    ConstantPool* cp,
237                                    const int length,
238                                    TRAPS);
239 
240   void parse_constant_pool(const ClassFileStream* const cfs,
241                            ConstantPool* const cp,
242                            const int length,
243                            TRAPS);
244 
245   // Interface parsing
246   void parse_interfaces(const ClassFileStream* const stream,
247                         const int itfs_len,
248                         ConstantPool* const cp,

249                         bool* has_nonstatic_concrete_methods,

250                         TRAPS);
251 
252   const InstanceKlass* parse_super_class(ConstantPool* const cp,
253                                          const int super_class_index,
254                                          const bool need_verify,
255                                          TRAPS);
256 
257   // Field parsing
258   void parse_field_attributes(const ClassFileStream* const cfs,
259                               u2 attributes_count,
260                               bool is_static,
261                               u2 signature_index,
262                               u2* const constantvalue_index_addr,
263                               bool* const is_synthetic_addr,
264                               u2* const generic_signature_index_addr,
265                               FieldAnnotationCollector* parsed_annotations,
266                               TRAPS);
267 
268   void parse_fields(const ClassFileStream* const cfs,
269                     bool is_interface,

270                     FieldAllocationCount* const fac,
271                     ConstantPool* cp,
272                     const int cp_size,
273                     u2* const java_fields_count_ptr,
274                     TRAPS);
275 
276   // Method parsing
277   Method* parse_method(const ClassFileStream* const cfs,
278                        bool is_interface,

279                        const ConstantPool* cp,
280                        AccessFlags* const promoted_flags,
281                        TRAPS);
282 
283   void parse_methods(const ClassFileStream* const cfs,
284                      bool is_interface,

285                      AccessFlags* const promoted_flags,
286                      bool* const has_final_method,
287                      bool* const declares_nonstatic_concrete_methods,
288                      TRAPS);
289 
290   const unsafe_u2* parse_exception_table(const ClassFileStream* const stream,
291                                          u4 code_length,
292                                          u4 exception_table_length,
293                                          TRAPS);
294 
295   void parse_linenumber_table(u4 code_attribute_length,
296                               u4 code_length,
297                               CompressedLineNumberWriteStream**const write_stream,
298                               TRAPS);
299 
300   const unsafe_u2* parse_localvariable_table(const ClassFileStream* const cfs,
301                                              u4 code_length,
302                                              u2 max_locals,
303                                              u4 code_attribute_length,
304                                              u2* const localvariable_table_length,
</pre>
<hr />
<pre>
426   inline void guarantee_property(bool b,
427                                  const char* msg,
428                                  const char *name,
429                                  TRAPS) const {
430     if (!b) { classfile_parse_error(msg, name, CHECK); }
431   }
432 
433   inline void guarantee_property(bool b,
434                                  const char* msg,
435                                  int index,
436                                  const char *name,
437                                  TRAPS) const {
438     if (!b) { classfile_parse_error(msg, index, name, CHECK); }
439   }
440 
441   void throwIllegalSignature(const char* type,
442                              const Symbol* name,
443                              const Symbol* sig,
444                              TRAPS) const;
445 





446   void verify_constantvalue(const ConstantPool* const cp,
447                             int constantvalue_index,
448                             int signature_index,
449                             TRAPS) const;
450 
451   void verify_legal_utf8(const unsigned char* buffer, int length, TRAPS) const;
452   void verify_legal_class_name(const Symbol* name, TRAPS) const;
453   void verify_legal_field_name(const Symbol* name, TRAPS) const;
454   void verify_legal_method_name(const Symbol* name, TRAPS) const;
455 
456   void verify_legal_field_signature(const Symbol* fieldname,
457                                     const Symbol* signature,
458                                     TRAPS) const;
459   int  verify_legal_method_signature(const Symbol* methodname,
460                                      const Symbol* signature,
461                                      TRAPS) const;
462 
463   void verify_legal_class_modifiers(jint flags, TRAPS) const;
<span class="line-modified">464   void verify_legal_field_modifiers(jint flags, bool is_interface, TRAPS) const;</span>



465   void verify_legal_method_modifiers(jint flags,
466                                      bool is_interface,

467                                      const Symbol* name,
468                                      TRAPS) const;
469 
470   const char* skip_over_field_signature(const char* signature,
471                                         bool void_ok,
472                                         unsigned int length,
473                                         TRAPS) const;
474 
475   bool has_cp_patch_at(int index) const {
476     assert(index &gt;= 0, &quot;oob&quot;);
477     return (_cp_patches != NULL
478             &amp;&amp; index &lt; _cp_patches-&gt;length()
479             &amp;&amp; _cp_patches-&gt;adr_at(index)-&gt;not_null());
480   }
481 
482   Handle cp_patch_at(int index) const {
483     assert(has_cp_patch_at(index), &quot;oob&quot;);
484     return _cp_patches-&gt;at(index);
485   }
486 
</pre>
<hr />
<pre>
525                                int runtime_visible_parameter_annotations_length,
526                                const u1* runtime_invisible_parameter_annotations,
527                                int runtime_invisible_parameter_annotations_length,
528                                const u1* runtime_visible_type_annotations,
529                                int runtime_visible_type_annotations_length,
530                                const u1* runtime_invisible_type_annotations,
531                                int runtime_invisible_type_annotations_length,
532                                const u1* annotation_default,
533                                int annotation_default_length,
534                                TRAPS);
535 
536   // lays out fields in class and returns the total oopmap count
537   void layout_fields(ConstantPool* cp,
538                      const FieldAllocationCount* fac,
539                      const ClassAnnotationCollector* parsed_annotations,
540                      FieldLayoutInfo* info,
541                      TRAPS);
542 
543   void update_class_name(Symbol* new_name);
544 



545  public:
546   ClassFileParser(ClassFileStream* stream,
547                   Symbol* name,
548                   ClassLoaderData* loader_data,
549                   const ClassLoadInfo* cl_info,
550                   Publicity pub_level,
551                   TRAPS);
552 
553   ~ClassFileParser();
554 
555   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
556 
557   const ClassFileStream* clone_stream() const;
558 
559   void set_klass_to_deallocate(InstanceKlass* klass);
560 
561   int static_field_size() const;
562   int total_oop_map_count() const;
563   jint layout_size() const;
564 
565   int vtable_size() const { return _vtable_size; }
566   int itable_size() const { return _itable_size; }
567 
568   u2 this_class_index() const { return _this_class_index; }
569 
570   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
571   bool is_hidden() const { return _is_hidden; }
572   bool is_interface() const { return _access_flags.is_interface(); }










573 
574   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
575   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
576   ClassLoaderData* loader_data() const { return _loader_data; }
577   const Symbol* class_name() const { return _class_name; }
578   const InstanceKlass* super_klass() const { return _super_klass; }
579 
580   ReferenceType reference_type() const { return _rt; }
581   AccessFlags access_flags() const { return _access_flags; }
582 
583   bool is_internal() const { return INTERNAL == _pub_level; }
584 
585   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
586 
587 #ifdef ASSERT
588   static bool is_internal_format(Symbol* class_name);
589 #endif
590 
591 };
592 
</pre>
</td>
<td>
<hr />
<pre>
 58   unsigned int _max_nonstatic_oop_maps;
 59 
 60   OopMapBlocksBuilder(unsigned int  max_blocks);
 61   OopMapBlock* last_oop_map() const;
 62   void initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks);
 63   void add(int offset, int count);
 64   void copy(OopMapBlock* dst);
 65   void compact();
 66   void print_on(outputStream* st) const;
 67   void print_value_on(outputStream* st) const;
 68 };
 69 
 70 // Values needed for oopmap and InstanceKlass creation
 71 class FieldLayoutInfo : public ResourceObj {
 72  public:
 73   OopMapBlocksBuilder* oop_map_blocks;
 74   int _instance_size;
 75   int _nonstatic_field_size;
 76   int _static_field_size;
 77   bool  _has_nonstatic_fields;
<span class="line-added"> 78   bool  _is_naturally_atomic;</span>
 79 };
 80 
 81 // Parser for for .class files
 82 //
 83 // The bytes describing the class file structure is read from a Stream object
 84 
 85 class ClassFileParser {
 86   friend class FieldLayoutBuilder;
 87   friend class FieldLayout;
 88 
 89   class ClassAnnotationCollector;
 90   class FieldAllocationCount;
 91   class FieldAnnotationCollector;
 92 
 93  public:
 94   // The ClassFileParser has an associated &quot;publicity&quot; level
 95   // It is used to control which subsystems (if any)
 96   // will observe the parsing (logging, events, tracing).
 97   // Default level is &quot;BROADCAST&quot;, which is equivalent to
 98   // a &quot;public&quot; parsing attempt.
</pre>
<hr />
<pre>
118   GrowableArray&lt;Handle&gt;* _cp_patches; // overrides for CP entries
119   const bool _is_hidden;
120   const bool _can_access_vm_annotations;
121   int _num_patched_klasses;
122   int _max_num_patched_klasses;
123   int _orig_cp_size;
124   int _first_patched_klass_resolved_index;
125 
126   // Metadata created before the instance klass is created.  Must be deallocated
127   // if not transferred to the InstanceKlass upon successful class loading
128   // in which case these pointers have been set to NULL.
129   const InstanceKlass* _super_klass;
130   ConstantPool* _cp;
131   Array&lt;u2&gt;* _fields;
132   Array&lt;Method*&gt;* _methods;
133   Array&lt;u2&gt;* _inner_classes;
134   Array&lt;u2&gt;* _nest_members;
135   u2 _nest_host;
136   Array&lt;u2&gt;* _permitted_subclasses;
137   Array&lt;RecordComponent*&gt;* _record_components;
<span class="line-added">138   GrowableArray&lt;InstanceKlass*&gt;* _temp_local_interfaces;</span>
139   Array&lt;InstanceKlass*&gt;* _local_interfaces;
140   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
141   Annotations* _combined_annotations;
142   AnnotationArray* _class_annotations;
143   AnnotationArray* _class_type_annotations;
144   Array&lt;AnnotationArray*&gt;* _fields_annotations;
145   Array&lt;AnnotationArray*&gt;* _fields_type_annotations;
146   InstanceKlass* _klass;  // InstanceKlass* once created.
147   InstanceKlass* _klass_to_deallocate; // an InstanceKlass* to be destroyed
148 
149   ClassAnnotationCollector* _parsed_annotations;
150   FieldAllocationCount* _fac;
151   FieldLayoutInfo* _field_info;
152   const intArray* _method_ordering;
153   GrowableArray&lt;Method*&gt;* _all_mirandas;
154 
155   enum { fixed_buffer_size = 128 };
156   u_char _linenumbertable_buffer[fixed_buffer_size];
157 
158   // Size of Java vtable (in words)
159   int _vtable_size;
160   int _itable_size;
161 
162   int _num_miranda_methods;
163 
<span class="line-added">164   int _alignment;</span>
<span class="line-added">165   int _first_field_offset;</span>
<span class="line-added">166   int _exact_size_in_bytes;</span>
<span class="line-added">167 </span>
168   ReferenceType _rt;
169   Handle _protection_domain;
170   AccessFlags _access_flags;
171 
172   // for tracing and notifications
173   Publicity _pub_level;
174 
175   // Used to keep track of whether a constant pool item 19 or 20 is found.  These
176   // correspond to CONSTANT_Module and CONSTANT_Package tags and are not allowed
177   // in regular class files.  For class file version &gt;= 53, a CFE cannot be thrown
178   // immediately when these are seen because a NCDFE must be thrown if the class&#39;s
179   // access_flags have ACC_MODULE set.  But, the access_flags haven&#39;t been looked
180   // at yet.  So, the bad constant pool item is cached here.  A value of zero
181   // means that no constant pool item 19 or 20 was found.
182   short _bad_constant_seen;
183 
184   // class attributes parsed before the instance klass is created:
185   bool _synthetic_flag;
186   int _sde_length;
187   const char* _sde_buffer;
188   u2 _sourcefile_index;
189   u2 _generic_signature_index;
190 
191   u2 _major_version;
192   u2 _minor_version;
193   u2 _this_class_index;
194   u2 _super_class_index;
195   u2 _itfs_len;
196   u2 _java_fields_count;
197 
198   bool _need_verify;
199   bool _relax_verify;
200 
201   bool _has_nonstatic_concrete_methods;
202   bool _declares_nonstatic_concrete_methods;
203   bool _has_final_method;
204   bool _has_contended_fields;
205 
<span class="line-added">206   bool _has_flattenable_fields;</span>
<span class="line-added">207   bool _has_nonstatic_fields;</span>
<span class="line-added">208   bool _is_empty_inline_type;</span>
<span class="line-added">209   bool _is_naturally_atomic;</span>
<span class="line-added">210   bool _is_declared_atomic;</span>
<span class="line-added">211   bool _invalid_inline_super;   // if true, invalid super type for an inline type.</span>
<span class="line-added">212   bool _invalid_identity_super; // if true, invalid super type for an identity type.</span>
<span class="line-added">213   bool _implements_identityObject;</span>
<span class="line-added">214   bool _has_injected_identityObject;</span>
<span class="line-added">215 </span>
216   // precomputed flags
217   bool _has_finalizer;
218   bool _has_empty_finalizer;
219   bool _has_vanilla_constructor;
220   int _max_bootstrap_specifier_index;  // detects BSS values
221 
222   void parse_stream(const ClassFileStream* const stream, TRAPS);
223 
224   void mangle_hidden_class_name(InstanceKlass* const ik);
225 
226   void post_process_parsed_stream(const ClassFileStream* const stream,
227                                   ConstantPool* cp,
228                                   TRAPS);
229 
230   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
231   void fix_unsafe_anonymous_class_name(TRAPS);
232 
233   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH,
234                            const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
235 
</pre>
<hr />
<pre>
245   void create_combined_annotations(TRAPS);
246   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
247   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
248   void clear_class_metadata();
249 
250   // Constant pool parsing
251   void parse_constant_pool_entries(const ClassFileStream* const stream,
252                                    ConstantPool* cp,
253                                    const int length,
254                                    TRAPS);
255 
256   void parse_constant_pool(const ClassFileStream* const cfs,
257                            ConstantPool* const cp,
258                            const int length,
259                            TRAPS);
260 
261   // Interface parsing
262   void parse_interfaces(const ClassFileStream* const stream,
263                         const int itfs_len,
264                         ConstantPool* const cp,
<span class="line-added">265                         bool is_inline_type,</span>
266                         bool* has_nonstatic_concrete_methods,
<span class="line-added">267                         bool* is_declared_atomic,</span>
268                         TRAPS);
269 
270   const InstanceKlass* parse_super_class(ConstantPool* const cp,
271                                          const int super_class_index,
272                                          const bool need_verify,
273                                          TRAPS);
274 
275   // Field parsing
276   void parse_field_attributes(const ClassFileStream* const cfs,
277                               u2 attributes_count,
278                               bool is_static,
279                               u2 signature_index,
280                               u2* const constantvalue_index_addr,
281                               bool* const is_synthetic_addr,
282                               u2* const generic_signature_index_addr,
283                               FieldAnnotationCollector* parsed_annotations,
284                               TRAPS);
285 
286   void parse_fields(const ClassFileStream* const cfs,
287                     bool is_interface,
<span class="line-added">288                     bool is_inline_type,</span>
289                     FieldAllocationCount* const fac,
290                     ConstantPool* cp,
291                     const int cp_size,
292                     u2* const java_fields_count_ptr,
293                     TRAPS);
294 
295   // Method parsing
296   Method* parse_method(const ClassFileStream* const cfs,
297                        bool is_interface,
<span class="line-added">298                        bool is_inline_type,</span>
299                        const ConstantPool* cp,
300                        AccessFlags* const promoted_flags,
301                        TRAPS);
302 
303   void parse_methods(const ClassFileStream* const cfs,
304                      bool is_interface,
<span class="line-added">305                      bool is_inline_type,</span>
306                      AccessFlags* const promoted_flags,
307                      bool* const has_final_method,
308                      bool* const declares_nonstatic_concrete_methods,
309                      TRAPS);
310 
311   const unsafe_u2* parse_exception_table(const ClassFileStream* const stream,
312                                          u4 code_length,
313                                          u4 exception_table_length,
314                                          TRAPS);
315 
316   void parse_linenumber_table(u4 code_attribute_length,
317                               u4 code_length,
318                               CompressedLineNumberWriteStream**const write_stream,
319                               TRAPS);
320 
321   const unsafe_u2* parse_localvariable_table(const ClassFileStream* const cfs,
322                                              u4 code_length,
323                                              u2 max_locals,
324                                              u4 code_attribute_length,
325                                              u2* const localvariable_table_length,
</pre>
<hr />
<pre>
447   inline void guarantee_property(bool b,
448                                  const char* msg,
449                                  const char *name,
450                                  TRAPS) const {
451     if (!b) { classfile_parse_error(msg, name, CHECK); }
452   }
453 
454   inline void guarantee_property(bool b,
455                                  const char* msg,
456                                  int index,
457                                  const char *name,
458                                  TRAPS) const {
459     if (!b) { classfile_parse_error(msg, index, name, CHECK); }
460   }
461 
462   void throwIllegalSignature(const char* type,
463                              const Symbol* name,
464                              const Symbol* sig,
465                              TRAPS) const;
466 
<span class="line-added">467   void throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-added">468                                  const char* msg,</span>
<span class="line-added">469                                  const Symbol* name = NULL,</span>
<span class="line-added">470                                  const Symbol* sig  = NULL) const;</span>
<span class="line-added">471 </span>
472   void verify_constantvalue(const ConstantPool* const cp,
473                             int constantvalue_index,
474                             int signature_index,
475                             TRAPS) const;
476 
477   void verify_legal_utf8(const unsigned char* buffer, int length, TRAPS) const;
478   void verify_legal_class_name(const Symbol* name, TRAPS) const;
479   void verify_legal_field_name(const Symbol* name, TRAPS) const;
480   void verify_legal_method_name(const Symbol* name, TRAPS) const;
481 
482   void verify_legal_field_signature(const Symbol* fieldname,
483                                     const Symbol* signature,
484                                     TRAPS) const;
485   int  verify_legal_method_signature(const Symbol* methodname,
486                                      const Symbol* signature,
487                                      TRAPS) const;
488 
489   void verify_legal_class_modifiers(jint flags, TRAPS) const;
<span class="line-modified">490   void verify_legal_field_modifiers(jint flags,</span>
<span class="line-added">491                                     bool is_interface,</span>
<span class="line-added">492                                     bool is_inline_type,</span>
<span class="line-added">493                                     TRAPS) const;</span>
494   void verify_legal_method_modifiers(jint flags,
495                                      bool is_interface,
<span class="line-added">496                                      bool is_inline_type,</span>
497                                      const Symbol* name,
498                                      TRAPS) const;
499 
500   const char* skip_over_field_signature(const char* signature,
501                                         bool void_ok,
502                                         unsigned int length,
503                                         TRAPS) const;
504 
505   bool has_cp_patch_at(int index) const {
506     assert(index &gt;= 0, &quot;oob&quot;);
507     return (_cp_patches != NULL
508             &amp;&amp; index &lt; _cp_patches-&gt;length()
509             &amp;&amp; _cp_patches-&gt;adr_at(index)-&gt;not_null());
510   }
511 
512   Handle cp_patch_at(int index) const {
513     assert(has_cp_patch_at(index), &quot;oob&quot;);
514     return _cp_patches-&gt;at(index);
515   }
516 
</pre>
<hr />
<pre>
555                                int runtime_visible_parameter_annotations_length,
556                                const u1* runtime_invisible_parameter_annotations,
557                                int runtime_invisible_parameter_annotations_length,
558                                const u1* runtime_visible_type_annotations,
559                                int runtime_visible_type_annotations_length,
560                                const u1* runtime_invisible_type_annotations,
561                                int runtime_invisible_type_annotations_length,
562                                const u1* annotation_default,
563                                int annotation_default_length,
564                                TRAPS);
565 
566   // lays out fields in class and returns the total oopmap count
567   void layout_fields(ConstantPool* cp,
568                      const FieldAllocationCount* fac,
569                      const ClassAnnotationCollector* parsed_annotations,
570                      FieldLayoutInfo* info,
571                      TRAPS);
572 
573   void update_class_name(Symbol* new_name);
574 
<span class="line-added">575   // Check if the class file supports inline types</span>
<span class="line-added">576   bool supports_inline_types() const;</span>
<span class="line-added">577 </span>
578  public:
579   ClassFileParser(ClassFileStream* stream,
580                   Symbol* name,
581                   ClassLoaderData* loader_data,
582                   const ClassLoadInfo* cl_info,
583                   Publicity pub_level,
584                   TRAPS);
585 
586   ~ClassFileParser();
587 
588   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
589 
590   const ClassFileStream* clone_stream() const;
591 
592   void set_klass_to_deallocate(InstanceKlass* klass);
593 
594   int static_field_size() const;
595   int total_oop_map_count() const;
596   jint layout_size() const;
597 
598   int vtable_size() const { return _vtable_size; }
599   int itable_size() const { return _itable_size; }
600 
601   u2 this_class_index() const { return _this_class_index; }
602 
603   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
604   bool is_hidden() const { return _is_hidden; }
605   bool is_interface() const { return _access_flags.is_interface(); }
<span class="line-added">606   bool is_inline_type() const { return _access_flags.is_inline_type(); }</span>
<span class="line-added">607   bool is_value_capable_class() const;</span>
<span class="line-added">608   bool has_flattenable_fields() const { return _has_flattenable_fields; }</span>
<span class="line-added">609   bool invalid_inline_super() const { return _invalid_inline_super; }</span>
<span class="line-added">610   void set_invalid_inline_super() { _invalid_inline_super = true; }</span>
<span class="line-added">611   bool invalid_identity_super() const { return _invalid_identity_super; }</span>
<span class="line-added">612   void set_invalid_identity_super() { _invalid_identity_super = true; }</span>
<span class="line-added">613   bool is_invalid_super_for_inline_type();</span>
<span class="line-added">614 </span>
<span class="line-added">615   u2 java_fields_count() const { return _java_fields_count; }</span>
616 
617   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
618   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
619   ClassLoaderData* loader_data() const { return _loader_data; }
620   const Symbol* class_name() const { return _class_name; }
621   const InstanceKlass* super_klass() const { return _super_klass; }
622 
623   ReferenceType reference_type() const { return _rt; }
624   AccessFlags access_flags() const { return _access_flags; }
625 
626   bool is_internal() const { return INTERNAL == _pub_level; }
627 
628   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
629 
630 #ifdef ASSERT
631   static bool is_internal_format(Symbol* class_name);
632 #endif
633 
634 };
635 
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
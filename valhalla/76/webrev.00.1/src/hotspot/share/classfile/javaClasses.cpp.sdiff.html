<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;


  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
  72 #include &quot;utilities/utf8.hpp&quot;
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 791   bool is_latin1 = java_lang_String::is_latin1(java_string);
 792 
 793   st-&gt;print(&quot;\&quot;&quot;);
 794   for (int index = 0; index &lt; length; index++) {
 795     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 796                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 797   }
 798   st-&gt;print(&quot;\&quot;&quot;);
 799 }
 800 
 801 // java_lang_Class
 802 
 803 int java_lang_Class::_klass_offset;
 804 int java_lang_Class::_array_klass_offset;
 805 int java_lang_Class::_oop_size_offset;
 806 int java_lang_Class::_static_oop_field_count_offset;
 807 int java_lang_Class::_class_loader_offset;
 808 int java_lang_Class::_module_offset;
 809 int java_lang_Class::_protection_domain_offset;
 810 int java_lang_Class::_component_mirror_offset;


 811 int java_lang_Class::_init_lock_offset;
 812 int java_lang_Class::_signers_offset;
 813 int java_lang_Class::_name_offset;
 814 int java_lang_Class::_source_file_offset;
 815 int java_lang_Class::_classData_offset;
 816 int java_lang_Class::_classRedefinedCount_offset;
 817 
 818 bool java_lang_Class::_offsets_computed = false;
 819 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
 820 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
 821 
 822 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 823   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 824   if (fd-&gt;has_initial_value()) {
 825     BasicType t = fd-&gt;field_type();
 826     switch (t) {
 827       case T_BYTE:
 828         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 829               break;
 830       case T_BOOLEAN:
</pre>
<hr />
<pre>
 986   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 987   k-&gt;set_modifier_flags(computed_modifiers);
 988   // Class_klass has to be loaded because it is used to allocate
 989   // the mirror.
 990   if (SystemDictionary::Class_klass_loaded()) {
 991     // Allocate mirror (java.lang.Class instance)
 992     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 993     Handle mirror(THREAD, mirror_oop);
 994     Handle comp_mirror;
 995 
 996     // Setup indirection from mirror-&gt;klass
 997     java_lang_Class::set_klass(mirror(), k);
 998 
 999     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
1000     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
1001 
1002     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
1003 
1004     // It might also have a component mirror.  This mirror must already exist.
1005     if (k-&gt;is_array_klass()) {
<span class="line-modified">1006       if (k-&gt;is_typeArray_klass()) {</span>





1007         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
1008         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
1009       } else {
1010         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1011         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1012         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1013         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1014       }
1015       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1016 
1017       // Two-way link between the array klass and its component mirror:
1018       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1019       set_component_mirror(mirror(), comp_mirror());
1020       // See below for ordering dependencies between field array_klass in component mirror
1021       // and java_mirror in this klass.
1022     } else {
1023       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1024 
1025       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1026       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1033       }
1034     }
1035 
1036     // set the classLoader field in the java_lang_Class instance
1037     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1038     set_class_loader(mirror(), class_loader());
1039 
1040     // Setup indirection from klass-&gt;mirror
1041     // after any exceptions can happen during allocations.
1042     k-&gt;set_java_mirror(mirror);
1043 
1044     // Set the module field in the java_lang_Class instance.  This must be done
1045     // after the mirror is set.
1046     set_mirror_module_field(k, mirror, module, THREAD);
1047 
1048     if (comp_mirror() != NULL) {
1049       // Set after k-&gt;java_mirror() is published, because compiled code running
1050       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1051       release_set_array_klass(comp_mirror(), k);
1052     }

















1053   } else {
1054     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1055     fixup_mirror_list()-&gt;push(k);
1056   }
1057 }
1058 
1059 #if INCLUDE_CDS_JAVA_HEAP
1060 // Clears mirror fields. Static final fields with initial values are reloaded
1061 // from constant pool. The object identity hash is in the object header and is
1062 // not affected.
1063 class ResetMirrorField: public FieldClosure {
1064  private:
1065   Handle _m;
1066 
1067  public:
1068   ResetMirrorField(Handle mirror) : _m(mirror) {}
1069 
1070   void do_field(fieldDescriptor* fd) {
1071     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1072     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1189 
1190   // No mirror
1191   oop mirror = k-&gt;java_mirror();
1192   if (mirror == NULL) {
1193     return NULL;
1194   }
1195 
1196   if (k-&gt;is_instance_klass()) {
1197     InstanceKlass *ik = InstanceKlass::cast(k);
1198     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1199 
1200     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1201           ik-&gt;is_shared_app_class())) {
1202       // Archiving mirror for classes from non-builtin loaders is not
1203       // supported. Clear the _java_mirror within the archived class.
1204       k-&gt;set_java_mirror_handle(NULL);
1205       return NULL;
1206     }
1207   }
1208 






1209   // Now start archiving the mirror object
1210   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1211   if (archived_mirror == NULL) {
1212     return NULL;
1213   }
1214 
1215   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1216   if (archived_mirror == NULL) {
1217     return NULL;
1218   }
1219 
1220   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1221 
1222   k-&gt;set_has_raw_archived_mirror();
1223 
1224   ResourceMark rm;
1225   log_trace(cds, heap, mirror)(
1226     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1227     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1228 
</pre>
<hr />
<pre>
1480 oop java_lang_Class::name(Handle java_class, TRAPS) {
1481   assert(_name_offset != 0, &quot;must be set&quot;);
1482   oop o = java_class-&gt;obj_field(_name_offset);
1483   if (o == NULL) {
1484     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1485     java_class-&gt;obj_field_put(_name_offset, o);
1486   }
1487   return o;
1488 }
1489 
1490 oop java_lang_Class::source_file(oop java_class) {
1491   assert(_source_file_offset != 0, &quot;must be set&quot;);
1492   return java_class-&gt;obj_field(_source_file_offset);
1493 }
1494 
1495 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1496   assert(_source_file_offset != 0, &quot;must be set&quot;);
1497   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1498 }
1499 




















1500 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1501   // This should be improved by adding a field at the Java level or by
1502   // introducing a new VM klass (see comment in ClassFileParser)
1503   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1504   if (type != T_VOID) {
1505     Klass* aklass = Universe::typeArrayKlassObj(type);
1506     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1507     release_set_array_klass(java_class, aklass);
1508   }
1509 #ifdef ASSERT
1510   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1511   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1512 #endif
1513   return java_class;
1514 }
1515 
1516 
1517 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1518   //%note memory_2
1519   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1520   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1521   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1522   return k;
1523 }
1524 
1525 
1526 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1527   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1528   java_class-&gt;metadata_field_put(_klass_offset, klass);
1529 }
1530 
1531 
1532 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1533   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1534   Symbol* name = NULL;
1535   bool is_instance = false;

1536   if (is_primitive(java_class)) {
1537     name = vmSymbols::type_signature(primitive_type(java_class));
1538   } else {
1539     Klass* k = as_Klass(java_class);
1540     is_instance = k-&gt;is_instance_klass();

1541     name = k-&gt;name();
1542   }
1543   if (name == NULL) {
1544     st-&gt;print(&quot;&lt;null&gt;&quot;);
1545     return;
1546   }
<span class="line-modified">1547   if (is_instance)  st-&gt;print(&quot;L&quot;);</span>






1548   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1549   if (is_instance)  st-&gt;print(&quot;;&quot;);
1550 }
1551 
1552 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1553   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1554   Symbol* name;
1555   if (is_primitive(java_class)) {
1556     name = vmSymbols::type_signature(primitive_type(java_class));
1557     // Because this can create a new symbol, the caller has to decrement
1558     // the refcount, so make adjustment here and below for symbols returned
1559     // that are not created or incremented due to a successful lookup.
1560     name-&gt;increment_refcount();
1561   } else {
1562     Klass* k = as_Klass(java_class);
1563     if (!k-&gt;is_instance_klass()) {
1564       name = k-&gt;name();
1565       name-&gt;increment_refcount();
1566     } else {
1567       ResourceMark rm;
1568       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1569       int         siglen = (int) strlen(sigstr);</span>
1570       if (!intern_if_not_found) {
1571         name = SymbolTable::probe(sigstr, siglen);
1572       } else {
1573         name = SymbolTable::new_symbol(sigstr, siglen);
1574       }
1575     }
1576   }
1577   return name;
1578 }
1579 
1580 // Returns the Java name for this Java mirror (Resource allocated)
1581 // See Klass::external_name().
1582 // For primitive type Java mirrors, its type name is returned.
1583 const char* java_lang_Class::as_external_name(oop java_class) {
1584   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1585   const char* name = NULL;
1586   if (is_primitive(java_class)) {
1587     name = type2name(primitive_type(java_class));
1588   } else {
1589     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1630   } else {
1631     if (reference_klass != NULL)
1632       (*reference_klass) = as_Klass(java_class);
1633     return T_OBJECT;
1634   }
1635 }
1636 
1637 
1638 oop java_lang_Class::primitive_mirror(BasicType t) {
1639   oop mirror = Universe::java_mirror(t);
1640   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1641   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1642   return mirror;
1643 }
1644 
1645 #define CLASS_FIELDS_DO(macro) \
1646   macro(_classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1647   macro(_class_loader_offset,        k, &quot;classLoader&quot;,         classloader_signature, false); \
1648   macro(_component_mirror_offset,    k, &quot;componentType&quot;,       class_signature,       false); \
1649   macro(_module_offset,              k, &quot;module&quot;,              module_signature,      false); \


1650   macro(_name_offset,                k, &quot;name&quot;,                string_signature,      false); \
1651   macro(_classData_offset,           k, &quot;classData&quot;,           object_signature,      false);
1652 
1653 void java_lang_Class::compute_offsets() {
1654   if (_offsets_computed) {
1655     return;
1656   }
1657 
1658   _offsets_computed = true;
1659 
1660   InstanceKlass* k = SystemDictionary::Class_klass();
1661   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1662 
1663   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1664   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1665   // GC treats them the same.
1666   _init_lock_offset = _component_mirror_offset;
1667 
1668   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1669 }
</pre>
<hr />
<pre>
2514 #endif
2515 
2516     // the format of the stacktrace will be:
2517     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2518     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2519     // - rest of the stack
2520 
2521     if (!skip_fillInStackTrace_check) {
2522       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2523           throwable-&gt;is_a(method-&gt;method_holder())) {
2524         continue;
2525       }
2526       else {
2527         skip_fillInStackTrace_check = true; // gone past them all
2528       }
2529     }
2530     if (!skip_throwableInit_check) {
2531       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2532 
2533       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2534       // This is simlar to classic VM.</span>
<span class="line-modified">2535       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
2536           throwable-&gt;is_a(method-&gt;method_holder())) {
2537         continue;
2538       } else {
2539         // there are none or we&#39;ve seen them all - either way stop checking
2540         skip_throwableInit_check = true;
2541       }
2542     }
2543     if (method-&gt;is_hidden()) {
2544       if (skip_hidden) {
2545         if (total_count == 0) {
2546           // The top frame will be hidden from the stack trace.
2547           bt.set_has_hidden_top_frame(CHECK);
2548         }
2549         continue;
2550       }
2551     }
2552     bt.push(method, bci, CHECK);
2553     total_count++;
2554   }
2555 
</pre>
<hr />
<pre>
3878 int java_lang_invoke_MemberName::flags(oop mname) {
3879   assert(is_instance(mname), &quot;wrong type&quot;);
3880   return mname-&gt;int_field(_flags_offset);
3881 }
3882 
3883 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3884   assert(is_instance(mname), &quot;wrong type&quot;);
3885   mname-&gt;int_field_put(_flags_offset, flags);
3886 }
3887 
3888 
3889 // Return vmtarget from ResolvedMethodName method field through indirection
3890 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3891   assert(is_instance(mname), &quot;wrong type&quot;);
3892   oop method = mname-&gt;obj_field(_method_offset);
3893   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3894 }
3895 
3896 bool java_lang_invoke_MemberName::is_method(oop mname) {
3897   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3898   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;</span>
3899 }
3900 
3901 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3902   assert(is_instance(mname), &quot;wrong type&quot;);
3903   mname-&gt;obj_field_put(_method_offset, resolved_method);
3904 }
3905 
3906 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3907   assert(is_instance(mname), &quot;wrong type&quot;);
3908   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3909 }
3910 
3911 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3912   assert(is_instance(mname), &quot;wrong type&quot;);
3913   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3914 }
3915 
3916 
3917 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3918   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4680   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4681   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4682 }
4683 
4684 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4685   oop base = ik-&gt;static_field_base_raw();
4686   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4687 }
4688 
4689 Symbol* java_lang_Byte_ByteCache::symbol() {
4690   return vmSymbols::java_lang_Byte_ByteCache();
4691 }
4692 
4693 #if INCLUDE_CDS
4694 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4695   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4696 }
4697 #endif
4698 #undef BYTE_CACHE_FIELDS_DO
4699 







































































4700 jbyte java_lang_Byte::value(oop obj) {
4701    jvalue v;
4702    java_lang_boxing_object::get_value(obj, &amp;v);
4703    return v.b;
4704 }
4705 
4706 int java_lang_Boolean::_static_TRUE_offset;
4707 int java_lang_Boolean::_static_FALSE_offset;
4708 
4709 #define BOOLEAN_FIELDS_DO(macro) \
4710   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4711   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4712 
4713 
4714 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4715   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4716   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4717 }
4718 
4719 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
</pre>
</td>
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  55 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  56 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/safepoint.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/vframe.inline.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/preserveException.hpp&quot;
  74 #include &quot;utilities/utf8.hpp&quot;
  75 #if INCLUDE_JVMCI
  76 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 793   bool is_latin1 = java_lang_String::is_latin1(java_string);
 794 
 795   st-&gt;print(&quot;\&quot;&quot;);
 796   for (int index = 0; index &lt; length; index++) {
 797     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 798                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 799   }
 800   st-&gt;print(&quot;\&quot;&quot;);
 801 }
 802 
 803 // java_lang_Class
 804 
 805 int java_lang_Class::_klass_offset;
 806 int java_lang_Class::_array_klass_offset;
 807 int java_lang_Class::_oop_size_offset;
 808 int java_lang_Class::_static_oop_field_count_offset;
 809 int java_lang_Class::_class_loader_offset;
 810 int java_lang_Class::_module_offset;
 811 int java_lang_Class::_protection_domain_offset;
 812 int java_lang_Class::_component_mirror_offset;
<span class="line-added"> 813 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-added"> 814 int java_lang_Class::_ref_type_mirror_offset;</span>
 815 int java_lang_Class::_init_lock_offset;
 816 int java_lang_Class::_signers_offset;
 817 int java_lang_Class::_name_offset;
 818 int java_lang_Class::_source_file_offset;
 819 int java_lang_Class::_classData_offset;
 820 int java_lang_Class::_classRedefinedCount_offset;
 821 
 822 bool java_lang_Class::_offsets_computed = false;
 823 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
 824 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
 825 
 826 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 827   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 828   if (fd-&gt;has_initial_value()) {
 829     BasicType t = fd-&gt;field_type();
 830     switch (t) {
 831       case T_BYTE:
 832         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 833               break;
 834       case T_BOOLEAN:
</pre>
<hr />
<pre>
 990   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 991   k-&gt;set_modifier_flags(computed_modifiers);
 992   // Class_klass has to be loaded because it is used to allocate
 993   // the mirror.
 994   if (SystemDictionary::Class_klass_loaded()) {
 995     // Allocate mirror (java.lang.Class instance)
 996     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 997     Handle mirror(THREAD, mirror_oop);
 998     Handle comp_mirror;
 999 
1000     // Setup indirection from mirror-&gt;klass
1001     java_lang_Class::set_klass(mirror(), k);
1002 
1003     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
1004     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
1005 
1006     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
1007 
1008     // It might also have a component mirror.  This mirror must already exist.
1009     if (k-&gt;is_array_klass()) {
<span class="line-modified">1010       if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added">1011         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added">1012         assert(element_klass-&gt;is_value(), &quot;Must be value type component&quot;);</span>
<span class="line-added">1013         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added">1014         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());</span>
<span class="line-added">1015       } else if (k-&gt;is_typeArray_klass()) {</span>
1016         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
1017         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
1018       } else {
1019         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1020         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1021         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1022         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1023       }
1024       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1025 
1026       // Two-way link between the array klass and its component mirror:
1027       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1028       set_component_mirror(mirror(), comp_mirror());
1029       // See below for ordering dependencies between field array_klass in component mirror
1030       // and java_mirror in this klass.
1031     } else {
1032       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1033 
1034       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1035       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1042       }
1043     }
1044 
1045     // set the classLoader field in the java_lang_Class instance
1046     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1047     set_class_loader(mirror(), class_loader());
1048 
1049     // Setup indirection from klass-&gt;mirror
1050     // after any exceptions can happen during allocations.
1051     k-&gt;set_java_mirror(mirror);
1052 
1053     // Set the module field in the java_lang_Class instance.  This must be done
1054     // after the mirror is set.
1055     set_mirror_module_field(k, mirror, module, THREAD);
1056 
1057     if (comp_mirror() != NULL) {
1058       // Set after k-&gt;java_mirror() is published, because compiled code running
1059       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1060       release_set_array_klass(comp_mirror(), k);
1061     }
<span class="line-added">1062 </span>
<span class="line-added">1063     if (k-&gt;is_value()) {</span>
<span class="line-added">1064       InstanceKlass* super = k-&gt;java_super();</span>
<span class="line-added">1065       set_val_type_mirror(mirror(), mirror());</span>
<span class="line-added">1066 </span>
<span class="line-added">1067       // if the supertype is a restricted abstract class</span>
<span class="line-added">1068       if (super != SystemDictionary::Object_klass()) {</span>
<span class="line-added">1069         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);</span>
<span class="line-added">1070         oop ref_type_oop = super-&gt;java_mirror();</span>
<span class="line-added">1071         // set the reference projection type</span>
<span class="line-added">1072         set_ref_type_mirror(mirror(), ref_type_oop);</span>
<span class="line-added">1073 </span>
<span class="line-added">1074         // set the value and reference projection types</span>
<span class="line-added">1075         set_val_type_mirror(ref_type_oop, mirror());</span>
<span class="line-added">1076         set_ref_type_mirror(ref_type_oop, ref_type_oop);</span>
<span class="line-added">1077       }</span>
<span class="line-added">1078     }</span>
1079   } else {
1080     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1081     fixup_mirror_list()-&gt;push(k);
1082   }
1083 }
1084 
1085 #if INCLUDE_CDS_JAVA_HEAP
1086 // Clears mirror fields. Static final fields with initial values are reloaded
1087 // from constant pool. The object identity hash is in the object header and is
1088 // not affected.
1089 class ResetMirrorField: public FieldClosure {
1090  private:
1091   Handle _m;
1092 
1093  public:
1094   ResetMirrorField(Handle mirror) : _m(mirror) {}
1095 
1096   void do_field(fieldDescriptor* fd) {
1097     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1098     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1215 
1216   // No mirror
1217   oop mirror = k-&gt;java_mirror();
1218   if (mirror == NULL) {
1219     return NULL;
1220   }
1221 
1222   if (k-&gt;is_instance_klass()) {
1223     InstanceKlass *ik = InstanceKlass::cast(k);
1224     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1225 
1226     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1227           ik-&gt;is_shared_app_class())) {
1228       // Archiving mirror for classes from non-builtin loaders is not
1229       // supported. Clear the _java_mirror within the archived class.
1230       k-&gt;set_java_mirror_handle(NULL);
1231       return NULL;
1232     }
1233   }
1234 
<span class="line-added">1235   if (k-&gt;is_value()) {</span>
<span class="line-added">1236     // Values have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
<span class="line-added">1237     k-&gt;set_java_mirror_handle(NULL);</span>
<span class="line-added">1238     return NULL;</span>
<span class="line-added">1239   }</span>
<span class="line-added">1240 </span>
1241   // Now start archiving the mirror object
1242   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1243   if (archived_mirror == NULL) {
1244     return NULL;
1245   }
1246 
1247   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1248   if (archived_mirror == NULL) {
1249     return NULL;
1250   }
1251 
1252   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1253 
1254   k-&gt;set_has_raw_archived_mirror();
1255 
1256   ResourceMark rm;
1257   log_trace(cds, heap, mirror)(
1258     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1259     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1260 
</pre>
<hr />
<pre>
1512 oop java_lang_Class::name(Handle java_class, TRAPS) {
1513   assert(_name_offset != 0, &quot;must be set&quot;);
1514   oop o = java_class-&gt;obj_field(_name_offset);
1515   if (o == NULL) {
1516     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1517     java_class-&gt;obj_field_put(_name_offset, o);
1518   }
1519   return o;
1520 }
1521 
1522 oop java_lang_Class::source_file(oop java_class) {
1523   assert(_source_file_offset != 0, &quot;must be set&quot;);
1524   return java_class-&gt;obj_field(_source_file_offset);
1525 }
1526 
1527 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1528   assert(_source_file_offset != 0, &quot;must be set&quot;);
1529   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1530 }
1531 
<span class="line-added">1532 oop java_lang_Class::val_type_mirror(oop java_class) {</span>
<span class="line-added">1533   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1534   return java_class-&gt;obj_field(_val_type_mirror_offset);</span>
<span class="line-added">1535 }</span>
<span class="line-added">1536 </span>
<span class="line-added">1537 void java_lang_Class::set_val_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1538   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1539   java_class-&gt;obj_field_put(_val_type_mirror_offset, mirror);</span>
<span class="line-added">1540 }</span>
<span class="line-added">1541 </span>
<span class="line-added">1542 oop java_lang_Class::ref_type_mirror(oop java_class) {</span>
<span class="line-added">1543   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1544   return java_class-&gt;obj_field(_ref_type_mirror_offset);</span>
<span class="line-added">1545 }</span>
<span class="line-added">1546 </span>
<span class="line-added">1547 void java_lang_Class::set_ref_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1548   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1549   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);</span>
<span class="line-added">1550 }</span>
<span class="line-added">1551 </span>
1552 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1553   // This should be improved by adding a field at the Java level or by
1554   // introducing a new VM klass (see comment in ClassFileParser)
1555   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1556   if (type != T_VOID) {
1557     Klass* aklass = Universe::typeArrayKlassObj(type);
1558     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1559     release_set_array_klass(java_class, aklass);
1560   }
1561 #ifdef ASSERT
1562   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1563   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1564 #endif
1565   return java_class;
1566 }
1567 
1568 
1569 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1570   //%note memory_2
1571   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1572   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1573   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1574   return k;
1575 }
1576 
1577 
1578 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1579   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1580   java_class-&gt;metadata_field_put(_klass_offset, klass);
1581 }
1582 
1583 
1584 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1585   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1586   Symbol* name = NULL;
1587   bool is_instance = false;
<span class="line-added">1588   bool is_value = false;</span>
1589   if (is_primitive(java_class)) {
1590     name = vmSymbols::type_signature(primitive_type(java_class));
1591   } else {
1592     Klass* k = as_Klass(java_class);
1593     is_instance = k-&gt;is_instance_klass();
<span class="line-added">1594     is_value = k-&gt;is_value();</span>
1595     name = k-&gt;name();
1596   }
1597   if (name == NULL) {
1598     st-&gt;print(&quot;&lt;null&gt;&quot;);
1599     return;
1600   }
<span class="line-modified">1601   if (is_instance)  {</span>
<span class="line-added">1602     if (is_value) {</span>
<span class="line-added">1603       st-&gt;print(&quot;Q&quot;);</span>
<span class="line-added">1604     } else {</span>
<span class="line-added">1605       st-&gt;print(&quot;L&quot;);</span>
<span class="line-added">1606     }</span>
<span class="line-added">1607   }</span>
1608   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1609   if (is_instance)  st-&gt;print(&quot;;&quot;);
1610 }
1611 
1612 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1613   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1614   Symbol* name;
1615   if (is_primitive(java_class)) {
1616     name = vmSymbols::type_signature(primitive_type(java_class));
1617     // Because this can create a new symbol, the caller has to decrement
1618     // the refcount, so make adjustment here and below for symbols returned
1619     // that are not created or incremented due to a successful lookup.
1620     name-&gt;increment_refcount();
1621   } else {
1622     Klass* k = as_Klass(java_class);
1623     if (!k-&gt;is_instance_klass()) {
1624       name = k-&gt;name();
1625       name-&gt;increment_refcount();
1626     } else {
1627       ResourceMark rm;
1628       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1629       int siglen = (int) strlen(sigstr);</span>
1630       if (!intern_if_not_found) {
1631         name = SymbolTable::probe(sigstr, siglen);
1632       } else {
1633         name = SymbolTable::new_symbol(sigstr, siglen);
1634       }
1635     }
1636   }
1637   return name;
1638 }
1639 
1640 // Returns the Java name for this Java mirror (Resource allocated)
1641 // See Klass::external_name().
1642 // For primitive type Java mirrors, its type name is returned.
1643 const char* java_lang_Class::as_external_name(oop java_class) {
1644   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1645   const char* name = NULL;
1646   if (is_primitive(java_class)) {
1647     name = type2name(primitive_type(java_class));
1648   } else {
1649     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1690   } else {
1691     if (reference_klass != NULL)
1692       (*reference_klass) = as_Klass(java_class);
1693     return T_OBJECT;
1694   }
1695 }
1696 
1697 
1698 oop java_lang_Class::primitive_mirror(BasicType t) {
1699   oop mirror = Universe::java_mirror(t);
1700   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1701   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1702   return mirror;
1703 }
1704 
1705 #define CLASS_FIELDS_DO(macro) \
1706   macro(_classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1707   macro(_class_loader_offset,        k, &quot;classLoader&quot;,         classloader_signature, false); \
1708   macro(_component_mirror_offset,    k, &quot;componentType&quot;,       class_signature,       false); \
1709   macro(_module_offset,              k, &quot;module&quot;,              module_signature,      false); \
<span class="line-added">1710   macro(_name_offset,                k, &quot;name&quot;,                string_signature,      false); \</span>
<span class="line-added">1711   macro(_val_type_mirror_offset,     k, &quot;valType&quot;,             class_signature,       false); \</span>
1712   macro(_ref_type_mirror_offset,     k, &quot;refType&quot;,             class_signature,       false); \
1713   macro(_classData_offset,           k, &quot;classData&quot;,           object_signature,      false);
1714 
1715 void java_lang_Class::compute_offsets() {
1716   if (_offsets_computed) {
1717     return;
1718   }
1719 
1720   _offsets_computed = true;
1721 
1722   InstanceKlass* k = SystemDictionary::Class_klass();
1723   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1724 
1725   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1726   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1727   // GC treats them the same.
1728   _init_lock_offset = _component_mirror_offset;
1729 
1730   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1731 }
</pre>
<hr />
<pre>
2576 #endif
2577 
2578     // the format of the stacktrace will be:
2579     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2580     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2581     // - rest of the stack
2582 
2583     if (!skip_fillInStackTrace_check) {
2584       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2585           throwable-&gt;is_a(method-&gt;method_holder())) {
2586         continue;
2587       }
2588       else {
2589         skip_fillInStackTrace_check = true; // gone past them all
2590       }
2591     }
2592     if (!skip_throwableInit_check) {
2593       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2594 
2595       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2596       // This is similar to classic VM (before HotSpot).</span>
<span class="line-modified">2597       if (method-&gt;is_object_constructor() &amp;&amp;</span>
2598           throwable-&gt;is_a(method-&gt;method_holder())) {
2599         continue;
2600       } else {
2601         // there are none or we&#39;ve seen them all - either way stop checking
2602         skip_throwableInit_check = true;
2603       }
2604     }
2605     if (method-&gt;is_hidden()) {
2606       if (skip_hidden) {
2607         if (total_count == 0) {
2608           // The top frame will be hidden from the stack trace.
2609           bt.set_has_hidden_top_frame(CHECK);
2610         }
2611         continue;
2612       }
2613     }
2614     bt.push(method, bci, CHECK);
2615     total_count++;
2616   }
2617 
</pre>
<hr />
<pre>
3940 int java_lang_invoke_MemberName::flags(oop mname) {
3941   assert(is_instance(mname), &quot;wrong type&quot;);
3942   return mname-&gt;int_field(_flags_offset);
3943 }
3944 
3945 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3946   assert(is_instance(mname), &quot;wrong type&quot;);
3947   mname-&gt;int_field_put(_flags_offset, flags);
3948 }
3949 
3950 
3951 // Return vmtarget from ResolvedMethodName method field through indirection
3952 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3953   assert(is_instance(mname), &quot;wrong type&quot;);
3954   oop method = mname-&gt;obj_field(_method_offset);
3955   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3956 }
3957 
3958 bool java_lang_invoke_MemberName::is_method(oop mname) {
3959   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3960   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) &gt; 0;</span>
3961 }
3962 
3963 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3964   assert(is_instance(mname), &quot;wrong type&quot;);
3965   mname-&gt;obj_field_put(_method_offset, resolved_method);
3966 }
3967 
3968 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3969   assert(is_instance(mname), &quot;wrong type&quot;);
3970   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3971 }
3972 
3973 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3974   assert(is_instance(mname), &quot;wrong type&quot;);
3975   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3976 }
3977 
3978 
3979 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3980   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4742   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4743   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4744 }
4745 
4746 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4747   oop base = ik-&gt;static_field_base_raw();
4748   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4749 }
4750 
4751 Symbol* java_lang_Byte_ByteCache::symbol() {
4752   return vmSymbols::java_lang_Byte_ByteCache();
4753 }
4754 
4755 #if INCLUDE_CDS
4756 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4757   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4758 }
4759 #endif
4760 #undef BYTE_CACHE_FIELDS_DO
4761 
<span class="line-added">4762 // jdk_internal_vm_jni_SubElementSelector</span>
<span class="line-added">4763 </span>
<span class="line-added">4764 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4765 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4766 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4767 int jdk_internal_vm_jni_SubElementSelector::_isFlattened_offset;</span>
<span class="line-added">4768 int jdk_internal_vm_jni_SubElementSelector::_isFlattenable_offset;</span>
<span class="line-added">4769 </span>
<span class="line-added">4770 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \</span>
<span class="line-added">4771   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \</span>
<span class="line-added">4772   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \</span>
<span class="line-added">4773   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \</span>
<span class="line-added">4774   macro(_isFlattened_offset,       k, &quot;isFlattened&quot;,      bool_signature,  false); \</span>
<span class="line-added">4775   macro(_isFlattenable_offset,     k, &quot;isFlattenable&quot;,    bool_signature,  false);</span>
<span class="line-added">4776 </span>
<span class="line-added">4777 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {</span>
<span class="line-added">4778   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();</span>
<span class="line-added">4779   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4780 }</span>
<span class="line-added">4781 </span>
<span class="line-added">4782 #if INCLUDE_CDS</span>
<span class="line-added">4783 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4784   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4785 }</span>
<span class="line-added">4786 #endif</span>
<span class="line-added">4787 #undef SUBELEMENT_SELECTOR_FIELDS_DO</span>
<span class="line-added">4788 </span>
<span class="line-added">4789 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {</span>
<span class="line-added">4790   return vmSymbols::jdk_internal_vm_jni_SubElementSelector();</span>
<span class="line-added">4791 }</span>
<span class="line-added">4792 </span>
<span class="line-added">4793 oop jdk_internal_vm_jni_SubElementSelector::getArrayElementType(oop obj) {</span>
<span class="line-added">4794   return obj-&gt;obj_field(_arrayElementType_offset);</span>
<span class="line-added">4795 }</span>
<span class="line-added">4796 </span>
<span class="line-added">4797 void jdk_internal_vm_jni_SubElementSelector::setArrayElementType(oop obj, oop type) {</span>
<span class="line-added">4798   obj-&gt;obj_field_put(_arrayElementType_offset, type);</span>
<span class="line-added">4799 }</span>
<span class="line-added">4800 </span>
<span class="line-added">4801 oop jdk_internal_vm_jni_SubElementSelector::getSubElementType(oop obj) {</span>
<span class="line-added">4802   return obj-&gt;obj_field(_subElementType_offset);</span>
<span class="line-added">4803 }</span>
<span class="line-added">4804 </span>
<span class="line-added">4805 void jdk_internal_vm_jni_SubElementSelector::setSubElementType(oop obj, oop type) {</span>
<span class="line-added">4806   obj-&gt;obj_field_put(_subElementType_offset, type);</span>
<span class="line-added">4807 }</span>
<span class="line-added">4808 </span>
<span class="line-added">4809 int jdk_internal_vm_jni_SubElementSelector::getOffset(oop obj) {</span>
<span class="line-added">4810   return obj-&gt;int_field(_offset_offset);</span>
<span class="line-added">4811 }</span>
<span class="line-added">4812 </span>
<span class="line-added">4813 void jdk_internal_vm_jni_SubElementSelector::setOffset(oop obj, int offset) {</span>
<span class="line-added">4814   obj-&gt;int_field_put(_offset_offset, offset);</span>
<span class="line-added">4815 }</span>
<span class="line-added">4816 </span>
<span class="line-added">4817 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattened(oop obj) {</span>
<span class="line-added">4818   return obj-&gt;bool_field(_isFlattened_offset);</span>
<span class="line-added">4819 }</span>
<span class="line-added">4820 </span>
<span class="line-added">4821 void jdk_internal_vm_jni_SubElementSelector::setIsFlattened(oop obj, bool b) {</span>
<span class="line-added">4822   obj-&gt;bool_field_put(_isFlattened_offset, b);</span>
<span class="line-added">4823 }</span>
<span class="line-added">4824 </span>
<span class="line-added">4825 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(oop obj) {</span>
<span class="line-added">4826   return obj-&gt;bool_field(_isFlattenable_offset);</span>
<span class="line-added">4827 }</span>
<span class="line-added">4828 </span>
<span class="line-added">4829 void jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(oop obj, bool b) {</span>
<span class="line-added">4830   obj-&gt;bool_field_put(_isFlattenable_offset, b);</span>
<span class="line-added">4831 }</span>
<span class="line-added">4832 </span>
4833 jbyte java_lang_Byte::value(oop obj) {
4834    jvalue v;
4835    java_lang_boxing_object::get_value(obj, &amp;v);
4836    return v.b;
4837 }
4838 
4839 int java_lang_Boolean::_static_TRUE_offset;
4840 int java_lang_Boolean::_static_FALSE_offset;
4841 
4842 #define BOOLEAN_FIELDS_DO(macro) \
4843   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4844   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4845 
4846 
4847 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4848   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4849   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4850 }
4851 
4852 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
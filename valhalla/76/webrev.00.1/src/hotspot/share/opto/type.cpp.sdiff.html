<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stringopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;

  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;ci/ciTypeFlow.hpp&quot;

  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;compiler/compileLog.hpp&quot;
  31 #include &quot;libadt/dict.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/typeArrayKlass.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/node.hpp&quot;
  40 #include &quot;opto/opcodes.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 // Portions of code courtesy of Clifford Click
  45 
  46 // Optimization - Graph Style
  47 
  48 // Dictionary of types shared among compilations.
  49 Dict* Type::_shared_type_dict = NULL;














































  50 
  51 // Array which maps compiler types to Basic Types
  52 const Type::TypeInfo Type::_type_info[Type::lastype] = {
  53   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
  54   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
  55   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
  56   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
  57   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
  58   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
  59   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
  60   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
  61   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
  62   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
  63 
  64 #if defined(PPC64)
  65   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  66   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  67   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  68   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  69   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  70 #elif defined(S390)
  71   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  72   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  73   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  74   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  75   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  76 #else // all other
  77   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
  78   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
  79   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  80   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
  81   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  82 #endif

  83   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
  84   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
  85   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
  86   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
  87   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
  88   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
  89   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
  90   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
  91   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
  92   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
  93   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
  94   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
  95   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
  96   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
  97   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
  98   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
  99   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 100   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 101 };
 102 
</pre>
<hr />
<pre>
 193   case ciTypeFlow::StateVector::T_NULL:
 194     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 195     return TypePtr::NULL_PTR;
 196 
 197   case ciTypeFlow::StateVector::T_LONG2:
 198     // The ciTypeFlow pass pushes a long, then the half.
 199     // We do the same.
 200     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 201     return TypeInt::TOP;
 202 
 203   case ciTypeFlow::StateVector::T_DOUBLE2:
 204     // The ciTypeFlow pass pushes double, then the half.
 205     // Our convention is the same.
 206     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 207     return Type::TOP;
 208 
 209   case T_ADDRESS:
 210     assert(type-&gt;is_return_address(), &quot;&quot;);
 211     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 212 










 213   default:
 214     // make sure we did not mix up the cases:
 215     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 216     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 217     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 218     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 219     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 220     assert(!type-&gt;is_return_address(), &quot;&quot;);
 221 
 222     return Type::get_const_type(type);
 223   }
 224 }
 225 
 226 
 227 //-----------------------make_from_constant------------------------------------
 228 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 229                                      int stable_dimension, bool is_narrow_oop,
 230                                      bool is_autobox_cache) {
 231   switch (constant.basic_type()) {
 232     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 233     case T_CHAR:     return TypeInt::make(constant.as_char());
 234     case T_BYTE:     return TypeInt::make(constant.as_byte());
 235     case T_SHORT:    return TypeInt::make(constant.as_short());
 236     case T_INT:      return TypeInt::make(constant.as_int());
 237     case T_LONG:     return TypeLong::make(constant.as_long());
 238     case T_FLOAT:    return TypeF::make(constant.as_float());
 239     case T_DOUBLE:   return TypeD::make(constant.as_double());
 240     case T_ARRAY:

 241     case T_OBJECT: {
 242         const Type* con_type = NULL;
 243         ciObject* oop_constant = constant.as_object();
 244         if (oop_constant-&gt;is_null_object()) {
 245           con_type = Type::get_zero_type(T_OBJECT);
 246         } else {
 247           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 248           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 249           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 250             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 251           }
 252           if (stable_dimension &gt; 0) {
 253             assert(FoldStableValues, &quot;sanity&quot;);
 254             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 255             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 256           }
 257         }
 258         if (is_narrow_oop) {
 259           con_type = con_type-&gt;make_narrowoop();
 260         }
 261         return con_type;
 262       }
 263     case T_ILLEGAL:
 264       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 265       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 266       return NULL;
 267     default:
 268       // Fall through to failure
 269       return NULL;
 270   }
 271 }
 272 
 273 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 274   BasicType conbt = con.basic_type();
 275   switch (conbt) {
 276     case T_BOOLEAN: conbt = T_BYTE;   break;
 277     case T_ARRAY:   conbt = T_OBJECT; break;

 278     default:                          break;
 279   }
 280   switch (loadbt) {
 281     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 282     case T_NARROWOOP: loadbt = T_OBJECT; break;
 283     case T_ARRAY:     loadbt = T_OBJECT; break;

 284     case T_ADDRESS:   loadbt = T_OBJECT; break;
 285     default:                             break;
 286   }
 287   if (conbt == loadbt) {
 288     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 289       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 290       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 291     } else {
 292       return con;
 293     }
 294   }
 295   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 296     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 297     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 298   }
 299   return ciConstant(); // T_ILLEGAL
 300 }
 301 
 302 // Try to constant-fold a stable array element.
 303 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
</pre>
<hr />
<pre>
 491   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 492   ffalse[0] = Type::CONTROL;
 493   ffalse[1] = Type::TOP;
 494   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 495 
 496   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 497   fneither[0] = Type::TOP;
 498   fneither[1] = Type::TOP;
 499   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 500 
 501   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 502   ftrue[0] = Type::TOP;
 503   ftrue[1] = Type::CONTROL;
 504   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 505 
 506   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 507   floop[0] = Type::CONTROL;
 508   floop[1] = TypeInt::INT;
 509   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 510 
<span class="line-modified"> 511   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, 0);</span>
<span class="line-modified"> 512   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, OffsetBot);</span>
<span class="line-modified"> 513   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, OffsetBot);</span>
 514 
 515   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 516   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 517 
 518   const Type **fmembar = TypeTuple::fields(0);
 519   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 520 
 521   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 522   fsc[0] = TypeInt::CC;
 523   fsc[1] = Type::MEMORY;
 524   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 525 
 526   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 527   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 528   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 529   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 530                                            false, 0, oopDesc::mark_offset_in_bytes());</span>
 531   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 532                                            false, 0, oopDesc::klass_offset_in_bytes());</span>
<span class="line-modified"> 533   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, OffsetBot, TypeOopPtr::InstanceBot);</span>


 534 
<span class="line-modified"> 535   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);</span>
 536 
 537   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 538   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 539 
 540   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 541 
 542   mreg2type[Op_Node] = Type::BOTTOM;
 543   mreg2type[Op_Set ] = 0;
 544   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 545   mreg2type[Op_RegI] = TypeInt::INT;
 546   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 547   mreg2type[Op_RegF] = Type::FLOAT;
 548   mreg2type[Op_RegD] = Type::DOUBLE;
 549   mreg2type[Op_RegL] = TypeLong::LONG;
 550   mreg2type[Op_RegFlags] = TypeInt::CC;
 551 
<span class="line-modified"> 552   TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, arrayOopDesc::length_offset_in_bytes());</span>
 553 
<span class="line-modified"> 554   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);</span>
 555 
 556 #ifdef _LP64
 557   if (UseCompressedOops) {
 558     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 559     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 560   } else
 561 #endif
 562   {
 563     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
<span class="line-modified"> 564     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);</span>
 565   }
<span class="line-modified"> 566   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Type::OffsetBot);</span>
<span class="line-modified"> 567   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Type::OffsetBot);</span>
<span class="line-modified"> 568   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Type::OffsetBot);</span>
<span class="line-modified"> 569   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Type::OffsetBot);</span>
<span class="line-modified"> 570   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Type::OffsetBot);</span>
<span class="line-modified"> 571   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Type::OffsetBot);</span>
<span class="line-modified"> 572   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Type::OffsetBot);</span>

 573 
 574   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 575   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 576   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;

 577   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 578   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 579   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 580   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 581   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 582   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 583   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 584   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 585   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 586 
<span class="line-modified"> 587   TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), 0 );</span>
<span class="line-modified"> 588   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), 0 );</span>
 589 
 590   const Type **fi2c = TypeTuple::fields(2);
 591   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 592   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 593   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 594 
 595   const Type **intpair = TypeTuple::fields(2);
 596   intpair[0] = TypeInt::INT;
 597   intpair[1] = TypeInt::INT;
 598   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 599 
 600   const Type **longpair = TypeTuple::fields(2);
 601   longpair[0] = TypeLong::LONG;
 602   longpair[1] = TypeLong::LONG;
 603   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 604 
 605   const Type **intccpair = TypeTuple::fields(2);
 606   intccpair[0] = TypeInt::INT;
 607   intccpair[1] = TypeInt::CC;
 608   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 609 
 610   const Type **longccpair = TypeTuple::fields(2);
 611   longccpair[0] = TypeLong::LONG;
 612   longccpair[1] = TypeInt::CC;
 613   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 614 
 615   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 616   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 617   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 618   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 619   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 620   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 621   _const_basic_type[T_INT]         = TypeInt::INT;
 622   _const_basic_type[T_LONG]        = TypeLong::LONG;
 623   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 624   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 625   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 626   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays

 627   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 628   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 629   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 630 
 631   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 632   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 633   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 634   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 635   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 636   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 637   _zero_type[T_INT]         = TypeInt::ZERO;
 638   _zero_type[T_LONG]        = TypeLong::ZERO;
 639   _zero_type[T_FLOAT]       = TypeF::ZERO;
 640   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 641   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 642   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop

 643   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 644   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 645 
 646   // get_zero_type() should not happen for T_CONFLICT
 647   _zero_type[T_CONFLICT]= NULL;
 648 
 649   // Vector predefined types, it needs initialized _const_basic_type[].
 650   if (Matcher::vector_size_supported(T_BYTE,4)) {
 651     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 652   }
 653   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 654     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 655   }
 656   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 657     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 658   }
 659   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 660     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 661   }
 662   if (Matcher::vector_size_supported(T_FLOAT,16)) {
</pre>
<hr />
<pre>
 798   }
 799   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 800     return true;
 801   }
 802   return false;
 803 }
 804 
 805 #endif
 806 
 807 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 808 #ifdef ASSERT
 809   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 810   const Type* dual_join = mt-&gt;_dual;
 811   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 812   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 813 
 814   // Interface meet Oop is Not Symmetric:
 815   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 816   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 817 
<span class="line-modified"> 818   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual) ) {</span>
 819     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 820     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 821     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 822     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 823 
 824     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 825     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 826     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 827 
 828     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 829     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 830 
 831     fatal(&quot;meet not symmetric&quot; );
 832   }
 833 #endif
 834 }
 835 
 836 //------------------------------meet-------------------------------------------
 837 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 838 // commutative and the lattice is symmetric.
</pre>
<hr />
<pre>
 902 
 903   case OopPtr:
 904     return t-&gt;xmeet(this);
 905 
 906   case InstPtr:
 907     return t-&gt;xmeet(this);
 908 
 909   case MetadataPtr:
 910   case KlassPtr:
 911     return t-&gt;xmeet(this);
 912 
 913   case AryPtr:
 914     return t-&gt;xmeet(this);
 915 
 916   case NarrowOop:
 917     return t-&gt;xmeet(this);
 918 
 919   case NarrowKlass:
 920     return t-&gt;xmeet(this);
 921 



 922   case Bad:                     // Type check
 923   default:                      // Bogus type not in lattice
 924     typerr(t);
 925     return Type::BOTTOM;
 926 
 927   case Bottom:                  // Ye Olde Default
 928     return t;
 929 
 930   case FloatTop:
 931     if( _base == FloatTop ) return this;
 932   case FloatBot:                // Float
 933     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
 934     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
 935     typerr(t);
 936     return Type::BOTTOM;
 937 
 938   case DoubleTop:
 939     if( _base == DoubleTop ) return this;
 940   case DoubleBot:               // Double
 941     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
</pre>
<hr />
<pre>
 969 
 970 //------------------------------xdual------------------------------------------
 971 // Compute dual right now.
 972 const Type::TYPES Type::dual_type[Type::lastype] = {
 973   Bad,          // Bad
 974   Control,      // Control
 975   Bottom,       // Top
 976   Bad,          // Int - handled in v-call
 977   Bad,          // Long - handled in v-call
 978   Half,         // Half
 979   Bad,          // NarrowOop - handled in v-call
 980   Bad,          // NarrowKlass - handled in v-call
 981 
 982   Bad,          // Tuple - handled in v-call
 983   Bad,          // Array - handled in v-call
 984   Bad,          // VectorS - handled in v-call
 985   Bad,          // VectorD - handled in v-call
 986   Bad,          // VectorX - handled in v-call
 987   Bad,          // VectorY - handled in v-call
 988   Bad,          // VectorZ - handled in v-call

 989 
 990   Bad,          // AnyPtr - handled in v-call
 991   Bad,          // RawPtr - handled in v-call
 992   Bad,          // OopPtr - handled in v-call
 993   Bad,          // InstPtr - handled in v-call
 994   Bad,          // AryPtr - handled in v-call
 995 
 996   Bad,          //  MetadataPtr - handled in v-call
 997   Bad,          // KlassPtr - handled in v-call
 998 
 999   Bad,          // Function - handled in v-call
1000   Abio,         // Abio
1001   Return_Address,// Return_Address
1002   Memory,       // Memory
1003   FloatBot,     // FloatTop
1004   FloatCon,     // FloatCon
1005   FloatTop,     // FloatBot
1006   DoubleBot,    // DoubleTop
1007   DoubleCon,    // DoubleCon
1008   DoubleTop,    // DoubleBot
</pre>
<hr />
<pre>
1864 
1865 bool TypeLong::empty(void) const {
1866   return _lo &gt; _hi;
1867 }
1868 
1869 //=============================================================================
1870 // Convenience common pre-built types.
1871 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1872 const TypeTuple *TypeTuple::IFFALSE;
1873 const TypeTuple *TypeTuple::IFTRUE;
1874 const TypeTuple *TypeTuple::IFNEITHER;
1875 const TypeTuple *TypeTuple::LOOPBODY;
1876 const TypeTuple *TypeTuple::MEMBAR;
1877 const TypeTuple *TypeTuple::STORECONDITIONAL;
1878 const TypeTuple *TypeTuple::START_I2C;
1879 const TypeTuple *TypeTuple::INT_PAIR;
1880 const TypeTuple *TypeTuple::LONG_PAIR;
1881 const TypeTuple *TypeTuple::INT_CC_PAIR;
1882 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1883 


















1884 
1885 //------------------------------make-------------------------------------------
1886 // Make a TypeTuple from the range of a method signature
<span class="line-modified">1887 const TypeTuple *TypeTuple::make_range(ciSignature* sig) {</span>
1888   ciType* return_type = sig-&gt;return_type();
1889   uint arg_cnt = return_type-&gt;size();




1890   const Type **field_array = fields(arg_cnt);
1891   switch (return_type-&gt;basic_type()) {
1892   case T_LONG:
1893     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1894     field_array[TypeFunc::Parms+1] = Type::HALF;
1895     break;
1896   case T_DOUBLE:
1897     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1898     field_array[TypeFunc::Parms+1] = Type::HALF;
1899     break;
1900   case T_OBJECT:
1901   case T_ARRAY:
1902   case T_BOOLEAN:
1903   case T_CHAR:
1904   case T_FLOAT:
1905   case T_BYTE:
1906   case T_SHORT:
1907   case T_INT:
1908     field_array[TypeFunc::Parms] = get_const_type(return_type);
1909     break;











1910   case T_VOID:
1911     break;
1912   default:
1913     ShouldNotReachHere();
1914   }
1915   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1916 }
1917 
1918 // Make a TypeTuple from the domain of a method signature
<span class="line-modified">1919 const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {</span>
<span class="line-modified">1920   uint arg_cnt = sig-&gt;size();</span>









1921 
1922   uint pos = TypeFunc::Parms;
<span class="line-modified">1923   const Type **field_array;</span>
<span class="line-modified">1924   if (recv != NULL) {</span>
<span class="line-modified">1925     arg_cnt++;</span>
<span class="line-modified">1926     field_array = fields(arg_cnt);</span>
<span class="line-modified">1927     // Use get_const_type here because it respects UseUniqueSubclasses:</span>
<span class="line-modified">1928     field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="line-modified">1929   } else {</span>
<span class="line-modified">1930     field_array = fields(arg_cnt);</span>



1931   }
1932 
1933   int i = 0;
1934   while (pos &lt; TypeFunc::Parms + arg_cnt) {
1935     ciType* type = sig-&gt;type_at(i);


1936 
<span class="line-modified">1937     switch (type-&gt;basic_type()) {</span>
1938     case T_LONG:
1939       field_array[pos++] = TypeLong::LONG;
1940       field_array[pos++] = Type::HALF;
1941       break;
1942     case T_DOUBLE:
1943       field_array[pos++] = Type::DOUBLE;
1944       field_array[pos++] = Type::HALF;
1945       break;
1946     case T_OBJECT:
1947     case T_ARRAY:
1948     case T_FLOAT:
1949     case T_INT:
1950       field_array[pos++] = get_const_type(type);
1951       break;
1952     case T_BOOLEAN:
1953     case T_CHAR:
1954     case T_BYTE:
1955     case T_SHORT:
1956       field_array[pos++] = TypeInt::INT;
1957       break;










1958     default:
1959       ShouldNotReachHere();
1960     }







1961     i++;
1962   }

1963 
1964   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1965 }
1966 
1967 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
1968   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
1969 }
1970 
1971 //------------------------------fields-----------------------------------------
1972 // Subroutine call type with space allocated for argument types
1973 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
1974 const Type **TypeTuple::fields( uint arg_cnt ) {
1975   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
1976   flds[TypeFunc::Control  ] = Type::CONTROL;
1977   flds[TypeFunc::I_O      ] = Type::ABIO;
1978   flds[TypeFunc::Memory   ] = Type::MEMORY;
1979   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
1980   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
1981 
1982   return flds;
</pre>
<hr />
<pre>
2077     if (_fields[i]-&gt;empty())  return true;
2078   }
2079   return false;
2080 }
2081 
2082 //=============================================================================
2083 // Convenience common pre-built types.
2084 
2085 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2086   // Certain normalizations keep us sane when comparing types.
2087   // We do not want arrayOop variables to differ only by the wideness
2088   // of their index types.  Pick minimum wideness, since that is the
2089   // forced wideness of small ranges anyway.
2090   if (size-&gt;_widen != Type::WidenMin)
2091     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2092   else
2093     return size;
2094 }
2095 
2096 //------------------------------make-------------------------------------------
<span class="line-modified">2097 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable) {</span>

2098   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2099     elem = elem-&gt;make_narrowoop();
2100   }
2101   size = normalize_array_size(size);
<span class="line-modified">2102   return (TypeAry*)(new TypeAry(elem,size,stable))-&gt;hashcons();</span>
2103 }
2104 
2105 //------------------------------meet-------------------------------------------
2106 // Compute the MEET of two types.  It returns a new Type object.
2107 const Type *TypeAry::xmeet( const Type *t ) const {
2108   // Perform a fast test for common case; meeting the same types together.
2109   if( this == t ) return this;  // Meeting same type-rep?
2110 
2111   // Current &quot;this-&gt;_base&quot; is Ary
2112   switch (t-&gt;base()) {          // switch on original type
2113 
2114   case Bottom:                  // Ye Olde Default
2115     return t;
2116 
2117   default:                      // All else is a mistake
2118     typerr(t);
2119 
2120   case Array: {                 // Meeting 2 arrays?
2121     const TypeAry *a = t-&gt;is_ary();
2122     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2123                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
<span class="line-modified">2124                          _stable &amp;&amp; a-&gt;_stable);</span>


2125   }
2126   case Top:
2127     break;
2128   }
2129   return this;                  // Return the double constant
2130 }
2131 
2132 //------------------------------xdual------------------------------------------
2133 // Dual: compute field-by-field dual
2134 const Type *TypeAry::xdual() const {
2135   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2136   size_dual = normalize_array_size(size_dual);
<span class="line-modified">2137   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);</span>
2138 }
2139 
2140 //------------------------------eq---------------------------------------------
2141 // Structural equality check for Type representations
2142 bool TypeAry::eq( const Type *t ) const {
2143   const TypeAry *a = (const TypeAry*)t;
2144   return _elem == a-&gt;_elem &amp;&amp;
2145     _stable == a-&gt;_stable &amp;&amp;
<span class="line-modified">2146     _size == a-&gt;_size;</span>



2147 }
2148 
2149 //------------------------------hash-------------------------------------------
2150 // Type-specific hashing function.
2151 int TypeAry::hash(void) const {
2152   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2153 }
2154 
2155 /**
2156  * Return same type without a speculative part in the element
2157  */
2158 const Type* TypeAry::remove_speculative() const {
<span class="line-modified">2159   return make(_elem-&gt;remove_speculative(), _size, _stable);</span>
2160 }
2161 
2162 /**
2163  * Return same type with cleaned up speculative part of element
2164  */
2165 const Type* TypeAry::cleanup_speculative() const {
<span class="line-modified">2166   return make(_elem-&gt;cleanup_speculative(), _size, _stable);</span>
2167 }
2168 
2169 /**
2170  * Return same type but with a different inline depth (used for speculation)
2171  *
2172  * @param depth  depth to meet with
2173  */
2174 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2175   if (!UseInlineDepthForSpeculativeTypes) {
2176     return this;
2177   }
2178   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2179 }
2180 
2181 //----------------------interface_vs_oop---------------------------------------
2182 #ifdef ASSERT
2183 bool TypeAry::interface_vs_oop(const Type *t) const {
2184   const TypeAry* t_ary = t-&gt;is_ary();
2185   if (t_ary) {
2186     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2187     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2188     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2189       return this_ptr-&gt;interface_vs_oop(t_ptr);
2190     }
2191   }
2192   return false;
2193 }
2194 #endif
2195 
2196 //------------------------------dump2------------------------------------------
2197 #ifndef PRODUCT
2198 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2199   if (_stable)  st-&gt;print(&quot;stable:&quot;);




2200   _elem-&gt;dump2(d, depth, st);
2201   st-&gt;print(&quot;[&quot;);
2202   _size-&gt;dump2(d, depth, st);
2203   st-&gt;print(&quot;]&quot;);
2204 }
2205 #endif
2206 
2207 //------------------------------singleton--------------------------------------
2208 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2209 // constants (Ldi nodes).  Singletons are integer, float or double constants
2210 // or a single symbol.
2211 bool TypeAry::singleton(void) const {
2212   return false;                 // Never a singleton
2213 }
2214 
2215 bool TypeAry::empty(void) const {
2216   return _elem-&gt;empty() || _size-&gt;empty();
2217 }
2218 
2219 //--------------------------ary_must_be_exact----------------------------------
</pre>
<hr />
<pre>
2234   ciKlass* tklass = toop-&gt;klass();
2235   if (tklass == NULL)       return false;  // unloaded class
2236   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2237   const TypeInstPtr* tinst;
2238   if (_elem-&gt;isa_narrowoop())
2239     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2240   else
2241     tinst = _elem-&gt;isa_instptr();
2242   if (tinst)
2243     return tklass-&gt;as_instance_klass()-&gt;is_final();
2244   const TypeAryPtr*  tap;
2245   if (_elem-&gt;isa_narrowoop())
2246     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2247   else
2248     tap = _elem-&gt;isa_aryptr();
2249   if (tap)
2250     return tap-&gt;ary()-&gt;ary_must_be_exact();
2251   return false;
2252 }
2253 




























































































































2254 //==============================TypeVect=======================================
2255 // Convenience common pre-built types.
2256 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2257 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2258 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2259 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2260 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2261 
2262 //------------------------------make-------------------------------------------
2263 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2264   BasicType elem_bt = elem-&gt;array_element_basic_type();
2265   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2266   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2267   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2268   int size = length * type2aelembytes(elem_bt);
2269   switch (Matcher::vector_ideal_reg(size)) {
2270   case Op_VecS:
2271     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2272   case Op_RegL:
2273   case Op_VecD:
</pre>
<hr />
<pre>
2375 
2376 //=============================================================================
2377 // Convenience common pre-built types.
2378 const TypePtr *TypePtr::NULL_PTR;
2379 const TypePtr *TypePtr::NOTNULL;
2380 const TypePtr *TypePtr::BOTTOM;
2381 
2382 //------------------------------meet-------------------------------------------
2383 // Meet over the PTR enum
2384 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2385   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2386   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2387   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2388   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2389   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2390   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2391   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2392 };
2393 
2394 //------------------------------make-------------------------------------------
<span class="line-modified">2395 const TypePtr *TypePtr::make(TYPES t, enum PTR ptr, int offset, const TypePtr* speculative, int inline_depth) {</span>
2396   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2397 }
2398 
2399 //------------------------------cast_to_ptr_type-------------------------------
2400 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2401   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2402   if( ptr == _ptr ) return this;
2403   return make(_base, ptr, _offset, _speculative, _inline_depth);
2404 }
2405 
2406 //------------------------------get_con----------------------------------------
2407 intptr_t TypePtr::get_con() const {
2408   assert( _ptr == Null, &quot;&quot; );
<span class="line-modified">2409   return _offset;</span>
2410 }
2411 
2412 //------------------------------meet-------------------------------------------
2413 // Compute the MEET of two types.  It returns a new Type object.
2414 const Type *TypePtr::xmeet(const Type *t) const {
2415   const Type* res = xmeet_helper(t);
2416   if (res-&gt;isa_ptr() == NULL) {
2417     return res;
2418   }
2419 
2420   const TypePtr* res_ptr = res-&gt;is_ptr();
2421   if (res_ptr-&gt;speculative() != NULL) {
2422     // type-&gt;speculative() == NULL means that speculation is no better
2423     // than type, i.e. type-&gt;speculative() == type. So there are 2
2424     // ways to represent the fact that we have no useful speculative
2425     // data and we should use a single one to be able to test for
2426     // equality between types. Check whether type-&gt;speculative() ==
2427     // type and set speculative to NULL if it is the case.
2428     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2429       return res_ptr-&gt;remove_speculative();
</pre>
<hr />
<pre>
2458     const TypePtr *tp = t-&gt;is_ptr();
2459     const TypePtr* speculative = xmeet_speculative(tp);
2460     int depth = meet_inline_depth(tp-&gt;inline_depth());
2461     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2462   }
2463   case RawPtr:                  // For these, flip the call around to cut down
2464   case OopPtr:
2465   case InstPtr:                 // on the cases I have to handle.
2466   case AryPtr:
2467   case MetadataPtr:
2468   case KlassPtr:
2469     return t-&gt;xmeet(this);      // Call in reverse direction
2470   default:                      // All else is a mistake
2471     typerr(t);
2472 
2473   }
2474   return this;
2475 }
2476 
2477 //------------------------------meet_offset------------------------------------
<span class="line-modified">2478 int TypePtr::meet_offset( int offset ) const {</span>
<span class="line-modified">2479   // Either is &#39;TOP&#39; offset?  Return the other offset!</span>
<span class="line-removed">2480   if( _offset == OffsetTop ) return offset;</span>
<span class="line-removed">2481   if( offset == OffsetTop ) return _offset;</span>
<span class="line-removed">2482   // If either is different, return &#39;BOTTOM&#39; offset</span>
<span class="line-removed">2483   if( _offset != offset ) return OffsetBot;</span>
<span class="line-removed">2484   return _offset;</span>
2485 }
2486 
2487 //------------------------------dual_offset------------------------------------
<span class="line-modified">2488 int TypePtr::dual_offset( ) const {</span>
<span class="line-modified">2489   if( _offset == OffsetTop ) return OffsetBot;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;</span>
<span class="line-removed">2490   if( _offset == OffsetBot ) return OffsetTop;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;</span>
<span class="line-removed">2491   return _offset;               // Map everything else into self</span>
2492 }
2493 
2494 //------------------------------xdual------------------------------------------
2495 // Dual: compute field-by-field dual
2496 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2497   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2498 };
2499 const Type *TypePtr::xdual() const {
2500   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2501 }
2502 
2503 //------------------------------xadd_offset------------------------------------
<span class="line-modified">2504 int TypePtr::xadd_offset( intptr_t offset ) const {</span>
<span class="line-modified">2505   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!</span>
<span class="line-removed">2506   if( _offset == OffsetTop || offset == OffsetTop ) return OffsetTop;</span>
<span class="line-removed">2507   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!</span>
<span class="line-removed">2508   if( _offset == OffsetBot || offset == OffsetBot ) return OffsetBot;</span>
<span class="line-removed">2509   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!</span>
<span class="line-removed">2510   offset += (intptr_t)_offset;</span>
<span class="line-removed">2511   if (offset != (int)offset || offset == OffsetTop) return OffsetBot;</span>
<span class="line-removed">2512 </span>
<span class="line-removed">2513   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );</span>
<span class="line-removed">2514   // It is possible to construct a negative offset during PhaseCCP</span>
<span class="line-removed">2515 </span>
<span class="line-removed">2516   return (int)offset;        // Sum valid offsets</span>
2517 }
2518 
2519 //------------------------------add_offset-------------------------------------
2520 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2521   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2522 }
2523 
2524 //------------------------------eq---------------------------------------------
2525 // Structural equality check for Type representations
2526 bool TypePtr::eq( const Type *t ) const {
2527   const TypePtr *a = (const TypePtr*)t;
<span class="line-modified">2528   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;offset() &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;</span>
2529 }
2530 
2531 //------------------------------hash-------------------------------------------
2532 // Type-specific hashing function.
2533 int TypePtr::hash(void) const {
<span class="line-modified">2534   return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));</span>
2535 ;
2536 }
2537 
2538 /**
2539  * Return same type without a speculative part
2540  */
2541 const Type* TypePtr::remove_speculative() const {
2542   if (_speculative == NULL) {
2543     return this;
2544   }
2545   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2546   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2547 }
2548 
2549 /**
2550  * Return same type but drop speculative part if we know we won&#39;t use
2551  * it
2552  */
2553 const Type* TypePtr::cleanup_speculative() const {
2554   if (speculative() == NULL) {
</pre>
<hr />
<pre>
2774   }
2775   // We already know the speculative type is always null
2776   if (speculative_always_null()) {
2777     return false;
2778   }
2779   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
2780     return false;
2781   }
2782   return true;
2783 }
2784 
2785 //------------------------------dump2------------------------------------------
2786 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
2787   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
2788 };
2789 
2790 #ifndef PRODUCT
2791 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2792   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
2793   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
<span class="line-modified">2794   if( _offset == OffsetTop ) st-&gt;print(&quot;+top&quot;);</span>
<span class="line-removed">2795   else if( _offset == OffsetBot ) st-&gt;print(&quot;+bot&quot;);</span>
<span class="line-removed">2796   else if( _offset ) st-&gt;print(&quot;+%d&quot;, _offset);</span>
2797   dump_inline_depth(st);
2798   dump_speculative(st);
2799 }
2800 
2801 /**
2802  *dump the speculative part of the type
2803  */
2804 void TypePtr::dump_speculative(outputStream *st) const {
2805   if (_speculative != NULL) {
2806     st-&gt;print(&quot; (speculative=&quot;);
2807     _speculative-&gt;dump_on(st);
2808     st-&gt;print(&quot;)&quot;);
2809   }
2810 }
2811 
2812 /**
2813  *dump the inline depth of the type
2814  */
2815 void TypePtr::dump_inline_depth(outputStream *st) const {
2816   if (_inline_depth != InlineDepthBottom) {
2817     if (_inline_depth == InlineDepthTop) {
2818       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
2819     } else {
2820       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
2821     }
2822   }
2823 }
2824 #endif
2825 
2826 //------------------------------singleton--------------------------------------
2827 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2828 // constants
2829 bool TypePtr::singleton(void) const {
2830   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">2831   return (_offset != OffsetBot) &amp;&amp; !below_centerline(_ptr);</span>
2832 }
2833 
2834 bool TypePtr::empty(void) const {
<span class="line-modified">2835   return (_offset == OffsetTop) || above_centerline(_ptr);</span>
2836 }
2837 
2838 //=============================================================================
2839 // Convenience common pre-built types.
2840 const TypeRawPtr *TypeRawPtr::BOTTOM;
2841 const TypeRawPtr *TypeRawPtr::NOTNULL;
2842 
2843 //------------------------------make-------------------------------------------
2844 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
2845   assert( ptr != Constant, &quot;what is the constant?&quot; );
2846   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2847   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
2848 }
2849 
2850 const TypeRawPtr *TypeRawPtr::make( address bits ) {
2851   assert( bits, &quot;Use TypePtr for NULL&quot; );
2852   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
2853 }
2854 
2855 //------------------------------cast_to_ptr_type-------------------------------
</pre>
<hr />
<pre>
2957 // Type-specific hashing function.
2958 int TypeRawPtr::hash(void) const {
2959   return (intptr_t)_bits + TypePtr::hash();
2960 }
2961 
2962 //------------------------------dump2------------------------------------------
2963 #ifndef PRODUCT
2964 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2965   if( _ptr == Constant )
2966     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
2967   else
2968     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
2969 }
2970 #endif
2971 
2972 //=============================================================================
2973 // Convenience common pre-built type.
2974 const TypeOopPtr *TypeOopPtr::BOTTOM;
2975 
2976 //------------------------------TypeOopPtr-------------------------------------
<span class="line-modified">2977 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,</span>
2978                        int instance_id, const TypePtr* speculative, int inline_depth)
2979   : TypePtr(t, ptr, offset, speculative, inline_depth),
2980     _const_oop(o), _klass(k),
2981     _klass_is_exact(xk),
2982     _is_ptr_to_narrowoop(false),
2983     _is_ptr_to_narrowklass(false),
2984     _is_ptr_to_boxed_value(false),
2985     _instance_id(instance_id) {
2986   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
<span class="line-modified">2987       (offset &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="line-modified">2988     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset);</span>
2989   }
2990 #ifdef _LP64
<span class="line-modified">2991   if (_offset &gt; 0 || _offset == Type::OffsetTop || _offset == Type::OffsetBot) {</span>
<span class="line-modified">2992     if (_offset == oopDesc::klass_offset_in_bytes()) {</span>
2993       _is_ptr_to_narrowklass = UseCompressedClassPointers;
2994     } else if (klass() == NULL) {
2995       // Array with unknown body type
2996       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
2997       _is_ptr_to_narrowoop = UseCompressedOops;
<span class="line-modified">2998     } else if (this-&gt;isa_aryptr()) {</span>
<span class="line-modified">2999       _is_ptr_to_narrowoop = (UseCompressedOops &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp;</span>
<span class="line-modified">3000                              _offset != arrayOopDesc::length_offset_in_bytes());</span>









3001     } else if (klass()-&gt;is_instance_klass()) {
<span class="line-removed">3002       ciInstanceKlass* ik = klass()-&gt;as_instance_klass();</span>
<span class="line-removed">3003       ciField* field = NULL;</span>
3004       if (this-&gt;isa_klassptr()) {
3005         // Perm objects don&#39;t use compressed references
<span class="line-modified">3006       } else if (_offset == OffsetBot || _offset == OffsetTop) {</span>
3007         // unsafe access
3008         _is_ptr_to_narrowoop = UseCompressedOops;
3009       } else { // exclude unsafe ops
3010         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
<span class="line-modified">3011 </span>
<span class="line-modified">3012         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="line-removed">3013             (_offset == java_lang_Class::klass_offset() ||</span>
3014              _offset == java_lang_Class::array_klass_offset())) {
3015           // Special hidden fields from the Class.
3016           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3017           _is_ptr_to_narrowoop = false;
3018         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
<span class="line-modified">3019                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {</span>
3020           // Static fields
3021           assert(o != NULL, &quot;must be constant&quot;);
<span class="line-modified">3022           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="line-modified">3023           ciField* field = k-&gt;get_field_by_offset(_offset, true);</span>
<span class="line-modified">3024           assert(field != NULL, &quot;missing field&quot;);</span>
<span class="line-modified">3025           BasicType basic_elem_type = field-&gt;layout_type();</span>






3026           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3027         } else {
3028           // Instance fields which contains a compressed oop references.
<span class="line-modified">3029           field = ik-&gt;get_field_by_offset(_offset, false);</span>

3030           if (field != NULL) {
3031             BasicType basic_elem_type = field-&gt;layout_type();
3032             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3033           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3034             // Compile::find_alias_type() cast exactness on all types to verify
3035             // that it does not affect alias type.
3036             _is_ptr_to_narrowoop = UseCompressedOops;
3037           } else {
3038             // Type for the copy start in LibraryCallKit::inline_native_clone().
3039             _is_ptr_to_narrowoop = UseCompressedOops;
3040           }
3041         }
3042       }
3043     }
3044   }
3045 #endif
3046 }
3047 
3048 //------------------------------make-------------------------------------------
<span class="line-modified">3049 const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,</span>
<span class="line-modified">3050                                      const TypePtr* speculative, int inline_depth) {</span>
3051   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3052   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3053   bool      xk = false;
3054   ciObject* o = NULL;
<span class="line-modified">3055   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3056 }
3057 
3058 
3059 //------------------------------cast_to_ptr_type-------------------------------
3060 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3061   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3062   if( ptr == _ptr ) return this;
3063   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3064 }
3065 
3066 //-----------------------------cast_to_instance_id----------------------------
3067 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3068   // There are no instances of a general oop.
3069   // Return self unchanged.
3070   return this;
3071 }
3072 
3073 //-----------------------------cast_to_exactness-------------------------------
3074 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3075   // There is no such thing as an exact general oop.
3076   // Return self unchanged.
3077   return this;
3078 }
3079 
3080 
3081 //------------------------------as_klass_type----------------------------------
3082 // Return the klass type corresponding to this instance or array type.
3083 // It is the type that is loaded from an object of this type.
3084 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3085   ciKlass* k = klass();
3086   bool    xk = klass_is_exact();
3087   if (k == NULL)
3088     return TypeKlassPtr::OBJECT;
3089   else
<span class="line-modified">3090     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);</span>
3091 }
3092 
3093 //------------------------------meet-------------------------------------------
3094 // Compute the MEET of two types.  It returns a new Type object.
3095 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3096   // Perform a fast test for common case; meeting the same types together.
3097   if( this == t ) return this;  // Meeting same type-rep?
3098 
3099   // Current &quot;this-&gt;_base&quot; is OopPtr
3100   switch (t-&gt;base()) {          // switch on original type
3101 
3102   case Int:                     // Mixing ints &amp; oops happens when javac
3103   case Long:                    // reuses local variables
3104   case FloatTop:
3105   case FloatCon:
3106   case FloatBot:
3107   case DoubleTop:
3108   case DoubleCon:
3109   case DoubleBot:
3110   case NarrowOop:
3111   case NarrowKlass:
3112   case Bottom:                  // Ye Olde Default
3113     return Type::BOTTOM;
3114   case Top:
3115     return this;
3116 
3117   default:                      // All else is a mistake
3118     typerr(t);
3119 
3120   case RawPtr:
3121   case MetadataPtr:
3122   case KlassPtr:
3123     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3124 
3125   case AnyPtr: {
3126     // Found an AnyPtr type vs self-OopPtr type
3127     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">3128     int offset = meet_offset(tp-&gt;offset());</span>
3129     PTR ptr = meet_ptr(tp-&gt;ptr());
3130     const TypePtr* speculative = xmeet_speculative(tp);
3131     int depth = meet_inline_depth(tp-&gt;inline_depth());
3132     switch (tp-&gt;ptr()) {
3133     case Null:
3134       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3135       // else fall through:
3136     case TopPTR:
3137     case AnyNull: {
3138       int instance_id = meet_instance_id(InstanceTop);
3139       return make(ptr, offset, instance_id, speculative, depth);
3140     }
3141     case BotPTR:
3142     case NotNull:
3143       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3144     default: typerr(t);
3145     }
3146   }
3147 
3148   case OopPtr: {                 // Meeting to other OopPtrs
</pre>
<hr />
<pre>
3150     int instance_id = meet_instance_id(tp-&gt;instance_id());
3151     const TypePtr* speculative = xmeet_speculative(tp);
3152     int depth = meet_inline_depth(tp-&gt;inline_depth());
3153     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3154   }
3155 
3156   case InstPtr:                  // For these, flip the call around to cut down
3157   case AryPtr:
3158     return t-&gt;xmeet(this);      // Call in reverse direction
3159 
3160   } // End of switch
3161   return this;                  // Return the double constant
3162 }
3163 
3164 
3165 //------------------------------xdual------------------------------------------
3166 // Dual of a pure heap pointer.  No relevant klass or oop information.
3167 const Type *TypeOopPtr::xdual() const {
3168   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3169   assert(const_oop() == NULL,             &quot;no constants here&quot;);
<span class="line-modified">3170   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
3171 }
3172 
3173 //--------------------------make_from_klass_common-----------------------------
3174 // Computes the element-type given a klass.
3175 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
<span class="line-modified">3176   if (klass-&gt;is_instance_klass()) {</span>
3177     Compile* C = Compile::current();
3178     Dependencies* deps = C-&gt;dependencies();
3179     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3180     // Element is an instance
3181     bool klass_is_exact = false;
3182     if (klass-&gt;is_loaded()) {
3183       // Try to set klass_is_exact.
3184       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3185       klass_is_exact = ik-&gt;is_final();
3186       if (!klass_is_exact &amp;&amp; klass_change
3187           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3188         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3189         if (sub != NULL) {
3190           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3191           klass = ik = sub;
3192           klass_is_exact = sub-&gt;is_final();
3193         }
3194       }
3195       if (!klass_is_exact &amp;&amp; try_for_exact
3196           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3197         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3198           // Add a dependence; if concrete subclass added we need to recompile
3199           deps-&gt;assert_leaf_type(ik);
3200           klass_is_exact = true;
3201         }
3202       }
3203     }
<span class="line-modified">3204     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);</span>
3205   } else if (klass-&gt;is_obj_array_klass()) {
<span class="line-modified">3206     // Element is an object array. Recursively call ourself.</span>
<span class="line-modified">3207     const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_obj_array_klass()-&gt;element_klass(), false, try_for_exact);</span>












3208     bool xk = etype-&gt;klass_is_exact();
<span class="line-modified">3209     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);</span>
3210     // We used to pass NotNull in here, asserting that the sub-arrays
3211     // are all not-null.  This is not true in generally, as code can
3212     // slam NULLs down in the subarrays.
<span class="line-modified">3213     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);</span>
3214     return arr;
3215   } else if (klass-&gt;is_type_array_klass()) {
3216     // Element is an typeArray
3217     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
<span class="line-modified">3218     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);</span>

3219     // We used to pass NotNull in here, asserting that the array pointer
3220     // is not-null. That was not true in general.
<span class="line-modified">3221     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, 0);</span>





3222     return arr;
3223   } else {
3224     ShouldNotReachHere();
3225     return NULL;
3226   }
3227 }
3228 
3229 //------------------------------make_from_constant-----------------------------
3230 // Make a java pointer from an oop constant
3231 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3232   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3233 
3234   const bool make_constant = require_constant || o-&gt;should_be_constant();
3235 
3236   ciKlass* klass = o-&gt;klass();
<span class="line-modified">3237   if (klass-&gt;is_instance_klass()) {</span>
<span class="line-modified">3238     // Element is an instance</span>
3239     if (make_constant) {
3240       return TypeInstPtr::make(o);
3241     } else {
<span class="line-modified">3242       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);</span>
3243     }
3244   } else if (klass-&gt;is_obj_array_klass()) {
3245     // Element is an object array. Recursively call ourself.
<span class="line-modified">3246     const TypeOopPtr *etype =</span>
<span class="line-modified">3247       TypeOopPtr::make_from_klass_raw(klass-&gt;as_obj_array_klass()-&gt;element_klass());</span>
<span class="line-modified">3248     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));</span>





3249     // We used to pass NotNull in here, asserting that the sub-arrays
3250     // are all not-null.  This is not true in generally, as code can
3251     // slam NULLs down in the subarrays.
3252     if (make_constant) {
<span class="line-modified">3253       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);</span>
3254     } else {
<span class="line-modified">3255       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);</span>
3256     }
3257   } else if (klass-&gt;is_type_array_klass()) {
3258     // Element is an typeArray
<span class="line-modified">3259     const Type* etype =</span>
<span class="line-modified">3260       (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());</span>
<span class="line-modified">3261     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
3262     // We used to pass NotNull in here, asserting that the array pointer
3263     // is not-null. That was not true in general.
3264     if (make_constant) {
<span class="line-modified">3265       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);</span>











3266     } else {
<span class="line-modified">3267       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);</span>
3268     }
3269   }
3270 
3271   fatal(&quot;unhandled object type&quot;);
3272   return NULL;
3273 }
3274 
3275 //------------------------------get_con----------------------------------------
3276 intptr_t TypeOopPtr::get_con() const {
3277   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">3278   assert( _offset &gt;= 0, &quot;&quot; );</span>
3279 
<span class="line-modified">3280   if (_offset != 0) {</span>
3281     // After being ported to the compiler interface, the compiler no longer
3282     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3283     // to a handle at compile time.  This handle is embedded in the generated
3284     // code and dereferenced at the time the nmethod is made.  Until that time,
3285     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3286     // have access to the addresses!).  This does not seem to currently happen,
3287     // but this assertion here is to help prevent its occurence.
3288     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3289     ShouldNotReachHere();
3290   }
3291 
3292   return (intptr_t)const_oop()-&gt;constant_encoding();
3293 }
3294 
3295 
3296 //-----------------------------filter------------------------------------------
3297 // Do not allow interface-vs.-noninterface joins to collapse to top.
3298 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3299 
3300   const Type* ft = join_helper(kills, include_speculative);
</pre>
<hr />
<pre>
3353     return (one == two) &amp;&amp; TypePtr::eq(t);
3354   } else {
3355     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3356   }
3357 }
3358 
3359 //------------------------------hash-------------------------------------------
3360 // Type-specific hashing function.
3361 int TypeOopPtr::hash(void) const {
3362   return
3363     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3364              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3365 }
3366 
3367 //------------------------------dump2------------------------------------------
3368 #ifndef PRODUCT
3369 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3370   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3371   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3372   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
<span class="line-modified">3373   switch( _offset ) {</span>
<span class="line-removed">3374   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;</span>
<span class="line-removed">3375   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;</span>
<span class="line-removed">3376   case         0: break;</span>
<span class="line-removed">3377   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;</span>
<span class="line-removed">3378   }</span>
3379   if (_instance_id == InstanceTop)
3380     st-&gt;print(&quot;,iid=top&quot;);
3381   else if (_instance_id != InstanceBot)
3382     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3383 
3384   dump_inline_depth(st);
3385   dump_speculative(st);
3386 }
3387 #endif
3388 
3389 //------------------------------singleton--------------------------------------
3390 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3391 // constants
3392 bool TypeOopPtr::singleton(void) const {
3393   // detune optimizer to not generate constant oop + constant offset as a constant!
3394   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">3395   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);</span>
3396 }
3397 
3398 //------------------------------add_offset-------------------------------------
3399 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3400   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3401 }
3402 
3403 /**
3404  * Return same type without a speculative part
3405  */
3406 const Type* TypeOopPtr::remove_speculative() const {
3407   if (_speculative == NULL) {
3408     return this;
3409   }
3410   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3411   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3412 }
3413 
3414 /**
3415  * Return same type but drop speculative part if we know we won&#39;t use
</pre>
<hr />
<pre>
3467  *
3468  * @return  true if type profile is valuable
3469  */
3470 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3471   // no way to improve an already exact type
3472   if (klass_is_exact()) {
3473     return false;
3474   }
3475   return TypePtr::would_improve_type(exact_kls, inline_depth);
3476 }
3477 
3478 //=============================================================================
3479 // Convenience common pre-built types.
3480 const TypeInstPtr *TypeInstPtr::NOTNULL;
3481 const TypeInstPtr *TypeInstPtr::BOTTOM;
3482 const TypeInstPtr *TypeInstPtr::MIRROR;
3483 const TypeInstPtr *TypeInstPtr::MARK;
3484 const TypeInstPtr *TypeInstPtr::KLASS;
3485 
3486 //------------------------------TypeInstPtr-------------------------------------
<span class="line-modified">3487 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,</span>
<span class="line-modified">3488                          int instance_id, const TypePtr* speculative, int inline_depth)</span>
<span class="line-modified">3489   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth),</span>
<span class="line-modified">3490     _name(k-&gt;name()) {</span>

3491    assert(k != NULL &amp;&amp;
3492           (k-&gt;is_loaded() || o == NULL),
3493           &quot;cannot have constants with non-loaded klass&quot;);


3494 };
3495 
3496 //------------------------------make-------------------------------------------
3497 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3498                                      ciKlass* k,
3499                                      bool xk,
3500                                      ciObject* o,
<span class="line-modified">3501                                      int offset,</span>

3502                                      int instance_id,
3503                                      const TypePtr* speculative,
3504                                      int inline_depth) {
3505   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3506   // Either const_oop() is NULL or else ptr is Constant
3507   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3508           &quot;constant pointers must have a value supplied&quot; );
3509   // Ptr is never Null
3510   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3511 
3512   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3513   if (!UseExactTypes)  xk = false;
3514   if (ptr == Constant) {
3515     // Note:  This case includes meta-object constants, such as methods.
3516     xk = true;
3517   } else if (k-&gt;is_loaded()) {
3518     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3519     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3520     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3521   }
3522 
3523   // Now hash this baby
3524   TypeInstPtr *result =
<span class="line-modified">3525     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3526 
3527   return result;
3528 }
3529 
3530 /**
3531  *  Create constant type for a constant boxed value
3532  */
3533 const Type* TypeInstPtr::get_const_boxed_value() const {
3534   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3535   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3536   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3537   BasicType bt = constant.basic_type();
3538   switch (bt) {
3539     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3540     case T_INT:      return TypeInt::make(constant.as_int());
3541     case T_CHAR:     return TypeInt::make(constant.as_char());
3542     case T_BYTE:     return TypeInt::make(constant.as_byte());
3543     case T_SHORT:    return TypeInt::make(constant.as_short());
3544     case T_FLOAT:    return TypeF::make(constant.as_float());
3545     case T_DOUBLE:   return TypeD::make(constant.as_double());
3546     case T_LONG:     return TypeLong::make(constant.as_long());
3547     default:         break;
3548   }
3549   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3550   return NULL;
3551 }
3552 
3553 //------------------------------cast_to_ptr_type-------------------------------
3554 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3555   if( ptr == _ptr ) return this;
3556   // Reconstruct _sig info here since not a problem with later lazy
3557   // construction, _sig will show up on demand.
<span class="line-modified">3558   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, _inline_depth);</span>
3559 }
3560 
3561 
3562 //-----------------------------cast_to_exactness-------------------------------
3563 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3564   if( klass_is_exact == _klass_is_exact ) return this;
3565   if (!UseExactTypes)  return this;
3566   if (!_klass-&gt;is_loaded())  return this;
3567   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3568   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3569   if( ik-&gt;is_interface() )              return this;  // cannot set xk
<span class="line-modified">3570   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);</span>
3571 }
3572 
3573 //-----------------------------cast_to_instance_id----------------------------
3574 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3575   if( instance_id == _instance_id ) return this;
<span class="line-modified">3576   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);</span>
3577 }
3578 
3579 //------------------------------xmeet_unloaded---------------------------------
3580 // Compute the MEET of two InstPtrs when at least one is unloaded.
3581 // Assume classes are different since called after check for same name/class-loader
3582 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
<span class="line-modified">3583     int off = meet_offset(tinst-&gt;offset());</span>
3584     PTR ptr = meet_ptr(tinst-&gt;ptr());
3585     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3586     const TypePtr* speculative = xmeet_speculative(tinst);
3587     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3588 
3589     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3590     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3591     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3592       //
3593       // Meet unloaded class with java/lang/Object
3594       //
3595       // Meet
3596       //          |                     Unloaded Class
3597       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3598       //  ===================================================================
3599       //   TOP    | ..........................Unloaded......................|
3600       //  AnyNull |  U-AN    |................Unloaded......................|
3601       // Constant | ... O-NN .................................. |   O-BOT   |
3602       //  NotNull | ... O-NN .................................. |   O-BOT   |
3603       //  BOTTOM  | ........................Object-BOTTOM ..................|
3604       //
3605       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3606       //
3607       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
<span class="line-modified">3608       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, instance_id, speculative, depth); }</span>
3609       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3610       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3611         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3612         else                                      { return TypeInstPtr::NOTNULL; }
3613       }
3614       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3615 
3616       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3617     }
3618 
3619     // Both are unloaded, not the same class, not Object
3620     // Or meet unloaded with a different loaded class, not java/lang/Object
3621     if( ptr != TypePtr::BotPTR ) {
3622       return TypeInstPtr::NOTNULL;
3623     }
3624     return TypeInstPtr::BOTTOM;
3625 }
3626 
3627 
3628 //------------------------------meet-------------------------------------------
</pre>
<hr />
<pre>
3641   case FloatBot:
3642   case DoubleTop:
3643   case DoubleCon:
3644   case DoubleBot:
3645   case NarrowOop:
3646   case NarrowKlass:
3647   case Bottom:                  // Ye Olde Default
3648     return Type::BOTTOM;
3649   case Top:
3650     return this;
3651 
3652   default:                      // All else is a mistake
3653     typerr(t);
3654 
3655   case MetadataPtr:
3656   case KlassPtr:
3657   case RawPtr: return TypePtr::BOTTOM;
3658 
3659   case AryPtr: {                // All arrays inherit from Object class
3660     const TypeAryPtr *tp = t-&gt;is_aryptr();
<span class="line-modified">3661     int offset = meet_offset(tp-&gt;offset());</span>
3662     PTR ptr = meet_ptr(tp-&gt;ptr());
3663     int instance_id = meet_instance_id(tp-&gt;instance_id());
3664     const TypePtr* speculative = xmeet_speculative(tp);
3665     int depth = meet_inline_depth(tp-&gt;inline_depth());
3666     switch (ptr) {
3667     case TopPTR:
3668     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3669       // For instances when a subclass meets a superclass we fall
3670       // below the centerline when the superclass is exact. We need to
3671       // do the same here.
<span class="line-modified">3672       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {</span>
<span class="line-modified">3673         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);</span>
3674       } else {
3675         // cannot subclass, so the meet has to fall badly below the centerline
3676         ptr = NotNull;
3677         instance_id = InstanceBot;
<span class="line-modified">3678         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);</span>
3679       }
3680     case Constant:
3681     case NotNull:
3682     case BotPTR:                // Fall down to object klass
3683       // LCA is object_klass, but if we subclass from the top we can do better
3684       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3685         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3686         // then we can subclass in the Java class hierarchy.
3687         // For instances when a subclass meets a superclass we fall
3688         // below the centerline when the superclass is exact. We need
3689         // to do the same here.
<span class="line-modified">3690         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {</span>
3691           // that is, tp&#39;s array type is a subtype of my klass
3692           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
<span class="line-modified">3693                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);</span>
3694         }
3695       }
3696       // The other case cannot happen, since I cannot be a subtype of an array.
3697       // The meet falls down to Object class below centerline.
3698       if( ptr == Constant )
3699          ptr = NotNull;
3700       instance_id = InstanceBot;
<span class="line-modified">3701       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);</span>
3702     default: typerr(t);
3703     }
3704   }
3705 
3706   case OopPtr: {                // Meeting to OopPtrs
3707     // Found a OopPtr type vs self-InstPtr type
3708     const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="line-modified">3709     int offset = meet_offset(tp-&gt;offset());</span>
3710     PTR ptr = meet_ptr(tp-&gt;ptr());
3711     switch (tp-&gt;ptr()) {
3712     case TopPTR:
3713     case AnyNull: {
3714       int instance_id = meet_instance_id(InstanceTop);
3715       const TypePtr* speculative = xmeet_speculative(tp);
3716       int depth = meet_inline_depth(tp-&gt;inline_depth());
3717       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">3718                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);</span>
3719     }
3720     case NotNull:
3721     case BotPTR: {
3722       int instance_id = meet_instance_id(tp-&gt;instance_id());
3723       const TypePtr* speculative = xmeet_speculative(tp);
3724       int depth = meet_inline_depth(tp-&gt;inline_depth());
3725       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
3726     }
3727     default: typerr(t);
3728     }
3729   }
3730 
3731   case AnyPtr: {                // Meeting to AnyPtrs
3732     // Found an AnyPtr type vs self-InstPtr type
3733     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">3734     int offset = meet_offset(tp-&gt;offset());</span>
3735     PTR ptr = meet_ptr(tp-&gt;ptr());
3736     int instance_id = meet_instance_id(InstanceTop);
3737     const TypePtr* speculative = xmeet_speculative(tp);
3738     int depth = meet_inline_depth(tp-&gt;inline_depth());
3739     switch (tp-&gt;ptr()) {
3740     case Null:
3741       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3742       // else fall through to AnyNull
3743     case TopPTR:
3744     case AnyNull: {
3745       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">3746                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);</span>
3747     }
3748     case NotNull:
3749     case BotPTR:
3750       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
3751     default: typerr(t);
3752     }
3753   }
3754 
3755   /*
3756                  A-top         }
3757                /   |   \       }  Tops
3758            B-top A-any C-top   }
3759               | /  |  \ |      }  Any-nulls
3760            B-any   |   C-any   }
3761               |    |    |
3762            B-con A-con C-con   } constants; not comparable across classes
3763               |    |    |
3764            B-not   |   C-not   }
3765               | \  |  / |      }  not-nulls
3766            B-bot A-not C-bot   }
3767                \   |   /       }  Bottoms
3768                  A-bot         }
3769   */
3770 
3771   case InstPtr: {                // Meeting 2 Oops?
3772     // Found an InstPtr sub-type vs self-InstPtr type
3773     const TypeInstPtr *tinst = t-&gt;is_instptr();
<span class="line-modified">3774     int off = meet_offset( tinst-&gt;offset() );</span>
3775     PTR ptr = meet_ptr( tinst-&gt;ptr() );
3776     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3777     const TypePtr* speculative = xmeet_speculative(tinst);
3778     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3779 
3780     // Check for easy case; klasses are equal (and perhaps not loaded!)
3781     // If we have constants, then we created oops so classes are loaded
3782     // and we can handle the constants further down.  This case handles
3783     // both-not-loaded or both-loaded classes
<span class="line-modified">3784     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact()) {</span>
<span class="line-modified">3785       return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);</span>

3786     }
3787 
3788     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
3789     ciKlass* tinst_klass = tinst-&gt;klass();
3790     ciKlass* this_klass  = this-&gt;klass();
3791     bool tinst_xk = tinst-&gt;klass_is_exact();
3792     bool this_xk  = this-&gt;klass_is_exact();


3793     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
3794       // One of these classes has not been loaded
3795       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
3796 #ifndef PRODUCT
3797       if( PrintOpto &amp;&amp; Verbose ) {
3798         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
3799         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
3800         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
3801       }
3802 #endif
3803       return unloaded_meet;
3804     }
3805 
3806     // Handle mixing oops and interfaces first.
3807     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
3808                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
3809       ciKlass *tmp = tinst_klass; // Swap interface around
3810       tinst_klass = this_klass;
3811       this_klass = tmp;
3812       bool tmp2 = tinst_xk;
3813       tinst_xk = this_xk;
3814       this_xk = tmp2;



3815     }
3816     if (tinst_klass-&gt;is_interface() &amp;&amp;
3817         !(this_klass-&gt;is_interface() ||
3818           // Treat java/lang/Object as an honorary interface,
3819           // because we need a bottom for the interface hierarchy.
3820           this_klass == ciEnv::current()-&gt;Object_klass())) {
3821       // Oop meets interface!
3822 
3823       // See if the oop subtypes (implements) interface.
3824       ciKlass *k;
3825       bool xk;

3826       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3827         // Oop indeed subtypes.  Now keep oop or interface depending
3828         // on whether we are both above the centerline or either is
3829         // below the centerline.  If we are on the centerline
3830         // (e.g., Constant vs. AnyNull interface), use the constant.
3831         k  = below_centerline(ptr) ? tinst_klass : this_klass;
3832         // If we are keeping this_klass, keep its exactness too.
3833         xk = below_centerline(ptr) ? tinst_xk    : this_xk;

3834       } else {                  // Does not implement, fall to Object
3835         // Oop does not implement interface, so mixing falls to Object
3836         // just like the verifier does (if both are above the
3837         // centerline fall to interface)
3838         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
3839         xk = above_centerline(ptr) ? tinst_xk : false;

3840         // Watch out for Constant vs. AnyNull interface.
3841         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
3842         instance_id = InstanceBot;
3843       }
3844       ciObject* o = NULL;  // the Constant value, if any
3845       if (ptr == Constant) {
3846         // Find out which constant.
3847         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
3848       }
<span class="line-modified">3849       return make(ptr, k, xk, o, off, instance_id, speculative, depth);</span>
3850     }
3851 
3852     // Either oop vs oop or interface vs interface or interface vs Object
3853 
3854     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
3855     // If we split one up &amp; one down AND they subtype, take the down man.
3856     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3857     // If both are up and they subtype, take the subtype class.
3858     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3859     // If both are down and they subtype, take the supertype class.
3860     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3861     // Constants treated as down.
3862 
3863     // Now, reorder the above list; observe that both-down+subtype is also
3864     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
3865     // If we split one up &amp; one down AND they subtype, take the down man.
3866     // If both are up and they subtype, take the subtype class.
3867 
3868     // If both are down and they subtype, &quot;fall hard&quot;.
3869     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3870     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3871     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3872 
3873     // If a proper subtype is exact, and we return it, we return it exactly.
3874     // If a proper supertype is exact, there can be no subtyping relationship!
3875     // If both types are equal to the subtype, exactness is and-ed below the
3876     // centerline and or-ed above it.  (N.B. Constants are always exact.)
3877 
3878     // Check for subtyping:
3879     ciKlass *subtype = NULL;
3880     bool subtype_exact = false;
<span class="line-modified">3881     if( tinst_klass-&gt;equals(this_klass) ) {</span>

3882       subtype = this_klass;
3883       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
<span class="line-modified">3884     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {</span>

3885       subtype = this_klass;     // Pick subtyping class
3886       subtype_exact = this_xk;
<span class="line-modified">3887     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {</span>

3888       subtype = tinst_klass;    // Pick subtyping class
3889       subtype_exact = tinst_xk;

3890     }
3891 
<span class="line-modified">3892     if( subtype ) {</span>
<span class="line-modified">3893       if( above_centerline(ptr) ) { // both are up?</span>
3894         this_klass = tinst_klass = subtype;
3895         this_xk = tinst_xk = subtype_exact;
<span class="line-modified">3896       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {</span>

3897         this_klass = tinst_klass; // tinst is down; keep down man
3898         this_xk = tinst_xk;
<span class="line-modified">3899       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {</span>

3900         tinst_klass = this_klass; // this is down; keep down man
3901         tinst_xk = this_xk;

3902       } else {
3903         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA

3904       }
3905     }
3906 
3907     // Check for classes now being equal
3908     if (tinst_klass-&gt;equals(this_klass)) {
3909       // If the klasses are equal, the constants may still differ.  Fall to
3910       // NotNull if they do (neither constant is NULL; that is a special case
3911       // handled elsewhere).
3912       ciObject* o = NULL;             // Assume not constant when done
3913       ciObject* this_oop  = const_oop();
3914       ciObject* tinst_oop = tinst-&gt;const_oop();
3915       if( ptr == Constant ) {
3916         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
3917             this_oop-&gt;equals(tinst_oop) )
3918           o = this_oop;
3919         else if (above_centerline(this -&gt;_ptr))
3920           o = tinst_oop;
3921         else if (above_centerline(tinst -&gt;_ptr))
3922           o = this_oop;
3923         else
3924           ptr = NotNull;
3925       }
<span class="line-modified">3926       return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);</span>
3927     } // Else classes are not equal
3928 
3929     // Since klasses are different, we require a LCA in the Java
3930     // class hierarchy - which means we have to fall to at least NotNull.
3931     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
3932       ptr = NotNull;
3933 
3934     instance_id = InstanceBot;
3935 
3936     // Now we find the LCA of Java classes
3937     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
<span class="line-modified">3938     return make(ptr, k, false, NULL, off, instance_id, speculative, depth);</span>
3939   } // End of case InstPtr
3940 





















3941   } // End of switch
3942   return this;                  // Return the double constant
3943 }
3944 
3945 
3946 //------------------------java_mirror_type--------------------------------------
3947 ciType* TypeInstPtr::java_mirror_type() const {
3948   // must be a singleton type
3949   if( const_oop() == NULL )  return NULL;
3950 
3951   // must be of type java.lang.Class
3952   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
<span class="line-removed">3953 </span>
3954   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
3955 }
3956 
3957 
3958 //------------------------------xdual------------------------------------------
3959 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
3960 // inheritance mechanism.
3961 const Type *TypeInstPtr::xdual() const {
<span class="line-modified">3962   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
3963 }
3964 
3965 //------------------------------eq---------------------------------------------
3966 // Structural equality check for Type representations
3967 bool TypeInstPtr::eq( const Type *t ) const {
3968   const TypeInstPtr *p = t-&gt;is_instptr();
3969   return
3970     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;

3971     TypeOopPtr::eq(p);          // Check sub-type stuff
3972 }
3973 
3974 //------------------------------hash-------------------------------------------
3975 // Type-specific hashing function.
3976 int TypeInstPtr::hash(void) const {
<span class="line-modified">3977   int hash = java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash());</span>
3978   return hash;
3979 }
3980 
3981 //------------------------------dump2------------------------------------------
3982 // Dump oop Type
3983 #ifndef PRODUCT
3984 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3985   // Print the name of the klass.
3986   klass()-&gt;print_name_on(st);
3987 
3988   switch( _ptr ) {
3989   case Constant:
3990     // TO DO: Make CI print the hex address of the underlying oop.
3991     if (WizardMode || Verbose) {
3992       const_oop()-&gt;print_oop(st);
3993     }
3994   case BotPTR:
3995     if (!WizardMode &amp;&amp; !Verbose) {
3996       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3997       break;
3998     }
3999   case TopPTR:
4000   case AnyNull:
4001   case NotNull:
4002     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4003     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4004     break;
4005   default:
4006     break;
4007   }
4008 
<span class="line-modified">4009   if( _offset ) {               // Dump offset, if any</span>
<span class="line-removed">4010     if( _offset == OffsetBot )      st-&gt;print(&quot;+any&quot;);</span>
<span class="line-removed">4011     else if( _offset == OffsetTop ) st-&gt;print(&quot;+unknown&quot;);</span>
<span class="line-removed">4012     else st-&gt;print(&quot;+%d&quot;, _offset);</span>
<span class="line-removed">4013   }</span>
4014 
4015   st-&gt;print(&quot; *&quot;);





4016   if (_instance_id == InstanceTop)
4017     st-&gt;print(&quot;,iid=top&quot;);
4018   else if (_instance_id != InstanceBot)
4019     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4020 
4021   dump_inline_depth(st);
4022   dump_speculative(st);
4023 }
4024 #endif
4025 
4026 //------------------------------add_offset-------------------------------------
4027 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4028   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),</span>
4029               _instance_id, add_offset_speculative(offset), _inline_depth);
4030 }
4031 
4032 const Type *TypeInstPtr::remove_speculative() const {
4033   if (_speculative == NULL) {
4034     return this;
4035   }
4036   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4037   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,</span>
4038               _instance_id, NULL, _inline_depth);
4039 }
4040 
4041 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4042   if (!UseInlineDepthForSpeculativeTypes) {
4043     return this;
4044   }
<span class="line-modified">4045   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);</span>
4046 }
4047 
4048 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4049   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4050   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);</span>
4051 }
4052 





4053 //=============================================================================
4054 // Convenience common pre-built types.
4055 const TypeAryPtr *TypeAryPtr::RANGE;
4056 const TypeAryPtr *TypeAryPtr::OOPS;
4057 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4058 const TypeAryPtr *TypeAryPtr::BYTES;
4059 const TypeAryPtr *TypeAryPtr::SHORTS;
4060 const TypeAryPtr *TypeAryPtr::CHARS;
4061 const TypeAryPtr *TypeAryPtr::INTS;
4062 const TypeAryPtr *TypeAryPtr::LONGS;
4063 const TypeAryPtr *TypeAryPtr::FLOATS;
4064 const TypeAryPtr *TypeAryPtr::DOUBLES;

4065 
4066 //------------------------------make-------------------------------------------
<span class="line-modified">4067 const TypeAryPtr *TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,</span>
4068                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4069   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4070          &quot;integral arrays must be pre-equipped with a class&quot;);
<span class="line-modified">4071   if (!xk)  xk = ary-&gt;ary_must_be_exact();</span>
4072   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4073   if (!UseExactTypes)  xk = (ptr == Constant);
<span class="line-modified">4074   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();</span>
4075 }
4076 
4077 //------------------------------make-------------------------------------------
<span class="line-modified">4078 const TypeAryPtr *TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,</span>
4079                                    int instance_id, const TypePtr* speculative, int inline_depth,
4080                                    bool is_autobox_cache) {
4081   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4082          &quot;integral arrays must be pre-equipped with a class&quot;);
4083   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4084   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4085   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4086   if (!UseExactTypes)  xk = (ptr == Constant);
<span class="line-modified">4087   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();</span>
4088 }
4089 
4090 //------------------------------cast_to_ptr_type-------------------------------
4091 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4092   if( ptr == _ptr ) return this;
<span class="line-modified">4093   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);</span>
4094 }
4095 
4096 
4097 //-----------------------------cast_to_exactness-------------------------------
4098 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4099   if( klass_is_exact == _klass_is_exact ) return this;
4100   if (!UseExactTypes)  return this;
4101   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
<span class="line-modified">4102   return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);</span>






4103 }
4104 
4105 //-----------------------------cast_to_instance_id----------------------------
4106 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4107   if( instance_id == _instance_id ) return this;
<span class="line-modified">4108   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);</span>
4109 }
4110 
4111 
4112 //-----------------------------max_array_length-------------------------------
4113 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4114 jint TypeAryPtr::max_array_length(BasicType etype) {
4115   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4116     if (etype == T_NARROWOOP) {
4117       etype = T_OBJECT;
4118     } else if (etype == T_ILLEGAL) { // bottom[]
4119       etype = T_BYTE; // will produce conservatively high value
4120     } else {
4121       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4122     }
4123   }
4124   return arrayOopDesc::max_array_length(etype);
4125 }
4126 
4127 //-----------------------------narrow_size_type-------------------------------
4128 // Narrow the given size type to the index range for the given array base type.
</pre>
<hr />
<pre>
4144   if (hi &gt; max_hi) {
4145     hi = max_hi;
4146     if (size-&gt;is_con()) {
4147       lo = hi;
4148     }
4149     chg = true;
4150   }
4151   // Negative length arrays will produce weird intermediate dead fast-path code
4152   if (lo &gt; hi)
4153     return TypeInt::ZERO;
4154   if (!chg)
4155     return size;
4156   return TypeInt::make(lo, hi, Type::WidenMin);
4157 }
4158 
4159 //-------------------------------cast_to_size----------------------------------
4160 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4161   assert(new_size != NULL, &quot;&quot;);
4162   new_size = narrow_size_type(new_size);
4163   if (new_size == size())  return this;
<span class="line-modified">4164   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable());</span>
<span class="line-modified">4165   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);</span>



















4166 }
4167 
4168 //------------------------------cast_to_stable---------------------------------
4169 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4170   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4171     return this;
4172 
4173   const Type* elem = this-&gt;elem();
4174   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4175 
4176   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4177     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4178     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4179   }
4180 
<span class="line-modified">4181   const TypeAry* new_ary = TypeAry::make(elem, size(), stable);</span>
4182 
<span class="line-modified">4183   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);</span>
4184 }
4185 
4186 //-----------------------------stable_dimension--------------------------------
4187 int TypeAryPtr::stable_dimension() const {
4188   if (!is_stable())  return 0;
4189   int dim = 1;
4190   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4191   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4192     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4193   return dim;
4194 }
4195 
4196 //----------------------cast_to_autobox_cache-----------------------------------
4197 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4198   if (is_autobox_cache() == cache)  return this;
4199   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4200   if (etype == NULL)  return this;
4201   // The pointers in the autobox arrays are always non-null.
4202   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4203   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">4204   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable());</span>
<span class="line-modified">4205   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth, cache);</span>
4206 }
4207 
4208 //------------------------------eq---------------------------------------------
4209 // Structural equality check for Type representations
4210 bool TypeAryPtr::eq( const Type *t ) const {
4211   const TypeAryPtr *p = t-&gt;is_aryptr();
4212   return
4213     _ary == p-&gt;_ary &amp;&amp;  // Check array
<span class="line-modified">4214     TypeOopPtr::eq(p);  // Check sub-parts</span>

4215 }
4216 
4217 //------------------------------hash-------------------------------------------
4218 // Type-specific hashing function.
4219 int TypeAryPtr::hash(void) const {
<span class="line-modified">4220   return (intptr_t)_ary + TypeOopPtr::hash();</span>
4221 }
4222 
4223 //------------------------------meet-------------------------------------------
4224 // Compute the MEET of two types.  It returns a new Type object.
4225 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4226   // Perform a fast test for common case; meeting the same types together.
4227   if( this == t ) return this;  // Meeting same type-rep?
4228   // Current &quot;this-&gt;_base&quot; is Pointer
4229   switch (t-&gt;base()) {          // switch on original type
4230 
4231   // Mixing ints &amp; oops happens when javac reuses local variables
4232   case Int:
4233   case Long:
4234   case FloatTop:
4235   case FloatCon:
4236   case FloatBot:
4237   case DoubleTop:
4238   case DoubleCon:
4239   case DoubleBot:
4240   case NarrowOop:
4241   case NarrowKlass:
4242   case Bottom:                  // Ye Olde Default
4243     return Type::BOTTOM;
4244   case Top:
4245     return this;
4246 
4247   default:                      // All else is a mistake
4248     typerr(t);
4249 
4250   case OopPtr: {                // Meeting to OopPtrs
4251     // Found a OopPtr type vs self-AryPtr type
4252     const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="line-modified">4253     int offset = meet_offset(tp-&gt;offset());</span>
4254     PTR ptr = meet_ptr(tp-&gt;ptr());
4255     int depth = meet_inline_depth(tp-&gt;inline_depth());
4256     const TypePtr* speculative = xmeet_speculative(tp);
4257     switch (tp-&gt;ptr()) {
4258     case TopPTR:
4259     case AnyNull: {
4260       int instance_id = meet_instance_id(InstanceTop);
4261       return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4262                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
4263     }
4264     case BotPTR:
4265     case NotNull: {
4266       int instance_id = meet_instance_id(tp-&gt;instance_id());
4267       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4268     }
4269     default: ShouldNotReachHere();
4270     }
4271   }
4272 
4273   case AnyPtr: {                // Meeting two AnyPtrs
4274     // Found an AnyPtr type vs self-AryPtr type
4275     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">4276     int offset = meet_offset(tp-&gt;offset());</span>
4277     PTR ptr = meet_ptr(tp-&gt;ptr());
4278     const TypePtr* speculative = xmeet_speculative(tp);
4279     int depth = meet_inline_depth(tp-&gt;inline_depth());
4280     switch (tp-&gt;ptr()) {
4281     case TopPTR:
4282       return this;
4283     case BotPTR:
4284     case NotNull:
4285       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4286     case Null:
4287       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4288       // else fall through to AnyNull
4289     case AnyNull: {
4290       int instance_id = meet_instance_id(InstanceTop);
4291       return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4292                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
4293     }
4294     default: ShouldNotReachHere();
4295     }
4296   }
4297 
4298   case MetadataPtr:
4299   case KlassPtr:
4300   case RawPtr: return TypePtr::BOTTOM;
4301 
4302   case AryPtr: {                // Meeting 2 references?
4303     const TypeAryPtr *tap = t-&gt;is_aryptr();
<span class="line-modified">4304     int off = meet_offset(tap-&gt;offset());</span>

4305     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4306     PTR ptr = meet_ptr(tap-&gt;ptr());
4307     int instance_id = meet_instance_id(tap-&gt;instance_id());
4308     const TypePtr* speculative = xmeet_speculative(tap);
4309     int depth = meet_inline_depth(tap-&gt;inline_depth());
4310     ciKlass* lazy_klass = NULL;
4311     if (tary-&gt;_elem-&gt;isa_int()) {
4312       // Integral array element types have irrelevant lattice relations.
4313       // It is the klass that determines array layout, not the element type.
4314       if (_klass == NULL)
4315         lazy_klass = tap-&gt;_klass;
4316       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4317         lazy_klass = _klass;
4318       } else {
4319         // Something like byte[int+] meets char[int+].
4320         // This must fall to bottom, not (int[-128..65535])[int+].
4321         instance_id = InstanceBot;
<span class="line-modified">4322         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);</span>
4323       }
4324     } else // Non integral arrays.
4325       // Must fall to bottom if exact klasses in upper lattice
4326       // are not equal or super klass is exact.
4327       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4328           // meet with top[] and bottom[] are processed further down:
<span class="line-modified">4329           tap-&gt;_klass != NULL  &amp;&amp; this-&gt;_klass != NULL   &amp;&amp;</span>
4330           // both are exact and not equal:
4331           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
<span class="line-modified">4332            // &#39;tap&#39;  is exact and super or unrelated:</span>
4333            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4334            // &#39;this&#39; is exact and super or unrelated:
4335            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4336       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
<span class="line-modified">4337         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);</span>












4338       }
<span class="line-removed">4339       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);</span>
4340     }
4341 
4342     bool xk = false;
4343     switch (tap-&gt;ptr()) {
4344     case AnyNull:
4345     case TopPTR:
4346       // Compute new klass on demand, do not use tap-&gt;_klass
4347       if (below_centerline(this-&gt;_ptr)) {
4348         xk = this-&gt;_klass_is_exact;
4349       } else {
4350         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4351       }
<span class="line-modified">4352       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);</span>
4353     case Constant: {
4354       ciObject* o = const_oop();
4355       if( _ptr == Constant ) {
4356         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4357           xk = (klass() == tap-&gt;klass());
4358           ptr = NotNull;
4359           o = NULL;
4360           instance_id = InstanceBot;
4361         } else {
4362           xk = true;
4363         }
4364       } else if(above_centerline(_ptr)) {
4365         o = tap-&gt;const_oop();
4366         xk = true;
4367       } else {
4368         // Only precise for identical arrays
4369         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4370       }
<span class="line-modified">4371       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);</span>
4372     }
4373     case NotNull:
4374     case BotPTR:
4375       // Compute new klass on demand, do not use tap-&gt;_klass
4376       if (above_centerline(this-&gt;_ptr))
4377             xk = tap-&gt;_klass_is_exact;
4378       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4379               (klass() == tap-&gt;klass()); // Only precise for identical arrays
<span class="line-modified">4380       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);</span>
4381     default: ShouldNotReachHere();
4382     }
4383   }
4384 
4385   // All arrays inherit from Object class
4386   case InstPtr: {
4387     const TypeInstPtr *tp = t-&gt;is_instptr();
<span class="line-modified">4388     int offset = meet_offset(tp-&gt;offset());</span>
4389     PTR ptr = meet_ptr(tp-&gt;ptr());
4390     int instance_id = meet_instance_id(tp-&gt;instance_id());
4391     const TypePtr* speculative = xmeet_speculative(tp);
4392     int depth = meet_inline_depth(tp-&gt;inline_depth());
4393     switch (ptr) {
4394     case TopPTR:
4395     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4396       // For instances when a subclass meets a superclass we fall
4397       // below the centerline when the superclass is exact. We need to
4398       // do the same here.
<span class="line-modified">4399       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {</span>
<span class="line-modified">4400         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
4401       } else {
4402         // cannot subclass, so the meet has to fall badly below the centerline
4403         ptr = NotNull;
4404         instance_id = InstanceBot;
<span class="line-modified">4405         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);</span>
4406       }
4407     case Constant:
4408     case NotNull:
4409     case BotPTR:                // Fall down to object klass
4410       // LCA is object_klass, but if we subclass from the top we can do better
4411       if (above_centerline(tp-&gt;ptr())) {
4412         // If &#39;tp&#39;  is above the centerline and it is Object class
4413         // then we can subclass in the Java class hierarchy.
4414         // For instances when a subclass meets a superclass we fall
4415         // below the centerline when the superclass is exact. We need
4416         // to do the same here.
<span class="line-modified">4417         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {</span>
4418           // that is, my array type is a subtype of &#39;tp&#39; klass
4419           return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4420                       _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
4421         }
4422       }
4423       // The other case cannot happen, since t cannot be a subtype of an array.
4424       // The meet falls down to Object class below centerline.
4425       if( ptr == Constant )
4426          ptr = NotNull;
4427       instance_id = InstanceBot;
<span class="line-modified">4428       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);</span>
4429     default: typerr(t);
4430     }
4431   }













4432   }
4433   return this;                  // Lint noise
4434 }
4435 
4436 //------------------------------xdual------------------------------------------
4437 // Dual: compute field-by-field dual
4438 const Type *TypeAryPtr::xdual() const {
<span class="line-modified">4439   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());</span>









4440 }
4441 
4442 //----------------------interface_vs_oop---------------------------------------
4443 #ifdef ASSERT
4444 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4445   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4446   if (t_aryptr) {
4447     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4448   }
4449   return false;
4450 }
4451 #endif
4452 
4453 //------------------------------dump2------------------------------------------
4454 #ifndef PRODUCT
4455 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4456   _ary-&gt;dump2(d,depth,st);
4457   switch( _ptr ) {
4458   case Constant:
4459     const_oop()-&gt;print(st);
4460     break;
4461   case BotPTR:
4462     if (!WizardMode &amp;&amp; !Verbose) {
4463       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4464       break;
4465     }
4466   case TopPTR:
4467   case AnyNull:
4468   case NotNull:
4469     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4470     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4471     break;
4472   default:
4473     break;
4474   }
4475 
<span class="line-modified">4476   if( _offset != 0 ) {</span>





4477     int header_size = objArrayOopDesc::header_size() * wordSize;
<span class="line-modified">4478     if( _offset == OffsetTop )       st-&gt;print(&quot;+undefined&quot;);</span>
<span class="line-modified">4479     else if( _offset == OffsetBot )  st-&gt;print(&quot;+any&quot;);</span>
<span class="line-modified">4480     else if( _offset &lt; header_size ) st-&gt;print(&quot;+%d&quot;, _offset);</span>
4481     else {
4482       BasicType basic_elem_type = elem()-&gt;basic_type();
4483       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4484       int elem_size = type2aelembytes(basic_elem_type);
<span class="line-modified">4485       st-&gt;print(&quot;[%d]&quot;, (_offset - array_base)/elem_size);</span>
4486     }
4487   }
4488   st-&gt;print(&quot; *&quot;);
4489   if (_instance_id == InstanceTop)
4490     st-&gt;print(&quot;,iid=top&quot;);
4491   else if (_instance_id != InstanceBot)
4492     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4493 
4494   dump_inline_depth(st);
4495   dump_speculative(st);
4496 }
4497 #endif
4498 
4499 bool TypeAryPtr::empty(void) const {
4500   if (_ary-&gt;empty())       return true;
4501   return TypeOopPtr::empty();
4502 }
4503 
4504 //------------------------------add_offset-------------------------------------
4505 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4506   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);</span>
4507 }
4508 
4509 const Type *TypeAryPtr::remove_speculative() const {
4510   if (_speculative == NULL) {
4511     return this;
4512   }
4513   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4514   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);</span>












4515 }
4516 
4517 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4518   if (!UseInlineDepthForSpeculativeTypes) {
4519     return this;
4520   }
<span class="line-modified">4521   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, _speculative, depth);</span>



















































4522 }
4523 
4524 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4525   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4526   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);</span>
4527 }
4528 
4529 //=============================================================================
4530 

4531 //------------------------------hash-------------------------------------------
4532 // Type-specific hashing function.
4533 int TypeNarrowPtr::hash(void) const {
4534   return _ptrtype-&gt;hash() + 7;
4535 }
4536 
4537 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
4538   return _ptrtype-&gt;singleton();
4539 }
4540 
4541 bool TypeNarrowPtr::empty(void) const {
4542   return _ptrtype-&gt;empty();
4543 }
4544 
4545 intptr_t TypeNarrowPtr::get_con() const {
4546   return _ptrtype-&gt;get_con();
4547 }
4548 
4549 bool TypeNarrowPtr::eq( const Type *t ) const {
4550   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
</pre>
<hr />
<pre>
4599   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
4600   switch (t-&gt;base()) {          // switch on original type
4601 
4602   case Int:                     // Mixing ints &amp; oops happens when javac
4603   case Long:                    // reuses local variables
4604   case FloatTop:
4605   case FloatCon:
4606   case FloatBot:
4607   case DoubleTop:
4608   case DoubleCon:
4609   case DoubleBot:
4610   case AnyPtr:
4611   case RawPtr:
4612   case OopPtr:
4613   case InstPtr:
4614   case AryPtr:
4615   case MetadataPtr:
4616   case KlassPtr:
4617   case NarrowOop:
4618   case NarrowKlass:
<span class="line-removed">4619 </span>
4620   case Bottom:                  // Ye Olde Default
4621     return Type::BOTTOM;
4622   case Top:
4623     return this;
4624 



4625   default:                      // All else is a mistake
4626     typerr(t);
4627 
4628   } // End of switch
4629 
4630   return this;
4631 }
4632 
4633 #ifndef PRODUCT
4634 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4635   _ptrtype-&gt;dump2(d, depth, st);
4636 }
4637 #endif
4638 
4639 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
4640 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
4641 
4642 
4643 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
4644   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
</pre>
<hr />
<pre>
4683     return (one == two) &amp;&amp; TypePtr::eq(t);
4684   } else {
4685     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
4686   }
4687 }
4688 
4689 //------------------------------hash-------------------------------------------
4690 // Type-specific hashing function.
4691 int TypeMetadataPtr::hash(void) const {
4692   return
4693     (metadata() ? metadata()-&gt;hash() : 0) +
4694     TypePtr::hash();
4695 }
4696 
4697 //------------------------------singleton--------------------------------------
4698 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4699 // constants
4700 bool TypeMetadataPtr::singleton(void) const {
4701   // detune optimizer to not generate constant metadata + constant offset as a constant!
4702   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">4703   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);</span>
4704 }
4705 
4706 //------------------------------add_offset-------------------------------------
4707 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
4708   return make( _ptr, _metadata, xadd_offset(offset));
4709 }
4710 
4711 //-----------------------------filter------------------------------------------
4712 // Do not allow interface-vs.-noninterface joins to collapse to top.
4713 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
4714   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
4715   if (ft == NULL || ft-&gt;empty())
4716     return Type::TOP;           // Canonical empty value
4717   return ft;
4718 }
4719 
4720  //------------------------------get_con----------------------------------------
4721 intptr_t TypeMetadataPtr::get_con() const {
4722   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">4723   assert( _offset &gt;= 0, &quot;&quot; );</span>
4724 
<span class="line-modified">4725   if (_offset != 0) {</span>
4726     // After being ported to the compiler interface, the compiler no longer
4727     // directly manipulates the addresses of oops.  Rather, it only has a pointer
4728     // to a handle at compile time.  This handle is embedded in the generated
4729     // code and dereferenced at the time the nmethod is made.  Until that time,
4730     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
4731     // have access to the addresses!).  This does not seem to currently happen,
4732     // but this assertion here is to help prevent its occurence.
4733     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
4734     ShouldNotReachHere();
4735   }
4736 
4737   return (intptr_t)metadata()-&gt;constant_encoding();
4738 }
4739 
4740 //------------------------------cast_to_ptr_type-------------------------------
4741 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
4742   if( ptr == _ptr ) return this;
4743   return make(ptr, metadata(), _offset);
4744 }
4745 
</pre>
<hr />
<pre>
4756   case Long:                    // reuses local variables
4757   case FloatTop:
4758   case FloatCon:
4759   case FloatBot:
4760   case DoubleTop:
4761   case DoubleCon:
4762   case DoubleBot:
4763   case NarrowOop:
4764   case NarrowKlass:
4765   case Bottom:                  // Ye Olde Default
4766     return Type::BOTTOM;
4767   case Top:
4768     return this;
4769 
4770   default:                      // All else is a mistake
4771     typerr(t);
4772 
4773   case AnyPtr: {
4774     // Found an AnyPtr type vs self-OopPtr type
4775     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">4776     int offset = meet_offset(tp-&gt;offset());</span>
4777     PTR ptr = meet_ptr(tp-&gt;ptr());
4778     switch (tp-&gt;ptr()) {
4779     case Null:
4780       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4781       // else fall through:
4782     case TopPTR:
4783     case AnyNull: {
4784       return make(ptr, _metadata, offset);
4785     }
4786     case BotPTR:
4787     case NotNull:
4788       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4789     default: typerr(t);
4790     }
4791   }
4792 
4793   case RawPtr:
4794   case KlassPtr:
4795   case OopPtr:
4796   case InstPtr:
4797   case AryPtr:
4798     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
4799 
4800   case MetadataPtr: {
4801     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
<span class="line-modified">4802     int offset = meet_offset(tp-&gt;offset());</span>
4803     PTR tptr = tp-&gt;ptr();
4804     PTR ptr = meet_ptr(tptr);
4805     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
4806     if (tptr == TopPTR || _ptr == TopPTR ||
4807         metadata()-&gt;equals(tp-&gt;metadata())) {
4808       return make(ptr, md, offset);
4809     }
4810     // metadata is different
4811     if( ptr == Constant ) {  // Cannot be equal constants, so...
4812       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
4813       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
4814       ptr = NotNull;            // Fall down in lattice
4815     }
4816     return make(ptr, NULL, offset);
4817     break;
4818   }
4819   } // End of switch
4820   return this;                  // Return the double constant
4821 }
4822 
4823 
4824 //------------------------------xdual------------------------------------------
4825 // Dual of a pure metadata pointer.
4826 const Type *TypeMetadataPtr::xdual() const {
4827   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
4828 }
4829 
4830 //------------------------------dump2------------------------------------------
4831 #ifndef PRODUCT
4832 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4833   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
4834   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
<span class="line-modified">4835   switch( _offset ) {</span>
4836   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
4837   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
4838   case         0: break;
<span class="line-modified">4839   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;</span>
4840   }
4841 }
4842 #endif
4843 
4844 
4845 //=============================================================================
4846 // Convenience common pre-built type.
4847 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
4848 
<span class="line-modified">4849 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset):</span>
4850   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
4851 }
4852 
4853 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
<span class="line-modified">4854   return make(Constant, m, 0);</span>
4855 }
4856 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
<span class="line-modified">4857   return make(Constant, m, 0);</span>
4858 }
4859 
4860 //------------------------------make-------------------------------------------
4861 // Create a meta data constant
<span class="line-modified">4862 const TypeMetadataPtr *TypeMetadataPtr::make(PTR ptr, ciMetadata* m, int offset) {</span>
4863   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
4864   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
4865 }
4866 
4867 
4868 //=============================================================================
4869 // Convenience common pre-built types.
4870 
4871 // Not-null object klass or below
4872 const TypeKlassPtr *TypeKlassPtr::OBJECT;
4873 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
4874 
4875 //------------------------------TypeKlassPtr-----------------------------------
<span class="line-modified">4876 TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )</span>
<span class="line-modified">4877   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {</span>


4878 }
4879 
4880 //------------------------------make-------------------------------------------
4881 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
<span class="line-modified">4882 const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {</span>
<span class="line-modified">4883   assert( k != NULL, &quot;Expect a non-NULL klass&quot;);</span>
<span class="line-modified">4884   assert(k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);</span>
<span class="line-removed">4885   TypeKlassPtr *r =</span>
<span class="line-removed">4886     (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))-&gt;hashcons();</span>
<span class="line-removed">4887 </span>
<span class="line-removed">4888   return r;</span>
4889 }
4890 
4891 //------------------------------eq---------------------------------------------
4892 // Structural equality check for Type representations
4893 bool TypeKlassPtr::eq( const Type *t ) const {
4894   const TypeKlassPtr *p = t-&gt;is_klassptr();
<span class="line-modified">4895   return</span>
<span class="line-removed">4896     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;</span>
<span class="line-removed">4897     TypePtr::eq(p);</span>
4898 }
4899 
4900 //------------------------------hash-------------------------------------------
4901 // Type-specific hashing function.
4902 int TypeKlassPtr::hash(void) const {
<span class="line-modified">4903   return java_add((jint)klass()-&gt;hash(), (jint)TypePtr::hash());</span>
4904 }
4905 
4906 //------------------------------singleton--------------------------------------
4907 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4908 // constants
4909 bool TypeKlassPtr::singleton(void) const {
4910   // detune optimizer to not generate constant klass + constant offset as a constant!
4911   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">4912   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);</span>
4913 }
4914 
4915 // Do not allow interface-vs.-noninterface joins to collapse to top.
4916 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
4917   // logic here mirrors the one from TypeOopPtr::filter. See comments
4918   // there.
4919   const Type* ft = join_helper(kills, include_speculative);
4920   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
4921   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
4922 
4923   if (ft-&gt;empty()) {
<span class="line-modified">4924     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;klass()-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())</span>
4925       return kills;             // Uplift to interface
4926 
4927     return Type::TOP;           // Canonical empty value
4928   }
4929 
4930   // Interface klass type could be exact in opposite to interface type,
4931   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
4932   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
4933       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
4934       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
4935       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
4936     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
4937   }
4938 
4939   return ft;
4940 }
4941 
4942 //----------------------compute_klass------------------------------------------
4943 // Compute the defining klass for this class
4944 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
4945   // Compute _klass based on element type.
4946   ciKlass* k_ary = NULL;
<span class="line-removed">4947   const TypeInstPtr *tinst;</span>
4948   const TypeAryPtr *tary;
4949   const Type* el = elem();
4950   if (el-&gt;isa_narrowoop()) {
4951     el = el-&gt;make_ptr();
4952   }
4953 
4954   // Get element klass
<span class="line-modified">4955   if ((tinst = el-&gt;isa_instptr()) != NULL) {</span>
<span class="line-modified">4956     // Compute array klass from element klass</span>
<span class="line-modified">4957     k_ary = ciObjArrayKlass::make(tinst-&gt;klass());</span>





4958   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
4959     // Compute array klass from element klass
4960     ciKlass* k_elem = tary-&gt;klass();
4961     // If element type is something like bottom[], k_elem will be null.
4962     if (k_elem != NULL)
4963       k_ary = ciObjArrayKlass::make(k_elem);
4964   } else if ((el-&gt;base() == Type::Top) ||
4965              (el-&gt;base() == Type::Bottom)) {
4966     // element type of Bottom occurs from meet of basic type
4967     // and object; Top occurs when doing join on Bottom.
4968     // Leave k_ary at NULL.
4969   } else {
4970     // Cannot compute array klass directly from basic type,
4971     // since subtypes of TypeInt all have basic type T_INT.
4972 #ifdef ASSERT
4973     if (verify &amp;&amp; el-&gt;isa_int()) {
4974       // Check simple cases when verifying klass.
4975       BasicType bt = T_ILLEGAL;
4976       if (el == TypeInt::BYTE) {
4977         bt = T_BYTE;
</pre>
<hr />
<pre>
5002 
5003   // Oops, need to compute _klass and cache it
5004   ciKlass* k_ary = compute_klass();
5005 
5006   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5007     // The _klass field acts as a cache of the underlying
5008     // ciKlass for this array type.  In order to set the field,
5009     // we need to cast away const-ness.
5010     //
5011     // IMPORTANT NOTE: we *never* set the _klass field for the
5012     // type TypeAryPtr::OOPS.  This Type is shared between all
5013     // active compilations.  However, the ciKlass which represents
5014     // this Type is *not* shared between compilations, so caching
5015     // this value would result in fetching a dangling pointer.
5016     //
5017     // Recomputing the underlying ciKlass for each request is
5018     // a bit less efficient than caching, but calls to
5019     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5020     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5021     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
<span class="line-modified">5022         _offset != 0 &amp;&amp; _offset != arrayOopDesc::length_offset_in_bytes()) {</span>
5023       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5024     }
5025   }
5026   return k_ary;
5027 }
5028 
5029 
5030 //------------------------------add_offset-------------------------------------
5031 // Access internals of klass object
5032 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
<span class="line-modified">5033   return make( _ptr, klass(), xadd_offset(offset) );</span>
5034 }
5035 
5036 //------------------------------cast_to_ptr_type-------------------------------
5037 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5038   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5039   if( ptr == _ptr ) return this;
<span class="line-modified">5040   return make(ptr, _klass, _offset);</span>
5041 }
5042 
5043 
5044 //-----------------------------cast_to_exactness-------------------------------
5045 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5046   if( klass_is_exact == _klass_is_exact ) return this;
5047   if (!UseExactTypes)  return this;
<span class="line-modified">5048   return make(klass_is_exact ? Constant : NotNull, _klass, _offset);</span>
5049 }
5050 
5051 
5052 //-----------------------------as_instance_type--------------------------------
5053 // Corresponding type for an instance of the given class.
5054 // It will be NotNull, and exact if and only if the klass type is exact.
5055 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5056   ciKlass* k = klass();

5057   bool    xk = klass_is_exact();
5058   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5059   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5060   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5061   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();



5062   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5063 }
5064 
5065 
5066 //------------------------------xmeet------------------------------------------
5067 // Compute the MEET of two types, return a new Type object.
5068 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5069   // Perform a fast test for common case; meeting the same types together.
5070   if( this == t ) return this;  // Meeting same type-rep?
5071 
5072   // Current &quot;this-&gt;_base&quot; is Pointer
5073   switch (t-&gt;base()) {          // switch on original type
5074 
5075   case Int:                     // Mixing ints &amp; oops happens when javac
5076   case Long:                    // reuses local variables
5077   case FloatTop:
5078   case FloatCon:
5079   case FloatBot:
5080   case DoubleTop:
5081   case DoubleCon:
5082   case DoubleBot:
5083   case NarrowOop:
5084   case NarrowKlass:
5085   case Bottom:                  // Ye Olde Default
5086     return Type::BOTTOM;
5087   case Top:
5088     return this;
5089 
5090   default:                      // All else is a mistake
5091     typerr(t);
5092 
5093   case AnyPtr: {                // Meeting to AnyPtrs
5094     // Found an AnyPtr type vs self-KlassPtr type
5095     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">5096     int offset = meet_offset(tp-&gt;offset());</span>
5097     PTR ptr = meet_ptr(tp-&gt;ptr());
5098     switch (tp-&gt;ptr()) {
5099     case TopPTR:
5100       return this;
5101     case Null:
5102       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5103     case AnyNull:
<span class="line-modified">5104       return make( ptr, klass(), offset );</span>
5105     case BotPTR:
5106     case NotNull:
5107       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5108     default: typerr(t);
5109     }
5110   }
5111 
5112   case RawPtr:
5113   case MetadataPtr:
5114   case OopPtr:
5115   case AryPtr:                  // Meet with AryPtr
5116   case InstPtr:                 // Meet with InstPtr
5117     return TypePtr::BOTTOM;
5118 
5119   //
5120   //             A-top         }
5121   //           /   |   \       }  Tops
5122   //       B-top A-any C-top   }
5123   //          | /  |  \ |      }  Any-nulls
5124   //       B-any   |   C-any   }
5125   //          |    |    |
5126   //       B-con A-con C-con   } constants; not comparable across classes
5127   //          |    |    |
5128   //       B-not   |   C-not   }
5129   //          | \  |  / |      }  not-nulls
5130   //       B-bot A-not C-bot   }
5131   //           \   |   /       }  Bottoms
5132   //             A-bot         }
5133   //
5134 
5135   case KlassPtr: {  // Meet two KlassPtr types
5136     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
<span class="line-modified">5137     int  off     = meet_offset(tkls-&gt;offset());</span>
5138     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5139 








5140     // Check for easy case; klasses are equal (and perhaps not loaded!)
5141     // If we have constants, then we created oops so classes are loaded
5142     // and we can handle the constants further down.  This case handles
5143     // not-loaded classes
<span class="line-modified">5144     if( ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) ) {</span>
<span class="line-modified">5145       return make( ptr, klass(), off );</span>
5146     }
5147 
5148     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5149     ciKlass* tkls_klass = tkls-&gt;klass();
5150     ciKlass* this_klass = this-&gt;klass();
5151     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5152     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);



5153 
5154     // If &#39;this&#39; type is above the centerline and is a superclass of the
5155     // other, we can treat &#39;this&#39; as having the same type as the other.
5156     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5157         tkls_klass-&gt;is_subtype_of(this_klass)) {
5158       this_klass = tkls_klass;
5159     }
5160     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5161     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5162     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5163         this_klass-&gt;is_subtype_of(tkls_klass)) {
5164       tkls_klass = this_klass;
5165     }
5166 
5167     // Check for classes now being equal
5168     if (tkls_klass-&gt;equals(this_klass)) {
5169       // If the klasses are equal, the constants may still differ.  Fall to
5170       // NotNull if they do (neither constant is NULL; that is a special case
5171       // handled elsewhere).
5172       if( ptr == Constant ) {
5173         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5174             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5175         else if (above_centerline(this-&gt;ptr()));
5176         else if (above_centerline(tkls-&gt;ptr()));
5177         else
5178           ptr = NotNull;
5179       }
<span class="line-modified">5180       return make( ptr, this_klass, off );</span>
5181     } // Else classes are not equal
5182 
5183     // Since klasses are different, we require the LCA in the Java
5184     // class hierarchy - which means we have to fall to at least NotNull.
5185     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5186       ptr = NotNull;
5187     // Now we find the LCA of Java classes
5188     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">5189     return   make( ptr, k, off );</span>
5190   } // End of case KlassPtr
5191 
5192   } // End of switch
5193   return this;                  // Return the double constant
5194 }
5195 
5196 //------------------------------xdual------------------------------------------
5197 // Dual: compute field-by-field dual
5198 const Type    *TypeKlassPtr::xdual() const {
<span class="line-modified">5199   return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );</span>
5200 }
5201 
5202 //------------------------------get_con----------------------------------------
5203 intptr_t TypeKlassPtr::get_con() const {
5204   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">5205   assert( _offset &gt;= 0, &quot;&quot; );</span>
5206 
<span class="line-modified">5207   if (_offset != 0) {</span>
5208     // After being ported to the compiler interface, the compiler no longer
5209     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5210     // to a handle at compile time.  This handle is embedded in the generated
5211     // code and dereferenced at the time the nmethod is made.  Until that time,
5212     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5213     // have access to the addresses!).  This does not seem to currently happen,
5214     // but this assertion here is to help prevent its occurence.
5215     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5216     ShouldNotReachHere();
5217   }
5218 
5219   return (intptr_t)klass()-&gt;constant_encoding();
5220 }
5221 //------------------------------dump2------------------------------------------
5222 // Dump Klass Type
5223 #ifndef PRODUCT
5224 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5225   switch( _ptr ) {
5226   case Constant:
5227     st-&gt;print(&quot;precise &quot;);
5228   case NotNull:
5229     {
<span class="line-modified">5230       const char *name = klass()-&gt;name()-&gt;as_utf8();</span>
<span class="line-modified">5231       if( name ) {</span>
5232         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5233       } else {
<span class="line-modified">5234         ShouldNotReachHere();</span>
5235       }
5236     }
5237   case BotPTR:
5238     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5239   case TopPTR:
5240   case AnyNull:
5241     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5242     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5243     break;
5244   default:
5245     break;
5246   }
5247 
<span class="line-modified">5248   if( _offset ) {               // Dump offset, if any</span>
<span class="line-removed">5249     if( _offset == OffsetBot )      { st-&gt;print(&quot;+any&quot;); }</span>
<span class="line-removed">5250     else if( _offset == OffsetTop ) { st-&gt;print(&quot;+unknown&quot;); }</span>
<span class="line-removed">5251     else                            { st-&gt;print(&quot;+%d&quot;, _offset); }</span>
<span class="line-removed">5252   }</span>
5253 
5254   st-&gt;print(&quot; *&quot;);
5255 }
5256 #endif
5257 
5258 
5259 
5260 //=============================================================================
5261 // Convenience common pre-built types.
5262 
5263 //------------------------------make-------------------------------------------
<span class="line-modified">5264 const TypeFunc *TypeFunc::make( const TypeTuple *domain, const TypeTuple *range ) {</span>
<span class="line-modified">5265   return (TypeFunc*)(new TypeFunc(domain,range))-&gt;hashcons();</span>












5266 }
5267 
5268 //------------------------------make-------------------------------------------
<span class="line-modified">5269 const TypeFunc *TypeFunc::make(ciMethod* method) {</span>
5270   Compile* C = Compile::current();
<span class="line-modified">5271   const TypeFunc* tf = C-&gt;last_tf(method); // check cache</span>
<span class="line-modified">5272   if (tf != NULL)  return tf;  // The hit rate here is almost 50%.</span>
<span class="line-modified">5273   const TypeTuple *domain;</span>
<span class="line-modified">5274   if (method-&gt;is_static()) {</span>
<span class="line-modified">5275     domain = TypeTuple::make_domain(NULL, method-&gt;signature());</span>
<span class="line-modified">5276   } else {</span>
<span class="line-modified">5277     domain = TypeTuple::make_domain(method-&gt;holder(), method-&gt;signature());</span>













5278   }
<span class="line-removed">5279   const TypeTuple *range  = TypeTuple::make_range(method-&gt;signature());</span>
<span class="line-removed">5280   tf = TypeFunc::make(domain, range);</span>
<span class="line-removed">5281   C-&gt;set_last_tf(method, tf);  // fill cache</span>
5282   return tf;
5283 }
5284 
5285 //------------------------------meet-------------------------------------------
5286 // Compute the MEET of two types.  It returns a new Type object.
5287 const Type *TypeFunc::xmeet( const Type *t ) const {
5288   // Perform a fast test for common case; meeting the same types together.
5289   if( this == t ) return this;  // Meeting same type-rep?
5290 
5291   // Current &quot;this-&gt;_base&quot; is Func
5292   switch (t-&gt;base()) {          // switch on original type
5293 
5294   case Bottom:                  // Ye Olde Default
5295     return t;
5296 
5297   default:                      // All else is a mistake
5298     typerr(t);
5299 
5300   case Top:
5301     break;
5302   }
5303   return this;                  // Return the double constant
5304 }
5305 
5306 //------------------------------xdual------------------------------------------
5307 // Dual: compute field-by-field dual
5308 const Type *TypeFunc::xdual() const {
5309   return this;
5310 }
5311 
5312 //------------------------------eq---------------------------------------------
5313 // Structural equality check for Type representations
5314 bool TypeFunc::eq( const Type *t ) const {
5315   const TypeFunc *a = (const TypeFunc*)t;
<span class="line-modified">5316   return _domain == a-&gt;_domain &amp;&amp;</span>
<span class="line-modified">5317     _range == a-&gt;_range;</span>


5318 }
5319 
5320 //------------------------------hash-------------------------------------------
5321 // Type-specific hashing function.
5322 int TypeFunc::hash(void) const {
<span class="line-modified">5323   return (intptr_t)_domain + (intptr_t)_range;</span>
5324 }
5325 
5326 //------------------------------dump2------------------------------------------
5327 // Dump Function Type
5328 #ifndef PRODUCT
5329 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
<span class="line-modified">5330   if( _range-&gt;cnt() &lt;= Parms )</span>
5331     st-&gt;print(&quot;void&quot;);
5332   else {
5333     uint i;
<span class="line-modified">5334     for (i = Parms; i &lt; _range-&gt;cnt()-1; i++) {</span>
<span class="line-modified">5335       _range-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
5336       st-&gt;print(&quot;/&quot;);
5337     }
<span class="line-modified">5338     _range-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
5339   }
5340   st-&gt;print(&quot; &quot;);
5341   st-&gt;print(&quot;( &quot;);
5342   if( !depth || d[this] ) {     // Check for recursive dump
5343     st-&gt;print(&quot;...)&quot;);
5344     return;
5345   }
5346   d.Insert((void*)this,(void*)this);    // Stop recursion
<span class="line-modified">5347   if (Parms &lt; _domain-&gt;cnt())</span>
<span class="line-modified">5348     _domain-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);</span>
<span class="line-modified">5349   for (uint i = Parms+1; i &lt; _domain-&gt;cnt(); i++) {</span>
5350     st-&gt;print(&quot;, &quot;);
<span class="line-modified">5351     _domain-&gt;field_at(i)-&gt;dump2(d,depth-1,st);</span>
5352   }
5353   st-&gt;print(&quot; )&quot;);
5354 }
5355 #endif
5356 
5357 //------------------------------singleton--------------------------------------
5358 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5359 // constants (Ldi nodes).  Singletons are integer, float or double constants
5360 // or a single symbol.
5361 bool TypeFunc::singleton(void) const {
5362   return false;                 // Never a singleton
5363 }
5364 
5365 bool TypeFunc::empty(void) const {
5366   return false;                 // Never empty
5367 }
5368 
5369 
5370 BasicType TypeFunc::return_type() const{
<span class="line-modified">5371   if (range()-&gt;cnt() == TypeFunc::Parms) {</span>
5372     return T_VOID;
5373   }
<span class="line-modified">5374   return range()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();</span>
5375 }
</pre>
</td>
<td>
<hr />
<pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
<span class="line-added">  26 #include &quot;ci/ciField.hpp&quot;</span>
  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciTypeFlow.hpp&quot;
<span class="line-added">  29 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;compiler/compileLog.hpp&quot;
  33 #include &quot;libadt/dict.hpp&quot;
  34 #include &quot;memory/oopFactory.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;oops/instanceKlass.hpp&quot;
  37 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;oops/typeArrayKlass.hpp&quot;
  40 #include &quot;opto/matcher.hpp&quot;
  41 #include &quot;opto/node.hpp&quot;
  42 #include &quot;opto/opcodes.hpp&quot;
  43 #include &quot;opto/type.hpp&quot;
  44 #include &quot;utilities/powerOfTwo.hpp&quot;
  45 
  46 // Portions of code courtesy of Clifford Click
  47 
  48 // Optimization - Graph Style
  49 
  50 // Dictionary of types shared among compilations.
  51 Dict* Type::_shared_type_dict = NULL;
<span class="line-added">  52 const Type::Offset Type::Offset::top(Type::OffsetTop);</span>
<span class="line-added">  53 const Type::Offset Type::Offset::bottom(Type::OffsetBot);</span>
<span class="line-added">  54 </span>
<span class="line-added">  55 const Type::Offset Type::Offset::meet(const Type::Offset other) const {</span>
<span class="line-added">  56   // Either is &#39;TOP&#39; offset?  Return the other offset!</span>
<span class="line-added">  57   int offset = other._offset;</span>
<span class="line-added">  58   if (_offset == OffsetTop) return Offset(offset);</span>
<span class="line-added">  59   if (offset == OffsetTop) return Offset(_offset);</span>
<span class="line-added">  60   // If either is different, return &#39;BOTTOM&#39; offset</span>
<span class="line-added">  61   if (_offset != offset) return bottom;</span>
<span class="line-added">  62   return Offset(_offset);</span>
<span class="line-added">  63 }</span>
<span class="line-added">  64 </span>
<span class="line-added">  65 const Type::Offset Type::Offset::dual() const {</span>
<span class="line-added">  66   if (_offset == OffsetTop) return bottom;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;</span>
<span class="line-added">  67   if (_offset == OffsetBot) return top;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;</span>
<span class="line-added">  68   return Offset(_offset);               // Map everything else into self</span>
<span class="line-added">  69 }</span>
<span class="line-added">  70 </span>
<span class="line-added">  71 const Type::Offset Type::Offset::add(intptr_t offset) const {</span>
<span class="line-added">  72   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!</span>
<span class="line-added">  73   if (_offset == OffsetTop || offset == OffsetTop) return top;</span>
<span class="line-added">  74   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!</span>
<span class="line-added">  75   if (_offset == OffsetBot || offset == OffsetBot) return bottom;</span>
<span class="line-added">  76   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!</span>
<span class="line-added">  77   offset += (intptr_t)_offset;</span>
<span class="line-added">  78   if (offset != (int)offset || offset == OffsetTop) return bottom;</span>
<span class="line-added">  79 </span>
<span class="line-added">  80   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );</span>
<span class="line-added">  81   // It is possible to construct a negative offset during PhaseCCP</span>
<span class="line-added">  82 </span>
<span class="line-added">  83   return Offset((int)offset);        // Sum valid offsets</span>
<span class="line-added">  84 }</span>
<span class="line-added">  85 </span>
<span class="line-added">  86 void Type::Offset::dump2(outputStream *st) const {</span>
<span class="line-added">  87   if (_offset == 0) {</span>
<span class="line-added">  88     return;</span>
<span class="line-added">  89   } else if (_offset == OffsetTop) {</span>
<span class="line-added">  90     st-&gt;print(&quot;+top&quot;);</span>
<span class="line-added">  91   }</span>
<span class="line-added">  92   else if (_offset == OffsetBot) {</span>
<span class="line-added">  93     st-&gt;print(&quot;+bot&quot;);</span>
<span class="line-added">  94   } else if (_offset) {</span>
<span class="line-added">  95     st-&gt;print(&quot;+%d&quot;, _offset);</span>
<span class="line-added">  96   }</span>
<span class="line-added">  97 }</span>
  98 
  99 // Array which maps compiler types to Basic Types
 100 const Type::TypeInfo Type::_type_info[Type::lastype] = {
 101   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
 102   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
 103   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
 104   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
 105   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
 106   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
 107   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
 108   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
 109   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
 110   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
 111 
 112 #if defined(PPC64)
 113   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 114   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 115   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 116   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 117   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 118 #elif defined(S390)
 119   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 120   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 121   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 122   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 123   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 124 #else // all other
 125   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 126   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 127   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 128   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 129   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 130 #endif
<span class="line-added"> 131   { Bad,             T_VALUETYPE,  &quot;value:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // ValueType</span>
 132   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 133   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 134   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 135   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 136   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 137   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 138   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 139   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 140   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 141   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 142   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 143   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 144   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 145   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 146   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 147   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 148   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 149   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 150 };
 151 
</pre>
<hr />
<pre>
 242   case ciTypeFlow::StateVector::T_NULL:
 243     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 244     return TypePtr::NULL_PTR;
 245 
 246   case ciTypeFlow::StateVector::T_LONG2:
 247     // The ciTypeFlow pass pushes a long, then the half.
 248     // We do the same.
 249     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 250     return TypeInt::TOP;
 251 
 252   case ciTypeFlow::StateVector::T_DOUBLE2:
 253     // The ciTypeFlow pass pushes double, then the half.
 254     // Our convention is the same.
 255     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 256     return Type::TOP;
 257 
 258   case T_ADDRESS:
 259     assert(type-&gt;is_return_address(), &quot;&quot;);
 260     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 261 
<span class="line-added"> 262   case T_VALUETYPE: {</span>
<span class="line-added"> 263     bool is_never_null = type-&gt;is_never_null();</span>
<span class="line-added"> 264     ciValueKlass* vk = type-&gt;unwrap()-&gt;as_value_klass();</span>
<span class="line-added"> 265     if (vk-&gt;is_scalarizable() &amp;&amp; is_never_null) {</span>
<span class="line-added"> 266       return TypeValueType::make(vk);</span>
<span class="line-added"> 267     } else {</span>
<span class="line-added"> 268       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(is_never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);</span>
<span class="line-added"> 269     }</span>
<span class="line-added"> 270   }</span>
<span class="line-added"> 271 </span>
 272   default:
 273     // make sure we did not mix up the cases:
 274     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 275     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 276     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 277     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 278     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 279     assert(!type-&gt;is_return_address(), &quot;&quot;);
 280 
 281     return Type::get_const_type(type);
 282   }
 283 }
 284 
 285 
 286 //-----------------------make_from_constant------------------------------------
 287 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 288                                      int stable_dimension, bool is_narrow_oop,
 289                                      bool is_autobox_cache) {
 290   switch (constant.basic_type()) {
 291     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 292     case T_CHAR:     return TypeInt::make(constant.as_char());
 293     case T_BYTE:     return TypeInt::make(constant.as_byte());
 294     case T_SHORT:    return TypeInt::make(constant.as_short());
 295     case T_INT:      return TypeInt::make(constant.as_int());
 296     case T_LONG:     return TypeLong::make(constant.as_long());
 297     case T_FLOAT:    return TypeF::make(constant.as_float());
 298     case T_DOUBLE:   return TypeD::make(constant.as_double());
 299     case T_ARRAY:
<span class="line-added"> 300     case T_VALUETYPE:</span>
 301     case T_OBJECT: {
 302         const Type* con_type = NULL;
 303         ciObject* oop_constant = constant.as_object();
 304         if (oop_constant-&gt;is_null_object()) {
 305           con_type = Type::get_zero_type(T_OBJECT);
 306         } else {
 307           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 308           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 309           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 310             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 311           }
 312           if (stable_dimension &gt; 0) {
 313             assert(FoldStableValues, &quot;sanity&quot;);
 314             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 315             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 316           }
 317         }
 318         if (is_narrow_oop) {
 319           con_type = con_type-&gt;make_narrowoop();
 320         }
 321         return con_type;
 322       }
 323     case T_ILLEGAL:
 324       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 325       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 326       return NULL;
 327     default:
 328       // Fall through to failure
 329       return NULL;
 330   }
 331 }
 332 
 333 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 334   BasicType conbt = con.basic_type();
 335   switch (conbt) {
 336     case T_BOOLEAN: conbt = T_BYTE;   break;
 337     case T_ARRAY:   conbt = T_OBJECT; break;
<span class="line-added"> 338     case T_VALUETYPE: conbt = T_OBJECT; break;</span>
 339     default:                          break;
 340   }
 341   switch (loadbt) {
 342     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 343     case T_NARROWOOP: loadbt = T_OBJECT; break;
 344     case T_ARRAY:     loadbt = T_OBJECT; break;
<span class="line-added"> 345     case T_VALUETYPE: loadbt = T_OBJECT; break;</span>
 346     case T_ADDRESS:   loadbt = T_OBJECT; break;
 347     default:                             break;
 348   }
 349   if (conbt == loadbt) {
 350     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 351       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 352       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 353     } else {
 354       return con;
 355     }
 356   }
 357   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 358     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 359     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 360   }
 361   return ciConstant(); // T_ILLEGAL
 362 }
 363 
 364 // Try to constant-fold a stable array element.
 365 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
</pre>
<hr />
<pre>
 553   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 554   ffalse[0] = Type::CONTROL;
 555   ffalse[1] = Type::TOP;
 556   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 557 
 558   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 559   fneither[0] = Type::TOP;
 560   fneither[1] = Type::TOP;
 561   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 562 
 563   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 564   ftrue[0] = Type::TOP;
 565   ftrue[1] = Type::CONTROL;
 566   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 567 
 568   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 569   floop[0] = Type::CONTROL;
 570   floop[1] = TypeInt::INT;
 571   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 572 
<span class="line-modified"> 573   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));</span>
<span class="line-modified"> 574   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);</span>
<span class="line-modified"> 575   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);</span>
 576 
 577   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 578   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 579 
 580   const Type **fmembar = TypeTuple::fields(0);
 581   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 582 
 583   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 584   fsc[0] = TypeInt::CC;
 585   fsc[1] = Type::MEMORY;
 586   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 587 
 588   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 589   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 590   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 591   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 592                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);</span>
 593   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 594                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);</span>
<span class="line-modified"> 595   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);</span>
<span class="line-added"> 596 </span>
<span class="line-added"> 597   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);</span>
 598 
<span class="line-modified"> 599   TypeValueType::BOTTOM = TypeValueType::make(NULL);</span>
 600 
 601   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 602   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 603 
 604   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 605 
 606   mreg2type[Op_Node] = Type::BOTTOM;
 607   mreg2type[Op_Set ] = 0;
 608   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 609   mreg2type[Op_RegI] = TypeInt::INT;
 610   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 611   mreg2type[Op_RegF] = Type::FLOAT;
 612   mreg2type[Op_RegD] = Type::DOUBLE;
 613   mreg2type[Op_RegL] = TypeLong::LONG;
 614   mreg2type[Op_RegFlags] = TypeInt::CC;
 615 
<span class="line-modified"> 616   TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, Offset(arrayOopDesc::length_offset_in_bytes()));</span>
 617 
<span class="line-modified"> 618   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);</span>
 619 
 620 #ifdef _LP64
 621   if (UseCompressedOops) {
 622     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 623     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 624   } else
 625 #endif
 626   {
 627     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
<span class="line-modified"> 628     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);</span>
 629   }
<span class="line-modified"> 630   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);</span>
<span class="line-modified"> 631   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);</span>
<span class="line-modified"> 632   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);</span>
<span class="line-modified"> 633   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);</span>
<span class="line-modified"> 634   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);</span>
<span class="line-modified"> 635   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);</span>
<span class="line-modified"> 636   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);</span>
<span class="line-added"> 637   TypeAryPtr::VALUES  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeValueType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);</span>
 638 
 639   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 640   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 641   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
<span class="line-added"> 642   TypeAryPtr::_array_body_type[T_VALUETYPE] = TypeAryPtr::OOPS;</span>
 643   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 644   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 645   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 646   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 647   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 648   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 649   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 650   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 651   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 652 
<span class="line-modified"> 653   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);</span>
<span class="line-modified"> 654   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);</span>
 655 
 656   const Type **fi2c = TypeTuple::fields(2);
 657   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 658   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 659   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 660 
 661   const Type **intpair = TypeTuple::fields(2);
 662   intpair[0] = TypeInt::INT;
 663   intpair[1] = TypeInt::INT;
 664   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 665 
 666   const Type **longpair = TypeTuple::fields(2);
 667   longpair[0] = TypeLong::LONG;
 668   longpair[1] = TypeLong::LONG;
 669   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 670 
 671   const Type **intccpair = TypeTuple::fields(2);
 672   intccpair[0] = TypeInt::INT;
 673   intccpair[1] = TypeInt::CC;
 674   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 675 
 676   const Type **longccpair = TypeTuple::fields(2);
 677   longccpair[0] = TypeLong::LONG;
 678   longccpair[1] = TypeInt::CC;
 679   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 680 
 681   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 682   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 683   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 684   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 685   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 686   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 687   _const_basic_type[T_INT]         = TypeInt::INT;
 688   _const_basic_type[T_LONG]        = TypeLong::LONG;
 689   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 690   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 691   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 692   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
<span class="line-added"> 693   _const_basic_type[T_VALUETYPE]   = TypeInstPtr::BOTTOM;</span>
 694   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 695   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 696   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 697 
 698   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 699   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 700   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 701   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 702   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 703   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 704   _zero_type[T_INT]         = TypeInt::ZERO;
 705   _zero_type[T_LONG]        = TypeLong::ZERO;
 706   _zero_type[T_FLOAT]       = TypeF::ZERO;
 707   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 708   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 709   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
<span class="line-added"> 710   _zero_type[T_VALUETYPE]   = TypePtr::NULL_PTR;</span>
 711   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 712   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 713 
 714   // get_zero_type() should not happen for T_CONFLICT
 715   _zero_type[T_CONFLICT]= NULL;
 716 
 717   // Vector predefined types, it needs initialized _const_basic_type[].
 718   if (Matcher::vector_size_supported(T_BYTE,4)) {
 719     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 720   }
 721   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 722     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 723   }
 724   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 725     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 726   }
 727   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 728     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 729   }
 730   if (Matcher::vector_size_supported(T_FLOAT,16)) {
</pre>
<hr />
<pre>
 866   }
 867   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 868     return true;
 869   }
 870   return false;
 871 }
 872 
 873 #endif
 874 
 875 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 876 #ifdef ASSERT
 877   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 878   const Type* dual_join = mt-&gt;_dual;
 879   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 880   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 881 
 882   // Interface meet Oop is Not Symmetric:
 883   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 884   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 885 
<span class="line-modified"> 886   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual)) {</span>
 887     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 888     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 889     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 890     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 891 
 892     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 893     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 894     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 895 
 896     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 897     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 898 
 899     fatal(&quot;meet not symmetric&quot; );
 900   }
 901 #endif
 902 }
 903 
 904 //------------------------------meet-------------------------------------------
 905 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 906 // commutative and the lattice is symmetric.
</pre>
<hr />
<pre>
 970 
 971   case OopPtr:
 972     return t-&gt;xmeet(this);
 973 
 974   case InstPtr:
 975     return t-&gt;xmeet(this);
 976 
 977   case MetadataPtr:
 978   case KlassPtr:
 979     return t-&gt;xmeet(this);
 980 
 981   case AryPtr:
 982     return t-&gt;xmeet(this);
 983 
 984   case NarrowOop:
 985     return t-&gt;xmeet(this);
 986 
 987   case NarrowKlass:
 988     return t-&gt;xmeet(this);
 989 
<span class="line-added"> 990   case ValueType:</span>
<span class="line-added"> 991     return t-&gt;xmeet(this);</span>
<span class="line-added"> 992 </span>
 993   case Bad:                     // Type check
 994   default:                      // Bogus type not in lattice
 995     typerr(t);
 996     return Type::BOTTOM;
 997 
 998   case Bottom:                  // Ye Olde Default
 999     return t;
1000 
1001   case FloatTop:
1002     if( _base == FloatTop ) return this;
1003   case FloatBot:                // Float
1004     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
1005     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
1006     typerr(t);
1007     return Type::BOTTOM;
1008 
1009   case DoubleTop:
1010     if( _base == DoubleTop ) return this;
1011   case DoubleBot:               // Double
1012     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
</pre>
<hr />
<pre>
1040 
1041 //------------------------------xdual------------------------------------------
1042 // Compute dual right now.
1043 const Type::TYPES Type::dual_type[Type::lastype] = {
1044   Bad,          // Bad
1045   Control,      // Control
1046   Bottom,       // Top
1047   Bad,          // Int - handled in v-call
1048   Bad,          // Long - handled in v-call
1049   Half,         // Half
1050   Bad,          // NarrowOop - handled in v-call
1051   Bad,          // NarrowKlass - handled in v-call
1052 
1053   Bad,          // Tuple - handled in v-call
1054   Bad,          // Array - handled in v-call
1055   Bad,          // VectorS - handled in v-call
1056   Bad,          // VectorD - handled in v-call
1057   Bad,          // VectorX - handled in v-call
1058   Bad,          // VectorY - handled in v-call
1059   Bad,          // VectorZ - handled in v-call
<span class="line-added">1060   Bad,          // ValueType - handled in v-call</span>
1061 
1062   Bad,          // AnyPtr - handled in v-call
1063   Bad,          // RawPtr - handled in v-call
1064   Bad,          // OopPtr - handled in v-call
1065   Bad,          // InstPtr - handled in v-call
1066   Bad,          // AryPtr - handled in v-call
1067 
1068   Bad,          //  MetadataPtr - handled in v-call
1069   Bad,          // KlassPtr - handled in v-call
1070 
1071   Bad,          // Function - handled in v-call
1072   Abio,         // Abio
1073   Return_Address,// Return_Address
1074   Memory,       // Memory
1075   FloatBot,     // FloatTop
1076   FloatCon,     // FloatCon
1077   FloatTop,     // FloatBot
1078   DoubleBot,    // DoubleTop
1079   DoubleCon,    // DoubleCon
1080   DoubleTop,    // DoubleBot
</pre>
<hr />
<pre>
1936 
1937 bool TypeLong::empty(void) const {
1938   return _lo &gt; _hi;
1939 }
1940 
1941 //=============================================================================
1942 // Convenience common pre-built types.
1943 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1944 const TypeTuple *TypeTuple::IFFALSE;
1945 const TypeTuple *TypeTuple::IFTRUE;
1946 const TypeTuple *TypeTuple::IFNEITHER;
1947 const TypeTuple *TypeTuple::LOOPBODY;
1948 const TypeTuple *TypeTuple::MEMBAR;
1949 const TypeTuple *TypeTuple::STORECONDITIONAL;
1950 const TypeTuple *TypeTuple::START_I2C;
1951 const TypeTuple *TypeTuple::INT_PAIR;
1952 const TypeTuple *TypeTuple::LONG_PAIR;
1953 const TypeTuple *TypeTuple::INT_CC_PAIR;
1954 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1955 
<span class="line-added">1956 static void collect_value_fields(ciValueKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {</span>
<span class="line-added">1957   for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {</span>
<span class="line-added">1958     ciField* field = vk-&gt;nonstatic_field_at(j);</span>
<span class="line-added">1959     BasicType bt = field-&gt;type()-&gt;basic_type();</span>
<span class="line-added">1960     const Type* ft = Type::get_const_type(field-&gt;type());</span>
<span class="line-added">1961     field_array[pos++] = ft;</span>
<span class="line-added">1962     if (type2size[bt] == 2) {</span>
<span class="line-added">1963       field_array[pos++] = Type::HALF;</span>
<span class="line-added">1964     }</span>
<span class="line-added">1965     // Skip reserved arguments</span>
<span class="line-added">1966     while (SigEntry::next_is_reserved(sig_cc, bt)) {</span>
<span class="line-added">1967       field_array[pos++] = Type::get_const_basic_type(bt);</span>
<span class="line-added">1968       if (type2size[bt] == 2) {</span>
<span class="line-added">1969         field_array[pos++] = Type::HALF;</span>
<span class="line-added">1970       }</span>
<span class="line-added">1971     }</span>
<span class="line-added">1972   }</span>
<span class="line-added">1973 }</span>
1974 
1975 //------------------------------make-------------------------------------------
1976 // Make a TypeTuple from the range of a method signature
<span class="line-modified">1977 const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {</span>
1978   ciType* return_type = sig-&gt;return_type();
1979   uint arg_cnt = return_type-&gt;size();
<span class="line-added">1980   if (ret_vt_fields) {</span>
<span class="line-added">1981     arg_cnt = return_type-&gt;as_value_klass()-&gt;value_arg_slots() + 1;</span>
<span class="line-added">1982   }</span>
<span class="line-added">1983 </span>
1984   const Type **field_array = fields(arg_cnt);
1985   switch (return_type-&gt;basic_type()) {
1986   case T_LONG:
1987     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1988     field_array[TypeFunc::Parms+1] = Type::HALF;
1989     break;
1990   case T_DOUBLE:
1991     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1992     field_array[TypeFunc::Parms+1] = Type::HALF;
1993     break;
1994   case T_OBJECT:
1995   case T_ARRAY:
1996   case T_BOOLEAN:
1997   case T_CHAR:
1998   case T_FLOAT:
1999   case T_BYTE:
2000   case T_SHORT:
2001   case T_INT:
2002     field_array[TypeFunc::Parms] = get_const_type(return_type);
2003     break;
<span class="line-added">2004   case T_VALUETYPE:</span>
<span class="line-added">2005     if (ret_vt_fields) {</span>
<span class="line-added">2006       uint pos = TypeFunc::Parms;</span>
<span class="line-added">2007       field_array[pos] = TypePtr::BOTTOM;</span>
<span class="line-added">2008       pos++;</span>
<span class="line-added">2009       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());</span>
<span class="line-added">2010       collect_value_fields(return_type-&gt;as_value_klass(), field_array, pos, sig);</span>
<span class="line-added">2011     } else {</span>
<span class="line-added">2012       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(sig-&gt;returns_never_null() ? TypePtr::NOTNULL : TypePtr::BOTTOM);</span>
<span class="line-added">2013     }</span>
<span class="line-added">2014     break;</span>
2015   case T_VOID:
2016     break;
2017   default:
2018     ShouldNotReachHere();
2019   }
2020   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2021 }
2022 
2023 // Make a TypeTuple from the domain of a method signature
<span class="line-modified">2024 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {</span>
<span class="line-modified">2025   ciSignature* sig = method-&gt;signature();</span>
<span class="line-added">2026   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());</span>
<span class="line-added">2027 </span>
<span class="line-added">2028   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);</span>
<span class="line-added">2029   if (vt_fields_as_args) {</span>
<span class="line-added">2030     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {</span>
<span class="line-added">2031       arg_cnt += type2size[(*sig_cc)._bt];</span>
<span class="line-added">2032     }</span>
<span class="line-added">2033     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());</span>
<span class="line-added">2034   }</span>
2035 
2036   uint pos = TypeFunc::Parms;
<span class="line-modified">2037   const Type** field_array = fields(arg_cnt);</span>
<span class="line-modified">2038   if (!method-&gt;is_static()) {</span>
<span class="line-modified">2039     ciInstanceKlass* recv = method-&gt;holder();</span>
<span class="line-modified">2040     if (vt_fields_as_args &amp;&amp; recv-&gt;is_valuetype() &amp;&amp; recv-&gt;as_value_klass()-&gt;is_scalarizable()) {</span>
<span class="line-modified">2041       collect_value_fields(recv-&gt;as_value_klass(), field_array, pos, sig_cc);</span>
<span class="line-modified">2042     } else {</span>
<span class="line-modified">2043       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="line-modified">2044       if (vt_fields_as_args) {</span>
<span class="line-added">2045         ++sig_cc;</span>
<span class="line-added">2046       }</span>
<span class="line-added">2047     }</span>
2048   }
2049 
2050   int i = 0;
2051   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2052     ciType* type = sig-&gt;type_at(i);
<span class="line-added">2053     BasicType bt = type-&gt;basic_type();</span>
<span class="line-added">2054     bool is_flattened = false;</span>
2055 
<span class="line-modified">2056     switch (bt) {</span>
2057     case T_LONG:
2058       field_array[pos++] = TypeLong::LONG;
2059       field_array[pos++] = Type::HALF;
2060       break;
2061     case T_DOUBLE:
2062       field_array[pos++] = Type::DOUBLE;
2063       field_array[pos++] = Type::HALF;
2064       break;
2065     case T_OBJECT:
2066     case T_ARRAY:
2067     case T_FLOAT:
2068     case T_INT:
2069       field_array[pos++] = get_const_type(type);
2070       break;
2071     case T_BOOLEAN:
2072     case T_CHAR:
2073     case T_BYTE:
2074     case T_SHORT:
2075       field_array[pos++] = TypeInt::INT;
2076       break;
<span class="line-added">2077     case T_VALUETYPE: {</span>
<span class="line-added">2078       bool never_null = sig-&gt;is_never_null_at(i);</span>
<span class="line-added">2079       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;is_scalarizable() &amp;&amp; never_null) {</span>
<span class="line-added">2080         is_flattened = true;</span>
<span class="line-added">2081         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);</span>
<span class="line-added">2082       } else {</span>
<span class="line-added">2083         field_array[pos++] = get_const_type(type)-&gt;join_speculative(never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);</span>
<span class="line-added">2084       }</span>
<span class="line-added">2085       break;</span>
<span class="line-added">2086     }</span>
2087     default:
2088       ShouldNotReachHere();
2089     }
<span class="line-added">2090     // Skip reserved arguments</span>
<span class="line-added">2091     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {</span>
<span class="line-added">2092       field_array[pos++] = Type::get_const_basic_type(bt);</span>
<span class="line-added">2093       if (type2size[bt] == 2) {</span>
<span class="line-added">2094         field_array[pos++] = Type::HALF;</span>
<span class="line-added">2095       }</span>
<span class="line-added">2096     }</span>
2097     i++;
2098   }
<span class="line-added">2099   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);</span>
2100 
2101   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2102 }
2103 
2104 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
2105   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
2106 }
2107 
2108 //------------------------------fields-----------------------------------------
2109 // Subroutine call type with space allocated for argument types
2110 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
2111 const Type **TypeTuple::fields( uint arg_cnt ) {
2112   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
2113   flds[TypeFunc::Control  ] = Type::CONTROL;
2114   flds[TypeFunc::I_O      ] = Type::ABIO;
2115   flds[TypeFunc::Memory   ] = Type::MEMORY;
2116   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
2117   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
2118 
2119   return flds;
</pre>
<hr />
<pre>
2214     if (_fields[i]-&gt;empty())  return true;
2215   }
2216   return false;
2217 }
2218 
2219 //=============================================================================
2220 // Convenience common pre-built types.
2221 
2222 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2223   // Certain normalizations keep us sane when comparing types.
2224   // We do not want arrayOop variables to differ only by the wideness
2225   // of their index types.  Pick minimum wideness, since that is the
2226   // forced wideness of small ranges anyway.
2227   if (size-&gt;_widen != Type::WidenMin)
2228     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2229   else
2230     return size;
2231 }
2232 
2233 //------------------------------make-------------------------------------------
<span class="line-modified">2234 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable,</span>
<span class="line-added">2235                              bool not_flat, bool not_null_free) {</span>
2236   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2237     elem = elem-&gt;make_narrowoop();
2238   }
2239   size = normalize_array_size(size);
<span class="line-modified">2240   return (TypeAry*)(new TypeAry(elem, size, stable, not_flat, not_null_free))-&gt;hashcons();</span>
2241 }
2242 
2243 //------------------------------meet-------------------------------------------
2244 // Compute the MEET of two types.  It returns a new Type object.
2245 const Type *TypeAry::xmeet( const Type *t ) const {
2246   // Perform a fast test for common case; meeting the same types together.
2247   if( this == t ) return this;  // Meeting same type-rep?
2248 
2249   // Current &quot;this-&gt;_base&quot; is Ary
2250   switch (t-&gt;base()) {          // switch on original type
2251 
2252   case Bottom:                  // Ye Olde Default
2253     return t;
2254 
2255   default:                      // All else is a mistake
2256     typerr(t);
2257 
2258   case Array: {                 // Meeting 2 arrays?
2259     const TypeAry *a = t-&gt;is_ary();
2260     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2261                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
<span class="line-modified">2262                          _stable &amp;&amp; a-&gt;_stable,</span>
<span class="line-added">2263                          _not_flat &amp;&amp; a-&gt;_not_flat,</span>
<span class="line-added">2264                          _not_null_free &amp;&amp; a-&gt;_not_null_free);</span>
2265   }
2266   case Top:
2267     break;
2268   }
2269   return this;                  // Return the double constant
2270 }
2271 
2272 //------------------------------xdual------------------------------------------
2273 // Dual: compute field-by-field dual
2274 const Type *TypeAry::xdual() const {
2275   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2276   size_dual = normalize_array_size(size_dual);
<span class="line-modified">2277   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable, !_not_flat, !_not_null_free);</span>
2278 }
2279 
2280 //------------------------------eq---------------------------------------------
2281 // Structural equality check for Type representations
2282 bool TypeAry::eq( const Type *t ) const {
2283   const TypeAry *a = (const TypeAry*)t;
2284   return _elem == a-&gt;_elem &amp;&amp;
2285     _stable == a-&gt;_stable &amp;&amp;
<span class="line-modified">2286     _size == a-&gt;_size &amp;&amp;</span>
<span class="line-added">2287     _not_flat == a-&gt;_not_flat &amp;&amp;</span>
<span class="line-added">2288     _not_null_free == a-&gt;_not_null_free;</span>
<span class="line-added">2289 </span>
2290 }
2291 
2292 //------------------------------hash-------------------------------------------
2293 // Type-specific hashing function.
2294 int TypeAry::hash(void) const {
2295   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2296 }
2297 
2298 /**
2299  * Return same type without a speculative part in the element
2300  */
2301 const Type* TypeAry::remove_speculative() const {
<span class="line-modified">2302   return make(_elem-&gt;remove_speculative(), _size, _stable, _not_flat, _not_null_free);</span>
2303 }
2304 
2305 /**
2306  * Return same type with cleaned up speculative part of element
2307  */
2308 const Type* TypeAry::cleanup_speculative() const {
<span class="line-modified">2309   return make(_elem-&gt;cleanup_speculative(), _size, _stable, _not_flat, _not_null_free);</span>
2310 }
2311 
2312 /**
2313  * Return same type but with a different inline depth (used for speculation)
2314  *
2315  * @param depth  depth to meet with
2316  */
2317 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2318   if (!UseInlineDepthForSpeculativeTypes) {
2319     return this;
2320   }
2321   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2322 }
2323 
2324 //----------------------interface_vs_oop---------------------------------------
2325 #ifdef ASSERT
2326 bool TypeAry::interface_vs_oop(const Type *t) const {
2327   const TypeAry* t_ary = t-&gt;is_ary();
2328   if (t_ary) {
2329     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2330     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2331     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2332       return this_ptr-&gt;interface_vs_oop(t_ptr);
2333     }
2334   }
2335   return false;
2336 }
2337 #endif
2338 
2339 //------------------------------dump2------------------------------------------
2340 #ifndef PRODUCT
2341 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2342   if (_stable)  st-&gt;print(&quot;stable:&quot;);
<span class="line-added">2343   if (Verbose) {</span>
<span class="line-added">2344     if (_not_flat) st-&gt;print(&quot;not flat:&quot;);</span>
<span class="line-added">2345     if (_not_null_free) st-&gt;print(&quot;not null free:&quot;);</span>
<span class="line-added">2346   }</span>
2347   _elem-&gt;dump2(d, depth, st);
2348   st-&gt;print(&quot;[&quot;);
2349   _size-&gt;dump2(d, depth, st);
2350   st-&gt;print(&quot;]&quot;);
2351 }
2352 #endif
2353 
2354 //------------------------------singleton--------------------------------------
2355 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2356 // constants (Ldi nodes).  Singletons are integer, float or double constants
2357 // or a single symbol.
2358 bool TypeAry::singleton(void) const {
2359   return false;                 // Never a singleton
2360 }
2361 
2362 bool TypeAry::empty(void) const {
2363   return _elem-&gt;empty() || _size-&gt;empty();
2364 }
2365 
2366 //--------------------------ary_must_be_exact----------------------------------
</pre>
<hr />
<pre>
2381   ciKlass* tklass = toop-&gt;klass();
2382   if (tklass == NULL)       return false;  // unloaded class
2383   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2384   const TypeInstPtr* tinst;
2385   if (_elem-&gt;isa_narrowoop())
2386     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2387   else
2388     tinst = _elem-&gt;isa_instptr();
2389   if (tinst)
2390     return tklass-&gt;as_instance_klass()-&gt;is_final();
2391   const TypeAryPtr*  tap;
2392   if (_elem-&gt;isa_narrowoop())
2393     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2394   else
2395     tap = _elem-&gt;isa_aryptr();
2396   if (tap)
2397     return tap-&gt;ary()-&gt;ary_must_be_exact();
2398   return false;
2399 }
2400 
<span class="line-added">2401 //==============================TypeValueType=======================================</span>
<span class="line-added">2402 </span>
<span class="line-added">2403 const TypeValueType *TypeValueType::BOTTOM;</span>
<span class="line-added">2404 </span>
<span class="line-added">2405 //------------------------------make-------------------------------------------</span>
<span class="line-added">2406 const TypeValueType* TypeValueType::make(ciValueKlass* vk, bool larval) {</span>
<span class="line-added">2407   return (TypeValueType*)(new TypeValueType(vk, larval))-&gt;hashcons();</span>
<span class="line-added">2408 }</span>
<span class="line-added">2409 </span>
<span class="line-added">2410 //------------------------------meet-------------------------------------------</span>
<span class="line-added">2411 // Compute the MEET of two types.  It returns a new Type object.</span>
<span class="line-added">2412 const Type* TypeValueType::xmeet(const Type* t) const {</span>
<span class="line-added">2413   // Perform a fast test for common case; meeting the same types together.</span>
<span class="line-added">2414   if(this == t) return this;  // Meeting same type-rep?</span>
<span class="line-added">2415 </span>
<span class="line-added">2416   // Current &quot;this-&gt;_base&quot; is ValueType</span>
<span class="line-added">2417   switch (t-&gt;base()) {          // switch on original type</span>
<span class="line-added">2418 </span>
<span class="line-added">2419   case Int:</span>
<span class="line-added">2420   case Long:</span>
<span class="line-added">2421   case FloatTop:</span>
<span class="line-added">2422   case FloatCon:</span>
<span class="line-added">2423   case FloatBot:</span>
<span class="line-added">2424   case DoubleTop:</span>
<span class="line-added">2425   case DoubleCon:</span>
<span class="line-added">2426   case DoubleBot:</span>
<span class="line-added">2427   case NarrowKlass:</span>
<span class="line-added">2428   case Bottom:</span>
<span class="line-added">2429     return Type::BOTTOM;</span>
<span class="line-added">2430 </span>
<span class="line-added">2431   case OopPtr:</span>
<span class="line-added">2432   case MetadataPtr:</span>
<span class="line-added">2433   case KlassPtr:</span>
<span class="line-added">2434   case RawPtr:</span>
<span class="line-added">2435     return TypePtr::BOTTOM;</span>
<span class="line-added">2436 </span>
<span class="line-added">2437   case Top:</span>
<span class="line-added">2438     return this;</span>
<span class="line-added">2439 </span>
<span class="line-added">2440   case NarrowOop: {</span>
<span class="line-added">2441     const Type* res = t-&gt;make_ptr()-&gt;xmeet(this);</span>
<span class="line-added">2442     if (res-&gt;isa_ptr()) {</span>
<span class="line-added">2443       return res-&gt;make_narrowoop();</span>
<span class="line-added">2444     }</span>
<span class="line-added">2445     return res;</span>
<span class="line-added">2446   }</span>
<span class="line-added">2447 </span>
<span class="line-added">2448   case AryPtr:</span>
<span class="line-added">2449   case InstPtr: {</span>
<span class="line-added">2450     return t-&gt;xmeet(this);</span>
<span class="line-added">2451   }</span>
<span class="line-added">2452 </span>
<span class="line-added">2453   case ValueType: {</span>
<span class="line-added">2454     // All value types inherit from Object</span>
<span class="line-added">2455     const TypeValueType* other = t-&gt;is_valuetype();</span>
<span class="line-added">2456     if (_vk == NULL) {</span>
<span class="line-added">2457       return this;</span>
<span class="line-added">2458     } else if (other-&gt;_vk == NULL) {</span>
<span class="line-added">2459       return other;</span>
<span class="line-added">2460     } else if (_vk == other-&gt;_vk) {</span>
<span class="line-added">2461       if (_larval == other-&gt;_larval ||</span>
<span class="line-added">2462           !_larval) {</span>
<span class="line-added">2463         return this;</span>
<span class="line-added">2464       } else {</span>
<span class="line-added">2465         return t;</span>
<span class="line-added">2466       }</span>
<span class="line-added">2467     }</span>
<span class="line-added">2468     return TypeInstPtr::NOTNULL;</span>
<span class="line-added">2469   }</span>
<span class="line-added">2470 </span>
<span class="line-added">2471   default:                      // All else is a mistake</span>
<span class="line-added">2472     typerr(t);</span>
<span class="line-added">2473 </span>
<span class="line-added">2474   }</span>
<span class="line-added">2475   return this;</span>
<span class="line-added">2476 }</span>
<span class="line-added">2477 </span>
<span class="line-added">2478 //------------------------------xdual------------------------------------------</span>
<span class="line-added">2479 const Type* TypeValueType::xdual() const {</span>
<span class="line-added">2480   return this;</span>
<span class="line-added">2481 }</span>
<span class="line-added">2482 </span>
<span class="line-added">2483 //------------------------------eq---------------------------------------------</span>
<span class="line-added">2484 // Structural equality check for Type representations</span>
<span class="line-added">2485 bool TypeValueType::eq(const Type* t) const {</span>
<span class="line-added">2486   const TypeValueType* vt = t-&gt;is_valuetype();</span>
<span class="line-added">2487   return (_vk == vt-&gt;value_klass() &amp;&amp; _larval == vt-&gt;larval());</span>
<span class="line-added">2488 }</span>
<span class="line-added">2489 </span>
<span class="line-added">2490 //------------------------------hash-------------------------------------------</span>
<span class="line-added">2491 // Type-specific hashing function.</span>
<span class="line-added">2492 int TypeValueType::hash(void) const {</span>
<span class="line-added">2493   return (intptr_t)_vk;</span>
<span class="line-added">2494 }</span>
<span class="line-added">2495 </span>
<span class="line-added">2496 //------------------------------singleton--------------------------------------</span>
<span class="line-added">2497 // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.</span>
<span class="line-added">2498 bool TypeValueType::singleton(void) const {</span>
<span class="line-added">2499   return false;</span>
<span class="line-added">2500 }</span>
<span class="line-added">2501 </span>
<span class="line-added">2502 //------------------------------empty------------------------------------------</span>
<span class="line-added">2503 // TRUE if Type is a type with no values, FALSE otherwise.</span>
<span class="line-added">2504 bool TypeValueType::empty(void) const {</span>
<span class="line-added">2505   return false;</span>
<span class="line-added">2506 }</span>
<span class="line-added">2507 </span>
<span class="line-added">2508 //------------------------------dump2------------------------------------------</span>
<span class="line-added">2509 #ifndef PRODUCT</span>
<span class="line-added">2510 void TypeValueType::dump2(Dict &amp;d, uint depth, outputStream* st) const {</span>
<span class="line-added">2511   if (_vk == NULL) {</span>
<span class="line-added">2512     st-&gt;print(&quot;BOTTOM valuetype&quot;);</span>
<span class="line-added">2513     return;</span>
<span class="line-added">2514   }</span>
<span class="line-added">2515   int count = _vk-&gt;nof_declared_nonstatic_fields();</span>
<span class="line-added">2516   st-&gt;print(&quot;valuetype[%d]:{&quot;, count);</span>
<span class="line-added">2517   st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);</span>
<span class="line-added">2518   for (int i = 1; i &lt; count; ++i) {</span>
<span class="line-added">2519     st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());</span>
<span class="line-added">2520   }</span>
<span class="line-added">2521   st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);</span>
<span class="line-added">2522 }</span>
<span class="line-added">2523 #endif</span>
<span class="line-added">2524 </span>
2525 //==============================TypeVect=======================================
2526 // Convenience common pre-built types.
2527 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2528 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2529 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2530 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2531 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2532 
2533 //------------------------------make-------------------------------------------
2534 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2535   BasicType elem_bt = elem-&gt;array_element_basic_type();
2536   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2537   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2538   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2539   int size = length * type2aelembytes(elem_bt);
2540   switch (Matcher::vector_ideal_reg(size)) {
2541   case Op_VecS:
2542     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2543   case Op_RegL:
2544   case Op_VecD:
</pre>
<hr />
<pre>
2646 
2647 //=============================================================================
2648 // Convenience common pre-built types.
2649 const TypePtr *TypePtr::NULL_PTR;
2650 const TypePtr *TypePtr::NOTNULL;
2651 const TypePtr *TypePtr::BOTTOM;
2652 
2653 //------------------------------meet-------------------------------------------
2654 // Meet over the PTR enum
2655 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2656   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2657   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2658   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2659   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2660   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2661   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2662   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2663 };
2664 
2665 //------------------------------make-------------------------------------------
<span class="line-modified">2666 const TypePtr* TypePtr::make(TYPES t, enum PTR ptr, Offset offset, const TypePtr* speculative, int inline_depth) {</span>
2667   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2668 }
2669 
2670 //------------------------------cast_to_ptr_type-------------------------------
2671 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2672   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2673   if( ptr == _ptr ) return this;
2674   return make(_base, ptr, _offset, _speculative, _inline_depth);
2675 }
2676 
2677 //------------------------------get_con----------------------------------------
2678 intptr_t TypePtr::get_con() const {
2679   assert( _ptr == Null, &quot;&quot; );
<span class="line-modified">2680   return offset();</span>
2681 }
2682 
2683 //------------------------------meet-------------------------------------------
2684 // Compute the MEET of two types.  It returns a new Type object.
2685 const Type *TypePtr::xmeet(const Type *t) const {
2686   const Type* res = xmeet_helper(t);
2687   if (res-&gt;isa_ptr() == NULL) {
2688     return res;
2689   }
2690 
2691   const TypePtr* res_ptr = res-&gt;is_ptr();
2692   if (res_ptr-&gt;speculative() != NULL) {
2693     // type-&gt;speculative() == NULL means that speculation is no better
2694     // than type, i.e. type-&gt;speculative() == type. So there are 2
2695     // ways to represent the fact that we have no useful speculative
2696     // data and we should use a single one to be able to test for
2697     // equality between types. Check whether type-&gt;speculative() ==
2698     // type and set speculative to NULL if it is the case.
2699     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2700       return res_ptr-&gt;remove_speculative();
</pre>
<hr />
<pre>
2729     const TypePtr *tp = t-&gt;is_ptr();
2730     const TypePtr* speculative = xmeet_speculative(tp);
2731     int depth = meet_inline_depth(tp-&gt;inline_depth());
2732     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2733   }
2734   case RawPtr:                  // For these, flip the call around to cut down
2735   case OopPtr:
2736   case InstPtr:                 // on the cases I have to handle.
2737   case AryPtr:
2738   case MetadataPtr:
2739   case KlassPtr:
2740     return t-&gt;xmeet(this);      // Call in reverse direction
2741   default:                      // All else is a mistake
2742     typerr(t);
2743 
2744   }
2745   return this;
2746 }
2747 
2748 //------------------------------meet_offset------------------------------------
<span class="line-modified">2749 Type::Offset TypePtr::meet_offset(int offset) const {</span>
<span class="line-modified">2750   return _offset.meet(Offset(offset));</span>





2751 }
2752 
2753 //------------------------------dual_offset------------------------------------
<span class="line-modified">2754 Type::Offset TypePtr::dual_offset() const {</span>
<span class="line-modified">2755   return _offset.dual();</span>


2756 }
2757 
2758 //------------------------------xdual------------------------------------------
2759 // Dual: compute field-by-field dual
2760 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2761   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2762 };
2763 const Type *TypePtr::xdual() const {
2764   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2765 }
2766 
2767 //------------------------------xadd_offset------------------------------------
<span class="line-modified">2768 Type::Offset TypePtr::xadd_offset(intptr_t offset) const {</span>
<span class="line-modified">2769   return _offset.add(offset);</span>











2770 }
2771 
2772 //------------------------------add_offset-------------------------------------
2773 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2774   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2775 }
2776 
2777 //------------------------------eq---------------------------------------------
2778 // Structural equality check for Type representations
2779 bool TypePtr::eq( const Type *t ) const {
2780   const TypePtr *a = (const TypePtr*)t;
<span class="line-modified">2781   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;_offset &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;</span>
2782 }
2783 
2784 //------------------------------hash-------------------------------------------
2785 // Type-specific hashing function.
2786 int TypePtr::hash(void) const {
<span class="line-modified">2787   return java_add(java_add((jint)_ptr, (jint)offset()), java_add((jint)hash_speculative(), (jint)_inline_depth));</span>
2788 ;
2789 }
2790 
2791 /**
2792  * Return same type without a speculative part
2793  */
2794 const Type* TypePtr::remove_speculative() const {
2795   if (_speculative == NULL) {
2796     return this;
2797   }
2798   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2799   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2800 }
2801 
2802 /**
2803  * Return same type but drop speculative part if we know we won&#39;t use
2804  * it
2805  */
2806 const Type* TypePtr::cleanup_speculative() const {
2807   if (speculative() == NULL) {
</pre>
<hr />
<pre>
3027   }
3028   // We already know the speculative type is always null
3029   if (speculative_always_null()) {
3030     return false;
3031   }
3032   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
3033     return false;
3034   }
3035   return true;
3036 }
3037 
3038 //------------------------------dump2------------------------------------------
3039 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
3040   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
3041 };
3042 
3043 #ifndef PRODUCT
3044 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3045   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
3046   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
<span class="line-modified">3047   _offset.dump2(st);</span>


3048   dump_inline_depth(st);
3049   dump_speculative(st);
3050 }
3051 
3052 /**
3053  *dump the speculative part of the type
3054  */
3055 void TypePtr::dump_speculative(outputStream *st) const {
3056   if (_speculative != NULL) {
3057     st-&gt;print(&quot; (speculative=&quot;);
3058     _speculative-&gt;dump_on(st);
3059     st-&gt;print(&quot;)&quot;);
3060   }
3061 }
3062 
3063 /**
3064  *dump the inline depth of the type
3065  */
3066 void TypePtr::dump_inline_depth(outputStream *st) const {
3067   if (_inline_depth != InlineDepthBottom) {
3068     if (_inline_depth == InlineDepthTop) {
3069       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
3070     } else {
3071       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
3072     }
3073   }
3074 }
3075 #endif
3076 
3077 //------------------------------singleton--------------------------------------
3078 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3079 // constants
3080 bool TypePtr::singleton(void) const {
3081   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">3082   return (_offset != Offset::bottom) &amp;&amp; !below_centerline(_ptr);</span>
3083 }
3084 
3085 bool TypePtr::empty(void) const {
<span class="line-modified">3086   return (_offset == Offset::top) || above_centerline(_ptr);</span>
3087 }
3088 
3089 //=============================================================================
3090 // Convenience common pre-built types.
3091 const TypeRawPtr *TypeRawPtr::BOTTOM;
3092 const TypeRawPtr *TypeRawPtr::NOTNULL;
3093 
3094 //------------------------------make-------------------------------------------
3095 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
3096   assert( ptr != Constant, &quot;what is the constant?&quot; );
3097   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3098   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
3099 }
3100 
3101 const TypeRawPtr *TypeRawPtr::make( address bits ) {
3102   assert( bits, &quot;Use TypePtr for NULL&quot; );
3103   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
3104 }
3105 
3106 //------------------------------cast_to_ptr_type-------------------------------
</pre>
<hr />
<pre>
3208 // Type-specific hashing function.
3209 int TypeRawPtr::hash(void) const {
3210   return (intptr_t)_bits + TypePtr::hash();
3211 }
3212 
3213 //------------------------------dump2------------------------------------------
3214 #ifndef PRODUCT
3215 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3216   if( _ptr == Constant )
3217     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
3218   else
3219     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
3220 }
3221 #endif
3222 
3223 //=============================================================================
3224 // Convenience common pre-built type.
3225 const TypeOopPtr *TypeOopPtr::BOTTOM;
3226 
3227 //------------------------------TypeOopPtr-------------------------------------
<span class="line-modified">3228 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,</span>
3229                        int instance_id, const TypePtr* speculative, int inline_depth)
3230   : TypePtr(t, ptr, offset, speculative, inline_depth),
3231     _const_oop(o), _klass(k),
3232     _klass_is_exact(xk),
3233     _is_ptr_to_narrowoop(false),
3234     _is_ptr_to_narrowklass(false),
3235     _is_ptr_to_boxed_value(false),
3236     _instance_id(instance_id) {
3237   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
<span class="line-modified">3238       (offset.get() &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="line-modified">3239     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());</span>
3240   }
3241 #ifdef _LP64
<span class="line-modified">3242   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {</span>
<span class="line-modified">3243     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {</span>
3244       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3245     } else if (klass() == NULL) {
3246       // Array with unknown body type
3247       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3248       _is_ptr_to_narrowoop = UseCompressedOops;
<span class="line-modified">3249     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {</span>
<span class="line-modified">3250       if (klass()-&gt;is_obj_array_klass()) {</span>
<span class="line-modified">3251         _is_ptr_to_narrowoop = true;</span>
<span class="line-added">3252       } else if (klass()-&gt;is_value_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {</span>
<span class="line-added">3253         // Check if the field of the value type array element contains oops</span>
<span class="line-added">3254         ciValueKlass* vk = klass()-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-added">3255         int foffset = field_offset.get() + vk-&gt;first_field_offset();</span>
<span class="line-added">3256         ciField* field = vk-&gt;get_field_by_offset(foffset, false);</span>
<span class="line-added">3257         assert(field != NULL, &quot;missing field&quot;);</span>
<span class="line-added">3258         BasicType bt = field-&gt;layout_type();</span>
<span class="line-added">3259         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_VALUETYPE);</span>
<span class="line-added">3260       }</span>
3261     } else if (klass()-&gt;is_instance_klass()) {


3262       if (this-&gt;isa_klassptr()) {
3263         // Perm objects don&#39;t use compressed references
<span class="line-modified">3264       } else if (_offset == Offset::bottom || _offset == Offset::top) {</span>
3265         // unsafe access
3266         _is_ptr_to_narrowoop = UseCompressedOops;
3267       } else { // exclude unsafe ops
3268         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
<span class="line-modified">3269         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="line-modified">3270             (this-&gt;offset() == java_lang_Class::klass_offset() ||</span>

3271              this-&gt;offset() == java_lang_Class::array_klass_offset())) {
3272           // Special hidden fields from the Class.
3273           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3274           _is_ptr_to_narrowoop = false;
3275         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
<span class="line-modified">3276                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {</span>
3277           // Static fields
3278           assert(o != NULL, &quot;must be constant&quot;);
<span class="line-modified">3279           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="line-modified">3280           BasicType basic_elem_type;</span>
<span class="line-modified">3281           if (ik-&gt;is_valuetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_value_klass()-&gt;default_value_offset()) {</span>
<span class="line-modified">3282             // Special hidden field that contains the oop of the default value type</span>
<span class="line-added">3283             basic_elem_type = T_VALUETYPE;</span>
<span class="line-added">3284           } else {</span>
<span class="line-added">3285             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);</span>
<span class="line-added">3286             assert(field != NULL, &quot;missing field&quot;);</span>
<span class="line-added">3287             basic_elem_type = field-&gt;layout_type();</span>
<span class="line-added">3288           }</span>
3289           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3290         } else {
3291           // Instance fields which contains a compressed oop references.
<span class="line-modified">3292           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();</span>
<span class="line-added">3293           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);</span>
3294           if (field != NULL) {
3295             BasicType basic_elem_type = field-&gt;layout_type();
3296             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3297           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3298             // Compile::find_alias_type() cast exactness on all types to verify
3299             // that it does not affect alias type.
3300             _is_ptr_to_narrowoop = UseCompressedOops;
3301           } else {
3302             // Type for the copy start in LibraryCallKit::inline_native_clone().
3303             _is_ptr_to_narrowoop = UseCompressedOops;
3304           }
3305         }
3306       }
3307     }
3308   }
3309 #endif
3310 }
3311 
3312 //------------------------------make-------------------------------------------
<span class="line-modified">3313 const TypeOopPtr *TypeOopPtr::make(PTR ptr, Offset offset, int instance_id,</span>
<span class="line-modified">3314                                    const TypePtr* speculative, int inline_depth) {</span>
3315   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3316   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3317   bool      xk = false;
3318   ciObject* o = NULL;
<span class="line-modified">3319   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3320 }
3321 
3322 
3323 //------------------------------cast_to_ptr_type-------------------------------
3324 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3325   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3326   if( ptr == _ptr ) return this;
3327   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3328 }
3329 
3330 //-----------------------------cast_to_instance_id----------------------------
3331 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3332   // There are no instances of a general oop.
3333   // Return self unchanged.
3334   return this;
3335 }
3336 
3337 //-----------------------------cast_to_exactness-------------------------------
3338 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3339   // There is no such thing as an exact general oop.
3340   // Return self unchanged.
3341   return this;
3342 }
3343 
3344 
3345 //------------------------------as_klass_type----------------------------------
3346 // Return the klass type corresponding to this instance or array type.
3347 // It is the type that is loaded from an object of this type.
3348 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3349   ciKlass* k = klass();
3350   bool    xk = klass_is_exact();
3351   if (k == NULL)
3352     return TypeKlassPtr::OBJECT;
3353   else
<span class="line-modified">3354     return TypeKlassPtr::make(xk? Constant: NotNull, k, Offset(0), isa_instptr() &amp;&amp; is_instptr()-&gt;flat_array());</span>
3355 }
3356 
3357 //------------------------------meet-------------------------------------------
3358 // Compute the MEET of two types.  It returns a new Type object.
3359 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3360   // Perform a fast test for common case; meeting the same types together.
3361   if( this == t ) return this;  // Meeting same type-rep?
3362 
3363   // Current &quot;this-&gt;_base&quot; is OopPtr
3364   switch (t-&gt;base()) {          // switch on original type
3365 
3366   case Int:                     // Mixing ints &amp; oops happens when javac
3367   case Long:                    // reuses local variables
3368   case FloatTop:
3369   case FloatCon:
3370   case FloatBot:
3371   case DoubleTop:
3372   case DoubleCon:
3373   case DoubleBot:
3374   case NarrowOop:
3375   case NarrowKlass:
3376   case Bottom:                  // Ye Olde Default
3377     return Type::BOTTOM;
3378   case Top:
3379     return this;
3380 
3381   default:                      // All else is a mistake
3382     typerr(t);
3383 
3384   case RawPtr:
3385   case MetadataPtr:
3386   case KlassPtr:
3387     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3388 
3389   case AnyPtr: {
3390     // Found an AnyPtr type vs self-OopPtr type
3391     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">3392     Offset offset = meet_offset(tp-&gt;offset());</span>
3393     PTR ptr = meet_ptr(tp-&gt;ptr());
3394     const TypePtr* speculative = xmeet_speculative(tp);
3395     int depth = meet_inline_depth(tp-&gt;inline_depth());
3396     switch (tp-&gt;ptr()) {
3397     case Null:
3398       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3399       // else fall through:
3400     case TopPTR:
3401     case AnyNull: {
3402       int instance_id = meet_instance_id(InstanceTop);
3403       return make(ptr, offset, instance_id, speculative, depth);
3404     }
3405     case BotPTR:
3406     case NotNull:
3407       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3408     default: typerr(t);
3409     }
3410   }
3411 
3412   case OopPtr: {                 // Meeting to other OopPtrs
</pre>
<hr />
<pre>
3414     int instance_id = meet_instance_id(tp-&gt;instance_id());
3415     const TypePtr* speculative = xmeet_speculative(tp);
3416     int depth = meet_inline_depth(tp-&gt;inline_depth());
3417     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3418   }
3419 
3420   case InstPtr:                  // For these, flip the call around to cut down
3421   case AryPtr:
3422     return t-&gt;xmeet(this);      // Call in reverse direction
3423 
3424   } // End of switch
3425   return this;                  // Return the double constant
3426 }
3427 
3428 
3429 //------------------------------xdual------------------------------------------
3430 // Dual of a pure heap pointer.  No relevant klass or oop information.
3431 const Type *TypeOopPtr::xdual() const {
3432   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3433   assert(const_oop() == NULL,             &quot;no constants here&quot;);
<span class="line-modified">3434   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
3435 }
3436 
3437 //--------------------------make_from_klass_common-----------------------------
3438 // Computes the element-type given a klass.
3439 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
<span class="line-modified">3440   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {</span>
3441     Compile* C = Compile::current();
3442     Dependencies* deps = C-&gt;dependencies();
3443     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3444     // Element is an instance
3445     bool klass_is_exact = false;
3446     if (klass-&gt;is_loaded()) {
3447       // Try to set klass_is_exact.
3448       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3449       klass_is_exact = ik-&gt;is_final();
3450       if (!klass_is_exact &amp;&amp; klass_change
3451           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3452         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3453         if (sub != NULL) {
3454           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3455           klass = ik = sub;
3456           klass_is_exact = sub-&gt;is_final();
3457         }
3458       }
3459       if (!klass_is_exact &amp;&amp; try_for_exact
3460           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3461         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3462           // Add a dependence; if concrete subclass added we need to recompile
3463           deps-&gt;assert_leaf_type(ik);
3464           klass_is_exact = true;
3465         }
3466       }
3467     }
<span class="line-modified">3468     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());</span>
3469   } else if (klass-&gt;is_obj_array_klass()) {
<span class="line-modified">3470     // Element is an object or value array. Recursively call ourself.</span>
<span class="line-modified">3471     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);</span>
<span class="line-added">3472     if (etype-&gt;is_valuetypeptr()) {</span>
<span class="line-added">3473       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();</span>
<span class="line-added">3474     }</span>
<span class="line-added">3475     // Determine null-free/flattened properties</span>
<span class="line-added">3476     const TypeOopPtr* exact_etype = etype;</span>
<span class="line-added">3477     if (etype-&gt;can_be_value_type()) {</span>
<span class="line-added">3478       // Use exact type if element can be a value type</span>
<span class="line-added">3479       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);</span>
<span class="line-added">3480     }</span>
<span class="line-added">3481     bool not_null_free = !exact_etype-&gt;can_be_value_type();</span>
<span class="line-added">3482     bool not_flat = !ValueArrayFlatten || not_null_free || (exact_etype-&gt;is_valuetypeptr() &amp;&amp; !exact_etype-&gt;value_klass()-&gt;flatten_array());</span>
<span class="line-added">3483 </span>
3484     bool xk = etype-&gt;klass_is_exact();
<span class="line-modified">3485     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);</span>
3486     // We used to pass NotNull in here, asserting that the sub-arrays
3487     // are all not-null.  This is not true in generally, as code can
3488     // slam NULLs down in the subarrays.
<span class="line-modified">3489     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));</span>
3490     return arr;
3491   } else if (klass-&gt;is_type_array_klass()) {
3492     // Element is an typeArray
3493     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
<span class="line-modified">3494     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,</span>
<span class="line-added">3495                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);</span>
3496     // We used to pass NotNull in here, asserting that the array pointer
3497     // is not-null. That was not true in general.
<span class="line-modified">3498     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));</span>
<span class="line-added">3499     return arr;</span>
<span class="line-added">3500   } else if (klass-&gt;is_value_array_klass()) {</span>
<span class="line-added">3501     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-added">3502     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::POS);</span>
<span class="line-added">3503     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));</span>
3504     return arr;
3505   } else {
3506     ShouldNotReachHere();
3507     return NULL;
3508   }
3509 }
3510 
3511 //------------------------------make_from_constant-----------------------------
3512 // Make a java pointer from an oop constant
3513 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3514   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3515 
3516   const bool make_constant = require_constant || o-&gt;should_be_constant();
3517 
3518   ciKlass* klass = o-&gt;klass();
<span class="line-modified">3519   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {</span>
<span class="line-modified">3520     // Element is an instance or value type</span>
3521     if (make_constant) {
3522       return TypeInstPtr::make(o);
3523     } else {
<span class="line-modified">3524       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());</span>
3525     }
3526   } else if (klass-&gt;is_obj_array_klass()) {
3527     // Element is an object array. Recursively call ourself.
<span class="line-modified">3528     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());</span>
<span class="line-modified">3529     bool null_free = false;</span>
<span class="line-modified">3530     if (etype-&gt;is_valuetypeptr()) {</span>
<span class="line-added">3531       null_free = true;</span>
<span class="line-added">3532       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();</span>
<span class="line-added">3533     }</span>
<span class="line-added">3534     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),</span>
<span class="line-added">3535                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);</span>
3536     // We used to pass NotNull in here, asserting that the sub-arrays
3537     // are all not-null.  This is not true in generally, as code can
3538     // slam NULLs down in the subarrays.
3539     if (make_constant) {
<span class="line-modified">3540       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));</span>
3541     } else {
<span class="line-modified">3542       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));</span>
3543     }
3544   } else if (klass-&gt;is_type_array_klass()) {
3545     // Element is an typeArray
<span class="line-modified">3546     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());</span>
<span class="line-modified">3547     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),</span>
<span class="line-modified">3548                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);</span>
3549     // We used to pass NotNull in here, asserting that the array pointer
3550     // is not-null. That was not true in general.
3551     if (make_constant) {
<span class="line-modified">3552       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));</span>
<span class="line-added">3553     } else {</span>
<span class="line-added">3554       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));</span>
<span class="line-added">3555     }</span>
<span class="line-added">3556   } else if (klass-&gt;is_value_array_klass()) {</span>
<span class="line-added">3557     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-added">3558     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
<span class="line-added">3559     // We used to pass NotNull in here, asserting that the sub-arrays</span>
<span class="line-added">3560     // are all not-null.  This is not true in generally, as code can</span>
<span class="line-added">3561     // slam NULLs down in the subarrays.</span>
<span class="line-added">3562     if (make_constant) {</span>
<span class="line-added">3563       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));</span>
3564     } else {
<span class="line-modified">3565       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));</span>
3566     }
3567   }
3568 
3569   fatal(&quot;unhandled object type&quot;);
3570   return NULL;
3571 }
3572 
3573 //------------------------------get_con----------------------------------------
3574 intptr_t TypeOopPtr::get_con() const {
3575   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">3576   assert(offset() &gt;= 0, &quot;&quot;);</span>
3577 
<span class="line-modified">3578   if (offset() != 0) {</span>
3579     // After being ported to the compiler interface, the compiler no longer
3580     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3581     // to a handle at compile time.  This handle is embedded in the generated
3582     // code and dereferenced at the time the nmethod is made.  Until that time,
3583     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3584     // have access to the addresses!).  This does not seem to currently happen,
3585     // but this assertion here is to help prevent its occurence.
3586     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3587     ShouldNotReachHere();
3588   }
3589 
3590   return (intptr_t)const_oop()-&gt;constant_encoding();
3591 }
3592 
3593 
3594 //-----------------------------filter------------------------------------------
3595 // Do not allow interface-vs.-noninterface joins to collapse to top.
3596 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3597 
3598   const Type* ft = join_helper(kills, include_speculative);
</pre>
<hr />
<pre>
3651     return (one == two) &amp;&amp; TypePtr::eq(t);
3652   } else {
3653     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3654   }
3655 }
3656 
3657 //------------------------------hash-------------------------------------------
3658 // Type-specific hashing function.
3659 int TypeOopPtr::hash(void) const {
3660   return
3661     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3662              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3663 }
3664 
3665 //------------------------------dump2------------------------------------------
3666 #ifndef PRODUCT
3667 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3668   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3669   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3670   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
<span class="line-modified">3671   _offset.dump2(st);</span>





3672   if (_instance_id == InstanceTop)
3673     st-&gt;print(&quot;,iid=top&quot;);
3674   else if (_instance_id != InstanceBot)
3675     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3676 
3677   dump_inline_depth(st);
3678   dump_speculative(st);
3679 }
3680 #endif
3681 
3682 //------------------------------singleton--------------------------------------
3683 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3684 // constants
3685 bool TypeOopPtr::singleton(void) const {
3686   // detune optimizer to not generate constant oop + constant offset as a constant!
3687   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">3688   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);</span>
3689 }
3690 
3691 //------------------------------add_offset-------------------------------------
3692 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3693   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3694 }
3695 
3696 /**
3697  * Return same type without a speculative part
3698  */
3699 const Type* TypeOopPtr::remove_speculative() const {
3700   if (_speculative == NULL) {
3701     return this;
3702   }
3703   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3704   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3705 }
3706 
3707 /**
3708  * Return same type but drop speculative part if we know we won&#39;t use
</pre>
<hr />
<pre>
3760  *
3761  * @return  true if type profile is valuable
3762  */
3763 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3764   // no way to improve an already exact type
3765   if (klass_is_exact()) {
3766     return false;
3767   }
3768   return TypePtr::would_improve_type(exact_kls, inline_depth);
3769 }
3770 
3771 //=============================================================================
3772 // Convenience common pre-built types.
3773 const TypeInstPtr *TypeInstPtr::NOTNULL;
3774 const TypeInstPtr *TypeInstPtr::BOTTOM;
3775 const TypeInstPtr *TypeInstPtr::MIRROR;
3776 const TypeInstPtr *TypeInstPtr::MARK;
3777 const TypeInstPtr *TypeInstPtr::KLASS;
3778 
3779 //------------------------------TypeInstPtr-------------------------------------
<span class="line-modified">3780 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,</span>
<span class="line-modified">3781                          bool flat_array, int instance_id, const TypePtr* speculative,</span>
<span class="line-modified">3782                          int inline_depth)</span>
<span class="line-modified">3783   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),</span>
<span class="line-added">3784     _name(k-&gt;name()), _flat_array(flat_array) {</span>
3785    assert(k != NULL &amp;&amp;
3786           (k-&gt;is_loaded() || o == NULL),
3787           &quot;cannot have constants with non-loaded klass&quot;);
<span class="line-added">3788    assert(!klass()-&gt;is_valuetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-added">3789    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);</span>
3790 };
3791 
3792 //------------------------------make-------------------------------------------
3793 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3794                                      ciKlass* k,
3795                                      bool xk,
3796                                      ciObject* o,
<span class="line-modified">3797                                      Offset offset,</span>
<span class="line-added">3798                                      bool flat_array,</span>
3799                                      int instance_id,
3800                                      const TypePtr* speculative,
3801                                      int inline_depth) {
3802   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3803   // Either const_oop() is NULL or else ptr is Constant
3804   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3805           &quot;constant pointers must have a value supplied&quot; );
3806   // Ptr is never Null
3807   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3808 
3809   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3810   if (!UseExactTypes)  xk = false;
3811   if (ptr == Constant) {
3812     // Note:  This case includes meta-object constants, such as methods.
3813     xk = true;
3814   } else if (k-&gt;is_loaded()) {
3815     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3816     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3817     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3818   }
3819 
3820   // Now hash this baby
3821   TypeInstPtr *result =
<span class="line-modified">3822     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, flat_array, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3823 
3824   return result;
3825 }
3826 
3827 /**
3828  *  Create constant type for a constant boxed value
3829  */
3830 const Type* TypeInstPtr::get_const_boxed_value() const {
3831   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3832   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3833   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3834   BasicType bt = constant.basic_type();
3835   switch (bt) {
3836     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3837     case T_INT:      return TypeInt::make(constant.as_int());
3838     case T_CHAR:     return TypeInt::make(constant.as_char());
3839     case T_BYTE:     return TypeInt::make(constant.as_byte());
3840     case T_SHORT:    return TypeInt::make(constant.as_short());
3841     case T_FLOAT:    return TypeF::make(constant.as_float());
3842     case T_DOUBLE:   return TypeD::make(constant.as_double());
3843     case T_LONG:     return TypeLong::make(constant.as_long());
3844     default:         break;
3845   }
3846   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3847   return NULL;
3848 }
3849 
3850 //------------------------------cast_to_ptr_type-------------------------------
3851 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3852   if( ptr == _ptr ) return this;
3853   // Reconstruct _sig info here since not a problem with later lazy
3854   // construction, _sig will show up on demand.
<span class="line-modified">3855   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);</span>
3856 }
3857 
3858 
3859 //-----------------------------cast_to_exactness-------------------------------
3860 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3861   if( klass_is_exact == _klass_is_exact ) return this;
3862   if (!UseExactTypes)  return this;
3863   if (!_klass-&gt;is_loaded())  return this;
3864   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3865   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3866   if( ik-&gt;is_interface() )              return this;  // cannot set xk
<span class="line-modified">3867   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);</span>
3868 }
3869 
3870 //-----------------------------cast_to_instance_id----------------------------
3871 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3872   if( instance_id == _instance_id ) return this;
<span class="line-modified">3873   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);</span>
3874 }
3875 
3876 //------------------------------xmeet_unloaded---------------------------------
3877 // Compute the MEET of two InstPtrs when at least one is unloaded.
3878 // Assume classes are different since called after check for same name/class-loader
3879 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
<span class="line-modified">3880     Offset off = meet_offset(tinst-&gt;offset());</span>
3881     PTR ptr = meet_ptr(tinst-&gt;ptr());
3882     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3883     const TypePtr* speculative = xmeet_speculative(tinst);
3884     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3885 
3886     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3887     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3888     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3889       //
3890       // Meet unloaded class with java/lang/Object
3891       //
3892       // Meet
3893       //          |                     Unloaded Class
3894       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3895       //  ===================================================================
3896       //   TOP    | ..........................Unloaded......................|
3897       //  AnyNull |  U-AN    |................Unloaded......................|
3898       // Constant | ... O-NN .................................. |   O-BOT   |
3899       //  NotNull | ... O-NN .................................. |   O-BOT   |
3900       //  BOTTOM  | ........................Object-BOTTOM ..................|
3901       //
3902       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3903       //
3904       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
<span class="line-modified">3905       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, false, instance_id, speculative, depth); }</span>
3906       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3907       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3908         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3909         else                                      { return TypeInstPtr::NOTNULL; }
3910       }
3911       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3912 
3913       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3914     }
3915 
3916     // Both are unloaded, not the same class, not Object
3917     // Or meet unloaded with a different loaded class, not java/lang/Object
3918     if( ptr != TypePtr::BotPTR ) {
3919       return TypeInstPtr::NOTNULL;
3920     }
3921     return TypeInstPtr::BOTTOM;
3922 }
3923 
3924 
3925 //------------------------------meet-------------------------------------------
</pre>
<hr />
<pre>
3938   case FloatBot:
3939   case DoubleTop:
3940   case DoubleCon:
3941   case DoubleBot:
3942   case NarrowOop:
3943   case NarrowKlass:
3944   case Bottom:                  // Ye Olde Default
3945     return Type::BOTTOM;
3946   case Top:
3947     return this;
3948 
3949   default:                      // All else is a mistake
3950     typerr(t);
3951 
3952   case MetadataPtr:
3953   case KlassPtr:
3954   case RawPtr: return TypePtr::BOTTOM;
3955 
3956   case AryPtr: {                // All arrays inherit from Object class
3957     const TypeAryPtr *tp = t-&gt;is_aryptr();
<span class="line-modified">3958     Offset offset = meet_offset(tp-&gt;offset());</span>
3959     PTR ptr = meet_ptr(tp-&gt;ptr());
3960     int instance_id = meet_instance_id(tp-&gt;instance_id());
3961     const TypePtr* speculative = xmeet_speculative(tp);
3962     int depth = meet_inline_depth(tp-&gt;inline_depth());
3963     switch (ptr) {
3964     case TopPTR:
3965     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3966       // For instances when a subclass meets a superclass we fall
3967       // below the centerline when the superclass is exact. We need to
3968       // do the same here.
<span class="line-modified">3969       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
<span class="line-modified">3970         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);</span>
3971       } else {
3972         // cannot subclass, so the meet has to fall badly below the centerline
3973         ptr = NotNull;
3974         instance_id = InstanceBot;
<span class="line-modified">3975         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
3976       }
3977     case Constant:
3978     case NotNull:
3979     case BotPTR:                // Fall down to object klass
3980       // LCA is object_klass, but if we subclass from the top we can do better
3981       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3982         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3983         // then we can subclass in the Java class hierarchy.
3984         // For instances when a subclass meets a superclass we fall
3985         // below the centerline when the superclass is exact. We need
3986         // to do the same here.
<span class="line-modified">3987         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
3988           // that is, tp&#39;s array type is a subtype of my klass
3989           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
<span class="line-modified">3990                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);</span>
3991         }
3992       }
3993       // The other case cannot happen, since I cannot be a subtype of an array.
3994       // The meet falls down to Object class below centerline.
3995       if( ptr == Constant )
3996          ptr = NotNull;
3997       instance_id = InstanceBot;
<span class="line-modified">3998       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
3999     default: typerr(t);
4000     }
4001   }
4002 
4003   case OopPtr: {                // Meeting to OopPtrs
4004     // Found a OopPtr type vs self-InstPtr type
4005     const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="line-modified">4006     Offset offset = meet_offset(tp-&gt;offset());</span>
4007     PTR ptr = meet_ptr(tp-&gt;ptr());
4008     switch (tp-&gt;ptr()) {
4009     case TopPTR:
4010     case AnyNull: {
4011       int instance_id = meet_instance_id(InstanceTop);
4012       const TypePtr* speculative = xmeet_speculative(tp);
4013       int depth = meet_inline_depth(tp-&gt;inline_depth());
4014       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">4015                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);</span>
4016     }
4017     case NotNull:
4018     case BotPTR: {
4019       int instance_id = meet_instance_id(tp-&gt;instance_id());
4020       const TypePtr* speculative = xmeet_speculative(tp);
4021       int depth = meet_inline_depth(tp-&gt;inline_depth());
4022       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4023     }
4024     default: typerr(t);
4025     }
4026   }
4027 
4028   case AnyPtr: {                // Meeting to AnyPtrs
4029     // Found an AnyPtr type vs self-InstPtr type
4030     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">4031     Offset offset = meet_offset(tp-&gt;offset());</span>
4032     PTR ptr = meet_ptr(tp-&gt;ptr());
4033     int instance_id = meet_instance_id(InstanceTop);
4034     const TypePtr* speculative = xmeet_speculative(tp);
4035     int depth = meet_inline_depth(tp-&gt;inline_depth());
4036     switch (tp-&gt;ptr()) {
4037     case Null:
4038       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4039       // else fall through to AnyNull
4040     case TopPTR:
4041     case AnyNull: {
4042       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">4043                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);</span>
4044     }
4045     case NotNull:
4046     case BotPTR:
4047       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
4048     default: typerr(t);
4049     }
4050   }
4051 
4052   /*
4053                  A-top         }
4054                /   |   \       }  Tops
4055            B-top A-any C-top   }
4056               | /  |  \ |      }  Any-nulls
4057            B-any   |   C-any   }
4058               |    |    |
4059            B-con A-con C-con   } constants; not comparable across classes
4060               |    |    |
4061            B-not   |   C-not   }
4062               | \  |  / |      }  not-nulls
4063            B-bot A-not C-bot   }
4064                \   |   /       }  Bottoms
4065                  A-bot         }
4066   */
4067 
4068   case InstPtr: {                // Meeting 2 Oops?
4069     // Found an InstPtr sub-type vs self-InstPtr type
4070     const TypeInstPtr *tinst = t-&gt;is_instptr();
<span class="line-modified">4071     Offset off = meet_offset( tinst-&gt;offset() );</span>
4072     PTR ptr = meet_ptr( tinst-&gt;ptr() );
4073     int instance_id = meet_instance_id(tinst-&gt;instance_id());
4074     const TypePtr* speculative = xmeet_speculative(tinst);
4075     int depth = meet_inline_depth(tinst-&gt;inline_depth());
4076 
4077     // Check for easy case; klasses are equal (and perhaps not loaded!)
4078     // If we have constants, then we created oops so classes are loaded
4079     // and we can handle the constants further down.  This case handles
4080     // both-not-loaded or both-loaded classes
<span class="line-modified">4081     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;</span>
<span class="line-modified">4082         flat_array() == tinst-&gt;flat_array()) {</span>
<span class="line-added">4083       return make(ptr, klass(), klass_is_exact(), NULL, off, flat_array(), instance_id, speculative, depth);</span>
4084     }
4085 
4086     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
4087     ciKlass* tinst_klass = tinst-&gt;klass();
4088     ciKlass* this_klass  = this-&gt;klass();
4089     bool tinst_xk = tinst-&gt;klass_is_exact();
4090     bool this_xk  = this-&gt;klass_is_exact();
<span class="line-added">4091     bool tinst_flat_array = tinst-&gt;flat_array();</span>
<span class="line-added">4092     bool this_flat_array  = this-&gt;flat_array();</span>
4093     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
4094       // One of these classes has not been loaded
4095       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
4096 #ifndef PRODUCT
4097       if( PrintOpto &amp;&amp; Verbose ) {
4098         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
4099         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
4100         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
4101       }
4102 #endif
4103       return unloaded_meet;
4104     }
4105 
4106     // Handle mixing oops and interfaces first.
4107     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
4108                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
4109       ciKlass *tmp = tinst_klass; // Swap interface around
4110       tinst_klass = this_klass;
4111       this_klass = tmp;
4112       bool tmp2 = tinst_xk;
4113       tinst_xk = this_xk;
4114       this_xk = tmp2;
<span class="line-added">4115       tmp2 = tinst_flat_array;</span>
<span class="line-added">4116       tinst_flat_array = this_flat_array;</span>
<span class="line-added">4117       this_flat_array = tmp2;</span>
4118     }
4119     if (tinst_klass-&gt;is_interface() &amp;&amp;
4120         !(this_klass-&gt;is_interface() ||
4121           // Treat java/lang/Object as an honorary interface,
4122           // because we need a bottom for the interface hierarchy.
4123           this_klass == ciEnv::current()-&gt;Object_klass())) {
4124       // Oop meets interface!
4125 
4126       // See if the oop subtypes (implements) interface.
4127       ciKlass *k;
4128       bool xk;
<span class="line-added">4129       bool flat_array;</span>
4130       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
4131         // Oop indeed subtypes.  Now keep oop or interface depending
4132         // on whether we are both above the centerline or either is
4133         // below the centerline.  If we are on the centerline
4134         // (e.g., Constant vs. AnyNull interface), use the constant.
4135         k  = below_centerline(ptr) ? tinst_klass : this_klass;
4136         // If we are keeping this_klass, keep its exactness too.
4137         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
<span class="line-added">4138         flat_array = below_centerline(ptr) ? tinst_flat_array    : this_flat_array;</span>
4139       } else {                  // Does not implement, fall to Object
4140         // Oop does not implement interface, so mixing falls to Object
4141         // just like the verifier does (if both are above the
4142         // centerline fall to interface)
4143         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
4144         xk = above_centerline(ptr) ? tinst_xk : false;
<span class="line-added">4145         flat_array = above_centerline(ptr) ? tinst_flat_array : false;</span>
4146         // Watch out for Constant vs. AnyNull interface.
4147         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
4148         instance_id = InstanceBot;
4149       }
4150       ciObject* o = NULL;  // the Constant value, if any
4151       if (ptr == Constant) {
4152         // Find out which constant.
4153         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
4154       }
<span class="line-modified">4155       return make(ptr, k, xk, o, off, flat_array, instance_id, speculative, depth);</span>
4156     }
4157 
4158     // Either oop vs oop or interface vs interface or interface vs Object
4159 
4160     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
4161     // If we split one up &amp; one down AND they subtype, take the down man.
4162     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4163     // If both are up and they subtype, take the subtype class.
4164     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4165     // If both are down and they subtype, take the supertype class.
4166     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4167     // Constants treated as down.
4168 
4169     // Now, reorder the above list; observe that both-down+subtype is also
4170     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
4171     // If we split one up &amp; one down AND they subtype, take the down man.
4172     // If both are up and they subtype, take the subtype class.
4173 
4174     // If both are down and they subtype, &quot;fall hard&quot;.
4175     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4176     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4177     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4178 
4179     // If a proper subtype is exact, and we return it, we return it exactly.
4180     // If a proper supertype is exact, there can be no subtyping relationship!
4181     // If both types are equal to the subtype, exactness is and-ed below the
4182     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4183 
4184     // Check for subtyping:
4185     ciKlass *subtype = NULL;
4186     bool subtype_exact = false;
<span class="line-modified">4187     bool flat_array = false;</span>
<span class="line-added">4188     if (tinst_klass-&gt;equals(this_klass)) {</span>
4189       subtype = this_klass;
4190       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
<span class="line-modified">4191       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);</span>
<span class="line-added">4192     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flat_array || this_flat_array)) {</span>
4193       subtype = this_klass;     // Pick subtyping class
4194       subtype_exact = this_xk;
<span class="line-modified">4195       flat_array = this_flat_array;</span>
<span class="line-added">4196     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flat_array || tinst_flat_array)) {</span>
4197       subtype = tinst_klass;    // Pick subtyping class
4198       subtype_exact = tinst_xk;
<span class="line-added">4199       flat_array = tinst_flat_array;</span>
4200     }
4201 
<span class="line-modified">4202     if (subtype) {</span>
<span class="line-modified">4203       if (above_centerline(ptr)) { // both are up?</span>
4204         this_klass = tinst_klass = subtype;
4205         this_xk = tinst_xk = subtype_exact;
<span class="line-modified">4206         this_flat_array = tinst_flat_array = flat_array;</span>
<span class="line-added">4207       } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {</span>
4208         this_klass = tinst_klass; // tinst is down; keep down man
4209         this_xk = tinst_xk;
<span class="line-modified">4210         this_flat_array = tinst_flat_array;</span>
<span class="line-added">4211       } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {</span>
4212         tinst_klass = this_klass; // this is down; keep down man
4213         tinst_xk = this_xk;
<span class="line-added">4214         tinst_flat_array = this_flat_array;</span>
4215       } else {
4216         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
<span class="line-added">4217         this_flat_array = flat_array;</span>
4218       }
4219     }
4220 
4221     // Check for classes now being equal
4222     if (tinst_klass-&gt;equals(this_klass)) {
4223       // If the klasses are equal, the constants may still differ.  Fall to
4224       // NotNull if they do (neither constant is NULL; that is a special case
4225       // handled elsewhere).
4226       ciObject* o = NULL;             // Assume not constant when done
4227       ciObject* this_oop  = const_oop();
4228       ciObject* tinst_oop = tinst-&gt;const_oop();
4229       if( ptr == Constant ) {
4230         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4231             this_oop-&gt;equals(tinst_oop) )
4232           o = this_oop;
4233         else if (above_centerline(this -&gt;_ptr))
4234           o = tinst_oop;
4235         else if (above_centerline(tinst -&gt;_ptr))
4236           o = this_oop;
4237         else
4238           ptr = NotNull;
4239       }
<span class="line-modified">4240       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);</span>
4241     } // Else classes are not equal
4242 
4243     // Since klasses are different, we require a LCA in the Java
4244     // class hierarchy - which means we have to fall to at least NotNull.
4245     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4246       ptr = NotNull;
4247 
4248     instance_id = InstanceBot;
4249 
4250     // Now we find the LCA of Java classes
4251     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
<span class="line-modified">4252     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);</span>
4253   } // End of case InstPtr
4254 
<span class="line-added">4255   case ValueType: {</span>
<span class="line-added">4256     const TypeValueType* tv = t-&gt;is_valuetype();</span>
<span class="line-added">4257     if (above_centerline(ptr())) {</span>
<span class="line-added">4258       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {</span>
<span class="line-added">4259         return t;</span>
<span class="line-added">4260       } else {</span>
<span class="line-added">4261         return TypeInstPtr::NOTNULL;</span>
<span class="line-added">4262       }</span>
<span class="line-added">4263     } else {</span>
<span class="line-added">4264       PTR ptr = this-&gt;_ptr;</span>
<span class="line-added">4265       if (ptr == Constant) {</span>
<span class="line-added">4266         ptr = NotNull;</span>
<span class="line-added">4267       }</span>
<span class="line-added">4268       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {</span>
<span class="line-added">4269         return TypeInstPtr::make(ptr, _klass);</span>
<span class="line-added">4270       } else {</span>
<span class="line-added">4271         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());</span>
<span class="line-added">4272       }</span>
<span class="line-added">4273     }</span>
<span class="line-added">4274   }</span>
<span class="line-added">4275 </span>
4276   } // End of switch
4277   return this;                  // Return the double constant
4278 }
4279 
4280 
4281 //------------------------java_mirror_type--------------------------------------
4282 ciType* TypeInstPtr::java_mirror_type() const {
4283   // must be a singleton type
4284   if( const_oop() == NULL )  return NULL;
4285 
4286   // must be of type java.lang.Class
4287   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;

4288   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
4289 }
4290 
4291 
4292 //------------------------------xdual------------------------------------------
4293 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4294 // inheritance mechanism.
4295 const Type *TypeInstPtr::xdual() const {
<span class="line-modified">4296   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
4297 }
4298 
4299 //------------------------------eq---------------------------------------------
4300 // Structural equality check for Type representations
4301 bool TypeInstPtr::eq( const Type *t ) const {
4302   const TypeInstPtr *p = t-&gt;is_instptr();
4303   return
4304     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
<span class="line-added">4305     flat_array() == p-&gt;flat_array() &amp;&amp;</span>
4306     TypeOopPtr::eq(p);          // Check sub-type stuff
4307 }
4308 
4309 //------------------------------hash-------------------------------------------
4310 // Type-specific hashing function.
4311 int TypeInstPtr::hash(void) const {
<span class="line-modified">4312   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flat_array());</span>
4313   return hash;
4314 }
4315 
4316 //------------------------------dump2------------------------------------------
4317 // Dump oop Type
4318 #ifndef PRODUCT
4319 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4320   // Print the name of the klass.
4321   klass()-&gt;print_name_on(st);
4322 
4323   switch( _ptr ) {
4324   case Constant:
4325     // TO DO: Make CI print the hex address of the underlying oop.
4326     if (WizardMode || Verbose) {
4327       const_oop()-&gt;print_oop(st);
4328     }
4329   case BotPTR:
4330     if (!WizardMode &amp;&amp; !Verbose) {
4331       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4332       break;
4333     }
4334   case TopPTR:
4335   case AnyNull:
4336   case NotNull:
4337     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4338     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4339     break;
4340   default:
4341     break;
4342   }
4343 
<span class="line-modified">4344   _offset.dump2(st);</span>




4345 
4346   st-&gt;print(&quot; *&quot;);
<span class="line-added">4347 </span>
<span class="line-added">4348   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {</span>
<span class="line-added">4349     st-&gt;print(&quot; (flatten array)&quot;);</span>
<span class="line-added">4350   }</span>
<span class="line-added">4351 </span>
4352   if (_instance_id == InstanceTop)
4353     st-&gt;print(&quot;,iid=top&quot;);
4354   else if (_instance_id != InstanceBot)
4355     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4356 
4357   dump_inline_depth(st);
4358   dump_speculative(st);
4359 }
4360 #endif
4361 
4362 //------------------------------add_offset-------------------------------------
4363 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4364   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),</span>
4365               _instance_id, add_offset_speculative(offset), _inline_depth);
4366 }
4367 
4368 const Type *TypeInstPtr::remove_speculative() const {
4369   if (_speculative == NULL) {
4370     return this;
4371   }
4372   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4373   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(),</span>
4374               _instance_id, NULL, _inline_depth);
4375 }
4376 
4377 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4378   if (!UseInlineDepthForSpeculativeTypes) {
4379     return this;
4380   }
<span class="line-modified">4381   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);</span>
4382 }
4383 
4384 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4385   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4386   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);</span>
4387 }
4388 
<span class="line-added">4389 const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {</span>
<span class="line-added">4390   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);</span>
<span class="line-added">4391 }</span>
<span class="line-added">4392 </span>
<span class="line-added">4393 </span>
4394 //=============================================================================
4395 // Convenience common pre-built types.
4396 const TypeAryPtr *TypeAryPtr::RANGE;
4397 const TypeAryPtr *TypeAryPtr::OOPS;
4398 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4399 const TypeAryPtr *TypeAryPtr::BYTES;
4400 const TypeAryPtr *TypeAryPtr::SHORTS;
4401 const TypeAryPtr *TypeAryPtr::CHARS;
4402 const TypeAryPtr *TypeAryPtr::INTS;
4403 const TypeAryPtr *TypeAryPtr::LONGS;
4404 const TypeAryPtr *TypeAryPtr::FLOATS;
4405 const TypeAryPtr *TypeAryPtr::DOUBLES;
<span class="line-added">4406 const TypeAryPtr *TypeAryPtr::VALUES;</span>
4407 
4408 //------------------------------make-------------------------------------------
<span class="line-modified">4409 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,</span>
4410                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4411   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4412          &quot;integral arrays must be pre-equipped with a class&quot;);
<span class="line-modified">4413   if (!xk) xk = ary-&gt;ary_must_be_exact();</span>
4414   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4415   if (!UseExactTypes)  xk = (ptr == Constant);
<span class="line-modified">4416   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();</span>
4417 }
4418 
4419 //------------------------------make-------------------------------------------
<span class="line-modified">4420 const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,</span>
4421                                    int instance_id, const TypePtr* speculative, int inline_depth,
4422                                    bool is_autobox_cache) {
4423   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4424          &quot;integral arrays must be pre-equipped with a class&quot;);
4425   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4426   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4427   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4428   if (!UseExactTypes)  xk = (ptr == Constant);
<span class="line-modified">4429   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, field_offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();</span>
4430 }
4431 
4432 //------------------------------cast_to_ptr_type-------------------------------
4433 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4434   if( ptr == _ptr ) return this;
<span class="line-modified">4435   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
4436 }
4437 
4438 
4439 //-----------------------------cast_to_exactness-------------------------------
4440 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4441   if( klass_is_exact == _klass_is_exact ) return this;
4442   if (!UseExactTypes)  return this;
4443   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
<span class="line-modified">4444 </span>
<span class="line-added">4445   const TypeAry* new_ary = _ary;</span>
<span class="line-added">4446   if (klass() != NULL &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp; klass_is_exact) {</span>
<span class="line-added">4447     // An object array can&#39;t be flat or null-free if the klass is exact</span>
<span class="line-added">4448     new_ary = TypeAry::make(elem(), size(), is_stable(), /* not_flat= */ true, /* not_null_free= */ true);</span>
<span class="line-added">4449   }</span>
<span class="line-added">4450   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
4451 }
4452 
4453 //-----------------------------cast_to_instance_id----------------------------
4454 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4455   if( instance_id == _instance_id ) return this;
<span class="line-modified">4456   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
4457 }
4458 
4459 
4460 //-----------------------------max_array_length-------------------------------
4461 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4462 jint TypeAryPtr::max_array_length(BasicType etype) {
4463   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4464     if (etype == T_NARROWOOP) {
4465       etype = T_OBJECT;
4466     } else if (etype == T_ILLEGAL) { // bottom[]
4467       etype = T_BYTE; // will produce conservatively high value
4468     } else {
4469       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4470     }
4471   }
4472   return arrayOopDesc::max_array_length(etype);
4473 }
4474 
4475 //-----------------------------narrow_size_type-------------------------------
4476 // Narrow the given size type to the index range for the given array base type.
</pre>
<hr />
<pre>
4492   if (hi &gt; max_hi) {
4493     hi = max_hi;
4494     if (size-&gt;is_con()) {
4495       lo = hi;
4496     }
4497     chg = true;
4498   }
4499   // Negative length arrays will produce weird intermediate dead fast-path code
4500   if (lo &gt; hi)
4501     return TypeInt::ZERO;
4502   if (!chg)
4503     return size;
4504   return TypeInt::make(lo, hi, Type::WidenMin);
4505 }
4506 
4507 //-------------------------------cast_to_size----------------------------------
4508 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4509   assert(new_size != NULL, &quot;&quot;);
4510   new_size = narrow_size_type(new_size);
4511   if (new_size == size())  return this;
<span class="line-modified">4512   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_not_flat(), is_not_null_free());</span>
<span class="line-modified">4513   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="line-added">4514 }</span>
<span class="line-added">4515 </span>
<span class="line-added">4516 //-------------------------------cast_to_not_flat------------------------------</span>
<span class="line-added">4517 const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {</span>
<span class="line-added">4518   if (not_flat == is_not_flat()) {</span>
<span class="line-added">4519     return this;</span>
<span class="line-added">4520   }</span>
<span class="line-added">4521   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());</span>
<span class="line-added">4522   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="line-added">4523 }</span>
<span class="line-added">4524 </span>
<span class="line-added">4525 //-------------------------------cast_to_not_null_free-------------------------</span>
<span class="line-added">4526 const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {</span>
<span class="line-added">4527   if (not_null_free == is_not_null_free()) {</span>
<span class="line-added">4528     return this;</span>
<span class="line-added">4529   }</span>
<span class="line-added">4530   // Not null free implies not flat</span>
<span class="line-added">4531   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);</span>
<span class="line-added">4532   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
4533 }
4534 
4535 //------------------------------cast_to_stable---------------------------------
4536 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4537   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4538     return this;
4539 
4540   const Type* elem = this-&gt;elem();
4541   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4542 
4543   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4544     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4545     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4546   }
4547 
<span class="line-modified">4548   const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());</span>
4549 
<span class="line-modified">4550   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
4551 }
4552 
4553 //-----------------------------stable_dimension--------------------------------
4554 int TypeAryPtr::stable_dimension() const {
4555   if (!is_stable())  return 0;
4556   int dim = 1;
4557   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4558   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4559     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4560   return dim;
4561 }
4562 
4563 //----------------------cast_to_autobox_cache-----------------------------------
4564 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4565   if (is_autobox_cache() == cache)  return this;
4566   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4567   if (etype == NULL)  return this;
4568   // The pointers in the autobox arrays are always non-null.
4569   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4570   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">4571   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_not_flat(), is_not_null_free());</span>
<span class="line-modified">4572   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, cache);</span>
4573 }
4574 
4575 //------------------------------eq---------------------------------------------
4576 // Structural equality check for Type representations
4577 bool TypeAryPtr::eq( const Type *t ) const {
4578   const TypeAryPtr *p = t-&gt;is_aryptr();
4579   return
4580     _ary == p-&gt;_ary &amp;&amp;  // Check array
<span class="line-modified">4581     TypeOopPtr::eq(p) &amp;&amp;// Check sub-parts</span>
<span class="line-added">4582     _field_offset == p-&gt;_field_offset;</span>
4583 }
4584 
4585 //------------------------------hash-------------------------------------------
4586 // Type-specific hashing function.
4587 int TypeAryPtr::hash(void) const {
<span class="line-modified">4588   return (intptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();</span>
4589 }
4590 
4591 //------------------------------meet-------------------------------------------
4592 // Compute the MEET of two types.  It returns a new Type object.
4593 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4594   // Perform a fast test for common case; meeting the same types together.
4595   if( this == t ) return this;  // Meeting same type-rep?
4596   // Current &quot;this-&gt;_base&quot; is Pointer
4597   switch (t-&gt;base()) {          // switch on original type
4598 
4599   // Mixing ints &amp; oops happens when javac reuses local variables
4600   case Int:
4601   case Long:
4602   case FloatTop:
4603   case FloatCon:
4604   case FloatBot:
4605   case DoubleTop:
4606   case DoubleCon:
4607   case DoubleBot:
4608   case NarrowOop:
4609   case NarrowKlass:
4610   case Bottom:                  // Ye Olde Default
4611     return Type::BOTTOM;
4612   case Top:
4613     return this;
4614 
4615   default:                      // All else is a mistake
4616     typerr(t);
4617 
4618   case OopPtr: {                // Meeting to OopPtrs
4619     // Found a OopPtr type vs self-AryPtr type
4620     const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="line-modified">4621     Offset offset = meet_offset(tp-&gt;offset());</span>
4622     PTR ptr = meet_ptr(tp-&gt;ptr());
4623     int depth = meet_inline_depth(tp-&gt;inline_depth());
4624     const TypePtr* speculative = xmeet_speculative(tp);
4625     switch (tp-&gt;ptr()) {
4626     case TopPTR:
4627     case AnyNull: {
4628       int instance_id = meet_instance_id(InstanceTop);
4629       return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4630                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
4631     }
4632     case BotPTR:
4633     case NotNull: {
4634       int instance_id = meet_instance_id(tp-&gt;instance_id());
4635       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4636     }
4637     default: ShouldNotReachHere();
4638     }
4639   }
4640 
4641   case AnyPtr: {                // Meeting two AnyPtrs
4642     // Found an AnyPtr type vs self-AryPtr type
4643     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">4644     Offset offset = meet_offset(tp-&gt;offset());</span>
4645     PTR ptr = meet_ptr(tp-&gt;ptr());
4646     const TypePtr* speculative = xmeet_speculative(tp);
4647     int depth = meet_inline_depth(tp-&gt;inline_depth());
4648     switch (tp-&gt;ptr()) {
4649     case TopPTR:
4650       return this;
4651     case BotPTR:
4652     case NotNull:
4653       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4654     case Null:
4655       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4656       // else fall through to AnyNull
4657     case AnyNull: {
4658       int instance_id = meet_instance_id(InstanceTop);
4659       return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4660                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
4661     }
4662     default: ShouldNotReachHere();
4663     }
4664   }
4665 
4666   case MetadataPtr:
4667   case KlassPtr:
4668   case RawPtr: return TypePtr::BOTTOM;
4669 
4670   case AryPtr: {                // Meeting 2 references?
4671     const TypeAryPtr *tap = t-&gt;is_aryptr();
<span class="line-modified">4672     Offset off = meet_offset(tap-&gt;offset());</span>
<span class="line-added">4673     Offset field_off = meet_field_offset(tap-&gt;field_offset());</span>
4674     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4675     PTR ptr = meet_ptr(tap-&gt;ptr());
4676     int instance_id = meet_instance_id(tap-&gt;instance_id());
4677     const TypePtr* speculative = xmeet_speculative(tap);
4678     int depth = meet_inline_depth(tap-&gt;inline_depth());
4679     ciKlass* lazy_klass = NULL;
4680     if (tary-&gt;_elem-&gt;isa_int()) {
4681       // Integral array element types have irrelevant lattice relations.
4682       // It is the klass that determines array layout, not the element type.
4683       if (_klass == NULL)
4684         lazy_klass = tap-&gt;_klass;
4685       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4686         lazy_klass = _klass;
4687       } else {
4688         // Something like byte[int+] meets char[int+].
4689         // This must fall to bottom, not (int[-128..65535])[int+].
4690         instance_id = InstanceBot;
<span class="line-modified">4691         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);</span>
4692       }
4693     } else // Non integral arrays.
4694       // Must fall to bottom if exact klasses in upper lattice
4695       // are not equal or super klass is exact.
4696       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4697           // meet with top[] and bottom[] are processed further down:
<span class="line-modified">4698           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;</span>
4699           // both are exact and not equal:
4700           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
<span class="line-modified">4701            // &#39;tap&#39; is exact and super or unrelated:</span>
4702            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4703            // &#39;this&#39; is exact and super or unrelated:
4704            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4705       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
<span class="line-modified">4706         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);</span>
<span class="line-added">4707       }</span>
<span class="line-added">4708       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);</span>
<span class="line-added">4709     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_value_array_klass() != tap-&gt;klass()-&gt;is_value_array_klass()) {</span>
<span class="line-added">4710       // Meeting flattened value type array with non-flattened array. Adjust (field) offset accordingly.</span>
<span class="line-added">4711       if (tary-&gt;_elem-&gt;isa_valuetype()) {</span>
<span class="line-added">4712         // Result is flattened</span>
<span class="line-added">4713         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());</span>
<span class="line-added">4714         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();</span>
<span class="line-added">4715       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {</span>
<span class="line-added">4716         // Result is non-flattened</span>
<span class="line-added">4717         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));</span>
<span class="line-added">4718         field_off = Offset::bottom;</span>
4719       }

4720     }
4721 
4722     bool xk = false;
4723     switch (tap-&gt;ptr()) {
4724     case AnyNull:
4725     case TopPTR:
4726       // Compute new klass on demand, do not use tap-&gt;_klass
4727       if (below_centerline(this-&gt;_ptr)) {
4728         xk = this-&gt;_klass_is_exact;
4729       } else {
4730         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4731       }
<span class="line-modified">4732       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);</span>
4733     case Constant: {
4734       ciObject* o = const_oop();
4735       if( _ptr == Constant ) {
4736         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4737           xk = (klass() == tap-&gt;klass());
4738           ptr = NotNull;
4739           o = NULL;
4740           instance_id = InstanceBot;
4741         } else {
4742           xk = true;
4743         }
4744       } else if(above_centerline(_ptr)) {
4745         o = tap-&gt;const_oop();
4746         xk = true;
4747       } else {
4748         // Only precise for identical arrays
4749         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4750       }
<span class="line-modified">4751       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);</span>
4752     }
4753     case NotNull:
4754     case BotPTR:
4755       // Compute new klass on demand, do not use tap-&gt;_klass
4756       if (above_centerline(this-&gt;_ptr))
4757             xk = tap-&gt;_klass_is_exact;
4758       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4759               (klass() == tap-&gt;klass()); // Only precise for identical arrays
<span class="line-modified">4760       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);</span>
4761     default: ShouldNotReachHere();
4762     }
4763   }
4764 
4765   // All arrays inherit from Object class
4766   case InstPtr: {
4767     const TypeInstPtr *tp = t-&gt;is_instptr();
<span class="line-modified">4768     Offset offset = meet_offset(tp-&gt;offset());</span>
4769     PTR ptr = meet_ptr(tp-&gt;ptr());
4770     int instance_id = meet_instance_id(tp-&gt;instance_id());
4771     const TypePtr* speculative = xmeet_speculative(tp);
4772     int depth = meet_inline_depth(tp-&gt;inline_depth());
4773     switch (ptr) {
4774     case TopPTR:
4775     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4776       // For instances when a subclass meets a superclass we fall
4777       // below the centerline when the superclass is exact. We need to
4778       // do the same here.
<span class="line-modified">4779       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
<span class="line-modified">4780         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
4781       } else {
4782         // cannot subclass, so the meet has to fall badly below the centerline
4783         ptr = NotNull;
4784         instance_id = InstanceBot;
<span class="line-modified">4785         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
4786       }
4787     case Constant:
4788     case NotNull:
4789     case BotPTR:                // Fall down to object klass
4790       // LCA is object_klass, but if we subclass from the top we can do better
4791       if (above_centerline(tp-&gt;ptr())) {
4792         // If &#39;tp&#39;  is above the centerline and it is Object class
4793         // then we can subclass in the Java class hierarchy.
4794         // For instances when a subclass meets a superclass we fall
4795         // below the centerline when the superclass is exact. We need
4796         // to do the same here.
<span class="line-modified">4797         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
4798           // that is, my array type is a subtype of &#39;tp&#39; klass
4799           return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4800                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
4801         }
4802       }
4803       // The other case cannot happen, since t cannot be a subtype of an array.
4804       // The meet falls down to Object class below centerline.
4805       if( ptr == Constant )
4806          ptr = NotNull;
4807       instance_id = InstanceBot;
<span class="line-modified">4808       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
4809     default: typerr(t);
4810     }
4811   }
<span class="line-added">4812 </span>
<span class="line-added">4813   case ValueType: {</span>
<span class="line-added">4814     const TypeValueType* tv = t-&gt;is_valuetype();</span>
<span class="line-added">4815     if (above_centerline(ptr())) {</span>
<span class="line-added">4816       return TypeInstPtr::NOTNULL;</span>
<span class="line-added">4817     } else {</span>
<span class="line-added">4818       PTR ptr = this-&gt;_ptr;</span>
<span class="line-added">4819       if (ptr == Constant) {</span>
<span class="line-added">4820         ptr = NotNull;</span>
<span class="line-added">4821       }</span>
<span class="line-added">4822       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());</span>
<span class="line-added">4823     }</span>
<span class="line-added">4824   }</span>
4825   }
4826   return this;                  // Lint noise
4827 }
4828 
4829 //------------------------------xdual------------------------------------------
4830 // Dual: compute field-by-field dual
4831 const Type *TypeAryPtr::xdual() const {
<span class="line-modified">4832   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());</span>
<span class="line-added">4833 }</span>
<span class="line-added">4834 </span>
<span class="line-added">4835 Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {</span>
<span class="line-added">4836   return _field_offset.meet(offset);</span>
<span class="line-added">4837 }</span>
<span class="line-added">4838 </span>
<span class="line-added">4839 //------------------------------dual_offset------------------------------------</span>
<span class="line-added">4840 Type::Offset TypeAryPtr::dual_field_offset() const {</span>
<span class="line-added">4841   return _field_offset.dual();</span>
4842 }
4843 
4844 //----------------------interface_vs_oop---------------------------------------
4845 #ifdef ASSERT
4846 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4847   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4848   if (t_aryptr) {
4849     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4850   }
4851   return false;
4852 }
4853 #endif
4854 
4855 //------------------------------dump2------------------------------------------
4856 #ifndef PRODUCT
4857 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4858   _ary-&gt;dump2(d,depth,st);
4859   switch( _ptr ) {
4860   case Constant:
4861     const_oop()-&gt;print(st);
4862     break;
4863   case BotPTR:
4864     if (!WizardMode &amp;&amp; !Verbose) {
4865       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4866       break;
4867     }
4868   case TopPTR:
4869   case AnyNull:
4870   case NotNull:
4871     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4872     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4873     break;
4874   default:
4875     break;
4876   }
4877 
<span class="line-modified">4878   if (elem()-&gt;isa_valuetype()) {</span>
<span class="line-added">4879     st-&gt;print(&quot;(&quot;);</span>
<span class="line-added">4880     _field_offset.dump2(st);</span>
<span class="line-added">4881     st-&gt;print(&quot;)&quot;);</span>
<span class="line-added">4882   }</span>
<span class="line-added">4883   if (offset() != 0) {</span>
4884     int header_size = objArrayOopDesc::header_size() * wordSize;
<span class="line-modified">4885     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);</span>
<span class="line-modified">4886     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);</span>
<span class="line-modified">4887     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());</span>
4888     else {
4889       BasicType basic_elem_type = elem()-&gt;basic_type();
4890       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4891       int elem_size = type2aelembytes(basic_elem_type);
<span class="line-modified">4892       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);</span>
4893     }
4894   }
4895   st-&gt;print(&quot; *&quot;);
4896   if (_instance_id == InstanceTop)
4897     st-&gt;print(&quot;,iid=top&quot;);
4898   else if (_instance_id != InstanceBot)
4899     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4900 
4901   dump_inline_depth(st);
4902   dump_speculative(st);
4903 }
4904 #endif
4905 
4906 bool TypeAryPtr::empty(void) const {
4907   if (_ary-&gt;empty())       return true;
4908   return TypeOopPtr::empty();
4909 }
4910 
4911 //------------------------------add_offset-------------------------------------
4912 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4913   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _field_offset, _instance_id, add_offset_speculative(offset), _inline_depth, _is_autobox_cache);</span>
4914 }
4915 
4916 const Type *TypeAryPtr::remove_speculative() const {
4917   if (_speculative == NULL) {
4918     return this;
4919   }
4920   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4921   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, NULL, _inline_depth, _is_autobox_cache);</span>
<span class="line-added">4922 }</span>
<span class="line-added">4923 </span>
<span class="line-added">4924 const Type* TypeAryPtr::cleanup_speculative() const {</span>
<span class="line-added">4925   if (speculative() == NULL) {</span>
<span class="line-added">4926     return this;</span>
<span class="line-added">4927   }</span>
<span class="line-added">4928   // Keep speculative part if it contains information about flat-/nullability</span>
<span class="line-added">4929   const TypeAryPtr* spec_aryptr = speculative()-&gt;isa_aryptr();</span>
<span class="line-added">4930   if (spec_aryptr != NULL &amp;&amp; (spec_aryptr-&gt;is_not_flat() || spec_aryptr-&gt;is_not_null_free())) {</span>
<span class="line-added">4931     return this;</span>
<span class="line-added">4932   }</span>
<span class="line-added">4933   return TypeOopPtr::cleanup_speculative();</span>
4934 }
4935 
4936 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4937   if (!UseInlineDepthForSpeculativeTypes) {
4938     return this;
4939   }
<span class="line-modified">4940   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);</span>
<span class="line-added">4941 }</span>
<span class="line-added">4942 </span>
<span class="line-added">4943 const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {</span>
<span class="line-added">4944   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="line-added">4945 }</span>
<span class="line-added">4946 </span>
<span class="line-added">4947 const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {</span>
<span class="line-added">4948   int adj = 0;</span>
<span class="line-added">4949   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {</span>
<span class="line-added">4950     const Type* elemtype = elem();</span>
<span class="line-added">4951     if (elemtype-&gt;isa_valuetype()) {</span>
<span class="line-added">4952       if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {</span>
<span class="line-added">4953         adj = _offset.get();</span>
<span class="line-added">4954         offset += _offset.get();</span>
<span class="line-added">4955       }</span>
<span class="line-added">4956       uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);</span>
<span class="line-added">4957       if (_field_offset.get() != OffsetBot &amp;&amp; _field_offset.get() != OffsetTop) {</span>
<span class="line-added">4958         offset += _field_offset.get();</span>
<span class="line-added">4959         if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {</span>
<span class="line-added">4960           offset += header;</span>
<span class="line-added">4961         }</span>
<span class="line-added">4962       }</span>
<span class="line-added">4963       if (offset &gt;= (intptr_t)header || offset &lt; 0) {</span>
<span class="line-added">4964         // Try to get the field of the value type array element we are pointing to</span>
<span class="line-added">4965         ciKlass* arytype_klass = klass();</span>
<span class="line-added">4966         ciValueArrayKlass* vak = arytype_klass-&gt;as_value_array_klass();</span>
<span class="line-added">4967         ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-added">4968         int shift = vak-&gt;log2_element_size();</span>
<span class="line-added">4969         int mask = (1 &lt;&lt; shift) - 1;</span>
<span class="line-added">4970         intptr_t field_offset = ((offset - header) &amp; mask);</span>
<span class="line-added">4971         ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);</span>
<span class="line-added">4972         if (field == NULL) {</span>
<span class="line-added">4973           // This may happen with nested AddP(base, AddP(base, base, offset), longcon(16))</span>
<span class="line-added">4974           return add_offset(offset);</span>
<span class="line-added">4975         } else {</span>
<span class="line-added">4976           return with_field_offset(field_offset)-&gt;add_offset(offset - field_offset - adj);</span>
<span class="line-added">4977         }</span>
<span class="line-added">4978       }</span>
<span class="line-added">4979     }</span>
<span class="line-added">4980   }</span>
<span class="line-added">4981   return add_offset(offset - adj);</span>
<span class="line-added">4982 }</span>
<span class="line-added">4983 </span>
<span class="line-added">4984 // Return offset incremented by field_offset for flattened value type arrays</span>
<span class="line-added">4985 const int TypeAryPtr::flattened_offset() const {</span>
<span class="line-added">4986   int offset = _offset.get();</span>
<span class="line-added">4987   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;</span>
<span class="line-added">4988       _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {</span>
<span class="line-added">4989     offset += _field_offset.get();</span>
<span class="line-added">4990   }</span>
<span class="line-added">4991   return offset;</span>
4992 }
4993 
4994 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4995   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4996   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);</span>
4997 }
4998 
4999 //=============================================================================
5000 
<span class="line-added">5001 </span>
5002 //------------------------------hash-------------------------------------------
5003 // Type-specific hashing function.
5004 int TypeNarrowPtr::hash(void) const {
5005   return _ptrtype-&gt;hash() + 7;
5006 }
5007 
5008 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
5009   return _ptrtype-&gt;singleton();
5010 }
5011 
5012 bool TypeNarrowPtr::empty(void) const {
5013   return _ptrtype-&gt;empty();
5014 }
5015 
5016 intptr_t TypeNarrowPtr::get_con() const {
5017   return _ptrtype-&gt;get_con();
5018 }
5019 
5020 bool TypeNarrowPtr::eq( const Type *t ) const {
5021   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
</pre>
<hr />
<pre>
5070   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
5071   switch (t-&gt;base()) {          // switch on original type
5072 
5073   case Int:                     // Mixing ints &amp; oops happens when javac
5074   case Long:                    // reuses local variables
5075   case FloatTop:
5076   case FloatCon:
5077   case FloatBot:
5078   case DoubleTop:
5079   case DoubleCon:
5080   case DoubleBot:
5081   case AnyPtr:
5082   case RawPtr:
5083   case OopPtr:
5084   case InstPtr:
5085   case AryPtr:
5086   case MetadataPtr:
5087   case KlassPtr:
5088   case NarrowOop:
5089   case NarrowKlass:

5090   case Bottom:                  // Ye Olde Default
5091     return Type::BOTTOM;
5092   case Top:
5093     return this;
5094 
<span class="line-added">5095   case ValueType:</span>
<span class="line-added">5096     return t-&gt;xmeet(this);</span>
<span class="line-added">5097 </span>
5098   default:                      // All else is a mistake
5099     typerr(t);
5100 
5101   } // End of switch
5102 
5103   return this;
5104 }
5105 
5106 #ifndef PRODUCT
5107 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5108   _ptrtype-&gt;dump2(d, depth, st);
5109 }
5110 #endif
5111 
5112 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
5113 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
5114 
5115 
5116 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
5117   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
</pre>
<hr />
<pre>
5156     return (one == two) &amp;&amp; TypePtr::eq(t);
5157   } else {
5158     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
5159   }
5160 }
5161 
5162 //------------------------------hash-------------------------------------------
5163 // Type-specific hashing function.
5164 int TypeMetadataPtr::hash(void) const {
5165   return
5166     (metadata() ? metadata()-&gt;hash() : 0) +
5167     TypePtr::hash();
5168 }
5169 
5170 //------------------------------singleton--------------------------------------
5171 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5172 // constants
5173 bool TypeMetadataPtr::singleton(void) const {
5174   // detune optimizer to not generate constant metadata + constant offset as a constant!
5175   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">5176   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);</span>
5177 }
5178 
5179 //------------------------------add_offset-------------------------------------
5180 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
5181   return make( _ptr, _metadata, xadd_offset(offset));
5182 }
5183 
5184 //-----------------------------filter------------------------------------------
5185 // Do not allow interface-vs.-noninterface joins to collapse to top.
5186 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
5187   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
5188   if (ft == NULL || ft-&gt;empty())
5189     return Type::TOP;           // Canonical empty value
5190   return ft;
5191 }
5192 
5193  //------------------------------get_con----------------------------------------
5194 intptr_t TypeMetadataPtr::get_con() const {
5195   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">5196   assert(offset() &gt;= 0, &quot;&quot;);</span>
5197 
<span class="line-modified">5198   if (offset() != 0) {</span>
5199     // After being ported to the compiler interface, the compiler no longer
5200     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5201     // to a handle at compile time.  This handle is embedded in the generated
5202     // code and dereferenced at the time the nmethod is made.  Until that time,
5203     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5204     // have access to the addresses!).  This does not seem to currently happen,
5205     // but this assertion here is to help prevent its occurence.
5206     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5207     ShouldNotReachHere();
5208   }
5209 
5210   return (intptr_t)metadata()-&gt;constant_encoding();
5211 }
5212 
5213 //------------------------------cast_to_ptr_type-------------------------------
5214 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
5215   if( ptr == _ptr ) return this;
5216   return make(ptr, metadata(), _offset);
5217 }
5218 
</pre>
<hr />
<pre>
5229   case Long:                    // reuses local variables
5230   case FloatTop:
5231   case FloatCon:
5232   case FloatBot:
5233   case DoubleTop:
5234   case DoubleCon:
5235   case DoubleBot:
5236   case NarrowOop:
5237   case NarrowKlass:
5238   case Bottom:                  // Ye Olde Default
5239     return Type::BOTTOM;
5240   case Top:
5241     return this;
5242 
5243   default:                      // All else is a mistake
5244     typerr(t);
5245 
5246   case AnyPtr: {
5247     // Found an AnyPtr type vs self-OopPtr type
5248     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">5249     Offset offset = meet_offset(tp-&gt;offset());</span>
5250     PTR ptr = meet_ptr(tp-&gt;ptr());
5251     switch (tp-&gt;ptr()) {
5252     case Null:
5253       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5254       // else fall through:
5255     case TopPTR:
5256     case AnyNull: {
5257       return make(ptr, _metadata, offset);
5258     }
5259     case BotPTR:
5260     case NotNull:
5261       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5262     default: typerr(t);
5263     }
5264   }
5265 
5266   case RawPtr:
5267   case KlassPtr:
5268   case OopPtr:
5269   case InstPtr:
5270   case AryPtr:
5271     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
5272 
5273   case MetadataPtr: {
5274     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
<span class="line-modified">5275     Offset offset = meet_offset(tp-&gt;offset());</span>
5276     PTR tptr = tp-&gt;ptr();
5277     PTR ptr = meet_ptr(tptr);
5278     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
5279     if (tptr == TopPTR || _ptr == TopPTR ||
5280         metadata()-&gt;equals(tp-&gt;metadata())) {
5281       return make(ptr, md, offset);
5282     }
5283     // metadata is different
5284     if( ptr == Constant ) {  // Cannot be equal constants, so...
5285       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
5286       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
5287       ptr = NotNull;            // Fall down in lattice
5288     }
5289     return make(ptr, NULL, offset);
5290     break;
5291   }
5292   } // End of switch
5293   return this;                  // Return the double constant
5294 }
5295 
5296 
5297 //------------------------------xdual------------------------------------------
5298 // Dual of a pure metadata pointer.
5299 const Type *TypeMetadataPtr::xdual() const {
5300   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
5301 }
5302 
5303 //------------------------------dump2------------------------------------------
5304 #ifndef PRODUCT
5305 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5306   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
5307   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
<span class="line-modified">5308   switch (offset()) {</span>
5309   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
5310   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
5311   case         0: break;
<span class="line-modified">5312   default:        st-&gt;print(&quot;+%d&quot;,offset()); break;</span>
5313   }
5314 }
5315 #endif
5316 
5317 
5318 //=============================================================================
5319 // Convenience common pre-built type.
5320 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
5321 
<span class="line-modified">5322 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset):</span>
5323   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
5324 }
5325 
5326 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
<span class="line-modified">5327   return make(Constant, m, Offset(0));</span>
5328 }
5329 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
<span class="line-modified">5330   return make(Constant, m, Offset(0));</span>
5331 }
5332 
5333 //------------------------------make-------------------------------------------
5334 // Create a meta data constant
<span class="line-modified">5335 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {</span>
5336   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5337   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5338 }
5339 
5340 
5341 //=============================================================================
5342 // Convenience common pre-built types.
5343 
5344 // Not-null object klass or below
5345 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5346 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5347 
5348 //------------------------------TypeKlassPtr-----------------------------------
<span class="line-modified">5349 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)</span>
<span class="line-modified">5350   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {</span>
<span class="line-added">5351    assert(!klass-&gt;is_valuetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-added">5352    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);</span>
5353 }
5354 
5355 //------------------------------make-------------------------------------------
5356 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
<span class="line-modified">5357 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {</span>
<span class="line-modified">5358   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);</span>
<span class="line-modified">5359   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();</span>




5360 }
5361 
5362 //------------------------------eq---------------------------------------------
5363 // Structural equality check for Type representations
5364 bool TypeKlassPtr::eq( const Type *t ) const {
5365   const TypeKlassPtr *p = t-&gt;is_klassptr();
<span class="line-modified">5366   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();</span>


5367 }
5368 
5369 //------------------------------hash-------------------------------------------
5370 // Type-specific hashing function.
5371 int TypeKlassPtr::hash(void) const {
<span class="line-modified">5372   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());</span>
5373 }
5374 
5375 //------------------------------singleton--------------------------------------
5376 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5377 // constants
5378 bool TypeKlassPtr::singleton(void) const {
5379   // detune optimizer to not generate constant klass + constant offset as a constant!
5380   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">5381   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);</span>
5382 }
5383 
5384 // Do not allow interface-vs.-noninterface joins to collapse to top.
5385 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
5386   // logic here mirrors the one from TypeOopPtr::filter. See comments
5387   // there.
5388   const Type* ft = join_helper(kills, include_speculative);
5389   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
5390   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
5391 
5392   if (ft-&gt;empty()) {
<span class="line-modified">5393     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())</span>
5394       return kills;             // Uplift to interface
5395 
5396     return Type::TOP;           // Canonical empty value
5397   }
5398 
5399   // Interface klass type could be exact in opposite to interface type,
5400   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
5401   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
5402       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
5403       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
5404       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
5405     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
5406   }
5407 
5408   return ft;
5409 }
5410 
5411 //----------------------compute_klass------------------------------------------
5412 // Compute the defining klass for this class
5413 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5414   // Compute _klass based on element type.
5415   ciKlass* k_ary = NULL;

5416   const TypeAryPtr *tary;
5417   const Type* el = elem();
5418   if (el-&gt;isa_narrowoop()) {
5419     el = el-&gt;make_ptr();
5420   }
5421 
5422   // Get element klass
<span class="line-modified">5423   if (el-&gt;isa_instptr()) {</span>
<span class="line-modified">5424     // Compute object array klass from element klass</span>
<span class="line-modified">5425     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());</span>
<span class="line-added">5426   } else if (el-&gt;isa_valuetype()) {</span>
<span class="line-added">5427     // If element type is TypeValueType::BOTTOM, value_klass() will be null.</span>
<span class="line-added">5428     if (el-&gt;value_klass() != NULL) {</span>
<span class="line-added">5429       k_ary = ciArrayKlass::make(el-&gt;value_klass());</span>
<span class="line-added">5430     }</span>
5431   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5432     // Compute array klass from element klass
5433     ciKlass* k_elem = tary-&gt;klass();
5434     // If element type is something like bottom[], k_elem will be null.
5435     if (k_elem != NULL)
5436       k_ary = ciObjArrayKlass::make(k_elem);
5437   } else if ((el-&gt;base() == Type::Top) ||
5438              (el-&gt;base() == Type::Bottom)) {
5439     // element type of Bottom occurs from meet of basic type
5440     // and object; Top occurs when doing join on Bottom.
5441     // Leave k_ary at NULL.
5442   } else {
5443     // Cannot compute array klass directly from basic type,
5444     // since subtypes of TypeInt all have basic type T_INT.
5445 #ifdef ASSERT
5446     if (verify &amp;&amp; el-&gt;isa_int()) {
5447       // Check simple cases when verifying klass.
5448       BasicType bt = T_ILLEGAL;
5449       if (el == TypeInt::BYTE) {
5450         bt = T_BYTE;
</pre>
<hr />
<pre>
5475 
5476   // Oops, need to compute _klass and cache it
5477   ciKlass* k_ary = compute_klass();
5478 
5479   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5480     // The _klass field acts as a cache of the underlying
5481     // ciKlass for this array type.  In order to set the field,
5482     // we need to cast away const-ness.
5483     //
5484     // IMPORTANT NOTE: we *never* set the _klass field for the
5485     // type TypeAryPtr::OOPS.  This Type is shared between all
5486     // active compilations.  However, the ciKlass which represents
5487     // this Type is *not* shared between compilations, so caching
5488     // this value would result in fetching a dangling pointer.
5489     //
5490     // Recomputing the underlying ciKlass for each request is
5491     // a bit less efficient than caching, but calls to
5492     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5493     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5494     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
<span class="line-modified">5495         offset() != 0 &amp;&amp; offset() != arrayOopDesc::length_offset_in_bytes()) {</span>
5496       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5497     }
5498   }
5499   return k_ary;
5500 }
5501 
5502 
5503 //------------------------------add_offset-------------------------------------
5504 // Access internals of klass object
5505 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
<span class="line-modified">5506   return make(_ptr, klass(), xadd_offset(offset), flat_array());</span>
5507 }
5508 
5509 //------------------------------cast_to_ptr_type-------------------------------
5510 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5511   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5512   if( ptr == _ptr ) return this;
<span class="line-modified">5513   return make(ptr, _klass, _offset, _flat_array);</span>
5514 }
5515 
5516 
5517 //-----------------------------cast_to_exactness-------------------------------
5518 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5519   if( klass_is_exact == _klass_is_exact ) return this;
5520   if (!UseExactTypes)  return this;
<span class="line-modified">5521   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);</span>
5522 }
5523 
5524 
5525 //-----------------------------as_instance_type--------------------------------
5526 // Corresponding type for an instance of the given class.
5527 // It will be NotNull, and exact if and only if the klass type is exact.
5528 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5529   ciKlass* k = klass();
<span class="line-added">5530   assert(k != NULL, &quot;klass should not be NULL&quot;);</span>
5531   bool    xk = klass_is_exact();
5532   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5533   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5534   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5535   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-added">5536   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {</span>
<span class="line-added">5537     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();</span>
<span class="line-added">5538   }</span>
5539   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5540 }
5541 
5542 
5543 //------------------------------xmeet------------------------------------------
5544 // Compute the MEET of two types, return a new Type object.
5545 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5546   // Perform a fast test for common case; meeting the same types together.
5547   if( this == t ) return this;  // Meeting same type-rep?
5548 
5549   // Current &quot;this-&gt;_base&quot; is Pointer
5550   switch (t-&gt;base()) {          // switch on original type
5551 
5552   case Int:                     // Mixing ints &amp; oops happens when javac
5553   case Long:                    // reuses local variables
5554   case FloatTop:
5555   case FloatCon:
5556   case FloatBot:
5557   case DoubleTop:
5558   case DoubleCon:
5559   case DoubleBot:
5560   case NarrowOop:
5561   case NarrowKlass:
5562   case Bottom:                  // Ye Olde Default
5563     return Type::BOTTOM;
5564   case Top:
5565     return this;
5566 
5567   default:                      // All else is a mistake
5568     typerr(t);
5569 
5570   case AnyPtr: {                // Meeting to AnyPtrs
5571     // Found an AnyPtr type vs self-KlassPtr type
5572     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">5573     Offset offset = meet_offset(tp-&gt;offset());</span>
5574     PTR ptr = meet_ptr(tp-&gt;ptr());
5575     switch (tp-&gt;ptr()) {
5576     case TopPTR:
5577       return this;
5578     case Null:
5579       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5580     case AnyNull:
<span class="line-modified">5581       return make(ptr, klass(), offset, flat_array());</span>
5582     case BotPTR:
5583     case NotNull:
5584       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5585     default: typerr(t);
5586     }
5587   }
5588 
5589   case RawPtr:
5590   case MetadataPtr:
5591   case OopPtr:
5592   case AryPtr:                  // Meet with AryPtr
5593   case InstPtr:                 // Meet with InstPtr
5594     return TypePtr::BOTTOM;
5595 
5596   //
5597   //             A-top         }
5598   //           /   |   \       }  Tops
5599   //       B-top A-any C-top   }
5600   //          | /  |  \ |      }  Any-nulls
5601   //       B-any   |   C-any   }
5602   //          |    |    |
5603   //       B-con A-con C-con   } constants; not comparable across classes
5604   //          |    |    |
5605   //       B-not   |   C-not   }
5606   //          | \  |  / |      }  not-nulls
5607   //       B-bot A-not C-bot   }
5608   //           \   |   /       }  Bottoms
5609   //             A-bot         }
5610   //
5611 
5612   case KlassPtr: {  // Meet two KlassPtr types
5613     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
<span class="line-modified">5614     Offset  off  = meet_offset(tkls-&gt;offset());</span>
5615     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5616 
<span class="line-added">5617     if (klass() == NULL || tkls-&gt;klass() == NULL) {</span>
<span class="line-added">5618       ciKlass* k = NULL;</span>
<span class="line-added">5619       if (ptr == Constant) {</span>
<span class="line-added">5620         k = (klass() == NULL) ? tkls-&gt;klass() : klass();</span>
<span class="line-added">5621       }</span>
<span class="line-added">5622       return make(ptr, k, off, false);</span>
<span class="line-added">5623     }</span>
<span class="line-added">5624 </span>
5625     // Check for easy case; klasses are equal (and perhaps not loaded!)
5626     // If we have constants, then we created oops so classes are loaded
5627     // and we can handle the constants further down.  This case handles
5628     // not-loaded classes
<span class="line-modified">5629     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flat_array() == tkls-&gt;flat_array()) {</span>
<span class="line-modified">5630       return make(ptr, klass(), off, flat_array());</span>
5631     }
5632 
5633     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5634     ciKlass* tkls_klass = tkls-&gt;klass();
5635     ciKlass* this_klass = this-&gt;klass();
5636     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5637     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
<span class="line-added">5638     bool tkls_flat_array = tkls-&gt;flat_array();</span>
<span class="line-added">5639     bool this_flat_array  = this-&gt;flat_array();</span>
<span class="line-added">5640     bool flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tkls_flat_array) : (this_flat_array || tkls_flat_array);</span>
5641 
5642     // If &#39;this&#39; type is above the centerline and is a superclass of the
5643     // other, we can treat &#39;this&#39; as having the same type as the other.
5644     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5645         tkls_klass-&gt;is_subtype_of(this_klass)) {
5646       this_klass = tkls_klass;
5647     }
5648     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5649     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5650     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5651         this_klass-&gt;is_subtype_of(tkls_klass)) {
5652       tkls_klass = this_klass;
5653     }
5654 
5655     // Check for classes now being equal
5656     if (tkls_klass-&gt;equals(this_klass)) {
5657       // If the klasses are equal, the constants may still differ.  Fall to
5658       // NotNull if they do (neither constant is NULL; that is a special case
5659       // handled elsewhere).
5660       if( ptr == Constant ) {
5661         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5662             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5663         else if (above_centerline(this-&gt;ptr()));
5664         else if (above_centerline(tkls-&gt;ptr()));
5665         else
5666           ptr = NotNull;
5667       }
<span class="line-modified">5668       return make(ptr, this_klass, off, flat_array);</span>
5669     } // Else classes are not equal
5670 
5671     // Since klasses are different, we require the LCA in the Java
5672     // class hierarchy - which means we have to fall to at least NotNull.
5673     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5674       ptr = NotNull;
5675     // Now we find the LCA of Java classes
5676     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">5677     return   make(ptr, k, off, k-&gt;is_valuetype() &amp;&amp; k-&gt;flatten_array());</span>
5678   } // End of case KlassPtr
5679 
5680   } // End of switch
5681   return this;                  // Return the double constant
5682 }
5683 
5684 //------------------------------xdual------------------------------------------
5685 // Dual: compute field-by-field dual
5686 const Type    *TypeKlassPtr::xdual() const {
<span class="line-modified">5687   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());</span>
5688 }
5689 
5690 //------------------------------get_con----------------------------------------
5691 intptr_t TypeKlassPtr::get_con() const {
5692   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">5693   assert(offset() &gt;= 0, &quot;&quot;);</span>
5694 
<span class="line-modified">5695   if (offset() != 0) {</span>
5696     // After being ported to the compiler interface, the compiler no longer
5697     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5698     // to a handle at compile time.  This handle is embedded in the generated
5699     // code and dereferenced at the time the nmethod is made.  Until that time,
5700     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5701     // have access to the addresses!).  This does not seem to currently happen,
5702     // but this assertion here is to help prevent its occurence.
5703     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5704     ShouldNotReachHere();
5705   }
5706 
5707   return (intptr_t)klass()-&gt;constant_encoding();
5708 }
5709 //------------------------------dump2------------------------------------------
5710 // Dump Klass Type
5711 #ifndef PRODUCT
5712 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5713   switch( _ptr ) {
5714   case Constant:
5715     st-&gt;print(&quot;precise &quot;);
5716   case NotNull:
5717     {
<span class="line-modified">5718       if (klass() != NULL) {</span>
<span class="line-modified">5719         const char* name = klass()-&gt;name()-&gt;as_utf8();</span>
5720         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5721       } else {
<span class="line-modified">5722         st-&gt;print(&quot;klass BOTTOM&quot;);</span>
5723       }
5724     }
5725   case BotPTR:
5726     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5727   case TopPTR:
5728   case AnyNull:
5729     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5730     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5731     break;
5732   default:
5733     break;
5734   }
5735 
<span class="line-modified">5736   _offset.dump2(st);</span>




5737 
5738   st-&gt;print(&quot; *&quot;);
5739 }
5740 #endif
5741 
5742 
5743 
5744 //=============================================================================
5745 // Convenience common pre-built types.
5746 
5747 //------------------------------make-------------------------------------------
<span class="line-modified">5748 const TypeFunc *TypeFunc::make(const TypeTuple *domain_sig, const TypeTuple* domain_cc,</span>
<span class="line-modified">5749                                const TypeTuple *range_sig, const TypeTuple *range_cc) {</span>
<span class="line-added">5750   return (TypeFunc*)(new TypeFunc(domain_sig, domain_cc, range_sig, range_cc))-&gt;hashcons();</span>
<span class="line-added">5751 }</span>
<span class="line-added">5752 </span>
<span class="line-added">5753 const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {</span>
<span class="line-added">5754   return make(domain, domain, range, range);</span>
<span class="line-added">5755 }</span>
<span class="line-added">5756 </span>
<span class="line-added">5757 //------------------------------osr_domain-----------------------------</span>
<span class="line-added">5758 const TypeTuple* osr_domain() {</span>
<span class="line-added">5759   const Type **fields = TypeTuple::fields(2);</span>
<span class="line-added">5760   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer</span>
<span class="line-added">5761   return TypeTuple::make(TypeFunc::Parms+1, fields);</span>
5762 }
5763 
5764 //------------------------------make-------------------------------------------
<span class="line-modified">5765 const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {</span>
5766   Compile* C = Compile::current();
<span class="line-modified">5767   const TypeFunc* tf = NULL;</span>
<span class="line-modified">5768   if (!is_osr_compilation) {</span>
<span class="line-modified">5769     tf = C-&gt;last_tf(method); // check cache</span>
<span class="line-modified">5770     if (tf != NULL)  return tf;  // The hit rate here is almost 50%.</span>
<span class="line-modified">5771   }</span>
<span class="line-modified">5772   // Value types are not passed/returned by reference, instead each field of</span>
<span class="line-modified">5773   // the value type is passed/returned as an argument. We maintain two views of</span>
<span class="line-added">5774   // the argument/return list here: one based on the signature (with a value</span>
<span class="line-added">5775   // type argument/return as a single slot), one based on the actual calling</span>
<span class="line-added">5776   // convention (with a value type argument/return as a list of its fields).</span>
<span class="line-added">5777   bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;</span>
<span class="line-added">5778   const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);</span>
<span class="line-added">5779   const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;</span>
<span class="line-added">5780   ciSignature* sig = method-&gt;signature();</span>
<span class="line-added">5781   bool has_scalar_ret = sig-&gt;returns_never_null() &amp;&amp; sig-&gt;return_type()-&gt;as_value_klass()-&gt;can_be_returned_as_fields();</span>
<span class="line-added">5782   const TypeTuple* range_sig = TypeTuple::make_range(sig, false);</span>
<span class="line-added">5783   const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;</span>
<span class="line-added">5784   tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);</span>
<span class="line-added">5785   if (!is_osr_compilation) {</span>
<span class="line-added">5786     C-&gt;set_last_tf(method, tf);  // fill cache</span>
5787   }



5788   return tf;
5789 }
5790 
5791 //------------------------------meet-------------------------------------------
5792 // Compute the MEET of two types.  It returns a new Type object.
5793 const Type *TypeFunc::xmeet( const Type *t ) const {
5794   // Perform a fast test for common case; meeting the same types together.
5795   if( this == t ) return this;  // Meeting same type-rep?
5796 
5797   // Current &quot;this-&gt;_base&quot; is Func
5798   switch (t-&gt;base()) {          // switch on original type
5799 
5800   case Bottom:                  // Ye Olde Default
5801     return t;
5802 
5803   default:                      // All else is a mistake
5804     typerr(t);
5805 
5806   case Top:
5807     break;
5808   }
5809   return this;                  // Return the double constant
5810 }
5811 
5812 //------------------------------xdual------------------------------------------
5813 // Dual: compute field-by-field dual
5814 const Type *TypeFunc::xdual() const {
5815   return this;
5816 }
5817 
5818 //------------------------------eq---------------------------------------------
5819 // Structural equality check for Type representations
5820 bool TypeFunc::eq( const Type *t ) const {
5821   const TypeFunc *a = (const TypeFunc*)t;
<span class="line-modified">5822   return _domain_sig == a-&gt;_domain_sig &amp;&amp;</span>
<span class="line-modified">5823     _domain_cc == a-&gt;_domain_cc &amp;&amp;</span>
<span class="line-added">5824     _range_sig == a-&gt;_range_sig &amp;&amp;</span>
<span class="line-added">5825     _range_cc == a-&gt;_range_cc;</span>
5826 }
5827 
5828 //------------------------------hash-------------------------------------------
5829 // Type-specific hashing function.
5830 int TypeFunc::hash(void) const {
<span class="line-modified">5831   return (intptr_t)_domain_sig + (intptr_t)_domain_cc + (intptr_t)_range_sig + (intptr_t)_range_cc;</span>
5832 }
5833 
5834 //------------------------------dump2------------------------------------------
5835 // Dump Function Type
5836 #ifndef PRODUCT
5837 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
<span class="line-modified">5838   if( _range_sig-&gt;cnt() &lt;= Parms )</span>
5839     st-&gt;print(&quot;void&quot;);
5840   else {
5841     uint i;
<span class="line-modified">5842     for (i = Parms; i &lt; _range_sig-&gt;cnt()-1; i++) {</span>
<span class="line-modified">5843       _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
5844       st-&gt;print(&quot;/&quot;);
5845     }
<span class="line-modified">5846     _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
5847   }
5848   st-&gt;print(&quot; &quot;);
5849   st-&gt;print(&quot;( &quot;);
5850   if( !depth || d[this] ) {     // Check for recursive dump
5851     st-&gt;print(&quot;...)&quot;);
5852     return;
5853   }
5854   d.Insert((void*)this,(void*)this);    // Stop recursion
<span class="line-modified">5855   if (Parms &lt; _domain_sig-&gt;cnt())</span>
<span class="line-modified">5856     _domain_sig-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);</span>
<span class="line-modified">5857   for (uint i = Parms+1; i &lt; _domain_sig-&gt;cnt(); i++) {</span>
5858     st-&gt;print(&quot;, &quot;);
<span class="line-modified">5859     _domain_sig-&gt;field_at(i)-&gt;dump2(d,depth-1,st);</span>
5860   }
5861   st-&gt;print(&quot; )&quot;);
5862 }
5863 #endif
5864 
5865 //------------------------------singleton--------------------------------------
5866 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5867 // constants (Ldi nodes).  Singletons are integer, float or double constants
5868 // or a single symbol.
5869 bool TypeFunc::singleton(void) const {
5870   return false;                 // Never a singleton
5871 }
5872 
5873 bool TypeFunc::empty(void) const {
5874   return false;                 // Never empty
5875 }
5876 
5877 
5878 BasicType TypeFunc::return_type() const{
<span class="line-modified">5879   if (range_sig()-&gt;cnt() == TypeFunc::Parms) {</span>
5880     return T_VOID;
5881   }
<span class="line-modified">5882   return range_sig()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();</span>
5883 }
</pre>
</td>
</tr>
</table>
<center><a href="stringopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
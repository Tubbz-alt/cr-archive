<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/interpreterRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/z/zBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciCompilerToVM.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/interpreterRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  38 #include &quot;interpreter/linkResolver.hpp&quot;
  39 #include &quot;interpreter/templateTable.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/cpCache.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/methodData.hpp&quot;
  48 #include &quot;oops/objArrayKlass.hpp&quot;
  49 #include &quot;oops/objArrayOop.inline.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;oops/symbol.hpp&quot;



  52 #include &quot;prims/jvmtiExport.hpp&quot;
  53 #include &quot;prims/nativeLookup.hpp&quot;
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/biasedLocking.hpp&quot;
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/icache.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  65 #include &quot;runtime/osThread.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/stubRoutines.hpp&quot;
  68 #include &quot;runtime/synchronizer.hpp&quot;
  69 #include &quot;runtime/threadCritical.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/copy.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;

  73 #ifdef COMPILER2
  74 #include &quot;opto/runtime.hpp&quot;
  75 #endif
  76 
  77 class UnlockFlagSaver {
  78   private:
  79     JavaThread* _thread;
  80     bool _do_not_unlock;
  81   public:
  82     UnlockFlagSaver(JavaThread* t) {
  83       _thread = t;
  84       _do_not_unlock = t-&gt;do_not_unlock_if_synchronized();
  85       t-&gt;set_do_not_unlock_if_synchronized(false);
  86     }
  87     ~UnlockFlagSaver() {
  88       _thread-&gt;set_do_not_unlock_if_synchronized(_do_not_unlock);
  89     }
  90 };
  91 
  92 // Helper class to access current interpreter state
</pre>
<hr />
<pre>
 213   thread-&gt;set_vm_result(result);
 214   if (!is_fast_aldc) {
 215     // Tell the interpreter how to unbox the primitive.
 216     guarantee(java_lang_boxing_object::is_instance(result, type), &quot;&quot;);
 217     int offset = java_lang_boxing_object::value_offset(type);
 218     intptr_t flags = ((as_TosState(type) &lt;&lt; ConstantPoolCacheEntry::tos_state_shift)
 219                       | (offset &amp; ConstantPoolCacheEntry::field_index_mask));
 220     thread-&gt;set_vm_result_2((Metadata*)flags);
 221   }
 222 }
 223 JRT_END
 224 
 225 
 226 //------------------------------------------------------------------------------------------------------------------------
 227 // Allocation
 228 
 229 JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
 230   Klass* k = pool-&gt;klass_at(index, CHECK);
 231   InstanceKlass* klass = InstanceKlass::cast(k);
 232 




 233   // Make sure we are not instantiating an abstract klass
 234   klass-&gt;check_valid_for_instantiation(true, CHECK);
 235 
 236   // Make sure klass is initialized
 237   klass-&gt;initialize(CHECK);
 238 
 239   // At this point the class may not be fully initialized
 240   // because of recursive initialization. If it is fully
 241   // initialized &amp; has_finalized is not set, we rewrite
 242   // it into its fast version (Note: no locking is needed
 243   // here since this is an atomic byte write and can be
 244   // done more than once).
 245   //
 246   // Note: In case of classes with has_finalized we don&#39;t
 247   //       rewrite since that saves us an extra check in
 248   //       the fast version which then would call the
 249   //       slow version anyway (and do a call back into
 250   //       Java).
 251   //       If we have a breakpoint, then we don&#39;t rewrite
 252   //       because the _breakpoint bytecode would be lost.
 253   oop obj = klass-&gt;allocate_instance(CHECK);
 254   thread-&gt;set_vm_result(obj);
 255 JRT_END
 256 



















































































































































































 257 
 258 JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))
 259   oop obj = oopFactory::new_typeArray(type, size, CHECK);
 260   thread-&gt;set_vm_result(obj);
 261 JRT_END
 262 
 263 
 264 JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))
 265   Klass*    klass = pool-&gt;klass_at(index, CHECK);
<span class="line-modified"> 266   objArrayOop obj = oopFactory::new_objArray(klass, size, CHECK);</span>







 267   thread-&gt;set_vm_result(obj);
 268 JRT_END
 269 










 270 
 271 JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* thread, jint* first_size_address))
 272   // We may want to pass in more arguments - could make this slightly faster
 273   LastFrameAccessor last_frame(thread);
 274   ConstantPool* constants = last_frame.method()-&gt;constants();
<span class="line-modified"> 275   int          i = last_frame.get_index_u2(Bytecodes::_multianewarray);</span>
<span class="line-modified"> 276   Klass* klass   = constants-&gt;klass_at(i, CHECK);</span>

 277   int   nof_dims = last_frame.number_of_dimensions();
 278   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 279   assert(nof_dims &gt;= 1, &quot;multianewarray rank must be nonzero&quot;);
 280 




 281   // We must create an array of jints to pass to multi_allocate.
 282   ResourceMark rm(thread);
 283   const int small_dims = 10;
 284   jint dim_array[small_dims];
 285   jint *dims = &amp;dim_array[0];
 286   if (nof_dims &gt; small_dims) {
 287     dims = (jint*) NEW_RESOURCE_ARRAY(jint, nof_dims);
 288   }
 289   for (int index = 0; index &lt; nof_dims; index++) {
 290     // offset from first_size_address is addressed as local[index]
 291     int n = Interpreter::local_offset_in_bytes(index)/jintSize;
 292     dims[index] = first_size_address[n];
 293   }
 294   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(nof_dims, dims, CHECK);
 295   thread-&gt;set_vm_result(obj);
 296 JRT_END
 297 
 298 
 299 JRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))
 300   assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
 301   assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
 302   InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
 303 JRT_END
 304 























 305 
 306 // Quicken instance-of and check-cast bytecodes
 307 JRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))
 308   // Force resolving; quicken the bytecode
 309   LastFrameAccessor last_frame(thread);
 310   int which = last_frame.get_index_u2(Bytecodes::_checkcast);
 311   ConstantPool* cpool = last_frame.method()-&gt;constants();
 312   // We&#39;d expect to assert that we&#39;re only here to quicken bytecodes, but in a multithreaded
 313   // program we might have seen an unquick&#39;d bytecode in the interpreter but have another
 314   // thread quicken the bytecode before we get here.
 315   // assert( cpool-&gt;tag_at(which).is_unresolved_klass(), &quot;should only come here to quicken bytecodes&quot; );
 316   Klass* klass = cpool-&gt;klass_at(which, CHECK);
 317   thread-&gt;set_vm_result_2(klass);
 318 JRT_END
 319 
 320 
 321 //------------------------------------------------------------------------------------------------------------------------
 322 // Exceptions
 323 
 324 void InterpreterRuntime::note_trap_inner(JavaThread* thread, int reason,
</pre>
<hr />
<pre>
 641 // and therefore we don&#39;t have the receiver object at our fingertips. (Though,
 642 // on some platforms the receiver still resides in a register...). Thus,
 643 // we have no choice but print an error message not containing the receiver
 644 // type.
 645 JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* thread,
 646                                                                         Method* missingMethod))
 647   ResourceMark rm(thread);
 648   assert(missingMethod != NULL, &quot;sanity&quot;);
 649   methodHandle m(thread, missingMethod);
 650   LinkResolver::throw_abstract_method_error(m, THREAD);
 651 JRT_END
 652 
 653 JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* thread,
 654                                                                      Klass* recvKlass,
 655                                                                      Method* missingMethod))
 656   ResourceMark rm(thread);
 657   methodHandle mh = methodHandle(thread, missingMethod);
 658   LinkResolver::throw_abstract_method_error(mh, recvKlass, THREAD);
 659 JRT_END
 660 




 661 
 662 JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))
 663   THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 664 JRT_END
 665 
 666 JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,
 667                                                                               Klass* recvKlass,
 668                                                                               Klass* interfaceKlass))
 669   ResourceMark rm(thread);
 670   char buf[1000];
 671   buf[0] = &#39;\0&#39;;
 672   jio_snprintf(buf, sizeof(buf),
 673                &quot;Class %s does not implement the requested interface %s&quot;,
 674                recvKlass ? recvKlass-&gt;external_name() : &quot;NULL&quot;,
 675                interfaceKlass ? interfaceKlass-&gt;external_name() : &quot;NULL&quot;);
 676   THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 677 JRT_END
 678 
 679 //------------------------------------------------------------------------------------------------------------------------
 680 // Fields
 681 //
 682 
 683 void InterpreterRuntime::resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode) {
 684   Thread* THREAD = thread;
 685   // resolve field
 686   fieldDescriptor info;
 687   LastFrameAccessor last_frame(thread);
 688   constantPoolHandle pool(thread, last_frame.method()-&gt;constants());
 689   methodHandle m(thread, last_frame.method());
 690   bool is_put    = (bytecode == Bytecodes::_putfield  || bytecode == Bytecodes::_nofast_putfield ||
<span class="line-modified"> 691                     bytecode == Bytecodes::_putstatic);</span>
 692   bool is_static = (bytecode == Bytecodes::_getstatic || bytecode == Bytecodes::_putstatic);

 693 
 694   {
 695     JvmtiHideSingleStepping jhss(thread);
 696     LinkResolver::resolve_field_access(info, pool, last_frame.get_index_u2_cpcache(bytecode),
 697                                        m, bytecode, CHECK);
 698   } // end JvmtiHideSingleStepping
 699 
 700   // check if link resolution caused cpCache to be updated
 701   ConstantPoolCacheEntry* cp_cache_entry = last_frame.cache_entry();
 702   if (cp_cache_entry-&gt;is_resolved(bytecode)) return;
 703 
 704   // compute auxiliary field attributes
 705   TosState state  = as_TosState(info.field_type());
 706 
 707   // Resolution of put instructions on final fields is delayed. That is required so that
 708   // exceptions are thrown at the correct place (when the instruction is actually invoked).
 709   // If we do not resolve an instruction in the current pass, leaving the put_code
 710   // set to zero will cause the next put instruction to the same field to reresolve.
 711 
 712   // Resolution of put instructions to final instance fields with invalid updates (i.e.,
</pre>
<hr />
<pre>
 716   // initializer method &lt;init&gt;. If resolution were not inhibited, a putfield
 717   // in an initializer method could be resolved in the initializer. Subsequent
 718   // putfield instructions to the same field would then use cached information.
 719   // As a result, those instructions would not pass through the VM. That is,
 720   // checks in resolve_field_access() would not be executed for those instructions
 721   // and the required IllegalAccessError would not be thrown.
 722   //
 723   // Also, we need to delay resolving getstatic and putstatic instructions until the
 724   // class is initialized.  This is required so that access to the static
 725   // field will call the initialization function every time until the class
 726   // is completely initialized ala. in 2.17.5 in JVM Specification.
 727   InstanceKlass* klass = info.field_holder();
 728   bool uninitialized_static = is_static &amp;&amp; !klass-&gt;is_initialized();
 729   bool has_initialized_final_update = info.field_holder()-&gt;major_version() &gt;= 53 &amp;&amp;
 730                                       info.has_initialized_final_update();
 731   assert(!(has_initialized_final_update &amp;&amp; !info.access_flags().is_final()), &quot;Fields with initialized final updates must be final&quot;);
 732 
 733   Bytecodes::Code get_code = (Bytecodes::Code)0;
 734   Bytecodes::Code put_code = (Bytecodes::Code)0;
 735   if (!uninitialized_static) {
<span class="line-modified"> 736     get_code = ((is_static) ? Bytecodes::_getstatic : Bytecodes::_getfield);</span>
<span class="line-modified"> 737     if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {</span>
<span class="line-modified"> 738       put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);</span>






 739     }
 740   }
 741 
 742   cp_cache_entry-&gt;set_field(
 743     get_code,
 744     put_code,
 745     info.field_holder(),
 746     info.index(),
 747     info.offset(),
 748     state,
 749     info.access_flags().is_final(),
 750     info.access_flags().is_volatile(),


 751     pool-&gt;pool_holder()
 752   );
 753 }
 754 
 755 
 756 //------------------------------------------------------------------------------------------------------------------------
 757 // Synchronization
 758 //
 759 // The interpreter&#39;s synchronization code is factored out so that it can
 760 // be shared by method invocation and synchronized blocks.
 761 //%note synchronization_3
 762 
 763 //%note monitor_1
 764 JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
 765 #ifdef ASSERT
 766   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
 767 #endif
 768   if (PrintBiasedLockingStatistics) {
 769     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
 770   }
</pre>
<hr />
<pre>
 980   int index = last_frame.get_index_u4(bytecode);
 981   {
 982     JvmtiHideSingleStepping jhss(thread);
 983     LinkResolver::resolve_invoke(info, Handle(), pool,
 984                                  index, bytecode, CHECK);
 985   } // end JvmtiHideSingleStepping
 986 
 987   ConstantPoolCacheEntry* cp_cache_entry = pool-&gt;invokedynamic_cp_cache_entry_at(index);
 988   cp_cache_entry-&gt;set_dynamic_call(pool, info);
 989 }
 990 
 991 // This function is the interface to the assembly code. It returns the resolved
 992 // cpCache entry.  This doesn&#39;t safepoint, but the helper routines safepoint.
 993 // This function will check for redefinition!
 994 JRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode)) {
 995   switch (bytecode) {
 996   case Bytecodes::_getstatic:
 997   case Bytecodes::_putstatic:
 998   case Bytecodes::_getfield:
 999   case Bytecodes::_putfield:

1000     resolve_get_put(thread, bytecode);
1001     break;
1002   case Bytecodes::_invokevirtual:
1003   case Bytecodes::_invokespecial:
1004   case Bytecodes::_invokestatic:
1005   case Bytecodes::_invokeinterface:
1006     resolve_invoke(thread, bytecode);
1007     break;
1008   case Bytecodes::_invokehandle:
1009     resolve_invokehandle(thread);
1010     break;
1011   case Bytecodes::_invokedynamic:
1012     resolve_invokedynamic(thread);
1013     break;
1014   default:
1015     fatal(&quot;unexpected bytecode: %s&quot;, Bytecodes::name(bytecode));
1016     break;
1017   }
1018 }
1019 JRT_END
</pre>
<hr />
<pre>
1206 
1207   if (JvmtiExport::should_post_single_step()) {
1208     // We are called during regular safepoints and when the VM is
1209     // single stepping. If any thread is marked for single stepping,
1210     // then we may have JVMTI work to do.
1211     LastFrameAccessor last_frame(thread);
1212     JvmtiExport::at_single_stepping_point(thread, last_frame.method(), last_frame.bcp());
1213   }
1214 JRT_END
1215 
1216 JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,
1217 ConstantPoolCacheEntry *cp_entry))
1218 
1219   // check the access_flags for the field in the klass
1220 
1221   InstanceKlass* ik = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
1222   int index = cp_entry-&gt;field_index();
1223   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_ACCESS_WATCHED) == 0) return;
1224 
1225   bool is_static = (obj == NULL);

1226   HandleMark hm(thread);
1227 
1228   Handle h_obj;
1229   if (!is_static) {
1230     // non-static field accessors have an object, but we need a handle
1231     h_obj = Handle(thread, obj);
1232   }
1233   InstanceKlass* cp_entry_f1 = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
<span class="line-modified">1234   jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry-&gt;f2_as_index(), is_static);</span>
1235   LastFrameAccessor last_frame(thread);
1236   JvmtiExport::post_field_access(thread, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);
1237 JRT_END
1238 
1239 JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,
1240   oopDesc* obj, ConstantPoolCacheEntry *cp_entry, jvalue *value))
1241 
1242   Klass* k = cp_entry-&gt;f1_as_klass();
1243 
1244   // check the access_flags for the field in the klass
1245   InstanceKlass* ik = InstanceKlass::cast(k);
1246   int index = cp_entry-&gt;field_index();
1247   // bail out if field modifications are not watched
1248   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_MODIFICATION_WATCHED) == 0) return;
1249 
1250   char sig_type = &#39;\0&#39;;
1251 
1252   switch(cp_entry-&gt;flag_state()) {
1253     case btos: sig_type = JVM_SIGNATURE_BYTE;    break;
1254     case ztos: sig_type = JVM_SIGNATURE_BOOLEAN; break;
1255     case ctos: sig_type = JVM_SIGNATURE_CHAR;    break;
1256     case stos: sig_type = JVM_SIGNATURE_SHORT;   break;
1257     case itos: sig_type = JVM_SIGNATURE_INT;     break;
1258     case ftos: sig_type = JVM_SIGNATURE_FLOAT;   break;
1259     case atos: sig_type = JVM_SIGNATURE_CLASS;   break;
1260     case ltos: sig_type = JVM_SIGNATURE_LONG;    break;
1261     case dtos: sig_type = JVM_SIGNATURE_DOUBLE;  break;
1262     default:  ShouldNotReachHere(); return;
1263   }






1264   bool is_static = (obj == NULL);

1265 
1266   HandleMark hm(thread);
<span class="line-modified">1267   jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry-&gt;f2_as_index(), is_static);</span>
1268   jvalue fvalue;
1269 #ifdef _LP64
1270   fvalue = *value;
1271 #else
1272   // Long/double values are stored unaligned and also noncontiguously with
1273   // tagged stacks.  We can&#39;t just do a simple assignment even in the non-
1274   // J/D cases because a C++ compiler is allowed to assume that a jvalue is
1275   // 8-byte aligned, and interpreter stack slots are only 4-byte aligned.
1276   // We assume that the two halves of longs/doubles are stored in interpreter
1277   // stack slots in platform-endian order.
1278   jlong_accessor u;
1279   jint* newval = (jint*)value;
1280   u.words[0] = newval[0];
1281   u.words[1] = newval[Interpreter::stackElementWords]; // skip if tag
1282   fvalue.j = u.long_value;
1283 #endif // _LP64
1284 
1285   Handle h_obj;
1286   if (!is_static) {
1287     // non-static field accessors have an object, but we need a handle
</pre>
</td>
<td>
<hr />
<pre>
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  38 #include &quot;interpreter/linkResolver.hpp&quot;
  39 #include &quot;interpreter/templateTable.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/cpCache.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/methodData.hpp&quot;
  48 #include &quot;oops/objArrayKlass.hpp&quot;
  49 #include &quot;oops/objArrayOop.inline.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  52 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  53 #include &quot;oops/valueArrayOop.inline.hpp&quot;</span>
<span class="line-added">  54 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;runtime/atomic.hpp&quot;
  58 #include &quot;runtime/biasedLocking.hpp&quot;
  59 #include &quot;runtime/deoptimization.hpp&quot;
  60 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  61 #include &quot;runtime/frame.inline.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/icache.hpp&quot;
  64 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  65 #include &quot;runtime/java.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  68 #include &quot;runtime/osThread.hpp&quot;
  69 #include &quot;runtime/sharedRuntime.hpp&quot;
  70 #include &quot;runtime/stubRoutines.hpp&quot;
  71 #include &quot;runtime/synchronizer.hpp&quot;
  72 #include &quot;runtime/threadCritical.hpp&quot;
  73 #include &quot;utilities/align.hpp&quot;
  74 #include &quot;utilities/copy.hpp&quot;
  75 #include &quot;utilities/events.hpp&quot;
<span class="line-added">  76 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  77 #ifdef COMPILER2
  78 #include &quot;opto/runtime.hpp&quot;
  79 #endif
  80 
  81 class UnlockFlagSaver {
  82   private:
  83     JavaThread* _thread;
  84     bool _do_not_unlock;
  85   public:
  86     UnlockFlagSaver(JavaThread* t) {
  87       _thread = t;
  88       _do_not_unlock = t-&gt;do_not_unlock_if_synchronized();
  89       t-&gt;set_do_not_unlock_if_synchronized(false);
  90     }
  91     ~UnlockFlagSaver() {
  92       _thread-&gt;set_do_not_unlock_if_synchronized(_do_not_unlock);
  93     }
  94 };
  95 
  96 // Helper class to access current interpreter state
</pre>
<hr />
<pre>
 217   thread-&gt;set_vm_result(result);
 218   if (!is_fast_aldc) {
 219     // Tell the interpreter how to unbox the primitive.
 220     guarantee(java_lang_boxing_object::is_instance(result, type), &quot;&quot;);
 221     int offset = java_lang_boxing_object::value_offset(type);
 222     intptr_t flags = ((as_TosState(type) &lt;&lt; ConstantPoolCacheEntry::tos_state_shift)
 223                       | (offset &amp; ConstantPoolCacheEntry::field_index_mask));
 224     thread-&gt;set_vm_result_2((Metadata*)flags);
 225   }
 226 }
 227 JRT_END
 228 
 229 
 230 //------------------------------------------------------------------------------------------------------------------------
 231 // Allocation
 232 
 233 JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
 234   Klass* k = pool-&gt;klass_at(index, CHECK);
 235   InstanceKlass* klass = InstanceKlass::cast(k);
 236 
<span class="line-added"> 237   if (klass-&gt;is_value()) {</span>
<span class="line-added"> 238     THROW(vmSymbols::java_lang_InstantiationError());</span>
<span class="line-added"> 239   }</span>
<span class="line-added"> 240 </span>
 241   // Make sure we are not instantiating an abstract klass
 242   klass-&gt;check_valid_for_instantiation(true, CHECK);
 243 
 244   // Make sure klass is initialized
 245   klass-&gt;initialize(CHECK);
 246 
 247   // At this point the class may not be fully initialized
 248   // because of recursive initialization. If it is fully
 249   // initialized &amp; has_finalized is not set, we rewrite
 250   // it into its fast version (Note: no locking is needed
 251   // here since this is an atomic byte write and can be
 252   // done more than once).
 253   //
 254   // Note: In case of classes with has_finalized we don&#39;t
 255   //       rewrite since that saves us an extra check in
 256   //       the fast version which then would call the
 257   //       slow version anyway (and do a call back into
 258   //       Java).
 259   //       If we have a breakpoint, then we don&#39;t rewrite
 260   //       because the _breakpoint bytecode would be lost.
 261   oop obj = klass-&gt;allocate_instance(CHECK);
 262   thread-&gt;set_vm_result(obj);
 263 JRT_END
 264 
<span class="line-added"> 265 void copy_primitive_argument(intptr_t* addr, Handle instance, int offset, BasicType type) {</span>
<span class="line-added"> 266   switch (type) {</span>
<span class="line-added"> 267   case T_BOOLEAN:</span>
<span class="line-added"> 268     instance()-&gt;bool_field_put(offset, (jboolean)*((int*)addr));</span>
<span class="line-added"> 269     break;</span>
<span class="line-added"> 270   case T_CHAR:</span>
<span class="line-added"> 271     instance()-&gt;char_field_put(offset, (jchar) *((int*)addr));</span>
<span class="line-added"> 272     break;</span>
<span class="line-added"> 273   case T_FLOAT:</span>
<span class="line-added"> 274     instance()-&gt;float_field_put(offset, (jfloat)*((float*)addr));</span>
<span class="line-added"> 275     break;</span>
<span class="line-added"> 276   case T_DOUBLE:</span>
<span class="line-added"> 277     instance()-&gt;double_field_put(offset, (jdouble)*((double*)addr));</span>
<span class="line-added"> 278     break;</span>
<span class="line-added"> 279   case T_BYTE:</span>
<span class="line-added"> 280     instance()-&gt;byte_field_put(offset, (jbyte)*((int*)addr));</span>
<span class="line-added"> 281     break;</span>
<span class="line-added"> 282   case T_SHORT:</span>
<span class="line-added"> 283     instance()-&gt;short_field_put(offset, (jshort)*((int*)addr));</span>
<span class="line-added"> 284     break;</span>
<span class="line-added"> 285   case T_INT:</span>
<span class="line-added"> 286     instance()-&gt;int_field_put(offset, (jint)*((int*)addr));</span>
<span class="line-added"> 287     break;</span>
<span class="line-added"> 288   case T_LONG:</span>
<span class="line-added"> 289     instance()-&gt;long_field_put(offset, (jlong)*((long long*)addr));</span>
<span class="line-added"> 290     break;</span>
<span class="line-added"> 291   case T_OBJECT:</span>
<span class="line-added"> 292   case T_ARRAY:</span>
<span class="line-added"> 293   case T_VALUETYPE:</span>
<span class="line-added"> 294     fatal(&quot;Should not be handled with this method&quot;);</span>
<span class="line-added"> 295     break;</span>
<span class="line-added"> 296   default:</span>
<span class="line-added"> 297     fatal(&quot;Unsupported BasicType&quot;);</span>
<span class="line-added"> 298   }</span>
<span class="line-added"> 299 }</span>
<span class="line-added"> 300 </span>
<span class="line-added"> 301 JRT_ENTRY(void, InterpreterRuntime::defaultvalue(JavaThread* thread, ConstantPool* pool, int index))</span>
<span class="line-added"> 302   // Getting the ValueKlass</span>
<span class="line-added"> 303   Klass* k = pool-&gt;klass_at(index, CHECK);</span>
<span class="line-added"> 304   if (!k-&gt;is_value()) {</span>
<span class="line-added"> 305     // inconsistency with &#39;new&#39; which throws an InstantiationError</span>
<span class="line-added"> 306     // in the future, defaultvalue will just return null instead of throwing an exception</span>
<span class="line-added"> 307     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added"> 308   }</span>
<span class="line-added"> 309   assert(k-&gt;is_value(), &quot;defaultvalue argument must be the value type class&quot;);</span>
<span class="line-added"> 310   ValueKlass* vklass = ValueKlass::cast(k);</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312   vklass-&gt;initialize(THREAD);</span>
<span class="line-added"> 313   oop res = vklass-&gt;default_value();</span>
<span class="line-added"> 314   thread-&gt;set_vm_result(res);</span>
<span class="line-added"> 315 JRT_END</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317 JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* thread, ConstantPoolCache* cp_cache))</span>
<span class="line-added"> 318   LastFrameAccessor last_frame(thread);</span>
<span class="line-added"> 319   // Getting the ValueKlass</span>
<span class="line-added"> 320   int index = ConstantPool::decode_cpcache_index(last_frame.get_index_u2_cpcache(Bytecodes::_withfield));</span>
<span class="line-added"> 321   ConstantPoolCacheEntry* cp_entry = cp_cache-&gt;entry_at(index);</span>
<span class="line-added"> 322   assert(cp_entry-&gt;is_resolved(Bytecodes::_withfield), &quot;Should have been resolved&quot;);</span>
<span class="line-added"> 323   Klass* klass = cp_entry-&gt;f1_as_klass();</span>
<span class="line-added"> 324   assert(klass-&gt;is_value(), &quot;withfield only applies to value types&quot;);</span>
<span class="line-added"> 325   ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327   // Getting Field information</span>
<span class="line-added"> 328   int offset = cp_entry-&gt;f2_as_index();</span>
<span class="line-added"> 329   int field_index = cp_entry-&gt;field_index();</span>
<span class="line-added"> 330   int field_offset = cp_entry-&gt;f2_as_offset();</span>
<span class="line-added"> 331   Symbol* field_signature = vklass-&gt;field_signature(field_index);</span>
<span class="line-added"> 332   BasicType field_type = Signature::basic_type(field_signature);</span>
<span class="line-added"> 333   int return_offset = (type2size[field_type] + type2size[T_OBJECT]) * AbstractInterpreter::stackElementSize;</span>
<span class="line-added"> 334 </span>
<span class="line-added"> 335   // Getting old value</span>
<span class="line-added"> 336   frame&amp; f = last_frame.get_frame();</span>
<span class="line-added"> 337   jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;</span>
<span class="line-added"> 338   int vt_offset = type2size[field_type];</span>
<span class="line-added"> 339   oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);</span>
<span class="line-added"> 340   assert(old_value != NULL &amp;&amp; oopDesc::is_oop(old_value) &amp;&amp; old_value-&gt;is_value(),&quot;Verifying receiver&quot;);</span>
<span class="line-added"> 341   Handle old_value_h(THREAD, old_value);</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343   // Creating new value by copying the one passed in argument</span>
<span class="line-added"> 344   instanceOop new_value = vklass-&gt;allocate_instance(</span>
<span class="line-added"> 345       CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));</span>
<span class="line-added"> 346   Handle new_value_h = Handle(THREAD, new_value);</span>
<span class="line-added"> 347   vklass-&gt;value_copy_oop_to_new_oop(old_value_h(), new_value_h());</span>
<span class="line-added"> 348 </span>
<span class="line-added"> 349   // Updating the field specified in arguments</span>
<span class="line-added"> 350   if (field_type == T_ARRAY || field_type == T_OBJECT) {</span>
<span class="line-added"> 351     oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);</span>
<span class="line-added"> 352     assert(aoop == NULL || oopDesc::is_oop(aoop),&quot;argument must be a reference type&quot;);</span>
<span class="line-added"> 353     new_value_h()-&gt;obj_field_put(field_offset, aoop);</span>
<span class="line-added"> 354   } else if (field_type == T_VALUETYPE) {</span>
<span class="line-added"> 355     if (cp_entry-&gt;is_flattened()) {</span>
<span class="line-added"> 356       oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);</span>
<span class="line-added"> 357       assert(vt_oop != NULL &amp;&amp; oopDesc::is_oop(vt_oop) &amp;&amp; vt_oop-&gt;is_value(),&quot;argument must be a value type&quot;);</span>
<span class="line-added"> 358       ValueKlass* field_vk = ValueKlass::cast(vklass-&gt;get_value_field_klass(field_index));</span>
<span class="line-added"> 359       assert(vt_oop != NULL &amp;&amp; field_vk == vt_oop-&gt;klass(), &quot;Must match&quot;);</span>
<span class="line-added"> 360       field_vk-&gt;write_flattened_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));</span>
<span class="line-added"> 361     } else { // not flattened</span>
<span class="line-added"> 362       oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);</span>
<span class="line-added"> 363       if (voop == NULL &amp;&amp; cp_entry-&gt;is_flattenable()) {</span>
<span class="line-added"> 364         THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);</span>
<span class="line-added"> 365       }</span>
<span class="line-added"> 366       assert(voop == NULL || oopDesc::is_oop(voop),&quot;checking argument&quot;);</span>
<span class="line-added"> 367       new_value_h()-&gt;obj_field_put(field_offset, voop);</span>
<span class="line-added"> 368     }</span>
<span class="line-added"> 369   } else { // not T_OBJECT nor T_ARRAY nor T_VALUETYPE</span>
<span class="line-added"> 370     intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);</span>
<span class="line-added"> 371     copy_primitive_argument(addr, new_value_h, field_offset, field_type);</span>
<span class="line-added"> 372   }</span>
<span class="line-added"> 373 </span>
<span class="line-added"> 374   // returning result</span>
<span class="line-added"> 375   thread-&gt;set_vm_result(new_value_h());</span>
<span class="line-added"> 376   return return_offset;</span>
<span class="line-added"> 377 JRT_END</span>
<span class="line-added"> 378 </span>
<span class="line-added"> 379 JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_value_field(JavaThread* thread, oopDesc* mirror, int index))</span>
<span class="line-added"> 380   // The interpreter tries to access a flattenable static field that has not been initialized.</span>
<span class="line-added"> 381   // This situation can happen in different scenarios:</span>
<span class="line-added"> 382   //   1 - if the load or initialization of the field failed during step 8 of</span>
<span class="line-added"> 383   //       the initialization of the holder of the field, in this case the access to the field</span>
<span class="line-added"> 384   //       must fail</span>
<span class="line-added"> 385   //   2 - it can also happen when the initialization of the holder class triggered the initialization of</span>
<span class="line-added"> 386   //       another class which accesses this field in its static initializer, in this case the</span>
<span class="line-added"> 387   //       access must succeed to allow circularity</span>
<span class="line-added"> 388   // The code below tries to load and initialize the field&#39;s class again before returning the default value.</span>
<span class="line-added"> 389   // If the field was not initialized because of an error, a exception should be thrown.</span>
<span class="line-added"> 390   // If the class is being initialized, the default value is returned.</span>
<span class="line-added"> 391   instanceHandle mirror_h(THREAD, (instanceOop)mirror);</span>
<span class="line-added"> 392   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));</span>
<span class="line-added"> 393   if (klass-&gt;is_being_initialized() &amp;&amp; klass-&gt;is_reentrant_initialization(THREAD)) {</span>
<span class="line-added"> 394     int offset = klass-&gt;field_offset(index);</span>
<span class="line-added"> 395     Klass* field_k = klass-&gt;get_value_field_klass_or_null(index);</span>
<span class="line-added"> 396     if (field_k == NULL) {</span>
<span class="line-added"> 397       field_k = SystemDictionary::resolve_or_fail(klass-&gt;field_signature(index)-&gt;fundamental_name(THREAD),</span>
<span class="line-added"> 398           Handle(THREAD, klass-&gt;class_loader()),</span>
<span class="line-added"> 399           Handle(THREAD, klass-&gt;protection_domain()),</span>
<span class="line-added"> 400           true, CHECK);</span>
<span class="line-added"> 401       assert(field_k != NULL, &quot;Should have been loaded or an exception thrown above&quot;);</span>
<span class="line-added"> 402       klass-&gt;set_value_field_klass(index, field_k);</span>
<span class="line-added"> 403     }</span>
<span class="line-added"> 404     field_k-&gt;initialize(CHECK);</span>
<span class="line-added"> 405     oop defaultvalue = ValueKlass::cast(field_k)-&gt;default_value();</span>
<span class="line-added"> 406     // It is safe to initialized the static field because 1) the current thread is the initializing thread</span>
<span class="line-added"> 407     // and is the only one that can access it, and 2) the field is actually not initialized (i.e. null)</span>
<span class="line-added"> 408     // otherwise the JVM should not be executing this code.</span>
<span class="line-added"> 409     mirror-&gt;obj_field_put(offset, defaultvalue);</span>
<span class="line-added"> 410     thread-&gt;set_vm_result(defaultvalue);</span>
<span class="line-added"> 411   } else {</span>
<span class="line-added"> 412     assert(klass-&gt;is_in_error_state(), &quot;If not initializing, initialization must have failed to get there&quot;);</span>
<span class="line-added"> 413     ResourceMark rm(THREAD);</span>
<span class="line-added"> 414     const char* desc = &quot;Could not initialize class &quot;;</span>
<span class="line-added"> 415     const char* className = klass-&gt;external_name();</span>
<span class="line-added"> 416     size_t msglen = strlen(desc) + strlen(className) + 1;</span>
<span class="line-added"> 417     char* message = NEW_RESOURCE_ARRAY(char, msglen);</span>
<span class="line-added"> 418     if (NULL == message) {</span>
<span class="line-added"> 419       // Out of memory: can&#39;t create detailed error message</span>
<span class="line-added"> 420       THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);</span>
<span class="line-added"> 421     } else {</span>
<span class="line-added"> 422       jio_snprintf(message, msglen, &quot;%s%s&quot;, desc, className);</span>
<span class="line-added"> 423       THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);</span>
<span class="line-added"> 424     }</span>
<span class="line-added"> 425   }</span>
<span class="line-added"> 426 JRT_END</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428 JRT_ENTRY(void, InterpreterRuntime::read_flattened_field(JavaThread* thread, oopDesc* obj, int index, Klass* field_holder))</span>
<span class="line-added"> 429   Handle obj_h(THREAD, obj);</span>
<span class="line-added"> 430 </span>
<span class="line-added"> 431   assert(oopDesc::is_oop(obj), &quot;Sanity check&quot;);</span>
<span class="line-added"> 432 </span>
<span class="line-added"> 433   assert(field_holder-&gt;is_instance_klass(), &quot;Sanity check&quot;);</span>
<span class="line-added"> 434   InstanceKlass* klass = InstanceKlass::cast(field_holder);</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436   assert(klass-&gt;field_is_flattened(index), &quot;Sanity check&quot;);</span>
<span class="line-added"> 437 </span>
<span class="line-added"> 438   ValueKlass* field_vklass = ValueKlass::cast(klass-&gt;get_value_field_klass(index));</span>
<span class="line-added"> 439   assert(field_vklass-&gt;is_initialized(), &quot;Must be initialized at this point&quot;);</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441   oop res = field_vklass-&gt;read_flattened_field(obj_h(), klass-&gt;field_offset(index), CHECK);</span>
<span class="line-added"> 442   thread-&gt;set_vm_result(res);</span>
<span class="line-added"> 443 JRT_END</span>
 444 
 445 JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))
 446   oop obj = oopFactory::new_typeArray(type, size, CHECK);
 447   thread-&gt;set_vm_result(obj);
 448 JRT_END
 449 
 450 
 451 JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))
 452   Klass*    klass = pool-&gt;klass_at(index, CHECK);
<span class="line-modified"> 453   bool      is_qtype_desc = pool-&gt;tag_at(index).is_Qdescriptor_klass();</span>
<span class="line-added"> 454   arrayOop obj;</span>
<span class="line-added"> 455   if ((!klass-&gt;is_array_klass()) &amp;&amp; is_qtype_desc) { // Logically creates elements, ensure klass init</span>
<span class="line-added"> 456     klass-&gt;initialize(CHECK);</span>
<span class="line-added"> 457     obj = oopFactory::new_valueArray(klass, size, CHECK);</span>
<span class="line-added"> 458   } else {</span>
<span class="line-added"> 459     obj = oopFactory::new_objArray(klass, size, CHECK);</span>
<span class="line-added"> 460   }</span>
 461   thread-&gt;set_vm_result(obj);
 462 JRT_END
 463 
<span class="line-added"> 464 JRT_ENTRY(void, InterpreterRuntime::value_array_load(JavaThread* thread, arrayOopDesc* array, int index))</span>
<span class="line-added"> 465   valueArrayHandle vah(thread, (valueArrayOop)array);</span>
<span class="line-added"> 466   oop value_holder = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);</span>
<span class="line-added"> 467   thread-&gt;set_vm_result(value_holder);</span>
<span class="line-added"> 468 JRT_END</span>
<span class="line-added"> 469 </span>
<span class="line-added"> 470 JRT_ENTRY(void, InterpreterRuntime::value_array_store(JavaThread* thread, void* val, arrayOopDesc* array, int index))</span>
<span class="line-added"> 471   assert(val != NULL, &quot;can&#39;t store null into flat array&quot;);</span>
<span class="line-added"> 472   ((valueArrayOop)array)-&gt;value_copy_to_index((oop)val, index);</span>
<span class="line-added"> 473 JRT_END</span>
 474 
 475 JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* thread, jint* first_size_address))
 476   // We may want to pass in more arguments - could make this slightly faster
 477   LastFrameAccessor last_frame(thread);
 478   ConstantPool* constants = last_frame.method()-&gt;constants();
<span class="line-modified"> 479   int i = last_frame.get_index_u2(Bytecodes::_multianewarray);</span>
<span class="line-modified"> 480   Klass* klass = constants-&gt;klass_at(i, CHECK);</span>
<span class="line-added"> 481   bool is_qtype = klass-&gt;name()-&gt;is_Q_array_signature();</span>
 482   int   nof_dims = last_frame.number_of_dimensions();
 483   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 484   assert(nof_dims &gt;= 1, &quot;multianewarray rank must be nonzero&quot;);
 485 
<span class="line-added"> 486   if (is_qtype) { // Logically creates elements, ensure klass init</span>
<span class="line-added"> 487     klass-&gt;initialize(CHECK);</span>
<span class="line-added"> 488   }</span>
<span class="line-added"> 489 </span>
 490   // We must create an array of jints to pass to multi_allocate.
 491   ResourceMark rm(thread);
 492   const int small_dims = 10;
 493   jint dim_array[small_dims];
 494   jint *dims = &amp;dim_array[0];
 495   if (nof_dims &gt; small_dims) {
 496     dims = (jint*) NEW_RESOURCE_ARRAY(jint, nof_dims);
 497   }
 498   for (int index = 0; index &lt; nof_dims; index++) {
 499     // offset from first_size_address is addressed as local[index]
 500     int n = Interpreter::local_offset_in_bytes(index)/jintSize;
 501     dims[index] = first_size_address[n];
 502   }
 503   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(nof_dims, dims, CHECK);
 504   thread-&gt;set_vm_result(obj);
 505 JRT_END
 506 
 507 
 508 JRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))
 509   assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
 510   assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
 511   InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
 512 JRT_END
 513 
<span class="line-added"> 514 JRT_ENTRY(jboolean, InterpreterRuntime::is_substitutable(JavaThread* thread, oopDesc* aobj, oopDesc* bobj))</span>
<span class="line-added"> 515   assert(oopDesc::is_oop(aobj) &amp;&amp; oopDesc::is_oop(bobj), &quot;must be valid oops&quot;);</span>
<span class="line-added"> 516 </span>
<span class="line-added"> 517   Handle ha(THREAD, aobj);</span>
<span class="line-added"> 518   Handle hb(THREAD, bobj);</span>
<span class="line-added"> 519   JavaValue result(T_BOOLEAN);</span>
<span class="line-added"> 520   JavaCallArguments args;</span>
<span class="line-added"> 521   args.push_oop(ha);</span>
<span class="line-added"> 522   args.push_oop(hb);</span>
<span class="line-added"> 523   methodHandle method(thread, Universe::is_substitutable_method());</span>
<span class="line-added"> 524   JavaCalls::call(&amp;result, method, &amp;args, THREAD);</span>
<span class="line-added"> 525   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added"> 526     // Something really bad happened because isSubstitutable() should not throw exceptions</span>
<span class="line-added"> 527     // If it is an error, just let it propagate</span>
<span class="line-added"> 528     // If it is an exception, wrap it into an InternalError</span>
<span class="line-added"> 529     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::Error_klass())) {</span>
<span class="line-added"> 530       Handle e(THREAD, PENDING_EXCEPTION);</span>
<span class="line-added"> 531       CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added"> 532       THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), &quot;Internal error in substitutability test&quot;, e, false);</span>
<span class="line-added"> 533     }</span>
<span class="line-added"> 534   }</span>
<span class="line-added"> 535   return result.get_jboolean();</span>
<span class="line-added"> 536 JRT_END</span>
 537 
 538 // Quicken instance-of and check-cast bytecodes
 539 JRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))
 540   // Force resolving; quicken the bytecode
 541   LastFrameAccessor last_frame(thread);
 542   int which = last_frame.get_index_u2(Bytecodes::_checkcast);
 543   ConstantPool* cpool = last_frame.method()-&gt;constants();
 544   // We&#39;d expect to assert that we&#39;re only here to quicken bytecodes, but in a multithreaded
 545   // program we might have seen an unquick&#39;d bytecode in the interpreter but have another
 546   // thread quicken the bytecode before we get here.
 547   // assert( cpool-&gt;tag_at(which).is_unresolved_klass(), &quot;should only come here to quicken bytecodes&quot; );
 548   Klass* klass = cpool-&gt;klass_at(which, CHECK);
 549   thread-&gt;set_vm_result_2(klass);
 550 JRT_END
 551 
 552 
 553 //------------------------------------------------------------------------------------------------------------------------
 554 // Exceptions
 555 
 556 void InterpreterRuntime::note_trap_inner(JavaThread* thread, int reason,
</pre>
<hr />
<pre>
 873 // and therefore we don&#39;t have the receiver object at our fingertips. (Though,
 874 // on some platforms the receiver still resides in a register...). Thus,
 875 // we have no choice but print an error message not containing the receiver
 876 // type.
 877 JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* thread,
 878                                                                         Method* missingMethod))
 879   ResourceMark rm(thread);
 880   assert(missingMethod != NULL, &quot;sanity&quot;);
 881   methodHandle m(thread, missingMethod);
 882   LinkResolver::throw_abstract_method_error(m, THREAD);
 883 JRT_END
 884 
 885 JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* thread,
 886                                                                      Klass* recvKlass,
 887                                                                      Method* missingMethod))
 888   ResourceMark rm(thread);
 889   methodHandle mh = methodHandle(thread, missingMethod);
 890   LinkResolver::throw_abstract_method_error(mh, recvKlass, THREAD);
 891 JRT_END
 892 
<span class="line-added"> 893 JRT_ENTRY(void, InterpreterRuntime::throw_InstantiationError(JavaThread* thread))</span>
<span class="line-added"> 894   THROW(vmSymbols::java_lang_InstantiationError());</span>
<span class="line-added"> 895 JRT_END</span>
<span class="line-added"> 896 </span>
 897 
 898 JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))
 899   THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 900 JRT_END
 901 
 902 JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,
 903                                                                               Klass* recvKlass,
 904                                                                               Klass* interfaceKlass))
 905   ResourceMark rm(thread);
 906   char buf[1000];
 907   buf[0] = &#39;\0&#39;;
 908   jio_snprintf(buf, sizeof(buf),
 909                &quot;Class %s does not implement the requested interface %s&quot;,
 910                recvKlass ? recvKlass-&gt;external_name() : &quot;NULL&quot;,
 911                interfaceKlass ? interfaceKlass-&gt;external_name() : &quot;NULL&quot;);
 912   THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 913 JRT_END
 914 
 915 //------------------------------------------------------------------------------------------------------------------------
 916 // Fields
 917 //
 918 
 919 void InterpreterRuntime::resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode) {
 920   Thread* THREAD = thread;
 921   // resolve field
 922   fieldDescriptor info;
 923   LastFrameAccessor last_frame(thread);
 924   constantPoolHandle pool(thread, last_frame.method()-&gt;constants());
 925   methodHandle m(thread, last_frame.method());
 926   bool is_put    = (bytecode == Bytecodes::_putfield  || bytecode == Bytecodes::_nofast_putfield ||
<span class="line-modified"> 927                     bytecode == Bytecodes::_putstatic || bytecode == Bytecodes::_withfield);</span>
 928   bool is_static = (bytecode == Bytecodes::_getstatic || bytecode == Bytecodes::_putstatic);
<span class="line-added"> 929   bool is_value  = bytecode == Bytecodes::_withfield;</span>
 930 
 931   {
 932     JvmtiHideSingleStepping jhss(thread);
 933     LinkResolver::resolve_field_access(info, pool, last_frame.get_index_u2_cpcache(bytecode),
 934                                        m, bytecode, CHECK);
 935   } // end JvmtiHideSingleStepping
 936 
 937   // check if link resolution caused cpCache to be updated
 938   ConstantPoolCacheEntry* cp_cache_entry = last_frame.cache_entry();
 939   if (cp_cache_entry-&gt;is_resolved(bytecode)) return;
 940 
 941   // compute auxiliary field attributes
 942   TosState state  = as_TosState(info.field_type());
 943 
 944   // Resolution of put instructions on final fields is delayed. That is required so that
 945   // exceptions are thrown at the correct place (when the instruction is actually invoked).
 946   // If we do not resolve an instruction in the current pass, leaving the put_code
 947   // set to zero will cause the next put instruction to the same field to reresolve.
 948 
 949   // Resolution of put instructions to final instance fields with invalid updates (i.e.,
</pre>
<hr />
<pre>
 953   // initializer method &lt;init&gt;. If resolution were not inhibited, a putfield
 954   // in an initializer method could be resolved in the initializer. Subsequent
 955   // putfield instructions to the same field would then use cached information.
 956   // As a result, those instructions would not pass through the VM. That is,
 957   // checks in resolve_field_access() would not be executed for those instructions
 958   // and the required IllegalAccessError would not be thrown.
 959   //
 960   // Also, we need to delay resolving getstatic and putstatic instructions until the
 961   // class is initialized.  This is required so that access to the static
 962   // field will call the initialization function every time until the class
 963   // is completely initialized ala. in 2.17.5 in JVM Specification.
 964   InstanceKlass* klass = info.field_holder();
 965   bool uninitialized_static = is_static &amp;&amp; !klass-&gt;is_initialized();
 966   bool has_initialized_final_update = info.field_holder()-&gt;major_version() &gt;= 53 &amp;&amp;
 967                                       info.has_initialized_final_update();
 968   assert(!(has_initialized_final_update &amp;&amp; !info.access_flags().is_final()), &quot;Fields with initialized final updates must be final&quot;);
 969 
 970   Bytecodes::Code get_code = (Bytecodes::Code)0;
 971   Bytecodes::Code put_code = (Bytecodes::Code)0;
 972   if (!uninitialized_static) {
<span class="line-modified"> 973     if (is_static) {</span>
<span class="line-modified"> 974       get_code = Bytecodes::_getstatic;</span>
<span class="line-modified"> 975     } else {</span>
<span class="line-added"> 976       get_code = Bytecodes::_getfield;</span>
<span class="line-added"> 977     }</span>
<span class="line-added"> 978     if (is_put &amp;&amp; is_value) {</span>
<span class="line-added"> 979         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);</span>
<span class="line-added"> 980     } else if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {</span>
<span class="line-added"> 981         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);</span>
 982     }
 983   }
 984 
 985   cp_cache_entry-&gt;set_field(
 986     get_code,
 987     put_code,
 988     info.field_holder(),
 989     info.index(),
 990     info.offset(),
 991     state,
 992     info.access_flags().is_final(),
 993     info.access_flags().is_volatile(),
<span class="line-added"> 994     info.is_flattened(),</span>
<span class="line-added"> 995     info.is_flattenable(),</span>
 996     pool-&gt;pool_holder()
 997   );
 998 }
 999 
1000 
1001 //------------------------------------------------------------------------------------------------------------------------
1002 // Synchronization
1003 //
1004 // The interpreter&#39;s synchronization code is factored out so that it can
1005 // be shared by method invocation and synchronized blocks.
1006 //%note synchronization_3
1007 
1008 //%note monitor_1
1009 JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
1010 #ifdef ASSERT
1011   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
1012 #endif
1013   if (PrintBiasedLockingStatistics) {
1014     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
1015   }
</pre>
<hr />
<pre>
1225   int index = last_frame.get_index_u4(bytecode);
1226   {
1227     JvmtiHideSingleStepping jhss(thread);
1228     LinkResolver::resolve_invoke(info, Handle(), pool,
1229                                  index, bytecode, CHECK);
1230   } // end JvmtiHideSingleStepping
1231 
1232   ConstantPoolCacheEntry* cp_cache_entry = pool-&gt;invokedynamic_cp_cache_entry_at(index);
1233   cp_cache_entry-&gt;set_dynamic_call(pool, info);
1234 }
1235 
1236 // This function is the interface to the assembly code. It returns the resolved
1237 // cpCache entry.  This doesn&#39;t safepoint, but the helper routines safepoint.
1238 // This function will check for redefinition!
1239 JRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode)) {
1240   switch (bytecode) {
1241   case Bytecodes::_getstatic:
1242   case Bytecodes::_putstatic:
1243   case Bytecodes::_getfield:
1244   case Bytecodes::_putfield:
<span class="line-added">1245   case Bytecodes::_withfield:</span>
1246     resolve_get_put(thread, bytecode);
1247     break;
1248   case Bytecodes::_invokevirtual:
1249   case Bytecodes::_invokespecial:
1250   case Bytecodes::_invokestatic:
1251   case Bytecodes::_invokeinterface:
1252     resolve_invoke(thread, bytecode);
1253     break;
1254   case Bytecodes::_invokehandle:
1255     resolve_invokehandle(thread);
1256     break;
1257   case Bytecodes::_invokedynamic:
1258     resolve_invokedynamic(thread);
1259     break;
1260   default:
1261     fatal(&quot;unexpected bytecode: %s&quot;, Bytecodes::name(bytecode));
1262     break;
1263   }
1264 }
1265 JRT_END
</pre>
<hr />
<pre>
1452 
1453   if (JvmtiExport::should_post_single_step()) {
1454     // We are called during regular safepoints and when the VM is
1455     // single stepping. If any thread is marked for single stepping,
1456     // then we may have JVMTI work to do.
1457     LastFrameAccessor last_frame(thread);
1458     JvmtiExport::at_single_stepping_point(thread, last_frame.method(), last_frame.bcp());
1459   }
1460 JRT_END
1461 
1462 JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,
1463 ConstantPoolCacheEntry *cp_entry))
1464 
1465   // check the access_flags for the field in the klass
1466 
1467   InstanceKlass* ik = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
1468   int index = cp_entry-&gt;field_index();
1469   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_ACCESS_WATCHED) == 0) return;
1470 
1471   bool is_static = (obj == NULL);
<span class="line-added">1472   bool is_flattened = cp_entry-&gt;is_flattened();</span>
1473   HandleMark hm(thread);
1474 
1475   Handle h_obj;
1476   if (!is_static) {
1477     // non-static field accessors have an object, but we need a handle
1478     h_obj = Handle(thread, obj);
1479   }
1480   InstanceKlass* cp_entry_f1 = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
<span class="line-modified">1481   jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry-&gt;f2_as_index(), is_static, is_flattened);</span>
1482   LastFrameAccessor last_frame(thread);
1483   JvmtiExport::post_field_access(thread, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);
1484 JRT_END
1485 
1486 JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,
1487   oopDesc* obj, ConstantPoolCacheEntry *cp_entry, jvalue *value))
1488 
1489   Klass* k = cp_entry-&gt;f1_as_klass();
1490 
1491   // check the access_flags for the field in the klass
1492   InstanceKlass* ik = InstanceKlass::cast(k);
1493   int index = cp_entry-&gt;field_index();
1494   // bail out if field modifications are not watched
1495   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_MODIFICATION_WATCHED) == 0) return;
1496 
1497   char sig_type = &#39;\0&#39;;
1498 
1499   switch(cp_entry-&gt;flag_state()) {
1500     case btos: sig_type = JVM_SIGNATURE_BYTE;    break;
1501     case ztos: sig_type = JVM_SIGNATURE_BOOLEAN; break;
1502     case ctos: sig_type = JVM_SIGNATURE_CHAR;    break;
1503     case stos: sig_type = JVM_SIGNATURE_SHORT;   break;
1504     case itos: sig_type = JVM_SIGNATURE_INT;     break;
1505     case ftos: sig_type = JVM_SIGNATURE_FLOAT;   break;
1506     case atos: sig_type = JVM_SIGNATURE_CLASS;   break;
1507     case ltos: sig_type = JVM_SIGNATURE_LONG;    break;
1508     case dtos: sig_type = JVM_SIGNATURE_DOUBLE;  break;
1509     default:  ShouldNotReachHere(); return;
1510   }
<span class="line-added">1511 </span>
<span class="line-added">1512   // Both Q-signatures and L-signatures are mapped to atos</span>
<span class="line-added">1513   if (cp_entry-&gt;flag_state() == atos &amp;&amp; ik-&gt;field_signature(index)-&gt;is_Q_signature()) {</span>
<span class="line-added">1514     sig_type = JVM_SIGNATURE_VALUETYPE;</span>
<span class="line-added">1515   }</span>
<span class="line-added">1516 </span>
1517   bool is_static = (obj == NULL);
<span class="line-added">1518   bool is_flattened = cp_entry-&gt;is_flattened();</span>
1519 
1520   HandleMark hm(thread);
<span class="line-modified">1521   jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry-&gt;f2_as_index(), is_static, is_flattened);</span>
1522   jvalue fvalue;
1523 #ifdef _LP64
1524   fvalue = *value;
1525 #else
1526   // Long/double values are stored unaligned and also noncontiguously with
1527   // tagged stacks.  We can&#39;t just do a simple assignment even in the non-
1528   // J/D cases because a C++ compiler is allowed to assume that a jvalue is
1529   // 8-byte aligned, and interpreter stack slots are only 4-byte aligned.
1530   // We assume that the two halves of longs/doubles are stored in interpreter
1531   // stack slots in platform-endian order.
1532   jlong_accessor u;
1533   jint* newval = (jint*)value;
1534   u.words[0] = newval[0];
1535   u.words[1] = newval[Interpreter::stackElementWords]; // skip if tag
1536   fvalue.j = u.long_value;
1537 #endif // _LP64
1538 
1539   Handle h_obj;
1540   if (!is_static) {
1541     // non-static field accessors have an object, but we need a handle
</pre>
</td>
</tr>
</table>
<center><a href="../gc/z/zBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciCompilerToVM.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_GraphBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
  30 #include &quot;interpreter/interp_masm.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  33 #include &quot;interpreter/templateInterpreterGenerator.hpp&quot;
  34 #include &quot;interpreter/templateTable.hpp&quot;
  35 #include &quot;oops/arrayOop.hpp&quot;
  36 #include &quot;oops/methodData.hpp&quot;
  37 #include &quot;oops/method.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;

  39 #include &quot;prims/jvmtiExport.hpp&quot;
  40 #include &quot;prims/jvmtiThreadState.hpp&quot;
  41 #include &quot;runtime/arguments.hpp&quot;
  42 #include &quot;runtime/deoptimization.hpp&quot;
  43 #include &quot;runtime/frame.inline.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;runtime/stubRoutines.hpp&quot;
  46 #include &quot;runtime/synchronizer.hpp&quot;
  47 #include &quot;runtime/timer.hpp&quot;
  48 #include &quot;runtime/vframeArray.hpp&quot;
  49 #include &quot;utilities/debug.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 
  52 #define __ Disassembler::hook&lt;InterpreterMacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
  53 
  54 // Size of interpreter code.  Increase if too small.  Interpreter will
  55 // fail with a guarantee (&quot;not enough space for interpreter generation&quot;);
  56 // if too small.
  57 // Run with +PrintInterpreter to get the VM to print out the size.
  58 // Max size with JVMTI
  59 #ifdef AMD64
<span class="line-modified">  60 int TemplateInterpreter::InterpreterCodeSize = JVMCI_ONLY(268) NOT_JVMCI(256) * 1024;</span>
  61 #else
  62 int TemplateInterpreter::InterpreterCodeSize = 224 * 1024;
  63 #endif // AMD64
  64 
  65 // Global Register Names
  66 static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);
  67 static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);
  68 
  69 const int method_offset = frame::interpreter_frame_method_offset * wordSize;
  70 const int bcp_offset    = frame::interpreter_frame_bcp_offset    * wordSize;
  71 const int locals_offset = frame::interpreter_frame_locals_offset * wordSize;
  72 
  73 
  74 //-----------------------------------------------------------------------------
  75 
  76 address TemplateInterpreterGenerator::generate_StackOverflowError_handler() {
  77   address entry = __ pc();
  78 
  79 #ifdef ASSERT
  80   {
</pre>
<hr />
<pre>
 188   }
 189 #endif // COMPILER2
 190   if ((state == ftos &amp;&amp; UseSSE &lt; 1) || (state == dtos &amp;&amp; UseSSE &lt; 2)) {
 191     __ MacroAssembler::verify_FPU(1, &quot;generate_return_entry_for compiled&quot;);
 192   } else {
 193     __ MacroAssembler::verify_FPU(0, &quot;generate_return_entry_for compiled&quot;);
 194   }
 195 
 196   if (state == ftos) {
 197     __ MacroAssembler::verify_FPU(UseSSE &gt;= 1 ? 0 : 1, &quot;generate_return_entry_for in interpreter&quot;);
 198   } else if (state == dtos) {
 199     __ MacroAssembler::verify_FPU(UseSSE &gt;= 2 ? 0 : 1, &quot;generate_return_entry_for in interpreter&quot;);
 200   }
 201 #endif // _LP64
 202 
 203   // Restore stack bottom in case i2c adjusted stack
 204   __ movptr(rsp, Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize));
 205   // and NULL it as marker that esp is now tos until next java call
 206   __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);
 207 




 208   __ restore_bcp();
 209   __ restore_locals();
 210 
 211   if (state == atos) {
 212     Register mdp = rbx;
 213     Register tmp = rcx;
 214     __ profile_return_type(mdp, rax, tmp);
 215   }
 216 
 217   const Register cache = rbx;
 218   const Register index = rcx;
 219   __ get_cache_and_index_at_bcp(cache, index, 1, index_size);
 220 
 221   const Register flags = cache;
 222   __ movl(flags, Address(cache, index, Address::times_ptr, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));
 223   __ andl(flags, ConstantPoolCacheEntry::parameter_size_mask);
 224   __ lea(rsp, Address(rsp, flags, Interpreter::stackElementScale()));
 225 
 226    const Register java_thread = NOT_LP64(rcx) LP64_ONLY(r15_thread);
 227    if (JvmtiExport::can_pop_frame()) {
</pre>
<hr />
<pre>
 330         // Store as float and empty fpu stack
 331         __ fstp_s(Address(rsp, 0));
 332         // and reload
 333         __ movflt(xmm0, Address(rsp, 0));
 334       } else if (type == T_DOUBLE &amp;&amp; UseSSE &gt;= 2 ) {
 335         __ movdbl(xmm0, Address(rsp, 0));
 336       } else {
 337         // restore ST0
 338         __ fld_d(Address(rsp, 0));
 339       }
 340       // and pop the temp
 341       __ addptr(rsp, 2 * wordSize);
 342       __ push(t);                           // restore return address
 343     }
 344     break;
 345 #else
 346   case T_FLOAT  : /* nothing to do */        break;
 347   case T_DOUBLE : /* nothing to do */        break;
 348 #endif // _LP64
 349 

 350   case T_OBJECT :
 351     // retrieve result from frame
 352     __ movptr(rax, Address(rbp, frame::interpreter_frame_oop_temp_offset*wordSize));
 353     // and verify it
 354     __ verify_oop(rax);
 355     break;
 356   default       : ShouldNotReachHere();
 357   }
 358   __ ret(0);                                   // return from result handler
 359   return entry;
 360 }
 361 
 362 address TemplateInterpreterGenerator::generate_safept_entry_for(
 363         TosState state,
 364         address runtime_entry) {
 365   address entry = __ pc();
 366   __ push(state);
 367   __ call_VM(noreg, runtime_entry);
 368   __ dispatch_via(vtos, Interpreter::_normal_table.table_for(vtos));
 369   return entry;
</pre>
</td>
<td>
<hr />
<pre>
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
  30 #include &quot;interpreter/interp_masm.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  33 #include &quot;interpreter/templateInterpreterGenerator.hpp&quot;
  34 #include &quot;interpreter/templateTable.hpp&quot;
  35 #include &quot;oops/arrayOop.hpp&quot;
  36 #include &quot;oops/methodData.hpp&quot;
  37 #include &quot;oops/method.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  39 #include &quot;oops/valueKlass.hpp&quot;</span>
  40 #include &quot;prims/jvmtiExport.hpp&quot;
  41 #include &quot;prims/jvmtiThreadState.hpp&quot;
  42 #include &quot;runtime/arguments.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;runtime/frame.inline.hpp&quot;
  45 #include &quot;runtime/sharedRuntime.hpp&quot;
  46 #include &quot;runtime/stubRoutines.hpp&quot;
  47 #include &quot;runtime/synchronizer.hpp&quot;
  48 #include &quot;runtime/timer.hpp&quot;
  49 #include &quot;runtime/vframeArray.hpp&quot;
  50 #include &quot;utilities/debug.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;
  52 
  53 #define __ Disassembler::hook&lt;InterpreterMacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
  54 
  55 // Size of interpreter code.  Increase if too small.  Interpreter will
  56 // fail with a guarantee (&quot;not enough space for interpreter generation&quot;);
  57 // if too small.
  58 // Run with +PrintInterpreter to get the VM to print out the size.
  59 // Max size with JVMTI
  60 #ifdef AMD64
<span class="line-modified">  61 int TemplateInterpreter::InterpreterCodeSize = JVMCI_ONLY(280) NOT_JVMCI(268) * 1024;</span>
  62 #else
  63 int TemplateInterpreter::InterpreterCodeSize = 224 * 1024;
  64 #endif // AMD64
  65 
  66 // Global Register Names
  67 static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);
  68 static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);
  69 
  70 const int method_offset = frame::interpreter_frame_method_offset * wordSize;
  71 const int bcp_offset    = frame::interpreter_frame_bcp_offset    * wordSize;
  72 const int locals_offset = frame::interpreter_frame_locals_offset * wordSize;
  73 
  74 
  75 //-----------------------------------------------------------------------------
  76 
  77 address TemplateInterpreterGenerator::generate_StackOverflowError_handler() {
  78   address entry = __ pc();
  79 
  80 #ifdef ASSERT
  81   {
</pre>
<hr />
<pre>
 189   }
 190 #endif // COMPILER2
 191   if ((state == ftos &amp;&amp; UseSSE &lt; 1) || (state == dtos &amp;&amp; UseSSE &lt; 2)) {
 192     __ MacroAssembler::verify_FPU(1, &quot;generate_return_entry_for compiled&quot;);
 193   } else {
 194     __ MacroAssembler::verify_FPU(0, &quot;generate_return_entry_for compiled&quot;);
 195   }
 196 
 197   if (state == ftos) {
 198     __ MacroAssembler::verify_FPU(UseSSE &gt;= 1 ? 0 : 1, &quot;generate_return_entry_for in interpreter&quot;);
 199   } else if (state == dtos) {
 200     __ MacroAssembler::verify_FPU(UseSSE &gt;= 2 ? 0 : 1, &quot;generate_return_entry_for in interpreter&quot;);
 201   }
 202 #endif // _LP64
 203 
 204   // Restore stack bottom in case i2c adjusted stack
 205   __ movptr(rsp, Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize));
 206   // and NULL it as marker that esp is now tos until next java call
 207   __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);
 208 
<span class="line-added"> 209   if (state == atos &amp;&amp; InlineTypeReturnedAsFields) {</span>
<span class="line-added"> 210     __ store_value_type_fields_to_buf(NULL);</span>
<span class="line-added"> 211   }</span>
<span class="line-added"> 212 </span>
 213   __ restore_bcp();
 214   __ restore_locals();
 215 
 216   if (state == atos) {
 217     Register mdp = rbx;
 218     Register tmp = rcx;
 219     __ profile_return_type(mdp, rax, tmp);
 220   }
 221 
 222   const Register cache = rbx;
 223   const Register index = rcx;
 224   __ get_cache_and_index_at_bcp(cache, index, 1, index_size);
 225 
 226   const Register flags = cache;
 227   __ movl(flags, Address(cache, index, Address::times_ptr, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));
 228   __ andl(flags, ConstantPoolCacheEntry::parameter_size_mask);
 229   __ lea(rsp, Address(rsp, flags, Interpreter::stackElementScale()));
 230 
 231    const Register java_thread = NOT_LP64(rcx) LP64_ONLY(r15_thread);
 232    if (JvmtiExport::can_pop_frame()) {
</pre>
<hr />
<pre>
 335         // Store as float and empty fpu stack
 336         __ fstp_s(Address(rsp, 0));
 337         // and reload
 338         __ movflt(xmm0, Address(rsp, 0));
 339       } else if (type == T_DOUBLE &amp;&amp; UseSSE &gt;= 2 ) {
 340         __ movdbl(xmm0, Address(rsp, 0));
 341       } else {
 342         // restore ST0
 343         __ fld_d(Address(rsp, 0));
 344       }
 345       // and pop the temp
 346       __ addptr(rsp, 2 * wordSize);
 347       __ push(t);                           // restore return address
 348     }
 349     break;
 350 #else
 351   case T_FLOAT  : /* nothing to do */        break;
 352   case T_DOUBLE : /* nothing to do */        break;
 353 #endif // _LP64
 354 
<span class="line-added"> 355   case T_VALUETYPE: // fall through (value types are handled with oops)</span>
 356   case T_OBJECT :
 357     // retrieve result from frame
 358     __ movptr(rax, Address(rbp, frame::interpreter_frame_oop_temp_offset*wordSize));
 359     // and verify it
 360     __ verify_oop(rax);
 361     break;
 362   default       : ShouldNotReachHere();
 363   }
 364   __ ret(0);                                   // return from result handler
 365   return entry;
 366 }
 367 
 368 address TemplateInterpreterGenerator::generate_safept_entry_for(
 369         TosState state,
 370         address runtime_entry) {
 371   address entry = __ pc();
 372   __ push(state);
 373   __ call_VM(noreg, runtime_entry);
 374   __ dispatch_via(vtos, Interpreter::_normal_table.table_for(vtos));
 375   return entry;
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_GraphBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
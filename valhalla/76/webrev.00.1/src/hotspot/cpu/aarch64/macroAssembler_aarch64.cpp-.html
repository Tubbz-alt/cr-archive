<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &lt;sys/types.h&gt;
  27 
  28 #include &quot;precompiled.hpp&quot;
  29 #include &quot;jvm.h&quot;
  30 #include &quot;asm/assembler.hpp&quot;
  31 #include &quot;asm/assembler.inline.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;gc/shared/cardTable.hpp&quot;
  34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  35 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;compiler/disassembler.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/accessDecorators.hpp&quot;
  42 #include &quot;oops/compressedOops.inline.hpp&quot;
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #ifdef COMPILER1
  52 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  53 #endif
  54 #ifdef COMPILER2
  55 #include &quot;oops/oop.hpp&quot;
  56 #include &quot;opto/compile.hpp&quot;
  57 #include &quot;opto/node.hpp&quot;
  58 #include &quot;opto/output.hpp&quot;
  59 #endif
  60 
  61 #ifdef PRODUCT
  62 #define BLOCK_COMMENT(str) /* nothing */
  63 #else
  64 #define BLOCK_COMMENT(str) block_comment(str)
  65 #endif
  66 #define STOP(str) stop(str);
  67 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  68 
  69 // Patch any kind of instruction; there may be several instructions.
  70 // Return the total length (in bytes) of the instructions.
  71 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  72   int instructions = 1;
  73   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  74   long offset = (target - branch) &gt;&gt; 2;
  75   unsigned insn = *(unsigned*)branch;
  76   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
  77     // Load register (literal)
  78     Instruction_aarch64::spatch(branch, 23, 5, offset);
  79   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
  80     // Unconditional branch (immediate)
  81     Instruction_aarch64::spatch(branch, 25, 0, offset);
  82   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
  83     // Conditional branch (immediate)
  84     Instruction_aarch64::spatch(branch, 23, 5, offset);
  85   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
  86     // Compare &amp; branch (immediate)
  87     Instruction_aarch64::spatch(branch, 23, 5, offset);
  88   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
  89     // Test &amp; branch (immediate)
  90     Instruction_aarch64::spatch(branch, 18, 5, offset);
  91   } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
  92     // PC-rel. addressing
  93     offset = target-branch;
  94     int shift = Instruction_aarch64::extract(insn, 31, 31);
  95     if (shift) {
  96       u_int64_t dest = (u_int64_t)target;
  97       uint64_t pc_page = (uint64_t)branch &gt;&gt; 12;
  98       uint64_t adr_page = (uint64_t)target &gt;&gt; 12;
  99       unsigned offset_lo = dest &amp; 0xfff;
 100       offset = adr_page - pc_page;
 101 
 102       // We handle 4 types of PC relative addressing
 103       //   1 - adrp    Rx, target_page
 104       //       ldr/str Ry, [Rx, #offset_in_page]
 105       //   2 - adrp    Rx, target_page
 106       //       add     Ry, Rx, #offset_in_page
 107       //   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 108       //       movk    Rx, #imm16&lt;&lt;32
 109       //   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 110       // In the first 3 cases we must check that Rx is the same in the adrp and the
 111       // subsequent ldr/str, add or movk instruction. Otherwise we could accidentally end
 112       // up treating a type 4 relocation as a type 1, 2 or 3 just because it happened
 113       // to be followed by a random unrelated ldr/str, add or movk instruction.
 114       //
 115       unsigned insn2 = ((unsigned*)branch)[1];
 116       if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &amp;&amp;
 117                 Instruction_aarch64::extract(insn, 4, 0) ==
 118                         Instruction_aarch64::extract(insn2, 9, 5)) {
 119         // Load/store register (unsigned immediate)
 120         unsigned size = Instruction_aarch64::extract(insn2, 31, 30);
 121         Instruction_aarch64::patch(branch + sizeof (unsigned),
 122                                     21, 10, offset_lo &gt;&gt; size);
 123         guarantee(((dest &gt;&gt; size) &lt;&lt; size) == dest, &quot;misaligned target&quot;);
 124         instructions = 2;
 125       } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &amp;&amp;
 126                 Instruction_aarch64::extract(insn, 4, 0) ==
 127                         Instruction_aarch64::extract(insn2, 4, 0)) {
 128         // add (immediate)
 129         Instruction_aarch64::patch(branch + sizeof (unsigned),
 130                                    21, 10, offset_lo);
 131         instructions = 2;
 132       } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &amp;&amp;
 133                    Instruction_aarch64::extract(insn, 4, 0) ==
 134                      Instruction_aarch64::extract(insn2, 4, 0)) {
 135         // movk #imm16&lt;&lt;32
 136         Instruction_aarch64::patch(branch + 4, 20, 5, (uint64_t)target &gt;&gt; 32);
 137         long dest = ((long)target &amp; 0xffffffffL) | ((long)branch &amp; 0xffff00000000L);
 138         long pc_page = (long)branch &gt;&gt; 12;
 139         long adr_page = (long)dest &gt;&gt; 12;
 140         offset = adr_page - pc_page;
 141         instructions = 2;
 142       }
 143     }
 144     int offset_lo = offset &amp; 3;
 145     offset &gt;&gt;= 2;
 146     Instruction_aarch64::spatch(branch, 23, 5, offset);
 147     Instruction_aarch64::patch(branch, 30, 29, offset_lo);
 148   } else if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100) {
 149     u_int64_t dest = (u_int64_t)target;
 150     // Move wide constant
 151     assert(nativeInstruction_at(branch+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 152     assert(nativeInstruction_at(branch+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 153     Instruction_aarch64::patch(branch, 20, 5, dest &amp; 0xffff);
 154     Instruction_aarch64::patch(branch+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 155     Instruction_aarch64::patch(branch+8, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 156     assert(target_addr_for_insn(branch) == target, &quot;should be&quot;);
 157     instructions = 3;
 158   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 159              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 160     // nothing to do
 161     assert(target == 0, &quot;did not expect to relocate target for polling page load&quot;);
 162   } else {
 163     ShouldNotReachHere();
 164   }
 165   return instructions * NativeInstruction::instruction_size;
 166 }
 167 
 168 int MacroAssembler::patch_oop(address insn_addr, address o) {
 169   int instructions;
 170   unsigned insn = *(unsigned*)insn_addr;
 171   assert(nativeInstruction_at(insn_addr+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 172 
 173   // OOPs are either narrow (32 bits) or wide (48 bits).  We encode
 174   // narrow OOPs by setting the upper 16 bits in the first
 175   // instruction.
 176   if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010101) {
 177     // Move narrow OOP
 178     narrowOop n = CompressedOops::encode((oop)o);
 179     Instruction_aarch64::patch(insn_addr, 20, 5, n &gt;&gt; 16);
 180     Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
 181     instructions = 2;
 182   } else {
 183     // Move wide OOP
 184     assert(nativeInstruction_at(insn_addr+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 185     uintptr_t dest = (uintptr_t)o;
 186     Instruction_aarch64::patch(insn_addr, 20, 5, dest &amp; 0xffff);
 187     Instruction_aarch64::patch(insn_addr+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 188     Instruction_aarch64::patch(insn_addr+8, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 189     instructions = 3;
 190   }
 191   return instructions * NativeInstruction::instruction_size;
 192 }
 193 
 194 int MacroAssembler::patch_narrow_klass(address insn_addr, narrowKlass n) {
 195   // Metatdata pointers are either narrow (32 bits) or wide (48 bits).
 196   // We encode narrow ones by setting the upper 16 bits in the first
 197   // instruction.
 198   NativeInstruction *insn = nativeInstruction_at(insn_addr);
 199   assert(Instruction_aarch64::extract(insn-&gt;encoding(), 31, 21) == 0b11010010101 &amp;&amp;
 200          nativeInstruction_at(insn_addr+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 201 
 202   Instruction_aarch64::patch(insn_addr, 20, 5, n &gt;&gt; 16);
 203   Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
 204   return 2 * NativeInstruction::instruction_size;
 205 }
 206 
 207 address MacroAssembler::target_addr_for_insn(address insn_addr, unsigned insn) {
 208   long offset = 0;
 209   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b011011) == 0b00011000) {
 210     // Load register (literal)
 211     offset = Instruction_aarch64::sextract(insn, 23, 5);
 212     return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 213   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
 214     // Unconditional branch (immediate)
 215     offset = Instruction_aarch64::sextract(insn, 25, 0);
 216   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
 217     // Conditional branch (immediate)
 218     offset = Instruction_aarch64::sextract(insn, 23, 5);
 219   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
 220     // Compare &amp; branch (immediate)
 221     offset = Instruction_aarch64::sextract(insn, 23, 5);
 222    } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
 223     // Test &amp; branch (immediate)
 224     offset = Instruction_aarch64::sextract(insn, 18, 5);
 225   } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
 226     // PC-rel. addressing
 227     offset = Instruction_aarch64::extract(insn, 30, 29);
 228     offset |= Instruction_aarch64::sextract(insn, 23, 5) &lt;&lt; 2;
 229     int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;
 230     if (shift) {
 231       offset &lt;&lt;= shift;
 232       uint64_t target_page = ((uint64_t)insn_addr) + offset;
 233       target_page &amp;= ((uint64_t)-1) &lt;&lt; shift;
 234       // Return the target address for the following sequences
 235       //   1 - adrp    Rx, target_page
 236       //       ldr/str Ry, [Rx, #offset_in_page]
 237       //   2 - adrp    Rx, target_page
 238       //       add     Ry, Rx, #offset_in_page
 239       //   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 240       //       movk    Rx, #imm12&lt;&lt;32
 241       //   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 242       //
 243       // In the first two cases  we check that the register is the same and
 244       // return the target_page + the offset within the page.
 245       // Otherwise we assume it is a page aligned relocation and return
 246       // the target page only.
 247       //
 248       unsigned insn2 = ((unsigned*)insn_addr)[1];
 249       if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &amp;&amp;
 250                 Instruction_aarch64::extract(insn, 4, 0) ==
 251                         Instruction_aarch64::extract(insn2, 9, 5)) {
 252         // Load/store register (unsigned immediate)
 253         unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);
 254         unsigned int size = Instruction_aarch64::extract(insn2, 31, 30);
 255         return address(target_page + (byte_offset &lt;&lt; size));
 256       } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &amp;&amp;
 257                 Instruction_aarch64::extract(insn, 4, 0) ==
 258                         Instruction_aarch64::extract(insn2, 4, 0)) {
 259         // add (immediate)
 260         unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);
 261         return address(target_page + byte_offset);
 262       } else {
 263         if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110  &amp;&amp;
 264                Instruction_aarch64::extract(insn, 4, 0) ==
 265                  Instruction_aarch64::extract(insn2, 4, 0)) {
 266           target_page = (target_page &amp; 0xffffffff) |
 267                          ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) &lt;&lt; 32);
 268         }
 269         return (address)target_page;
 270       }
 271     } else {
 272       ShouldNotReachHere();
 273     }
 274   } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
 275     u_int32_t *insns = (u_int32_t *)insn_addr;
 276     // Move wide constant: movz, movk, movk.  See movptr().
 277     assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 278     assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 279     return address(u_int64_t(Instruction_aarch64::extract(insns[0], 20, 5))
 280                    + (u_int64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)
 281                    + (u_int64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));
 282   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 283              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 284     return 0;
 285   } else {
 286     ShouldNotReachHere();
 287   }
 288   return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 289 }
 290 
 291 void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
 292   ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));
 293   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
 294 }
 295 
 296 // Just like safepoint_poll, but use an acquiring load for thread-
 297 // local polling.
 298 //
 299 // We need an acquire here to ensure that any subsequent load of the
 300 // global SafepointSynchronize::_state flag is ordered after this load
 301 // of the local Thread::_polling page.  We don&#39;t want this poll to
 302 // return false (i.e. not safepointing) and a later poll of the global
 303 // SafepointSynchronize::_state spuriously to return true.
 304 //
 305 // This is to avoid a race when we&#39;re in a native-&gt;Java transition
 306 // racing the code which wakes up from a safepoint.
 307 //
 308 void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
 309   lea(rscratch1, Address(rthread, Thread::polling_page_offset()));
 310   ldar(rscratch1, rscratch1);
 311   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
 312 }
 313 
 314 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 315   // we must set sp to zero to clear frame
 316   str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
 317 
 318   // must clear fp, so that compiled frames are not confused; it is
 319   // possible that we need it only for debugging
 320   if (clear_fp) {
 321     str(zr, Address(rthread, JavaThread::last_Java_fp_offset()));
 322   }
 323 
 324   // Always clear the pc because it could have been set by make_walkable()
 325   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 326 }
 327 
 328 // Calls to C land
 329 //
 330 // When entering C land, the rfp, &amp; resp of the last Java frame have to be recorded
 331 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
 332 // has to be reset to 0. This is required to allow proper stack traversal.
 333 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 334                                          Register last_java_fp,
 335                                          Register last_java_pc,
 336                                          Register scratch) {
 337 
 338   if (last_java_pc-&gt;is_valid()) {
 339       str(last_java_pc, Address(rthread,
 340                                 JavaThread::frame_anchor_offset()
 341                                 + JavaFrameAnchor::last_Java_pc_offset()));
 342     }
 343 
 344   // determine last_java_sp register
 345   if (last_java_sp == sp) {
 346     mov(scratch, sp);
 347     last_java_sp = scratch;
 348   } else if (!last_java_sp-&gt;is_valid()) {
 349     last_java_sp = esp;
 350   }
 351 
 352   str(last_java_sp, Address(rthread, JavaThread::last_Java_sp_offset()));
 353 
 354   // last_java_fp is optional
 355   if (last_java_fp-&gt;is_valid()) {
 356     str(last_java_fp, Address(rthread, JavaThread::last_Java_fp_offset()));
 357   }
 358 }
 359 
 360 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 361                                          Register last_java_fp,
 362                                          address  last_java_pc,
 363                                          Register scratch) {
 364   assert(last_java_pc != NULL, &quot;must provide a valid PC&quot;);
 365 
 366   adr(scratch, last_java_pc);
 367   str(scratch, Address(rthread,
 368                        JavaThread::frame_anchor_offset()
 369                        + JavaFrameAnchor::last_Java_pc_offset()));
 370 
 371   set_last_Java_frame(last_java_sp, last_java_fp, noreg, scratch);
 372 }
 373 
 374 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 375                                          Register last_java_fp,
 376                                          Label &amp;L,
 377                                          Register scratch) {
 378   if (L.is_bound()) {
 379     set_last_Java_frame(last_java_sp, last_java_fp, target(L), scratch);
 380   } else {
 381     InstructionMark im(this);
 382     L.add_patch_at(code(), locator());
 383     set_last_Java_frame(last_java_sp, last_java_fp, pc() /* Patched later */, scratch);
 384   }
 385 }
 386 
 387 void MacroAssembler::far_call(Address entry, CodeBuffer *cbuf, Register tmp) {
 388   assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
 389   assert(CodeCache::find_blob(entry.target()) != NULL,
 390          &quot;destination of far call not found in code cache&quot;);
 391   if (far_branches()) {
 392     unsigned long offset;
 393     // We can use ADRP here because we know that the total size of
 394     // the code cache cannot exceed 2Gb.
 395     adrp(tmp, entry, offset);
 396     add(tmp, tmp, offset);
 397     if (cbuf) cbuf-&gt;set_insts_mark();
 398     blr(tmp);
 399   } else {
 400     if (cbuf) cbuf-&gt;set_insts_mark();
 401     bl(entry);
 402   }
 403 }
 404 
 405 void MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {
 406   assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
 407   assert(CodeCache::find_blob(entry.target()) != NULL,
 408          &quot;destination of far call not found in code cache&quot;);
 409   if (far_branches()) {
 410     unsigned long offset;
 411     // We can use ADRP here because we know that the total size of
 412     // the code cache cannot exceed 2Gb.
 413     adrp(tmp, entry, offset);
 414     add(tmp, tmp, offset);
 415     if (cbuf) cbuf-&gt;set_insts_mark();
 416     br(tmp);
 417   } else {
 418     if (cbuf) cbuf-&gt;set_insts_mark();
 419     b(entry);
 420   }
 421 }
 422 
 423 void MacroAssembler::reserved_stack_check() {
 424     // testing if reserved zone needs to be enabled
 425     Label no_reserved_zone_enabling;
 426 
 427     ldr(rscratch1, Address(rthread, JavaThread::reserved_stack_activation_offset()));
 428     cmp(sp, rscratch1);
 429     br(Assembler::LO, no_reserved_zone_enabling);
 430 
 431     enter();   // LR and FP are live.
 432     lea(rscratch1, CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone));
 433     mov(c_rarg0, rthread);
 434     blr(rscratch1);
 435     leave();
 436 
 437     // We have already removed our own frame.
 438     // throw_delayed_StackOverflowError will think that it&#39;s been
 439     // called by our caller.
 440     lea(rscratch1, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
 441     br(rscratch1);
 442     should_not_reach_here();
 443 
 444     bind(no_reserved_zone_enabling);
 445 }
 446 
 447 int MacroAssembler::biased_locking_enter(Register lock_reg,
 448                                          Register obj_reg,
 449                                          Register swap_reg,
 450                                          Register tmp_reg,
 451                                          bool swap_reg_contains_mark,
 452                                          Label&amp; done,
 453                                          Label* slow_case,
 454                                          BiasedLockingCounters* counters) {
 455   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 456   assert_different_registers(lock_reg, obj_reg, swap_reg);
 457 
 458   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL)
 459     counters = BiasedLocking::counters();
 460 
 461   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);
 462   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
 463   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
 464   Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());
 465   Address saved_mark_addr(lock_reg, 0);
 466 
 467   // Biased locking
 468   // See whether the lock is currently biased toward our thread and
 469   // whether the epoch is still valid
 470   // Note that the runtime guarantees sufficient alignment of JavaThread
 471   // pointers to allow age to be placed into low bits
 472   // First check to see whether biasing is even enabled for this object
 473   Label cas_label;
 474   int null_check_offset = -1;
 475   if (!swap_reg_contains_mark) {
 476     null_check_offset = offset();
 477     ldr(swap_reg, mark_addr);
 478   }
 479   andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);
 480   cmp(tmp_reg, (u1)markWord::biased_lock_pattern);
 481   br(Assembler::NE, cas_label);
 482   // The bias pattern is present in the object&#39;s header. Need to check
 483   // whether the bias owner and the epoch are both still current.
 484   load_prototype_header(tmp_reg, obj_reg);
 485   orr(tmp_reg, tmp_reg, rthread);
 486   eor(tmp_reg, swap_reg, tmp_reg);
 487   andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));
 488   if (counters != NULL) {
 489     Label around;
 490     cbnz(tmp_reg, around);
 491     atomic_incw(Address((address)counters-&gt;biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);
 492     b(done);
 493     bind(around);
 494   } else {
 495     cbz(tmp_reg, done);
 496   }
 497 
 498   Label try_revoke_bias;
 499   Label try_rebias;
 500 
 501   // At this point we know that the header has the bias pattern and
 502   // that we are not the bias owner in the current epoch. We need to
 503   // figure out more details about the state of the header in order to
 504   // know what operations can be legally performed on the object&#39;s
 505   // header.
 506 
 507   // If the low three bits in the xor result aren&#39;t clear, that means
 508   // the prototype header is no longer biased and we have to revoke
 509   // the bias on this object.
 510   andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);
 511   cbnz(rscratch1, try_revoke_bias);
 512 
 513   // Biasing is still enabled for this data type. See whether the
 514   // epoch of the current bias is still valid, meaning that the epoch
 515   // bits of the mark word are equal to the epoch bits of the
 516   // prototype header. (Note that the prototype header&#39;s epoch bits
 517   // only change at a safepoint.) If not, attempt to rebias the object
 518   // toward the current thread. Note that we must be absolutely sure
 519   // that the current epoch is invalid in order to do this because
 520   // otherwise the manipulations it performs on the mark word are
 521   // illegal.
 522   andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);
 523   cbnz(rscratch1, try_rebias);
 524 
 525   // The epoch of the current bias is still valid but we know nothing
 526   // about the owner; it might be set or it might be clear. Try to
 527   // acquire the bias of the object using an atomic operation. If this
 528   // fails we will go in to the runtime to revoke the object&#39;s bias.
 529   // Note that we first construct the presumed unbiased header so we
 530   // don&#39;t accidentally blow away another thread&#39;s valid bias.
 531   {
 532     Label here;
 533     mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
 534     andr(swap_reg, swap_reg, rscratch1);
 535     orr(tmp_reg, swap_reg, rthread);
 536     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);
 537     // If the biasing toward our thread failed, this means that
 538     // another thread succeeded in biasing it toward itself and we
 539     // need to revoke that bias. The revocation will occur in the
 540     // interpreter runtime in the slow case.
 541     bind(here);
 542     if (counters != NULL) {
 543       atomic_incw(Address((address)counters-&gt;anonymously_biased_lock_entry_count_addr()),
 544                   tmp_reg, rscratch1, rscratch2);
 545     }
 546   }
 547   b(done);
 548 
 549   bind(try_rebias);
 550   // At this point we know the epoch has expired, meaning that the
 551   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
 552   // circumstances _only_, we are allowed to use the current header&#39;s
 553   // value as the comparison value when doing the cas to acquire the
 554   // bias in the current epoch. In other words, we allow transfer of
 555   // the bias from one thread to another directly in this situation.
 556   //
 557   // FIXME: due to a lack of registers we currently blow away the age
 558   // bits in this situation. Should attempt to preserve them.
 559   {
 560     Label here;
 561     load_prototype_header(tmp_reg, obj_reg);
 562     orr(tmp_reg, rthread, tmp_reg);
 563     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);
 564     // If the biasing toward our thread failed, then another thread
 565     // succeeded in biasing it toward itself and we need to revoke that
 566     // bias. The revocation will occur in the runtime in the slow case.
 567     bind(here);
 568     if (counters != NULL) {
 569       atomic_incw(Address((address)counters-&gt;rebiased_lock_entry_count_addr()),
 570                   tmp_reg, rscratch1, rscratch2);
 571     }
 572   }
 573   b(done);
 574 
 575   bind(try_revoke_bias);
 576   // The prototype mark in the klass doesn&#39;t have the bias bit set any
 577   // more, indicating that objects of this data type are not supposed
 578   // to be biased any more. We are going to try to reset the mark of
 579   // this object to the prototype value and fall through to the
 580   // CAS-based locking scheme. Note that if our CAS fails, it means
 581   // that another thread raced us for the privilege of revoking the
 582   // bias of this particular object, so it&#39;s okay to continue in the
 583   // normal locking code.
 584   //
 585   // FIXME: due to a lack of registers we currently blow away the age
 586   // bits in this situation. Should attempt to preserve them.
 587   {
 588     Label here, nope;
 589     load_prototype_header(tmp_reg, obj_reg);
 590     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &amp;nope);
 591     bind(here);
 592 
 593     // Fall through to the normal CAS-based lock, because no matter what
 594     // the result of the above CAS, some thread must have succeeded in
 595     // removing the bias bit from the object&#39;s header.
 596     if (counters != NULL) {
 597       atomic_incw(Address((address)counters-&gt;revoked_lock_entry_count_addr()), tmp_reg,
 598                   rscratch1, rscratch2);
 599     }
 600     bind(nope);
 601   }
 602 
 603   bind(cas_label);
 604 
 605   return null_check_offset;
 606 }
 607 
 608 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 609   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 610 
 611   // Check for biased locking unlock case, which is a no-op
 612   // Note: we do not have to check the thread ID for two reasons.
 613   // First, the interpreter checks for IllegalMonitorStateException at
 614   // a higher level. Second, if the bias was revoked while we held the
 615   // lock, the object could not be rebiased toward another thread, so
 616   // the bias bit would be clear.
 617   ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 618   andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);
 619   cmp(temp_reg, (u1)markWord::biased_lock_pattern);
 620   br(Assembler::EQ, done);
 621 }
 622 
 623 static void pass_arg0(MacroAssembler* masm, Register arg) {
 624   if (c_rarg0 != arg ) {
 625     masm-&gt;mov(c_rarg0, arg);
 626   }
 627 }
 628 
 629 static void pass_arg1(MacroAssembler* masm, Register arg) {
 630   if (c_rarg1 != arg ) {
 631     masm-&gt;mov(c_rarg1, arg);
 632   }
 633 }
 634 
 635 static void pass_arg2(MacroAssembler* masm, Register arg) {
 636   if (c_rarg2 != arg ) {
 637     masm-&gt;mov(c_rarg2, arg);
 638   }
 639 }
 640 
 641 static void pass_arg3(MacroAssembler* masm, Register arg) {
 642   if (c_rarg3 != arg ) {
 643     masm-&gt;mov(c_rarg3, arg);
 644   }
 645 }
 646 
 647 void MacroAssembler::call_VM_base(Register oop_result,
 648                                   Register java_thread,
 649                                   Register last_java_sp,
 650                                   address  entry_point,
 651                                   int      number_of_arguments,
 652                                   bool     check_exceptions) {
 653    // determine java_thread register
 654   if (!java_thread-&gt;is_valid()) {
 655     java_thread = rthread;
 656   }
 657 
 658   // determine last_java_sp register
 659   if (!last_java_sp-&gt;is_valid()) {
 660     last_java_sp = esp;
 661   }
 662 
 663   // debugging support
 664   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 665   assert(java_thread == rthread, &quot;unexpected register&quot;);
 666 #ifdef ASSERT
 667   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
 668   // if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);
 669 #endif // ASSERT
 670 
 671   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
 672   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
 673 
 674   // push java thread (becomes first argument of C function)
 675 
 676   mov(c_rarg0, java_thread);
 677 
 678   // set last Java frame before call
 679   assert(last_java_sp != rfp, &quot;can&#39;t use rfp&quot;);
 680 
 681   Label l;
 682   set_last_Java_frame(last_java_sp, rfp, l, rscratch1);
 683 
 684   // do the call, remove parameters
 685   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments, &amp;l);
 686 
 687   // reset last Java frame
 688   // Only interpreter should have to clear fp
 689   reset_last_Java_frame(true);
 690 
 691    // C++ interp handles this in the interpreter
 692   check_and_handle_popframe(java_thread);
 693   check_and_handle_earlyret(java_thread);
 694 
 695   if (check_exceptions) {
 696     // check for pending exceptions (java_thread is set upon return)
 697     ldr(rscratch1, Address(java_thread, in_bytes(Thread::pending_exception_offset())));
 698     Label ok;
 699     cbz(rscratch1, ok);
 700     lea(rscratch1, RuntimeAddress(StubRoutines::forward_exception_entry()));
 701     br(rscratch1);
 702     bind(ok);
 703   }
 704 
 705   // get oop result if there is one and reset the value in the thread
 706   if (oop_result-&gt;is_valid()) {
 707     get_vm_result(oop_result, java_thread);
 708   }
 709 }
 710 
 711 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 712   call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);
 713 }
 714 
 715 // Maybe emit a call via a trampoline.  If the code cache is small
 716 // trampolines won&#39;t be emitted.
 717 
 718 address MacroAssembler::trampoline_call(Address entry, CodeBuffer *cbuf) {
 719   assert(JavaThread::current()-&gt;is_Compiler_thread(), &quot;just checking&quot;);
 720   assert(entry.rspec().type() == relocInfo::runtime_call_type
 721          || entry.rspec().type() == relocInfo::opt_virtual_call_type
 722          || entry.rspec().type() == relocInfo::static_call_type
 723          || entry.rspec().type() == relocInfo::virtual_call_type, &quot;wrong reloc type&quot;);
 724 
 725   // We need a trampoline if branches are far.
 726   if (far_branches()) {
 727     bool in_scratch_emit_size = false;
 728 #ifdef COMPILER2
 729     // We don&#39;t want to emit a trampoline if C2 is generating dummy
 730     // code during its branch shortening phase.
 731     CompileTask* task = ciEnv::current()-&gt;task();
 732     in_scratch_emit_size =
 733       (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
 734        Compile::current()-&gt;output()-&gt;in_scratch_emit_size());
 735 #endif
 736     if (!in_scratch_emit_size) {
 737       address stub = emit_trampoline_stub(offset(), entry.target());
 738       if (stub == NULL) {
 739         return NULL; // CodeCache is full
 740       }
 741     }
 742   }
 743 
 744   if (cbuf) cbuf-&gt;set_insts_mark();
 745   relocate(entry.rspec());
 746   if (!far_branches()) {
 747     bl(entry.target());
 748   } else {
 749     bl(pc());
 750   }
 751   // just need to return a non-null address
 752   return pc();
 753 }
 754 
 755 
 756 // Emit a trampoline stub for a call to a target which is too far away.
 757 //
 758 // code sequences:
 759 //
 760 // call-site:
 761 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 762 //
 763 // Related trampoline stub for this call site in the stub section:
 764 //   load the call target from the constant pool
 765 //   branch (LR still points to the call site above)
 766 
 767 address MacroAssembler::emit_trampoline_stub(int insts_call_instruction_offset,
 768                                              address dest) {
 769   // Max stub size: alignment nop, TrampolineStub.
 770   address stub = start_a_stub(NativeInstruction::instruction_size
 771                    + NativeCallTrampolineStub::instruction_size);
 772   if (stub == NULL) {
 773     return NULL;  // CodeBuffer::expand failed
 774   }
 775 
 776   // Create a trampoline stub relocation which relates this trampoline stub
 777   // with the call instruction at insts_call_instruction_offset in the
 778   // instructions code-section.
 779   align(wordSize);
 780   relocate(trampoline_stub_Relocation::spec(code()-&gt;insts()-&gt;start()
 781                                             + insts_call_instruction_offset));
 782   const int stub_start_offset = offset();
 783 
 784   // Now, create the trampoline stub&#39;s code:
 785   // - load the call
 786   // - call
 787   Label target;
 788   ldr(rscratch1, target);
 789   br(rscratch1);
 790   bind(target);
 791   assert(offset() - stub_start_offset == NativeCallTrampolineStub::data_offset,
 792          &quot;should be&quot;);
 793   emit_int64((int64_t)dest);
 794 
 795   const address stub_start_addr = addr_at(stub_start_offset);
 796 
 797   assert(is_NativeCallTrampolineStub_at(stub_start_addr), &quot;doesn&#39;t look like a trampoline&quot;);
 798 
 799   end_a_stub();
 800   return stub_start_addr;
 801 }
 802 
 803 void MacroAssembler::emit_static_call_stub() {
 804   // CompiledDirectStaticCall::set_to_interpreted knows the
 805   // exact layout of this stub.
 806 
 807   isb();
 808   mov_metadata(rmethod, (Metadata*)NULL);
 809 
 810   // Jump to the entry point of the i2c stub.
 811   movptr(rscratch1, 0);
 812   br(rscratch1);
 813 }
 814 
 815 void MacroAssembler::c2bool(Register x) {
 816   // implements x == 0 ? 0 : 1
 817   // note: must only look at least-significant byte of x
 818   //       since C-style booleans are stored in one byte
 819   //       only! (was bug)
 820   tst(x, 0xff);
 821   cset(x, Assembler::NE);
 822 }
 823 
 824 address MacroAssembler::ic_call(address entry, jint method_index) {
 825   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
 826   // address const_ptr = long_constant((jlong)Universe::non_oop_word());
 827   // unsigned long offset;
 828   // ldr_constant(rscratch2, const_ptr);
 829   movptr(rscratch2, (uintptr_t)Universe::non_oop_word());
 830   return trampoline_call(Address(entry, rh));
 831 }
 832 
 833 // Implementation of call_VM versions
 834 
 835 void MacroAssembler::call_VM(Register oop_result,
 836                              address entry_point,
 837                              bool check_exceptions) {
 838   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
 839 }
 840 
 841 void MacroAssembler::call_VM(Register oop_result,
 842                              address entry_point,
 843                              Register arg_1,
 844                              bool check_exceptions) {
 845   pass_arg1(this, arg_1);
 846   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
 847 }
 848 
 849 void MacroAssembler::call_VM(Register oop_result,
 850                              address entry_point,
 851                              Register arg_1,
 852                              Register arg_2,
 853                              bool check_exceptions) {
 854   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 855   pass_arg2(this, arg_2);
 856   pass_arg1(this, arg_1);
 857   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
 858 }
 859 
 860 void MacroAssembler::call_VM(Register oop_result,
 861                              address entry_point,
 862                              Register arg_1,
 863                              Register arg_2,
 864                              Register arg_3,
 865                              bool check_exceptions) {
 866   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
 867   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
 868   pass_arg3(this, arg_3);
 869 
 870   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 871   pass_arg2(this, arg_2);
 872 
 873   pass_arg1(this, arg_1);
 874   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
 875 }
 876 
 877 void MacroAssembler::call_VM(Register oop_result,
 878                              Register last_java_sp,
 879                              address entry_point,
 880                              int number_of_arguments,
 881                              bool check_exceptions) {
 882   call_VM_base(oop_result, rthread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 883 }
 884 
 885 void MacroAssembler::call_VM(Register oop_result,
 886                              Register last_java_sp,
 887                              address entry_point,
 888                              Register arg_1,
 889                              bool check_exceptions) {
 890   pass_arg1(this, arg_1);
 891   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 892 }
 893 
 894 void MacroAssembler::call_VM(Register oop_result,
 895                              Register last_java_sp,
 896                              address entry_point,
 897                              Register arg_1,
 898                              Register arg_2,
 899                              bool check_exceptions) {
 900 
 901   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 902   pass_arg2(this, arg_2);
 903   pass_arg1(this, arg_1);
 904   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 905 }
 906 
 907 void MacroAssembler::call_VM(Register oop_result,
 908                              Register last_java_sp,
 909                              address entry_point,
 910                              Register arg_1,
 911                              Register arg_2,
 912                              Register arg_3,
 913                              bool check_exceptions) {
 914   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
 915   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
 916   pass_arg3(this, arg_3);
 917   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 918   pass_arg2(this, arg_2);
 919   pass_arg1(this, arg_1);
 920   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 921 }
 922 
 923 
 924 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
 925   ldr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
 926   str(zr, Address(java_thread, JavaThread::vm_result_offset()));
 927   verify_oop(oop_result, &quot;broken oop in call_VM_base&quot;);
 928 }
 929 
 930 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
 931   ldr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
 932   str(zr, Address(java_thread, JavaThread::vm_result_2_offset()));
 933 }
 934 
 935 void MacroAssembler::align(int modulus) {
 936   while (offset() % modulus != 0) nop();
 937 }
 938 
 939 // these are no-ops overridden by InterpreterMacroAssembler
 940 
 941 void MacroAssembler::check_and_handle_earlyret(Register java_thread) { }
 942 
 943 void MacroAssembler::check_and_handle_popframe(Register java_thread) { }
 944 
 945 
 946 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
 947                                                       Register tmp,
 948                                                       int offset) {
 949   intptr_t value = *delayed_value_addr;
 950   if (value != 0)
 951     return RegisterOrConstant(value + offset);
 952 
 953   // load indirectly to solve generation ordering problem
 954   ldr(tmp, ExternalAddress((address) delayed_value_addr));
 955 
 956   if (offset != 0)
 957     add(tmp, tmp, offset);
 958 
 959   return RegisterOrConstant(tmp);
 960 }
 961 
 962 // Look up the method for a megamorphic invokeinterface call.
 963 // The target method is determined by &lt;intf_klass, itable_index&gt;.
 964 // The receiver klass is in recv_klass.
 965 // On success, the result will be in method_result, and execution falls through.
 966 // On failure, execution transfers to the given label.
 967 void MacroAssembler::lookup_interface_method(Register recv_klass,
 968                                              Register intf_klass,
 969                                              RegisterOrConstant itable_index,
 970                                              Register method_result,
 971                                              Register scan_temp,
 972                                              Label&amp; L_no_such_interface,
 973                          bool return_method) {
 974   assert_different_registers(recv_klass, intf_klass, scan_temp);
 975   assert_different_registers(method_result, intf_klass, scan_temp);
 976   assert(recv_klass != method_result || !return_method,
 977      &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
 978   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
 979          &quot;caller must use same register for non-constant itable index as for method&quot;);
 980 
 981   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
 982   int vtable_base = in_bytes(Klass::vtable_start_offset());
 983   int itentry_off = itableMethodEntry::method_offset_in_bytes();
 984   int scan_step   = itableOffsetEntry::size() * wordSize;
 985   int vte_size    = vtableEntry::size_in_bytes();
 986   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
 987 
 988   ldrw(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
 989 
 990   // %%% Could store the aligned, prescaled offset in the klassoop.
 991   // lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
 992   lea(scan_temp, Address(recv_klass, scan_temp, Address::lsl(3)));
 993   add(scan_temp, scan_temp, vtable_base);
 994 
 995   if (return_method) {
 996     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
 997     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
 998     // lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
 999     lea(recv_klass, Address(recv_klass, itable_index, Address::lsl(3)));
1000     if (itentry_off)
1001       add(recv_klass, recv_klass, itentry_off);
1002   }
1003 
1004   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
1005   //   if (scan-&gt;interface() == intf) {
1006   //     result = (klass + scan-&gt;offset() + itable_index);
1007   //   }
1008   // }
1009   Label search, found_method;
1010 
1011   for (int peel = 1; peel &gt;= 0; peel--) {
1012     ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
1013     cmp(intf_klass, method_result);
1014 
1015     if (peel) {
1016       br(Assembler::EQ, found_method);
1017     } else {
1018       br(Assembler::NE, search);
1019       // (invert the test to fall through to found_method...)
1020     }
1021 
1022     if (!peel)  break;
1023 
1024     bind(search);
1025 
1026     // Check that the previous entry is non-null.  A null entry means that
1027     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
1028     // same as when the caller was compiled.
1029     cbz(method_result, L_no_such_interface);
1030     add(scan_temp, scan_temp, scan_step);
1031   }
1032 
1033   bind(found_method);
1034 
1035   // Got a hit.
1036   if (return_method) {
1037     ldrw(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
1038     ldr(method_result, Address(recv_klass, scan_temp, Address::uxtw(0)));
1039   }
1040 }
1041 
1042 // virtual method calling
1043 void MacroAssembler::lookup_virtual_method(Register recv_klass,
1044                                            RegisterOrConstant vtable_index,
1045                                            Register method_result) {
1046   const int base = in_bytes(Klass::vtable_start_offset());
1047   assert(vtableEntry::size() * wordSize == 8,
1048          &quot;adjust the scaling in the code below&quot;);
1049   int vtable_offset_in_bytes = base + vtableEntry::method_offset_in_bytes();
1050 
1051   if (vtable_index.is_register()) {
1052     lea(method_result, Address(recv_klass,
1053                                vtable_index.as_register(),
1054                                Address::lsl(LogBytesPerWord)));
1055     ldr(method_result, Address(method_result, vtable_offset_in_bytes));
1056   } else {
1057     vtable_offset_in_bytes += vtable_index.as_constant() * wordSize;
1058     ldr(method_result,
1059         form_address(rscratch1, recv_klass, vtable_offset_in_bytes, 0));
1060   }
1061 }
1062 
1063 void MacroAssembler::check_klass_subtype(Register sub_klass,
1064                            Register super_klass,
1065                            Register temp_reg,
1066                            Label&amp; L_success) {
1067   Label L_failure;
1068   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
1069   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
1070   bind(L_failure);
1071 }
1072 
1073 
1074 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
1075                                                    Register super_klass,
1076                                                    Register temp_reg,
1077                                                    Label* L_success,
1078                                                    Label* L_failure,
1079                                                    Label* L_slow_path,
1080                                         RegisterOrConstant super_check_offset) {
1081   assert_different_registers(sub_klass, super_klass, temp_reg);
1082   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
1083   if (super_check_offset.is_register()) {
1084     assert_different_registers(sub_klass, super_klass,
1085                                super_check_offset.as_register());
1086   } else if (must_load_sco) {
1087     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
1088   }
1089 
1090   Label L_fallthrough;
1091   int label_nulls = 0;
1092   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
1093   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
1094   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
1095   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
1096 
1097   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
1098   int sco_offset = in_bytes(Klass::super_check_offset_offset());
1099   Address super_check_offset_addr(super_klass, sco_offset);
1100 
1101   // Hacked jmp, which may only be used just before L_fallthrough.
1102 #define final_jmp(label)                                                \
1103   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
1104   else                            b(label)                /*omit semi*/
1105 
1106   // If the pointers are equal, we are done (e.g., String[] elements).
1107   // This self-check enables sharing of secondary supertype arrays among
1108   // non-primary types such as array-of-interface.  Otherwise, each such
1109   // type would need its own customized SSA.
1110   // We move this check to the front of the fast path because many
1111   // type checks are in fact trivially successful in this manner,
1112   // so we get a nicely predicted branch right at the start of the check.
1113   cmp(sub_klass, super_klass);
1114   br(Assembler::EQ, *L_success);
1115 
1116   // Check the supertype display:
1117   if (must_load_sco) {
1118     ldrw(temp_reg, super_check_offset_addr);
1119     super_check_offset = RegisterOrConstant(temp_reg);
1120   }
1121   Address super_check_addr(sub_klass, super_check_offset);
1122   ldr(rscratch1, super_check_addr);
1123   cmp(super_klass, rscratch1); // load displayed supertype
1124 
1125   // This check has worked decisively for primary supers.
1126   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
1127   // (Secondary supers are interfaces and very deeply nested subtypes.)
1128   // This works in the same check above because of a tricky aliasing
1129   // between the super_cache and the primary super display elements.
1130   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
1131   // Note that the cache is updated below if it does not help us find
1132   // what we need immediately.
1133   // So if it was a primary super, we can just fail immediately.
1134   // Otherwise, it&#39;s the slow path for us (no success at this point).
1135 
1136   if (super_check_offset.is_register()) {
1137     br(Assembler::EQ, *L_success);
1138     subs(zr, super_check_offset.as_register(), sc_offset);
1139     if (L_failure == &amp;L_fallthrough) {
1140       br(Assembler::EQ, *L_slow_path);
1141     } else {
1142       br(Assembler::NE, *L_failure);
1143       final_jmp(*L_slow_path);
1144     }
1145   } else if (super_check_offset.as_constant() == sc_offset) {
1146     // Need a slow path; fast failure is impossible.
1147     if (L_slow_path == &amp;L_fallthrough) {
1148       br(Assembler::EQ, *L_success);
1149     } else {
1150       br(Assembler::NE, *L_slow_path);
1151       final_jmp(*L_success);
1152     }
1153   } else {
1154     // No slow path; it&#39;s a fast decision.
1155     if (L_failure == &amp;L_fallthrough) {
1156       br(Assembler::EQ, *L_success);
1157     } else {
1158       br(Assembler::NE, *L_failure);
1159       final_jmp(*L_success);
1160     }
1161   }
1162 
1163   bind(L_fallthrough);
1164 
1165 #undef final_jmp
1166 }
1167 
1168 // These two are taken from x86, but they look generally useful
1169 
1170 // scans count pointer sized words at [addr] for occurence of value,
1171 // generic
1172 void MacroAssembler::repne_scan(Register addr, Register value, Register count,
1173                                 Register scratch) {
1174   Label Lloop, Lexit;
1175   cbz(count, Lexit);
1176   bind(Lloop);
1177   ldr(scratch, post(addr, wordSize));
1178   cmp(value, scratch);
1179   br(EQ, Lexit);
1180   sub(count, count, 1);
1181   cbnz(count, Lloop);
1182   bind(Lexit);
1183 }
1184 
1185 // scans count 4 byte words at [addr] for occurence of value,
1186 // generic
1187 void MacroAssembler::repne_scanw(Register addr, Register value, Register count,
1188                                 Register scratch) {
1189   Label Lloop, Lexit;
1190   cbz(count, Lexit);
1191   bind(Lloop);
1192   ldrw(scratch, post(addr, wordSize));
1193   cmpw(value, scratch);
1194   br(EQ, Lexit);
1195   sub(count, count, 1);
1196   cbnz(count, Lloop);
1197   bind(Lexit);
1198 }
1199 
1200 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
1201                                                    Register super_klass,
1202                                                    Register temp_reg,
1203                                                    Register temp2_reg,
1204                                                    Label* L_success,
1205                                                    Label* L_failure,
1206                                                    bool set_cond_codes) {
1207   assert_different_registers(sub_klass, super_klass, temp_reg);
1208   if (temp2_reg != noreg)
1209     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, rscratch1);
1210 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
1211 
1212   Label L_fallthrough;
1213   int label_nulls = 0;
1214   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
1215   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
1216   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
1217 
1218   // a couple of useful fields in sub_klass:
1219   int ss_offset = in_bytes(Klass::secondary_supers_offset());
1220   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
1221   Address secondary_supers_addr(sub_klass, ss_offset);
1222   Address super_cache_addr(     sub_klass, sc_offset);
1223 
1224   BLOCK_COMMENT(&quot;check_klass_subtype_slow_path&quot;);
1225 
1226   // Do a linear scan of the secondary super-klass chain.
1227   // This code is rarely used, so simplicity is a virtue here.
1228   // The repne_scan instruction uses fixed registers, which we must spill.
1229   // Don&#39;t worry too much about pre-existing connections with the input regs.
1230 
1231   assert(sub_klass != r0, &quot;killed reg&quot;); // killed by mov(r0, super)
1232   assert(sub_klass != r2, &quot;killed reg&quot;); // killed by lea(r2, &amp;pst_counter)
1233 
1234   RegSet pushed_registers;
1235   if (!IS_A_TEMP(r2))    pushed_registers += r2;
1236   if (!IS_A_TEMP(r5))    pushed_registers += r5;
1237 
1238   if (super_klass != r0 || UseCompressedOops) {
1239     if (!IS_A_TEMP(r0))   pushed_registers += r0;
1240   }
1241 
1242   push(pushed_registers, sp);
1243 
1244   // Get super_klass value into r0 (even if it was in r5 or r2).
1245   if (super_klass != r0) {
1246     mov(r0, super_klass);
1247   }
1248 
1249 #ifndef PRODUCT
1250   mov(rscratch2, (address)&amp;SharedRuntime::_partial_subtype_ctr);
1251   Address pst_counter_addr(rscratch2);
1252   ldr(rscratch1, pst_counter_addr);
1253   add(rscratch1, rscratch1, 1);
1254   str(rscratch1, pst_counter_addr);
1255 #endif //PRODUCT
1256 
1257   // We will consult the secondary-super array.
1258   ldr(r5, secondary_supers_addr);
1259   // Load the array length.
1260   ldrw(r2, Address(r5, Array&lt;Klass*&gt;::length_offset_in_bytes()));
1261   // Skip to start of data.
1262   add(r5, r5, Array&lt;Klass*&gt;::base_offset_in_bytes());
1263 
1264   cmp(sp, zr); // Clear Z flag; SP is never zero
1265   // Scan R2 words at [R5] for an occurrence of R0.
1266   // Set NZ/Z based on last compare.
1267   repne_scan(r5, r0, r2, rscratch1);
1268 
1269   // Unspill the temp. registers:
1270   pop(pushed_registers, sp);
1271 
1272   br(Assembler::NE, *L_failure);
1273 
1274   // Success.  Cache the super we found and proceed in triumph.
1275   str(super_klass, super_cache_addr);
1276 
1277   if (L_success != &amp;L_fallthrough) {
1278     b(*L_success);
1279   }
1280 
1281 #undef IS_A_TEMP
1282 
1283   bind(L_fallthrough);
1284 }
1285 
1286 void MacroAssembler::clinit_barrier(Register klass, Register scratch, Label* L_fast_path, Label* L_slow_path) {
1287   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
1288   assert_different_registers(klass, rthread, scratch);
1289 
1290   Label L_fallthrough, L_tmp;
1291   if (L_fast_path == NULL) {
1292     L_fast_path = &amp;L_fallthrough;
1293   } else if (L_slow_path == NULL) {
1294     L_slow_path = &amp;L_fallthrough;
1295   }
1296   // Fast path check: class is fully initialized
1297   ldrb(scratch, Address(klass, InstanceKlass::init_state_offset()));
1298   subs(zr, scratch, InstanceKlass::fully_initialized);
1299   br(Assembler::EQ, *L_fast_path);
1300 
1301   // Fast path check: current thread is initializer thread
1302   ldr(scratch, Address(klass, InstanceKlass::init_thread_offset()));
1303   cmp(rthread, scratch);
1304 
1305   if (L_slow_path == &amp;L_fallthrough) {
1306     br(Assembler::EQ, *L_fast_path);
1307     bind(*L_slow_path);
1308   } else if (L_fast_path == &amp;L_fallthrough) {
1309     br(Assembler::NE, *L_slow_path);
1310     bind(*L_fast_path);
1311   } else {
1312     Unimplemented();
1313   }
1314 }
1315 
1316 void MacroAssembler::verify_oop(Register reg, const char* s) {
1317   if (!VerifyOops) return;
1318 
1319   // Pass register number to verify_oop_subroutine
1320   const char* b = NULL;
1321   {
1322     ResourceMark rm;
1323     stringStream ss;
1324     ss.print(&quot;verify_oop: %s: %s&quot;, reg-&gt;name(), s);
1325     b = code_string(ss.as_string());
1326   }
1327   BLOCK_COMMENT(&quot;verify_oop {&quot;);
1328 
1329   stp(r0, rscratch1, Address(pre(sp, -2 * wordSize)));
1330   stp(rscratch2, lr, Address(pre(sp, -2 * wordSize)));
1331 
1332   mov(r0, reg);
1333   mov(rscratch1, (address)b);
1334 
1335   // call indirectly to solve generation ordering problem
1336   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
1337   ldr(rscratch2, Address(rscratch2));
1338   blr(rscratch2);
1339 
1340   ldp(rscratch2, lr, Address(post(sp, 2 * wordSize)));
1341   ldp(r0, rscratch1, Address(post(sp, 2 * wordSize)));
1342 
1343   BLOCK_COMMENT(&quot;} verify_oop&quot;);
1344 }
1345 
1346 void MacroAssembler::verify_oop_addr(Address addr, const char* s) {
1347   if (!VerifyOops) return;
1348 
1349   const char* b = NULL;
1350   {
1351     ResourceMark rm;
1352     stringStream ss;
1353     ss.print(&quot;verify_oop_addr: %s&quot;, s);
1354     b = code_string(ss.as_string());
1355   }
1356   BLOCK_COMMENT(&quot;verify_oop_addr {&quot;);
1357 
1358   stp(r0, rscratch1, Address(pre(sp, -2 * wordSize)));
1359   stp(rscratch2, lr, Address(pre(sp, -2 * wordSize)));
1360 
1361   // addr may contain sp so we will have to adjust it based on the
1362   // pushes that we just did.
1363   if (addr.uses(sp)) {
1364     lea(r0, addr);
1365     ldr(r0, Address(r0, 4 * wordSize));
1366   } else {
1367     ldr(r0, addr);
1368   }
1369   mov(rscratch1, (address)b);
1370 
1371   // call indirectly to solve generation ordering problem
1372   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
1373   ldr(rscratch2, Address(rscratch2));
1374   blr(rscratch2);
1375 
1376   ldp(rscratch2, lr, Address(post(sp, 2 * wordSize)));
1377   ldp(r0, rscratch1, Address(post(sp, 2 * wordSize)));
1378 
1379   BLOCK_COMMENT(&quot;} verify_oop_addr&quot;);
1380 }
1381 
1382 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
1383                                          int extra_slot_offset) {
1384   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
1385   int stackElementSize = Interpreter::stackElementSize;
1386   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
1387 #ifdef ASSERT
1388   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
1389   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
1390 #endif
1391   if (arg_slot.is_constant()) {
1392     return Address(esp, arg_slot.as_constant() * stackElementSize
1393                    + offset);
1394   } else {
1395     add(rscratch1, esp, arg_slot.as_register(),
1396         ext::uxtx, exact_log2(stackElementSize));
1397     return Address(rscratch1, offset);
1398   }
1399 }
1400 
1401 void MacroAssembler::call_VM_leaf_base(address entry_point,
1402                                        int number_of_arguments,
1403                                        Label *retaddr) {
1404   Label E, L;
1405 
1406   stp(rscratch1, rmethod, Address(pre(sp, -2 * wordSize)));
1407 
1408   mov(rscratch1, entry_point);
1409   blr(rscratch1);
1410   if (retaddr)
1411     bind(*retaddr);
1412 
1413   ldp(rscratch1, rmethod, Address(post(sp, 2 * wordSize)));
1414   maybe_isb();
1415 }
1416 
1417 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1418   call_VM_leaf_base(entry_point, number_of_arguments);
1419 }
1420 
1421 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1422   pass_arg0(this, arg_0);
1423   call_VM_leaf_base(entry_point, 1);
1424 }
1425 
1426 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1427   pass_arg0(this, arg_0);
1428   pass_arg1(this, arg_1);
1429   call_VM_leaf_base(entry_point, 2);
1430 }
1431 
1432 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0,
1433                                   Register arg_1, Register arg_2) {
1434   pass_arg0(this, arg_0);
1435   pass_arg1(this, arg_1);
1436   pass_arg2(this, arg_2);
1437   call_VM_leaf_base(entry_point, 3);
1438 }
1439 
1440 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1441   pass_arg0(this, arg_0);
1442   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1443 }
1444 
1445 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1446 
1447   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1448   pass_arg1(this, arg_1);
1449   pass_arg0(this, arg_0);
1450   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1451 }
1452 
1453 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1454   assert(arg_0 != c_rarg2, &quot;smashed arg&quot;);
1455   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
1456   pass_arg2(this, arg_2);
1457   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1458   pass_arg1(this, arg_1);
1459   pass_arg0(this, arg_0);
1460   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1461 }
1462 
1463 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1464   assert(arg_0 != c_rarg3, &quot;smashed arg&quot;);
1465   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
1466   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
1467   pass_arg3(this, arg_3);
1468   assert(arg_0 != c_rarg2, &quot;smashed arg&quot;);
1469   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
1470   pass_arg2(this, arg_2);
1471   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1472   pass_arg1(this, arg_1);
1473   pass_arg0(this, arg_0);
1474   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1475 }
1476 
1477 void MacroAssembler::null_check(Register reg, int offset) {
1478   if (needs_explicit_null_check(offset)) {
1479     // provoke OS NULL exception if reg = NULL by
1480     // accessing M[reg] w/o changing any registers
1481     // NOTE: this is plenty to provoke a segv
1482     ldr(zr, Address(reg));
1483   } else {
1484     // nothing to do, (later) access of M[reg + offset]
1485     // will provoke OS NULL exception if reg = NULL
1486   }
1487 }
1488 
1489 // MacroAssembler protected routines needed to implement
1490 // public methods
1491 
1492 void MacroAssembler::mov(Register r, Address dest) {
1493   code_section()-&gt;relocate(pc(), dest.rspec());
1494   u_int64_t imm64 = (u_int64_t)dest.target();
1495   movptr(r, imm64);
1496 }
1497 
1498 // Move a constant pointer into r.  In AArch64 mode the virtual
1499 // address space is 48 bits in size, so we only need three
1500 // instructions to create a patchable instruction sequence that can
1501 // reach anywhere.
1502 void MacroAssembler::movptr(Register r, uintptr_t imm64) {
1503 #ifndef PRODUCT
1504   {
1505     char buffer[64];
1506     snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
1507     block_comment(buffer);
1508   }
1509 #endif
1510   assert(imm64 &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
1511   movz(r, imm64 &amp; 0xffff);
1512   imm64 &gt;&gt;= 16;
1513   movk(r, imm64 &amp; 0xffff, 16);
1514   imm64 &gt;&gt;= 16;
1515   movk(r, imm64 &amp; 0xffff, 32);
1516 }
1517 
1518 // Macro to mov replicated immediate to vector register.
1519 //  Vd will get the following values for different arrangements in T
1520 //   imm32 == hex 000000gh  T8B:  Vd = ghghghghghghghgh
1521 //   imm32 == hex 000000gh  T16B: Vd = ghghghghghghghghghghghghghghghgh
1522 //   imm32 == hex 0000efgh  T4H:  Vd = efghefghefghefgh
1523 //   imm32 == hex 0000efgh  T8H:  Vd = efghefghefghefghefghefghefghefgh
1524 //   imm32 == hex abcdefgh  T2S:  Vd = abcdefghabcdefgh
1525 //   imm32 == hex abcdefgh  T4S:  Vd = abcdefghabcdefghabcdefghabcdefgh
1526 //   T1D/T2D: invalid
1527 void MacroAssembler::mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32) {
1528   assert(T != T1D &amp;&amp; T != T2D, &quot;invalid arrangement&quot;);
1529   if (T == T8B || T == T16B) {
1530     assert((imm32 &amp; ~0xff) == 0, &quot;extraneous bits in unsigned imm32 (T8B/T16B)&quot;);
1531     movi(Vd, T, imm32 &amp; 0xff, 0);
1532     return;
1533   }
1534   u_int32_t nimm32 = ~imm32;
1535   if (T == T4H || T == T8H) {
1536     assert((imm32  &amp; ~0xffff) == 0, &quot;extraneous bits in unsigned imm32 (T4H/T8H)&quot;);
1537     imm32 &amp;= 0xffff;
1538     nimm32 &amp;= 0xffff;
1539   }
1540   u_int32_t x = imm32;
1541   int movi_cnt = 0;
1542   int movn_cnt = 0;
1543   while (x) { if (x &amp; 0xff) movi_cnt++; x &gt;&gt;= 8; }
1544   x = nimm32;
1545   while (x) { if (x &amp; 0xff) movn_cnt++; x &gt;&gt;= 8; }
1546   if (movn_cnt &lt; movi_cnt) imm32 = nimm32;
1547   unsigned lsl = 0;
1548   while (imm32 &amp;&amp; (imm32 &amp; 0xff) == 0) { lsl += 8; imm32 &gt;&gt;= 8; }
1549   if (movn_cnt &lt; movi_cnt)
1550     mvni(Vd, T, imm32 &amp; 0xff, lsl);
1551   else
1552     movi(Vd, T, imm32 &amp; 0xff, lsl);
1553   imm32 &gt;&gt;= 8; lsl += 8;
1554   while (imm32) {
1555     while ((imm32 &amp; 0xff) == 0) { lsl += 8; imm32 &gt;&gt;= 8; }
1556     if (movn_cnt &lt; movi_cnt)
1557       bici(Vd, T, imm32 &amp; 0xff, lsl);
1558     else
1559       orri(Vd, T, imm32 &amp; 0xff, lsl);
1560     lsl += 8; imm32 &gt;&gt;= 8;
1561   }
1562 }
1563 
1564 void MacroAssembler::mov_immediate64(Register dst, u_int64_t imm64)
1565 {
1566 #ifndef PRODUCT
1567   {
1568     char buffer[64];
1569     snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
1570     block_comment(buffer);
1571   }
1572 #endif
1573   if (operand_valid_for_logical_immediate(false, imm64)) {
1574     orr(dst, zr, imm64);
1575   } else {
1576     // we can use a combination of MOVZ or MOVN with
1577     // MOVK to build up the constant
1578     u_int64_t imm_h[4];
1579     int zero_count = 0;
1580     int neg_count = 0;
1581     int i;
1582     for (i = 0; i &lt; 4; i++) {
1583       imm_h[i] = ((imm64 &gt;&gt; (i * 16)) &amp; 0xffffL);
1584       if (imm_h[i] == 0) {
1585         zero_count++;
1586       } else if (imm_h[i] == 0xffffL) {
1587         neg_count++;
1588       }
1589     }
1590     if (zero_count == 4) {
1591       // one MOVZ will do
1592       movz(dst, 0);
1593     } else if (neg_count == 4) {
1594       // one MOVN will do
1595       movn(dst, 0);
1596     } else if (zero_count == 3) {
1597       for (i = 0; i &lt; 4; i++) {
1598         if (imm_h[i] != 0L) {
1599           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1600           break;
1601         }
1602       }
1603     } else if (neg_count == 3) {
1604       // one MOVN will do
1605       for (int i = 0; i &lt; 4; i++) {
1606         if (imm_h[i] != 0xffffL) {
1607           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1608           break;
1609         }
1610       }
1611     } else if (zero_count == 2) {
1612       // one MOVZ and one MOVK will do
1613       for (i = 0; i &lt; 3; i++) {
1614         if (imm_h[i] != 0L) {
1615           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1616           i++;
1617           break;
1618         }
1619       }
1620       for (;i &lt; 4; i++) {
1621         if (imm_h[i] != 0L) {
1622           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1623         }
1624       }
1625     } else if (neg_count == 2) {
1626       // one MOVN and one MOVK will do
1627       for (i = 0; i &lt; 4; i++) {
1628         if (imm_h[i] != 0xffffL) {
1629           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1630           i++;
1631           break;
1632         }
1633       }
1634       for (;i &lt; 4; i++) {
1635         if (imm_h[i] != 0xffffL) {
1636           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1637         }
1638       }
1639     } else if (zero_count == 1) {
1640       // one MOVZ and two MOVKs will do
1641       for (i = 0; i &lt; 4; i++) {
1642         if (imm_h[i] != 0L) {
1643           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1644           i++;
1645           break;
1646         }
1647       }
1648       for (;i &lt; 4; i++) {
1649         if (imm_h[i] != 0x0L) {
1650           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1651         }
1652       }
1653     } else if (neg_count == 1) {
1654       // one MOVN and two MOVKs will do
1655       for (i = 0; i &lt; 4; i++) {
1656         if (imm_h[i] != 0xffffL) {
1657           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1658           i++;
1659           break;
1660         }
1661       }
1662       for (;i &lt; 4; i++) {
1663         if (imm_h[i] != 0xffffL) {
1664           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1665         }
1666       }
1667     } else {
1668       // use a MOVZ and 3 MOVKs (makes it easier to debug)
1669       movz(dst, (u_int32_t)imm_h[0], 0);
1670       for (i = 1; i &lt; 4; i++) {
1671         movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1672       }
1673     }
1674   }
1675 }
1676 
1677 void MacroAssembler::mov_immediate32(Register dst, u_int32_t imm32)
1678 {
1679 #ifndef PRODUCT
1680     {
1681       char buffer[64];
1682       snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX32, imm32);
1683       block_comment(buffer);
1684     }
1685 #endif
1686   if (operand_valid_for_logical_immediate(true, imm32)) {
1687     orrw(dst, zr, imm32);
1688   } else {
1689     // we can use MOVZ, MOVN or two calls to MOVK to build up the
1690     // constant
1691     u_int32_t imm_h[2];
1692     imm_h[0] = imm32 &amp; 0xffff;
1693     imm_h[1] = ((imm32 &gt;&gt; 16) &amp; 0xffff);
1694     if (imm_h[0] == 0) {
1695       movzw(dst, imm_h[1], 16);
1696     } else if (imm_h[0] == 0xffff) {
1697       movnw(dst, imm_h[1] ^ 0xffff, 16);
1698     } else if (imm_h[1] == 0) {
1699       movzw(dst, imm_h[0], 0);
1700     } else if (imm_h[1] == 0xffff) {
1701       movnw(dst, imm_h[0] ^ 0xffff, 0);
1702     } else {
1703       // use a MOVZ and MOVK (makes it easier to debug)
1704       movzw(dst, imm_h[0], 0);
1705       movkw(dst, imm_h[1], 16);
1706     }
1707   }
1708 }
1709 
1710 // Form an address from base + offset in Rd.  Rd may or may
1711 // not actually be used: you must use the Address that is returned.
1712 // It is up to you to ensure that the shift provided matches the size
1713 // of your data.
1714 Address MacroAssembler::form_address(Register Rd, Register base, long byte_offset, int shift) {
1715   if (Address::offset_ok_for_immed(byte_offset, shift))
1716     // It fits; no need for any heroics
1717     return Address(base, byte_offset);
1718 
1719   // Don&#39;t do anything clever with negative or misaligned offsets
1720   unsigned mask = (1 &lt;&lt; shift) - 1;
1721   if (byte_offset &lt; 0 || byte_offset &amp; mask) {
1722     mov(Rd, byte_offset);
1723     add(Rd, base, Rd);
1724     return Address(Rd);
1725   }
1726 
1727   // See if we can do this with two 12-bit offsets
1728   {
1729     unsigned long word_offset = byte_offset &gt;&gt; shift;
1730     unsigned long masked_offset = word_offset &amp; 0xfff000;
1731     if (Address::offset_ok_for_immed(word_offset - masked_offset, 0)
1732         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(masked_offset &lt;&lt; shift)) {
1733       add(Rd, base, masked_offset &lt;&lt; shift);
1734       word_offset -= masked_offset;
1735       return Address(Rd, word_offset &lt;&lt; shift);
1736     }
1737   }
1738 
1739   // Do it the hard way
1740   mov(Rd, byte_offset);
1741   add(Rd, base, Rd);
1742   return Address(Rd);
1743 }
1744 
1745 void MacroAssembler::atomic_incw(Register counter_addr, Register tmp, Register tmp2) {
1746   if (UseLSE) {
1747     mov(tmp, 1);
1748     ldadd(Assembler::word, tmp, zr, counter_addr);
1749     return;
1750   }
1751   Label retry_load;
1752   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
1753     prfm(Address(counter_addr), PSTL1STRM);
1754   bind(retry_load);
1755   // flush and load exclusive from the memory location
1756   ldxrw(tmp, counter_addr);
1757   addw(tmp, tmp, 1);
1758   // if we store+flush with no intervening write tmp wil be zero
1759   stxrw(tmp2, tmp, counter_addr);
1760   cbnzw(tmp2, retry_load);
1761 }
1762 
1763 
1764 int MacroAssembler::corrected_idivl(Register result, Register ra, Register rb,
1765                                     bool want_remainder, Register scratch)
1766 {
1767   // Full implementation of Java idiv and irem.  The function
1768   // returns the (pc) offset of the div instruction - may be needed
1769   // for implicit exceptions.
1770   //
1771   // constraint : ra/rb =/= scratch
1772   //         normal case
1773   //
1774   // input : ra: dividend
1775   //         rb: divisor
1776   //
1777   // result: either
1778   //         quotient  (= ra idiv rb)
1779   //         remainder (= ra irem rb)
1780 
1781   assert(ra != scratch &amp;&amp; rb != scratch, &quot;reg cannot be scratch&quot;);
1782 
1783   int idivl_offset = offset();
1784   if (! want_remainder) {
1785     sdivw(result, ra, rb);
1786   } else {
1787     sdivw(scratch, ra, rb);
1788     Assembler::msubw(result, scratch, rb, ra);
1789   }
1790 
1791   return idivl_offset;
1792 }
1793 
1794 int MacroAssembler::corrected_idivq(Register result, Register ra, Register rb,
1795                                     bool want_remainder, Register scratch)
1796 {
1797   // Full implementation of Java ldiv and lrem.  The function
1798   // returns the (pc) offset of the div instruction - may be needed
1799   // for implicit exceptions.
1800   //
1801   // constraint : ra/rb =/= scratch
1802   //         normal case
1803   //
1804   // input : ra: dividend
1805   //         rb: divisor
1806   //
1807   // result: either
1808   //         quotient  (= ra idiv rb)
1809   //         remainder (= ra irem rb)
1810 
1811   assert(ra != scratch &amp;&amp; rb != scratch, &quot;reg cannot be scratch&quot;);
1812 
1813   int idivq_offset = offset();
1814   if (! want_remainder) {
1815     sdiv(result, ra, rb);
1816   } else {
1817     sdiv(scratch, ra, rb);
1818     Assembler::msub(result, scratch, rb, ra);
1819   }
1820 
1821   return idivq_offset;
1822 }
1823 
1824 void MacroAssembler::membar(Membar_mask_bits order_constraint) {
1825   address prev = pc() - NativeMembar::instruction_size;
1826   address last = code()-&gt;last_insn();
1827   if (last != NULL &amp;&amp; nativeInstruction_at(last)-&gt;is_Membar() &amp;&amp; prev == last) {
1828     NativeMembar *bar = NativeMembar_at(prev);
1829     // We are merging two memory barrier instructions.  On AArch64 we
1830     // can do this simply by ORing them together.
1831     bar-&gt;set_kind(bar-&gt;get_kind() | order_constraint);
1832     BLOCK_COMMENT(&quot;merged membar&quot;);
1833   } else {
1834     code()-&gt;set_last_insn(pc());
1835     dmb(Assembler::barrier(order_constraint));
1836   }
1837 }
1838 
1839 bool MacroAssembler::try_merge_ldst(Register rt, const Address &amp;adr, size_t size_in_bytes, bool is_store) {
1840   if (ldst_can_merge(rt, adr, size_in_bytes, is_store)) {
1841     merge_ldst(rt, adr, size_in_bytes, is_store);
1842     code()-&gt;clear_last_insn();
1843     return true;
1844   } else {
1845     assert(size_in_bytes == 8 || size_in_bytes == 4, &quot;only 8 bytes or 4 bytes load/store is supported.&quot;);
1846     const unsigned mask = size_in_bytes - 1;
1847     if (adr.getMode() == Address::base_plus_offset &amp;&amp;
1848         (adr.offset() &amp; mask) == 0) { // only supports base_plus_offset.
1849       code()-&gt;set_last_insn(pc());
1850     }
1851     return false;
1852   }
1853 }
1854 
1855 void MacroAssembler::ldr(Register Rx, const Address &amp;adr) {
1856   // We always try to merge two adjacent loads into one ldp.
1857   if (!try_merge_ldst(Rx, adr, 8, false)) {
1858     Assembler::ldr(Rx, adr);
1859   }
1860 }
1861 
1862 void MacroAssembler::ldrw(Register Rw, const Address &amp;adr) {
1863   // We always try to merge two adjacent loads into one ldp.
1864   if (!try_merge_ldst(Rw, adr, 4, false)) {
1865     Assembler::ldrw(Rw, adr);
1866   }
1867 }
1868 
1869 void MacroAssembler::str(Register Rx, const Address &amp;adr) {
1870   // We always try to merge two adjacent stores into one stp.
1871   if (!try_merge_ldst(Rx, adr, 8, true)) {
1872     Assembler::str(Rx, adr);
1873   }
1874 }
1875 
1876 void MacroAssembler::strw(Register Rw, const Address &amp;adr) {
1877   // We always try to merge two adjacent stores into one stp.
1878   if (!try_merge_ldst(Rw, adr, 4, true)) {
1879     Assembler::strw(Rw, adr);
1880   }
1881 }
1882 
1883 // MacroAssembler routines found actually to be needed
1884 
1885 void MacroAssembler::push(Register src)
1886 {
1887   str(src, Address(pre(esp, -1 * wordSize)));
1888 }
1889 
1890 void MacroAssembler::pop(Register dst)
1891 {
1892   ldr(dst, Address(post(esp, 1 * wordSize)));
1893 }
1894 
1895 // Note: load_unsigned_short used to be called load_unsigned_word.
1896 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
1897   int off = offset();
1898   ldrh(dst, src);
1899   return off;
1900 }
1901 
1902 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
1903   int off = offset();
1904   ldrb(dst, src);
1905   return off;
1906 }
1907 
1908 int MacroAssembler::load_signed_short(Register dst, Address src) {
1909   int off = offset();
1910   ldrsh(dst, src);
1911   return off;
1912 }
1913 
1914 int MacroAssembler::load_signed_byte(Register dst, Address src) {
1915   int off = offset();
1916   ldrsb(dst, src);
1917   return off;
1918 }
1919 
1920 int MacroAssembler::load_signed_short32(Register dst, Address src) {
1921   int off = offset();
1922   ldrshw(dst, src);
1923   return off;
1924 }
1925 
1926 int MacroAssembler::load_signed_byte32(Register dst, Address src) {
1927   int off = offset();
1928   ldrsbw(dst, src);
1929   return off;
1930 }
1931 
1932 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
1933   switch (size_in_bytes) {
1934   case  8:  ldr(dst, src); break;
1935   case  4:  ldrw(dst, src); break;
1936   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
1937   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
1938   default:  ShouldNotReachHere();
1939   }
1940 }
1941 
1942 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
1943   switch (size_in_bytes) {
1944   case  8:  str(src, dst); break;
1945   case  4:  strw(src, dst); break;
1946   case  2:  strh(src, dst); break;
1947   case  1:  strb(src, dst); break;
1948   default:  ShouldNotReachHere();
1949   }
1950 }
1951 
1952 void MacroAssembler::decrementw(Register reg, int value)
1953 {
1954   if (value &lt; 0)  { incrementw(reg, -value);      return; }
1955   if (value == 0) {                               return; }
1956   if (value &lt; (1 &lt;&lt; 12)) { subw(reg, reg, value); return; }
1957   /* else */ {
1958     guarantee(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
1959     movw(rscratch2, (unsigned)value);
1960     subw(reg, reg, rscratch2);
1961   }
1962 }
1963 
1964 void MacroAssembler::decrement(Register reg, int value)
1965 {
1966   if (value &lt; 0)  { increment(reg, -value);      return; }
1967   if (value == 0) {                              return; }
1968   if (value &lt; (1 &lt;&lt; 12)) { sub(reg, reg, value); return; }
1969   /* else */ {
1970     assert(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
1971     mov(rscratch2, (unsigned long)value);
1972     sub(reg, reg, rscratch2);
1973   }
1974 }
1975 
1976 void MacroAssembler::decrementw(Address dst, int value)
1977 {
1978   assert(!dst.uses(rscratch1), &quot;invalid dst for address decrement&quot;);
1979   if (dst.getMode() == Address::literal) {
1980     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
1981     lea(rscratch2, dst);
1982     dst = Address(rscratch2);
1983   }
1984   ldrw(rscratch1, dst);
1985   decrementw(rscratch1, value);
1986   strw(rscratch1, dst);
1987 }
1988 
1989 void MacroAssembler::decrement(Address dst, int value)
1990 {
1991   assert(!dst.uses(rscratch1), &quot;invalid address for decrement&quot;);
1992   if (dst.getMode() == Address::literal) {
1993     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
1994     lea(rscratch2, dst);
1995     dst = Address(rscratch2);
1996   }
1997   ldr(rscratch1, dst);
1998   decrement(rscratch1, value);
1999   str(rscratch1, dst);
2000 }
2001 
2002 void MacroAssembler::incrementw(Register reg, int value)
2003 {
2004   if (value &lt; 0)  { decrementw(reg, -value);      return; }
2005   if (value == 0) {                               return; }
2006   if (value &lt; (1 &lt;&lt; 12)) { addw(reg, reg, value); return; }
2007   /* else */ {
2008     assert(reg != rscratch2, &quot;invalid dst for register increment&quot;);
2009     movw(rscratch2, (unsigned)value);
2010     addw(reg, reg, rscratch2);
2011   }
2012 }
2013 
2014 void MacroAssembler::increment(Register reg, int value)
2015 {
2016   if (value &lt; 0)  { decrement(reg, -value);      return; }
2017   if (value == 0) {                              return; }
2018   if (value &lt; (1 &lt;&lt; 12)) { add(reg, reg, value); return; }
2019   /* else */ {
2020     assert(reg != rscratch2, &quot;invalid dst for register increment&quot;);
2021     movw(rscratch2, (unsigned)value);
2022     add(reg, reg, rscratch2);
2023   }
2024 }
2025 
2026 void MacroAssembler::incrementw(Address dst, int value)
2027 {
2028   assert(!dst.uses(rscratch1), &quot;invalid dst for address increment&quot;);
2029   if (dst.getMode() == Address::literal) {
2030     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2031     lea(rscratch2, dst);
2032     dst = Address(rscratch2);
2033   }
2034   ldrw(rscratch1, dst);
2035   incrementw(rscratch1, value);
2036   strw(rscratch1, dst);
2037 }
2038 
2039 void MacroAssembler::increment(Address dst, int value)
2040 {
2041   assert(!dst.uses(rscratch1), &quot;invalid dst for address increment&quot;);
2042   if (dst.getMode() == Address::literal) {
2043     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2044     lea(rscratch2, dst);
2045     dst = Address(rscratch2);
2046   }
2047   ldr(rscratch1, dst);
2048   increment(rscratch1, value);
2049   str(rscratch1, dst);
2050 }
2051 
2052 
2053 void MacroAssembler::pusha() {
2054   push(0x7fffffff, sp);
2055 }
2056 
2057 void MacroAssembler::popa() {
2058   pop(0x7fffffff, sp);
2059 }
2060 
2061 // Push lots of registers in the bit set supplied.  Don&#39;t push sp.
2062 // Return the number of words pushed
2063 int MacroAssembler::push(unsigned int bitset, Register stack) {
2064   int words_pushed = 0;
2065 
2066   // Scan bitset to accumulate register pairs
2067   unsigned char regs[32];
2068   int count = 0;
2069   for (int reg = 0; reg &lt;= 30; reg++) {
2070     if (1 &amp; bitset)
2071       regs[count++] = reg;
2072     bitset &gt;&gt;= 1;
2073   }
2074   regs[count++] = zr-&gt;encoding_nocheck();
2075   count &amp;= ~1;  // Only push an even nuber of regs
2076 
2077   if (count) {
2078     stp(as_Register(regs[0]), as_Register(regs[1]),
2079        Address(pre(stack, -count * wordSize)));
2080     words_pushed += 2;
2081   }
2082   for (int i = 2; i &lt; count; i += 2) {
2083     stp(as_Register(regs[i]), as_Register(regs[i+1]),
2084        Address(stack, i * wordSize));
2085     words_pushed += 2;
2086   }
2087 
2088   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2089 
2090   return count;
2091 }
2092 
2093 int MacroAssembler::pop(unsigned int bitset, Register stack) {
2094   int words_pushed = 0;
2095 
2096   // Scan bitset to accumulate register pairs
2097   unsigned char regs[32];
2098   int count = 0;
2099   for (int reg = 0; reg &lt;= 30; reg++) {
2100     if (1 &amp; bitset)
2101       regs[count++] = reg;
2102     bitset &gt;&gt;= 1;
2103   }
2104   regs[count++] = zr-&gt;encoding_nocheck();
2105   count &amp;= ~1;
2106 
2107   for (int i = 2; i &lt; count; i += 2) {
2108     ldp(as_Register(regs[i]), as_Register(regs[i+1]),
2109        Address(stack, i * wordSize));
2110     words_pushed += 2;
2111   }
2112   if (count) {
2113     ldp(as_Register(regs[0]), as_Register(regs[1]),
2114        Address(post(stack, count * wordSize)));
2115     words_pushed += 2;
2116   }
2117 
2118   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2119 
2120   return count;
2121 }
2122 
2123 // Push lots of registers in the bit set supplied.  Don&#39;t push sp.
2124 // Return the number of words pushed
2125 int MacroAssembler::push_fp(unsigned int bitset, Register stack) {
2126   int words_pushed = 0;
2127 
2128   // Scan bitset to accumulate register pairs
2129   unsigned char regs[32];
2130   int count = 0;
2131   for (int reg = 0; reg &lt;= 31; reg++) {
2132     if (1 &amp; bitset)
2133       regs[count++] = reg;
2134     bitset &gt;&gt;= 1;
2135   }
2136   regs[count++] = zr-&gt;encoding_nocheck();
2137   count &amp;= ~1;  // Only push an even number of regs
2138 
2139   // Always pushing full 128 bit registers.
2140   if (count) {
2141     stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -count * wordSize * 2)));
2142     words_pushed += 2;
2143   }
2144   for (int i = 2; i &lt; count; i += 2) {
2145     stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
2146     words_pushed += 2;
2147   }
2148 
2149   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2150   return count;
2151 }
2152 
2153 int MacroAssembler::pop_fp(unsigned int bitset, Register stack) {
2154   int words_pushed = 0;
2155 
2156   // Scan bitset to accumulate register pairs
2157   unsigned char regs[32];
2158   int count = 0;
2159   for (int reg = 0; reg &lt;= 31; reg++) {
2160     if (1 &amp; bitset)
2161       regs[count++] = reg;
2162     bitset &gt;&gt;= 1;
2163   }
2164   regs[count++] = zr-&gt;encoding_nocheck();
2165   count &amp;= ~1;
2166 
2167   for (int i = 2; i &lt; count; i += 2) {
2168     ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
2169     words_pushed += 2;
2170   }
2171   if (count) {
2172     ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, count * wordSize * 2)));
2173     words_pushed += 2;
2174   }
2175 
2176   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2177 
2178   return count;
2179 }
2180 
2181 #ifdef ASSERT
2182 void MacroAssembler::verify_heapbase(const char* msg) {
2183 #if 0
2184   assert (UseCompressedOops || UseCompressedClassPointers, &quot;should be compressed&quot;);
2185   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
2186   if (!UseCompressedOops || Universe::ptr_base() == NULL) {
2187     // rheapbase is allocated as general register
2188     return;
2189   }
2190   if (CheckCompressedOops) {
2191     Label ok;
2192     push(1 &lt;&lt; rscratch1-&gt;encoding(), sp); // cmpptr trashes rscratch1
2193     cmpptr(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
2194     br(Assembler::EQ, ok);
2195     stop(msg);
2196     bind(ok);
2197     pop(1 &lt;&lt; rscratch1-&gt;encoding(), sp);
2198   }
2199 #endif
2200 }
2201 #endif
2202 
2203 void MacroAssembler::resolve_jobject(Register value, Register thread, Register tmp) {
2204   Label done, not_weak;
2205   cbz(value, done);           // Use NULL as-is.
2206 
2207   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
2208   tbz(r0, 0, not_weak);    // Test for jweak tag.
2209 
2210   // Resolve jweak.
2211   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,
2212                  Address(value, -JNIHandles::weak_tag_value), tmp, thread);
2213   verify_oop(value);
2214   b(done);
2215 
2216   bind(not_weak);
2217   // Resolve (untagged) jobject.
2218   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
2219   verify_oop(value);
2220   bind(done);
2221 }
2222 
2223 void MacroAssembler::stop(const char* msg) {
2224   BLOCK_COMMENT(msg);
2225   dcps1(0xdeae);
2226   emit_int64((uintptr_t)msg);
2227 }
2228 
2229 void MacroAssembler::unimplemented(const char* what) {
2230   const char* buf = NULL;
2231   {
2232     ResourceMark rm;
2233     stringStream ss;
2234     ss.print(&quot;unimplemented: %s&quot;, what);
2235     buf = code_string(ss.as_string());
2236   }
2237   stop(buf);
2238 }
2239 
2240 // If a constant does not fit in an immediate field, generate some
2241 // number of MOV instructions and then perform the operation.
2242 void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
2243                                            add_sub_imm_insn insn1,
2244                                            add_sub_reg_insn insn2) {
2245   assert(Rd != zr, &quot;Rd = zr and not setting flags?&quot;);
2246   if (operand_valid_for_add_sub_immediate((int)imm)) {
2247     (this-&gt;*insn1)(Rd, Rn, imm);
2248   } else {
2249     if (uabs(imm) &lt; (1 &lt;&lt; 24)) {
2250        (this-&gt;*insn1)(Rd, Rn, imm &amp; -(1 &lt;&lt; 12));
2251        (this-&gt;*insn1)(Rd, Rd, imm &amp; ((1 &lt;&lt; 12)-1));
2252     } else {
2253        assert_different_registers(Rd, Rn);
2254        mov(Rd, (uint64_t)imm);
2255        (this-&gt;*insn2)(Rd, Rn, Rd, LSL, 0);
2256     }
2257   }
2258 }
2259 
2260 // Seperate vsn which sets the flags. Optimisations are more restricted
2261 // because we must set the flags correctly.
2262 void MacroAssembler::wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
2263                                            add_sub_imm_insn insn1,
2264                                            add_sub_reg_insn insn2) {
2265   if (operand_valid_for_add_sub_immediate((int)imm)) {
2266     (this-&gt;*insn1)(Rd, Rn, imm);
2267   } else {
2268     assert_different_registers(Rd, Rn);
2269     assert(Rd != zr, &quot;overflow in immediate operand&quot;);
2270     mov(Rd, (uint64_t)imm);
2271     (this-&gt;*insn2)(Rd, Rn, Rd, LSL, 0);
2272   }
2273 }
2274 
2275 
2276 void MacroAssembler::add(Register Rd, Register Rn, RegisterOrConstant increment) {
2277   if (increment.is_register()) {
2278     add(Rd, Rn, increment.as_register());
2279   } else {
2280     add(Rd, Rn, increment.as_constant());
2281   }
2282 }
2283 
2284 void MacroAssembler::addw(Register Rd, Register Rn, RegisterOrConstant increment) {
2285   if (increment.is_register()) {
2286     addw(Rd, Rn, increment.as_register());
2287   } else {
2288     addw(Rd, Rn, increment.as_constant());
2289   }
2290 }
2291 
2292 void MacroAssembler::sub(Register Rd, Register Rn, RegisterOrConstant decrement) {
2293   if (decrement.is_register()) {
2294     sub(Rd, Rn, decrement.as_register());
2295   } else {
2296     sub(Rd, Rn, decrement.as_constant());
2297   }
2298 }
2299 
2300 void MacroAssembler::subw(Register Rd, Register Rn, RegisterOrConstant decrement) {
2301   if (decrement.is_register()) {
2302     subw(Rd, Rn, decrement.as_register());
2303   } else {
2304     subw(Rd, Rn, decrement.as_constant());
2305   }
2306 }
2307 
2308 void MacroAssembler::reinit_heapbase()
2309 {
2310   if (UseCompressedOops) {
2311     if (Universe::is_fully_initialized()) {
2312       mov(rheapbase, CompressedOops::ptrs_base());
2313     } else {
2314       lea(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
2315       ldr(rheapbase, Address(rheapbase));
2316     }
2317   }
2318 }
2319 
2320 // this simulates the behaviour of the x86 cmpxchg instruction using a
2321 // load linked/store conditional pair. we use the acquire/release
2322 // versions of these instructions so that we flush pending writes as
2323 // per Java semantics.
2324 
2325 // n.b the x86 version assumes the old value to be compared against is
2326 // in rax and updates rax with the value located in memory if the
2327 // cmpxchg fails. we supply a register for the old value explicitly
2328 
2329 // the aarch64 load linked/store conditional instructions do not
2330 // accept an offset. so, unlike x86, we must provide a plain register
2331 // to identify the memory word to be compared/exchanged rather than a
2332 // register+offset Address.
2333 
2334 void MacroAssembler::cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
2335                                 Label &amp;succeed, Label *fail) {
2336   // oldv holds comparison value
2337   // newv holds value to write in exchange
2338   // addr identifies memory word to compare against/update
2339   if (UseLSE) {
2340     mov(tmp, oldv);
2341     casal(Assembler::xword, oldv, newv, addr);
2342     cmp(tmp, oldv);
2343     br(Assembler::EQ, succeed);
2344     membar(AnyAny);
2345   } else {
2346     Label retry_load, nope;
2347     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2348       prfm(Address(addr), PSTL1STRM);
2349     bind(retry_load);
2350     // flush and load exclusive from the memory location
2351     // and fail if it is not what we expect
2352     ldaxr(tmp, addr);
2353     cmp(tmp, oldv);
2354     br(Assembler::NE, nope);
2355     // if we store+flush with no intervening write tmp wil be zero
2356     stlxr(tmp, newv, addr);
2357     cbzw(tmp, succeed);
2358     // retry so we only ever return after a load fails to compare
2359     // ensures we don&#39;t return a stale value after a failed write.
2360     b(retry_load);
2361     // if the memory word differs we return it in oldv and signal a fail
2362     bind(nope);
2363     membar(AnyAny);
2364     mov(oldv, tmp);
2365   }
2366   if (fail)
2367     b(*fail);
2368 }
2369 
2370 void MacroAssembler::cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
2371                                         Label &amp;succeed, Label *fail) {
2372   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;assumption&quot;);
2373   cmpxchgptr(oldv, newv, obj, tmp, succeed, fail);
2374 }
2375 
2376 void MacroAssembler::cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
2377                                 Label &amp;succeed, Label *fail) {
2378   // oldv holds comparison value
2379   // newv holds value to write in exchange
2380   // addr identifies memory word to compare against/update
2381   // tmp returns 0/1 for success/failure
2382   if (UseLSE) {
2383     mov(tmp, oldv);
2384     casal(Assembler::word, oldv, newv, addr);
2385     cmp(tmp, oldv);
2386     br(Assembler::EQ, succeed);
2387     membar(AnyAny);
2388   } else {
2389     Label retry_load, nope;
2390     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2391       prfm(Address(addr), PSTL1STRM);
2392     bind(retry_load);
2393     // flush and load exclusive from the memory location
2394     // and fail if it is not what we expect
2395     ldaxrw(tmp, addr);
2396     cmp(tmp, oldv);
2397     br(Assembler::NE, nope);
2398     // if we store+flush with no intervening write tmp wil be zero
2399     stlxrw(tmp, newv, addr);
2400     cbzw(tmp, succeed);
2401     // retry so we only ever return after a load fails to compare
2402     // ensures we don&#39;t return a stale value after a failed write.
2403     b(retry_load);
2404     // if the memory word differs we return it in oldv and signal a fail
2405     bind(nope);
2406     membar(AnyAny);
2407     mov(oldv, tmp);
2408   }
2409   if (fail)
2410     b(*fail);
2411 }
2412 
2413 // A generic CAS; success or failure is in the EQ flag.  A weak CAS
2414 // doesn&#39;t retry and may fail spuriously.  If the oldval is wanted,
2415 // Pass a register for the result, otherwise pass noreg.
2416 
2417 // Clobbers rscratch1
2418 void MacroAssembler::cmpxchg(Register addr, Register expected,
2419                              Register new_val,
2420                              enum operand_size size,
2421                              bool acquire, bool release,
2422                              bool weak,
2423                              Register result) {
2424   if (result == noreg)  result = rscratch1;
2425   BLOCK_COMMENT(&quot;cmpxchg {&quot;);
2426   if (UseLSE) {
2427     mov(result, expected);
2428     lse_cas(result, new_val, addr, size, acquire, release, /*not_pair*/ true);
2429     compare_eq(result, expected, size);
2430   } else {
2431     Label retry_load, done;
2432     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2433       prfm(Address(addr), PSTL1STRM);
2434     bind(retry_load);
2435     load_exclusive(result, addr, size, acquire);
2436     compare_eq(result, expected, size);
2437     br(Assembler::NE, done);
2438     store_exclusive(rscratch1, new_val, addr, size, release);
2439     if (weak) {
2440       cmpw(rscratch1, 0u);  // If the store fails, return NE to our caller.
2441     } else {
2442       cbnzw(rscratch1, retry_load);
2443     }
2444     bind(done);
2445   }
2446   BLOCK_COMMENT(&quot;} cmpxchg&quot;);
2447 }
2448 
2449 // A generic comparison. Only compares for equality, clobbers rscratch1.
2450 void MacroAssembler::compare_eq(Register rm, Register rn, enum operand_size size) {
2451   if (size == xword) {
2452     cmp(rm, rn);
2453   } else if (size == word) {
2454     cmpw(rm, rn);
2455   } else if (size == halfword) {
2456     eorw(rscratch1, rm, rn);
2457     ands(zr, rscratch1, 0xffff);
2458   } else if (size == byte) {
2459     eorw(rscratch1, rm, rn);
2460     ands(zr, rscratch1, 0xff);
2461   } else {
2462     ShouldNotReachHere();
2463   }
2464 }
2465 
2466 
2467 static bool different(Register a, RegisterOrConstant b, Register c) {
2468   if (b.is_constant())
2469     return a != c;
2470   else
2471     return a != b.as_register() &amp;&amp; a != c &amp;&amp; b.as_register() != c;
2472 }
2473 
2474 #define ATOMIC_OP(NAME, LDXR, OP, IOP, AOP, STXR, sz)                   \
2475 void MacroAssembler::atomic_##NAME(Register prev, RegisterOrConstant incr, Register addr) { \
2476   if (UseLSE) {                                                         \
2477     prev = prev-&gt;is_valid() ? prev : zr;                                \
2478     if (incr.is_register()) {                                           \
2479       AOP(sz, incr.as_register(), prev, addr);                          \
2480     } else {                                                            \
2481       mov(rscratch2, incr.as_constant());                               \
2482       AOP(sz, rscratch2, prev, addr);                                   \
2483     }                                                                   \
2484     return;                                                             \
2485   }                                                                     \
2486   Register result = rscratch2;                                          \
2487   if (prev-&gt;is_valid())                                                 \
2488     result = different(prev, incr, addr) ? prev : rscratch2;            \
2489                                                                         \
2490   Label retry_load;                                                     \
2491   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))         \
2492     prfm(Address(addr), PSTL1STRM);                                     \
2493   bind(retry_load);                                                     \
2494   LDXR(result, addr);                                                   \
2495   OP(rscratch1, result, incr);                                          \
2496   STXR(rscratch2, rscratch1, addr);                                     \
2497   cbnzw(rscratch2, retry_load);                                         \
2498   if (prev-&gt;is_valid() &amp;&amp; prev != result) {                             \
2499     IOP(prev, rscratch1, incr);                                         \
2500   }                                                                     \
2501 }
2502 
2503 ATOMIC_OP(add, ldxr, add, sub, ldadd, stxr, Assembler::xword)
2504 ATOMIC_OP(addw, ldxrw, addw, subw, ldadd, stxrw, Assembler::word)
2505 ATOMIC_OP(addal, ldaxr, add, sub, ldaddal, stlxr, Assembler::xword)
2506 ATOMIC_OP(addalw, ldaxrw, addw, subw, ldaddal, stlxrw, Assembler::word)
2507 
2508 #undef ATOMIC_OP
2509 
2510 #define ATOMIC_XCHG(OP, AOP, LDXR, STXR, sz)                            \
2511 void MacroAssembler::atomic_##OP(Register prev, Register newv, Register addr) { \
2512   if (UseLSE) {                                                         \
2513     prev = prev-&gt;is_valid() ? prev : zr;                                \
2514     AOP(sz, newv, prev, addr);                                          \
2515     return;                                                             \
2516   }                                                                     \
2517   Register result = rscratch2;                                          \
2518   if (prev-&gt;is_valid())                                                 \
2519     result = different(prev, newv, addr) ? prev : rscratch2;            \
2520                                                                         \
2521   Label retry_load;                                                     \
2522   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))         \
2523     prfm(Address(addr), PSTL1STRM);                                     \
2524   bind(retry_load);                                                     \
2525   LDXR(result, addr);                                                   \
2526   STXR(rscratch1, newv, addr);                                          \
2527   cbnzw(rscratch1, retry_load);                                         \
2528   if (prev-&gt;is_valid() &amp;&amp; prev != result)                               \
2529     mov(prev, result);                                                  \
2530 }
2531 
2532 ATOMIC_XCHG(xchg, swp, ldxr, stxr, Assembler::xword)
2533 ATOMIC_XCHG(xchgw, swp, ldxrw, stxrw, Assembler::word)
2534 ATOMIC_XCHG(xchgal, swpal, ldaxr, stlxr, Assembler::xword)
2535 ATOMIC_XCHG(xchgalw, swpal, ldaxrw, stlxrw, Assembler::word)
2536 
2537 #undef ATOMIC_XCHG
2538 
2539 #ifndef PRODUCT
2540 extern &quot;C&quot; void findpc(intptr_t x);
2541 #endif
2542 
2543 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[])
2544 {
2545   // In order to get locks to work, we need to fake a in_VM state
2546   if (ShowMessageBoxOnError ) {
2547     JavaThread* thread = JavaThread::current();
2548     JavaThreadState saved_state = thread-&gt;thread_state();
2549     thread-&gt;set_thread_state(_thread_in_vm);
2550 #ifndef PRODUCT
2551     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
2552       ttyLocker ttyl;
2553       BytecodeCounter::print();
2554     }
2555 #endif
2556     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
2557       ttyLocker ttyl;
2558       tty-&gt;print_cr(&quot; pc = 0x%016lx&quot;, pc);
2559 #ifndef PRODUCT
2560       tty-&gt;cr();
2561       findpc(pc);
2562       tty-&gt;cr();
2563 #endif
2564       tty-&gt;print_cr(&quot; r0 = 0x%016lx&quot;, regs[0]);
2565       tty-&gt;print_cr(&quot; r1 = 0x%016lx&quot;, regs[1]);
2566       tty-&gt;print_cr(&quot; r2 = 0x%016lx&quot;, regs[2]);
2567       tty-&gt;print_cr(&quot; r3 = 0x%016lx&quot;, regs[3]);
2568       tty-&gt;print_cr(&quot; r4 = 0x%016lx&quot;, regs[4]);
2569       tty-&gt;print_cr(&quot; r5 = 0x%016lx&quot;, regs[5]);
2570       tty-&gt;print_cr(&quot; r6 = 0x%016lx&quot;, regs[6]);
2571       tty-&gt;print_cr(&quot; r7 = 0x%016lx&quot;, regs[7]);
2572       tty-&gt;print_cr(&quot; r8 = 0x%016lx&quot;, regs[8]);
2573       tty-&gt;print_cr(&quot; r9 = 0x%016lx&quot;, regs[9]);
2574       tty-&gt;print_cr(&quot;r10 = 0x%016lx&quot;, regs[10]);
2575       tty-&gt;print_cr(&quot;r11 = 0x%016lx&quot;, regs[11]);
2576       tty-&gt;print_cr(&quot;r12 = 0x%016lx&quot;, regs[12]);
2577       tty-&gt;print_cr(&quot;r13 = 0x%016lx&quot;, regs[13]);
2578       tty-&gt;print_cr(&quot;r14 = 0x%016lx&quot;, regs[14]);
2579       tty-&gt;print_cr(&quot;r15 = 0x%016lx&quot;, regs[15]);
2580       tty-&gt;print_cr(&quot;r16 = 0x%016lx&quot;, regs[16]);
2581       tty-&gt;print_cr(&quot;r17 = 0x%016lx&quot;, regs[17]);
2582       tty-&gt;print_cr(&quot;r18 = 0x%016lx&quot;, regs[18]);
2583       tty-&gt;print_cr(&quot;r19 = 0x%016lx&quot;, regs[19]);
2584       tty-&gt;print_cr(&quot;r20 = 0x%016lx&quot;, regs[20]);
2585       tty-&gt;print_cr(&quot;r21 = 0x%016lx&quot;, regs[21]);
2586       tty-&gt;print_cr(&quot;r22 = 0x%016lx&quot;, regs[22]);
2587       tty-&gt;print_cr(&quot;r23 = 0x%016lx&quot;, regs[23]);
2588       tty-&gt;print_cr(&quot;r24 = 0x%016lx&quot;, regs[24]);
2589       tty-&gt;print_cr(&quot;r25 = 0x%016lx&quot;, regs[25]);
2590       tty-&gt;print_cr(&quot;r26 = 0x%016lx&quot;, regs[26]);
2591       tty-&gt;print_cr(&quot;r27 = 0x%016lx&quot;, regs[27]);
2592       tty-&gt;print_cr(&quot;r28 = 0x%016lx&quot;, regs[28]);
2593       tty-&gt;print_cr(&quot;r30 = 0x%016lx&quot;, regs[30]);
2594       tty-&gt;print_cr(&quot;r31 = 0x%016lx&quot;, regs[31]);
2595       BREAKPOINT;
2596     }
2597   }
2598   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
2599 }
2600 
2601 void MacroAssembler::push_call_clobbered_registers() {
2602   int step = 4 * wordSize;
2603   push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
2604   sub(sp, sp, step);
2605   mov(rscratch1, -step);
2606   // Push v0-v7, v16-v31.
2607   for (int i = 31; i&gt;= 4; i -= 4) {
2608     if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
2609       st1(as_FloatRegister(i-3), as_FloatRegister(i-2), as_FloatRegister(i-1),
2610           as_FloatRegister(i), T1D, Address(post(sp, rscratch1)));
2611   }
2612   st1(as_FloatRegister(0), as_FloatRegister(1), as_FloatRegister(2),
2613       as_FloatRegister(3), T1D, Address(sp));
2614 }
2615 
2616 void MacroAssembler::pop_call_clobbered_registers() {
2617   for (int i = 0; i &lt; 32; i += 4) {
2618     if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
2619       ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2620           as_FloatRegister(i+3), T1D, Address(post(sp, 4 * wordSize)));
2621   }
2622 
2623   pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
2624 }
2625 
2626 void MacroAssembler::push_CPU_state(bool save_vectors) {
2627   int step = (save_vectors ? 8 : 4) * wordSize;
2628   push(0x3fffffff, sp);         // integer registers except lr &amp; sp
2629   mov(rscratch1, -step);
2630   sub(sp, sp, step);
2631   for (int i = 28; i &gt;= 4; i -= 4) {
2632     st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2633         as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));
2634   }
2635   st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);
2636 }
2637 
2638 void MacroAssembler::pop_CPU_state(bool restore_vectors) {
2639   int step = (restore_vectors ? 8 : 4) * wordSize;
2640   for (int i = 0; i &lt;= 28; i += 4)
2641     ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2642         as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));
2643   pop(0x3fffffff, sp);         // integer registers except lr &amp; sp
2644 }
2645 
2646 /**
2647  * Helpers for multiply_to_len().
2648  */
2649 void MacroAssembler::add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
2650                                      Register src1, Register src2) {
2651   adds(dest_lo, dest_lo, src1);
2652   adc(dest_hi, dest_hi, zr);
2653   adds(dest_lo, dest_lo, src2);
2654   adc(final_dest_hi, dest_hi, zr);
2655 }
2656 
2657 // Generate an address from (r + r1 extend offset).  &quot;size&quot; is the
2658 // size of the operand.  The result may be in rscratch2.
2659 Address MacroAssembler::offsetted_address(Register r, Register r1,
2660                                           Address::extend ext, int offset, int size) {
2661   if (offset || (ext.shift() % size != 0)) {
2662     lea(rscratch2, Address(r, r1, ext));
2663     return Address(rscratch2, offset);
2664   } else {
2665     return Address(r, r1, ext);
2666   }
2667 }
2668 
2669 Address MacroAssembler::spill_address(int size, int offset, Register tmp)
2670 {
2671   assert(offset &gt;= 0, &quot;spill to negative address?&quot;);
2672   // Offset reachable ?
2673   //   Not aligned - 9 bits signed offset
2674   //   Aligned - 12 bits unsigned offset shifted
2675   Register base = sp;
2676   if ((offset &amp; (size-1)) &amp;&amp; offset &gt;= (1&lt;&lt;8)) {
2677     add(tmp, base, offset &amp; ((1&lt;&lt;12)-1));
2678     base = tmp;
2679     offset &amp;= -1u&lt;&lt;12;
2680   }
2681 
2682   if (offset &gt;= (1&lt;&lt;12) * size) {
2683     add(tmp, base, offset &amp; (((1&lt;&lt;12)-1)&lt;&lt;12));
2684     base = tmp;
2685     offset &amp;= ~(((1&lt;&lt;12)-1)&lt;&lt;12);
2686   }
2687 
2688   return Address(base, offset);
2689 }
2690 
2691 // Checks whether offset is aligned.
2692 // Returns true if it is, else false.
2693 bool MacroAssembler::merge_alignment_check(Register base,
2694                                            size_t size,
2695                                            long cur_offset,
2696                                            long prev_offset) const {
2697   if (AvoidUnalignedAccesses) {
2698     if (base == sp) {
2699       // Checks whether low offset if aligned to pair of registers.
2700       long pair_mask = size * 2 - 1;
2701       long offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;
2702       return (offset &amp; pair_mask) == 0;
2703     } else { // If base is not sp, we can&#39;t guarantee the access is aligned.
2704       return false;
2705     }
2706   } else {
2707     long mask = size - 1;
2708     // Load/store pair instruction only supports element size aligned offset.
2709     return (cur_offset &amp; mask) == 0 &amp;&amp; (prev_offset &amp; mask) == 0;
2710   }
2711 }
2712 
2713 // Checks whether current and previous loads/stores can be merged.
2714 // Returns true if it can be merged, else false.
2715 bool MacroAssembler::ldst_can_merge(Register rt,
2716                                     const Address &amp;adr,
2717                                     size_t cur_size_in_bytes,
2718                                     bool is_store) const {
2719   address prev = pc() - NativeInstruction::instruction_size;
2720   address last = code()-&gt;last_insn();
2721 
2722   if (last == NULL || !nativeInstruction_at(last)-&gt;is_Imm_LdSt()) {
2723     return false;
2724   }
2725 
2726   if (adr.getMode() != Address::base_plus_offset || prev != last) {
2727     return false;
2728   }
2729 
2730   NativeLdSt* prev_ldst = NativeLdSt_at(prev);
2731   size_t prev_size_in_bytes = prev_ldst-&gt;size_in_bytes();
2732 
2733   assert(prev_size_in_bytes == 4 || prev_size_in_bytes == 8, &quot;only supports 64/32bit merging.&quot;);
2734   assert(cur_size_in_bytes == 4 || cur_size_in_bytes == 8, &quot;only supports 64/32bit merging.&quot;);
2735 
2736   if (cur_size_in_bytes != prev_size_in_bytes || is_store != prev_ldst-&gt;is_store()) {
2737     return false;
2738   }
2739 
2740   long max_offset = 63 * prev_size_in_bytes;
2741   long min_offset = -64 * prev_size_in_bytes;
2742 
2743   assert(prev_ldst-&gt;is_not_pre_post_index(), &quot;pre-index or post-index is not supported to be merged.&quot;);
2744 
2745   // Only same base can be merged.
2746   if (adr.base() != prev_ldst-&gt;base()) {
2747     return false;
2748   }
2749 
2750   long cur_offset = adr.offset();
2751   long prev_offset = prev_ldst-&gt;offset();
2752   size_t diff = abs(cur_offset - prev_offset);
2753   if (diff != prev_size_in_bytes) {
2754     return false;
2755   }
2756 
2757   // Following cases can not be merged:
2758   // ldr x2, [x2, #8]
2759   // ldr x3, [x2, #16]
2760   // or:
2761   // ldr x2, [x3, #8]
2762   // ldr x2, [x3, #16]
2763   // If t1 and t2 is the same in &quot;ldp t1, t2, [xn, #imm]&quot;, we&#39;ll get SIGILL.
2764   if (!is_store &amp;&amp; (adr.base() == prev_ldst-&gt;target() || rt == prev_ldst-&gt;target())) {
2765     return false;
2766   }
2767 
2768   long low_offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;
2769   // Offset range must be in ldp/stp instruction&#39;s range.
2770   if (low_offset &gt; max_offset || low_offset &lt; min_offset) {
2771     return false;
2772   }
2773 
2774   if (merge_alignment_check(adr.base(), prev_size_in_bytes, cur_offset, prev_offset)) {
2775     return true;
2776   }
2777 
2778   return false;
2779 }
2780 
2781 // Merge current load/store with previous load/store into ldp/stp.
2782 void MacroAssembler::merge_ldst(Register rt,
2783                                 const Address &amp;adr,
2784                                 size_t cur_size_in_bytes,
2785                                 bool is_store) {
2786 
2787   assert(ldst_can_merge(rt, adr, cur_size_in_bytes, is_store) == true, &quot;cur and prev must be able to be merged.&quot;);
2788 
2789   Register rt_low, rt_high;
2790   address prev = pc() - NativeInstruction::instruction_size;
2791   NativeLdSt* prev_ldst = NativeLdSt_at(prev);
2792 
2793   long offset;
2794 
2795   if (adr.offset() &lt; prev_ldst-&gt;offset()) {
2796     offset = adr.offset();
2797     rt_low = rt;
2798     rt_high = prev_ldst-&gt;target();
2799   } else {
2800     offset = prev_ldst-&gt;offset();
2801     rt_low = prev_ldst-&gt;target();
2802     rt_high = rt;
2803   }
2804 
2805   Address adr_p = Address(prev_ldst-&gt;base(), offset);
2806   // Overwrite previous generated binary.
2807   code_section()-&gt;set_end(prev);
2808 
2809   const int sz = prev_ldst-&gt;size_in_bytes();
2810   assert(sz == 8 || sz == 4, &quot;only supports 64/32bit merging.&quot;);
2811   if (!is_store) {
2812     BLOCK_COMMENT(&quot;merged ldr pair&quot;);
2813     if (sz == 8) {
2814       ldp(rt_low, rt_high, adr_p);
2815     } else {
2816       ldpw(rt_low, rt_high, adr_p);
2817     }
2818   } else {
2819     BLOCK_COMMENT(&quot;merged str pair&quot;);
2820     if (sz == 8) {
2821       stp(rt_low, rt_high, adr_p);
2822     } else {
2823       stpw(rt_low, rt_high, adr_p);
2824     }
2825   }
2826 }
2827 
2828 /**
2829  * Multiply 64 bit by 64 bit first loop.
2830  */
2831 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
2832                                            Register y, Register y_idx, Register z,
2833                                            Register carry, Register product,
2834                                            Register idx, Register kdx) {
2835   //
2836   //  jlong carry, x[], y[], z[];
2837   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
2838   //    huge_128 product = y[idx] * x[xstart] + carry;
2839   //    z[kdx] = (jlong)product;
2840   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
2841   //  }
2842   //  z[xstart] = carry;
2843   //
2844 
2845   Label L_first_loop, L_first_loop_exit;
2846   Label L_one_x, L_one_y, L_multiply;
2847 
2848   subsw(xstart, xstart, 1);
2849   br(Assembler::MI, L_one_x);
2850 
2851   lea(rscratch1, Address(x, xstart, Address::lsl(LogBytesPerInt)));
2852   ldr(x_xstart, Address(rscratch1));
2853   ror(x_xstart, x_xstart, 32); // convert big-endian to little-endian
2854 
2855   bind(L_first_loop);
2856   subsw(idx, idx, 1);
2857   br(Assembler::MI, L_first_loop_exit);
2858   subsw(idx, idx, 1);
2859   br(Assembler::MI, L_one_y);
2860   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2861   ldr(y_idx, Address(rscratch1));
2862   ror(y_idx, y_idx, 32); // convert big-endian to little-endian
2863   bind(L_multiply);
2864 
2865   // AArch64 has a multiply-accumulate instruction that we can&#39;t use
2866   // here because it has no way to process carries, so we have to use
2867   // separate add and adc instructions.  Bah.
2868   umulh(rscratch1, x_xstart, y_idx); // x_xstart * y_idx -&gt; rscratch1:product
2869   mul(product, x_xstart, y_idx);
2870   adds(product, product, carry);
2871   adc(carry, rscratch1, zr);   // x_xstart * y_idx + carry -&gt; carry:product
2872 
2873   subw(kdx, kdx, 2);
2874   ror(product, product, 32); // back to big-endian
2875   str(product, offsetted_address(z, kdx, Address::uxtw(LogBytesPerInt), 0, BytesPerLong));
2876 
2877   b(L_first_loop);
2878 
2879   bind(L_one_y);
2880   ldrw(y_idx, Address(y,  0));
2881   b(L_multiply);
2882 
2883   bind(L_one_x);
2884   ldrw(x_xstart, Address(x,  0));
2885   b(L_first_loop);
2886 
2887   bind(L_first_loop_exit);
2888 }
2889 
2890 /**
2891  * Multiply 128 bit by 128. Unrolled inner loop.
2892  *
2893  */
2894 void MacroAssembler::multiply_128_x_128_loop(Register y, Register z,
2895                                              Register carry, Register carry2,
2896                                              Register idx, Register jdx,
2897                                              Register yz_idx1, Register yz_idx2,
2898                                              Register tmp, Register tmp3, Register tmp4,
2899                                              Register tmp6, Register product_hi) {
2900 
2901   //   jlong carry, x[], y[], z[];
2902   //   int kdx = ystart+1;
2903   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
2904   //     huge_128 tmp3 = (y[idx+1] * product_hi) + z[kdx+idx+1] + carry;
2905   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
2906   //     huge_128 tmp4 = (y[idx]   * product_hi) + z[kdx+idx] + carry2;
2907   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
2908   //     z[kdx+idx+1] = (jlong)tmp3;
2909   //     z[kdx+idx] = (jlong)tmp4;
2910   //   }
2911   //   idx += 2;
2912   //   if (idx &gt; 0) {
2913   //     yz_idx1 = (y[idx] * product_hi) + z[kdx+idx] + carry;
2914   //     z[kdx+idx] = (jlong)yz_idx1;
2915   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
2916   //   }
2917   //
2918 
2919   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
2920 
2921   lsrw(jdx, idx, 2);
2922 
2923   bind(L_third_loop);
2924 
2925   subsw(jdx, jdx, 1);
2926   br(Assembler::MI, L_third_loop_exit);
2927   subw(idx, idx, 4);
2928 
2929   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2930 
2931   ldp(yz_idx2, yz_idx1, Address(rscratch1, 0));
2932 
2933   lea(tmp6, Address(z, idx, Address::uxtw(LogBytesPerInt)));
2934 
2935   ror(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
2936   ror(yz_idx2, yz_idx2, 32);
2937 
2938   ldp(rscratch2, rscratch1, Address(tmp6, 0));
2939 
2940   mul(tmp3, product_hi, yz_idx1);  //  yz_idx1 * product_hi -&gt; tmp4:tmp3
2941   umulh(tmp4, product_hi, yz_idx1);
2942 
2943   ror(rscratch1, rscratch1, 32); // convert big-endian to little-endian
2944   ror(rscratch2, rscratch2, 32);
2945 
2946   mul(tmp, product_hi, yz_idx2);   //  yz_idx2 * product_hi -&gt; carry2:tmp
2947   umulh(carry2, product_hi, yz_idx2);
2948 
2949   // propagate sum of both multiplications into carry:tmp4:tmp3
2950   adds(tmp3, tmp3, carry);
2951   adc(tmp4, tmp4, zr);
2952   adds(tmp3, tmp3, rscratch1);
2953   adcs(tmp4, tmp4, tmp);
2954   adc(carry, carry2, zr);
2955   adds(tmp4, tmp4, rscratch2);
2956   adc(carry, carry, zr);
2957 
2958   ror(tmp3, tmp3, 32); // convert little-endian to big-endian
2959   ror(tmp4, tmp4, 32);
2960   stp(tmp4, tmp3, Address(tmp6, 0));
2961 
2962   b(L_third_loop);
2963   bind (L_third_loop_exit);
2964 
2965   andw (idx, idx, 0x3);
2966   cbz(idx, L_post_third_loop_done);
2967 
2968   Label L_check_1;
2969   subsw(idx, idx, 2);
2970   br(Assembler::MI, L_check_1);
2971 
2972   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2973   ldr(yz_idx1, Address(rscratch1, 0));
2974   ror(yz_idx1, yz_idx1, 32);
2975   mul(tmp3, product_hi, yz_idx1);  //  yz_idx1 * product_hi -&gt; tmp4:tmp3
2976   umulh(tmp4, product_hi, yz_idx1);
2977   lea(rscratch1, Address(z, idx, Address::uxtw(LogBytesPerInt)));
2978   ldr(yz_idx2, Address(rscratch1, 0));
2979   ror(yz_idx2, yz_idx2, 32);
2980 
2981   add2_with_carry(carry, tmp4, tmp3, carry, yz_idx2);
2982 
2983   ror(tmp3, tmp3, 32);
2984   str(tmp3, Address(rscratch1, 0));
2985 
2986   bind (L_check_1);
2987 
2988   andw (idx, idx, 0x1);
2989   subsw(idx, idx, 1);
2990   br(Assembler::MI, L_post_third_loop_done);
2991   ldrw(tmp4, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2992   mul(tmp3, tmp4, product_hi);  //  tmp4 * product_hi -&gt; carry2:tmp3
2993   umulh(carry2, tmp4, product_hi);
2994   ldrw(tmp4, Address(z, idx, Address::uxtw(LogBytesPerInt)));
2995 
2996   add2_with_carry(carry2, tmp3, tmp4, carry);
2997 
2998   strw(tmp3, Address(z, idx, Address::uxtw(LogBytesPerInt)));
2999   extr(carry, carry2, tmp3, 32);
3000 
3001   bind(L_post_third_loop_done);
3002 }
3003 
3004 /**
3005  * Code for BigInteger::multiplyToLen() instrinsic.
3006  *
3007  * r0: x
3008  * r1: xlen
3009  * r2: y
3010  * r3: ylen
3011  * r4:  z
3012  * r5: zlen
3013  * r10: tmp1
3014  * r11: tmp2
3015  * r12: tmp3
3016  * r13: tmp4
3017  * r14: tmp5
3018  * r15: tmp6
3019  * r16: tmp7
3020  *
3021  */
3022 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen,
3023                                      Register z, Register zlen,
3024                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4,
3025                                      Register tmp5, Register tmp6, Register product_hi) {
3026 
3027   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);
3028 
3029   const Register idx = tmp1;
3030   const Register kdx = tmp2;
3031   const Register xstart = tmp3;
3032 
3033   const Register y_idx = tmp4;
3034   const Register carry = tmp5;
3035   const Register product  = xlen;
3036   const Register x_xstart = zlen;  // reuse register
3037 
3038   // First Loop.
3039   //
3040   //  final static long LONG_MASK = 0xffffffffL;
3041   //  int xstart = xlen - 1;
3042   //  int ystart = ylen - 1;
3043   //  long carry = 0;
3044   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
3045   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
3046   //    z[kdx] = (int)product;
3047   //    carry = product &gt;&gt;&gt; 32;
3048   //  }
3049   //  z[xstart] = (int)carry;
3050   //
3051 
3052   movw(idx, ylen);      // idx = ylen;
3053   movw(kdx, zlen);      // kdx = xlen+ylen;
3054   mov(carry, zr);       // carry = 0;
3055 
3056   Label L_done;
3057 
3058   movw(xstart, xlen);
3059   subsw(xstart, xstart, 1);
3060   br(Assembler::MI, L_done);
3061 
3062   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
3063 
3064   Label L_second_loop;
3065   cbzw(kdx, L_second_loop);
3066 
3067   Label L_carry;
3068   subw(kdx, kdx, 1);
3069   cbzw(kdx, L_carry);
3070 
3071   strw(carry, Address(z, kdx, Address::uxtw(LogBytesPerInt)));
3072   lsr(carry, carry, 32);
3073   subw(kdx, kdx, 1);
3074 
3075   bind(L_carry);
3076   strw(carry, Address(z, kdx, Address::uxtw(LogBytesPerInt)));
3077 
3078   // Second and third (nested) loops.
3079   //
3080   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
3081   //   carry = 0;
3082   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
3083   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
3084   //                    (z[k] &amp; LONG_MASK) + carry;
3085   //     z[k] = (int)product;
3086   //     carry = product &gt;&gt;&gt; 32;
3087   //   }
3088   //   z[i] = (int)carry;
3089   // }
3090   //
3091   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = product_hi
3092 
3093   const Register jdx = tmp1;
3094 
3095   bind(L_second_loop);
3096   mov(carry, zr);                // carry = 0;
3097   movw(jdx, ylen);               // j = ystart+1
3098 
3099   subsw(xstart, xstart, 1);      // i = xstart-1;
3100   br(Assembler::MI, L_done);
3101 
3102   str(z, Address(pre(sp, -4 * wordSize)));
3103 
3104   Label L_last_x;
3105   lea(z, offsetted_address(z, xstart, Address::uxtw(LogBytesPerInt), 4, BytesPerInt)); // z = z + k - j
3106   subsw(xstart, xstart, 1);       // i = xstart-1;
3107   br(Assembler::MI, L_last_x);
3108 
3109   lea(rscratch1, Address(x, xstart, Address::uxtw(LogBytesPerInt)));
3110   ldr(product_hi, Address(rscratch1));
3111   ror(product_hi, product_hi, 32);  // convert big-endian to little-endian
3112 
3113   Label L_third_loop_prologue;
3114   bind(L_third_loop_prologue);
3115 
3116   str(ylen, Address(sp, wordSize));
3117   stp(x, xstart, Address(sp, 2 * wordSize));
3118   multiply_128_x_128_loop(y, z, carry, x, jdx, ylen, product,
3119                           tmp2, x_xstart, tmp3, tmp4, tmp6, product_hi);
3120   ldp(z, ylen, Address(post(sp, 2 * wordSize)));
3121   ldp(x, xlen, Address(post(sp, 2 * wordSize)));   // copy old xstart -&gt; xlen
3122 
3123   addw(tmp3, xlen, 1);
3124   strw(carry, Address(z, tmp3, Address::uxtw(LogBytesPerInt)));
3125   subsw(tmp3, tmp3, 1);
3126   br(Assembler::MI, L_done);
3127 
3128   lsr(carry, carry, 32);
3129   strw(carry, Address(z, tmp3, Address::uxtw(LogBytesPerInt)));
3130   b(L_second_loop);
3131 
3132   // Next infrequent code is moved outside loops.
3133   bind(L_last_x);
3134   ldrw(product_hi, Address(x,  0));
3135   b(L_third_loop_prologue);
3136 
3137   bind(L_done);
3138 }
3139 
3140 // Code for BigInteger::mulAdd instrinsic
3141 // out     = r0
3142 // in      = r1
3143 // offset  = r2  (already out.length-offset)
3144 // len     = r3
3145 // k       = r4
3146 //
3147 // pseudo code from java implementation:
3148 // carry = 0;
3149 // offset = out.length-offset - 1;
3150 // for (int j=len-1; j &gt;= 0; j--) {
3151 //     product = (in[j] &amp; LONG_MASK) * kLong + (out[offset] &amp; LONG_MASK) + carry;
3152 //     out[offset--] = (int)product;
3153 //     carry = product &gt;&gt;&gt; 32;
3154 // }
3155 // return (int)carry;
3156 void MacroAssembler::mul_add(Register out, Register in, Register offset,
3157       Register len, Register k) {
3158     Label LOOP, END;
3159     // pre-loop
3160     cmp(len, zr); // cmp, not cbz/cbnz: to use condition twice =&gt; less branches
3161     csel(out, zr, out, Assembler::EQ);
3162     br(Assembler::EQ, END);
3163     add(in, in, len, LSL, 2); // in[j+1] address
3164     add(offset, out, offset, LSL, 2); // out[offset + 1] address
3165     mov(out, zr); // used to keep carry now
3166     BIND(LOOP);
3167     ldrw(rscratch1, Address(pre(in, -4)));
3168     madd(rscratch1, rscratch1, k, out);
3169     ldrw(rscratch2, Address(pre(offset, -4)));
3170     add(rscratch1, rscratch1, rscratch2);
3171     strw(rscratch1, Address(offset));
3172     lsr(out, rscratch1, 32);
3173     subs(len, len, 1);
3174     br(Assembler::NE, LOOP);
3175     BIND(END);
3176 }
3177 
3178 /**
3179  * Emits code to update CRC-32 with a byte value according to constants in table
3180  *
3181  * @param [in,out]crc   Register containing the crc.
3182  * @param [in]val       Register containing the byte to fold into the CRC.
3183  * @param [in]table     Register containing the table of crc constants.
3184  *
3185  * uint32_t crc;
3186  * val = crc_table[(val ^ crc) &amp; 0xFF];
3187  * crc = val ^ (crc &gt;&gt; 8);
3188  *
3189  */
3190 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
3191   eor(val, val, crc);
3192   andr(val, val, 0xff);
3193   ldrw(val, Address(table, val, Address::lsl(2)));
3194   eor(crc, val, crc, Assembler::LSR, 8);
3195 }
3196 
3197 /**
3198  * Emits code to update CRC-32 with a 32-bit value according to tables 0 to 3
3199  *
3200  * @param [in,out]crc   Register containing the crc.
3201  * @param [in]v         Register containing the 32-bit to fold into the CRC.
3202  * @param [in]table0    Register containing table 0 of crc constants.
3203  * @param [in]table1    Register containing table 1 of crc constants.
3204  * @param [in]table2    Register containing table 2 of crc constants.
3205  * @param [in]table3    Register containing table 3 of crc constants.
3206  *
3207  * uint32_t crc;
3208  *   v = crc ^ v
3209  *   crc = table3[v&amp;0xff]^table2[(v&gt;&gt;8)&amp;0xff]^table1[(v&gt;&gt;16)&amp;0xff]^table0[v&gt;&gt;24]
3210  *
3211  */
3212 void MacroAssembler::update_word_crc32(Register crc, Register v, Register tmp,
3213         Register table0, Register table1, Register table2, Register table3,
3214         bool upper) {
3215   eor(v, crc, v, upper ? LSR:LSL, upper ? 32:0);
3216   uxtb(tmp, v);
3217   ldrw(crc, Address(table3, tmp, Address::lsl(2)));
3218   ubfx(tmp, v, 8, 8);
3219   ldrw(tmp, Address(table2, tmp, Address::lsl(2)));
3220   eor(crc, crc, tmp);
3221   ubfx(tmp, v, 16, 8);
3222   ldrw(tmp, Address(table1, tmp, Address::lsl(2)));
3223   eor(crc, crc, tmp);
3224   ubfx(tmp, v, 24, 8);
3225   ldrw(tmp, Address(table0, tmp, Address::lsl(2)));
3226   eor(crc, crc, tmp);
3227 }
3228 
3229 void MacroAssembler::kernel_crc32_using_crc32(Register crc, Register buf,
3230         Register len, Register tmp0, Register tmp1, Register tmp2,
3231         Register tmp3) {
3232     Label CRC_by64_loop, CRC_by4_loop, CRC_by1_loop, CRC_less64, CRC_by64_pre, CRC_by32_loop, CRC_less32, L_exit;
3233     assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2, tmp3);
3234 
3235     mvnw(crc, crc);
3236 
3237     subs(len, len, 128);
3238     br(Assembler::GE, CRC_by64_pre);
3239   BIND(CRC_less64);
3240     adds(len, len, 128-32);
3241     br(Assembler::GE, CRC_by32_loop);
3242   BIND(CRC_less32);
3243     adds(len, len, 32-4);
3244     br(Assembler::GE, CRC_by4_loop);
3245     adds(len, len, 4);
3246     br(Assembler::GT, CRC_by1_loop);
3247     b(L_exit);
3248 
3249   BIND(CRC_by32_loop);
3250     ldp(tmp0, tmp1, Address(post(buf, 16)));
3251     subs(len, len, 32);
3252     crc32x(crc, crc, tmp0);
3253     ldr(tmp2, Address(post(buf, 8)));
3254     crc32x(crc, crc, tmp1);
3255     ldr(tmp3, Address(post(buf, 8)));
3256     crc32x(crc, crc, tmp2);
3257     crc32x(crc, crc, tmp3);
3258     br(Assembler::GE, CRC_by32_loop);
3259     cmn(len, 32);
3260     br(Assembler::NE, CRC_less32);
3261     b(L_exit);
3262 
3263   BIND(CRC_by4_loop);
3264     ldrw(tmp0, Address(post(buf, 4)));
3265     subs(len, len, 4);
3266     crc32w(crc, crc, tmp0);
3267     br(Assembler::GE, CRC_by4_loop);
3268     adds(len, len, 4);
3269     br(Assembler::LE, L_exit);
3270   BIND(CRC_by1_loop);
3271     ldrb(tmp0, Address(post(buf, 1)));
3272     subs(len, len, 1);
3273     crc32b(crc, crc, tmp0);
3274     br(Assembler::GT, CRC_by1_loop);
3275     b(L_exit);
3276 
3277   BIND(CRC_by64_pre);
3278     sub(buf, buf, 8);
3279     ldp(tmp0, tmp1, Address(buf, 8));
3280     crc32x(crc, crc, tmp0);
3281     ldr(tmp2, Address(buf, 24));
3282     crc32x(crc, crc, tmp1);
3283     ldr(tmp3, Address(buf, 32));
3284     crc32x(crc, crc, tmp2);
3285     ldr(tmp0, Address(buf, 40));
3286     crc32x(crc, crc, tmp3);
3287     ldr(tmp1, Address(buf, 48));
3288     crc32x(crc, crc, tmp0);
3289     ldr(tmp2, Address(buf, 56));
3290     crc32x(crc, crc, tmp1);
3291     ldr(tmp3, Address(pre(buf, 64)));
3292 
3293     b(CRC_by64_loop);
3294 
3295     align(CodeEntryAlignment);
3296   BIND(CRC_by64_loop);
3297     subs(len, len, 64);
3298     crc32x(crc, crc, tmp2);
3299     ldr(tmp0, Address(buf, 8));
3300     crc32x(crc, crc, tmp3);
3301     ldr(tmp1, Address(buf, 16));
3302     crc32x(crc, crc, tmp0);
3303     ldr(tmp2, Address(buf, 24));
3304     crc32x(crc, crc, tmp1);
3305     ldr(tmp3, Address(buf, 32));
3306     crc32x(crc, crc, tmp2);
3307     ldr(tmp0, Address(buf, 40));
3308     crc32x(crc, crc, tmp3);
3309     ldr(tmp1, Address(buf, 48));
3310     crc32x(crc, crc, tmp0);
3311     ldr(tmp2, Address(buf, 56));
3312     crc32x(crc, crc, tmp1);
3313     ldr(tmp3, Address(pre(buf, 64)));
3314     br(Assembler::GE, CRC_by64_loop);
3315 
3316     // post-loop
3317     crc32x(crc, crc, tmp2);
3318     crc32x(crc, crc, tmp3);
3319 
3320     sub(len, len, 64);
3321     add(buf, buf, 8);
3322     cmn(len, 128);
3323     br(Assembler::NE, CRC_less64);
3324   BIND(L_exit);
3325     mvnw(crc, crc);
3326 }
3327 
3328 /**
3329  * @param crc   register containing existing CRC (32-bit)
3330  * @param buf   register pointing to input byte buffer (byte*)
3331  * @param len   register containing number of bytes
3332  * @param table register that will contain address of CRC table
3333  * @param tmp   scratch register
3334  */
3335 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,
3336         Register table0, Register table1, Register table2, Register table3,
3337         Register tmp, Register tmp2, Register tmp3) {
3338   Label L_by16, L_by16_loop, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;
3339   unsigned long offset;
3340 
3341   if (UseCRC32) {
3342       kernel_crc32_using_crc32(crc, buf, len, table0, table1, table2, table3);
3343       return;
3344   }
3345 
3346     mvnw(crc, crc);
3347 
3348     adrp(table0, ExternalAddress(StubRoutines::crc_table_addr()), offset);
3349     if (offset) add(table0, table0, offset);
3350     add(table1, table0, 1*256*sizeof(juint));
3351     add(table2, table0, 2*256*sizeof(juint));
3352     add(table3, table0, 3*256*sizeof(juint));
3353 
3354   if (UseNeon) {
3355       cmp(len, (u1)64);
3356       br(Assembler::LT, L_by16);
3357       eor(v16, T16B, v16, v16);
3358 
3359     Label L_fold;
3360 
3361       add(tmp, table0, 4*256*sizeof(juint)); // Point at the Neon constants
3362 
3363       ld1(v0, v1, T2D, post(buf, 32));
3364       ld1r(v4, T2D, post(tmp, 8));
3365       ld1r(v5, T2D, post(tmp, 8));
3366       ld1r(v6, T2D, post(tmp, 8));
3367       ld1r(v7, T2D, post(tmp, 8));
3368       mov(v16, T4S, 0, crc);
3369 
3370       eor(v0, T16B, v0, v16);
3371       sub(len, len, 64);
3372 
3373     BIND(L_fold);
3374       pmull(v22, T8H, v0, v5, T8B);
3375       pmull(v20, T8H, v0, v7, T8B);
3376       pmull(v23, T8H, v0, v4, T8B);
3377       pmull(v21, T8H, v0, v6, T8B);
3378 
3379       pmull2(v18, T8H, v0, v5, T16B);
3380       pmull2(v16, T8H, v0, v7, T16B);
3381       pmull2(v19, T8H, v0, v4, T16B);
3382       pmull2(v17, T8H, v0, v6, T16B);
3383 
3384       uzp1(v24, T8H, v20, v22);
3385       uzp2(v25, T8H, v20, v22);
3386       eor(v20, T16B, v24, v25);
3387 
3388       uzp1(v26, T8H, v16, v18);
3389       uzp2(v27, T8H, v16, v18);
3390       eor(v16, T16B, v26, v27);
3391 
3392       ushll2(v22, T4S, v20, T8H, 8);
3393       ushll(v20, T4S, v20, T4H, 8);
3394 
3395       ushll2(v18, T4S, v16, T8H, 8);
3396       ushll(v16, T4S, v16, T4H, 8);
3397 
3398       eor(v22, T16B, v23, v22);
3399       eor(v18, T16B, v19, v18);
3400       eor(v20, T16B, v21, v20);
3401       eor(v16, T16B, v17, v16);
3402 
3403       uzp1(v17, T2D, v16, v20);
3404       uzp2(v21, T2D, v16, v20);
3405       eor(v17, T16B, v17, v21);
3406 
3407       ushll2(v20, T2D, v17, T4S, 16);
3408       ushll(v16, T2D, v17, T2S, 16);
3409 
3410       eor(v20, T16B, v20, v22);
3411       eor(v16, T16B, v16, v18);
3412 
3413       uzp1(v17, T2D, v20, v16);
3414       uzp2(v21, T2D, v20, v16);
3415       eor(v28, T16B, v17, v21);
3416 
3417       pmull(v22, T8H, v1, v5, T8B);
3418       pmull(v20, T8H, v1, v7, T8B);
3419       pmull(v23, T8H, v1, v4, T8B);
3420       pmull(v21, T8H, v1, v6, T8B);
3421 
3422       pmull2(v18, T8H, v1, v5, T16B);
3423       pmull2(v16, T8H, v1, v7, T16B);
3424       pmull2(v19, T8H, v1, v4, T16B);
3425       pmull2(v17, T8H, v1, v6, T16B);
3426 
3427       ld1(v0, v1, T2D, post(buf, 32));
3428 
3429       uzp1(v24, T8H, v20, v22);
3430       uzp2(v25, T8H, v20, v22);
3431       eor(v20, T16B, v24, v25);
3432 
3433       uzp1(v26, T8H, v16, v18);
3434       uzp2(v27, T8H, v16, v18);
3435       eor(v16, T16B, v26, v27);
3436 
3437       ushll2(v22, T4S, v20, T8H, 8);
3438       ushll(v20, T4S, v20, T4H, 8);
3439 
3440       ushll2(v18, T4S, v16, T8H, 8);
3441       ushll(v16, T4S, v16, T4H, 8);
3442 
3443       eor(v22, T16B, v23, v22);
3444       eor(v18, T16B, v19, v18);
3445       eor(v20, T16B, v21, v20);
3446       eor(v16, T16B, v17, v16);
3447 
3448       uzp1(v17, T2D, v16, v20);
3449       uzp2(v21, T2D, v16, v20);
3450       eor(v16, T16B, v17, v21);
3451 
3452       ushll2(v20, T2D, v16, T4S, 16);
3453       ushll(v16, T2D, v16, T2S, 16);
3454 
3455       eor(v20, T16B, v22, v20);
3456       eor(v16, T16B, v16, v18);
3457 
3458       uzp1(v17, T2D, v20, v16);
3459       uzp2(v21, T2D, v20, v16);
3460       eor(v20, T16B, v17, v21);
3461 
3462       shl(v16, T2D, v28, 1);
3463       shl(v17, T2D, v20, 1);
3464 
3465       eor(v0, T16B, v0, v16);
3466       eor(v1, T16B, v1, v17);
3467 
3468       subs(len, len, 32);
3469       br(Assembler::GE, L_fold);
3470 
3471       mov(crc, 0);
3472       mov(tmp, v0, T1D, 0);
3473       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3474       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3475       mov(tmp, v0, T1D, 1);
3476       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3477       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3478       mov(tmp, v1, T1D, 0);
3479       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3480       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3481       mov(tmp, v1, T1D, 1);
3482       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3483       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3484 
3485       add(len, len, 32);
3486   }
3487 
3488   BIND(L_by16);
3489     subs(len, len, 16);
3490     br(Assembler::GE, L_by16_loop);
3491     adds(len, len, 16-4);
3492     br(Assembler::GE, L_by4_loop);
3493     adds(len, len, 4);
3494     br(Assembler::GT, L_by1_loop);
3495     b(L_exit);
3496 
3497   BIND(L_by4_loop);
3498     ldrw(tmp, Address(post(buf, 4)));
3499     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3);
3500     subs(len, len, 4);
3501     br(Assembler::GE, L_by4_loop);
3502     adds(len, len, 4);
3503     br(Assembler::LE, L_exit);
3504   BIND(L_by1_loop);
3505     subs(len, len, 1);
3506     ldrb(tmp, Address(post(buf, 1)));
3507     update_byte_crc32(crc, tmp, table0);
3508     br(Assembler::GT, L_by1_loop);
3509     b(L_exit);
3510 
3511     align(CodeEntryAlignment);
3512   BIND(L_by16_loop);
3513     subs(len, len, 16);
3514     ldp(tmp, tmp3, Address(post(buf, 16)));
3515     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3516     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3517     update_word_crc32(crc, tmp3, tmp2, table0, table1, table2, table3, false);
3518     update_word_crc32(crc, tmp3, tmp2, table0, table1, table2, table3, true);
3519     br(Assembler::GE, L_by16_loop);
3520     adds(len, len, 16-4);
3521     br(Assembler::GE, L_by4_loop);
3522     adds(len, len, 4);
3523     br(Assembler::GT, L_by1_loop);
3524   BIND(L_exit);
3525     mvnw(crc, crc);
3526 }
3527 
3528 void MacroAssembler::kernel_crc32c_using_crc32c(Register crc, Register buf,
3529         Register len, Register tmp0, Register tmp1, Register tmp2,
3530         Register tmp3) {
3531     Label CRC_by64_loop, CRC_by4_loop, CRC_by1_loop, CRC_less64, CRC_by64_pre, CRC_by32_loop, CRC_less32, L_exit;
3532     assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2, tmp3);
3533 
3534     subs(len, len, 128);
3535     br(Assembler::GE, CRC_by64_pre);
3536   BIND(CRC_less64);
3537     adds(len, len, 128-32);
3538     br(Assembler::GE, CRC_by32_loop);
3539   BIND(CRC_less32);
3540     adds(len, len, 32-4);
3541     br(Assembler::GE, CRC_by4_loop);
3542     adds(len, len, 4);
3543     br(Assembler::GT, CRC_by1_loop);
3544     b(L_exit);
3545 
3546   BIND(CRC_by32_loop);
3547     ldp(tmp0, tmp1, Address(post(buf, 16)));
3548     subs(len, len, 32);
3549     crc32cx(crc, crc, tmp0);
3550     ldr(tmp2, Address(post(buf, 8)));
3551     crc32cx(crc, crc, tmp1);
3552     ldr(tmp3, Address(post(buf, 8)));
3553     crc32cx(crc, crc, tmp2);
3554     crc32cx(crc, crc, tmp3);
3555     br(Assembler::GE, CRC_by32_loop);
3556     cmn(len, 32);
3557     br(Assembler::NE, CRC_less32);
3558     b(L_exit);
3559 
3560   BIND(CRC_by4_loop);
3561     ldrw(tmp0, Address(post(buf, 4)));
3562     subs(len, len, 4);
3563     crc32cw(crc, crc, tmp0);
3564     br(Assembler::GE, CRC_by4_loop);
3565     adds(len, len, 4);
3566     br(Assembler::LE, L_exit);
3567   BIND(CRC_by1_loop);
3568     ldrb(tmp0, Address(post(buf, 1)));
3569     subs(len, len, 1);
3570     crc32cb(crc, crc, tmp0);
3571     br(Assembler::GT, CRC_by1_loop);
3572     b(L_exit);
3573 
3574   BIND(CRC_by64_pre);
3575     sub(buf, buf, 8);
3576     ldp(tmp0, tmp1, Address(buf, 8));
3577     crc32cx(crc, crc, tmp0);
3578     ldr(tmp2, Address(buf, 24));
3579     crc32cx(crc, crc, tmp1);
3580     ldr(tmp3, Address(buf, 32));
3581     crc32cx(crc, crc, tmp2);
3582     ldr(tmp0, Address(buf, 40));
3583     crc32cx(crc, crc, tmp3);
3584     ldr(tmp1, Address(buf, 48));
3585     crc32cx(crc, crc, tmp0);
3586     ldr(tmp2, Address(buf, 56));
3587     crc32cx(crc, crc, tmp1);
3588     ldr(tmp3, Address(pre(buf, 64)));
3589 
3590     b(CRC_by64_loop);
3591 
3592     align(CodeEntryAlignment);
3593   BIND(CRC_by64_loop);
3594     subs(len, len, 64);
3595     crc32cx(crc, crc, tmp2);
3596     ldr(tmp0, Address(buf, 8));
3597     crc32cx(crc, crc, tmp3);
3598     ldr(tmp1, Address(buf, 16));
3599     crc32cx(crc, crc, tmp0);
3600     ldr(tmp2, Address(buf, 24));
3601     crc32cx(crc, crc, tmp1);
3602     ldr(tmp3, Address(buf, 32));
3603     crc32cx(crc, crc, tmp2);
3604     ldr(tmp0, Address(buf, 40));
3605     crc32cx(crc, crc, tmp3);
3606     ldr(tmp1, Address(buf, 48));
3607     crc32cx(crc, crc, tmp0);
3608     ldr(tmp2, Address(buf, 56));
3609     crc32cx(crc, crc, tmp1);
3610     ldr(tmp3, Address(pre(buf, 64)));
3611     br(Assembler::GE, CRC_by64_loop);
3612 
3613     // post-loop
3614     crc32cx(crc, crc, tmp2);
3615     crc32cx(crc, crc, tmp3);
3616 
3617     sub(len, len, 64);
3618     add(buf, buf, 8);
3619     cmn(len, 128);
3620     br(Assembler::NE, CRC_less64);
3621   BIND(L_exit);
3622 }
3623 
3624 /**
3625  * @param crc   register containing existing CRC (32-bit)
3626  * @param buf   register pointing to input byte buffer (byte*)
3627  * @param len   register containing number of bytes
3628  * @param table register that will contain address of CRC table
3629  * @param tmp   scratch register
3630  */
3631 void MacroAssembler::kernel_crc32c(Register crc, Register buf, Register len,
3632         Register table0, Register table1, Register table2, Register table3,
3633         Register tmp, Register tmp2, Register tmp3) {
3634   kernel_crc32c_using_crc32c(crc, buf, len, table0, table1, table2, table3);
3635 }
3636 
3637 
3638 SkipIfEqual::SkipIfEqual(
3639     MacroAssembler* masm, const bool* flag_addr, bool value) {
3640   _masm = masm;
3641   unsigned long offset;
3642   _masm-&gt;adrp(rscratch1, ExternalAddress((address)flag_addr), offset);
3643   _masm-&gt;ldrb(rscratch1, Address(rscratch1, offset));
3644   _masm-&gt;cbzw(rscratch1, _label);
3645 }
3646 
3647 SkipIfEqual::~SkipIfEqual() {
3648   _masm-&gt;bind(_label);
3649 }
3650 
3651 void MacroAssembler::addptr(const Address &amp;dst, int32_t src) {
3652   Address adr;
3653   switch(dst.getMode()) {
3654   case Address::base_plus_offset:
3655     // This is the expected mode, although we allow all the other
3656     // forms below.
3657     adr = form_address(rscratch2, dst.base(), dst.offset(), LogBytesPerWord);
3658     break;
3659   default:
3660     lea(rscratch2, dst);
3661     adr = Address(rscratch2);
3662     break;
3663   }
3664   ldr(rscratch1, adr);
3665   add(rscratch1, rscratch1, src);
3666   str(rscratch1, adr);
3667 }
3668 
3669 void MacroAssembler::cmpptr(Register src1, Address src2) {
3670   unsigned long offset;
3671   adrp(rscratch1, src2, offset);
3672   ldr(rscratch1, Address(rscratch1, offset));
3673   cmp(src1, rscratch1);
3674 }
3675 
3676 void MacroAssembler::cmpoop(Register obj1, Register obj2) {
3677   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3678   bs-&gt;obj_equals(this, obj1, obj2);
3679 }
3680 
3681 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
3682   load_method_holder(rresult, rmethod);
3683   ldr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
3684 }
3685 
3686 void MacroAssembler::load_method_holder(Register holder, Register method) {
3687   ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
3688   ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
3689   ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
3690 }
3691 
3692 void MacroAssembler::load_klass(Register dst, Register src) {
3693   if (UseCompressedClassPointers) {
3694     ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3695     decode_klass_not_null(dst);
3696   } else {
3697     ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3698   }
3699 }
3700 
3701 // ((OopHandle)result).resolve();
3702 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3703   // OopHandle::resolve is an indirection.
3704   access_load_at(T_OBJECT, IN_NATIVE, result, Address(result, 0), tmp, noreg);
3705 }
3706 
3707 // ((WeakHandle)result).resolve();
3708 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
3709   assert_different_registers(rresult, rtmp);
3710   Label resolved;
3711 
3712   // A null weak handle resolves to null.
3713   cbz(rresult, resolved);
3714 
3715   // Only 64 bit platforms support GCs that require a tmp register
3716   // Only IN_HEAP loads require a thread_tmp register
3717   // WeakHandle::resolve is an indirection like jweak.
3718   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3719                  rresult, Address(rresult), rtmp, /*tmp_thread*/noreg);
3720   bind(resolved);
3721 }
3722 
3723 void MacroAssembler::load_mirror(Register dst, Register method, Register tmp) {
3724   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3725   ldr(dst, Address(rmethod, Method::const_offset()));
3726   ldr(dst, Address(dst, ConstMethod::constants_offset()));
3727   ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));
3728   ldr(dst, Address(dst, mirror_offset));
3729   resolve_oop_handle(dst, tmp);
3730 }
3731 
3732 void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
3733   if (UseCompressedClassPointers) {
3734     ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3735     if (CompressedKlassPointers::base() == NULL) {
3736       cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());
3737       return;
3738     } else if (((uint64_t)CompressedKlassPointers::base() &amp; 0xffffffff) == 0
3739                &amp;&amp; CompressedKlassPointers::shift() == 0) {
3740       // Only the bottom 32 bits matter
3741       cmpw(trial_klass, tmp);
3742       return;
3743     }
3744     decode_klass_not_null(tmp);
3745   } else {
3746     ldr(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3747   }
3748   cmp(trial_klass, tmp);
3749 }
3750 
3751 void MacroAssembler::load_prototype_header(Register dst, Register src) {
3752   load_klass(dst, src);
3753   ldr(dst, Address(dst, Klass::prototype_header_offset()));
3754 }
3755 
3756 void MacroAssembler::store_klass(Register dst, Register src) {
3757   // FIXME: Should this be a store release?  concurrent gcs assumes
3758   // klass length is valid if klass field is not null.
3759   if (UseCompressedClassPointers) {
3760     encode_klass_not_null(src);
3761     strw(src, Address(dst, oopDesc::klass_offset_in_bytes()));
3762   } else {
3763     str(src, Address(dst, oopDesc::klass_offset_in_bytes()));
3764   }
3765 }
3766 
3767 void MacroAssembler::store_klass_gap(Register dst, Register src) {
3768   if (UseCompressedClassPointers) {
3769     // Store to klass gap in destination
3770     strw(src, Address(dst, oopDesc::klass_gap_offset_in_bytes()));
3771   }
3772 }
3773 
3774 // Algorithm must match CompressedOops::encode.
3775 void MacroAssembler::encode_heap_oop(Register d, Register s) {
3776 #ifdef ASSERT
3777   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
3778 #endif
3779   verify_oop(s, &quot;broken oop in encode_heap_oop&quot;);
3780   if (CompressedOops::base() == NULL) {
3781     if (CompressedOops::shift() != 0) {
3782       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3783       lsr(d, s, LogMinObjAlignmentInBytes);
3784     } else {
3785       mov(d, s);
3786     }
3787   } else {
3788     subs(d, s, rheapbase);
3789     csel(d, d, zr, Assembler::HS);
3790     lsr(d, d, LogMinObjAlignmentInBytes);
3791 
3792     /*  Old algorithm: is this any worse?
3793     Label nonnull;
3794     cbnz(r, nonnull);
3795     sub(r, r, rheapbase);
3796     bind(nonnull);
3797     lsr(r, r, LogMinObjAlignmentInBytes);
3798     */
3799   }
3800 }
3801 
3802 void MacroAssembler::encode_heap_oop_not_null(Register r) {
3803 #ifdef ASSERT
3804   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
3805   if (CheckCompressedOops) {
3806     Label ok;
3807     cbnz(r, ok);
3808     stop(&quot;null oop passed to encode_heap_oop_not_null&quot;);
3809     bind(ok);
3810   }
3811 #endif
3812   verify_oop(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
3813   if (CompressedOops::base() != NULL) {
3814     sub(r, r, rheapbase);
3815   }
3816   if (CompressedOops::shift() != 0) {
3817     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3818     lsr(r, r, LogMinObjAlignmentInBytes);
3819   }
3820 }
3821 
3822 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
3823 #ifdef ASSERT
3824   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
3825   if (CheckCompressedOops) {
3826     Label ok;
3827     cbnz(src, ok);
3828     stop(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
3829     bind(ok);
3830   }
3831 #endif
3832   verify_oop(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
3833 
3834   Register data = src;
3835   if (CompressedOops::base() != NULL) {
3836     sub(dst, src, rheapbase);
3837     data = dst;
3838   }
3839   if (CompressedOops::shift() != 0) {
3840     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3841     lsr(dst, data, LogMinObjAlignmentInBytes);
3842     data = dst;
3843   }
3844   if (data == src)
3845     mov(dst, src);
3846 }
3847 
3848 void  MacroAssembler::decode_heap_oop(Register d, Register s) {
3849 #ifdef ASSERT
3850   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
3851 #endif
3852   if (CompressedOops::base() == NULL) {
3853     if (CompressedOops::shift() != 0 || d != s) {
3854       lsl(d, s, CompressedOops::shift());
3855     }
3856   } else {
3857     Label done;
3858     if (d != s)
3859       mov(d, s);
3860     cbz(s, done);
3861     add(d, rheapbase, s, Assembler::LSL, LogMinObjAlignmentInBytes);
3862     bind(done);
3863   }
3864   verify_oop(d, &quot;broken oop in decode_heap_oop&quot;);
3865 }
3866 
3867 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
3868   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
3869   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3870   // Cannot assert, unverified entry point counts instructions (see .ad file)
3871   // vtableStubs also counts instructions in pd_code_size_limit.
3872   // Also do not verify_oop as this is called by verify_oop.
3873   if (CompressedOops::shift() != 0) {
3874     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3875     if (CompressedOops::base() != NULL) {
3876       add(r, rheapbase, r, Assembler::LSL, LogMinObjAlignmentInBytes);
3877     } else {
3878       add(r, zr, r, Assembler::LSL, LogMinObjAlignmentInBytes);
3879     }
3880   } else {
3881     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
3882   }
3883 }
3884 
3885 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
3886   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
3887   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3888   // Cannot assert, unverified entry point counts instructions (see .ad file)
3889   // vtableStubs also counts instructions in pd_code_size_limit.
3890   // Also do not verify_oop as this is called by verify_oop.
3891   if (CompressedOops::shift() != 0) {
3892     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3893     if (CompressedOops::base() != NULL) {
3894       add(dst, rheapbase, src, Assembler::LSL, LogMinObjAlignmentInBytes);
3895     } else {
3896       add(dst, zr, src, Assembler::LSL, LogMinObjAlignmentInBytes);
3897     }
3898   } else {
3899     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
3900     if (dst != src) {
3901       mov(dst, src);
3902     }
3903   }
3904 }
3905 
3906 MacroAssembler::KlassDecodeMode MacroAssembler::_klass_decode_mode(KlassDecodeNone);
3907 
3908 MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode() {
3909   assert(UseCompressedClassPointers, &quot;not using compressed class pointers&quot;);
3910   assert(Metaspace::initialized(), &quot;metaspace not initialized yet&quot;);
3911 
3912   if (_klass_decode_mode != KlassDecodeNone) {
3913     return _klass_decode_mode;
3914   }
3915 
3916   assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift()
3917          || 0 == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
3918 
3919   if (CompressedKlassPointers::base() == NULL) {
3920     return (_klass_decode_mode = KlassDecodeZero);
3921   }
3922 
3923   if (operand_valid_for_logical_immediate(
3924         /*is32*/false, (uint64_t)CompressedKlassPointers::base())) {
3925     const uint64_t range_mask =
3926       (1UL &lt;&lt; log2_intptr(CompressedKlassPointers::range())) - 1;
3927     if (((uint64_t)CompressedKlassPointers::base() &amp; range_mask) == 0) {
3928       return (_klass_decode_mode = KlassDecodeXor);
3929     }
3930   }
3931 
3932   const uint64_t shifted_base =
3933     (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();
3934   guarantee((shifted_base &amp; 0xffff0000ffffffff) == 0,
3935             &quot;compressed class base bad alignment&quot;);
3936 
3937   return (_klass_decode_mode = KlassDecodeMovk);
3938 }
3939 
3940 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
3941   switch (klass_decode_mode()) {
3942   case KlassDecodeZero:
3943     if (CompressedKlassPointers::shift() != 0) {
3944       lsr(dst, src, LogKlassAlignmentInBytes);
3945     } else {
3946       if (dst != src) mov(dst, src);
3947     }
3948     break;
3949 
3950   case KlassDecodeXor:
3951     if (CompressedKlassPointers::shift() != 0) {
3952       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
3953       lsr(dst, dst, LogKlassAlignmentInBytes);
3954     } else {
3955       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
3956     }
3957     break;
3958 
3959   case KlassDecodeMovk:
3960     if (CompressedKlassPointers::shift() != 0) {
3961       ubfx(dst, src, LogKlassAlignmentInBytes, 32);
3962     } else {
3963       movw(dst, src);
3964     }
3965     break;
3966 
3967   case KlassDecodeNone:
3968     ShouldNotReachHere();
3969     break;
3970   }
3971 }
3972 
3973 void MacroAssembler::encode_klass_not_null(Register r) {
3974   encode_klass_not_null(r, r);
3975 }
3976 
3977 void  MacroAssembler::decode_klass_not_null(Register dst, Register src) {
3978   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
3979 
3980   switch (klass_decode_mode()) {
3981   case KlassDecodeZero:
3982     if (CompressedKlassPointers::shift() != 0) {
3983       lsl(dst, src, LogKlassAlignmentInBytes);
3984     } else {
3985       if (dst != src) mov(dst, src);
3986     }
3987     break;
3988 
3989   case KlassDecodeXor:
3990     if (CompressedKlassPointers::shift() != 0) {
3991       lsl(dst, src, LogKlassAlignmentInBytes);
3992       eor(dst, dst, (uint64_t)CompressedKlassPointers::base());
3993     } else {
3994       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
3995     }
3996     break;
3997 
3998   case KlassDecodeMovk: {
3999     const uint64_t shifted_base =
4000       (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();
4001 
4002     if (dst != src) movw(dst, src);
4003     movk(dst, shifted_base &gt;&gt; 32, 32);
4004 
4005     if (CompressedKlassPointers::shift() != 0) {
4006       lsl(dst, dst, LogKlassAlignmentInBytes);
4007     }
4008 
4009     break;
4010   }
4011 
4012   case KlassDecodeNone:
4013     ShouldNotReachHere();
4014     break;
4015   }
4016 }
4017 
4018 void  MacroAssembler::decode_klass_not_null(Register r) {
4019   decode_klass_not_null(r, r);
4020 }
4021 
4022 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4023 #ifdef ASSERT
4024   {
4025     ThreadInVMfromUnknown tiv;
4026     assert (UseCompressedOops, &quot;should only be used for compressed oops&quot;);
4027     assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4028     assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4029     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4030   }
4031 #endif
4032   int oop_index = oop_recorder()-&gt;find_index(obj);
4033   InstructionMark im(this);
4034   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4035   code_section()-&gt;relocate(inst_mark(), rspec);
4036   movz(dst, 0xDEAD, 16);
4037   movk(dst, 0xBEEF);
4038 }
4039 
4040 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4041   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4042   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4043   int index = oop_recorder()-&gt;find_index(k);
4044   assert(! Universe::heap()-&gt;is_in(k), &quot;should not be an oop&quot;);
4045 
4046   InstructionMark im(this);
4047   RelocationHolder rspec = metadata_Relocation::spec(index);
4048   code_section()-&gt;relocate(inst_mark(), rspec);
4049   narrowKlass nk = CompressedKlassPointers::encode(k);
4050   movz(dst, (nk &gt;&gt; 16), 16);
4051   movk(dst, nk &amp; 0xffff);
4052 }
4053 
4054 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
4055                                     Register dst, Address src,
4056                                     Register tmp1, Register thread_tmp) {
4057   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4058   decorators = AccessInternal::decorator_fixup(decorators);
4059   bool as_raw = (decorators &amp; AS_RAW) != 0;
4060   if (as_raw) {
4061     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4062   } else {
4063     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4064   }
4065 }
4066 
4067 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
4068                                      Address dst, Register src,
4069                                      Register tmp1, Register thread_tmp) {
4070   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4071   decorators = AccessInternal::decorator_fixup(decorators);
4072   bool as_raw = (decorators &amp; AS_RAW) != 0;
4073   if (as_raw) {
4074     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4075   } else {
4076     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4077   }
4078 }
4079 
4080 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4081   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4082   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4083     decorators |= ACCESS_READ | ACCESS_WRITE;
4084   }
4085   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4086   return bs-&gt;resolve(this, decorators, obj);
4087 }
4088 
4089 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4090                                    Register thread_tmp, DecoratorSet decorators) {
4091   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4092 }
4093 
4094 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4095                                             Register thread_tmp, DecoratorSet decorators) {
4096   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4097 }
4098 
4099 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4100                                     Register thread_tmp, DecoratorSet decorators) {
4101   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4102 }
4103 
4104 // Used for storing NULLs.
4105 void MacroAssembler::store_heap_oop_null(Address dst) {
4106   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
4107 }
4108 
4109 Address MacroAssembler::allocate_metadata_address(Metadata* obj) {
4110   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
4111   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
4112   RelocationHolder rspec = metadata_Relocation::spec(index);
4113   return Address((address)obj, rspec);
4114 }
4115 
4116 // Move an oop into a register.  immediate is true if we want
4117 // immediate instructions and nmethod entry barriers are not enabled.
4118 // i.e. we are not going to patch this instruction while the code is being
4119 // executed by another thread.
4120 void MacroAssembler::movoop(Register dst, jobject obj, bool immediate) {
4121   int oop_index;
4122   if (obj == NULL) {
4123     oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
4124   } else {
4125 #ifdef ASSERT
4126     {
4127       ThreadInVMfromUnknown tiv;
4128       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4129     }
4130 #endif
4131     oop_index = oop_recorder()-&gt;find_index(obj);
4132   }
4133   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4134 
4135   // nmethod entry barrier necessitate using the constant pool. They have to be
4136   // ordered with respected to oop accesses.
4137   // Using immediate literals would necessitate ISBs.
4138   if (BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL || !immediate) {
4139     address dummy = address(uintptr_t(pc()) &amp; -wordSize); // A nearby aligned address
4140     ldr_constant(dst, Address(dummy, rspec));
4141   } else
4142     mov(dst, Address((address)obj, rspec));
4143 
4144 }
4145 
4146 // Move a metadata address into a register.
4147 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
4148   int oop_index;
4149   if (obj == NULL) {
4150     oop_index = oop_recorder()-&gt;allocate_metadata_index(obj);
4151   } else {
4152     oop_index = oop_recorder()-&gt;find_index(obj);
4153   }
4154   RelocationHolder rspec = metadata_Relocation::spec(oop_index);
4155   mov(dst, Address((address)obj, rspec));
4156 }
4157 
4158 Address MacroAssembler::constant_oop_address(jobject obj) {
4159 #ifdef ASSERT
4160   {
4161     ThreadInVMfromUnknown tiv;
4162     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4163     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
4164   }
4165 #endif
4166   int oop_index = oop_recorder()-&gt;find_index(obj);
4167   return Address((address)obj, oop_Relocation::spec(oop_index));
4168 }
4169 
4170 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
4171 void MacroAssembler::tlab_allocate(Register obj,
4172                                    Register var_size_in_bytes,
4173                                    int con_size_in_bytes,
4174                                    Register t1,
4175                                    Register t2,
4176                                    Label&amp; slow_case) {
4177   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4178   bs-&gt;tlab_allocate(this, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
4179 }
4180 
4181 // Defines obj, preserves var_size_in_bytes
4182 void MacroAssembler::eden_allocate(Register obj,
4183                                    Register var_size_in_bytes,
4184                                    int con_size_in_bytes,
4185                                    Register t1,
4186                                    Label&amp; slow_case) {
4187   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4188   bs-&gt;eden_allocate(this, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
4189 }
4190 
4191 // Zero words; len is in bytes
4192 // Destroys all registers except addr
4193 // len must be a nonzero multiple of wordSize
4194 void MacroAssembler::zero_memory(Register addr, Register len, Register t1) {
4195   assert_different_registers(addr, len, t1, rscratch1, rscratch2);
4196 
4197 #ifdef ASSERT
4198   { Label L;
4199     tst(len, BytesPerWord - 1);
4200     br(Assembler::EQ, L);
4201     stop(&quot;len is not a multiple of BytesPerWord&quot;);
4202     bind(L);
4203   }
4204 #endif
4205 
4206 #ifndef PRODUCT
4207   block_comment(&quot;zero memory&quot;);
4208 #endif
4209 
4210   Label loop;
4211   Label entry;
4212 
4213 //  Algorithm:
4214 //
4215 //    scratch1 = cnt &amp; 7;
4216 //    cnt -= scratch1;
4217 //    p += scratch1;
4218 //    switch (scratch1) {
4219 //      do {
4220 //        cnt -= 8;
4221 //          p[-8] = 0;
4222 //        case 7:
4223 //          p[-7] = 0;
4224 //        case 6:
4225 //          p[-6] = 0;
4226 //          // ...
4227 //        case 1:
4228 //          p[-1] = 0;
4229 //        case 0:
4230 //          p += 8;
4231 //      } while (cnt);
4232 //    }
4233 
4234   const int unroll = 8; // Number of str(zr) instructions we&#39;ll unroll
4235 
4236   lsr(len, len, LogBytesPerWord);
4237   andr(rscratch1, len, unroll - 1);  // tmp1 = cnt % unroll
4238   sub(len, len, rscratch1);      // cnt -= unroll
4239   // t1 always points to the end of the region we&#39;re about to zero
4240   add(t1, addr, rscratch1, Assembler::LSL, LogBytesPerWord);
4241   adr(rscratch2, entry);
4242   sub(rscratch2, rscratch2, rscratch1, Assembler::LSL, 2);
4243   br(rscratch2);
4244   bind(loop);
4245   sub(len, len, unroll);
4246   for (int i = -unroll; i &lt; 0; i++)
4247     Assembler::str(zr, Address(t1, i * wordSize));
4248   bind(entry);
4249   add(t1, t1, unroll * wordSize);
4250   cbnz(len, loop);
4251 }
4252 
4253 void MacroAssembler::verify_tlab() {
4254 #ifdef ASSERT
4255   if (UseTLAB &amp;&amp; VerifyOops) {
4256     Label next, ok;
4257 
4258     stp(rscratch2, rscratch1, Address(pre(sp, -16)));
4259 
4260     ldr(rscratch2, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
4261     ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_start_offset())));
4262     cmp(rscratch2, rscratch1);
4263     br(Assembler::HS, next);
4264     STOP(&quot;assert(top &gt;= start)&quot;);
4265     should_not_reach_here();
4266 
4267     bind(next);
4268     ldr(rscratch2, Address(rthread, in_bytes(JavaThread::tlab_end_offset())));
4269     ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
4270     cmp(rscratch2, rscratch1);
4271     br(Assembler::HS, ok);
4272     STOP(&quot;assert(top &lt;= end)&quot;);
4273     should_not_reach_here();
4274 
4275     bind(ok);
4276     ldp(rscratch2, rscratch1, Address(post(sp, 16)));
4277   }
4278 #endif
4279 }
4280 
4281 // Writes to stack successive pages until offset reached to check for
4282 // stack overflow + shadow pages.  This clobbers tmp.
4283 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
4284   assert_different_registers(tmp, size, rscratch1);
4285   mov(tmp, sp);
4286   // Bang stack for total size given plus shadow page size.
4287   // Bang one page at a time because large size can bang beyond yellow and
4288   // red zones.
4289   Label loop;
4290   mov(rscratch1, os::vm_page_size());
4291   bind(loop);
4292   lea(tmp, Address(tmp, -os::vm_page_size()));
4293   subsw(size, size, rscratch1);
4294   str(size, Address(tmp));
4295   br(Assembler::GT, loop);
4296 
4297   // Bang down shadow pages too.
4298   // At this point, (tmp-0) is the last address touched, so don&#39;t
4299   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
4300   // was post-decremented.)  Skip this address by starting at i=1, and
4301   // touch a few more pages below.  N.B.  It is important to touch all
4302   // the way down to and including i=StackShadowPages.
4303   for (int i = 0; i &lt; (int)(JavaThread::stack_shadow_zone_size() / os::vm_page_size()) - 1; i++) {
4304     // this could be any sized move but this is can be a debugging crumb
4305     // so the bigger the better.
4306     lea(tmp, Address(tmp, -os::vm_page_size()));
4307     str(size, Address(tmp));
4308   }
4309 }
4310 
4311 // Move the address of the polling page into dest.
4312 void MacroAssembler::get_polling_page(Register dest, relocInfo::relocType rtype) {
4313   ldr(dest, Address(rthread, Thread::polling_page_offset()));
4314 }
4315 
4316 // Move the address of the polling page into r, then read the polling
4317 // page.
4318 address MacroAssembler::fetch_and_read_polling_page(Register r, relocInfo::relocType rtype) {
4319   get_polling_page(r, rtype);
4320   return read_polling_page(r, rtype);
4321 }
4322 
4323 // Read the polling page.  The address of the polling page must
4324 // already be in r.
4325 address MacroAssembler::read_polling_page(Register r, relocInfo::relocType rtype) {
4326   InstructionMark im(this);
4327   code_section()-&gt;relocate(inst_mark(), rtype);
4328   ldrw(zr, Address(r, 0));
4329   return inst_mark();
4330 }
4331 
4332 void MacroAssembler::adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset) {
4333   relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
4334   unsigned long low_page = (unsigned long)CodeCache::low_bound() &gt;&gt; 12;
4335   unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) &gt;&gt; 12;
4336   unsigned long dest_page = (unsigned long)dest.target() &gt;&gt; 12;
4337   long offset_low = dest_page - low_page;
4338   long offset_high = dest_page - high_page;
4339 
4340   assert(is_valid_AArch64_address(dest.target()), &quot;bad address&quot;);
4341   assert(dest.getMode() == Address::literal, &quot;ADRP must be applied to a literal address&quot;);
4342 
4343   InstructionMark im(this);
4344   code_section()-&gt;relocate(inst_mark(), dest.rspec());
4345   // 8143067: Ensure that the adrp can reach the dest from anywhere within
4346   // the code cache so that if it is relocated we know it will still reach
4347   if (offset_high &gt;= -(1&lt;&lt;20) &amp;&amp; offset_low &lt; (1&lt;&lt;20)) {
4348     _adrp(reg1, dest.target());
4349   } else {
4350     unsigned long target = (unsigned long)dest.target();
4351     unsigned long adrp_target
4352       = (target &amp; 0xffffffffUL) | ((unsigned long)pc() &amp; 0xffff00000000UL);
4353 
4354     _adrp(reg1, (address)adrp_target);
4355     movk(reg1, target &gt;&gt; 32, 32);
4356   }
4357   byte_offset = (unsigned long)dest.target() &amp; 0xfff;
4358 }
4359 
4360 void MacroAssembler::load_byte_map_base(Register reg) {
4361   CardTable::CardValue* byte_map_base =
4362     ((CardTableBarrierSet*)(BarrierSet::barrier_set()))-&gt;card_table()-&gt;byte_map_base();
4363 
4364   if (is_valid_AArch64_address((address)byte_map_base)) {
4365     // Strictly speaking the byte_map_base isn&#39;t an address at all,
4366     // and it might even be negative.
4367     unsigned long offset;
4368     adrp(reg, ExternalAddress((address)byte_map_base), offset);
4369     // We expect offset to be zero with most collectors.
4370     if (offset != 0) {
4371       add(reg, reg, offset);
4372     }
4373   } else {
4374     mov(reg, (uint64_t)byte_map_base);
4375   }
4376 }
4377 
4378 void MacroAssembler::build_frame(int framesize) {
4379   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4380   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4381     sub(sp, sp, framesize);
4382     stp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4383     if (PreserveFramePointer) add(rfp, sp, framesize - 2 * wordSize);
4384   } else {
4385     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
4386     if (PreserveFramePointer) mov(rfp, sp);
4387     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4388       sub(sp, sp, framesize - 2 * wordSize);
4389     else {
4390       mov(rscratch1, framesize - 2 * wordSize);
4391       sub(sp, sp, rscratch1);
4392     }
4393   }
4394 }
4395 
4396 void MacroAssembler::remove_frame(int framesize) {
4397   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4398   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4399     ldp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4400     add(sp, sp, framesize);
4401   } else {
4402     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4403       add(sp, sp, framesize - 2 * wordSize);
4404     else {
4405       mov(rscratch1, framesize - 2 * wordSize);
4406       add(sp, sp, rscratch1);
4407     }
4408     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
4409   }
4410 }
4411 
4412 
4413 // This method checks if provided byte array contains byte with highest bit set.
4414 void MacroAssembler::has_negatives(Register ary1, Register len, Register result) {
4415     // Simple and most common case of aligned small array which is not at the
4416     // end of memory page is placed here. All other cases are in stub.
4417     Label LOOP, END, STUB, STUB_LONG, SET_RESULT, DONE;
4418     const uint64_t UPPER_BIT_MASK=0x8080808080808080;
4419     assert_different_registers(ary1, len, result);
4420 
4421     cmpw(len, 0);
4422     br(LE, SET_RESULT);
4423     cmpw(len, 4 * wordSize);
4424     br(GE, STUB_LONG); // size &gt; 32 then go to stub
4425 
4426     int shift = 64 - exact_log2(os::vm_page_size());
4427     lsl(rscratch1, ary1, shift);
4428     mov(rscratch2, (size_t)(4 * wordSize) &lt;&lt; shift);
4429     adds(rscratch2, rscratch1, rscratch2);  // At end of page?
4430     br(CS, STUB); // at the end of page then go to stub
4431     subs(len, len, wordSize);
4432     br(LT, END);
4433 
4434   BIND(LOOP);
4435     ldr(rscratch1, Address(post(ary1, wordSize)));
4436     tst(rscratch1, UPPER_BIT_MASK);
4437     br(NE, SET_RESULT);
4438     subs(len, len, wordSize);
4439     br(GE, LOOP);
4440     cmpw(len, -wordSize);
4441     br(EQ, SET_RESULT);
4442 
4443   BIND(END);
4444     ldr(result, Address(ary1));
4445     sub(len, zr, len, LSL, 3); // LSL 3 is to get bits from bytes
4446     lslv(result, result, len);
4447     tst(result, UPPER_BIT_MASK);
4448     b(SET_RESULT);
4449 
4450   BIND(STUB);
4451     RuntimeAddress has_neg =  RuntimeAddress(StubRoutines::aarch64::has_negatives());
4452     assert(has_neg.target() != NULL, &quot;has_negatives stub has not been generated&quot;);
4453     trampoline_call(has_neg);
4454     b(DONE);
4455 
4456   BIND(STUB_LONG);
4457     RuntimeAddress has_neg_long =  RuntimeAddress(
4458             StubRoutines::aarch64::has_negatives_long());
4459     assert(has_neg_long.target() != NULL, &quot;has_negatives stub has not been generated&quot;);
4460     trampoline_call(has_neg_long);
4461     b(DONE);
4462 
4463   BIND(SET_RESULT);
4464     cset(result, NE); // set true or false
4465 
4466   BIND(DONE);
4467 }
4468 
4469 void MacroAssembler::arrays_equals(Register a1, Register a2, Register tmp3,
4470                                    Register tmp4, Register tmp5, Register result,
4471                                    Register cnt1, int elem_size) {
4472   Label DONE, SAME;
4473   Register tmp1 = rscratch1;
4474   Register tmp2 = rscratch2;
4475   Register cnt2 = tmp2;  // cnt2 only used in array length compare
4476   int elem_per_word = wordSize/elem_size;
4477   int log_elem_size = exact_log2(elem_size);
4478   int length_offset = arrayOopDesc::length_offset_in_bytes();
4479   int base_offset
4480     = arrayOopDesc::base_offset_in_bytes(elem_size == 2 ? T_CHAR : T_BYTE);
4481   int stubBytesThreshold = 3 * 64 + (UseSIMDForArrayEquals ? 0 : 16);
4482 
4483   assert(elem_size == 1 || elem_size == 2, &quot;must be char or byte&quot;);
4484   assert_different_registers(a1, a2, result, cnt1, rscratch1, rscratch2);
4485 
4486 #ifndef PRODUCT
4487   {
4488     const char kind = (elem_size == 2) ? &#39;U&#39; : &#39;L&#39;;
4489     char comment[64];
4490     snprintf(comment, sizeof comment, &quot;array_equals%c{&quot;, kind);
4491     BLOCK_COMMENT(comment);
4492   }
4493 #endif
4494 
4495   // if (a1 == a2)
4496   //     return true;
4497   cmpoop(a1, a2); // May have read barriers for a1 and a2.
4498   br(EQ, SAME);
4499 
4500   if (UseSimpleArrayEquals) {
4501     Label NEXT_WORD, SHORT, TAIL03, TAIL01, A_MIGHT_BE_NULL, A_IS_NOT_NULL;
4502     // if (a1 == null || a2 == null)
4503     //     return false;
4504     // a1 &amp; a2 == 0 means (some-pointer is null) or
4505     // (very-rare-or-even-probably-impossible-pointer-values)
4506     // so, we can save one branch in most cases
4507     tst(a1, a2);
4508     mov(result, false);
4509     br(EQ, A_MIGHT_BE_NULL);
4510     // if (a1.length != a2.length)
4511     //      return false;
4512     bind(A_IS_NOT_NULL);
4513     ldrw(cnt1, Address(a1, length_offset));
4514     ldrw(cnt2, Address(a2, length_offset));
4515     eorw(tmp5, cnt1, cnt2);
4516     cbnzw(tmp5, DONE);
4517     lea(a1, Address(a1, base_offset));
4518     lea(a2, Address(a2, base_offset));
4519     // Check for short strings, i.e. smaller than wordSize.
4520     subs(cnt1, cnt1, elem_per_word);
4521     br(Assembler::LT, SHORT);
4522     // Main 8 byte comparison loop.
4523     bind(NEXT_WORD); {
4524       ldr(tmp1, Address(post(a1, wordSize)));
4525       ldr(tmp2, Address(post(a2, wordSize)));
4526       subs(cnt1, cnt1, elem_per_word);
4527       eor(tmp5, tmp1, tmp2);
4528       cbnz(tmp5, DONE);
4529     } br(GT, NEXT_WORD);
4530     // Last longword.  In the case where length == 4 we compare the
4531     // same longword twice, but that&#39;s still faster than another
4532     // conditional branch.
4533     // cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when
4534     // length == 4.
4535     if (log_elem_size &gt; 0)
4536       lsl(cnt1, cnt1, log_elem_size);
4537     ldr(tmp3, Address(a1, cnt1));
4538     ldr(tmp4, Address(a2, cnt1));
4539     eor(tmp5, tmp3, tmp4);
4540     cbnz(tmp5, DONE);
4541     b(SAME);
4542     bind(A_MIGHT_BE_NULL);
4543     // in case both a1 and a2 are not-null, proceed with loads
4544     cbz(a1, DONE);
4545     cbz(a2, DONE);
4546     b(A_IS_NOT_NULL);
4547     bind(SHORT);
4548 
4549     tbz(cnt1, 2 - log_elem_size, TAIL03); // 0-7 bytes left.
4550     {
4551       ldrw(tmp1, Address(post(a1, 4)));
4552       ldrw(tmp2, Address(post(a2, 4)));
4553       eorw(tmp5, tmp1, tmp2);
4554       cbnzw(tmp5, DONE);
4555     }
4556     bind(TAIL03);
4557     tbz(cnt1, 1 - log_elem_size, TAIL01); // 0-3 bytes left.
4558     {
4559       ldrh(tmp3, Address(post(a1, 2)));
4560       ldrh(tmp4, Address(post(a2, 2)));
4561       eorw(tmp5, tmp3, tmp4);
4562       cbnzw(tmp5, DONE);
4563     }
4564     bind(TAIL01);
4565     if (elem_size == 1) { // Only needed when comparing byte arrays.
4566       tbz(cnt1, 0, SAME); // 0-1 bytes left.
4567       {
4568         ldrb(tmp1, a1);
4569         ldrb(tmp2, a2);
4570         eorw(tmp5, tmp1, tmp2);
4571         cbnzw(tmp5, DONE);
4572       }
4573     }
4574   } else {
4575     Label NEXT_DWORD, SHORT, TAIL, TAIL2, STUB, EARLY_OUT,
4576         CSET_EQ, LAST_CHECK;
4577     mov(result, false);
4578     cbz(a1, DONE);
4579     ldrw(cnt1, Address(a1, length_offset));
4580     cbz(a2, DONE);
4581     ldrw(cnt2, Address(a2, length_offset));
4582     // on most CPUs a2 is still &quot;locked&quot;(surprisingly) in ldrw and it&#39;s
4583     // faster to perform another branch before comparing a1 and a2
4584     cmp(cnt1, (u1)elem_per_word);
4585     br(LE, SHORT); // short or same
4586     ldr(tmp3, Address(pre(a1, base_offset)));
4587     subs(zr, cnt1, stubBytesThreshold);
4588     br(GE, STUB);
4589     ldr(tmp4, Address(pre(a2, base_offset)));
4590     sub(tmp5, zr, cnt1, LSL, 3 + log_elem_size);
4591     cmp(cnt2, cnt1);
4592     br(NE, DONE);
4593 
4594     // Main 16 byte comparison loop with 2 exits
4595     bind(NEXT_DWORD); {
4596       ldr(tmp1, Address(pre(a1, wordSize)));
4597       ldr(tmp2, Address(pre(a2, wordSize)));
4598       subs(cnt1, cnt1, 2 * elem_per_word);
4599       br(LE, TAIL);
4600       eor(tmp4, tmp3, tmp4);
4601       cbnz(tmp4, DONE);
4602       ldr(tmp3, Address(pre(a1, wordSize)));
4603       ldr(tmp4, Address(pre(a2, wordSize)));
4604       cmp(cnt1, (u1)elem_per_word);
4605       br(LE, TAIL2);
4606       cmp(tmp1, tmp2);
4607     } br(EQ, NEXT_DWORD);
4608     b(DONE);
4609 
4610     bind(TAIL);
4611     eor(tmp4, tmp3, tmp4);
4612     eor(tmp2, tmp1, tmp2);
4613     lslv(tmp2, tmp2, tmp5);
4614     orr(tmp5, tmp4, tmp2);
4615     cmp(tmp5, zr);
4616     b(CSET_EQ);
4617 
4618     bind(TAIL2);
4619     eor(tmp2, tmp1, tmp2);
4620     cbnz(tmp2, DONE);
4621     b(LAST_CHECK);
4622 
4623     bind(STUB);
4624     ldr(tmp4, Address(pre(a2, base_offset)));
4625     cmp(cnt2, cnt1);
4626     br(NE, DONE);
4627     if (elem_size == 2) { // convert to byte counter
4628       lsl(cnt1, cnt1, 1);
4629     }
4630     eor(tmp5, tmp3, tmp4);
4631     cbnz(tmp5, DONE);
4632     RuntimeAddress stub = RuntimeAddress(StubRoutines::aarch64::large_array_equals());
4633     assert(stub.target() != NULL, &quot;array_equals_long stub has not been generated&quot;);
4634     trampoline_call(stub);
4635     b(DONE);
4636 
4637     bind(EARLY_OUT);
4638     // (a1 != null &amp;&amp; a2 == null) || (a1 != null &amp;&amp; a2 != null &amp;&amp; a1 == a2)
4639     // so, if a2 == null =&gt; return false(0), else return true, so we can return a2
4640     mov(result, a2);
4641     b(DONE);
4642     bind(SHORT);
4643     cmp(cnt2, cnt1);
4644     br(NE, DONE);
4645     cbz(cnt1, SAME);
4646     sub(tmp5, zr, cnt1, LSL, 3 + log_elem_size);
4647     ldr(tmp3, Address(a1, base_offset));
4648     ldr(tmp4, Address(a2, base_offset));
4649     bind(LAST_CHECK);
4650     eor(tmp4, tmp3, tmp4);
4651     lslv(tmp5, tmp4, tmp5);
4652     cmp(tmp5, zr);
4653     bind(CSET_EQ);
4654     cset(result, EQ);
4655     b(DONE);
4656   }
4657 
4658   bind(SAME);
4659   mov(result, true);
4660   // That&#39;s it.
4661   bind(DONE);
4662 
4663   BLOCK_COMMENT(&quot;} array_equals&quot;);
4664 }
4665 
4666 // Compare Strings
4667 
4668 // For Strings we&#39;re passed the address of the first characters in a1
4669 // and a2 and the length in cnt1.
4670 // elem_size is the element size in bytes: either 1 or 2.
4671 // There are two implementations.  For arrays &gt;= 8 bytes, all
4672 // comparisons (including the final one, which may overlap) are
4673 // performed 8 bytes at a time.  For strings &lt; 8 bytes, we compare a
4674 // halfword, then a short, and then a byte.
4675 
4676 void MacroAssembler::string_equals(Register a1, Register a2,
4677                                    Register result, Register cnt1, int elem_size)
4678 {
4679   Label SAME, DONE, SHORT, NEXT_WORD;
4680   Register tmp1 = rscratch1;
4681   Register tmp2 = rscratch2;
4682   Register cnt2 = tmp2;  // cnt2 only used in array length compare
4683 
4684   assert(elem_size == 1 || elem_size == 2, &quot;must be 2 or 1 byte&quot;);
4685   assert_different_registers(a1, a2, result, cnt1, rscratch1, rscratch2);
4686 
4687 #ifndef PRODUCT
4688   {
4689     const char kind = (elem_size == 2) ? &#39;U&#39; : &#39;L&#39;;
4690     char comment[64];
4691     snprintf(comment, sizeof comment, &quot;{string_equals%c&quot;, kind);
4692     BLOCK_COMMENT(comment);
4693   }
4694 #endif
4695 
4696   mov(result, false);
4697 
4698   // Check for short strings, i.e. smaller than wordSize.
4699   subs(cnt1, cnt1, wordSize);
4700   br(Assembler::LT, SHORT);
4701   // Main 8 byte comparison loop.
4702   bind(NEXT_WORD); {
4703     ldr(tmp1, Address(post(a1, wordSize)));
4704     ldr(tmp2, Address(post(a2, wordSize)));
4705     subs(cnt1, cnt1, wordSize);
4706     eor(tmp1, tmp1, tmp2);
4707     cbnz(tmp1, DONE);
4708   } br(GT, NEXT_WORD);
4709   // Last longword.  In the case where length == 4 we compare the
4710   // same longword twice, but that&#39;s still faster than another
4711   // conditional branch.
4712   // cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when
4713   // length == 4.
4714   ldr(tmp1, Address(a1, cnt1));
4715   ldr(tmp2, Address(a2, cnt1));
4716   eor(tmp2, tmp1, tmp2);
4717   cbnz(tmp2, DONE);
4718   b(SAME);
4719 
4720   bind(SHORT);
4721   Label TAIL03, TAIL01;
4722 
4723   tbz(cnt1, 2, TAIL03); // 0-7 bytes left.
4724   {
4725     ldrw(tmp1, Address(post(a1, 4)));
4726     ldrw(tmp2, Address(post(a2, 4)));
4727     eorw(tmp1, tmp1, tmp2);
4728     cbnzw(tmp1, DONE);
4729   }
4730   bind(TAIL03);
4731   tbz(cnt1, 1, TAIL01); // 0-3 bytes left.
4732   {
4733     ldrh(tmp1, Address(post(a1, 2)));
4734     ldrh(tmp2, Address(post(a2, 2)));
4735     eorw(tmp1, tmp1, tmp2);
4736     cbnzw(tmp1, DONE);
4737   }
4738   bind(TAIL01);
4739   if (elem_size == 1) { // Only needed when comparing 1-byte elements
4740     tbz(cnt1, 0, SAME); // 0-1 bytes left.
4741     {
4742       ldrb(tmp1, a1);
4743       ldrb(tmp2, a2);
4744       eorw(tmp1, tmp1, tmp2);
4745       cbnzw(tmp1, DONE);
4746     }
4747   }
4748   // Arrays are equal.
4749   bind(SAME);
4750   mov(result, true);
4751 
4752   // That&#39;s it.
4753   bind(DONE);
4754   BLOCK_COMMENT(&quot;} string_equals&quot;);
4755 }
4756 
4757 
4758 // The size of the blocks erased by the zero_blocks stub.  We must
4759 // handle anything smaller than this ourselves in zero_words().
4760 const int MacroAssembler::zero_words_block_size = 8;
4761 
4762 // zero_words() is used by C2 ClearArray patterns.  It is as small as
4763 // possible, handling small word counts locally and delegating
4764 // anything larger to the zero_blocks stub.  It is expanded many times
4765 // in compiled code, so it is important to keep it short.
4766 
4767 // ptr:   Address of a buffer to be zeroed.
4768 // cnt:   Count in HeapWords.
4769 //
4770 // ptr, cnt, rscratch1, and rscratch2 are clobbered.
4771 void MacroAssembler::zero_words(Register ptr, Register cnt)
4772 {
4773   assert(is_power_of_2(zero_words_block_size), &quot;adjust this&quot;);
4774   assert(ptr == r10 &amp;&amp; cnt == r11, &quot;mismatch in register usage&quot;);
4775 
4776   BLOCK_COMMENT(&quot;zero_words {&quot;);
4777   cmp(cnt, (u1)zero_words_block_size);
4778   Label around;
4779   br(LO, around);
4780   {
4781     RuntimeAddress zero_blocks =  RuntimeAddress(StubRoutines::aarch64::zero_blocks());
4782     assert(zero_blocks.target() != NULL, &quot;zero_blocks stub has not been generated&quot;);
4783     if (StubRoutines::aarch64::complete()) {
4784       trampoline_call(zero_blocks);
4785     } else {
4786       bl(zero_blocks);
4787     }
4788   }
4789   bind(around);
4790   for (int i = zero_words_block_size &gt;&gt; 1; i &gt; 1; i &gt;&gt;= 1) {
4791     Label l;
4792     tbz(cnt, exact_log2(i), l);
4793     for (int j = 0; j &lt; i; j += 2) {
4794       stp(zr, zr, post(ptr, 16));
4795     }
4796     bind(l);
4797   }
4798   {
4799     Label l;
4800     tbz(cnt, 0, l);
4801     str(zr, Address(ptr));
4802     bind(l);
4803   }
4804   BLOCK_COMMENT(&quot;} zero_words&quot;);
4805 }
4806 
4807 // base:         Address of a buffer to be zeroed, 8 bytes aligned.
4808 // cnt:          Immediate count in HeapWords.
4809 #define SmallArraySize (18 * BytesPerLong)
4810 void MacroAssembler::zero_words(Register base, u_int64_t cnt)
4811 {
4812   BLOCK_COMMENT(&quot;zero_words {&quot;);
4813   int i = cnt &amp; 1;  // store any odd word to start
4814   if (i) str(zr, Address(base));
4815 
4816   if (cnt &lt;= SmallArraySize / BytesPerLong) {
4817     for (; i &lt; (int)cnt; i += 2)
4818       stp(zr, zr, Address(base, i * wordSize));
4819   } else {
4820     const int unroll = 4; // Number of stp(zr, zr) instructions we&#39;ll unroll
4821     int remainder = cnt % (2 * unroll);
4822     for (; i &lt; remainder; i += 2)
4823       stp(zr, zr, Address(base, i * wordSize));
4824 
4825     Label loop;
4826     Register cnt_reg = rscratch1;
4827     Register loop_base = rscratch2;
4828     cnt = cnt - remainder;
4829     mov(cnt_reg, cnt);
4830     // adjust base and prebias by -2 * wordSize so we can pre-increment
4831     add(loop_base, base, (remainder - 2) * wordSize);
4832     bind(loop);
4833     sub(cnt_reg, cnt_reg, 2 * unroll);
4834     for (i = 1; i &lt; unroll; i++)
4835       stp(zr, zr, Address(loop_base, 2 * i * wordSize));
4836     stp(zr, zr, Address(pre(loop_base, 2 * unroll * wordSize)));
4837     cbnz(cnt_reg, loop);
4838   }
4839   BLOCK_COMMENT(&quot;} zero_words&quot;);
4840 }
4841 
4842 // Zero blocks of memory by using DC ZVA.
4843 //
4844 // Aligns the base address first sufficently for DC ZVA, then uses
4845 // DC ZVA repeatedly for every full block.  cnt is the size to be
4846 // zeroed in HeapWords.  Returns the count of words left to be zeroed
4847 // in cnt.
4848 //
4849 // NOTE: This is intended to be used in the zero_blocks() stub.  If
4850 // you want to use it elsewhere, note that cnt must be &gt;= 2*zva_length.
4851 void MacroAssembler::zero_dcache_blocks(Register base, Register cnt) {
4852   Register tmp = rscratch1;
4853   Register tmp2 = rscratch2;
4854   int zva_length = VM_Version::zva_length();
4855   Label initial_table_end, loop_zva;
4856   Label fini;
4857 
4858   // Base must be 16 byte aligned. If not just return and let caller handle it
4859   tst(base, 0x0f);
4860   br(Assembler::NE, fini);
4861   // Align base with ZVA length.
4862   neg(tmp, base);
4863   andr(tmp, tmp, zva_length - 1);
4864 
4865   // tmp: the number of bytes to be filled to align the base with ZVA length.
4866   add(base, base, tmp);
4867   sub(cnt, cnt, tmp, Assembler::ASR, 3);
4868   adr(tmp2, initial_table_end);
4869   sub(tmp2, tmp2, tmp, Assembler::LSR, 2);
4870   br(tmp2);
4871 
4872   for (int i = -zva_length + 16; i &lt; 0; i += 16)
4873     stp(zr, zr, Address(base, i));
4874   bind(initial_table_end);
4875 
4876   sub(cnt, cnt, zva_length &gt;&gt; 3);
4877   bind(loop_zva);
4878   dc(Assembler::ZVA, base);
4879   subs(cnt, cnt, zva_length &gt;&gt; 3);
4880   add(base, base, zva_length);
4881   br(Assembler::GE, loop_zva);
4882   add(cnt, cnt, zva_length &gt;&gt; 3); // count not zeroed by DC ZVA
4883   bind(fini);
4884 }
4885 
4886 // base:   Address of a buffer to be filled, 8 bytes aligned.
4887 // cnt:    Count in 8-byte unit.
4888 // value:  Value to be filled with.
4889 // base will point to the end of the buffer after filling.
4890 void MacroAssembler::fill_words(Register base, Register cnt, Register value)
4891 {
4892 //  Algorithm:
4893 //
4894 //    scratch1 = cnt &amp; 7;
4895 //    cnt -= scratch1;
4896 //    p += scratch1;
4897 //    switch (scratch1) {
4898 //      do {
4899 //        cnt -= 8;
4900 //          p[-8] = v;
4901 //        case 7:
4902 //          p[-7] = v;
4903 //        case 6:
4904 //          p[-6] = v;
4905 //          // ...
4906 //        case 1:
4907 //          p[-1] = v;
4908 //        case 0:
4909 //          p += 8;
4910 //      } while (cnt);
4911 //    }
4912 
4913   assert_different_registers(base, cnt, value, rscratch1, rscratch2);
4914 
4915   Label fini, skip, entry, loop;
4916   const int unroll = 8; // Number of stp instructions we&#39;ll unroll
4917 
4918   cbz(cnt, fini);
4919   tbz(base, 3, skip);
4920   str(value, Address(post(base, 8)));
4921   sub(cnt, cnt, 1);
4922   bind(skip);
4923 
4924   andr(rscratch1, cnt, (unroll-1) * 2);
4925   sub(cnt, cnt, rscratch1);
4926   add(base, base, rscratch1, Assembler::LSL, 3);
4927   adr(rscratch2, entry);
4928   sub(rscratch2, rscratch2, rscratch1, Assembler::LSL, 1);
4929   br(rscratch2);
4930 
4931   bind(loop);
4932   add(base, base, unroll * 16);
4933   for (int i = -unroll; i &lt; 0; i++)
4934     stp(value, value, Address(base, i * 16));
4935   bind(entry);
4936   subs(cnt, cnt, unroll * 2);
4937   br(Assembler::GE, loop);
4938 
4939   tbz(cnt, 0, fini);
4940   str(value, Address(post(base, 8)));
4941   bind(fini);
4942 }
4943 
4944 // Intrinsic for sun/nio/cs/ISO_8859_1$Encoder.implEncodeISOArray and
4945 // java/lang/StringUTF16.compress.
4946 void MacroAssembler::encode_iso_array(Register src, Register dst,
4947                       Register len, Register result,
4948                       FloatRegister Vtmp1, FloatRegister Vtmp2,
4949                       FloatRegister Vtmp3, FloatRegister Vtmp4)
4950 {
4951     Label DONE, SET_RESULT, NEXT_32, NEXT_32_PRFM, LOOP_8, NEXT_8, LOOP_1, NEXT_1,
4952         NEXT_32_START, NEXT_32_PRFM_START;
4953     Register tmp1 = rscratch1, tmp2 = rscratch2;
4954 
4955       mov(result, len); // Save initial len
4956 
4957       cmp(len, (u1)8); // handle shortest strings first
4958       br(LT, LOOP_1);
4959       cmp(len, (u1)32);
4960       br(LT, NEXT_8);
4961       // The following code uses the SIMD &#39;uzp1&#39; and &#39;uzp2&#39; instructions
4962       // to convert chars to bytes
4963       if (SoftwarePrefetchHintDistance &gt;= 0) {
4964         ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
4965         subs(tmp2, len, SoftwarePrefetchHintDistance/2 + 16);
4966         br(LE, NEXT_32_START);
4967         b(NEXT_32_PRFM_START);
4968         BIND(NEXT_32_PRFM);
4969           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
4970         BIND(NEXT_32_PRFM_START);
4971           prfm(Address(src, SoftwarePrefetchHintDistance));
4972           orr(v4, T16B, Vtmp1, Vtmp2);
4973           orr(v5, T16B, Vtmp3, Vtmp4);
4974           uzp1(Vtmp1, T16B, Vtmp1, Vtmp2);
4975           uzp1(Vtmp3, T16B, Vtmp3, Vtmp4);
4976           uzp2(v5, T16B, v4, v5); // high bytes
4977           umov(tmp2, v5, D, 1);
4978           fmovd(tmp1, v5);
4979           orr(tmp1, tmp1, tmp2);
4980           cbnz(tmp1, LOOP_8);
4981           stpq(Vtmp1, Vtmp3, dst);
4982           sub(len, len, 32);
4983           add(dst, dst, 32);
4984           add(src, src, 64);
4985           subs(tmp2, len, SoftwarePrefetchHintDistance/2 + 16);
4986           br(GE, NEXT_32_PRFM);
4987           cmp(len, (u1)32);
4988           br(LT, LOOP_8);
4989         BIND(NEXT_32);
4990           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
4991         BIND(NEXT_32_START);
4992       } else {
4993         BIND(NEXT_32);
4994           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
4995       }
4996       prfm(Address(src, SoftwarePrefetchHintDistance));
4997       uzp1(v4, T16B, Vtmp1, Vtmp2);
4998       uzp1(v5, T16B, Vtmp3, Vtmp4);
4999       orr(Vtmp1, T16B, Vtmp1, Vtmp2);
5000       orr(Vtmp3, T16B, Vtmp3, Vtmp4);
5001       uzp2(Vtmp1, T16B, Vtmp1, Vtmp3); // high bytes
5002       umov(tmp2, Vtmp1, D, 1);
5003       fmovd(tmp1, Vtmp1);
5004       orr(tmp1, tmp1, tmp2);
5005       cbnz(tmp1, LOOP_8);
5006       stpq(v4, v5, dst);
5007       sub(len, len, 32);
5008       add(dst, dst, 32);
5009       add(src, src, 64);
5010       cmp(len, (u1)32);
5011       br(GE, NEXT_32);
5012       cbz(len, DONE);
5013 
5014     BIND(LOOP_8);
5015       cmp(len, (u1)8);
5016       br(LT, LOOP_1);
5017     BIND(NEXT_8);
5018       ld1(Vtmp1, T8H, src);
5019       uzp1(Vtmp2, T16B, Vtmp1, Vtmp1); // low bytes
5020       uzp2(Vtmp3, T16B, Vtmp1, Vtmp1); // high bytes
5021       fmovd(tmp1, Vtmp3);
5022       cbnz(tmp1, NEXT_1);
5023       strd(Vtmp2, dst);
5024 
5025       sub(len, len, 8);
5026       add(dst, dst, 8);
5027       add(src, src, 16);
5028       cmp(len, (u1)8);
5029       br(GE, NEXT_8);
5030 
5031     BIND(LOOP_1);
5032 
5033     cbz(len, DONE);
5034     BIND(NEXT_1);
5035       ldrh(tmp1, Address(post(src, 2)));
5036       tst(tmp1, 0xff00);
5037       br(NE, SET_RESULT);
5038       strb(tmp1, Address(post(dst, 1)));
5039       subs(len, len, 1);
5040       br(GT, NEXT_1);
5041 
5042     BIND(SET_RESULT);
5043       sub(result, result, len); // Return index where we stopped
5044                                 // Return len == 0 if we processed all
5045                                 // characters
5046     BIND(DONE);
5047 }
5048 
5049 
5050 // Inflate byte[] array to char[].
5051 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
5052                                         FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,
5053                                         Register tmp4) {
5054   Label big, done, after_init, to_stub;
5055 
5056   assert_different_registers(src, dst, len, tmp4, rscratch1);
5057 
5058   fmovd(vtmp1, zr);
5059   lsrw(tmp4, len, 3);
5060   bind(after_init);
5061   cbnzw(tmp4, big);
5062   // Short string: less than 8 bytes.
5063   {
5064     Label loop, tiny;
5065 
5066     cmpw(len, 4);
5067     br(LT, tiny);
5068     // Use SIMD to do 4 bytes.
5069     ldrs(vtmp2, post(src, 4));
5070     zip1(vtmp3, T8B, vtmp2, vtmp1);
5071     subw(len, len, 4);
5072     strd(vtmp3, post(dst, 8));
5073 
5074     cbzw(len, done);
5075 
5076     // Do the remaining bytes by steam.
5077     bind(loop);
5078     ldrb(tmp4, post(src, 1));
5079     strh(tmp4, post(dst, 2));
5080     subw(len, len, 1);
5081 
5082     bind(tiny);
5083     cbnz(len, loop);
5084 
5085     b(done);
5086   }
5087 
5088   if (SoftwarePrefetchHintDistance &gt;= 0) {
5089     bind(to_stub);
5090       RuntimeAddress stub =  RuntimeAddress(StubRoutines::aarch64::large_byte_array_inflate());
5091       assert(stub.target() != NULL, &quot;large_byte_array_inflate stub has not been generated&quot;);
5092       trampoline_call(stub);
5093       b(after_init);
5094   }
5095 
5096   // Unpack the bytes 8 at a time.
5097   bind(big);
5098   {
5099     Label loop, around, loop_last, loop_start;
5100 
5101     if (SoftwarePrefetchHintDistance &gt;= 0) {
5102       const int large_loop_threshold = (64 + 16)/8;
5103       ldrd(vtmp2, post(src, 8));
5104       andw(len, len, 7);
5105       cmp(tmp4, (u1)large_loop_threshold);
5106       br(GE, to_stub);
5107       b(loop_start);
5108 
5109       bind(loop);
5110       ldrd(vtmp2, post(src, 8));
5111       bind(loop_start);
5112       subs(tmp4, tmp4, 1);
5113       br(EQ, loop_last);
5114       zip1(vtmp2, T16B, vtmp2, vtmp1);
5115       ldrd(vtmp3, post(src, 8));
5116       st1(vtmp2, T8H, post(dst, 16));
5117       subs(tmp4, tmp4, 1);
5118       zip1(vtmp3, T16B, vtmp3, vtmp1);
5119       st1(vtmp3, T8H, post(dst, 16));
5120       br(NE, loop);
5121       b(around);
5122       bind(loop_last);
5123       zip1(vtmp2, T16B, vtmp2, vtmp1);
5124       st1(vtmp2, T8H, post(dst, 16));
5125       bind(around);
5126       cbz(len, done);
5127     } else {
5128       andw(len, len, 7);
5129       bind(loop);
5130       ldrd(vtmp2, post(src, 8));
5131       sub(tmp4, tmp4, 1);
5132       zip1(vtmp3, T16B, vtmp2, vtmp1);
5133       st1(vtmp3, T8H, post(dst, 16));
5134       cbnz(tmp4, loop);
5135     }
5136   }
5137 
5138   // Do the tail of up to 8 bytes.
5139   add(src, src, len);
5140   ldrd(vtmp3, Address(src, -8));
5141   add(dst, dst, len, ext::uxtw, 1);
5142   zip1(vtmp3, T16B, vtmp3, vtmp1);
5143   strq(vtmp3, Address(dst, -16));
5144 
5145   bind(done);
5146 }
5147 
5148 // Compress char[] array to byte[].
5149 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
5150                                          FloatRegister tmp1Reg, FloatRegister tmp2Reg,
5151                                          FloatRegister tmp3Reg, FloatRegister tmp4Reg,
5152                                          Register result) {
5153   encode_iso_array(src, dst, len, result,
5154                    tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg);
5155   cmp(len, zr);
5156   csel(result, result, zr, EQ);
5157 }
5158 
5159 // get_thread() can be called anywhere inside generated code so we
5160 // need to save whatever non-callee save context might get clobbered
5161 // by the call to JavaThread::aarch64_get_thread_helper() or, indeed,
5162 // the call setup code.
5163 //
5164 // aarch64_get_thread_helper() clobbers only r0, r1, and flags.
5165 //
5166 void MacroAssembler::get_thread(Register dst) {
5167   RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;
5168   push(saved_regs, sp);
5169 
5170   mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));
5171   blr(lr);
5172   if (dst != c_rarg0) {
5173     mov(dst, c_rarg0);
5174   }
5175 
5176   pop(saved_regs, sp);
5177 }
5178 
5179 void MacroAssembler::cache_wb(Address line) {
5180   assert(line.getMode() == Address::base_plus_offset, &quot;mode should be base_plus_offset&quot;);
5181   assert(line.index() == noreg, &quot;index should be noreg&quot;);
5182   assert(line.offset() == 0, &quot;offset should be 0&quot;);
5183   // would like to assert this
5184   // assert(line._ext.shift == 0, &quot;shift should be zero&quot;);
5185   if (VM_Version::supports_dcpop()) {
5186     // writeback using clear virtual address to point of persistence
5187     dc(Assembler::CVAP, line.base());
5188   } else {
5189     // no need to generate anything as Unsafe.writebackMemory should
5190     // never invoke this stub
5191   }
5192 }
5193 
5194 void MacroAssembler::cache_wbsync(bool is_pre) {
5195   // we only need a barrier post sync
5196   if (!is_pre) {
5197     membar(Assembler::AnyAny);
5198   }
5199 }
    </pre>
  </body>
</html>
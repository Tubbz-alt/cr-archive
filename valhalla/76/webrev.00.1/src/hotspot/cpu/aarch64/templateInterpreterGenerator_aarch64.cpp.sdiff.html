<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../x86/c1_CodeStubs_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  32 #include &quot;interpreter/interp_masm.hpp&quot;
  33 #include &quot;interpreter/templateInterpreterGenerator.hpp&quot;
  34 #include &quot;interpreter/templateTable.hpp&quot;
  35 #include &quot;interpreter/bytecodeTracer.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/arrayOop.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;oops/method.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;

  41 #include &quot;prims/jvmtiExport.hpp&quot;
  42 #include &quot;prims/jvmtiThreadState.hpp&quot;
  43 #include &quot;runtime/arguments.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/frame.inline.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/stubRoutines.hpp&quot;
  48 #include &quot;runtime/synchronizer.hpp&quot;
  49 #include &quot;runtime/timer.hpp&quot;
  50 #include &quot;runtime/vframeArray.hpp&quot;
  51 #include &quot;utilities/debug.hpp&quot;
  52 #include &quot;utilities/powerOfTwo.hpp&quot;
  53 #include &lt;sys/types.h&gt;
  54 
  55 #ifndef PRODUCT
  56 #include &quot;oops/method.hpp&quot;
  57 #endif // !PRODUCT
  58 
  59 // Size of interpreter code.  Increase if too small.  Interpreter will
  60 // fail with a guarantee (&quot;not enough space for interpreter generation&quot;);
</pre>
<hr />
<pre>
 418       __ lea(c_rarg2, Address((address)message));
 419     } else {
 420       __ mov(c_rarg2, NULL_WORD);
 421     }
 422     __ call_VM(r0,
 423                CAST_FROM_FN_PTR(address, InterpreterRuntime::create_exception),
 424                c_rarg1, c_rarg2);
 425   }
 426   // throw exception
 427   __ b(address(Interpreter::throw_exception_entry()));
 428   return entry;
 429 }
 430 
 431 address TemplateInterpreterGenerator::generate_return_entry_for(TosState state, int step, size_t index_size) {
 432   address entry = __ pc();
 433 
 434   // Restore stack bottom in case i2c adjusted stack
 435   __ ldr(esp, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 436   // and NULL it as marker that esp is now tos until next java call
 437   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));





 438   __ restore_bcp();
 439   __ restore_locals();
 440   __ restore_constant_pool_cache();
 441   __ get_method(rmethod);
 442 
 443   if (state == atos) {
 444     Register obj = r0;
 445     Register mdp = r1;
 446     Register tmp = r2;
 447     __ profile_return_type(mdp, obj, tmp);
 448   }
 449 
 450   // Pop N words from the stack
 451   __ get_cache_and_index_at_bcp(r1, r2, 1, index_size);
 452   __ ldr(r1, Address(r1, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));
 453   __ andr(r1, r1, ConstantPoolCacheEntry::parameter_size_mask);
 454 
 455   __ add(esp, esp, r1, Assembler::LSL, 3);
 456 
 457   // Restore machine SP
</pre>
<hr />
<pre>
 536     __ dispatch_next(state, step);
 537   } else {
 538     __ jump_to_entry(continuation);
 539   }
 540   return entry;
 541 }
 542 
 543 address TemplateInterpreterGenerator::generate_result_handler_for(
 544         BasicType type) {
 545     address entry = __ pc();
 546   switch (type) {
 547   case T_BOOLEAN: __ c2bool(r0);         break;
 548   case T_CHAR   : __ uxth(r0, r0);       break;
 549   case T_BYTE   : __ sxtb(r0, r0);        break;
 550   case T_SHORT  : __ sxth(r0, r0);        break;
 551   case T_INT    : __ uxtw(r0, r0);        break;  // FIXME: We almost certainly don&#39;t need this
 552   case T_LONG   : /* nothing to do */        break;
 553   case T_VOID   : /* nothing to do */        break;
 554   case T_FLOAT  : /* nothing to do */        break;
 555   case T_DOUBLE : /* nothing to do */        break;

 556   case T_OBJECT :
 557     // retrieve result from frame
 558     __ ldr(r0, Address(rfp, frame::interpreter_frame_oop_temp_offset*wordSize));
 559     // and verify it
 560     __ verify_oop(r0);
 561     break;
 562   default       : ShouldNotReachHere();
 563   }
 564   __ ret(lr);                                  // return from result handler
 565   return entry;
 566 }
 567 
 568 address TemplateInterpreterGenerator::generate_safept_entry_for(
 569         TosState state,
 570         address runtime_entry) {
 571   address entry = __ pc();
 572   __ push(state);
 573   __ call_VM(noreg, runtime_entry);
 574   __ membar(Assembler::AnyAny);
 575   __ dispatch_via(vtos, Interpreter::_normal_table.table_for(vtos));
</pre>
</td>
<td>
<hr />
<pre>
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  32 #include &quot;interpreter/interp_masm.hpp&quot;
  33 #include &quot;interpreter/templateInterpreterGenerator.hpp&quot;
  34 #include &quot;interpreter/templateTable.hpp&quot;
  35 #include &quot;interpreter/bytecodeTracer.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/arrayOop.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;oops/method.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  41 #include &quot;oops/valueKlass.hpp&quot;</span>
  42 #include &quot;prims/jvmtiExport.hpp&quot;
  43 #include &quot;prims/jvmtiThreadState.hpp&quot;
  44 #include &quot;runtime/arguments.hpp&quot;
  45 #include &quot;runtime/deoptimization.hpp&quot;
  46 #include &quot;runtime/frame.inline.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;runtime/synchronizer.hpp&quot;
  50 #include &quot;runtime/timer.hpp&quot;
  51 #include &quot;runtime/vframeArray.hpp&quot;
  52 #include &quot;utilities/debug.hpp&quot;
  53 #include &quot;utilities/powerOfTwo.hpp&quot;
  54 #include &lt;sys/types.h&gt;
  55 
  56 #ifndef PRODUCT
  57 #include &quot;oops/method.hpp&quot;
  58 #endif // !PRODUCT
  59 
  60 // Size of interpreter code.  Increase if too small.  Interpreter will
  61 // fail with a guarantee (&quot;not enough space for interpreter generation&quot;);
</pre>
<hr />
<pre>
 419       __ lea(c_rarg2, Address((address)message));
 420     } else {
 421       __ mov(c_rarg2, NULL_WORD);
 422     }
 423     __ call_VM(r0,
 424                CAST_FROM_FN_PTR(address, InterpreterRuntime::create_exception),
 425                c_rarg1, c_rarg2);
 426   }
 427   // throw exception
 428   __ b(address(Interpreter::throw_exception_entry()));
 429   return entry;
 430 }
 431 
 432 address TemplateInterpreterGenerator::generate_return_entry_for(TosState state, int step, size_t index_size) {
 433   address entry = __ pc();
 434 
 435   // Restore stack bottom in case i2c adjusted stack
 436   __ ldr(esp, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 437   // and NULL it as marker that esp is now tos until next java call
 438   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
<span class="line-added"> 439 </span>
<span class="line-added"> 440   if (state == atos &amp;&amp; InlineTypeReturnedAsFields) {</span>
<span class="line-added"> 441     __ store_value_type_fields_to_buf(NULL, true);</span>
<span class="line-added"> 442   }</span>
<span class="line-added"> 443 </span>
 444   __ restore_bcp();
 445   __ restore_locals();
 446   __ restore_constant_pool_cache();
 447   __ get_method(rmethod);
 448 
 449   if (state == atos) {
 450     Register obj = r0;
 451     Register mdp = r1;
 452     Register tmp = r2;
 453     __ profile_return_type(mdp, obj, tmp);
 454   }
 455 
 456   // Pop N words from the stack
 457   __ get_cache_and_index_at_bcp(r1, r2, 1, index_size);
 458   __ ldr(r1, Address(r1, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));
 459   __ andr(r1, r1, ConstantPoolCacheEntry::parameter_size_mask);
 460 
 461   __ add(esp, esp, r1, Assembler::LSL, 3);
 462 
 463   // Restore machine SP
</pre>
<hr />
<pre>
 542     __ dispatch_next(state, step);
 543   } else {
 544     __ jump_to_entry(continuation);
 545   }
 546   return entry;
 547 }
 548 
 549 address TemplateInterpreterGenerator::generate_result_handler_for(
 550         BasicType type) {
 551     address entry = __ pc();
 552   switch (type) {
 553   case T_BOOLEAN: __ c2bool(r0);         break;
 554   case T_CHAR   : __ uxth(r0, r0);       break;
 555   case T_BYTE   : __ sxtb(r0, r0);        break;
 556   case T_SHORT  : __ sxth(r0, r0);        break;
 557   case T_INT    : __ uxtw(r0, r0);        break;  // FIXME: We almost certainly don&#39;t need this
 558   case T_LONG   : /* nothing to do */        break;
 559   case T_VOID   : /* nothing to do */        break;
 560   case T_FLOAT  : /* nothing to do */        break;
 561   case T_DOUBLE : /* nothing to do */        break;
<span class="line-added"> 562   case T_VALUETYPE: // fall through (value types are handled with oops)</span>
 563   case T_OBJECT :
 564     // retrieve result from frame
 565     __ ldr(r0, Address(rfp, frame::interpreter_frame_oop_temp_offset*wordSize));
 566     // and verify it
 567     __ verify_oop(r0);
 568     break;
 569   default       : ShouldNotReachHere();
 570   }
 571   __ ret(lr);                                  // return from result handler
 572   return entry;
 573 }
 574 
 575 address TemplateInterpreterGenerator::generate_safept_entry_for(
 576         TosState state,
 577         address runtime_entry) {
 578   address entry = __ pc();
 579   __ push(state);
 580   __ call_VM(noreg, runtime_entry);
 581   __ membar(Assembler::AnyAny);
 582   __ dispatch_via(vtos, Interpreter::_normal_table.table_for(vtos));
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../x86/c1_CodeStubs_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
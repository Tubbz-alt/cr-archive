<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../x86/interp_masm_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2663       patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2664     }
2665     __ b(Done);
2666   } else { // Valhalla
2667 
2668     if (is_static) {
2669       __ load_heap_oop(r0, field);
2670       Label is_inline, isUninitialized;
2671       // Issue below if the static field has not been initialized yet
2672       __ test_field_is_inline_type(raw_flags, r8 /*temp*/, is_inline);
2673         // Not inline case
2674         __ push(atos);
2675         __ b(Done);
2676       // Inline case, must not return null even if uninitialized
2677       __ bind(is_inline);
2678         __ cbz(r0, isUninitialized);
2679           __ push(atos);
2680           __ b(Done);
2681         __ bind(isUninitialized);
2682           __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);
<span class="line-modified">2683           __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_value_field), obj, raw_flags);</span>
2684           __ verify_oop(r0);
2685           __ push(atos);
2686           __ b(Done);
2687     } else {
2688       Label isFlattened, isInitialized, is_inline, rewrite_inline;
2689         __ test_field_is_inline_type(raw_flags, r8 /*temp*/, is_inline);
2690         // Non-inline field case
2691         __ load_heap_oop(r0, field);
2692         __ push(atos);
2693         if (rc == may_rewrite) {
2694           patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2695         }
2696         __ b(Done);
2697       __ bind(is_inline);
2698         __ test_field_is_inlined(raw_flags, r8 /* temp */, isFlattened);
2699          // Non-inline field case
2700           __ load_heap_oop(r0, field);
2701           __ cbnz(r0, isInitialized);
2702             __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);
<span class="line-modified">2703             __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_instance_value_field), obj, raw_flags);</span>
2704           __ bind(isInitialized);
2705           __ verify_oop(r0);
2706           __ push(atos);
2707           __ b(rewrite_inline);
2708         __ bind(isFlattened);
2709           __ ldr(r10, Address(cache, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset())));
2710           __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);
2711           call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flattened_field), obj, raw_flags, r10);
2712           __ verify_oop(r0);
2713           __ push(atos);
2714       __ bind(rewrite_inline);
2715       if (rc == may_rewrite) {
2716          patch_bytecode(Bytecodes::_fast_qgetfield, bc, r1);
2717       }
2718       __ b(Done);
2719     }
2720   }
2721 
2722   __ bind(notObj);
2723   __ cmp(flags, (u1)itos);
</pre>
<hr />
<pre>
3323     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3324     __ membar(MacroAssembler::AnyAny);
3325     __ bind(notVolatile);
3326   }
3327 
3328   // access field
3329   switch (bytecode()) {
3330   case Bytecodes::_fast_qgetfield:
3331     {
3332        Label isFlattened, isInitialized, Done;
3333        // FIXME: We don&#39;t need to reload registers multiple times, but stay close to x86 code
3334        __ ldrw(r9, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset())));
3335        __ test_field_is_inlined(r9, r8 /* temp */, isFlattened);
3336         // Non-flattened field case
3337         __ mov(r9, r0);
3338         __ load_heap_oop(r0, field);
3339         __ cbnz(r0, isInitialized);
3340           __ mov(r0, r9);
3341           __ ldrw(r9, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset())));
3342           __ andw(r9, r9, ConstantPoolCacheEntry::field_index_mask);
<span class="line-modified">3343           __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_instance_value_field), r0, r9);</span>
3344         __ bind(isInitialized);
3345         __ verify_oop(r0);
3346         __ b(Done);
3347       __ bind(isFlattened);
3348         __ ldrw(r9, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset())));
3349         __ andw(r9, r9, ConstantPoolCacheEntry::field_index_mask);
3350         __ ldr(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset())));
3351         call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flattened_field), r0, r9, r3);
3352         __ verify_oop(r0);
3353       __ bind(Done);
3354     }
3355     break;
3356   case Bytecodes::_fast_agetfield:
3357     do_oop_load(_masm, field, r0, IN_HEAP);
3358     __ verify_oop(r0);
3359     break;
3360   case Bytecodes::_fast_lgetfield:
3361     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3362     break;
3363   case Bytecodes::_fast_igetfield:
</pre>
</td>
<td>
<hr />
<pre>
2663       patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2664     }
2665     __ b(Done);
2666   } else { // Valhalla
2667 
2668     if (is_static) {
2669       __ load_heap_oop(r0, field);
2670       Label is_inline, isUninitialized;
2671       // Issue below if the static field has not been initialized yet
2672       __ test_field_is_inline_type(raw_flags, r8 /*temp*/, is_inline);
2673         // Not inline case
2674         __ push(atos);
2675         __ b(Done);
2676       // Inline case, must not return null even if uninitialized
2677       __ bind(is_inline);
2678         __ cbz(r0, isUninitialized);
2679           __ push(atos);
2680           __ b(Done);
2681         __ bind(isUninitialized);
2682           __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);
<span class="line-modified">2683           __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field), obj, raw_flags);</span>
2684           __ verify_oop(r0);
2685           __ push(atos);
2686           __ b(Done);
2687     } else {
2688       Label isFlattened, isInitialized, is_inline, rewrite_inline;
2689         __ test_field_is_inline_type(raw_flags, r8 /*temp*/, is_inline);
2690         // Non-inline field case
2691         __ load_heap_oop(r0, field);
2692         __ push(atos);
2693         if (rc == may_rewrite) {
2694           patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2695         }
2696         __ b(Done);
2697       __ bind(is_inline);
2698         __ test_field_is_inlined(raw_flags, r8 /* temp */, isFlattened);
2699          // Non-inline field case
2700           __ load_heap_oop(r0, field);
2701           __ cbnz(r0, isInitialized);
2702             __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);
<span class="line-modified">2703             __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_instance_inline_type_field), obj, raw_flags);</span>
2704           __ bind(isInitialized);
2705           __ verify_oop(r0);
2706           __ push(atos);
2707           __ b(rewrite_inline);
2708         __ bind(isFlattened);
2709           __ ldr(r10, Address(cache, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset())));
2710           __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);
2711           call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flattened_field), obj, raw_flags, r10);
2712           __ verify_oop(r0);
2713           __ push(atos);
2714       __ bind(rewrite_inline);
2715       if (rc == may_rewrite) {
2716          patch_bytecode(Bytecodes::_fast_qgetfield, bc, r1);
2717       }
2718       __ b(Done);
2719     }
2720   }
2721 
2722   __ bind(notObj);
2723   __ cmp(flags, (u1)itos);
</pre>
<hr />
<pre>
3323     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3324     __ membar(MacroAssembler::AnyAny);
3325     __ bind(notVolatile);
3326   }
3327 
3328   // access field
3329   switch (bytecode()) {
3330   case Bytecodes::_fast_qgetfield:
3331     {
3332        Label isFlattened, isInitialized, Done;
3333        // FIXME: We don&#39;t need to reload registers multiple times, but stay close to x86 code
3334        __ ldrw(r9, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset())));
3335        __ test_field_is_inlined(r9, r8 /* temp */, isFlattened);
3336         // Non-flattened field case
3337         __ mov(r9, r0);
3338         __ load_heap_oop(r0, field);
3339         __ cbnz(r0, isInitialized);
3340           __ mov(r0, r9);
3341           __ ldrw(r9, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset())));
3342           __ andw(r9, r9, ConstantPoolCacheEntry::field_index_mask);
<span class="line-modified">3343           __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_instance_inline_type_field), r0, r9);</span>
3344         __ bind(isInitialized);
3345         __ verify_oop(r0);
3346         __ b(Done);
3347       __ bind(isFlattened);
3348         __ ldrw(r9, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset())));
3349         __ andw(r9, r9, ConstantPoolCacheEntry::field_index_mask);
3350         __ ldr(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset())));
3351         call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flattened_field), r0, r9, r3);
3352         __ verify_oop(r0);
3353       __ bind(Done);
3354     }
3355     break;
3356   case Bytecodes::_fast_agetfield:
3357     do_oop_load(_masm, field, r0, IN_HEAP);
3358     __ verify_oop(r0);
3359     break;
3360   case Bytecodes::_fast_lgetfield:
3361     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3362     break;
3363   case Bytecodes::_fast_igetfield:
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../x86/interp_masm_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/fieldLayoutBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/fieldLayoutBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;classfile/classFileParser.hpp&quot;
 28 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;oops/array.hpp&quot;
 31 #include &quot;oops/fieldStreams.inline.hpp&quot;
 32 #include &quot;oops/instanceMirrorKlass.hpp&quot;
 33 #include &quot;oops/klass.inline.hpp&quot;
 34 #include &quot;oops/inlineKlass.inline.hpp&quot;
 35 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 36 
 37 LayoutRawBlock::LayoutRawBlock(Kind kind, int size) :
 38   _next_block(NULL),
 39   _prev_block(NULL),
<span class="line-modified"> 40   _value_klass(NULL),</span>
 41   _kind(kind),
 42   _offset(-1),
 43   _alignment(1),
 44   _size(size),
 45   _field_index(-1),
 46   _is_reference(false) {
 47   assert(kind == EMPTY || kind == RESERVED || kind == PADDING || kind == INHERITED,
 48          &quot;Otherwise, should use the constructor with a field index argument&quot;);
 49   assert(size &gt; 0, &quot;Sanity check&quot;);
 50 }
 51 
 52 
 53 LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference) :
 54  _next_block(NULL),
 55  _prev_block(NULL),
<span class="line-modified"> 56  _value_klass(NULL),</span>
 57  _kind(kind),
 58  _offset(-1),
 59  _alignment(alignment),
 60  _size(size),
 61  _field_index(index),
 62  _is_reference(is_reference) {
 63   assert(kind == REGULAR || kind == INLINED || kind == INHERITED,
 64          &quot;Other kind do not have a field index&quot;);
 65   assert(size &gt; 0, &quot;Sanity check&quot;);
 66   assert(alignment &gt; 0, &quot;Sanity check&quot;);
 67 }
 68 
 69 bool LayoutRawBlock::fit(int size, int alignment) {
 70   int adjustment = 0;
 71   if ((_offset % alignment) != 0) {
 72     adjustment = alignment - (_offset % alignment);
 73   }
 74   return _size &gt;= size + adjustment;
 75 }
 76 
</pre>
<hr />
<pre>
 87   LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size /* alignment == size for primitive types */, false);
 88   if (_primitive_fields == NULL) {
 89     _primitive_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray&lt;LayoutRawBlock*&gt;(INITIAL_LIST_SIZE);
 90   }
 91   _primitive_fields-&gt;append(block);
 92 }
 93 
 94 void FieldGroup::add_oop_field(AllFieldStream fs) {
 95   int size = type2aelembytes(T_OBJECT);
 96   LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size /* alignment == size for oops */, true);
 97   if (_oop_fields == NULL) {
 98     _oop_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray&lt;LayoutRawBlock*&gt;(INITIAL_LIST_SIZE);
 99   }
100   _oop_fields-&gt;append(block);
101   _oop_count++;
102 }
103 
104 void FieldGroup::add_inlined_field(AllFieldStream fs, InlineKlass* vk) {
105   // _inlined_fields list might be merged with the _primitive_fields list in the future
106   LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk-&gt;get_exact_size_in_bytes(), vk-&gt;get_alignment(), false);
<span class="line-modified">107   block-&gt;set_value_klass(vk);</span>
108   if (_inlined_fields == NULL) {
109     _inlined_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray&lt;LayoutRawBlock*&gt;(INITIAL_LIST_SIZE);
110   }
111   _inlined_fields-&gt;append(block);
112 }
113 
114 void FieldGroup::sort_by_size() {
115   if (_primitive_fields != NULL) {
116     _primitive_fields-&gt;sort(LayoutRawBlock::compare_size_inverted);
117   }
118   if (_inlined_fields != NULL) {
119     _inlined_fields-&gt;sort(LayoutRawBlock::compare_size_inverted);
120   }
121 }
122 
123 FieldLayout::FieldLayout(Array&lt;u2&gt;* fields, ConstantPool* cp) :
124   _fields(fields),
125   _cp(cp),
126   _blocks(NULL),
127   _start(_blocks),
</pre>
<hr />
<pre>
898   int max_oop_map_count = super_oop_map_count + _nonstatic_oopmap_count;
899 
900   OopMapBlocksBuilder* nonstatic_oop_maps =
901       new OopMapBlocksBuilder(max_oop_map_count);
902   if (super_oop_map_count &gt; 0) {
903     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
904     _super_klass-&gt;nonstatic_oop_map_count());
905   }
906 
907   if (_root_group-&gt;oop_fields() != NULL) {
908     for (int i = 0; i &lt; _root_group-&gt;oop_fields()-&gt;length(); i++) {
909       LayoutRawBlock* b = _root_group-&gt;oop_fields()-&gt;at(i);
910       nonstatic_oop_maps-&gt;add(b-&gt;offset(), 1);
911     }
912   }
913 
914   GrowableArray&lt;LayoutRawBlock*&gt;* ff = _root_group-&gt;inlined_fields();
915   if (ff != NULL) {
916     for (int i = 0; i &lt; ff-&gt;length(); i++) {
917       LayoutRawBlock* f = ff-&gt;at(i);
<span class="line-modified">918       InlineKlass* vk = f-&gt;value_klass();</span>
919       assert(vk != NULL, &quot;Should have been initialized&quot;);
920       if (vk-&gt;contains_oops()) {
921         add_inlined_field_oopmap(nonstatic_oop_maps, vk, f-&gt;offset());
922       }
923     }
924   }
925 
926   if (!_contended_groups.is_empty()) {
927     for (int i = 0; i &lt; _contended_groups.length(); i++) {
928       FieldGroup* cg = _contended_groups.at(i);
929       if (cg-&gt;oop_count() &gt; 0) {
930         assert(cg-&gt;oop_fields() != NULL &amp;&amp; cg-&gt;oop_fields()-&gt;at(0) != NULL, &quot;oop_count &gt; 0 but no oop fields found&quot;);
931         nonstatic_oop_maps-&gt;add(cg-&gt;oop_fields()-&gt;at(0)-&gt;offset(), cg-&gt;oop_count());
932       }
933     }
934   }
935 
936   nonstatic_oop_maps-&gt;compact();
937 
938   int instance_end = align_up(_layout-&gt;last_block()-&gt;offset(), wordSize);
</pre>
</td>
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;classfile/classFileParser.hpp&quot;
 28 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;oops/array.hpp&quot;
 31 #include &quot;oops/fieldStreams.inline.hpp&quot;
 32 #include &quot;oops/instanceMirrorKlass.hpp&quot;
 33 #include &quot;oops/klass.inline.hpp&quot;
 34 #include &quot;oops/inlineKlass.inline.hpp&quot;
 35 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 36 
 37 LayoutRawBlock::LayoutRawBlock(Kind kind, int size) :
 38   _next_block(NULL),
 39   _prev_block(NULL),
<span class="line-modified"> 40   _inline_klass(NULL),</span>
 41   _kind(kind),
 42   _offset(-1),
 43   _alignment(1),
 44   _size(size),
 45   _field_index(-1),
 46   _is_reference(false) {
 47   assert(kind == EMPTY || kind == RESERVED || kind == PADDING || kind == INHERITED,
 48          &quot;Otherwise, should use the constructor with a field index argument&quot;);
 49   assert(size &gt; 0, &quot;Sanity check&quot;);
 50 }
 51 
 52 
 53 LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference) :
 54  _next_block(NULL),
 55  _prev_block(NULL),
<span class="line-modified"> 56  _inline_klass(NULL),</span>
 57  _kind(kind),
 58  _offset(-1),
 59  _alignment(alignment),
 60  _size(size),
 61  _field_index(index),
 62  _is_reference(is_reference) {
 63   assert(kind == REGULAR || kind == INLINED || kind == INHERITED,
 64          &quot;Other kind do not have a field index&quot;);
 65   assert(size &gt; 0, &quot;Sanity check&quot;);
 66   assert(alignment &gt; 0, &quot;Sanity check&quot;);
 67 }
 68 
 69 bool LayoutRawBlock::fit(int size, int alignment) {
 70   int adjustment = 0;
 71   if ((_offset % alignment) != 0) {
 72     adjustment = alignment - (_offset % alignment);
 73   }
 74   return _size &gt;= size + adjustment;
 75 }
 76 
</pre>
<hr />
<pre>
 87   LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size /* alignment == size for primitive types */, false);
 88   if (_primitive_fields == NULL) {
 89     _primitive_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray&lt;LayoutRawBlock*&gt;(INITIAL_LIST_SIZE);
 90   }
 91   _primitive_fields-&gt;append(block);
 92 }
 93 
 94 void FieldGroup::add_oop_field(AllFieldStream fs) {
 95   int size = type2aelembytes(T_OBJECT);
 96   LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size /* alignment == size for oops */, true);
 97   if (_oop_fields == NULL) {
 98     _oop_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray&lt;LayoutRawBlock*&gt;(INITIAL_LIST_SIZE);
 99   }
100   _oop_fields-&gt;append(block);
101   _oop_count++;
102 }
103 
104 void FieldGroup::add_inlined_field(AllFieldStream fs, InlineKlass* vk) {
105   // _inlined_fields list might be merged with the _primitive_fields list in the future
106   LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk-&gt;get_exact_size_in_bytes(), vk-&gt;get_alignment(), false);
<span class="line-modified">107   block-&gt;set_inline_klass(vk);</span>
108   if (_inlined_fields == NULL) {
109     _inlined_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray&lt;LayoutRawBlock*&gt;(INITIAL_LIST_SIZE);
110   }
111   _inlined_fields-&gt;append(block);
112 }
113 
114 void FieldGroup::sort_by_size() {
115   if (_primitive_fields != NULL) {
116     _primitive_fields-&gt;sort(LayoutRawBlock::compare_size_inverted);
117   }
118   if (_inlined_fields != NULL) {
119     _inlined_fields-&gt;sort(LayoutRawBlock::compare_size_inverted);
120   }
121 }
122 
123 FieldLayout::FieldLayout(Array&lt;u2&gt;* fields, ConstantPool* cp) :
124   _fields(fields),
125   _cp(cp),
126   _blocks(NULL),
127   _start(_blocks),
</pre>
<hr />
<pre>
898   int max_oop_map_count = super_oop_map_count + _nonstatic_oopmap_count;
899 
900   OopMapBlocksBuilder* nonstatic_oop_maps =
901       new OopMapBlocksBuilder(max_oop_map_count);
902   if (super_oop_map_count &gt; 0) {
903     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
904     _super_klass-&gt;nonstatic_oop_map_count());
905   }
906 
907   if (_root_group-&gt;oop_fields() != NULL) {
908     for (int i = 0; i &lt; _root_group-&gt;oop_fields()-&gt;length(); i++) {
909       LayoutRawBlock* b = _root_group-&gt;oop_fields()-&gt;at(i);
910       nonstatic_oop_maps-&gt;add(b-&gt;offset(), 1);
911     }
912   }
913 
914   GrowableArray&lt;LayoutRawBlock*&gt;* ff = _root_group-&gt;inlined_fields();
915   if (ff != NULL) {
916     for (int i = 0; i &lt; ff-&gt;length(); i++) {
917       LayoutRawBlock* f = ff-&gt;at(i);
<span class="line-modified">918       InlineKlass* vk = f-&gt;inline_klass();</span>
919       assert(vk != NULL, &quot;Should have been initialized&quot;);
920       if (vk-&gt;contains_oops()) {
921         add_inlined_field_oopmap(nonstatic_oop_maps, vk, f-&gt;offset());
922       }
923     }
924   }
925 
926   if (!_contended_groups.is_empty()) {
927     for (int i = 0; i &lt; _contended_groups.length(); i++) {
928       FieldGroup* cg = _contended_groups.at(i);
929       if (cg-&gt;oop_count() &gt; 0) {
930         assert(cg-&gt;oop_fields() != NULL &amp;&amp; cg-&gt;oop_fields()-&gt;at(0) != NULL, &quot;oop_count &gt; 0 but no oop fields found&quot;);
931         nonstatic_oop_maps-&gt;add(cg-&gt;oop_fields()-&gt;at(0)-&gt;offset(), cg-&gt;oop_count());
932       }
933     }
934   }
935 
936   nonstatic_oop_maps-&gt;compact();
937 
938   int instance_end = align_up(_layout-&gt;last_block()-&gt;offset(), wordSize);
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/x86/templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
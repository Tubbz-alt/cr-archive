<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/universe.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 520       // Only want to delete methods that are not executing for RedefineClasses.
 521       // The previous version will point to them so they&#39;re not totally dangling
 522       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 523       MetadataFactory::free_metadata(loader_data, method);
 524     }
 525     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 526   }
 527 }
 528 
 529 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 530                                           const Klass* super_klass,
 531                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 532                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 533   // Only deallocate transitive interfaces if not empty, same as super class
 534   // or same as local interfaces.  See code in parseClassFile.
 535   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 536   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 537     // check that the interfaces don&#39;t come from super class
 538     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 539                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 540     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared()) {</span>

 541       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 542     }
 543   }
 544 
 545   // local interfaces can be empty
 546   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 547       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared()) {</span>

 548     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 549   }
 550 }
 551 
 552 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 553                                                  Array&lt;RecordComponent*&gt;* record_components) {
 554   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 555     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 556       RecordComponent* record_component = record_components-&gt;at(i);
 557       MetadataFactory::free_metadata(loader_data, record_component);
 558     }
 559     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 560   }
 561 }
 562 
 563 // This function deallocates the metadata and C heap pointers that the
 564 // InstanceKlass points to.
 565 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 566 
 567   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
</td>
<td>
<hr />
<pre>
 520       // Only want to delete methods that are not executing for RedefineClasses.
 521       // The previous version will point to them so they&#39;re not totally dangling
 522       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 523       MetadataFactory::free_metadata(loader_data, method);
 524     }
 525     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 526   }
 527 }
 528 
 529 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 530                                           const Klass* super_klass,
 531                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 532                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 533   // Only deallocate transitive interfaces if not empty, same as super class
 534   // or same as local interfaces.  See code in parseClassFile.
 535   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 536   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 537     // check that the interfaces don&#39;t come from super class
 538     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 539                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 540     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 541         ti != Universe::the_single_IdentityObject_klass_array()) {</span>
 542       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 543     }
 544   }
 545 
 546   // local interfaces can be empty
 547   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 548       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 549       local_interfaces != Universe::the_single_IdentityObject_klass_array()) {</span>
 550     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 551   }
 552 }
 553 
 554 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 555                                                  Array&lt;RecordComponent*&gt;* record_components) {
 556   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 557     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 558       RecordComponent* record_component = record_components-&gt;at(i);
 559       MetadataFactory::free_metadata(loader_data, record_component);
 560     }
 561     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 562   }
 563 }
 564 
 565 // This function deallocates the metadata and C heap pointers that the
 566 // InstanceKlass points to.
 567 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 568 
 569   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
</td>
</tr>
</table>
<center><a href="../memory/universe.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
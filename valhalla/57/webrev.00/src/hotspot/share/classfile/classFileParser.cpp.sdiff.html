<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../memory/universe.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
5040   } else {
5041     ResourceMark rm;
5042     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5043 
5044     // Copy down from superclass
5045     if (super != NULL) {
5046       append_interfaces(result, super-&gt;transitive_interfaces());
5047     }
5048 
5049     // Copy down from local interfaces&#39; superinterfaces
5050     for (int i = 0; i &lt; local_size; i++) {
5051       InstanceKlass* const l = local_ifs-&gt;at(i);
5052       append_interfaces(result, l-&gt;transitive_interfaces());
5053     }
5054     // Finally add local interfaces
5055     append_interfaces(result, local_ifs);
5056 
5057     // length will be less than the max_transitive_size if duplicates were removed
5058     const int length = result-&gt;length();
5059     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);





5060     Array&lt;InstanceKlass*&gt;* const new_result =
5061       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5062     for (int i = 0; i &lt; length; i++) {
5063       InstanceKlass* const e = result-&gt;at(i);
5064       assert(e != NULL, &quot;just checking&quot;);
5065       new_result-&gt;at_put(i, e);
5066     }
5067     return new_result;
5068   }
5069 }
5070 
5071 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5072   assert(this_klass != NULL, &quot;invariant&quot;);
5073   const Klass* const super = this_klass-&gt;super();
5074 
5075   if (super != NULL) {
5076 
5077     // If the loader is not the boot loader then throw an exception if its
5078     // superclass is in package jdk.internal.reflect and its loader is not a
5079     // special reflection class loader
</pre>
<hr />
<pre>
6379         const int length = local_interfaces-&gt;length();
6380         for (int i = 0; i &lt; length; i++) {
6381           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6382           const char * to = k-&gt;external_name();
6383           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6384         }
6385       }
6386     }
6387   }
6388 
6389   JFR_ONLY(INIT_ID(ik);)
6390 
6391   // If we reach here, all is well.
6392   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6393   // in order for it to not be destroyed in the ClassFileParser destructor.
6394   set_klass_to_deallocate(NULL);
6395 
6396   // it&#39;s official
6397   set_klass(ik);
6398 




6399   debug_only(ik-&gt;verify();)
6400 }
6401 
6402 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6403   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6404   _class_name-&gt;decrement_refcount();
6405 
6406   _class_name = new_class_name;
6407   // Increment the refcount of the new name.
6408   // Now the ClassFileParser owns this name and will decrement in
6409   // the destructor.
6410   _class_name-&gt;increment_refcount();
6411 }
6412 
6413 
6414 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6415 // package by prepending its host class&#39;s package name to its class name and setting
6416 // its _class_name field.
6417 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6418   ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
7030     }
7031   }
7032 
7033   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,
7034   // if super is marked invalid, or if is_invalid_super_for_inline_type()
7035   // returns true
7036   if (invalid_inline_super() ||
7037       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
7038       is_invalid_super_for_inline_type()) {
7039     set_invalid_inline_super();
7040   }
7041 
7042   if (!is_value_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())
7043       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
7044     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());
7045     _has_injected_identityObject = true;
7046   }
7047   int itfs_len = _temp_local_interfaces-&gt;length();
7048   if (itfs_len == 0) {
7049     _local_interfaces = Universe::the_empty_instance_klass_array();


7050   } else {
7051     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
7052     for (int i = 0; i &lt; itfs_len; i++) {
7053       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));
7054     }
7055   }
7056   _temp_local_interfaces = NULL;
7057   assert(_local_interfaces != NULL, &quot;invariant&quot;);
7058 
7059   // Compute the transitive list of all unique interfaces implemented by this class
7060   _transitive_interfaces =
7061     compute_transitive_interfaces(_super_klass,
7062                                   _local_interfaces,
7063                                   _loader_data,
7064                                   CHECK);
7065 
7066   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7067 
7068   // sort methods
7069   _method_ordering = sort_methods(_methods);
</pre>
</td>
<td>
<hr />
<pre>
5040   } else {
5041     ResourceMark rm;
5042     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5043 
5044     // Copy down from superclass
5045     if (super != NULL) {
5046       append_interfaces(result, super-&gt;transitive_interfaces());
5047     }
5048 
5049     // Copy down from local interfaces&#39; superinterfaces
5050     for (int i = 0; i &lt; local_size; i++) {
5051       InstanceKlass* const l = local_ifs-&gt;at(i);
5052       append_interfaces(result, l-&gt;transitive_interfaces());
5053     }
5054     // Finally add local interfaces
5055     append_interfaces(result, local_ifs);
5056 
5057     // length will be less than the max_transitive_size if duplicates were removed
5058     const int length = result-&gt;length();
5059     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
<span class="line-added">5060 </span>
<span class="line-added">5061     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">5062       return Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">5063     }</span>
<span class="line-added">5064 </span>
5065     Array&lt;InstanceKlass*&gt;* const new_result =
5066       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5067     for (int i = 0; i &lt; length; i++) {
5068       InstanceKlass* const e = result-&gt;at(i);
5069       assert(e != NULL, &quot;just checking&quot;);
5070       new_result-&gt;at_put(i, e);
5071     }
5072     return new_result;
5073   }
5074 }
5075 
5076 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5077   assert(this_klass != NULL, &quot;invariant&quot;);
5078   const Klass* const super = this_klass-&gt;super();
5079 
5080   if (super != NULL) {
5081 
5082     // If the loader is not the boot loader then throw an exception if its
5083     // superclass is in package jdk.internal.reflect and its loader is not a
5084     // special reflection class loader
</pre>
<hr />
<pre>
6384         const int length = local_interfaces-&gt;length();
6385         for (int i = 0; i &lt; length; i++) {
6386           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6387           const char * to = k-&gt;external_name();
6388           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6389         }
6390       }
6391     }
6392   }
6393 
6394   JFR_ONLY(INIT_ID(ik);)
6395 
6396   // If we reach here, all is well.
6397   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6398   // in order for it to not be destroyed in the ClassFileParser destructor.
6399   set_klass_to_deallocate(NULL);
6400 
6401   // it&#39;s official
6402   set_klass(ik);
6403 
<span class="line-added">6404   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6405     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);</span>
<span class="line-added">6406   }</span>
<span class="line-added">6407 </span>
6408   debug_only(ik-&gt;verify();)
6409 }
6410 
6411 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6412   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6413   _class_name-&gt;decrement_refcount();
6414 
6415   _class_name = new_class_name;
6416   // Increment the refcount of the new name.
6417   // Now the ClassFileParser owns this name and will decrement in
6418   // the destructor.
6419   _class_name-&gt;increment_refcount();
6420 }
6421 
6422 
6423 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6424 // package by prepending its host class&#39;s package name to its class name and setting
6425 // its _class_name field.
6426 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6427   ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
7039     }
7040   }
7041 
7042   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,
7043   // if super is marked invalid, or if is_invalid_super_for_inline_type()
7044   // returns true
7045   if (invalid_inline_super() ||
7046       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
7047       is_invalid_super_for_inline_type()) {
7048     set_invalid_inline_super();
7049   }
7050 
7051   if (!is_value_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())
7052       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
7053     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());
7054     _has_injected_identityObject = true;
7055   }
7056   int itfs_len = _temp_local_interfaces-&gt;length();
7057   if (itfs_len == 0) {
7058     _local_interfaces = Universe::the_empty_instance_klass_array();
<span class="line-added">7059   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">7060     _local_interfaces = Universe::the_single_IdentityObject_klass_array();</span>
7061   } else {
7062     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
7063     for (int i = 0; i &lt; itfs_len; i++) {
7064       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));
7065     }
7066   }
7067   _temp_local_interfaces = NULL;
7068   assert(_local_interfaces != NULL, &quot;invariant&quot;);
7069 
7070   // Compute the transitive list of all unique interfaces implemented by this class
7071   _transitive_interfaces =
7072     compute_transitive_interfaces(_super_klass,
7073                                   _local_interfaces,
7074                                   _loader_data,
7075                                   CHECK);
7076 
7077   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7078 
7079   // sort methods
7080   _method_ordering = sort_methods(_methods);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../memory/universe.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
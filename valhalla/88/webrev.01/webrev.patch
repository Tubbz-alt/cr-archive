diff a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -643,5 +643,7 @@
 497fd9f9129c4928fd5a876dd55e0daf6298b511 jdk-15+24
 58833044988772ca06c97ab2f142474a8627af80 jdk-15+25
 58833044988772ca06c97ab2f142474a8627af80 jdk-15+25
 90b266a84c06f1b3dc0ed8767856793e8c1c357e jdk-15+25
 0a32396f7a690015d22ca3328ac441a358295d90 jdk-15+26
+506abc554caeb275928c02bf3a16e95d1978749f jdk-15+27
+93813843680bbe1b7efbca56c03fd137f20a2c31 jdk-16+0
diff a/make/Docs.gmk b/make/Docs.gmk
--- a/make/Docs.gmk
+++ b/make/Docs.gmk
@@ -61,11 +61,11 @@
 
 # URLs
 JAVADOC_BASE_URL := https://docs.oracle.com/pls/topic/lookup?ctx=javase$(VERSION_NUMBER)&amp;id=homepage
 BUG_SUBMIT_URL := https://bugreport.java.com/bugreport/
 COPYRIGHT_URL := legal/copyright.html
-LICENSE_URL := https://www.oracle.com/technetwork/java/javase/terms/license/java$(VERSION_NUMBER)speclicense.html
+LICENSE_URL := https://www.oracle.com/java/javase/terms/license/java$(VERSION_NUMBER)speclicense.html
 REDISTRIBUTION_URL := https://www.oracle.com/technetwork/java/redist-137594.html
 
 # In order to get a specific ordering it's necessary to specify the total
 # ordering of tags as the tags are otherwise ordered in order of definition.
 JAVADOC_TAGS := \
diff a/make/autoconf/version-numbers b/make/autoconf/version-numbers
--- a/make/autoconf/version-numbers
+++ b/make/autoconf/version-numbers
@@ -1,7 +1,7 @@
 #
-# Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License version 2 only, as
 # published by the Free Software Foundation.  Oracle designates this
@@ -24,22 +24,22 @@
 #
 
 # Default version, product, and vendor information to use,
 # unless overridden by configure
 
-DEFAULT_VERSION_FEATURE=15
+DEFAULT_VERSION_FEATURE=16
 DEFAULT_VERSION_INTERIM=0
 DEFAULT_VERSION_UPDATE=0
 DEFAULT_VERSION_PATCH=0
 DEFAULT_VERSION_EXTRA1=0
 DEFAULT_VERSION_EXTRA2=0
 DEFAULT_VERSION_EXTRA3=0
-DEFAULT_VERSION_DATE=2020-09-15
-DEFAULT_VERSION_CLASSFILE_MAJOR=59  # "`$EXPR $DEFAULT_VERSION_FEATURE + 44`"
+DEFAULT_VERSION_DATE=2021-03-16
+DEFAULT_VERSION_CLASSFILE_MAJOR=60  # "`$EXPR $DEFAULT_VERSION_FEATURE + 44`"
 DEFAULT_VERSION_CLASSFILE_MINOR=0
-DEFAULT_ACCEPTABLE_BOOT_VERSIONS="14 15"
-DEFAULT_JDK_SOURCE_TARGET_VERSION=15
+DEFAULT_ACCEPTABLE_BOOT_VERSIONS="14 15 16"
+DEFAULT_JDK_SOURCE_TARGET_VERSION=16
 DEFAULT_PROMOTED_VERSION_PRE=ea
 
 LAUNCHER_NAME=openjdk
 PRODUCT_NAME=OpenJDK
 PRODUCT_SUFFIX="Runtime Environment"
diff a/make/data/symbols/java.base-F.sym.txt b/make/data/symbols/java.base-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/java.base-F.sym.txt
@@ -0,0 +1,258 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name java/lang/Boolean
+header extends java/lang/Object implements java/io/Serializable,java/lang/Comparable,java/lang/constant/Constable flags 31 signature Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/lang/Boolean;>;Ljava/lang/constant/Constable;
+method name describeConstable descriptor ()Ljava/util/Optional; flags 1 signature ()Ljava/util/Optional<Ljava/lang/constant/DynamicConstantDesc<Ljava/lang/Boolean;>;>;
+
+class name java/lang/Byte
+header extends java/lang/Number implements java/lang/Comparable,java/lang/constant/Constable flags 31 signature Ljava/lang/Number;Ljava/lang/Comparable<Ljava/lang/Byte;>;Ljava/lang/constant/Constable;
+method name describeConstable descriptor ()Ljava/util/Optional; flags 1 signature ()Ljava/util/Optional<Ljava/lang/constant/DynamicConstantDesc<Ljava/lang/Byte;>;>;
+
+class name java/lang/CharSequence
+method name isEmpty descriptor ()Z flags 1
+
+class name java/lang/Character
+header extends java/lang/Object implements java/io/Serializable,java/lang/Comparable,java/lang/constant/Constable nestMembers java/lang/Character$UnicodeScript,java/lang/Character$UnicodeBlock,java/lang/Character$Subset flags 31 signature Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/lang/Character;>;Ljava/lang/constant/Constable;
+innerclass innerClass java/lang/Character$UnicodeBlock outerClass java/lang/Character innerClassName UnicodeBlock flags 19
+innerclass innerClass java/lang/Character$UnicodeScript outerClass java/lang/Character innerClassName UnicodeScript flags 4019
+innerclass innerClass java/lang/Character$Subset outerClass java/lang/Character innerClassName Subset flags 9
+method name describeConstable descriptor ()Ljava/util/Optional; flags 1 signature ()Ljava/util/Optional<Ljava/lang/constant/DynamicConstantDesc<Ljava/lang/Character;>;>;
+
+class name java/lang/Character$UnicodeBlock
+field name YEZIDI descriptor Ljava/lang/Character$UnicodeBlock; flags 19
+field name CHORASMIAN descriptor Ljava/lang/Character$UnicodeBlock; flags 19
+field name DIVES_AKURU descriptor Ljava/lang/Character$UnicodeBlock; flags 19
+field name LISU_SUPPLEMENT descriptor Ljava/lang/Character$UnicodeBlock; flags 19
+field name KHITAN_SMALL_SCRIPT descriptor Ljava/lang/Character$UnicodeBlock; flags 19
+field name TANGUT_SUPPLEMENT descriptor Ljava/lang/Character$UnicodeBlock; flags 19
+field name SYMBOLS_FOR_LEGACY_COMPUTING descriptor Ljava/lang/Character$UnicodeBlock; flags 19
+field name CJK_UNIFIED_IDEOGRAPHS_EXTENSION_G descriptor Ljava/lang/Character$UnicodeBlock; flags 19
+
+class name java/lang/Character$UnicodeScript
+field name YEZIDI descriptor Ljava/lang/Character$UnicodeScript; flags 4019
+field name CHORASMIAN descriptor Ljava/lang/Character$UnicodeScript; flags 4019
+field name DIVES_AKURU descriptor Ljava/lang/Character$UnicodeScript; flags 4019
+field name KHITAN_SMALL_SCRIPT descriptor Ljava/lang/Character$UnicodeScript; flags 4019
+
+class name java/lang/Class
+method name isHidden descriptor ()Z flags 101 runtimeAnnotations @Ljdk/internal/HotSpotIntrinsicCandidate;
+method name permittedSubclasses descriptor ()[Ljava/lang/constant/ClassDesc; flags 1 classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;SEALED_CLASSES;,essentialAPI=Zfalse)
+method name isSealed descriptor ()Z flags 1 classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;SEALED_CLASSES;,essentialAPI=Zfalse)
+
+class name java/lang/Math
+method name absExact descriptor (I)I flags 9
+method name absExact descriptor (J)J flags 9
+
+class name java/lang/Short
+header extends java/lang/Number implements java/lang/Comparable,java/lang/constant/Constable flags 31 signature Ljava/lang/Number;Ljava/lang/Comparable<Ljava/lang/Short;>;Ljava/lang/constant/Constable;
+method name describeConstable descriptor ()Ljava/util/Optional; flags 1 signature ()Ljava/util/Optional<Ljava/lang/constant/DynamicConstantDesc<Ljava/lang/Short;>;>;
+
+class name java/lang/StrictMath
+method name absExact descriptor (I)I flags 9
+method name absExact descriptor (J)J flags 9
+
+class name java/lang/String
+-method name stripIndent descriptor ()Ljava/lang/String;
+-method name translateEscapes descriptor ()Ljava/lang/String;
+-method name formatted descriptor ([Ljava/lang/Object;)Ljava/lang/String;
+method name stripIndent descriptor ()Ljava/lang/String; flags 1
+method name translateEscapes descriptor ()Ljava/lang/String; flags 1
+method name formatted descriptor ([Ljava/lang/Object;)Ljava/lang/String; flags 81
+
+class name java/lang/constant/ConstantDescs
+field name BSM_GET_STATIC_FINAL descriptor Ljava/lang/constant/DirectMethodHandleDesc; flags 19
+field name BSM_EXPLICIT_CAST descriptor Ljava/lang/constant/DirectMethodHandleDesc; flags 19
+field name TRUE descriptor Ljava/lang/constant/DynamicConstantDesc; flags 19 signature Ljava/lang/constant/DynamicConstantDesc<Ljava/lang/Boolean;>;
+field name FALSE descriptor Ljava/lang/constant/DynamicConstantDesc; flags 19 signature Ljava/lang/constant/DynamicConstantDesc<Ljava/lang/Boolean;>;
+
+class name java/lang/invoke/ConstantBootstraps
+-method name <init> descriptor ()V
+method name explicitCast descriptor (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/Class;Ljava/lang/Object;)Ljava/lang/Object; thrownTypes java/lang/ClassCastException flags 9 signature (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/Class<*>;Ljava/lang/Object;)Ljava/lang/Object;
+
+class name java/lang/invoke/MethodHandles
+header extends java/lang/Object nestMembers java/lang/invoke/MethodHandles$Lookup,java/lang/invoke/MethodHandles$Lookup$ClassOption flags 21
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup outerClass java/lang/invoke/MethodHandles innerClassName Lookup flags 19
+innerclass innerClass java/lang/invoke/VarHandle$AccessMode outerClass java/lang/invoke/VarHandle innerClassName AccessMode flags 4019
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup$ClassOption outerClass java/lang/invoke/MethodHandles$Lookup innerClassName ClassOption flags 4019
+
+class name java/lang/invoke/MethodHandles$Lookup
+header extends java/lang/Object nestHost java/lang/invoke/MethodHandles flags 31
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup outerClass java/lang/invoke/MethodHandles innerClassName Lookup flags 19
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup$ClassOption outerClass java/lang/invoke/MethodHandles$Lookup innerClassName ClassOption flags 4019
+innerclass innerClass java/lang/invoke/VarHandle$AccessMode outerClass java/lang/invoke/VarHandle innerClassName AccessMode flags 4019
+method name defineHiddenClass descriptor ([BZ[Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;)Ljava/lang/invoke/MethodHandles$Lookup; thrownTypes java/lang/IllegalAccessException flags 81
+
+class name java/lang/invoke/MethodHandles$Lookup$ClassOption
+header extends java/lang/Enum nestHost java/lang/invoke/MethodHandles flags 4031 signature Ljava/lang/Enum<Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;>;
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup outerClass java/lang/invoke/MethodHandles innerClassName Lookup flags 19
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup$ClassOption outerClass java/lang/invoke/MethodHandles$Lookup innerClassName ClassOption flags 4019
+field name NESTMATE descriptor Ljava/lang/invoke/MethodHandles$Lookup$ClassOption; flags 4019
+field name STRONG descriptor Ljava/lang/invoke/MethodHandles$Lookup$ClassOption; flags 4019
+method name values descriptor ()[Ljava/lang/invoke/MethodHandles$Lookup$ClassOption; flags 9
+method name valueOf descriptor (Ljava/lang/String;)Ljava/lang/invoke/MethodHandles$Lookup$ClassOption; flags 9
+
+class name java/lang/invoke/VarHandle
+-method name varType descriptor ()Ljava/lang/Class;
+-method name coordinateTypes descriptor ()Ljava/util/List;
+-method name toMethodHandle descriptor (Ljava/lang/invoke/VarHandle$AccessMode;)Ljava/lang/invoke/MethodHandle;
+method name varType descriptor ()Ljava/lang/Class; flags 1 signature ()Ljava/lang/Class<*>;
+method name coordinateTypes descriptor ()Ljava/util/List; flags 1 signature ()Ljava/util/List<Ljava/lang/Class<*>;>;
+method name toMethodHandle descriptor (Ljava/lang/invoke/VarHandle$AccessMode;)Ljava/lang/invoke/MethodHandle; flags 1
+
+class name java/lang/reflect/AnnotatedType
+method name getAnnotation descriptor (Ljava/lang/Class;)Ljava/lang/annotation/Annotation; flags 401 signature <T::Ljava/lang/annotation/Annotation;>(Ljava/lang/Class<TT;>;)TT;
+method name getAnnotations descriptor ()[Ljava/lang/annotation/Annotation; flags 401
+method name getDeclaredAnnotations descriptor ()[Ljava/lang/annotation/Annotation; flags 401
+
+class name java/lang/reflect/Modifier
+-method name <init> descriptor ()V
+
+class name java/net/DatagramSocket
+header extends java/lang/Object implements java/io/Closeable flags 21
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup outerClass java/lang/invoke/MethodHandles innerClassName Lookup flags 19
+-method name bind descriptor (Ljava/net/SocketAddress;)V
+-method name receive descriptor (Ljava/net/DatagramPacket;)V
+-method name setSoTimeout descriptor (I)V
+-method name getSoTimeout descriptor ()I
+-method name setSendBufferSize descriptor (I)V
+-method name getSendBufferSize descriptor ()I
+-method name setReceiveBufferSize descriptor (I)V
+-method name getReceiveBufferSize descriptor ()I
+-method name setReuseAddress descriptor (Z)V
+-method name getReuseAddress descriptor ()Z
+-method name setBroadcast descriptor (Z)V
+-method name getBroadcast descriptor ()Z
+-method name setTrafficClass descriptor (I)V
+-method name getTrafficClass descriptor ()I
+method name bind descriptor (Ljava/net/SocketAddress;)V thrownTypes java/net/SocketException flags 1
+method name receive descriptor (Ljava/net/DatagramPacket;)V thrownTypes java/io/IOException flags 1
+method name setSoTimeout descriptor (I)V thrownTypes java/net/SocketException flags 1
+method name getSoTimeout descriptor ()I thrownTypes java/net/SocketException flags 1
+method name setSendBufferSize descriptor (I)V thrownTypes java/net/SocketException flags 1
+method name getSendBufferSize descriptor ()I thrownTypes java/net/SocketException flags 1
+method name setReceiveBufferSize descriptor (I)V thrownTypes java/net/SocketException flags 1
+method name getReceiveBufferSize descriptor ()I thrownTypes java/net/SocketException flags 1
+method name setReuseAddress descriptor (Z)V thrownTypes java/net/SocketException flags 1
+method name getReuseAddress descriptor ()Z thrownTypes java/net/SocketException flags 1
+method name setBroadcast descriptor (Z)V thrownTypes java/net/SocketException flags 1
+method name getBroadcast descriptor ()Z thrownTypes java/net/SocketException flags 1
+method name setTrafficClass descriptor (I)V thrownTypes java/net/SocketException flags 1
+method name getTrafficClass descriptor ()I thrownTypes java/net/SocketException flags 1
+
+class name java/net/MulticastSocket
+-method name supportedOptions descriptor ()Ljava/util/Set;
+
+class name java/nio/CharBuffer
+method name isEmpty descriptor ()Z flags 11
+
+class name java/nio/channels/ServerSocketChannel
+method name open descriptor (Ljava/net/ProtocolFamily;)Ljava/nio/channels/ServerSocketChannel; thrownTypes java/io/IOException flags 9
+
+class name java/nio/channels/SocketChannel
+method name open descriptor (Ljava/net/ProtocolFamily;)Ljava/nio/channels/SocketChannel; thrownTypes java/io/IOException flags 9
+
+class name java/nio/channels/spi/SelectorProvider
+method name openSocketChannel descriptor (Ljava/net/ProtocolFamily;)Ljava/nio/channels/SocketChannel; thrownTypes java/io/IOException flags 1
+method name openServerSocketChannel descriptor (Ljava/net/ProtocolFamily;)Ljava/nio/channels/ServerSocketChannel; thrownTypes java/io/IOException flags 1
+
+class name java/security/interfaces/EdECKey
+header extends java/lang/Object flags 601
+method name getParams descriptor ()Ljava/security/spec/NamedParameterSpec; flags 401
+
+class name java/security/interfaces/EdECPrivateKey
+header extends java/lang/Object implements java/security/interfaces/EdECKey,java/security/PrivateKey flags 601
+method name getBytes descriptor ()Ljava/util/Optional; flags 401 signature ()Ljava/util/Optional<[B>;
+
+class name java/security/interfaces/EdECPublicKey
+header extends java/lang/Object implements java/security/interfaces/EdECKey,java/security/PublicKey flags 601
+method name getPoint descriptor ()Ljava/security/spec/EdECPoint; flags 401
+
+class name java/security/spec/EdDSAParameterSpec
+header extends java/lang/Object implements java/security/spec/AlgorithmParameterSpec flags 21
+method name <init> descriptor (Z)V flags 1
+method name <init> descriptor (Z[B)V flags 1
+method name isPrehash descriptor ()Z flags 1
+method name getContext descriptor ()Ljava/util/Optional; flags 1 signature ()Ljava/util/Optional<[B>;
+
+class name java/security/spec/EdECPoint
+header extends java/lang/Object flags 31
+method name <init> descriptor (ZLjava/math/BigInteger;)V flags 1
+method name isXOdd descriptor ()Z flags 1
+method name getY descriptor ()Ljava/math/BigInteger; flags 1
+
+class name java/security/spec/EdECPrivateKeySpec
+header extends java/lang/Object implements java/security/spec/KeySpec flags 31
+method name <init> descriptor (Ljava/security/spec/NamedParameterSpec;[B)V flags 1
+method name getParams descriptor ()Ljava/security/spec/NamedParameterSpec; flags 1
+method name getBytes descriptor ()[B flags 1
+
+class name java/security/spec/EdECPublicKeySpec
+header extends java/lang/Object implements java/security/spec/KeySpec flags 31
+method name <init> descriptor (Ljava/security/spec/NamedParameterSpec;Ljava/security/spec/EdECPoint;)V flags 1
+method name getParams descriptor ()Ljava/security/spec/NamedParameterSpec; flags 1
+method name getPoint descriptor ()Ljava/security/spec/EdECPoint; flags 1
+
+class name java/security/spec/NamedParameterSpec
+field name ED25519 descriptor Ljava/security/spec/NamedParameterSpec; flags 19
+field name ED448 descriptor Ljava/security/spec/NamedParameterSpec; flags 19
+
+class name java/text/DecimalFormatSymbols
+method name getMonetaryGroupingSeparator descriptor ()C flags 1
+method name setMonetaryGroupingSeparator descriptor (C)V flags 1
+
+class name java/util/NoSuchElementException
+method name <init> descriptor (Ljava/lang/String;Ljava/lang/Throwable;)V flags 1
+method name <init> descriptor (Ljava/lang/Throwable;)V flags 1
+
+class name java/util/TreeMap
+method name putIfAbsent descriptor (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object; flags 1 signature (TK;TV;)TV;
+method name computeIfAbsent descriptor (Ljava/lang/Object;Ljava/util/function/Function;)Ljava/lang/Object; flags 1 signature (TK;Ljava/util/function/Function<-TK;+TV;>;)TV;
+method name computeIfPresent descriptor (Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object; flags 1 signature (TK;Ljava/util/function/BiFunction<-TK;-TV;+TV;>;)TV;
+method name compute descriptor (Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object; flags 1 signature (TK;Ljava/util/function/BiFunction<-TK;-TV;+TV;>;)TV;
+method name merge descriptor (Ljava/lang/Object;Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object; flags 1 signature (TK;TV;Ljava/util/function/BiFunction<-TV;-TV;+TV;>;)TV;
+
+class name java/util/concurrent/locks/StampedLock
+header extends java/lang/Object implements java/io/Serializable flags 21 classAnnotations @Ljdk/Profile+Annotation;(value=I1)
+method name tryWriteLock descriptor ()J flags 1
+method name writeLockInterruptibly descriptor ()J thrownTypes java/lang/InterruptedException flags 1
+method name tryReadLock descriptor ()J flags 1
+method name tryReadLock descriptor (JLjava/util/concurrent/TimeUnit;)J thrownTypes java/lang/InterruptedException flags 1
+method name readLockInterruptibly descriptor ()J thrownTypes java/lang/InterruptedException flags 1
+method name unlock descriptor (J)V flags 1
+-method name tryWriteLock descriptor ()J
+-method name writeLockInterruptibly descriptor ()J
+-method name tryReadLock descriptor ()J
+-method name tryReadLock descriptor (JLjava/util/concurrent/TimeUnit;)J
+-method name readLockInterruptibly descriptor ()J
+-method name unlock descriptor (J)V
+
+class name javax/net/ssl/SSLSession
+-method name getPeerCertificateChain descriptor ()[Ljavax/security/cert/X509Certificate;
+method name getPeerCertificateChain descriptor ()[Ljavax/security/cert/X509Certificate; thrownTypes javax/net/ssl/SSLPeerUnverifiedException flags 1 deprecated true runtimeAnnotations @Ljava/lang/Deprecated;(forRemoval=Ztrue,since="9")
+
diff a/make/data/symbols/java.compiler-F.sym.txt b/make/data/symbols/java.compiler-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/java.compiler-F.sym.txt
@@ -0,0 +1,74 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name javax/lang/model/SourceVersion
+field name RELEASE_15 descriptor Ljavax/lang/model/SourceVersion; flags 4019
+
+class name javax/lang/model/element/Element
+method name getAnnotationsByType descriptor (Ljava/lang/Class;)[Ljava/lang/annotation/Annotation; flags 401 signature <A::Ljava/lang/annotation/Annotation;>(Ljava/lang/Class<TA;>;)[TA;
+
+class name javax/lang/model/element/Modifier
+header extends java/lang/Enum flags 4021 signature Ljava/lang/Enum<Ljavax/lang/model/element/Modifier;>;
+field name SEALED descriptor Ljavax/lang/model/element/Modifier; flags 4019 classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;SEALED_CLASSES;,essentialAPI=Zfalse)
+field name NON_SEALED descriptor Ljavax/lang/model/element/Modifier; flags 4019 classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;SEALED_CLASSES;,essentialAPI=Zfalse)
+
+class name javax/lang/model/element/TypeElement
+method name getPermittedSubclasses descriptor ()Ljava/util/List; flags 1 signature ()Ljava/util/List<+Ljavax/lang/model/type/TypeMirror;>; classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;SEALED_CLASSES;,essentialAPI=Zfalse)
+
+class name javax/lang/model/type/TypeMirror
+method name getAnnotationMirrors descriptor ()Ljava/util/List; flags 401 signature ()Ljava/util/List<+Ljavax/lang/model/element/AnnotationMirror;>;
+method name getAnnotation descriptor (Ljava/lang/Class;)Ljava/lang/annotation/Annotation; flags 401 signature <A::Ljava/lang/annotation/Annotation;>(Ljava/lang/Class<TA;>;)TA;
+method name getAnnotationsByType descriptor (Ljava/lang/Class;)[Ljava/lang/annotation/Annotation; flags 401 signature <A::Ljava/lang/annotation/Annotation;>(Ljava/lang/Class<TA;>;)[TA;
+
+class name javax/lang/model/util/AbstractAnnotationValueVisitor14
+header extends javax/lang/model/util/AbstractAnnotationValueVisitor9 flags 421 signature <R:Ljava/lang/Object;P:Ljava/lang/Object;>Ljavax/lang/model/util/AbstractAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax/annotation/processing/SupportedSourceVersion;(value=eLjavax/lang/model/SourceVersion;RELEASE_15;)
+
+class name javax/lang/model/util/AbstractElementVisitor14
+header extends javax/lang/model/util/AbstractElementVisitor9 flags 421 signature <R:Ljava/lang/Object;P:Ljava/lang/Object;>Ljavax/lang/model/util/AbstractElementVisitor9<TR;TP;>; classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;RECORDS;,essentialAPI=Zfalse) runtimeAnnotations @Ljavax/annotation/processing/SupportedSourceVersion;(value=eLjavax/lang/model/SourceVersion;RELEASE_15;)
+
+class name javax/lang/model/util/AbstractTypeVisitor14
+header extends javax/lang/model/util/AbstractTypeVisitor9 flags 421 signature <R:Ljava/lang/Object;P:Ljava/lang/Object;>Ljavax/lang/model/util/AbstractTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax/annotation/processing/SupportedSourceVersion;(value=eLjavax/lang/model/SourceVersion;RELEASE_15;)
+
+class name javax/lang/model/util/ElementKindVisitor14
+header extends javax/lang/model/util/ElementKindVisitor9 flags 21 signature <R:Ljava/lang/Object;P:Ljava/lang/Object;>Ljavax/lang/model/util/ElementKindVisitor9<TR;TP;>; classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;RECORDS;,essentialAPI=Zfalse) runtimeAnnotations @Ljavax/annotation/processing/SupportedSourceVersion;(value=eLjavax/lang/model/SourceVersion;RELEASE_15;)
+
+class name javax/lang/model/util/ElementScanner14
+header extends javax/lang/model/util/ElementScanner9 flags 21 signature <R:Ljava/lang/Object;P:Ljava/lang/Object;>Ljavax/lang/model/util/ElementScanner9<TR;TP;>; classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;RECORDS;,essentialAPI=Zfalse) runtimeAnnotations @Ljavax/annotation/processing/SupportedSourceVersion;(value=eLjavax/lang/model/SourceVersion;RELEASE_15;)
+
+class name javax/lang/model/util/SimpleAnnotationValueVisitor14
+header extends javax/lang/model/util/SimpleAnnotationValueVisitor9 flags 21 signature <R:Ljava/lang/Object;P:Ljava/lang/Object;>Ljavax/lang/model/util/SimpleAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax/annotation/processing/SupportedSourceVersion;(value=eLjavax/lang/model/SourceVersion;RELEASE_15;)
+
+class name javax/lang/model/util/SimpleElementVisitor14
+header extends javax/lang/model/util/SimpleElementVisitor9 flags 21 signature <R:Ljava/lang/Object;P:Ljava/lang/Object;>Ljavax/lang/model/util/SimpleElementVisitor9<TR;TP;>; classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;RECORDS;,essentialAPI=Zfalse) runtimeAnnotations @Ljavax/annotation/processing/SupportedSourceVersion;(value=eLjavax/lang/model/SourceVersion;RELEASE_15;)
+
+class name javax/lang/model/util/SimpleTypeVisitor14
+header extends javax/lang/model/util/SimpleTypeVisitor9 flags 21 signature <R:Ljava/lang/Object;P:Ljava/lang/Object;>Ljavax/lang/model/util/SimpleTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax/annotation/processing/SupportedSourceVersion;(value=eLjavax/lang/model/SourceVersion;RELEASE_15;)
+
+class name javax/lang/model/util/TypeKindVisitor14
+header extends javax/lang/model/util/TypeKindVisitor9 flags 21 signature <R:Ljava/lang/Object;P:Ljava/lang/Object;>Ljavax/lang/model/util/TypeKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax/annotation/processing/SupportedSourceVersion;(value=eLjavax/lang/model/SourceVersion;RELEASE_15;)
+
diff a/make/data/symbols/java.desktop-F.sym.txt b/make/data/symbols/java.desktop-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/java.desktop-F.sym.txt
@@ -0,0 +1,65 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name java/awt/Robot
+-method name delay descriptor (I)V
+method name delay descriptor (I)V flags 1
+
+class name javax/accessibility/AccessibleBundle
+header extends java/lang/Object flags 421 classAnnotations @Ljdk/Profile+Annotation;(value=I4)
+
+class name javax/sound/sampled/BooleanControl
+header extends javax/sound/sampled/Control nestMembers javax/sound/sampled/BooleanControl$Type flags 421
+innerclass innerClass javax/sound/sampled/Control$Type outerClass javax/sound/sampled/Control innerClassName Type flags 9
+innerclass innerClass javax/sound/sampled/BooleanControl$Type outerClass javax/sound/sampled/BooleanControl innerClassName Type flags 9
+
+class name javax/sound/sampled/CompoundControl
+header extends javax/sound/sampled/Control nestMembers javax/sound/sampled/CompoundControl$Type flags 421
+innerclass innerClass javax/sound/sampled/Control$Type outerClass javax/sound/sampled/Control innerClassName Type flags 9
+innerclass innerClass javax/sound/sampled/CompoundControl$Type outerClass javax/sound/sampled/CompoundControl innerClassName Type flags 9
+
+class name javax/sound/sampled/Control
+header extends java/lang/Object nestMembers javax/sound/sampled/Control$Type flags 421
+innerclass innerClass javax/sound/sampled/Control$Type outerClass javax/sound/sampled/Control innerClassName Type flags 9
+
+class name javax/sound/sampled/LineEvent
+header extends java/util/EventObject nestMembers javax/sound/sampled/LineEvent$Type flags 21
+innerclass innerClass javax/sound/sampled/LineEvent$Type outerClass javax/sound/sampled/LineEvent innerClassName Type flags 9
+
+class name javax/sound/sampled/Mixer$Info
+header extends java/lang/Object nestHost javax/sound/sampled/Mixer flags 21
+innerclass innerClass javax/sound/sampled/Mixer$Info outerClass javax/sound/sampled/Mixer innerClassName Info flags 9
+
+class name javax/sound/sampled/Port$Info
+header extends javax/sound/sampled/Line$Info nestHost javax/sound/sampled/Port flags 21
+innerclass innerClass javax/sound/sampled/Line$Info outerClass javax/sound/sampled/Line innerClassName Info flags 9
+innerclass innerClass javax/sound/sampled/Port$Info outerClass javax/sound/sampled/Port innerClassName Info flags 9
+
+class name javax/sound/sampled/ReverbType
+header extends java/lang/Object flags 21 classAnnotations @Ljdk/Profile+Annotation;(value=I4)
+
diff a/make/data/symbols/java.management.rmi-F.sym.txt b/make/data/symbols/java.management.rmi-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/java.management.rmi-F.sym.txt
@@ -0,0 +1,31 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name javax/management/remote/rmi/RMIConnectorServer
+-field name CREDENTIAL_TYPES descriptor Ljava/lang/String;
+
diff a/make/data/symbols/java.naming-F.sym.txt b/make/data/symbols/java.naming-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/java.naming-F.sym.txt
@@ -0,0 +1,33 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name javax/naming/spi/NamingManager
+header extends java/lang/Object flags 21
+innerclass innerClass java/util/ServiceLoader$Provider outerClass java/util/ServiceLoader innerClassName Provider flags 609
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup outerClass java/lang/invoke/MethodHandles innerClassName Lookup flags 19
+
diff a/make/data/symbols/java.xml-F.sym.txt b/make/data/symbols/java.xml-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/java.xml-F.sym.txt
@@ -0,0 +1,32 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name javax/xml/stream/XMLInputFactory
+method name newFactory descriptor ()Ljavax/xml/stream/XMLInputFactory; thrownTypes javax/xml/stream/FactoryConfigurationError flags 9
+-method name newFactory descriptor ()Ljavax/xml/stream/XMLInputFactory;
+
diff a/make/data/symbols/jdk.compiler-F.sym.txt b/make/data/symbols/jdk.compiler-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/jdk.compiler-F.sym.txt
@@ -0,0 +1,34 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name com/sun/source/tree/ClassTree
+method name getPermitsClause descriptor ()Ljava/util/List; flags 1 signature ()Ljava/util/List<+Lcom/sun/source/tree/Tree;>; classAnnotations @Ljdk/internal/PreviewFeature;(feature=eLjdk/internal/PreviewFeature$Feature;SEALED_CLASSES;,essentialAPI=Zfalse)
+
+class name com/sun/source/util/DocTrees
+method name getType descriptor (Lcom/sun/source/util/DocTreePath;)Ljavax/lang/model/type/TypeMirror; flags 401
+
diff a/make/data/symbols/jdk.incubator.foreign-F.sym.txt b/make/data/symbols/jdk.incubator.foreign-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/jdk.incubator.foreign-F.sym.txt
@@ -0,0 +1,131 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name jdk/incubator/foreign/AbstractLayout
+header extends java/lang/Object implements jdk/incubator/foreign/MemoryLayout flags 420
+innerclass innerClass java/util/Map$Entry outerClass java/util/Map innerClassName Entry flags 609
+innerclass innerClass java/lang/constant/DirectMethodHandleDesc$Kind outerClass java/lang/constant/DirectMethodHandleDesc innerClassName Kind flags 4019
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup outerClass java/lang/invoke/MethodHandles innerClassName Lookup flags 19
+-method name <init> descriptor (Ljava/util/OptionalLong;JLjava/util/Optional;)V
+method name <init> descriptor (Ljava/util/OptionalLong;JLjava/util/Map;)V flags 1 signature (Ljava/util/OptionalLong;JLjava/util/Map<Ljava/lang/String;Ljava/lang/constant/Constable;>;)V
+method name attribute descriptor (Ljava/lang/String;)Ljava/util/Optional; flags 1 signature (Ljava/lang/String;)Ljava/util/Optional<Ljava/lang/constant/Constable;>;
+method name attributes descriptor ()Ljava/util/stream/Stream; flags 1 signature ()Ljava/util/stream/Stream<Ljava/lang/String;>;
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/AbstractLayout; flags 1
+method name isPadding descriptor ()Z flags 1
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/MemoryLayout; flags 1041
+
+class name jdk/incubator/foreign/GroupLayout
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/GroupLayout; flags 1
+method name isPadding descriptor ()Z flags 1041
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/AbstractLayout; flags 1041
+method name attributes descriptor ()Ljava/util/stream/Stream; flags 1041
+method name attribute descriptor (Ljava/lang/String;)Ljava/util/Optional; flags 1041
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/MemoryLayout; flags 1041
+
+class name jdk/incubator/foreign/MappedMemorySegment
+header extends java/lang/Object implements jdk/incubator/foreign/MemorySegment flags 601
+method name withAccessModes descriptor (I)Ljdk/incubator/foreign/MappedMemorySegment; flags 401
+method name asSlice descriptor (JJ)Ljdk/incubator/foreign/MappedMemorySegment; flags 401
+method name force descriptor ()V flags 401
+method name load descriptor ()V flags 401
+method name unload descriptor ()V flags 401
+method name isLoaded descriptor ()Z flags 401
+method name asSlice descriptor (JJ)Ljdk/incubator/foreign/MemorySegment; flags 1041
+method name withAccessModes descriptor (I)Ljdk/incubator/foreign/MemorySegment; flags 1041
+
+class name jdk/incubator/foreign/MemoryAddress
+field name NULL descriptor Ljdk/incubator/foreign/MemoryAddress; flags 19
+-method name offset descriptor ()J
+-method name copy descriptor (Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;J)V
+method name segmentOffset descriptor ()J flags 401
+method name toRawLongValue descriptor ()J flags 401
+method name rebase descriptor (Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress; flags 401
+method name ofLong descriptor (J)Ljdk/incubator/foreign/MemoryAddress; flags 9
+
+class name jdk/incubator/foreign/MemoryHandles
+method name asAddressVarHandle descriptor (Ljava/lang/invoke/VarHandle;)Ljava/lang/invoke/VarHandle; flags 9
+method name asUnsigned descriptor (Ljava/lang/invoke/VarHandle;Ljava/lang/Class;)Ljava/lang/invoke/VarHandle; flags 9 signature (Ljava/lang/invoke/VarHandle;Ljava/lang/Class<*>;)Ljava/lang/invoke/VarHandle;
+method name filterValue descriptor (Ljava/lang/invoke/VarHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/VarHandle; flags 9
+method name filterCoordinates descriptor (Ljava/lang/invoke/VarHandle;I[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/VarHandle; flags 89
+method name insertCoordinates descriptor (Ljava/lang/invoke/VarHandle;I[Ljava/lang/Object;)Ljava/lang/invoke/VarHandle; flags 89
+method name permuteCoordinates descriptor (Ljava/lang/invoke/VarHandle;Ljava/util/List;[I)Ljava/lang/invoke/VarHandle; flags 89 signature (Ljava/lang/invoke/VarHandle;Ljava/util/List<Ljava/lang/Class<*>;>;[I)Ljava/lang/invoke/VarHandle;
+method name collectCoordinates descriptor (Ljava/lang/invoke/VarHandle;ILjava/lang/invoke/MethodHandle;)Ljava/lang/invoke/VarHandle; flags 9
+method name dropCoordinates descriptor (Ljava/lang/invoke/VarHandle;I[Ljava/lang/Class;)Ljava/lang/invoke/VarHandle; flags 89 signature (Ljava/lang/invoke/VarHandle;I[Ljava/lang/Class<*>;)Ljava/lang/invoke/VarHandle;
+
+class name jdk/incubator/foreign/MemoryLayout
+field name LAYOUT_NAME descriptor Ljava/lang/String; constantValue layout/name flags 19
+-method name offset descriptor ([Ljdk/incubator/foreign/MemoryLayout$PathElement;)J
+method name attribute descriptor (Ljava/lang/String;)Ljava/util/Optional; flags 401 signature (Ljava/lang/String;)Ljava/util/Optional<Ljava/lang/constant/Constable;>;
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/MemoryLayout; flags 401
+method name attributes descriptor ()Ljava/util/stream/Stream; flags 401 signature ()Ljava/util/stream/Stream<Ljava/lang/String;>;
+method name bitOffset descriptor ([Ljdk/incubator/foreign/MemoryLayout$PathElement;)J flags 81
+method name byteOffset descriptor ([Ljdk/incubator/foreign/MemoryLayout$PathElement;)J flags 81
+method name isPadding descriptor ()Z flags 401
+
+class name jdk/incubator/foreign/MemorySegment
+field name READ descriptor I constantValue 1 flags 19
+field name WRITE descriptor I constantValue 2 flags 19
+field name CLOSE descriptor I constantValue 4 flags 19
+field name ACQUIRE descriptor I constantValue 8 flags 19
+field name HANDOFF descriptor I constantValue 16 flags 19
+field name ALL_ACCESS descriptor I constantValue 31 flags 19
+-method name acquire descriptor ()Ljdk/incubator/foreign/MemorySegment;
+-method name asReadOnly descriptor ()Ljdk/incubator/foreign/MemorySegment;
+-method name isReadOnly descriptor ()Z
+-method name mapFromPath descriptor (Ljava/nio/file/Path;JLjava/nio/channels/FileChannel$MapMode;)Ljdk/incubator/foreign/MemorySegment;
+method name spliterator descriptor (Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/SequenceLayout;)Ljava/util/Spliterator; flags 9 signature <S::Ljdk/incubator/foreign/MemorySegment;>(TS;Ljdk/incubator/foreign/SequenceLayout;)Ljava/util/Spliterator<TS;>;
+method name withOwnerThread descriptor (Ljava/lang/Thread;)Ljdk/incubator/foreign/MemorySegment; flags 401
+method name withAccessModes descriptor (I)Ljdk/incubator/foreign/MemorySegment; flags 401
+method name hasAccessModes descriptor (I)Z flags 401
+method name accessModes descriptor ()I flags 401
+method name fill descriptor (B)Ljdk/incubator/foreign/MemorySegment; flags 401
+method name copyFrom descriptor (Ljdk/incubator/foreign/MemorySegment;)V flags 401
+method name mismatch descriptor (Ljdk/incubator/foreign/MemorySegment;)J flags 401
+method name mapFromPath descriptor (Ljava/nio/file/Path;JJLjava/nio/channels/FileChannel$MapMode;)Ljdk/incubator/foreign/MappedMemorySegment; thrownTypes java/io/IOException flags 9
+method name ofNativeRestricted descriptor (Ljdk/incubator/foreign/MemoryAddress;JLjava/lang/Thread;Ljava/lang/Runnable;Ljava/lang/Object;)Ljdk/incubator/foreign/MemorySegment; flags 9
+
+class name jdk/incubator/foreign/SequenceLayout
+header extends jdk/incubator/foreign/AbstractLayout flags 31
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup outerClass java/lang/invoke/MethodHandles innerClassName Lookup flags 19
+method name reshape descriptor ([J)Ljdk/incubator/foreign/SequenceLayout; flags 81
+method name flatten descriptor ()Ljdk/incubator/foreign/SequenceLayout; flags 1
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/SequenceLayout; flags 1
+method name isPadding descriptor ()Z flags 1041
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/AbstractLayout; flags 1041
+method name attributes descriptor ()Ljava/util/stream/Stream; flags 1041
+method name attribute descriptor (Ljava/lang/String;)Ljava/util/Optional; flags 1041
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/MemoryLayout; flags 1041
+
+class name jdk/incubator/foreign/ValueLayout
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/ValueLayout; flags 1
+method name isPadding descriptor ()Z flags 1041
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/AbstractLayout; flags 1041
+method name attributes descriptor ()Ljava/util/stream/Stream; flags 1041
+method name attribute descriptor (Ljava/lang/String;)Ljava/util/Optional; flags 1041
+method name withAttribute descriptor (Ljava/lang/String;Ljava/lang/constant/Constable;)Ljdk/incubator/foreign/MemoryLayout; flags 1041
+
diff a/make/data/symbols/jdk.jartool-F.sym.txt b/make/data/symbols/jdk.jartool-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/jdk.jartool-F.sym.txt
@@ -0,0 +1,34 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name com/sun/jarsigner/ContentSigner
+header extends java/lang/Object flags 421 deprecated true runtimeAnnotations @Ljava/lang/Deprecated;(forRemoval=Ztrue,since="9")
+
+class name com/sun/jarsigner/ContentSignerParameters
+header extends java/lang/Object flags 601 deprecated true runtimeAnnotations @Ljava/lang/Deprecated;(forRemoval=Ztrue,since="9")
+
diff a/make/data/symbols/jdk.javadoc-F.sym.txt b/make/data/symbols/jdk.javadoc-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/jdk.javadoc-F.sym.txt
@@ -0,0 +1,35 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name jdk/javadoc/doclet/StandardDoclet
+-method name getSupportedOptions descriptor ()Ljava/util/Set;
+method name getSupportedOptions descriptor ()Ljava/util/Set; flags 1 signature ()Ljava/util/Set<+Ljdk/javadoc/doclet/Doclet$Option;>;
+
+class name jdk/javadoc/doclet/Taglet
+method name isBlockTag descriptor ()Z flags 1
+
diff a/make/data/symbols/jdk.net-F.sym.txt b/make/data/symbols/jdk.net-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/jdk.net-F.sym.txt
@@ -0,0 +1,31 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name jdk/net/ExtendedSocketOptions
+field name SO_INCOMING_NAPI_ID descriptor Ljava/net/SocketOption; flags 19 signature Ljava/net/SocketOption<Ljava/lang/Integer;>;
+
diff a/make/data/symbols/jdk.nio.mapmode-F.sym.txt b/make/data/symbols/jdk.nio.mapmode-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/jdk.nio.mapmode-F.sym.txt
@@ -0,0 +1,37 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+module name jdk.nio.mapmode
+header exports jdk/nio/mapmode requires name\u0020;java.base\u0020;flags\u0020;8000 target linux-amd64 flags 8000
+
+class name jdk/nio/mapmode/ExtendedMapMode
+header extends java/lang/Object flags 21
+innerclass innerClass java/nio/channels/FileChannel$MapMode outerClass java/nio/channels/FileChannel innerClassName MapMode flags 9
+field name READ_ONLY_SYNC descriptor Ljava/nio/channels/FileChannel$MapMode; flags 19
+field name READ_WRITE_SYNC descriptor Ljava/nio/channels/FileChannel$MapMode; flags 19
+
diff a/make/data/symbols/jdk.rmic-F.sym.txt b/make/data/symbols/jdk.rmic-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/jdk.rmic-F.sym.txt
@@ -0,0 +1,30 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+-module name jdk.rmic
+
diff a/make/data/symbols/jdk.scripting.nashorn-F.sym.txt b/make/data/symbols/jdk.scripting.nashorn-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/jdk.scripting.nashorn-F.sym.txt
@@ -0,0 +1,180 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+-module name jdk.scripting.nashorn
+
+-class name jdk/nashorn/api/scripting/AbstractJSObject
+
+-class name jdk/nashorn/api/scripting/ClassFilter
+
+-class name jdk/nashorn/api/scripting/JSObject
+
+-class name jdk/nashorn/api/scripting/NashornException
+
+-class name jdk/nashorn/api/scripting/NashornScriptEngine
+
+-class name jdk/nashorn/api/scripting/NashornScriptEngineFactory
+
+-class name jdk/nashorn/api/scripting/ScriptObjectMirror
+
+-class name jdk/nashorn/api/scripting/ScriptUtils
+
+-class name jdk/nashorn/api/scripting/URLReader
+
+-class name jdk/nashorn/api/tree/ArrayAccessTree
+
+-class name jdk/nashorn/api/tree/ArrayLiteralTree
+
+-class name jdk/nashorn/api/tree/AssignmentTree
+
+-class name jdk/nashorn/api/tree/BinaryTree
+
+-class name jdk/nashorn/api/tree/BlockTree
+
+-class name jdk/nashorn/api/tree/BreakTree
+
+-class name jdk/nashorn/api/tree/CaseTree
+
+-class name jdk/nashorn/api/tree/CatchTree
+
+-class name jdk/nashorn/api/tree/ClassDeclarationTree
+
+-class name jdk/nashorn/api/tree/ClassExpressionTree
+
+-class name jdk/nashorn/api/tree/CompilationUnitTree
+
+-class name jdk/nashorn/api/tree/CompoundAssignmentTree
+
+-class name jdk/nashorn/api/tree/ConditionalExpressionTree
+
+-class name jdk/nashorn/api/tree/ConditionalLoopTree
+
+-class name jdk/nashorn/api/tree/ContinueTree
+
+-class name jdk/nashorn/api/tree/DebuggerTree
+
+-class name jdk/nashorn/api/tree/Diagnostic
+
+-class name jdk/nashorn/api/tree/Diagnostic$Kind
+
+-class name jdk/nashorn/api/tree/DiagnosticListener
+
+-class name jdk/nashorn/api/tree/DoWhileLoopTree
+
+-class name jdk/nashorn/api/tree/EmptyStatementTree
+
+-class name jdk/nashorn/api/tree/ErroneousTree
+
+-class name jdk/nashorn/api/tree/ExportEntryTree
+
+-class name jdk/nashorn/api/tree/ExpressionStatementTree
+
+-class name jdk/nashorn/api/tree/ExpressionTree
+
+-class name jdk/nashorn/api/tree/ForInLoopTree
+
+-class name jdk/nashorn/api/tree/ForLoopTree
+
+-class name jdk/nashorn/api/tree/ForOfLoopTree
+
+-class name jdk/nashorn/api/tree/FunctionCallTree
+
+-class name jdk/nashorn/api/tree/FunctionDeclarationTree
+
+-class name jdk/nashorn/api/tree/FunctionExpressionTree
+
+-class name jdk/nashorn/api/tree/GotoTree
+
+-class name jdk/nashorn/api/tree/IdentifierTree
+
+-class name jdk/nashorn/api/tree/IfTree
+
+-class name jdk/nashorn/api/tree/ImportEntryTree
+
+-class name jdk/nashorn/api/tree/InstanceOfTree
+
+-class name jdk/nashorn/api/tree/LabeledStatementTree
+
+-class name jdk/nashorn/api/tree/LineMap
+
+-class name jdk/nashorn/api/tree/LiteralTree
+
+-class name jdk/nashorn/api/tree/LoopTree
+
+-class name jdk/nashorn/api/tree/MemberSelectTree
+
+-class name jdk/nashorn/api/tree/ModuleTree
+
+-class name jdk/nashorn/api/tree/NewTree
+
+-class name jdk/nashorn/api/tree/ObjectLiteralTree
+
+-class name jdk/nashorn/api/tree/ParenthesizedTree
+
+-class name jdk/nashorn/api/tree/Parser
+
+-class name jdk/nashorn/api/tree/PropertyTree
+
+-class name jdk/nashorn/api/tree/RegExpLiteralTree
+
+-class name jdk/nashorn/api/tree/ReturnTree
+
+-class name jdk/nashorn/api/tree/SimpleTreeVisitorES5_1
+
+-class name jdk/nashorn/api/tree/SimpleTreeVisitorES6
+
+-class name jdk/nashorn/api/tree/SpreadTree
+
+-class name jdk/nashorn/api/tree/StatementTree
+
+-class name jdk/nashorn/api/tree/SwitchTree
+
+-class name jdk/nashorn/api/tree/TemplateLiteralTree
+
+-class name jdk/nashorn/api/tree/ThrowTree
+
+-class name jdk/nashorn/api/tree/Tree
+
+-class name jdk/nashorn/api/tree/Tree$Kind
+
+-class name jdk/nashorn/api/tree/TreeVisitor
+
+-class name jdk/nashorn/api/tree/TryTree
+
+-class name jdk/nashorn/api/tree/UnaryTree
+
+-class name jdk/nashorn/api/tree/UnknownTreeException
+
+-class name jdk/nashorn/api/tree/VariableTree
+
+-class name jdk/nashorn/api/tree/WhileLoopTree
+
+-class name jdk/nashorn/api/tree/WithTree
+
+-class name jdk/nashorn/api/tree/YieldTree
+
diff a/make/data/symbols/jdk.unsupported-F.sym.txt b/make/data/symbols/jdk.unsupported-F.sym.txt
--- /dev/null
+++ b/make/data/symbols/jdk.unsupported-F.sym.txt
@@ -0,0 +1,34 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# ##########################################################
+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###
+# ##########################################################
+#
+class name sun/misc/Unsafe
+header extends java/lang/Object flags 31 classAnnotations @Lsun/Proprietary+Annotation;
+innerclass innerClass java/lang/invoke/MethodHandles$Lookup outerClass java/lang/invoke/MethodHandles innerClassName Lookup flags 19
+-method name defineAnonymousClass descriptor (Ljava/lang/Class;[B[Ljava/lang/Object;)Ljava/lang/Class;
+method name defineAnonymousClass descriptor (Ljava/lang/Class;[B[Ljava/lang/Object;)Ljava/lang/Class; flags 1 deprecated true signature (Ljava/lang/Class<*>;[B[Ljava/lang/Object;)Ljava/lang/Class<*>; runtimeAnnotations @Ljdk/internal/vm/annotation/ForceInline;@Ljava/lang/Deprecated;(forRemoval=Zfalse,since="15")
+
diff a/make/data/symbols/symbols b/make/data/symbols/symbols
--- a/make/data/symbols/symbols
+++ b/make/data/symbols/symbols
@@ -27,14 +27,15 @@
 # ##########################################################
 #
 #command used to generate this file:
 #build.tools.symbolgenerator.CreateSymbols build-description-incremental symbols include.list
 #
-generate platforms 7:8:9:A:B:C:D:E
+generate platforms 7:8:9:A:B:C:D:E:F
 platform version 8 files java.activation-8.sym.txt:java.base-8.sym.txt:java.compiler-8.sym.txt:java.corba-8.sym.txt:java.datatransfer-8.sym.txt:java.desktop-8.sym.txt:java.instrument-8.sym.txt:java.logging-8.sym.txt:java.management-8.sym.txt:java.management.rmi-8.sym.txt:java.naming-8.sym.txt:java.prefs-8.sym.txt:java.rmi-8.sym.txt:java.scripting-8.sym.txt:java.security.jgss-8.sym.txt:java.security.sasl-8.sym.txt:java.sql-8.sym.txt:java.sql.rowset-8.sym.txt:java.transaction-8.sym.txt:java.xml-8.sym.txt:java.xml.bind-8.sym.txt:java.xml.crypto-8.sym.txt:java.xml.ws-8.sym.txt:java.xml.ws.annotation-8.sym.txt:jdk.httpserver-8.sym.txt:jdk.management-8.sym.txt:jdk.scripting.nashorn-8.sym.txt:jdk.sctp-8.sym.txt:jdk.security.auth-8.sym.txt:jdk.security.jgss-8.sym.txt
 platform version 7 base 8 files java.base-7.sym.txt:java.compiler-7.sym.txt:java.datatransfer-7.sym.txt:java.desktop-7.sym.txt:java.logging-7.sym.txt:java.management-7.sym.txt:java.naming-7.sym.txt:java.prefs-7.sym.txt:java.rmi-7.sym.txt:java.scripting-7.sym.txt:java.security.jgss-7.sym.txt:java.security.sasl-7.sym.txt:java.sql-7.sym.txt:java.sql.rowset-7.sym.txt:java.xml-7.sym.txt:java.xml.bind-7.sym.txt:java.xml.ws.annotation-7.sym.txt:jdk.httpserver-7.sym.txt:jdk.management-7.sym.txt:jdk.scripting.nashorn-7.sym.txt:jdk.sctp-7.sym.txt:jdk.security.auth-7.sym.txt:jdk.security.jgss-7.sym.txt
 platform version 9 base 8 files java.activation-9.sym.txt:java.base-9.sym.txt:java.compiler-9.sym.txt:java.corba-9.sym.txt:java.datatransfer-9.sym.txt:java.desktop-9.sym.txt:java.instrument-9.sym.txt:java.logging-9.sym.txt:java.management-9.sym.txt:java.management.rmi-9.sym.txt:java.naming-9.sym.txt:java.prefs-9.sym.txt:java.rmi-9.sym.txt:java.scripting-9.sym.txt:java.se-9.sym.txt:java.se.ee-9.sym.txt:java.security.jgss-9.sym.txt:java.security.sasl-9.sym.txt:java.smartcardio-9.sym.txt:java.sql-9.sym.txt:java.sql.rowset-9.sym.txt:java.transaction-9.sym.txt:java.xml-9.sym.txt:java.xml.bind-9.sym.txt:java.xml.crypto-9.sym.txt:java.xml.ws-9.sym.txt:java.xml.ws.annotation-9.sym.txt:jdk.accessibility-9.sym.txt:jdk.attach-9.sym.txt:jdk.charsets-9.sym.txt:jdk.compiler-9.sym.txt:jdk.crypto.cryptoki-9.sym.txt:jdk.crypto.ec-9.sym.txt:jdk.dynalink-9.sym.txt:jdk.editpad-9.sym.txt:jdk.hotspot.agent-9.sym.txt:jdk.httpserver-9.sym.txt:jdk.incubator.httpclient-9.sym.txt:jdk.jartool-9.sym.txt:jdk.javadoc-9.sym.txt:jdk.jcmd-9.sym.txt:jdk.jconsole-9.sym.txt:jdk.jdeps-9.sym.txt:jdk.jdi-9.sym.txt:jdk.jdwp.agent-9.sym.txt:jdk.jlink-9.sym.txt:jdk.jshell-9.sym.txt:jdk.jsobject-9.sym.txt:jdk.jstatd-9.sym.txt:jdk.localedata-9.sym.txt:jdk.management-9.sym.txt:jdk.management.agent-9.sym.txt:jdk.naming.dns-9.sym.txt:jdk.naming.rmi-9.sym.txt:jdk.net-9.sym.txt:jdk.pack-9.sym.txt:jdk.policytool-9.sym.txt:jdk.rmic-9.sym.txt:jdk.scripting.nashorn-9.sym.txt:jdk.sctp-9.sym.txt:jdk.security.auth-9.sym.txt:jdk.security.jgss-9.sym.txt:jdk.unsupported-9.sym.txt:jdk.xml.dom-9.sym.txt:jdk.zipfs-9.sym.txt
 platform version A base 9 files java.activation-A.sym.txt:java.base-A.sym.txt:java.compiler-A.sym.txt:java.corba-A.sym.txt:java.datatransfer-A.sym.txt:java.desktop-A.sym.txt:java.instrument-A.sym.txt:java.logging-A.sym.txt:java.management-A.sym.txt:java.management.rmi-A.sym.txt:java.naming-A.sym.txt:java.prefs-A.sym.txt:java.rmi-A.sym.txt:java.scripting-A.sym.txt:java.se-A.sym.txt:java.se.ee-A.sym.txt:java.security.jgss-A.sym.txt:java.security.sasl-A.sym.txt:java.smartcardio-A.sym.txt:java.sql-A.sym.txt:java.sql.rowset-A.sym.txt:java.transaction-A.sym.txt:java.xml-A.sym.txt:java.xml.bind-A.sym.txt:java.xml.crypto-A.sym.txt:java.xml.ws-A.sym.txt:java.xml.ws.annotation-A.sym.txt:jdk.accessibility-A.sym.txt:jdk.attach-A.sym.txt:jdk.charsets-A.sym.txt:jdk.compiler-A.sym.txt:jdk.crypto.cryptoki-A.sym.txt:jdk.crypto.ec-A.sym.txt:jdk.dynalink-A.sym.txt:jdk.editpad-A.sym.txt:jdk.hotspot.agent-A.sym.txt:jdk.httpserver-A.sym.txt:jdk.incubator.httpclient-A.sym.txt:jdk.jartool-A.sym.txt:jdk.javadoc-A.sym.txt:jdk.jcmd-A.sym.txt:jdk.jconsole-A.sym.txt:jdk.jdeps-A.sym.txt:jdk.jdi-A.sym.txt:jdk.jdwp.agent-A.sym.txt:jdk.jlink-A.sym.txt:jdk.jshell-A.sym.txt:jdk.jsobject-A.sym.txt:jdk.jstatd-A.sym.txt:jdk.localedata-A.sym.txt:jdk.management-A.sym.txt:jdk.management.agent-A.sym.txt:jdk.naming.dns-A.sym.txt:jdk.naming.rmi-A.sym.txt:jdk.net-A.sym.txt:jdk.pack-A.sym.txt:jdk.policytool-A.sym.txt:jdk.rmic-A.sym.txt:jdk.scripting.nashorn-A.sym.txt:jdk.sctp-A.sym.txt:jdk.security.auth-A.sym.txt:jdk.security.jgss-A.sym.txt:jdk.unsupported-A.sym.txt:jdk.xml.dom-A.sym.txt:jdk.zipfs-A.sym.txt
 platform version B base A files java.activation-B.sym.txt:java.base-B.sym.txt:java.compiler-B.sym.txt:java.corba-B.sym.txt:java.datatransfer-B.sym.txt:java.desktop-B.sym.txt:java.instrument-B.sym.txt:java.logging-B.sym.txt:java.management-B.sym.txt:java.management.rmi-B.sym.txt:java.naming-B.sym.txt:java.net.http-B.sym.txt:java.prefs-B.sym.txt:java.rmi-B.sym.txt:java.scripting-B.sym.txt:java.se-B.sym.txt:java.se.ee-B.sym.txt:java.security.jgss-B.sym.txt:java.security.sasl-B.sym.txt:java.smartcardio-B.sym.txt:java.sql-B.sym.txt:java.sql.rowset-B.sym.txt:java.transaction-B.sym.txt:java.transaction.xa-B.sym.txt:java.xml-B.sym.txt:java.xml.bind-B.sym.txt:java.xml.crypto-B.sym.txt:java.xml.ws-B.sym.txt:java.xml.ws.annotation-B.sym.txt:jdk.accessibility-B.sym.txt:jdk.attach-B.sym.txt:jdk.charsets-B.sym.txt:jdk.compiler-B.sym.txt:jdk.crypto.cryptoki-B.sym.txt:jdk.crypto.ec-B.sym.txt:jdk.dynalink-B.sym.txt:jdk.editpad-B.sym.txt:jdk.hotspot.agent-B.sym.txt:jdk.httpserver-B.sym.txt:jdk.incubator.httpclient-B.sym.txt:jdk.jartool-B.sym.txt:jdk.javadoc-B.sym.txt:jdk.jcmd-B.sym.txt:jdk.jconsole-B.sym.txt:jdk.jdeps-B.sym.txt:jdk.jdi-B.sym.txt:jdk.jdwp.agent-B.sym.txt:jdk.jfr-B.sym.txt:jdk.jlink-B.sym.txt:jdk.jshell-B.sym.txt:jdk.jsobject-B.sym.txt:jdk.jstatd-B.sym.txt:jdk.localedata-B.sym.txt:jdk.management-B.sym.txt:jdk.management.agent-B.sym.txt:jdk.management.jfr-B.sym.txt:jdk.naming.dns-B.sym.txt:jdk.naming.rmi-B.sym.txt:jdk.net-B.sym.txt:jdk.pack-B.sym.txt:jdk.rmic-B.sym.txt:jdk.scripting.nashorn-B.sym.txt:jdk.sctp-B.sym.txt:jdk.security.auth-B.sym.txt:jdk.security.jgss-B.sym.txt:jdk.unsupported-B.sym.txt:jdk.xml.dom-B.sym.txt:jdk.zipfs-B.sym.txt
 platform version C base B files java.base-C.sym.txt:java.compiler-C.sym.txt:java.desktop-C.sym.txt:java.naming-C.sym.txt:java.rmi-C.sym.txt:java.xml-C.sym.txt:jdk.compiler-C.sym.txt:jdk.jfr-C.sym.txt:jdk.jsobject-C.sym.txt:jdk.unsupported-C.sym.txt
 platform version D base C files java.base-D.sym.txt:java.compiler-D.sym.txt:java.desktop-D.sym.txt:java.management-D.sym.txt:java.management.rmi-D.sym.txt:java.net.http-D.sym.txt:java.security.jgss-D.sym.txt:java.xml-D.sym.txt:java.xml.crypto-D.sym.txt:jdk.compiler-D.sym.txt:jdk.httpserver-D.sym.txt:jdk.jartool-D.sym.txt:jdk.javadoc-D.sym.txt:jdk.jlink-D.sym.txt:jdk.jshell-D.sym.txt
 platform version E base D files java.base-E.sym.txt:java.compiler-E.sym.txt:java.desktop-E.sym.txt:java.xml-E.sym.txt:jdk.compiler-E.sym.txt:jdk.httpserver-E.sym.txt:jdk.incubator.foreign-E.sym.txt:jdk.incubator.jpackage-E.sym.txt:jdk.jfr-E.sym.txt:jdk.jlink-E.sym.txt:jdk.jshell-E.sym.txt:jdk.jsobject-E.sym.txt:jdk.management-E.sym.txt:jdk.net-E.sym.txt:jdk.pack-E.sym.txt
+platform version F base E files java.base-F.sym.txt:java.compiler-F.sym.txt:java.desktop-F.sym.txt:java.management.rmi-F.sym.txt:java.naming-F.sym.txt:java.xml-F.sym.txt:jdk.compiler-F.sym.txt:jdk.incubator.foreign-F.sym.txt:jdk.jartool-F.sym.txt:jdk.javadoc-F.sym.txt:jdk.net-F.sym.txt:jdk.nio.mapmode-F.sym.txt:jdk.rmic-F.sym.txt:jdk.scripting.nashorn-F.sym.txt:jdk.unsupported-F.sym.txt
diff a/src/hotspot/share/ci/ciEnv.cpp b/src/hotspot/share/ci/ciEnv.cpp
--- a/src/hotspot/share/ci/ciEnv.cpp
+++ b/src/hotspot/share/ci/ciEnv.cpp
@@ -40,10 +40,11 @@
 #include "code/codeCache.hpp"
 #include "code/scopeDesc.hpp"
 #include "compiler/compileBroker.hpp"
 #include "compiler/compilerEvent.hpp"
 #include "compiler/compileLog.hpp"
+#include "compiler/compileTask.hpp"
 #include "compiler/disassembler.hpp"
 #include "gc/shared/collectedHeap.inline.hpp"
 #include "interpreter/linkResolver.hpp"
 #include "jfr/jfrEvents.hpp"
 #include "logging/log.hpp"
@@ -229,20 +230,21 @@
   )
 }
 
 // ------------------------------------------------------------------
 // Cache Jvmti state
-void ciEnv::cache_jvmti_state() {
+bool ciEnv::cache_jvmti_state() {
   VM_ENTRY_MARK;
   // Get Jvmti capabilities under lock to get consistant values.
   MutexLocker mu(JvmtiThreadState_lock);
   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();
   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint();
   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables();
   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions();
   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame();
   _jvmti_can_get_owned_monitor_info     = JvmtiExport::can_get_owned_monitor_info();
+  return _task != NULL && _task->method()->is_old();
 }
 
 bool ciEnv::jvmti_state_changed() const {
   // Some classes were redefined
   if (_jvmti_redefinition_count != JvmtiExport::redefinition_count()) {
diff a/src/hotspot/share/ci/ciEnv.hpp b/src/hotspot/share/ci/ciEnv.hpp
--- a/src/hotspot/share/ci/ciEnv.hpp
+++ b/src/hotspot/share/ci/ciEnv.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -345,11 +345,11 @@
 
   bool break_at_compile() { return _break_at_compile; }
   void set_break_at_compile(bool z) { _break_at_compile = z; }
 
   // Cache Jvmti state
-  void  cache_jvmti_state();
+  bool  cache_jvmti_state();
   bool  jvmti_state_changed() const;
   bool  should_retain_local_variables() const {
     return _jvmti_can_access_local_variables || _jvmti_can_pop_frame;
   }
   bool  jvmti_can_hotswap_or_post_breakpoint() const { return _jvmti_can_hotswap_or_post_breakpoint; }
diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -133,11 +133,13 @@
 
 #define JAVA_14_VERSION                   58
 
 #define JAVA_15_VERSION                   59
 
-#define CONSTANT_CLASS_DESCRIPTORS        59
+#define JAVA_16_VERSION                   60
+
+#define CONSTANT_CLASS_DESCRIPTORS        60
 
 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
   assert((bad_constant == JVM_CONSTANT_Module ||
           bad_constant == JVM_CONSTANT_Package) && _major_version >= JAVA_9_VERSION,
          "Unexpected bad constant pool entry");
diff a/src/hotspot/share/classfile/classLoader.cpp b/src/hotspot/share/classfile/classLoader.cpp
--- a/src/hotspot/share/classfile/classLoader.cpp
+++ b/src/hotspot/share/classfile/classLoader.cpp
@@ -1526,10 +1526,23 @@
   if (Arguments::is_dumping_archive()) {
     ClassLoaderExt::setup_module_paths(THREAD);
     FileMapInfo::allocate_shared_path_table();
   }
 }
+
+// Helper function used by CDS code to get the number of module path
+// entries during shared classpath setup time.
+int ClassLoader::num_module_path_entries() {
+  Arguments::assert_is_dumping_archive();
+  int num_entries = 0;
+  ClassPathEntry* e= ClassLoader::_module_path_entries;
+  while (e != NULL) {
+    num_entries ++;
+    e = e->next();
+  }
+  return num_entries;
+}
 #endif
 
 jlong ClassLoader::classloader_time_ms() {
   return UsePerfData ?
     Management::ticks_to_ms(_perf_accumulated_time->get_value()) : -1;
diff a/src/hotspot/share/classfile/classLoader.hpp b/src/hotspot/share/classfile/classLoader.hpp
--- a/src/hotspot/share/classfile/classLoader.hpp
+++ b/src/hotspot/share/classfile/classLoader.hpp
@@ -386,20 +386,11 @@
   // entries during shared classpath setup time.
   static int num_app_classpath_entries();
 
   // Helper function used by CDS code to get the number of module path
   // entries during shared classpath setup time.
-  static int num_module_path_entries() {
-    Arguments::assert_is_dumping_archive();
-    int num_entries = 0;
-    ClassPathEntry* e= ClassLoader::_module_path_entries;
-    while (e != NULL) {
-      num_entries ++;
-      e = e->next();
-    }
-    return num_entries;
-  }
+  static int num_module_path_entries();
   static void  exit_with_path_failure(const char* error, const char* message);
   static char* skip_uri_protocol(char* source);
   static void  record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS);
 #endif
 
diff a/src/hotspot/share/classfile/systemDictionary.cpp b/src/hotspot/share/classfile/systemDictionary.cpp
--- a/src/hotspot/share/classfile/systemDictionary.cpp
+++ b/src/hotspot/share/classfile/systemDictionary.cpp
@@ -1277,10 +1277,11 @@
 // Load a class for boot loader from the shared spaces. This also
 // forces the super class and all interfaces to be loaded.
 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
                                                         PackageEntry* pkg_entry,
                                                         TRAPS) {
+  assert(UseSharedSpaces, "Sanity check");
   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
   if (ik != NULL && ik->is_shared_boot_class()) {
     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);
   }
   return NULL;
@@ -1296,22 +1297,34 @@
                                                InstanceKlass* ik,
                                                PackageEntry* pkg_entry,
                                                Handle class_loader, TRAPS) {
   assert(!ModuleEntryTable::javabase_moduleEntry()->is_patched(),
          "Cannot use sharing if java.base is patched");
-  ResourceMark rm(THREAD);
-  int path_index = ik->shared_classpath_index();
-  ClassLoaderData* loader_data = class_loader_data(class_loader);
-  if (path_index < 0) {
+  if (ik->shared_classpath_index() < 0) {
     // path_index < 0 indicates that the class is intended for a custom loader
     // and should not be loaded by boot/platform/app loaders
-    if (loader_data->is_builtin_class_loader_data()) {
+    if (is_builtin_class_loader(class_loader())) {
       return false;
     } else {
       return true;
     }
   }
+
+  // skip class visibility check
+  if (MetaspaceShared::use_optimized_module_handling()) {
+    assert(SystemDictionary::is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD), "Optimizing module handling failed.");
+    return true;
+  }
+  return is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD);
+}
+
+bool SystemDictionary::is_shared_class_visible_impl(Symbol* class_name,
+                                               InstanceKlass* ik,
+                                               PackageEntry* pkg_entry,
+                                               Handle class_loader, TRAPS) {
+  int path_index = ik->shared_classpath_index();
+  ClassLoaderData* loader_data = class_loader_data(class_loader);
   SharedClassPathEntry* ent =
             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
   if (!Universe::is_module_initialized()) {
     assert(ent != NULL && ent->is_modules_image(),
            "Loading non-bootstrap classes before the module system is initialized");
@@ -1641,16 +1654,18 @@
            !search_only_bootloader_append,
            "Attempt to load a class outside of boot loader's module path");
 
     // Search for classes in the CDS archive.
     InstanceKlass* k = NULL;
-    {
+
 #if INCLUDE_CDS
+    if (UseSharedSpaces)
+    {
       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
       k = load_shared_boot_class(class_name, pkg_entry, THREAD);
-#endif
     }
+#endif
 
     if (k == NULL) {
       // Use VM class loader
       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
diff a/src/hotspot/share/classfile/systemDictionary.hpp b/src/hotspot/share/classfile/systemDictionary.hpp
--- a/src/hotspot/share/classfile/systemDictionary.hpp
+++ b/src/hotspot/share/classfile/systemDictionary.hpp
@@ -638,10 +638,14 @@
                                                 Handle class_loader,
                                                 InstanceKlass* k, TRAPS);
   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
                                       PackageEntry* pkg_entry,
                                       Handle class_loader, TRAPS);
+  static bool is_shared_class_visible_impl(Symbol* class_name,
+                                           InstanceKlass* ik,
+                                           PackageEntry* pkg_entry,
+                                           Handle class_loader, TRAPS);
   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,
                                             Handle class_loader,  Handle protection_domain,
                                             bool is_superclass, TRAPS);
   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
                                                Handle protection_domain, TRAPS);
diff a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -2147,18 +2147,18 @@
   if (UseJVMCICompiler && comp != NULL && comp->is_jvmci()) {
     JVMCICompiler* jvmci = (JVMCICompiler*) comp;
 
     TraceTime t1("compilation", &time);
     EventCompilation event;
+    JVMCICompileState compile_state(task);
 
     // Skip redefined methods
-    if (target_handle->is_old()) {
+    if (compile_state.target_method_is_old()) {
       failure_reason = "redefined method";
       retry_message = "not retryable";
       compilable = ciEnv::MethodCompilable_never;
     } else {
-      JVMCICompileState compile_state(task);
       JVMCIEnv env(thread, &compile_state, __FILE__, __LINE__);
       methodHandle method(thread, target_handle);
       env.runtime()->compile_method(&env, jvmci, method, osr_bci);
 
       failure_reason = compile_state.failure_reason();
@@ -2191,11 +2191,16 @@
     }
     assert(thread->env() == &ci_env, "set by ci_env");
     // The thread-env() field is cleared in ~CompileTaskWrapper.
 
     // Cache Jvmti state
-    ci_env.cache_jvmti_state();
+    bool method_is_old = ci_env.cache_jvmti_state();
+
+    // Skip redefined methods
+    if (method_is_old) {
+      ci_env.record_method_not_compilable("redefined method", true);
+    }
 
     // Cache DTrace flags
     ci_env.cache_dtrace_flags();
 
     ciMethod* target = ci_env.get_method_from_handle(target_handle);
@@ -2203,11 +2208,11 @@
     TraceTime t1("compilation", &time);
     EventCompilation event;
 
     if (comp == NULL) {
       ci_env.record_method_not_compilable("no compiler", !TieredCompilation);
-    } else {
+    } else if (!ci_env.failing()) {
       if (WhiteBoxAPI && WhiteBox::compilation_locked) {
         MonitorLocker locker(Compilation_lock, Mutex::_no_safepoint_check_flag);
         while (WhiteBox::compilation_locked) {
           locker.wait();
         }
diff a/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp b/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
@@ -48,16 +48,12 @@
  *
  * For concurrent evac and update-refs, we are walking the heap per-region, and so the
  * notion of progress is clear: we get reported the "used" size from the processed regions
  * and use the global heap-used as the baseline.
  *
- * The allocatable space when GC is running is "free" at the start of cycle, but the
+ * The allocatable space when GC is running is "free" at the start of phase, but the
  * accounted budget is based on "used". So, we need to adjust the tax knowing that.
- * Also, since we effectively count the used space three times (mark, evac, update-refs),
- * we need to multiply the tax by 3. Example: for 10 MB free and 90 MB used, GC would
- * come back with 3*90 MB budget, and thus for each 1 MB of allocation, we have to pay
- * 3*90 / 10 MBs. In the end, we would pay back the entire budget.
  */
 
 void ShenandoahPacer::setup_for_mark() {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
@@ -66,11 +62,11 @@
 
   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
   size_t taxable = free - non_taxable;
 
   double tax = 1.0 * live / taxable; // base tax for available free space
-  tax *= 3;                          // mark is phase 1 of 3, claim 1/3 of free for it
+  tax *= 1;                          // mark can succeed with immediate garbage, claim all available space
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
   log_info(gc, ergo)("Pacer for Mark. Expected Live: " SIZE_FORMAT "%s, Free: " SIZE_FORMAT "%s, "
@@ -89,11 +85,11 @@
 
   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
   size_t taxable = free - non_taxable;
 
   double tax = 1.0 * used / taxable; // base tax for available free space
-  tax *= 2;                          // evac is phase 2 of 3, claim 1/2 of remaining free
+  tax *= 2;                          // evac is followed by update-refs, claim 1/2 of remaining free
   tax = MAX2<double>(1, tax);        // never allocate more than GC processes during the phase
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
@@ -113,11 +109,11 @@
 
   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
   size_t taxable = free - non_taxable;
 
   double tax = 1.0 * used / taxable; // base tax for available free space
-  tax *= 1;                          // update-refs is phase 3 of 3, claim the remaining free
+  tax *= 1;                          // update-refs is the last phase, claim the remaining free
   tax = MAX2<double>(1, tax);        // never allocate more than GC processes during the phase
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
@@ -193,10 +189,13 @@
   size_t initial = (size_t)(non_taxable_bytes * tax_rate) >> LogHeapWordSize;
   STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));
   Atomic::xchg(&_budget, (intptr_t)initial);
   Atomic::store(&_tax_rate, tax_rate);
   Atomic::inc(&_epoch);
+
+  // Shake up stalled waiters after budget update.
+  notify_waiters();
 }
 
 bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
@@ -233,60 +232,49 @@
 
 void ShenandoahPacer::pace_for_alloc(size_t words) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
   // Fast path: try to allocate right away
-  if (claim_for_alloc(words, false)) {
+  bool claimed = claim_for_alloc(words, false);
+  if (claimed) {
     return;
   }
 
+  // Forcefully claim the budget: it may go negative at this point, and
+  // GC should replenish for this and subsequent allocations. After this claim,
+  // we would wait a bit until our claim is matched by additional progress,
+  // or the time budget depletes.
+  claimed = claim_for_alloc(words, true);
+  assert(claimed, "Should always succeed");
+
   // Threads that are attaching should not block at all: they are not
   // fully initialized yet. Blocking them would be awkward.
   // This is probably the path that allocates the thread oop itself.
-  // Forcefully claim without waiting.
   if (JavaThread::current()->is_attaching_via_jni()) {
-    claim_for_alloc(words, true);
     return;
   }
 
-  size_t max = ShenandoahPacingMaxDelay;
   double start = os::elapsedTime();
 
-  size_t total = 0;
-  size_t cur = 0;
+  size_t max_ms = ShenandoahPacingMaxDelay;
+  size_t total_ms = 0;
 
   while (true) {
     // We could instead assist GC, but this would suffice for now.
-    // This code should also participate in safepointing.
-    // Perform the exponential backoff, limited by max.
-
-    cur = cur * 2;
-    if (total + cur > max) {
-      cur = (max > total) ? (max - total) : 0;
-    }
-    cur = MAX2<size_t>(1, cur);
-
-    wait(cur);
+    size_t cur_ms = (max_ms > total_ms) ? (max_ms - total_ms) : 1;
+    wait(cur_ms);
 
     double end = os::elapsedTime();
-    total = (size_t)((end - start) * 1000);
-
-    if (total > max) {
-      // Spent local time budget to wait for enough GC progress.
-      // Breaking out and allocating anyway, which may mean we outpace GC,
-      // and start Degenerated GC cycle.
-      _delays.add(total);
-
-      // Forcefully claim the budget: it may go negative at this point, and
-      // GC should replenish for this and subsequent allocations
-      claim_for_alloc(words, true);
-      break;
-    }
-
-    if (claim_for_alloc(words, false)) {
-      // Acquired enough permit, nice. Can allocate now.
-      _delays.add(total);
+    total_ms = (size_t)((end - start) * 1000);
+
+    if (total_ms > max_ms || Atomic::load(&_budget) >= 0) {
+      // Exiting if either:
+      //  a) Spent local time budget to wait for enough GC progress.
+      //     Breaking out and allocating anyway, which may mean we outpace GC,
+      //     and start Degenerated GC cycle.
+      //  b) The budget had been replenished, which means our claim is satisfied.
+      _delays.add(total_ms);
       break;
     }
   }
 }
 
diff a/src/hotspot/share/gc/shenandoah/shenandoahPacer.inline.hpp b/src/hotspot/share/gc/shenandoah/shenandoahPacer.inline.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahPacer.inline.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahPacer.inline.hpp
@@ -46,11 +46,18 @@
 }
 
 inline void ShenandoahPacer::report_internal(size_t words) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
   STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));
-  Atomic::add(&_budget, (intptr_t)words);
+  intptr_t inc = (intptr_t) words;
+  intptr_t new_budget = Atomic::add(&_budget, inc);
+
+  // Was the budget replenished beyond zero? Then all pacing claims
+  // are satisfied, notify the waiters.
+  if (new_budget >= 0 && (new_budget - inc) < 0) {
+    notify_waiters();
+  }
 }
 
 inline void ShenandoahPacer::report_progress_internal(size_t words) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
   STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));
diff a/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp b/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp
--- a/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp
+++ b/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp
@@ -721,48 +721,44 @@
   }
   remove_thread_from_exclusion_list(h_obj);
   return true;
 }
 
-jlong JfrJavaSupport::jfr_thread_id(jobject thread) {
+static JavaThread* get_native(jobject thread) {
   ThreadsListHandle tlh;
   JavaThread* native_thread = NULL;
   (void)tlh.cv_internal_thread_to_JavaThread(thread, &native_thread, NULL);
+  return native_thread;
+}
+
+jlong JfrJavaSupport::jfr_thread_id(jobject thread) {
+  JavaThread* native_thread = get_native(thread);
   return native_thread != NULL ? JFR_THREAD_ID(native_thread) : 0;
 }
 
 void JfrJavaSupport::exclude(jobject thread) {
-  HandleMark hm;
-  ThreadsListHandle tlh;
-  JavaThread* native_thread = NULL;
-  (void)tlh.cv_internal_thread_to_JavaThread(thread, &native_thread, NULL);
+  JavaThread* native_thread = get_native(thread);
   if (native_thread != NULL) {
     JfrThreadLocal::exclude(native_thread);
   } else {
     // not started yet, track the thread oop
     add_thread_to_exclusion_list(thread);
   }
 }
 
 void JfrJavaSupport::include(jobject thread) {
-  HandleMark hm;
-  ThreadsListHandle tlh;
-  JavaThread* native_thread = NULL;
-  (void)tlh.cv_internal_thread_to_JavaThread(thread, &native_thread, NULL);
+  JavaThread* native_thread = get_native(thread);
   if (native_thread != NULL) {
     JfrThreadLocal::include(native_thread);
   } else {
     // not started yet, untrack the thread oop
     remove_thread_from_exclusion_list(thread);
   }
 }
 
 bool JfrJavaSupport::is_excluded(jobject thread) {
-  HandleMark hm;
-  ThreadsListHandle tlh;
-  JavaThread* native_thread = NULL;
-  (void)tlh.cv_internal_thread_to_JavaThread(thread, &native_thread, NULL);
+  JavaThread* native_thread = get_native(thread);
   return native_thread != NULL ? native_thread->jfr_thread_local()->is_excluded() : is_thread_excluded(thread);
 }
 
 jobject JfrJavaSupport::get_handler(jobject clazz, TRAPS) {
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
diff a/src/hotspot/share/jfr/jni/jfrJniMethod.cpp b/src/hotspot/share/jfr/jni/jfrJniMethod.cpp
--- a/src/hotspot/share/jfr/jni/jfrJniMethod.cpp
+++ b/src/hotspot/share/jfr/jni/jfrJniMethod.cpp
@@ -177,10 +177,16 @@
 
 NO_TRANSITION(jboolean, jfr_should_rotate_disk(JNIEnv* env, jobject jvm))
   return JfrChunkRotation::should_rotate() ? JNI_TRUE : JNI_FALSE;
 NO_TRANSITION_END
 
+NO_TRANSITION(jlong, jfr_get_type_id_from_string(JNIEnv * env, jobject jvm, jstring type))
+  const char* type_name = env->GetStringUTFChars(type, NULL);
+  jlong id = JfrType::name_to_id(type_name);
+  env->ReleaseStringUTFChars(type, type_name);
+  return id;
+NO_TRANSITION_END
 /*
  * JVM_ENTRY_NO_ENV entries
  *
  * Transitions:
  *   Entry: _thread_in_native -> _thread_in_vm
@@ -348,13 +354,5 @@
 JVM_END
 
 JVM_ENTRY_NO_ENV(jboolean, jfr_set_handler(JNIEnv * env, jobject jvm, jobject clazz, jobject handler))
   return JfrJavaSupport::set_handler(clazz, handler, thread);
 JVM_END
-
-NO_TRANSITION(jlong, jfr_get_type_id_from_string(JNIEnv * env, jobject jvm, jstring type))
-  const char* type_name= env->GetStringUTFChars(type, NULL);
-  jlong id = JfrType::name_to_id(type_name);
-  env->ReleaseStringUTFChars(type, type_name);
-  return id;
-NO_TRANSITION_END
-
diff a/src/hotspot/share/jfr/leakprofiler/checkpoint/eventEmitter.cpp b/src/hotspot/share/jfr/leakprofiler/checkpoint/eventEmitter.cpp
--- a/src/hotspot/share/jfr/leakprofiler/checkpoint/eventEmitter.cpp
+++ b/src/hotspot/share/jfr/leakprofiler/checkpoint/eventEmitter.cpp
@@ -56,14 +56,10 @@
   assert(sampler != NULL, "invariant");
   ResourceMark rm;
   EdgeStore edge_store;
   if (cutoff_ticks <= 0) {
     // no reference chains
-    MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);
-    // The lock is needed here to prevent the recorder thread (running flush())
-    // from writing old object events out from the thread local buffer
-    // before the required constant pools have been serialized.
     JfrTicks time_stamp = JfrTicks::now();
     EventEmitter emitter(time_stamp, time_stamp);
     emitter.write_events(sampler, &edge_store, emit_all);
     return;
   }
@@ -71,32 +67,44 @@
   PathToGcRootsOperation op(sampler, &edge_store, cutoff_ticks, emit_all, skip_bfs);
   VMThread::execute(&op);
 }
 
 size_t EventEmitter::write_events(ObjectSampler* object_sampler, EdgeStore* edge_store, bool emit_all) {
-  assert_locked_or_safepoint(JfrStream_lock);
   assert(_thread == Thread::current(), "invariant");
   assert(_thread->jfr_thread_local() == _jfr_thread_local, "invariant");
   assert(object_sampler != NULL, "invariant");
   assert(edge_store != NULL, "invariant");
 
   const jlong last_sweep = emit_all ? max_jlong : object_sampler->last_sweep().value();
   size_t count = 0;
 
+  // First pass associates a live sample with its immediate edge
+  // in preparation for writing checkpoint information.
   const ObjectSample* current = object_sampler->first();
   while (current != NULL) {
     ObjectSample* prev = current->prev();
     if (current->is_alive_and_older_than(last_sweep)) {
-      write_event(current, edge_store);
+      link_sample_with_edge(current, edge_store);
       ++count;
     }
     current = prev;
   }
-
   if (count > 0) {
-    // serialize associated checkpoints and potential chains
+    // We need to serialize the associated checkpoints and potential chains
+    // before writing the events to ensure constants are available for resolution
+    // at the time old object sample events appear in the stream.
     ObjectSampleCheckpoint::write(object_sampler, edge_store, emit_all, _thread);
+
+    // Now we are ready to write the events
+    const ObjectSample* current = object_sampler->first();
+    while (current != NULL) {
+      ObjectSample* prev = current->prev();
+      if (current->is_alive_and_older_than(last_sweep)) {
+        write_event(current, edge_store);
+      }
+      current = prev;
+    }
   }
   return count;
 }
 
 static int array_size(const oop object) {
@@ -105,10 +113,26 @@
     return arrayOop(object)->length();
   }
   return min_jint;
 }
 
+void EventEmitter::link_sample_with_edge(const ObjectSample* sample, EdgeStore* edge_store) {
+  assert(sample != NULL, "invariant");
+  assert(!sample->is_dead(), "invariant");
+  assert(edge_store != NULL, "invariant");
+  if (SafepointSynchronize::is_at_safepoint()) {
+    if (!sample->object()->mark().is_marked()) {
+      // Associated with an edge (chain) already during heap traversal.
+      return;
+    }
+  }
+  // In order to dump out a representation of the event
+  // even though the sample object was found not reachable / too long to reach,
+  // we need to register a top level edge.
+  edge_store->put(UnifiedOopRef::encode_in_native(sample->object_addr()));
+}
+
 void EventEmitter::write_event(const ObjectSample* sample, EdgeStore* edge_store) {
   assert(sample != NULL, "invariant");
   assert(!sample->is_dead(), "invariant");
   assert(edge_store != NULL, "invariant");
   assert(_jfr_thread_local != NULL, "invariant");
@@ -119,18 +143,14 @@
     if (!sample->object()->mark().is_marked()) {
       edge = (const Edge*)(sample->object())->mark().to_pointer();
     }
   }
   if (edge == NULL) {
-    // In order to dump out a representation of the event
-    // even though it was not reachable / too long to reach,
-    // we need to register a top level edge for this object.
-    edge = edge_store->put(UnifiedOopRef::encode_in_native(sample->object_addr()));
+    edge = edge_store->get(UnifiedOopRef::encode_in_native(sample->object_addr()));
   } else {
     gc_root_id = edge_store->gc_root_id(edge);
   }
-
   assert(edge != NULL, "invariant");
   const traceid object_id = edge_store->get_id(edge);
   assert(object_id != 0, "invariant");
 
   Tickspan object_age = Ticks(_start_time.value()) - sample->allocation_time();
diff a/src/hotspot/share/jfr/leakprofiler/checkpoint/eventEmitter.hpp b/src/hotspot/share/jfr/leakprofiler/checkpoint/eventEmitter.hpp
--- a/src/hotspot/share/jfr/leakprofiler/checkpoint/eventEmitter.hpp
+++ b/src/hotspot/share/jfr/leakprofiler/checkpoint/eventEmitter.hpp
@@ -49,10 +49,11 @@
   EventEmitter(const JfrTicks& start_time, const JfrTicks& end_time);
   ~EventEmitter();
 
   void write_event(const ObjectSample* sample, EdgeStore* edge_store);
   size_t write_events(ObjectSampler* sampler, EdgeStore* store, bool emit_all);
+  void link_sample_with_edge(const ObjectSample* sample, EdgeStore* edge_store);
 
   static void emit(ObjectSampler* sampler, int64_t cutoff_ticks, bool emit_all, bool skip_bfs);
 };
 
 #endif // SHARE_JFR_LEAKPROFILER_CHECKPOINT_EVENTEMITTER_HPP
diff a/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp b/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp
--- a/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp
+++ b/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp
@@ -22,10 +22,11 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "jfr/jfrEvents.hpp"
+#include "jfr/jni/jfrJavaSupport.hpp"
 #include "jfr/leakprofiler/chains/edgeStore.hpp"
 #include "jfr/leakprofiler/chains/objectSampleMarker.hpp"
 #include "jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp"
 #include "jfr/leakprofiler/checkpoint/objectSampleWriter.hpp"
 #include "jfr/leakprofiler/leakProfiler.hpp"
@@ -38,14 +39,16 @@
 #include "jfr/support/jfrKlassUnloading.hpp"
 #include "jfr/support/jfrMethodLookup.hpp"
 #include "jfr/utilities/jfrHashtable.hpp"
 #include "jfr/utilities/jfrPredicate.hpp"
 #include "jfr/utilities/jfrRelation.hpp"
+#include "memory/resourceArea.inline.hpp"
 #include "oops/instanceKlass.inline.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/mutexLocker.hpp"
 #include "runtime/safepoint.hpp"
-#include "runtime/thread.hpp"
+#include "runtime/thread.inline.hpp"
 
 const int initial_array_size = 64;
 
 template <typename T>
 static GrowableArray<T>* c_heap_allocate_array(int size = initial_array_size) {
@@ -246,21 +249,24 @@
 
 static void install_stack_traces(const ObjectSampler* sampler, JfrStackTraceRepository& stack_trace_repo) {
   assert(sampler != NULL, "invariant");
   const ObjectSample* const last = sampler->last();
   if (last != sampler->last_resolved()) {
+    ResourceMark rm;
     JfrKlassUnloading::sort();
     StackTraceBlobInstaller installer(stack_trace_repo);
     iterate_samples(installer);
   }
 }
 
-// caller needs ResourceMark
 void ObjectSampleCheckpoint::on_rotation(const ObjectSampler* sampler, JfrStackTraceRepository& stack_trace_repo) {
-  assert(JfrStream_lock->owned_by_self(), "invariant");
   assert(sampler != NULL, "invariant");
   assert(LeakProfiler::is_running(), "invariant");
+  Thread* const thread = Thread::current();
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread);)
+  // can safepoint here
+  ThreadInVMfromNative transition((JavaThread*)thread);
   MutexLocker lock(ClassLoaderDataGraph_lock);
   // the lock is needed to ensure the unload lists do not grow in the middle of inspection.
   install_stack_traces(sampler, stack_trace_repo);
 }
 
@@ -363,11 +369,10 @@
   cbw.set_reset();
   iterate_samples(cbw, true);
 }
 
 void ObjectSampleCheckpoint::write(const ObjectSampler* sampler, EdgeStore* edge_store, bool emit_all, Thread* thread) {
-  assert_locked_or_safepoint(JfrStream_lock);
   assert(sampler != NULL, "invariant");
   assert(edge_store != NULL, "invariant");
   assert(thread != NULL, "invariant");
   write_sample_blobs(sampler, emit_all, thread);
   // write reference chains
@@ -414,10 +419,11 @@
   }
 }
 
 void ObjectSampleCheckpoint::on_type_set(JfrCheckpointWriter& writer) {
   assert(LeakProfiler::is_running(), "invariant");
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(Thread::current());)
   const ObjectSample* last = ObjectSampler::sampler()->last();
   if (writer.has_data() && last != NULL) {
     save_type_set_blob(writer);
     install_type_set_blobs();
     ObjectSampler::sampler()->set_last_resolved(last);
diff a/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp b/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
@@ -22,10 +22,11 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "classfile/javaClasses.inline.hpp"
+#include "jfr/jni/jfrJavaSupport.hpp"
 #include "jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp"
 #include "jfr/leakprofiler/leakProfiler.hpp"
 #include "jfr/recorder/checkpoint/jfrCheckpointManager.hpp"
 #include "jfr/recorder/checkpoint/jfrCheckpointWriter.hpp"
 #include "jfr/recorder/checkpoint/types/jfrTypeManager.hpp"
@@ -46,10 +47,11 @@
 #include "logging/log.hpp"
 #include "memory/iterator.hpp"
 #include "memory/resourceArea.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/handles.inline.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/mutex.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/safepoint.hpp"
 
 typedef JfrCheckpointManager::BufferPtr BufferPtr;
@@ -323,10 +325,11 @@
   JfrTraceIdEpoch::end_epoch_shift();
   assert(current_epoch != JfrTraceIdEpoch::current(), "invariant");
 }
 
 size_t JfrCheckpointManager::write() {
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));
   assert(_mspace->free_list_is_empty(), "invariant");
   WriteOperation wo(_chunkwriter);
   MutexedWriteOperation mwo(wo);
   ReleaseOperation ro(_mspace, _mspace->live_list(true));
   WriteReleaseOperation wro(&mwo, &ro);
@@ -355,19 +358,23 @@
   return writer.used_size();
 }
 
 size_t JfrCheckpointManager::write_threads(Thread* thread) {
   assert(thread != NULL, "invariant");
+  // can safepoint here
+  ThreadInVMfromNative transition((JavaThread*)thread);
+  ResetNoHandleMark rnhm;
+  ResourceMark rm(thread);
+  HandleMark hm(thread);
   JfrCheckpointWriter writer(true, thread, THREADS);
   JfrTypeManager::write_threads(writer);
   return writer.used_size();
 }
 
 size_t JfrCheckpointManager::write_static_type_set_and_threads() {
   Thread* const thread = Thread::current();
-  ResourceMark rm(thread);
-  HandleMark hm(thread);
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread));
   write_static_type_set(thread);
   write_threads(thread);
   return write();
 }
 
@@ -378,33 +385,39 @@
 }
 
 void JfrCheckpointManager::clear_type_set() {
   assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
   assert(!JfrRecorder::is_recording(), "invariant");
+  Thread* t = Thread::current();
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(t));
   // can safepoint here
+  ThreadInVMfromNative transition((JavaThread*)t);
+  ResetNoHandleMark rnhm;
   MutexLocker cld_lock(ClassLoaderDataGraph_lock);
   MutexLocker module_lock(Module_lock);
   JfrTypeSet::clear();
 }
 
 void JfrCheckpointManager::write_type_set() {
   assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
-  Thread* const thread = Thread::current();
-  if (LeakProfiler::is_running()) {
+  {
+    Thread* const thread = Thread::current();
+    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread));
     // can safepoint here
+    ThreadInVMfromNative transition((JavaThread*)thread);
+    ResetNoHandleMark rnhm;
     MutexLocker cld_lock(thread, ClassLoaderDataGraph_lock);
     MutexLocker module_lock(thread, Module_lock);
-    JfrCheckpointWriter leakp_writer(true, thread);
-    JfrCheckpointWriter writer(true, thread);
-    JfrTypeSet::serialize(&writer, &leakp_writer, false, false);
-    ObjectSampleCheckpoint::on_type_set(leakp_writer);
-  } else {
-    // can safepoint here
-    MutexLocker cld_lock(ClassLoaderDataGraph_lock);
-    MutexLocker module_lock(Module_lock);
-    JfrCheckpointWriter writer(true, thread);
-    JfrTypeSet::serialize(&writer, NULL, false, false);
+    if (LeakProfiler::is_running()) {
+      JfrCheckpointWriter leakp_writer(true, thread);
+      JfrCheckpointWriter writer(true, thread);
+      JfrTypeSet::serialize(&writer, &leakp_writer, false, false);
+      ObjectSampleCheckpoint::on_type_set(leakp_writer);
+    } else {
+      JfrCheckpointWriter writer(true, thread);
+      JfrTypeSet::serialize(&writer, NULL, false, false);
+    }
   }
   write();
 }
 
 void JfrCheckpointManager::on_unloading_classes() {
@@ -414,17 +427,37 @@
   if (LeakProfiler::is_running()) {
     ObjectSampleCheckpoint::on_type_set_unload(writer);
   }
 }
 
+class JavaThreadToVM : public StackObj {
+ private:
+  JavaThread* _jt;
+ public:
+  JavaThreadToVM(Thread* thread) : _jt(thread->is_Java_thread() ? (JavaThread*)thread : NULL) {
+    if (_jt != NULL) {
+      assert(_jt->thread_state() == _thread_in_native, "invariant");
+      _jt->set_thread_state(_thread_in_vm);
+    }
+  }
+  ~JavaThreadToVM() {
+    if (_jt != NULL) {
+      _jt->set_thread_state(_thread_in_native);
+    }
+  }
+};
+
 size_t JfrCheckpointManager::flush_type_set() {
   size_t elements = 0;
   if (JfrTraceIdEpoch::has_changed_tag_state()) {
-    JfrCheckpointWriter writer(Thread::current());
-    // can safepoint here
-    MutexLocker cld_lock(ClassLoaderDataGraph_lock);
-    MutexLocker module_lock(Module_lock);
+    Thread* const t = Thread::current();
+    // can safepoint here (if JavaThread)
+    JavaThreadToVM transition(t);
+    ResetNoHandleMark rnhm;
+    MutexLocker cld_lock(t, ClassLoaderDataGraph_lock);
+    MutexLocker module_lock(t, Module_lock);
+    JfrCheckpointWriter writer(t);
     elements = JfrTypeSet::serialize(&writer, NULL, false, true);
   }
   if (is_constant_pending()) {
     WriteOperation wo(_chunkwriter);
     MutexedWriteOperation mwo(wo);
diff a/src/hotspot/share/jfr/recorder/checkpoint/jfrMetadataEvent.cpp b/src/hotspot/share/jfr/recorder/checkpoint/jfrMetadataEvent.cpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/jfrMetadataEvent.cpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/jfrMetadataEvent.cpp
@@ -27,47 +27,54 @@
 #include "jfr/recorder/checkpoint/jfrMetadataEvent.hpp"
 #include "jfr/recorder/repository/jfrChunkWriter.hpp"
 #include "oops/klass.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayOop.inline.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/thread.inline.hpp"
 
 static jbyteArray metadata_blob = NULL;
 static u8 metadata_id = 0;
 static u8 last_metadata_id = 0;
 
-static void write_metadata_blob(JfrChunkWriter& chunkwriter) {
+static void write_metadata_blob(JfrChunkWriter& chunkwriter, Thread* thread) {
+  assert(chunkwriter.is_valid(), "invariant");
+  assert(thread != NULL, "invariant");
   assert(metadata_blob != NULL, "invariant");
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));
   const typeArrayOop arr = (typeArrayOop)JfrJavaSupport::resolve_non_null(metadata_blob);
   assert(arr != NULL, "invariant");
   const int length = arr->length();
   const Klass* const k = arr->klass();
   assert(k != NULL && k->is_array_klass(), "invariant");
   const TypeArrayKlass* const byte_arr_klass = TypeArrayKlass::cast(k);
   const jbyte* const data_address = arr->byte_at_addr(0);
   chunkwriter.write_unbuffered(data_address, length);
 }
 
-bool JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {
+void JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {
   assert(chunkwriter.is_valid(), "invariant");
   if (last_metadata_id == metadata_id && chunkwriter.has_metadata()) {
-    return false;
+    return;
   }
+  JavaThread* const jt = (JavaThread*)Thread::current();
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
+  // can safepoint here
+  ThreadInVMfromNative transition(jt);
   // header
   const int64_t metadata_offset = chunkwriter.reserve(sizeof(u4));
   chunkwriter.write<u8>(EVENT_METADATA); // ID 0
   // time data
   chunkwriter.write(JfrTicks::now());
   chunkwriter.write((u8)0); // duration
   chunkwriter.write(metadata_id); // metadata id
-  write_metadata_blob(chunkwriter); // payload
+  write_metadata_blob(chunkwriter, jt); // payload
   // fill in size of metadata descriptor event
   const int64_t size_written = chunkwriter.current_offset() - metadata_offset;
   chunkwriter.write_padded_at_offset((u4)size_written, metadata_offset);
   chunkwriter.set_last_metadata_offset(metadata_offset);
   last_metadata_id = metadata_id;
-  return true;
 }
 
 void JfrMetadataEvent::update(jbyteArray metadata) {
   JavaThread* thread = (JavaThread*)Thread::current();
   assert(thread->is_Java_thread(), "invariant");
diff a/src/hotspot/share/jfr/recorder/checkpoint/jfrMetadataEvent.hpp b/src/hotspot/share/jfr/recorder/checkpoint/jfrMetadataEvent.hpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/jfrMetadataEvent.hpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/jfrMetadataEvent.hpp
@@ -34,10 +34,10 @@
 // Metadata is continuously updated in Java as event classes are loaded / unloaded.
 // Using update(), Java stores a binary representation back to native.
 //
 class JfrMetadataEvent : AllStatic {
  public:
-  static bool write(JfrChunkWriter& writer);
+  static void write(JfrChunkWriter& writer);
   static void update(jbyteArray metadata);
 };
 
 #endif // SHARE_JFR_RECORDER_CHECKPOINT_JFRMETADATAEVENT_HPP
diff a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp
@@ -1036,10 +1036,11 @@
 
 /**
  * Clear all tags from the previous epoch.
  */
 void JfrTypeSet::clear() {
+  ResourceMark rm;
   JfrKlassUnloading::clear();
   clear_artifacts = true;
   setup(NULL, NULL, false, false);
   register_klasses();
   clear_packages();
diff a/src/hotspot/share/jfr/recorder/repository/jfrChunkRotation.cpp b/src/hotspot/share/jfr/recorder/repository/jfrChunkRotation.cpp
--- a/src/hotspot/share/jfr/recorder/repository/jfrChunkRotation.cpp
+++ b/src/hotspot/share/jfr/recorder/repository/jfrChunkRotation.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,10 +25,11 @@
 #include "precompiled.hpp"
 #include "jfr/jni/jfrJavaSupport.hpp"
 #include "jfr/recorder/repository/jfrChunkRotation.hpp"
 #include "jfr/recorder/repository/jfrChunkWriter.hpp"
 #include "runtime/handles.inline.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
 
 static jobject chunk_monitor = NULL;
 static int64_t threshold = 0;
 static bool rotate = false;
 
@@ -51,10 +52,13 @@
   return chunk_monitor != NULL ? chunk_monitor : install_chunk_monitor(thread);
 }
 
 static void notify() {
   Thread* const thread = Thread::current();
+  // can safepoint here
+  ThreadInVMfromNative transition((JavaThread*)thread);
+  ResetNoHandleMark rnhm;
   JfrJavaSupport::notify_all(get_chunk_monitor(thread), thread);
 }
 
 void JfrChunkRotation::evaluate(const JfrChunkWriter& writer) {
   assert(threshold > 0, "invariant");
diff a/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp b/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp
--- a/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp
+++ b/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp
@@ -420,19 +420,15 @@
 * This "safety net" somewhat explains the aggressiveness in this attempt.
 *
 */
 static bool prepare_for_emergency_dump(Thread* thread) {
   assert(thread != NULL, "invariant");
-
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));
   if (thread->is_Watcher_thread()) {
     // need WatcherThread as a safeguard against potential deadlocks
     return false;
   }
-  if (JfrStream_lock->owned_by_self()) {
-    // crashed during jfr rotation, disallow recursion
-    return false;
-  }
 
 #ifdef ASSERT
   Mutex* owned_lock = thread->owned_locks();
   while (owned_lock != NULL) {
     Mutex* next = owned_lock->next();
@@ -499,33 +495,42 @@
 
 static bool guard_reentrancy() {
   return Atomic::cmpxchg(&jfr_shutdown_lock, 0, 1) == 0;
 }
 
-class JavaThreadInVM : public StackObj {
+class JavaThreadInVMAndNative : public StackObj {
  private:
   JavaThread* const _jt;
   JavaThreadState _original_state;
  public:
 
-  JavaThreadInVM(Thread* t) : _jt(t->is_Java_thread() ? (JavaThread*)t : NULL),
-                              _original_state(_thread_max_state) {
-    if ((_jt != NULL) && (_jt->thread_state() != _thread_in_vm)) {
+  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? (JavaThread*)t : NULL),
+                                       _original_state(_thread_max_state) {
+    if (_jt != NULL) {
       _original_state = _jt->thread_state();
-      _jt->set_thread_state(_thread_in_vm);
+      if (_original_state != _thread_in_vm) {
+        _jt->set_thread_state(_thread_in_vm);
+      }
     }
   }
 
-  ~JavaThreadInVM() {
+  ~JavaThreadInVMAndNative() {
     if (_original_state != _thread_max_state) {
       _jt->set_thread_state(_original_state);
     }
   }
 
+  void transition_to_native() {
+    if (_jt != NULL) {
+      assert(_jt->thread_state() == _thread_in_vm, "invariant");
+      _jt->set_thread_state(_thread_in_native);
+    }
+  }
 };
 
-static void post_events(bool exception_handler) {
+static void post_events(bool exception_handler, Thread* thread) {
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));
   if (exception_handler) {
     EventShutdown e;
     e.set_reason("VM Error");
     e.commit();
   } else {
@@ -545,14 +550,17 @@
   Thread* thread = Thread::current_or_null_safe();
   if (thread == NULL) {
     return;
   }
   // Ensure a JavaThread is _thread_in_vm when we make this call
-  JavaThreadInVM jtivm(thread);
+  JavaThreadInVMAndNative jtivm(thread);
   if (!prepare_for_emergency_dump(thread)) {
     return;
   }
-  post_events(exception_handler);
+  post_events(exception_handler, thread);
+  // if JavaThread, transition to _thread_in_native to issue a final flushpoint
+  NoHandleMark nhm;
+  jtivm.transition_to_native();
   const int messages = MSGBIT(MSG_VM_ERROR);
   JfrRecorderService service;
   service.rotate(messages);
 }
diff a/src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp b/src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp
--- a/src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp
+++ b/src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp
@@ -43,23 +43,86 @@
 #include "jfr/utilities/jfrAllocation.hpp"
 #include "jfr/utilities/jfrTime.hpp"
 #include "jfr/writers/jfrJavaEventWriter.hpp"
 #include "jfr/utilities/jfrTypes.hpp"
 #include "logging/log.hpp"
-#include "memory/resourceArea.hpp"
 #include "runtime/atomic.hpp"
-#include "runtime/handles.inline.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/mutexLocker.hpp"
 #include "runtime/os.hpp"
 #include "runtime/safepoint.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/vmOperations.hpp"
 #include "runtime/vmThread.hpp"
 
 // incremented on each flushpoint
 static u8 flushpoint_id = 0;
 
+class JfrRotationLock : public StackObj {
+ private:
+  static const Thread* _owner_thread;
+  static const int retry_wait_millis;
+  static volatile int _lock;
+  Thread* _thread;
+  bool _recursive;
+
+  static bool acquire(Thread* thread) {
+    if (Atomic::cmpxchg(&_lock, 0, 1) == 0) {
+      assert(_owner_thread == NULL, "invariant");
+      _owner_thread = thread;
+      return true;
+    }
+    return false;
+  }
+
+  // The system can proceed to a safepoint
+  // because even if the thread is a JavaThread,
+  // it is running as _thread_in_native here.
+  void lock() {
+    while (!acquire(_thread)) {
+      os::naked_short_sleep(retry_wait_millis);
+    }
+    assert(is_owner(), "invariant");
+  }
+
+ public:
+  JfrRotationLock() : _thread(Thread::current()), _recursive(false) {
+    assert(_thread != NULL, "invariant");
+    if (_thread == _owner_thread) {
+      // Recursive case is not supported.
+      _recursive = true;
+      assert(_lock == 1, "invariant");
+      // For user, should not be "jfr, system".
+      log_info(jfr)("Unable to issue rotation due to recursive calls.");
+      return;
+    }
+    lock();
+  }
+
+  ~JfrRotationLock() {
+    assert(is_owner(), "invariant");
+    if (_recursive) {
+      return;
+    }
+    _owner_thread = NULL;
+    OrderAccess::storestore();
+    _lock = 0;
+  }
+
+  static bool is_owner() {
+    return _owner_thread == Thread::current();
+  }
+
+  bool is_acquired_recursively() const {
+    return _recursive;
+  }
+};
+
+const Thread* JfrRotationLock::_owner_thread = NULL;
+const int JfrRotationLock::retry_wait_millis = 10;
+volatile int JfrRotationLock::_lock = 0;
+
 template <typename Instance, size_t(Instance::*func)()>
 class Content {
  private:
   Instance& _instance;
   u4 _elements;
@@ -340,15 +403,17 @@
   OrderAccess::storestore();
   recorder_state = to;
 }
 
 static void start_recorder() {
+  assert(JfrRotationLock::is_owner(), "invariant");
   set_recorder_state(STOPPED, RUNNING);
   log_debug(jfr, system)("Recording service STARTED");
 }
 
 static void stop_recorder() {
+  assert(JfrRotationLock::is_owner(), "invariant");
   set_recorder_state(RUNNING, STOPPED);
   log_debug(jfr, system)("Recording service STOPPED");
 }
 
 bool JfrRecorderService::is_recording() {
@@ -356,11 +421,11 @@
   OrderAccess::loadload();
   return is_running;
 }
 
 void JfrRecorderService::start() {
-  MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);
+  JfrRotationLock lock;
   assert(!is_recording(), "invariant");
   clear();
   open_new_chunk();
   start_recorder();
   assert(is_recording(), "invariant");
@@ -371,12 +436,11 @@
   stop_recorder();
   assert(!JfrRecorderService::is_recording(), "invariant");
 }
 
 void JfrRecorderService::clear() {
-  ResourceMark rm;
-  HandleMark hm;
+  assert(JfrRotationLock::is_owner(), "invariant");
   pre_safepoint_clear();
   invoke_safepoint_clear();
   post_safepoint_clear();
 }
 
@@ -386,10 +450,11 @@
   _stack_trace_repository.clear();
 }
 
 void JfrRecorderService::invoke_safepoint_clear() {
   JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_clear> safepoint_task(*this);
+  ThreadInVMfromNative transition((JavaThread*)Thread::current());
   VMThread::execute(&safepoint_task);
 }
 
 void JfrRecorderService::safepoint_clear() {
   assert(SafepointSynchronize::is_at_safepoint(), "invariant");
@@ -404,86 +469,42 @@
 void JfrRecorderService::post_safepoint_clear() {
   _checkpoint_manager.clear();
 }
 
 void JfrRecorderService::open_new_chunk(bool vm_error) {
-  assert(JfrStream_lock->owned_by_self(), "invariant");
+  assert(JfrRotationLock::is_owner(), "invariant");
   JfrChunkRotation::on_rotation();
   const bool valid_chunk = _repository.open_chunk(vm_error);
   _storage.control().set_to_disk(valid_chunk);
   if (valid_chunk) {
     _checkpoint_manager.write_static_type_set_and_threads();
   }
 }
 
-// 'rotation_safepoint_pending' is currently only relevant in the unusual case of an emergency dump.
-// Since the JfrStream_lock must be acquired using _no_safepoint_check,
-// if the thread running the emergency dump is a JavaThread, a pending safepoint, induced by rotation,
-// would lead to a deadlock. This deadlock, although unpleasant, is not completely horrendous at this
-// location because the WatcherThread will terminate the VM after a timeout.
-// Deadlock avoidance is done not to affect the stability of general VM error reporting.
-static bool rotation_safepoint_pending = false;
-
-static bool is_rotation_safepoint_pending() {
-  return Atomic::load_acquire(&rotation_safepoint_pending);
-}
-
-static void set_rotation_safepoint_pending(bool value) {
-  assert(value ? !is_rotation_safepoint_pending() : is_rotation_safepoint_pending(), "invariant");
-  Atomic::release_store(&rotation_safepoint_pending, value);
-}
-
-static bool vm_error = false;
-static const Thread* vm_error_thread = NULL;
-
-static bool prepare_for_vm_error_rotation() {
-  assert(!JfrStream_lock->owned_by_self(), "invariant");
-  Thread* const t = Thread::current();
-  assert(t != NULL, "invariant");
-  if (is_rotation_safepoint_pending() && t->is_Java_thread()) {
-    // A safepoint is pending, avoid deadlock.
-    log_warning(jfr, system)("Unable to issue successful emergency dump");
-    return false;
-  }
-  vm_error_thread = t;
-  vm_error = true;
-  OrderAccess::fence();
-  return true;
-}
-
 void JfrRecorderService::vm_error_rotation() {
-  assert(JfrStream_lock->owned_by_self(), "invariant");
-  assert(vm_error, "invariant");
-  Thread* const t = Thread::current();
-  if (vm_error_thread != t) {
-    return;
-  }
-  assert(vm_error_thread == t, "invariant");
+  assert(JfrRotationLock::is_owner(), "invariant");
   if (!_chunkwriter.is_valid()) {
     open_new_chunk(true);
   }
   if (_chunkwriter.is_valid()) {
-    _storage.flush_regular_buffer(t->jfr_thread_local()->native_buffer(), t);
+    Thread* const thread = Thread::current();
+    _storage.flush_regular_buffer(thread->jfr_thread_local()->native_buffer(), thread);
     _chunkwriter.mark_chunk_final();
     invoke_flush();
     _chunkwriter.set_time_stamp();
     _repository.close_chunk();
     assert(!_chunkwriter.is_valid(), "invariant");
     _repository.on_vm_error();
   }
 }
 
 void JfrRecorderService::rotate(int msgs) {
-  assert(!JfrStream_lock->owned_by_self(), "invariant");
-  if (msgs & MSGBIT(MSG_VM_ERROR)) {
-    // emergency dump
-    if (!prepare_for_vm_error_rotation()) {
-      return;
-    }
+  JfrRotationLock lock;
+  if (lock.is_acquired_recursively()) {
+    return;
   }
-  MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);
-  if (vm_error) {
+  if (msgs & MSGBIT(MSG_VM_ERROR)) {
     vm_error_rotation();
     return;
   }
   if (_storage.control().to_disk()) {
     chunk_rotation();
@@ -494,45 +515,39 @@
     stop();
   }
 }
 
 void JfrRecorderService::in_memory_rotation() {
-  assert(JfrStream_lock->owned_by_self(), "invariant");
+  assert(JfrRotationLock::is_owner(), "invariant");
   // currently running an in-memory recording
   assert(!_storage.control().to_disk(), "invariant");
   open_new_chunk();
   if (_chunkwriter.is_valid()) {
     // dump all in-memory buffer data to the newly created chunk
     write_storage(_storage, _chunkwriter);
   }
 }
 
 void JfrRecorderService::chunk_rotation() {
-  assert(JfrStream_lock->owned_by_self(), "invariant");
+  assert(JfrRotationLock::is_owner(), "invariant");
   finalize_current_chunk();
   open_new_chunk();
 }
 
 void JfrRecorderService::finalize_current_chunk() {
   assert(_chunkwriter.is_valid(), "invariant");
-  assert(!is_rotation_safepoint_pending(), "invariant");
-  set_rotation_safepoint_pending(true);
   write();
-  assert(!is_rotation_safepoint_pending(), "invariant");
 }
 
 void JfrRecorderService::write() {
-  ResourceMark rm;
-  HandleMark hm;
   pre_safepoint_write();
   invoke_safepoint_write();
   post_safepoint_write();
 }
 
 void JfrRecorderService::pre_safepoint_write() {
   assert(_chunkwriter.is_valid(), "invariant");
-  assert(is_rotation_safepoint_pending(), "invariant");
   if (LeakProfiler::is_running()) {
     // Exclusive access to the object sampler instance.
     // The sampler is released (unlocked) later in post_safepoint_write.
     ObjectSampleCheckpoint::on_rotation(ObjectSampler::acquire(), _stack_trace_repository);
   }
@@ -545,17 +560,17 @@
   }
 }
 
 void JfrRecorderService::invoke_safepoint_write() {
   JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_write> safepoint_task(*this);
+  // can safepoint here
+  ThreadInVMfromNative transition((JavaThread*)Thread::current());
   VMThread::execute(&safepoint_task);
 }
 
 void JfrRecorderService::safepoint_write() {
   assert(SafepointSynchronize::is_at_safepoint(), "invariant");
-  assert(is_rotation_safepoint_pending(), "invariant");
-  set_rotation_safepoint_pending(false);
   _checkpoint_manager.begin_epoch_shift();
   if (_string_pool.is_modified()) {
     write_stringpool_safepoint(_string_pool, _chunkwriter);
   }
   _checkpoint_manager.on_rotation();
@@ -565,11 +580,10 @@
   _checkpoint_manager.end_epoch_shift();
 }
 
 void JfrRecorderService::post_safepoint_write() {
   assert(_chunkwriter.is_valid(), "invariant");
-  assert(!is_rotation_safepoint_pending(), "invariant");
   // During the safepoint tasks just completed, the system transitioned to a new epoch.
   // Type tagging is epoch relative which entails we are able to write out the
   // already tagged artifacts for the previous epoch. We can accomplish this concurrently
   // with threads now tagging artifacts in relation to the new, now updated, epoch and remain outside of a safepoint.
   _checkpoint_manager.write_type_set();
@@ -602,16 +616,14 @@
 static void write_thread_local_buffer(JfrChunkWriter& chunkwriter, Thread* t) {
   JfrBuffer * const buffer = thread_local_buffer(t);
   assert(buffer != NULL, "invariant");
   if (!buffer->empty()) {
     chunkwriter.write_unbuffered(buffer->top(), buffer->pos() - buffer->top());
-    reset_buffer(buffer, t);
   }
 }
 
 size_t JfrRecorderService::flush() {
-  assert(JfrStream_lock->owned_by_self(), "invariant");
   size_t total_elements = flush_metadata(_chunkwriter);
   const size_t storage_elements = flush_storage(_storage, _chunkwriter);
   if (0 == storage_elements) {
     return total_elements;
   }
@@ -627,35 +639,37 @@
 
 typedef Content<JfrRecorderService, &JfrRecorderService::flush> FlushFunctor;
 typedef WriteContent<FlushFunctor> Flush;
 
 void JfrRecorderService::invoke_flush() {
-  assert(JfrStream_lock->owned_by_self(), "invariant");
+  assert(JfrRotationLock::is_owner(), "invariant");
   assert(_chunkwriter.is_valid(), "invariant");
   Thread* const t = Thread::current();
-  ResourceMark rm(t);
-  HandleMark hm(t);
   ++flushpoint_id;
   reset_thread_local_buffer(t);
   FlushFunctor flushpoint(*this);
   Flush fl(_chunkwriter, flushpoint);
   invoke_with_flush_event(fl);
   write_thread_local_buffer(_chunkwriter, t);
   _repository.flush_chunk();
 }
 
 void JfrRecorderService::flushpoint() {
-  MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));
+  JfrRotationLock lock;
   if (_chunkwriter.is_valid()) {
     invoke_flush();
   }
 }
 
 void JfrRecorderService::process_full_buffers() {
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));
+  JfrRotationLock lock;
   if (_chunkwriter.is_valid()) {
     _storage.write_full();
   }
 }
 
 void JfrRecorderService::evaluate_chunk_size_for_rotation() {
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));
   JfrChunkRotation::evaluate(_chunkwriter);
 }
diff a/src/hotspot/share/jfr/recorder/service/jfrRecorderThreadLoop.cpp b/src/hotspot/share/jfr/recorder/service/jfrRecorderThreadLoop.cpp
--- a/src/hotspot/share/jfr/recorder/service/jfrRecorderThreadLoop.cpp
+++ b/src/hotspot/share/jfr/recorder/service/jfrRecorderThreadLoop.cpp
@@ -21,15 +21,19 @@
  * questions.
  *
  */
 
 #include "precompiled.hpp"
+#include "jfr/jni/jfrJavaSupport.hpp"
 #include "jfr/recorder/jfrRecorder.hpp"
 #include "jfr/recorder/service/jfrPostBox.hpp"
 #include "jfr/recorder/service/jfrRecorderService.hpp"
 #include "jfr/recorder/service/jfrRecorderThread.hpp"
+#include "jfr/recorder/jfrRecorder.hpp"
 #include "logging/log.hpp"
+#include "runtime/handles.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/mutexLocker.hpp"
 #include "runtime/thread.inline.hpp"
 
 //
 // Entry point for "JFR Recorder Thread" message loop.
@@ -57,22 +61,28 @@
       if (post_box.is_empty()) {
         JfrMsg_lock->wait();
       }
       msgs = post_box.collect();
       JfrMsg_lock->unlock();
-      if (PROCESS_FULL_BUFFERS) {
-        service.process_full_buffers();
-      }
-      // Check amount of data written to chunk already
-      // if it warrants asking for a new chunk
-      service.evaluate_chunk_size_for_rotation();
-      if (START) {
-        service.start();
-      } else if (ROTATE) {
-        service.rotate(msgs);
-      } else if (FLUSHPOINT) {
-        service.flushpoint();
+      {
+        // Run as _thread_in_native as much a possible
+        // to minimize impact on safepoint synchronizations.
+        NoHandleMark nhm;
+        ThreadToNativeFromVM transition(thread);
+        if (PROCESS_FULL_BUFFERS) {
+          service.process_full_buffers();
+        }
+        // Check amount of data written to chunk already
+        // if it warrants asking for a new chunk.
+        service.evaluate_chunk_size_for_rotation();
+        if (START) {
+          service.start();
+        } else if (ROTATE) {
+          service.rotate(msgs);
+        } else if (FLUSHPOINT) {
+          service.flushpoint();
+        }
       }
       JfrMsg_lock->lock();
       post_box.notify_waiters();
       if (SHUTDOWN) {
         log_debug(jfr, system)("Request to STOP recorder");
diff a/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.hpp b/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.hpp
--- a/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.hpp
+++ b/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.hpp
@@ -63,15 +63,15 @@
 * a failed cas not to be the result of a new node inserted as with the LIFO case. With FIFO, there is only a single
 * failure mode, i.e. some other thread excised the node already. Therefore, in the FIFO case, we skip the slow-path search pass.
 *
 * We say that the FIFO solution is "mostly" concurrent, in certain situations.
 *
-* Safe memory reclamation is based on a reference tracking scheme based on versions, implemented using JfrVersion.
-* An access to the list is "version controlled", with clients checking out the latest version of the list.
-* Destructive modifications made by clients, i.e. deletions, are committed to describe new versions of the list.
-* Before reclamation, a client inspects the versioning system to ensure checkouts for versions strictly
-* less than the version of the modification have all been relinquished. See utilities/JfrVersion.hpp.
+* Safe memory reclamation is based on a reference tracking scheme based on versioning, implemented using JfrVersionSystem.
+* An access to the list is "versioned", with clients checking out the latest version describing the list.
+* Destructive modifications made by clients, i.e. deletions, are signalled by incrementing the version.
+* Before reclamation, a client inspects JfrVersionSystem to ensure checkouts with versions strictly
+* less than the version of the modification have been relinquished. See utilities/JfrVersionSystem.hpp.
 *
 * Insertions can only take place from one end of the list, head or tail, exclusively.
 * Specializations, a.k.a clients, must ensure this requirement.
 */
 
diff a/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp b/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp
--- a/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp
+++ b/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp
@@ -220,11 +220,11 @@
   // Invariant: predecessor --> (successor) --> successor_next
   // Successor node now logically excised.
   assert(is_marked_for_removal(successor->_next), "invariant");
   // Now attempt to physically excise the successor node.
   // If the cas fails, we can optimize for the slow path if we know we are not performing
-  // insertions from the head. Then a failed cas results not from new a node being inserted,
+  // insertions from the head. Then a failed cas results not from a new node being inserted,
   // but only because another thread excised us already.
   if (!cas(&predecessor->_next, successor, successor_next) && insert_is_head) {
     // Physically excise using slow path, can be completed asynchronously by other threads.
     Identity<Node> excise(successor);
     find_adjacent<Node, VersionHandle, Identity>(head, tail, &predecessor, version_handle, excise);
diff a/src/hotspot/share/jfr/utilities/jfrVersionSystem.inline.hpp b/src/hotspot/share/jfr/utilities/jfrVersionSystem.inline.hpp
--- a/src/hotspot/share/jfr/utilities/jfrVersionSystem.inline.hpp
+++ b/src/hotspot/share/jfr/utilities/jfrVersionSystem.inline.hpp
@@ -23,15 +23,13 @@
  */
 
 #ifndef SHARE_JFR_UTILITIES_JFRVERSIONSYSTEM_INLINE_HPP
 #define SHARE_JFR_UTILITIES_JFRVERSIONSYSTEM_INLINE_HPP
 
-#include "jfr/utilities/jfrSpinlockHelper.hpp"
 #include "jfr/utilities/jfrVersionSystem.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/os.inline.hpp"
-#include "runtime/vm_version.hpp"
 
 inline JfrVersionSystem::Node::Node() : _next(NULL), _version(0), _live(true) {}
 
 inline traceid JfrVersionSystem::Node::version() const {
   return _version;
@@ -63,14 +61,10 @@
 inline JfrVersionSystem::Type JfrVersionSystem::tip() const {
   return Atomic::load(&_tip._value);
 }
 
 inline JfrVersionSystem::Type JfrVersionSystem::increment() {
-  if (!VM_Version::supports_cx8()) {
-    JfrSpinlockHelper lock(&_spinlock);
-    return ++_tip._value;
-  }
   traceid cmp;
   traceid xchg;
   do {
     cmp = _tip._value;
     xchg = cmp + 1;
diff a/src/hotspot/share/jvmci/jvmciEnv.cpp b/src/hotspot/share/jvmci/jvmciEnv.cpp
--- a/src/hotspot/share/jvmci/jvmciEnv.cpp
+++ b/src/hotspot/share/jvmci/jvmciEnv.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,10 +24,11 @@
 
 #include "precompiled.hpp"
 #include "classfile/stringTable.hpp"
 #include "classfile/symbolTable.hpp"
 #include "code/codeCache.hpp"
+#include "compiler/compileTask.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/typeArrayOop.inline.hpp"
@@ -47,10 +48,11 @@
   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();
   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
+  _target_method_is_old                 = _task != NULL && _task->method()->is_old();
 }
 
 bool JVMCICompileState::jvmti_state_changed() const {
   // Some classes were redefined
   if (jvmti_redefinition_count() != JvmtiExport::redefinition_count()) {
diff a/src/hotspot/share/jvmci/jvmciEnv.hpp b/src/hotspot/share/jvmci/jvmciEnv.hpp
--- a/src/hotspot/share/jvmci/jvmciEnv.hpp
+++ b/src/hotspot/share/jvmci/jvmciEnv.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -97,10 +97,11 @@
   uint64_t _jvmti_redefinition_count;
   jbyte  _jvmti_can_hotswap_or_post_breakpoint;
   jbyte  _jvmti_can_access_local_variables;
   jbyte  _jvmti_can_post_on_exceptions;
   jbyte  _jvmti_can_pop_frame;
+  bool   _target_method_is_old;
 
   // Compilation result values.
   bool             _retryable;
   const char*      _failure_reason;
 
@@ -117,10 +118,11 @@
   uint64_t jvmti_redefinition_count() const          { return  _jvmti_redefinition_count; }
   bool  jvmti_can_hotswap_or_post_breakpoint() const { return  _jvmti_can_hotswap_or_post_breakpoint != 0; }
   bool  jvmti_can_access_local_variables() const     { return  _jvmti_can_access_local_variables != 0; }
   bool  jvmti_can_post_on_exceptions() const         { return  _jvmti_can_post_on_exceptions != 0; }
   bool  jvmti_can_pop_frame() const                  { return  _jvmti_can_pop_frame != 0; }
+  bool  target_method_is_old() const                 { return  _target_method_is_old; }
 
   const char* failure_reason() { return _failure_reason; }
   bool failure_reason_on_C_heap() { return _failure_reason_on_C_heap; }
   bool retryable() { return _retryable; }
 
diff a/src/hotspot/share/memory/dynamicArchive.cpp b/src/hotspot/share/memory/dynamicArchive.cpp
--- a/src/hotspot/share/memory/dynamicArchive.cpp
+++ b/src/hotspot/share/memory/dynamicArchive.cpp
@@ -1143,30 +1143,26 @@
 
 DynamicArchiveBuilder* DynamicArchive::_builder = NULL;
 
 
 bool DynamicArchive::validate(FileMapInfo* dynamic_info) {
+  assert(!dynamic_info->is_static(), "must be");
   // Check if the recorded base archive matches with the current one
   FileMapInfo* base_info = FileMapInfo::current_info();
   DynamicArchiveHeader* dynamic_header = dynamic_info->dynamic_header();
 
   // Check the header crc
   if (dynamic_header->base_header_crc() != base_info->crc()) {
-    FileMapInfo::fail_continue("Archive header checksum verification failed.");
+    FileMapInfo::fail_continue("Dynamic archive cannot be used: static archive header checksum verification failed.");
     return false;
   }
 
   // Check each space's crc
   for (int i = 0; i < MetaspaceShared::n_regions; i++) {
     if (dynamic_header->base_region_crc(i) != base_info->space_crc(i)) {
-      FileMapInfo::fail_continue("Archive region #%d checksum verification failed.", i);
+      FileMapInfo::fail_continue("Dynamic archive cannot be used: static archive region #%d checksum verification failed.", i);
       return false;
     }
   }
 
-  // Validate the dynamic archived shared path table, and set the global
-  // _shared_path_table to that.
-  if (!dynamic_info->validate_shared_path_table()) {
-    return false;
-  }
   return true;
 }
diff a/src/hotspot/share/memory/filemap.cpp b/src/hotspot/share/memory/filemap.cpp
--- a/src/hotspot/share/memory/filemap.cpp
+++ b/src/hotspot/share/memory/filemap.cpp
@@ -215,10 +215,11 @@
   }
   _compressed_oops = UseCompressedOops;
   _compressed_class_ptrs = UseCompressedClassPointers;
   _max_heap_size = MaxHeapSize;
   _narrow_klass_shift = CompressedKlassPointers::shift();
+  _use_optimized_module_handling = MetaspaceShared::use_optimized_module_handling();
 
   // The following fields are for sanity checks for whether this archive
   // will function correctly with this JVM and the bootclasspath it's
   // invoked with.
 
@@ -2128,15 +2129,27 @@
     FileMapInfo::fail_continue("Unable to use shared archive.\nThe saved state of UseCompressedOops and UseCompressedClassPointers is "
                                "different from runtime, CDS will be disabled.");
     return false;
   }
 
+  if (!_use_optimized_module_handling) {
+    MetaspaceShared::disable_optimized_module_handling();
+    log_info(cds)("use_optimized_module_handling disabled: archive was created without optimized module handling");
+  }
+
   return true;
 }
 
 bool FileMapInfo::validate_header() {
-  return header()->validate();
+  if (!header()->validate()) {
+    return false;
+  }
+  if (_is_static) {
+    return true;
+  } else {
+    return DynamicArchive::validate(this);
+  }
 }
 
 // Check if a given address is within one of the shared regions
 bool FileMapInfo::is_in_shared_region(const void* p, int idx) {
   assert(idx == MetaspaceShared::ro ||
diff a/src/hotspot/share/memory/filemap.hpp b/src/hotspot/share/memory/filemap.hpp
--- a/src/hotspot/share/memory/filemap.hpp
+++ b/src/hotspot/share/memory/filemap.hpp
@@ -225,10 +225,12 @@
   bool   _has_platform_or_app_classes;  // Archive contains app classes
   char*  _requested_base_address;       // Archive relocation is not necessary if we map with this base address.
   char*  _mapped_base_address;          // Actual base address where archive is mapped.
 
   bool   _allow_archiving_with_java_agent; // setting of the AllowArchivingWithJavaAgent option
+  bool   _use_optimized_module_handling;// No module-relation VM options were specified, so we can skip
+                                        // some expensive operations.
   size_t _ptrmap_size_in_bits;          // Size of pointer relocation bitmap
 
   char* from_mapped_offset(size_t offset) const {
     return mapped_base_address() + offset;
   }
diff a/src/hotspot/share/memory/metaspaceShared.cpp b/src/hotspot/share/memory/metaspaceShared.cpp
--- a/src/hotspot/share/memory/metaspaceShared.cpp
+++ b/src/hotspot/share/memory/metaspaceShared.cpp
@@ -89,10 +89,11 @@
 address MetaspaceShared::_i2i_entry_code_buffers = NULL;
 size_t MetaspaceShared::_i2i_entry_code_buffers_size = 0;
 void* MetaspaceShared::_shared_metaspace_static_top = NULL;
 intx MetaspaceShared::_relocation_delta;
 char* MetaspaceShared::_requested_base_address;
+bool MetaspaceShared::_use_optimized_module_handling = true;
 
 // The CDS archive is divided into the following regions:
 //     mc  - misc code (the method entry trampolines, c++ vtables)
 //     rw  - read-write metadata
 //     ro  - read-only metadata and read-only tables
@@ -2287,10 +2288,11 @@
   char* mapped_base_address = reserve_address_space_for_archives(static_mapinfo, dynamic_mapinfo,
                                                                  use_requested_addr, archive_space_rs,
                                                                  class_space_rs);
   if (mapped_base_address == NULL) {
     result = MAP_ARCHIVE_MMAP_FAILURE;
+    log_debug(cds)("Failed to reserve spaces (use_requested_addr=%u)", (unsigned)use_requested_addr);
   } else {
 
 #ifdef ASSERT
     // Some sanity checks after reserving address spaces for archives
     //  and class space.
@@ -2394,10 +2396,11 @@
           // map_heap_regions() compares the current narrow oop and klass encodings
           // with the archived ones, so it must be done after all encodings are determined.
           static_mapinfo->map_heap_regions();
         }
       });
+    log_info(cds)("Using optimized module handling %s", MetaspaceShared::use_optimized_module_handling() ? "enabled" : "disabled");
   } else {
     unmap_archive(static_mapinfo);
     unmap_archive(dynamic_mapinfo);
     release_reserved_spaces(archive_space_rs, class_space_rs);
   }
@@ -2489,10 +2492,12 @@
     archive_space_rs = ReservedSpace(archive_space_size, archive_space_alignment,
                                      false /* bool large */, (char*)base_address);
     if (archive_space_rs.is_reserved()) {
       assert(base_address == NULL ||
              (address)archive_space_rs.base() == base_address, "Sanity");
+      // Register archive space with NMT.
+      MemTracker::record_virtual_memory_type(archive_space_rs.base(), mtClassShared);
       return archive_space_rs.base();
     }
     return NULL;
   }
 
@@ -2608,20 +2613,13 @@
   if (result != MAP_ARCHIVE_SUCCESS) {
     unmap_archive(mapinfo);
     return result;
   }
 
-  if (mapinfo->is_static()) {
-    if (!mapinfo->validate_shared_path_table()) {
-      unmap_archive(mapinfo);
-      return MAP_ARCHIVE_OTHER_FAILURE;
-    }
-  } else {
-    if (!DynamicArchive::validate(mapinfo)) {
-      unmap_archive(mapinfo);
-      return MAP_ARCHIVE_OTHER_FAILURE;
-    }
+  if (!mapinfo->validate_shared_path_table()) {
+    unmap_archive(mapinfo);
+    return MAP_ARCHIVE_OTHER_FAILURE;
   }
 
   mapinfo->set_is_mapped(true);
   return MAP_ARCHIVE_SUCCESS;
 }
diff a/src/hotspot/share/memory/metaspaceShared.hpp b/src/hotspot/share/memory/metaspaceShared.hpp
--- a/src/hotspot/share/memory/metaspaceShared.hpp
+++ b/src/hotspot/share/memory/metaspaceShared.hpp
@@ -182,10 +182,11 @@
   static size_t  _i2i_entry_code_buffers_size;
   static size_t  _core_spaces_size;
   static void* _shared_metaspace_static_top;
   static intx _relocation_delta;
   static char* _requested_base_address;
+  static bool _use_optimized_module_handling;
  public:
   enum {
     // core archive spaces
     mc = 0,  // miscellaneous code for method trampolines
     rw = 1,  // read-write shared space in the heap
@@ -370,10 +371,15 @@
   }
 
   static void write_core_archive_regions(FileMapInfo* mapinfo,
                                          GrowableArray<ArchiveHeapOopmapInfo>* closed_oopmaps,
                                          GrowableArray<ArchiveHeapOopmapInfo>* open_oopmaps);
+
+  // Can we skip some expensive operations related to modules?
+  static bool use_optimized_module_handling()     { return _use_optimized_module_handling;  }
+  static void disable_optimized_module_handling() { _use_optimized_module_handling = false; }
+
 private:
 #if INCLUDE_CDS
   static void write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region,
                            bool read_only,  bool allow_exec);
 #endif
diff a/src/hotspot/share/oops/cpCache.cpp b/src/hotspot/share/oops/cpCache.cpp
--- a/src/hotspot/share/oops/cpCache.cpp
+++ b/src/hotspot/share/oops/cpCache.cpp
@@ -565,19 +565,18 @@
 
 
 #if INCLUDE_JVMTI
 
 void log_adjust(const char* entry_type, Method* old_method, Method* new_method, bool* trace_name_printed) {
-  if (log_is_enabled(Info, redefine, class, update)) {
-    ResourceMark rm;
-    if (!(*trace_name_printed)) {
-      log_info(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
-      *trace_name_printed = true;
-    }
-    log_debug(redefine, class, update, constantpool)
-          ("cpc %s entry update: %s(%s)", entry_type, new_method->name()->as_C_string(), new_method->signature()->as_C_string());
+  ResourceMark rm;
+
+  if (!(*trace_name_printed)) {
+    log_info(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
+    *trace_name_printed = true;
   }
+  log_trace(redefine, class, update, constantpool)
+    ("cpc %s entry update: %s", entry_type, new_method->external_name());
 }
 
 // RedefineClasses() API support:
 // If this ConstantPoolCacheEntry refers to old_method then update it
 // to refer to new_method.
@@ -813,13 +812,17 @@
   }
 }
 
 // the constant pool cache should never contain old or obsolete methods
 bool ConstantPoolCache::check_no_old_or_obsolete_entries() {
+  ResourceMark rm;
   for (int i = 1; i < length(); i++) {
-    if (entry_at(i)->get_interesting_method_entry() != NULL &&
-        !entry_at(i)->check_no_old_or_obsolete_entries()) {
+    Method* m = entry_at(i)->get_interesting_method_entry();
+    if (m != NULL && !entry_at(i)->check_no_old_or_obsolete_entries()) {
+      log_trace(redefine, class, update, constantpool)
+        ("cpcache check found old method entry: class: %s, old: %d, obsolete: %d, method: %s",
+         constant_pool()->pool_holder()->external_name(), m->is_old(), m->is_obsolete(), m->external_name());
       return false;
     }
   }
   return true;
 }
diff a/src/hotspot/share/oops/klassVtable.cpp b/src/hotspot/share/oops/klassVtable.cpp
--- a/src/hotspot/share/oops/klassVtable.cpp
+++ b/src/hotspot/share/oops/klassVtable.cpp
@@ -959,10 +959,12 @@
 }
 
 // search the vtable for uses of either obsolete or EMCP methods
 void klassVtable::adjust_method_entries(bool * trace_name_printed) {
   int prn_enabled = 0;
+  ResourceMark rm;
+
   for (int index = 0; index < length(); index++) {
     Method* old_method = unchecked_method_at(index);
     if (old_method == NULL || !old_method->is_old()) {
       continue; // skip uninteresting entries
     }
@@ -976,31 +978,33 @@
     bool updated_default = false;
     if (old_method->is_default_method()) {
       updated_default = adjust_default_method(index, old_method, new_method);
     }
 
-    if (log_is_enabled(Info, redefine, class, update)) {
-      ResourceMark rm;
-      if (!(*trace_name_printed)) {
-        log_info(redefine, class, update)
-          ("adjust: klassname=%s for methods from name=%s",
-           _klass->external_name(), old_method->method_holder()->external_name());
-        *trace_name_printed = true;
-      }
-      log_debug(redefine, class, update, vtables)
-        ("vtable method update: %s(%s), updated default = %s",
-         new_method->name()->as_C_string(), new_method->signature()->as_C_string(), updated_default ? "true" : "false");
+    if (!(*trace_name_printed)) {
+      log_info(redefine, class, update)
+        ("adjust: klassname=%s for methods from name=%s",
+         _klass->external_name(), old_method->method_holder()->external_name());
+      *trace_name_printed = true;
     }
+    log_trace(redefine, class, update, vtables)
+      ("vtable method update: class: %s method: %s, updated default = %s",
+       _klass->external_name(), new_method->external_name(), updated_default ? "true" : "false");
   }
 }
 
 // a vtable should never contain old or obsolete methods
 bool klassVtable::check_no_old_or_obsolete_entries() {
+  ResourceMark rm;
+
   for (int i = 0; i < length(); i++) {
     Method* m = unchecked_method_at(i);
     if (m != NULL &&
         (NOT_PRODUCT(!m->is_valid() ||) m->is_old() || m->is_obsolete())) {
+      log_trace(redefine, class, update, vtables)
+        ("vtable check found old method entry: class: %s old: %d obsolete: %d, method: %s",
+         _klass->external_name(), m->is_old(), m->is_obsolete(), m->external_name());
       return false;
     }
   }
   return true;
 }
@@ -1280,40 +1284,43 @@
 }
 
 #if INCLUDE_JVMTI
 // search the itable for uses of either obsolete or EMCP methods
 void klassItable::adjust_method_entries(bool * trace_name_printed) {
-
+  ResourceMark rm;
   itableMethodEntry* ime = method_entry(0);
+
   for (int i = 0; i < _size_method_table; i++, ime++) {
     Method* old_method = ime->method();
     if (old_method == NULL || !old_method->is_old()) {
       continue; // skip uninteresting entries
     }
     assert(!old_method->is_deleted(), "itable methods may not be deleted");
     Method* new_method = old_method->get_new_method();
     ime->initialize(new_method);
 
-    if (log_is_enabled(Info, redefine, class, update)) {
-      ResourceMark rm;
-      if (!(*trace_name_printed)) {
-        log_info(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
-        *trace_name_printed = true;
-      }
-      log_trace(redefine, class, update, itables)
-        ("itable method update: %s(%s)", new_method->name()->as_C_string(), new_method->signature()->as_C_string());
+    if (!(*trace_name_printed)) {
+      log_info(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
+      *trace_name_printed = true;
     }
+    log_trace(redefine, class, update, itables)
+      ("itable method update: class: %s method: %s", _klass->external_name(), new_method->external_name());
   }
 }
 
 // an itable should never contain old or obsolete methods
 bool klassItable::check_no_old_or_obsolete_entries() {
+  ResourceMark rm;
   itableMethodEntry* ime = method_entry(0);
+
   for (int i = 0; i < _size_method_table; i++) {
     Method* m = ime->method();
     if (m != NULL &&
         (NOT_PRODUCT(!m->is_valid() ||) m->is_old() || m->is_obsolete())) {
+      log_trace(redefine, class, update, itables)
+        ("itable check found old method entry: class: %s old: %d obsolete: %d, method: %s",
+         _klass->external_name(), m->is_old(), m->is_obsolete(), m->external_name());
       return false;
     }
     ime++;
   }
   return true;
diff a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -3790,10 +3790,11 @@
                                               jobject methodType,
                                               jobject implMethodMember,
                                               jobject instantiatedMethodType,
                                               jclass lambdaProxyClass))
   JVMWrapper("JVM_RegisterLambdaProxyClassForArchiving");
+#if INCLUDE_CDS
   if (!DynamicDumpSharedSpaces) {
     return;
   }
 
   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
@@ -3826,11 +3827,11 @@
   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
 
   SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,
                                                  method_type, m, instantiated_method_type);
-
+#endif // INCLUDE_CDS
 JVM_END
 
 JVM_ENTRY(jclass, JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env,
                                                         jclass caller,
                                                         jstring invokedName,
@@ -3838,10 +3839,11 @@
                                                         jobject methodType,
                                                         jobject implMethodMember,
                                                         jobject instantiatedMethodType,
                                                         jboolean initialize))
   JVMWrapper("JVM_LookupLambdaProxyClassFromArchive");
+#if INCLUDE_CDS
   if (!DynamicArchive::is_mapped()) {
     return NULL;
   }
 
   if (invokedName == NULL || invokedType == NULL || methodType == NULL ||
@@ -3876,10 +3878,13 @@
   if (lambda_ik != NULL) {
     InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, initialize, THREAD);
     jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(env, loaded_lambda->java_mirror());
   }
   return jcls;
+#else
+  return NULL;
+#endif // INCLUDE_CDS
 JVM_END
 
 JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))
     JVMWrapper("JVM_IsCDSDumpingEnable");
     return DynamicDumpSharedSpaces;
diff a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -1198,22 +1198,23 @@
 // owned_monitor_count_ptr - pre-checked for NULL
 // owned_monitors_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetOwnedMonitorInfo(JavaThread* java_thread, jint* owned_monitor_count_ptr, jobject** owned_monitors_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
+  JavaThread* calling_thread = JavaThread::current();
 
   // growable array of jvmti monitors info on the C-heap
   GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =
       new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, true);
 
   // It is only safe to perform the direct operation on the current
   // thread. All other usage needs to use a direct handshake for safety.
-  if (java_thread == JavaThread::current()) {
-    err = get_owned_monitors(java_thread, owned_monitors_list);
+  if (java_thread == calling_thread) {
+    err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);
   } else {
     // get owned monitors info with handshake
-    GetOwnedMonitorInfoClosure op(this, owned_monitors_list);
+    GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);
     Handshake::execute_direct(&op, java_thread);
     err = op.result();
   }
   jint owned_monitor_count = owned_monitors_list->length();
   if (err == JVMTI_ERROR_NONE) {
@@ -1242,22 +1243,23 @@
 // monitor_info_count_ptr - pre-checked for NULL
 // monitor_info_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetOwnedMonitorStackDepthInfo(JavaThread* java_thread, jint* monitor_info_count_ptr, jvmtiMonitorStackDepthInfo** monitor_info_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
+  JavaThread* calling_thread = JavaThread::current();
 
   // growable array of jvmti monitors info on the C-heap
   GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =
          new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, true);
 
   // It is only safe to perform the direct operation on the current
   // thread. All other usage needs to use a direct handshake for safety.
-  if (java_thread == JavaThread::current()) {
-    err = get_owned_monitors(java_thread, owned_monitors_list);
+  if (java_thread == calling_thread) {
+    err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);
   } else {
     // get owned monitors info with handshake
-    GetOwnedMonitorInfoClosure op(this, owned_monitors_list);
+    GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);
     Handshake::execute_direct(&op, java_thread);
     err = op.result();
   }
 
   jint owned_monitor_count = owned_monitors_list->length();
@@ -1289,18 +1291,19 @@
 // java_thread - pre-checked
 // monitor_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetCurrentContendedMonitor(JavaThread* java_thread, jobject* monitor_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
+  JavaThread* calling_thread = JavaThread::current();
 
   // It is only safe to perform the direct operation on the current
   // thread. All other usage needs to use a direct handshake for safety.
-  if (java_thread == JavaThread::current()) {
-    err = get_current_contended_monitor(java_thread, monitor_ptr);
+  if (java_thread == calling_thread) {
+    err = get_current_contended_monitor(calling_thread, java_thread, monitor_ptr);
   } else {
     // get contended monitor information with handshake
-    GetCurrentContendedMonitorClosure op(this, monitor_ptr);
+    GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr);
     Handshake::execute_direct(&op, java_thread);
     err = op.result();
   }
   return err;
 } /* end GetCurrentContendedMonitor */
diff a/src/hotspot/share/prims/jvmtiEnvBase.cpp b/src/hotspot/share/prims/jvmtiEnvBase.cpp
--- a/src/hotspot/share/prims/jvmtiEnvBase.cpp
+++ b/src/hotspot/share/prims/jvmtiEnvBase.cpp
@@ -645,11 +645,11 @@
 }
 
 
 
 jvmtiError
-JvmtiEnvBase::get_current_contended_monitor(JavaThread *java_thread, jobject *monitor_ptr) {
+JvmtiEnvBase::get_current_contended_monitor(JavaThread *calling_thread, JavaThread *java_thread, jobject *monitor_ptr) {
   JavaThread *current_jt = JavaThread::current();
   assert(current_jt == java_thread ||
          current_jt == java_thread->active_handshaker(),
          "call by myself or at direct handshake");
   oop obj = NULL;
@@ -675,18 +675,18 @@
   if (obj == NULL) {
     *monitor_ptr = NULL;
   } else {
     HandleMark hm;
     Handle     hobj(current_jt, obj);
-    *monitor_ptr = jni_reference(current_jt, hobj);
+    *monitor_ptr = jni_reference(calling_thread, hobj);
   }
   return JVMTI_ERROR_NONE;
 }
 
 
 jvmtiError
-JvmtiEnvBase::get_owned_monitors(JavaThread* java_thread,
+JvmtiEnvBase::get_owned_monitors(JavaThread *calling_thread, JavaThread* java_thread,
                                  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list) {
   jvmtiError err = JVMTI_ERROR_NONE;
   JavaThread *current_jt = JavaThread::current();
   assert(current_jt == java_thread ||
          current_jt == java_thread->active_handshaker(),
@@ -700,20 +700,20 @@
     int depth = 0;
     for (javaVFrame *jvf = java_thread->last_java_vframe(&reg_map); jvf != NULL;
          jvf = jvf->java_sender()) {
       if (MaxJavaStackTraceDepth == 0 || depth++ < MaxJavaStackTraceDepth) {  // check for stack too deep
         // add locked objects for this frame into list
-        err = get_locked_objects_in_frame(current_jt, java_thread, jvf, owned_monitors_list, depth-1);
+        err = get_locked_objects_in_frame(calling_thread, java_thread, jvf, owned_monitors_list, depth-1);
         if (err != JVMTI_ERROR_NONE) {
           return err;
         }
       }
     }
   }
 
   // Get off stack monitors. (e.g. acquired via jni MonitorEnter).
-  JvmtiMonitorClosure jmc(java_thread, current_jt, owned_monitors_list, this);
+  JvmtiMonitorClosure jmc(java_thread, calling_thread, owned_monitors_list, this);
   ObjectSynchronizer::monitors_iterate(&jmc);
   err = jmc.error();
 
   return err;
 }
@@ -1546,16 +1546,16 @@
   }
 }
 
 void
 GetOwnedMonitorInfoClosure::do_thread(Thread *target) {
-  _result = ((JvmtiEnvBase *)_env)->get_owned_monitors((JavaThread *)target, _owned_monitors_list);
+  _result = ((JvmtiEnvBase *)_env)->get_owned_monitors(_calling_thread, (JavaThread *)target, _owned_monitors_list);
 }
 
 void
 GetCurrentContendedMonitorClosure::do_thread(Thread *target) {
-  _result = ((JvmtiEnvBase *)_env)->get_current_contended_monitor((JavaThread *)target, _owned_monitor_ptr);
+  _result = ((JvmtiEnvBase *)_env)->get_current_contended_monitor(_calling_thread, (JavaThread *)target, _owned_monitor_ptr);
 }
 
 void
 VM_GetStackTrace::doit() {
   _result = JVMTI_ERROR_THREAD_NOT_ALIVE;
diff a/src/hotspot/share/prims/jvmtiEnvBase.hpp b/src/hotspot/share/prims/jvmtiEnvBase.hpp
--- a/src/hotspot/share/prims/jvmtiEnvBase.hpp
+++ b/src/hotspot/share/prims/jvmtiEnvBase.hpp
@@ -300,13 +300,13 @@
   jvmtiError get_object_monitor_usage(JavaThread *calling_thread,
                                                     jobject object, jvmtiMonitorUsage* info_ptr);
   jvmtiError get_stack_trace(JavaThread *java_thread,
                                            jint stack_depth, jint max_count,
                                            jvmtiFrameInfo* frame_buffer, jint* count_ptr);
-  jvmtiError get_current_contended_monitor(JavaThread *java_thread,
+  jvmtiError get_current_contended_monitor(JavaThread *calling_thread, JavaThread *java_thread,
                                            jobject *monitor_ptr);
-  jvmtiError get_owned_monitors(JavaThread* java_thread,
+  jvmtiError get_owned_monitors(JavaThread *calling_thread, JavaThread* java_thread,
                                 GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list);
   jvmtiError check_top_frame(JavaThread* current_thread, JavaThread* java_thread,
                              jvalue value, TosState tos, Handle* ret_ob_h);
   jvmtiError force_early_return(JavaThread* java_thread, jvalue value, TosState tos);
 };
@@ -374,23 +374,25 @@
 
 
 // HandshakeClosure to get monitor information with stack depth.
 class GetOwnedMonitorInfoClosure : public HandshakeClosure {
 private:
+  JavaThread* _calling_thread;
   JvmtiEnv *_env;
   jvmtiError _result;
   GrowableArray<jvmtiMonitorStackDepthInfo*> *_owned_monitors_list;
 
 public:
-  GetOwnedMonitorInfoClosure(JvmtiEnv* env,
+  GetOwnedMonitorInfoClosure(JavaThread* calling_thread, JvmtiEnv* env,
                              GrowableArray<jvmtiMonitorStackDepthInfo*>* owned_monitor_list)
     : HandshakeClosure("GetOwnedMonitorInfo"),
+      _calling_thread(calling_thread),
       _env(env),
       _result(JVMTI_ERROR_NONE),
       _owned_monitors_list(owned_monitor_list) {}
-  void do_thread(Thread *target);
   jvmtiError result() { return _result; }
+  void do_thread(Thread *target);
 };
 
 
 // VM operation to get object monitor usage.
 class VM_GetObjectMonitorUsage : public VM_Operation {
@@ -417,17 +419,19 @@
 };
 
 // HandshakeClosure to get current contended monitor.
 class GetCurrentContendedMonitorClosure : public HandshakeClosure {
 private:
+  JavaThread *_calling_thread;
   JvmtiEnv *_env;
   jobject *_owned_monitor_ptr;
   jvmtiError _result;
 
 public:
-  GetCurrentContendedMonitorClosure(JvmtiEnv *env, jobject *mon_ptr)
+  GetCurrentContendedMonitorClosure(JavaThread* calling_thread, JvmtiEnv *env, jobject *mon_ptr)
     : HandshakeClosure("GetCurrentContendedMonitor"),
+      _calling_thread(calling_thread),
       _env(env),
       _owned_monitor_ptr(mon_ptr),
       _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}
   jvmtiError result() { return _result; }
   void do_thread(Thread *target);
diff a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
--- a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
@@ -68,12 +68,13 @@
 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
 Method**  VM_RedefineClasses::_added_methods        = NULL;
 int       VM_RedefineClasses::_matching_methods_length = 0;
 int       VM_RedefineClasses::_deleted_methods_length  = 0;
 int       VM_RedefineClasses::_added_methods_length    = 0;
+
+// This flag is global as the constructor does not reset it:
 bool      VM_RedefineClasses::_has_redefined_Object = false;
-bool      VM_RedefineClasses::_has_null_class_loader = false;
 u8        VM_RedefineClasses::_id_counter = 0;
 
 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
                                        const jvmtiClassDefinition *class_defs,
                                        JvmtiClassLoadKind class_load_kind) {
@@ -81,12 +82,10 @@
   _class_defs = class_defs;
   _class_load_kind = class_load_kind;
   _any_class_has_resolved_methods = false;
   _res = JVMTI_ERROR_NONE;
   _the_class = NULL;
-  _has_redefined_Object = false;
-  _has_null_class_loader = false;
   _id = next_id();
 }
 
 static inline InstanceKlass* get_ik(jclass def) {
   oop mirror = JNIHandles::resolve_non_null(def);
@@ -3595,11 +3594,14 @@
   // This is a very busy routine. We don't want too much tracing
   // printed out.
   bool trace_name_printed = false;
 
   // If the class being redefined is java.lang.Object, we need to fix all
-  // array class vtables also
+  // array class vtables also. The _has_redefined_Object flag is global.
+  // Once the java.lang.Object has been redefined (by the current or one
+  // of the previous VM_RedefineClasses operations) we have to always
+  // adjust method entries for array classes.
   if (k->is_array_klass() && _has_redefined_Object) {
     k->vtable().adjust_method_entries(&trace_name_printed);
 
   } else if (k->is_instance_klass()) {
     HandleMark hm(_thread);
@@ -3613,26 +3615,10 @@
       if (methods->at(index)->method_data() != NULL) {
         methods->at(index)->method_data()->clean_weak_method_links();
       }
     }
 
-    // HotSpot specific optimization! HotSpot does not currently
-    // support delegation from the bootstrap class loader to a
-    // user-defined class loader. This means that if the bootstrap
-    // class loader is the initiating class loader, then it will also
-    // be the defining class loader. This also means that classes
-    // loaded by the bootstrap class loader cannot refer to classes
-    // loaded by a user-defined class loader. Note: a user-defined
-    // class loader can delegate to the bootstrap class loader.
-    //
-    // If the current class being redefined has a user-defined class
-    // loader as its defining class loader, then we can skip all
-    // classes loaded by the bootstrap class loader.
-    if (!_has_null_class_loader && ik->class_loader() == NULL) {
-      return;
-    }
-
     // Adjust all vtables, default methods and itables, to clean out old methods.
     ResourceMark rm(_thread);
     if (ik->vtable_length() > 0) {
       ik->vtable().adjust_method_entries(&trace_name_printed);
       ik->adjust_default_methods(&trace_name_printed);
@@ -3647,25 +3633,28 @@
     // other_cp's cache. If other_cp has a previous version, then we
     // have to repeat the process for each previous version. The
     // constant pool cache holds the Method*s for non-virtual
     // methods and for virtual, final methods.
     //
-    // Special case: if the current class being redefined, then new_cp
-    // has already been attached to the_class and old_cp has already
-    // been added as a previous version. The new_cp doesn't have any
-    // cached references to old methods so it doesn't need to be
-    // updated. We can simply start with the previous version(s) in
-    // that case.
+    // Special case: if the current class is being redefined by the current
+    // VM_RedefineClasses operation, then new_cp has already been attached
+    // to the_class and old_cp has already been added as a previous version.
+    // The new_cp doesn't have any cached references to old methods so it
+    // doesn't need to be updated and we could optimize by skipping it.
+    // However, the current class can be marked as being redefined by another
+    // VM_RedefineClasses operation which has already executed its doit_prologue
+    // and needs cpcache method entries adjusted. For simplicity, the cpcache
+    // update is done unconditionally. It should result in doing nothing for
+    // classes being redefined by the current VM_RedefineClasses operation.
+    // Method entries in the previous version(s) are adjusted as well.
     ConstantPoolCache* cp_cache;
 
-    if (!ik->is_being_redefined()) {
-      // this klass' constant pool cache may need adjustment
-      ConstantPool* other_cp = ik->constants();
-      cp_cache = other_cp->cache();
-      if (cp_cache != NULL) {
-        cp_cache->adjust_method_entries(&trace_name_printed);
-      }
+    // this klass' constant pool cache may need adjustment
+    ConstantPool* other_cp = ik->constants();
+    cp_cache = other_cp->cache();
+    if (cp_cache != NULL) {
+      cp_cache->adjust_method_entries(&trace_name_printed);
     }
 
     // the previous versions' constant pool caches may need adjustment
     for (InstanceKlass* pv_node = ik->previous_versions();
          pv_node != NULL;
@@ -4106,13 +4095,12 @@
     _timer_rsc_phase1.start();
   }
 
   InstanceKlass* the_class = get_ik(the_jclass);
 
-  // Set some flags to control and optimize adjusting method entries
+  // Set a flag to control and optimize adjusting method entries
   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
-  _has_null_class_loader |= the_class->class_loader() == NULL;
 
   // Remove all breakpoints in methods of this class
   JvmtiBreakpoints& jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
 
diff a/src/hotspot/share/runtime/arguments.cpp b/src/hotspot/share/runtime/arguments.cpp
--- a/src/hotspot/share/runtime/arguments.cpp
+++ b/src/hotspot/share/runtime/arguments.cpp
@@ -1465,10 +1465,16 @@
     key = tmp_key;
 
     value = &prop[key_len + 1];
   }
 
+  if (is_internal_module_property(key) ||
+      strcmp(key, "jdk.module.main") == 0) {
+    MetaspaceShared::disable_optimized_module_handling();
+    log_info(cds)("Using optimized module handling disabled due to incompatible property: %s=%s", key, value);
+  }
+
   if (strcmp(key, "java.compiler") == 0) {
     process_java_compiler_argument(value);
     // Record value in Arguments, but let it get passed to Java.
   } else if (strcmp(key, "sun.java.launcher.is_altjvm") == 0) {
     // sun.java.launcher.is_altjvm property is
@@ -2518,10 +2524,12 @@
           "-Xbootclasspath is no longer a supported option.\n");
         return JNI_EINVAL;
     // -bootclasspath/a:
     } else if (match_option(option, "-Xbootclasspath/a:", &tail)) {
       Arguments::append_sysclasspath(tail);
+      MetaspaceShared::disable_optimized_module_handling();
+      log_info(cds)("Using optimized module handling disabled due to bootclasspath was appended");
     // -bootclasspath/p:
     } else if (match_option(option, "-Xbootclasspath/p:", &tail)) {
         jio_fprintf(defaultStream::output_stream(),
           "-Xbootclasspath/p is no longer a supported option.\n");
         return JNI_EINVAL;
diff a/src/hotspot/share/services/virtualMemoryTracker.cpp b/src/hotspot/share/services/virtualMemoryTracker.cpp
--- a/src/hotspot/share/services/virtualMemoryTracker.cpp
+++ b/src/hotspot/share/services/virtualMemoryTracker.cpp
@@ -28,10 +28,11 @@
 #include "runtime/os.hpp"
 #include "runtime/threadCritical.hpp"
 #include "services/memTracker.hpp"
 #include "services/threadStackTracker.hpp"
 #include "services/virtualMemoryTracker.hpp"
+#include "utilities/ostream.hpp"
 
 size_t VirtualMemorySummary::_snapshot[CALC_OBJ_SIZE_IN_TYPE(VirtualMemorySnapshot, size_t)];
 
 void VirtualMemorySummary::initialize() {
   assert(sizeof(_snapshot) >= sizeof(VirtualMemorySnapshot), "Sanity Check");
@@ -286,11 +287,13 @@
   }
   return committed;
 }
 
 void ReservedMemoryRegion::set_flag(MEMFLAGS f) {
-  assert((flag() == mtNone || flag() == f), "Overwrite memory type");
+  assert((flag() == mtNone || flag() == f),
+         "Overwrite memory type for region [" PTR_FORMAT "-" PTR_FORMAT "), %u->%u.",
+         p2i(base()), p2i(end()), (unsigned)flag(), (unsigned)f);
   if (flag() != f) {
     VirtualMemorySummary::move_reserved_memory(flag(), f, size());
     VirtualMemorySummary::move_committed_memory(flag(), f, committed_size());
     _flag = f;
   }
@@ -383,10 +386,17 @@
       if (reserved_rgn->flag() == mtJavaHeap) {
         assert(reserved_rgn->contain_region(base_addr, size), "Reserved heap region should contain this mapping region");
         return true;
       }
 
+      // Print some more details. Don't use UL here to avoid circularities.
+#ifdef ASSERT
+      tty->print_cr("Error: existing region: [" PTR_FORMAT "-" PTR_FORMAT "), flag %u.\n"
+                    "       new region: [" PTR_FORMAT "-" PTR_FORMAT "), flag %u.",
+                    p2i(reserved_rgn->base()), p2i(reserved_rgn->end()), (unsigned)reserved_rgn->flag(),
+                    p2i(base_addr), p2i(base_addr + size), (unsigned)flag);
+#endif
       ShouldNotReachHere();
       return false;
     }
   }
 }
diff a/src/java.base/share/classes/java/lang/AbstractStringBuilder.java b/src/java.base/share/classes/java/lang/AbstractStringBuilder.java
--- a/src/java.base/share/classes/java/lang/AbstractStringBuilder.java
+++ b/src/java.base/share/classes/java/lang/AbstractStringBuilder.java
@@ -29,10 +29,11 @@
 
 import java.util.Arrays;
 import java.util.Spliterator;
 import java.util.stream.IntStream;
 import java.util.stream.StreamSupport;
+import jdk.internal.util.ArraysSupport;
 
 import static java.lang.String.COMPACT_STRINGS;
 import static java.lang.String.UTF16;
 import static java.lang.String.LATIN1;
 import static java.lang.String.checkIndex;
@@ -237,41 +238,29 @@
      */
     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
 
     /**
      * Returns a capacity at least as large as the given minimum capacity.
-     * Returns the current capacity increased by the same amount + 2 if
+     * Returns the current capacity increased by the current length + 2 if
      * that suffices.
      * Will not return a capacity greater than
      * {@code (MAX_ARRAY_SIZE >> coder)} unless the given minimum capacity
      * is greater than that.
      *
      * @param  minCapacity the desired minimum capacity
      * @throws OutOfMemoryError if minCapacity is less than zero or
      *         greater than (Integer.MAX_VALUE >> coder)
      */
     private int newCapacity(int minCapacity) {
-        // overflow-conscious code
-        int oldCapacity = value.length >> coder;
-        int newCapacity = (oldCapacity << 1) + 2;
-        if (newCapacity - minCapacity < 0) {
-            newCapacity = minCapacity;
-        }
-        int SAFE_BOUND = MAX_ARRAY_SIZE >> coder;
-        return (newCapacity <= 0 || SAFE_BOUND - newCapacity < 0)
-            ? hugeCapacity(minCapacity)
-            : newCapacity;
-    }
-
-    private int hugeCapacity(int minCapacity) {
-        int SAFE_BOUND = MAX_ARRAY_SIZE >> coder;
-        int UNSAFE_BOUND = Integer.MAX_VALUE >> coder;
-        if (UNSAFE_BOUND - minCapacity < 0) { // overflow
-            throw new OutOfMemoryError();
+        int oldLength = value.length;
+        int newLength = minCapacity << coder;
+        int growth = newLength - oldLength;
+        int length = ArraysSupport.newLength(oldLength, growth, oldLength + (2 << coder));
+        if (length == Integer.MAX_VALUE) {
+            throw new OutOfMemoryError("Required length exceeds implementation limit");
         }
-        return (minCapacity > SAFE_BOUND)
-            ? minCapacity : SAFE_BOUND;
+        return length >> coder;
     }
 
     /**
      * If the coder is "isLatin1", this inflates the internal 8-bit storage
      * to 16-bit <hi=0, low> pair storage.
diff a/src/java.base/share/classes/java/lang/Module.java b/src/java.base/share/classes/java/lang/Module.java
--- a/src/java.base/share/classes/java/lang/Module.java
+++ b/src/java.base/share/classes/java/lang/Module.java
@@ -40,11 +40,10 @@
 import java.net.URL;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
@@ -1502,10 +1501,28 @@
                     return super.defineClass(cn, bytes, 0, bytes.length);
                 } else {
                     throw new ClassNotFoundException(cn);
                 }
             }
+            @Override
+            protected Class<?> loadClass(String cn, boolean resolve)
+                throws ClassNotFoundException
+            {
+                synchronized (getClassLoadingLock(cn)) {
+                    Class<?> c = findLoadedClass(cn);
+                    if (c == null) {
+                        if (cn.equals(MODULE_INFO)) {
+                            c = findClass(cn);
+                        } else {
+                            c = super.loadClass(cn, resolve);
+                        }
+                    }
+                    if (resolve)
+                        resolveClass(c);
+                    return c;
+                }
+            }
         };
 
         try {
             return cl.loadClass(MODULE_INFO);
         } catch (ClassNotFoundException e) {
diff a/src/java.base/share/classes/java/lang/String.java b/src/java.base/share/classes/java/lang/String.java
--- a/src/java.base/share/classes/java/lang/String.java
+++ b/src/java.base/share/classes/java/lang/String.java
@@ -2185,11 +2185,11 @@
             int resultLen;
             try {
                 resultLen = Math.addExact(thisLen, Math.multiplyExact(
                         Math.addExact(thisLen, 1), replLen));
             } catch (ArithmeticException ignored) {
-                throw new OutOfMemoryError();
+                throw new OutOfMemoryError("Required length exceeds implementation limit");
             }
 
             StringBuilder sb = new StringBuilder(resultLen);
             sb.append(replStr);
             for (int i = 0; i < thisLen; ++i) {
@@ -3569,19 +3569,18 @@
         }
         final int len = value.length;
         if (len == 0 || count == 0) {
             return "";
         }
+        if (Integer.MAX_VALUE / count < len) {
+            throw new OutOfMemoryError("Required length exceeds implementation limit");
+        }
         if (len == 1) {
             final byte[] single = new byte[count];
             Arrays.fill(single, value[0]);
             return new String(single, coder);
         }
-        if (Integer.MAX_VALUE / count < len) {
-            throw new OutOfMemoryError("Repeating " + len + " bytes String " + count +
-                    " times will produce a String exceeding maximum size.");
-        }
         final int limit = len * count;
         final byte[] multiple = new byte[limit];
         System.arraycopy(value, 0, multiple, 0, len);
         int copied = len;
         for (; copied < limit - copied; copied <<= 1) {
diff a/src/java.base/share/classes/java/lang/StringLatin1.java b/src/java.base/share/classes/java/lang/StringLatin1.java
--- a/src/java.base/share/classes/java/lang/StringLatin1.java
+++ b/src/java.base/share/classes/java/lang/StringLatin1.java
@@ -355,11 +355,11 @@
         int resultLen;
         try {
             resultLen = Math.addExact(valLen,
                     Math.multiplyExact(++p, replLen - targLen));
         } catch (ArithmeticException ignored) {
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Required length exceeds implementation limit");
         }
         if (resultLen == 0) {
             return "";
         }
 
diff a/src/java.base/share/classes/java/lang/StringUTF16.java b/src/java.base/share/classes/java/lang/StringUTF16.java
--- a/src/java.base/share/classes/java/lang/StringUTF16.java
+++ b/src/java.base/share/classes/java/lang/StringUTF16.java
@@ -659,11 +659,11 @@
         int resultLen;
         try {
             resultLen = Math.addExact(valLen,
                     Math.multiplyExact(++p, replLen - targLen));
         } catch (ArithmeticException ignored) {
-            throw new OutOfMemoryError();
+           throw new OutOfMemoryError("Required length exceeds implementation limit");
         }
         if (resultLen == 0) {
             return "";
         }
 
diff a/src/java.base/share/classes/java/lang/annotation/Annotation.java b/src/java.base/share/classes/java/lang/annotation/Annotation.java
--- a/src/java.base/share/classes/java/lang/annotation/Annotation.java
+++ b/src/java.base/share/classes/java/lang/annotation/Annotation.java
@@ -29,11 +29,11 @@
  * The common interface extended by all annotation types.  Note that an
  * interface that manually extends this one does <i>not</i> define
  * an annotation type.  Also note that this interface does not itself
  * define an annotation type.
  *
- * More information about annotation types can be found in section 9.6 of
+ * More information about annotation types can be found in section {@jls 9.6} of
  * <cite>The Java&trade; Language Specification</cite>.
  *
  * The {@link java.lang.reflect.AnnotatedElement} interface discusses
  * compatibility concerns when evolving an annotation type from being
  * non-repeatable to being repeatable.
@@ -70,30 +70,28 @@
      *    are considered equal if {@code x.equals(y)}.  (Note that this
      *    definition is recursive for annotation typed members.)
      *
      *    <li>Two corresponding array typed members {@code x} and {@code y}
      *    are considered equal if {@code Arrays.equals(x, y)}, for the
-     *    appropriate overloading of {@link java.util.Arrays#equals}.
+     *    appropriate overloading of {@link java.util.Arrays#equals Arrays.equals}.
      * </ul>
      *
      * @return true if the specified object represents an annotation
      *     that is logically equivalent to this one, otherwise false
      */
     boolean equals(Object obj);
 
     /**
-     * Returns the hash code of this annotation, as defined below:
+     * Returns the hash code of this annotation.
      *
      * <p>The hash code of an annotation is the sum of the hash codes
-     * of its members (including those with default values), as defined
-     * below:
+     * of its members (including those with default values).
      *
      * The hash code of an annotation member is (127 times the hash code
      * of the member-name as computed by {@link String#hashCode()}) XOR
-     * the hash code of the member-value, as defined below:
-     *
-     * <p>The hash code of a member-value depends on its type:
+     * the hash code of the member-value.
+     * The hash code of a member-value depends on its type as defined below:
      * <ul>
      * <li>The hash code of a primitive value <i>{@code v}</i> is equal to
      *     <code><i>WrapperType</i>.valueOf(<i>v</i>).hashCode()</code>, where
      *     <i>{@code WrapperType}</i> is the wrapper type corresponding
      *     to the primitive type of <i>{@code v}</i> ({@link Byte},
@@ -119,18 +117,26 @@
     /**
      * Returns a string representation of this annotation.  The details
      * of the representation are implementation-dependent, but the following
      * may be regarded as typical:
      * <pre>
-     *   &#064;com.acme.util.Name(first=Alfred, middle=E., last=Neuman)
+     *   &#064;com.example.Name(first="Duke", middle="of", last="Java")
      * </pre>
      *
      * @return a string representation of this annotation
      */
     String toString();
 
     /**
      * Returns the annotation type of this annotation.
+     *
+     * @apiNote Implementation-dependent classes are used to provide
+     * the implementations of annotations. Therefore, calling {@link
+     * Object#getClass getClass} on an annotation will return an
+     * implementation-dependent class. In contrast, this method will
+     * reliably return the annotation type of the annotation.
+     *
      * @return the annotation type of this annotation
+     * @see Enum#getDeclaringClass
      */
     Class<? extends Annotation> annotationType();
 }
diff a/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java b/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
--- a/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
+++ b/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
@@ -444,11 +444,11 @@
     /**
      * Generate a class file for the proxy class.  This method drives the
      * class file generation process.
      */
     private byte[] generateClassFile() {
-        visit(V15, accessFlags, dotToSlash(className), null,
+        visit(V16, accessFlags, dotToSlash(className), null,
                 JLR_PROXY, typeNames(interfaces));
 
         /*
          * Add proxy methods for the hashCode, equals,
          * and toString methods of java.lang.Object.  This is done before
diff a/src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java b/src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java
--- a/src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java
+++ b/src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java
@@ -51,10 +51,11 @@
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import jdk.internal.access.SharedSecrets;
+import jdk.internal.util.ArraysSupport;
 
 /**
  * An unbounded {@linkplain BlockingQueue blocking queue} that uses
  * the same ordering rules as class {@link PriorityQueue} and supplies
  * blocking retrieval operations.  While this queue is logically
@@ -134,18 +135,10 @@
     /**
      * Default array capacity.
      */
     private static final int DEFAULT_INITIAL_CAPACITY = 11;
 
-    /**
-     * The maximum size of array to allocate.
-     * Some VMs reserve some header words in an array.
-     * Attempts to allocate larger arrays may result in
-     * OutOfMemoryError: Requested array size exceeds VM limit
-     */
-    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
-
     /**
      * Priority queue represented as a balanced binary heap: the two
      * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The
      * priority queue is ordered by comparator, or by the elements'
      * natural ordering, if comparator is null: For each node n in the
@@ -296,20 +289,13 @@
         lock.unlock(); // must release and then re-acquire main lock
         Object[] newArray = null;
         if (allocationSpinLock == 0 &&
             ALLOCATIONSPINLOCK.compareAndSet(this, 0, 1)) {
             try {
-                int newCap = oldCap + ((oldCap < 64) ?
-                                       (oldCap + 2) : // grow faster if small
-                                       (oldCap >> 1));
-                if (newCap - MAX_ARRAY_SIZE > 0) {    // possible overflow
-                    int minCap = oldCap + 1;
-                    if (minCap < 0 || minCap > MAX_ARRAY_SIZE)
-                        throw new OutOfMemoryError();
-                    newCap = MAX_ARRAY_SIZE;
-                }
-                if (newCap > oldCap && queue == array)
+                int growth = oldCap < 64 ? oldCap + 2 : oldCap >> 1;
+                int newCap = ArraysSupport.newLength(oldCap, 1, growth);
+                if (queue == array)
                     newArray = new Object[newCap];
             } finally {
                 allocationSpinLock = 0;
             }
         }
diff a/src/java.base/share/classes/java/util/regex/Pattern.java b/src/java.base/share/classes/java/util/regex/Pattern.java
--- a/src/java.base/share/classes/java/util/regex/Pattern.java
+++ b/src/java.base/share/classes/java/util/regex/Pattern.java
@@ -1679,11 +1679,11 @@
         i += 2;
         int newTempLen;
         try {
             newTempLen = Math.addExact(j + 2, Math.multiplyExact(3, pLen - i));
         } catch (ArithmeticException ae) {
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Required pattern length too large");
         }
         int[] newtemp = new int[newTempLen];
         System.arraycopy(temp, 0, newtemp, 0, j);
 
         boolean inQuote = true;
diff a/src/java.base/share/classes/java/util/zip/ZipEntry.java b/src/java.base/share/classes/java/util/zip/ZipEntry.java
--- a/src/java.base/share/classes/java/util/zip/ZipEntry.java
+++ b/src/java.base/share/classes/java/util/zip/ZipEntry.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -131,15 +131,10 @@
         flag = e.flag;
         extra = e.extra;
         comment = e.comment;
     }
 
-    /**
-     * Creates a new un-initialized zip entry
-     */
-    ZipEntry() {}
-
     /**
      * Returns the name of the entry.
      * @return the name of the entry
      */
     public String getName() {
@@ -165,14 +160,19 @@
      */
     public void setTime(long time) {
         this.xdostime = javaToExtendedDosTime(time);
         // Avoid setting the mtime field if time is in the valid
         // range for a DOS time
-        if (xdostime != DOSTIME_BEFORE_1980 && time <= UPPER_DOSTIME_BOUND) {
+        if (this.xdostime != DOSTIME_BEFORE_1980 && time <= UPPER_DOSTIME_BOUND) {
             this.mtime = null;
         } else {
-            this.mtime = FileTime.from(time, TimeUnit.MILLISECONDS);
+            int localYear = javaEpochToLocalDateTime(time).getYear();
+            if (localYear >= 1980 && localYear <= 2099) {
+                this.mtime = null;
+            } else {
+                this.mtime = FileTime.from(time, TimeUnit.MILLISECONDS);
+            }
         }
     }
 
     /**
      * Returns the last modification time of the entry.
diff a/src/java.base/share/classes/java/util/zip/ZipUtils.java b/src/java.base/share/classes/java/util/zip/ZipUtils.java
--- a/src/java.base/share/classes/java/util/zip/ZipUtils.java
+++ b/src/java.base/share/classes/java/util/zip/ZipUtils.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -129,18 +129,12 @@
     }
 
     /**
      * Converts Java time to DOS time.
      */
-    private static long javaToDosTime(long time) {
-        Instant instant = Instant.ofEpochMilli(time);
-        LocalDateTime ldt = LocalDateTime.ofInstant(
-                instant, ZoneId.systemDefault());
+    private static long javaToDosTime(LocalDateTime ldt) {
         int year = ldt.getYear() - 1980;
-        if (year < 0) {
-            return (1 << 21) | (1 << 16);
-        }
         return (year << 25 |
             ldt.getMonthValue() << 21 |
             ldt.getDayOfMonth() << 16 |
             ldt.getHour() << 11 |
             ldt.getMinute() << 5 |
@@ -152,18 +146,21 @@
      * in the conversion into the upper half of the returned long.
      *
      * @param time milliseconds since epoch
      * @return DOS time with 2s remainder encoded into upper half
      */
-    public static long javaToExtendedDosTime(long time) {
-        if (time < 0) {
-            return ZipEntry.DOSTIME_BEFORE_1980;
+    static long javaToExtendedDosTime(long time) {
+        LocalDateTime ldt = javaEpochToLocalDateTime(time);
+        if (ldt.getYear() >= 1980) {
+            return javaToDosTime(ldt) + ((time % 2000) << 32);
         }
-        long dostime = javaToDosTime(time);
-        return (dostime != ZipEntry.DOSTIME_BEFORE_1980)
-                ? dostime + ((time % 2000) << 32)
-                : ZipEntry.DOSTIME_BEFORE_1980;
+        return ZipEntry.DOSTIME_BEFORE_1980;
+    }
+
+    static LocalDateTime javaEpochToLocalDateTime(long time) {
+        Instant instant = Instant.ofEpochMilli(time);
+        return LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
     }
 
     /**
      * Fetches unsigned 16-bit value from byte array at specified offset.
      * The bytes are assumed to be in Intel (little-endian) byte order.
diff a/src/java.base/share/classes/javax/net/ssl/ExtendedSSLSession.java b/src/java.base/share/classes/javax/net/ssl/ExtendedSSLSession.java
--- a/src/java.base/share/classes/javax/net/ssl/ExtendedSSLSession.java
+++ b/src/java.base/share/classes/javax/net/ssl/ExtendedSSLSession.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,10 +32,15 @@
  * session attributes.
  *
  * @since 1.7
  */
 public abstract class ExtendedSSLSession implements SSLSession {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public ExtendedSSLSession() {}
+
     /**
      * Obtains an array of supported signature algorithms that the local side
      * is willing to use.
      * <p>
      * Note: this method is used to indicate to the peer which signature
diff a/src/java.base/share/classes/javax/net/ssl/KeyManagerFactorySpi.java b/src/java.base/share/classes/javax/net/ssl/KeyManagerFactorySpi.java
--- a/src/java.base/share/classes/javax/net/ssl/KeyManagerFactorySpi.java
+++ b/src/java.base/share/classes/javax/net/ssl/KeyManagerFactorySpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -38,10 +38,15 @@
  * @since 1.4
  * @see KeyManagerFactory
  * @see KeyManager
  */
 public abstract class KeyManagerFactorySpi {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public KeyManagerFactorySpi() {}
+
     /**
      * Initializes this factory with a source of key material.
      *
      * @param ks the key store or null
      * @param password the password for recovering keys
diff a/src/java.base/share/classes/javax/net/ssl/SSLContextSpi.java b/src/java.base/share/classes/javax/net/ssl/SSLContextSpi.java
--- a/src/java.base/share/classes/javax/net/ssl/SSLContextSpi.java
+++ b/src/java.base/share/classes/javax/net/ssl/SSLContextSpi.java
@@ -37,10 +37,15 @@
  *
  * @since 1.4
  * @see SSLContext
  */
 public abstract class SSLContextSpi {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public SSLContextSpi() {}
+
     /**
      * Initializes this context.
      *
      * @param km the sources of authentication keys
      * @param tm the sources of peer authentication trust decisions
diff a/src/java.base/share/classes/javax/net/ssl/TrustManagerFactorySpi.java b/src/java.base/share/classes/javax/net/ssl/TrustManagerFactorySpi.java
--- a/src/java.base/share/classes/javax/net/ssl/TrustManagerFactorySpi.java
+++ b/src/java.base/share/classes/javax/net/ssl/TrustManagerFactorySpi.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -38,10 +38,15 @@
  * @since 1.4
  * @see TrustManagerFactory
  * @see TrustManager
  */
 public abstract class TrustManagerFactorySpi {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public TrustManagerFactorySpi() {}
+
     /**
      * Initializes this factory with a source of certificate
      * authorities and related trust material.
      *
      * @param ks the key store or null
diff a/src/java.base/share/classes/javax/net/ssl/X509ExtendedTrustManager.java b/src/java.base/share/classes/javax/net/ssl/X509ExtendedTrustManager.java
--- a/src/java.base/share/classes/javax/net/ssl/X509ExtendedTrustManager.java
+++ b/src/java.base/share/classes/javax/net/ssl/X509ExtendedTrustManager.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -52,10 +52,15 @@
  * @see HostnameVerifier
  *
  * @since 1.7
  */
 public abstract class X509ExtendedTrustManager implements X509TrustManager {
+    /**
+     * Constructor for subclasses to call.
+     */
+    public X509ExtendedTrustManager() {}
+
     /**
      * Given the partial or complete certificate chain provided by the
      * peer, build and validate the certificate path based on the
      * authentication type and ssl parameters.
      * <p>
diff a/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java b/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java
--- a/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java
+++ b/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java
@@ -91,11 +91,11 @@
             Function<Class<?>, Z> resFunc, Consumer<? super C> builder) {
 
         IsolatedMethodBuilder isolatedMethodBuilder = new IsolatedMethodBuilder(className, lookup);
         isolatedMethodBuilder
                 .withSuperclass(Object.class)
-                .withMajorVersion(59)
+                .withMajorVersion(60)
                 .withMinorVersion(0)
                 .withFlags(Flag.ACC_PUBLIC)
                 .withMethod(methodName, type, M ->
                         M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)
                                 .withCode(builderFunc, builder));
diff a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
--- a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
+++ b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
@@ -747,11 +747,11 @@
             return 0;
         }
 
         long p = allocateMemory0(bytes);
         if (p == 0) {
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Unable to allocate " + bytes + " bytes");
         }
 
         return p;
     }
 
@@ -803,11 +803,11 @@
             return 0;
         }
 
         long p = (address == 0) ? allocateMemory0(bytes) : reallocateMemory0(address, bytes);
         if (p == 0) {
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Unable to allocate " + bytes + " bytes");
         }
 
         return p;
     }
 
diff a/src/java.base/share/classes/jdk/internal/module/ModuleInfoWriter.java b/src/java.base/share/classes/jdk/internal/module/ModuleInfoWriter.java
--- a/src/java.base/share/classes/jdk/internal/module/ModuleInfoWriter.java
+++ b/src/java.base/share/classes/jdk/internal/module/ModuleInfoWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -210,10 +210,18 @@
         throws IOException
     {
         write(descriptor, null, null, out);
     }
 
+    /**
+     * Returns a byte array containing the given module descriptor in
+     * module-info.class format.
+     */
+    public static byte[] toBytes(ModuleDescriptor descriptor) {
+        return toModuleInfo(descriptor, null, null);
+    }
+
     /**
      * Returns a {@code ByteBuffer} containing the given module descriptor
      * in module-info.class format.
      */
     public static ByteBuffer toByteBuffer(ModuleDescriptor descriptor) {
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
@@ -220,11 +220,11 @@
             final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
         this.classFileBuffer = classFileBuffer;
         this.b = classFileBuffer;
         // Check the class' major_version. This field is after the magic and minor_version fields, which
         // use 4 and 2 bytes respectively.
-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V15) {
+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V16) {
             throw new IllegalArgumentException(
                     "Unsupported class file major version " + readShort(classFileOffset + 6));
         }
         // Create the constant pool arrays. The constant_pool_count field is after the magic,
         // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
@@ -309,10 +309,11 @@
     int V11 = 0 << 16 | 55;
     int V12 = 0 << 16 | 56;
     int V13 = 0 << 16 | 57;
     int V14 = 0 << 16 | 58;
     int V15 = 0 << 16 | 59;
+    int V16 = 0 << 16 | 60;
 
     /**
       * Version flag indicating that the class is using 'preview' features.
       *
       * <p>{@code version & V_PREVIEW == V_PREVIEW} tests if a version is flagged with {@code
diff a/src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java b/src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java
--- a/src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java
+++ b/src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java
@@ -352,11 +352,11 @@
 
     @Override
     public SSLSession getSession() {
         try {
             // start handshaking, if failed, the connection will be closed.
-            ensureNegotiated();
+            ensureNegotiated(false);
         } catch (IOException ioe) {
             if (SSLLogger.isOn && SSLLogger.isOn("handshake")) {
                 SSLLogger.severe("handshake failed", ioe);
             }
 
@@ -407,10 +407,14 @@
         }
     }
 
     @Override
     public void startHandshake() throws IOException {
+        startHandshake(true);
+    }
+
+    private void startHandshake(boolean resumable) throws IOException {
         if (!isConnected) {
             throw new SocketException("Socket is not connected");
         }
 
         if (conContext.isBroken || conContext.isInboundClosed() ||
@@ -435,11 +439,16 @@
                 // Handle handshake messages only, need no application data.
                 if (!conContext.isNegotiated) {
                     readHandshakeRecord();
                 }
             } catch (InterruptedIOException iioe) {
-                handleException(iioe);
+                if(resumable){
+                    handleException(iioe);
+                } else{
+                    throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
+                            "Couldn't kickstart handshaking", iioe);
+                }
             } catch (IOException ioe) {
                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
                     "Couldn't kickstart handshaking", ioe);
             } catch (Exception oe) {    // including RuntimeException
                 handleException(oe);
@@ -865,11 +874,11 @@
         } finally {
             socketLock.unlock();
         }
     }
 
-    private void ensureNegotiated() throws IOException {
+    private void ensureNegotiated(boolean resumable) throws IOException {
         if (conContext.isNegotiated || conContext.isBroken ||
                 conContext.isInboundClosed() || conContext.isOutboundClosed()) {
             return;
         }
 
@@ -880,11 +889,11 @@
                     conContext.isInboundClosed() ||
                     conContext.isOutboundClosed()) {
                 return;
             }
 
-            startHandshake();
+            startHandshake(resumable);
         } finally {
             handshakeLock.unlock();
         }
     }
 
@@ -971,11 +980,11 @@
 
             // start handshaking if the connection has not been negotiated.
             if (!conContext.isNegotiated && !conContext.isBroken &&
                     !conContext.isInboundClosed() &&
                     !conContext.isOutboundClosed()) {
-                ensureNegotiated();
+                ensureNegotiated(true);
             }
 
             // Check if the Socket is invalid (error or closed).
             if (!conContext.isNegotiated ||
                     conContext.isBroken || conContext.isInboundClosed()) {
@@ -1250,11 +1259,11 @@
 
             // Start handshaking if the connection has not been negotiated.
             if (!conContext.isNegotiated && !conContext.isBroken &&
                     !conContext.isInboundClosed() &&
                     !conContext.isOutboundClosed()) {
-                ensureNegotiated();
+                ensureNegotiated(true);
             }
 
             // Check if the Socket is invalid (error or closed).
             if (!conContext.isNegotiated ||
                     conContext.isBroken || conContext.isOutboundClosed()) {
diff a/src/java.compiler/share/classes/javax/lang/model/SourceVersion.java b/src/java.compiler/share/classes/javax/lang/model/SourceVersion.java
--- a/src/java.compiler/share/classes/javax/lang/model/SourceVersion.java
+++ b/src/java.compiler/share/classes/javax/lang/model/SourceVersion.java
@@ -166,38 +166,38 @@
      * Additions in this release include local-variable type inference
      * ({@code var}).
      *
      * @since 10
      */
-     RELEASE_10,
+    RELEASE_10,
 
     /**
      * The version recognized by the Java Platform, Standard Edition
      * 11.
      *
      * Additions in this release include local-variable syntax for
      * lambda parameters.
      *
      * @since 11
      */
-     RELEASE_11,
+    RELEASE_11,
 
     /**
      * The version recognized by the Java Platform, Standard Edition
      * 12.
      *
      * @since 12
      */
-     RELEASE_12,
+    RELEASE_12,
 
     /**
      * The version recognized by the Java Platform, Standard Edition
      * 13.
      *
      * @since 13
      */
-     RELEASE_13,
+    RELEASE_13,
 
     /**
      * The version recognized by the Java Platform, Standard Edition
      * 14.
      *
@@ -213,22 +213,30 @@
      *
      * Additions in this release include text blocks.
      *
      * @since 15
      */
-     RELEASE_15;
+    RELEASE_15,
+
+    /**
+     * The version recognized by the Java Platform, Standard Edition
+     * 16.
+     *
+     * @since 16
+     */
+    RELEASE_16;
 
     // Note that when adding constants for newer releases, the
     // behavior of latest() and latestSupported() must be updated too.
 
     /**
      * Returns the latest source version that can be modeled.
      *
      * @return the latest source version that can be modeled
      */
     public static SourceVersion latest() {
-        return RELEASE_15;
+        return RELEASE_16;
     }
 
     private static final SourceVersion latestSupported = getLatestSupported();
 
     /*
@@ -239,11 +247,11 @@
      * need to be updated accordingly.
      */
     private static SourceVersion getLatestSupported() {
         int intVersion = Runtime.version().feature();
         return (intVersion >= 11) ?
-            valueOf("RELEASE_" + Math.min(15, intVersion)):
+            valueOf("RELEASE_" + Math.min(16, intVersion)):
             RELEASE_10;
     }
 
     /**
      * Returns the latest source version fully supported by the
diff a/src/java.compiler/share/classes/javax/lang/model/util/AbstractAnnotationValueVisitor14.java b/src/java.compiler/share/classes/javax/lang/model/util/AbstractAnnotationValueVisitor14.java
--- a/src/java.compiler/share/classes/javax/lang/model/util/AbstractAnnotationValueVisitor14.java
+++ b/src/java.compiler/share/classes/javax/lang/model/util/AbstractAnnotationValueVisitor14.java
@@ -42,11 +42,11 @@
  * @see AbstractAnnotationValueVisitor7
  * @see AbstractAnnotationValueVisitor8
  * @see AbstractAnnotationValueVisitor9
  * @since 14
  */
-@SupportedSourceVersion(RELEASE_15)
+@SupportedSourceVersion(RELEASE_16)
 public abstract class AbstractAnnotationValueVisitor14<R, P> extends AbstractAnnotationValueVisitor9<R, P> {
 
     /**
      * Constructor for concrete subclasses to call.
      */
diff a/src/java.compiler/share/classes/javax/lang/model/util/AbstractElementVisitor14.java b/src/java.compiler/share/classes/javax/lang/model/util/AbstractElementVisitor14.java
--- a/src/java.compiler/share/classes/javax/lang/model/util/AbstractElementVisitor14.java
+++ b/src/java.compiler/share/classes/javax/lang/model/util/AbstractElementVisitor14.java
@@ -56,11 +56,11 @@
  * @see AbstractElementVisitor9
  * @since 14
  */
 @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
                              essentialAPI=false)
-@SupportedSourceVersion(RELEASE_15)
+@SupportedSourceVersion(RELEASE_16)
 public abstract class AbstractElementVisitor14<R, P> extends AbstractElementVisitor9<R, P> {
     /**
      * Constructor for concrete subclasses to call.
      */
     protected AbstractElementVisitor14(){
diff a/src/java.compiler/share/classes/javax/lang/model/util/AbstractTypeVisitor14.java b/src/java.compiler/share/classes/javax/lang/model/util/AbstractTypeVisitor14.java
--- a/src/java.compiler/share/classes/javax/lang/model/util/AbstractTypeVisitor14.java
+++ b/src/java.compiler/share/classes/javax/lang/model/util/AbstractTypeVisitor14.java
@@ -45,11 +45,11 @@
  * @see AbstractTypeVisitor7
  * @see AbstractTypeVisitor8
  * @see AbstractTypeVisitor9
  * @since 14
  */
-@SupportedSourceVersion(RELEASE_15)
+@SupportedSourceVersion(RELEASE_16)
 public abstract class AbstractTypeVisitor14<R, P> extends AbstractTypeVisitor9<R, P> {
     /**
      * Constructor for concrete subclasses to call.
      */
     protected AbstractTypeVisitor14() {
diff a/src/java.compiler/share/classes/javax/lang/model/util/ElementKindVisitor14.java b/src/java.compiler/share/classes/javax/lang/model/util/ElementKindVisitor14.java
--- a/src/java.compiler/share/classes/javax/lang/model/util/ElementKindVisitor14.java
+++ b/src/java.compiler/share/classes/javax/lang/model/util/ElementKindVisitor14.java
@@ -68,11 +68,11 @@
  * @see ElementKindVisitor9
  * @since 14
  */
 @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
                              essentialAPI=false)
-@SupportedSourceVersion(RELEASE_15)
+@SupportedSourceVersion(RELEASE_16)
 public class ElementKindVisitor14<R, P> extends ElementKindVisitor9<R, P> {
     /**
      * Constructor for concrete subclasses; uses {@code null} for the
      * default value.
      */
diff a/src/java.compiler/share/classes/javax/lang/model/util/ElementScanner14.java b/src/java.compiler/share/classes/javax/lang/model/util/ElementScanner14.java
--- a/src/java.compiler/share/classes/javax/lang/model/util/ElementScanner14.java
+++ b/src/java.compiler/share/classes/javax/lang/model/util/ElementScanner14.java
@@ -83,11 +83,11 @@
  * @see ElementScanner9
  * @since 14
  */
 @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
                              essentialAPI=false)
-@SupportedSourceVersion(RELEASE_15)
+@SupportedSourceVersion(RELEASE_16)
 public class ElementScanner14<R, P> extends ElementScanner9<R, P> {
     /**
      * Constructor for concrete subclasses; uses {@code null} for the
      * default value.
      */
diff a/src/java.compiler/share/classes/javax/lang/model/util/SimpleAnnotationValueVisitor14.java b/src/java.compiler/share/classes/javax/lang/model/util/SimpleAnnotationValueVisitor14.java
--- a/src/java.compiler/share/classes/javax/lang/model/util/SimpleAnnotationValueVisitor14.java
+++ b/src/java.compiler/share/classes/javax/lang/model/util/SimpleAnnotationValueVisitor14.java
@@ -50,11 +50,11 @@
  * @see SimpleAnnotationValueVisitor7
  * @see SimpleAnnotationValueVisitor8
  * @see SimpleAnnotationValueVisitor9
  * @since 14
  */
-@SupportedSourceVersion(RELEASE_15)
+@SupportedSourceVersion(RELEASE_16)
 public class SimpleAnnotationValueVisitor14<R, P> extends SimpleAnnotationValueVisitor9<R, P> {
     /**
      * Constructor for concrete subclasses; uses {@code null} for the
      * default value.
      */
diff a/src/java.compiler/share/classes/javax/lang/model/util/SimpleElementVisitor14.java b/src/java.compiler/share/classes/javax/lang/model/util/SimpleElementVisitor14.java
--- a/src/java.compiler/share/classes/javax/lang/model/util/SimpleElementVisitor14.java
+++ b/src/java.compiler/share/classes/javax/lang/model/util/SimpleElementVisitor14.java
@@ -64,11 +64,11 @@
  * @see SimpleElementVisitor9
  * @since 14
  */
 @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
                              essentialAPI=false)
-@SupportedSourceVersion(RELEASE_15)
+@SupportedSourceVersion(RELEASE_16)
 public class SimpleElementVisitor14<R, P> extends SimpleElementVisitor9<R, P> {
     /**
      * Constructor for concrete subclasses; uses {@code null} for the
      * default value.
      */
diff a/src/java.compiler/share/classes/javax/lang/model/util/SimpleTypeVisitor14.java b/src/java.compiler/share/classes/javax/lang/model/util/SimpleTypeVisitor14.java
--- a/src/java.compiler/share/classes/javax/lang/model/util/SimpleTypeVisitor14.java
+++ b/src/java.compiler/share/classes/javax/lang/model/util/SimpleTypeVisitor14.java
@@ -54,11 +54,11 @@
  * @see SimpleTypeVisitor7
  * @see SimpleTypeVisitor8
  * @see SimpleTypeVisitor9
  * @since 14
  */
-@SupportedSourceVersion(RELEASE_15)
+@SupportedSourceVersion(RELEASE_16)
 public class SimpleTypeVisitor14<R, P> extends SimpleTypeVisitor9<R, P> {
     /**
      * Constructor for concrete subclasses; uses {@code null} for the
      * default value.
      */
diff a/src/java.compiler/share/classes/javax/lang/model/util/TypeKindVisitor14.java b/src/java.compiler/share/classes/javax/lang/model/util/TypeKindVisitor14.java
--- a/src/java.compiler/share/classes/javax/lang/model/util/TypeKindVisitor14.java
+++ b/src/java.compiler/share/classes/javax/lang/model/util/TypeKindVisitor14.java
@@ -59,11 +59,11 @@
  * @see TypeKindVisitor7
  * @see TypeKindVisitor8
  * @see TypeKindVisitor9
  * @since 14
  */
-@SupportedSourceVersion(RELEASE_15)
+@SupportedSourceVersion(RELEASE_16)
 public class TypeKindVisitor14<R, P> extends TypeKindVisitor9<R, P> {
     /**
      * Constructor for concrete subclasses to call; uses {@code null}
      * for the default value.
      */
diff a/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/UnsyncByteArrayOutputStream.java b/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/UnsyncByteArrayOutputStream.java
--- a/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/UnsyncByteArrayOutputStream.java
+++ b/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/UnsyncByteArrayOutputStream.java
@@ -44,11 +44,11 @@
         buf = new byte[INITIAL_SIZE];
     }
 
     public void write(byte[] arg0) {
         if ((VM_ARRAY_INDEX_MAX_VALUE - pos) < arg0.length) {
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Required length exceeds implementation limit");
         }
         int newPos = pos + arg0.length;
         if (newPos > size) {
             expandSize(newPos);
         }
@@ -56,11 +56,11 @@
         pos = newPos;
     }
 
     public void write(byte[] arg0, int arg1, int arg2) {
         if ((VM_ARRAY_INDEX_MAX_VALUE - pos) < arg2) {
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Required length exceeds implementation limit");
         }
         int newPos = pos + arg2;
         if (newPos > size) {
             expandSize(newPos);
         }
@@ -68,11 +68,11 @@
         pos = newPos;
     }
 
     public void write(int arg0) {
         if (VM_ARRAY_INDEX_MAX_VALUE - pos == 0) {
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Required length exceeds implementation limit");
         }
         int newPos = pos + 1;
         if (newPos > size) {
             expandSize(newPos);
         }
@@ -114,6 +114,6 @@
         byte newBuf[] = new byte[newSize];
         System.arraycopy(buf, 0, newBuf, 0, pos);
         buf = newBuf;
         size = newSize;
     }
-}
+}
diff a/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java b/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java
@@ -373,11 +373,11 @@
                 }
             }
         }
 
         // check for self closing tags, such as <a id="name"/>
-        if (tree.isSelfClosing()) {
+        if (tree.isSelfClosing() && !isSelfClosingAllowed(t)) {
             env.messages.error(HTML, tree, "dc.tag.self.closing", treeName);
         }
 
         try {
             TagStackItem parent = tagStack.peek();
@@ -413,10 +413,17 @@
             if (t == null || t.endKind == HtmlTag.EndKind.NONE)
                 tagStack.pop();
         }
     }
 
+    // so-called "self-closing" tags are only permitted in HTML 5, for void elements
+    // https://html.spec.whatwg.org/multipage/syntax.html#start-tags
+    private boolean isSelfClosingAllowed(HtmlTag tag) {
+        return env.htmlVersion == HtmlVersion.HTML5
+                && tag.endKind == HtmlTag.EndKind.NONE;
+    }
+
     private void checkStructure(StartElementTree tree, HtmlTag t) {
         Name treeName = tree.getName();
         TagStackItem top = tagStack.peek();
         switch (t.blockType) {
             case BLOCK:
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java
@@ -98,13 +98,18 @@
      * text blocks in preview
      */
     JDK14("14"),
 
     /**
-      * 15, tbd
+      * 15, text blocks
       */
-    JDK15("15");
+    JDK15("15"),
+
+    /**
+      * 16, tbd
+      */
+    JDK16("16");
 
     private static final Context.Key<Source> sourceKey = new Context.Key<>();
 
     public static Source instance(Context context) {
         Source instance = context.get(sourceKey);
@@ -151,23 +156,26 @@
     public boolean isSupported() {
         return this.compareTo(MIN) >= 0;
     }
 
     public Target requiredTarget() {
-        if (this.compareTo(JDK15) >= 0) return Target.JDK1_15;
-        if (this.compareTo(JDK14) >= 0) return Target.JDK1_14;
-        if (this.compareTo(JDK13) >= 0) return Target.JDK1_13;
-        if (this.compareTo(JDK12) >= 0) return Target.JDK1_12;
-        if (this.compareTo(JDK11) >= 0) return Target.JDK1_11;
-        if (this.compareTo(JDK10) >= 0) return Target.JDK1_10;
-        if (this.compareTo(JDK9) >= 0) return Target.JDK1_9;
-        if (this.compareTo(JDK8) >= 0) return Target.JDK1_8;
-        if (this.compareTo(JDK7) >= 0) return Target.JDK1_7;
-        if (this.compareTo(JDK6) >= 0) return Target.JDK1_6;
-        if (this.compareTo(JDK5) >= 0) return Target.JDK1_5;
-        if (this.compareTo(JDK1_4) >= 0) return Target.JDK1_4;
-        return Target.JDK1_1;
+        return switch(this) {
+        case JDK16  -> Target.JDK1_16;
+        case JDK15  -> Target.JDK1_15;
+        case JDK14  -> Target.JDK1_14;
+        case JDK13  -> Target.JDK1_13;
+        case JDK12  -> Target.JDK1_12;
+        case JDK11  -> Target.JDK1_11;
+        case JDK10  -> Target.JDK1_10;
+        case JDK9   -> Target.JDK1_9;
+        case JDK8   -> Target.JDK1_8;
+        case JDK7   -> Target.JDK1_7;
+        case JDK6   -> Target.JDK1_6;
+        case JDK5   -> Target.JDK1_5;
+        case JDK1_4 -> Target.JDK1_4;
+        default     -> Target.JDK1_1;
+        };
     }
 
     /**
      * Models a feature of the Java programming language. Each feature can be associated with a
      * minimum source level, a maximum source level and a diagnostic fragment describing the feature,
@@ -204,15 +212,15 @@
         IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES(JDK1_2, JDK8),
         SWITCH_MULTIPLE_CASE_LABELS(JDK14, Fragments.FeatureMultipleCaseLabels, DiagKind.PLURAL),
         SWITCH_RULE(JDK14, Fragments.FeatureSwitchRules, DiagKind.PLURAL),
         SWITCH_EXPRESSION(JDK14, Fragments.FeatureSwitchExpressions, DiagKind.PLURAL),
         TEXT_BLOCKS(JDK15, Fragments.FeatureTextBlocks, DiagKind.PLURAL),
-        PATTERN_MATCHING_IN_INSTANCEOF(JDK15, Fragments.FeaturePatternMatchingInstanceof, DiagKind.NORMAL),
-        REIFIABLE_TYPES_INSTANCEOF(JDK15, Fragments.FeatureReifiableTypesInstanceof, DiagKind.PLURAL),
-        RECORDS(JDK15, Fragments.FeatureRecords, DiagKind.PLURAL),
-        INLINE_TYPES(JDK15, Fragments.FeatureInlineType, DiagKind.NORMAL),
-        SEALED_CLASSES(JDK15, Fragments.FeatureSealedClasses, DiagKind.PLURAL),
+        PATTERN_MATCHING_IN_INSTANCEOF(JDK16, Fragments.FeaturePatternMatchingInstanceof, DiagKind.NORMAL),
+        REIFIABLE_TYPES_INSTANCEOF(JDK16, Fragments.FeatureReifiableTypesInstanceof, DiagKind.PLURAL),
+        RECORDS(JDK16, Fragments.FeatureRecords, DiagKind.PLURAL),
+        INLINE_TYPES(JDK16, Fragments.FeatureInlineType, DiagKind.NORMAL),
+        SEALED_CLASSES(JDK16, Fragments.FeatureSealedClasses, DiagKind.PLURAL),
         ;
 
         enum DiagKind {
             NORMAL,
             PLURAL;
@@ -271,39 +279,25 @@
                     Errors.FeatureNotSupportedInSourcePlural(optFragment, sourceName, minLevel.name);
         }
     }
 
     public static SourceVersion toSourceVersion(Source source) {
-        switch(source) {
-        case JDK1_2:
-            return RELEASE_2;
-        case JDK1_3:
-            return RELEASE_3;
-        case JDK1_4:
-            return RELEASE_4;
-        case JDK5:
-            return RELEASE_5;
-        case JDK6:
-            return RELEASE_6;
-        case JDK7:
-            return RELEASE_7;
-        case JDK8:
-            return RELEASE_8;
-        case JDK9:
-            return RELEASE_9;
-        case JDK10:
-            return RELEASE_10;
-        case JDK11:
-            return RELEASE_11;
-        case JDK12:
-            return RELEASE_12;
-        case JDK13:
-            return RELEASE_13;
-        case JDK14:
-            return RELEASE_14;
-        case JDK15:
-            return RELEASE_15;
-        default:
-            return null;
-        }
+        return switch(source) {
+        case JDK1_2 -> RELEASE_2;
+        case JDK1_3 -> RELEASE_3;
+        case JDK1_4 -> RELEASE_4;
+        case JDK5   -> RELEASE_5;
+        case JDK6   -> RELEASE_6;
+        case JDK7   -> RELEASE_7;
+        case JDK8   -> RELEASE_8;
+        case JDK9   -> RELEASE_9;
+        case JDK10  -> RELEASE_10;
+        case JDK11  -> RELEASE_11;
+        case JDK12  -> RELEASE_12;
+        case JDK13  -> RELEASE_13;
+        case JDK14  -> RELEASE_14;
+        case JDK15  -> RELEASE_15;
+        case JDK16  -> RELEASE_16;
+        default     -> null;
+        };
     }
 }
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -114,11 +114,12 @@
         V54(54, 0),   // JDK 10
         V55(55, 0),   // JDK 11: constant dynamic, nest mates
         V56(56, 0),   // JDK 12
         V57(57, 0),   // JDK 13
         V58(58, 0),   // JDK 14
-        V59(59, 0);   // JDK 15
+        V59(59, 0),   // JDK 15
+        V60(60, 0);   // JDK 16
         Version(int major, int minor) {
             this.major = major;
             this.minor = minor;
         }
         public final int major, minor;
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java
@@ -77,11 +77,14 @@
 
     /** JDK 14. */
     JDK1_14("14", 58, 0),
 
     /** JDK 15. */
-    JDK1_15("15", 59, 0);
+    JDK1_15("15", 59, 0),
+
+    /** JDK 16. */
+    JDK1_16("16", 60, 0);
 
     private static final Context.Key<Target> targetKey = new Context.Key<>();
 
     public static Target instance(Context context) {
         Target instance = context.get(targetKey);
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/platform/JDKPlatformProvider.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/platform/JDKPlatformProvider.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/platform/JDKPlatformProvider.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/platform/JDKPlatformProvider.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -119,11 +119,11 @@
                 for (Path section : dir) {
                     if (section.getFileName().toString().contains("-"))
                         continue;
                     for (char ver : section.getFileName().toString().toCharArray()) {
                         String verString = Character.toString(ver);
-                        Target t = Target.lookup("" + Integer.parseInt(verString, 16));
+                        Target t = Target.lookup("" + Integer.parseInt(verString, Character.MAX_RADIX));
 
                         if (t != null) {
                             SUPPORTED_JAVA_PLATFORM_VERSIONS.add(targetNumericVersion(t));
                         }
                     }
@@ -144,11 +144,11 @@
         private final String ctSymVersion;
 
         PlatformDescriptionImpl(String sourceVersion) {
             this.sourceVersion = sourceVersion;
             this.ctSymVersion =
-                    StringUtils.toUpperCase(Integer.toHexString(Integer.parseInt(sourceVersion)));
+                    StringUtils.toUpperCase(Integer.toString(Integer.parseInt(sourceVersion), Character.MAX_RADIX));
         }
 
         @Override
         public JavaFileManager getFileManager() {
             Context context = new Context();
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java
@@ -53,11 +53,11 @@
  * If you write code that depends on this, you do so at your own risk.
  * This code and its internal interfaces are subject to change or
  * deletion without notice.</b>
  */
 @SupportedAnnotationTypes("*")
-@SupportedSourceVersion(SourceVersion.RELEASE_15)
+@SupportedSourceVersion(SourceVersion.RELEASE_16)
 public class PrintingProcessor extends AbstractProcessor {
     PrintWriter writer;
 
     public PrintingProcessor() {
         super();
diff a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java
--- a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java
+++ b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java
@@ -308,10 +308,23 @@
         writeInfoPlist(contentsDir.resolve("Info.plist").toFile(), params);
 
         // generate java runtime info.plist
         writeRuntimeInfoPlist(
                 runtimeDir.resolve("Contents/Info.plist").toFile(), params);
+
+        // copy library
+        Path runtimeMacOSDir = Files.createDirectories(
+                runtimeDir.resolve("Contents/MacOS"));
+
+        final Path jliName = Path.of("libjli.dylib");
+        try (Stream<Path> walk = Files.walk(runtimeRoot.resolve("lib"))) {
+            final Path jli = walk
+                    .filter(file -> file.getFileName().equals(jliName))
+                    .findFirst()
+                    .get();
+            Files.copy(jli, runtimeMacOSDir.resolve(jliName));
+        }
     }
 
     private void sign(Map<String, ? super Object> params) throws IOException {
         if (Optional.ofNullable(
                 SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
diff a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java
--- a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java
+++ b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java
@@ -334,14 +334,10 @@
         IOUtils.exec(pb, false, null, true);
 
         File mountedRoot = new File(imagesRoot.getAbsolutePath(),
                     APP_NAME.fetchFrom(params));
         try {
-            Files.deleteIfExists(AppImageFile.getPathInAppImage(
-                    mountedRoot.toPath().resolve(APP_NAME.fetchFrom(params)
-                            + ".app")));
-
             // background image
             File bgdir = new File(mountedRoot, BACKGROUND_IMAGE_FOLDER);
             bgdir.mkdirs();
             IOUtils.copyFile(getConfig_VolumeBackground(params),
                     new File(bgdir, BACKGROUND_IMAGE));
diff a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacPkgBundler.java b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacPkgBundler.java
--- a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacPkgBundler.java
+++ b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacPkgBundler.java
@@ -405,12 +405,10 @@
             ProcessBuilder pb = new ProcessBuilder("pkgbuild",
                     "--root",
                     root,
                     "--install-location",
                     getInstallDir(params),
-                    "--filter",
-                    AppImageFile.getPathInAppImage(Path.of("")).toString(),
                     "--analyze",
                     cpl.getAbsolutePath());
 
             IOUtils.exec(pb);
 
@@ -422,12 +420,10 @@
             pb = new ProcessBuilder("pkgbuild",
                     "--root",
                     root,
                     "--install-location",
                     getInstallDir(params),
-                    "--filter",
-                    AppImageFile.getPathInAppImage(Path.of("")).toString(),
                     "--component-plist",
                     cpl.getAbsolutePath(),
                     "--scripts",
                     SCRIPTS_DIR.fetchFrom(params).getAbsolutePath(),
                     "--identifier",
diff a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/AppImageFile.java b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/AppImageFile.java
--- a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/AppImageFile.java
+++ b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/AppImageFile.java
@@ -93,11 +93,14 @@
     /**
      * Returns path to application image info file.
      * @param appImageDir - path to application image
      */
     public static Path getPathInAppImage(Path appImageDir) {
-        return appImageDir.resolve(FILENAME);
+        return ApplicationLayout.platformAppImage()
+                .resolveAt(appImageDir)
+                .appDirectory()
+                .resolve(FILENAME);
     }
 
     /**
      * Saves file with application image info in application image.
      * @param appImageDir - path to application image
diff a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java
--- a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java
+++ b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java
@@ -249,10 +249,11 @@
     }
 
     public static void createXml(Path dstFile, XmlConsumer xmlConsumer) throws
             IOException {
         XMLOutputFactory xmlFactory = XMLOutputFactory.newInstance();
+        Files.createDirectories(dstFile.getParent());
         try (Writer w = Files.newBufferedWriter(dstFile)) {
             // Wrap with pretty print proxy
             XMLStreamWriter xml = (XMLStreamWriter) Proxy.newProxyInstance(
                     XMLStreamWriter.class.getClassLoader(), new Class<?>[]{
                 XMLStreamWriter.class}, new PrettyPrintHandler(
diff a/src/jdk.incubator.jpackage/share/native/applauncher/JvmLauncher.cpp b/src/jdk.incubator.jpackage/share/native/applauncher/JvmLauncher.cpp
--- a/src/jdk.incubator.jpackage/share/native/applauncher/JvmLauncher.cpp
+++ b/src/jdk.incubator.jpackage/share/native/applauncher/JvmLauncher.cpp
@@ -167,11 +167,23 @@
         jboolean cpwildcard,
         jboolean javaw,
         jint ergo);
 
     std::vector<char*> argv;
+#ifdef TSTRINGS_WITH_WCHAR
+    std::vector<std::string> mbcs_args;
+    do {
+        tstring_array::const_iterator it = args.begin();
+        const tstring_array::const_iterator end = args.end();
+        for (; it != end; ++it) {
+            mbcs_args.push_back(tstrings::toACP(*it));
+        }
+    } while (0);
+    convertArgs(mbcs_args, argv);
+#else
     convertArgs(args, argv);
+#endif
 
     // Don't count terminal '0'.
     const int argc = (int)argv.size() - 1;
 
     LOG_TRACE(tstrings::any() << "JVM library: \"" << jvmPath << "\"");
diff a/src/jdk.incubator.jpackage/share/native/applauncher/JvmLauncher.h b/src/jdk.incubator.jpackage/share/native/applauncher/JvmLauncher.h
--- a/src/jdk.incubator.jpackage/share/native/applauncher/JvmLauncher.h
+++ b/src/jdk.incubator.jpackage/share/native/applauncher/JvmLauncher.h
@@ -35,11 +35,11 @@
 class Jvm {
 public:
     Jvm& initFromConfigFile(const CfgFile& cfgFile);
 
     Jvm& addArgument(const tstring& value) {
-        args.push_back(tstrings::any(value).str());
+        args.push_back(value);
         return *this;
     }
 
     Jvm& setPath(const tstring& v) {
         jvmPath = v;
@@ -52,9 +52,9 @@
 
     void launch();
 
 private:
     tstring jvmPath;
-    std::vector<std::string> args;
+    tstring_array args;
 };
 
 #endif // JvmLauncher_h
diff a/src/jdk.incubator.jpackage/share/native/common/tstrings.cpp b/src/jdk.incubator.jpackage/share/native/common/tstrings.cpp
--- a/src/jdk.incubator.jpackage/share/native/common/tstrings.cpp
+++ b/src/jdk.incubator.jpackage/share/native/common/tstrings.cpp
@@ -273,10 +273,14 @@
 
     return utf16;
 }
 } // namespace
 
+std::string toACP(const std::wstring& utf16str) {
+    return toMultiByte(utf16str, CP_ACP);
+}
+
 std::string toUtf8(const std::wstring& utf16str) {
     return toMultiByte(utf16str, CP_UTF8);
 }
 
 std::wstring toUtf16(const std::string& utf8str) {
diff a/src/jdk.incubator.jpackage/share/native/common/tstrings.h b/src/jdk.incubator.jpackage/share/native/common/tstrings.h
--- a/src/jdk.incubator.jpackage/share/native/common/tstrings.h
+++ b/src/jdk.incubator.jpackage/share/native/common/tstrings.h
@@ -138,10 +138,13 @@
     inline std::string toUtf8(const std::string& utf8str) {
         return utf8str;
     }
 
 #ifdef TSTRINGS_WITH_WCHAR
+    // conversion to the active code page
+    std::string toACP(const std::wstring& utf16str);
+
     // conversion to Utf8
     std::string toUtf8(const std::wstring& utf16str);
 
     // conversion to Utf16
     std::wstring toUtf16(const std::string& utf8str);
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/classfile/Classfile.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/classfile/Classfile.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/classfile/Classfile.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/classfile/Classfile.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -47,11 +47,11 @@
 
     private final ResolvedJavaType type;
     private final List<ClassfileBytecode> codeAttributes;
 
     private static final int MAJOR_VERSION_JAVA_MIN = 51; // JDK7
-    private static final int MAJOR_VERSION_JAVA_MAX = 59; // JDK15
+    private static final int MAJOR_VERSION_JAVA_MAX = 60; // JDK16
     private static final int MAGIC = 0xCAFEBABE;
 
     /**
      * Creates a {@link Classfile} by parsing the class file bytes for {@code type} loadable from
      * {@code context}.
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java
@@ -107,20 +107,20 @@
         eventTypes.addAll(nativeEventTypes);
         return eventTypes;
     }
 
     public synchronized EventType getEventType(Class<? extends jdk.internal.event.Event> eventClass) {
-        EventHandler h = getHandler(eventClass);
+        EventHandler h = getHandler(eventClass, false);
         if (h != null && h.isRegistered()) {
             return h.getEventType();
         }
         throw new IllegalStateException("Event class " + eventClass.getName() + " is not registered");
     }
 
     public synchronized void unregister(Class<? extends Event> eventClass) {
         Utils.checkRegisterPermission();
-        EventHandler handler = getHandler(eventClass);
+        EventHandler handler = getHandler(eventClass, false);
         if (handler != null) {
             handler.setRegistered(false);
         }
         // never registered, ignore call
     }
@@ -128,11 +128,11 @@
         return register(eventClass, Collections.emptyList(), Collections.emptyList());
     }
 
     public synchronized EventType register(Class<? extends jdk.internal.event.Event> eventClass, List<AnnotationElement> dynamicAnnotations, List<ValueDescriptor> dynamicFields) {
         Utils.checkRegisterPermission();
-        EventHandler handler = getHandler(eventClass);
+        EventHandler handler = getHandler(eventClass, true);
         if (handler == null) {
             if (eventClass.getAnnotation(MirrorEvent.class) != null) {
                 // don't register mirrors
                 return null;
             }
@@ -163,14 +163,16 @@
         long id = Type.getTypeId(eventClass);
         et.setId(id);
         return et;
     }
 
-    private EventHandler getHandler(Class<? extends jdk.internal.event.Event> eventClass) {
+    private EventHandler getHandler(Class<? extends jdk.internal.event.Event> eventClass, boolean ensureInitialized) {
         Utils.ensureValidEventSubclass(eventClass);
         SecuritySupport.makeVisibleToJFR(eventClass);
-        Utils.ensureInitialized(eventClass);
+        if (ensureInitialized) {
+            Utils.ensureInitialized(eventClass);
+        }
         return Utils.getHandler(eventClass);
     }
 
     private EventHandler makeHandler(Class<? extends jdk.internal.event.Event> eventClass, PlatformEventType pEventType, List<AnnotationElement> dynamicAnnotations, List<ValueDescriptor> dynamicFields) throws InternalError {
         SecuritySupport.addHandlerExport(eventClass);
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java
@@ -430,13 +430,26 @@
         doPrivileged(() -> constructor.setAccessible(true), new ReflectPermission("suppressAccessChecks"));
     }
 
     static void ensureClassIsInitialized(Class<?> clazz) {
         try {
-            MethodHandles.privateLookupIn(clazz, LOOKUP).ensureInitialized(clazz);
+            MethodHandles.Lookup lookup;
+            if (System.getSecurityManager() == null) {
+                lookup = MethodHandles.privateLookupIn(clazz, LOOKUP);
+            } else {
+                lookup = AccessController.doPrivileged(new PrivilegedExceptionAction<>() {
+                    @Override
+                    public MethodHandles.Lookup run() throws IllegalAccessException {
+                        return MethodHandles.privateLookupIn(clazz, LOOKUP);
+                    }
+                }, null, new ReflectPermission("suppressAccessChecks"));
+            }
+            lookup.ensureInitialized(clazz);
         } catch (IllegalAccessException e) {
             throw new InternalError(e);
+        } catch (PrivilegedActionException e) {
+            throw new InternalError(e.getCause());
         }
     }
 
     static Class<?> defineClass(Class<?> lookupClass, byte[] bytes) {
         return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {
diff a/src/jdk.zipfs/share/classes/jdk/nio/zipfs/ByteArrayChannel.java b/src/jdk.zipfs/share/classes/jdk/nio/zipfs/ByteArrayChannel.java
--- a/src/jdk.zipfs/share/classes/jdk/nio/zipfs/ByteArrayChannel.java
+++ b/src/jdk.zipfs/share/classes/jdk/nio/zipfs/ByteArrayChannel.java
@@ -242,11 +242,11 @@
         buf = Arrays.copyOf(buf, newCapacity);
     }
 
     private static int hugeCapacity(int minCapacity) {
         if (minCapacity < 0) // overflow
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Required length exceeds implementation limit");
         return (minCapacity > MAX_ARRAY_SIZE) ?
             Integer.MAX_VALUE :
             MAX_ARRAY_SIZE;
     }
 }
diff a/test/hotspot/jtreg/ProblemList.txt b/test/hotspot/jtreg/ProblemList.txt
--- a/test/hotspot/jtreg/ProblemList.txt
+++ b/test/hotspot/jtreg/ProblemList.txt
@@ -145,12 +145,10 @@
 compiler/aot/fingerprint/SelfChangedCDS.java 8226295 generic-all
 compiler/aot/fingerprint/SuperChanged.java 8226295 generic-all
 
 compiler/c2/Test8004741.java 8235801 generic-all
 
-compiler/jsr292/CreatesInterfaceDotEqualsCallInfo.java 8242923 generic-all
-
 #############################################################################
 
 # :hotspot_gc
 
 gc/epsilon/TestMemoryMXBeans.java 8206434 generic-all
diff a/test/hotspot/jtreg/compiler/intrinsics/Test8237524.java b/test/hotspot/jtreg/compiler/intrinsics/Test8237524.java
--- a/test/hotspot/jtreg/compiler/intrinsics/Test8237524.java
+++ b/test/hotspot/jtreg/compiler/intrinsics/Test8237524.java
@@ -25,10 +25,12 @@
 /*
  * @test
  * @bug 8237524
  * @summary String.compareTo() may return incorrect result in this case
  *
+ * @modules java.base/java.lang:open
+ *
  * @run main/othervm compiler.intrinsics.Test8237524
  */
 
 package compiler.intrinsics;
 
diff a/test/hotspot/jtreg/compiler/jsr292/CreatesInterfaceDotEqualsCallInfo.java b/test/hotspot/jtreg/compiler/jsr292/CreatesInterfaceDotEqualsCallInfo.java
--- a/test/hotspot/jtreg/compiler/jsr292/CreatesInterfaceDotEqualsCallInfo.java
+++ b/test/hotspot/jtreg/compiler/jsr292/CreatesInterfaceDotEqualsCallInfo.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,21 +22,24 @@
  */
 
 /**
  * @test
  * @bug 8026124
- * @summary Javascript file provoked assertion failure in linkResolver.cpp
- * @modules jdk.scripting.nashorn/jdk.nashorn.tools
+ * @summary MethodHandle lookup for an interface method causes assertion failure in linkResolver.cpp
  *
  * @run main/othervm compiler.jsr292.CreatesInterfaceDotEqualsCallInfo
  */
 
 package compiler.jsr292;
 
+import java.lang.invoke.MethodHandles;
+import java.nio.file.Path;
+
 public class CreatesInterfaceDotEqualsCallInfo {
-    public static void main(String[] args) throws java.io.IOException {
-        String[] jsargs = {System.getProperty("test.src", ".") +
-                "/createsInterfaceDotEqualsCallInfo.js"};
-        jdk.nashorn.tools.Shell.main(System.in, System.out, System.err, jsargs);
-        System.out.println("PASS, did not crash running Javascript");
+    public static void main(String[] args) throws Throwable {
+        MethodHandles.publicLookup()
+            .unreflect(Path.class.getMethod("toString", new Class[]{}))
+            .invoke(Path.of("."));
+
+        System.out.println("PASS, did not crash calling interface method handle");
     }
 }
diff a/test/hotspot/jtreg/compiler/jsr292/createsInterfaceDotEqualsCallInfo.js b/test/hotspot/jtreg/compiler/jsr292/createsInterfaceDotEqualsCallInfo.js
--- a/test/hotspot/jtreg/compiler/jsr292/createsInterfaceDotEqualsCallInfo.js
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-var path = new java.io.File("/Users/someone").toPath();
-path.toString();
diff a/test/hotspot/jtreg/runtime/CommandLine/VMDeprecatedOptions.java b/test/hotspot/jtreg/runtime/CommandLine/VMDeprecatedOptions.java
--- a/test/hotspot/jtreg/runtime/CommandLine/VMDeprecatedOptions.java
+++ b/test/hotspot/jtreg/runtime/CommandLine/VMDeprecatedOptions.java
@@ -45,20 +45,10 @@
         {"MaxRAMFraction",            "8"},
         {"MinRAMFraction",            "2"},
         {"InitialRAMFraction",        "64"},
         {"TLABStats",                 "false"},
         {"AllowRedefinitionToAddDeleteMethods", "true"},
-        {"PrintVMQWaitTime",          "true"},
-        {"UseNewFieldLayout",         "true"},
-        {"UseBiasedLocking",                    "false"},
-        {"BiasedLockingStartupDelay",           "0"},
-        {"BiasedLockingBulkRebiasThreshold",    "20"},
-        {"BiasedLockingBulkRevokeThreshold",    "40"},
-        {"BiasedLockingDecayTime",              "25000"},
-        {"UseOptoBiasInlining",                 "true"},
-        {"InitialBootClassLoaderMetaspaceSize", "2200000"},
-        {"UseLargePagesInMetaspace",            "true"},
 
         // deprecated alias flags (see also aliased_jvm_flags):
         {"DefaultMaxRAMFraction", "4"},
         {"CreateMinidumpOnCrash", "false"}
     };
diff a/test/hotspot/jtreg/runtime/cds/SharedBaseAddress.java b/test/hotspot/jtreg/runtime/cds/SharedBaseAddress.java
--- a/test/hotspot/jtreg/runtime/cds/SharedBaseAddress.java
+++ b/test/hotspot/jtreg/runtime/cds/SharedBaseAddress.java
@@ -56,11 +56,12 @@
             System.out.println("sharedBaseAddress = " + testEntry);
             CDSOptions opts = (new CDSOptions())
                 .setArchiveName(filename)
                 .addPrefix("-XX:SharedBaseAddress=" + testEntry)
                 .addPrefix("-Xlog:cds=debug")
-                .addPrefix("-Xlog:cds+reloc=debug");
+                .addPrefix("-Xlog:cds+reloc=debug")
+                .addPrefix("-XX:NativeMemoryTracking=detail");
 
             CDSTestUtils.createArchiveAndCheck(opts);
             OutputAnalyzer out = CDSTestUtils.runWithArchiveAndCheck(opts);
             if (testEntry.equals("0")) {
               out.shouldContain("Archive(s) were created with -XX:SharedBaseAddress=0. Always map at os-selected address.")
diff a/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java b/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java
@@ -66,16 +66,17 @@
         String forceRelocation = "-XX:ArchiveRelocationMode=1";
         String dumpRelocArg = dump_reloc ? forceRelocation : "-showversion";
         String runRelocArg  = run_reloc  ? forceRelocation : "-showversion";
         String logArg = "-Xlog:cds=debug,cds+reloc=debug";
         String unlockArg = "-XX:+UnlockDiagnosticVMOptions";
+        String nmtArg = "-XX:NativeMemoryTracking=detail";
 
         OutputAnalyzer out = TestCommon.dump(appJar,
                                              TestCommon.list(mainClass,
                                                              "HelloInlineClassApp",
                                                              "HelloInlineClassApp$Point"),
-                                             unlockArg, dumpRelocArg, logArg);
+                                             unlockArg, dumpRelocArg, logArg, nmtArg);
         if (dump_reloc) {
             out.shouldContain("ArchiveRelocationMode == 1: always allocate class space at an alternative address");
             out.shouldContain("Relocating archive from");
         }
 
diff a/test/hotspot/jtreg/runtime/cds/appcds/TestCombinedCompressedFlags.java b/test/hotspot/jtreg/runtime/cds/appcds/TestCombinedCompressedFlags.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/TestCombinedCompressedFlags.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/TestCombinedCompressedFlags.java
@@ -161,19 +161,21 @@
             out = TestCommon
                 .dump(helloJar,
                       new String[] {"Hello"},
                       getCompressedOopsArg(t.dumpArg.useCompressedOops),
                       getCompressedClassPointersArg(t.dumpArg.useCompressedClassPointers),
-                      "-Xlog:cds");
+                      "-Xlog:cds",
+                      "-XX:NativeMemoryTracking=detail");
             out.shouldContain("Dumping shared data to file:");
             out.shouldHaveExitValue(0);
 
             for (ConfArg c : t.execArgs) {
                 out = TestCommon.exec(helloJar,
                                       "-cp",
                                       helloJar,
                                       "-Xlog:cds",
+                                      "-XX:NativeMemoryTracking=detail",
                                       getCompressedOopsArg(c.useCompressedOops),
                                       getCompressedClassPointersArg(c.useCompressedClassPointers),
                                       "Hello");
                 out.shouldContain(c.msg);
                 out.shouldHaveExitValue(c.code);
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MismatchedBaseArchive.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MismatchedBaseArchive.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MismatchedBaseArchive.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ * @test
+ * @summary The base archive used for dynamic dump is not the same as the one
+ *          used during run time. With -Xshare:on, VM will exit with en error message.
+ * @requires vm.cds
+ * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/test-classes
+ * @build Hello
+ * @build sun.hotspot.WhiteBox
+ * @run driver ClassFileInstaller -jar hello.jar Hello
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MismatchedBaseArchive
+ */
+
+public class MismatchedBaseArchive extends DynamicArchiveTestBase {
+    public static void main(String[] args) throws Exception {
+        createBaseArchive();
+        runTest(MismatchedBaseArchive::testDefaultBase);
+        runTest(MismatchedBaseArchive::testCustomBase);
+    }
+
+    static String helloBaseArchive = getNewArchiveName("base-with-hello");
+    static String appJar = ClassFileInstaller.getJarPath("hello.jar");
+    static String mainClass = "Hello";
+
+    static void createBaseArchive() throws Exception {
+        TestCommon.dumpBaseArchive(helloBaseArchive,
+                                   "-Xlog:cds",
+                                   "-cp", appJar, mainClass);
+    }
+
+    // (1) Test with default base archive + top archive
+    static void testDefaultBase() throws Exception {
+        String topArchiveName = getNewArchiveName("top");
+        doTest(null, topArchiveName);
+    }
+
+    // (2) Test with custom base archive + top archive
+    static void testCustomBase() throws Exception {
+        String topArchiveName = getNewArchiveName("top2");
+        String baseArchiveName = getNewArchiveName("base");
+        TestCommon.dumpBaseArchive(baseArchiveName);
+        doTest(baseArchiveName, topArchiveName);
+    }
+
+    private static void doTest(String baseArchiveName, String topArchiveName) throws Exception {
+        dump2(baseArchiveName, topArchiveName,
+             "-Xlog:cds",
+             "-Xlog:cds+dynamic=debug",
+             "-cp", appJar, mainClass)
+            .assertNormalExit(output -> {
+                    output.shouldContain("Buffer-space to target-space delta")
+                           .shouldContain("Written dynamic archive 0x");
+                });
+
+        run2(helloBaseArchive, topArchiveName,
+            "-Xlog:class+load",
+            "-Xlog:cds+dynamic=debug,cds=debug",
+            "-cp", appJar, mainClass)
+            .assertAbnormalExit(output -> {
+                    output.shouldContain("Dynamic archive cannot be used: static archive header checksum verification failed.")
+                          .shouldHaveExitValue(1);
+                });
+
+    }
+}
diff a/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/OptimizeModuleHandlingTest.java b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/OptimizeModuleHandlingTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/OptimizeModuleHandlingTest.java
@@ -0,0 +1,311 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/**
+ * @test
+ * @requires vm.cds
+ * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds
+ * @run driver OptimizeModuleHandlingTest
+ * @summary test module path changes for optimization of
+ *          module handling.
+ *
+ */
+
+import java.io.File;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+import jdk.test.lib.process.OutputAnalyzer;
+
+public class OptimizeModuleHandlingTest {
+
+    private static final Path USER_DIR = Paths.get(System.getProperty("user.dir"));
+
+    private static final String TEST_SRC = System.getProperty("test.src");
+
+    private static final Path SRC_DIR = Paths.get(TEST_SRC, "src");
+    private static final Path MODS_DIR = Paths.get("mody");
+
+    // the module name of the test module
+    private static final String MAIN_MODULE = "com.bars";
+    private static final String TEST_MODULE = "com.foos";
+
+    // the module main class
+    private static final String MAIN_CLASS = "com.bars.Main";
+    private static final String TEST_CLASS = "com.foos.Test";
+
+    private static String PATH_LIBS = "modylibs";
+    private static Path libsDir = null;
+    private static Path mainJar = null;
+    private static Path testJar = null;
+
+    private static String CLASS_FOUND_MESSAGE = "com.foos.Test found";
+    private static String CLASS_NOT_FOUND_MESSAGE = "java.lang.ClassNotFoundException: com.foos.Test";
+    private static String OPTIMIZE_ENABLED = "Using optimized module handling enabled";
+    private static String OPTIMIZE_DISABLED = "Using optimized module handling disabled";
+    private static String MAIN_FROM_JAR = "class,load.*com.bars.Main.*[.]jar";
+    private static String MAIN_FROM_CDS = "class,load.*com.bars.Main.*shared objects file";
+    private static String TEST_FROM_JAR = "class,load.*com.foos.Test.*[.]jar";
+    private static String TEST_FROM_CDS = "class,load.*com.foos.Test.*shared objects file";
+    private static String MAP_FAILED  = "Unable to use shared archive";
+    private static String PATH_SEPARATOR = File.pathSeparator;
+
+    public static void buildTestModule() throws Exception {
+
+        // javac -d mods/$TESTMODULE src/$TESTMODULE/**
+        JarBuilder.compileModule(SRC_DIR.resolve(TEST_MODULE),
+                                 MODS_DIR.resolve(TEST_MODULE),
+                                 null);
+
+        // javac -d mods/$TESTMODULE --module-path MOD_DIR src/$TESTMODULE/**
+        JarBuilder.compileModule(SRC_DIR.resolve(MAIN_MODULE),
+                                 MODS_DIR.resolve(MAIN_MODULE),
+                                 MODS_DIR.toString());
+
+        libsDir = Files.createTempDirectory(USER_DIR, PATH_LIBS);
+        mainJar = libsDir.resolve(MAIN_MODULE + ".jar");
+        testJar = libsDir.resolve(TEST_MODULE + ".jar");
+
+        // modylibs contains both modules com.foos.jar, com.bars.jar
+        // build com.foos.jar
+        String classes = MODS_DIR.resolve(TEST_MODULE).toString();
+        JarBuilder.createModularJar(testJar.toString(), classes, TEST_CLASS);
+
+        // build com.bars.jar
+        classes = MODS_DIR.resolve(MAIN_MODULE).toString();
+        JarBuilder.createModularJar(mainJar.toString(), classes, MAIN_CLASS);
+    }
+
+    public static void main(String... args) throws Exception {
+        runWithModulePath();
+        runWithJarPath();
+    }
+
+    private static void tty(String... args) {
+        for (String s : args) {
+            System.out.print(s + " ");
+        }
+        System.out.print("\n");
+    }
+
+    public static void runWithModulePath(String... extraRuntimeArgs) throws Exception {
+        // compile the modules and create the modular jar files
+        buildTestModule();
+        String appClasses[] = {MAIN_CLASS, TEST_CLASS};
+        // create an archive with the classes in the modules built in the
+        // previous step
+        OutputAnalyzer output = TestCommon.createArchive(
+                                        null, appClasses,
+                                        "--module-path",
+                                        libsDir.toString(),
+                                        "-m", MAIN_MODULE);
+        TestCommon.checkDump(output);
+
+        // following 1 - 4 test with CDS off
+        tty("1. run with CDS off");
+        TestCommon.execOff( "-p", libsDir.toString(),
+                            "-m", MAIN_MODULE)
+            .shouldHaveExitValue(0)
+            .shouldNotContain(OPTIMIZE_ENABLED)
+            .shouldContain(CLASS_FOUND_MESSAGE);
+        tty("2. run with CDS off, without module path");
+        TestCommon.execOff("-cp",
+                           mainJar.toString(),
+                           MAIN_CLASS)
+            .shouldHaveExitValue(0)
+            .shouldContain(CLASS_NOT_FOUND_MESSAGE);
+        tty("3. run with CDS off, but with full jars in path");
+        TestCommon.execOff( "-cp", mainJar.toString() + PATH_SEPARATOR + testJar.toString(),
+                            MAIN_CLASS)
+            .shouldHaveExitValue(0)
+            .shouldNotContain(OPTIMIZE_ENABLED)
+            .shouldContain(CLASS_FOUND_MESSAGE);
+        tty("4. run with CDS off, only main jar on path, but given moudle path");
+        TestCommon.execOff( "-cp", mainJar.toString(),
+                            "--module-path", libsDir.toString(),
+                            "--add-modules", TEST_MODULE,
+                            MAIN_CLASS)
+            .shouldHaveExitValue(0)
+            .shouldNotContain(OPTIMIZE_ENABLED)
+            .shouldContain(CLASS_FOUND_MESSAGE);
+
+        // Following 5 - 10 test with CDS on
+        tty("5. run with CDS on, with module path");
+        String prefix[] = {"-Djava.class.path=", "-Xlog:cds", "-Xlog:class+load"};
+        TestCommon.runWithModules(prefix,
+                                 null,               // --upgrade-module-path
+                                 libsDir.toString(), // --module-path
+                                 MAIN_MODULE)        // -m
+            .assertNormalExit(out -> {
+                out.shouldNotContain(OPTIMIZE_ENABLED)
+                   .shouldContain(OPTIMIZE_DISABLED)
+                   .shouldMatch(MAIN_FROM_CDS)       // // archived Main class is for module only
+                   .shouldContain(CLASS_FOUND_MESSAGE);
+            });
+        tty("6. run with CDS on, with module paths set correctly");
+        TestCommon.run("-Xlog:cds",
+                       "-Xlog:class+load",
+                       "-p", libsDir.toString(),
+                       "-m", MAIN_MODULE)
+            .assertNormalExit(out -> {
+                out.shouldContain(CLASS_FOUND_MESSAGE)
+                   .shouldMatch(MAIN_FROM_CDS)
+                   .shouldMatch(TEST_FROM_CDS)
+                   .shouldContain(OPTIMIZE_DISABLED)
+                   .shouldNotContain(OPTIMIZE_ENABLED);
+            });
+        tty("7. run with CDS on, with jar on path");
+        TestCommon.run("-Xlog:cds",
+                       "-Xlog:class+load",
+                       "-cp", mainJar.toString() + PATH_SEPARATOR + testJar.toString(),
+                       MAIN_CLASS)
+            .assertNormalExit(out -> {
+                out.shouldContain(CLASS_FOUND_MESSAGE)
+                   .shouldMatch(MAIN_FROM_JAR)
+                   .shouldMatch(TEST_FROM_JAR)
+                   .shouldContain(OPTIMIZE_DISABLED)
+                   .shouldNotContain(OPTIMIZE_ENABLED);
+            });
+
+        tty("8. run with CDS on, with --module-path, with jar should fail");
+        TestCommon.run("-Xlog:cds",
+                       "-Xlog:class+load",
+                       "-p", libsDir.toString(),
+                       "-cp", mainJar.toString(),
+                       MAIN_CLASS)
+            .assertNormalExit(out -> {
+                out.shouldContain(CLASS_NOT_FOUND_MESSAGE)
+                   .shouldMatch(MAIN_FROM_JAR)
+                   .shouldNotContain(OPTIMIZE_ENABLED);
+            });
+        tty("9. run with CDS on, with com.foos on --module-path, with main jar on cp should pass");
+        TestCommon.run("-Xlog:cds",
+                       "-Xlog:class+load",
+                       "--module-path", libsDir.toString(),
+                       "--add-modules", TEST_MODULE,
+                       "-cp", mainJar.toString(),
+                       MAIN_CLASS)
+            .assertNormalExit(out -> {
+                out.shouldContain(CLASS_FOUND_MESSAGE)
+                   .shouldMatch(MAIN_FROM_JAR)
+                   .shouldMatch(TEST_FROM_CDS)
+                   .shouldNotContain(OPTIMIZE_ENABLED);
+            });
+        tty("10. run with CDS on, --module-path, with -Xbootclasspath/a: .");
+        TestCommon.run("-Xlog:cds",
+                       "-Xbootclasspath/a:", ".",
+                       "--module-path", libsDir.toString(),
+                       MAIN_CLASS)
+            .assertAbnormalExit(out -> {
+                out.shouldNotContain(CLASS_FOUND_MESSAGE)
+                   .shouldContain(OPTIMIZE_DISABLED)           // mapping info
+                   .shouldContain("shared class paths mismatch");
+            });
+    }
+
+    public static void runWithJarPath(String... extraRuntimeArgs) throws Exception {
+        // compile the modules and create the modular jar files
+        buildTestModule();
+        String appClasses[] = {MAIN_CLASS, TEST_CLASS};
+        // create an archive with the classes in the modules built in the
+        // previous step
+        OutputAnalyzer output = TestCommon.createArchive(
+                                    testJar.toString() + PATH_SEPARATOR + mainJar.toString(),
+                                    appClasses);
+        TestCommon.checkDump(output);
+
+        // tests 1 - 4 test with CDS off are same as with module archive.
+        tty("tests 1 - 4 test with CDS off are same as with module archive, skipped");
+
+        // Following 5 - 9 test with CDS on
+        tty("5. run with CDS on, with module path");
+        String prefix[] = {"-Djava.class.path=", "-Xlog:cds"};
+        TestCommon.runWithModules(prefix,
+                                  null,               // --upgrade-module-path
+                                  libsDir.toString(), // --module-path
+                                  MAIN_MODULE)        // -m
+            .assertAbnormalExit(out -> {
+                out.shouldContain(MAP_FAILED)
+                   .shouldNotContain(OPTIMIZE_ENABLED)
+                   .shouldNotContain(CLASS_FOUND_MESSAGE);
+            });
+        tty("6. run with CDS on, with module paths set correctly");
+        TestCommon.run("-Xlog:cds",
+                       "-p", libsDir.toString(),
+                       "-m", MAIN_MODULE)
+            .assertAbnormalExit(out -> {
+                out.shouldContain(MAP_FAILED)
+                   .shouldNotContain(CLASS_FOUND_MESSAGE)
+                   .shouldNotContain(OPTIMIZE_ENABLED);
+            });
+        tty("7. run with CDS on, with jar on path");
+        TestCommon.run("-Xlog:cds",
+                       "-Xlog:class+load",
+                       "-cp", testJar.toString() + PATH_SEPARATOR + mainJar.toString(),
+                       MAIN_CLASS)
+            .assertNormalExit(out -> {
+                out.shouldMatch(MAIN_FROM_CDS)
+                   .shouldMatch(TEST_FROM_CDS)
+                   .shouldContain(CLASS_FOUND_MESSAGE)
+                   .shouldContain(OPTIMIZE_ENABLED);
+            });
+        tty("8. run with CDS on, with --module-path, with jars on classpath should run but not optimized");
+        TestCommon.run("-Xlog:cds",
+                       "-Xlog:class+load",
+                       "-p", libsDir.toString(),
+                       "-cp", testJar.toString() + PATH_SEPARATOR + mainJar.toString(),
+                       "--add-modules=com.bars",         // Main/Test from jars
+                       MAIN_CLASS)
+            .assertNormalExit(out -> {
+                out.shouldMatch(MAIN_FROM_JAR)
+                   .shouldMatch(TEST_FROM_JAR)
+                   .shouldContain(CLASS_FOUND_MESSAGE)
+                   .shouldNotContain(OPTIMIZE_ENABLED);
+            });
+        tty("9. run with CDS on,  with main jar only on classpath should not pass");
+        TestCommon.run("-Xlog:cds",
+                       "-cp", mainJar.toString(),
+                       MAIN_CLASS)
+            .assertAbnormalExit(out -> {
+                out.shouldContain(MAP_FAILED)
+                   .shouldNotContain(CLASS_FOUND_MESSAGE)
+                   .shouldNotContain(CLASS_NOT_FOUND_MESSAGE)
+                   .shouldNotContain(OPTIMIZE_ENABLED)
+                   .shouldNotContain(OPTIMIZE_DISABLED);
+            });
+        tty("10. run with CDS on,  with main/test jars on classpath also with -Xbootclasspath/a:  should not pass");
+        TestCommon.run("-Xlog:cds",
+                       "-cp", mainJar.toString() + PATH_SEPARATOR + testJar.toString(),
+                       "-Xbootclasspath/a:", ".",
+                       MAIN_CLASS)
+            .assertAbnormalExit(out -> {
+                out.shouldNotContain(CLASS_FOUND_MESSAGE)
+                   .shouldNotContain(CLASS_NOT_FOUND_MESSAGE)
+                   .shouldContain(OPTIMIZE_DISABLED)
+                   .shouldNotContain(OPTIMIZE_ENABLED)
+                   .shouldContain(MAP_FAILED);
+            });
+    }
+}
diff a/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.bars/com/bars/Main.java b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.bars/com/bars/Main.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.bars/com/bars/Main.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package com.bars;
+public class Main {
+    public static void main(String... args) {
+        try {
+             System.out.println("Main.class from " + Main.class.getModule());
+             Class.forName("com.foos.Test");
+             System.out.println("com.foos.Test found!");
+        } catch (ClassNotFoundException e) {
+             System.out.println("ClassNotFoundException " + e);
+        }
+    }
+}
diff a/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.bars/module-info.java b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.bars/module-info.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.bars/module-info.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+module com.bars {
+    requires com.foos;
+}
diff a/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.foos/com/foos/Test.java b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.foos/com/foos/Test.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.foos/com/foos/Test.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package com.foos;
+public class Test {
+    public static String getString() { return "Test"; }
+    public static void main(String args[]) {
+        System.out.println(getString());
+    }
+}
diff a/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.foos/module-info.java b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.foos/module-info.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/src/com.foos/module-info.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+module com.foos {
+    exports com.foos;
+}
diff a/test/hotspot/jtreg/runtime/modules/sealedP1/SuperClass.jcod b/test/hotspot/jtreg/runtime/modules/sealedP1/SuperClass.jcod
--- a/test/hotspot/jtreg/runtime/modules/sealedP1/SuperClass.jcod
+++ b/test/hotspot/jtreg/runtime/modules/sealedP1/SuperClass.jcod
@@ -31,11 +31,11 @@
 // public sealed class SuperClass permits sealedP1.C1, sealedP2.C2, sealedP3.C3 { }
 
 class sealedP1/SuperClass {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [20] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/records/abstractRecord.jcod b/test/hotspot/jtreg/runtime/records/abstractRecord.jcod
--- a/test/hotspot/jtreg/runtime/records/abstractRecord.jcod
+++ b/test/hotspot/jtreg/runtime/records/abstractRecord.jcod
@@ -27,11 +27,11 @@
 // This test is a Record marked as abstract.  It should result in a
 // ClassFormatError exception.
 class abstractRecord {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [69] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/records/badRecordAttribute.jcod b/test/hotspot/jtreg/runtime/records/badRecordAttribute.jcod
--- a/test/hotspot/jtreg/runtime/records/badRecordAttribute.jcod
+++ b/test/hotspot/jtreg/runtime/records/badRecordAttribute.jcod
@@ -27,11 +27,11 @@
 // This test has a Record attribute entry that points to a Field instead of a
 // Utf8.  It should result in a ClassFormatError exception.
 class badRecordAttribute {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [69] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/records/notFinalRecord.jcod b/test/hotspot/jtreg/runtime/records/notFinalRecord.jcod
--- a/test/hotspot/jtreg/runtime/records/notFinalRecord.jcod
+++ b/test/hotspot/jtreg/runtime/records/notFinalRecord.jcod
@@ -27,11 +27,11 @@
 // This test is a Record but not marked final.  It should result in a
 // ClassFormatError exception.
 class notFinalRecord {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [69] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/records/recordIgnoredVersion.jcod b/test/hotspot/jtreg/runtime/records/recordIgnoredVersion.jcod
--- a/test/hotspot/jtreg/runtime/records/recordIgnoredVersion.jcod
+++ b/test/hotspot/jtreg/runtime/records/recordIgnoredVersion.jcod
@@ -23,11 +23,11 @@
 
 // Record attribute is ignored because class file minor version is 0.
 class recordIgnoredVersion {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [52] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/records/shortRecordAttribute.jcod b/test/hotspot/jtreg/runtime/records/shortRecordAttribute.jcod
--- a/test/hotspot/jtreg/runtime/records/shortRecordAttribute.jcod
+++ b/test/hotspot/jtreg/runtime/records/shortRecordAttribute.jcod
@@ -27,11 +27,11 @@
 // This test has a Record attribute that is too short.  It is missing a required
 // attribute_count field.  It should result in a ClassFormatError exception.
 class shortRecordAttribute {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [69] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/records/superNotJLRecord.jcod b/test/hotspot/jtreg/runtime/records/superNotJLRecord.jcod
--- a/test/hotspot/jtreg/runtime/records/superNotJLRecord.jcod
+++ b/test/hotspot/jtreg/runtime/records/superNotJLRecord.jcod
@@ -27,11 +27,11 @@
 // This test has a Record attribute that is too short but its super class is
 // not java.lang.Record.  So, the bogus Record attribute should be ignored.
 class superNotJLRecord {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [69] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/records/twoRecordAttributes.jcod b/test/hotspot/jtreg/runtime/records/twoRecordAttributes.jcod
--- a/test/hotspot/jtreg/runtime/records/twoRecordAttributes.jcod
+++ b/test/hotspot/jtreg/runtime/records/twoRecordAttributes.jcod
@@ -27,11 +27,11 @@
 // This test has a Record with two Record attributes.  It should result in
 // a ClassFormatError exception.
 class twoRecordAttributes {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [69] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/sealedClasses/GetPermittedSubclasses.jcod b/test/hotspot/jtreg/runtime/sealedClasses/GetPermittedSubclasses.jcod
--- a/test/hotspot/jtreg/runtime/sealedClasses/GetPermittedSubclasses.jcod
+++ b/test/hotspot/jtreg/runtime/sealedClasses/GetPermittedSubclasses.jcod
@@ -28,11 +28,11 @@
 // sealed class NoLoadSubclasses permits iDontExist, I/Dont/Exist/Either { }
 //
 class NoLoadSubclasses {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [18] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
@@ -104,11 +104,11 @@
 // This class contains an empty PermittedSubclasses attribute.  Test that
 // this causes an exception to get thrown.
 class NoSubclasses {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [14] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
@@ -255,11 +255,11 @@
 // This class has a corrupted PermittedSubclasses attribute.  Attempts to load it
 // should throw ClassFormatError.
 class BadPermittedAttr {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [18] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
@@ -333,11 +333,11 @@
 // sealed class SealedButFinal permits iDontExist, I/Dont/Exist/Either { }
 //
 class SealedButFinal {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [18] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
@@ -411,11 +411,11 @@
 // sealed class BadPermittedSubclassEntry permits iDont;;Exist, I/Dont/Exist/Either { }
 //
 class BadPermittedSubclassEntry {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [18] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
@@ -488,11 +488,11 @@
 // sealed class EmptyPermittedSubclassEntry permits "", I/Dont/Exist/Either { }
 //
 class EmptyPermittedSubclassEntry {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [18] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/sealedClasses/Pkg/NotPermitted.jcod b/test/hotspot/jtreg/runtime/sealedClasses/Pkg/NotPermitted.jcod
--- a/test/hotspot/jtreg/runtime/sealedClasses/Pkg/NotPermitted.jcod
+++ b/test/hotspot/jtreg/runtime/sealedClasses/Pkg/NotPermitted.jcod
@@ -29,11 +29,11 @@
 //    public class NotPermitted implements SealedInterface { }
 //
 class Pkg/NotPermitted {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [15] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/sealedClasses/Pkg/SealedInterface.jcod b/test/hotspot/jtreg/runtime/sealedClasses/Pkg/SealedInterface.jcod
--- a/test/hotspot/jtreg/runtime/sealedClasses/Pkg/SealedInterface.jcod
+++ b/test/hotspot/jtreg/runtime/sealedClasses/Pkg/SealedInterface.jcod
@@ -29,11 +29,11 @@
 // sealed public interface SealedInterface permits Permitted, otherPkg.WrongPackage { }
 
 class Pkg/SealedInterface {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [12] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "Pkg/SealedInterface"; // #2     at 0x0D
     class #4; // #3     at 0x23
diff a/test/hotspot/jtreg/runtime/sealedClasses/planets/Mars.jcod b/test/hotspot/jtreg/runtime/sealedClasses/planets/Mars.jcod
--- a/test/hotspot/jtreg/runtime/sealedClasses/planets/Mars.jcod
+++ b/test/hotspot/jtreg/runtime/sealedClasses/planets/Mars.jcod
@@ -29,11 +29,11 @@
 //    public class Mars extends OuterPlanets { }
 //
 class planets/Mars {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [13] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/sealedClasses/planets/OuterPlanets.jcod b/test/hotspot/jtreg/runtime/sealedClasses/planets/OuterPlanets.jcod
--- a/test/hotspot/jtreg/runtime/sealedClasses/planets/OuterPlanets.jcod
+++ b/test/hotspot/jtreg/runtime/sealedClasses/planets/OuterPlanets.jcod
@@ -26,11 +26,11 @@
 // sealed public class OuterPlanets permits Neptune, asteroids.Pluto { }
 
 class planets/OuterPlanets {
   0xCAFEBABE;
   65535; // minor version
-  59; // version
+  60; // version
   [18] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1     at 0x0A
     class #4; // #2     at 0x0F
     NameAndType #5 #6; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod
@@ -91,11 +91,11 @@
 //
 
 class WithFieldNoAccessTest$V {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [58] { // Constant Pool
     ; // first element is empty
     class #33; // #1     at 0x0A
     Field #1 #34; // #2     at 0x0D
     Field #1 #35; // #3     at 0x12
@@ -351,11 +351,11 @@
 
 
 class WithFieldNoAccessTest {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [91] { // Constant Pool
     ; // first element is empty
     Method #23 #39; // #1     at 0x0A
     long 0x0000000000000005;; // #2     at 0x0F
     Method #24 #40; // #4     at 0x18
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod
@@ -46,11 +46,11 @@
 // Test that class modifiers cannot have both ACC_VALUE and ACC_ABSTRACT set.
 //
 class ValueAbstract {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [28] { // Constant Pool
     ; // first element is empty
     Method #7 #23; // #1     at 0x0A
     Field #3 #24; // #2     at 0x0F
     class #9; // #3     at 0x14
@@ -202,11 +202,11 @@
 // Test that class modifiers cannot have both ACC_VALUE and ACC_ENUM set.
 //
 class ValueEnum {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [28] { // Constant Pool
     ; // first element is empty
     Method #7 #23; // #1     at 0x0A
     Field #3 #24; // #2     at 0x0F
     class #9; // #3     at 0x14
@@ -358,11 +358,11 @@
 // Test that inline type fields must be final.
 //
 class ValueFieldNotFinal {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [28] { // Constant Pool
     ; // first element is empty
     Method #7 #23; // #1     at 0x0A
     Field #3 #24; // #2     at 0x0F
     class #9; // #3     at 0x14
@@ -514,11 +514,11 @@
 // Test that class modifiers cannot have both ACC_VALUE and ACC_INTERFACE set.
 //
 class ValueInterface {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [27] { // Constant Pool
     ; // first element is empty
     Method #7 #21; // #1     at 0x0A
     Field #3 #22; // #2     at 0x0F
     class #23; // #3     at 0x14
@@ -621,11 +621,11 @@
 // }
 
 class ValueMethodSynch {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [46] { // Constant Pool
     ; // first element is empty
     class #23; // #1     at 0x0A
     Field #1 #24; // #2     at 0x0D
     InvokeDynamic 0s #27; // #3     at 0x12
@@ -876,11 +876,11 @@
 // }
 
 class Circ {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [61] { // Constant Pool
     ; // first element is empty
     class #34; // #1     at 0x0A
     Field #1 #35; // #2     at 0x0D
     class #36; // #3     at 0x12
@@ -1155,11 +1155,11 @@
 } // end class Circ
 
 class Circ2 {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [60] { // Constant Pool
     ; // first element is empty
     class #33; // #1     at 0x0A
     Field #1 #34; // #2     at 0x0D
     class #35; // #3     at 0x12
@@ -1469,11 +1469,11 @@
 // }
 
 class CircStaticA {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [61] { // Constant Pool
     ; // first element is empty
     class #34; // #1     at 0x0A
     Field #1 #35; // #2     at 0x0D
     InvokeDynamic 0s #38; // #3     at 0x12
@@ -1747,11 +1747,11 @@
 } // end class CircStaticA
 
 class CircStaticB {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [61] { // Constant Pool
     ; // first element is empty
     class #34; // #1     at 0x0A
     Field #1 #35; // #2     at 0x0D
     InvokeDynamic 0s #38; // #3     at 0x12
@@ -2034,11 +2034,11 @@
 //}
 
 class ValueCloneable {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [46] { // Constant Pool
     ; // first element is empty
     class #22; // #1     at 0x0A
     Field #1 #23; // #2     at 0x0D
     InvokeDynamic 0s #26; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod
@@ -1,9 +1,9 @@
 class IdentityType {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1
     class #4; // #2
     NameAndType #5 #6; // #3
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod
@@ -37,11 +37,11 @@
 
 // Inline class with a super class that is not abstract.
 class SuperNotAbstract {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperNotAbstract"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -297,11 +297,11 @@
 
 // Inline class with a super class that has instance fields.
 class SuperHasNonStaticFields {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperHasNonStaticFields"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -557,11 +557,11 @@
 
 // Inline class with a super class whose super class has a syncronized instance method.
 class SuperHasSynchMethod {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperHasSynchMethod"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -816,11 +816,11 @@
 
 // Inline class with a super class containing a constructor that has arguments.
 class SuperCtorHasArgs {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperCtorHasArgs"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -1077,11 +1077,11 @@
 // Inline class with a super class containing a constructor that has a non-empty
 // method body.
 class SuperCtorIsNotEmpty {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperCtorIsNotEmpty"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -1337,11 +1337,11 @@
 // Inline class that implements java.lang.IdentityObject.  Loading this
 // class should throw an ICCE.
 class InlineImplementsIdentityObject {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [53] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "InlineImplementsIdentityObject"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x28
@@ -1601,11 +1601,11 @@
 // Inline class with a super class that implements java.lang.IdentityObject.
 // Loading this class should throw an ICCE.
 class SuperImplementsIdentityObject {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperImplementsIdentityObject"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -1861,11 +1861,11 @@
 // Inline class with a super class that implements an interface that extends other
 // interfaces that eventually extend java.lang.IdentityObject
 class SuperIntfImplementsIdentityObject {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperIntfImplementsIdentityObject"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod
@@ -66,11 +66,11 @@
 // }
 
 class NoNullVT {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [63] { // Constant Pool
     ; // first element is empty
     class #36; // #1     at 0x0A
     Field #1 #37; // #2     at 0x0D
     Field #1 #38; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod
@@ -58,11 +58,11 @@
 // the constant pool, a VerifyError exception should get thrown.
 //
 class defValBadCP {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [27] { // Constant Pool
     ; // first element is empty
     Method #7 #21; // #1     at 0x0A
     Field #3 #22; // #2     at 0x0F
     class #23; // #3     at 0x14
@@ -260,11 +260,11 @@
 // entry instead of a Class entry, a VerifyError exception should get thrown.
 //
 class defValWrongCPType {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [27] { // Constant Pool
     ; // first element is empty
     Method #7 #21; // #1     at 0x0A
     Field #3 #22; // #2     at 0x0F
     class #23; // #3     at 0x14
@@ -361,11 +361,11 @@
 // the constant pool, a VerifyError exception should get thrown.
 //
 class wthFldBadCP {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [20] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -479,11 +479,11 @@
 // the type (int) of the field being assigned to.
 //
 class wthFldBadFldVal {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [20] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -596,11 +596,11 @@
 // for the withfield opcode (0xCC at bytecode position 6) must be a reference.
 //
 class wthFldBadFldRef {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [20] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -815,11 +815,11 @@
 // entry instead of a Field entry, a VerifyError exception should get thrown.
 //
 class wthFldWrongCPType {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [20] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -934,11 +934,11 @@
 // and the inline type on the stack, in this case 'wthFldObject', be identical.
 //
 class wthFldObject {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [22] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -1056,11 +1056,11 @@
 // cannot be an inline type.
 //
 class monEnterVT {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [46] { // Constant Pool
     ; // first element is empty
     class #23; // #1     at 0x0A
     Field #1 #24; // #2     at 0x0D
     InvokeDynamic 0s #27; // #3     at 0x12
@@ -1284,11 +1284,11 @@
 // must be an inline type.
 //
 class defValueObj {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [46] { // Constant Pool
     ; // first element is empty
     class #23; // #1     at 0x0A
     Field #1 #24; // #2     at 0x0D
     InvokeDynamic 0s #27; // #3     at 0x12
@@ -1512,11 +1512,11 @@
 // opcode must be an inline type.
 //
 class withfieldObj {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [23] { // Constant Pool
     ; // first element is empty
     Method #5 #19; // #1     at 0x0A
     Field #3 #20; // #2     at 0x0F
     class #13; // #3     at 0x14
diff a/test/hotspot/jtreg/serviceability/dcmd/gc/HeapDumpCompressedTest.java b/test/hotspot/jtreg/serviceability/dcmd/gc/HeapDumpCompressedTest.java
--- a/test/hotspot/jtreg/serviceability/dcmd/gc/HeapDumpCompressedTest.java
+++ b/test/hotspot/jtreg/serviceability/dcmd/gc/HeapDumpCompressedTest.java
@@ -34,18 +34,41 @@
 import jdk.test.lib.dcmd.PidJcmdExecutor;
 import jdk.test.lib.process.OutputAnalyzer;
 
 /*
  * @test
- * @summary Test of diagnostic command GC.heap_dump with gzipped output (Serial, Parallel and G1)
+ * @requires vm.gc.Serial
+ * @summary Test of diagnostic command GC.heap_dump with gzipped output (Serial GC)
  * @library /test/lib
  * @modules java.base/jdk.internal.misc
  *          java.compiler
  *          java.management
  *          jdk.internal.jvmstat/sun.jvmstat.monitor
  * @run main/othervm -XX:+UseSerialGC HeapDumpCompressedTest
+ */
+
+/*
+ * @test
+ * @requires vm.gc.Parallel
+ * @summary Test of diagnostic command GC.heap_dump with gzipped output (Parallel GC)
+ * @library /test/lib
+ * @modules java.base/jdk.internal.misc
+ *          java.compiler
+ *          java.management
+ *          jdk.internal.jvmstat/sun.jvmstat.monitor
  * @run main/othervm -XX:+UseParallelGC HeapDumpCompressedTest
+ */
+
+/*
+ * @test
+ * @requires vm.gc.G1
+ * @summary Test of diagnostic command GC.heap_dump with gzipped output (G1 GC)
+ * @library /test/lib
+ * @modules java.base/jdk.internal.misc
+ *          java.compiler
+ *          java.management
+ *          jdk.internal.jvmstat/sun.jvmstat.monitor
  * @run main/othervm -XX:+UseG1GC HeapDumpCompressedTest
  */
 
 /*
  * @test
diff a/test/hotspot/jtreg/vmTestbase/nsk/jdi/VirtualMachine/dispose/dispose004.java b/test/hotspot/jtreg/vmTestbase/nsk/jdi/VirtualMachine/dispose/dispose004.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/jdi/VirtualMachine/dispose/dispose004.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/jdi/VirtualMachine/dispose/dispose004.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -220,11 +220,11 @@
                         mainThread = (ThreadReference) listIterator.next();
                         if (mainThread.name().equals("main"))
                             break ;
                     } catch ( NoSuchElementException e ) {
                         log3("ERROR: NoSuchElementException for listIterator.next()");
-                        log3("ERROR: NO THREAD2 ?????????!!!!!!!");
+                        log3("ERROR: NO MAIN THREAD ?????????!!!!!!!");
                         expresult = returnCode1;
                         break label0;
                     }
                 }
             }
diff a/test/hotspot/jtreg/vmTestbase/nsk/jdi/VirtualMachine/suspend/suspend001.java b/test/hotspot/jtreg/vmTestbase/nsk/jdi/VirtualMachine/suspend/suspend001.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/jdi/VirtualMachine/suspend/suspend001.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/jdi/VirtualMachine/suspend/suspend001.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -244,11 +244,11 @@
                         mainThread = (ThreadReference) listIterator.next();
                         if (mainThread.name().equals("main"))
                             break ;
                     } catch ( NoSuchElementException e ) {
                         log3("ERROR: NoSuchElementException for listIterator.next()");
-                        log3("ERROR: NO THREAD2 ?????????!!!!!!!");
+                        log3("ERROR: NO MAIN THREAD ?????????!!!!!!!");
                         expresult = returnCode1;
                         break label0;
                     }
                 }
 
diff a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/Debugee.java b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/Debugee.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/Debugee.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/Debugee.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -648,15 +648,6 @@
                 }
             }
         }
     }
 
-    public boolean isJFR_active() {
-        String opts = argumentHandler.getLaunchOptions();
-        int jfrPos = opts.indexOf("-XX:+FlightRecorder");
-
-        if (jfrPos >= 0)
-            return true;
-        else
-            return false;
-    }
 }
diff a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebuggee.java b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebuggee.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebuggee.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebuggee.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,10 +22,11 @@
  */
 package nsk.share.jdi;
 
 import java.io.*;
 import java.util.*;
+import java.lang.reflect.Method;
 import nsk.share.Log;
 import nsk.share.ObjectInstancesManager;
 import nsk.share.TestBug;
 import nsk.share.jpda.DebugeeArgumentHandler;
 import nsk.share.jpda.IOPipe;
@@ -68,13 +69,17 @@
     static public final String COMMAND_DELETE_REFERRERS = "deleteReferrers";
 
     //create instance with all type referrers
     static public final String COMMAND_CREATE_ALL_TYPE_REFERENCES = "createAllTypeReferences";
 
+    // check jfr is active process
+    public static boolean isJFRActive;
+
     protected void init(String args[]) {
         super.init(args);
         objectInstancesManager = new ObjectInstancesManager(log);
+        isJFRActive = isJFRActive();
     }
 
     public void initDebuggee(DebugeeArgumentHandler argHandler, Log log, IOPipe pipe, String args[], boolean callExit) {
         super.initDebuggee(argHandler, log, pipe, args, callExit);
         objectInstancesManager = new ObjectInstancesManager(log);
@@ -184,42 +189,19 @@
         }
 
         return false;
     }
 
-    // instances of some classes couldn't be strictly controlled during test execution, use non-strict checks for this classes
-    public static boolean useStrictCheck(String className, boolean otherThreadPresent) {
-        if (className.equals("java.lang.String"))
-            return false;
-
-        if (className.equals("char[]"))
-            return false;
-
-        if (className.equals("byte[]"))
-            return false;
-
-        if (className.equals("boolean[]"))
-            return false;
-
-        if (className.equals("float[]"))
-            return false;
-
-        if (className.equals("long[]"))
-            return false;
-
-        if (className.equals("int[]"))
-            return false;
-
-        if (className.equals("double[]"))
+    // check if jfr is initialized
+    public static boolean isJFRActive() {
+        try {
+            Class cls = Class.forName("jdk.jfr.FlightRecorder");
+            Method method = cls.getDeclaredMethod("isInitialized", new Class[0]);
+            return (Boolean)method.invoke(cls, new Object[0]);
+        } catch(Exception e) {
             return false;
-
-        if (className.equals("java.lang.Thread")) {
-            if (otherThreadPresent)
-                return false;
         }
-
-        return true;
     }
 
     // is reference with given type should be included in ObjectReference.referringObjects
     static public boolean isIncludedIntoReferrersCount(String referenceType) {
         if (!ObjectInstancesManager.allReferenceTypes.contains(referenceType)) {
diff a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebugger.java b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebugger.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebugger.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebugger.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,12 +31,49 @@
  * Contains several common checking and auxiliary methods.
  */
 public class HeapwalkingDebugger extends TestDebuggerType2 {
     // instances of some classes couldn't be strictly controlled during test execution, use non-strict checks for this classes
     protected boolean strictCheck(String className) {
-        boolean otherThreadPresent = isJFR_active();
-        return HeapwalkingDebuggee.useStrictCheck(className, otherThreadPresent);
+        if (className.equals("java.lang.String"))
+            return false;
+
+        if (className.equals("char[]"))
+            return false;
+
+        if (className.equals("byte[]"))
+            return false;
+
+        if (className.equals("boolean[]"))
+            return false;
+
+        if (className.equals("float[]"))
+            return false;
+
+        if (className.equals("long[]"))
+            return false;
+
+        if (className.equals("int[]"))
+            return false;
+
+        if (className.equals("double[]"))
+            return false;
+
+        if (className.equals("java.lang.Thread")) {
+            return !isJFRActive();
+        }
+
+        return true;
+    }
+
+    protected boolean isJFRActive() {
+       ReferenceType referenceType = debuggee.classByName("nsk.share.jdi.HeapwalkingDebuggee");
+       if (referenceType == null)
+           throw new RuntimeException("Debugeee is not initialized yet");
+
+        Field isJFRActiveFld = referenceType.fieldByName("isJFRActive");
+        boolean isJFRActive = ((BooleanValue)referenceType.getValue(isJFRActiveFld)).value();
+        return isJFRActive;
     }
 
     // wrapper for VirtualMachine.instanceCounts
     public long getInstanceCount(String className) {
         List<ReferenceType> list = vm.classesByName(className);
diff a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/TestDebuggerType2.java b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/TestDebuggerType2.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/TestDebuggerType2.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/TestDebuggerType2.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -355,9 +355,6 @@
 
     protected void complain(String msg) {
         log.complain("debugger FAILURE> " + msg + "\n");
     }
 
-    protected boolean isJFR_active() {
-        return debuggee.isJFR_active();
-    }
 }
diff a/test/jdk/java/lang/ModuleTests/AnnotationsTest.java b/test/jdk/java/lang/ModuleTests/AnnotationsTest.java
--- a/test/jdk/java/lang/ModuleTests/AnnotationsTest.java
+++ b/test/jdk/java/lang/ModuleTests/AnnotationsTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,21 +21,24 @@
  * questions.
  */
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 import java.lang.annotation.Annotation;
 import java.lang.module.Configuration;
+import java.lang.module.ModuleDescriptor;
 import java.lang.module.ModuleFinder;
+import java.net.URL;
+import java.net.URLClassLoader;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.nio.file.Paths;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
+import jdk.internal.module.ModuleInfoWriter;
 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
 import jdk.internal.org.objectweb.asm.Attribute;
 import jdk.internal.org.objectweb.asm.ClassReader;
 import jdk.internal.org.objectweb.asm.ClassVisitor;
 import jdk.internal.org.objectweb.asm.ClassWriter;
@@ -48,11 +51,10 @@
 /**
  * @test
  * @modules java.base/jdk.internal.org.objectweb.asm
  *          java.base/jdk.internal.org.objectweb.asm.commons
  *          java.base/jdk.internal.module
- *          java.xml
  * @run testng AnnotationsTest
  * @summary Basic test of annotations on modules
  */
 
 public class AnnotationsTest {
@@ -66,23 +68,24 @@
         assertTrue(module.getAnnotations().length == 0);
         assertTrue(module.getDeclaredAnnotations().length == 0);
     }
 
     /**
-     * Test loading a module with a RuntimeVisibleAnnotation attribute.
-     * The test copies the module-info.class for java.xml, adds the attribute,
-     * and then loads the updated module.
+     * Test reflectively reading the annotations on a named module.
      */
     @Test
     public void testNamedModule() throws IOException {
+        Path mods = Files.createTempDirectory(Path.of(""), "mods");
 
-        // "deprecate" java.xml
-        Path dir = Files.createTempDirectory(Paths.get(""), "mods");
-        deprecateModule("java.xml", true, "9", dir);
+        // @Deprecated(since="9", forRemoval=true) module foo { }
+        ModuleDescriptor descriptor = ModuleDescriptor.newModule("foo").build();
+        byte[] classBytes = ModuleInfoWriter.toBytes(descriptor);
+        classBytes = addDeprecated(classBytes, true, "9");
+        Files.write(mods.resolve("module-info.class"), classBytes);
 
-        // "load" the cloned java.xml
-        Module module = loadModule(dir, "java.xml");
+        // create module layer with module foo
+        Module module = loadModule(mods, "foo");
 
         // check the annotation is present
         assertTrue(module.isAnnotationPresent(Deprecated.class));
         Deprecated d = module.getAnnotation(Deprecated.class);
         assertNotNull(d, "@Deprecated not found");
@@ -92,64 +95,98 @@
         assertTrue(a.length == 1);
         assertTrue(a[0] instanceof Deprecated);
         assertEquals(module.getDeclaredAnnotations(), a);
     }
 
-
     /**
-     * Copy the module-info.class for the given module, add the
-     * Deprecated annotation, and write the updated module-info.class
-     * to a directory.
+     * Test reflectively reading annotations on a named module where the module
+     * is mapped to a class loader that can locate a module-info.class.
      */
-    static void deprecateModule(String name,
-                                boolean forRemoval,
-                                String since,
-                                Path output) throws IOException {
-        Module module = ModuleLayer.boot().findModule(name).orElse(null);
-        assertNotNull(module, name + " not found");
-
-        InputStream in = module.getResourceAsStream("module-info.class");
-        assertNotNull(in, "No module-info.class for " + name);
-
-        try (in) {
-            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS
-                                             + ClassWriter.COMPUTE_FRAMES);
-
-            ClassVisitor cv = new ClassVisitor(Opcodes.ASM6, cw) { };
-
-            ClassReader cr = new ClassReader(in);
-            List<Attribute> attrs = new ArrayList<>();
-            attrs.add(new ModuleTargetAttribute());
-            cr.accept(cv, attrs.toArray(new Attribute[0]), 0);
-
-            AnnotationVisitor annotationVisitor
-                = cv.visitAnnotation("Ljava/lang/Deprecated;", true);
-            annotationVisitor.visit("forRemoval", forRemoval);
-            annotationVisitor.visit("since", since);
-            annotationVisitor.visitEnd();
-
-            byte[] bytes = cw.toByteArray();
-            Path mi = output.resolve("module-info.class");
-            Files.write(mi, bytes);
+    @Test
+    public void testWithModuleInfoResourceXXXX() throws IOException {
+        Path mods = Files.createTempDirectory(Path.of(""), "mods");
+
+        // classes directory with module-info.class
+        Path classes = Files.createTempDirectory(Path.of("."), "classes");
+        Path mi = classes.resolve("module-info.class");
+        try (OutputStream out = Files.newOutputStream(mi)) {
+            ModuleDescriptor descriptor = ModuleDescriptor.newModule("lurker").build();
+            ModuleInfoWriter.write(descriptor, out);
         }
+
+        // URLClassLoader that can locate a module-info.class resource
+        URL url = classes.toUri().toURL();
+        URLClassLoader loader = new URLClassLoader(new URL[] { url });
+        assertTrue(loader.findResource("module-info.class") != null);
+
+        // module foo { }
+        ModuleDescriptor descriptor = ModuleDescriptor.newModule("foo").build();
+        byte[] classBytes = ModuleInfoWriter.toBytes(descriptor);
+        Files.write(mods.resolve("module-info.class"), classBytes);
+
+        // create module layer with module foo
+        Module foo = loadModule(mods, "foo", loader);
+
+        // check the annotation is not present
+        assertFalse(foo.isAnnotationPresent(Deprecated.class));
+
+        // @Deprecated(since="11", forRemoval=true) module bar { }
+        descriptor = ModuleDescriptor.newModule("bar").build();
+        classBytes = ModuleInfoWriter.toBytes(descriptor);
+        classBytes = addDeprecated(classBytes, true, "11");
+        Files.write(mods.resolve("module-info.class"), classBytes);
+
+        // create module layer with module bar
+        Module bar = loadModule(mods, "bar", loader);
+
+        // check the annotation is present
+        assertTrue(bar.isAnnotationPresent(Deprecated.class));
+    }
+
+    /**
+     * Adds the Deprecated annotation to the given module-info class file.
+     */
+    static byte[] addDeprecated(byte[] bytes, boolean forRemoval, String since) {
+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS
+                                         + ClassWriter.COMPUTE_FRAMES);
+
+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM6, cw) { };
+
+        ClassReader cr = new ClassReader(bytes);
+        List<Attribute> attrs = new ArrayList<>();
+        attrs.add(new ModuleTargetAttribute());
+        cr.accept(cv, attrs.toArray(new Attribute[0]), 0);
+
+        AnnotationVisitor annotationVisitor
+            = cv.visitAnnotation("Ljava/lang/Deprecated;", true);
+        annotationVisitor.visit("forRemoval", forRemoval);
+        annotationVisitor.visit("since", since);
+        annotationVisitor.visitEnd();
+
+        return cw.toByteArray();
     }
 
     /**
      * Load the module of the given name in the given directory into a
-     * child layer.
+     * child layer with the given class loader as the parent class loader.
      */
-    static Module loadModule(Path dir, String name) throws IOException {
+    static Module loadModule(Path dir, String name, ClassLoader parent)
+        throws IOException
+    {
         ModuleFinder finder = ModuleFinder.of(dir);
 
         ModuleLayer bootLayer = ModuleLayer.boot();
 
         Configuration cf = bootLayer.configuration()
                 .resolve(finder, ModuleFinder.of(), Set.of(name));
 
-        ClassLoader scl = ClassLoader.getSystemClassLoader();
-        ModuleLayer layer = bootLayer.defineModulesWithOneLoader(cf, scl);
+        ModuleLayer layer = bootLayer.defineModulesWithOneLoader(cf, parent);
 
         Module module = layer.findModule(name).orElse(null);
         assertNotNull(module, name + " not loaded");
         return module;
     }
+
+    static Module loadModule(Path dir, String name) throws IOException {
+        return loadModule(dir, name, ClassLoader.getSystemClassLoader());
+    }
 }
diff a/test/jdk/java/lang/module/ClassFileVersionsTest.java b/test/jdk/java/lang/module/ClassFileVersionsTest.java
--- a/test/jdk/java/lang/module/ClassFileVersionsTest.java
+++ b/test/jdk/java/lang/module/ClassFileVersionsTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -57,10 +57,11 @@
                 { 55,   0,  Set.of() },                      // JDK 11
                 { 56,   0,  Set.of() },                      // JDK 12
                 { 57,   0,  Set.of() },                      // JDK 13
                 { 58,   0,  Set.of() },                      // JDK 14
                 { 59,   0,  Set.of() },                      // JDK 15
+                { 60,   0,  Set.of() },                      // JDK 16
         };
     }
 
     // major, minor, modifiers for requires java.base
     @DataProvider(name = "unsupported")
@@ -92,11 +93,15 @@
 
                 { 59,   0,  Set.of(STATIC) },                // JDK 15
                 { 59,   0,  Set.of(TRANSITIVE) },
                 { 59,   0,  Set.of(STATIC, TRANSITIVE) },
 
-                { 60,   0,  Set.of()},                       // JDK 16
+                { 60,   0,  Set.of(STATIC) },                // JDK 16
+                { 60,   0,  Set.of(TRANSITIVE) },
+                { 60,   0,  Set.of(STATIC, TRANSITIVE) },
+
+                { 61,   0,  Set.of()},                       // JDK 17
         };
     }
 
     @Test(dataProvider = "supported")
     public void testSupported(int major, int minor, Set<Modifier> ms) {
diff a/test/jdk/java/util/Locale/LocaleProvidersRun.java b/test/jdk/java/util/Locale/LocaleProvidersRun.java
--- a/test/jdk/java/util/Locale/LocaleProvidersRun.java
+++ b/test/jdk/java/util/Locale/LocaleProvidersRun.java
@@ -24,18 +24,19 @@
 /*
  * @test
  * @bug 6336885 7196799 7197573 7198834 8000245 8000615 8001440 8008577
  *      8010666 8013086 8013233 8013903 8015960 8028771 8054482 8062006
  *      8150432 8215913 8220227 8228465 8232871 8232860 8236495 8245241
+ *      8246721
  * @summary tests for "java.locale.providers" system property
  * @library /test/lib
  * @build LocaleProviders
  *        providersrc.spi.src.tznp
  *        providersrc.spi.src.tznp8013086
  * @modules java.base/sun.util.locale
  *          java.base/sun.util.locale.provider
- * @run main LocaleProvidersRun
+ * @run main/othervm -Djdk.lang.Process.allowAmbiguousCommands=false LocaleProvidersRun
  */
 
 import java.util.Locale;
 
 import jdk.test.lib.JDKToolLauncher;
@@ -162,10 +163,12 @@
 
         //testing 8232860 fix. (macOS/Windows only)
         testRun("HOST", "bug8232860Test", "", "", "");
 
         //testing 8245241 fix.
+        //jdk.lang.Process.allowAmbiguousCommands=false is needed for properly escaping
+        //double quotes in the string argument.
         testRun("FOO", "bug8245241Test",
             "Invalid locale provider adapter \"FOO\" ignored.", "", "");
     }
 
     private static void testRun(String prefList, String methodName,
diff a/test/jdk/java/util/zip/ZipFile/TestZipFile.java b/test/jdk/java/util/zip/ZipFile/TestZipFile.java
--- a/test/jdk/java/util/zip/ZipFile/TestZipFile.java
+++ b/test/jdk/java/util/zip/ZipFile/TestZipFile.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,44 +28,52 @@
  * @summary Tests various ZipFile apis
  * @run main/manual TestZipFile
  */
 
 import java.io.*;
-import java.lang.reflect.Method;
-import java.nio.*;
-import java.nio.file.*;
-import java.nio.file.attribute.*;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.util.*;
-import java.util.concurrent.*;
-import java.util.zip.*;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.CRC32;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
 
 public class TestZipFile {
 
-    private static Random r = new Random();
-    private static int    N = 50;
-    private static int    NN = 10;
-    private static int    ENUM = 10000;
-    private static int    ESZ = 10000;
+    private static final Random r = new Random();
+    private static final int    N = 50;
+    private static final int    NN = 10;
+    private static final int    ENUM = 10000;
+    private static final int    ESZ = 10000;
     private static ExecutorService executor = Executors.newFixedThreadPool(20);
-    private static Set<Path> paths = new HashSet<>();
+    private static final Set<Path> paths = new HashSet<>();
+    private static final boolean isWindows = System.getProperty("os.name")
+            .startsWith("Windows");
 
     static void realMain (String[] args) throws Throwable {
-
         try {
             for (int i = 0; i < N; i++) {
                 test(r.nextInt(ENUM), r.nextInt(ESZ), false, true);
                 test(r.nextInt(ENUM), r.nextInt(ESZ), true, true);
             }
-
+            executor.shutdown();
+            executor.awaitTermination(10, TimeUnit.MINUTES);
+            executor = Executors.newFixedThreadPool(20);
             for (int i = 0; i < NN; i++) {
                 test(r.nextInt(ENUM), 100000 + r.nextInt(ESZ), false, true);
                 test(r.nextInt(ENUM), 100000 + r.nextInt(ESZ), true, true);
-                testCachedDelete();
-                testCachedOverwrite();
-                //test(r.nextInt(ENUM), r.nextInt(ESZ), false, true);
+                if(!isWindows) {
+                    testCachedDelete();
+                    testCachedOverwrite();
+                }
             }
-
             test(70000, 1000, false, true);   // > 65536 entry number;
             testDelete();                     // OPEN_DELETE
 
             executor.shutdown();
             executor.awaitTermination(10, TimeUnit.MINUTES);
@@ -75,11 +83,11 @@
             }
         }
     }
 
     static void test(int numEntry, int szMax, boolean addPrefix, boolean cleanOld) {
-        String name = "zftest" + r.nextInt() + ".zip";
+        String name = "test-" + r.nextInt() + ".zip";
         Zip zip = new Zip(name, numEntry, szMax, addPrefix, cleanOld);
         for (int i = 0; i < NN; i++) {
             executor.submit(() -> doTest(zip));
         }
      }
@@ -87,11 +95,11 @@
     // test scenario:
     // (1) open the ZipFile(zip) with OPEN_READ | OPEN_DELETE
     // (2) test the ZipFile works correctly
     // (3) check the zip is deleted after ZipFile gets closed
     static void testDelete() throws Throwable {
-        String name = "zftest" + r.nextInt() + ".zip";
+        String name = "testDelete-" + r.nextInt() + ".zip";
         Zip zip = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
         try (ZipFile zf = new ZipFile(new File(zip.name),
                                       ZipFile.OPEN_READ | ZipFile.OPEN_DELETE ))
         {
             doTest0(zip, zf);
@@ -106,11 +114,11 @@
     // (1) keep a ZipFile(zip1) alive (in ZipFile's cache), dont close it
     // (2) delete zip1 and create zip2 with the same name the zip1 with zip2
     // (3) zip1 tests should fail, but no crash
     // (4) zip2 tasks should all get zip2, then pass normal testing.
     static void testCachedDelete() throws Throwable {
-        String name = "zftest" + r.nextInt() + ".zip";
+        String name = "testCachedDelete-" + r.nextInt() + ".zip";
         Zip zip1 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
 
         try (ZipFile zf = new ZipFile(zip1.name)) {
             for (int i = 0; i < NN; i++) {
                 executor.submit(() -> verifyNoCrash(zip1));
@@ -133,11 +141,11 @@
     }
 
    // overwrite the "zip1"  and create a new one to test. So the two zip files
    // have the same fileKey, but probably different lastModified()
     static void testCachedOverwrite() throws Throwable {
-        String name = "zftest" + r.nextInt() + ".zip";
+        String name = "testCachedOverWrite-" + r.nextInt() + ".zip";
         Zip zip1 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
         try (ZipFile zf = new ZipFile(zip1.name)) {
             for (int i = 0; i < NN; i++) {
                 executor.submit(() -> verifyNoCrash(zip1));
             }
@@ -151,12 +159,12 @@
 
     // just check the entries and contents. since the file has been either overwritten
     // or deleted/rewritten, we only care if it crahes or not.
     static void verifyNoCrash(Zip zip) throws RuntimeException {
         try (ZipFile zf = new ZipFile(zip.name)) {
-            List<ZipEntry> zlist = new ArrayList(zip.entries.keySet());
-            String[] elist = zf.stream().map( e -> e.getName()).toArray(String[]::new);
+            List<ZipEntry> zlist = new ArrayList<>(zip.entries.keySet());
+            String[] elist = zf.stream().map(e -> e.getName()).toArray(String[]::new);
             if (!Arrays.equals(elist,
                                zlist.stream().map( e -> e.getName()).toArray(String[]::new)))
             {
                 //System.out.printf("++++++ LIST NG [%s] entries.len=%d, expected=%d+++++++%n",
                 //                  zf.getName(), elist.length, zlist.size());
@@ -217,16 +225,16 @@
     }
 
     static void doTest0(Zip zip, ZipFile zf) throws Throwable {
         // (0) check zero-length entry name, no AIOOBE
         try {
-            check(zf.getEntry("") == null);;
+            check(zf.getEntry("") == null);
         } catch (Throwable t) {
             unexpected(t);
         }
 
-        List<ZipEntry> list = new ArrayList(zip.entries.keySet());
+        List<ZipEntry> list = new ArrayList<>(zip.entries.keySet());
         // (1) check entry list, in expected order
         if (!check(Arrays.equals(
                 list.stream().map( e -> e.getName()).toArray(String[]::new),
                 zf.stream().map( e -> e.getName()).toArray(String[]::new)))) {
             return;
@@ -254,33 +262,15 @@
                     check(is.read() == -1);
                     check(Arrays.equals(data, buf));
                 }
             }
         }
-        // (3) check getMetaInfEntryNames
-        String[] metas = list.stream()
-                             .map( e -> e.getName())
-                             .filter( s -> s.startsWith("META-INF/"))
-                             .sorted()
-                             .toArray(String[]::new);
-        if (metas.length > 0) {
-            // meta-inf entries
-            Method getMetas = ZipFile.class.getDeclaredMethod("getMetaInfEntryNames");
-            getMetas.setAccessible(true);
-            String[] names = (String[])getMetas.invoke(zf);
-            if (names == null) {
-                fail("Failed to get metanames from " + zf);
-            } else {
-                Arrays.sort(names);
-                check(Arrays.equals(names, metas));
-            }
-        }
     }
 
     private static class Zip {
-        String name;
-        Map<ZipEntry, byte[]> entries;
+        final String name;
+        final Map<ZipEntry, byte[]> entries;
         BasicFileAttributes attrs;
         long lastModified;
 
         Zip(String name, int num, int szMax, boolean prefix, boolean clean) {
             this.name = name;
@@ -290,11 +280,11 @@
                 if (clean) {
                     Files.deleteIfExists(p);
                 }
                 paths.add(p);
             } catch (Exception x) {
-                throw (RuntimeException)x;
+                throw new RuntimeException(x);
             }
 
             try (FileOutputStream fos = new FileOutputStream(name);
                  BufferedOutputStream bos = new BufferedOutputStream(fos);
                  ZipOutputStream zos = new ZipOutputStream(bos))
@@ -307,26 +297,26 @@
                 CRC32 crc = new CRC32();
                 for (int i = 0; i < num; i++) {
                     String ename = "entry-" + i + "-name-" + r.nextLong();
                     ZipEntry ze = new ZipEntry(ename);
                     int method = r.nextBoolean() ? ZipEntry.STORED : ZipEntry.DEFLATED;
-                    writeEntry(zos, crc, ze, ZipEntry.STORED, szMax);
+                    writeEntry(zos, crc, ze, method, szMax);
                 }
                 // add some manifest entries
                 for (int i = 0; i < r.nextInt(20); i++) {
                     String meta = "META-INF/" + "entry-" + i + "-metainf-" + r.nextLong();
                     ZipEntry ze = new ZipEntry(meta);
                     writeEntry(zos, crc, ze, ZipEntry.STORED, szMax);
                 }
             } catch (Exception x) {
-                throw (RuntimeException)x;
+                throw new RuntimeException(x);
             }
             try {
                 this.attrs = Files.readAttributes(Paths.get(name), BasicFileAttributes.class);
                 this.lastModified = new File(name).lastModified();
             } catch (Exception x) {
-                throw (RuntimeException)x;
+                throw new RuntimeException(x);
             }
         }
 
         private void writeEntry(ZipOutputStream zos, CRC32 crc,
                                 ZipEntry ze, int method, int szMax)
@@ -356,14 +346,13 @@
     static void pass() {passed++;}
     static void pass(String msg) {System.out.println(msg); passed++;}
     static void fail() {failed++; Thread.dumpStack();}
     static void fail(String msg) {System.out.println(msg); fail();}
     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
-    static void unexpected(Throwable t, String msg) {
-        System.out.println(msg); failed++; t.printStackTrace();}
+
     static boolean check(boolean cond) {if (cond) pass(); else fail(); return cond;}
 
-    public static void main(String[] args) throws Throwable {
+    public static void main(String[] args) {
         try {realMain(args);} catch (Throwable t) {unexpected(t);}
         System.out.println("\nPassed = " + passed + " failed = " + failed);
         if (failed > 0) throw new AssertionError("Some tests failed");}
 }
diff a/test/jdk/java/util/zip/ZipFile/ZipEntryTimeBounds.java b/test/jdk/java/util/zip/ZipFile/ZipEntryTimeBounds.java
--- /dev/null
+++ b/test/jdk/java/util/zip/ZipFile/ZipEntryTimeBounds.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import org.testng.annotations.Test;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+
+import static org.testng.Assert.*;
+
+/* @test
+ * @bug 8246129
+ * @summary JDK add metadata to zip files with entries timestamped at the
+ *          lower bound of the DOS time epoch, i.e., 1980-01-01T00:00:00Z
+ * @run testng/othervm ZipEntryTimeBounds
+ */
+public class ZipEntryTimeBounds {
+
+    @Test
+    public void testFilesWithEntryAtLowerTimeBoundAreEqual() throws Exception {
+
+        // Ensure that entries that end up being exactly at the start of the
+        // DOS epoch, java.util.zip.ZipEntry.DOSTIME_BEFORE_1980, or
+        // 1980-01-01 00:00:00 are written without any extra timestamp metadata
+        // being written
+
+        TimeZone.setDefault(TimeZone.getTimeZone("GMT-01"));
+        File f1 = createTempFile();
+        makeZip(f1, new GregorianCalendar(1980, Calendar.JANUARY, 1, 0, 0, 0).getTimeInMillis());
+
+        TimeZone.setDefault(TimeZone.getTimeZone("GMT"));
+        File f2 = createTempFile();
+        makeZip(f2, new GregorianCalendar(1980, Calendar.JANUARY, 1, 0, 0, 0).getTimeInMillis());
+        assertEquals(Files.mismatch(f1.toPath(), f2.toPath()), -1L);
+
+        TimeZone.setDefault(TimeZone.getTimeZone("GMT+01"));
+        File f3 = createTempFile();
+        makeZip(f3, new GregorianCalendar(1980, Calendar.JANUARY, 1, 0, 0, 0).getTimeInMillis());
+        assertEquals(Files.mismatch(f1.toPath(), f3.toPath()), -1L);
+
+        // Check that the milliseconds part of the time is exactly preserved
+        assertEquals(new ZipFile(f1).getEntry("entry.txt").getTime() % 60000, 0);
+        assertEquals(new ZipFile(f2).getEntry("entry.txt").getTime() % 60000, 0);
+        assertEquals(new ZipFile(f3).getEntry("entry.txt").getTime() % 60000, 0);
+    }
+
+    @Test
+    public void testFilesWithEntryAfterLowerTimeBoundAreEqual() throws Exception {
+        // Ensure files written using different timezone with entries set
+        // shortly after 1980-01-01 00:00:00 produce exactly identical files
+        // without metadata
+
+        TimeZone.setDefault(TimeZone.getTimeZone("GMT-01"));
+        File f1 = createTempFile();
+        makeZip(f1, new GregorianCalendar(1980, Calendar.JANUARY, 1, 0, 0, 1).getTimeInMillis());
+
+        TimeZone.setDefault(TimeZone.getTimeZone("GMT"));
+        File f2 = createTempFile();
+        makeZip(f2, new GregorianCalendar(1980, Calendar.JANUARY, 1, 0, 0, 1).getTimeInMillis());
+        assertEquals(Files.mismatch(f1.toPath(), f2.toPath()), -1L);
+
+        TimeZone.setDefault(TimeZone.getTimeZone("GMT+01"));
+        File f3 = createTempFile();
+        makeZip(f3, new GregorianCalendar(1980, Calendar.JANUARY, 1, 0, 0, 1).getTimeInMillis() + 999);
+        assertEquals(Files.mismatch(f1.toPath(), f3.toPath()), -1L);
+
+        // Check that the seconds part of the time is lossily preserved,
+        // rounding down to the previous 2s step since epoch
+        assertEquals(new ZipFile(f1).getEntry("entry.txt").getTime() % 60000, 0);
+        assertEquals(new ZipFile(f2).getEntry("entry.txt").getTime() % 60000, 0);
+        assertEquals(new ZipFile(f3).getEntry("entry.txt").getTime() % 60000, 0);
+
+        File f4 = createTempFile();
+        makeZip(f4, new GregorianCalendar(1980, Calendar.JANUARY, 1, 0, 0, 2).getTimeInMillis());
+        assertEquals(new ZipFile(f4).getEntry("entry.txt").getTime() % 60000, 2000);
+    }
+
+    @Test
+    public void testFilesWithEntryBeforeLowerTimeBoundAreNotEqual() throws Exception {
+        // Files written using different timezone with entries set shortly
+        // before 1980-01-01 00:00:00 will produce files which add timestamp
+        // metadata that make the files turn up not equal
+
+        TimeZone.setDefault(TimeZone.getTimeZone("GMT-01"));
+        File f1 = createTempFile();
+        makeZip(f1, new GregorianCalendar(1979, Calendar.DECEMBER, 31, 23, 59, 59).getTimeInMillis());
+
+        TimeZone.setDefault(TimeZone.getTimeZone("GMT"));
+        File f2 = createTempFile();
+        makeZip(f2, new GregorianCalendar(1979, Calendar.DECEMBER, 31, 23, 59, 59).getTimeInMillis());
+        assertNotEquals(Files.mismatch(f1.toPath(), f2.toPath()), -1L);
+
+        TimeZone.setDefault(TimeZone.getTimeZone("GMT+01"));
+        File f3 = createTempFile();
+        makeZip(f3, new GregorianCalendar(1979, Calendar.DECEMBER, 31, 23, 59, 59).getTimeInMillis() + 500);
+        assertNotEquals(Files.mismatch(f1.toPath(), f3.toPath()), -1L);
+
+        // Check that the time is preserved at second precision, no rounding
+        // to 2s
+        assertEquals(new ZipFile(f1).getEntry("entry.txt").getTime() % 60000, 59000);
+        assertEquals(new ZipFile(f2).getEntry("entry.txt").getTime() % 60000, 59000);
+        // Milliseconds are discarded even when storing entries with extended
+        // time metadata
+        assertEquals(new ZipFile(f3).getEntry("entry.txt").getTime() % 60000, 59000);
+    }
+
+    private static void makeZip(File f, long time) throws Exception {
+        try (ZipOutputStream out = new ZipOutputStream(new FileOutputStream(f))) {
+            ZipEntry e = new ZipEntry("entry.txt");
+            e.setTime(time);
+            out.putNextEntry(e);
+            out.write(new byte[] { 0, 1, 2, 3 });
+            out.closeEntry();
+        }
+    }
+
+    private static File createTempFile() throws IOException {
+        File file = File.createTempFile("out", "zip");
+        file.deleteOnExit();
+        return file;
+    }
+}
diff a/test/jdk/sun/security/ssl/SSLSocketImpl/SetSoTimeout.java b/test/jdk/sun/security/ssl/SSLSocketImpl/SetSoTimeout.java
--- /dev/null
+++ b/test/jdk/sun/security/ssl/SSLSocketImpl/SetSoTimeout.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+
+/*
+ * @test
+ * @bug 8246031
+ * @summary Socket timeouts for getSession.
+ * @run main/othervm SetSoTimeout
+ */
+
+import java.io.*;
+import java.net.*;
+import java.util.*;
+import java.security.*;
+import javax.net.ssl.*;
+
+public class SetSoTimeout {
+
+    /*
+     * =============================================================
+     * Set the various variables needed for the tests, then
+     * specify what tests to run on each side.
+     */
+
+    /*
+     * Should we run the client or server in a separate thread?
+     * Both sides can throw exceptions, but do you have a preference
+     * as to which side should be the main thread.
+     */
+    static boolean separateServerThread = true;
+
+    /*
+     * Where do we find the keystores?
+     */
+    static String pathToStores = "../../../../javax/net/ssl/etc";
+    static String keyStoreFile = "keystore";
+    static String trustStoreFile = "truststore";
+    static String passwd = "passphrase";
+
+    /*
+     * Is the server ready to serve?
+     */
+    volatile static boolean serverReady = false;
+
+    /*
+     * Turn on SSL debugging?
+     */
+    static boolean debug = false;
+
+
+    /*
+     * Define the server side of the test.
+     *
+     * If the server prematurely exits, serverReady will be set to true
+     * to avoid infinite hangs.
+     */
+    void doServerSide() throws Exception {
+        SSLServerSocketFactory sslssf =
+                (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
+        SSLServerSocket sslServerSocket =
+                (SSLServerSocket) sslssf.createServerSocket(serverPort);
+
+        serverPort = sslServerSocket.getLocalPort();
+
+        /*
+         * Signal Client, we're ready for his connect.
+         */
+        serverReady = true;
+
+        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
+
+        //Make server busy.
+        Thread.sleep(500);
+
+        sslSocket.close();
+    }
+
+    /*
+     * Define the client side of the test.
+     *
+     * If the server prematurely exits, serverReady will be set to true
+     * to avoid infinite hangs.
+     */
+    void doClientSide() throws Exception {
+        boolean caught = false;
+
+        /*
+         * Wait for server to get started.
+         */
+        while (!serverReady) {
+            Thread.sleep(50);
+        }
+
+        SSLSocketFactory sslsf = (SSLSocketFactory)SSLSocketFactory.getDefault();
+        SSLSocket sslSocket = (SSLSocket)sslsf.createSocket(
+                InetAddress.getLocalHost(),
+                serverPort );
+
+        sslSocket.setSoTimeout(100); // The stall timeout.
+
+        sslSocket.getSession();
+        //Check connection state.
+        if (!sslSocket.isClosed()) {
+            throw new RuntimeException("Expected connection to be closed");
+        }
+
+        sslSocket.close();
+
+    }
+
+
+    // use any free port by default
+    volatile int serverPort = 0;
+
+    volatile Exception serverException = null;
+    volatile Exception clientException = null;
+
+
+    public static void main(String[] args) throws Exception {
+        String keyFilename =
+            System.getProperty("test.src", "./") + "/" + pathToStores +
+                "/" + keyStoreFile;
+        String trustFilename =
+            System.getProperty("test.src", "./") + "/" + pathToStores +
+                "/" + trustStoreFile;
+
+        System.setProperty("javax.net.ssl.keyStore", keyFilename);
+        System.setProperty("javax.net.ssl.keyStorePassword", passwd);
+        System.setProperty("javax.net.ssl.trustStore", trustFilename);
+        System.setProperty("javax.net.ssl.trustStorePassword", passwd);
+
+        if (debug)
+            System.setProperty("javax.net.debug", "all");
+
+        /*
+         * Start the tests.
+         */
+        new SetSoTimeout();
+    }
+
+    Thread clientThread = null;
+    Thread serverThread = null;
+
+    /*
+     * Primary constructor, used to drive remainder of the test.
+     *
+     * Fork off the other side, then do your work.
+     */
+    SetSoTimeout() throws Exception {
+        if (separateServerThread) {
+            startServer(true);
+            startClient(false);
+        } else {
+            startClient(true);
+            startServer(false);
+        }
+
+        /*
+         * Wait for other side to close down.
+         */
+        if (separateServerThread) {
+            serverThread.join();
+        } else {
+            clientThread.join();
+        }
+
+        /*
+         * When we get here, the test is pretty much over.
+         *
+         * If the main thread excepted, that propagates back
+         * immediately.  If the other thread threw an exception, we
+         * should report back.
+         */
+        if (serverException != null) {
+            System.out.print("Server Exception:");
+            throw serverException;
+        }
+        if (clientException != null) {
+            System.out.print("Client Exception:");
+            throw clientException;
+        }
+    }
+
+    void startServer(boolean newThread) throws Exception {
+        if (newThread) {
+            serverThread = new Thread() {
+                public void run() {
+                    try {
+                        doServerSide();
+                    } catch (Exception e) {
+                        /*
+                         * Our server thread just died.
+                         *
+                         * Release the client, if not active already...
+                         */
+                        System.err.println("Server died...");
+                        System.err.println(e);
+                        serverReady = true;
+                        serverException = e;
+                    }
+                }
+            };
+            serverThread.start();
+        } else {
+            doServerSide();
+        }
+    }
+
+    void startClient(boolean newThread) throws Exception {
+        if (newThread) {
+            clientThread = new Thread() {
+                public void run() {
+                    try {
+                        doClientSide();
+                    } catch (Exception e) {
+                        /*
+                         * Our client thread just died.
+                         */
+                        System.err.println("Client died...");
+                        clientException = e;
+                    }
+                }
+            };
+            clientThread.start();
+        } else {
+            doClientSide();
+        }
+    }
+}
diff a/test/jdk/tools/jpackage/apps/image/Hello.java b/test/jdk/tools/jpackage/apps/image/Hello.java
--- a/test/jdk/tools/jpackage/apps/image/Hello.java
+++ b/test/jdk/tools/jpackage/apps/image/Hello.java
@@ -48,10 +48,15 @@
             args = faFiles.toArray(String[]::new);
         }
 
         var lines = printArgs(args);
 
+        Stream.of(args).forEach(arg -> System.out.println(
+                arg.codePoints()
+                        .mapToObj(codePoint -> String.format("0x%04x", codePoint))
+                        .collect(Collectors.joining(",", "[", "]"))));
+
         lines.forEach(System.out::println);
 
         var outputFile = getOutputFile(args);
         trace(String.format("Output file: [%s]", outputFile));
         Files.write(outputFile, lines);
diff a/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/FileAssociations.java b/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/FileAssociations.java
--- a/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/FileAssociations.java
+++ b/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/FileAssociations.java
@@ -23,10 +23,11 @@
 package jdk.jpackage.test;
 
 import java.nio.file.Path;
 import java.util.HashMap;
 import java.util.Map;
+import jdk.incubator.jpackage.internal.IOUtils;
 
 
 final public class FileAssociations {
     public FileAssociations(String faSuffixName) {
         suffixName = faSuffixName;
@@ -63,10 +64,17 @@
     public FileAssociations setIcon(Path v) {
         icon = v;
         return this;
     }
 
+    Path getLinuxIconFileName() {
+        if (icon == null) {
+            return null;
+        }
+        return Path.of(getMime().replace('/', '-') + IOUtils.getSuffix(icon));
+    }
+
     Path getPropertiesFile() {
         return file;
     }
 
     String getSuffix() {
diff a/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/JPackageCommand.java b/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/JPackageCommand.java
--- a/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/JPackageCommand.java
+++ b/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/JPackageCommand.java
@@ -36,10 +36,11 @@
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+import jdk.incubator.jpackage.internal.AppImageFile;
 import jdk.incubator.jpackage.internal.ApplicationLayout;
 import jdk.jpackage.test.Functional.ThrowingConsumer;
 import jdk.jpackage.test.Functional.ThrowingFunction;
 import jdk.jpackage.test.Functional.ThrowingSupplier;
 
@@ -233,22 +234,20 @@
             TKit.trace(String.format("Init fake runtime in [%s] directory",
                     fakeRuntimeDir));
 
             Files.createDirectories(fakeRuntimeDir);
 
-            if (TKit.isWindows() || TKit.isLinux()) {
-                // Needed to make WindowsAppBundler happy as it copies MSVC dlls
-                // from `bin` directory.
+            if (TKit.isLinux()) {
                 // Need to make the code in rpm spec happy as it assumes there is
                 // always something in application image.
                 fakeRuntimeDir.resolve("bin").toFile().mkdir();
             }
 
             if (TKit.isOSX()) {
                 // Make MacAppImageBuilder happy
                 createBulkFile.accept(fakeRuntimeDir.resolve(Path.of(
-                        "Contents/Home/lib/jli/libjli.dylib")));
+                        "lib/jli/libjli.dylib")));
             }
 
             // Mak sure fake runtime takes some disk space.
             // Package bundles with 0KB size are unexpected and considered
             // an error by PackageTest.
@@ -678,17 +677,60 @@
         return result;
     }
 
     public JPackageCommand assertImageCreated() {
         verifyIsOfType(PackageType.IMAGE);
+        assertAppLayout();
+        return this;
+    }
+
+    JPackageCommand assertAppLayout() {
+        if (isPackageUnpacked() || isImagePackageType()) {
+            final Path rootDir = isPackageUnpacked() ? pathToUnpackedPackageFile(
+                    appInstallationDirectory()) : outputBundle();
+            final Path appImageFileName = AppImageFile.getPathInAppImage(
+                    Path.of("")).getFileName();
+            try (Stream<Path> walk = ThrowingSupplier.toSupplier(
+                    () -> Files.walk(rootDir)).get()) {
+                List<String> appImageFiles = walk
+                        .filter(path -> path.getFileName().equals(appImageFileName))
+                        .map(Path::toString)
+                        .collect(Collectors.toList());
+                if (isImagePackageType() || TKit.isOSX()) {
+                    List<String> expected = List.of(
+                            AppImageFile.getPathInAppImage(rootDir).toString());
+                    TKit.assertStringListEquals(expected, appImageFiles,
+                            String.format(
+                                    "Check there is only one file with [%s] name in the package",
+                                    appImageFileName));
+                } else {
+                    TKit.assertStringListEquals(List.of(), appImageFiles,
+                            String.format(
+                                    "Check there are no files with [%s] name in the package",
+                                    appImageFileName));
+                }
+            }
+        } else if (TKit.isOSX()) {
+            TKit.assertFileExists(AppImageFile.getPathInAppImage(
+                    appInstallationDirectory()));
+        } else {
+            TKit.assertPathExists(AppImageFile.getPathInAppImage(
+                    appInstallationDirectory()), false);
+        }
+
         TKit.assertDirectoryExists(appRuntimeDirectory());
 
         if (!isRuntime()) {
             TKit.assertExecutableFileExists(appLauncherPath());
             TKit.assertFileExists(appLauncherCfgPath(null));
         }
 
+        if (TKit.isOSX()) {
+            TKit.assertFileExists(appRuntimeDirectory().resolve(
+                    "Contents/MacOS/libjli.dylib"));
+        }
+
         return this;
     }
 
     JPackageCommand setUnpackedPackageLocation(Path path) {
         verifyIsOfType(PackageType.NATIVE);
@@ -783,18 +825,10 @@
             }
             return str;
         }).collect(Collectors.joining(" "));
     }
 
-    public static Path relativePathInRuntime(JavaTool tool) {
-        Path path = tool.relativePathInJavaHome();
-        if (TKit.isOSX()) {
-            path = Path.of("Contents/Home").resolve(path);
-        }
-        return path;
-    }
-
     public static Stream<String> filterOutput(Stream<String> jpackageOutput) {
         // Skip "WARNING: Using incubator ..." first line of output
         return jpackageOutput.skip(1);
     }
 
diff a/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/LinuxHelper.java b/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/LinuxHelper.java
--- a/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/LinuxHelper.java
+++ b/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/LinuxHelper.java
@@ -23,16 +23,27 @@
 package jdk.jpackage.test;
 
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
 import java.util.function.Function;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+import jdk.incubator.jpackage.internal.IOUtils;
 import jdk.jpackage.test.PackageTest.PackageHandlers;
 
+
+
 public class LinuxHelper {
     private static String getRelease(JPackageCommand cmd) {
         return cmd.getArgumentValue("--linux-app-release", () -> "1");
     }
 
@@ -278,31 +289,10 @@
 
     static void addBundleDesktopIntegrationVerifier(PackageTest test,
             boolean integrated) {
         final String xdgUtils = "xdg-utils";
 
-        test.addBundleVerifier(cmd -> {
-            List<String> prerequisites = getPrerequisitePackages(cmd);
-            boolean xdgUtilsFound = prerequisites.contains(xdgUtils);
-            if (integrated) {
-                TKit.assertTrue(xdgUtilsFound, String.format(
-                        "Check [%s] is in the list of required packages %s",
-                        xdgUtils, prerequisites));
-            } else {
-                TKit.assertFalse(xdgUtilsFound, String.format(
-                        "Check [%s] is NOT in the list of required packages %s",
-                        xdgUtils, prerequisites));
-            }
-        });
-
-        test.forTypes(PackageType.LINUX_DEB, () -> {
-            addDebBundleDesktopIntegrationVerifier(test, integrated);
-        });
-    }
-
-    private static void addDebBundleDesktopIntegrationVerifier(PackageTest test,
-            boolean integrated) {
         Function<List<String>, String> verifier = (lines) -> {
             // Lookup for xdg commands
             return lines.stream().filter(line -> {
                 Set<String> words = Stream.of(line.split("\\s+")).collect(
                         Collectors.toSet());
@@ -310,25 +300,33 @@
                         "xdg-mime") || words.contains("xdg-icon-resource");
             }).findFirst().orElse(null);
         };
 
         test.addBundleVerifier(cmd -> {
-            TKit.withTempDirectory("dpkg-control-files", tempDir -> {
-                // Extract control Debian package files into temporary directory
-                Executor.of("dpkg", "-e")
-                .addArgument(cmd.outputBundle())
-                .addArgument(tempDir)
-                .execute();
+            // Verify dependencies.
+            List<String> prerequisites = getPrerequisitePackages(cmd);
+            boolean xdgUtilsFound = prerequisites.contains(xdgUtils);
+            TKit.assertTrue(xdgUtilsFound == integrated, String.format(
+                    "Check [%s] is%s in the list of required packages %s",
+                    xdgUtils, integrated ? "" : " NOT", prerequisites));
 
-                Path controlFile = Path.of("postinst");
+            Map<Scriptlet, List<String>> scriptlets = getScriptlets(cmd);
+            if (integrated) {
+                Set<Scriptlet> requiredScriptlets = Stream.of(Scriptlet.values()).sorted().collect(
+                        Collectors.toSet());
+                TKit.assertTrue(scriptlets.keySet().containsAll(
+                        requiredScriptlets), String.format(
+                                "Check all required scriptlets %s found in the package. Package scriptlets: %s",
+                                requiredScriptlets, scriptlets.keySet()));
+            }
 
-                // Lookup for xdg commands in postinstall script
-                String lineWithXsdCommand = verifier.apply(
-                        Files.readAllLines(tempDir.resolve(controlFile)));
+            // Lookup for xdg commands in scriptlets.
+            scriptlets.entrySet().forEach(scriptlet -> {
+                String lineWithXsdCommand = verifier.apply(scriptlet.getValue());
                 String assertMsg = String.format(
-                        "Check if %s@%s control file uses xdg commands",
-                        cmd.outputBundle(), controlFile);
+                        "Check if [%s] scriptlet uses xdg commands",
+                        scriptlet.getKey());
                 if (integrated) {
                     TKit.assertNotNull(lineWithXsdCommand, assertMsg);
                 } else {
                     TKit.assertNull(lineWithXsdCommand, assertMsg);
                 }
@@ -409,10 +407,23 @@
                 TKit.assertNull(desktopFileName, String.format(
                         "Check there is no default handler for [%s] mime type",
                         fa.getMime()));
             });
         });
+
+        test.addBundleVerifier(cmd -> {
+            final Path mimeTypeIconFileName = fa.getLinuxIconFileName();
+            if (mimeTypeIconFileName != null) {
+                // Verify there are xdg registration commands for mime icon file.
+                Path mimeTypeIcon = cmd.appLayout().destktopIntegrationDirectory().resolve(
+                        mimeTypeIconFileName);
+
+                Map<Scriptlet, List<String>> scriptlets = getScriptlets(cmd);
+                scriptlets.entrySet().stream().forEach(e -> verifyIconInScriptlet(
+                        e.getKey(), e.getValue(), mimeTypeIcon));
+            }
+        });
     }
 
     private static String queryFileMimeType(Path file) {
         return Executor.of("xdg-mime", "query", "filetype").addArgument(file)
                 .executeAndGetFirstLineOfOutput();
@@ -421,10 +432,126 @@
     private static String queryMimeTypeDefaultHandler(String mimeType) {
         return Executor.of("xdg-mime", "query", "default", mimeType)
                 .executeAndGetFirstLineOfOutput();
     }
 
+    private static void verifyIconInScriptlet(Scriptlet scriptletType,
+            List<String> scriptletBody, Path iconPathInPackage) {
+        final String dashMime = IOUtils.replaceSuffix(
+                iconPathInPackage.getFileName(), null).toString();
+        final String xdgCmdName = "xdg-icon-resource";
+
+        Stream<String> scriptletBodyStream = scriptletBody.stream()
+                .filter(str -> str.startsWith(xdgCmdName))
+                .filter(str -> Pattern.compile(
+                        "\\b" + dashMime + "\\b").matcher(str).find());
+        if (scriptletType == Scriptlet.PostInstall) {
+            scriptletBodyStream = scriptletBodyStream.filter(str -> List.of(
+                    str.split("\\s+")).contains(iconPathInPackage.toString()));
+        }
+
+        scriptletBodyStream.peek(xdgCmd -> {
+            Matcher m = XDG_CMD_ICON_SIZE_PATTERN.matcher(xdgCmd);
+            TKit.assertTrue(m.find(), String.format(
+                    "Check icon size is specified as a number in [%s] xdg command of [%s] scriptlet",
+                    xdgCmd, scriptletType));
+            int iconSize = Integer.parseInt(m.group(1));
+            TKit.assertTrue(XDG_CMD_VALID_ICON_SIZES.contains(iconSize),
+                    String.format(
+                            "Check icon size [%s] is one of %s values",
+                            iconSize, XDG_CMD_VALID_ICON_SIZES));
+        })
+        .findFirst().orElseGet(() -> {
+            TKit.assertUnexpected(String.format(
+                    "Failed to find [%s] command in [%s] scriptlet for [%s] icon file",
+                    xdgCmdName, scriptletType, iconPathInPackage));
+            return null;
+        });
+    }
+
+    private static Map<Scriptlet, List<String>> getScriptlets(
+            JPackageCommand cmd, Scriptlet... scriptlets) {
+        cmd.verifyIsOfType(PackageType.LINUX);
+
+        Set<Scriptlet> scriptletSet = Set.of(
+                scriptlets.length == 0 ? Scriptlet.values() : scriptlets);
+        switch (cmd.packageType()) {
+            case LINUX_DEB:
+                return getDebScriptlets(cmd, scriptletSet);
+
+            case LINUX_RPM:
+                return getRpmScriptlets(cmd, scriptletSet);
+        }
+
+        // Unreachable
+        return null;
+    }
+
+    private static Map<Scriptlet, List<String>> getDebScriptlets(
+            JPackageCommand cmd, Set<Scriptlet> scriptlets) {
+        Map<Scriptlet, List<String>> result = new HashMap<>();
+        TKit.withTempDirectory("dpkg-control-files", tempDir -> {
+            // Extract control Debian package files into temporary directory
+            Executor.of("dpkg", "-e")
+                    .addArgument(cmd.outputBundle())
+                    .addArgument(tempDir)
+                    .execute();
+
+            for (Scriptlet scriptlet : scriptlets) {
+                Path controlFile = Path.of(scriptlet.deb);
+                result.put(scriptlet, Files.readAllLines(tempDir.resolve(
+                        controlFile)));
+            }
+        });
+        return result;
+    }
+
+    private static Map<Scriptlet, List<String>> getRpmScriptlets(
+            JPackageCommand cmd, Set<Scriptlet> scriptlets) {
+        List<String> output = Executor.of("rpm", "-qp", "--scripts",
+                cmd.outputBundle().toString()).executeAndGetOutput();
+
+        Map<Scriptlet, List<String>> result = new HashMap<>();
+        List<String> curScriptletBody = null;
+        for (String str : output) {
+            Matcher m = Scriptlet.RPM_HEADER_PATTERN.matcher(str);
+            if (m.find()) {
+                Scriptlet scriptlet = Scriptlet.RPM_MAP.get(m.group(1));
+                if (scriptlets.contains(scriptlet)) {
+                    curScriptletBody = new ArrayList<>();
+                    result.put(scriptlet, curScriptletBody);
+                } else if (curScriptletBody != null) {
+                    curScriptletBody = null;
+                }
+            } else if (curScriptletBody != null) {
+                curScriptletBody.add(str);
+            }
+        }
+
+        return result;
+    }
+
+    private static enum Scriptlet {
+        PostInstall("postinstall", "postinst"),
+        PreUninstall("preuninstall", "prerm");
+
+        Scriptlet(String rpm, String deb) {
+            this.rpm = rpm;
+            this.deb = deb;
+        }
+
+        private final String rpm;
+        private final String deb;
+
+        static final Pattern RPM_HEADER_PATTERN = Pattern.compile(String.format(
+                "(%s) scriptlet \\(using /bin/sh\\):", Stream.of(values()).map(
+                        v -> v.rpm).collect(Collectors.joining("|"))));
+
+        static final Map<String, Scriptlet> RPM_MAP = Stream.of(values()).collect(
+                Collectors.toMap(v -> v.rpm, v -> v));
+    };
+
     public static String getDefaultPackageArch(PackageType type) {
         if (archs == null) {
             archs = new HashMap<>();
         }
 
@@ -447,7 +574,12 @@
     }
 
     static final Set<Path> CRITICAL_RUNTIME_FILES = Set.of(Path.of(
             "lib/server/libjvm.so"));
 
-    static private Map<PackageType, String> archs;
+    private static Map<PackageType, String> archs;
+
+    private final static Pattern XDG_CMD_ICON_SIZE_PATTERN = Pattern.compile("\\s--size\\s+(\\d+)\\b");
+
+    // Values grabbed from https://linux.die.net/man/1/xdg-icon-resource
+    private final static Set<Integer> XDG_CMD_VALID_ICON_SIZES = Set.of(16, 22, 32, 48, 64, 128);
 }
diff a/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/PackageTest.java b/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/PackageTest.java
--- a/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/PackageTest.java
+++ b/test/jdk/tools/jpackage/helpers/jdk/jpackage/test/PackageTest.java
@@ -237,10 +237,14 @@
 
         // Setup test app to have valid jpackage command line before
         // running check of type of environment.
         addHelloAppInitializer(null);
 
+        forTypes(PackageType.LINUX, () -> {
+            LinuxHelper.addFileAssociationsVerifier(this, fa);
+        });
+
         String noActionMsg = "Not running file associations test";
         if (GraphicsEnvironment.isHeadless()) {
             TKit.trace(String.format(
                     "%s because running in headless environment", noActionMsg));
             return this;
@@ -273,14 +277,10 @@
                 HelloApp.verifyOutputFile(appOutput, expectedArgs,
                         Collections.emptyMap());
             });
         });
 
-        forTypes(PackageType.LINUX, () -> {
-            LinuxHelper.addFileAssociationsVerifier(this, fa);
-        });
-
         return this;
     }
 
     public PackageTest forTypes(Collection<PackageType> types, Runnable action) {
         Set<PackageType> oldTypes = Set.of(currentTypes.toArray(
@@ -551,34 +551,18 @@
             } else {
                 formatString = "Verify installed: %s";
             }
             TKit.trace(String.format(formatString, cmd.getPrintableCommandLine()));
 
-            TKit.assertDirectoryExists(cmd.appRuntimeDirectory());
             if (!cmd.isRuntime()) {
-                TKit.assertExecutableFileExists(cmd.appLauncherPath());
-
                 if (PackageType.WINDOWS.contains(cmd.packageType())
                         && !cmd.isPackageUnpacked(
                                 "Not verifying desktop integration")) {
                     new WindowsHelper.DesktopIntegrationVerifier(cmd);
                 }
             }
-
-            if (cmd.isPackageUnpacked()) {
-                final Path appImageFile = AppImageFile.getPathInAppImage(
-                        Path.of(""));
-                try (Stream<Path> walk = ThrowingSupplier.toSupplier(
-                        () -> Files.walk(cmd.unpackedPackageDirectory())).get()) {
-                    walk.filter(path -> path.getFileName().equals(appImageFile))
-                        .findFirst()
-                        .ifPresent(path -> TKit.assertPathExists(path, false));
-                }
-            } else {
-                TKit.assertPathExists(AppImageFile.getPathInAppImage(
-                        cmd.appInstallationDirectory()), false);
-            }
+            cmd.assertAppLayout();
 
             installVerifiers.forEach(v -> v.accept(cmd));
         }
 
         private void verifyPackageUninstalled(JPackageCommand cmd) {
diff a/test/jdk/tools/jpackage/share/AddLauncherTest.java b/test/jdk/tools/jpackage/share/AddLauncherTest.java
--- a/test/jdk/tools/jpackage/share/AddLauncherTest.java
+++ b/test/jdk/tools/jpackage/share/AddLauncherTest.java
@@ -175,10 +175,11 @@
             cmd.addArguments("--description",
                     "Test non modular app with multiple add-launchers where one is modular app and other is non modular app");
             cmd.addArguments("--module-path", modularJarCmd.getArgumentValue(
                     "--module-path"));
             cmd.addArguments("--add-modules", modularAppDesc.moduleName());
+            cmd.ignoreDefaultRuntime(true); // because of --add-modules
         }
 
         new AdditionalLauncher("ModularAppLauncher")
         .addRawProperties(Map.entry("module", JavaAppDesc.parse(
                 modularAppDesc.toString()).setBundleFileName(null).toString()))
diff a/test/jdk/tools/jpackage/share/EmptyFolderPackageTest.java b/test/jdk/tools/jpackage/share/EmptyFolderPackageTest.java
--- a/test/jdk/tools/jpackage/share/EmptyFolderPackageTest.java
+++ b/test/jdk/tools/jpackage/share/EmptyFolderPackageTest.java
@@ -22,10 +22,11 @@
  */
 
 import java.nio.file.Path;
 import jdk.incubator.jpackage.internal.ApplicationLayout;
 import jdk.jpackage.test.PackageTest;
+import jdk.jpackage.test.PackageType;
 import jdk.jpackage.test.TKit;
 
 /**
  * Tests generation of packages with input folder containing empty folders.
  */
@@ -49,10 +50,17 @@
                     .addInitializer(cmd -> {
                         Path input = cmd.inputDir();
                         EmptyFolderBase.createDirStrcture(input);
                     })
                     .addInstallVerifier(cmd -> {
+                        if (cmd.packageType() == PackageType.WIN_MSI) {
+                            if (cmd.isPackageUnpacked("Not running file "
+                                    + "structure check for empty folders")) {
+                                return;
+                            }
+                        }
+
                         ApplicationLayout appLayout = cmd.appLayout();
                         Path appDir = appLayout.appDirectory();
                         EmptyFolderBase.validateDirStrcture(appDir);
                     })
                     .run();
diff a/test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java b/test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java
--- a/test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java
+++ b/test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java
@@ -225,11 +225,12 @@
     @Parameter("java.desktop")
     @Parameter("java.desktop,jdk.jartool")
     @Parameter({ "java.desktop", "jdk.jartool" })
     public void testAddModules(String... addModulesArg) {
         JPackageCommand cmd = JPackageCommand
-                .helloAppImage("goodbye.jar:com.other/com.other.Hello");
+                .helloAppImage("goodbye.jar:com.other/com.other.Hello")
+                .ignoreDefaultRuntime(true); // because of --add-modules
         Stream.of(addModulesArg).map(v -> Stream.of("--add-modules", v)).flatMap(
                 s -> s).forEachOrdered(cmd::addArgument);
         cmd.executeAndAssertHelloAppImageCreated();
     }
 
@@ -268,14 +269,10 @@
                             tempDir));
         })
         .run(PackageTest.Action.CREATE);
 
         createTest.get()
-        .addInitializer(cmd -> {
-            // Clean output from the previus jpackage run.
-            Files.delete(cmd.outputBundle());
-        })
         // Temporary directory should not be empty,
         // jpackage should exit with error.
         .setExpectedExitCode(1)
         .run(PackageTest.Action.CREATE);
     }
@@ -336,10 +333,19 @@
                 "--output", runtimeDir.toString(),
                 "--strip-debug",
                 "--no-header-files",
                 "--no-man-pages");
 
+        TKit.trace("jlink output BEGIN");
+        try (Stream<Path> paths = Files.walk(runtimeDir)) {
+            paths.filter(Files::isRegularFile)
+                    .map(runtimeDir::relativize)
+                    .map(Path::toString)
+                    .forEach(TKit::trace);
+        }
+        TKit.trace("jlink output END");
+
         if (moduleName != null) {
             jlink.addArguments("--add-modules", moduleName, "--module-path",
                     Path.of(cmd.getArgumentValue("--module-path")).resolve(
                             "hello.jar").toString());
         }
diff a/test/jdk/tools/jpackage/share/jdk/jpackage/tests/UnicodeArgsTest.java b/test/jdk/tools/jpackage/share/jdk/jpackage/tests/UnicodeArgsTest.java
--- /dev/null
+++ b/test/jdk/tools/jpackage/share/jdk/jpackage/tests/UnicodeArgsTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.jpackage.tests;
+
+import java.util.stream.Collectors;
+import jdk.jpackage.test.TKit;
+import jdk.jpackage.test.Annotations.Test;
+import jdk.jpackage.test.Annotations.Parameter;
+import jdk.jpackage.test.HelloApp;
+import jdk.jpackage.test.JPackageCommand;
+
+/*
+ * @test
+ * @summary test how app launcher handles unicode command line arguments
+ * @library ../../../../helpers
+ * @build jdk.jpackage.test.*
+ * @modules jdk.incubator.jpackage/jdk.incubator.jpackage.internal
+ * @compile UnicodeArgsTest.java
+ * @requires (os.family == "windows")
+ * @run main/othervm/timeout=720 -Xmx512m jdk.jpackage.test.Main
+ *  --jpt-run=jdk.jpackage.tests.UnicodeArgsTest
+ */
+
+public final class UnicodeArgsTest {
+
+    @Parameter("true")
+    @Parameter("false")
+    @Test
+    public void test8246042(boolean onCommandLine) {
+        final String testString = new String(Character.toChars(0x00E9));
+
+        TKit.trace(String.format("Test string code points: %s", testString
+                .codePoints()
+                .mapToObj(codePoint -> String.format("0x%04x", codePoint))
+                .collect(Collectors.joining(",", "[", "]"))));
+
+        JPackageCommand cmd = JPackageCommand.helloAppImage().useToolProvider(true);
+        if (!onCommandLine) {
+            cmd.addArguments("--arguments", testString);
+        }
+        cmd.executeAndAssertImageCreated();
+
+        if (onCommandLine) {
+            HelloApp.executeLauncherAndVerifyOutput(cmd, testString);
+        } else {
+            HelloApp.executeLauncherAndVerifyOutput(cmd);
+        }
+    }
+}
diff a/test/langtools/jdk/javadoc/doclet/testWarnings/TestWarnings.java b/test/langtools/jdk/javadoc/doclet/testWarnings/TestWarnings.java
--- a/test/langtools/jdk/javadoc/doclet/testWarnings/TestWarnings.java
+++ b/test/langtools/jdk/javadoc/doclet/testWarnings/TestWarnings.java
@@ -21,11 +21,11 @@
  * questions.
  */
 
 /*
  * @test
- * @bug      4515705 4804296 4702454 4697036 8025633 8182765
+ * @bug      4515705 4804296 4702454 4697036 8025633 8182765 8247235
  * @summary  Make sure that first sentence warning only appears once.
  *           Make sure that only warnings/errors are printed when quiet is used.
  *           Make sure that links to private/unincluded methods do not cause
  *           a "link unresolved" warning.
  *           Make sure error message starts with "error -".
@@ -48,22 +48,28 @@
         javadoc("-d", "out-default",
                 "-sourcepath", testSrc,
                 "pkg");
         checkExit(Exit.ERROR);
 
-        checkOutput(Output.OUT, true,
+        checkOutput(Output.OUT, false,
                 "X.java:23: error: self-closing element not allowed");
 
-        checkOutput(Output.OUT, true,
+        checkOutput(Output.OUT, false,
                 "X.java:24: error: self-closing element not allowed");
 
-        checkOutput(Output.OUT, true,
+        checkOutput(Output.OUT, false,
                 "X.java:25: error: self-closing element not allowed");
 
-        checkOutput(Output.OUT, true,
+        checkOutput(Output.OUT, false,
                 "X.java:26: error: self-closing element not allowed");
 
+        checkOutput(Output.OUT, true,
+                "X.java:28: error: self-closing element not allowed");
+
+        checkOutput(Output.OUT, true,
+                "X.java:28: warning: empty <p> tag");
+
         checkOutput("pkg/X.html", false,
                 "can't find m()");
         checkOutput("pkg/X.html", false,
                 "can't find X()");
         checkOutput("pkg/X.html", false,
diff a/test/langtools/jdk/javadoc/doclet/testWarnings/pkg/X.java b/test/langtools/jdk/javadoc/doclet/testWarnings/pkg/X.java
--- a/test/langtools/jdk/javadoc/doclet/testWarnings/pkg/X.java
+++ b/test/langtools/jdk/javadoc/doclet/testWarnings/pkg/X.java
@@ -22,8 +22,10 @@
     /**
      * {@link #X()}<br/>
      * {@link #m()}<br/>
      * {@link #f}<br/>
      * {@link java.lang.String#toString()}<br/>
+     * <hr/>
+     * <p/>
      */
     public void foo() {}
 }
diff a/test/langtools/tools/javac/api/T6395981.java b/test/langtools/tools/javac/api/T6395981.java
--- a/test/langtools/tools/javac/api/T6395981.java
+++ b/test/langtools/tools/javac/api/T6395981.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,19 +21,22 @@
  * questions.
  */
 
 /*
  * @test
- * @bug     6395981 6458819 7025784 8028543 8028544 8193291 8193292 8193292 8205393
+ * @bug     6395981 6458819 7025784 8028543 8028544 8193291 8193292 8193292 8205393 8245585 8245585
  * @summary JavaCompilerTool and Tool must specify version of JLS and JVMS
  * @author  Peter von der Ah\u00e9
  * @modules java.compiler
  *          jdk.compiler
  * @run main/fail T6395981
- * @run main/fail T6395981 RELEASE_3 RELEASE_5 RELEASE_6
- * @run main/fail T6395981 RELEASE_0 RELEASE_1 RELEASE_2 RELEASE_3 RELEASE_4 RELEASE_5 RELEASE_6
- * @run main T6395981 RELEASE_3 RELEASE_4 RELEASE_5 RELEASE_6 RELEASE_7 RELEASE_8 RELEASE_9 RELEASE_10 RELEASE_11 RELEASE_12 RELEASE_13 RELEASE_14 RELEASE_15
+ * @run main/fail T6395981 RELEASE_3  RELEASE_5  RELEASE_6
+ * @run main/fail T6395981 RELEASE_0  RELEASE_1  RELEASE_2  RELEASE_3  RELEASE_4
+ *                         RELEASE_5  RELEASE_6
+ * @run main T6395981      RELEASE_3  RELEASE_4  RELEASE_5  RELEASE_6  RELEASE_7
+ *                         RELEASE_8  RELEASE_9  RELEASE_10 RELEASE_11 RELEASE_12
+ *                         RELEASE_13 RELEASE_14 RELEASE_15 RELEASE_16
  */
 
 import java.util.EnumSet;
 import java.util.Set;
 import javax.lang.model.SourceVersion;
diff a/test/langtools/tools/javac/classfiles/ClassVersionChecker.java b/test/langtools/tools/javac/classfiles/ClassVersionChecker.java
--- a/test/langtools/tools/javac/classfiles/ClassVersionChecker.java
+++ b/test/langtools/tools/javac/classfiles/ClassVersionChecker.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,11 +21,11 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 7157626 8001112 8188870 8173382 8193290 8205619
+ * @bug 7157626 8001112 8188870 8173382 8193290 8205619 8245586
  * @summary Test major version for all legal combinations for -source and -target
  * @author sgoel
  *
  * @modules jdk.compiler
  */
@@ -48,11 +48,12 @@
         TEN("10", 54),
         ELEVEN("11", 55),
         TWELVE("12", 56),
         THIRTEEN("13", 57),
         FOURTEEN("14", 58),
-        FIFTEEN("15", 59);
+        FIFTEEN("15", 59),
+        SIXTEEN("16", 60);
 
         private Version(String release, int classFileVer) {
             this.release = release;
             this.classFileVer = classFileVer;
         }
diff a/test/langtools/tools/javac/lib/JavacTestingAbstractProcessor.java b/test/langtools/tools/javac/lib/JavacTestingAbstractProcessor.java
--- a/test/langtools/tools/javac/lib/JavacTestingAbstractProcessor.java
+++ b/test/langtools/tools/javac/lib/JavacTestingAbstractProcessor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -108,42 +108,42 @@
     /*
      * The set of visitors below will directly extend the most recent
      * corresponding platform visitor type.
      */
 
-    @SupportedSourceVersion(RELEASE_15)
+    @SupportedSourceVersion(RELEASE_16)
     public static abstract class AbstractAnnotationValueVisitor<R, P> extends AbstractAnnotationValueVisitor14<R, P> {
 
         /**
          * Constructor for concrete subclasses to call.
          */
         protected AbstractAnnotationValueVisitor() {
             super();
         }
     }
 
-    @SupportedSourceVersion(RELEASE_15)
+    @SupportedSourceVersion(RELEASE_16)
     public static abstract class AbstractElementVisitor<R, P> extends AbstractElementVisitor14<R, P> {
         /**
          * Constructor for concrete subclasses to call.
          */
         protected AbstractElementVisitor(){
             super();
         }
     }
 
-    @SupportedSourceVersion(RELEASE_15)
+    @SupportedSourceVersion(RELEASE_16)
     public static abstract class AbstractTypeVisitor<R, P> extends AbstractTypeVisitor14<R, P> {
         /**
          * Constructor for concrete subclasses to call.
          */
         protected AbstractTypeVisitor() {
             super();
         }
     }
 
-    @SupportedSourceVersion(RELEASE_14)
+    @SupportedSourceVersion(RELEASE_16)
     public static class ElementKindVisitor<R, P> extends ElementKindVisitor14<R, P> {
         /**
          * Constructor for concrete subclasses; uses {@code null} for the
          * default value.
          */
@@ -160,11 +160,11 @@
         protected ElementKindVisitor(R defaultValue) {
             super(defaultValue);
         }
     }
 
-    @SupportedSourceVersion(RELEASE_15)
+    @SupportedSourceVersion(RELEASE_16)
     public static class ElementScanner<R, P> extends ElementScanner14<R, P> {
         /**
          * Constructor for concrete subclasses; uses {@code null} for the
          * default value.
          */
@@ -179,11 +179,11 @@
         protected ElementScanner(R defaultValue){
             super(defaultValue);
         }
     }
 
-    @SupportedSourceVersion(RELEASE_15)
+    @SupportedSourceVersion(RELEASE_16)
     public static class SimpleAnnotationValueVisitor<R, P> extends SimpleAnnotationValueVisitor14<R, P> {
         /**
          * Constructor for concrete subclasses; uses {@code null} for the
          * default value.
          */
@@ -200,11 +200,11 @@
         protected SimpleAnnotationValueVisitor(R defaultValue) {
             super(defaultValue);
         }
     }
 
-    @SupportedSourceVersion(RELEASE_15)
+    @SupportedSourceVersion(RELEASE_16)
     public static class SimpleElementVisitor<R, P> extends SimpleElementVisitor14<R, P> {
         /**
          * Constructor for concrete subclasses; uses {@code null} for the
          * default value.
          */
@@ -221,11 +221,11 @@
         protected SimpleElementVisitor(R defaultValue){
             super(defaultValue);
         }
     }
 
-    @SupportedSourceVersion(RELEASE_15)
+    @SupportedSourceVersion(RELEASE_16)
     public static class SimpleTypeVisitor<R, P> extends SimpleTypeVisitor14<R, P> {
         /**
          * Constructor for concrete subclasses; uses {@code null} for the
          * default value.
          */
@@ -242,11 +242,11 @@
         protected SimpleTypeVisitor(R defaultValue){
             super(defaultValue);
         }
     }
 
-    @SupportedSourceVersion(RELEASE_15)
+    @SupportedSourceVersion(RELEASE_16)
     public static class TypeKindVisitor<R, P> extends TypeKindVisitor14<R, P> {
         /**
          * Constructor for concrete subclasses to call; uses {@code null}
          * for the default value.
          */
diff a/test/langtools/tools/javac/preview/classReaderTest/Client.nopreview.out b/test/langtools/tools/javac/preview/classReaderTest/Client.nopreview.out
--- a/test/langtools/tools/javac/preview/classReaderTest/Client.nopreview.out
+++ b/test/langtools/tools/javac/preview/classReaderTest/Client.nopreview.out
@@ -1,2 +1,2 @@
-- compiler.err.preview.feature.disabled.classfile: Bar.class, 15
+- compiler.err.preview.feature.disabled.classfile: Bar.class, 16
 1 error
diff a/test/langtools/tools/javac/preview/classReaderTest/Client.preview.out b/test/langtools/tools/javac/preview/classReaderTest/Client.preview.out
--- a/test/langtools/tools/javac/preview/classReaderTest/Client.preview.out
+++ b/test/langtools/tools/javac/preview/classReaderTest/Client.preview.out
@@ -1,4 +1,4 @@
-- compiler.warn.preview.feature.use.classfile: Bar.class, 15
+- compiler.warn.preview.feature.use.classfile: Bar.class, 16
 - compiler.err.warnings.and.werror
 1 error
 1 warning
diff a/test/langtools/tools/javac/valhalla/lworld-values/CheckFeatureGate1.out b/test/langtools/tools/javac/valhalla/lworld-values/CheckFeatureGate1.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/CheckFeatureGate1.out
+++ b/test/langtools/tools/javac/valhalla/lworld-values/CheckFeatureGate1.out
@@ -1,2 +1,2 @@
-CheckFeatureGate1.java:10:12: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.inline.type), 13, 15
+CheckFeatureGate1.java:10:12: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.inline.type), 13, 16
 1 error
diff a/test/langtools/tools/javac/valhalla/lworld-values/CheckFeatureGate2.out b/test/langtools/tools/javac/valhalla/lworld-values/CheckFeatureGate2.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/CheckFeatureGate2.out
+++ b/test/langtools/tools/javac/valhalla/lworld-values/CheckFeatureGate2.out
@@ -1,2 +1,2 @@
-CheckFeatureGate2.java:11:17: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.inline.type), 13, 15
+CheckFeatureGate2.java:11:17: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.inline.type), 13, 16
 1 error
diff a/test/langtools/tools/javac/versions/Versions.java b/test/langtools/tools/javac/versions/Versions.java
--- a/test/langtools/tools/javac/versions/Versions.java
+++ b/test/langtools/tools/javac/versions/Versions.java
@@ -21,11 +21,11 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 4981566 5028634 5094412 6304984 7025786 7025789 8001112 8028545 8000961 8030610 8028546 8188870 8173382 8173382 8193290 8205619 8028563 8245147
+ * @bug 4981566 5028634 5094412 6304984 7025786 7025789 8001112 8028545 8000961 8030610 8028546 8188870 8173382 8173382 8193290 8205619 8028563 8245147 8245586
  * @summary Check interpretation of -target and -source options
  * @modules java.compiler
  *          jdk.compiler
  * @run main Versions
  */
@@ -68,24 +68,25 @@
 
     public static final Set<String> RETIRED_SOURCES =
         Set.of("1.2", "1.3", "1.4", "1.5", "1.6");
 
     public static final Set<String> VALID_SOURCES =
-        Set.of("1.7", "1.8", "1.9", "1.10", "11", "12", "13", "14", "15");
+        Set.of("1.7", "1.8", "1.9", "1.10", "11", "12", "13", "14", "15", "16");
 
-    public static final String LATEST_MAJOR_VERSION = "59.0";
+    public static final String LATEST_MAJOR_VERSION = "60.0";
 
     static enum SourceTarget {
         SEVEN(true,   "51.0",  "7", Versions::checksrc7),
         EIGHT(true,   "52.0",  "8", Versions::checksrc8),
         NINE(true,    "53.0",  "9", Versions::checksrc9),
         TEN(true,     "54.0", "10", Versions::checksrc10),
         ELEVEN(false, "55.0", "11", Versions::checksrc11),
         TWELVE(false, "56.0", "12", Versions::checksrc12),
         THIRTEEN(false, "57.0", "13", Versions::checksrc13),
         FOURTEEN(false, "58.0", "14", Versions::checksrc14),
-        FIFTEEN(false,  "59.0", "15", Versions::checksrc15);
+        FIFTEEN(false,  "59.0", "15", Versions::checksrc15),
+        SIXTEEN(false,  "60.0", "16", Versions::checksrc16);
 
         private final boolean dotOne;
         private final String classFileVer;
         private final String target;
         private final BiConsumer<Versions, List<String>> checker;
@@ -288,10 +289,17 @@
         expectedFail(args, List.of("New15.java"));
     }
 
    protected void checksrc15(List<String> args) {
        printargs("checksrc15", args);
+       expectedPass(args, List.of("New7.java", "New8.java", "New10.java", "New11.java",
+                                  "New14.java", "New15.java"));
+       // Add expectedFail after new language features added in a later release.
+    }
+
+   protected void checksrc16(List<String> args) {
+       printargs("checksrc16", args);
        expectedPass(args, List.of("New7.java", "New8.java", "New10.java", "New11.java",
                                   "New14.java", "New15.java"));
        // Add expectedFail after new language features added in a later release.
     }
 
diff a/test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java b/test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java
--- a/test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java
+++ b/test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java
@@ -75,14 +75,13 @@
 
     @DataProvider(name = "BuiltinParams")
     Object[][] builtinParams() {
         return new Object[][]{
                 {"minimal", "", "%02x", 16, "", 64, HexPrinter.Formatters.NONE, ""},
-                {"canonical", "%08x  ", "%02x ", 16, "|", 31, HexPrinter.Formatters.ASCII, "|\n"},
-                {"simple", "%5d: ", "%02x ", 16, " // ", 64, HexPrinter.Formatters.PRINTABLE, "\n"},
-                {"source", "    ", "(byte)%3d, ", 8, " // ", 64, HexPrinter.Formatters.PRINTABLE,
-                        "\n"},
+                {"canonical", "%08x  ", "%02x ", 16, "|", 31, HexPrinter.Formatters.PRINTABLE, "|\n"},
+                {"simple", "%5d: ", "%02x ", 16, " // ", 64, HexPrinter.Formatters.ASCII, "\n"},
+                {"source", "    ", "(byte)%3d, ", 8, " // ", 64, HexPrinter.Formatters.PRINTABLE, "\n"},
         };
     }
 
     @Test(dataProvider = "BuiltinParams")
     public void testBuiltins(String name, String offsetFormat, String binFormat, int colWidth,
@@ -160,10 +159,56 @@
                 ndx = out.indexOf(lineSep, ndx) + lineSep.length();
             }
         }
     }
 
+    @Test
+    static void testPrintable() {
+        String expected =
+                "................................" +
+                " !\"#$%&'()*+,-./0123456789:;<=>?" +
+                "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_" +
+                "`abcdefghijklmnopqrstuvwxyz{|}~." +
+                "................................" +
+                "................................" +
+                "................................" +
+                "................................";
+        byte[] bytes = new byte[256];
+        for (int i = 0; i < bytes.length; i++)
+            bytes[i] = (byte)i;
+        HexPrinter p = HexPrinter.minimal()
+                        .withBytesFormat("", 256)
+                        .formatter(HexPrinter.Formatters.PRINTABLE, "", 512);
+        String actual = p.toString(bytes);
+        Assert.assertEquals(actual, expected, "Formatters.Printable mismatch");
+    }
+
+    @Test
+    static void testASCII() {
+        String expected = "\\nul\\soh\\stx\\etx\\eot\\enq\\ack\\bel\\b\\t\\n\\vt\\f\\r\\so\\si\\dle" +
+                "\\dc1\\dc2\\dc3\\dc4\\nak\\syn\\etb\\can\\em\\sub\\esc\\fs\\gs\\rs\\us" +
+                " !\"#$%&'()*+,-./0123456789:;<=>?" +
+                "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_" +
+                "`abcdefghijklmnopqrstuvwxyz{|}~\\127" +
+                "\\128\\129\\130\\131\\132\\133\\134\\135\\136\\137\\138\\139\\140\\141\\142\\143" +
+                "\\144\\145\\146\\147\\148\\149\\150\\151\\152\\153\\154\\155\\156\\157\\158\\159" +
+                "\\160\\161\\162\\163\\164\\165\\166\\167\\168\\169\\170\\171\\172\\173\\174\\175" +
+                "\\176\\177\\178\\179\\180\\181\\182\\183\\184\\185\\186\\187\\188\\189\\190\\191" +
+                "\\192\\193\\194\\195\\196\\197\\198\\199\\200\\201\\202\\203\\204\\205\\206\\207" +
+                "\\208\\209\\210\\211\\212\\213\\214\\215\\216\\217\\218\\219\\220\\221\\222\\223" +
+                "\\224\\225\\226\\227\\228\\229\\230\\231\\232\\233\\234\\235\\236\\237\\238\\239" +
+                "\\240\\241\\242\\243\\244\\245\\246\\247\\248\\249\\250\\251\\252\\253\\254\\255";
+        byte[] bytes = new byte[256];
+        for (int i = 0; i < bytes.length; i++)
+            bytes[i] = (byte)i;
+        HexPrinter p = HexPrinter.minimal()
+                        .withBytesFormat("", 256)
+                        .formatter(HexPrinter.Formatters.ASCII, "", 256);
+        String actual = p.toString(bytes);
+        Assert.assertEquals(actual, expected, "Formatters.ASCII mismatch");
+    }
+
     @DataProvider(name = "PrimitiveFormatters")
     Object[][] formatterParams() {
         return new Object[][]{
                 {byte.class, ""},
                 {byte.class, "%02x: "},
@@ -250,10 +295,17 @@
                 {genBytes(21), 0, -1},
                 {genBytes(21), 5, 12},
         };
     }
 
+    @DataProvider(name = "badsources")
+    Object[][] badSources() {
+        return new Object[][]{
+                {genBytes(21), 5, 22},
+        };
+    }
+
     public static byte[] genData(int len) {
         // Create a byte array with data for two lines
         byte[] bytes = new byte[len];
         for (int i = 0; i < len / 2; i++) {
             bytes[i] = (byte) (i + 'A');
@@ -310,10 +362,30 @@
         String r = p.toString(bytes);
         Assert.assertEquals(r.length(), bytes.length * 2, "encoded byte wrong size");
         Assert.assertEquals(r.replace("00", "").length(), 0, "contents not all zeros");
     }
 
+    @Test(dataProvider = "badsources",
+            expectedExceptions = java.lang.IndexOutOfBoundsException.class)
+    public void testBadToStringByteBuffer(byte[] bytes, int offset, int length) {
+        if (length < 0)
+            length = bytes.length - offset;
+        ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);
+        System.out.printf("Source: %s, off: %d, len: %d%n",
+                bytes.getClass().getName(), offset, length);
+        String actual;
+        if (offset == 0 && length < 0) {
+            bb.position(offset);
+            bb.limit(length);
+            actual = HexPrinter.simple().toString(bb);
+        } else
+            actual = HexPrinter.simple().toString(bb, offset, length);
+        System.out.println(actual);
+        String expected = HexPrinter.simple().toString(bytes, offset, length);
+        Assert.assertEquals(actual, expected, "mismatch in format()");
+    }
+
     @Test(dataProvider = "sources")
     public void testToStringByteBuffer(byte[] bytes, int offset, int length) {
         if (length < 0)
             length = bytes.length - offset;
         ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);
diff a/test/lib/jdk/test/lib/Platform.java b/test/lib/jdk/test/lib/Platform.java
--- a/test/lib/jdk/test/lib/Platform.java
+++ b/test/lib/jdk/test/lib/Platform.java
@@ -21,13 +21,13 @@
  * questions.
  */
 
 package jdk.test.lib;
 
-import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.concurrent.TimeUnit;
@@ -237,11 +237,11 @@
 
         // Find the path to the java binary.
         String jdkPath = System.getProperty("java.home");
         Path javaPath = Paths.get(jdkPath + "/bin/java");
         String javaFileName = javaPath.toAbsolutePath().toString();
-        if (!javaPath.toFile().exists()) {
+        if (Files.notExists(javaPath)) {
             throw new FileNotFoundException("Could not find file " + javaFileName);
         }
 
         // Run codesign on the java binary.
         ProcessBuilder pb = new ProcessBuilder("codesign", "-d", "-v", javaFileName);
diff a/test/lib/jdk/test/lib/SA/SATestUtils.java b/test/lib/jdk/test/lib/SA/SATestUtils.java
--- a/test/lib/jdk/test/lib/SA/SATestUtils.java
+++ b/test/lib/jdk/test/lib/SA/SATestUtils.java
@@ -20,32 +20,27 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.test.lib.SA;
 
+import jdk.test.lib.JDKToolLauncher;
+import jdk.test.lib.Platform;
+import jtreg.SkippedException;
+
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.RandomAccessFile;
+import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 
-import jdk.test.lib.Asserts;
-import jdk.test.lib.JDKToolLauncher;
-import jdk.test.lib.Platform;
-import jdk.test.lib.process.OutputAnalyzer;
-import jdk.test.lib.process.ProcessTools;
-import jtreg.SkippedException;
-
 public class SATestUtils {
     /**
      * Creates a ProcessBuilder, adding privileges (sudo) if needed.
      */
     public static ProcessBuilder createProcessBuilder(JDKToolLauncher launcher) {
@@ -166,15 +161,19 @@
      * if we are root, so return true.  Then return false for an expected denial
      * if "ptrace_scope" is 1, and true otherwise.
      */
     private static boolean canPtraceAttachLinux() throws IOException {
         // SELinux deny_ptrace:
-        File deny_ptrace = new File("/sys/fs/selinux/booleans/deny_ptrace");
-        if (deny_ptrace.exists()) {
-            try (RandomAccessFile file = AccessController.doPrivileged(
-                    (PrivilegedExceptionAction<RandomAccessFile>) () -> new RandomAccessFile(deny_ptrace, "r"))) {
-                if (file.readByte() != '0') {
+        var deny_ptrace = Paths.get("/sys/fs/selinux/booleans/deny_ptrace");
+        if (Files.exists(deny_ptrace)) {
+            try {
+                var bb = AccessController.doPrivileged(
+                    (PrivilegedExceptionAction<byte[]>) () -> Files.readAllBytes(deny_ptrace));
+                if (bb.length == 0) {
+                    throw new Error("deny_ptrace is empty");
+                }
+                if (bb[0] != '0') {
                     return false;
                 }
             } catch (PrivilegedActionException e) {
                 IOException t = (IOException) e.getException();
                 throw t;
@@ -184,15 +183,19 @@
         // YAMA enhanced security ptrace_scope:
         // 0 - a process can PTRACE_ATTACH to any other process running under the same uid
         // 1 - restricted ptrace: a process must be a children of the inferior or user is root
         // 2 - only processes with CAP_SYS_PTRACE may use ptrace or user is root
         // 3 - no attach: no processes may use ptrace with PTRACE_ATTACH
-        File ptrace_scope = new File("/proc/sys/kernel/yama/ptrace_scope");
-        if (ptrace_scope.exists()) {
-            try (RandomAccessFile file = AccessController.doPrivileged(
-                    (PrivilegedExceptionAction<RandomAccessFile>) () -> new RandomAccessFile(ptrace_scope, "r"))) {
-                byte yama_scope = file.readByte();
+        var ptrace_scope = Paths.get("/proc/sys/kernel/yama/ptrace_scope");
+        if (Files.exists(ptrace_scope)) {
+            try {
+                var bb = AccessController.doPrivileged(
+                    (PrivilegedExceptionAction<byte[]>) () -> Files.readAllBytes(ptrace_scope));
+                if (bb.length == 0) {
+                    throw new Error("ptrace_scope is empty");
+                }
+                byte yama_scope = bb[0];
                 if (yama_scope == '3') {
                     return false;
                 }
 
                 if (!Platform.isRoot() && yama_scope != '0') {
@@ -210,17 +213,12 @@
     public static void unzipCores(File dir) {
         File[] gzCores = dir.listFiles((directory, name) -> name.matches("core(\\.\\d+)?\\.gz"));
         for (File gzCore : gzCores) {
             String coreFileName = gzCore.getName().replace(".gz", "");
             System.out.println("Unzipping core into " + coreFileName);
-            try (GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(gzCore));
-                 FileOutputStream fos = new FileOutputStream(coreFileName)) {
-                byte[] buffer = new byte[1024];
-                int length;
-                while ((length = gzis.read(buffer)) > 0) {
-                    fos.write(buffer, 0, length);
-                }
+            try (GZIPInputStream gzis = new GZIPInputStream(Files.newInputStream(gzCore.toPath()))) {
+                Files.copy(gzis, Paths.get(coreFileName));
             } catch (IOException e) {
                 throw new SkippedException("Not able to unzip file: " + gzCore.getAbsolutePath(), e);
             }
         }
     }
diff a/test/lib/jdk/test/lib/hexdump/HexPrinter.java b/test/lib/jdk/test/lib/hexdump/HexPrinter.java
--- a/test/lib/jdk/test/lib/hexdump/HexPrinter.java
+++ b/test/lib/jdk/test/lib/hexdump/HexPrinter.java
@@ -89,11 +89,11 @@
  * such as {@link PrintStream}, {@link StringBuilder}, or {@link Writer}.
  * <p>
  * {@linkplain Formatter Formatter} functions read and interpret the bytes to show the
  * structure and content of a protocol or data stream.
  * Built-in formatters include {@link HexPrinter#formatter(Class, String) primitives},
- * {@link Formatters#PRINTABLE printable ascii},
+ * {@link Formatters#PRINTABLE printable bytes},
  * and {@link Formatters#utf8Parser(DataInputStream, Appendable) UTF-8 strings}.
  * The {@link #formatter(Formatter, String, int) formatter} method sets the
  * formatting function, the delimiter, and the width.
  * Custom formatter functions can be implemented as a lambda, a method, an inner class, or a concrete class.
  * <p>
@@ -236,11 +236,11 @@
      * <UL>
      * <LI>byte offset format: {@code "%08x  "},
      * <LI>each byte value is formatted as 2 hex digits and a space: {@code "%02x "},
      * <LI>maximum number of byte values per line: {@value initBytesCount},
      * <LI>delimiter for the annotation: {@code "|"},
-     * <LI>formatter: {@link Formatters#ASCII ASCII bytes}, and
+     * <LI>formatter: {@link Formatters#PRINTABLE printable bytes}, and
      * <LI>line separator: "|" + {@link  System#lineSeparator()},
      * <LI>destination: {@link System#out System.out}.
      * </UL>
      * Example,
      * <pre>
@@ -252,11 +252,11 @@
      * }</pre>
      *
      * @return a new HexPrinter
      */
     public static HexPrinter canonical() {
-        return new HexPrinter(Formatters.ASCII, "%08x  ",
+        return new HexPrinter(Formatters.PRINTABLE, "%08x  ",
                 "%02x ", initBytesCount,
                 "|", 31, "|" + System.lineSeparator(),
                 System.out);
     }
 
@@ -269,11 +269,11 @@
      * <LI>each byte value is formatted as 2 hex digits and a space: {@code "%02x "},
      * <LI>maximum number of byte values per line: {@value initBytesCount},
      * <LI>delimiter for the annotation: {@code " // "},
      * <LI>width for the annotation: {@value initAnnoWidth},
      * <LI>line separator: {@link System#lineSeparator()},
-     * <LI>formatter: {@link Formatters#PRINTABLE printable ASCII}
+     * <LI>formatter: {@link Formatters#ASCII ASCII bytes}
      * showing printable characters, mnemonics for control chars, and
      * otherwise the decimal byte values,
      * <LI>destination default: {@link System#out System.out}.
      * </UL>
      * Example,
@@ -286,11 +286,11 @@
      * }</pre>
      *
      * @return a new HexPrinter
      */
     public static HexPrinter simple() {
-        return new HexPrinter(Formatters.PRINTABLE, initOffsetFormat,
+        return new HexPrinter(Formatters.ASCII, initOffsetFormat,
                 initBytesFormat, initBytesCount,
                 initAnnoDelim, initAnnoWidth, System.lineSeparator(),
                 System.out);
     }
 
@@ -303,13 +303,12 @@
      * <LI>each byte value is formatted as: {@code "(byte)%3d, "},
      * <LI>maximum number of byte values per line: {@code 8},
      * <LI>delimiter for the annotation: {@code " // "},
      * <LI>width for the annotation: {@value initAnnoWidth},
      * <LI>line separator: {@link System#lineSeparator()},
-     * <LI>formatter: {@link Formatters#PRINTABLE printable ASCII}
-     * showing printable characters, mnemonics for control chars, and
-     * otherwise the decimal byte values,
+     * <LI>formatter: {@link Formatters#PRINTABLE printable bytes}
+     * showing printable characters and otherwise ".",
      * <LI>destination default: {@link System#out System.out}.
      * </UL>
      *
      * @return a new HexPrinter
      */
@@ -424,49 +423,45 @@
             return this;
         }
     }
 
     /**
-     * The formatter function is called repeatedly to read the bytes
-     * from the offset for the length and append the output.
+     * The formatter function is called for the range of the ByteBuffer's contents.
      * All annotation output is appended and flushed to the output destination.
-     * The ByteBuffer position and limit are unused and not modified.
+     * The ByteBuffer position is not used and not modified.
      *
      * @param source a ByteBuffer
-     * @param offset the offset in the ByteBuffer
-     * @param length the length in the ByteBuffer
+     * @param index the index in the ByteBuffer, must be non-negative and
+     *              less than {@code limit()}.
+     * @param length the length in the ByteBuffer must be non-negative and
+     *               no larger than {@code source.limit() - index}
      * @return this HexPrinter
      * @throws java.io.UncheckedIOException if an I/O error occurs
+     * @throws java.lang.IndexOutOfBoundsException if the preconditions on
+     *          {@code index} and {@code length} do not hold
      */
-    public HexPrinter format(ByteBuffer source, int offset, int length) {
+    public HexPrinter format(ByteBuffer source, int index, int length) {
         Objects.requireNonNull(source, "ByteBuffer must be non-null");
-        ByteArrayInputStream bais;
-        if (source.hasArray() && !source.isReadOnly()) {
-            bais = new ByteArrayInputStream(source.array(), offset, length);
-        } else {
-            int size = source.limit() - source.position();
-            byte[] bytes = new byte[size];
-            source.get(bytes, offset, length);
-            bais = new ByteArrayInputStream(bytes);
-        }
-        return format(bais, offset);
+        byte[] bytes = new byte[length];
+        source.get(index, bytes, 0, length);
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
+        return format(bais, index);
     }
 
     /**
-     * The formatter function is called repeatedly to read all of the bytes
-     * in the source and append the output.
+     * The formatter function is called for the ByteBuffer's contents.
      * The source bytes are from the {@code ByteBuffer.position()}
      * to the {@code ByteBuffer.limit()}.
      * The position is not modified.
      * All output is appended and flushed to the destination.
      *
      * @param source a ByteBuffer
      * @return this HexPrinter
      * @throws java.io.UncheckedIOException if an I/O error occurs
      */
     public HexPrinter format(ByteBuffer source) {
-        return format(source, source.position(), source.limit());
+        return format(source, source.position(), source.limit() - source.position());
     }
 
     /**
      * The formatter function is called repeatedly to read all of the bytes
      * and return a String.
@@ -542,51 +537,50 @@
             return sb.toString();
         }
     }
 
     /**
-     * The formatter function is called repeatedly to read the bytes
-     * from the offset for the length and return a String.
-     * The ByteBuffer position and limit are unused and not modified.
+     * The formatter function is called for the range of the ByteBuffer contents
+     * and returned as a string.
+     * The ByteBuffer position is not used and not modified.
      *
      * @param source a ByteBuffer
-     * @param offset the offset in the ByteBuffer
-     * @param length the length in the ByteBuffer
+     * @param index the index in the ByteBuffer, must be non-negative and
+     *              less than {@code limit()}.
+     * @param length the length in the ByteBuffer must be non-negative and
+     *               no larger than {@code source.limit() - index}
      * @return the output as a non-null {@code String}
      * @throws java.io.UncheckedIOException if an I/O error occurs
+     * @throws java.lang.IndexOutOfBoundsException if the preconditions on
+     *          {@code index} and {@code length} do not hold
      */
-    public String toString(ByteBuffer source, int offset, int length) {
+    public String toString(ByteBuffer source, int index, int length) {
         Objects.requireNonNull(source, "ByteBuffer must be non-null");
+        byte[] bytes = new byte[length];
+        source.get(index, bytes, 0, length);
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         StringBuilder sb = new StringBuilder();
-        ByteArrayInputStream bais;
-        if (source.hasArray() && !source.isReadOnly()) {
-            bais = new ByteArrayInputStream(source.array(), offset, length);
-        } else {
-            byte[] bytes = new byte[length];
-            source.get(bytes, offset, length);
-            bais = new ByteArrayInputStream(bytes);
-        }
         try (AnnotationWriter writer =
-                     new AnnotationWriter(this, bais, offset, sb)) {
+                     new AnnotationWriter(this, bais, index, sb)) {
             writer.flush();
             return sb.toString();
         }
     }
 
     /**
-     * The formatter function is called repeatedly to read all of the bytes
-     * in the source and return a String.
+     * The formatter function is called for the ByteBuffer contents
+     * and returned as a string.
      * The source bytes are from the {@code ByteBuffer.position()}
      * to the {@code ByteBuffer.limit()}.
      * The position is not modified.
      *
      * @param source a ByteBuffer
      * @return the output as a non-null {@code String}
      * @throws java.io.UncheckedIOException if an I/O error occurs
      */
     public String toString(ByteBuffer source) {
-        return toString(source, source.position(), source.limit());
+        return toString(source, source.position(), source.limit() - source.position());
     }
 
     /**
      * Returns a new HexPrinter setting the format for the byte offset.
      * The format string is specified by {@link String#format String format}
@@ -828,22 +822,24 @@
          */
         void annotate(DataInputStream in, Appendable out) throws IOException;
     }
 
     /**
-     * Built-in formatters for printable byte, ASCII, UTF-8 and primitive types.
+     * Built-in formatters for printable byte, ASCII byte, UTF-8 and primitive types.
      * Formatters for primitive types and different formatting options
      * can be found by calling {@link #ofPrimitive(Class, String)}.
      */
     public enum Formatters implements Formatter {
         /**
-         * Read a byte and if it is ASCII write it,
-         * otherwise, write its mnemonic or its decimal value.
+         * Read a byte, return the value as a single character string
+         * if it is printable, otherwise return ".".
          */
         PRINTABLE,
         /**
-         * Read a byte, if it is ASCII write it, otherwise write a ".".
+         * Read a byte and return it as a string.
+         * Return the character if it is ASCII, return its mnemonic if it
+         * is a control character, otherwise return its decimal value as a string.
          */
         ASCII,
         /**
          * Read a modified UTF-8 string and write it.
          */
@@ -861,43 +857,43 @@
                 case NONE -> byteNoneParser(in, out);
             }
         }
 
         /**
-         * Read a byte and write it as ASCII if it is printable,
-         * print its mnemonic if it is a control character,
-         * and print its decimal value otherwise.
-         * A space separator character is appended for control and decimal values.
+         * Read a byte and return it as a single character string if it is printable,
+         * otherwise return ".".
          *
          * @param in  a DataInputStream
          * @param out an Appendable to write to
          * @throws IOException if an I/O error occurs
          */
         static void bytePrintable(DataInputStream in, Appendable out) throws IOException {
             int v = in.readUnsignedByte();
-            if (v < 32) {
-                out.append("\\").append(CONTROL_MNEMONICS[v]);
-            } else if (v < 126 && Character.isDefined(v)) {
+            if (!Character.isISOControl(v) && v < 127) {
                 out.append((char) v);
             } else {
-                out.append("\\").append(Integer.toString(v, 10));
+                out.append('.');
             }
         }
 
         /**
-         * Read a byte and write it as ASCII if it is printable, otherwise print ".".
+         * Read a byte and return it as a string.
+         * Append the byte if it is ASCII, its mnemonic if it
+         * is a control character, and otherwise its decimal value.
          *
          * @param in  a DataInputStream
          * @param out an Appendable to write to
          * @throws IOException if an I/O error occurs
          */
         static void byteASCII(DataInputStream in, Appendable out) throws IOException {
             int v = in.readUnsignedByte();
-            if (Character.isDefined(v)) {
+            if (v < 32) {
+                out.append('\\').append(CONTROL_MNEMONICS[v]);
+            } else if (v < 127) {
                 out.append((char) v);
             } else {
-                out.append('.');
+                out.append('\\').append(Integer.toString(v, 10));
             }
         }
 
         /**
          * Read a modified UTF-8 string and write it to the output destination.

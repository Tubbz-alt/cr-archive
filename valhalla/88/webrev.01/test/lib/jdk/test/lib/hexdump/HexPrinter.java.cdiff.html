<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/lib/jdk/test/lib/hexdump/HexPrinter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../SA/SATestUtils.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>test/lib/jdk/test/lib/hexdump/HexPrinter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 89,11 ***</span>
   * such as {@link PrintStream}, {@link StringBuilder}, or {@link Writer}.
   * &lt;p&gt;
   * {@linkplain Formatter Formatter} functions read and interpret the bytes to show the
   * structure and content of a protocol or data stream.
   * Built-in formatters include {@link HexPrinter#formatter(Class, String) primitives},
<span class="line-modified">!  * {@link Formatters#PRINTABLE printable ascii},</span>
   * and {@link Formatters#utf8Parser(DataInputStream, Appendable) UTF-8 strings}.
   * The {@link #formatter(Formatter, String, int) formatter} method sets the
   * formatting function, the delimiter, and the width.
   * Custom formatter functions can be implemented as a lambda, a method, an inner class, or a concrete class.
   * &lt;p&gt;
<span class="line-new-header">--- 89,11 ---</span>
   * such as {@link PrintStream}, {@link StringBuilder}, or {@link Writer}.
   * &lt;p&gt;
   * {@linkplain Formatter Formatter} functions read and interpret the bytes to show the
   * structure and content of a protocol or data stream.
   * Built-in formatters include {@link HexPrinter#formatter(Class, String) primitives},
<span class="line-modified">!  * {@link Formatters#PRINTABLE printable bytes},</span>
   * and {@link Formatters#utf8Parser(DataInputStream, Appendable) UTF-8 strings}.
   * The {@link #formatter(Formatter, String, int) formatter} method sets the
   * formatting function, the delimiter, and the width.
   * Custom formatter functions can be implemented as a lambda, a method, an inner class, or a concrete class.
   * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,11 ***</span>
       * &lt;UL&gt;
       * &lt;LI&gt;byte offset format: {@code &quot;%08x  &quot;},
       * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
       * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
       * &lt;LI&gt;delimiter for the annotation: {@code &quot;|&quot;},
<span class="line-modified">!      * &lt;LI&gt;formatter: {@link Formatters#ASCII ASCII bytes}, and</span>
       * &lt;LI&gt;line separator: &quot;|&quot; + {@link  System#lineSeparator()},
       * &lt;LI&gt;destination: {@link System#out System.out}.
       * &lt;/UL&gt;
       * Example,
       * &lt;pre&gt;
<span class="line-new-header">--- 236,11 ---</span>
       * &lt;UL&gt;
       * &lt;LI&gt;byte offset format: {@code &quot;%08x  &quot;},
       * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
       * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
       * &lt;LI&gt;delimiter for the annotation: {@code &quot;|&quot;},
<span class="line-modified">!      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable bytes}, and</span>
       * &lt;LI&gt;line separator: &quot;|&quot; + {@link  System#lineSeparator()},
       * &lt;LI&gt;destination: {@link System#out System.out}.
       * &lt;/UL&gt;
       * Example,
       * &lt;pre&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,11 ***</span>
       * }&lt;/pre&gt;
       *
       * @return a new HexPrinter
       */
      public static HexPrinter canonical() {
<span class="line-modified">!         return new HexPrinter(Formatters.ASCII, &quot;%08x  &quot;,</span>
                  &quot;%02x &quot;, initBytesCount,
                  &quot;|&quot;, 31, &quot;|&quot; + System.lineSeparator(),
                  System.out);
      }
  
<span class="line-new-header">--- 252,11 ---</span>
       * }&lt;/pre&gt;
       *
       * @return a new HexPrinter
       */
      public static HexPrinter canonical() {
<span class="line-modified">!         return new HexPrinter(Formatters.PRINTABLE, &quot;%08x  &quot;,</span>
                  &quot;%02x &quot;, initBytesCount,
                  &quot;|&quot;, 31, &quot;|&quot; + System.lineSeparator(),
                  System.out);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,11 ***</span>
       * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
       * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
       * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
       * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
       * &lt;LI&gt;line separator: {@link System#lineSeparator()},
<span class="line-modified">!      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable ASCII}</span>
       * showing printable characters, mnemonics for control chars, and
       * otherwise the decimal byte values,
       * &lt;LI&gt;destination default: {@link System#out System.out}.
       * &lt;/UL&gt;
       * Example,
<span class="line-new-header">--- 269,11 ---</span>
       * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
       * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
       * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
       * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
       * &lt;LI&gt;line separator: {@link System#lineSeparator()},
<span class="line-modified">!      * &lt;LI&gt;formatter: {@link Formatters#ASCII ASCII bytes}</span>
       * showing printable characters, mnemonics for control chars, and
       * otherwise the decimal byte values,
       * &lt;LI&gt;destination default: {@link System#out System.out}.
       * &lt;/UL&gt;
       * Example,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,11 ***</span>
       * }&lt;/pre&gt;
       *
       * @return a new HexPrinter
       */
      public static HexPrinter simple() {
<span class="line-modified">!         return new HexPrinter(Formatters.PRINTABLE, initOffsetFormat,</span>
                  initBytesFormat, initBytesCount,
                  initAnnoDelim, initAnnoWidth, System.lineSeparator(),
                  System.out);
      }
  
<span class="line-new-header">--- 286,11 ---</span>
       * }&lt;/pre&gt;
       *
       * @return a new HexPrinter
       */
      public static HexPrinter simple() {
<span class="line-modified">!         return new HexPrinter(Formatters.ASCII, initOffsetFormat,</span>
                  initBytesFormat, initBytesCount,
                  initAnnoDelim, initAnnoWidth, System.lineSeparator(),
                  System.out);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 303,13 ***</span>
       * &lt;LI&gt;each byte value is formatted as: {@code &quot;(byte)%3d, &quot;},
       * &lt;LI&gt;maximum number of byte values per line: {@code 8},
       * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
       * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
       * &lt;LI&gt;line separator: {@link System#lineSeparator()},
<span class="line-modified">!      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable ASCII}</span>
<span class="line-modified">!      * showing printable characters, mnemonics for control chars, and</span>
<span class="line-removed">-      * otherwise the decimal byte values,</span>
       * &lt;LI&gt;destination default: {@link System#out System.out}.
       * &lt;/UL&gt;
       *
       * @return a new HexPrinter
       */
<span class="line-new-header">--- 303,12 ---</span>
       * &lt;LI&gt;each byte value is formatted as: {@code &quot;(byte)%3d, &quot;},
       * &lt;LI&gt;maximum number of byte values per line: {@code 8},
       * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
       * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
       * &lt;LI&gt;line separator: {@link System#lineSeparator()},
<span class="line-modified">!      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable bytes}</span>
<span class="line-modified">!      * showing printable characters and otherwise &quot;.&quot;,</span>
       * &lt;LI&gt;destination default: {@link System#out System.out}.
       * &lt;/UL&gt;
       *
       * @return a new HexPrinter
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,49 ***</span>
              return this;
          }
      }
  
      /**
<span class="line-modified">!      * The formatter function is called repeatedly to read the bytes</span>
<span class="line-removed">-      * from the offset for the length and append the output.</span>
       * All annotation output is appended and flushed to the output destination.
<span class="line-modified">!      * The ByteBuffer position and limit are unused and not modified.</span>
       *
       * @param source a ByteBuffer
<span class="line-modified">!      * @param offset the offset in the ByteBuffer</span>
<span class="line-modified">!      * @param length the length in the ByteBuffer</span>
       * @return this HexPrinter
       * @throws java.io.UncheckedIOException if an I/O error occurs
       */
<span class="line-modified">!     public HexPrinter format(ByteBuffer source, int offset, int length) {</span>
          Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
<span class="line-modified">!         ByteArrayInputStream bais;</span>
<span class="line-modified">!         if (source.hasArray() &amp;&amp; !source.isReadOnly()) {</span>
<span class="line-modified">!             bais = new ByteArrayInputStream(source.array(), offset, length);</span>
<span class="line-modified">!         } else {</span>
<span class="line-removed">-             int size = source.limit() - source.position();</span>
<span class="line-removed">-             byte[] bytes = new byte[size];</span>
<span class="line-removed">-             source.get(bytes, offset, length);</span>
<span class="line-removed">-             bais = new ByteArrayInputStream(bytes);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return format(bais, offset);</span>
      }
  
      /**
<span class="line-modified">!      * The formatter function is called repeatedly to read all of the bytes</span>
<span class="line-removed">-      * in the source and append the output.</span>
       * The source bytes are from the {@code ByteBuffer.position()}
       * to the {@code ByteBuffer.limit()}.
       * The position is not modified.
       * All output is appended and flushed to the destination.
       *
       * @param source a ByteBuffer
       * @return this HexPrinter
       * @throws java.io.UncheckedIOException if an I/O error occurs
       */
      public HexPrinter format(ByteBuffer source) {
<span class="line-modified">!         return format(source, source.position(), source.limit());</span>
      }
  
      /**
       * The formatter function is called repeatedly to read all of the bytes
       * and return a String.
<span class="line-new-header">--- 423,45 ---</span>
              return this;
          }
      }
  
      /**
<span class="line-modified">!      * The formatter function is called for the range of the ByteBuffer&#39;s contents.</span>
       * All annotation output is appended and flushed to the output destination.
<span class="line-modified">!      * The ByteBuffer position is not used and not modified.</span>
       *
       * @param source a ByteBuffer
<span class="line-modified">!      * @param index the index in the ByteBuffer, must be non-negative and</span>
<span class="line-modified">!      *              less than {@code limit()}.</span>
<span class="line-added">+      * @param length the length in the ByteBuffer must be non-negative and</span>
<span class="line-added">+      *               no larger than {@code source.limit() - index}</span>
       * @return this HexPrinter
       * @throws java.io.UncheckedIOException if an I/O error occurs
<span class="line-added">+      * @throws java.lang.IndexOutOfBoundsException if the preconditions on</span>
<span class="line-added">+      *          {@code index} and {@code length} do not hold</span>
       */
<span class="line-modified">!     public HexPrinter format(ByteBuffer source, int index, int length) {</span>
          Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
<span class="line-modified">!         byte[] bytes = new byte[length];</span>
<span class="line-modified">!         source.get(index, bytes, 0, length);</span>
<span class="line-modified">!         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);</span>
<span class="line-modified">!         return format(bais, index);</span>
      }
  
      /**
<span class="line-modified">!      * The formatter function is called for the ByteBuffer&#39;s contents.</span>
       * The source bytes are from the {@code ByteBuffer.position()}
       * to the {@code ByteBuffer.limit()}.
       * The position is not modified.
       * All output is appended and flushed to the destination.
       *
       * @param source a ByteBuffer
       * @return this HexPrinter
       * @throws java.io.UncheckedIOException if an I/O error occurs
       */
      public HexPrinter format(ByteBuffer source) {
<span class="line-modified">!         return format(source, source.position(), source.limit() - source.position());</span>
      }
  
      /**
       * The formatter function is called repeatedly to read all of the bytes
       * and return a String.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 542,51 ***</span>
              return sb.toString();
          }
      }
  
      /**
<span class="line-modified">!      * The formatter function is called repeatedly to read the bytes</span>
<span class="line-modified">!      * from the offset for the length and return a String.</span>
<span class="line-modified">!      * The ByteBuffer position and limit are unused and not modified.</span>
       *
       * @param source a ByteBuffer
<span class="line-modified">!      * @param offset the offset in the ByteBuffer</span>
<span class="line-modified">!      * @param length the length in the ByteBuffer</span>
       * @return the output as a non-null {@code String}
       * @throws java.io.UncheckedIOException if an I/O error occurs
       */
<span class="line-modified">!     public String toString(ByteBuffer source, int offset, int length) {</span>
          Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
          StringBuilder sb = new StringBuilder();
<span class="line-removed">-         ByteArrayInputStream bais;</span>
<span class="line-removed">-         if (source.hasArray() &amp;&amp; !source.isReadOnly()) {</span>
<span class="line-removed">-             bais = new ByteArrayInputStream(source.array(), offset, length);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             byte[] bytes = new byte[length];</span>
<span class="line-removed">-             source.get(bytes, offset, length);</span>
<span class="line-removed">-             bais = new ByteArrayInputStream(bytes);</span>
<span class="line-removed">-         }</span>
          try (AnnotationWriter writer =
<span class="line-modified">!                      new AnnotationWriter(this, bais, offset, sb)) {</span>
              writer.flush();
              return sb.toString();
          }
      }
  
      /**
<span class="line-modified">!      * The formatter function is called repeatedly to read all of the bytes</span>
<span class="line-modified">!      * in the source and return a String.</span>
       * The source bytes are from the {@code ByteBuffer.position()}
       * to the {@code ByteBuffer.limit()}.
       * The position is not modified.
       *
       * @param source a ByteBuffer
       * @return the output as a non-null {@code String}
       * @throws java.io.UncheckedIOException if an I/O error occurs
       */
      public String toString(ByteBuffer source) {
<span class="line-modified">!         return toString(source, source.position(), source.limit());</span>
      }
  
      /**
       * Returns a new HexPrinter setting the format for the byte offset.
       * The format string is specified by {@link String#format String format}
<span class="line-new-header">--- 537,50 ---</span>
              return sb.toString();
          }
      }
  
      /**
<span class="line-modified">!      * The formatter function is called for the range of the ByteBuffer contents</span>
<span class="line-modified">!      * and returned as a string.</span>
<span class="line-modified">!      * The ByteBuffer position is not used and not modified.</span>
       *
       * @param source a ByteBuffer
<span class="line-modified">!      * @param index the index in the ByteBuffer, must be non-negative and</span>
<span class="line-modified">!      *              less than {@code limit()}.</span>
<span class="line-added">+      * @param length the length in the ByteBuffer must be non-negative and</span>
<span class="line-added">+      *               no larger than {@code source.limit() - index}</span>
       * @return the output as a non-null {@code String}
       * @throws java.io.UncheckedIOException if an I/O error occurs
<span class="line-added">+      * @throws java.lang.IndexOutOfBoundsException if the preconditions on</span>
<span class="line-added">+      *          {@code index} and {@code length} do not hold</span>
       */
<span class="line-modified">!     public String toString(ByteBuffer source, int index, int length) {</span>
          Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
<span class="line-added">+         byte[] bytes = new byte[length];</span>
<span class="line-added">+         source.get(index, bytes, 0, length);</span>
<span class="line-added">+         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);</span>
          StringBuilder sb = new StringBuilder();
          try (AnnotationWriter writer =
<span class="line-modified">!                      new AnnotationWriter(this, bais, index, sb)) {</span>
              writer.flush();
              return sb.toString();
          }
      }
  
      /**
<span class="line-modified">!      * The formatter function is called for the ByteBuffer contents</span>
<span class="line-modified">!      * and returned as a string.</span>
       * The source bytes are from the {@code ByteBuffer.position()}
       * to the {@code ByteBuffer.limit()}.
       * The position is not modified.
       *
       * @param source a ByteBuffer
       * @return the output as a non-null {@code String}
       * @throws java.io.UncheckedIOException if an I/O error occurs
       */
      public String toString(ByteBuffer source) {
<span class="line-modified">!         return toString(source, source.position(), source.limit() - source.position());</span>
      }
  
      /**
       * Returns a new HexPrinter setting the format for the byte offset.
       * The format string is specified by {@link String#format String format}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 828,22 ***</span>
           */
          void annotate(DataInputStream in, Appendable out) throws IOException;
      }
  
      /**
<span class="line-modified">!      * Built-in formatters for printable byte, ASCII, UTF-8 and primitive types.</span>
       * Formatters for primitive types and different formatting options
       * can be found by calling {@link #ofPrimitive(Class, String)}.
       */
      public enum Formatters implements Formatter {
          /**
<span class="line-modified">!          * Read a byte and if it is ASCII write it,</span>
<span class="line-modified">!          * otherwise, write its mnemonic or its decimal value.</span>
           */
          PRINTABLE,
          /**
<span class="line-modified">!          * Read a byte, if it is ASCII write it, otherwise write a &quot;.&quot;.</span>
           */
          ASCII,
          /**
           * Read a modified UTF-8 string and write it.
           */
<span class="line-new-header">--- 822,24 ---</span>
           */
          void annotate(DataInputStream in, Appendable out) throws IOException;
      }
  
      /**
<span class="line-modified">!      * Built-in formatters for printable byte, ASCII byte, UTF-8 and primitive types.</span>
       * Formatters for primitive types and different formatting options
       * can be found by calling {@link #ofPrimitive(Class, String)}.
       */
      public enum Formatters implements Formatter {
          /**
<span class="line-modified">!          * Read a byte, return the value as a single character string</span>
<span class="line-modified">!          * if it is printable, otherwise return &quot;.&quot;.</span>
           */
          PRINTABLE,
          /**
<span class="line-modified">!          * Read a byte and return it as a string.</span>
<span class="line-added">+          * Return the character if it is ASCII, return its mnemonic if it</span>
<span class="line-added">+          * is a control character, otherwise return its decimal value as a string.</span>
           */
          ASCII,
          /**
           * Read a modified UTF-8 string and write it.
           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 861,43 ***</span>
                  case NONE -&gt; byteNoneParser(in, out);
              }
          }
  
          /**
<span class="line-modified">!          * Read a byte and write it as ASCII if it is printable,</span>
<span class="line-modified">!          * print its mnemonic if it is a control character,</span>
<span class="line-removed">-          * and print its decimal value otherwise.</span>
<span class="line-removed">-          * A space separator character is appended for control and decimal values.</span>
           *
           * @param in  a DataInputStream
           * @param out an Appendable to write to
           * @throws IOException if an I/O error occurs
           */
          static void bytePrintable(DataInputStream in, Appendable out) throws IOException {
              int v = in.readUnsignedByte();
<span class="line-modified">!             if (v &lt; 32) {</span>
<span class="line-removed">-                 out.append(&quot;\\&quot;).append(CONTROL_MNEMONICS[v]);</span>
<span class="line-removed">-             } else if (v &lt; 126 &amp;&amp; Character.isDefined(v)) {</span>
                  out.append((char) v);
              } else {
<span class="line-modified">!                 out.append(&quot;\\&quot;).append(Integer.toString(v, 10));</span>
              }
          }
  
          /**
<span class="line-modified">!          * Read a byte and write it as ASCII if it is printable, otherwise print &quot;.&quot;.</span>
           *
           * @param in  a DataInputStream
           * @param out an Appendable to write to
           * @throws IOException if an I/O error occurs
           */
          static void byteASCII(DataInputStream in, Appendable out) throws IOException {
              int v = in.readUnsignedByte();
<span class="line-modified">!             if (Character.isDefined(v)) {</span>
                  out.append((char) v);
              } else {
<span class="line-modified">!                 out.append(&#39;.&#39;);</span>
              }
          }
  
          /**
           * Read a modified UTF-8 string and write it to the output destination.
<span class="line-new-header">--- 857,43 ---</span>
                  case NONE -&gt; byteNoneParser(in, out);
              }
          }
  
          /**
<span class="line-modified">!          * Read a byte and return it as a single character string if it is printable,</span>
<span class="line-modified">!          * otherwise return &quot;.&quot;.</span>
           *
           * @param in  a DataInputStream
           * @param out an Appendable to write to
           * @throws IOException if an I/O error occurs
           */
          static void bytePrintable(DataInputStream in, Appendable out) throws IOException {
              int v = in.readUnsignedByte();
<span class="line-modified">!             if (!Character.isISOControl(v) &amp;&amp; v &lt; 127) {</span>
                  out.append((char) v);
              } else {
<span class="line-modified">!                 out.append(&#39;.&#39;);</span>
              }
          }
  
          /**
<span class="line-modified">!          * Read a byte and return it as a string.</span>
<span class="line-added">+          * Append the byte if it is ASCII, its mnemonic if it</span>
<span class="line-added">+          * is a control character, and otherwise its decimal value.</span>
           *
           * @param in  a DataInputStream
           * @param out an Appendable to write to
           * @throws IOException if an I/O error occurs
           */
          static void byteASCII(DataInputStream in, Appendable out) throws IOException {
              int v = in.readUnsignedByte();
<span class="line-modified">!             if (v &lt; 32) {</span>
<span class="line-added">+                 out.append(&#39;\\&#39;).append(CONTROL_MNEMONICS[v]);</span>
<span class="line-added">+             } else if (v &lt; 127) {</span>
                  out.append((char) v);
              } else {
<span class="line-modified">!                 out.append(&#39;\\&#39;).append(Integer.toString(v, 10));</span>
              }
          }
  
          /**
           * Read a modified UTF-8 string and write it to the output destination.
</pre>
<center><a href="../SA/SATestUtils.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
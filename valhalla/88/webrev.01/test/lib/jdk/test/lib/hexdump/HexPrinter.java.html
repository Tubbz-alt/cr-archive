<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/lib/jdk/test/lib/hexdump/HexPrinter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package jdk.test.lib.hexdump;
  25 
  26 import java.io.BufferedInputStream;
  27 import java.io.ByteArrayInputStream;
  28 import java.io.CharArrayWriter;
  29 import java.io.DataInputStream;
  30 import java.io.EOFException;
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.PrintStream;
  34 import java.io.UncheckedIOException;
  35 import java.io.Writer;
  36 import java.nio.ByteBuffer;
  37 import java.util.Objects;
  38 
  39 /**
  40  * Decode a sequence of bytes to a readable format.
  41  * &lt;p&gt;
  42  * The predefined formats are:
  43  * &lt;DL&gt;
  44  * &lt;DT&gt;{@link #minimal() Minimal format}:  {@code &quot;Now is the time for Java.\n&quot;}&lt;/DT&gt;
  45  * &lt;DD&gt;&lt;pre&gt;    {@code
  46  *     4e6f77206973207468652074696d6520666f72204a6176612e0a} &lt;/pre&gt;
  47  * &lt;/DD&gt;
  48  *
  49  * &lt;DT&gt;{@link #simple() Simple format}: {@code &quot;Now is the time for Java.\n&quot;}&lt;/DT&gt;
  50  * &lt;DD&gt;&lt;pre&gt;{@code
  51  *     0: 4e 6f 77 20 69 73 20 74 68 65 20 74 69 6d 65 20  // Now is the time for Java.\n
  52  *    16: 66 6f 72 20 4a 61 76 61 2e 0a} &lt;/pre&gt;
  53  * &lt;/DD&gt;
  54  *
  55  * &lt;DT&gt;{@link #canonical() Canonical format}: {@code &quot;Now is the time for Java.\n&quot;}&lt;/DT&gt;
  56  * &lt;DD&gt;&lt;pre&gt;{@code
  57  *     00000000  4e 6f 77 20 69 73 20 74 68 65 20 74 69 6d 65 20 |Now is the time |
  58  *     00000010  66 6f 72 20 4a 61 76 61 2e 0a                   |for Java.|} &lt;/pre&gt;
  59  * &lt;/DD&gt;
  60  * &lt;DT&gt;{@link #source() Byte array initialization source}: {@code &quot;Now is the time for Java.\n&quot;}&lt;/DT&gt;
  61  * &lt;DD&gt;&lt;pre&gt;{@code
  62  *     (byte) 78, (byte)111, (byte)119, (byte) 32, (byte)105, (byte)115, (byte) 32, (byte)116,  // Now is t
  63  *     (byte)104, (byte)101, (byte) 32, (byte)116, (byte)105, (byte)109, (byte)101, (byte) 32,  // he time
  64  *     (byte)102, (byte)111, (byte)114, (byte) 32, (byte) 74, (byte) 97, (byte)118, (byte) 97,  // for Java
  65  *     (byte) 46, (byte) 10,                                                                    // .\n}&lt;/pre&gt;
  66  * &lt;/DD&gt;
  67  * &lt;/DL&gt;
  68  * &lt;p&gt;
  69  * The static factories {@link #minimal minimal}, {@link #simple simple},
  70  * {@link #canonical canonical}, and {@link #source() Java source}
  71  * return predefined {@code HexPrinter}s for the formats above.
  72  * HexPrinter holds the formatting parameters that control the width and formatting
  73  * of each of the offset, byte values, and formatted output.
  74  * New HexPrinters with different parameters are created using an existing HexPrinter
  75  * as a template with the methods {@link #formatter(Formatter)},
  76  * {@link #withBytesFormat(String, int)}, {@link #withOffsetFormat(String)},
  77  * and {@link #withLineSeparator(String)}.
  78  * &lt;p&gt;
  79  * The source of the bytes includes byte arrays, InputStreams, and ByteBuffers.
  80  * For example, {@link #toString(InputStream)} reads the input and returns a String.
  81  * Each of the {@code toString(...)} methods immediately reads and
  82  * formats all of the bytes from the source and returns a String.
  83  * &lt;p&gt;
  84  * Each of the  {@code format(...)} methods immediately reads and
  85  * formats all of the bytes from the source and appends it to the destination.
  86  * For example, {@link #format(InputStream)} reads the input and
  87  * appends the output to {@link System#out System.out} unless the
  88  * {@link #dest(Appendable) destination} is changed to an {@link Appendable}
  89  * such as {@link PrintStream}, {@link StringBuilder}, or {@link Writer}.
  90  * &lt;p&gt;
  91  * {@linkplain Formatter Formatter} functions read and interpret the bytes to show the
  92  * structure and content of a protocol or data stream.
  93  * Built-in formatters include {@link HexPrinter#formatter(Class, String) primitives},
  94  * {@link Formatters#PRINTABLE printable bytes},
  95  * and {@link Formatters#utf8Parser(DataInputStream, Appendable) UTF-8 strings}.
  96  * The {@link #formatter(Formatter, String, int) formatter} method sets the
  97  * formatting function, the delimiter, and the width.
  98  * Custom formatter functions can be implemented as a lambda, a method, an inner class, or a concrete class.
  99  * &lt;p&gt;
 100  * The format of each line is customizable.
 101  * The {@link #withOffsetFormat(String) withOffsetFormat} method controls
 102  * the format of the byte offset.
 103  * The {@link #withBytesFormat(String, int) withBytesFormat} method controls
 104  * the printing of each byte value including the separator,
 105  * and the maximum number of byte values per line.
 106  * The offset and byte values are formatted using the familiar
 107  * {@link String#format String formats} with spacing
 108  * and delimiters included in the format string.
 109  * The {@link #withLineSeparator(String) withLineSeparator} method sets
 110  * the line separator.
 111  * &lt;p&gt;
 112  * Examples:
 113  * &lt;UL&gt;
 114  * &lt;LI&gt; Encoding bytes to a minimal string.
 115  * &lt;pre&gt;{@code
 116  * byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 117  * String s = HexPrinter.minimal().toString(bytes);
 118  * Result: &quot;2041420a&quot;
 119  * }&lt;/pre&gt;
 120  * &lt;LI&gt;Simple formatting of a byte array.
 121  * &lt;pre&gt;{@code
 122  * byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 123  * String s = HexPrinter.simple().toString(bytes);
 124  * Result:    0: 20 41 42 0a                                      //  AB\n
 125  * }&lt;/pre&gt;
 126  * &lt;LI&gt;Simple formatting of a ByteBuffer.
 127  * &lt;pre&gt;{@code
 128  * ByteBuffer bb = ByteBuffer.wrap(bytes);
 129  * String s = HexPrinter.simple().toString(bb);
 130  * Result:    0: 20 41 42 0a                                      //  AB\n
 131  * }&lt;/pre&gt;
 132  * &lt;LI&gt;Simple formatting of ranges of a byte array to System.err.
 133  * &lt;pre&gt;{@code
 134  * byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, 0x43, 0x44, &#39;\n&#39;};
 135  * HexPrinter hex = HexPrinter.simple()
 136  *                            .dest(System.err);
 137  *                            .format(bytes, 1, 2)
 138  *                            .format(bytes, 3, 2);
 139  * Result:
 140  * 1: 41 42                                            // AB
 141  * 3: 43 44                                            // CD
 142  * }&lt;/pre&gt;
 143  * &lt;/UL&gt;
 144  * &lt;p&gt;
 145  * This is a &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
 146  * class; use of identity-sensitive operations (including reference equality
 147  * ({@code ==}), identity hash code, or synchronization) on instances
 148  * may have unpredictable results and should be avoided.
 149  * The {@code equals} method should be used for comparisons.
 150  *
 151  * &lt;p&gt;
 152  * This class is immutable and thread-safe.
 153  */
 154 public final class HexPrinter {
 155 
 156     /**
 157      * Mnemonics for control characters.
 158      */
 159     static final String[] CONTROL_MNEMONICS = {
 160             &quot;nul&quot;, &quot;soh&quot;, &quot;stx&quot;, &quot;etx&quot;, &quot;eot&quot;, &quot;enq&quot;, &quot;ack&quot;, &quot;bel&quot;,
 161             &quot;b&quot;, &quot;t&quot;, &quot;n&quot;, &quot;vt&quot;, &quot;f&quot;, &quot;r&quot;, &quot;so&quot;, &quot;si&quot;,
 162             &quot;dle&quot;, &quot;dc1&quot;, &quot;dc2&quot;, &quot;dc3&quot;, &quot;dc4&quot;, &quot;nak&quot;, &quot;syn&quot;, &quot;etb&quot;,
 163             &quot;can&quot;, &quot;em&quot;, &quot;sub&quot;, &quot;esc&quot;, &quot;fs&quot;, &quot;gs&quot;, &quot;rs&quot;, &quot;us&quot;
 164     };
 165     private static final String initOffsetFormat = &quot;%5d: &quot;;
 166     private static final int initBytesCount = 16;   // 16 byte values
 167     private static final String initBytesFormat = &quot;%02x &quot;;
 168     private static final int initAnnoWidth = initBytesCount * 4;
 169     private static final String initAnnoDelim = &quot; // &quot;;
 170 
 171     final Appendable dest;              // Final output target
 172     final String offsetFormat;          // Byte offset Formatter String
 173     final String bytesFormat;           // Hex bytes Formatter string
 174     final int bytesCount;               // Maximum number of byte values per line
 175     final String annoDelim;             // Annotation delimiter
 176     final int annoWidth;                // Annotation field width (characters)
 177     final String lineSeparator;         // End of line separator
 178     final Formatter annoFormatter;      // formatter function
 179 
 180     /**
 181      * Construct a new HexPrinter with all new values.
 182      *
 183      * @param printer       the formatter
 184      * @param offsetFormat  the offset format
 185      * @param bytesFormat   the bytes format
 186      * @param bytesCount    the count of bytes per line
 187      * @param annoDelim     the delimiter before the annotation
 188      * @param annoWidth     the width of the annotation
 189      * @param lineSeparator the line separator
 190      * @param dest          the destination
 191      */
 192     private HexPrinter(Formatter printer, String offsetFormat, String bytesFormat, int bytesCount,
 193                        String annoDelim, int annoWidth,
 194                        String lineSeparator, Appendable dest) {
 195         this.annoFormatter = Objects.requireNonNull(printer, &quot;formatter&quot;);
 196         this.bytesCount = bytesCount;
 197         this.bytesFormat = Objects.requireNonNull(bytesFormat, bytesFormat);
 198         this.offsetFormat = Objects.requireNonNull(offsetFormat, &quot;offsetFormat&quot;);
 199         this.annoDelim = Objects.requireNonNull(annoDelim, &quot;annoDelim&quot;);
 200         this.annoWidth = annoWidth;
 201         this.lineSeparator = Objects.requireNonNull(lineSeparator, &quot;lineSeparator&quot;);
 202         this.dest = Objects.requireNonNull(dest, &quot;dest&quot;);
 203     }
 204 
 205     /**
 206      * Returns a new HexPrinter setting the parameters to produce a minimal string.
 207      * The parameters are set to:
 208      * &lt;UL&gt;
 209      * &lt;LI&gt;byte offset format: none {@code &quot;&quot;},
 210      * &lt;LI&gt;each byte value is formatted as 2 hex digits: {@code &quot;%02x&quot;},
 211      * &lt;LI&gt;maximum number of byte values per line: unbounded,
 212      * &lt;LI&gt;delimiter for the annotation: none {@code &quot;&quot;},
 213      * &lt;LI&gt;formatter: {@link Formatters#NONE does not output a formatted byte}, and
 214      * &lt;LI&gt;destination: {@link System#out System.out}.
 215      * &lt;/UL&gt;
 216      * Example,
 217      * &lt;pre&gt;
 218      * {@code     byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 219      *     String s = HexPrinter.minimal()
 220      *             .toString(bytes);
 221      *     Result: &quot;2041420a&quot;
 222      * }&lt;/pre&gt;
 223      *
 224      * @return a new HexPrinter
 225      */
 226     public static HexPrinter minimal() {
 227         return new HexPrinter(Formatters.NONE, &quot;&quot;,
 228                 &quot;%02x&quot;, initBytesCount,
 229                 &quot;&quot;, initAnnoWidth, &quot;&quot;,
 230                 System.out);
 231     }
 232 
 233     /**
 234      * Returns a new HexPrinter setting the parameters to produce canonical output.
 235      * The parameters are set to:
 236      * &lt;UL&gt;
 237      * &lt;LI&gt;byte offset format: {@code &quot;%08x  &quot;},
 238      * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
 239      * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
 240      * &lt;LI&gt;delimiter for the annotation: {@code &quot;|&quot;},
 241      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable bytes}, and
 242      * &lt;LI&gt;line separator: &quot;|&quot; + {@link  System#lineSeparator()},
 243      * &lt;LI&gt;destination: {@link System#out System.out}.
 244      * &lt;/UL&gt;
 245      * Example,
 246      * &lt;pre&gt;
 247      * {@code     byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 248      *     String s = HexPrinter.canonical()
 249      *             .toString(bytes);
 250      *
 251      *     Result: &quot;00000000  20 41 42 0a                                     | AB|&quot;
 252      * }&lt;/pre&gt;
 253      *
 254      * @return a new HexPrinter
 255      */
 256     public static HexPrinter canonical() {
 257         return new HexPrinter(Formatters.PRINTABLE, &quot;%08x  &quot;,
 258                 &quot;%02x &quot;, initBytesCount,
 259                 &quot;|&quot;, 31, &quot;|&quot; + System.lineSeparator(),
 260                 System.out);
 261     }
 262 
 263     /**
 264      * Returns a new HexPrinter setting simple formatting parameters to output
 265      * to a multi-line string.
 266      * The parameters are set to:
 267      * &lt;UL&gt;
 268      * &lt;LI&gt;byte offset format: signed decimal width 5 and a space, {@code &quot;%5d: &quot;},
 269      * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
 270      * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
 271      * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
 272      * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
 273      * &lt;LI&gt;line separator: {@link System#lineSeparator()},
 274      * &lt;LI&gt;formatter: {@link Formatters#ASCII ASCII bytes}
 275      * showing printable characters, mnemonics for control chars, and
 276      * otherwise the decimal byte values,
 277      * &lt;LI&gt;destination default: {@link System#out System.out}.
 278      * &lt;/UL&gt;
 279      * Example,
 280      * &lt;pre&gt;
 281      * {@code    byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 282      *    String s = HexPrinter.simple()
 283      *            .toString(bytes);
 284      *
 285      *    Result: &quot;    0: 20 41 42 0a                                      //  AB\n&quot;
 286      * }&lt;/pre&gt;
 287      *
 288      * @return a new HexPrinter
 289      */
 290     public static HexPrinter simple() {
 291         return new HexPrinter(Formatters.ASCII, initOffsetFormat,
 292                 initBytesFormat, initBytesCount,
 293                 initAnnoDelim, initAnnoWidth, System.lineSeparator(),
 294                 System.out);
 295     }
 296 
 297     /**
 298      * Returns a new HexPrinter setting formatting parameters to output
 299      * to a multi-line string as a byte array initialization for Java source.
 300      * The parameters are set to:
 301      * &lt;UL&gt;
 302      * &lt;LI&gt;byte offset format: 4 space indent: {@code &quot;    &quot;},
 303      * &lt;LI&gt;each byte value is formatted as: {@code &quot;(byte)%3d, &quot;},
 304      * &lt;LI&gt;maximum number of byte values per line: {@code 8},
 305      * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
 306      * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
 307      * &lt;LI&gt;line separator: {@link System#lineSeparator()},
 308      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable bytes}
 309      * showing printable characters and otherwise &quot;.&quot;,
 310      * &lt;LI&gt;destination default: {@link System#out System.out}.
 311      * &lt;/UL&gt;
 312      *
 313      * @return a new HexPrinter
 314      */
 315     public static HexPrinter source() {
 316         return new HexPrinter(Formatters.PRINTABLE, &quot;    &quot;,
 317                 &quot;(byte)%3d, &quot;, 8,
 318                 &quot; // &quot;, initAnnoWidth, System.lineSeparator(),
 319                 System.out);
 320     }
 321 
 322     /**
 323      * Returns a new HexPrinter setting the destination to the Appendable.
 324      * {@code Appendable} classes include: {@link PrintStream}, {@link Writer},
 325      * {@link StringBuilder}, and {@link StringBuffer}.
 326      *
 327      * @param dest the Appendable destination for the output, non-null
 328      * @return a new HexPrinter
 329      * @throws UncheckedIOException if an I/O error occurs
 330      */
 331     public HexPrinter dest(Appendable dest) {
 332         Objects.requireNonNull(dest, &quot;dest&quot;);
 333         return new HexPrinter(annoFormatter, offsetFormat,
 334                 bytesFormat, bytesCount, annoDelim,
 335                 annoWidth, lineSeparator, dest);
 336     }
 337 
 338     /**
 339      * The formatter function is called repeatedly to read all of the bytes
 340      * and append the output.
 341      * All output is appended and flushed to the destination.
 342      * &lt;p&gt;
 343      * The result is equivalent to calling
 344      * {@code format(new ByteArrayInputStream(source))}.
 345      *
 346      * @param source a non-null array of bytes.
 347      * @return this HexPrinter
 348      * @throws java.io.UncheckedIOException if an I/O error occurs
 349      */
 350     public HexPrinter format(byte[] source) {
 351         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 352         return format(new ByteArrayInputStream(source));
 353     }
 354 
 355     /**
 356      * The formatter function is called repeatedly to read the bytes from offset
 357      * for length and append the output.
 358      * All output is appended and flushed to the destination.
 359      * Only {@code length} bytes starting at the {@code offset} are formatted.
 360      * &lt;p&gt;
 361      * The result is equivalent to calling
 362      * {@code format(new ByteArrayInputStream(source, offset, len))}.
 363      *
 364      * @param source a non-null array of bytes.
 365      * @param offset the offset into the array to start
 366      * @param length the length of bytes in the array to format
 367      * @return this HexPrinter
 368      * @throws java.io.UncheckedIOException if an I/O error occurs
 369      */
 370     public HexPrinter format(byte[] source, int offset, int length) {
 371         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 372         return format(new ByteArrayInputStream(source, offset, length), offset);
 373     }
 374 
 375     /**
 376      * The formatter function is called repeatedly to read all of the bytes
 377      * and append the output.
 378      * All output is appended and flushed to the destination.
 379      * &lt;p&gt;
 380      * The {@code format} method invokes the {@code formatter} to read bytes from the
 381      * source and append the formatted sequence of byte values to the destination.
 382      * As the bytes are read they are printed using the {@link #withBytesFormat}
 383      * to fill the bytes values of the output destination.
 384      * The output of the {@code formatter} fills the annotation field.
 385      * A new line is started when either the byte values or annotation
 386      * is filled to its respective width. The offset of the first byte on the line
 387      * is inserted at the beginning of each line using {@link #withOffsetFormat(String)}.
 388      * &lt;p&gt;
 389      * This method may block indefinitely reading from the input stream,
 390      * or writing to the output stream. The behavior for the case where
 391      * the input and/or output stream is asynchronously closed,
 392      * or the thread interrupted during the transfer, is highly input
 393      * and output stream specific, and therefore not specified.
 394      * &lt;p&gt;
 395      * If an I/O error occurs reading from the input stream or
 396      * writing to the output stream, then it may do so after some bytes
 397      * have been read or written. Consequently the input stream
 398      * may not be at end of stream and one, or both, streams may be
 399      * in an inconsistent state. It is strongly recommended that both streams
 400      * be promptly closed if an I/O error occurs.
 401      *
 402      * @param source an InputStream to read from, the stream not closed and
 403      *               is at end-of-file.
 404      * @return this HexPrinter
 405      * @throws java.io.UncheckedIOException if an I/O error occurs
 406      */
 407     public HexPrinter format(InputStream source) {
 408         return format(source, 0);
 409     }
 410 
 411     /**
 412      * Format an InputStream and supply the initial offset.
 413      *
 414      * @param source an InputStream
 415      * @param offset an offset
 416      * @return this HexPrinter
 417      */
 418     private HexPrinter format(InputStream source, int offset) {
 419         Objects.requireNonNull(source, &quot;InputStream must be non-null&quot;);
 420         try (AnnotationWriter writer =
 421                      new AnnotationWriter(this, source, offset, dest)) {
 422             writer.flush();
 423             return this;
 424         }
 425     }
 426 
 427     /**
 428      * The formatter function is called for the range of the ByteBuffer&#39;s contents.
 429      * All annotation output is appended and flushed to the output destination.
 430      * The ByteBuffer position is not used and not modified.
 431      *
 432      * @param source a ByteBuffer
 433      * @param index the index in the ByteBuffer, must be non-negative and
 434      *              less than {@code limit()}.
 435      * @param length the length in the ByteBuffer must be non-negative and
 436      *               no larger than {@code source.limit() - index}
 437      * @return this HexPrinter
 438      * @throws java.io.UncheckedIOException if an I/O error occurs
 439      * @throws java.lang.IndexOutOfBoundsException if the preconditions on
 440      *          {@code index} and {@code length} do not hold
 441      */
 442     public HexPrinter format(ByteBuffer source, int index, int length) {
 443         Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
 444         byte[] bytes = new byte[length];
 445         source.get(index, bytes, 0, length);
 446         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
 447         return format(bais, index);
 448     }
 449 
 450     /**
 451      * The formatter function is called for the ByteBuffer&#39;s contents.
 452      * The source bytes are from the {@code ByteBuffer.position()}
 453      * to the {@code ByteBuffer.limit()}.
 454      * The position is not modified.
 455      * All output is appended and flushed to the destination.
 456      *
 457      * @param source a ByteBuffer
 458      * @return this HexPrinter
 459      * @throws java.io.UncheckedIOException if an I/O error occurs
 460      */
 461     public HexPrinter format(ByteBuffer source) {
 462         return format(source, source.position(), source.limit() - source.position());
 463     }
 464 
 465     /**
 466      * The formatter function is called repeatedly to read all of the bytes
 467      * and return a String.
 468      *
 469      * @param source a non-null array of bytes.
 470      * @return the output as a non-null {@code String}
 471      * @throws java.io.UncheckedIOException if an I/O error occurs
 472      */
 473     public String toString(byte[] source) {
 474         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 475         return toString(new ByteArrayInputStream(source));
 476     }
 477 
 478     /**
 479      * The formatter function is called repeatedly to read the bytes from offset
 480      * for length and return a String.
 481      * Only {@code length} bytes starting at the {@code offset} are formatted.
 482      *
 483      * @param source a non-null array of bytes.
 484      * @param offset the offset into the array to start
 485      * @param length the length of bytes in the array to format
 486      * @return the output as a non-null {@code String}
 487      * @throws java.io.UncheckedIOException if an I/O error occurs
 488      */
 489     public String toString(byte[] source, int offset, int length) {
 490         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 491         StringBuilder sb = new StringBuilder();
 492         try (AnnotationWriter writer =
 493                      new AnnotationWriter(this, new ByteArrayInputStream(source, offset, length),
 494                              offset, sb)) {
 495             writer.flush();
 496             return sb.toString();
 497         }
 498     }
 499 
 500     /**
 501      * The formatter function is called repeatedly to read all of the bytes
 502      * and return a String.
 503      * &lt;p&gt;
 504      * The {@code toString} method invokes the formatter to read bytes from the
 505      * source and append the formatted sequence of byte values.
 506      * As the bytes are read they are printed using the {@link #withBytesFormat}
 507      * to fill the second field of the line.
 508      * The output of the {@code formatter} fills the annotation field.
 509      * A new line is started when either the byte values or annotation
 510      * is filled to its respective width. The offset of the first byte on the line
 511      * is inserted at the beginning of each line using {@link #withOffsetFormat(String)}.
 512      * &lt;p&gt;
 513      * This method may block indefinitely reading from the input stream,
 514      * or writing to the output stream. The behavior for the case where
 515      * the input and/or output stream is asynchronously closed,
 516      * or the thread interrupted during the transfer, is highly input
 517      * and output stream specific, and therefore not specified.
 518      * &lt;p&gt;
 519      * If an I/O error occurs reading from the input stream or
 520      * writing to the output stream, then it may do so after some bytes
 521      * have been read or written. Consequently the input stream
 522      * may not be at end of stream and one, or both, streams may be
 523      * in an inconsistent state. It is strongly recommended that both streams
 524      * be promptly closed if an I/O error occurs.
 525      *
 526      * @param source an InputStream to read from, the stream not closed and
 527      *               is at end-of-file upon return.
 528      * @return the output as a non-null {@code String}
 529      * @throws java.io.UncheckedIOException if an I/O error occurs
 530      */
 531     public String toString(InputStream source) {
 532         Objects.requireNonNull(source, &quot;InputStream must be non-null&quot;);
 533         StringBuilder sb = new StringBuilder();
 534         try (AnnotationWriter writer =
 535                      new AnnotationWriter(this, source, 0, sb)) {
 536             writer.flush();
 537             return sb.toString();
 538         }
 539     }
 540 
 541     /**
 542      * The formatter function is called for the range of the ByteBuffer contents
 543      * and returned as a string.
 544      * The ByteBuffer position is not used and not modified.
 545      *
 546      * @param source a ByteBuffer
 547      * @param index the index in the ByteBuffer, must be non-negative and
 548      *              less than {@code limit()}.
 549      * @param length the length in the ByteBuffer must be non-negative and
 550      *               no larger than {@code source.limit() - index}
 551      * @return the output as a non-null {@code String}
 552      * @throws java.io.UncheckedIOException if an I/O error occurs
 553      * @throws java.lang.IndexOutOfBoundsException if the preconditions on
 554      *          {@code index} and {@code length} do not hold
 555      */
 556     public String toString(ByteBuffer source, int index, int length) {
 557         Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
 558         byte[] bytes = new byte[length];
 559         source.get(index, bytes, 0, length);
 560         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
 561         StringBuilder sb = new StringBuilder();
 562         try (AnnotationWriter writer =
 563                      new AnnotationWriter(this, bais, index, sb)) {
 564             writer.flush();
 565             return sb.toString();
 566         }
 567     }
 568 
 569     /**
 570      * The formatter function is called for the ByteBuffer contents
 571      * and returned as a string.
 572      * The source bytes are from the {@code ByteBuffer.position()}
 573      * to the {@code ByteBuffer.limit()}.
 574      * The position is not modified.
 575      *
 576      * @param source a ByteBuffer
 577      * @return the output as a non-null {@code String}
 578      * @throws java.io.UncheckedIOException if an I/O error occurs
 579      */
 580     public String toString(ByteBuffer source) {
 581         return toString(source, source.position(), source.limit() - source.position());
 582     }
 583 
 584     /**
 585      * Returns a new HexPrinter setting the format for the byte offset.
 586      * The format string is specified by {@link String#format String format}
 587      * including any delimiters. For example, {@code &quot;%3x: &quot;}.
 588      * If the format is an empty string, there is no offset in the output.
 589      *
 590      * @param offsetFormat a new format string for the byte offset.
 591      * @return a new HexPrinter
 592      */
 593     public HexPrinter withOffsetFormat(String offsetFormat) {
 594         Objects.requireNonNull(offsetFormat, &quot;offsetFormat&quot;);
 595         return new HexPrinter(annoFormatter, offsetFormat, bytesFormat, bytesCount,
 596                 annoDelim, annoWidth, lineSeparator, dest);
 597     }
 598 
 599     /**
 600      * Returns a new HexPrinter setting the format for each byte value and
 601      * the maximum number of byte values per line.
 602      * The format string is specified by {@link String#format String format},
 603      * including any delimiters or padding. For example, {@code &quot;%02x &quot;}.
 604      * If the byteFormat is an empty String, there are no byte values in the output.
 605      *
 606      * @param byteFormat a format string for each byte
 607      * @param bytesCount the maximum number of byte values per line
 608      * @return a new HexPrinter
 609      */
 610     public HexPrinter withBytesFormat(String byteFormat, int bytesCount) {
 611         Objects.requireNonNull(bytesFormat, &quot;bytesFormat&quot;);
 612         return new HexPrinter(annoFormatter, offsetFormat, byteFormat, bytesCount,
 613                 annoDelim, annoWidth, lineSeparator, dest);
 614     }
 615 
 616     /**
 617      * Returns a new HexPrinter setting the line separator.
 618      * The line separator can be set to an empty string or to
 619      * a string to be added at the end of each line.  It should include the line
 620      * separator {@link System#lineSeparator()} if a line break is to be output.
 621      *
 622      * @param separator the line separator
 623      * @return a new HexPrinter
 624      */
 625     public HexPrinter withLineSeparator(String separator) {
 626         return new HexPrinter(annoFormatter, offsetFormat, bytesFormat, bytesCount,
 627                 annoDelim, annoWidth, separator, dest);
 628     }
 629 
 630     /**
 631      * Returns a new HexPrinter setting the formatter.
 632      * The widths, delimiters and other parameters are unchanged.
 633      *
 634      * @param formatter a non-null Formatter
 635      * @return a new HexPrinter
 636      */
 637     public HexPrinter formatter(Formatter formatter) {
 638         Objects.requireNonNull(formatter, &quot;Formatter must be non-null&quot;);
 639         return new HexPrinter(formatter, offsetFormat, bytesFormat, bytesCount,
 640                 annoDelim, annoWidth, lineSeparator, dest);
 641     }
 642 
 643     /**
 644      * Returns a new HexPrinter setting the formatter, delimiter, and width of the annotation.
 645      * Note: The annotations may exceed the width.
 646      *
 647      * @param formatter a non-null Formatter
 648      * @param delim     a string delimiter for the annotation
 649      * @param width     the width of the annotation, non-negative
 650      * @return a new HexPrinter
 651      */
 652     public HexPrinter formatter(Formatter formatter, String delim, int width) {
 653         Objects.requireNonNull(formatter, &quot;formatter&quot;);
 654         Objects.requireNonNull(delim, &quot;delim&quot;);
 655         return new HexPrinter(formatter, offsetFormat, bytesFormat, bytesCount,
 656                 delim, width, lineSeparator, dest);
 657     }
 658 
 659     /**
 660      * Returns a new HexPrinter setting the formatter to format a primitive type
 661      * using the format string.
 662      * The format string should include any pre or post spacing and delimiters.
 663      * &lt;p&gt;
 664      * This is a convenience function equivalent to finding a formatter using
 665      * {@link HexPrinter.Formatters#ofPrimitive}.
 666      * &lt;/p&gt;
 667      *
 668      * @param primClass a primitive class, for example, {@code int.class}
 669      * @param fmtString a {@link java.util.Formatter format string}.
 670      * @return a new HexPrinter
 671      * @throws IllegalArgumentException if the class is not a primitive class
 672      */
 673     public HexPrinter formatter(Class&lt;?&gt; primClass, String fmtString) {
 674         Formatter formatter = getFormatter(primClass, fmtString);
 675         return new HexPrinter(formatter, offsetFormat, bytesFormat, bytesCount,
 676                 annoDelim, annoWidth, lineSeparator, dest);
 677     }
 678 
 679     /**
 680      * Returns a formatter for the primitive type using the format string.
 681      * The formatter reads a value of the primitive type from the stream
 682      * and formats it using the format string.
 683      * The format string includes any pre or post spacing and delimiters.
 684      *
 685      * @param primClass a primitive class, for example, {@code int.class}
 686      * @param fmtString a {@link java.util.Formatter format string}
 687      * @return a Formatter for the primitive type using the format string
 688      */
 689     static Formatter getFormatter(Class&lt;?&gt; primClass, String fmtString) {
 690         return new PrimitiveFormatter(primClass, fmtString);
 691     }
 692 
 693     /**
 694      * Returns a string describing this HexPrinter.
 695      * The string indicates the type of the destination and
 696      * the formatting options.
 697      *
 698      * @return a String describing this HexPrinter
 699      */
 700     public String toString() {
 701         return &quot;formatter: &quot; + annoFormatter
 702                 + &quot;, dest: &quot; + dest.getClass().getName()
 703                 + &quot;, offset: \&quot;&quot; + offsetFormat
 704                 + &quot;\&quot;, bytes: &quot; + bytesCount
 705                 + &quot; x \&quot;&quot; + bytesFormat + &quot;\&quot;&quot;
 706                 + &quot;, delim: \&quot;&quot; + annoDelim + &quot;\&quot;&quot;
 707                 + &quot;, width: &quot; + annoWidth
 708                 + &quot;, nl: \&quot;&quot; + expand(lineSeparator) + &quot;\&quot;&quot;;
 709     }
 710 
 711     private String expand(String sep) {
 712         return sep.replace(&quot;\n&quot;, &quot;\\n&quot;)
 713                 .replace(&quot;\r&quot;, &quot;\\r&quot;);
 714     }
 715 
 716     private static class PrimitiveFormatter implements Formatter {
 717 
 718         private final Class&lt;?&gt; primClass;
 719         private final String fmtString;
 720 
 721         PrimitiveFormatter(Class&lt;?&gt; primClass, String fmtString) {
 722             Objects.requireNonNull(primClass, &quot;primClass&quot;);
 723             Objects.requireNonNull(fmtString, &quot;fmtString&quot;);
 724             if (!primClass.isPrimitive())
 725                 throw new IllegalArgumentException(&quot;Not a primitive type: &quot; + primClass.getName());
 726             this.primClass = primClass;
 727             this.fmtString = fmtString;
 728         }
 729 
 730         public void annotate(DataInputStream in, Appendable out) throws IOException {
 731             if (primClass == byte.class) {
 732                 int v = in.readByte();
 733                 out.append(String.format(fmtString, v));
 734             } else if (primClass == boolean.class) {
 735                 boolean v = in.readByte() != 0;
 736                 out.append(String.format(fmtString, v));
 737             } else if (primClass == short.class | primClass == char.class) {
 738                 int v = in.readShort();
 739                 out.append(String.format(fmtString, v));
 740             } else if (primClass == float.class) {
 741                 float v = in.readFloat();
 742                 out.append(String.format(fmtString, v));
 743             } else if (primClass == int.class) {
 744                 int v = in.readInt();
 745                 out.append(String.format(fmtString, v));
 746             } else if (primClass == double.class) {
 747                 double v = in.readDouble();
 748                 out.append(String.format(fmtString, v));
 749             } else if (primClass == long.class) {
 750                 long v = in.readLong();
 751                 out.append(String.format(fmtString, v));
 752             } else {
 753                 throw new AssertionError(&quot;missing case on primitive class&quot;);
 754             }
 755         }
 756 
 757         public String toString() {
 758             return &quot;(&quot; + primClass.getName() + &quot;, \&quot;&quot; + fmtString + &quot;\&quot;)&quot;;
 759         }
 760     }
 761 
 762     /**
 763      * Formatter function reads bytes from a stream and
 764      * appends a readable annotation to the output destination.
 765      * &lt;p&gt;
 766      * Each invocation of the {@link #annotate annotate} method reads and annotates
 767      * a single instance of its protocol or data type.
 768      * &lt;p&gt;
 769      * Built-in formatting functions are provided in the {@link Formatters} class.
 770      * &lt;p&gt;
 771      * As described by the {@link HexPrinter#toString(InputStream)} method,
 772      * the {@link #annotate annotate} method is called to read bytes and produce
 773      * the descriptive annotation.
 774      * &lt;p&gt;
 775      * For example, a custom lambda formatter to read a float value (4 bytes) and
 776      * print as a floating number could be written as a static method.
 777      * &lt;pre&gt;{@code
 778      *     // Format 4 bytes read from the input as a float 3.4.
 779      *     static void annotate(DataInputStream in, Appendable out) throws IOException {
 780      *         float f = in.readFloat();
 781      *         out.append(String.format(&quot;%3.4f, &quot;, f));
 782      *     }
 783      *
 784      *     byte[] bytes = new byte[] {00 00 00 00 3f 80 00 00 40 00 00 00 40 40 00 00};
 785      *     HexPrinter pp = HexPrinter.simple()
 786      *         .withBytesFormat(&quot;%02x &quot;, 8)
 787      *         .formatter(Example::annotate)
 788      *         .format(bytes);
 789      *
 790      * Result:
 791      *     0: 00 00 00 00 3f 80 00 00  // 0.0000, 1.0000,
 792      *     8: 40 00 00 00 40 40 00 00  // 2.0000, 3.0000,
 793      * }&lt;/pre&gt;
 794      *
 795      * &lt;p&gt;
 796      * The details of the buffering and calling of the formatter {@code annotate}
 797      * methods is roughly as follows.
 798      * The bytes read by the {@code annotate} method are logically buffered
 799      * for each line of output.
 800      * The {@code annotate} method writes its description of the bytes read
 801      * to the output, this output is also buffered.
 802      * When the number of bytes read exceeds the
 803      * {@link #withBytesFormat(String, int) byte values count per line},
 804      * the buffered output exceeds the
 805      * {@link #formatter(Formatter, String, int) width of the annotation field},
 806      * or a new line {@code &quot;\n&quot;} character is found in the output then
 807      * a line of output is assembled and written to the destination Appendable.
 808      * The formatter&#39;s {@code annotate} method is called repeatedly
 809      * until the input is completely consumed or an exception is thrown.
 810      * Any remaining buffered bytes or description are flushed to the destination Appendable.
 811      */
 812     @FunctionalInterface
 813     public interface Formatter {
 814 
 815         /**
 816          * Read bytes from the input stream and append a descriptive annotation
 817          * to the output destination.
 818          *
 819          * @param in  a DataInputStream
 820          * @param out an Appendable for the output
 821          * @throws IOException if an I/O error occurs
 822          */
 823         void annotate(DataInputStream in, Appendable out) throws IOException;
 824     }
 825 
 826     /**
 827      * Built-in formatters for printable byte, ASCII byte, UTF-8 and primitive types.
 828      * Formatters for primitive types and different formatting options
 829      * can be found by calling {@link #ofPrimitive(Class, String)}.
 830      */
 831     public enum Formatters implements Formatter {
 832         /**
 833          * Read a byte, return the value as a single character string
 834          * if it is printable, otherwise return &quot;.&quot;.
 835          */
 836         PRINTABLE,
 837         /**
 838          * Read a byte and return it as a string.
 839          * Return the character if it is ASCII, return its mnemonic if it
 840          * is a control character, otherwise return its decimal value as a string.
 841          */
 842         ASCII,
 843         /**
 844          * Read a modified UTF-8 string and write it.
 845          */
 846         UTF8,
 847         /**
 848          * Read a byte and write nothing.
 849          */
 850         NONE;
 851 
 852         public void annotate(DataInputStream in, Appendable out) throws IOException {
 853             switch (this) {
 854                 case PRINTABLE -&gt; bytePrintable(in, out);
 855                 case ASCII -&gt; byteASCII(in, out);
 856                 case UTF8 -&gt; utf8Parser(in, out);
 857                 case NONE -&gt; byteNoneParser(in, out);
 858             }
 859         }
 860 
 861         /**
 862          * Read a byte and return it as a single character string if it is printable,
 863          * otherwise return &quot;.&quot;.
 864          *
 865          * @param in  a DataInputStream
 866          * @param out an Appendable to write to
 867          * @throws IOException if an I/O error occurs
 868          */
 869         static void bytePrintable(DataInputStream in, Appendable out) throws IOException {
 870             int v = in.readUnsignedByte();
 871             if (!Character.isISOControl(v) &amp;&amp; v &lt; 127) {
 872                 out.append((char) v);
 873             } else {
 874                 out.append(&#39;.&#39;);
 875             }
 876         }
 877 
 878         /**
 879          * Read a byte and return it as a string.
 880          * Append the byte if it is ASCII, its mnemonic if it
 881          * is a control character, and otherwise its decimal value.
 882          *
 883          * @param in  a DataInputStream
 884          * @param out an Appendable to write to
 885          * @throws IOException if an I/O error occurs
 886          */
 887         static void byteASCII(DataInputStream in, Appendable out) throws IOException {
 888             int v = in.readUnsignedByte();
 889             if (v &lt; 32) {
 890                 out.append(&#39;\\&#39;).append(CONTROL_MNEMONICS[v]);
 891             } else if (v &lt; 127) {
 892                 out.append((char) v);
 893             } else {
 894                 out.append(&#39;\\&#39;).append(Integer.toString(v, 10));
 895             }
 896         }
 897 
 898         /**
 899          * Read a modified UTF-8 string and write it to the output destination.
 900          *
 901          * @param in  a DataInputStream
 902          * @param out an Appendable to write the output to
 903          * @throws IOException if an I/O error occurs
 904          */
 905         static void utf8Parser(DataInputStream in, Appendable out) throws IOException {
 906             out.append(in.readUTF()).append(&quot; &quot;);
 907         }
 908 
 909         /**
 910          * Read a a byte and write nothing.
 911          *
 912          * @param in  a DataInputStream
 913          * @param out an Appendable to write the output to
 914          * @throws IOException if an I/O error occurs
 915          */
 916         static void byteNoneParser(DataInputStream in, Appendable out) throws IOException {
 917             in.readByte();
 918         }
 919 
 920         /**
 921          * Returns a {@code Formatter} for a primitive using the format string.
 922          * The format string includes any pre or post spacing or delimiters.
 923          * A value of the primitive is read using the type specific methods
 924          * of {@link DataInputStream}, formatted using the format string, and
 925          * written to the output.
 926          *
 927          * @param primClass a primitive class, for example, {@code int.class}
 928          * @param fmtString a {@link java.util.Formatter format string}.
 929          * @return a Formatter
 930          */
 931         public static Formatter ofPrimitive(Class&lt;?&gt; primClass, String fmtString) {
 932             Objects.requireNonNull(primClass, &quot;primClass&quot;);
 933             Objects.requireNonNull(fmtString, &quot;fmtString&quot;);
 934             return new PrimitiveFormatter(primClass, fmtString);
 935         }
 936     }
 937 
 938     /**
 939      * Internal implementation of the annotation output and processor of annotated output.
 940      * Created for each new input source and discarded after each use.
 941      * An OffsetInputStream is created to buffer and count the input bytes.
 942      *
 943      */
 944     private static final class AnnotationWriter extends CharArrayWriter {
 945         private final transient OffsetInputStream source;
 946         private final transient DataInputStream in;
 947         private final transient int baseOffset;
 948         private final transient HexPrinter params;
 949         private final transient int bytesColWidth;
 950         private final transient int annoWidth;
 951         private final transient Appendable dest;
 952 
 953         /**
 954          * Construct a new AnnotationWriter to process the source into the destination.
 955          * Initializes the DataInputStream and marking of the input to keep track
 956          * of bytes as they are read by the formatter.
 957          * @param params formatting parameters
 958          * @param source source InputStream
 959          * @param baseOffset initial offset
 960          * @param dest destination Appendable
 961          */
 962         AnnotationWriter(HexPrinter params, InputStream source, int baseOffset, Appendable dest) {
 963             this.params = params;
 964             this.baseOffset = baseOffset;
 965             Objects.requireNonNull(source, &quot;Source is null&quot;);
 966             this.source = new OffsetInputStream(source);
 967             this.source.mark(1024);
 968             this.in = new DataInputStream(this.source);
 969             this.bytesColWidth = params.bytesCount * String.format(params.bytesFormat, 255).length();
 970             this.annoWidth = params.annoWidth;
 971             this.dest = dest;
 972         }
 973 
 974         @Override
 975         public void write(int c) {
 976             super.write(c);
 977             checkFlush();
 978         }
 979 
 980         @Override
 981         public void write(char[] c, int off, int len) {
 982             super.write(c, off, len);
 983             for (int i = 0; i &lt; len; i++) {
 984                 if (c[off+i] == &#39;\n&#39;) {
 985                     process();
 986                     return;
 987                 }
 988             }
 989             checkFlush();
 990         }
 991 
 992         @Override
 993         public void write(String str, int off, int len) {
 994             super.write(str, off, len);
 995             if (str.indexOf(&#39;\n&#39;) &gt;=0 )
 996                 process();
 997             else
 998                 checkFlush();
 999         }
1000 
1001         private void checkFlush() {
1002             if (size() &gt; annoWidth)
1003                 process();
1004         }
1005 
1006         /**
1007          * The annotation printing function is called repeatedly to read all of the bytes
1008          * in the source stream and annotate the stream.
1009          * The annotated output is appended to the output dest or buffered.
1010          * &lt;p&gt;
1011          *     The HexPrinter is not closed and can be used as a template
1012          *     to create a new formatter with a new Source or different formatting
1013          *     options.
1014          * &lt;/p&gt;
1015          */
1016         @Override
1017         public void flush() {
1018             try {
1019                 while (true) {
1020                     if (source.markedByteCount() &gt;= params.bytesCount)
1021                         process();
1022                     params.annoFormatter.annotate(in, this);
1023                     if (source.markedByteCount() &gt; 256) {
1024                         // Normally annotations would cause processing more often
1025                         // Guard against overrunning the mark/reset buffer.
1026                         process();
1027                     }
1028                 }
1029             } catch (IOException ioe) {
1030                 process();
1031                 if (!(ioe instanceof EOFException)) {
1032                     throw new UncheckedIOException(ioe);
1033                 }
1034             } catch (UncheckedIOException uio) {
1035                 process();      // clear out the buffers
1036                 throw uio;
1037             }
1038         }
1039 
1040         /**
1041          * Merge the buffered stream of annotations with the formatted bytes
1042          * and append them to the dest.
1043          * &lt;p&gt;
1044          * The annotation mapping function has read some bytes and buffered
1045          * some output that corresponds to those bytes.
1046          * The un-formatted bytes are in the OffsetInputStream after the mark.
1047          * The stream is reset and the bytes are read again.
1048          * Each line of the produced one line at a time to the dest.
1049          * The byte offset is formatted according to the offsetFormat.
1050          * The bytes after the mark are read and formatted using the bytesFormat
1051          * and written to the dest up to the bytesWidth.
1052          * The annotation stream is appended to the dest, but only up to the
1053          * first newline (if any). The alignment between the annotated stream
1054          * and the formatted bytes is approximate.
1055          * New line characters in the annotation cause a new line to be started
1056          * without regard to the number of formatted bytes. The column of formatted
1057          * bytes may be incomplete.
1058          */
1059         private void process() {
1060             String info = toString();
1061             reset();
1062             int count = source.markedByteCount();
1063             try {
1064                 source.reset();
1065                 long binColOffset = source.byteOffset();
1066                 while (count &gt; 0 || info.length() &gt; 0) {
1067                     dest.append(String.format(params.offsetFormat, binColOffset + baseOffset));
1068                     int colWidth = 0;
1069                     int byteCount = Math.min(params.bytesCount, count);
1070                     for (int i = 0; i &lt; byteCount; i++) {
1071                         int b = source.read();
1072                         if (b == -1)
1073                             throw new IllegalStateException(&quot;BUG&quot;);
1074                         String s = String.format(params.bytesFormat, b);
1075                         colWidth += s.length();
1076                         dest.append(s);
1077                     }
1078                     binColOffset += byteCount;
1079                     count -= byteCount;
1080 
1081                     // Pad out the bytes column to its width
1082                     dest.append(&quot; &quot;.repeat(Math.max(0, bytesColWidth - colWidth)));
1083                     dest.append(params.annoDelim);
1084 
1085                     // finish a line and prepare for next line
1086                     // Add a line from annotation buffer
1087                     if (info.length() &gt; 0) {
1088                         int nl = info.indexOf(&#39;\n&#39;);
1089                         if (nl &lt; 0) {
1090                             dest.append(info);
1091                             info = &quot;&quot;;
1092                         } else {
1093                             dest.append(info, 0, nl);
1094                             info = info.substring(nl + 1);
1095                         }
1096                     }
1097                     dest.append(params.lineSeparator);
1098                 }
1099             } catch (IOException ioe) {
1100                 try {
1101                     dest.append(&quot;\nIOException during annotations: &quot;)
1102                         .append(ioe.getMessage())
1103                         .append(&quot;\n&quot;);
1104                 } catch (IOException ignore) {
1105                     // ignore
1106                 }
1107             }
1108             // reset the mark for the next line
1109             source.mark(1024);
1110         }
1111     }
1112 
1113     /**
1114      * Buffered InputStream that keeps track of byte offset.
1115      */
1116     private static final class OffsetInputStream extends BufferedInputStream {
1117         private long byteOffset;
1118         private long markByteOffset;
1119 
1120         OffsetInputStream(InputStream in) {
1121             super(in);
1122             byteOffset = 0;
1123             markByteOffset = 0;
1124         }
1125 
1126         long byteOffset() {
1127             return byteOffset;
1128         }
1129 
1130         @Override
1131         public void reset() throws IOException {
1132             super.reset();
1133             byteOffset = markByteOffset;
1134         }
1135 
1136         @Override
1137         public synchronized void mark(int readlimit) {
1138             super.mark(readlimit);
1139             markByteOffset = byteOffset;
1140         }
1141 
1142         int markedByteCount() {
1143             if (markpos &lt; 0)
1144                 return 0;
1145             return pos - markpos;
1146         }
1147 
1148         @Override
1149         public int read() throws IOException {
1150             int b = super.read();
1151             if (b &gt;= 0)
1152                 byteOffset++;
1153             return b;
1154         }
1155 
1156         @Override
1157         public long skip(long n) throws IOException {
1158             long size = super.skip(n);
1159             byteOffset += size;
1160             return size;
1161         }
1162 
1163         @Override
1164         public int read(byte[] b) throws IOException {
1165             int size = super.read(b);
1166             byteOffset += Math.max(size, 0);
1167             return size;
1168         }
1169 
1170         @Override
1171         public int read(byte[] b, int off, int len) throws IOException {
1172             int size = super.read(b, off, len);
1173             byteOffset += Math.max(size, 0);
1174             return size;
1175         }
1176     }
1177 }
    </pre>
  </body>
</html>
diff a/test/lib/jdk/test/lib/hexdump/HexPrinter.java b/test/lib/jdk/test/lib/hexdump/HexPrinter.java
--- a/test/lib/jdk/test/lib/hexdump/HexPrinter.java
+++ b/test/lib/jdk/test/lib/hexdump/HexPrinter.java
@@ -89,11 +89,11 @@
  * such as {@link PrintStream}, {@link StringBuilder}, or {@link Writer}.
  * <p>
  * {@linkplain Formatter Formatter} functions read and interpret the bytes to show the
  * structure and content of a protocol or data stream.
  * Built-in formatters include {@link HexPrinter#formatter(Class, String) primitives},
- * {@link Formatters#PRINTABLE printable ascii},
+ * {@link Formatters#PRINTABLE printable bytes},
  * and {@link Formatters#utf8Parser(DataInputStream, Appendable) UTF-8 strings}.
  * The {@link #formatter(Formatter, String, int) formatter} method sets the
  * formatting function, the delimiter, and the width.
  * Custom formatter functions can be implemented as a lambda, a method, an inner class, or a concrete class.
  * <p>
@@ -236,11 +236,11 @@
      * <UL>
      * <LI>byte offset format: {@code "%08x  "},
      * <LI>each byte value is formatted as 2 hex digits and a space: {@code "%02x "},
      * <LI>maximum number of byte values per line: {@value initBytesCount},
      * <LI>delimiter for the annotation: {@code "|"},
-     * <LI>formatter: {@link Formatters#ASCII ASCII bytes}, and
+     * <LI>formatter: {@link Formatters#PRINTABLE printable bytes}, and
      * <LI>line separator: "|" + {@link  System#lineSeparator()},
      * <LI>destination: {@link System#out System.out}.
      * </UL>
      * Example,
      * <pre>
@@ -252,11 +252,11 @@
      * }</pre>
      *
      * @return a new HexPrinter
      */
     public static HexPrinter canonical() {
-        return new HexPrinter(Formatters.ASCII, "%08x  ",
+        return new HexPrinter(Formatters.PRINTABLE, "%08x  ",
                 "%02x ", initBytesCount,
                 "|", 31, "|" + System.lineSeparator(),
                 System.out);
     }
 
@@ -269,11 +269,11 @@
      * <LI>each byte value is formatted as 2 hex digits and a space: {@code "%02x "},
      * <LI>maximum number of byte values per line: {@value initBytesCount},
      * <LI>delimiter for the annotation: {@code " // "},
      * <LI>width for the annotation: {@value initAnnoWidth},
      * <LI>line separator: {@link System#lineSeparator()},
-     * <LI>formatter: {@link Formatters#PRINTABLE printable ASCII}
+     * <LI>formatter: {@link Formatters#ASCII ASCII bytes}
      * showing printable characters, mnemonics for control chars, and
      * otherwise the decimal byte values,
      * <LI>destination default: {@link System#out System.out}.
      * </UL>
      * Example,
@@ -286,11 +286,11 @@
      * }</pre>
      *
      * @return a new HexPrinter
      */
     public static HexPrinter simple() {
-        return new HexPrinter(Formatters.PRINTABLE, initOffsetFormat,
+        return new HexPrinter(Formatters.ASCII, initOffsetFormat,
                 initBytesFormat, initBytesCount,
                 initAnnoDelim, initAnnoWidth, System.lineSeparator(),
                 System.out);
     }
 
@@ -303,13 +303,12 @@
      * <LI>each byte value is formatted as: {@code "(byte)%3d, "},
      * <LI>maximum number of byte values per line: {@code 8},
      * <LI>delimiter for the annotation: {@code " // "},
      * <LI>width for the annotation: {@value initAnnoWidth},
      * <LI>line separator: {@link System#lineSeparator()},
-     * <LI>formatter: {@link Formatters#PRINTABLE printable ASCII}
-     * showing printable characters, mnemonics for control chars, and
-     * otherwise the decimal byte values,
+     * <LI>formatter: {@link Formatters#PRINTABLE printable bytes}
+     * showing printable characters and otherwise ".",
      * <LI>destination default: {@link System#out System.out}.
      * </UL>
      *
      * @return a new HexPrinter
      */
@@ -424,49 +423,45 @@
             return this;
         }
     }
 
     /**
-     * The formatter function is called repeatedly to read the bytes
-     * from the offset for the length and append the output.
+     * The formatter function is called for the range of the ByteBuffer's contents.
      * All annotation output is appended and flushed to the output destination.
-     * The ByteBuffer position and limit are unused and not modified.
+     * The ByteBuffer position is not used and not modified.
      *
      * @param source a ByteBuffer
-     * @param offset the offset in the ByteBuffer
-     * @param length the length in the ByteBuffer
+     * @param index the index in the ByteBuffer, must be non-negative and
+     *              less than {@code limit()}.
+     * @param length the length in the ByteBuffer must be non-negative and
+     *               no larger than {@code source.limit() - index}
      * @return this HexPrinter
      * @throws java.io.UncheckedIOException if an I/O error occurs
+     * @throws java.lang.IndexOutOfBoundsException if the preconditions on
+     *          {@code index} and {@code length} do not hold
      */
-    public HexPrinter format(ByteBuffer source, int offset, int length) {
+    public HexPrinter format(ByteBuffer source, int index, int length) {
         Objects.requireNonNull(source, "ByteBuffer must be non-null");
-        ByteArrayInputStream bais;
-        if (source.hasArray() && !source.isReadOnly()) {
-            bais = new ByteArrayInputStream(source.array(), offset, length);
-        } else {
-            int size = source.limit() - source.position();
-            byte[] bytes = new byte[size];
-            source.get(bytes, offset, length);
-            bais = new ByteArrayInputStream(bytes);
-        }
-        return format(bais, offset);
+        byte[] bytes = new byte[length];
+        source.get(index, bytes, 0, length);
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
+        return format(bais, index);
     }
 
     /**
-     * The formatter function is called repeatedly to read all of the bytes
-     * in the source and append the output.
+     * The formatter function is called for the ByteBuffer's contents.
      * The source bytes are from the {@code ByteBuffer.position()}
      * to the {@code ByteBuffer.limit()}.
      * The position is not modified.
      * All output is appended and flushed to the destination.
      *
      * @param source a ByteBuffer
      * @return this HexPrinter
      * @throws java.io.UncheckedIOException if an I/O error occurs
      */
     public HexPrinter format(ByteBuffer source) {
-        return format(source, source.position(), source.limit());
+        return format(source, source.position(), source.limit() - source.position());
     }
 
     /**
      * The formatter function is called repeatedly to read all of the bytes
      * and return a String.
@@ -542,51 +537,50 @@
             return sb.toString();
         }
     }
 
     /**
-     * The formatter function is called repeatedly to read the bytes
-     * from the offset for the length and return a String.
-     * The ByteBuffer position and limit are unused and not modified.
+     * The formatter function is called for the range of the ByteBuffer contents
+     * and returned as a string.
+     * The ByteBuffer position is not used and not modified.
      *
      * @param source a ByteBuffer
-     * @param offset the offset in the ByteBuffer
-     * @param length the length in the ByteBuffer
+     * @param index the index in the ByteBuffer, must be non-negative and
+     *              less than {@code limit()}.
+     * @param length the length in the ByteBuffer must be non-negative and
+     *               no larger than {@code source.limit() - index}
      * @return the output as a non-null {@code String}
      * @throws java.io.UncheckedIOException if an I/O error occurs
+     * @throws java.lang.IndexOutOfBoundsException if the preconditions on
+     *          {@code index} and {@code length} do not hold
      */
-    public String toString(ByteBuffer source, int offset, int length) {
+    public String toString(ByteBuffer source, int index, int length) {
         Objects.requireNonNull(source, "ByteBuffer must be non-null");
+        byte[] bytes = new byte[length];
+        source.get(index, bytes, 0, length);
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         StringBuilder sb = new StringBuilder();
-        ByteArrayInputStream bais;
-        if (source.hasArray() && !source.isReadOnly()) {
-            bais = new ByteArrayInputStream(source.array(), offset, length);
-        } else {
-            byte[] bytes = new byte[length];
-            source.get(bytes, offset, length);
-            bais = new ByteArrayInputStream(bytes);
-        }
         try (AnnotationWriter writer =
-                     new AnnotationWriter(this, bais, offset, sb)) {
+                     new AnnotationWriter(this, bais, index, sb)) {
             writer.flush();
             return sb.toString();
         }
     }
 
     /**
-     * The formatter function is called repeatedly to read all of the bytes
-     * in the source and return a String.
+     * The formatter function is called for the ByteBuffer contents
+     * and returned as a string.
      * The source bytes are from the {@code ByteBuffer.position()}
      * to the {@code ByteBuffer.limit()}.
      * The position is not modified.
      *
      * @param source a ByteBuffer
      * @return the output as a non-null {@code String}
      * @throws java.io.UncheckedIOException if an I/O error occurs
      */
     public String toString(ByteBuffer source) {
-        return toString(source, source.position(), source.limit());
+        return toString(source, source.position(), source.limit() - source.position());
     }
 
     /**
      * Returns a new HexPrinter setting the format for the byte offset.
      * The format string is specified by {@link String#format String format}
@@ -828,22 +822,24 @@
          */
         void annotate(DataInputStream in, Appendable out) throws IOException;
     }
 
     /**
-     * Built-in formatters for printable byte, ASCII, UTF-8 and primitive types.
+     * Built-in formatters for printable byte, ASCII byte, UTF-8 and primitive types.
      * Formatters for primitive types and different formatting options
      * can be found by calling {@link #ofPrimitive(Class, String)}.
      */
     public enum Formatters implements Formatter {
         /**
-         * Read a byte and if it is ASCII write it,
-         * otherwise, write its mnemonic or its decimal value.
+         * Read a byte, return the value as a single character string
+         * if it is printable, otherwise return ".".
          */
         PRINTABLE,
         /**
-         * Read a byte, if it is ASCII write it, otherwise write a ".".
+         * Read a byte and return it as a string.
+         * Return the character if it is ASCII, return its mnemonic if it
+         * is a control character, otherwise return its decimal value as a string.
          */
         ASCII,
         /**
          * Read a modified UTF-8 string and write it.
          */
@@ -861,43 +857,43 @@
                 case NONE -> byteNoneParser(in, out);
             }
         }
 
         /**
-         * Read a byte and write it as ASCII if it is printable,
-         * print its mnemonic if it is a control character,
-         * and print its decimal value otherwise.
-         * A space separator character is appended for control and decimal values.
+         * Read a byte and return it as a single character string if it is printable,
+         * otherwise return ".".
          *
          * @param in  a DataInputStream
          * @param out an Appendable to write to
          * @throws IOException if an I/O error occurs
          */
         static void bytePrintable(DataInputStream in, Appendable out) throws IOException {
             int v = in.readUnsignedByte();
-            if (v < 32) {
-                out.append("\\").append(CONTROL_MNEMONICS[v]);
-            } else if (v < 126 && Character.isDefined(v)) {
+            if (!Character.isISOControl(v) && v < 127) {
                 out.append((char) v);
             } else {
-                out.append("\\").append(Integer.toString(v, 10));
+                out.append('.');
             }
         }
 
         /**
-         * Read a byte and write it as ASCII if it is printable, otherwise print ".".
+         * Read a byte and return it as a string.
+         * Append the byte if it is ASCII, its mnemonic if it
+         * is a control character, and otherwise its decimal value.
          *
          * @param in  a DataInputStream
          * @param out an Appendable to write to
          * @throws IOException if an I/O error occurs
          */
         static void byteASCII(DataInputStream in, Appendable out) throws IOException {
             int v = in.readUnsignedByte();
-            if (Character.isDefined(v)) {
+            if (v < 32) {
+                out.append('\\').append(CONTROL_MNEMONICS[v]);
+            } else if (v < 127) {
                 out.append((char) v);
             } else {
-                out.append('.');
+                out.append('\\').append(Integer.toString(v, 10));
             }
         }
 
         /**
          * Read a modified UTF-8 string and write it to the output destination.

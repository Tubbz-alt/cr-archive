<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/hexdump/HexPrinter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../SA/SATestUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>test/lib/jdk/test/lib/hexdump/HexPrinter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  74  * New HexPrinters with different parameters are created using an existing HexPrinter
  75  * as a template with the methods {@link #formatter(Formatter)},
  76  * {@link #withBytesFormat(String, int)}, {@link #withOffsetFormat(String)},
  77  * and {@link #withLineSeparator(String)}.
  78  * &lt;p&gt;
  79  * The source of the bytes includes byte arrays, InputStreams, and ByteBuffers.
  80  * For example, {@link #toString(InputStream)} reads the input and returns a String.
  81  * Each of the {@code toString(...)} methods immediately reads and
  82  * formats all of the bytes from the source and returns a String.
  83  * &lt;p&gt;
  84  * Each of the  {@code format(...)} methods immediately reads and
  85  * formats all of the bytes from the source and appends it to the destination.
  86  * For example, {@link #format(InputStream)} reads the input and
  87  * appends the output to {@link System#out System.out} unless the
  88  * {@link #dest(Appendable) destination} is changed to an {@link Appendable}
  89  * such as {@link PrintStream}, {@link StringBuilder}, or {@link Writer}.
  90  * &lt;p&gt;
  91  * {@linkplain Formatter Formatter} functions read and interpret the bytes to show the
  92  * structure and content of a protocol or data stream.
  93  * Built-in formatters include {@link HexPrinter#formatter(Class, String) primitives},
<span class="line-modified">  94  * {@link Formatters#PRINTABLE printable ascii},</span>
  95  * and {@link Formatters#utf8Parser(DataInputStream, Appendable) UTF-8 strings}.
  96  * The {@link #formatter(Formatter, String, int) formatter} method sets the
  97  * formatting function, the delimiter, and the width.
  98  * Custom formatter functions can be implemented as a lambda, a method, an inner class, or a concrete class.
  99  * &lt;p&gt;
 100  * The format of each line is customizable.
 101  * The {@link #withOffsetFormat(String) withOffsetFormat} method controls
 102  * the format of the byte offset.
 103  * The {@link #withBytesFormat(String, int) withBytesFormat} method controls
 104  * the printing of each byte value including the separator,
 105  * and the maximum number of byte values per line.
 106  * The offset and byte values are formatted using the familiar
 107  * {@link String#format String formats} with spacing
 108  * and delimiters included in the format string.
 109  * The {@link #withLineSeparator(String) withLineSeparator} method sets
 110  * the line separator.
 111  * &lt;p&gt;
 112  * Examples:
 113  * &lt;UL&gt;
 114  * &lt;LI&gt; Encoding bytes to a minimal string.
</pre>
<hr />
<pre>
 221      *     Result: &quot;2041420a&quot;
 222      * }&lt;/pre&gt;
 223      *
 224      * @return a new HexPrinter
 225      */
 226     public static HexPrinter minimal() {
 227         return new HexPrinter(Formatters.NONE, &quot;&quot;,
 228                 &quot;%02x&quot;, initBytesCount,
 229                 &quot;&quot;, initAnnoWidth, &quot;&quot;,
 230                 System.out);
 231     }
 232 
 233     /**
 234      * Returns a new HexPrinter setting the parameters to produce canonical output.
 235      * The parameters are set to:
 236      * &lt;UL&gt;
 237      * &lt;LI&gt;byte offset format: {@code &quot;%08x  &quot;},
 238      * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
 239      * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
 240      * &lt;LI&gt;delimiter for the annotation: {@code &quot;|&quot;},
<span class="line-modified"> 241      * &lt;LI&gt;formatter: {@link Formatters#ASCII ASCII bytes}, and</span>
 242      * &lt;LI&gt;line separator: &quot;|&quot; + {@link  System#lineSeparator()},
 243      * &lt;LI&gt;destination: {@link System#out System.out}.
 244      * &lt;/UL&gt;
 245      * Example,
 246      * &lt;pre&gt;
 247      * {@code     byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 248      *     String s = HexPrinter.canonical()
 249      *             .toString(bytes);
 250      *
 251      *     Result: &quot;00000000  20 41 42 0a                                     | AB|&quot;
 252      * }&lt;/pre&gt;
 253      *
 254      * @return a new HexPrinter
 255      */
 256     public static HexPrinter canonical() {
<span class="line-modified"> 257         return new HexPrinter(Formatters.ASCII, &quot;%08x  &quot;,</span>
 258                 &quot;%02x &quot;, initBytesCount,
 259                 &quot;|&quot;, 31, &quot;|&quot; + System.lineSeparator(),
 260                 System.out);
 261     }
 262 
 263     /**
 264      * Returns a new HexPrinter setting simple formatting parameters to output
 265      * to a multi-line string.
 266      * The parameters are set to:
 267      * &lt;UL&gt;
 268      * &lt;LI&gt;byte offset format: signed decimal width 5 and a space, {@code &quot;%5d: &quot;},
 269      * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
 270      * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
 271      * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
 272      * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
 273      * &lt;LI&gt;line separator: {@link System#lineSeparator()},
<span class="line-modified"> 274      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable ASCII}</span>
 275      * showing printable characters, mnemonics for control chars, and
 276      * otherwise the decimal byte values,
 277      * &lt;LI&gt;destination default: {@link System#out System.out}.
 278      * &lt;/UL&gt;
 279      * Example,
 280      * &lt;pre&gt;
 281      * {@code    byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 282      *    String s = HexPrinter.simple()
 283      *            .toString(bytes);
 284      *
 285      *    Result: &quot;    0: 20 41 42 0a                                      //  AB\n&quot;
 286      * }&lt;/pre&gt;
 287      *
 288      * @return a new HexPrinter
 289      */
 290     public static HexPrinter simple() {
<span class="line-modified"> 291         return new HexPrinter(Formatters.PRINTABLE, initOffsetFormat,</span>
 292                 initBytesFormat, initBytesCount,
 293                 initAnnoDelim, initAnnoWidth, System.lineSeparator(),
 294                 System.out);
 295     }
 296 
 297     /**
 298      * Returns a new HexPrinter setting formatting parameters to output
 299      * to a multi-line string as a byte array initialization for Java source.
 300      * The parameters are set to:
 301      * &lt;UL&gt;
 302      * &lt;LI&gt;byte offset format: 4 space indent: {@code &quot;    &quot;},
 303      * &lt;LI&gt;each byte value is formatted as: {@code &quot;(byte)%3d, &quot;},
 304      * &lt;LI&gt;maximum number of byte values per line: {@code 8},
 305      * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
 306      * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
 307      * &lt;LI&gt;line separator: {@link System#lineSeparator()},
<span class="line-modified"> 308      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable ASCII}</span>
<span class="line-modified"> 309      * showing printable characters, mnemonics for control chars, and</span>
<span class="line-removed"> 310      * otherwise the decimal byte values,</span>
 311      * &lt;LI&gt;destination default: {@link System#out System.out}.
 312      * &lt;/UL&gt;
 313      *
 314      * @return a new HexPrinter
 315      */
 316     public static HexPrinter source() {
 317         return new HexPrinter(Formatters.PRINTABLE, &quot;    &quot;,
 318                 &quot;(byte)%3d, &quot;, 8,
 319                 &quot; // &quot;, initAnnoWidth, System.lineSeparator(),
 320                 System.out);
 321     }
 322 
 323     /**
 324      * Returns a new HexPrinter setting the destination to the Appendable.
 325      * {@code Appendable} classes include: {@link PrintStream}, {@link Writer},
 326      * {@link StringBuilder}, and {@link StringBuffer}.
 327      *
 328      * @param dest the Appendable destination for the output, non-null
 329      * @return a new HexPrinter
 330      * @throws UncheckedIOException if an I/O error occurs
</pre>
<hr />
<pre>
 409         return format(source, 0);
 410     }
 411 
 412     /**
 413      * Format an InputStream and supply the initial offset.
 414      *
 415      * @param source an InputStream
 416      * @param offset an offset
 417      * @return this HexPrinter
 418      */
 419     private HexPrinter format(InputStream source, int offset) {
 420         Objects.requireNonNull(source, &quot;InputStream must be non-null&quot;);
 421         try (AnnotationWriter writer =
 422                      new AnnotationWriter(this, source, offset, dest)) {
 423             writer.flush();
 424             return this;
 425         }
 426     }
 427 
 428     /**
<span class="line-modified"> 429      * The formatter function is called repeatedly to read the bytes</span>
<span class="line-removed"> 430      * from the offset for the length and append the output.</span>
 431      * All annotation output is appended and flushed to the output destination.
<span class="line-modified"> 432      * The ByteBuffer position and limit are unused and not modified.</span>
 433      *
 434      * @param source a ByteBuffer
<span class="line-modified"> 435      * @param offset the offset in the ByteBuffer</span>
<span class="line-modified"> 436      * @param length the length in the ByteBuffer</span>


 437      * @return this HexPrinter
 438      * @throws java.io.UncheckedIOException if an I/O error occurs


 439      */
<span class="line-modified"> 440     public HexPrinter format(ByteBuffer source, int offset, int length) {</span>
 441         Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
<span class="line-modified"> 442         ByteArrayInputStream bais;</span>
<span class="line-modified"> 443         if (source.hasArray() &amp;&amp; !source.isReadOnly()) {</span>
<span class="line-modified"> 444             bais = new ByteArrayInputStream(source.array(), offset, length);</span>
<span class="line-modified"> 445         } else {</span>
<span class="line-removed"> 446             int size = source.limit() - source.position();</span>
<span class="line-removed"> 447             byte[] bytes = new byte[size];</span>
<span class="line-removed"> 448             source.get(bytes, offset, length);</span>
<span class="line-removed"> 449             bais = new ByteArrayInputStream(bytes);</span>
<span class="line-removed"> 450         }</span>
<span class="line-removed"> 451         return format(bais, offset);</span>
 452     }
 453 
 454     /**
<span class="line-modified"> 455      * The formatter function is called repeatedly to read all of the bytes</span>
<span class="line-removed"> 456      * in the source and append the output.</span>
 457      * The source bytes are from the {@code ByteBuffer.position()}
 458      * to the {@code ByteBuffer.limit()}.
 459      * The position is not modified.
 460      * All output is appended and flushed to the destination.
 461      *
 462      * @param source a ByteBuffer
 463      * @return this HexPrinter
 464      * @throws java.io.UncheckedIOException if an I/O error occurs
 465      */
 466     public HexPrinter format(ByteBuffer source) {
<span class="line-modified"> 467         return format(source, source.position(), source.limit());</span>
 468     }
 469 
 470     /**
 471      * The formatter function is called repeatedly to read all of the bytes
 472      * and return a String.
 473      *
 474      * @param source a non-null array of bytes.
 475      * @return the output as a non-null {@code String}
 476      * @throws java.io.UncheckedIOException if an I/O error occurs
 477      */
 478     public String toString(byte[] source) {
 479         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 480         return toString(new ByteArrayInputStream(source));
 481     }
 482 
 483     /**
 484      * The formatter function is called repeatedly to read the bytes from offset
 485      * for length and return a String.
 486      * Only {@code length} bytes starting at the {@code offset} are formatted.
 487      *
</pre>
<hr />
<pre>
 527      * may not be at end of stream and one, or both, streams may be
 528      * in an inconsistent state. It is strongly recommended that both streams
 529      * be promptly closed if an I/O error occurs.
 530      *
 531      * @param source an InputStream to read from, the stream not closed and
 532      *               is at end-of-file upon return.
 533      * @return the output as a non-null {@code String}
 534      * @throws java.io.UncheckedIOException if an I/O error occurs
 535      */
 536     public String toString(InputStream source) {
 537         Objects.requireNonNull(source, &quot;InputStream must be non-null&quot;);
 538         StringBuilder sb = new StringBuilder();
 539         try (AnnotationWriter writer =
 540                      new AnnotationWriter(this, source, 0, sb)) {
 541             writer.flush();
 542             return sb.toString();
 543         }
 544     }
 545 
 546     /**
<span class="line-modified"> 547      * The formatter function is called repeatedly to read the bytes</span>
<span class="line-modified"> 548      * from the offset for the length and return a String.</span>
<span class="line-modified"> 549      * The ByteBuffer position and limit are unused and not modified.</span>
 550      *
 551      * @param source a ByteBuffer
<span class="line-modified"> 552      * @param offset the offset in the ByteBuffer</span>
<span class="line-modified"> 553      * @param length the length in the ByteBuffer</span>


 554      * @return the output as a non-null {@code String}
 555      * @throws java.io.UncheckedIOException if an I/O error occurs


 556      */
<span class="line-modified"> 557     public String toString(ByteBuffer source, int offset, int length) {</span>
 558         Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);



 559         StringBuilder sb = new StringBuilder();
<span class="line-removed"> 560         ByteArrayInputStream bais;</span>
<span class="line-removed"> 561         if (source.hasArray() &amp;&amp; !source.isReadOnly()) {</span>
<span class="line-removed"> 562             bais = new ByteArrayInputStream(source.array(), offset, length);</span>
<span class="line-removed"> 563         } else {</span>
<span class="line-removed"> 564             byte[] bytes = new byte[length];</span>
<span class="line-removed"> 565             source.get(bytes, offset, length);</span>
<span class="line-removed"> 566             bais = new ByteArrayInputStream(bytes);</span>
<span class="line-removed"> 567         }</span>
 568         try (AnnotationWriter writer =
<span class="line-modified"> 569                      new AnnotationWriter(this, bais, offset, sb)) {</span>
 570             writer.flush();
 571             return sb.toString();
 572         }
 573     }
 574 
 575     /**
<span class="line-modified"> 576      * The formatter function is called repeatedly to read all of the bytes</span>
<span class="line-modified"> 577      * in the source and return a String.</span>
 578      * The source bytes are from the {@code ByteBuffer.position()}
 579      * to the {@code ByteBuffer.limit()}.
 580      * The position is not modified.
 581      *
 582      * @param source a ByteBuffer
 583      * @return the output as a non-null {@code String}
 584      * @throws java.io.UncheckedIOException if an I/O error occurs
 585      */
 586     public String toString(ByteBuffer source) {
<span class="line-modified"> 587         return toString(source, source.position(), source.limit());</span>
 588     }
 589 
 590     /**
 591      * Returns a new HexPrinter setting the format for the byte offset.
 592      * The format string is specified by {@link String#format String format}
 593      * including any delimiters. For example, {@code &quot;%3x: &quot;}.
 594      * If the format is an empty string, there is no offset in the output.
 595      *
 596      * @param offsetFormat a new format string for the byte offset.
 597      * @return a new HexPrinter
 598      */
 599     public HexPrinter withOffsetFormat(String offsetFormat) {
 600         Objects.requireNonNull(offsetFormat, &quot;offsetFormat&quot;);
 601         return new HexPrinter(annoFormatter, offsetFormat, bytesFormat, bytesCount,
 602                 annoDelim, annoWidth, lineSeparator, dest);
 603     }
 604 
 605     /**
 606      * Returns a new HexPrinter setting the format for each byte value and
 607      * the maximum number of byte values per line.
</pre>
<hr />
<pre>
 813      * a line of output is assembled and written to the destination Appendable.
 814      * The formatter&#39;s {@code annotate} method is called repeatedly
 815      * until the input is completely consumed or an exception is thrown.
 816      * Any remaining buffered bytes or description are flushed to the destination Appendable.
 817      */
 818     @FunctionalInterface
 819     public interface Formatter {
 820 
 821         /**
 822          * Read bytes from the input stream and append a descriptive annotation
 823          * to the output destination.
 824          *
 825          * @param in  a DataInputStream
 826          * @param out an Appendable for the output
 827          * @throws IOException if an I/O error occurs
 828          */
 829         void annotate(DataInputStream in, Appendable out) throws IOException;
 830     }
 831 
 832     /**
<span class="line-modified"> 833      * Built-in formatters for printable byte, ASCII, UTF-8 and primitive types.</span>
 834      * Formatters for primitive types and different formatting options
 835      * can be found by calling {@link #ofPrimitive(Class, String)}.
 836      */
 837     public enum Formatters implements Formatter {
 838         /**
<span class="line-modified"> 839          * Read a byte and if it is ASCII write it,</span>
<span class="line-modified"> 840          * otherwise, write its mnemonic or its decimal value.</span>
 841          */
 842         PRINTABLE,
 843         /**
<span class="line-modified"> 844          * Read a byte, if it is ASCII write it, otherwise write a &quot;.&quot;.</span>


 845          */
 846         ASCII,
 847         /**
 848          * Read a modified UTF-8 string and write it.
 849          */
 850         UTF8,
 851         /**
 852          * Read a byte and write nothing.
 853          */
 854         NONE;
 855 
 856         public void annotate(DataInputStream in, Appendable out) throws IOException {
 857             switch (this) {
 858                 case PRINTABLE -&gt; bytePrintable(in, out);
 859                 case ASCII -&gt; byteASCII(in, out);
 860                 case UTF8 -&gt; utf8Parser(in, out);
 861                 case NONE -&gt; byteNoneParser(in, out);
 862             }
 863         }
 864 
 865         /**
<span class="line-modified"> 866          * Read a byte and write it as ASCII if it is printable,</span>
<span class="line-modified"> 867          * print its mnemonic if it is a control character,</span>
<span class="line-removed"> 868          * and print its decimal value otherwise.</span>
<span class="line-removed"> 869          * A space separator character is appended for control and decimal values.</span>
 870          *
 871          * @param in  a DataInputStream
 872          * @param out an Appendable to write to
 873          * @throws IOException if an I/O error occurs
 874          */
 875         static void bytePrintable(DataInputStream in, Appendable out) throws IOException {
 876             int v = in.readUnsignedByte();
<span class="line-modified"> 877             if (v &lt; 32) {</span>
<span class="line-removed"> 878                 out.append(&quot;\\&quot;).append(CONTROL_MNEMONICS[v]);</span>
<span class="line-removed"> 879             } else if (v &lt; 126 &amp;&amp; Character.isDefined(v)) {</span>
 880                 out.append((char) v);
 881             } else {
<span class="line-modified"> 882                 out.append(&quot;\\&quot;).append(Integer.toString(v, 10));</span>
 883             }
 884         }
 885 
 886         /**
<span class="line-modified"> 887          * Read a byte and write it as ASCII if it is printable, otherwise print &quot;.&quot;.</span>


 888          *
 889          * @param in  a DataInputStream
 890          * @param out an Appendable to write to
 891          * @throws IOException if an I/O error occurs
 892          */
 893         static void byteASCII(DataInputStream in, Appendable out) throws IOException {
 894             int v = in.readUnsignedByte();
<span class="line-modified"> 895             if (Character.isDefined(v)) {</span>


 896                 out.append((char) v);
 897             } else {
<span class="line-modified"> 898                 out.append(&#39;.&#39;);</span>
 899             }
 900         }
 901 
 902         /**
 903          * Read a modified UTF-8 string and write it to the output destination.
 904          *
 905          * @param in  a DataInputStream
 906          * @param out an Appendable to write the output to
 907          * @throws IOException if an I/O error occurs
 908          */
 909         static void utf8Parser(DataInputStream in, Appendable out) throws IOException {
 910             out.append(in.readUTF()).append(&quot; &quot;);
 911         }
 912 
 913         /**
 914          * Read a a byte and write nothing.
 915          *
 916          * @param in  a DataInputStream
 917          * @param out an Appendable to write the output to
 918          * @throws IOException if an I/O error occurs
</pre>
</td>
<td>
<hr />
<pre>
  74  * New HexPrinters with different parameters are created using an existing HexPrinter
  75  * as a template with the methods {@link #formatter(Formatter)},
  76  * {@link #withBytesFormat(String, int)}, {@link #withOffsetFormat(String)},
  77  * and {@link #withLineSeparator(String)}.
  78  * &lt;p&gt;
  79  * The source of the bytes includes byte arrays, InputStreams, and ByteBuffers.
  80  * For example, {@link #toString(InputStream)} reads the input and returns a String.
  81  * Each of the {@code toString(...)} methods immediately reads and
  82  * formats all of the bytes from the source and returns a String.
  83  * &lt;p&gt;
  84  * Each of the  {@code format(...)} methods immediately reads and
  85  * formats all of the bytes from the source and appends it to the destination.
  86  * For example, {@link #format(InputStream)} reads the input and
  87  * appends the output to {@link System#out System.out} unless the
  88  * {@link #dest(Appendable) destination} is changed to an {@link Appendable}
  89  * such as {@link PrintStream}, {@link StringBuilder}, or {@link Writer}.
  90  * &lt;p&gt;
  91  * {@linkplain Formatter Formatter} functions read and interpret the bytes to show the
  92  * structure and content of a protocol or data stream.
  93  * Built-in formatters include {@link HexPrinter#formatter(Class, String) primitives},
<span class="line-modified">  94  * {@link Formatters#PRINTABLE printable bytes},</span>
  95  * and {@link Formatters#utf8Parser(DataInputStream, Appendable) UTF-8 strings}.
  96  * The {@link #formatter(Formatter, String, int) formatter} method sets the
  97  * formatting function, the delimiter, and the width.
  98  * Custom formatter functions can be implemented as a lambda, a method, an inner class, or a concrete class.
  99  * &lt;p&gt;
 100  * The format of each line is customizable.
 101  * The {@link #withOffsetFormat(String) withOffsetFormat} method controls
 102  * the format of the byte offset.
 103  * The {@link #withBytesFormat(String, int) withBytesFormat} method controls
 104  * the printing of each byte value including the separator,
 105  * and the maximum number of byte values per line.
 106  * The offset and byte values are formatted using the familiar
 107  * {@link String#format String formats} with spacing
 108  * and delimiters included in the format string.
 109  * The {@link #withLineSeparator(String) withLineSeparator} method sets
 110  * the line separator.
 111  * &lt;p&gt;
 112  * Examples:
 113  * &lt;UL&gt;
 114  * &lt;LI&gt; Encoding bytes to a minimal string.
</pre>
<hr />
<pre>
 221      *     Result: &quot;2041420a&quot;
 222      * }&lt;/pre&gt;
 223      *
 224      * @return a new HexPrinter
 225      */
 226     public static HexPrinter minimal() {
 227         return new HexPrinter(Formatters.NONE, &quot;&quot;,
 228                 &quot;%02x&quot;, initBytesCount,
 229                 &quot;&quot;, initAnnoWidth, &quot;&quot;,
 230                 System.out);
 231     }
 232 
 233     /**
 234      * Returns a new HexPrinter setting the parameters to produce canonical output.
 235      * The parameters are set to:
 236      * &lt;UL&gt;
 237      * &lt;LI&gt;byte offset format: {@code &quot;%08x  &quot;},
 238      * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
 239      * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
 240      * &lt;LI&gt;delimiter for the annotation: {@code &quot;|&quot;},
<span class="line-modified"> 241      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable bytes}, and</span>
 242      * &lt;LI&gt;line separator: &quot;|&quot; + {@link  System#lineSeparator()},
 243      * &lt;LI&gt;destination: {@link System#out System.out}.
 244      * &lt;/UL&gt;
 245      * Example,
 246      * &lt;pre&gt;
 247      * {@code     byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 248      *     String s = HexPrinter.canonical()
 249      *             .toString(bytes);
 250      *
 251      *     Result: &quot;00000000  20 41 42 0a                                     | AB|&quot;
 252      * }&lt;/pre&gt;
 253      *
 254      * @return a new HexPrinter
 255      */
 256     public static HexPrinter canonical() {
<span class="line-modified"> 257         return new HexPrinter(Formatters.PRINTABLE, &quot;%08x  &quot;,</span>
 258                 &quot;%02x &quot;, initBytesCount,
 259                 &quot;|&quot;, 31, &quot;|&quot; + System.lineSeparator(),
 260                 System.out);
 261     }
 262 
 263     /**
 264      * Returns a new HexPrinter setting simple formatting parameters to output
 265      * to a multi-line string.
 266      * The parameters are set to:
 267      * &lt;UL&gt;
 268      * &lt;LI&gt;byte offset format: signed decimal width 5 and a space, {@code &quot;%5d: &quot;},
 269      * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
 270      * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
 271      * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
 272      * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
 273      * &lt;LI&gt;line separator: {@link System#lineSeparator()},
<span class="line-modified"> 274      * &lt;LI&gt;formatter: {@link Formatters#ASCII ASCII bytes}</span>
 275      * showing printable characters, mnemonics for control chars, and
 276      * otherwise the decimal byte values,
 277      * &lt;LI&gt;destination default: {@link System#out System.out}.
 278      * &lt;/UL&gt;
 279      * Example,
 280      * &lt;pre&gt;
 281      * {@code    byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 282      *    String s = HexPrinter.simple()
 283      *            .toString(bytes);
 284      *
 285      *    Result: &quot;    0: 20 41 42 0a                                      //  AB\n&quot;
 286      * }&lt;/pre&gt;
 287      *
 288      * @return a new HexPrinter
 289      */
 290     public static HexPrinter simple() {
<span class="line-modified"> 291         return new HexPrinter(Formatters.ASCII, initOffsetFormat,</span>
 292                 initBytesFormat, initBytesCount,
 293                 initAnnoDelim, initAnnoWidth, System.lineSeparator(),
 294                 System.out);
 295     }
 296 
 297     /**
 298      * Returns a new HexPrinter setting formatting parameters to output
 299      * to a multi-line string as a byte array initialization for Java source.
 300      * The parameters are set to:
 301      * &lt;UL&gt;
 302      * &lt;LI&gt;byte offset format: 4 space indent: {@code &quot;    &quot;},
 303      * &lt;LI&gt;each byte value is formatted as: {@code &quot;(byte)%3d, &quot;},
 304      * &lt;LI&gt;maximum number of byte values per line: {@code 8},
 305      * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
 306      * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
 307      * &lt;LI&gt;line separator: {@link System#lineSeparator()},
<span class="line-modified"> 308      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable bytes}</span>
<span class="line-modified"> 309      * showing printable characters and otherwise &quot;.&quot;,</span>

 310      * &lt;LI&gt;destination default: {@link System#out System.out}.
 311      * &lt;/UL&gt;
 312      *
 313      * @return a new HexPrinter
 314      */
 315     public static HexPrinter source() {
 316         return new HexPrinter(Formatters.PRINTABLE, &quot;    &quot;,
 317                 &quot;(byte)%3d, &quot;, 8,
 318                 &quot; // &quot;, initAnnoWidth, System.lineSeparator(),
 319                 System.out);
 320     }
 321 
 322     /**
 323      * Returns a new HexPrinter setting the destination to the Appendable.
 324      * {@code Appendable} classes include: {@link PrintStream}, {@link Writer},
 325      * {@link StringBuilder}, and {@link StringBuffer}.
 326      *
 327      * @param dest the Appendable destination for the output, non-null
 328      * @return a new HexPrinter
 329      * @throws UncheckedIOException if an I/O error occurs
</pre>
<hr />
<pre>
 408         return format(source, 0);
 409     }
 410 
 411     /**
 412      * Format an InputStream and supply the initial offset.
 413      *
 414      * @param source an InputStream
 415      * @param offset an offset
 416      * @return this HexPrinter
 417      */
 418     private HexPrinter format(InputStream source, int offset) {
 419         Objects.requireNonNull(source, &quot;InputStream must be non-null&quot;);
 420         try (AnnotationWriter writer =
 421                      new AnnotationWriter(this, source, offset, dest)) {
 422             writer.flush();
 423             return this;
 424         }
 425     }
 426 
 427     /**
<span class="line-modified"> 428      * The formatter function is called for the range of the ByteBuffer&#39;s contents.</span>

 429      * All annotation output is appended and flushed to the output destination.
<span class="line-modified"> 430      * The ByteBuffer position is not used and not modified.</span>
 431      *
 432      * @param source a ByteBuffer
<span class="line-modified"> 433      * @param index the index in the ByteBuffer, must be non-negative and</span>
<span class="line-modified"> 434      *              less than {@code limit()}.</span>
<span class="line-added"> 435      * @param length the length in the ByteBuffer must be non-negative and</span>
<span class="line-added"> 436      *               no larger than {@code source.limit() - index}</span>
 437      * @return this HexPrinter
 438      * @throws java.io.UncheckedIOException if an I/O error occurs
<span class="line-added"> 439      * @throws java.lang.IndexOutOfBoundsException if the preconditions on</span>
<span class="line-added"> 440      *          {@code index} and {@code length} do not hold</span>
 441      */
<span class="line-modified"> 442     public HexPrinter format(ByteBuffer source, int index, int length) {</span>
 443         Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
<span class="line-modified"> 444         byte[] bytes = new byte[length];</span>
<span class="line-modified"> 445         source.get(index, bytes, 0, length);</span>
<span class="line-modified"> 446         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);</span>
<span class="line-modified"> 447         return format(bais, index);</span>






 448     }
 449 
 450     /**
<span class="line-modified"> 451      * The formatter function is called for the ByteBuffer&#39;s contents.</span>

 452      * The source bytes are from the {@code ByteBuffer.position()}
 453      * to the {@code ByteBuffer.limit()}.
 454      * The position is not modified.
 455      * All output is appended and flushed to the destination.
 456      *
 457      * @param source a ByteBuffer
 458      * @return this HexPrinter
 459      * @throws java.io.UncheckedIOException if an I/O error occurs
 460      */
 461     public HexPrinter format(ByteBuffer source) {
<span class="line-modified"> 462         return format(source, source.position(), source.limit() - source.position());</span>
 463     }
 464 
 465     /**
 466      * The formatter function is called repeatedly to read all of the bytes
 467      * and return a String.
 468      *
 469      * @param source a non-null array of bytes.
 470      * @return the output as a non-null {@code String}
 471      * @throws java.io.UncheckedIOException if an I/O error occurs
 472      */
 473     public String toString(byte[] source) {
 474         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 475         return toString(new ByteArrayInputStream(source));
 476     }
 477 
 478     /**
 479      * The formatter function is called repeatedly to read the bytes from offset
 480      * for length and return a String.
 481      * Only {@code length} bytes starting at the {@code offset} are formatted.
 482      *
</pre>
<hr />
<pre>
 522      * may not be at end of stream and one, or both, streams may be
 523      * in an inconsistent state. It is strongly recommended that both streams
 524      * be promptly closed if an I/O error occurs.
 525      *
 526      * @param source an InputStream to read from, the stream not closed and
 527      *               is at end-of-file upon return.
 528      * @return the output as a non-null {@code String}
 529      * @throws java.io.UncheckedIOException if an I/O error occurs
 530      */
 531     public String toString(InputStream source) {
 532         Objects.requireNonNull(source, &quot;InputStream must be non-null&quot;);
 533         StringBuilder sb = new StringBuilder();
 534         try (AnnotationWriter writer =
 535                      new AnnotationWriter(this, source, 0, sb)) {
 536             writer.flush();
 537             return sb.toString();
 538         }
 539     }
 540 
 541     /**
<span class="line-modified"> 542      * The formatter function is called for the range of the ByteBuffer contents</span>
<span class="line-modified"> 543      * and returned as a string.</span>
<span class="line-modified"> 544      * The ByteBuffer position is not used and not modified.</span>
 545      *
 546      * @param source a ByteBuffer
<span class="line-modified"> 547      * @param index the index in the ByteBuffer, must be non-negative and</span>
<span class="line-modified"> 548      *              less than {@code limit()}.</span>
<span class="line-added"> 549      * @param length the length in the ByteBuffer must be non-negative and</span>
<span class="line-added"> 550      *               no larger than {@code source.limit() - index}</span>
 551      * @return the output as a non-null {@code String}
 552      * @throws java.io.UncheckedIOException if an I/O error occurs
<span class="line-added"> 553      * @throws java.lang.IndexOutOfBoundsException if the preconditions on</span>
<span class="line-added"> 554      *          {@code index} and {@code length} do not hold</span>
 555      */
<span class="line-modified"> 556     public String toString(ByteBuffer source, int index, int length) {</span>
 557         Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
<span class="line-added"> 558         byte[] bytes = new byte[length];</span>
<span class="line-added"> 559         source.get(index, bytes, 0, length);</span>
<span class="line-added"> 560         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);</span>
 561         StringBuilder sb = new StringBuilder();








 562         try (AnnotationWriter writer =
<span class="line-modified"> 563                      new AnnotationWriter(this, bais, index, sb)) {</span>
 564             writer.flush();
 565             return sb.toString();
 566         }
 567     }
 568 
 569     /**
<span class="line-modified"> 570      * The formatter function is called for the ByteBuffer contents</span>
<span class="line-modified"> 571      * and returned as a string.</span>
 572      * The source bytes are from the {@code ByteBuffer.position()}
 573      * to the {@code ByteBuffer.limit()}.
 574      * The position is not modified.
 575      *
 576      * @param source a ByteBuffer
 577      * @return the output as a non-null {@code String}
 578      * @throws java.io.UncheckedIOException if an I/O error occurs
 579      */
 580     public String toString(ByteBuffer source) {
<span class="line-modified"> 581         return toString(source, source.position(), source.limit() - source.position());</span>
 582     }
 583 
 584     /**
 585      * Returns a new HexPrinter setting the format for the byte offset.
 586      * The format string is specified by {@link String#format String format}
 587      * including any delimiters. For example, {@code &quot;%3x: &quot;}.
 588      * If the format is an empty string, there is no offset in the output.
 589      *
 590      * @param offsetFormat a new format string for the byte offset.
 591      * @return a new HexPrinter
 592      */
 593     public HexPrinter withOffsetFormat(String offsetFormat) {
 594         Objects.requireNonNull(offsetFormat, &quot;offsetFormat&quot;);
 595         return new HexPrinter(annoFormatter, offsetFormat, bytesFormat, bytesCount,
 596                 annoDelim, annoWidth, lineSeparator, dest);
 597     }
 598 
 599     /**
 600      * Returns a new HexPrinter setting the format for each byte value and
 601      * the maximum number of byte values per line.
</pre>
<hr />
<pre>
 807      * a line of output is assembled and written to the destination Appendable.
 808      * The formatter&#39;s {@code annotate} method is called repeatedly
 809      * until the input is completely consumed or an exception is thrown.
 810      * Any remaining buffered bytes or description are flushed to the destination Appendable.
 811      */
 812     @FunctionalInterface
 813     public interface Formatter {
 814 
 815         /**
 816          * Read bytes from the input stream and append a descriptive annotation
 817          * to the output destination.
 818          *
 819          * @param in  a DataInputStream
 820          * @param out an Appendable for the output
 821          * @throws IOException if an I/O error occurs
 822          */
 823         void annotate(DataInputStream in, Appendable out) throws IOException;
 824     }
 825 
 826     /**
<span class="line-modified"> 827      * Built-in formatters for printable byte, ASCII byte, UTF-8 and primitive types.</span>
 828      * Formatters for primitive types and different formatting options
 829      * can be found by calling {@link #ofPrimitive(Class, String)}.
 830      */
 831     public enum Formatters implements Formatter {
 832         /**
<span class="line-modified"> 833          * Read a byte, return the value as a single character string</span>
<span class="line-modified"> 834          * if it is printable, otherwise return &quot;.&quot;.</span>
 835          */
 836         PRINTABLE,
 837         /**
<span class="line-modified"> 838          * Read a byte and return it as a string.</span>
<span class="line-added"> 839          * Return the character if it is ASCII, return its mnemonic if it</span>
<span class="line-added"> 840          * is a control character, otherwise return its decimal value as a string.</span>
 841          */
 842         ASCII,
 843         /**
 844          * Read a modified UTF-8 string and write it.
 845          */
 846         UTF8,
 847         /**
 848          * Read a byte and write nothing.
 849          */
 850         NONE;
 851 
 852         public void annotate(DataInputStream in, Appendable out) throws IOException {
 853             switch (this) {
 854                 case PRINTABLE -&gt; bytePrintable(in, out);
 855                 case ASCII -&gt; byteASCII(in, out);
 856                 case UTF8 -&gt; utf8Parser(in, out);
 857                 case NONE -&gt; byteNoneParser(in, out);
 858             }
 859         }
 860 
 861         /**
<span class="line-modified"> 862          * Read a byte and return it as a single character string if it is printable,</span>
<span class="line-modified"> 863          * otherwise return &quot;.&quot;.</span>


 864          *
 865          * @param in  a DataInputStream
 866          * @param out an Appendable to write to
 867          * @throws IOException if an I/O error occurs
 868          */
 869         static void bytePrintable(DataInputStream in, Appendable out) throws IOException {
 870             int v = in.readUnsignedByte();
<span class="line-modified"> 871             if (!Character.isISOControl(v) &amp;&amp; v &lt; 127) {</span>


 872                 out.append((char) v);
 873             } else {
<span class="line-modified"> 874                 out.append(&#39;.&#39;);</span>
 875             }
 876         }
 877 
 878         /**
<span class="line-modified"> 879          * Read a byte and return it as a string.</span>
<span class="line-added"> 880          * Append the byte if it is ASCII, its mnemonic if it</span>
<span class="line-added"> 881          * is a control character, and otherwise its decimal value.</span>
 882          *
 883          * @param in  a DataInputStream
 884          * @param out an Appendable to write to
 885          * @throws IOException if an I/O error occurs
 886          */
 887         static void byteASCII(DataInputStream in, Appendable out) throws IOException {
 888             int v = in.readUnsignedByte();
<span class="line-modified"> 889             if (v &lt; 32) {</span>
<span class="line-added"> 890                 out.append(&#39;\\&#39;).append(CONTROL_MNEMONICS[v]);</span>
<span class="line-added"> 891             } else if (v &lt; 127) {</span>
 892                 out.append((char) v);
 893             } else {
<span class="line-modified"> 894                 out.append(&#39;\\&#39;).append(Integer.toString(v, 10));</span>
 895             }
 896         }
 897 
 898         /**
 899          * Read a modified UTF-8 string and write it to the output destination.
 900          *
 901          * @param in  a DataInputStream
 902          * @param out an Appendable to write the output to
 903          * @throws IOException if an I/O error occurs
 904          */
 905         static void utf8Parser(DataInputStream in, Appendable out) throws IOException {
 906             out.append(in.readUTF()).append(&quot; &quot;);
 907         }
 908 
 909         /**
 910          * Read a a byte and write nothing.
 911          *
 912          * @param in  a DataInputStream
 913          * @param out an Appendable to write the output to
 914          * @throws IOException if an I/O error occurs
</pre>
</td>
</tr>
</table>
<center><a href="../SA/SATestUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/zip/ZipFile/TestZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../Locale/LocaleProvidersRun.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../tools/jpackage/apps/image/Hello.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/zip/ZipFile/TestZipFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8142508 8146431
 27  * @modules java.base/java.util.zip:open
 28  * @summary Tests various ZipFile apis
 29  * @run main/manual TestZipFile
 30  */
 31 
 32 import java.io.*;
<span class="line-modified"> 33 import java.lang.reflect.Method;</span>
<span class="line-modified"> 34 import java.nio.*;</span>
<span class="line-modified"> 35 import java.nio.file.*;</span>
<span class="line-modified"> 36 import java.nio.file.attribute.*;</span>
 37 import java.util.*;
<span class="line-modified"> 38 import java.util.concurrent.*;</span>
<span class="line-modified"> 39 import java.util.zip.*;</span>





 40 
 41 public class TestZipFile {
 42 
<span class="line-modified"> 43     private static Random r = new Random();</span>
<span class="line-modified"> 44     private static int    N = 50;</span>
<span class="line-modified"> 45     private static int    NN = 10;</span>
<span class="line-modified"> 46     private static int    ENUM = 10000;</span>
<span class="line-modified"> 47     private static int    ESZ = 10000;</span>
 48     private static ExecutorService executor = Executors.newFixedThreadPool(20);
<span class="line-modified"> 49     private static Set&lt;Path&gt; paths = new HashSet&lt;&gt;();</span>


 50 
 51     static void realMain (String[] args) throws Throwable {
<span class="line-removed"> 52 </span>
 53         try {
 54             for (int i = 0; i &lt; N; i++) {
 55                 test(r.nextInt(ENUM), r.nextInt(ESZ), false, true);
 56                 test(r.nextInt(ENUM), r.nextInt(ESZ), true, true);
 57             }
<span class="line-modified"> 58 </span>


 59             for (int i = 0; i &lt; NN; i++) {
 60                 test(r.nextInt(ENUM), 100000 + r.nextInt(ESZ), false, true);
 61                 test(r.nextInt(ENUM), 100000 + r.nextInt(ESZ), true, true);
<span class="line-modified"> 62                 testCachedDelete();</span>
<span class="line-modified"> 63                 testCachedOverwrite();</span>
<span class="line-modified"> 64                 //test(r.nextInt(ENUM), r.nextInt(ESZ), false, true);</span>

 65             }
<span class="line-removed"> 66 </span>
 67             test(70000, 1000, false, true);   // &gt; 65536 entry number;
 68             testDelete();                     // OPEN_DELETE
 69 
 70             executor.shutdown();
 71             executor.awaitTermination(10, TimeUnit.MINUTES);
 72         } finally {
 73             for (Path path : paths) {
 74                 Files.deleteIfExists(path);
 75             }
 76         }
 77     }
 78 
 79     static void test(int numEntry, int szMax, boolean addPrefix, boolean cleanOld) {
<span class="line-modified"> 80         String name = &quot;zftest&quot; + r.nextInt() + &quot;.zip&quot;;</span>
 81         Zip zip = new Zip(name, numEntry, szMax, addPrefix, cleanOld);
 82         for (int i = 0; i &lt; NN; i++) {
 83             executor.submit(() -&gt; doTest(zip));
 84         }
 85      }
 86 
 87     // test scenario:
 88     // (1) open the ZipFile(zip) with OPEN_READ | OPEN_DELETE
 89     // (2) test the ZipFile works correctly
 90     // (3) check the zip is deleted after ZipFile gets closed
 91     static void testDelete() throws Throwable {
<span class="line-modified"> 92         String name = &quot;zftest&quot; + r.nextInt() + &quot;.zip&quot;;</span>
 93         Zip zip = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
 94         try (ZipFile zf = new ZipFile(new File(zip.name),
 95                                       ZipFile.OPEN_READ | ZipFile.OPEN_DELETE ))
 96         {
 97             doTest0(zip, zf);
 98         }
 99         Path p = Paths.get(name);
100         if (Files.exists(p)) {
101             fail(&quot;Failed to delete &quot; + name + &quot; with OPEN_DELETE&quot;);
102         }
103     }
104 
105     // test scenario:
106     // (1) keep a ZipFile(zip1) alive (in ZipFile&#39;s cache), dont close it
107     // (2) delete zip1 and create zip2 with the same name the zip1 with zip2
108     // (3) zip1 tests should fail, but no crash
109     // (4) zip2 tasks should all get zip2, then pass normal testing.
110     static void testCachedDelete() throws Throwable {
<span class="line-modified">111         String name = &quot;zftest&quot; + r.nextInt() + &quot;.zip&quot;;</span>
112         Zip zip1 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
113 
114         try (ZipFile zf = new ZipFile(zip1.name)) {
115             for (int i = 0; i &lt; NN; i++) {
116                 executor.submit(() -&gt; verifyNoCrash(zip1));
117             }
118             // delete the &quot;zip1&quot;  and create a new one to test
119             Zip zip2 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
120             /*
121                 System.out.println(&quot;========================================&quot;);
122                 System.out.printf(&quot;    zip1=%s, mt=%d, enum=%d%n    -&gt;attrs=[key=%s, sz=%d, mt=%d]%n&quot;,
123                     zip1.name, zip1.lastModified, zip1.entries.size(),
124                     zip1.attrs.fileKey(), zip1.attrs.size(), zip1.attrs.lastModifiedTime().toMillis());
125                 System.out.printf(&quot;    zip2=%s, mt=%d, enum=%d%n    -&gt;attrs=[key=%s, sz=%d, mt=%d]%n&quot;,
126                     zip2.name, zip2.lastModified, zip2.entries.size(),
127                     zip2.attrs.fileKey(), zip2.attrs.size(), zip2.attrs.lastModifiedTime().toMillis());
128             */
129             for (int i = 0; i &lt; NN; i++) {
130                 executor.submit(() -&gt; doTest(zip2));
131             }
132         }
133     }
134 
135    // overwrite the &quot;zip1&quot;  and create a new one to test. So the two zip files
136    // have the same fileKey, but probably different lastModified()
137     static void testCachedOverwrite() throws Throwable {
<span class="line-modified">138         String name = &quot;zftest&quot; + r.nextInt() + &quot;.zip&quot;;</span>
139         Zip zip1 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
140         try (ZipFile zf = new ZipFile(zip1.name)) {
141             for (int i = 0; i &lt; NN; i++) {
142                 executor.submit(() -&gt; verifyNoCrash(zip1));
143             }
144             // overwrite the &quot;zip1&quot;  with new contents
145             Zip zip2 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, false);
146             for (int i = 0; i &lt; NN; i++) {
147                 executor.submit(() -&gt; doTest(zip2));
148             }
149         }
150     }
151 
152     // just check the entries and contents. since the file has been either overwritten
153     // or deleted/rewritten, we only care if it crahes or not.
154     static void verifyNoCrash(Zip zip) throws RuntimeException {
155         try (ZipFile zf = new ZipFile(zip.name)) {
<span class="line-modified">156             List&lt;ZipEntry&gt; zlist = new ArrayList(zip.entries.keySet());</span>
<span class="line-modified">157             String[] elist = zf.stream().map( e -&gt; e.getName()).toArray(String[]::new);</span>
158             if (!Arrays.equals(elist,
159                                zlist.stream().map( e -&gt; e.getName()).toArray(String[]::new)))
160             {
161                 //System.out.printf(&quot;++++++ LIST NG [%s] entries.len=%d, expected=%d+++++++%n&quot;,
162                 //                  zf.getName(), elist.length, zlist.size());
163                 return;
164             }
165             for (ZipEntry ze : zlist) {
166                 byte[] zdata = zip.entries.get(ze);
167                 ZipEntry e = zf.getEntry(ze.getName());
168                 if (e != null) {
169                     checkEqual(e, ze);
170                     if (!e.isDirectory()) {
171                         // check with readAllBytes
172                         try (InputStream is = zf.getInputStream(e)) {
173                             if (!Arrays.equals(zdata, is.readAllBytes())) {
174                                 //System.out.printf(&quot;++++++ BYTES NG  [%s]/[%s] ++++++++%n&quot;,
175                                 //                  zf.getName(), ze.getName());
176                             }
177                         }
</pre>
<hr />
<pre>
202             System.out.printf(&quot;      %d       %d%n&quot;, x.getTime(), y.getTime());
203             System.out.printf(&quot;      %d       %d%n&quot;, x.getSize(), y.getSize());
204             System.out.printf(&quot;      %d       %d%n&quot;, x.getCompressedSize(), y.getCompressedSize());
205             System.out.printf(&quot;      %d       %d%n&quot;, x.getCrc(), y.getCrc());
206             System.out.println(&quot;-----------------&quot;);
207         }
208     }
209 
210     static void doTest(Zip zip) throws RuntimeException {
211         //Thread me = Thread.currentThread();
212         try (ZipFile zf = new ZipFile(zip.name)) {
213             doTest0(zip, zf);
214         } catch (Throwable t) {
215             throw new RuntimeException(t);
216         }
217     }
218 
219     static void doTest0(Zip zip, ZipFile zf) throws Throwable {
220         // (0) check zero-length entry name, no AIOOBE
221         try {
<span class="line-modified">222             check(zf.getEntry(&quot;&quot;) == null);;</span>
223         } catch (Throwable t) {
224             unexpected(t);
225         }
226 
<span class="line-modified">227         List&lt;ZipEntry&gt; list = new ArrayList(zip.entries.keySet());</span>
228         // (1) check entry list, in expected order
229         if (!check(Arrays.equals(
230                 list.stream().map( e -&gt; e.getName()).toArray(String[]::new),
231                 zf.stream().map( e -&gt; e.getName()).toArray(String[]::new)))) {
232             return;
233         }
234         // (2) shuffle, and check each entry and its bytes
235         Collections.shuffle(list);
236         for (ZipEntry ze : list) {
237             byte[] data = zip.entries.get(ze);
238             ZipEntry e = zf.getEntry(ze.getName());
239             checkEqual(e, ze);
240             if (!e.isDirectory()) {
241                 // check with readAllBytes
242                 try (InputStream is = zf.getInputStream(e)) {
243                     check(Arrays.equals(data, is.readAllBytes()));
244                 }
245                 // check with smaller sized buf
246                 try (InputStream is = zf.getInputStream(e)) {
247                     byte[] buf = new byte[(int)e.getSize()];
248                     int sz = r.nextInt((int)e.getSize()/4 + 1) + 1;
249                     int off = 0;
250                     int n;
251                     while ((n = is.read(buf, off, buf.length - off)) &gt; 0) {
252                         off += n;
253                     }
254                     check(is.read() == -1);
255                     check(Arrays.equals(data, buf));
256                 }
257             }
258         }
<span class="line-removed">259         // (3) check getMetaInfEntryNames</span>
<span class="line-removed">260         String[] metas = list.stream()</span>
<span class="line-removed">261                              .map( e -&gt; e.getName())</span>
<span class="line-removed">262                              .filter( s -&gt; s.startsWith(&quot;META-INF/&quot;))</span>
<span class="line-removed">263                              .sorted()</span>
<span class="line-removed">264                              .toArray(String[]::new);</span>
<span class="line-removed">265         if (metas.length &gt; 0) {</span>
<span class="line-removed">266             // meta-inf entries</span>
<span class="line-removed">267             Method getMetas = ZipFile.class.getDeclaredMethod(&quot;getMetaInfEntryNames&quot;);</span>
<span class="line-removed">268             getMetas.setAccessible(true);</span>
<span class="line-removed">269             String[] names = (String[])getMetas.invoke(zf);</span>
<span class="line-removed">270             if (names == null) {</span>
<span class="line-removed">271                 fail(&quot;Failed to get metanames from &quot; + zf);</span>
<span class="line-removed">272             } else {</span>
<span class="line-removed">273                 Arrays.sort(names);</span>
<span class="line-removed">274                 check(Arrays.equals(names, metas));</span>
<span class="line-removed">275             }</span>
<span class="line-removed">276         }</span>
277     }
278 
279     private static class Zip {
<span class="line-modified">280         String name;</span>
<span class="line-modified">281         Map&lt;ZipEntry, byte[]&gt; entries;</span>
282         BasicFileAttributes attrs;
283         long lastModified;
284 
285         Zip(String name, int num, int szMax, boolean prefix, boolean clean) {
286             this.name = name;
287             entries = new LinkedHashMap&lt;&gt;(num);
288             try {
289                 Path p = Paths.get(name);
290                 if (clean) {
291                     Files.deleteIfExists(p);
292                 }
293                 paths.add(p);
294             } catch (Exception x) {
<span class="line-modified">295                 throw (RuntimeException)x;</span>
296             }
297 
298             try (FileOutputStream fos = new FileOutputStream(name);
299                  BufferedOutputStream bos = new BufferedOutputStream(fos);
300                  ZipOutputStream zos = new ZipOutputStream(bos))
301             {
302                 if (prefix) {
303                     byte[] bytes = new byte[r.nextInt(1000)];
304                     r.nextBytes(bytes);
305                     bos.write(bytes);
306                 }
307                 CRC32 crc = new CRC32();
308                 for (int i = 0; i &lt; num; i++) {
309                     String ename = &quot;entry-&quot; + i + &quot;-name-&quot; + r.nextLong();
310                     ZipEntry ze = new ZipEntry(ename);
311                     int method = r.nextBoolean() ? ZipEntry.STORED : ZipEntry.DEFLATED;
<span class="line-modified">312                     writeEntry(zos, crc, ze, ZipEntry.STORED, szMax);</span>
313                 }
314                 // add some manifest entries
315                 for (int i = 0; i &lt; r.nextInt(20); i++) {
316                     String meta = &quot;META-INF/&quot; + &quot;entry-&quot; + i + &quot;-metainf-&quot; + r.nextLong();
317                     ZipEntry ze = new ZipEntry(meta);
318                     writeEntry(zos, crc, ze, ZipEntry.STORED, szMax);
319                 }
320             } catch (Exception x) {
<span class="line-modified">321                 throw (RuntimeException)x;</span>
322             }
323             try {
324                 this.attrs = Files.readAttributes(Paths.get(name), BasicFileAttributes.class);
325                 this.lastModified = new File(name).lastModified();
326             } catch (Exception x) {
<span class="line-modified">327                 throw (RuntimeException)x;</span>
328             }
329         }
330 
331         private void writeEntry(ZipOutputStream zos, CRC32 crc,
332                                 ZipEntry ze, int method, int szMax)
333             throws IOException
334         {
335             ze.setMethod(method);
336             byte[] data = new byte[r.nextInt(szMax + 1)];
337             r.nextBytes(data);
338             if (method == ZipEntry.STORED) {  // must set size/csize/crc
339                 ze.setSize(data.length);
340                 ze.setCompressedSize(data.length);
341                 crc.reset();
342                 crc.update(data);
343                 ze.setCrc(crc.getValue());
344             }
345             ze.setTime(System.currentTimeMillis());
346             ze.setComment(ze.getName());
347             zos.putNextEntry(ze);
348             zos.write(data);
349             zos.closeEntry();
350             entries.put(ze, data);
351         }
352     }
353 
354     //--------------------- Infrastructure ---------------------------
355     static volatile int passed = 0, failed = 0;
356     static void pass() {passed++;}
357     static void pass(String msg) {System.out.println(msg); passed++;}
358     static void fail() {failed++; Thread.dumpStack();}
359     static void fail(String msg) {System.out.println(msg); fail();}
360     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
<span class="line-modified">361     static void unexpected(Throwable t, String msg) {</span>
<span class="line-removed">362         System.out.println(msg); failed++; t.printStackTrace();}</span>
363     static boolean check(boolean cond) {if (cond) pass(); else fail(); return cond;}
364 
<span class="line-modified">365     public static void main(String[] args) throws Throwable {</span>
366         try {realMain(args);} catch (Throwable t) {unexpected(t);}
367         System.out.println(&quot;\nPassed = &quot; + passed + &quot; failed = &quot; + failed);
368         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
369 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8142508 8146431
 27  * @modules java.base/java.util.zip:open
 28  * @summary Tests various ZipFile apis
 29  * @run main/manual TestZipFile
 30  */
 31 
 32 import java.io.*;
<span class="line-modified"> 33 import java.nio.file.Files;</span>
<span class="line-modified"> 34 import java.nio.file.Path;</span>
<span class="line-modified"> 35 import java.nio.file.Paths;</span>
<span class="line-modified"> 36 import java.nio.file.attribute.BasicFileAttributes;</span>
 37 import java.util.*;
<span class="line-modified"> 38 import java.util.concurrent.ExecutorService;</span>
<span class="line-modified"> 39 import java.util.concurrent.Executors;</span>
<span class="line-added"> 40 import java.util.concurrent.TimeUnit;</span>
<span class="line-added"> 41 import java.util.zip.CRC32;</span>
<span class="line-added"> 42 import java.util.zip.ZipEntry;</span>
<span class="line-added"> 43 import java.util.zip.ZipFile;</span>
<span class="line-added"> 44 import java.util.zip.ZipOutputStream;</span>
 45 
 46 public class TestZipFile {
 47 
<span class="line-modified"> 48     private static final Random r = new Random();</span>
<span class="line-modified"> 49     private static final int    N = 50;</span>
<span class="line-modified"> 50     private static final int    NN = 10;</span>
<span class="line-modified"> 51     private static final int    ENUM = 10000;</span>
<span class="line-modified"> 52     private static final int    ESZ = 10000;</span>
 53     private static ExecutorService executor = Executors.newFixedThreadPool(20);
<span class="line-modified"> 54     private static final Set&lt;Path&gt; paths = new HashSet&lt;&gt;();</span>
<span class="line-added"> 55     private static final boolean isWindows = System.getProperty(&quot;os.name&quot;)</span>
<span class="line-added"> 56             .startsWith(&quot;Windows&quot;);</span>
 57 
 58     static void realMain (String[] args) throws Throwable {

 59         try {
 60             for (int i = 0; i &lt; N; i++) {
 61                 test(r.nextInt(ENUM), r.nextInt(ESZ), false, true);
 62                 test(r.nextInt(ENUM), r.nextInt(ESZ), true, true);
 63             }
<span class="line-modified"> 64             executor.shutdown();</span>
<span class="line-added"> 65             executor.awaitTermination(10, TimeUnit.MINUTES);</span>
<span class="line-added"> 66             executor = Executors.newFixedThreadPool(20);</span>
 67             for (int i = 0; i &lt; NN; i++) {
 68                 test(r.nextInt(ENUM), 100000 + r.nextInt(ESZ), false, true);
 69                 test(r.nextInt(ENUM), 100000 + r.nextInt(ESZ), true, true);
<span class="line-modified"> 70                 if(!isWindows) {</span>
<span class="line-modified"> 71                     testCachedDelete();</span>
<span class="line-modified"> 72                     testCachedOverwrite();</span>
<span class="line-added"> 73                 }</span>
 74             }

 75             test(70000, 1000, false, true);   // &gt; 65536 entry number;
 76             testDelete();                     // OPEN_DELETE
 77 
 78             executor.shutdown();
 79             executor.awaitTermination(10, TimeUnit.MINUTES);
 80         } finally {
 81             for (Path path : paths) {
 82                 Files.deleteIfExists(path);
 83             }
 84         }
 85     }
 86 
 87     static void test(int numEntry, int szMax, boolean addPrefix, boolean cleanOld) {
<span class="line-modified"> 88         String name = &quot;test-&quot; + r.nextInt() + &quot;.zip&quot;;</span>
 89         Zip zip = new Zip(name, numEntry, szMax, addPrefix, cleanOld);
 90         for (int i = 0; i &lt; NN; i++) {
 91             executor.submit(() -&gt; doTest(zip));
 92         }
 93      }
 94 
 95     // test scenario:
 96     // (1) open the ZipFile(zip) with OPEN_READ | OPEN_DELETE
 97     // (2) test the ZipFile works correctly
 98     // (3) check the zip is deleted after ZipFile gets closed
 99     static void testDelete() throws Throwable {
<span class="line-modified">100         String name = &quot;testDelete-&quot; + r.nextInt() + &quot;.zip&quot;;</span>
101         Zip zip = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
102         try (ZipFile zf = new ZipFile(new File(zip.name),
103                                       ZipFile.OPEN_READ | ZipFile.OPEN_DELETE ))
104         {
105             doTest0(zip, zf);
106         }
107         Path p = Paths.get(name);
108         if (Files.exists(p)) {
109             fail(&quot;Failed to delete &quot; + name + &quot; with OPEN_DELETE&quot;);
110         }
111     }
112 
113     // test scenario:
114     // (1) keep a ZipFile(zip1) alive (in ZipFile&#39;s cache), dont close it
115     // (2) delete zip1 and create zip2 with the same name the zip1 with zip2
116     // (3) zip1 tests should fail, but no crash
117     // (4) zip2 tasks should all get zip2, then pass normal testing.
118     static void testCachedDelete() throws Throwable {
<span class="line-modified">119         String name = &quot;testCachedDelete-&quot; + r.nextInt() + &quot;.zip&quot;;</span>
120         Zip zip1 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
121 
122         try (ZipFile zf = new ZipFile(zip1.name)) {
123             for (int i = 0; i &lt; NN; i++) {
124                 executor.submit(() -&gt; verifyNoCrash(zip1));
125             }
126             // delete the &quot;zip1&quot;  and create a new one to test
127             Zip zip2 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
128             /*
129                 System.out.println(&quot;========================================&quot;);
130                 System.out.printf(&quot;    zip1=%s, mt=%d, enum=%d%n    -&gt;attrs=[key=%s, sz=%d, mt=%d]%n&quot;,
131                     zip1.name, zip1.lastModified, zip1.entries.size(),
132                     zip1.attrs.fileKey(), zip1.attrs.size(), zip1.attrs.lastModifiedTime().toMillis());
133                 System.out.printf(&quot;    zip2=%s, mt=%d, enum=%d%n    -&gt;attrs=[key=%s, sz=%d, mt=%d]%n&quot;,
134                     zip2.name, zip2.lastModified, zip2.entries.size(),
135                     zip2.attrs.fileKey(), zip2.attrs.size(), zip2.attrs.lastModifiedTime().toMillis());
136             */
137             for (int i = 0; i &lt; NN; i++) {
138                 executor.submit(() -&gt; doTest(zip2));
139             }
140         }
141     }
142 
143    // overwrite the &quot;zip1&quot;  and create a new one to test. So the two zip files
144    // have the same fileKey, but probably different lastModified()
145     static void testCachedOverwrite() throws Throwable {
<span class="line-modified">146         String name = &quot;testCachedOverWrite-&quot; + r.nextInt() + &quot;.zip&quot;;</span>
147         Zip zip1 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
148         try (ZipFile zf = new ZipFile(zip1.name)) {
149             for (int i = 0; i &lt; NN; i++) {
150                 executor.submit(() -&gt; verifyNoCrash(zip1));
151             }
152             // overwrite the &quot;zip1&quot;  with new contents
153             Zip zip2 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, false);
154             for (int i = 0; i &lt; NN; i++) {
155                 executor.submit(() -&gt; doTest(zip2));
156             }
157         }
158     }
159 
160     // just check the entries and contents. since the file has been either overwritten
161     // or deleted/rewritten, we only care if it crahes or not.
162     static void verifyNoCrash(Zip zip) throws RuntimeException {
163         try (ZipFile zf = new ZipFile(zip.name)) {
<span class="line-modified">164             List&lt;ZipEntry&gt; zlist = new ArrayList&lt;&gt;(zip.entries.keySet());</span>
<span class="line-modified">165             String[] elist = zf.stream().map(e -&gt; e.getName()).toArray(String[]::new);</span>
166             if (!Arrays.equals(elist,
167                                zlist.stream().map( e -&gt; e.getName()).toArray(String[]::new)))
168             {
169                 //System.out.printf(&quot;++++++ LIST NG [%s] entries.len=%d, expected=%d+++++++%n&quot;,
170                 //                  zf.getName(), elist.length, zlist.size());
171                 return;
172             }
173             for (ZipEntry ze : zlist) {
174                 byte[] zdata = zip.entries.get(ze);
175                 ZipEntry e = zf.getEntry(ze.getName());
176                 if (e != null) {
177                     checkEqual(e, ze);
178                     if (!e.isDirectory()) {
179                         // check with readAllBytes
180                         try (InputStream is = zf.getInputStream(e)) {
181                             if (!Arrays.equals(zdata, is.readAllBytes())) {
182                                 //System.out.printf(&quot;++++++ BYTES NG  [%s]/[%s] ++++++++%n&quot;,
183                                 //                  zf.getName(), ze.getName());
184                             }
185                         }
</pre>
<hr />
<pre>
210             System.out.printf(&quot;      %d       %d%n&quot;, x.getTime(), y.getTime());
211             System.out.printf(&quot;      %d       %d%n&quot;, x.getSize(), y.getSize());
212             System.out.printf(&quot;      %d       %d%n&quot;, x.getCompressedSize(), y.getCompressedSize());
213             System.out.printf(&quot;      %d       %d%n&quot;, x.getCrc(), y.getCrc());
214             System.out.println(&quot;-----------------&quot;);
215         }
216     }
217 
218     static void doTest(Zip zip) throws RuntimeException {
219         //Thread me = Thread.currentThread();
220         try (ZipFile zf = new ZipFile(zip.name)) {
221             doTest0(zip, zf);
222         } catch (Throwable t) {
223             throw new RuntimeException(t);
224         }
225     }
226 
227     static void doTest0(Zip zip, ZipFile zf) throws Throwable {
228         // (0) check zero-length entry name, no AIOOBE
229         try {
<span class="line-modified">230             check(zf.getEntry(&quot;&quot;) == null);</span>
231         } catch (Throwable t) {
232             unexpected(t);
233         }
234 
<span class="line-modified">235         List&lt;ZipEntry&gt; list = new ArrayList&lt;&gt;(zip.entries.keySet());</span>
236         // (1) check entry list, in expected order
237         if (!check(Arrays.equals(
238                 list.stream().map( e -&gt; e.getName()).toArray(String[]::new),
239                 zf.stream().map( e -&gt; e.getName()).toArray(String[]::new)))) {
240             return;
241         }
242         // (2) shuffle, and check each entry and its bytes
243         Collections.shuffle(list);
244         for (ZipEntry ze : list) {
245             byte[] data = zip.entries.get(ze);
246             ZipEntry e = zf.getEntry(ze.getName());
247             checkEqual(e, ze);
248             if (!e.isDirectory()) {
249                 // check with readAllBytes
250                 try (InputStream is = zf.getInputStream(e)) {
251                     check(Arrays.equals(data, is.readAllBytes()));
252                 }
253                 // check with smaller sized buf
254                 try (InputStream is = zf.getInputStream(e)) {
255                     byte[] buf = new byte[(int)e.getSize()];
256                     int sz = r.nextInt((int)e.getSize()/4 + 1) + 1;
257                     int off = 0;
258                     int n;
259                     while ((n = is.read(buf, off, buf.length - off)) &gt; 0) {
260                         off += n;
261                     }
262                     check(is.read() == -1);
263                     check(Arrays.equals(data, buf));
264                 }
265             }
266         }


















267     }
268 
269     private static class Zip {
<span class="line-modified">270         final String name;</span>
<span class="line-modified">271         final Map&lt;ZipEntry, byte[]&gt; entries;</span>
272         BasicFileAttributes attrs;
273         long lastModified;
274 
275         Zip(String name, int num, int szMax, boolean prefix, boolean clean) {
276             this.name = name;
277             entries = new LinkedHashMap&lt;&gt;(num);
278             try {
279                 Path p = Paths.get(name);
280                 if (clean) {
281                     Files.deleteIfExists(p);
282                 }
283                 paths.add(p);
284             } catch (Exception x) {
<span class="line-modified">285                 throw new RuntimeException(x);</span>
286             }
287 
288             try (FileOutputStream fos = new FileOutputStream(name);
289                  BufferedOutputStream bos = new BufferedOutputStream(fos);
290                  ZipOutputStream zos = new ZipOutputStream(bos))
291             {
292                 if (prefix) {
293                     byte[] bytes = new byte[r.nextInt(1000)];
294                     r.nextBytes(bytes);
295                     bos.write(bytes);
296                 }
297                 CRC32 crc = new CRC32();
298                 for (int i = 0; i &lt; num; i++) {
299                     String ename = &quot;entry-&quot; + i + &quot;-name-&quot; + r.nextLong();
300                     ZipEntry ze = new ZipEntry(ename);
301                     int method = r.nextBoolean() ? ZipEntry.STORED : ZipEntry.DEFLATED;
<span class="line-modified">302                     writeEntry(zos, crc, ze, method, szMax);</span>
303                 }
304                 // add some manifest entries
305                 for (int i = 0; i &lt; r.nextInt(20); i++) {
306                     String meta = &quot;META-INF/&quot; + &quot;entry-&quot; + i + &quot;-metainf-&quot; + r.nextLong();
307                     ZipEntry ze = new ZipEntry(meta);
308                     writeEntry(zos, crc, ze, ZipEntry.STORED, szMax);
309                 }
310             } catch (Exception x) {
<span class="line-modified">311                 throw new RuntimeException(x);</span>
312             }
313             try {
314                 this.attrs = Files.readAttributes(Paths.get(name), BasicFileAttributes.class);
315                 this.lastModified = new File(name).lastModified();
316             } catch (Exception x) {
<span class="line-modified">317                 throw new RuntimeException(x);</span>
318             }
319         }
320 
321         private void writeEntry(ZipOutputStream zos, CRC32 crc,
322                                 ZipEntry ze, int method, int szMax)
323             throws IOException
324         {
325             ze.setMethod(method);
326             byte[] data = new byte[r.nextInt(szMax + 1)];
327             r.nextBytes(data);
328             if (method == ZipEntry.STORED) {  // must set size/csize/crc
329                 ze.setSize(data.length);
330                 ze.setCompressedSize(data.length);
331                 crc.reset();
332                 crc.update(data);
333                 ze.setCrc(crc.getValue());
334             }
335             ze.setTime(System.currentTimeMillis());
336             ze.setComment(ze.getName());
337             zos.putNextEntry(ze);
338             zos.write(data);
339             zos.closeEntry();
340             entries.put(ze, data);
341         }
342     }
343 
344     //--------------------- Infrastructure ---------------------------
345     static volatile int passed = 0, failed = 0;
346     static void pass() {passed++;}
347     static void pass(String msg) {System.out.println(msg); passed++;}
348     static void fail() {failed++; Thread.dumpStack();}
349     static void fail(String msg) {System.out.println(msg); fail();}
350     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
<span class="line-modified">351 </span>

352     static boolean check(boolean cond) {if (cond) pass(); else fail(); return cond;}
353 
<span class="line-modified">354     public static void main(String[] args) {</span>
355         try {realMain(args);} catch (Throwable t) {unexpected(t);}
356         System.out.println(&quot;\nPassed = &quot; + passed + &quot; failed = &quot; + failed);
357         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
358 }
</pre>
</td>
</tr>
</table>
<center><a href="../../Locale/LocaleProvidersRun.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../tools/jpackage/apps/image/Hello.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
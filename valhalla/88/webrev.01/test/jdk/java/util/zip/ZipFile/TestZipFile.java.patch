diff a/test/jdk/java/util/zip/ZipFile/TestZipFile.java b/test/jdk/java/util/zip/ZipFile/TestZipFile.java
--- a/test/jdk/java/util/zip/ZipFile/TestZipFile.java
+++ b/test/jdk/java/util/zip/ZipFile/TestZipFile.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,44 +28,52 @@
  * @summary Tests various ZipFile apis
  * @run main/manual TestZipFile
  */
 
 import java.io.*;
-import java.lang.reflect.Method;
-import java.nio.*;
-import java.nio.file.*;
-import java.nio.file.attribute.*;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.util.*;
-import java.util.concurrent.*;
-import java.util.zip.*;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.CRC32;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
 
 public class TestZipFile {
 
-    private static Random r = new Random();
-    private static int    N = 50;
-    private static int    NN = 10;
-    private static int    ENUM = 10000;
-    private static int    ESZ = 10000;
+    private static final Random r = new Random();
+    private static final int    N = 50;
+    private static final int    NN = 10;
+    private static final int    ENUM = 10000;
+    private static final int    ESZ = 10000;
     private static ExecutorService executor = Executors.newFixedThreadPool(20);
-    private static Set<Path> paths = new HashSet<>();
+    private static final Set<Path> paths = new HashSet<>();
+    private static final boolean isWindows = System.getProperty("os.name")
+            .startsWith("Windows");
 
     static void realMain (String[] args) throws Throwable {
-
         try {
             for (int i = 0; i < N; i++) {
                 test(r.nextInt(ENUM), r.nextInt(ESZ), false, true);
                 test(r.nextInt(ENUM), r.nextInt(ESZ), true, true);
             }
-
+            executor.shutdown();
+            executor.awaitTermination(10, TimeUnit.MINUTES);
+            executor = Executors.newFixedThreadPool(20);
             for (int i = 0; i < NN; i++) {
                 test(r.nextInt(ENUM), 100000 + r.nextInt(ESZ), false, true);
                 test(r.nextInt(ENUM), 100000 + r.nextInt(ESZ), true, true);
-                testCachedDelete();
-                testCachedOverwrite();
-                //test(r.nextInt(ENUM), r.nextInt(ESZ), false, true);
+                if(!isWindows) {
+                    testCachedDelete();
+                    testCachedOverwrite();
+                }
             }
-
             test(70000, 1000, false, true);   // > 65536 entry number;
             testDelete();                     // OPEN_DELETE
 
             executor.shutdown();
             executor.awaitTermination(10, TimeUnit.MINUTES);
@@ -75,11 +83,11 @@
             }
         }
     }
 
     static void test(int numEntry, int szMax, boolean addPrefix, boolean cleanOld) {
-        String name = "zftest" + r.nextInt() + ".zip";
+        String name = "test-" + r.nextInt() + ".zip";
         Zip zip = new Zip(name, numEntry, szMax, addPrefix, cleanOld);
         for (int i = 0; i < NN; i++) {
             executor.submit(() -> doTest(zip));
         }
      }
@@ -87,11 +95,11 @@
     // test scenario:
     // (1) open the ZipFile(zip) with OPEN_READ | OPEN_DELETE
     // (2) test the ZipFile works correctly
     // (3) check the zip is deleted after ZipFile gets closed
     static void testDelete() throws Throwable {
-        String name = "zftest" + r.nextInt() + ".zip";
+        String name = "testDelete-" + r.nextInt() + ".zip";
         Zip zip = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
         try (ZipFile zf = new ZipFile(new File(zip.name),
                                       ZipFile.OPEN_READ | ZipFile.OPEN_DELETE ))
         {
             doTest0(zip, zf);
@@ -106,11 +114,11 @@
     // (1) keep a ZipFile(zip1) alive (in ZipFile's cache), dont close it
     // (2) delete zip1 and create zip2 with the same name the zip1 with zip2
     // (3) zip1 tests should fail, but no crash
     // (4) zip2 tasks should all get zip2, then pass normal testing.
     static void testCachedDelete() throws Throwable {
-        String name = "zftest" + r.nextInt() + ".zip";
+        String name = "testCachedDelete-" + r.nextInt() + ".zip";
         Zip zip1 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
 
         try (ZipFile zf = new ZipFile(zip1.name)) {
             for (int i = 0; i < NN; i++) {
                 executor.submit(() -> verifyNoCrash(zip1));
@@ -133,11 +141,11 @@
     }
 
    // overwrite the "zip1"  and create a new one to test. So the two zip files
    // have the same fileKey, but probably different lastModified()
     static void testCachedOverwrite() throws Throwable {
-        String name = "zftest" + r.nextInt() + ".zip";
+        String name = "testCachedOverWrite-" + r.nextInt() + ".zip";
         Zip zip1 = new Zip(name, r.nextInt(ENUM), r.nextInt(ESZ), false, true);
         try (ZipFile zf = new ZipFile(zip1.name)) {
             for (int i = 0; i < NN; i++) {
                 executor.submit(() -> verifyNoCrash(zip1));
             }
@@ -151,12 +159,12 @@
 
     // just check the entries and contents. since the file has been either overwritten
     // or deleted/rewritten, we only care if it crahes or not.
     static void verifyNoCrash(Zip zip) throws RuntimeException {
         try (ZipFile zf = new ZipFile(zip.name)) {
-            List<ZipEntry> zlist = new ArrayList(zip.entries.keySet());
-            String[] elist = zf.stream().map( e -> e.getName()).toArray(String[]::new);
+            List<ZipEntry> zlist = new ArrayList<>(zip.entries.keySet());
+            String[] elist = zf.stream().map(e -> e.getName()).toArray(String[]::new);
             if (!Arrays.equals(elist,
                                zlist.stream().map( e -> e.getName()).toArray(String[]::new)))
             {
                 //System.out.printf("++++++ LIST NG [%s] entries.len=%d, expected=%d+++++++%n",
                 //                  zf.getName(), elist.length, zlist.size());
@@ -217,16 +225,16 @@
     }
 
     static void doTest0(Zip zip, ZipFile zf) throws Throwable {
         // (0) check zero-length entry name, no AIOOBE
         try {
-            check(zf.getEntry("") == null);;
+            check(zf.getEntry("") == null);
         } catch (Throwable t) {
             unexpected(t);
         }
 
-        List<ZipEntry> list = new ArrayList(zip.entries.keySet());
+        List<ZipEntry> list = new ArrayList<>(zip.entries.keySet());
         // (1) check entry list, in expected order
         if (!check(Arrays.equals(
                 list.stream().map( e -> e.getName()).toArray(String[]::new),
                 zf.stream().map( e -> e.getName()).toArray(String[]::new)))) {
             return;
@@ -254,33 +262,15 @@
                     check(is.read() == -1);
                     check(Arrays.equals(data, buf));
                 }
             }
         }
-        // (3) check getMetaInfEntryNames
-        String[] metas = list.stream()
-                             .map( e -> e.getName())
-                             .filter( s -> s.startsWith("META-INF/"))
-                             .sorted()
-                             .toArray(String[]::new);
-        if (metas.length > 0) {
-            // meta-inf entries
-            Method getMetas = ZipFile.class.getDeclaredMethod("getMetaInfEntryNames");
-            getMetas.setAccessible(true);
-            String[] names = (String[])getMetas.invoke(zf);
-            if (names == null) {
-                fail("Failed to get metanames from " + zf);
-            } else {
-                Arrays.sort(names);
-                check(Arrays.equals(names, metas));
-            }
-        }
     }
 
     private static class Zip {
-        String name;
-        Map<ZipEntry, byte[]> entries;
+        final String name;
+        final Map<ZipEntry, byte[]> entries;
         BasicFileAttributes attrs;
         long lastModified;
 
         Zip(String name, int num, int szMax, boolean prefix, boolean clean) {
             this.name = name;
@@ -290,11 +280,11 @@
                 if (clean) {
                     Files.deleteIfExists(p);
                 }
                 paths.add(p);
             } catch (Exception x) {
-                throw (RuntimeException)x;
+                throw new RuntimeException(x);
             }
 
             try (FileOutputStream fos = new FileOutputStream(name);
                  BufferedOutputStream bos = new BufferedOutputStream(fos);
                  ZipOutputStream zos = new ZipOutputStream(bos))
@@ -307,26 +297,26 @@
                 CRC32 crc = new CRC32();
                 for (int i = 0; i < num; i++) {
                     String ename = "entry-" + i + "-name-" + r.nextLong();
                     ZipEntry ze = new ZipEntry(ename);
                     int method = r.nextBoolean() ? ZipEntry.STORED : ZipEntry.DEFLATED;
-                    writeEntry(zos, crc, ze, ZipEntry.STORED, szMax);
+                    writeEntry(zos, crc, ze, method, szMax);
                 }
                 // add some manifest entries
                 for (int i = 0; i < r.nextInt(20); i++) {
                     String meta = "META-INF/" + "entry-" + i + "-metainf-" + r.nextLong();
                     ZipEntry ze = new ZipEntry(meta);
                     writeEntry(zos, crc, ze, ZipEntry.STORED, szMax);
                 }
             } catch (Exception x) {
-                throw (RuntimeException)x;
+                throw new RuntimeException(x);
             }
             try {
                 this.attrs = Files.readAttributes(Paths.get(name), BasicFileAttributes.class);
                 this.lastModified = new File(name).lastModified();
             } catch (Exception x) {
-                throw (RuntimeException)x;
+                throw new RuntimeException(x);
             }
         }
 
         private void writeEntry(ZipOutputStream zos, CRC32 crc,
                                 ZipEntry ze, int method, int szMax)
@@ -356,14 +346,13 @@
     static void pass() {passed++;}
     static void pass(String msg) {System.out.println(msg); passed++;}
     static void fail() {failed++; Thread.dumpStack();}
     static void fail(String msg) {System.out.println(msg); fail();}
     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
-    static void unexpected(Throwable t, String msg) {
-        System.out.println(msg); failed++; t.printStackTrace();}
+
     static boolean check(boolean cond) {if (cond) pass(); else fail(); return cond;}
 
-    public static void main(String[] args) throws Throwable {
+    public static void main(String[] args) {
         try {realMain(args);} catch (Throwable t) {unexpected(t);}
         System.out.println("\nPassed = " + passed + " failed = " + failed);
         if (failed > 0) throw new AssertionError("Some tests failed");}
 }

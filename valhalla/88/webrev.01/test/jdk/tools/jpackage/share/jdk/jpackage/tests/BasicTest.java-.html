<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.jpackage.tests;
 25 
 26 import java.io.IOException;
 27 import java.nio.file.Files;
 28 import java.nio.file.Path;
 29 import java.util.List;
 30 import java.util.ArrayList;
 31 import java.util.function.Function;
 32 import java.util.function.Predicate;
 33 import java.util.function.Supplier;
 34 import java.util.regex.Pattern;
 35 import java.util.stream.Collectors;
 36 import java.util.stream.Stream;
 37 import jdk.jpackage.test.*;
 38 import jdk.jpackage.test.Functional.ThrowingConsumer;
 39 import jdk.jpackage.test.Annotations.*;
 40 
 41 /*
 42  * @test
 43  * @summary jpackage basic testing
 44  * @library ../../../../helpers
 45  * @build jdk.jpackage.test.*
 46  * @modules jdk.incubator.jpackage/jdk.incubator.jpackage.internal
 47  * @compile BasicTest.java
 48  * @run main/othervm/timeout=720 -Xmx512m jdk.jpackage.test.Main
 49  *  --jpt-run=jdk.jpackage.tests.BasicTest
 50  */
 51 
 52 public final class BasicTest {
 53     @Test
 54     public void testNoArgs() {
 55         List&lt;String&gt; output =
 56                 getJPackageToolProvider().executeAndGetOutput();
 57         TKit.assertStringListEquals(List.of(&quot;Usage: jpackage &lt;options&gt;&quot;,
 58                 &quot;Use jpackage --help (or -h) for a list of possible options&quot;),
 59                 output, &quot;Check jpackage output&quot;);
 60     }
 61 
 62     @Test
 63     public void testVersion() {
 64         List&lt;String&gt; output =
 65                 getJPackageToolProvider()
 66                         .addArgument(&quot;--version&quot;)
 67                         .executeAndGetOutput();
 68         TKit.assertStringListEquals(List.of(System.getProperty(&quot;java.version&quot;)),
 69                 output, &quot;Check jpackage output&quot;);
 70     }
 71 
 72     @Test
 73     public void testHelp() {
 74         List&lt;String&gt; hOutput = getJPackageToolProvider()
 75                 .addArgument(&quot;-h&quot;).executeAndGetOutput();
 76         List&lt;String&gt; helpOutput = getJPackageToolProvider()
 77                 .addArgument(&quot;--help&quot;).executeAndGetOutput();
 78 
 79         TKit.assertStringListEquals(hOutput, helpOutput,
 80                 &quot;Check -h and --help parameters produce the same output&quot;);
 81 
 82         final String windowsPrefix = &quot;--win-&quot;;
 83         final String linuxPrefix = &quot;--linux-&quot;;
 84         final String osxPrefix = &quot;--mac-&quot;;
 85 
 86         final String expectedPrefix;
 87         final List&lt;String&gt; unexpectedPrefixes;
 88 
 89         if (TKit.isWindows()) {
 90             expectedPrefix = windowsPrefix;
 91             unexpectedPrefixes = List.of(osxPrefix, linuxPrefix);
 92         } else if (TKit.isLinux()) {
 93             expectedPrefix = linuxPrefix;
 94             unexpectedPrefixes = List.of(windowsPrefix, osxPrefix);
 95         } else if (TKit.isOSX()) {
 96             expectedPrefix = osxPrefix;
 97             unexpectedPrefixes = List.of(linuxPrefix,  windowsPrefix);
 98         } else {
 99             throw TKit.throwUnknownPlatformError();
100         }
101 
102         Function&lt;String, Predicate&lt;String&gt;&gt; createPattern = (prefix) -&gt; {
103             return Pattern.compile(&quot;^  &quot; + prefix).asPredicate();
104         };
105 
106         Function&lt;List&lt;String&gt;, Long&gt; countStrings = (prefixes) -&gt; {
107             return hOutput.stream().filter(
108                     prefixes.stream().map(createPattern).reduce(x -&gt; false,
109                             Predicate::or)).peek(TKit::trace).count();
110         };
111 
112         TKit.trace(&quot;Check parameters in help text&quot;);
113         TKit.assertNotEquals(0, countStrings.apply(List.of(expectedPrefix)),
114                 &quot;Check help text contains plaform specific parameters&quot;);
115         TKit.assertEquals(0, countStrings.apply(unexpectedPrefixes),
116                 &quot;Check help text doesn&#39;t contain unexpected parameters&quot;);
117     }
118 
119     @Test
120     @SuppressWarnings(&quot;unchecked&quot;)
121     public void testVerbose() {
122         JPackageCommand cmd = JPackageCommand.helloAppImage()
123                 // Disable default logic adding `--verbose` option
124                 // to jpackage command line.
125                 .ignoreDefaultVerbose(true)
126                 .saveConsoleOutput(true)
127                 .setFakeRuntime().executePrerequisiteActions();
128 
129         List&lt;String&gt; expectedVerboseOutputStrings = new ArrayList&lt;&gt;();
130         expectedVerboseOutputStrings.add(&quot;Creating app package:&quot;);
131         if (TKit.isWindows()) {
132             expectedVerboseOutputStrings.add(
133                     &quot;Succeeded in building Windows Application Image package&quot;);
134         } else if (TKit.isLinux()) {
135             expectedVerboseOutputStrings.add(
136                     &quot;Succeeded in building Linux Application Image package&quot;);
137         } else if (TKit.isOSX()) {
138             expectedVerboseOutputStrings.add(&quot;Preparing Info.plist:&quot;);
139             expectedVerboseOutputStrings.add(
140                     &quot;Succeeded in building Mac Application Image package&quot;);
141         } else {
142             TKit.throwUnknownPlatformError();
143         }
144 
145         TKit.deleteDirectoryContentsRecursive(cmd.outputDir());
146         List&lt;String&gt; nonVerboseOutput = cmd.execute().getOutput();
147         List&lt;String&gt;[] verboseOutput = (List&lt;String&gt;[])new List&lt;?&gt;[1];
148 
149         // Directory clean up is not 100% reliable on Windows because of
150         // antivirus software that can lock .exe files. Setup
151         // different output directory instead of cleaning the default one for
152         // verbose jpackage run.
153         TKit.withTempDirectory(&quot;verbose-output&quot;, tempDir -&gt; {
154             cmd.setArgumentValue(&quot;--dest&quot;, tempDir);
155             cmd.addArgument(&quot;--verbose&quot;);
156             verboseOutput[0] = cmd.execute().getOutput();
157         });
158 
159         TKit.assertTrue(nonVerboseOutput.size() &lt; verboseOutput[0].size(),
160                 &quot;Check verbose output is longer than regular&quot;);
161 
162         expectedVerboseOutputStrings.forEach(str -&gt; {
163             TKit.assertTextStream(str).label(&quot;regular output&quot;)
164                     .predicate(String::contains).negate()
165                     .apply(nonVerboseOutput.stream());
166         });
167 
168         expectedVerboseOutputStrings.forEach(str -&gt; {
169             TKit.assertTextStream(str).label(&quot;verbose output&quot;)
170                     .apply(verboseOutput[0].stream());
171         });
172     }
173 
174     @Test
175     public void testNoName() {
176         final String mainClassName = &quot;Greetings&quot;;
177 
178         JPackageCommand cmd = JPackageCommand.helloAppImage(mainClassName)
179                 .removeArgumentWithValue(&quot;--name&quot;);
180 
181         Path expectedImageDir = cmd.outputDir().resolve(mainClassName);
182         if (TKit.isOSX()) {
183             expectedImageDir = expectedImageDir.getParent().resolve(
184                     expectedImageDir.getFileName().toString() + &quot;.app&quot;);
185         }
186 
187         cmd.executeAndAssertHelloAppImageCreated();
188         TKit.assertEquals(expectedImageDir.toAbsolutePath().normalize().toString(),
189                 cmd.outputBundle().toAbsolutePath().normalize().toString(),
190                 String.format(
191                         &quot;Check [%s] directory is filled with application image data&quot;,
192                         expectedImageDir));
193     }
194 
195     @Test
196     // Regular app
197     @Parameter(&quot;Hello&quot;)
198     // Modular app in .jar file
199     @Parameter(&quot;com.other/com.other.Hello&quot;)
200     // Modular app in .jmod file
201     @Parameter(&quot;hello.jmod:com.other/com.other.Hello&quot;)
202     public void testApp(String javaAppDesc) {
203         JavaAppDesc appDesc = JavaAppDesc.parse(javaAppDesc);
204         JPackageCommand cmd = JPackageCommand.helloAppImage(appDesc);
205         if (appDesc.jmodFileName() != null) {
206             // .jmod files are not supported at run-time. They should be
207             // bundled in Java run-time with jlink command, so disable
208             // use of external Java run-time if any configured.
209             cmd.ignoreDefaultRuntime(true);
210         }
211         cmd.executeAndAssertHelloAppImageCreated();
212     }
213 
214     @Test
215     public void testWhitespaceInPaths() {
216         JPackageCommand.helloAppImage(&quot;a/b c.jar:Hello&quot;)
217         .setArgumentValue(&quot;--input&quot;, TKit.workDir().resolve(&quot;The quick brown fox&quot;))
218         .setArgumentValue(&quot;--dest&quot;, TKit.workDir().resolve(&quot;jumps over the lazy dog&quot;))
219         .executeAndAssertHelloAppImageCreated();
220     }
221 
222     @Test
223     @Parameter(&quot;ALL-MODULE-PATH&quot;)
224     @Parameter(&quot;ALL-DEFAULT&quot;)
225     @Parameter(&quot;java.desktop&quot;)
226     @Parameter(&quot;java.desktop,jdk.jartool&quot;)
227     @Parameter({ &quot;java.desktop&quot;, &quot;jdk.jartool&quot; })
228     public void testAddModules(String... addModulesArg) {
229         JPackageCommand cmd = JPackageCommand
230                 .helloAppImage(&quot;goodbye.jar:com.other/com.other.Hello&quot;);
231         Stream.of(addModulesArg).map(v -&gt; Stream.of(&quot;--add-modules&quot;, v)).flatMap(
232                 s -&gt; s).forEachOrdered(cmd::addArgument);
233         cmd.executeAndAssertHelloAppImageCreated();
234     }
235 
236     /**
237      * Test --temp option. Doesn&#39;t make much sense for app image as temporary
238      * directory is used only on Windows. Test it in packaging mode.
239      * @throws IOException
240      */
241     @Test
242     public void testTemp() throws IOException {
243         final Path tempRoot = TKit.createTempDirectory(&quot;temp-root&quot;);
244 
245         Function&lt;JPackageCommand, Path&gt; getTempDir = cmd -&gt; {
246             return tempRoot.resolve(cmd.outputBundle().getFileName());
247         };
248 
249         Supplier&lt;PackageTest&gt; createTest = () -&gt; {
250             return new PackageTest()
251             .configureHelloApp()
252             // Force save of package bundle in test work directory.
253             .addInitializer(JPackageCommand::setDefaultInputOutput)
254             .addInitializer(cmd -&gt; {
255                 Path tempDir = getTempDir.apply(cmd);
256                 Files.createDirectories(tempDir);
257                 cmd.addArguments(&quot;--temp&quot;, tempDir);
258             });
259         };
260 
261         createTest.get()
262         .addBundleVerifier(cmd -&gt; {
263             // Check jpackage actually used the supplied directory.
264             Path tempDir = getTempDir.apply(cmd);
265             TKit.assertNotEquals(0, tempDir.toFile().list().length,
266                     String.format(
267                             &quot;Check jpackage wrote some data in the supplied temporary directory [%s]&quot;,
268                             tempDir));
269         })
270         .run(PackageTest.Action.CREATE);
271 
272         createTest.get()
273         .addInitializer(cmd -&gt; {
274             // Clean output from the previus jpackage run.
275             Files.delete(cmd.outputBundle());
276         })
277         // Temporary directory should not be empty,
278         // jpackage should exit with error.
279         .setExpectedExitCode(1)
280         .run(PackageTest.Action.CREATE);
281     }
282 
283     @Test
284     public void testAtFile() throws IOException {
285         JPackageCommand cmd = JPackageCommand
286                 .helloAppImage()
287                 .setArgumentValue(&quot;--dest&quot;, TKit.createTempDirectory(&quot;output&quot;));
288 
289         // Init options file with the list of options configured
290         // for JPackageCommand instance.
291         final Path optionsFile = TKit.createTempFile(Path.of(&quot;options&quot;));
292         Files.write(optionsFile,
293                 List.of(String.join(&quot; &quot;, cmd.getAllArguments())));
294 
295         // Build app jar file.
296         cmd.executePrerequisiteActions();
297 
298         // Instead of running jpackage command through configured
299         // JPackageCommand instance, run vanilla jpackage command with @ file.
300         getJPackageToolProvider()
301                 .addArgument(String.format(&quot;@%s&quot;, optionsFile))
302                 .execute();
303 
304         // Verify output of jpackage command.
305         cmd.assertImageCreated();
306         HelloApp.executeLauncherAndVerifyOutput(cmd);
307     }
308 
309     @Parameter(&quot;Hello&quot;)
310     @Parameter(&quot;com.foo/com.foo.main.Aloha&quot;)
311     @Test
312     public void testJLinkRuntime(String javaAppDesc) throws IOException {
313         JavaAppDesc appDesc = JavaAppDesc.parse(javaAppDesc);
314 
315         JPackageCommand cmd = JPackageCommand.helloAppImage(appDesc);
316 
317         final String moduleName = appDesc.moduleName();
318 
319         if (moduleName != null) {
320             // Build module jar.
321             cmd.executePrerequisiteActions();
322         }
323 
324         final Path runtimeDir = TKit.createTempDirectory(&quot;runtime&quot;).resolve(&quot;data&quot;);
325 
326         // List of modules required for test app.
327         final var modules = new String[] {
328             &quot;java.base&quot;,
329             &quot;java.desktop&quot;
330         };
331 
332         Executor jlink = getToolProvider(JavaTool.JLINK)
333         .saveOutput(false)
334         .addArguments(
335                 &quot;--add-modules&quot;, String.join(&quot;,&quot;, modules),
336                 &quot;--output&quot;, runtimeDir.toString(),
337                 &quot;--strip-debug&quot;,
338                 &quot;--no-header-files&quot;,
339                 &quot;--no-man-pages&quot;);
340 
341         if (moduleName != null) {
342             jlink.addArguments(&quot;--add-modules&quot;, moduleName, &quot;--module-path&quot;,
343                     Path.of(cmd.getArgumentValue(&quot;--module-path&quot;)).resolve(
344                             &quot;hello.jar&quot;).toString());
345         }
346 
347         jlink.execute();
348 
349         cmd.addArguments(&quot;--runtime-image&quot;, runtimeDir);
350         cmd.executeAndAssertHelloAppImageCreated();
351     }
352 
353     private static Executor getJPackageToolProvider() {
354         return getToolProvider(JavaTool.JPACKAGE);
355     }
356 
357     private static Executor getToolProvider(JavaTool tool) {
358         return new Executor().dumpOutput().saveOutput().setToolProvider(tool);
359     }
360 }
    </pre>
  </body>
</html>
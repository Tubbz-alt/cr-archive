<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/tools/jpackage/helpers/jdk/jpackage/test/LinuxHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.jpackage.test;
 24 
 25 import java.io.IOException;
 26 import java.nio.file.Files;
 27 import java.nio.file.Path;
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.HashMap;
 31 import java.util.List;
 32 import java.util.Map;
 33 import java.util.Optional;
 34 import java.util.Set;
 35 import java.util.function.Function;
 36 import java.util.regex.Matcher;
 37 import java.util.regex.Pattern;
 38 import java.util.stream.Collectors;
 39 import java.util.stream.Stream;
 40 import jdk.incubator.jpackage.internal.IOUtils;
 41 import jdk.jpackage.test.PackageTest.PackageHandlers;
 42 
 43 
 44 
 45 public class LinuxHelper {
 46     private static String getRelease(JPackageCommand cmd) {
 47         return cmd.getArgumentValue(&quot;--linux-app-release&quot;, () -&gt; &quot;1&quot;);
 48     }
 49 
 50     public static String getPackageName(JPackageCommand cmd) {
 51         cmd.verifyIsOfType(PackageType.LINUX);
 52         return cmd.getArgumentValue(&quot;--linux-package-name&quot;,
 53                 () -&gt; cmd.name().toLowerCase());
 54     }
 55 
 56     public static Path getDesktopFile(JPackageCommand cmd) {
 57         return getDesktopFile(cmd, null);
 58     }
 59 
 60     public static Path getDesktopFile(JPackageCommand cmd, String launcherName) {
 61         cmd.verifyIsOfType(PackageType.LINUX);
 62         String desktopFileName = String.format(&quot;%s-%s.desktop&quot;, getPackageName(
 63                 cmd), Optional.ofNullable(launcherName).orElseGet(
 64                         () -&gt; cmd.name()).replaceAll(&quot;\\s+&quot;, &quot;_&quot;));
 65         return cmd.appLayout().destktopIntegrationDirectory().resolve(
 66                 desktopFileName);
 67     }
 68 
 69     static String getBundleName(JPackageCommand cmd) {
 70         cmd.verifyIsOfType(PackageType.LINUX);
 71 
 72         final PackageType packageType = cmd.packageType();
 73         String format = null;
 74         switch (packageType) {
 75             case LINUX_DEB:
 76                 format = &quot;%s_%s-%s_%s&quot;;
 77                 break;
 78 
 79             case LINUX_RPM:
 80                 format = &quot;%s-%s-%s.%s&quot;;
 81                 break;
 82         }
 83 
 84         final String release = getRelease(cmd);
 85         final String version = cmd.version();
 86 
 87         return String.format(format, getPackageName(cmd), version, release,
 88                 getDefaultPackageArch(packageType)) + packageType.getSuffix();
 89     }
 90 
 91     public static Stream&lt;Path&gt; getPackageFiles(JPackageCommand cmd) {
 92         cmd.verifyIsOfType(PackageType.LINUX);
 93 
 94         final PackageType packageType = cmd.packageType();
 95         final Path packageFile = cmd.outputBundle();
 96 
 97         Executor exec = null;
 98         switch (packageType) {
 99             case LINUX_DEB:
100                 exec = Executor.of(&quot;dpkg&quot;, &quot;--contents&quot;).addArgument(packageFile);
101                 break;
102 
103             case LINUX_RPM:
104                 exec = Executor.of(&quot;rpm&quot;, &quot;-qpl&quot;).addArgument(packageFile);
105                 break;
106         }
107 
108         Stream&lt;String&gt; lines = exec.executeAndGetOutput().stream();
109         if (packageType == PackageType.LINUX_DEB) {
110             // Typical text lines produced by dpkg look like:
111             // drwxr-xr-x root/root         0 2019-08-30 05:30 ./opt/appcategorytest/runtime/lib/
112             // -rw-r--r-- root/root    574912 2019-08-30 05:30 ./opt/appcategorytest/runtime/lib/libmlib_image.so
113             // Need to skip all fields but absolute path to file.
114             lines = lines.map(line -&gt; line.substring(line.indexOf(&quot; ./&quot;) + 2));
115         }
116         return lines.map(Path::of);
117     }
118 
119     public static List&lt;String&gt; getPrerequisitePackages(JPackageCommand cmd) {
120         cmd.verifyIsOfType(PackageType.LINUX);
121         var packageType = cmd.packageType();
122         switch (packageType) {
123             case LINUX_DEB:
124                 return Stream.of(getDebBundleProperty(cmd.outputBundle(),
125                         &quot;Depends&quot;).split(&quot;,&quot;)).map(String::strip).collect(
126                         Collectors.toList());
127 
128             case LINUX_RPM:
129                 return Executor.of(&quot;rpm&quot;, &quot;-qp&quot;, &quot;-R&quot;)
130                 .addArgument(cmd.outputBundle())
131                 .executeAndGetOutput();
132         }
133         // Unreachable
134         return null;
135     }
136 
137     public static String getBundleProperty(JPackageCommand cmd,
138             String propertyName) {
139         return getBundleProperty(cmd,
140                 Map.of(PackageType.LINUX_DEB, propertyName,
141                         PackageType.LINUX_RPM, propertyName));
142     }
143 
144     public static String getBundleProperty(JPackageCommand cmd,
145             Map&lt;PackageType, String&gt; propertyName) {
146         cmd.verifyIsOfType(PackageType.LINUX);
147         var packageType = cmd.packageType();
148         switch (packageType) {
149             case LINUX_DEB:
150                 return getDebBundleProperty(cmd.outputBundle(), propertyName.get(
151                         packageType));
152 
153             case LINUX_RPM:
154                 return getRpmBundleProperty(cmd.outputBundle(), propertyName.get(
155                         packageType));
156         }
157         // Unrechable
158         return null;
159     }
160 
161     static PackageHandlers createDebPackageHandlers() {
162         PackageHandlers deb = new PackageHandlers();
163         deb.installHandler = cmd -&gt; {
164             cmd.verifyIsOfType(PackageType.LINUX_DEB);
165             Executor.of(&quot;sudo&quot;, &quot;dpkg&quot;, &quot;-i&quot;)
166             .addArgument(cmd.outputBundle())
167             .execute();
168         };
169         deb.uninstallHandler = cmd -&gt; {
170             cmd.verifyIsOfType(PackageType.LINUX_DEB);
171             Executor.of(&quot;sudo&quot;, &quot;dpkg&quot;, &quot;-r&quot;, getPackageName(cmd)).execute();
172         };
173         deb.unpackHandler = (cmd, destinationDir) -&gt; {
174             cmd.verifyIsOfType(PackageType.LINUX_DEB);
175             Executor.of(&quot;dpkg&quot;, &quot;-x&quot;)
176             .addArgument(cmd.outputBundle())
177             .addArgument(destinationDir)
178             .execute();
179             return destinationDir;
180         };
181         return deb;
182     }
183 
184     static PackageHandlers createRpmPackageHandlers() {
185         PackageHandlers rpm = new PackageHandlers();
186         rpm.installHandler = cmd -&gt; {
187             cmd.verifyIsOfType(PackageType.LINUX_RPM);
188             Executor.of(&quot;sudo&quot;, &quot;rpm&quot;, &quot;-i&quot;)
189             .addArgument(cmd.outputBundle())
190             .execute();
191         };
192         rpm.uninstallHandler = cmd -&gt; {
193             cmd.verifyIsOfType(PackageType.LINUX_RPM);
194             Executor.of(&quot;sudo&quot;, &quot;rpm&quot;, &quot;-e&quot;, getPackageName(cmd)).execute();
195         };
196         rpm.unpackHandler = (cmd, destinationDir) -&gt; {
197             cmd.verifyIsOfType(PackageType.LINUX_RPM);
198             Executor.of(&quot;sh&quot;, &quot;-c&quot;, String.format(
199                     &quot;rpm2cpio &#39;%s&#39; | cpio -idm --quiet&quot;,
200                     JPackageCommand.escapeAndJoin(
201                             cmd.outputBundle().toAbsolutePath().toString())))
202             .setDirectory(destinationDir)
203             .execute();
204             return destinationDir;
205         };
206 
207         return rpm;
208     }
209 
210     static Path getLauncherPath(JPackageCommand cmd) {
211         cmd.verifyIsOfType(PackageType.LINUX);
212 
213         final String launcherName = cmd.name();
214         final String launcherRelativePath = Path.of(&quot;/bin&quot;, launcherName).toString();
215 
216         return getPackageFiles(cmd).filter(path -&gt; path.toString().endsWith(
217                 launcherRelativePath)).findFirst().or(() -&gt; {
218             TKit.assertUnexpected(String.format(
219                     &quot;Failed to find %s in %s package&quot;, launcherName,
220                     getPackageName(cmd)));
221             return null;
222         }).get();
223     }
224 
225     static long getInstalledPackageSizeKB(JPackageCommand cmd) {
226         cmd.verifyIsOfType(PackageType.LINUX);
227 
228         final Path packageFile = cmd.outputBundle();
229         switch (cmd.packageType()) {
230             case LINUX_DEB:
231                 return Long.parseLong(getDebBundleProperty(packageFile,
232                         &quot;Installed-Size&quot;));
233 
234             case LINUX_RPM:
235                 return Long.parseLong(getRpmBundleProperty(packageFile, &quot;Size&quot;)) &gt;&gt; 10;
236         }
237 
238         return 0;
239     }
240 
241     static String getDebBundleProperty(Path bundle, String fieldName) {
242         return Executor.of(&quot;dpkg-deb&quot;, &quot;-f&quot;)
243                 .addArgument(bundle)
244                 .addArgument(fieldName)
245                 .executeAndGetFirstLineOfOutput();
246     }
247 
248     static String getRpmBundleProperty(Path bundle, String fieldName) {
249         return Executor.of(&quot;rpm&quot;, &quot;-qp&quot;, &quot;--queryformat&quot;, String.format(&quot;%%{%s}&quot;, fieldName))
250                 .addArgument(bundle)
251                 .executeAndGetFirstLineOfOutput();
252     }
253 
254     static void verifyPackageBundleEssential(JPackageCommand cmd) {
255         String packageName = LinuxHelper.getPackageName(cmd);
256         TKit.assertNotEquals(0L, LinuxHelper.getInstalledPackageSizeKB(
257                 cmd), String.format(
258                         &quot;Check installed size of [%s] package in KB is not zero&quot;,
259                         packageName));
260 
261         final boolean checkPrerequisites;
262         if (cmd.isRuntime()) {
263             Path runtimeDir = cmd.appRuntimeDirectory();
264             Set&lt;Path&gt; expectedCriticalRuntimePaths = CRITICAL_RUNTIME_FILES.stream().map(
265                     runtimeDir::resolve).collect(Collectors.toSet());
266             Set&lt;Path&gt; actualCriticalRuntimePaths = getPackageFiles(cmd).filter(
267                     expectedCriticalRuntimePaths::contains).collect(
268                             Collectors.toSet());
269             checkPrerequisites = expectedCriticalRuntimePaths.equals(
270                     actualCriticalRuntimePaths);
271         } else {
272             checkPrerequisites = true;
273         }
274 
275         List&lt;String&gt; prerequisites = LinuxHelper.getPrerequisitePackages(cmd);
276         if (checkPrerequisites) {
277             final String vitalPackage = &quot;libc&quot;;
278             TKit.assertTrue(prerequisites.stream().filter(
279                     dep -&gt; dep.contains(vitalPackage)).findAny().isPresent(),
280                     String.format(
281                             &quot;Check [%s] package is in the list of required packages %s of [%s] package&quot;,
282                             vitalPackage, prerequisites, packageName));
283         } else {
284             TKit.trace(String.format(
285                     &quot;Not cheking %s required packages of [%s] package&quot;,
286                     prerequisites, packageName));
287         }
288     }
289 
290     static void addBundleDesktopIntegrationVerifier(PackageTest test,
291             boolean integrated) {
292         final String xdgUtils = &quot;xdg-utils&quot;;
293 
294         Function&lt;List&lt;String&gt;, String&gt; verifier = (lines) -&gt; {
295             // Lookup for xdg commands
296             return lines.stream().filter(line -&gt; {
297                 Set&lt;String&gt; words = Stream.of(line.split(&quot;\\s+&quot;)).collect(
298                         Collectors.toSet());
299                 return words.contains(&quot;xdg-desktop-menu&quot;) || words.contains(
300                         &quot;xdg-mime&quot;) || words.contains(&quot;xdg-icon-resource&quot;);
301             }).findFirst().orElse(null);
302         };
303 
304         test.addBundleVerifier(cmd -&gt; {
305             // Verify dependencies.
306             List&lt;String&gt; prerequisites = getPrerequisitePackages(cmd);
307             boolean xdgUtilsFound = prerequisites.contains(xdgUtils);
308             TKit.assertTrue(xdgUtilsFound == integrated, String.format(
309                     &quot;Check [%s] is%s in the list of required packages %s&quot;,
310                     xdgUtils, integrated ? &quot;&quot; : &quot; NOT&quot;, prerequisites));
311 
312             Map&lt;Scriptlet, List&lt;String&gt;&gt; scriptlets = getScriptlets(cmd);
313             if (integrated) {
314                 Set&lt;Scriptlet&gt; requiredScriptlets = Stream.of(Scriptlet.values()).sorted().collect(
315                         Collectors.toSet());
316                 TKit.assertTrue(scriptlets.keySet().containsAll(
317                         requiredScriptlets), String.format(
318                                 &quot;Check all required scriptlets %s found in the package. Package scriptlets: %s&quot;,
319                                 requiredScriptlets, scriptlets.keySet()));
320             }
321 
322             // Lookup for xdg commands in scriptlets.
323             scriptlets.entrySet().forEach(scriptlet -&gt; {
324                 String lineWithXsdCommand = verifier.apply(scriptlet.getValue());
325                 String assertMsg = String.format(
326                         &quot;Check if [%s] scriptlet uses xdg commands&quot;,
327                         scriptlet.getKey());
328                 if (integrated) {
329                     TKit.assertNotNull(lineWithXsdCommand, assertMsg);
330                 } else {
331                     TKit.assertNull(lineWithXsdCommand, assertMsg);
332                 }
333             });
334         });
335     }
336 
337     static void initFileAssociationsTestFile(Path testFile) {
338         try {
339             // Write something in test file.
340             // On Ubuntu and Oracle Linux empty files are considered
341             // plain text. Seems like a system bug.
342             //
343             // $ &gt;foo.jptest1
344             // $ xdg-mime query filetype foo.jptest1
345             // text/plain
346             // $ echo &gt; foo.jptest1
347             // $ xdg-mime query filetype foo.jptest1
348             // application/x-jpackage-jptest1
349             //
350             Files.write(testFile, Arrays.asList(&quot;&quot;));
351         } catch (IOException ex) {
352             throw new RuntimeException(ex);
353         }
354     }
355 
356     private static Path getSystemDesktopFilesFolder() {
357         return Stream.of(&quot;/usr/share/applications&quot;,
358                 &quot;/usr/local/share/applications&quot;).map(Path::of).filter(dir -&gt; {
359             return Files.exists(dir.resolve(&quot;defaults.list&quot;));
360         }).findFirst().orElseThrow(() -&gt; new RuntimeException(
361                 &quot;Failed to locate system .desktop files folder&quot;));
362     }
363 
364     static void addFileAssociationsVerifier(PackageTest test, FileAssociations fa) {
365         test.addInstallVerifier(cmd -&gt; {
366             if (cmd.isPackageUnpacked(&quot;Not running file associations checks&quot;)) {
367                 return;
368             }
369 
370             PackageTest.withTestFileAssociationsFile(fa, testFile -&gt; {
371                 String mimeType = queryFileMimeType(testFile);
372 
373                 TKit.assertEquals(fa.getMime(), mimeType, String.format(
374                         &quot;Check mime type of [%s] file&quot;, testFile));
375 
376                 String desktopFileName = queryMimeTypeDefaultHandler(mimeType);
377 
378                 Path desktopFile = getSystemDesktopFilesFolder().resolve(
379                         desktopFileName);
380 
381                 TKit.assertFileExists(desktopFile);
382 
383                 TKit.trace(String.format(&quot;Reading [%s] file...&quot;, desktopFile));
384                 String mimeHandler = Files.readAllLines(desktopFile).stream().peek(
385                         v -&gt; TKit.trace(v)).filter(
386                                 v -&gt; v.startsWith(&quot;Exec=&quot;)).map(
387                                 v -&gt; v.split(&quot;=&quot;, 2)[1]).findFirst().orElseThrow();
388 
389                 TKit.trace(String.format(&quot;Done&quot;));
390 
391                 TKit.assertEquals(cmd.appLauncherPath().toString(),
392                         mimeHandler, String.format(
393                                 &quot;Check mime type handler is the main application launcher&quot;));
394 
395             });
396         });
397 
398         test.addUninstallVerifier(cmd -&gt; {
399             PackageTest.withTestFileAssociationsFile(fa, testFile -&gt; {
400                 String mimeType = queryFileMimeType(testFile);
401 
402                 TKit.assertNotEquals(fa.getMime(), mimeType, String.format(
403                         &quot;Check mime type of [%s] file&quot;, testFile));
404 
405                 String desktopFileName = queryMimeTypeDefaultHandler(fa.getMime());
406 
407                 TKit.assertNull(desktopFileName, String.format(
408                         &quot;Check there is no default handler for [%s] mime type&quot;,
409                         fa.getMime()));
410             });
411         });
412 
413         test.addBundleVerifier(cmd -&gt; {
414             final Path mimeTypeIconFileName = fa.getLinuxIconFileName();
415             if (mimeTypeIconFileName != null) {
416                 // Verify there are xdg registration commands for mime icon file.
417                 Path mimeTypeIcon = cmd.appLayout().destktopIntegrationDirectory().resolve(
418                         mimeTypeIconFileName);
419 
420                 Map&lt;Scriptlet, List&lt;String&gt;&gt; scriptlets = getScriptlets(cmd);
421                 scriptlets.entrySet().stream().forEach(e -&gt; verifyIconInScriptlet(
422                         e.getKey(), e.getValue(), mimeTypeIcon));
423             }
424         });
425     }
426 
427     private static String queryFileMimeType(Path file) {
428         return Executor.of(&quot;xdg-mime&quot;, &quot;query&quot;, &quot;filetype&quot;).addArgument(file)
429                 .executeAndGetFirstLineOfOutput();
430     }
431 
432     private static String queryMimeTypeDefaultHandler(String mimeType) {
433         return Executor.of(&quot;xdg-mime&quot;, &quot;query&quot;, &quot;default&quot;, mimeType)
434                 .executeAndGetFirstLineOfOutput();
435     }
436 
437     private static void verifyIconInScriptlet(Scriptlet scriptletType,
438             List&lt;String&gt; scriptletBody, Path iconPathInPackage) {
439         final String dashMime = IOUtils.replaceSuffix(
440                 iconPathInPackage.getFileName(), null).toString();
441         final String xdgCmdName = &quot;xdg-icon-resource&quot;;
442 
443         Stream&lt;String&gt; scriptletBodyStream = scriptletBody.stream()
444                 .filter(str -&gt; str.startsWith(xdgCmdName))
445                 .filter(str -&gt; Pattern.compile(
446                         &quot;\\b&quot; + dashMime + &quot;\\b&quot;).matcher(str).find());
447         if (scriptletType == Scriptlet.PostInstall) {
448             scriptletBodyStream = scriptletBodyStream.filter(str -&gt; List.of(
449                     str.split(&quot;\\s+&quot;)).contains(iconPathInPackage.toString()));
450         }
451 
452         scriptletBodyStream.peek(xdgCmd -&gt; {
453             Matcher m = XDG_CMD_ICON_SIZE_PATTERN.matcher(xdgCmd);
454             TKit.assertTrue(m.find(), String.format(
455                     &quot;Check icon size is specified as a number in [%s] xdg command of [%s] scriptlet&quot;,
456                     xdgCmd, scriptletType));
457             int iconSize = Integer.parseInt(m.group(1));
458             TKit.assertTrue(XDG_CMD_VALID_ICON_SIZES.contains(iconSize),
459                     String.format(
460                             &quot;Check icon size [%s] is one of %s values&quot;,
461                             iconSize, XDG_CMD_VALID_ICON_SIZES));
462         })
463         .findFirst().orElseGet(() -&gt; {
464             TKit.assertUnexpected(String.format(
465                     &quot;Failed to find [%s] command in [%s] scriptlet for [%s] icon file&quot;,
466                     xdgCmdName, scriptletType, iconPathInPackage));
467             return null;
468         });
469     }
470 
471     private static Map&lt;Scriptlet, List&lt;String&gt;&gt; getScriptlets(
472             JPackageCommand cmd, Scriptlet... scriptlets) {
473         cmd.verifyIsOfType(PackageType.LINUX);
474 
475         Set&lt;Scriptlet&gt; scriptletSet = Set.of(
476                 scriptlets.length == 0 ? Scriptlet.values() : scriptlets);
477         switch (cmd.packageType()) {
478             case LINUX_DEB:
479                 return getDebScriptlets(cmd, scriptletSet);
480 
481             case LINUX_RPM:
482                 return getRpmScriptlets(cmd, scriptletSet);
483         }
484 
485         // Unreachable
486         return null;
487     }
488 
489     private static Map&lt;Scriptlet, List&lt;String&gt;&gt; getDebScriptlets(
490             JPackageCommand cmd, Set&lt;Scriptlet&gt; scriptlets) {
491         Map&lt;Scriptlet, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;();
492         TKit.withTempDirectory(&quot;dpkg-control-files&quot;, tempDir -&gt; {
493             // Extract control Debian package files into temporary directory
494             Executor.of(&quot;dpkg&quot;, &quot;-e&quot;)
495                     .addArgument(cmd.outputBundle())
496                     .addArgument(tempDir)
497                     .execute();
498 
499             for (Scriptlet scriptlet : scriptlets) {
500                 Path controlFile = Path.of(scriptlet.deb);
501                 result.put(scriptlet, Files.readAllLines(tempDir.resolve(
502                         controlFile)));
503             }
504         });
505         return result;
506     }
507 
508     private static Map&lt;Scriptlet, List&lt;String&gt;&gt; getRpmScriptlets(
509             JPackageCommand cmd, Set&lt;Scriptlet&gt; scriptlets) {
510         List&lt;String&gt; output = Executor.of(&quot;rpm&quot;, &quot;-qp&quot;, &quot;--scripts&quot;,
511                 cmd.outputBundle().toString()).executeAndGetOutput();
512 
513         Map&lt;Scriptlet, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;();
514         List&lt;String&gt; curScriptletBody = null;
515         for (String str : output) {
516             Matcher m = Scriptlet.RPM_HEADER_PATTERN.matcher(str);
517             if (m.find()) {
518                 Scriptlet scriptlet = Scriptlet.RPM_MAP.get(m.group(1));
519                 if (scriptlets.contains(scriptlet)) {
520                     curScriptletBody = new ArrayList&lt;&gt;();
521                     result.put(scriptlet, curScriptletBody);
522                 } else if (curScriptletBody != null) {
523                     curScriptletBody = null;
524                 }
525             } else if (curScriptletBody != null) {
526                 curScriptletBody.add(str);
527             }
528         }
529 
530         return result;
531     }
532 
533     private static enum Scriptlet {
534         PostInstall(&quot;postinstall&quot;, &quot;postinst&quot;),
535         PreUninstall(&quot;preuninstall&quot;, &quot;prerm&quot;);
536 
537         Scriptlet(String rpm, String deb) {
538             this.rpm = rpm;
539             this.deb = deb;
540         }
541 
542         private final String rpm;
543         private final String deb;
544 
545         static final Pattern RPM_HEADER_PATTERN = Pattern.compile(String.format(
546                 &quot;(%s) scriptlet \\(using /bin/sh\\):&quot;, Stream.of(values()).map(
547                         v -&gt; v.rpm).collect(Collectors.joining(&quot;|&quot;))));
548 
549         static final Map&lt;String, Scriptlet&gt; RPM_MAP = Stream.of(values()).collect(
550                 Collectors.toMap(v -&gt; v.rpm, v -&gt; v));
551     };
552 
553     public static String getDefaultPackageArch(PackageType type) {
554         if (archs == null) {
555             archs = new HashMap&lt;&gt;();
556         }
557 
558         String arch = archs.get(type);
559         if (arch == null) {
560             Executor exec = null;
561             switch (type) {
562                 case LINUX_DEB:
563                     exec = Executor.of(&quot;dpkg&quot;, &quot;--print-architecture&quot;);
564                     break;
565 
566                 case LINUX_RPM:
567                     exec = Executor.of(&quot;rpmbuild&quot;, &quot;--eval=%{_target_cpu}&quot;);
568                     break;
569             }
570             arch = exec.executeAndGetFirstLineOfOutput();
571             archs.put(type, arch);
572         }
573         return arch;
574     }
575 
576     static final Set&lt;Path&gt; CRITICAL_RUNTIME_FILES = Set.of(Path.of(
577             &quot;lib/server/libjvm.so&quot;));
578 
579     private static Map&lt;PackageType, String&gt; archs;
580 
581     private final static Pattern XDG_CMD_ICON_SIZE_PATTERN = Pattern.compile(&quot;\\s--size\\s+(\\d+)\\b&quot;);
582 
583     // Values grabbed from https://linux.die.net/man/1/xdg-icon-resource
584     private final static Set&lt;Integer&gt; XDG_CMD_VALID_ICON_SIZES = Set.of(16, 22, 32, 48, 64, 128);
585 }
    </pre>
  </body>
</html>
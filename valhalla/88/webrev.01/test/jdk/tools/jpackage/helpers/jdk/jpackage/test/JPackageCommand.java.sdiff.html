<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/tools/jpackage/helpers/jdk/jpackage/test/JPackageCommand.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FileAssociations.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LinuxHelper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/tools/jpackage/helpers/jdk/jpackage/test/JPackageCommand.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jpackage.test;
 27 
 28 import java.io.FileOutputStream;
 29 import java.io.IOException;
 30 import java.nio.file.Files;
 31 import java.nio.file.Path;
 32 import java.security.SecureRandom;
 33 import java.util.*;
 34 import java.util.function.Consumer;
 35 import java.util.function.Function;
 36 import java.util.function.Predicate;
 37 import java.util.function.Supplier;
 38 import java.util.regex.Pattern;
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;

 41 import jdk.incubator.jpackage.internal.ApplicationLayout;
 42 import jdk.jpackage.test.Functional.ThrowingConsumer;
 43 import jdk.jpackage.test.Functional.ThrowingFunction;
 44 import jdk.jpackage.test.Functional.ThrowingSupplier;
 45 
 46 /**
 47  * jpackage command line with prerequisite actions. Prerequisite actions can be
 48  * anything. The simplest is to compile test application and pack in a jar for
 49  * use on jpackage command line.
 50  */
 51 public final class JPackageCommand extends CommandArguments&lt;JPackageCommand&gt; {
 52 
 53     public JPackageCommand() {
 54         prerequisiteActions = new Actions();
 55         verifyActions = new Actions();
 56     }
 57 
 58     public JPackageCommand(JPackageCommand cmd) {
 59         args.addAll(cmd.args);
 60         withToolProvider = cmd.withToolProvider;
</pre>
<hr />
<pre>
218     public JPackageCommand setFakeRuntime() {
219         verifyMutable();
220 
221         ThrowingConsumer&lt;Path&gt; createBulkFile = path -&gt; {
222             Files.createDirectories(path.getParent());
223             try (FileOutputStream out = new FileOutputStream(path.toFile())) {
224                 byte[] bytes = new byte[4 * 1024];
225                 new SecureRandom().nextBytes(bytes);
226                 out.write(bytes);
227             }
228         };
229 
230         addPrerequisiteAction(cmd -&gt; {
231             Path fakeRuntimeDir = TKit.workDir().resolve(&quot;fake_runtime&quot;);
232 
233             TKit.trace(String.format(&quot;Init fake runtime in [%s] directory&quot;,
234                     fakeRuntimeDir));
235 
236             Files.createDirectories(fakeRuntimeDir);
237 
<span class="line-modified">238             if (TKit.isWindows() || TKit.isLinux()) {</span>
<span class="line-removed">239                 // Needed to make WindowsAppBundler happy as it copies MSVC dlls</span>
<span class="line-removed">240                 // from `bin` directory.</span>
241                 // Need to make the code in rpm spec happy as it assumes there is
242                 // always something in application image.
243                 fakeRuntimeDir.resolve(&quot;bin&quot;).toFile().mkdir();
244             }
245 
246             if (TKit.isOSX()) {
247                 // Make MacAppImageBuilder happy
248                 createBulkFile.accept(fakeRuntimeDir.resolve(Path.of(
<span class="line-modified">249                         &quot;Contents/Home/lib/jli/libjli.dylib&quot;)));</span>
250             }
251 
252             // Mak sure fake runtime takes some disk space.
253             // Package bundles with 0KB size are unexpected and considered
254             // an error by PackageTest.
255             createBulkFile.accept(fakeRuntimeDir.resolve(Path.of(&quot;bin&quot;, &quot;bulk&quot;)));
256 
257             cmd.addArguments(&quot;--runtime-image&quot;, fakeRuntimeDir);
258         });
259 
260         return this;
261     }
262 
263     JPackageCommand addPrerequisiteAction(ThrowingConsumer&lt;JPackageCommand&gt; action) {
264         verifyMutable();
265         prerequisiteActions.add(action);
266         return this;
267     }
268 
269     JPackageCommand addVerifyAction(ThrowingConsumer&lt;JPackageCommand&gt; action) {
</pre>
<hr />
<pre>
663             executeVerifyActions();
664         }
665 
666         return result;
667     }
668 
669     public Executor.Result executeAndAssertHelloAppImageCreated() {
670         Executor.Result result = executeAndAssertImageCreated();
671         HelloApp.executeLauncherAndVerifyOutput(this);
672         return result;
673     }
674 
675     public Executor.Result executeAndAssertImageCreated() {
676         Executor.Result result = execute();
677         assertImageCreated();
678         return result;
679     }
680 
681     public JPackageCommand assertImageCreated() {
682         verifyIsOfType(PackageType.IMAGE);






































683         TKit.assertDirectoryExists(appRuntimeDirectory());
684 
685         if (!isRuntime()) {
686             TKit.assertExecutableFileExists(appLauncherPath());
687             TKit.assertFileExists(appLauncherCfgPath(null));
688         }
689 





690         return this;
691     }
692 
693     JPackageCommand setUnpackedPackageLocation(Path path) {
694         verifyIsOfType(PackageType.NATIVE);
695         setArgumentValue(UNPACKED_PATH_ARGNAME, path);
696         return this;
697     }
698 
699     private JPackageCommand adjustArgumentsBeforeExecution() {
700         if (!hasArgument(&quot;--runtime-image&quot;) &amp;&amp; !hasArgument(&quot;--app-image&quot;) &amp;&amp; DEFAULT_RUNTIME_IMAGE != null &amp;&amp; !ignoreDefaultRuntime) {
701             addArguments(&quot;--runtime-image&quot;, DEFAULT_RUNTIME_IMAGE);
702         }
703 
704         if (!hasArgument(&quot;--verbose&quot;) &amp;&amp; TKit.VERBOSE_JPACKAGE &amp;&amp; !ignoreDefaultVerbose) {
705             addArgument(&quot;--verbose&quot;);
706         }
707 
708         return this;
709     }
</pre>
<hr />
<pre>
768         return escapeAndJoin(List.of(args));
769     }
770 
771     public static String escapeAndJoin(List&lt;String&gt; args) {
772         Pattern whitespaceRegexp = Pattern.compile(&quot;\\s&quot;);
773 
774         return args.stream().map(v -&gt; {
775             String str = v;
776             // Escape backslashes.
777             str = str.replace(&quot;\\&quot;, &quot;\\\\&quot;);
778             // Escape quotes.
779             str = str.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;);
780             // If value contains whitespace characters, put the value in quotes
781             if (whitespaceRegexp.matcher(str).find()) {
782                 str = &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
783             }
784             return str;
785         }).collect(Collectors.joining(&quot; &quot;));
786     }
787 
<span class="line-removed">788     public static Path relativePathInRuntime(JavaTool tool) {</span>
<span class="line-removed">789         Path path = tool.relativePathInJavaHome();</span>
<span class="line-removed">790         if (TKit.isOSX()) {</span>
<span class="line-removed">791             path = Path.of(&quot;Contents/Home&quot;).resolve(path);</span>
<span class="line-removed">792         }</span>
<span class="line-removed">793         return path;</span>
<span class="line-removed">794     }</span>
<span class="line-removed">795 </span>
796     public static Stream&lt;String&gt; filterOutput(Stream&lt;String&gt; jpackageOutput) {
797         // Skip &quot;WARNING: Using incubator ...&quot; first line of output
798         return jpackageOutput.skip(1);
799     }
800 
801     public static List&lt;String&gt; filterOutput(List&lt;String&gt; jpackageOutput) {
802         return filterOutput(jpackageOutput.stream()).collect(Collectors.toList());
803     }
804 
805     @Override
806     protected boolean isMutable() {
807         return !immutable;
808     }
809 
810     private &lt;T&gt; T onLinuxPackageInstallDir(Function&lt;Path, T&gt; anyInstallDirConsumer,
811             Function&lt;Path, T&gt; usrInstallDirConsumer) {
812         if (TKit.isLinux()) {
813             Path installDir = Path.of(getArgumentValue(&quot;--install-dir&quot;,
814                     () -&gt; &quot;/opt&quot;));
815             if (Set.of(&quot;/usr&quot;, &quot;/usr/local&quot;).contains(installDir.toString())) {
</pre>
</td>
<td>
<hr />
<pre>
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jpackage.test;
 27 
 28 import java.io.FileOutputStream;
 29 import java.io.IOException;
 30 import java.nio.file.Files;
 31 import java.nio.file.Path;
 32 import java.security.SecureRandom;
 33 import java.util.*;
 34 import java.util.function.Consumer;
 35 import java.util.function.Function;
 36 import java.util.function.Predicate;
 37 import java.util.function.Supplier;
 38 import java.util.regex.Pattern;
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;
<span class="line-added"> 41 import jdk.incubator.jpackage.internal.AppImageFile;</span>
 42 import jdk.incubator.jpackage.internal.ApplicationLayout;
 43 import jdk.jpackage.test.Functional.ThrowingConsumer;
 44 import jdk.jpackage.test.Functional.ThrowingFunction;
 45 import jdk.jpackage.test.Functional.ThrowingSupplier;
 46 
 47 /**
 48  * jpackage command line with prerequisite actions. Prerequisite actions can be
 49  * anything. The simplest is to compile test application and pack in a jar for
 50  * use on jpackage command line.
 51  */
 52 public final class JPackageCommand extends CommandArguments&lt;JPackageCommand&gt; {
 53 
 54     public JPackageCommand() {
 55         prerequisiteActions = new Actions();
 56         verifyActions = new Actions();
 57     }
 58 
 59     public JPackageCommand(JPackageCommand cmd) {
 60         args.addAll(cmd.args);
 61         withToolProvider = cmd.withToolProvider;
</pre>
<hr />
<pre>
219     public JPackageCommand setFakeRuntime() {
220         verifyMutable();
221 
222         ThrowingConsumer&lt;Path&gt; createBulkFile = path -&gt; {
223             Files.createDirectories(path.getParent());
224             try (FileOutputStream out = new FileOutputStream(path.toFile())) {
225                 byte[] bytes = new byte[4 * 1024];
226                 new SecureRandom().nextBytes(bytes);
227                 out.write(bytes);
228             }
229         };
230 
231         addPrerequisiteAction(cmd -&gt; {
232             Path fakeRuntimeDir = TKit.workDir().resolve(&quot;fake_runtime&quot;);
233 
234             TKit.trace(String.format(&quot;Init fake runtime in [%s] directory&quot;,
235                     fakeRuntimeDir));
236 
237             Files.createDirectories(fakeRuntimeDir);
238 
<span class="line-modified">239             if (TKit.isLinux()) {</span>


240                 // Need to make the code in rpm spec happy as it assumes there is
241                 // always something in application image.
242                 fakeRuntimeDir.resolve(&quot;bin&quot;).toFile().mkdir();
243             }
244 
245             if (TKit.isOSX()) {
246                 // Make MacAppImageBuilder happy
247                 createBulkFile.accept(fakeRuntimeDir.resolve(Path.of(
<span class="line-modified">248                         &quot;lib/jli/libjli.dylib&quot;)));</span>
249             }
250 
251             // Mak sure fake runtime takes some disk space.
252             // Package bundles with 0KB size are unexpected and considered
253             // an error by PackageTest.
254             createBulkFile.accept(fakeRuntimeDir.resolve(Path.of(&quot;bin&quot;, &quot;bulk&quot;)));
255 
256             cmd.addArguments(&quot;--runtime-image&quot;, fakeRuntimeDir);
257         });
258 
259         return this;
260     }
261 
262     JPackageCommand addPrerequisiteAction(ThrowingConsumer&lt;JPackageCommand&gt; action) {
263         verifyMutable();
264         prerequisiteActions.add(action);
265         return this;
266     }
267 
268     JPackageCommand addVerifyAction(ThrowingConsumer&lt;JPackageCommand&gt; action) {
</pre>
<hr />
<pre>
662             executeVerifyActions();
663         }
664 
665         return result;
666     }
667 
668     public Executor.Result executeAndAssertHelloAppImageCreated() {
669         Executor.Result result = executeAndAssertImageCreated();
670         HelloApp.executeLauncherAndVerifyOutput(this);
671         return result;
672     }
673 
674     public Executor.Result executeAndAssertImageCreated() {
675         Executor.Result result = execute();
676         assertImageCreated();
677         return result;
678     }
679 
680     public JPackageCommand assertImageCreated() {
681         verifyIsOfType(PackageType.IMAGE);
<span class="line-added">682         assertAppLayout();</span>
<span class="line-added">683         return this;</span>
<span class="line-added">684     }</span>
<span class="line-added">685 </span>
<span class="line-added">686     JPackageCommand assertAppLayout() {</span>
<span class="line-added">687         if (isPackageUnpacked() || isImagePackageType()) {</span>
<span class="line-added">688             final Path rootDir = isPackageUnpacked() ? pathToUnpackedPackageFile(</span>
<span class="line-added">689                     appInstallationDirectory()) : outputBundle();</span>
<span class="line-added">690             final Path appImageFileName = AppImageFile.getPathInAppImage(</span>
<span class="line-added">691                     Path.of(&quot;&quot;)).getFileName();</span>
<span class="line-added">692             try (Stream&lt;Path&gt; walk = ThrowingSupplier.toSupplier(</span>
<span class="line-added">693                     () -&gt; Files.walk(rootDir)).get()) {</span>
<span class="line-added">694                 List&lt;String&gt; appImageFiles = walk</span>
<span class="line-added">695                         .filter(path -&gt; path.getFileName().equals(appImageFileName))</span>
<span class="line-added">696                         .map(Path::toString)</span>
<span class="line-added">697                         .collect(Collectors.toList());</span>
<span class="line-added">698                 if (isImagePackageType() || TKit.isOSX()) {</span>
<span class="line-added">699                     List&lt;String&gt; expected = List.of(</span>
<span class="line-added">700                             AppImageFile.getPathInAppImage(rootDir).toString());</span>
<span class="line-added">701                     TKit.assertStringListEquals(expected, appImageFiles,</span>
<span class="line-added">702                             String.format(</span>
<span class="line-added">703                                     &quot;Check there is only one file with [%s] name in the package&quot;,</span>
<span class="line-added">704                                     appImageFileName));</span>
<span class="line-added">705                 } else {</span>
<span class="line-added">706                     TKit.assertStringListEquals(List.of(), appImageFiles,</span>
<span class="line-added">707                             String.format(</span>
<span class="line-added">708                                     &quot;Check there are no files with [%s] name in the package&quot;,</span>
<span class="line-added">709                                     appImageFileName));</span>
<span class="line-added">710                 }</span>
<span class="line-added">711             }</span>
<span class="line-added">712         } else if (TKit.isOSX()) {</span>
<span class="line-added">713             TKit.assertFileExists(AppImageFile.getPathInAppImage(</span>
<span class="line-added">714                     appInstallationDirectory()));</span>
<span class="line-added">715         } else {</span>
<span class="line-added">716             TKit.assertPathExists(AppImageFile.getPathInAppImage(</span>
<span class="line-added">717                     appInstallationDirectory()), false);</span>
<span class="line-added">718         }</span>
<span class="line-added">719 </span>
720         TKit.assertDirectoryExists(appRuntimeDirectory());
721 
722         if (!isRuntime()) {
723             TKit.assertExecutableFileExists(appLauncherPath());
724             TKit.assertFileExists(appLauncherCfgPath(null));
725         }
726 
<span class="line-added">727         if (TKit.isOSX()) {</span>
<span class="line-added">728             TKit.assertFileExists(appRuntimeDirectory().resolve(</span>
<span class="line-added">729                     &quot;Contents/MacOS/libjli.dylib&quot;));</span>
<span class="line-added">730         }</span>
<span class="line-added">731 </span>
732         return this;
733     }
734 
735     JPackageCommand setUnpackedPackageLocation(Path path) {
736         verifyIsOfType(PackageType.NATIVE);
737         setArgumentValue(UNPACKED_PATH_ARGNAME, path);
738         return this;
739     }
740 
741     private JPackageCommand adjustArgumentsBeforeExecution() {
742         if (!hasArgument(&quot;--runtime-image&quot;) &amp;&amp; !hasArgument(&quot;--app-image&quot;) &amp;&amp; DEFAULT_RUNTIME_IMAGE != null &amp;&amp; !ignoreDefaultRuntime) {
743             addArguments(&quot;--runtime-image&quot;, DEFAULT_RUNTIME_IMAGE);
744         }
745 
746         if (!hasArgument(&quot;--verbose&quot;) &amp;&amp; TKit.VERBOSE_JPACKAGE &amp;&amp; !ignoreDefaultVerbose) {
747             addArgument(&quot;--verbose&quot;);
748         }
749 
750         return this;
751     }
</pre>
<hr />
<pre>
810         return escapeAndJoin(List.of(args));
811     }
812 
813     public static String escapeAndJoin(List&lt;String&gt; args) {
814         Pattern whitespaceRegexp = Pattern.compile(&quot;\\s&quot;);
815 
816         return args.stream().map(v -&gt; {
817             String str = v;
818             // Escape backslashes.
819             str = str.replace(&quot;\\&quot;, &quot;\\\\&quot;);
820             // Escape quotes.
821             str = str.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;);
822             // If value contains whitespace characters, put the value in quotes
823             if (whitespaceRegexp.matcher(str).find()) {
824                 str = &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
825             }
826             return str;
827         }).collect(Collectors.joining(&quot; &quot;));
828     }
829 








830     public static Stream&lt;String&gt; filterOutput(Stream&lt;String&gt; jpackageOutput) {
831         // Skip &quot;WARNING: Using incubator ...&quot; first line of output
832         return jpackageOutput.skip(1);
833     }
834 
835     public static List&lt;String&gt; filterOutput(List&lt;String&gt; jpackageOutput) {
836         return filterOutput(jpackageOutput.stream()).collect(Collectors.toList());
837     }
838 
839     @Override
840     protected boolean isMutable() {
841         return !immutable;
842     }
843 
844     private &lt;T&gt; T onLinuxPackageInstallDir(Function&lt;Path, T&gt; anyInstallDirConsumer,
845             Function&lt;Path, T&gt; usrInstallDirConsumer) {
846         if (TKit.isLinux()) {
847             Path installDir = Path.of(getArgumentValue(&quot;--install-dir&quot;,
848                     () -&gt; &quot;/opt&quot;));
849             if (Set.of(&quot;/usr&quot;, &quot;/usr/local&quot;).contains(installDir.toString())) {
</pre>
</td>
</tr>
</table>
<center><a href="FileAssociations.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LinuxHelper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebugger.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package nsk.share.jdi;
 24 
 25 import java.util.*;
 26 import com.sun.jdi.*;
 27 import nsk.share.TestBug;
 28 
 29 /*
 30  * Debugger class used in tests for heapwalking(tests for VirtualMachine.instanceCounts, ReferenceType.instances, ObjectReference.referrers)
 31  * Contains several common checking and auxiliary methods.
 32  */
 33 public class HeapwalkingDebugger extends TestDebuggerType2 {
 34     // instances of some classes couldn&#39;t be strictly controlled during test execution, use non-strict checks for this classes
 35     protected boolean strictCheck(String className) {
 36         if (className.equals(&quot;java.lang.String&quot;))
 37             return false;
 38 
 39         if (className.equals(&quot;char[]&quot;))
 40             return false;
 41 
 42         if (className.equals(&quot;byte[]&quot;))
 43             return false;
 44 
 45         if (className.equals(&quot;boolean[]&quot;))
 46             return false;
 47 
 48         if (className.equals(&quot;float[]&quot;))
 49             return false;
 50 
 51         if (className.equals(&quot;long[]&quot;))
 52             return false;
 53 
 54         if (className.equals(&quot;int[]&quot;))
 55             return false;
 56 
 57         if (className.equals(&quot;double[]&quot;))
 58             return false;
 59 
 60         if (className.equals(&quot;java.lang.Thread&quot;)) {
 61             return !isJFRActive();
 62         }
 63 
 64         return true;
 65     }
 66 
 67     protected boolean isJFRActive() {
 68        ReferenceType referenceType = debuggee.classByName(&quot;nsk.share.jdi.HeapwalkingDebuggee&quot;);
 69        if (referenceType == null)
 70            throw new RuntimeException(&quot;Debugeee is not initialized yet&quot;);
 71 
 72         Field isJFRActiveFld = referenceType.fieldByName(&quot;isJFRActive&quot;);
 73         boolean isJFRActive = ((BooleanValue)referenceType.getValue(isJFRActiveFld)).value();
 74         return isJFRActive;
 75     }
 76 
 77     // wrapper for VirtualMachine.instanceCounts
 78     public long getInstanceCount(String className) {
 79         List&lt;ReferenceType&gt; list = vm.classesByName(className);
 80 
 81         if (list.size() == 0)
 82             return 0;
 83 
 84         if (list.size() &gt; 1) {
 85             setSuccess(false);
 86             log.complain(&quot;Unexpected collection size returned by VirtualMachine.classesByName(&quot; + className + &quot;): &quot; + list.size()
 87                     + &quot;, only 1 entry was expected.&quot;);
 88         }
 89 
 90         long result[] = (vm.instanceCounts(list));
 91 
 92         return result[0];
 93     }
 94 
 95     // tests that vm.instanceCounts(vm.allClasses()) doesn&#39;t throws any exceptions
 96     protected void testInstanceCounts() {
 97         try {
 98             vm.instanceCounts(vm.allClasses());
 99         } catch (Throwable t) {
100             setSuccess(false);
101             log.complain(&quot;Unexpected exception: &quot; + t);
102             t.printStackTrace(log.getOutStream());
103         }
104 
105     }
106 
107     // check size of list returned by ReferenceType.instances
108     protected void checkDebugeeAnswer_instances(String className, int expectedCount) {
109         ReferenceType referenceType = debuggee.classByName(className);
110 
111         int instanceCounts = referenceType.instances(0).size();
112 
113         if (strictCheck(className)) {
114             if (referenceType.instances(0).size() != expectedCount) {
115                 setSuccess(false);
116                 log.complain(&quot;Unexpected size of referenceType.instances(&quot; + className + &quot;): &quot; + instanceCounts + &quot;, expected: &quot; + expectedCount);
117             }
118         } else {
119             if (referenceType.instances(0).size() &lt; expectedCount) {
120                 setSuccess(false);
121                 log.complain(&quot;Unexpected size of referenceType.instances(&quot; + className + &quot;): &quot; + instanceCounts + &quot;, expected: &gt;= &quot; + expectedCount);
122             }
123         }
124     }
125 
126     // check value returned by VirtualMachine.instanceCounts,
127     // note that method call method isDebuggeeReady() which check that debuggee completed pervious command and is ready for new one
128     public void checkDebugeeAnswer_instanceCounts(String className, int expectedValue) {
129         if (!isDebuggeeReady())
130             return;
131 
132         try {
133             long instanceCounts = getInstanceCount(className);
134 
135             if (strictCheck(className)) {
136                 if (instanceCounts != expectedValue) {
137                     setSuccess(false);
138                     log.complain(&quot;Wrong value was returned  by VirtualMachine.instanceCounts(&quot; + className + &quot;): &quot; + instanceCounts + &quot;, expected: &quot;
139                             + expectedValue);
140                 }
141             } else {
142                 if (instanceCounts &lt; expectedValue) {
143                     setSuccess(false);
144                     log.complain(&quot;Wrong value was returned  by VirtualMachine.instanceCounts(&quot; + className + &quot;): &quot; + instanceCounts
145                             + &quot;, expected: &gt;= &quot; + expectedValue);
146                 }
147             }
148         } catch (Throwable e) {
149             setSuccess(false);
150 
151             log.complain(&quot;Unexpected exception when getting instance count info:&quot;);
152             e.printStackTrace(log.getOutStream());
153         }
154     }
155 
156     // Verifies number of instances of a class.
157     // Two types of checks are done:
158     //   1. Current instances &gt;= old instances + created instances.
159     //   2. New instances &gt;= created instances.
160     //
161     // The check in case 1 can only be done for classes where the test controls
162     // all created and deleted instances.
163     // Other classes, like java.lang.String, can not make this check since
164     // an instance in &quot;old instances&quot; may have been removed by a GC.
165     // In that case the tetst would fail because it finds too few current instances.
166     public void checkDebugeeAnswer_instanceCounts(String className, int countCreated, List&lt;ObjectReference&gt; oldReferences) {
167         if (strictCheck(className)) {
168             int countAll = countCreated + oldReferences.size();
169             checkDebugeeAnswer_instanceCounts(className, countAll);
170             checkDebugeeAnswer_instances(className, countAll);
171         } else {
172             // isDebuggeeReady() check is hidden in checkDebugeeAnswer_instanceCounts() above.
173             // Must call it separately if we don&#39;t call checkDebugeeAnswer_instanceCounts().
174             if (!isDebuggeeReady()) {
175                 return;
176             }
177         }
178 
179         // Verify number of new instances created.
180         int countFoundCreated = countNewInstances(className, oldReferences);
181         if (countFoundCreated &lt; countCreated) {
182             setSuccess(false);
183             log.complain(&quot;Too few new instances(&quot; + className + &quot;). Expected &gt;= &quot; + countCreated + &quot;, found &quot; + countFoundCreated);
184         }
185     }
186 
187     private int countNewInstances(String className, List&lt;ObjectReference&gt; oldReferences) {
188         // New references = current references - old references.
189         List&lt;ObjectReference&gt; newReferences = new ArrayList&lt;ObjectReference&gt;(getObjectReferences(className, vm));
190         newReferences.removeAll(oldReferences);
191         return newReferences.size();
192     }
193 
194     // check value returned by InterfaceType.instances
195     protected void checkDebugeeAnswer_InterfaceType_instances(InterfaceType interfaceType, int expectedInstances) {
196         int instanceCounts = interfaceType.instances(0).size();
197 
198         if (instanceCounts != expectedInstances) {
199             setSuccess(false);
200             log.complain(&quot;List with wrong size was returned by InterfaceType.instances(&quot; + interfaceType.name() + &quot;): &quot; + instanceCounts
201                          + &quot;, expected: &quot; + expectedInstances);
202         }
203     }
204 
205     static public List&lt;ObjectReference&gt; filterObjectReferrence(List&lt;ObjectReference&gt; objectsToFilter, List&lt;ObjectReference&gt; sourceList) {
206         List&lt;ObjectReference&gt; result = new ArrayList&lt;ObjectReference&gt;();
207 
208         for (ObjectReference object : sourceList) {
209             if (!objectsToFilter.contains(object))
210                 result.add(object);
211         }
212 
213         return result;
214     }
215 
216     static public List&lt;ObjectReference&gt; getObjectReferences(String className, VirtualMachine vm) {
217         List&lt;ReferenceType&gt; referenceTypes = vm.classesByName(className);
218 
219         List&lt;ObjectReference&gt; objectReferences;
220 
221         if (referenceTypes.size() == 0)
222             objectReferences = new ArrayList&lt;ObjectReference&gt;();
223         else if (referenceTypes.size() == 1)
224             objectReferences = referenceTypes.get(0).instances(0);
225         else {
226             throw new TestBug(&quot;Unexpected collection size returned by VirtualMachine.classesByName: &quot; + referenceTypes.size()
227                     + &quot;, only 1 entry was expected.&quot;);
228         }
229 
230         return objectReferences;
231     }
232 
233 }
    </pre>
  </body>
</html>
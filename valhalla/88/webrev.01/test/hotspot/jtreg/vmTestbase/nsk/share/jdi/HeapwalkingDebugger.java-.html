<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/share/jdi/HeapwalkingDebugger.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package nsk.share.jdi;
 24 
 25 import java.util.*;
 26 import com.sun.jdi.*;
 27 import nsk.share.TestBug;
 28 
 29 /*
 30  * Debugger class used in tests for heapwalking(tests for VirtualMachine.instanceCounts, ReferenceType.instances, ObjectReference.referrers)
 31  * Contains several common checking and auxiliary methods.
 32  */
 33 public class HeapwalkingDebugger extends TestDebuggerType2 {
 34     // instances of some classes couldn&#39;t be strictly controlled during test execution, use non-strict checks for this classes
 35     protected boolean strictCheck(String className) {
 36         boolean otherThreadPresent = isJFR_active();
 37         return HeapwalkingDebuggee.useStrictCheck(className, otherThreadPresent);
 38     }
 39 
 40     // wrapper for VirtualMachine.instanceCounts
 41     public long getInstanceCount(String className) {
 42         List&lt;ReferenceType&gt; list = vm.classesByName(className);
 43 
 44         if (list.size() == 0)
 45             return 0;
 46 
 47         if (list.size() &gt; 1) {
 48             setSuccess(false);
 49             log.complain(&quot;Unexpected collection size returned by VirtualMachine.classesByName(&quot; + className + &quot;): &quot; + list.size()
 50                     + &quot;, only 1 entry was expected.&quot;);
 51         }
 52 
 53         long result[] = (vm.instanceCounts(list));
 54 
 55         return result[0];
 56     }
 57 
 58     // tests that vm.instanceCounts(vm.allClasses()) doesn&#39;t throws any exceptions
 59     protected void testInstanceCounts() {
 60         try {
 61             vm.instanceCounts(vm.allClasses());
 62         } catch (Throwable t) {
 63             setSuccess(false);
 64             log.complain(&quot;Unexpected exception: &quot; + t);
 65             t.printStackTrace(log.getOutStream());
 66         }
 67 
 68     }
 69 
 70     // check size of list returned by ReferenceType.instances
 71     protected void checkDebugeeAnswer_instances(String className, int expectedCount) {
 72         ReferenceType referenceType = debuggee.classByName(className);
 73 
 74         int instanceCounts = referenceType.instances(0).size();
 75 
 76         if (strictCheck(className)) {
 77             if (referenceType.instances(0).size() != expectedCount) {
 78                 setSuccess(false);
 79                 log.complain(&quot;Unexpected size of referenceType.instances(&quot; + className + &quot;): &quot; + instanceCounts + &quot;, expected: &quot; + expectedCount);
 80             }
 81         } else {
 82             if (referenceType.instances(0).size() &lt; expectedCount) {
 83                 setSuccess(false);
 84                 log.complain(&quot;Unexpected size of referenceType.instances(&quot; + className + &quot;): &quot; + instanceCounts + &quot;, expected: &gt;= &quot; + expectedCount);
 85             }
 86         }
 87     }
 88 
 89     // check value returned by VirtualMachine.instanceCounts,
 90     // note that method call method isDebuggeeReady() which check that debuggee completed pervious command and is ready for new one
 91     public void checkDebugeeAnswer_instanceCounts(String className, int expectedValue) {
 92         if (!isDebuggeeReady())
 93             return;
 94 
 95         try {
 96             long instanceCounts = getInstanceCount(className);
 97 
 98             if (strictCheck(className)) {
 99                 if (instanceCounts != expectedValue) {
100                     setSuccess(false);
101                     log.complain(&quot;Wrong value was returned  by VirtualMachine.instanceCounts(&quot; + className + &quot;): &quot; + instanceCounts + &quot;, expected: &quot;
102                             + expectedValue);
103                 }
104             } else {
105                 if (instanceCounts &lt; expectedValue) {
106                     setSuccess(false);
107                     log.complain(&quot;Wrong value was returned  by VirtualMachine.instanceCounts(&quot; + className + &quot;): &quot; + instanceCounts
108                             + &quot;, expected: &gt;= &quot; + expectedValue);
109                 }
110             }
111         } catch (Throwable e) {
112             setSuccess(false);
113 
114             log.complain(&quot;Unexpected exception when getting instance count info:&quot;);
115             e.printStackTrace(log.getOutStream());
116         }
117     }
118 
119     // Verifies number of instances of a class.
120     // Two types of checks are done:
121     //   1. Current instances &gt;= old instances + created instances.
122     //   2. New instances &gt;= created instances.
123     //
124     // The check in case 1 can only be done for classes where the test controls
125     // all created and deleted instances.
126     // Other classes, like java.lang.String, can not make this check since
127     // an instance in &quot;old instances&quot; may have been removed by a GC.
128     // In that case the tetst would fail because it finds too few current instances.
129     public void checkDebugeeAnswer_instanceCounts(String className, int countCreated, List&lt;ObjectReference&gt; oldReferences) {
130         if (strictCheck(className)) {
131             int countAll = countCreated + oldReferences.size();
132             checkDebugeeAnswer_instanceCounts(className, countAll);
133             checkDebugeeAnswer_instances(className, countAll);
134         } else {
135             // isDebuggeeReady() check is hidden in checkDebugeeAnswer_instanceCounts() above.
136             // Must call it separately if we don&#39;t call checkDebugeeAnswer_instanceCounts().
137             if (!isDebuggeeReady()) {
138                 return;
139             }
140         }
141 
142         // Verify number of new instances created.
143         int countFoundCreated = countNewInstances(className, oldReferences);
144         if (countFoundCreated &lt; countCreated) {
145             setSuccess(false);
146             log.complain(&quot;Too few new instances(&quot; + className + &quot;). Expected &gt;= &quot; + countCreated + &quot;, found &quot; + countFoundCreated);
147         }
148     }
149 
150     private int countNewInstances(String className, List&lt;ObjectReference&gt; oldReferences) {
151         // New references = current references - old references.
152         List&lt;ObjectReference&gt; newReferences = new ArrayList&lt;ObjectReference&gt;(getObjectReferences(className, vm));
153         newReferences.removeAll(oldReferences);
154         return newReferences.size();
155     }
156 
157     // check value returned by InterfaceType.instances
158     protected void checkDebugeeAnswer_InterfaceType_instances(InterfaceType interfaceType, int expectedInstances) {
159         int instanceCounts = interfaceType.instances(0).size();
160 
161         if (instanceCounts != expectedInstances) {
162             setSuccess(false);
163             log.complain(&quot;List with wrong size was returned by InterfaceType.instances(&quot; + interfaceType.name() + &quot;): &quot; + instanceCounts
164                          + &quot;, expected: &quot; + expectedInstances);
165         }
166     }
167 
168     static public List&lt;ObjectReference&gt; filterObjectReferrence(List&lt;ObjectReference&gt; objectsToFilter, List&lt;ObjectReference&gt; sourceList) {
169         List&lt;ObjectReference&gt; result = new ArrayList&lt;ObjectReference&gt;();
170 
171         for (ObjectReference object : sourceList) {
172             if (!objectsToFilter.contains(object))
173                 result.add(object);
174         }
175 
176         return result;
177     }
178 
179     static public List&lt;ObjectReference&gt; getObjectReferences(String className, VirtualMachine vm) {
180         List&lt;ReferenceType&gt; referenceTypes = vm.classesByName(className);
181 
182         List&lt;ObjectReference&gt; objectReferences;
183 
184         if (referenceTypes.size() == 0)
185             objectReferences = new ArrayList&lt;ObjectReference&gt;();
186         else if (referenceTypes.size() == 1)
187             objectReferences = referenceTypes.get(0).instances(0);
188         else {
189             throw new TestBug(&quot;Unexpected collection size returned by VirtualMachine.classesByName: &quot; + referenceTypes.size()
190                     + &quot;, only 1 entry was expected.&quot;);
191         }
192 
193         return objectReferences;
194     }
195 
196 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jdi/VirtualMachine/dispose/dispose004.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.VirtualMachine.dispose;
 25 
 26 import jdk.test.lib.Utils;
 27 import nsk.share.*;
 28 import nsk.share.jpda.*;
 29 import nsk.share.jdi.*;
 30 
 31 import com.sun.jdi.*;
 32 import java.util.*;
 33 import java.io.*;
 34 
 35 /**
 36  * The test for the implementation of an object of the type     &lt;BR&gt;
 37  * VirtualMachine.                                              &lt;BR&gt;
 38  *                                                              &lt;BR&gt;
 39  * The test checks up that results of the method                &lt;BR&gt;
 40  * &lt;code&gt;com.sun.jdi.VirtualMachine.dispose()&lt;/code&gt;            &lt;BR&gt;
 41  * complies with its specification.                             &lt;BR&gt;
 42  * The test checks up that after call to VirtualMachine.dispose(),&lt;BR&gt;
 43  * debuggee&#39;s thread suspended before the call by a debugger,   &lt;BR&gt;
 44  * with method VirtualMachine.suspend(), is resumed and runs.   &lt;BR&gt;
 45  * &lt;BR&gt;
 46  * The test work as follows.                                    &lt;BR&gt;
 47  * Upon launch the debuggee creates new thread which is waiting &lt;BR&gt;
 48  * until a main thread leaves a synchronized block, and informs &lt;BR&gt;
 49  * the debugger of the thread creation. The debugger suspends   &lt;BR&gt;
 50  * all threads, resumes the main thread, performs vm.dispose()  &lt;BR&gt;
 51  * and sleeps for a predefined time-test parameter.             &lt;BR&gt;
 52  * Then the debugger                                            &lt;BR&gt;
 53  * asks the debuggee to check up on the tested thread state     &lt;BR&gt;
 54  * which should be &quot;not alive&quot; if the thread was resumed.       &lt;BR&gt;
 55  */
 56 
 57 public class dispose004 {
 58 
 59     //----------------------------------------------------- templete section
 60     static final int PASSED = 0;
 61     static final int FAILED = 2;
 62     static final int PASS_BASE = 95;
 63 
 64     //----------------------------------------------------- templete parameters
 65     static final String
 66     sHeader1 = &quot;\n==&gt; nsk/jdi/VirtualMachine/dispose/dispose004  &quot;,
 67     sHeader2 = &quot;--&gt; debugger: &quot;,
 68     sHeader3 = &quot;##&gt; debugger: &quot;;
 69 
 70     //----------------------------------------------------- main method
 71 
 72     public static void main (String argv[]) {
 73         int result = run(argv, System.out);
 74         System.exit(result + PASS_BASE);
 75     }
 76 
 77     public static int run (String argv[], PrintStream out) {
 78         return new dispose004().runThis(argv, out);
 79     }
 80 
 81     //--------------------------------------------------   log procedures
 82 
 83     private static Log  logHandler;
 84 
 85     private static void log1(String message) {
 86         logHandler.display(sHeader1 + message);
 87     }
 88     private static void log2(String message) {
 89         logHandler.display(sHeader2 + message);
 90     }
 91     private static void log3(String message) {
 92         logHandler.complain(sHeader3 + message);
 93     }
 94 
 95     //  ************************************************    test parameters
 96 
 97     private String debuggeeName =
 98         &quot;nsk.jdi.VirtualMachine.dispose.dispose004a&quot;;
 99 
100     private String testedClassName =
101         &quot;nsk.jdi.VirtualMachine.dispose.Threaddispose004a&quot;;
102 
103     //String mName = &quot;nsk.jdi.VirtualMachine.dispose&quot;;
104 
105     //====================================================== test program
106     //------------------------------------------------------ common section
107 
108     static ArgumentHandler      argsHandler;
109 
110     static int waitTime;
111 
112     static VirtualMachine      vm            = null;
113 
114     ReferenceType     testedclass  = null;
115     ThreadReference   thread2      = null;
116     ThreadReference   mainThread   = null;
117 
118     static int  testExitCode = PASSED;
119 
120     static final int returnCode0 = 0;
121     static final int returnCode1 = 1;
122     static final int returnCode2 = 2;
123     static final int returnCode3 = 3;
124     static final int returnCode4 = 4;
125 
126     //------------------------------------------------------ methods
127 
128     private int runThis (String argv[], PrintStream out) {
129 
130         Debugee debuggee;
131 
132         argsHandler     = new ArgumentHandler(argv);
133         logHandler      = new Log(out, argsHandler);
134         Binder binder   = new Binder(argsHandler, logHandler);
135 
136         if (argsHandler.verbose()) {
137             debuggee = binder.bindToDebugee(debuggeeName + &quot; -vbs&quot;);
138         } else {
139             debuggee = binder.bindToDebugee(debuggeeName);
140         }
141 
142         waitTime = argsHandler.getWaitTime();
143 
144 
145         IOPipe pipe     = new IOPipe(debuggee);
146 
147         debuggee.redirectStderr(out);
148         log2(debuggeeName + &quot; debuggee launched&quot;);
149         debuggee.resume();
150 
151         String line = pipe.readln();
152         if ((line == null) || !line.equals(&quot;ready&quot;)) {
153             log3(&quot;signal received is not &#39;ready&#39; but: &quot; + line);
154             return FAILED;
155         } else {
156             log2(&quot;&#39;ready&#39; recieved&quot;);
157         }
158 
159         vm = debuggee.VM();
160 
161     //------------------------------------------------------  testing section
162         log1(&quot;      TESTING BEGINS&quot;);
163 
164         for (int i = 0; ; i++) {
165 
166             pipe.println(&quot;newcheck&quot;);
167             line = pipe.readln();
168 
169             if (line.equals(&quot;checkend&quot;)) {
170                 log2(&quot;     : returned string is &#39;checkend&#39;&quot;);
171                 break ;
172             } else if (!line.equals(&quot;checkready&quot;)) {
173                 log3(&quot;ERROR: returned string is not &#39;checkready&#39;&quot;);
174                 testExitCode = FAILED;
175                 break ;
176             }
177 
178             log1(&quot;new checkready: #&quot; + i);
179 
180             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ variable part
181 
182             int expresult = returnCode0;
183 
184             String threadName = &quot;testedThread&quot;;
185 
186             List            allThreads   = null;
187             ListIterator    listIterator = null;
188             List            classes      = null;
189 
190 
191             label0: {
192 
193                 log2(&quot;getting ThreadReference object&quot;);
194                 try {
195                     allThreads  = vm.allThreads();
196                     classes     = vm.classesByName(testedClassName);
197                     testedclass = (ReferenceType) classes.get(0);
198                 } catch ( Exception e) {
199                     log3(&quot;ERROR: Exception at very beginning !? : &quot; + e);
200                     expresult = returnCode1;
201                     break label0;
202                 }
203 
204                 listIterator = allThreads.listIterator();
205                 for (;;) {
206                     try {
207                         thread2 = (ThreadReference) listIterator.next();
208                         if (thread2.name().equals(threadName))
209                             break ;
210                     } catch ( NoSuchElementException e ) {
211                         log3(&quot;ERROR: NoSuchElementException for listIterator.next()&quot;);
212                         log3(&quot;ERROR: NO THREAD2 ?????????!!!!!!!&quot;);
213                         expresult = returnCode1;
214                         break label0;
215                     }
216                 }
217                 listIterator = allThreads.listIterator();
218                 for (;;) {
219                     try {
220                         mainThread = (ThreadReference) listIterator.next();
221                         if (mainThread.name().equals(&quot;main&quot;))
222                             break ;
223                     } catch ( NoSuchElementException e ) {
224                         log3(&quot;ERROR: NoSuchElementException for listIterator.next()&quot;);
225                         log3(&quot;ERROR: NO THREAD2 ?????????!!!!!!!&quot;);
226                         expresult = returnCode1;
227                         break label0;
228                     }
229                 }
230             }
231 
232             label1: {
233                 if (expresult != returnCode0)
234                     break label1;
235 
236                 log2(&quot;      suspending Virtual Machine&quot;);
237                 vm.suspend();
238                 log2(&quot;      resuming debuggee&#39;s main thread&quot;);
239                 mainThread.resume();
240 
241 
242                 log2(&quot;      checking up on mainThread state: not suspened is expected&quot;);
243                 if (!mainThread.isSuspended()) {
244                     log2(&quot;      mainThread is not suspended&quot;);
245                 } else {
246                     log3(&quot;ERROR: mainThread is suspended&quot;);
247                     expresult = returnCode1;
248                     break label1;
249                 }
250 
251                 log2(&quot;      vm.dispose()&quot;);
252                 vm.dispose();
253 
254                 log2(&quot;......forcing the main thread to leave synchronized block&quot;);
255                 pipe.println(&quot;continue&quot;);
256                 line = pipe.readln();
257                 if (!line.equals(&quot;docontinue&quot;)) {
258                     log3(&quot;ERROR: returned string is not &#39;docontinue&#39;&quot;);
259                     expresult = returnCode4;
260                 }
261 
262                 if (expresult != returnCode0)
263                     break label1;
264 
265                 log2(&quot;      Waiting for thread2 is not alive&quot;);
266 
267                 Utils.waitForCondition(
268                         () -&gt; {
269                             log2(&quot;......sending to the debuggee: &#39;check_alive&#39;&quot;);
270                             log2(&quot;       expected reply: &#39;not_alive&#39;&quot;);
271                             pipe.println(&quot;check_alive&quot;);
272                             String reply = pipe.readln();
273                             if (reply.equals(&quot;alive&quot;)) {
274                                 log3(&quot;ERROR: thread2 is alive&quot;);
275                                 return false;
276                             } else if (reply.equals(&quot;not_alive&quot;)) {
277                                 log2(&quot;     thread2 is not alive&quot;);
278                                 return true;
279                             } else {
280                                 log3(&quot;ERROR: unexpected reply: &quot; + reply);
281                                 throw new RuntimeException(&quot;ERROR: unexpected reply: &quot; + reply);
282                             }
283 
284                         },
285                         Utils.adjustTimeout(waitTime * 60000),
286                         1000);
287 
288                 pipe.println(&quot;check_done&quot;);
289             }
290 
291             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
292         }
293         log1(&quot;      TESTING ENDS&quot;);
294 
295     //--------------------------------------------------   test summary section
296     //-------------------------------------------------    standard end section
297 
298         pipe.println(&quot;quit&quot;);
299         log2(&quot;waiting for the debuggee to finish ...&quot;);
300         debuggee.waitFor();
301 
302         int status = debuggee.getStatus();
303         if (status != PASSED + PASS_BASE) {
304             log3(&quot;debuggee returned UNEXPECTED exit status: &quot; +
305                     status + &quot; != PASS_BASE&quot;);
306             testExitCode = FAILED;
307         } else {
308             log2(&quot;debuggee returned expected exit status: &quot; +
309                     status + &quot; == PASS_BASE&quot;);
310         }
311 
312         if (testExitCode != PASSED) {
313             logHandler.complain(&quot;TEST FAILED&quot;);
314         }
315         return testExitCode;
316     }
317 }
    </pre>
  </body>
</html>
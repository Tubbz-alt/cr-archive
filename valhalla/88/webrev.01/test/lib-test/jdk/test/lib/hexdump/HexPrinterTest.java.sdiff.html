<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../langtools/tools/javac/versions/Versions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../lib/jdk/test/lib/Platform.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60     }
 61 
 62     @DataProvider(name = &quot;ColumnParams&quot;)
 63     Object[][] columnParams() {
 64         return new Object[][]{
 65                 {&quot;%4d: &quot;, &quot;%d &quot;, 10, &quot; ; &quot;, 50, HexPrinter.Formatters.PRINTABLE, &quot;\n&quot;},
 66                 {&quot;%03o: &quot;, &quot;%d &quot;, 16, &quot; ; &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;&quot;), &quot;\n&quot;},
 67                 {&quot;%5d: &quot;, &quot;%02x:&quot;, 16, &quot; ; &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;&quot;), &quot;\n&quot;},
 68                 {&quot;%5d: &quot;, &quot;%3d&quot;, 16, &quot; ; &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;&quot;), &quot;\n&quot;},
 69                 {&quot;%05o: &quot;, &quot;%3o&quot;, 8, &quot; ; &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;&quot;), &quot;\n&quot;},
 70                 {&quot;%6x: &quot;, &quot;%02x&quot;, 8, &quot; | &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;%d &quot;), &quot;\n&quot;},
 71                 {&quot;%2x: &quot;, &quot;%02x&quot;, 8, &quot; | &quot;, 50, HexPrinter.Formatters.PRINTABLE, &quot;\n&quot;},
 72                 {&quot;%5d: &quot;, &quot;%02x&quot;, 16, &quot; | &quot;, 50, HexPrinter.Formatters.ofPrimitive(short.class, &quot;%d &quot;), &quot;\n&quot;},
 73         };
 74     }
 75 
 76     @DataProvider(name = &quot;BuiltinParams&quot;)
 77     Object[][] builtinParams() {
 78         return new Object[][]{
 79                 {&quot;minimal&quot;, &quot;&quot;, &quot;%02x&quot;, 16, &quot;&quot;, 64, HexPrinter.Formatters.NONE, &quot;&quot;},
<span class="line-modified"> 80                 {&quot;canonical&quot;, &quot;%08x  &quot;, &quot;%02x &quot;, 16, &quot;|&quot;, 31, HexPrinter.Formatters.ASCII, &quot;|\n&quot;},</span>
<span class="line-modified"> 81                 {&quot;simple&quot;, &quot;%5d: &quot;, &quot;%02x &quot;, 16, &quot; // &quot;, 64, HexPrinter.Formatters.PRINTABLE, &quot;\n&quot;},</span>
<span class="line-modified"> 82                 {&quot;source&quot;, &quot;    &quot;, &quot;(byte)%3d, &quot;, 8, &quot; // &quot;, 64, HexPrinter.Formatters.PRINTABLE,</span>
<span class="line-removed"> 83                         &quot;\n&quot;},</span>
 84         };
 85     }
 86 
 87     @Test(dataProvider = &quot;BuiltinParams&quot;)
 88     public void testBuiltins(String name, String offsetFormat, String binFormat, int colWidth,
 89                              String annoDelim, int annoWidth,
 90                              HexPrinter.Formatter mapper, String lineSep) {
 91         HexPrinter f = switch (name) {
 92             case &quot;minimal&quot; -&gt; HexPrinter.minimal();
 93             case &quot;simple&quot; -&gt; HexPrinter.simple();
 94             case &quot;canonical&quot; -&gt; HexPrinter.canonical();
 95             case &quot;source&quot; -&gt; HexPrinter.source();
 96             default -&gt; throw new IllegalStateException(&quot;Unexpected value: &quot; + name);
 97         };
 98 
 99         testParams(f, offsetFormat, binFormat, colWidth, annoDelim, annoWidth, mapper, lineSep);
100 
101         String actual = f.toString();
102         HexPrinter f2 = HexPrinter.simple()
103                 .withOffsetFormat(offsetFormat)
</pre>
<hr />
<pre>
145             String value = String.format(binFormat, (0xff &amp; bytes[i]));
146             l = value.length();
147             Assert.assertEquals(out.substring(ndx, ndx + l), value,
148                     &quot;value format mismatch: &quot; + ndx + &quot;, i: &quot; + i);
149             ndx += l;
150             if (((i + 1) % colWidth) == 0) {
151                 // Rest of line is for padding, delimiter, formatter
152                 String padding = &quot; &quot;.repeat(padToWidth - (ndx - valuesStart));
153                 Assert.assertEquals(out.substring(ndx, ndx + padding.length()), padding, &quot;padding&quot;);
154                 ndx += padding.length();
155                 Assert.assertEquals(out.substring(ndx, ndx + annoDelim.length()), annoDelim,
156                         &quot;delimiter mismatch&quot;);
157                 ndx += annoDelim.length();
158 
159                 // Formatter output is tested separately
160                 ndx = out.indexOf(lineSep, ndx) + lineSep.length();
161             }
162         }
163     }
164 














































165     @DataProvider(name = &quot;PrimitiveFormatters&quot;)
166     Object[][] formatterParams() {
167         return new Object[][]{
168                 {byte.class, &quot;&quot;},
169                 {byte.class, &quot;%02x: &quot;},
170                 {short.class, &quot;%d &quot;},
171                 {int.class, &quot;%08x, &quot;},
172                 {long.class, &quot;%16x &quot;},
173                 {float.class, &quot;%3.4f &quot;},
174                 {double.class, &quot;%6.3g &quot;},
175                 {boolean.class, &quot;%b &quot;},
176         };
177     }
178 
179     @Test(dataProvider = &quot;PrimitiveFormatters&quot;)
180     public void testFormatter(Class&lt;?&gt; primClass, String fmtString) {
181         HexPrinter.Formatter formatter = HexPrinter.Formatters.ofPrimitive(primClass, fmtString);
182         // Create a byte array with data for two lines
183         int colWidth = 8;
184         byte[] bytes = genData(colWidth);
</pre>
<hr />
<pre>
235             return in.readLong();
236         } else if (float.class.equals(primClass)) {
237             return in.readFloat();
238         } else if (double.class.equals(primClass)) {
239             return in.readDouble();
240         } else if (boolean.class.equals(primClass)) {
241             return in.readBoolean();
242         } else {
243             throw new RuntimeException(&quot;unknown primitive class: &quot; + primClass);
244         }
245     }
246 
247     @DataProvider(name = &quot;sources&quot;)
248     Object[][] sources() {
249         return new Object[][]{
250                 {genBytes(21), 0, -1},
251                 {genBytes(21), 5, 12},
252         };
253     }
254 







255     public static byte[] genData(int len) {
256         // Create a byte array with data for two lines
257         byte[] bytes = new byte[len];
258         for (int i = 0; i &lt; len / 2; i++) {
259             bytes[i] = (byte) (i + &#39;A&#39;);
260             bytes[i + len / 2] = (byte) (i + &#39;A&#39; + 128);
261         }
262         return bytes;
263     }
264 
265     public static byte[] genFloat(int len) {
266         byte[] bytes = null;
267         try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
268              DataOutputStream out = new DataOutputStream(baos)) {
269             for (int i = 0; i &lt; len; i++) {
270                 out.writeFloat(i);
271             }
272             bytes = baos.toByteArray();
273         } catch (IOException unused) {
274         }
</pre>
<hr />
<pre>
295         return bytes;
296     }
297 
298     public ByteBuffer genByteBuffer(int len) {
299         return ByteBuffer.wrap(genBytes(len));
300     }
301 
302     public InputStream genInputStream(int len) {
303         return new ByteArrayInputStream(genBytes(len));
304     }
305 
306     @Test
307     public void testNilPrinterBigBuffer() {
308         byte[] bytes = new byte[1024];
309         HexPrinter p = HexPrinter.minimal();
310         String r = p.toString(bytes);
311         Assert.assertEquals(r.length(), bytes.length * 2, &quot;encoded byte wrong size&quot;);
312         Assert.assertEquals(r.replace(&quot;00&quot;, &quot;&quot;).length(), 0, &quot;contents not all zeros&quot;);
313     }
314 




















315     @Test(dataProvider = &quot;sources&quot;)
316     public void testToStringByteBuffer(byte[] bytes, int offset, int length) {
317         if (length &lt; 0)
318             length = bytes.length - offset;
319         ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);
320         System.out.printf(&quot;Source: %s, off: %d, len: %d%n&quot;,
321                 bytes.getClass().getName(), offset, length);
322         String actual;
323         if (offset == 0 &amp;&amp; length &lt; 0) {
324             bb.position(offset);
325             bb.limit(length);
326             actual = HexPrinter.simple().toString(bb);
327         } else
328             actual = HexPrinter.simple().toString(bb, offset, length);
329         System.out.println(actual);
330         String expected = HexPrinter.simple().toString(bytes, offset, length);
331         Assert.assertEquals(actual, expected, &quot;mismatch in format()&quot;);
332     }
333 
334     @Test(dataProvider = &quot;sources&quot;)
</pre>
</td>
<td>
<hr />
<pre>
 60     }
 61 
 62     @DataProvider(name = &quot;ColumnParams&quot;)
 63     Object[][] columnParams() {
 64         return new Object[][]{
 65                 {&quot;%4d: &quot;, &quot;%d &quot;, 10, &quot; ; &quot;, 50, HexPrinter.Formatters.PRINTABLE, &quot;\n&quot;},
 66                 {&quot;%03o: &quot;, &quot;%d &quot;, 16, &quot; ; &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;&quot;), &quot;\n&quot;},
 67                 {&quot;%5d: &quot;, &quot;%02x:&quot;, 16, &quot; ; &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;&quot;), &quot;\n&quot;},
 68                 {&quot;%5d: &quot;, &quot;%3d&quot;, 16, &quot; ; &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;&quot;), &quot;\n&quot;},
 69                 {&quot;%05o: &quot;, &quot;%3o&quot;, 8, &quot; ; &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;&quot;), &quot;\n&quot;},
 70                 {&quot;%6x: &quot;, &quot;%02x&quot;, 8, &quot; | &quot;, 50, HexPrinter.Formatters.ofPrimitive(byte.class, &quot;%d &quot;), &quot;\n&quot;},
 71                 {&quot;%2x: &quot;, &quot;%02x&quot;, 8, &quot; | &quot;, 50, HexPrinter.Formatters.PRINTABLE, &quot;\n&quot;},
 72                 {&quot;%5d: &quot;, &quot;%02x&quot;, 16, &quot; | &quot;, 50, HexPrinter.Formatters.ofPrimitive(short.class, &quot;%d &quot;), &quot;\n&quot;},
 73         };
 74     }
 75 
 76     @DataProvider(name = &quot;BuiltinParams&quot;)
 77     Object[][] builtinParams() {
 78         return new Object[][]{
 79                 {&quot;minimal&quot;, &quot;&quot;, &quot;%02x&quot;, 16, &quot;&quot;, 64, HexPrinter.Formatters.NONE, &quot;&quot;},
<span class="line-modified"> 80                 {&quot;canonical&quot;, &quot;%08x  &quot;, &quot;%02x &quot;, 16, &quot;|&quot;, 31, HexPrinter.Formatters.PRINTABLE, &quot;|\n&quot;},</span>
<span class="line-modified"> 81                 {&quot;simple&quot;, &quot;%5d: &quot;, &quot;%02x &quot;, 16, &quot; // &quot;, 64, HexPrinter.Formatters.ASCII, &quot;\n&quot;},</span>
<span class="line-modified"> 82                 {&quot;source&quot;, &quot;    &quot;, &quot;(byte)%3d, &quot;, 8, &quot; // &quot;, 64, HexPrinter.Formatters.PRINTABLE, &quot;\n&quot;},</span>

 83         };
 84     }
 85 
 86     @Test(dataProvider = &quot;BuiltinParams&quot;)
 87     public void testBuiltins(String name, String offsetFormat, String binFormat, int colWidth,
 88                              String annoDelim, int annoWidth,
 89                              HexPrinter.Formatter mapper, String lineSep) {
 90         HexPrinter f = switch (name) {
 91             case &quot;minimal&quot; -&gt; HexPrinter.minimal();
 92             case &quot;simple&quot; -&gt; HexPrinter.simple();
 93             case &quot;canonical&quot; -&gt; HexPrinter.canonical();
 94             case &quot;source&quot; -&gt; HexPrinter.source();
 95             default -&gt; throw new IllegalStateException(&quot;Unexpected value: &quot; + name);
 96         };
 97 
 98         testParams(f, offsetFormat, binFormat, colWidth, annoDelim, annoWidth, mapper, lineSep);
 99 
100         String actual = f.toString();
101         HexPrinter f2 = HexPrinter.simple()
102                 .withOffsetFormat(offsetFormat)
</pre>
<hr />
<pre>
144             String value = String.format(binFormat, (0xff &amp; bytes[i]));
145             l = value.length();
146             Assert.assertEquals(out.substring(ndx, ndx + l), value,
147                     &quot;value format mismatch: &quot; + ndx + &quot;, i: &quot; + i);
148             ndx += l;
149             if (((i + 1) % colWidth) == 0) {
150                 // Rest of line is for padding, delimiter, formatter
151                 String padding = &quot; &quot;.repeat(padToWidth - (ndx - valuesStart));
152                 Assert.assertEquals(out.substring(ndx, ndx + padding.length()), padding, &quot;padding&quot;);
153                 ndx += padding.length();
154                 Assert.assertEquals(out.substring(ndx, ndx + annoDelim.length()), annoDelim,
155                         &quot;delimiter mismatch&quot;);
156                 ndx += annoDelim.length();
157 
158                 // Formatter output is tested separately
159                 ndx = out.indexOf(lineSep, ndx) + lineSep.length();
160             }
161         }
162     }
163 
<span class="line-added">164     @Test</span>
<span class="line-added">165     static void testPrintable() {</span>
<span class="line-added">166         String expected =</span>
<span class="line-added">167                 &quot;................................&quot; +</span>
<span class="line-added">168                 &quot; !\&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?&quot; +</span>
<span class="line-added">169                 &quot;@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_&quot; +</span>
<span class="line-added">170                 &quot;`abcdefghijklmnopqrstuvwxyz{|}~.&quot; +</span>
<span class="line-added">171                 &quot;................................&quot; +</span>
<span class="line-added">172                 &quot;................................&quot; +</span>
<span class="line-added">173                 &quot;................................&quot; +</span>
<span class="line-added">174                 &quot;................................&quot;;</span>
<span class="line-added">175         byte[] bytes = new byte[256];</span>
<span class="line-added">176         for (int i = 0; i &lt; bytes.length; i++)</span>
<span class="line-added">177             bytes[i] = (byte)i;</span>
<span class="line-added">178         HexPrinter p = HexPrinter.minimal()</span>
<span class="line-added">179                         .withBytesFormat(&quot;&quot;, 256)</span>
<span class="line-added">180                         .formatter(HexPrinter.Formatters.PRINTABLE, &quot;&quot;, 512);</span>
<span class="line-added">181         String actual = p.toString(bytes);</span>
<span class="line-added">182         Assert.assertEquals(actual, expected, &quot;Formatters.Printable mismatch&quot;);</span>
<span class="line-added">183     }</span>
<span class="line-added">184 </span>
<span class="line-added">185     @Test</span>
<span class="line-added">186     static void testASCII() {</span>
<span class="line-added">187         String expected = &quot;\\nul\\soh\\stx\\etx\\eot\\enq\\ack\\bel\\b\\t\\n\\vt\\f\\r\\so\\si\\dle&quot; +</span>
<span class="line-added">188                 &quot;\\dc1\\dc2\\dc3\\dc4\\nak\\syn\\etb\\can\\em\\sub\\esc\\fs\\gs\\rs\\us&quot; +</span>
<span class="line-added">189                 &quot; !\&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?&quot; +</span>
<span class="line-added">190                 &quot;@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_&quot; +</span>
<span class="line-added">191                 &quot;`abcdefghijklmnopqrstuvwxyz{|}~\\127&quot; +</span>
<span class="line-added">192                 &quot;\\128\\129\\130\\131\\132\\133\\134\\135\\136\\137\\138\\139\\140\\141\\142\\143&quot; +</span>
<span class="line-added">193                 &quot;\\144\\145\\146\\147\\148\\149\\150\\151\\152\\153\\154\\155\\156\\157\\158\\159&quot; +</span>
<span class="line-added">194                 &quot;\\160\\161\\162\\163\\164\\165\\166\\167\\168\\169\\170\\171\\172\\173\\174\\175&quot; +</span>
<span class="line-added">195                 &quot;\\176\\177\\178\\179\\180\\181\\182\\183\\184\\185\\186\\187\\188\\189\\190\\191&quot; +</span>
<span class="line-added">196                 &quot;\\192\\193\\194\\195\\196\\197\\198\\199\\200\\201\\202\\203\\204\\205\\206\\207&quot; +</span>
<span class="line-added">197                 &quot;\\208\\209\\210\\211\\212\\213\\214\\215\\216\\217\\218\\219\\220\\221\\222\\223&quot; +</span>
<span class="line-added">198                 &quot;\\224\\225\\226\\227\\228\\229\\230\\231\\232\\233\\234\\235\\236\\237\\238\\239&quot; +</span>
<span class="line-added">199                 &quot;\\240\\241\\242\\243\\244\\245\\246\\247\\248\\249\\250\\251\\252\\253\\254\\255&quot;;</span>
<span class="line-added">200         byte[] bytes = new byte[256];</span>
<span class="line-added">201         for (int i = 0; i &lt; bytes.length; i++)</span>
<span class="line-added">202             bytes[i] = (byte)i;</span>
<span class="line-added">203         HexPrinter p = HexPrinter.minimal()</span>
<span class="line-added">204                         .withBytesFormat(&quot;&quot;, 256)</span>
<span class="line-added">205                         .formatter(HexPrinter.Formatters.ASCII, &quot;&quot;, 256);</span>
<span class="line-added">206         String actual = p.toString(bytes);</span>
<span class="line-added">207         Assert.assertEquals(actual, expected, &quot;Formatters.ASCII mismatch&quot;);</span>
<span class="line-added">208     }</span>
<span class="line-added">209 </span>
210     @DataProvider(name = &quot;PrimitiveFormatters&quot;)
211     Object[][] formatterParams() {
212         return new Object[][]{
213                 {byte.class, &quot;&quot;},
214                 {byte.class, &quot;%02x: &quot;},
215                 {short.class, &quot;%d &quot;},
216                 {int.class, &quot;%08x, &quot;},
217                 {long.class, &quot;%16x &quot;},
218                 {float.class, &quot;%3.4f &quot;},
219                 {double.class, &quot;%6.3g &quot;},
220                 {boolean.class, &quot;%b &quot;},
221         };
222     }
223 
224     @Test(dataProvider = &quot;PrimitiveFormatters&quot;)
225     public void testFormatter(Class&lt;?&gt; primClass, String fmtString) {
226         HexPrinter.Formatter formatter = HexPrinter.Formatters.ofPrimitive(primClass, fmtString);
227         // Create a byte array with data for two lines
228         int colWidth = 8;
229         byte[] bytes = genData(colWidth);
</pre>
<hr />
<pre>
280             return in.readLong();
281         } else if (float.class.equals(primClass)) {
282             return in.readFloat();
283         } else if (double.class.equals(primClass)) {
284             return in.readDouble();
285         } else if (boolean.class.equals(primClass)) {
286             return in.readBoolean();
287         } else {
288             throw new RuntimeException(&quot;unknown primitive class: &quot; + primClass);
289         }
290     }
291 
292     @DataProvider(name = &quot;sources&quot;)
293     Object[][] sources() {
294         return new Object[][]{
295                 {genBytes(21), 0, -1},
296                 {genBytes(21), 5, 12},
297         };
298     }
299 
<span class="line-added">300     @DataProvider(name = &quot;badsources&quot;)</span>
<span class="line-added">301     Object[][] badSources() {</span>
<span class="line-added">302         return new Object[][]{</span>
<span class="line-added">303                 {genBytes(21), 5, 22},</span>
<span class="line-added">304         };</span>
<span class="line-added">305     }</span>
<span class="line-added">306 </span>
307     public static byte[] genData(int len) {
308         // Create a byte array with data for two lines
309         byte[] bytes = new byte[len];
310         for (int i = 0; i &lt; len / 2; i++) {
311             bytes[i] = (byte) (i + &#39;A&#39;);
312             bytes[i + len / 2] = (byte) (i + &#39;A&#39; + 128);
313         }
314         return bytes;
315     }
316 
317     public static byte[] genFloat(int len) {
318         byte[] bytes = null;
319         try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
320              DataOutputStream out = new DataOutputStream(baos)) {
321             for (int i = 0; i &lt; len; i++) {
322                 out.writeFloat(i);
323             }
324             bytes = baos.toByteArray();
325         } catch (IOException unused) {
326         }
</pre>
<hr />
<pre>
347         return bytes;
348     }
349 
350     public ByteBuffer genByteBuffer(int len) {
351         return ByteBuffer.wrap(genBytes(len));
352     }
353 
354     public InputStream genInputStream(int len) {
355         return new ByteArrayInputStream(genBytes(len));
356     }
357 
358     @Test
359     public void testNilPrinterBigBuffer() {
360         byte[] bytes = new byte[1024];
361         HexPrinter p = HexPrinter.minimal();
362         String r = p.toString(bytes);
363         Assert.assertEquals(r.length(), bytes.length * 2, &quot;encoded byte wrong size&quot;);
364         Assert.assertEquals(r.replace(&quot;00&quot;, &quot;&quot;).length(), 0, &quot;contents not all zeros&quot;);
365     }
366 
<span class="line-added">367     @Test(dataProvider = &quot;badsources&quot;,</span>
<span class="line-added">368             expectedExceptions = java.lang.IndexOutOfBoundsException.class)</span>
<span class="line-added">369     public void testBadToStringByteBuffer(byte[] bytes, int offset, int length) {</span>
<span class="line-added">370         if (length &lt; 0)</span>
<span class="line-added">371             length = bytes.length - offset;</span>
<span class="line-added">372         ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);</span>
<span class="line-added">373         System.out.printf(&quot;Source: %s, off: %d, len: %d%n&quot;,</span>
<span class="line-added">374                 bytes.getClass().getName(), offset, length);</span>
<span class="line-added">375         String actual;</span>
<span class="line-added">376         if (offset == 0 &amp;&amp; length &lt; 0) {</span>
<span class="line-added">377             bb.position(offset);</span>
<span class="line-added">378             bb.limit(length);</span>
<span class="line-added">379             actual = HexPrinter.simple().toString(bb);</span>
<span class="line-added">380         } else</span>
<span class="line-added">381             actual = HexPrinter.simple().toString(bb, offset, length);</span>
<span class="line-added">382         System.out.println(actual);</span>
<span class="line-added">383         String expected = HexPrinter.simple().toString(bytes, offset, length);</span>
<span class="line-added">384         Assert.assertEquals(actual, expected, &quot;mismatch in format()&quot;);</span>
<span class="line-added">385     }</span>
<span class="line-added">386 </span>
387     @Test(dataProvider = &quot;sources&quot;)
388     public void testToStringByteBuffer(byte[] bytes, int offset, int length) {
389         if (length &lt; 0)
390             length = bytes.length - offset;
391         ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);
392         System.out.printf(&quot;Source: %s, off: %d, len: %d%n&quot;,
393                 bytes.getClass().getName(), offset, length);
394         String actual;
395         if (offset == 0 &amp;&amp; length &lt; 0) {
396             bb.position(offset);
397             bb.limit(length);
398             actual = HexPrinter.simple().toString(bb);
399         } else
400             actual = HexPrinter.simple().toString(bb, offset, length);
401         System.out.println(actual);
402         String expected = HexPrinter.simple().toString(bytes, offset, length);
403         Assert.assertEquals(actual, expected, &quot;mismatch in format()&quot;);
404     }
405 
406     @Test(dataProvider = &quot;sources&quot;)
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../langtools/tools/javac/versions/Versions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../lib/jdk/test/lib/Platform.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiEnvBase.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEnvBase.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
285                                    JavaThread* java_thread,
286                                    javaVFrame *jvf,
287                                    GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitors_list,
288                                    jint depth);
289   vframe* vframeFor(JavaThread* java_thread, jint depth);
290 
291  public:
292   // get a field descriptor for the specified class and field
293   static bool get_field_descriptor(Klass* k, jfieldID field, fieldDescriptor* fd);
294 
295   // JVMTI API helper functions which are called when target thread is suspended
296   // or at safepoint / thread local handshake.
297   jvmtiError get_frame_count(JvmtiThreadState *state, jint *count_ptr);
298   jvmtiError get_frame_location(JavaThread* java_thread, jint depth,
299                                               jmethodID* method_ptr, jlocation* location_ptr);
300   jvmtiError get_object_monitor_usage(JavaThread *calling_thread,
301                                                     jobject object, jvmtiMonitorUsage* info_ptr);
302   jvmtiError get_stack_trace(JavaThread *java_thread,
303                                            jint stack_depth, jint max_count,
304                                            jvmtiFrameInfo* frame_buffer, jint* count_ptr);
<span class="line-modified">305   jvmtiError get_current_contended_monitor(JavaThread *java_thread,</span>
306                                            jobject *monitor_ptr);
<span class="line-modified">307   jvmtiError get_owned_monitors(JavaThread* java_thread,</span>
308                                 GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *owned_monitors_list);
309   jvmtiError check_top_frame(JavaThread* current_thread, JavaThread* java_thread,
310                              jvalue value, TosState tos, Handle* ret_ob_h);
311   jvmtiError force_early_return(JavaThread* java_thread, jvalue value, TosState tos);
312 };
313 
314 // This class is the only safe means of iterating through environments.
315 // Note that this iteratation includes invalid environments pending
316 // deallocation -- in fact, some uses depend on this behavior.
317 
318 class JvmtiEnvIterator : public StackObj {
319  private:
320   bool _entry_was_marked;
321  public:
322   JvmtiEnvIterator() {
323     if (Threads::number_of_threads() == 0) {
324       _entry_was_marked = false; // we are single-threaded, no need
325     } else {
326       Thread::current()-&gt;entering_jvmti_env_iteration();
327       _entry_was_marked = true;
</pre>
<hr />
<pre>
359   JvmtiThreadState* _state;
360   jint _depth;
361   jvmtiError _result;
362 
363 public:
364   VM_SetFramePop(JvmtiEnv *env, JvmtiThreadState* state, jint depth) {
365     _env = env;
366     _state = state;
367     _depth = depth;
368     _result = JVMTI_ERROR_NONE;
369   }
370   VMOp_Type type() const { return VMOp_SetFramePop; }
371   jvmtiError result() { return _result; }
372   void doit();
373 };
374 
375 
376 // HandshakeClosure to get monitor information with stack depth.
377 class GetOwnedMonitorInfoClosure : public HandshakeClosure {
378 private:

379   JvmtiEnv *_env;
380   jvmtiError _result;
381   GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *_owned_monitors_list;
382 
383 public:
<span class="line-modified">384   GetOwnedMonitorInfoClosure(JvmtiEnv* env,</span>
385                              GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitor_list)
386     : HandshakeClosure(&quot;GetOwnedMonitorInfo&quot;),

387       _env(env),
388       _result(JVMTI_ERROR_NONE),
389       _owned_monitors_list(owned_monitor_list) {}
<span class="line-removed">390   void do_thread(Thread *target);</span>
391   jvmtiError result() { return _result; }

392 };
393 
394 
395 // VM operation to get object monitor usage.
396 class VM_GetObjectMonitorUsage : public VM_Operation {
397 private:
398   JvmtiEnv *_env;
399   jobject _object;
400   JavaThread* _calling_thread;
401   jvmtiMonitorUsage* _info_ptr;
402   jvmtiError _result;
403 
404 public:
405   VM_GetObjectMonitorUsage(JvmtiEnv *env, JavaThread* calling_thread, jobject object, jvmtiMonitorUsage* info_ptr) {
406     _env = env;
407     _object = object;
408     _calling_thread = calling_thread;
409     _info_ptr = info_ptr;
410   }
411   VMOp_Type type() const { return VMOp_GetObjectMonitorUsage; }
412   jvmtiError result() { return _result; }
413   void doit() {
414     _result = ((JvmtiEnvBase*) _env)-&gt;get_object_monitor_usage(_calling_thread, _object, _info_ptr);
415   }
416 
417 };
418 
419 // HandshakeClosure to get current contended monitor.
420 class GetCurrentContendedMonitorClosure : public HandshakeClosure {
421 private:

422   JvmtiEnv *_env;
423   jobject *_owned_monitor_ptr;
424   jvmtiError _result;
425 
426 public:
<span class="line-modified">427   GetCurrentContendedMonitorClosure(JvmtiEnv *env, jobject *mon_ptr)</span>
428     : HandshakeClosure(&quot;GetCurrentContendedMonitor&quot;),

429       _env(env),
430       _owned_monitor_ptr(mon_ptr),
431       _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}
432   jvmtiError result() { return _result; }
433   void do_thread(Thread *target);
434 };
435 
436 // VM operation to get stack trace at safepoint.
437 class VM_GetStackTrace : public VM_Operation {
438 private:
439   JvmtiEnv *_env;
440   JavaThread *_java_thread;
441   jint _start_depth;
442   jint _max_count;
443   jvmtiFrameInfo *_frame_buffer;
444   jint *_count_ptr;
445   jvmtiError _result;
446 
447 public:
448   VM_GetStackTrace(JvmtiEnv *env, JavaThread *java_thread,
</pre>
</td>
<td>
<hr />
<pre>
285                                    JavaThread* java_thread,
286                                    javaVFrame *jvf,
287                                    GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitors_list,
288                                    jint depth);
289   vframe* vframeFor(JavaThread* java_thread, jint depth);
290 
291  public:
292   // get a field descriptor for the specified class and field
293   static bool get_field_descriptor(Klass* k, jfieldID field, fieldDescriptor* fd);
294 
295   // JVMTI API helper functions which are called when target thread is suspended
296   // or at safepoint / thread local handshake.
297   jvmtiError get_frame_count(JvmtiThreadState *state, jint *count_ptr);
298   jvmtiError get_frame_location(JavaThread* java_thread, jint depth,
299                                               jmethodID* method_ptr, jlocation* location_ptr);
300   jvmtiError get_object_monitor_usage(JavaThread *calling_thread,
301                                                     jobject object, jvmtiMonitorUsage* info_ptr);
302   jvmtiError get_stack_trace(JavaThread *java_thread,
303                                            jint stack_depth, jint max_count,
304                                            jvmtiFrameInfo* frame_buffer, jint* count_ptr);
<span class="line-modified">305   jvmtiError get_current_contended_monitor(JavaThread *calling_thread, JavaThread *java_thread,</span>
306                                            jobject *monitor_ptr);
<span class="line-modified">307   jvmtiError get_owned_monitors(JavaThread *calling_thread, JavaThread* java_thread,</span>
308                                 GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *owned_monitors_list);
309   jvmtiError check_top_frame(JavaThread* current_thread, JavaThread* java_thread,
310                              jvalue value, TosState tos, Handle* ret_ob_h);
311   jvmtiError force_early_return(JavaThread* java_thread, jvalue value, TosState tos);
312 };
313 
314 // This class is the only safe means of iterating through environments.
315 // Note that this iteratation includes invalid environments pending
316 // deallocation -- in fact, some uses depend on this behavior.
317 
318 class JvmtiEnvIterator : public StackObj {
319  private:
320   bool _entry_was_marked;
321  public:
322   JvmtiEnvIterator() {
323     if (Threads::number_of_threads() == 0) {
324       _entry_was_marked = false; // we are single-threaded, no need
325     } else {
326       Thread::current()-&gt;entering_jvmti_env_iteration();
327       _entry_was_marked = true;
</pre>
<hr />
<pre>
359   JvmtiThreadState* _state;
360   jint _depth;
361   jvmtiError _result;
362 
363 public:
364   VM_SetFramePop(JvmtiEnv *env, JvmtiThreadState* state, jint depth) {
365     _env = env;
366     _state = state;
367     _depth = depth;
368     _result = JVMTI_ERROR_NONE;
369   }
370   VMOp_Type type() const { return VMOp_SetFramePop; }
371   jvmtiError result() { return _result; }
372   void doit();
373 };
374 
375 
376 // HandshakeClosure to get monitor information with stack depth.
377 class GetOwnedMonitorInfoClosure : public HandshakeClosure {
378 private:
<span class="line-added">379   JavaThread* _calling_thread;</span>
380   JvmtiEnv *_env;
381   jvmtiError _result;
382   GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *_owned_monitors_list;
383 
384 public:
<span class="line-modified">385   GetOwnedMonitorInfoClosure(JavaThread* calling_thread, JvmtiEnv* env,</span>
386                              GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitor_list)
387     : HandshakeClosure(&quot;GetOwnedMonitorInfo&quot;),
<span class="line-added">388       _calling_thread(calling_thread),</span>
389       _env(env),
390       _result(JVMTI_ERROR_NONE),
391       _owned_monitors_list(owned_monitor_list) {}

392   jvmtiError result() { return _result; }
<span class="line-added">393   void do_thread(Thread *target);</span>
394 };
395 
396 
397 // VM operation to get object monitor usage.
398 class VM_GetObjectMonitorUsage : public VM_Operation {
399 private:
400   JvmtiEnv *_env;
401   jobject _object;
402   JavaThread* _calling_thread;
403   jvmtiMonitorUsage* _info_ptr;
404   jvmtiError _result;
405 
406 public:
407   VM_GetObjectMonitorUsage(JvmtiEnv *env, JavaThread* calling_thread, jobject object, jvmtiMonitorUsage* info_ptr) {
408     _env = env;
409     _object = object;
410     _calling_thread = calling_thread;
411     _info_ptr = info_ptr;
412   }
413   VMOp_Type type() const { return VMOp_GetObjectMonitorUsage; }
414   jvmtiError result() { return _result; }
415   void doit() {
416     _result = ((JvmtiEnvBase*) _env)-&gt;get_object_monitor_usage(_calling_thread, _object, _info_ptr);
417   }
418 
419 };
420 
421 // HandshakeClosure to get current contended monitor.
422 class GetCurrentContendedMonitorClosure : public HandshakeClosure {
423 private:
<span class="line-added">424   JavaThread *_calling_thread;</span>
425   JvmtiEnv *_env;
426   jobject *_owned_monitor_ptr;
427   jvmtiError _result;
428 
429 public:
<span class="line-modified">430   GetCurrentContendedMonitorClosure(JavaThread* calling_thread, JvmtiEnv *env, jobject *mon_ptr)</span>
431     : HandshakeClosure(&quot;GetCurrentContendedMonitor&quot;),
<span class="line-added">432       _calling_thread(calling_thread),</span>
433       _env(env),
434       _owned_monitor_ptr(mon_ptr),
435       _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}
436   jvmtiError result() { return _result; }
437   void do_thread(Thread *target);
438 };
439 
440 // VM operation to get stack trace at safepoint.
441 class VM_GetStackTrace : public VM_Operation {
442 private:
443   JvmtiEnv *_env;
444   JavaThread *_java_thread;
445   jint _start_depth;
446   jint _max_count;
447   jvmtiFrameInfo *_frame_buffer;
448   jint *_count_ptr;
449   jvmtiError _result;
450 
451 public:
452   VM_GetStackTrace(JvmtiEnv *env, JavaThread *java_thread,
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
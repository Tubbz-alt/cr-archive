<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../compiler/compileBroker.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 48,16 ***</span>
   *
   * For concurrent evac and update-refs, we are walking the heap per-region, and so the
   * notion of progress is clear: we get reported the &quot;used&quot; size from the processed regions
   * and use the global heap-used as the baseline.
   *
<span class="line-modified">!  * The allocatable space when GC is running is &quot;free&quot; at the start of cycle, but the</span>
   * accounted budget is based on &quot;used&quot;. So, we need to adjust the tax knowing that.
<span class="line-removed">-  * Also, since we effectively count the used space three times (mark, evac, update-refs),</span>
<span class="line-removed">-  * we need to multiply the tax by 3. Example: for 10 MB free and 90 MB used, GC would</span>
<span class="line-removed">-  * come back with 3*90 MB budget, and thus for each 1 MB of allocation, we have to pay</span>
<span class="line-removed">-  * 3*90 / 10 MBs. In the end, we would pay back the entire budget.</span>
   */
  
  void ShenandoahPacer::setup_for_mark() {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
<span class="line-new-header">--- 48,12 ---</span>
   *
   * For concurrent evac and update-refs, we are walking the heap per-region, and so the
   * notion of progress is clear: we get reported the &quot;used&quot; size from the processed regions
   * and use the global heap-used as the baseline.
   *
<span class="line-modified">!  * The allocatable space when GC is running is &quot;free&quot; at the start of phase, but the</span>
   * accounted budget is based on &quot;used&quot;. So, we need to adjust the tax knowing that.
   */
  
  void ShenandoahPacer::setup_for_mark() {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
  
    size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
    size_t taxable = free - non_taxable;
  
    double tax = 1.0 * live / taxable; // base tax for available free space
<span class="line-modified">!   tax *= 3;                          // mark is phase 1 of 3, claim 1/3 of free for it</span>
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
    log_info(gc, ergo)(&quot;Pacer for Mark. Expected Live: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;
<span class="line-new-header">--- 62,11 ---</span>
  
    size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
    size_t taxable = free - non_taxable;
  
    double tax = 1.0 * live / taxable; // base tax for available free space
<span class="line-modified">!   tax *= 1;                          // mark can succeed with immediate garbage, claim all available space</span>
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
    log_info(gc, ergo)(&quot;Pacer for Mark. Expected Live: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,11 ***</span>
  
    size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
    size_t taxable = free - non_taxable;
  
    double tax = 1.0 * used / taxable; // base tax for available free space
<span class="line-modified">!   tax *= 2;                          // evac is phase 2 of 3, claim 1/2 of remaining free</span>
    tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-new-header">--- 85,11 ---</span>
  
    size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
    size_t taxable = free - non_taxable;
  
    double tax = 1.0 * used / taxable; // base tax for available free space
<span class="line-modified">!   tax *= 2;                          // evac is followed by update-refs, claim 1/2 of remaining free</span>
    tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,11 ***</span>
  
    size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
    size_t taxable = free - non_taxable;
  
    double tax = 1.0 * used / taxable; // base tax for available free space
<span class="line-modified">!   tax *= 1;                          // update-refs is phase 3 of 3, claim the remaining free</span>
    tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-new-header">--- 109,11 ---</span>
  
    size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
    size_t taxable = free - non_taxable;
  
    double tax = 1.0 * used / taxable; // base tax for available free space
<span class="line-modified">!   tax *= 1;                          // update-refs is the last phase, claim the remaining free</span>
    tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,10 ***</span>
<span class="line-new-header">--- 189,13 ---</span>
    size_t initial = (size_t)(non_taxable_bytes * tax_rate) &gt;&gt; LogHeapWordSize;
    STATIC_ASSERT(sizeof(size_t) &lt;= sizeof(intptr_t));
    Atomic::xchg(&amp;_budget, (intptr_t)initial);
    Atomic::store(&amp;_tax_rate, tax_rate);
    Atomic::inc(&amp;_epoch);
<span class="line-added">+ </span>
<span class="line-added">+   // Shake up stalled waiters after budget update.</span>
<span class="line-added">+   notify_waiters();</span>
  }
  
  bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,60 ***</span>
  
  void ShenandoahPacer::pace_for_alloc(size_t words) {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
    // Fast path: try to allocate right away
<span class="line-modified">!   if (claim_for_alloc(words, false)) {</span>
      return;
    }
  
    // Threads that are attaching should not block at all: they are not
    // fully initialized yet. Blocking them would be awkward.
    // This is probably the path that allocates the thread oop itself.
<span class="line-removed">-   // Forcefully claim without waiting.</span>
    if (JavaThread::current()-&gt;is_attaching_via_jni()) {
<span class="line-removed">-     claim_for_alloc(words, true);</span>
      return;
    }
  
<span class="line-removed">-   size_t max = ShenandoahPacingMaxDelay;</span>
    double start = os::elapsedTime();
  
<span class="line-modified">!   size_t total = 0;</span>
<span class="line-modified">!   size_t cur = 0;</span>
  
    while (true) {
      // We could instead assist GC, but this would suffice for now.
<span class="line-modified">!     // This code should also participate in safepointing.</span>
<span class="line-modified">!     // Perform the exponential backoff, limited by max.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     cur = cur * 2;</span>
<span class="line-removed">-     if (total + cur &gt; max) {</span>
<span class="line-removed">-       cur = (max &gt; total) ? (max - total) : 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     cur = MAX2&lt;size_t&gt;(1, cur);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     wait(cur);</span>
  
      double end = os::elapsedTime();
<span class="line-modified">!     total = (size_t)((end - start) * 1000);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (total &gt; max) {</span>
<span class="line-modified">!       // Spent local time budget to wait for enough GC progress.</span>
<span class="line-modified">!       // Breaking out and allocating anyway, which may mean we outpace GC,</span>
<span class="line-modified">!       // and start Degenerated GC cycle.</span>
<span class="line-modified">!       _delays.add(total);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // Forcefully claim the budget: it may go negative at this point, and</span>
<span class="line-removed">-       // GC should replenish for this and subsequent allocations</span>
<span class="line-removed">-       claim_for_alloc(words, true);</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (claim_for_alloc(words, false)) {</span>
<span class="line-removed">-       // Acquired enough permit, nice. Can allocate now.</span>
<span class="line-removed">-       _delays.add(total);</span>
        break;
      }
    }
  }
  
<span class="line-new-header">--- 232,49 ---</span>
  
  void ShenandoahPacer::pace_for_alloc(size_t words) {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
    // Fast path: try to allocate right away
<span class="line-modified">!   bool claimed = claim_for_alloc(words, false);</span>
<span class="line-added">+   if (claimed) {</span>
      return;
    }
  
<span class="line-added">+   // Forcefully claim the budget: it may go negative at this point, and</span>
<span class="line-added">+   // GC should replenish for this and subsequent allocations. After this claim,</span>
<span class="line-added">+   // we would wait a bit until our claim is matched by additional progress,</span>
<span class="line-added">+   // or the time budget depletes.</span>
<span class="line-added">+   claimed = claim_for_alloc(words, true);</span>
<span class="line-added">+   assert(claimed, &quot;Should always succeed&quot;);</span>
<span class="line-added">+ </span>
    // Threads that are attaching should not block at all: they are not
    // fully initialized yet. Blocking them would be awkward.
    // This is probably the path that allocates the thread oop itself.
    if (JavaThread::current()-&gt;is_attaching_via_jni()) {
      return;
    }
  
    double start = os::elapsedTime();
  
<span class="line-modified">!   size_t max_ms = ShenandoahPacingMaxDelay;</span>
<span class="line-modified">!   size_t total_ms = 0;</span>
  
    while (true) {
      // We could instead assist GC, but this would suffice for now.
<span class="line-modified">!     size_t cur_ms = (max_ms &gt; total_ms) ? (max_ms - total_ms) : 1;</span>
<span class="line-modified">!     wait(cur_ms);</span>
  
      double end = os::elapsedTime();
<span class="line-modified">!     total_ms = (size_t)((end - start) * 1000);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (total_ms &gt; max_ms || Atomic::load(&amp;_budget) &gt;= 0) {</span>
<span class="line-modified">!       // Exiting if either:</span>
<span class="line-modified">!       //  a) Spent local time budget to wait for enough GC progress.</span>
<span class="line-modified">!       //     Breaking out and allocating anyway, which may mean we outpace GC,</span>
<span class="line-modified">!       //     and start Degenerated GC cycle.</span>
<span class="line-modified">!       //  b) The budget had been replenished, which means our claim is satisfied.</span>
<span class="line-modified">!       _delays.add(total_ms);</span>
        break;
      }
    }
  }
  
</pre>
<center><a href="../../compiler/compileBroker.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
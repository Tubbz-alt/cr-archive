diff a/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp b/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
@@ -48,16 +48,12 @@
  *
  * For concurrent evac and update-refs, we are walking the heap per-region, and so the
  * notion of progress is clear: we get reported the "used" size from the processed regions
  * and use the global heap-used as the baseline.
  *
- * The allocatable space when GC is running is "free" at the start of cycle, but the
+ * The allocatable space when GC is running is "free" at the start of phase, but the
  * accounted budget is based on "used". So, we need to adjust the tax knowing that.
- * Also, since we effectively count the used space three times (mark, evac, update-refs),
- * we need to multiply the tax by 3. Example: for 10 MB free and 90 MB used, GC would
- * come back with 3*90 MB budget, and thus for each 1 MB of allocation, we have to pay
- * 3*90 / 10 MBs. In the end, we would pay back the entire budget.
  */
 
 void ShenandoahPacer::setup_for_mark() {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
@@ -66,11 +62,11 @@
 
   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
   size_t taxable = free - non_taxable;
 
   double tax = 1.0 * live / taxable; // base tax for available free space
-  tax *= 3;                          // mark is phase 1 of 3, claim 1/3 of free for it
+  tax *= 1;                          // mark can succeed with immediate garbage, claim all available space
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
   log_info(gc, ergo)("Pacer for Mark. Expected Live: " SIZE_FORMAT "%s, Free: " SIZE_FORMAT "%s, "
@@ -89,11 +85,11 @@
 
   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
   size_t taxable = free - non_taxable;
 
   double tax = 1.0 * used / taxable; // base tax for available free space
-  tax *= 2;                          // evac is phase 2 of 3, claim 1/2 of remaining free
+  tax *= 2;                          // evac is followed by update-refs, claim 1/2 of remaining free
   tax = MAX2<double>(1, tax);        // never allocate more than GC processes during the phase
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
@@ -113,11 +109,11 @@
 
   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
   size_t taxable = free - non_taxable;
 
   double tax = 1.0 * used / taxable; // base tax for available free space
-  tax *= 1;                          // update-refs is phase 3 of 3, claim the remaining free
+  tax *= 1;                          // update-refs is the last phase, claim the remaining free
   tax = MAX2<double>(1, tax);        // never allocate more than GC processes during the phase
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
@@ -193,10 +189,13 @@
   size_t initial = (size_t)(non_taxable_bytes * tax_rate) >> LogHeapWordSize;
   STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));
   Atomic::xchg(&_budget, (intptr_t)initial);
   Atomic::store(&_tax_rate, tax_rate);
   Atomic::inc(&_epoch);
+
+  // Shake up stalled waiters after budget update.
+  notify_waiters();
 }
 
 bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
@@ -233,60 +232,49 @@
 
 void ShenandoahPacer::pace_for_alloc(size_t words) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
   // Fast path: try to allocate right away
-  if (claim_for_alloc(words, false)) {
+  bool claimed = claim_for_alloc(words, false);
+  if (claimed) {
     return;
   }
 
+  // Forcefully claim the budget: it may go negative at this point, and
+  // GC should replenish for this and subsequent allocations. After this claim,
+  // we would wait a bit until our claim is matched by additional progress,
+  // or the time budget depletes.
+  claimed = claim_for_alloc(words, true);
+  assert(claimed, "Should always succeed");
+
   // Threads that are attaching should not block at all: they are not
   // fully initialized yet. Blocking them would be awkward.
   // This is probably the path that allocates the thread oop itself.
-  // Forcefully claim without waiting.
   if (JavaThread::current()->is_attaching_via_jni()) {
-    claim_for_alloc(words, true);
     return;
   }
 
-  size_t max = ShenandoahPacingMaxDelay;
   double start = os::elapsedTime();
 
-  size_t total = 0;
-  size_t cur = 0;
+  size_t max_ms = ShenandoahPacingMaxDelay;
+  size_t total_ms = 0;
 
   while (true) {
     // We could instead assist GC, but this would suffice for now.
-    // This code should also participate in safepointing.
-    // Perform the exponential backoff, limited by max.
-
-    cur = cur * 2;
-    if (total + cur > max) {
-      cur = (max > total) ? (max - total) : 0;
-    }
-    cur = MAX2<size_t>(1, cur);
-
-    wait(cur);
+    size_t cur_ms = (max_ms > total_ms) ? (max_ms - total_ms) : 1;
+    wait(cur_ms);
 
     double end = os::elapsedTime();
-    total = (size_t)((end - start) * 1000);
-
-    if (total > max) {
-      // Spent local time budget to wait for enough GC progress.
-      // Breaking out and allocating anyway, which may mean we outpace GC,
-      // and start Degenerated GC cycle.
-      _delays.add(total);
-
-      // Forcefully claim the budget: it may go negative at this point, and
-      // GC should replenish for this and subsequent allocations
-      claim_for_alloc(words, true);
-      break;
-    }
-
-    if (claim_for_alloc(words, false)) {
-      // Acquired enough permit, nice. Can allocate now.
-      _delays.add(total);
+    total_ms = (size_t)((end - start) * 1000);
+
+    if (total_ms > max_ms || Atomic::load(&_budget) >= 0) {
+      // Exiting if either:
+      //  a) Spent local time budget to wait for enough GC progress.
+      //     Breaking out and allocating anyway, which may mean we outpace GC,
+      //     and start Degenerated GC cycle.
+      //  b) The budget had been replenished, which means our claim is satisfied.
+      _delays.add(total_ms);
       break;
     }
   }
 }
 

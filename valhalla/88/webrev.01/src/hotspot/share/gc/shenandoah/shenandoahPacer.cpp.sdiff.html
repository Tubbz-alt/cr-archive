<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../compiler/compileBroker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 /*
 34  * In normal concurrent cycle, we have to pace the application to let GC finish.
 35  *
 36  * Here, we do not know how large would be the collection set, and what are the
 37  * relative performances of the each stage in the concurrent cycle, and so we have to
 38  * make some assumptions.
 39  *
 40  * For concurrent mark, there is no clear notion of progress. The moderately accurate
 41  * and easy to get metric is the amount of live objects the mark had encountered. But,
 42  * that does directly correlate with the used heap, because the heap might be fully
 43  * dead or fully alive. We cannot assume either of the extremes: we would either allow
 44  * application to run out of memory if we assume heap is fully dead but it is not, and,
 45  * conversely, we would pacify application excessively if we assume heap is fully alive
 46  * but it is not. So we need to guesstimate the particular expected value for heap liveness.
 47  * The best way to do this is apparently recording the past history.
 48  *
 49  * For concurrent evac and update-refs, we are walking the heap per-region, and so the
 50  * notion of progress is clear: we get reported the &quot;used&quot; size from the processed regions
 51  * and use the global heap-used as the baseline.
 52  *
<span class="line-modified"> 53  * The allocatable space when GC is running is &quot;free&quot; at the start of cycle, but the</span>
 54  * accounted budget is based on &quot;used&quot;. So, we need to adjust the tax knowing that.
<span class="line-removed"> 55  * Also, since we effectively count the used space three times (mark, evac, update-refs),</span>
<span class="line-removed"> 56  * we need to multiply the tax by 3. Example: for 10 MB free and 90 MB used, GC would</span>
<span class="line-removed"> 57  * come back with 3*90 MB budget, and thus for each 1 MB of allocation, we have to pay</span>
<span class="line-removed"> 58  * 3*90 / 10 MBs. In the end, we would pay back the entire budget.</span>
 59  */
 60 
 61 void ShenandoahPacer::setup_for_mark() {
 62   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
 63 
 64   size_t live = update_and_get_progress_history();
 65   size_t free = _heap-&gt;free_set()-&gt;available();
 66 
 67   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
 68   size_t taxable = free - non_taxable;
 69 
 70   double tax = 1.0 * live / taxable; // base tax for available free space
<span class="line-modified"> 71   tax *= 3;                          // mark is phase 1 of 3, claim 1/3 of free for it</span>
 72   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 73 
 74   restart_with(non_taxable, tax);
 75 
 76   log_info(gc, ergo)(&quot;Pacer for Mark. Expected Live: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;
 77                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,
 78                      byte_size_in_proper_unit(live),        proper_unit_for_byte_size(live),
 79                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
 80                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
 81                      tax);
 82 }
 83 
 84 void ShenandoahPacer::setup_for_evac() {
 85   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
 86 
 87   size_t used = _heap-&gt;collection_set()-&gt;used();
 88   size_t free = _heap-&gt;free_set()-&gt;available();
 89 
 90   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
 91   size_t taxable = free - non_taxable;
 92 
 93   double tax = 1.0 * used / taxable; // base tax for available free space
<span class="line-modified"> 94   tax *= 2;                          // evac is phase 2 of 3, claim 1/2 of remaining free</span>
 95   tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
 96   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 97 
 98   restart_with(non_taxable, tax);
 99 
100   log_info(gc, ergo)(&quot;Pacer for Evacuation. Used CSet: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;
101                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,
102                      byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),
103                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
104                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
105                      tax);
106 }
107 
108 void ShenandoahPacer::setup_for_updaterefs() {
109   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
110 
111   size_t used = _heap-&gt;used();
112   size_t free = _heap-&gt;free_set()-&gt;available();
113 
114   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
115   size_t taxable = free - non_taxable;
116 
117   double tax = 1.0 * used / taxable; // base tax for available free space
<span class="line-modified">118   tax *= 1;                          // update-refs is phase 3 of 3, claim the remaining free</span>
119   tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
120   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
121 
122   restart_with(non_taxable, tax);
123 
124   log_info(gc, ergo)(&quot;Pacer for Update Refs. Used: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;
125                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,
126                      byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),
127                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
128                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
129                      tax);
130 }
131 
132 /*
133  * In idle phase, we have to pace the application to let control thread react with GC start.
134  *
135  * Here, we have rendezvous with concurrent thread that adds up the budget as it acknowledges
136  * it had seen recent allocations. It will naturally pace the allocations if control thread is
137  * not catching up. To bootstrap this feedback cycle, we need to start with some initial budget
138  * for applications to allocate at.
</pre>
<hr />
<pre>
178 
179 size_t ShenandoahPacer::update_and_get_progress_history() {
180   if (_progress == -1) {
181     // First initialization, report some prior
182     Atomic::store(&amp;_progress, (intptr_t)PACING_PROGRESS_ZERO);
183     return (size_t) (_heap-&gt;max_capacity() * 0.1);
184   } else {
185     // Record history, and reply historical data
186     _progress_history-&gt;add(_progress);
187     Atomic::store(&amp;_progress, (intptr_t)PACING_PROGRESS_ZERO);
188     return (size_t) (_progress_history-&gt;avg() * HeapWordSize);
189   }
190 }
191 
192 void ShenandoahPacer::restart_with(size_t non_taxable_bytes, double tax_rate) {
193   size_t initial = (size_t)(non_taxable_bytes * tax_rate) &gt;&gt; LogHeapWordSize;
194   STATIC_ASSERT(sizeof(size_t) &lt;= sizeof(intptr_t));
195   Atomic::xchg(&amp;_budget, (intptr_t)initial);
196   Atomic::store(&amp;_tax_rate, tax_rate);
197   Atomic::inc(&amp;_epoch);



198 }
199 
200 bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
201   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
202 
203   intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
204 
205   intptr_t cur = 0;
206   intptr_t new_val = 0;
207   do {
208     cur = Atomic::load(&amp;_budget);
209     if (cur &lt; tax &amp;&amp; !force) {
210       // Progress depleted, alas.
211       return false;
212     }
213     new_val = cur - tax;
214   } while (Atomic::cmpxchg(&amp;_budget, cur, new_val) != cur);
215   return true;
216 }
217 
218 void ShenandoahPacer::unpace_for_alloc(intptr_t epoch, size_t words) {
219   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
220 
221   if (_epoch != epoch) {
222     // Stale ticket, no need to unpace.
223     return;
224   }
225 
226   intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
227   Atomic::add(&amp;_budget, tax);
228 }
229 
230 intptr_t ShenandoahPacer::epoch() {
231   return Atomic::load(&amp;_epoch);
232 }
233 
234 void ShenandoahPacer::pace_for_alloc(size_t words) {
235   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
236 
237   // Fast path: try to allocate right away
<span class="line-modified">238   if (claim_for_alloc(words, false)) {</span>

239     return;
240   }
241 







242   // Threads that are attaching should not block at all: they are not
243   // fully initialized yet. Blocking them would be awkward.
244   // This is probably the path that allocates the thread oop itself.
<span class="line-removed">245   // Forcefully claim without waiting.</span>
246   if (JavaThread::current()-&gt;is_attaching_via_jni()) {
<span class="line-removed">247     claim_for_alloc(words, true);</span>
248     return;
249   }
250 
<span class="line-removed">251   size_t max = ShenandoahPacingMaxDelay;</span>
252   double start = os::elapsedTime();
253 
<span class="line-modified">254   size_t total = 0;</span>
<span class="line-modified">255   size_t cur = 0;</span>
256 
257   while (true) {
258     // We could instead assist GC, but this would suffice for now.
<span class="line-modified">259     // This code should also participate in safepointing.</span>
<span class="line-modified">260     // Perform the exponential backoff, limited by max.</span>
<span class="line-removed">261 </span>
<span class="line-removed">262     cur = cur * 2;</span>
<span class="line-removed">263     if (total + cur &gt; max) {</span>
<span class="line-removed">264       cur = (max &gt; total) ? (max - total) : 0;</span>
<span class="line-removed">265     }</span>
<span class="line-removed">266     cur = MAX2&lt;size_t&gt;(1, cur);</span>
<span class="line-removed">267 </span>
<span class="line-removed">268     wait(cur);</span>
269 
270     double end = os::elapsedTime();
<span class="line-modified">271     total = (size_t)((end - start) * 1000);</span>
<span class="line-modified">272 </span>
<span class="line-modified">273     if (total &gt; max) {</span>
<span class="line-modified">274       // Spent local time budget to wait for enough GC progress.</span>
<span class="line-modified">275       // Breaking out and allocating anyway, which may mean we outpace GC,</span>
<span class="line-modified">276       // and start Degenerated GC cycle.</span>
<span class="line-modified">277       _delays.add(total);</span>
<span class="line-modified">278 </span>
<span class="line-modified">279       // Forcefully claim the budget: it may go negative at this point, and</span>
<span class="line-removed">280       // GC should replenish for this and subsequent allocations</span>
<span class="line-removed">281       claim_for_alloc(words, true);</span>
<span class="line-removed">282       break;</span>
<span class="line-removed">283     }</span>
<span class="line-removed">284 </span>
<span class="line-removed">285     if (claim_for_alloc(words, false)) {</span>
<span class="line-removed">286       // Acquired enough permit, nice. Can allocate now.</span>
<span class="line-removed">287       _delays.add(total);</span>
288       break;
289     }
290   }
291 }
292 
293 void ShenandoahPacer::wait(long time_ms) {
294   // Perform timed wait. It works like like sleep(), except without modifying
295   // the thread interruptible status. MonitorLocker also checks for safepoints.
296   assert(time_ms &gt; 0, &quot;Should not call this with zero argument, as it would stall until notify&quot;);
297   MonitorLocker locker(_wait_monitor);
298   _wait_monitor-&gt;wait(time_ms);
299 }
300 
301 void ShenandoahPacer::notify_waiters() {
302   MonitorLocker locker(_wait_monitor);
303   _wait_monitor-&gt;notify_all();
304 }
305 
306 void ShenandoahPacer::print_on(outputStream* out) const {
307   out-&gt;print_cr(&quot;ALLOCATION PACING:&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 33 /*
 34  * In normal concurrent cycle, we have to pace the application to let GC finish.
 35  *
 36  * Here, we do not know how large would be the collection set, and what are the
 37  * relative performances of the each stage in the concurrent cycle, and so we have to
 38  * make some assumptions.
 39  *
 40  * For concurrent mark, there is no clear notion of progress. The moderately accurate
 41  * and easy to get metric is the amount of live objects the mark had encountered. But,
 42  * that does directly correlate with the used heap, because the heap might be fully
 43  * dead or fully alive. We cannot assume either of the extremes: we would either allow
 44  * application to run out of memory if we assume heap is fully dead but it is not, and,
 45  * conversely, we would pacify application excessively if we assume heap is fully alive
 46  * but it is not. So we need to guesstimate the particular expected value for heap liveness.
 47  * The best way to do this is apparently recording the past history.
 48  *
 49  * For concurrent evac and update-refs, we are walking the heap per-region, and so the
 50  * notion of progress is clear: we get reported the &quot;used&quot; size from the processed regions
 51  * and use the global heap-used as the baseline.
 52  *
<span class="line-modified"> 53  * The allocatable space when GC is running is &quot;free&quot; at the start of phase, but the</span>
 54  * accounted budget is based on &quot;used&quot;. So, we need to adjust the tax knowing that.




 55  */
 56 
 57 void ShenandoahPacer::setup_for_mark() {
 58   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
 59 
 60   size_t live = update_and_get_progress_history();
 61   size_t free = _heap-&gt;free_set()-&gt;available();
 62 
 63   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
 64   size_t taxable = free - non_taxable;
 65 
 66   double tax = 1.0 * live / taxable; // base tax for available free space
<span class="line-modified"> 67   tax *= 1;                          // mark can succeed with immediate garbage, claim all available space</span>
 68   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 69 
 70   restart_with(non_taxable, tax);
 71 
 72   log_info(gc, ergo)(&quot;Pacer for Mark. Expected Live: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;
 73                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,
 74                      byte_size_in_proper_unit(live),        proper_unit_for_byte_size(live),
 75                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
 76                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
 77                      tax);
 78 }
 79 
 80 void ShenandoahPacer::setup_for_evac() {
 81   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
 82 
 83   size_t used = _heap-&gt;collection_set()-&gt;used();
 84   size_t free = _heap-&gt;free_set()-&gt;available();
 85 
 86   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
 87   size_t taxable = free - non_taxable;
 88 
 89   double tax = 1.0 * used / taxable; // base tax for available free space
<span class="line-modified"> 90   tax *= 2;                          // evac is followed by update-refs, claim 1/2 of remaining free</span>
 91   tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
 92   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 93 
 94   restart_with(non_taxable, tax);
 95 
 96   log_info(gc, ergo)(&quot;Pacer for Evacuation. Used CSet: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;
 97                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,
 98                      byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),
 99                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
100                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
101                      tax);
102 }
103 
104 void ShenandoahPacer::setup_for_updaterefs() {
105   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
106 
107   size_t used = _heap-&gt;used();
108   size_t free = _heap-&gt;free_set()-&gt;available();
109 
110   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
111   size_t taxable = free - non_taxable;
112 
113   double tax = 1.0 * used / taxable; // base tax for available free space
<span class="line-modified">114   tax *= 1;                          // update-refs is the last phase, claim the remaining free</span>
115   tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
116   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
117 
118   restart_with(non_taxable, tax);
119 
120   log_info(gc, ergo)(&quot;Pacer for Update Refs. Used: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;
121                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,
122                      byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),
123                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
124                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
125                      tax);
126 }
127 
128 /*
129  * In idle phase, we have to pace the application to let control thread react with GC start.
130  *
131  * Here, we have rendezvous with concurrent thread that adds up the budget as it acknowledges
132  * it had seen recent allocations. It will naturally pace the allocations if control thread is
133  * not catching up. To bootstrap this feedback cycle, we need to start with some initial budget
134  * for applications to allocate at.
</pre>
<hr />
<pre>
174 
175 size_t ShenandoahPacer::update_and_get_progress_history() {
176   if (_progress == -1) {
177     // First initialization, report some prior
178     Atomic::store(&amp;_progress, (intptr_t)PACING_PROGRESS_ZERO);
179     return (size_t) (_heap-&gt;max_capacity() * 0.1);
180   } else {
181     // Record history, and reply historical data
182     _progress_history-&gt;add(_progress);
183     Atomic::store(&amp;_progress, (intptr_t)PACING_PROGRESS_ZERO);
184     return (size_t) (_progress_history-&gt;avg() * HeapWordSize);
185   }
186 }
187 
188 void ShenandoahPacer::restart_with(size_t non_taxable_bytes, double tax_rate) {
189   size_t initial = (size_t)(non_taxable_bytes * tax_rate) &gt;&gt; LogHeapWordSize;
190   STATIC_ASSERT(sizeof(size_t) &lt;= sizeof(intptr_t));
191   Atomic::xchg(&amp;_budget, (intptr_t)initial);
192   Atomic::store(&amp;_tax_rate, tax_rate);
193   Atomic::inc(&amp;_epoch);
<span class="line-added">194 </span>
<span class="line-added">195   // Shake up stalled waiters after budget update.</span>
<span class="line-added">196   notify_waiters();</span>
197 }
198 
199 bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
200   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
201 
202   intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
203 
204   intptr_t cur = 0;
205   intptr_t new_val = 0;
206   do {
207     cur = Atomic::load(&amp;_budget);
208     if (cur &lt; tax &amp;&amp; !force) {
209       // Progress depleted, alas.
210       return false;
211     }
212     new_val = cur - tax;
213   } while (Atomic::cmpxchg(&amp;_budget, cur, new_val) != cur);
214   return true;
215 }
216 
217 void ShenandoahPacer::unpace_for_alloc(intptr_t epoch, size_t words) {
218   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
219 
220   if (_epoch != epoch) {
221     // Stale ticket, no need to unpace.
222     return;
223   }
224 
225   intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
226   Atomic::add(&amp;_budget, tax);
227 }
228 
229 intptr_t ShenandoahPacer::epoch() {
230   return Atomic::load(&amp;_epoch);
231 }
232 
233 void ShenandoahPacer::pace_for_alloc(size_t words) {
234   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
235 
236   // Fast path: try to allocate right away
<span class="line-modified">237   bool claimed = claim_for_alloc(words, false);</span>
<span class="line-added">238   if (claimed) {</span>
239     return;
240   }
241 
<span class="line-added">242   // Forcefully claim the budget: it may go negative at this point, and</span>
<span class="line-added">243   // GC should replenish for this and subsequent allocations. After this claim,</span>
<span class="line-added">244   // we would wait a bit until our claim is matched by additional progress,</span>
<span class="line-added">245   // or the time budget depletes.</span>
<span class="line-added">246   claimed = claim_for_alloc(words, true);</span>
<span class="line-added">247   assert(claimed, &quot;Should always succeed&quot;);</span>
<span class="line-added">248 </span>
249   // Threads that are attaching should not block at all: they are not
250   // fully initialized yet. Blocking them would be awkward.
251   // This is probably the path that allocates the thread oop itself.

252   if (JavaThread::current()-&gt;is_attaching_via_jni()) {

253     return;
254   }
255 

256   double start = os::elapsedTime();
257 
<span class="line-modified">258   size_t max_ms = ShenandoahPacingMaxDelay;</span>
<span class="line-modified">259   size_t total_ms = 0;</span>
260 
261   while (true) {
262     // We could instead assist GC, but this would suffice for now.
<span class="line-modified">263     size_t cur_ms = (max_ms &gt; total_ms) ? (max_ms - total_ms) : 1;</span>
<span class="line-modified">264     wait(cur_ms);</span>








265 
266     double end = os::elapsedTime();
<span class="line-modified">267     total_ms = (size_t)((end - start) * 1000);</span>
<span class="line-modified">268 </span>
<span class="line-modified">269     if (total_ms &gt; max_ms || Atomic::load(&amp;_budget) &gt;= 0) {</span>
<span class="line-modified">270       // Exiting if either:</span>
<span class="line-modified">271       //  a) Spent local time budget to wait for enough GC progress.</span>
<span class="line-modified">272       //     Breaking out and allocating anyway, which may mean we outpace GC,</span>
<span class="line-modified">273       //     and start Degenerated GC cycle.</span>
<span class="line-modified">274       //  b) The budget had been replenished, which means our claim is satisfied.</span>
<span class="line-modified">275       _delays.add(total_ms);</span>








276       break;
277     }
278   }
279 }
280 
281 void ShenandoahPacer::wait(long time_ms) {
282   // Perform timed wait. It works like like sleep(), except without modifying
283   // the thread interruptible status. MonitorLocker also checks for safepoints.
284   assert(time_ms &gt; 0, &quot;Should not call this with zero argument, as it would stall until notify&quot;);
285   MonitorLocker locker(_wait_monitor);
286   _wait_monitor-&gt;wait(time_ms);
287 }
288 
289 void ShenandoahPacer::notify_waiters() {
290   MonitorLocker locker(_wait_monitor);
291   _wait_monitor-&gt;notify_all();
292 }
293 
294 void ShenandoahPacer::print_on(outputStream* out) const {
295   out-&gt;print_cr(&quot;ALLOCATION PACING:&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="../../compiler/compileBroker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
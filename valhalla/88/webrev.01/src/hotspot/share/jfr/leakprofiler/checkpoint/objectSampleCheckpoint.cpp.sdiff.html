<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="eventEmitter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../recorder/checkpoint/jfrCheckpointManager.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;

 27 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/objectSampleMarker.hpp&quot;
 29 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 30 #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
 31 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 32 #include &quot;jfr/leakprofiler/sampling/objectSample.hpp&quot;
 33 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
 34 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
 35 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
 36 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 37 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
 38 #include &quot;jfr/support/jfrKlassUnloading.hpp&quot;
 39 #include &quot;jfr/support/jfrMethodLookup.hpp&quot;
 40 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
 41 #include &quot;jfr/utilities/jfrPredicate.hpp&quot;
 42 #include &quot;jfr/utilities/jfrRelation.hpp&quot;

 43 #include &quot;oops/instanceKlass.inline.hpp&quot;

 44 #include &quot;runtime/mutexLocker.hpp&quot;
 45 #include &quot;runtime/safepoint.hpp&quot;
<span class="line-modified"> 46 #include &quot;runtime/thread.hpp&quot;</span>
 47 
 48 const int initial_array_size = 64;
 49 
 50 template &lt;typename T&gt;
 51 static GrowableArray&lt;T&gt;* c_heap_allocate_array(int size = initial_array_size) {
 52   return new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;T&gt;(size, true, mtTracing);
 53 }
 54 
 55 static GrowableArray&lt;traceid&gt;* unloaded_thread_id_set = NULL;
 56 
 57 class ThreadIdExclusiveAccess : public StackObj {
 58  private:
 59   static Semaphore _mutex_semaphore;
 60  public:
 61   ThreadIdExclusiveAccess() { _mutex_semaphore.wait(); }
 62   ~ThreadIdExclusiveAccess() { _mutex_semaphore.signal(); }
 63 };
 64 
 65 Semaphore ThreadIdExclusiveAccess::_mutex_semaphore(1);
 66 
</pre>
<hr />
<pre>
231   JfrBlobHandle blob = _cache.get(sample);
232   if (blob.valid()) {
233     sample-&gt;set_stacktrace(blob);
234     return;
235   }
236   const JfrStackTrace* const stack_trace = resolve(sample);
237   DEBUG_ONLY(validate_stack_trace(sample, stack_trace));
238   JfrCheckpointWriter writer;
239   writer.write_type(TYPE_STACKTRACE);
240   writer.write_count(1);
241   ObjectSampleCheckpoint::write_stacktrace(stack_trace, writer);
242   blob = writer.move();
243   _cache.put(sample, blob);
244   sample-&gt;set_stacktrace(blob);
245 }
246 
247 static void install_stack_traces(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {
248   assert(sampler != NULL, &quot;invariant&quot;);
249   const ObjectSample* const last = sampler-&gt;last();
250   if (last != sampler-&gt;last_resolved()) {

251     JfrKlassUnloading::sort();
252     StackTraceBlobInstaller installer(stack_trace_repo);
253     iterate_samples(installer);
254   }
255 }
256 
<span class="line-removed">257 // caller needs ResourceMark</span>
258 void ObjectSampleCheckpoint::on_rotation(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {
<span class="line-removed">259   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
260   assert(sampler != NULL, &quot;invariant&quot;);
261   assert(LeakProfiler::is_running(), &quot;invariant&quot;);




262   MutexLocker lock(ClassLoaderDataGraph_lock);
263   // the lock is needed to ensure the unload lists do not grow in the middle of inspection.
264   install_stack_traces(sampler, stack_trace_repo);
265 }
266 
267 static bool is_klass_unloaded(traceid klass_id) {
268   assert(ClassLoaderDataGraph_lock-&gt;owned_by_self(), &quot;invariant&quot;);
269   return JfrKlassUnloading::is_unloaded(klass_id);
270 }
271 
272 static bool is_processed(traceid method_id) {
273   assert(method_id != 0, &quot;invariant&quot;);
274   assert(id_set != NULL, &quot;invariant&quot;);
275   return JfrMutablePredicate&lt;traceid, compare_traceid&gt;::test(id_set, method_id);
276 }
277 
278 void ObjectSampleCheckpoint::add_to_leakp_set(const InstanceKlass* ik, traceid method_id) {
279   assert(ik != NULL, &quot;invariant&quot;);
280   if (is_processed(method_id) || is_klass_unloaded(JfrMethodLookup::klass_id(method_id))) {
281     return;
</pre>
<hr />
<pre>
348       write_blobs(sample, _writer, _reset);
349     }
350   }
351   void set_reset() {
352     _reset = true;
353   }
354 };
355 
356 static void write_sample_blobs(const ObjectSampler* sampler, bool emit_all, Thread* thread) {
357   // sample set is predicated on time of last sweep
358   const jlong last_sweep = emit_all ? max_jlong : sampler-&gt;last_sweep().value();
359   JfrCheckpointWriter writer(thread, false);
360   BlobWriter cbw(sampler, writer, last_sweep);
361   iterate_samples(cbw, true);
362   // reset blob write states
363   cbw.set_reset();
364   iterate_samples(cbw, true);
365 }
366 
367 void ObjectSampleCheckpoint::write(const ObjectSampler* sampler, EdgeStore* edge_store, bool emit_all, Thread* thread) {
<span class="line-removed">368   assert_locked_or_safepoint(JfrStream_lock);</span>
369   assert(sampler != NULL, &quot;invariant&quot;);
370   assert(edge_store != NULL, &quot;invariant&quot;);
371   assert(thread != NULL, &quot;invariant&quot;);
372   write_sample_blobs(sampler, emit_all, thread);
373   // write reference chains
374   if (!edge_store-&gt;is_empty()) {
375     JfrCheckpointWriter writer(thread);
376     ObjectSampleWriter osw(writer, edge_store);
377     edge_store-&gt;iterate(osw);
378   }
379 }
380 
381 // A linked list of saved type set blobs for the epoch.
382 // The link consist of a reference counted handle.
383 static JfrBlobHandle saved_type_set_blobs;
384 
385 static void release_state_for_previous_epoch() {
386   // decrements the reference count and the list is reinitialized
387   saved_type_set_blobs = JfrBlobHandle();
388 }
</pre>
<hr />
<pre>
399   }
400 };
401 
402 static void install_type_set_blobs() {
403   BlobInstaller installer;
404   iterate_samples(installer);
405 }
406 
407 static void save_type_set_blob(JfrCheckpointWriter&amp; writer, bool copy = false) {
408   assert(writer.has_data(), &quot;invariant&quot;);
409   const JfrBlobHandle blob = copy ? writer.copy() : writer.move();
410   if (saved_type_set_blobs.valid()) {
411     saved_type_set_blobs-&gt;set_next(blob);
412   } else {
413     saved_type_set_blobs = blob;
414   }
415 }
416 
417 void ObjectSampleCheckpoint::on_type_set(JfrCheckpointWriter&amp; writer) {
418   assert(LeakProfiler::is_running(), &quot;invariant&quot;);

419   const ObjectSample* last = ObjectSampler::sampler()-&gt;last();
420   if (writer.has_data() &amp;&amp; last != NULL) {
421     save_type_set_blob(writer);
422     install_type_set_blobs();
423     ObjectSampler::sampler()-&gt;set_last_resolved(last);
424   }
425 }
426 
427 void ObjectSampleCheckpoint::on_type_set_unload(JfrCheckpointWriter&amp; writer) {
428   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
429   assert(LeakProfiler::is_running(), &quot;invariant&quot;);
430   if (writer.has_data() &amp;&amp; ObjectSampler::sampler()-&gt;last() != NULL) {
431     save_type_set_blob(writer, true);
432   }
433 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
<span class="line-added"> 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;</span>
 28 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/objectSampleMarker.hpp&quot;
 30 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 31 #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
 32 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 33 #include &quot;jfr/leakprofiler/sampling/objectSample.hpp&quot;
 34 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
 35 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
 36 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
 37 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 38 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
 39 #include &quot;jfr/support/jfrKlassUnloading.hpp&quot;
 40 #include &quot;jfr/support/jfrMethodLookup.hpp&quot;
 41 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
 42 #include &quot;jfr/utilities/jfrPredicate.hpp&quot;
 43 #include &quot;jfr/utilities/jfrRelation.hpp&quot;
<span class="line-added"> 44 #include &quot;memory/resourceArea.inline.hpp&quot;</span>
 45 #include &quot;oops/instanceKlass.inline.hpp&quot;
<span class="line-added"> 46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/safepoint.hpp&quot;
<span class="line-modified"> 49 #include &quot;runtime/thread.inline.hpp&quot;</span>
 50 
 51 const int initial_array_size = 64;
 52 
 53 template &lt;typename T&gt;
 54 static GrowableArray&lt;T&gt;* c_heap_allocate_array(int size = initial_array_size) {
 55   return new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;T&gt;(size, true, mtTracing);
 56 }
 57 
 58 static GrowableArray&lt;traceid&gt;* unloaded_thread_id_set = NULL;
 59 
 60 class ThreadIdExclusiveAccess : public StackObj {
 61  private:
 62   static Semaphore _mutex_semaphore;
 63  public:
 64   ThreadIdExclusiveAccess() { _mutex_semaphore.wait(); }
 65   ~ThreadIdExclusiveAccess() { _mutex_semaphore.signal(); }
 66 };
 67 
 68 Semaphore ThreadIdExclusiveAccess::_mutex_semaphore(1);
 69 
</pre>
<hr />
<pre>
234   JfrBlobHandle blob = _cache.get(sample);
235   if (blob.valid()) {
236     sample-&gt;set_stacktrace(blob);
237     return;
238   }
239   const JfrStackTrace* const stack_trace = resolve(sample);
240   DEBUG_ONLY(validate_stack_trace(sample, stack_trace));
241   JfrCheckpointWriter writer;
242   writer.write_type(TYPE_STACKTRACE);
243   writer.write_count(1);
244   ObjectSampleCheckpoint::write_stacktrace(stack_trace, writer);
245   blob = writer.move();
246   _cache.put(sample, blob);
247   sample-&gt;set_stacktrace(blob);
248 }
249 
250 static void install_stack_traces(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {
251   assert(sampler != NULL, &quot;invariant&quot;);
252   const ObjectSample* const last = sampler-&gt;last();
253   if (last != sampler-&gt;last_resolved()) {
<span class="line-added">254     ResourceMark rm;</span>
255     JfrKlassUnloading::sort();
256     StackTraceBlobInstaller installer(stack_trace_repo);
257     iterate_samples(installer);
258   }
259 }
260 

261 void ObjectSampleCheckpoint::on_rotation(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {

262   assert(sampler != NULL, &quot;invariant&quot;);
263   assert(LeakProfiler::is_running(), &quot;invariant&quot;);
<span class="line-added">264   Thread* const thread = Thread::current();</span>
<span class="line-added">265   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread);)</span>
<span class="line-added">266   // can safepoint here</span>
<span class="line-added">267   ThreadInVMfromNative transition((JavaThread*)thread);</span>
268   MutexLocker lock(ClassLoaderDataGraph_lock);
269   // the lock is needed to ensure the unload lists do not grow in the middle of inspection.
270   install_stack_traces(sampler, stack_trace_repo);
271 }
272 
273 static bool is_klass_unloaded(traceid klass_id) {
274   assert(ClassLoaderDataGraph_lock-&gt;owned_by_self(), &quot;invariant&quot;);
275   return JfrKlassUnloading::is_unloaded(klass_id);
276 }
277 
278 static bool is_processed(traceid method_id) {
279   assert(method_id != 0, &quot;invariant&quot;);
280   assert(id_set != NULL, &quot;invariant&quot;);
281   return JfrMutablePredicate&lt;traceid, compare_traceid&gt;::test(id_set, method_id);
282 }
283 
284 void ObjectSampleCheckpoint::add_to_leakp_set(const InstanceKlass* ik, traceid method_id) {
285   assert(ik != NULL, &quot;invariant&quot;);
286   if (is_processed(method_id) || is_klass_unloaded(JfrMethodLookup::klass_id(method_id))) {
287     return;
</pre>
<hr />
<pre>
354       write_blobs(sample, _writer, _reset);
355     }
356   }
357   void set_reset() {
358     _reset = true;
359   }
360 };
361 
362 static void write_sample_blobs(const ObjectSampler* sampler, bool emit_all, Thread* thread) {
363   // sample set is predicated on time of last sweep
364   const jlong last_sweep = emit_all ? max_jlong : sampler-&gt;last_sweep().value();
365   JfrCheckpointWriter writer(thread, false);
366   BlobWriter cbw(sampler, writer, last_sweep);
367   iterate_samples(cbw, true);
368   // reset blob write states
369   cbw.set_reset();
370   iterate_samples(cbw, true);
371 }
372 
373 void ObjectSampleCheckpoint::write(const ObjectSampler* sampler, EdgeStore* edge_store, bool emit_all, Thread* thread) {

374   assert(sampler != NULL, &quot;invariant&quot;);
375   assert(edge_store != NULL, &quot;invariant&quot;);
376   assert(thread != NULL, &quot;invariant&quot;);
377   write_sample_blobs(sampler, emit_all, thread);
378   // write reference chains
379   if (!edge_store-&gt;is_empty()) {
380     JfrCheckpointWriter writer(thread);
381     ObjectSampleWriter osw(writer, edge_store);
382     edge_store-&gt;iterate(osw);
383   }
384 }
385 
386 // A linked list of saved type set blobs for the epoch.
387 // The link consist of a reference counted handle.
388 static JfrBlobHandle saved_type_set_blobs;
389 
390 static void release_state_for_previous_epoch() {
391   // decrements the reference count and the list is reinitialized
392   saved_type_set_blobs = JfrBlobHandle();
393 }
</pre>
<hr />
<pre>
404   }
405 };
406 
407 static void install_type_set_blobs() {
408   BlobInstaller installer;
409   iterate_samples(installer);
410 }
411 
412 static void save_type_set_blob(JfrCheckpointWriter&amp; writer, bool copy = false) {
413   assert(writer.has_data(), &quot;invariant&quot;);
414   const JfrBlobHandle blob = copy ? writer.copy() : writer.move();
415   if (saved_type_set_blobs.valid()) {
416     saved_type_set_blobs-&gt;set_next(blob);
417   } else {
418     saved_type_set_blobs = blob;
419   }
420 }
421 
422 void ObjectSampleCheckpoint::on_type_set(JfrCheckpointWriter&amp; writer) {
423   assert(LeakProfiler::is_running(), &quot;invariant&quot;);
<span class="line-added">424   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(Thread::current());)</span>
425   const ObjectSample* last = ObjectSampler::sampler()-&gt;last();
426   if (writer.has_data() &amp;&amp; last != NULL) {
427     save_type_set_blob(writer);
428     install_type_set_blobs();
429     ObjectSampler::sampler()-&gt;set_last_resolved(last);
430   }
431 }
432 
433 void ObjectSampleCheckpoint::on_type_set_unload(JfrCheckpointWriter&amp; writer) {
434   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
435   assert(LeakProfiler::is_running(), &quot;invariant&quot;);
436   if (writer.has_data() &amp;&amp; ObjectSampler::sampler()-&gt;last() != NULL) {
437     save_type_set_blob(writer, true);
438   }
439 }
</pre>
</td>
</tr>
</table>
<center><a href="eventEmitter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../recorder/checkpoint/jfrCheckpointManager.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp b/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
@@ -22,10 +22,11 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "classfile/javaClasses.inline.hpp"
+#include "jfr/jni/jfrJavaSupport.hpp"
 #include "jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp"
 #include "jfr/leakprofiler/leakProfiler.hpp"
 #include "jfr/recorder/checkpoint/jfrCheckpointManager.hpp"
 #include "jfr/recorder/checkpoint/jfrCheckpointWriter.hpp"
 #include "jfr/recorder/checkpoint/types/jfrTypeManager.hpp"
@@ -46,10 +47,11 @@
 #include "logging/log.hpp"
 #include "memory/iterator.hpp"
 #include "memory/resourceArea.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/handles.inline.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/mutex.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/safepoint.hpp"
 
 typedef JfrCheckpointManager::BufferPtr BufferPtr;
@@ -323,10 +325,11 @@
   JfrTraceIdEpoch::end_epoch_shift();
   assert(current_epoch != JfrTraceIdEpoch::current(), "invariant");
 }
 
 size_t JfrCheckpointManager::write() {
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));
   assert(_mspace->free_list_is_empty(), "invariant");
   WriteOperation wo(_chunkwriter);
   MutexedWriteOperation mwo(wo);
   ReleaseOperation ro(_mspace, _mspace->live_list(true));
   WriteReleaseOperation wro(&mwo, &ro);
@@ -355,19 +358,23 @@
   return writer.used_size();
 }
 
 size_t JfrCheckpointManager::write_threads(Thread* thread) {
   assert(thread != NULL, "invariant");
+  // can safepoint here
+  ThreadInVMfromNative transition((JavaThread*)thread);
+  ResetNoHandleMark rnhm;
+  ResourceMark rm(thread);
+  HandleMark hm(thread);
   JfrCheckpointWriter writer(true, thread, THREADS);
   JfrTypeManager::write_threads(writer);
   return writer.used_size();
 }
 
 size_t JfrCheckpointManager::write_static_type_set_and_threads() {
   Thread* const thread = Thread::current();
-  ResourceMark rm(thread);
-  HandleMark hm(thread);
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread));
   write_static_type_set(thread);
   write_threads(thread);
   return write();
 }
 
@@ -378,33 +385,39 @@
 }
 
 void JfrCheckpointManager::clear_type_set() {
   assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
   assert(!JfrRecorder::is_recording(), "invariant");
+  Thread* t = Thread::current();
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(t));
   // can safepoint here
+  ThreadInVMfromNative transition((JavaThread*)t);
+  ResetNoHandleMark rnhm;
   MutexLocker cld_lock(ClassLoaderDataGraph_lock);
   MutexLocker module_lock(Module_lock);
   JfrTypeSet::clear();
 }
 
 void JfrCheckpointManager::write_type_set() {
   assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
-  Thread* const thread = Thread::current();
-  if (LeakProfiler::is_running()) {
+  {
+    Thread* const thread = Thread::current();
+    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread));
     // can safepoint here
+    ThreadInVMfromNative transition((JavaThread*)thread);
+    ResetNoHandleMark rnhm;
     MutexLocker cld_lock(thread, ClassLoaderDataGraph_lock);
     MutexLocker module_lock(thread, Module_lock);
-    JfrCheckpointWriter leakp_writer(true, thread);
-    JfrCheckpointWriter writer(true, thread);
-    JfrTypeSet::serialize(&writer, &leakp_writer, false, false);
-    ObjectSampleCheckpoint::on_type_set(leakp_writer);
-  } else {
-    // can safepoint here
-    MutexLocker cld_lock(ClassLoaderDataGraph_lock);
-    MutexLocker module_lock(Module_lock);
-    JfrCheckpointWriter writer(true, thread);
-    JfrTypeSet::serialize(&writer, NULL, false, false);
+    if (LeakProfiler::is_running()) {
+      JfrCheckpointWriter leakp_writer(true, thread);
+      JfrCheckpointWriter writer(true, thread);
+      JfrTypeSet::serialize(&writer, &leakp_writer, false, false);
+      ObjectSampleCheckpoint::on_type_set(leakp_writer);
+    } else {
+      JfrCheckpointWriter writer(true, thread);
+      JfrTypeSet::serialize(&writer, NULL, false, false);
+    }
   }
   write();
 }
 
 void JfrCheckpointManager::on_unloading_classes() {
@@ -414,17 +427,37 @@
   if (LeakProfiler::is_running()) {
     ObjectSampleCheckpoint::on_type_set_unload(writer);
   }
 }
 
+class JavaThreadToVM : public StackObj {
+ private:
+  JavaThread* _jt;
+ public:
+  JavaThreadToVM(Thread* thread) : _jt(thread->is_Java_thread() ? (JavaThread*)thread : NULL) {
+    if (_jt != NULL) {
+      assert(_jt->thread_state() == _thread_in_native, "invariant");
+      _jt->set_thread_state(_thread_in_vm);
+    }
+  }
+  ~JavaThreadToVM() {
+    if (_jt != NULL) {
+      _jt->set_thread_state(_thread_in_native);
+    }
+  }
+};
+
 size_t JfrCheckpointManager::flush_type_set() {
   size_t elements = 0;
   if (JfrTraceIdEpoch::has_changed_tag_state()) {
-    JfrCheckpointWriter writer(Thread::current());
-    // can safepoint here
-    MutexLocker cld_lock(ClassLoaderDataGraph_lock);
-    MutexLocker module_lock(Module_lock);
+    Thread* const t = Thread::current();
+    // can safepoint here (if JavaThread)
+    JavaThreadToVM transition(t);
+    ResetNoHandleMark rnhm;
+    MutexLocker cld_lock(t, ClassLoaderDataGraph_lock);
+    MutexLocker module_lock(t, Module_lock);
+    JfrCheckpointWriter writer(t);
     elements = JfrTypeSet::serialize(&writer, NULL, false, true);
   }
   if (is_constant_pending()) {
     WriteOperation wo(_chunkwriter);
     MutexedWriteOperation mwo(wo);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../leakprofiler/checkpoint/objectSampleCheckpoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrMetadataEvent.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;

 27 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 28 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 29 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
 30 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
 31 #include &quot;jfr/recorder/checkpoint/types/jfrTypeManager.hpp&quot;
 32 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
 33 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceIdEpoch.hpp&quot;
 34 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 35 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
 36 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 37 #include &quot;jfr/recorder/storage/jfrMemorySpace.inline.hpp&quot;
 38 #include &quot;jfr/recorder/storage/jfrStorageUtils.inline.hpp&quot;
 39 #include &quot;jfr/support/jfrKlassUnloading.hpp&quot;
 40 #include &quot;jfr/utilities/jfrBigEndian.hpp&quot;
 41 #include &quot;jfr/utilities/jfrIterator.hpp&quot;
 42 #include &quot;jfr/utilities/jfrLinkedList.inline.hpp&quot;
 43 #include &quot;jfr/utilities/jfrThreadIterator.hpp&quot;
 44 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 45 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
 46 #include &quot;logging/log.hpp&quot;
 47 #include &quot;memory/iterator.hpp&quot;
 48 #include &quot;memory/resourceArea.hpp&quot;
 49 #include &quot;runtime/atomic.hpp&quot;
 50 #include &quot;runtime/handles.inline.hpp&quot;

 51 #include &quot;runtime/mutex.hpp&quot;
 52 #include &quot;runtime/os.inline.hpp&quot;
 53 #include &quot;runtime/safepoint.hpp&quot;
 54 
 55 typedef JfrCheckpointManager::BufferPtr BufferPtr;
 56 
 57 static volatile bool constant_pending = false;
 58 
 59 static bool is_constant_pending() {
 60   if (Atomic::load_acquire(&amp;constant_pending)) {
 61     Atomic::release_store(&amp;constant_pending, false); // reset
 62     return true;
 63   }
 64   return false;
 65 }
 66 
 67 static void set_constant_pending() {
 68   if (!Atomic::load_acquire(&amp;constant_pending)) {
 69     Atomic::release_store(&amp;constant_pending, true);
 70   }
</pre>
<hr />
<pre>
308 };
309 
310 typedef CheckpointWriteOp&lt;JfrCheckpointManager::Buffer&gt; WriteOperation;
311 typedef MutexedWriteOp&lt;WriteOperation&gt; MutexedWriteOperation;
312 typedef ReleaseOpWithExcision&lt;JfrCheckpointMspace, JfrCheckpointMspace::LiveList&gt; ReleaseOperation;
313 typedef CompositeOperation&lt;MutexedWriteOperation, ReleaseOperation&gt; WriteReleaseOperation;
314 
315 void JfrCheckpointManager::begin_epoch_shift() {
316   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
317   JfrTraceIdEpoch::begin_epoch_shift();
318 }
319 
320 void JfrCheckpointManager::end_epoch_shift() {
321   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
322   debug_only(const u1 current_epoch = JfrTraceIdEpoch::current();)
323   JfrTraceIdEpoch::end_epoch_shift();
324   assert(current_epoch != JfrTraceIdEpoch::current(), &quot;invariant&quot;);
325 }
326 
327 size_t JfrCheckpointManager::write() {

328   assert(_mspace-&gt;free_list_is_empty(), &quot;invariant&quot;);
329   WriteOperation wo(_chunkwriter);
330   MutexedWriteOperation mwo(wo);
331   ReleaseOperation ro(_mspace, _mspace-&gt;live_list(true));
332   WriteReleaseOperation wro(&amp;mwo, &amp;ro);
333   process_live_list(wro, _mspace, true);
334   return wo.processed();
335 }
336 
337 typedef DiscardOp&lt;DefaultDiscarder&lt;JfrCheckpointManager::Buffer&gt; &gt; DiscardOperation;
338 typedef CompositeOperation&lt;DiscardOperation, ReleaseOperation&gt; DiscardReleaseOperation;
339 
340 size_t JfrCheckpointManager::clear() {
341   JfrTraceIdLoadBarrier::clear();
342   clear_type_set();
343   DiscardOperation discard_operation(mutexed); // mutexed discard mode
344   ReleaseOperation ro(_mspace, _mspace-&gt;live_list(true));
345   DiscardReleaseOperation discard_op(&amp;discard_operation, &amp;ro);
346   assert(_mspace-&gt;free_list_is_empty(), &quot;invariant&quot;);
347   process_live_list(discard_op, _mspace, true); // previous epoch list
348   return discard_operation.elements();
349 }
350 
351 size_t JfrCheckpointManager::write_static_type_set(Thread* thread) {
352   assert(thread != NULL, &quot;invariant&quot;);
353   JfrCheckpointWriter writer(true, thread, STATICS);
354   JfrTypeManager::write_static_types(writer);
355   return writer.used_size();
356 }
357 
358 size_t JfrCheckpointManager::write_threads(Thread* thread) {
359   assert(thread != NULL, &quot;invariant&quot;);





360   JfrCheckpointWriter writer(true, thread, THREADS);
361   JfrTypeManager::write_threads(writer);
362   return writer.used_size();
363 }
364 
365 size_t JfrCheckpointManager::write_static_type_set_and_threads() {
366   Thread* const thread = Thread::current();
<span class="line-modified">367   ResourceMark rm(thread);</span>
<span class="line-removed">368   HandleMark hm(thread);</span>
369   write_static_type_set(thread);
370   write_threads(thread);
371   return write();
372 }
373 
374 void JfrCheckpointManager::on_rotation() {
375   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
376   JfrTypeManager::on_rotation();
377   notify_threads();
378 }
379 
380 void JfrCheckpointManager::clear_type_set() {
381   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
382   assert(!JfrRecorder::is_recording(), &quot;invariant&quot;);


383   // can safepoint here


384   MutexLocker cld_lock(ClassLoaderDataGraph_lock);
385   MutexLocker module_lock(Module_lock);
386   JfrTypeSet::clear();
387 }
388 
389 void JfrCheckpointManager::write_type_set() {
390   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">391   Thread* const thread = Thread::current();</span>
<span class="line-modified">392   if (LeakProfiler::is_running()) {</span>

393     // can safepoint here


394     MutexLocker cld_lock(thread, ClassLoaderDataGraph_lock);
395     MutexLocker module_lock(thread, Module_lock);
<span class="line-modified">396     JfrCheckpointWriter leakp_writer(true, thread);</span>
<span class="line-modified">397     JfrCheckpointWriter writer(true, thread);</span>
<span class="line-modified">398     JfrTypeSet::serialize(&amp;writer, &amp;leakp_writer, false, false);</span>
<span class="line-modified">399     ObjectSampleCheckpoint::on_type_set(leakp_writer);</span>
<span class="line-modified">400   } else {</span>
<span class="line-modified">401     // can safepoint here</span>
<span class="line-modified">402     MutexLocker cld_lock(ClassLoaderDataGraph_lock);</span>
<span class="line-modified">403     MutexLocker module_lock(Module_lock);</span>
<span class="line-modified">404     JfrCheckpointWriter writer(true, thread);</span>
<span class="line-removed">405     JfrTypeSet::serialize(&amp;writer, NULL, false, false);</span>
406   }
407   write();
408 }
409 
410 void JfrCheckpointManager::on_unloading_classes() {
411   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
412   JfrCheckpointWriter writer(Thread::current());
413   JfrTypeSet::on_unloading_classes(&amp;writer);
414   if (LeakProfiler::is_running()) {
415     ObjectSampleCheckpoint::on_type_set_unload(writer);
416   }
417 }
418 

















419 size_t JfrCheckpointManager::flush_type_set() {
420   size_t elements = 0;
421   if (JfrTraceIdEpoch::has_changed_tag_state()) {
<span class="line-modified">422     JfrCheckpointWriter writer(Thread::current());</span>
<span class="line-modified">423     // can safepoint here</span>
<span class="line-modified">424     MutexLocker cld_lock(ClassLoaderDataGraph_lock);</span>
<span class="line-modified">425     MutexLocker module_lock(Module_lock);</span>



426     elements = JfrTypeSet::serialize(&amp;writer, NULL, false, true);
427   }
428   if (is_constant_pending()) {
429     WriteOperation wo(_chunkwriter);
430     MutexedWriteOperation mwo(wo);
431     assert(_mspace-&gt;live_list_is_nonempty(), &quot;invariant&quot;);
432     process_live_list(mwo, _mspace);
433   }
434   return elements;
435 }
436 
437 void JfrCheckpointManager::create_thread_blob(Thread* thread) {
438   JfrTypeManager::create_thread_blob(thread);
439 }
440 
441 void JfrCheckpointManager::write_thread_checkpoint(Thread* thread) {
442   JfrTypeManager::write_thread_checkpoint(thread);
443 }
444 
445 class JfrNotifyClosure : public ThreadClosure {
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="line-added"> 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;</span>
 28 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 29 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 30 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
 31 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
 32 #include &quot;jfr/recorder/checkpoint/types/jfrTypeManager.hpp&quot;
 33 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
 34 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceIdEpoch.hpp&quot;
 35 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 36 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
 37 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 38 #include &quot;jfr/recorder/storage/jfrMemorySpace.inline.hpp&quot;
 39 #include &quot;jfr/recorder/storage/jfrStorageUtils.inline.hpp&quot;
 40 #include &quot;jfr/support/jfrKlassUnloading.hpp&quot;
 41 #include &quot;jfr/utilities/jfrBigEndian.hpp&quot;
 42 #include &quot;jfr/utilities/jfrIterator.hpp&quot;
 43 #include &quot;jfr/utilities/jfrLinkedList.inline.hpp&quot;
 44 #include &quot;jfr/utilities/jfrThreadIterator.hpp&quot;
 45 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 46 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
 47 #include &quot;logging/log.hpp&quot;
 48 #include &quot;memory/iterator.hpp&quot;
 49 #include &quot;memory/resourceArea.hpp&quot;
 50 #include &quot;runtime/atomic.hpp&quot;
 51 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added"> 52 #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
 53 #include &quot;runtime/mutex.hpp&quot;
 54 #include &quot;runtime/os.inline.hpp&quot;
 55 #include &quot;runtime/safepoint.hpp&quot;
 56 
 57 typedef JfrCheckpointManager::BufferPtr BufferPtr;
 58 
 59 static volatile bool constant_pending = false;
 60 
 61 static bool is_constant_pending() {
 62   if (Atomic::load_acquire(&amp;constant_pending)) {
 63     Atomic::release_store(&amp;constant_pending, false); // reset
 64     return true;
 65   }
 66   return false;
 67 }
 68 
 69 static void set_constant_pending() {
 70   if (!Atomic::load_acquire(&amp;constant_pending)) {
 71     Atomic::release_store(&amp;constant_pending, true);
 72   }
</pre>
<hr />
<pre>
310 };
311 
312 typedef CheckpointWriteOp&lt;JfrCheckpointManager::Buffer&gt; WriteOperation;
313 typedef MutexedWriteOp&lt;WriteOperation&gt; MutexedWriteOperation;
314 typedef ReleaseOpWithExcision&lt;JfrCheckpointMspace, JfrCheckpointMspace::LiveList&gt; ReleaseOperation;
315 typedef CompositeOperation&lt;MutexedWriteOperation, ReleaseOperation&gt; WriteReleaseOperation;
316 
317 void JfrCheckpointManager::begin_epoch_shift() {
318   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
319   JfrTraceIdEpoch::begin_epoch_shift();
320 }
321 
322 void JfrCheckpointManager::end_epoch_shift() {
323   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
324   debug_only(const u1 current_epoch = JfrTraceIdEpoch::current();)
325   JfrTraceIdEpoch::end_epoch_shift();
326   assert(current_epoch != JfrTraceIdEpoch::current(), &quot;invariant&quot;);
327 }
328 
329 size_t JfrCheckpointManager::write() {
<span class="line-added">330   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));</span>
331   assert(_mspace-&gt;free_list_is_empty(), &quot;invariant&quot;);
332   WriteOperation wo(_chunkwriter);
333   MutexedWriteOperation mwo(wo);
334   ReleaseOperation ro(_mspace, _mspace-&gt;live_list(true));
335   WriteReleaseOperation wro(&amp;mwo, &amp;ro);
336   process_live_list(wro, _mspace, true);
337   return wo.processed();
338 }
339 
340 typedef DiscardOp&lt;DefaultDiscarder&lt;JfrCheckpointManager::Buffer&gt; &gt; DiscardOperation;
341 typedef CompositeOperation&lt;DiscardOperation, ReleaseOperation&gt; DiscardReleaseOperation;
342 
343 size_t JfrCheckpointManager::clear() {
344   JfrTraceIdLoadBarrier::clear();
345   clear_type_set();
346   DiscardOperation discard_operation(mutexed); // mutexed discard mode
347   ReleaseOperation ro(_mspace, _mspace-&gt;live_list(true));
348   DiscardReleaseOperation discard_op(&amp;discard_operation, &amp;ro);
349   assert(_mspace-&gt;free_list_is_empty(), &quot;invariant&quot;);
350   process_live_list(discard_op, _mspace, true); // previous epoch list
351   return discard_operation.elements();
352 }
353 
354 size_t JfrCheckpointManager::write_static_type_set(Thread* thread) {
355   assert(thread != NULL, &quot;invariant&quot;);
356   JfrCheckpointWriter writer(true, thread, STATICS);
357   JfrTypeManager::write_static_types(writer);
358   return writer.used_size();
359 }
360 
361 size_t JfrCheckpointManager::write_threads(Thread* thread) {
362   assert(thread != NULL, &quot;invariant&quot;);
<span class="line-added">363   // can safepoint here</span>
<span class="line-added">364   ThreadInVMfromNative transition((JavaThread*)thread);</span>
<span class="line-added">365   ResetNoHandleMark rnhm;</span>
<span class="line-added">366   ResourceMark rm(thread);</span>
<span class="line-added">367   HandleMark hm(thread);</span>
368   JfrCheckpointWriter writer(true, thread, THREADS);
369   JfrTypeManager::write_threads(writer);
370   return writer.used_size();
371 }
372 
373 size_t JfrCheckpointManager::write_static_type_set_and_threads() {
374   Thread* const thread = Thread::current();
<span class="line-modified">375   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread));</span>

376   write_static_type_set(thread);
377   write_threads(thread);
378   return write();
379 }
380 
381 void JfrCheckpointManager::on_rotation() {
382   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
383   JfrTypeManager::on_rotation();
384   notify_threads();
385 }
386 
387 void JfrCheckpointManager::clear_type_set() {
388   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
389   assert(!JfrRecorder::is_recording(), &quot;invariant&quot;);
<span class="line-added">390   Thread* t = Thread::current();</span>
<span class="line-added">391   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(t));</span>
392   // can safepoint here
<span class="line-added">393   ThreadInVMfromNative transition((JavaThread*)t);</span>
<span class="line-added">394   ResetNoHandleMark rnhm;</span>
395   MutexLocker cld_lock(ClassLoaderDataGraph_lock);
396   MutexLocker module_lock(Module_lock);
397   JfrTypeSet::clear();
398 }
399 
400 void JfrCheckpointManager::write_type_set() {
401   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">402   {</span>
<span class="line-modified">403     Thread* const thread = Thread::current();</span>
<span class="line-added">404     DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread));</span>
405     // can safepoint here
<span class="line-added">406     ThreadInVMfromNative transition((JavaThread*)thread);</span>
<span class="line-added">407     ResetNoHandleMark rnhm;</span>
408     MutexLocker cld_lock(thread, ClassLoaderDataGraph_lock);
409     MutexLocker module_lock(thread, Module_lock);
<span class="line-modified">410     if (LeakProfiler::is_running()) {</span>
<span class="line-modified">411       JfrCheckpointWriter leakp_writer(true, thread);</span>
<span class="line-modified">412       JfrCheckpointWriter writer(true, thread);</span>
<span class="line-modified">413       JfrTypeSet::serialize(&amp;writer, &amp;leakp_writer, false, false);</span>
<span class="line-modified">414       ObjectSampleCheckpoint::on_type_set(leakp_writer);</span>
<span class="line-modified">415     } else {</span>
<span class="line-modified">416       JfrCheckpointWriter writer(true, thread);</span>
<span class="line-modified">417       JfrTypeSet::serialize(&amp;writer, NULL, false, false);</span>
<span class="line-modified">418     }</span>

419   }
420   write();
421 }
422 
423 void JfrCheckpointManager::on_unloading_classes() {
424   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
425   JfrCheckpointWriter writer(Thread::current());
426   JfrTypeSet::on_unloading_classes(&amp;writer);
427   if (LeakProfiler::is_running()) {
428     ObjectSampleCheckpoint::on_type_set_unload(writer);
429   }
430 }
431 
<span class="line-added">432 class JavaThreadToVM : public StackObj {</span>
<span class="line-added">433  private:</span>
<span class="line-added">434   JavaThread* _jt;</span>
<span class="line-added">435  public:</span>
<span class="line-added">436   JavaThreadToVM(Thread* thread) : _jt(thread-&gt;is_Java_thread() ? (JavaThread*)thread : NULL) {</span>
<span class="line-added">437     if (_jt != NULL) {</span>
<span class="line-added">438       assert(_jt-&gt;thread_state() == _thread_in_native, &quot;invariant&quot;);</span>
<span class="line-added">439       _jt-&gt;set_thread_state(_thread_in_vm);</span>
<span class="line-added">440     }</span>
<span class="line-added">441   }</span>
<span class="line-added">442   ~JavaThreadToVM() {</span>
<span class="line-added">443     if (_jt != NULL) {</span>
<span class="line-added">444       _jt-&gt;set_thread_state(_thread_in_native);</span>
<span class="line-added">445     }</span>
<span class="line-added">446   }</span>
<span class="line-added">447 };</span>
<span class="line-added">448 </span>
449 size_t JfrCheckpointManager::flush_type_set() {
450   size_t elements = 0;
451   if (JfrTraceIdEpoch::has_changed_tag_state()) {
<span class="line-modified">452     Thread* const t = Thread::current();</span>
<span class="line-modified">453     // can safepoint here (if JavaThread)</span>
<span class="line-modified">454     JavaThreadToVM transition(t);</span>
<span class="line-modified">455     ResetNoHandleMark rnhm;</span>
<span class="line-added">456     MutexLocker cld_lock(t, ClassLoaderDataGraph_lock);</span>
<span class="line-added">457     MutexLocker module_lock(t, Module_lock);</span>
<span class="line-added">458     JfrCheckpointWriter writer(t);</span>
459     elements = JfrTypeSet::serialize(&amp;writer, NULL, false, true);
460   }
461   if (is_constant_pending()) {
462     WriteOperation wo(_chunkwriter);
463     MutexedWriteOperation mwo(wo);
464     assert(_mspace-&gt;live_list_is_nonempty(), &quot;invariant&quot;);
465     process_live_list(mwo, _mspace);
466   }
467   return elements;
468 }
469 
470 void JfrCheckpointManager::create_thread_blob(Thread* thread) {
471   JfrTypeManager::create_thread_blob(thread);
472 }
473 
474 void JfrCheckpointManager::write_thread_checkpoint(Thread* thread) {
475   JfrTypeManager::write_thread_checkpoint(thread);
476 }
477 
478 class JfrNotifyClosure : public ThreadClosure {
</pre>
</td>
</tr>
</table>
<center><a href="../../leakprofiler/checkpoint/objectSampleCheckpoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrMetadataEvent.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
  32 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
  33 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
  34 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
  35 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceIdLoadBarrier.inline.hpp&quot;
  36 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
  37 #include &quot;jfr/support/jfrKlassUnloading.hpp&quot;
  38 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
  39 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
  40 #include &quot;jfr/writers/jfrTypeWriterHost.hpp&quot;
  41 #include &quot;memory/iterator.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;oops/instanceKlass.hpp&quot;
  44 #include &quot;oops/objArrayKlass.hpp&quot;
  45 #include &quot;oops/oop.inline.hpp&quot;
  46 #include &quot;utilities/accessFlags.hpp&quot;
  47 #include &quot;utilities/bitMap.inline.hpp&quot;
  48 #include &quot;utilities/stack.inline.hpp&quot;
  49 
  50 typedef const Klass* KlassPtr;
  51 typedef const PackageEntry* PkgPtr;
  52 typedef const ModuleEntry* ModPtr;
  53 typedef const ClassLoaderData* CldPtr;
  54 typedef const Method* MethodPtr;
  55 typedef const Symbol* SymbolPtr;
  56 typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;
  57 typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;
  58 
  59 static JfrCheckpointWriter* _writer = NULL;
  60 static JfrCheckpointWriter* _leakp_writer = NULL;
  61 static JfrArtifactSet* _artifacts = NULL;
  62 static JfrArtifactClosure* _subsystem_callback = NULL;
  63 static bool _class_unload = false;
  64 static bool _flushpoint = false;
  65 
  66 // incremented on each rotation
  67 static u8 checkpoint_id = 1;
  68 
  69 // creates a unique id by combining a checkpoint relative symbol id (2^24)
  70 // with the current checkpoint id (2^40)
  71 #define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id &lt;&lt; 24) | sym_id)))
  72 
  73 static traceid create_symbol_id(traceid artifact_id) {
  74   return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;
  75 }
  76 
  77 static bool current_epoch() {
  78   return _class_unload || _flushpoint;
  79 }
  80 
  81 static bool previous_epoch() {
  82   return !current_epoch();
  83 }
  84 
  85 static bool is_complete() {
  86   return !_artifacts-&gt;has_klass_entries() &amp;&amp; current_epoch();
  87 }
  88 
  89 static traceid mark_symbol(KlassPtr klass, bool leakp) {
  90   return klass != NULL ? create_symbol_id(_artifacts-&gt;mark(klass, leakp)) : 0;
  91 }
  92 
  93 static traceid mark_symbol(Symbol* symbol, bool leakp) {
  94   return symbol != NULL ? create_symbol_id(_artifacts-&gt;mark(symbol, leakp)) : 0;
  95 }
  96 
  97 static traceid get_bootstrap_name(bool leakp) {
  98   return create_symbol_id(_artifacts-&gt;bootstrap_name(leakp));
  99 }
 100 
 101 template &lt;typename T&gt;
 102 static traceid artifact_id(const T* ptr) {
 103   assert(ptr != NULL, &quot;invariant&quot;);
 104   return JfrTraceId::load_raw(ptr);
 105 }
 106 
 107 static traceid package_id(KlassPtr klass, bool leakp) {
 108   assert(klass != NULL, &quot;invariant&quot;);
 109   PkgPtr pkg_entry = klass-&gt;package();
 110   if (pkg_entry == NULL) {
 111     return 0;
 112   }
 113   if (leakp) {
 114     SET_LEAKP(pkg_entry);
 115   }
 116   // package implicitly tagged already
 117   return artifact_id(pkg_entry);
 118 }
 119 
 120 static traceid module_id(PkgPtr pkg, bool leakp) {
 121   assert(pkg != NULL, &quot;invariant&quot;);
 122   ModPtr module_entry = pkg-&gt;module();
 123   if (module_entry == NULL) {
 124     return 0;
 125   }
 126   if (leakp) {
 127     SET_LEAKP(module_entry);
 128   } else {
 129     SET_TRANSIENT(module_entry);
 130   }
 131   return artifact_id(module_entry);
 132 }
 133 
 134 static traceid method_id(KlassPtr klass, MethodPtr method) {
 135   assert(klass != NULL, &quot;invariant&quot;);
 136   assert(method != NULL, &quot;invariant&quot;);
 137   return METHOD_ID(klass, method);
 138 }
 139 
 140 static traceid cld_id(CldPtr cld, bool leakp) {
 141   assert(cld != NULL, &quot;invariant&quot;);
 142   if (leakp) {
 143     SET_LEAKP(cld);
 144   } else {
 145     SET_TRANSIENT(cld);
 146   }
 147   return artifact_id(cld);
 148 }
 149 
 150 template &lt;typename T&gt;
 151 static s4 get_flags(const T* ptr) {
 152   assert(ptr != NULL, &quot;invariant&quot;);
 153   return ptr-&gt;access_flags().get_flags();
 154 }
 155 
 156 static bool is_unsafe_anonymous(const Klass* klass) {
 157   assert(klass != NULL, &quot;invariant&quot;);
 158   assert(!klass-&gt;is_objArray_klass(), &quot;invariant&quot;);
 159   return klass-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(klass)-&gt;is_unsafe_anonymous();
 160 }
 161 
 162 static ClassLoaderData* get_cld(const Klass* klass) {
 163   assert(klass != NULL, &quot;invariant&quot;);
 164   if (klass-&gt;is_objArray_klass()) {
 165     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass();
 166   }
 167   if (klass-&gt;is_non_strong_hidden()) return NULL;
 168   return is_unsafe_anonymous(klass) ?
 169     InstanceKlass::cast(klass)-&gt;unsafe_anonymous_host()-&gt;class_loader_data() : klass-&gt;class_loader_data();
 170 }
 171 
 172 template &lt;typename T&gt;
 173 static void set_serialized(const T* ptr) {
 174   assert(ptr != NULL, &quot;invariant&quot;);
 175   SET_SERIALIZED(ptr);
 176   assert(IS_SERIALIZED(ptr), &quot;invariant&quot;);
 177   CLEAR_THIS_EPOCH_CLEARED_BIT(ptr);
 178 }
 179 
 180 /*
 181  * In C++03, functions used as template parameters must have external linkage;
 182  * this restriction was removed in C++11. Change back to &quot;static&quot; and
 183  * rename functions when C++11 becomes available.
 184  *
 185  * The weird naming is an effort to decrease the risk of name clashes.
 186  */
 187 
 188 static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {
 189   assert(writer != NULL, &quot;invariant&quot;);
 190   assert(_artifacts != NULL, &quot;invariant&quot;);
 191   assert(klass != NULL, &quot;invariant&quot;);
 192   writer-&gt;write(artifact_id(klass));
 193   ClassLoaderData* cld = get_cld(klass);
 194   writer-&gt;write(cld != NULL ? cld_id(cld, leakp) : 0);
 195   writer-&gt;write(mark_symbol(klass, leakp));
 196   writer-&gt;write(package_id(klass, leakp));
 197   writer-&gt;write(get_flags(klass));
 198   writer-&gt;write&lt;bool&gt;(klass-&gt;is_hidden());
 199   return 1;
 200 }
 201 
 202 int write__klass(JfrCheckpointWriter* writer, const void* k) {
 203   assert(k != NULL, &quot;invariant&quot;);
 204   KlassPtr klass = (KlassPtr)k;
 205   set_serialized(klass);
 206   return write_klass(writer, klass, false);
 207 }
 208 
 209 int write__klass__leakp(JfrCheckpointWriter* writer, const void* k) {
 210   assert(k != NULL, &quot;invariant&quot;);
 211   KlassPtr klass = (KlassPtr)k;
 212   return write_klass(writer, klass, true);
 213 }
 214 
 215 static bool is_implied(const Klass* klass) {
 216   assert(klass != NULL, &quot;invariant&quot;);
 217   return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass();
 218 }
 219 
 220 static void do_klass(Klass* klass) {
 221   assert(klass != NULL, &quot;invariant&quot;);
 222   assert(_flushpoint ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass), &quot;invariant&quot;);
 223   assert(_subsystem_callback != NULL, &quot;invariant&quot;);
 224   _subsystem_callback-&gt;do_artifact(klass);
 225 }
 226 
 227 static void do_loader_klass(const Klass* klass) {
 228   if (klass != NULL &amp;&amp; _artifacts-&gt;should_do_loader_klass(klass)) {
 229     if (_leakp_writer != NULL) {
 230       SET_LEAKP(klass);
 231     }
 232     SET_TRANSIENT(klass);
 233     _subsystem_callback-&gt;do_artifact(klass);
 234   }
 235 }
 236 
 237 static bool register_klass_unload(Klass* klass) {
 238   assert(klass != NULL, &quot;invariant&quot;);
 239   return JfrKlassUnloading::on_unload(klass);
 240 }
 241 
 242 static void on_klass_unload(Klass* klass) {
 243   register_klass_unload(klass);
 244 }
 245 
 246 static size_t register_unloading_klasses() {
 247   ClassLoaderDataGraph::classes_unloading_do(&amp;on_klass_unload);
 248   return 0;
 249 }
 250 
 251 static void do_unloading_klass(Klass* klass) {
 252   assert(klass != NULL, &quot;invariant&quot;);
 253   assert(_subsystem_callback != NULL, &quot;invariant&quot;);
 254   if (register_klass_unload(klass)) {
 255     _subsystem_callback-&gt;do_artifact(klass);
 256     do_loader_klass(klass-&gt;class_loader_data()-&gt;class_loader_klass());
 257   }
 258 }
 259 
 260 /*
 261  * Abstract klasses are filtered out unconditionally.
 262  * If a klass is not yet initialized, i.e yet to run its &lt;clinit&gt;
 263  * it is also filtered out so we don&#39;t accidentally
 264  * trigger initialization.
 265  */
 266 static bool is_classloader_klass_whitelisted(const Klass* k) {
 267   assert(k != NULL, &quot;invariant&quot;);
 268   return !(k-&gt;is_abstract() || k-&gt;should_be_initialized());
 269 }
 270 
 271 static void do_classloaders() {
 272   Stack&lt;const Klass*, mtTracing&gt; mark_stack;
 273   mark_stack.push(SystemDictionary::ClassLoader_klass()-&gt;subklass());
 274 
 275   while (!mark_stack.is_empty()) {
 276     const Klass* const current = mark_stack.pop();
 277     assert(current != NULL, &quot;null element in stack!&quot;);
 278     if (is_classloader_klass_whitelisted(current)) {
 279       do_loader_klass(current);
 280     }
 281 
 282     // subclass (depth)
 283     const Klass* next_klass = current-&gt;subklass();
 284     if (next_klass != NULL) {
 285       mark_stack.push(next_klass);
 286     }
 287 
 288     // siblings (breadth)
 289     next_klass = current-&gt;next_sibling();
 290     if (next_klass != NULL) {
 291       mark_stack.push(next_klass);
 292     }
 293   }
 294   assert(mark_stack.is_empty(), &quot;invariant&quot;);
 295 }
 296 
 297 static void do_object() {
 298   SET_TRANSIENT(SystemDictionary::Object_klass());
 299   do_klass(SystemDictionary::Object_klass());
 300 }
 301 
 302 static void do_klasses() {
 303   if (_class_unload) {
 304     ClassLoaderDataGraph::classes_unloading_do(&amp;do_unloading_klass);
 305     return;
 306   }
 307   JfrTraceIdLoadBarrier::do_klasses(&amp;do_klass, previous_epoch());
 308   do_classloaders();
 309   do_object();
 310 }
 311 
 312 typedef SerializePredicate&lt;KlassPtr&gt; KlassPredicate;
 313 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, KlassPredicate, write__klass&gt; KlassWriterImpl;
 314 typedef JfrTypeWriterHost&lt;KlassWriterImpl, TYPE_CLASS&gt; KlassWriter;
 315 typedef CompositeFunctor&lt;KlassPtr, KlassWriter, KlassArtifactRegistrator&gt; KlassWriterRegistration;
 316 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassWriterRegistration&gt; KlassCallback;
 317 
 318 template &lt;&gt;
 319 class LeakPredicate&lt;const Klass*&gt; {
 320 public:
 321   LeakPredicate(bool class_unload) {}
 322   bool operator()(const Klass* klass) {
 323     assert(klass != NULL, &quot;invariant&quot;);
 324     return IS_LEAKP(klass) || is_implied(klass);
 325   }
 326 };
 327 
 328 typedef LeakPredicate&lt;KlassPtr&gt; LeakKlassPredicate;
 329 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, LeakKlassPredicate, write__klass__leakp&gt; LeakKlassWriterImpl;
 330 typedef JfrTypeWriterHost&lt;LeakKlassWriterImpl, TYPE_CLASS&gt; LeakKlassWriter;
 331 
 332 typedef CompositeFunctor&lt;KlassPtr, LeakKlassWriter, KlassWriter&gt; CompositeKlassWriter;
 333 typedef CompositeFunctor&lt;KlassPtr, CompositeKlassWriter, KlassArtifactRegistrator&gt; CompositeKlassWriterRegistration;
 334 typedef JfrArtifactCallbackHost&lt;KlassPtr, CompositeKlassWriterRegistration&gt; CompositeKlassCallback;
 335 
 336 static bool write_klasses() {
 337   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
 338   assert(_writer != NULL, &quot;invariant&quot;);
 339   KlassArtifactRegistrator reg(_artifacts);
 340   KlassWriter kw(_writer, _class_unload);
 341   KlassWriterRegistration kwr(&amp;kw, &amp;reg);
 342   if (_leakp_writer == NULL) {
 343     KlassCallback callback(&amp;kwr);
 344     _subsystem_callback = &amp;callback;
 345     do_klasses();
 346   } else {
 347     LeakKlassWriter lkw(_leakp_writer, _class_unload);
 348     CompositeKlassWriter ckw(&amp;lkw, &amp;kw);
 349     CompositeKlassWriterRegistration ckwr(&amp;ckw, &amp;reg);
 350     CompositeKlassCallback callback(&amp;ckwr);
 351     _subsystem_callback = &amp;callback;
 352     do_klasses();
 353   }
 354   if (is_complete()) {
 355     return false;
 356   }
 357   _artifacts-&gt;tally(kw);
 358   return true;
 359 }
 360 
 361 template &lt;typename T&gt;
 362 static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {
 363   assert(callback != NULL, &quot;invariant&quot;);
 364   assert(value != NULL, &quot;invariant&quot;);
 365   if (USED_PREVIOUS_EPOCH(value)) {
 366     callback-&gt;do_artifact(value);
 367     assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);
 368     return;
 369   }
 370   if (IS_SERIALIZED(value)) {
 371     CLEAR_SERIALIZED(value);
 372   }
 373   assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);
 374 }
 375 
 376 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassArtifactRegistrator&gt; RegisterKlassCallback;
 377 
 378 static void register_klass(Klass* klass) {
 379   assert(klass != NULL, &quot;invariant&quot;);
 380   assert(_subsystem_callback != NULL, &quot;invariant&quot;);
 381   do_previous_epoch_artifact(_subsystem_callback, klass);
 382 }
 383 
 384 static void register_klasses() {
 385   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
 386   KlassArtifactRegistrator reg(_artifacts);
 387   RegisterKlassCallback callback(&amp;reg);
 388   _subsystem_callback = &amp;callback;
 389   ClassLoaderDataGraph::classes_do(&amp;register_klass);
 390 }
 391 
 392 static int write_package(JfrCheckpointWriter* writer, PkgPtr pkg, bool leakp) {
 393   assert(writer != NULL, &quot;invariant&quot;);
 394   assert(_artifacts != NULL, &quot;invariant&quot;);
 395   assert(pkg != NULL, &quot;invariant&quot;);
 396   writer-&gt;write(artifact_id(pkg));
 397   writer-&gt;write(mark_symbol(pkg-&gt;name(), leakp));
 398   writer-&gt;write(module_id(pkg, leakp));
 399   writer-&gt;write((bool)pkg-&gt;is_exported());
 400   return 1;
 401 }
 402 
 403 int write__package(JfrCheckpointWriter* writer, const void* p) {
 404   assert(p != NULL, &quot;invariant&quot;);
 405   PkgPtr pkg = (PkgPtr)p;
 406   set_serialized(pkg);
 407   return write_package(writer, pkg, false);
 408 }
 409 
 410 int write__package__leakp(JfrCheckpointWriter* writer, const void* p) {
 411   assert(p != NULL, &quot;invariant&quot;);
 412   PkgPtr pkg = (PkgPtr)p;
 413   CLEAR_LEAKP(pkg);
 414   return write_package(writer, pkg, true);
 415 }
 416 
 417 static void do_package(PackageEntry* entry) {
 418   do_previous_epoch_artifact(_subsystem_callback, entry);
 419 }
 420 
 421 static void do_packages() {
 422   ClassLoaderDataGraph::packages_do(&amp;do_package);
 423 }
 424 
 425 class PackageFieldSelector {
 426  public:
 427   typedef PkgPtr TypePtr;
 428   static TypePtr select(KlassPtr klass) {
 429     assert(klass != NULL, &quot;invariant&quot;);
 430     return klass-&gt;package();
 431   }
 432 };
 433 
 434 typedef SerializePredicate&lt;PkgPtr&gt; PackagePredicate;
 435 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, PackagePredicate, write__package&gt; PackageWriterImpl;
 436 typedef JfrTypeWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;
 437 typedef CompositeFunctor&lt;PkgPtr, PackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;
 438 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriter&gt; KlassPackageWriter;
 439 typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;
 440 
 441 typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;
 442 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__package__leakp&gt; LeakPackageWriterImpl;
 443 typedef JfrTypeWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;
 444 
 445 typedef CompositeFunctor&lt;PkgPtr, LeakPackageWriter, PackageWriter&gt; CompositePackageWriter;
 446 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, CompositePackageWriter&gt; KlassCompositePackageWriter;
 447 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriterWithClear&gt; KlassPackageWriterWithClear;
 448 typedef CompositeFunctor&lt;PkgPtr, CompositePackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;
 449 typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
 450 
 451 static void write_packages() {
 452   assert(_writer != NULL, &quot;invariant&quot;);
 453   PackageWriter pw(_writer, _class_unload);
 454   KlassPackageWriter kpw(&amp;pw);
 455   if (current_epoch()) {
 456     _artifacts-&gt;iterate_klasses(kpw);
 457     _artifacts-&gt;tally(pw);
 458     return;
 459   }
 460   assert(previous_epoch(), &quot;invariant&quot;);
 461   if (_leakp_writer == NULL) {
 462     _artifacts-&gt;iterate_klasses(kpw);
 463     ClearArtifact&lt;PkgPtr&gt; clear;
 464     PackageWriterWithClear pwwc(&amp;pw, &amp;clear);
 465     PackageCallback callback(&amp;pwwc);
 466     _subsystem_callback = &amp;callback;
 467     do_packages();
 468   } else {
 469     LeakPackageWriter lpw(_leakp_writer, _class_unload);
 470     CompositePackageWriter cpw(&amp;lpw, &amp;pw);
 471     KlassCompositePackageWriter kcpw(&amp;cpw);
 472     _artifacts-&gt;iterate_klasses(kcpw);
 473     ClearArtifact&lt;PkgPtr&gt; clear;
 474     CompositePackageWriterWithClear cpwwc(&amp;cpw, &amp;clear);
 475     CompositePackageCallback callback(&amp;cpwwc);
 476     _subsystem_callback = &amp;callback;
 477     do_packages();
 478   }
 479   _artifacts-&gt;tally(pw);
 480 }
 481 
 482 typedef JfrArtifactCallbackHost&lt;PkgPtr, ClearArtifact&lt;PkgPtr&gt; &gt; ClearPackageCallback;
 483 
 484 static void clear_packages() {
 485   ClearArtifact&lt;PkgPtr&gt; clear;
 486   ClearPackageCallback callback(&amp;clear);
 487   _subsystem_callback = &amp;callback;
 488   do_packages();
 489 }
 490 
 491 static int write_module(JfrCheckpointWriter* writer, ModPtr mod, bool leakp) {
 492   assert(mod != NULL, &quot;invariant&quot;);
 493   assert(_artifacts != NULL, &quot;invariant&quot;);
 494   writer-&gt;write(artifact_id(mod));
 495   writer-&gt;write(mark_symbol(mod-&gt;name(), leakp));
 496   writer-&gt;write(mark_symbol(mod-&gt;version(), leakp));
 497   writer-&gt;write(mark_symbol(mod-&gt;location(), leakp));
 498   writer-&gt;write(cld_id(mod-&gt;loader_data(), leakp));
 499   return 1;
 500 }
 501 
 502 int write__module(JfrCheckpointWriter* writer, const void* m) {
 503   assert(m != NULL, &quot;invariant&quot;);
 504   ModPtr mod = (ModPtr)m;
 505   set_serialized(mod);
 506   return write_module(writer, mod, false);
 507 }
 508 
 509 int write__module__leakp(JfrCheckpointWriter* writer, const void* m) {
 510   assert(m != NULL, &quot;invariant&quot;);
 511   ModPtr mod = (ModPtr)m;
 512   CLEAR_LEAKP(mod);
 513   return write_module(writer, mod, true);
 514 }
 515 
 516 static void do_module(ModuleEntry* entry) {
 517   do_previous_epoch_artifact(_subsystem_callback, entry);
 518 }
 519 
 520 static void do_modules() {
 521   ClassLoaderDataGraph::modules_do(&amp;do_module);
 522 }
 523 
 524 class ModuleFieldSelector {
 525  public:
 526   typedef ModPtr TypePtr;
 527   static TypePtr select(KlassPtr klass) {
 528     assert(klass != NULL, &quot;invariant&quot;);
 529     PkgPtr pkg = klass-&gt;package();
 530     return pkg != NULL ? pkg-&gt;module() : NULL;
 531   }
 532 };
 533 
 534 typedef SerializePredicate&lt;ModPtr&gt; ModulePredicate;
 535 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, ModulePredicate, write__module&gt; ModuleWriterImpl;
 536 typedef JfrTypeWriterHost&lt;ModuleWriterImpl, TYPE_MODULE&gt; ModuleWriter;
 537 typedef CompositeFunctor&lt;ModPtr, ModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; ModuleWriterWithClear;
 538 typedef JfrArtifactCallbackHost&lt;ModPtr, ModuleWriterWithClear&gt; ModuleCallback;
 539 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, ModuleWriter&gt; KlassModuleWriter;
 540 
 541 typedef LeakPredicate&lt;ModPtr&gt; LeakModulePredicate;
 542 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, LeakModulePredicate, write__module__leakp&gt; LeakModuleWriterImpl;
 543 typedef JfrTypeWriterHost&lt;LeakModuleWriterImpl, TYPE_MODULE&gt; LeakModuleWriter;
 544 
 545 typedef CompositeFunctor&lt;ModPtr, LeakModuleWriter, ModuleWriter&gt; CompositeModuleWriter;
 546 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, CompositeModuleWriter&gt; KlassCompositeModuleWriter;
 547 typedef CompositeFunctor&lt;ModPtr, CompositeModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; CompositeModuleWriterWithClear;
 548 typedef JfrArtifactCallbackHost&lt;ModPtr, CompositeModuleWriterWithClear&gt; CompositeModuleCallback;
 549 
 550 static void write_modules() {
 551   assert(_writer != NULL, &quot;invariant&quot;);
 552   ModuleWriter mw(_writer, _class_unload);
 553   KlassModuleWriter kmw(&amp;mw);
 554   if (current_epoch()) {
 555     _artifacts-&gt;iterate_klasses(kmw);
 556     _artifacts-&gt;tally(mw);
 557     return;
 558   }
 559   assert(previous_epoch(), &quot;invariant&quot;);
 560   if (_leakp_writer == NULL) {
 561     _artifacts-&gt;iterate_klasses(kmw);
 562     ClearArtifact&lt;ModPtr&gt; clear;
 563     ModuleWriterWithClear mwwc(&amp;mw, &amp;clear);
 564     ModuleCallback callback(&amp;mwwc);
 565     _subsystem_callback = &amp;callback;
 566     do_modules();
 567   } else {
 568     LeakModuleWriter lmw(_leakp_writer, _class_unload);
 569     CompositeModuleWriter cmw(&amp;lmw, &amp;mw);
 570     KlassCompositeModuleWriter kcpw(&amp;cmw);
 571     _artifacts-&gt;iterate_klasses(kcpw);
 572     ClearArtifact&lt;ModPtr&gt; clear;
 573     CompositeModuleWriterWithClear cmwwc(&amp;cmw, &amp;clear);
 574     CompositeModuleCallback callback(&amp;cmwwc);
 575     _subsystem_callback = &amp;callback;
 576     do_modules();
 577   }
 578   _artifacts-&gt;tally(mw);
 579 }
 580 
 581 typedef JfrArtifactCallbackHost&lt;ModPtr, ClearArtifact&lt;ModPtr&gt; &gt; ClearModuleCallback;
 582 
 583 static void clear_modules() {
 584   ClearArtifact&lt;ModPtr&gt; clear;
 585   ClearModuleCallback callback(&amp;clear);
 586   _subsystem_callback = &amp;callback;
 587   do_modules();
 588 }
 589 
 590 static int write_classloader(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {
 591   assert(cld != NULL, &quot;invariant&quot;);
 592   // class loader type
 593   const Klass* class_loader_klass = cld-&gt;class_loader_klass();
 594   if (class_loader_klass == NULL) {
 595     // (primordial) boot class loader
 596     writer-&gt;write(artifact_id(cld)); // class loader instance id
 597     writer-&gt;write((traceid)0);  // class loader type id (absence of)
 598     writer-&gt;write(get_bootstrap_name(leakp)); // maps to synthetic name -&gt; &quot;bootstrap&quot;
 599   } else {
 600     assert(_class_unload ? true : IS_SERIALIZED(class_loader_klass), &quot;invariant&quot;);
 601     writer-&gt;write(artifact_id(cld)); // class loader instance id
 602     writer-&gt;write(artifact_id(class_loader_klass)); // class loader type id
 603     writer-&gt;write(mark_symbol(cld-&gt;name(), leakp)); // class loader instance name
 604   }
 605   return 1;
 606 }
 607 
 608 int write__classloader(JfrCheckpointWriter* writer, const void* c) {
 609   assert(c != NULL, &quot;invariant&quot;);
 610   CldPtr cld = (CldPtr)c;
 611   set_serialized(cld);
 612   return write_classloader(writer, cld, false);
 613 }
 614 
 615 int write__classloader__leakp(JfrCheckpointWriter* writer, const void* c) {
 616   assert(c != NULL, &quot;invariant&quot;);
 617   CldPtr cld = (CldPtr)c;
 618   CLEAR_LEAKP(cld);
 619   return write_classloader(writer, cld, true);
 620 }
 621 
 622 static void do_class_loader_data(ClassLoaderData* cld) {
 623   do_previous_epoch_artifact(_subsystem_callback, cld);
 624 }
 625 
 626 class KlassCldFieldSelector {
 627  public:
 628   typedef CldPtr TypePtr;
 629   static TypePtr select(KlassPtr klass) {
 630     assert(klass != NULL, &quot;invariant&quot;);
 631     return get_cld(klass);
 632   }
 633 };
 634 
 635 class ModuleCldFieldSelector {
 636 public:
 637   typedef CldPtr TypePtr;
 638   static TypePtr select(KlassPtr klass) {
 639     assert(klass != NULL, &quot;invariant&quot;);
 640     ModPtr mod = ModuleFieldSelector::select(klass);
 641     return mod != NULL ? mod-&gt;loader_data() : NULL;
 642   }
 643 };
 644 
 645 class CLDCallback : public CLDClosure {
 646  public:
 647   CLDCallback() {}
 648   void do_cld(ClassLoaderData* cld) {
 649     assert(cld != NULL, &quot;invariant&quot;);
 650     if (cld-&gt;has_class_mirror_holder()) {
 651       return;
 652     }
 653     do_class_loader_data(cld);
 654   }
 655 };
 656 
 657 static void do_class_loaders() {
 658   CLDCallback cld_cb;
 659   ClassLoaderDataGraph::loaded_cld_do(&amp;cld_cb);
 660 }
 661 
 662 typedef SerializePredicate&lt;CldPtr&gt; CldPredicate;
 663 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, CldPredicate, write__classloader&gt; CldWriterImpl;
 664 typedef JfrTypeWriterHost&lt;CldWriterImpl, TYPE_CLASSLOADER&gt; CldWriter;
 665 typedef CompositeFunctor&lt;CldPtr, CldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CldWriterWithClear;
 666 typedef JfrArtifactCallbackHost&lt;CldPtr, CldWriterWithClear&gt; CldCallback;
 667 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CldWriter&gt; KlassCldWriter;
 668 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CldWriter&gt; ModuleCldWriter;
 669 typedef CompositeFunctor&lt;KlassPtr, KlassCldWriter, ModuleCldWriter&gt; KlassAndModuleCldWriter;
 670 
 671 typedef LeakPredicate&lt;CldPtr&gt; LeakCldPredicate;
 672 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, LeakCldPredicate, write__classloader__leakp&gt; LeakCldWriterImpl;
 673 typedef JfrTypeWriterHost&lt;LeakCldWriterImpl, TYPE_CLASSLOADER&gt; LeakCldWriter;
 674 
 675 typedef CompositeFunctor&lt;CldPtr, LeakCldWriter, CldWriter&gt; CompositeCldWriter;
 676 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CompositeCldWriter&gt; KlassCompositeCldWriter;
 677 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CompositeCldWriter&gt; ModuleCompositeCldWriter;
 678 typedef CompositeFunctor&lt;KlassPtr, KlassCompositeCldWriter, ModuleCompositeCldWriter&gt; KlassAndModuleCompositeCldWriter;
 679 typedef CompositeFunctor&lt;CldPtr, CompositeCldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CompositeCldWriterWithClear;
 680 typedef JfrArtifactCallbackHost&lt;CldPtr, CompositeCldWriterWithClear&gt; CompositeCldCallback;
 681 
 682 static void write_classloaders() {
 683   assert(_writer != NULL, &quot;invariant&quot;);
 684   CldWriter cldw(_writer, _class_unload);
 685   KlassCldWriter kcw(&amp;cldw);
 686   ModuleCldWriter mcw(&amp;cldw);
 687   KlassAndModuleCldWriter kmcw(&amp;kcw, &amp;mcw);
 688   if (current_epoch()) {
 689     _artifacts-&gt;iterate_klasses(kmcw);
 690     _artifacts-&gt;tally(cldw);
 691     return;
 692   }
 693   assert(previous_epoch(), &quot;invariant&quot;);
 694   if (_leakp_writer == NULL) {
 695     _artifacts-&gt;iterate_klasses(kmcw);
 696     ClearArtifact&lt;CldPtr&gt; clear;
 697     CldWriterWithClear cldwwc(&amp;cldw, &amp;clear);
 698     CldCallback callback(&amp;cldwwc);
 699     _subsystem_callback = &amp;callback;
 700     do_class_loaders();
 701   } else {
 702     LeakCldWriter lcldw(_leakp_writer, _class_unload);
 703     CompositeCldWriter ccldw(&amp;lcldw, &amp;cldw);
 704     KlassCompositeCldWriter kccldw(&amp;ccldw);
 705     ModuleCompositeCldWriter mccldw(&amp;ccldw);
 706     KlassAndModuleCompositeCldWriter kmccldw(&amp;kccldw, &amp;mccldw);
 707     _artifacts-&gt;iterate_klasses(kmccldw);
 708     ClearArtifact&lt;CldPtr&gt; clear;
 709     CompositeCldWriterWithClear ccldwwc(&amp;ccldw, &amp;clear);
 710     CompositeCldCallback callback(&amp;ccldwwc);
 711     _subsystem_callback = &amp;callback;
 712     do_class_loaders();
 713   }
 714   _artifacts-&gt;tally(cldw);
 715 }
 716 
 717 typedef JfrArtifactCallbackHost&lt;CldPtr, ClearArtifact&lt;CldPtr&gt; &gt; ClearCLDCallback;
 718 
 719 static void clear_classloaders() {
 720   ClearArtifact&lt;CldPtr&gt; clear;
 721   ClearCLDCallback callback(&amp;clear);
 722   _subsystem_callback = &amp;callback;
 723   do_class_loaders();
 724 }
 725 
 726 static u1 get_visibility(MethodPtr method) {
 727   assert(method != NULL, &quot;invariant&quot;);
 728   return const_cast&lt;Method*&gt;(method)-&gt;is_hidden() ? (u1)1 : (u1)0;
 729 }
 730 
 731 template &lt;&gt;
 732 void set_serialized&lt;Method&gt;(MethodPtr method) {
 733   assert(method != NULL, &quot;invariant&quot;);
 734   SET_METHOD_SERIALIZED(method);
 735   assert(IS_METHOD_SERIALIZED(method), &quot;invariant&quot;);
 736   CLEAR_THIS_EPOCH_METHOD_CLEARED_BIT(method);
 737 }
 738 
 739 static int write_method(JfrCheckpointWriter* writer, MethodPtr method, bool leakp) {
 740   assert(writer != NULL, &quot;invariant&quot;);
 741   assert(method != NULL, &quot;invariant&quot;);
 742   assert(_artifacts != NULL, &quot;invariant&quot;);
 743   KlassPtr klass = method-&gt;method_holder();
 744   assert(klass != NULL, &quot;invariant&quot;);
 745   writer-&gt;write(method_id(klass, method));
 746   writer-&gt;write(artifact_id(klass));
 747   writer-&gt;write(mark_symbol(method-&gt;name(), leakp));
 748   writer-&gt;write(mark_symbol(method-&gt;signature(), leakp));
 749   writer-&gt;write((u2)get_flags(method));
 750   writer-&gt;write(get_visibility(method));
 751   return 1;
 752 }
 753 
 754 int write__method(JfrCheckpointWriter* writer, const void* m) {
 755   assert(m != NULL, &quot;invariant&quot;);
 756   MethodPtr method = (MethodPtr)m;
 757   set_serialized(method);
 758   return write_method(writer, method, false);
 759 }
 760 
 761 int write__method__leakp(JfrCheckpointWriter* writer, const void* m) {
 762   assert(m != NULL, &quot;invariant&quot;);
 763   MethodPtr method = (MethodPtr)m;
 764   return write_method(writer, method, true);
 765 }
 766 
 767 class BitMapFilter {
 768   ResourceBitMap _bitmap;
 769  public:
 770   explicit BitMapFilter(int length = 0) : _bitmap((size_t)length) {}
 771   bool operator()(size_t idx) {
 772     if (_bitmap.size() == 0) {
 773       return true;
 774     }
 775     if (_bitmap.at(idx)) {
 776       return false;
 777     }
 778     _bitmap.set_bit(idx);
 779     return true;
 780   }
 781 };
 782 
 783 class AlwaysTrue {
 784  public:
 785   explicit AlwaysTrue(int length = 0) {}
 786   bool operator()(size_t idx) {
 787     return true;
 788   }
 789 };
 790 
 791 template &lt;typename MethodCallback, typename KlassCallback, class Filter, bool leakp&gt;
 792 class MethodIteratorHost {
 793  private:
 794   MethodCallback _method_cb;
 795   KlassCallback _klass_cb;
 796   MethodUsedPredicate&lt;leakp&gt; _method_used_predicate;
 797   MethodFlagPredicate&lt;leakp&gt; _method_flag_predicate;
 798  public:
 799   MethodIteratorHost(JfrCheckpointWriter* writer,
 800                      bool current_epoch = false,
 801                      bool class_unload = false,
 802                      bool skip_header = false) :
 803     _method_cb(writer, class_unload, skip_header),
 804     _klass_cb(writer, class_unload, skip_header),
 805     _method_used_predicate(current_epoch),
 806     _method_flag_predicate(current_epoch) {}
 807 
 808   bool operator()(KlassPtr klass) {
 809     if (_method_used_predicate(klass)) {
 810       const InstanceKlass* ik = InstanceKlass::cast(klass);
 811       const int len = ik-&gt;methods()-&gt;length();
 812       Filter filter(ik-&gt;previous_versions() != NULL ? len : 0);
 813       while (ik != NULL) {
 814         for (int i = 0; i &lt; len; ++i) {
 815           MethodPtr method = ik-&gt;methods()-&gt;at(i);
 816           if (_method_flag_predicate(method) &amp;&amp; filter(i)) {
 817             _method_cb(method);
 818           }
 819         }
 820         // There can be multiple versions of the same method running
 821         // due to redefinition. Need to inspect the complete set of methods.
 822         ik = ik-&gt;previous_versions();
 823       }
 824     }
 825     return _klass_cb(klass);
 826   }
 827 
 828   int count() const { return _method_cb.count(); }
 829   void add(int count) { _method_cb.add(count); }
 830 };
 831 
 832 template &lt;typename T, template &lt;typename&gt; class Impl&gt;
 833 class Wrapper {
 834   Impl&lt;T&gt; _t;
 835  public:
 836   Wrapper(JfrCheckpointWriter*, bool, bool) : _t() {}
 837   bool operator()(T const&amp; value) {
 838     return _t(value);
 839   }
 840 };
 841 
 842 template &lt;typename T&gt;
 843 class EmptyStub {
 844  public:
 845   bool operator()(T const&amp; value) { return true; }
 846 };
 847 
 848 typedef SerializePredicate&lt;MethodPtr&gt; MethodPredicate;
 849 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, MethodPredicate, write__method&gt; MethodWriterImplTarget;
 850 typedef Wrapper&lt;KlassPtr, EmptyStub&gt; KlassCallbackStub;
 851 typedef JfrTypeWriterHost&lt;MethodWriterImplTarget, TYPE_METHOD&gt; MethodWriterImpl;
 852 typedef MethodIteratorHost&lt;MethodWriterImpl, KlassCallbackStub, BitMapFilter, false&gt; MethodWriter;
 853 
 854 typedef LeakPredicate&lt;MethodPtr&gt; LeakMethodPredicate;
 855 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, LeakMethodPredicate, write__method__leakp&gt; LeakMethodWriterImplTarget;
 856 typedef JfrTypeWriterHost&lt;LeakMethodWriterImplTarget, TYPE_METHOD&gt; LeakMethodWriterImpl;
 857 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;
 858 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;
 859 typedef CompositeFunctor&lt;KlassPtr, LeakMethodWriter, MethodWriter&gt; CompositeMethodWriter;
 860 
 861 static void write_methods() {
 862   assert(_writer != NULL, &quot;invariant&quot;);
 863   MethodWriter mw(_writer, current_epoch(), _class_unload);
 864   if (_leakp_writer == NULL) {
 865     _artifacts-&gt;iterate_klasses(mw);
 866   } else {
 867     LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);
 868     CompositeMethodWriter cmw(&amp;lpmw, &amp;mw);
 869     _artifacts-&gt;iterate_klasses(cmw);
 870   }
 871   _artifacts-&gt;tally(mw);
 872 }
 873 
 874 template &lt;&gt;
 875 void set_serialized&lt;JfrSymbolId::SymbolEntry&gt;(SymbolEntryPtr ptr) {
 876   assert(ptr != NULL, &quot;invariant&quot;);
 877   ptr-&gt;set_serialized();
 878   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);
 879 }
 880 
 881 template &lt;&gt;
 882 void set_serialized&lt;JfrSymbolId::CStringEntry&gt;(CStringEntryPtr ptr) {
 883   assert(ptr != NULL, &quot;invariant&quot;);
 884   ptr-&gt;set_serialized();
 885   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);
 886 }
 887 
 888 static int write_symbol(JfrCheckpointWriter* writer, SymbolEntryPtr entry, bool leakp) {
 889   assert(writer != NULL, &quot;invariant&quot;);
 890   assert(entry != NULL, &quot;invariant&quot;);
 891   ResourceMark rm;
 892   writer-&gt;write(create_symbol_id(entry-&gt;id()));
 893   writer-&gt;write(entry-&gt;value()-&gt;as_C_string());
 894   return 1;
 895 }
 896 
 897 int write__symbol(JfrCheckpointWriter* writer, const void* e) {
 898   assert(e != NULL, &quot;invariant&quot;);
 899   SymbolEntryPtr entry = (SymbolEntryPtr)e;
 900   set_serialized(entry);
 901   return write_symbol(writer, entry, false);
 902 }
 903 
 904 int write__symbol__leakp(JfrCheckpointWriter* writer, const void* e) {
 905   assert(e != NULL, &quot;invariant&quot;);
 906   SymbolEntryPtr entry = (SymbolEntryPtr)e;
 907   return write_symbol(writer, entry, true);
 908 }
 909 
 910 static int write_cstring(JfrCheckpointWriter* writer, CStringEntryPtr entry, bool leakp) {
 911   assert(writer != NULL, &quot;invariant&quot;);
 912   assert(entry != NULL, &quot;invariant&quot;);
 913   writer-&gt;write(create_symbol_id(entry-&gt;id()));
 914   writer-&gt;write(entry-&gt;value());
 915   return 1;
 916 }
 917 
 918 int write__cstring(JfrCheckpointWriter* writer, const void* e) {
 919   assert(e != NULL, &quot;invariant&quot;);
 920   CStringEntryPtr entry = (CStringEntryPtr)e;
 921   set_serialized(entry);
 922   return write_cstring(writer, entry, false);
 923 }
 924 
 925 int write__cstring__leakp(JfrCheckpointWriter* writer, const void* e) {
 926   assert(e != NULL, &quot;invariant&quot;);
 927   CStringEntryPtr entry = (CStringEntryPtr)e;
 928   return write_cstring(writer, entry, true);
 929 }
 930 
 931 typedef SymbolPredicate&lt;SymbolEntryPtr, false&gt; SymPredicate;
 932 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, SymPredicate, write__symbol&gt; SymbolEntryWriterImpl;
 933 typedef JfrTypeWriterHost&lt;SymbolEntryWriterImpl, TYPE_SYMBOL&gt; SymbolEntryWriter;
 934 typedef SymbolPredicate&lt;CStringEntryPtr, false&gt; CStringPredicate;
 935 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, CStringPredicate, write__cstring&gt; CStringEntryWriterImpl;
 936 typedef JfrTypeWriterHost&lt;CStringEntryWriterImpl, TYPE_SYMBOL&gt; CStringEntryWriter;
 937 
 938 typedef SymbolPredicate&lt;SymbolEntryPtr, true&gt; LeakSymPredicate;
 939 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, LeakSymPredicate, write__symbol__leakp&gt; LeakSymbolEntryWriterImpl;
 940 typedef JfrTypeWriterHost&lt;LeakSymbolEntryWriterImpl, TYPE_SYMBOL&gt; LeakSymbolEntryWriter;
 941 typedef CompositeFunctor&lt;SymbolEntryPtr, LeakSymbolEntryWriter, SymbolEntryWriter&gt; CompositeSymbolWriter;
 942 typedef SymbolPredicate&lt;CStringEntryPtr, true&gt; LeakCStringPredicate;
 943 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, LeakCStringPredicate, write__cstring__leakp&gt; LeakCStringEntryWriterImpl;
 944 typedef JfrTypeWriterHost&lt;LeakCStringEntryWriterImpl, TYPE_SYMBOL&gt; LeakCStringEntryWriter;
 945 typedef CompositeFunctor&lt;CStringEntryPtr, LeakCStringEntryWriter, CStringEntryWriter&gt; CompositeCStringWriter;
 946 
 947 static void write_symbols_with_leakp() {
 948   assert(_leakp_writer != NULL, &quot;invariant&quot;);
 949   SymbolEntryWriter sw(_writer, _class_unload);
 950   LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);
 951   CompositeSymbolWriter csw(&amp;lsw, &amp;sw);
 952   _artifacts-&gt;iterate_symbols(csw);
 953   CStringEntryWriter ccsw(_writer, _class_unload, true); // skip header
 954   LeakCStringEntryWriter lccsw(_leakp_writer, _class_unload, true); // skip header
 955   CompositeCStringWriter cccsw(&amp;lccsw, &amp;ccsw);
 956   _artifacts-&gt;iterate_cstrings(cccsw);
 957   sw.add(ccsw.count());
 958   lsw.add(lccsw.count());
 959   _artifacts-&gt;tally(sw);
 960 }
 961 
 962 static void write_symbols() {
 963   assert(_writer != NULL, &quot;invariant&quot;);
 964   if (_leakp_writer != NULL) {
 965     write_symbols_with_leakp();
 966     return;
 967   }
 968   SymbolEntryWriter sw(_writer, _class_unload);
 969   _artifacts-&gt;iterate_symbols(sw);
 970   CStringEntryWriter csw(_writer, _class_unload, true); // skip header
 971   _artifacts-&gt;iterate_cstrings(csw);
 972   sw.add(csw.count());
 973   _artifacts-&gt;tally(sw);
 974 }
 975 
 976 typedef Wrapper&lt;KlassPtr, ClearArtifact&gt; ClearKlassBits;
 977 typedef Wrapper&lt;MethodPtr, ClearArtifact&gt; ClearMethodFlag;
 978 typedef MethodIteratorHost&lt;ClearMethodFlag, ClearKlassBits, AlwaysTrue, false&gt; ClearKlassAndMethods;
 979 
 980 static bool clear_artifacts = false;
 981 
 982 static void clear_klasses_and_methods() {
 983   ClearKlassAndMethods clear(_writer);
 984   _artifacts-&gt;iterate_klasses(clear);
 985 }
 986 
 987 static size_t teardown() {
 988   assert(_artifacts != NULL, &quot;invariant&quot;);
 989   const size_t total_count = _artifacts-&gt;total_count();
 990   if (previous_epoch()) {
 991     clear_klasses_and_methods();
 992     JfrKlassUnloading::clear();
 993     clear_artifacts = true;
 994     ++checkpoint_id;
 995   }
 996   return total_count;
 997 }
 998 
 999 static void setup(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {
1000   _writer = writer;
1001   _leakp_writer = leakp_writer;
1002   _class_unload = class_unload;
1003   _flushpoint = flushpoint;
1004   if (_artifacts == NULL) {
1005     _artifacts = new JfrArtifactSet(class_unload);
1006   } else {
1007     _artifacts-&gt;initialize(class_unload, clear_artifacts);
1008   }
1009   if (!_class_unload) {
1010     JfrKlassUnloading::sort(previous_epoch());
1011   }
1012   clear_artifacts = false;
1013   assert(_artifacts != NULL, &quot;invariant&quot;);
1014   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
1015 }
1016 
1017 /**
1018  * Write all &quot;tagged&quot; (in-use) constant artifacts and their dependencies.
1019  */
1020 size_t JfrTypeSet::serialize(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {
1021   assert(writer != NULL, &quot;invariant&quot;);
1022   ResourceMark rm;
1023   setup(writer, leakp_writer, class_unload, flushpoint);
1024   // write order is important because an individual write step
1025   // might tag an artifact to be written in a subsequent step
1026   if (!write_klasses()) {
1027     return 0;
1028   }
1029   write_packages();
1030   write_modules();
1031   write_classloaders();
1032   write_methods();
1033   write_symbols();
1034   return teardown();
1035 }
1036 
1037 /**
1038  * Clear all tags from the previous epoch.
1039  */
1040 void JfrTypeSet::clear() {
<a name="1" id="anc1"></a><span class="line-added">1041   ResourceMark rm;</span>
1042   JfrKlassUnloading::clear();
1043   clear_artifacts = true;
1044   setup(NULL, NULL, false, false);
1045   register_klasses();
1046   clear_packages();
1047   clear_modules();
1048   clear_classloaders();
1049   clear_klasses_and_methods();
1050 }
1051 
1052 size_t JfrTypeSet::on_unloading_classes(JfrCheckpointWriter* writer) {
1053   if (JfrRecorder::is_recording()) {
1054     return serialize(writer, NULL, true, false);
1055   }
1056   return register_unloading_klasses();
1057 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
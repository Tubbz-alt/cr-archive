<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../repository/jfrEmergencyDump.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrRecorderThreadLoop.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 29 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 30 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
 31 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 32 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
 33 #include &quot;jfr/recorder/checkpoint/jfrMetadataEvent.hpp&quot;
 34 #include &quot;jfr/recorder/repository/jfrChunkRotation.hpp&quot;
 35 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
 36 #include &quot;jfr/recorder/repository/jfrRepository.hpp&quot;
 37 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 38 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 39 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
 40 #include &quot;jfr/recorder/storage/jfrStorage.hpp&quot;
 41 #include &quot;jfr/recorder/storage/jfrStorageControl.hpp&quot;
 42 #include &quot;jfr/recorder/stringpool/jfrStringPool.hpp&quot;
 43 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 44 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 45 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
 46 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 47 #include &quot;logging/log.hpp&quot;
<span class="line-removed"> 48 #include &quot;memory/resourceArea.hpp&quot;</span>
 49 #include &quot;runtime/atomic.hpp&quot;
<span class="line-modified"> 50 #include &quot;runtime/handles.inline.hpp&quot;</span>
 51 #include &quot;runtime/mutexLocker.hpp&quot;
 52 #include &quot;runtime/os.hpp&quot;
 53 #include &quot;runtime/safepoint.hpp&quot;
 54 #include &quot;runtime/thread.inline.hpp&quot;
 55 #include &quot;runtime/vmOperations.hpp&quot;
 56 #include &quot;runtime/vmThread.hpp&quot;
 57 
 58 // incremented on each flushpoint
 59 static u8 flushpoint_id = 0;
 60 
































































 61 template &lt;typename Instance, size_t(Instance::*func)()&gt;
 62 class Content {
 63  private:
 64   Instance&amp; _instance;
 65   u4 _elements;
 66  public:
 67   Content(Instance&amp; instance) : _instance(instance), _elements(0) {}
 68   bool process() {
 69     _elements = (u4)(_instance.*func)();
 70     return true;
 71   }
 72   u4 elements() const { return _elements; }
 73 };
 74 
 75 template &lt;typename Content&gt;
 76 class WriteContent : public StackObj {
 77  protected:
 78   const JfrTicks _start_time;
 79   JfrTicks _end_time;
 80   JfrChunkWriter&amp; _cw;
</pre>
<hr />
<pre>
325   _chunkwriter(JfrRepository::chunkwriter()),
326   _repository(JfrRepository::instance()),
327   _stack_trace_repository(JfrStackTraceRepository::instance()),
328   _storage(JfrStorage::instance()),
329   _string_pool(JfrStringPool::instance()) {}
330 
331 enum RecorderState {
332   STOPPED,
333   RUNNING
334 };
335 
336 static RecorderState recorder_state = STOPPED;
337 
338 static void set_recorder_state(RecorderState from, RecorderState to) {
339   assert(from == recorder_state, &quot;invariant&quot;);
340   OrderAccess::storestore();
341   recorder_state = to;
342 }
343 
344 static void start_recorder() {

345   set_recorder_state(STOPPED, RUNNING);
346   log_debug(jfr, system)(&quot;Recording service STARTED&quot;);
347 }
348 
349 static void stop_recorder() {

350   set_recorder_state(RUNNING, STOPPED);
351   log_debug(jfr, system)(&quot;Recording service STOPPED&quot;);
352 }
353 
354 bool JfrRecorderService::is_recording() {
355   const bool is_running = recorder_state == RUNNING;
356   OrderAccess::loadload();
357   return is_running;
358 }
359 
360 void JfrRecorderService::start() {
<span class="line-modified">361   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
362   assert(!is_recording(), &quot;invariant&quot;);
363   clear();
364   open_new_chunk();
365   start_recorder();
366   assert(is_recording(), &quot;invariant&quot;);
367 }
368 
369 static void stop() {
370   assert(JfrRecorderService::is_recording(), &quot;invariant&quot;);
371   stop_recorder();
372   assert(!JfrRecorderService::is_recording(), &quot;invariant&quot;);
373 }
374 
375 void JfrRecorderService::clear() {
<span class="line-modified">376   ResourceMark rm;</span>
<span class="line-removed">377   HandleMark hm;</span>
378   pre_safepoint_clear();
379   invoke_safepoint_clear();
380   post_safepoint_clear();
381 }
382 
383 void JfrRecorderService::pre_safepoint_clear() {
384   _string_pool.clear();
385   _storage.clear();
386   _stack_trace_repository.clear();
387 }
388 
389 void JfrRecorderService::invoke_safepoint_clear() {
390   JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_clear&gt; safepoint_task(*this);

391   VMThread::execute(&amp;safepoint_task);
392 }
393 
394 void JfrRecorderService::safepoint_clear() {
395   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
396   _checkpoint_manager.begin_epoch_shift();
397   _string_pool.clear();
398   _storage.clear();
399   _chunkwriter.set_time_stamp();
400   _stack_trace_repository.clear();
401   _checkpoint_manager.end_epoch_shift();
402 }
403 
404 void JfrRecorderService::post_safepoint_clear() {
405   _checkpoint_manager.clear();
406 }
407 
408 void JfrRecorderService::open_new_chunk(bool vm_error) {
<span class="line-modified">409   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
410   JfrChunkRotation::on_rotation();
411   const bool valid_chunk = _repository.open_chunk(vm_error);
412   _storage.control().set_to_disk(valid_chunk);
413   if (valid_chunk) {
414     _checkpoint_manager.write_static_type_set_and_threads();
415   }
416 }
417 
<span class="line-removed">418 // &#39;rotation_safepoint_pending&#39; is currently only relevant in the unusual case of an emergency dump.</span>
<span class="line-removed">419 // Since the JfrStream_lock must be acquired using _no_safepoint_check,</span>
<span class="line-removed">420 // if the thread running the emergency dump is a JavaThread, a pending safepoint, induced by rotation,</span>
<span class="line-removed">421 // would lead to a deadlock. This deadlock, although unpleasant, is not completely horrendous at this</span>
<span class="line-removed">422 // location because the WatcherThread will terminate the VM after a timeout.</span>
<span class="line-removed">423 // Deadlock avoidance is done not to affect the stability of general VM error reporting.</span>
<span class="line-removed">424 static bool rotation_safepoint_pending = false;</span>
<span class="line-removed">425 </span>
<span class="line-removed">426 static bool is_rotation_safepoint_pending() {</span>
<span class="line-removed">427   return Atomic::load_acquire(&amp;rotation_safepoint_pending);</span>
<span class="line-removed">428 }</span>
<span class="line-removed">429 </span>
<span class="line-removed">430 static void set_rotation_safepoint_pending(bool value) {</span>
<span class="line-removed">431   assert(value ? !is_rotation_safepoint_pending() : is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-removed">432   Atomic::release_store(&amp;rotation_safepoint_pending, value);</span>
<span class="line-removed">433 }</span>
<span class="line-removed">434 </span>
<span class="line-removed">435 static bool vm_error = false;</span>
<span class="line-removed">436 static const Thread* vm_error_thread = NULL;</span>
<span class="line-removed">437 </span>
<span class="line-removed">438 static bool prepare_for_vm_error_rotation() {</span>
<span class="line-removed">439   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">440   Thread* const t = Thread::current();</span>
<span class="line-removed">441   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">442   if (is_rotation_safepoint_pending() &amp;&amp; t-&gt;is_Java_thread()) {</span>
<span class="line-removed">443     // A safepoint is pending, avoid deadlock.</span>
<span class="line-removed">444     log_warning(jfr, system)(&quot;Unable to issue successful emergency dump&quot;);</span>
<span class="line-removed">445     return false;</span>
<span class="line-removed">446   }</span>
<span class="line-removed">447   vm_error_thread = t;</span>
<span class="line-removed">448   vm_error = true;</span>
<span class="line-removed">449   OrderAccess::fence();</span>
<span class="line-removed">450   return true;</span>
<span class="line-removed">451 }</span>
<span class="line-removed">452 </span>
453 void JfrRecorderService::vm_error_rotation() {
<span class="line-modified">454   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">455   assert(vm_error, &quot;invariant&quot;);</span>
<span class="line-removed">456   Thread* const t = Thread::current();</span>
<span class="line-removed">457   if (vm_error_thread != t) {</span>
<span class="line-removed">458     return;</span>
<span class="line-removed">459   }</span>
<span class="line-removed">460   assert(vm_error_thread == t, &quot;invariant&quot;);</span>
461   if (!_chunkwriter.is_valid()) {
462     open_new_chunk(true);
463   }
464   if (_chunkwriter.is_valid()) {
<span class="line-modified">465     _storage.flush_regular_buffer(t-&gt;jfr_thread_local()-&gt;native_buffer(), t);</span>

466     _chunkwriter.mark_chunk_final();
467     invoke_flush();
468     _chunkwriter.set_time_stamp();
469     _repository.close_chunk();
470     assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);
471     _repository.on_vm_error();
472   }
473 }
474 
475 void JfrRecorderService::rotate(int msgs) {
<span class="line-modified">476   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-modified">477   if (msgs &amp; MSGBIT(MSG_VM_ERROR)) {</span>
<span class="line-modified">478     // emergency dump</span>
<span class="line-removed">479     if (!prepare_for_vm_error_rotation()) {</span>
<span class="line-removed">480       return;</span>
<span class="line-removed">481     }</span>
482   }
<span class="line-modified">483   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">484   if (vm_error) {</span>
485     vm_error_rotation();
486     return;
487   }
488   if (_storage.control().to_disk()) {
489     chunk_rotation();
490   } else {
491     in_memory_rotation();
492   }
493   if (msgs &amp; (MSGBIT(MSG_STOP))) {
494     stop();
495   }
496 }
497 
498 void JfrRecorderService::in_memory_rotation() {
<span class="line-modified">499   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
500   // currently running an in-memory recording
501   assert(!_storage.control().to_disk(), &quot;invariant&quot;);
502   open_new_chunk();
503   if (_chunkwriter.is_valid()) {
504     // dump all in-memory buffer data to the newly created chunk
505     write_storage(_storage, _chunkwriter);
506   }
507 }
508 
509 void JfrRecorderService::chunk_rotation() {
<span class="line-modified">510   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
511   finalize_current_chunk();
512   open_new_chunk();
513 }
514 
515 void JfrRecorderService::finalize_current_chunk() {
516   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-removed">517   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-removed">518   set_rotation_safepoint_pending(true);</span>
519   write();
<span class="line-removed">520   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
521 }
522 
523 void JfrRecorderService::write() {
<span class="line-removed">524   ResourceMark rm;</span>
<span class="line-removed">525   HandleMark hm;</span>
526   pre_safepoint_write();
527   invoke_safepoint_write();
528   post_safepoint_write();
529 }
530 
531 void JfrRecorderService::pre_safepoint_write() {
532   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-removed">533   assert(is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
534   if (LeakProfiler::is_running()) {
535     // Exclusive access to the object sampler instance.
536     // The sampler is released (unlocked) later in post_safepoint_write.
537     ObjectSampleCheckpoint::on_rotation(ObjectSampler::acquire(), _stack_trace_repository);
538   }
539   if (_string_pool.is_modified()) {
540     write_stringpool(_string_pool, _chunkwriter);
541   }
542   write_storage(_storage, _chunkwriter);
543   if (_stack_trace_repository.is_modified()) {
544     write_stacktrace(_stack_trace_repository, _chunkwriter, false);
545   }
546 }
547 
548 void JfrRecorderService::invoke_safepoint_write() {
549   JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_write&gt; safepoint_task(*this);


550   VMThread::execute(&amp;safepoint_task);
551 }
552 
553 void JfrRecorderService::safepoint_write() {
554   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-removed">555   assert(is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-removed">556   set_rotation_safepoint_pending(false);</span>
557   _checkpoint_manager.begin_epoch_shift();
558   if (_string_pool.is_modified()) {
559     write_stringpool_safepoint(_string_pool, _chunkwriter);
560   }
561   _checkpoint_manager.on_rotation();
562   _storage.write_at_safepoint();
563   _chunkwriter.set_time_stamp();
564   write_stacktrace(_stack_trace_repository, _chunkwriter, true);
565   _checkpoint_manager.end_epoch_shift();
566 }
567 
568 void JfrRecorderService::post_safepoint_write() {
569   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-removed">570   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
571   // During the safepoint tasks just completed, the system transitioned to a new epoch.
572   // Type tagging is epoch relative which entails we are able to write out the
573   // already tagged artifacts for the previous epoch. We can accomplish this concurrently
574   // with threads now tagging artifacts in relation to the new, now updated, epoch and remain outside of a safepoint.
575   _checkpoint_manager.write_type_set();
576   if (LeakProfiler::is_running()) {
577     // The object sampler instance was exclusively acquired and locked in pre_safepoint_write.
578     // Note: There is a dependency on write_type_set() above, ensure the release is subsequent.
579     ObjectSampler::release();
580   }
581   // serialize the metadata descriptor event and close out the chunk
582   write_metadata(_chunkwriter);
583   _repository.close_chunk();
584 }
585 
586 static JfrBuffer* thread_local_buffer(Thread* t) {
587   assert(t != NULL, &quot;invariant&quot;);
588   return t-&gt;jfr_thread_local()-&gt;native_buffer();
589 }
590 
591 static void reset_buffer(JfrBuffer* buffer, Thread* t) {
592   assert(buffer != NULL, &quot;invariant&quot;);
593   assert(t != NULL, &quot;invariant&quot;);
594   assert(buffer == thread_local_buffer(t), &quot;invariant&quot;);
595   buffer-&gt;set_pos(const_cast&lt;u1*&gt;(buffer-&gt;top()));
596 }
597 
598 static void reset_thread_local_buffer(Thread* t) {
599   reset_buffer(thread_local_buffer(t), t);
600 }
601 
602 static void write_thread_local_buffer(JfrChunkWriter&amp; chunkwriter, Thread* t) {
603   JfrBuffer * const buffer = thread_local_buffer(t);
604   assert(buffer != NULL, &quot;invariant&quot;);
605   if (!buffer-&gt;empty()) {
606     chunkwriter.write_unbuffered(buffer-&gt;top(), buffer-&gt;pos() - buffer-&gt;top());
<span class="line-removed">607     reset_buffer(buffer, t);</span>
608   }
609 }
610 
611 size_t JfrRecorderService::flush() {
<span class="line-removed">612   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
613   size_t total_elements = flush_metadata(_chunkwriter);
614   const size_t storage_elements = flush_storage(_storage, _chunkwriter);
615   if (0 == storage_elements) {
616     return total_elements;
617   }
618   total_elements += storage_elements;
619   if (_string_pool.is_modified()) {
620     total_elements += flush_stringpool(_string_pool, _chunkwriter);
621   }
622   if (_stack_trace_repository.is_modified()) {
623     total_elements += flush_stacktrace(_stack_trace_repository, _chunkwriter);
624   }
625   return flush_typeset(_checkpoint_manager, _chunkwriter) + total_elements;
626 }
627 
628 typedef Content&lt;JfrRecorderService, &amp;JfrRecorderService::flush&gt; FlushFunctor;
629 typedef WriteContent&lt;FlushFunctor&gt; Flush;
630 
631 void JfrRecorderService::invoke_flush() {
<span class="line-modified">632   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
633   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
634   Thread* const t = Thread::current();
<span class="line-removed">635   ResourceMark rm(t);</span>
<span class="line-removed">636   HandleMark hm(t);</span>
637   ++flushpoint_id;
638   reset_thread_local_buffer(t);
639   FlushFunctor flushpoint(*this);
640   Flush fl(_chunkwriter, flushpoint);
641   invoke_with_flush_event(fl);
642   write_thread_local_buffer(_chunkwriter, t);
643   _repository.flush_chunk();
644 }
645 
646 void JfrRecorderService::flushpoint() {
<span class="line-modified">647   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>

648   if (_chunkwriter.is_valid()) {
649     invoke_flush();
650   }
651 }
652 
653 void JfrRecorderService::process_full_buffers() {


654   if (_chunkwriter.is_valid()) {
655     _storage.write_full();
656   }
657 }
658 
659 void JfrRecorderService::evaluate_chunk_size_for_rotation() {

660   JfrChunkRotation::evaluate(_chunkwriter);
661 }
</pre>
</td>
<td>
<hr />
<pre>
 28 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 29 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 30 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
 31 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 32 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
 33 #include &quot;jfr/recorder/checkpoint/jfrMetadataEvent.hpp&quot;
 34 #include &quot;jfr/recorder/repository/jfrChunkRotation.hpp&quot;
 35 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
 36 #include &quot;jfr/recorder/repository/jfrRepository.hpp&quot;
 37 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 38 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 39 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
 40 #include &quot;jfr/recorder/storage/jfrStorage.hpp&quot;
 41 #include &quot;jfr/recorder/storage/jfrStorageControl.hpp&quot;
 42 #include &quot;jfr/recorder/stringpool/jfrStringPool.hpp&quot;
 43 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 44 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 45 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
 46 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 47 #include &quot;logging/log.hpp&quot;

 48 #include &quot;runtime/atomic.hpp&quot;
<span class="line-modified"> 49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
 50 #include &quot;runtime/mutexLocker.hpp&quot;
 51 #include &quot;runtime/os.hpp&quot;
 52 #include &quot;runtime/safepoint.hpp&quot;
 53 #include &quot;runtime/thread.inline.hpp&quot;
 54 #include &quot;runtime/vmOperations.hpp&quot;
 55 #include &quot;runtime/vmThread.hpp&quot;
 56 
 57 // incremented on each flushpoint
 58 static u8 flushpoint_id = 0;
 59 
<span class="line-added"> 60 class JfrRotationLock : public StackObj {</span>
<span class="line-added"> 61  private:</span>
<span class="line-added"> 62   static const Thread* _owner_thread;</span>
<span class="line-added"> 63   static const int retry_wait_millis;</span>
<span class="line-added"> 64   static volatile int _lock;</span>
<span class="line-added"> 65   Thread* _thread;</span>
<span class="line-added"> 66   bool _recursive;</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68   static bool acquire(Thread* thread) {</span>
<span class="line-added"> 69     if (Atomic::cmpxchg(&amp;_lock, 0, 1) == 0) {</span>
<span class="line-added"> 70       assert(_owner_thread == NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 71       _owner_thread = thread;</span>
<span class="line-added"> 72       return true;</span>
<span class="line-added"> 73     }</span>
<span class="line-added"> 74     return false;</span>
<span class="line-added"> 75   }</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77   // The system can proceed to a safepoint</span>
<span class="line-added"> 78   // because even if the thread is a JavaThread,</span>
<span class="line-added"> 79   // it is running as _thread_in_native here.</span>
<span class="line-added"> 80   void lock() {</span>
<span class="line-added"> 81     while (!acquire(_thread)) {</span>
<span class="line-added"> 82       os::naked_short_sleep(retry_wait_millis);</span>
<span class="line-added"> 83     }</span>
<span class="line-added"> 84     assert(is_owner(), &quot;invariant&quot;);</span>
<span class="line-added"> 85   }</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87  public:</span>
<span class="line-added"> 88   JfrRotationLock() : _thread(Thread::current()), _recursive(false) {</span>
<span class="line-added"> 89     assert(_thread != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 90     if (_thread == _owner_thread) {</span>
<span class="line-added"> 91       // Recursive case is not supported.</span>
<span class="line-added"> 92       _recursive = true;</span>
<span class="line-added"> 93       assert(_lock == 1, &quot;invariant&quot;);</span>
<span class="line-added"> 94       // For user, should not be &quot;jfr, system&quot;.</span>
<span class="line-added"> 95       log_info(jfr)(&quot;Unable to issue rotation due to recursive calls.&quot;);</span>
<span class="line-added"> 96       return;</span>
<span class="line-added"> 97     }</span>
<span class="line-added"> 98     lock();</span>
<span class="line-added"> 99   }</span>
<span class="line-added">100 </span>
<span class="line-added">101   ~JfrRotationLock() {</span>
<span class="line-added">102     assert(is_owner(), &quot;invariant&quot;);</span>
<span class="line-added">103     if (_recursive) {</span>
<span class="line-added">104       return;</span>
<span class="line-added">105     }</span>
<span class="line-added">106     _owner_thread = NULL;</span>
<span class="line-added">107     OrderAccess::storestore();</span>
<span class="line-added">108     _lock = 0;</span>
<span class="line-added">109   }</span>
<span class="line-added">110 </span>
<span class="line-added">111   static bool is_owner() {</span>
<span class="line-added">112     return _owner_thread == Thread::current();</span>
<span class="line-added">113   }</span>
<span class="line-added">114 </span>
<span class="line-added">115   bool is_acquired_recursively() const {</span>
<span class="line-added">116     return _recursive;</span>
<span class="line-added">117   }</span>
<span class="line-added">118 };</span>
<span class="line-added">119 </span>
<span class="line-added">120 const Thread* JfrRotationLock::_owner_thread = NULL;</span>
<span class="line-added">121 const int JfrRotationLock::retry_wait_millis = 10;</span>
<span class="line-added">122 volatile int JfrRotationLock::_lock = 0;</span>
<span class="line-added">123 </span>
124 template &lt;typename Instance, size_t(Instance::*func)()&gt;
125 class Content {
126  private:
127   Instance&amp; _instance;
128   u4 _elements;
129  public:
130   Content(Instance&amp; instance) : _instance(instance), _elements(0) {}
131   bool process() {
132     _elements = (u4)(_instance.*func)();
133     return true;
134   }
135   u4 elements() const { return _elements; }
136 };
137 
138 template &lt;typename Content&gt;
139 class WriteContent : public StackObj {
140  protected:
141   const JfrTicks _start_time;
142   JfrTicks _end_time;
143   JfrChunkWriter&amp; _cw;
</pre>
<hr />
<pre>
388   _chunkwriter(JfrRepository::chunkwriter()),
389   _repository(JfrRepository::instance()),
390   _stack_trace_repository(JfrStackTraceRepository::instance()),
391   _storage(JfrStorage::instance()),
392   _string_pool(JfrStringPool::instance()) {}
393 
394 enum RecorderState {
395   STOPPED,
396   RUNNING
397 };
398 
399 static RecorderState recorder_state = STOPPED;
400 
401 static void set_recorder_state(RecorderState from, RecorderState to) {
402   assert(from == recorder_state, &quot;invariant&quot;);
403   OrderAccess::storestore();
404   recorder_state = to;
405 }
406 
407 static void start_recorder() {
<span class="line-added">408   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
409   set_recorder_state(STOPPED, RUNNING);
410   log_debug(jfr, system)(&quot;Recording service STARTED&quot;);
411 }
412 
413 static void stop_recorder() {
<span class="line-added">414   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
415   set_recorder_state(RUNNING, STOPPED);
416   log_debug(jfr, system)(&quot;Recording service STOPPED&quot;);
417 }
418 
419 bool JfrRecorderService::is_recording() {
420   const bool is_running = recorder_state == RUNNING;
421   OrderAccess::loadload();
422   return is_running;
423 }
424 
425 void JfrRecorderService::start() {
<span class="line-modified">426   JfrRotationLock lock;</span>
427   assert(!is_recording(), &quot;invariant&quot;);
428   clear();
429   open_new_chunk();
430   start_recorder();
431   assert(is_recording(), &quot;invariant&quot;);
432 }
433 
434 static void stop() {
435   assert(JfrRecorderService::is_recording(), &quot;invariant&quot;);
436   stop_recorder();
437   assert(!JfrRecorderService::is_recording(), &quot;invariant&quot;);
438 }
439 
440 void JfrRecorderService::clear() {
<span class="line-modified">441   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>

442   pre_safepoint_clear();
443   invoke_safepoint_clear();
444   post_safepoint_clear();
445 }
446 
447 void JfrRecorderService::pre_safepoint_clear() {
448   _string_pool.clear();
449   _storage.clear();
450   _stack_trace_repository.clear();
451 }
452 
453 void JfrRecorderService::invoke_safepoint_clear() {
454   JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_clear&gt; safepoint_task(*this);
<span class="line-added">455   ThreadInVMfromNative transition((JavaThread*)Thread::current());</span>
456   VMThread::execute(&amp;safepoint_task);
457 }
458 
459 void JfrRecorderService::safepoint_clear() {
460   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
461   _checkpoint_manager.begin_epoch_shift();
462   _string_pool.clear();
463   _storage.clear();
464   _chunkwriter.set_time_stamp();
465   _stack_trace_repository.clear();
466   _checkpoint_manager.end_epoch_shift();
467 }
468 
469 void JfrRecorderService::post_safepoint_clear() {
470   _checkpoint_manager.clear();
471 }
472 
473 void JfrRecorderService::open_new_chunk(bool vm_error) {
<span class="line-modified">474   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
475   JfrChunkRotation::on_rotation();
476   const bool valid_chunk = _repository.open_chunk(vm_error);
477   _storage.control().set_to_disk(valid_chunk);
478   if (valid_chunk) {
479     _checkpoint_manager.write_static_type_set_and_threads();
480   }
481 }
482 



































483 void JfrRecorderService::vm_error_rotation() {
<span class="line-modified">484   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>






485   if (!_chunkwriter.is_valid()) {
486     open_new_chunk(true);
487   }
488   if (_chunkwriter.is_valid()) {
<span class="line-modified">489     Thread* const thread = Thread::current();</span>
<span class="line-added">490     _storage.flush_regular_buffer(thread-&gt;jfr_thread_local()-&gt;native_buffer(), thread);</span>
491     _chunkwriter.mark_chunk_final();
492     invoke_flush();
493     _chunkwriter.set_time_stamp();
494     _repository.close_chunk();
495     assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);
496     _repository.on_vm_error();
497   }
498 }
499 
500 void JfrRecorderService::rotate(int msgs) {
<span class="line-modified">501   JfrRotationLock lock;</span>
<span class="line-modified">502   if (lock.is_acquired_recursively()) {</span>
<span class="line-modified">503     return;</span>



504   }
<span class="line-modified">505   if (msgs &amp; MSGBIT(MSG_VM_ERROR)) {</span>

506     vm_error_rotation();
507     return;
508   }
509   if (_storage.control().to_disk()) {
510     chunk_rotation();
511   } else {
512     in_memory_rotation();
513   }
514   if (msgs &amp; (MSGBIT(MSG_STOP))) {
515     stop();
516   }
517 }
518 
519 void JfrRecorderService::in_memory_rotation() {
<span class="line-modified">520   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
521   // currently running an in-memory recording
522   assert(!_storage.control().to_disk(), &quot;invariant&quot;);
523   open_new_chunk();
524   if (_chunkwriter.is_valid()) {
525     // dump all in-memory buffer data to the newly created chunk
526     write_storage(_storage, _chunkwriter);
527   }
528 }
529 
530 void JfrRecorderService::chunk_rotation() {
<span class="line-modified">531   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
532   finalize_current_chunk();
533   open_new_chunk();
534 }
535 
536 void JfrRecorderService::finalize_current_chunk() {
537   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);


538   write();

539 }
540 
541 void JfrRecorderService::write() {


542   pre_safepoint_write();
543   invoke_safepoint_write();
544   post_safepoint_write();
545 }
546 
547 void JfrRecorderService::pre_safepoint_write() {
548   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);

549   if (LeakProfiler::is_running()) {
550     // Exclusive access to the object sampler instance.
551     // The sampler is released (unlocked) later in post_safepoint_write.
552     ObjectSampleCheckpoint::on_rotation(ObjectSampler::acquire(), _stack_trace_repository);
553   }
554   if (_string_pool.is_modified()) {
555     write_stringpool(_string_pool, _chunkwriter);
556   }
557   write_storage(_storage, _chunkwriter);
558   if (_stack_trace_repository.is_modified()) {
559     write_stacktrace(_stack_trace_repository, _chunkwriter, false);
560   }
561 }
562 
563 void JfrRecorderService::invoke_safepoint_write() {
564   JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_write&gt; safepoint_task(*this);
<span class="line-added">565   // can safepoint here</span>
<span class="line-added">566   ThreadInVMfromNative transition((JavaThread*)Thread::current());</span>
567   VMThread::execute(&amp;safepoint_task);
568 }
569 
570 void JfrRecorderService::safepoint_write() {
571   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);


572   _checkpoint_manager.begin_epoch_shift();
573   if (_string_pool.is_modified()) {
574     write_stringpool_safepoint(_string_pool, _chunkwriter);
575   }
576   _checkpoint_manager.on_rotation();
577   _storage.write_at_safepoint();
578   _chunkwriter.set_time_stamp();
579   write_stacktrace(_stack_trace_repository, _chunkwriter, true);
580   _checkpoint_manager.end_epoch_shift();
581 }
582 
583 void JfrRecorderService::post_safepoint_write() {
584   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);

585   // During the safepoint tasks just completed, the system transitioned to a new epoch.
586   // Type tagging is epoch relative which entails we are able to write out the
587   // already tagged artifacts for the previous epoch. We can accomplish this concurrently
588   // with threads now tagging artifacts in relation to the new, now updated, epoch and remain outside of a safepoint.
589   _checkpoint_manager.write_type_set();
590   if (LeakProfiler::is_running()) {
591     // The object sampler instance was exclusively acquired and locked in pre_safepoint_write.
592     // Note: There is a dependency on write_type_set() above, ensure the release is subsequent.
593     ObjectSampler::release();
594   }
595   // serialize the metadata descriptor event and close out the chunk
596   write_metadata(_chunkwriter);
597   _repository.close_chunk();
598 }
599 
600 static JfrBuffer* thread_local_buffer(Thread* t) {
601   assert(t != NULL, &quot;invariant&quot;);
602   return t-&gt;jfr_thread_local()-&gt;native_buffer();
603 }
604 
605 static void reset_buffer(JfrBuffer* buffer, Thread* t) {
606   assert(buffer != NULL, &quot;invariant&quot;);
607   assert(t != NULL, &quot;invariant&quot;);
608   assert(buffer == thread_local_buffer(t), &quot;invariant&quot;);
609   buffer-&gt;set_pos(const_cast&lt;u1*&gt;(buffer-&gt;top()));
610 }
611 
612 static void reset_thread_local_buffer(Thread* t) {
613   reset_buffer(thread_local_buffer(t), t);
614 }
615 
616 static void write_thread_local_buffer(JfrChunkWriter&amp; chunkwriter, Thread* t) {
617   JfrBuffer * const buffer = thread_local_buffer(t);
618   assert(buffer != NULL, &quot;invariant&quot;);
619   if (!buffer-&gt;empty()) {
620     chunkwriter.write_unbuffered(buffer-&gt;top(), buffer-&gt;pos() - buffer-&gt;top());

621   }
622 }
623 
624 size_t JfrRecorderService::flush() {

625   size_t total_elements = flush_metadata(_chunkwriter);
626   const size_t storage_elements = flush_storage(_storage, _chunkwriter);
627   if (0 == storage_elements) {
628     return total_elements;
629   }
630   total_elements += storage_elements;
631   if (_string_pool.is_modified()) {
632     total_elements += flush_stringpool(_string_pool, _chunkwriter);
633   }
634   if (_stack_trace_repository.is_modified()) {
635     total_elements += flush_stacktrace(_stack_trace_repository, _chunkwriter);
636   }
637   return flush_typeset(_checkpoint_manager, _chunkwriter) + total_elements;
638 }
639 
640 typedef Content&lt;JfrRecorderService, &amp;JfrRecorderService::flush&gt; FlushFunctor;
641 typedef WriteContent&lt;FlushFunctor&gt; Flush;
642 
643 void JfrRecorderService::invoke_flush() {
<span class="line-modified">644   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
645   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
646   Thread* const t = Thread::current();


647   ++flushpoint_id;
648   reset_thread_local_buffer(t);
649   FlushFunctor flushpoint(*this);
650   Flush fl(_chunkwriter, flushpoint);
651   invoke_with_flush_event(fl);
652   write_thread_local_buffer(_chunkwriter, t);
653   _repository.flush_chunk();
654 }
655 
656 void JfrRecorderService::flushpoint() {
<span class="line-modified">657   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));</span>
<span class="line-added">658   JfrRotationLock lock;</span>
659   if (_chunkwriter.is_valid()) {
660     invoke_flush();
661   }
662 }
663 
664 void JfrRecorderService::process_full_buffers() {
<span class="line-added">665   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));</span>
<span class="line-added">666   JfrRotationLock lock;</span>
667   if (_chunkwriter.is_valid()) {
668     _storage.write_full();
669   }
670 }
671 
672 void JfrRecorderService::evaluate_chunk_size_for_rotation() {
<span class="line-added">673   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));</span>
674   JfrChunkRotation::evaluate(_chunkwriter);
675 }
</pre>
</td>
</tr>
</table>
<center><a href="../repository/jfrEmergencyDump.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrRecorderThreadLoop.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
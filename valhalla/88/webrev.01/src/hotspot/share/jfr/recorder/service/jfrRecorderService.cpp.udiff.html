<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../repository/jfrEmergencyDump.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrRecorderThreadLoop.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -43,23 +43,86 @@</span>
  #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
  #include &quot;jfr/utilities/jfrTime.hpp&quot;
  #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
  #include &quot;jfr/utilities/jfrTypes.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="udiff-line-removed">- #include &quot;memory/resourceArea.hpp&quot;</span>
  #include &quot;runtime/atomic.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  
  // incremented on each flushpoint
  static u8 flushpoint_id = 0;
  
<span class="udiff-line-added">+ class JfrRotationLock : public StackObj {</span>
<span class="udiff-line-added">+  private:</span>
<span class="udiff-line-added">+   static const Thread* _owner_thread;</span>
<span class="udiff-line-added">+   static const int retry_wait_millis;</span>
<span class="udiff-line-added">+   static volatile int _lock;</span>
<span class="udiff-line-added">+   Thread* _thread;</span>
<span class="udiff-line-added">+   bool _recursive;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static bool acquire(Thread* thread) {</span>
<span class="udiff-line-added">+     if (Atomic::cmpxchg(&amp;_lock, 0, 1) == 0) {</span>
<span class="udiff-line-added">+       assert(_owner_thread == NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+       _owner_thread = thread;</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // The system can proceed to a safepoint</span>
<span class="udiff-line-added">+   // because even if the thread is a JavaThread,</span>
<span class="udiff-line-added">+   // it is running as _thread_in_native here.</span>
<span class="udiff-line-added">+   void lock() {</span>
<span class="udiff-line-added">+     while (!acquire(_thread)) {</span>
<span class="udiff-line-added">+       os::naked_short_sleep(retry_wait_millis);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     assert(is_owner(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+   JfrRotationLock() : _thread(Thread::current()), _recursive(false) {</span>
<span class="udiff-line-added">+     assert(_thread != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+     if (_thread == _owner_thread) {</span>
<span class="udiff-line-added">+       // Recursive case is not supported.</span>
<span class="udiff-line-added">+       _recursive = true;</span>
<span class="udiff-line-added">+       assert(_lock == 1, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+       // For user, should not be &quot;jfr, system&quot;.</span>
<span class="udiff-line-added">+       log_info(jfr)(&quot;Unable to issue rotation due to recursive calls.&quot;);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     lock();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ~JfrRotationLock() {</span>
<span class="udiff-line-added">+     assert(is_owner(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+     if (_recursive) {</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     _owner_thread = NULL;</span>
<span class="udiff-line-added">+     OrderAccess::storestore();</span>
<span class="udiff-line-added">+     _lock = 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static bool is_owner() {</span>
<span class="udiff-line-added">+     return _owner_thread == Thread::current();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool is_acquired_recursively() const {</span>
<span class="udiff-line-added">+     return _recursive;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const Thread* JfrRotationLock::_owner_thread = NULL;</span>
<span class="udiff-line-added">+ const int JfrRotationLock::retry_wait_millis = 10;</span>
<span class="udiff-line-added">+ volatile int JfrRotationLock::_lock = 0;</span>
<span class="udiff-line-added">+ </span>
  template &lt;typename Instance, size_t(Instance::*func)()&gt;
  class Content {
   private:
    Instance&amp; _instance;
    u4 _elements;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -340,15 +403,17 @@</span>
    OrderAccess::storestore();
    recorder_state = to;
  }
  
  static void start_recorder() {
<span class="udiff-line-added">+   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
    set_recorder_state(STOPPED, RUNNING);
    log_debug(jfr, system)(&quot;Recording service STARTED&quot;);
  }
  
  static void stop_recorder() {
<span class="udiff-line-added">+   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
    set_recorder_state(RUNNING, STOPPED);
    log_debug(jfr, system)(&quot;Recording service STOPPED&quot;);
  }
  
  bool JfrRecorderService::is_recording() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -356,11 +421,11 @@</span>
    OrderAccess::loadload();
    return is_running;
  }
  
  void JfrRecorderService::start() {
<span class="udiff-line-modified-removed">-   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   JfrRotationLock lock;</span>
    assert(!is_recording(), &quot;invariant&quot;);
    clear();
    open_new_chunk();
    start_recorder();
    assert(is_recording(), &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -371,12 +436,11 @@</span>
    stop_recorder();
    assert(!JfrRecorderService::is_recording(), &quot;invariant&quot;);
  }
  
  void JfrRecorderService::clear() {
<span class="udiff-line-modified-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">-   HandleMark hm;</span>
<span class="udiff-line-modified-added">+   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
    pre_safepoint_clear();
    invoke_safepoint_clear();
    post_safepoint_clear();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -386,10 +450,11 @@</span>
    _stack_trace_repository.clear();
  }
  
  void JfrRecorderService::invoke_safepoint_clear() {
    JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_clear&gt; safepoint_task(*this);
<span class="udiff-line-added">+   ThreadInVMfromNative transition((JavaThread*)Thread::current());</span>
    VMThread::execute(&amp;safepoint_task);
  }
  
  void JfrRecorderService::safepoint_clear() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -404,86 +469,42 @@</span>
  void JfrRecorderService::post_safepoint_clear() {
    _checkpoint_manager.clear();
  }
  
  void JfrRecorderService::open_new_chunk(bool vm_error) {
<span class="udiff-line-modified-removed">-   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
    JfrChunkRotation::on_rotation();
    const bool valid_chunk = _repository.open_chunk(vm_error);
    _storage.control().set_to_disk(valid_chunk);
    if (valid_chunk) {
      _checkpoint_manager.write_static_type_set_and_threads();
    }
  }
  
<span class="udiff-line-removed">- // &#39;rotation_safepoint_pending&#39; is currently only relevant in the unusual case of an emergency dump.</span>
<span class="udiff-line-removed">- // Since the JfrStream_lock must be acquired using _no_safepoint_check,</span>
<span class="udiff-line-removed">- // if the thread running the emergency dump is a JavaThread, a pending safepoint, induced by rotation,</span>
<span class="udiff-line-removed">- // would lead to a deadlock. This deadlock, although unpleasant, is not completely horrendous at this</span>
<span class="udiff-line-removed">- // location because the WatcherThread will terminate the VM after a timeout.</span>
<span class="udiff-line-removed">- // Deadlock avoidance is done not to affect the stability of general VM error reporting.</span>
<span class="udiff-line-removed">- static bool rotation_safepoint_pending = false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static bool is_rotation_safepoint_pending() {</span>
<span class="udiff-line-removed">-   return Atomic::load_acquire(&amp;rotation_safepoint_pending);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void set_rotation_safepoint_pending(bool value) {</span>
<span class="udiff-line-removed">-   assert(value ? !is_rotation_safepoint_pending() : is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   Atomic::release_store(&amp;rotation_safepoint_pending, value);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static bool vm_error = false;</span>
<span class="udiff-line-removed">- static const Thread* vm_error_thread = NULL;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static bool prepare_for_vm_error_rotation() {</span>
<span class="udiff-line-removed">-   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   Thread* const t = Thread::current();</span>
<span class="udiff-line-removed">-   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   if (is_rotation_safepoint_pending() &amp;&amp; t-&gt;is_Java_thread()) {</span>
<span class="udiff-line-removed">-     // A safepoint is pending, avoid deadlock.</span>
<span class="udiff-line-removed">-     log_warning(jfr, system)(&quot;Unable to issue successful emergency dump&quot;);</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   vm_error_thread = t;</span>
<span class="udiff-line-removed">-   vm_error = true;</span>
<span class="udiff-line-removed">-   OrderAccess::fence();</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void JfrRecorderService::vm_error_rotation() {
<span class="udiff-line-modified-removed">-   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(vm_error, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   Thread* const t = Thread::current();</span>
<span class="udiff-line-removed">-   if (vm_error_thread != t) {</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(vm_error_thread == t, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
    if (!_chunkwriter.is_valid()) {
      open_new_chunk(true);
    }
    if (_chunkwriter.is_valid()) {
<span class="udiff-line-modified-removed">-     _storage.flush_regular_buffer(t-&gt;jfr_thread_local()-&gt;native_buffer(), t);</span>
<span class="udiff-line-modified-added">+     Thread* const thread = Thread::current();</span>
<span class="udiff-line-added">+     _storage.flush_regular_buffer(thread-&gt;jfr_thread_local()-&gt;native_buffer(), thread);</span>
      _chunkwriter.mark_chunk_final();
      invoke_flush();
      _chunkwriter.set_time_stamp();
      _repository.close_chunk();
      assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);
      _repository.on_vm_error();
    }
  }
  
  void JfrRecorderService::rotate(int msgs) {
<span class="udiff-line-modified-removed">-   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-   if (msgs &amp; MSGBIT(MSG_VM_ERROR)) {</span>
<span class="udiff-line-modified-removed">-     // emergency dump</span>
<span class="udiff-line-removed">-     if (!prepare_for_vm_error_rotation()) {</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   JfrRotationLock lock;</span>
<span class="udiff-line-modified-added">+   if (lock.is_acquired_recursively()) {</span>
<span class="udiff-line-modified-added">+     return;</span>
    }
<span class="udiff-line-modified-removed">-   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">-   if (vm_error) {</span>
<span class="udiff-line-modified-added">+   if (msgs &amp; MSGBIT(MSG_VM_ERROR)) {</span>
      vm_error_rotation();
      return;
    }
    if (_storage.control().to_disk()) {
      chunk_rotation();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -494,45 +515,39 @@</span>
      stop();
    }
  }
  
  void JfrRecorderService::in_memory_rotation() {
<span class="udiff-line-modified-removed">-   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
    // currently running an in-memory recording
    assert(!_storage.control().to_disk(), &quot;invariant&quot;);
    open_new_chunk();
    if (_chunkwriter.is_valid()) {
      // dump all in-memory buffer data to the newly created chunk
      write_storage(_storage, _chunkwriter);
    }
  }
  
  void JfrRecorderService::chunk_rotation() {
<span class="udiff-line-modified-removed">-   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
    finalize_current_chunk();
    open_new_chunk();
  }
  
  void JfrRecorderService::finalize_current_chunk() {
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="udiff-line-removed">-   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   set_rotation_safepoint_pending(true);</span>
    write();
<span class="udiff-line-removed">-   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
  }
  
  void JfrRecorderService::write() {
<span class="udiff-line-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">-   HandleMark hm;</span>
    pre_safepoint_write();
    invoke_safepoint_write();
    post_safepoint_write();
  }
  
  void JfrRecorderService::pre_safepoint_write() {
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="udiff-line-removed">-   assert(is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
    if (LeakProfiler::is_running()) {
      // Exclusive access to the object sampler instance.
      // The sampler is released (unlocked) later in post_safepoint_write.
      ObjectSampleCheckpoint::on_rotation(ObjectSampler::acquire(), _stack_trace_repository);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -545,17 +560,17 @@</span>
    }
  }
  
  void JfrRecorderService::invoke_safepoint_write() {
    JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_write&gt; safepoint_task(*this);
<span class="udiff-line-added">+   // can safepoint here</span>
<span class="udiff-line-added">+   ThreadInVMfromNative transition((JavaThread*)Thread::current());</span>
    VMThread::execute(&amp;safepoint_task);
  }
  
  void JfrRecorderService::safepoint_write() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="udiff-line-removed">-   assert(is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   set_rotation_safepoint_pending(false);</span>
    _checkpoint_manager.begin_epoch_shift();
    if (_string_pool.is_modified()) {
      write_stringpool_safepoint(_string_pool, _chunkwriter);
    }
    _checkpoint_manager.on_rotation();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -565,11 +580,10 @@</span>
    _checkpoint_manager.end_epoch_shift();
  }
  
  void JfrRecorderService::post_safepoint_write() {
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="udiff-line-removed">-   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
    // During the safepoint tasks just completed, the system transitioned to a new epoch.
    // Type tagging is epoch relative which entails we are able to write out the
    // already tagged artifacts for the previous epoch. We can accomplish this concurrently
    // with threads now tagging artifacts in relation to the new, now updated, epoch and remain outside of a safepoint.
    _checkpoint_manager.write_type_set();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -602,16 +616,14 @@</span>
  static void write_thread_local_buffer(JfrChunkWriter&amp; chunkwriter, Thread* t) {
    JfrBuffer * const buffer = thread_local_buffer(t);
    assert(buffer != NULL, &quot;invariant&quot;);
    if (!buffer-&gt;empty()) {
      chunkwriter.write_unbuffered(buffer-&gt;top(), buffer-&gt;pos() - buffer-&gt;top());
<span class="udiff-line-removed">-     reset_buffer(buffer, t);</span>
    }
  }
  
  size_t JfrRecorderService::flush() {
<span class="udiff-line-removed">-   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
    size_t total_elements = flush_metadata(_chunkwriter);
    const size_t storage_elements = flush_storage(_storage, _chunkwriter);
    if (0 == storage_elements) {
      return total_elements;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -627,35 +639,37 @@</span>
  
  typedef Content&lt;JfrRecorderService, &amp;JfrRecorderService::flush&gt; FlushFunctor;
  typedef WriteContent&lt;FlushFunctor&gt; Flush;
  
  void JfrRecorderService::invoke_flush() {
<span class="udiff-line-modified-removed">-   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(JfrRotationLock::is_owner(), &quot;invariant&quot;);</span>
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
    Thread* const t = Thread::current();
<span class="udiff-line-removed">-   ResourceMark rm(t);</span>
<span class="udiff-line-removed">-   HandleMark hm(t);</span>
    ++flushpoint_id;
    reset_thread_local_buffer(t);
    FlushFunctor flushpoint(*this);
    Flush fl(_chunkwriter, flushpoint);
    invoke_with_flush_event(fl);
    write_thread_local_buffer(_chunkwriter, t);
    _repository.flush_chunk();
  }
  
  void JfrRecorderService::flushpoint() {
<span class="udiff-line-modified-removed">-   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));</span>
<span class="udiff-line-added">+   JfrRotationLock lock;</span>
    if (_chunkwriter.is_valid()) {
      invoke_flush();
    }
  }
  
  void JfrRecorderService::process_full_buffers() {
<span class="udiff-line-added">+   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));</span>
<span class="udiff-line-added">+   JfrRotationLock lock;</span>
    if (_chunkwriter.is_valid()) {
      _storage.write_full();
    }
  }
  
  void JfrRecorderService::evaluate_chunk_size_for_rotation() {
<span class="udiff-line-added">+   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(Thread::current()));</span>
    JfrChunkRotation::evaluate(_chunkwriter);
  }
</pre>
<center><a href="../repository/jfrEmergencyDump.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrRecorderThreadLoop.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
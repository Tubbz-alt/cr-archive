diff a/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp b/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp
--- a/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp
+++ b/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp
@@ -420,19 +420,15 @@
 * This "safety net" somewhat explains the aggressiveness in this attempt.
 *
 */
 static bool prepare_for_emergency_dump(Thread* thread) {
   assert(thread != NULL, "invariant");
-
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));
   if (thread->is_Watcher_thread()) {
     // need WatcherThread as a safeguard against potential deadlocks
     return false;
   }
-  if (JfrStream_lock->owned_by_self()) {
-    // crashed during jfr rotation, disallow recursion
-    return false;
-  }
 
 #ifdef ASSERT
   Mutex* owned_lock = thread->owned_locks();
   while (owned_lock != NULL) {
     Mutex* next = owned_lock->next();
@@ -499,33 +495,42 @@
 
 static bool guard_reentrancy() {
   return Atomic::cmpxchg(&jfr_shutdown_lock, 0, 1) == 0;
 }
 
-class JavaThreadInVM : public StackObj {
+class JavaThreadInVMAndNative : public StackObj {
  private:
   JavaThread* const _jt;
   JavaThreadState _original_state;
  public:
 
-  JavaThreadInVM(Thread* t) : _jt(t->is_Java_thread() ? (JavaThread*)t : NULL),
-                              _original_state(_thread_max_state) {
-    if ((_jt != NULL) && (_jt->thread_state() != _thread_in_vm)) {
+  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? (JavaThread*)t : NULL),
+                                       _original_state(_thread_max_state) {
+    if (_jt != NULL) {
       _original_state = _jt->thread_state();
-      _jt->set_thread_state(_thread_in_vm);
+      if (_original_state != _thread_in_vm) {
+        _jt->set_thread_state(_thread_in_vm);
+      }
     }
   }
 
-  ~JavaThreadInVM() {
+  ~JavaThreadInVMAndNative() {
     if (_original_state != _thread_max_state) {
       _jt->set_thread_state(_original_state);
     }
   }
 
+  void transition_to_native() {
+    if (_jt != NULL) {
+      assert(_jt->thread_state() == _thread_in_vm, "invariant");
+      _jt->set_thread_state(_thread_in_native);
+    }
+  }
 };
 
-static void post_events(bool exception_handler) {
+static void post_events(bool exception_handler, Thread* thread) {
+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));
   if (exception_handler) {
     EventShutdown e;
     e.set_reason("VM Error");
     e.commit();
   } else {
@@ -545,14 +550,17 @@
   Thread* thread = Thread::current_or_null_safe();
   if (thread == NULL) {
     return;
   }
   // Ensure a JavaThread is _thread_in_vm when we make this call
-  JavaThreadInVM jtivm(thread);
+  JavaThreadInVMAndNative jtivm(thread);
   if (!prepare_for_emergency_dump(thread)) {
     return;
   }
-  post_events(exception_handler);
+  post_events(exception_handler, thread);
+  // if JavaThread, transition to _thread_in_native to issue a final flushpoint
+  NoHandleMark nhm;
+  jtivm.transition_to_native();
   const int messages = MSGBIT(MSG_VM_ERROR);
   JfrRecorderService service;
   service.rotate(messages);
 }

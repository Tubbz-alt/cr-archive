<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../recorder/service/jfrRecorderThreadLoop.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrConcurrentLinkedListHost.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
48 *
49 * To allow FIFO, the solution extends support to mark, or reserve a node, not only as part of deletions
50 * as with the LIFO case, but also, to enable tail insertions.
51 *
52 * Compared to the LIFO algorithm, the FIFO algorithm is not non-blocking, because inserts to the tail block,
53 * making it not lock-free. remove() is lock-free up until the last node in the list. In practice, the FIFO
54 * solution can be used in certain ways that very closely approximate non-blocking, for example, situations
55 * involving a single producer and multiple consumers.
56 *
57 * Although the FIFO algorithm is not non-blocking, it includes an optimization for remove() that is attractive:
58 * In the LIFO case, a slow path taken as the result of a failed excision would have to re-traverse the list
59 * to find the updated adjacent node pair for the already marked node. However, that node might already have
60 * been excised by some other thread, letting the thread potentially traverse the entire list just to discover
61 * it is no longer present (not an issue if the list is ordered by a key, then traversal is only to node &gt;= key).
62 * In the FIFO case, premised on the invariant that inserts only come in from the tail, it is possible to prove
63 * a failed cas not to be the result of a new node inserted as with the LIFO case. With FIFO, there is only a single
64 * failure mode, i.e. some other thread excised the node already. Therefore, in the FIFO case, we skip the slow-path search pass.
65 *
66 * We say that the FIFO solution is &quot;mostly&quot; concurrent, in certain situations.
67 *
<span class="line-modified">68 * Safe memory reclamation is based on a reference tracking scheme based on versions, implemented using JfrVersion.</span>
<span class="line-modified">69 * An access to the list is &quot;version controlled&quot;, with clients checking out the latest version of the list.</span>
<span class="line-modified">70 * Destructive modifications made by clients, i.e. deletions, are committed to describe new versions of the list.</span>
<span class="line-modified">71 * Before reclamation, a client inspects the versioning system to ensure checkouts for versions strictly</span>
<span class="line-modified">72 * less than the version of the modification have all been relinquished. See utilities/JfrVersion.hpp.</span>
73 *
74 * Insertions can only take place from one end of the list, head or tail, exclusively.
75 * Specializations, a.k.a clients, must ensure this requirement.
76 */
77 
78 template &lt;typename Client, template &lt;typename&gt; class SearchPolicy, typename AllocPolicy = JfrCHeapObj&gt;
79 class JfrConcurrentLinkedListHost : public AllocPolicy {
80  private:
81   Client* _client;
82   typedef typename Client::Node Node;
83   typedef Node* NodePtr;
84   typedef const Node* ConstNodePtr;
85   typedef typename Client::VersionSystem::Type VersionType;
86   typedef typename Client::VersionSystem::Handle VersionHandle;
87  public:
88   JfrConcurrentLinkedListHost(Client* client);
89   bool initialize();
90   void insert_head(NodePtr node, NodePtr head, ConstNodePtr tail) const;
91   void insert_tail(NodePtr node, NodePtr head, NodePtr last, ConstNodePtr tail) const;
92   NodePtr remove(NodePtr head, ConstNodePtr tail, NodePtr last = NULL, bool insert_is_head = true);
</pre>
</td>
<td>
<hr />
<pre>
48 *
49 * To allow FIFO, the solution extends support to mark, or reserve a node, not only as part of deletions
50 * as with the LIFO case, but also, to enable tail insertions.
51 *
52 * Compared to the LIFO algorithm, the FIFO algorithm is not non-blocking, because inserts to the tail block,
53 * making it not lock-free. remove() is lock-free up until the last node in the list. In practice, the FIFO
54 * solution can be used in certain ways that very closely approximate non-blocking, for example, situations
55 * involving a single producer and multiple consumers.
56 *
57 * Although the FIFO algorithm is not non-blocking, it includes an optimization for remove() that is attractive:
58 * In the LIFO case, a slow path taken as the result of a failed excision would have to re-traverse the list
59 * to find the updated adjacent node pair for the already marked node. However, that node might already have
60 * been excised by some other thread, letting the thread potentially traverse the entire list just to discover
61 * it is no longer present (not an issue if the list is ordered by a key, then traversal is only to node &gt;= key).
62 * In the FIFO case, premised on the invariant that inserts only come in from the tail, it is possible to prove
63 * a failed cas not to be the result of a new node inserted as with the LIFO case. With FIFO, there is only a single
64 * failure mode, i.e. some other thread excised the node already. Therefore, in the FIFO case, we skip the slow-path search pass.
65 *
66 * We say that the FIFO solution is &quot;mostly&quot; concurrent, in certain situations.
67 *
<span class="line-modified">68 * Safe memory reclamation is based on a reference tracking scheme based on versioning, implemented using JfrVersionSystem.</span>
<span class="line-modified">69 * An access to the list is &quot;versioned&quot;, with clients checking out the latest version describing the list.</span>
<span class="line-modified">70 * Destructive modifications made by clients, i.e. deletions, are signalled by incrementing the version.</span>
<span class="line-modified">71 * Before reclamation, a client inspects JfrVersionSystem to ensure checkouts with versions strictly</span>
<span class="line-modified">72 * less than the version of the modification have been relinquished. See utilities/JfrVersionSystem.hpp.</span>
73 *
74 * Insertions can only take place from one end of the list, head or tail, exclusively.
75 * Specializations, a.k.a clients, must ensure this requirement.
76 */
77 
78 template &lt;typename Client, template &lt;typename&gt; class SearchPolicy, typename AllocPolicy = JfrCHeapObj&gt;
79 class JfrConcurrentLinkedListHost : public AllocPolicy {
80  private:
81   Client* _client;
82   typedef typename Client::Node Node;
83   typedef Node* NodePtr;
84   typedef const Node* ConstNodePtr;
85   typedef typename Client::VersionSystem::Type VersionType;
86   typedef typename Client::VersionSystem::Handle VersionHandle;
87  public:
88   JfrConcurrentLinkedListHost(Client* client);
89   bool initialize();
90   void insert_head(NodePtr node, NodePtr head, ConstNodePtr tail) const;
91   void insert_tail(NodePtr node, NodePtr head, NodePtr last, ConstNodePtr tail) const;
92   NodePtr remove(NodePtr head, ConstNodePtr tail, NodePtr last = NULL, bool insert_is_head = true);
</pre>
</td>
</tr>
</table>
<center><a href="../recorder/service/jfrRecorderThreadLoop.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrConcurrentLinkedListHost.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
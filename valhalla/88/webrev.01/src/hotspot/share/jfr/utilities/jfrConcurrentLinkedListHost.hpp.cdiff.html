<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../recorder/service/jfrRecorderThreadLoop.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrConcurrentLinkedListHost.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 63,15 ***</span>
  * a failed cas not to be the result of a new node inserted as with the LIFO case. With FIFO, there is only a single
  * failure mode, i.e. some other thread excised the node already. Therefore, in the FIFO case, we skip the slow-path search pass.
  *
  * We say that the FIFO solution is &quot;mostly&quot; concurrent, in certain situations.
  *
<span class="line-modified">! * Safe memory reclamation is based on a reference tracking scheme based on versions, implemented using JfrVersion.</span>
<span class="line-modified">! * An access to the list is &quot;version controlled&quot;, with clients checking out the latest version of the list.</span>
<span class="line-modified">! * Destructive modifications made by clients, i.e. deletions, are committed to describe new versions of the list.</span>
<span class="line-modified">! * Before reclamation, a client inspects the versioning system to ensure checkouts for versions strictly</span>
<span class="line-modified">! * less than the version of the modification have all been relinquished. See utilities/JfrVersion.hpp.</span>
  *
  * Insertions can only take place from one end of the list, head or tail, exclusively.
  * Specializations, a.k.a clients, must ensure this requirement.
  */
  
<span class="line-new-header">--- 63,15 ---</span>
  * a failed cas not to be the result of a new node inserted as with the LIFO case. With FIFO, there is only a single
  * failure mode, i.e. some other thread excised the node already. Therefore, in the FIFO case, we skip the slow-path search pass.
  *
  * We say that the FIFO solution is &quot;mostly&quot; concurrent, in certain situations.
  *
<span class="line-modified">! * Safe memory reclamation is based on a reference tracking scheme based on versioning, implemented using JfrVersionSystem.</span>
<span class="line-modified">! * An access to the list is &quot;versioned&quot;, with clients checking out the latest version describing the list.</span>
<span class="line-modified">! * Destructive modifications made by clients, i.e. deletions, are signalled by incrementing the version.</span>
<span class="line-modified">! * Before reclamation, a client inspects JfrVersionSystem to ensure checkouts with versions strictly</span>
<span class="line-modified">! * less than the version of the modification have been relinquished. See utilities/JfrVersionSystem.hpp.</span>
  *
  * Insertions can only take place from one end of the list, head or tail, exclusively.
  * Specializations, a.k.a clients, must ensure this requirement.
  */
  
</pre>
<center><a href="../recorder/service/jfrRecorderThreadLoop.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrConcurrentLinkedListHost.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
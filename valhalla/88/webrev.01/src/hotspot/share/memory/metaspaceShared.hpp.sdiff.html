<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceShared.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceShared.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
167 class MetaspaceShared : AllStatic {
168 
169   // CDS support
170 
171   // Note: _shared_rs and _symbol_rs are only used at dump time.
172   static ReservedSpace _shared_rs;
173   static VirtualSpace _shared_vs;
174   static ReservedSpace _symbol_rs;
175   static VirtualSpace _symbol_vs;
176   static int _max_alignment;
177   static MetaspaceSharedStats _stats;
178   static bool _has_error_classes;
179   static bool _archive_loading_failed;
180   static bool _remapped_readwrite;
181   static address _i2i_entry_code_buffers;
182   static size_t  _i2i_entry_code_buffers_size;
183   static size_t  _core_spaces_size;
184   static void* _shared_metaspace_static_top;
185   static intx _relocation_delta;
186   static char* _requested_base_address;

187  public:
188   enum {
189     // core archive spaces
190     mc = 0,  // miscellaneous code for method trampolines
191     rw = 1,  // read-write shared space in the heap
192     ro = 2,  // read-only shared space in the heap
193     bm = 3,  // relocation bitmaps (freed after file mapping is finished)
194     num_core_region = 3,
195     num_non_heap_spaces = 4,
196 
197     // mapped java heap regions
198     first_closed_archive_heap_region = bm + 1,
199     max_closed_archive_heap_region = 2,
200     last_closed_archive_heap_region = first_closed_archive_heap_region + max_closed_archive_heap_region - 1,
201     first_open_archive_heap_region = last_closed_archive_heap_region + 1,
202     max_open_archive_heap_region = 2,
203     last_open_archive_heap_region = first_open_archive_heap_region + max_open_archive_heap_region - 1,
204 
205     last_valid_region = last_open_archive_heap_region,
206     n_regions =  last_valid_region + 1 // total number of regions
</pre>
<hr />
<pre>
355   static void initialize_ptr_marker(CHeapBitMap* ptrmap);
356 
357   // This is the base address as specified by -XX:SharedBaseAddress during -Xshare:dump.
358   // Both the base/top archives are written using this as their base address.
359   static char* requested_base_address() {
360     return _requested_base_address;
361   }
362 
363   // Non-zero if the archive(s) need to be mapped a non-default location due to ASLR.
364   static intx relocation_delta() { return _relocation_delta; }
365   static intx final_delta();
366   static bool use_windows_memory_mapping() {
367     const bool is_windows = (NOT_WINDOWS(false) WINDOWS_ONLY(true));
368     //const bool is_windows = true; // enable this to allow testing the windows mmap semantics on Linux, etc.
369     return is_windows;
370   }
371 
372   static void write_core_archive_regions(FileMapInfo* mapinfo,
373                                          GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,
374                                          GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps);





375 private:
376 #if INCLUDE_CDS
377   static void write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region,
378                            bool read_only,  bool allow_exec);
379 #endif
380   static void read_extra_data(const char* filename, TRAPS) NOT_CDS_RETURN;
381   static FileMapInfo* open_static_archive();
382   static FileMapInfo* open_dynamic_archive();
383   // use_requested_addr: If true (default), attempt to map at the address the
384   static MapArchiveResult map_archives(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo,
385                                        bool use_requested_addr);
386   static char* reserve_address_space_for_archives(FileMapInfo* static_mapinfo,
387                                                   FileMapInfo* dynamic_mapinfo,
388                                                   bool use_archive_base_addr,
389                                                   ReservedSpace&amp; archive_space_rs,
390                                                   ReservedSpace&amp; class_space_rs);
391   static void release_reserved_spaces(ReservedSpace&amp; archive_space_rs,
392                                       ReservedSpace&amp; class_space_rs);
393   static MapArchiveResult map_archive(FileMapInfo* mapinfo, char* mapped_base_address, ReservedSpace rs);
394   static void unmap_archive(FileMapInfo* mapinfo);
</pre>
</td>
<td>
<hr />
<pre>
167 class MetaspaceShared : AllStatic {
168 
169   // CDS support
170 
171   // Note: _shared_rs and _symbol_rs are only used at dump time.
172   static ReservedSpace _shared_rs;
173   static VirtualSpace _shared_vs;
174   static ReservedSpace _symbol_rs;
175   static VirtualSpace _symbol_vs;
176   static int _max_alignment;
177   static MetaspaceSharedStats _stats;
178   static bool _has_error_classes;
179   static bool _archive_loading_failed;
180   static bool _remapped_readwrite;
181   static address _i2i_entry_code_buffers;
182   static size_t  _i2i_entry_code_buffers_size;
183   static size_t  _core_spaces_size;
184   static void* _shared_metaspace_static_top;
185   static intx _relocation_delta;
186   static char* _requested_base_address;
<span class="line-added">187   static bool _use_optimized_module_handling;</span>
188  public:
189   enum {
190     // core archive spaces
191     mc = 0,  // miscellaneous code for method trampolines
192     rw = 1,  // read-write shared space in the heap
193     ro = 2,  // read-only shared space in the heap
194     bm = 3,  // relocation bitmaps (freed after file mapping is finished)
195     num_core_region = 3,
196     num_non_heap_spaces = 4,
197 
198     // mapped java heap regions
199     first_closed_archive_heap_region = bm + 1,
200     max_closed_archive_heap_region = 2,
201     last_closed_archive_heap_region = first_closed_archive_heap_region + max_closed_archive_heap_region - 1,
202     first_open_archive_heap_region = last_closed_archive_heap_region + 1,
203     max_open_archive_heap_region = 2,
204     last_open_archive_heap_region = first_open_archive_heap_region + max_open_archive_heap_region - 1,
205 
206     last_valid_region = last_open_archive_heap_region,
207     n_regions =  last_valid_region + 1 // total number of regions
</pre>
<hr />
<pre>
356   static void initialize_ptr_marker(CHeapBitMap* ptrmap);
357 
358   // This is the base address as specified by -XX:SharedBaseAddress during -Xshare:dump.
359   // Both the base/top archives are written using this as their base address.
360   static char* requested_base_address() {
361     return _requested_base_address;
362   }
363 
364   // Non-zero if the archive(s) need to be mapped a non-default location due to ASLR.
365   static intx relocation_delta() { return _relocation_delta; }
366   static intx final_delta();
367   static bool use_windows_memory_mapping() {
368     const bool is_windows = (NOT_WINDOWS(false) WINDOWS_ONLY(true));
369     //const bool is_windows = true; // enable this to allow testing the windows mmap semantics on Linux, etc.
370     return is_windows;
371   }
372 
373   static void write_core_archive_regions(FileMapInfo* mapinfo,
374                                          GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,
375                                          GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps);
<span class="line-added">376 </span>
<span class="line-added">377   // Can we skip some expensive operations related to modules?</span>
<span class="line-added">378   static bool use_optimized_module_handling()     { return _use_optimized_module_handling;  }</span>
<span class="line-added">379   static void disable_optimized_module_handling() { _use_optimized_module_handling = false; }</span>
<span class="line-added">380 </span>
381 private:
382 #if INCLUDE_CDS
383   static void write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region,
384                            bool read_only,  bool allow_exec);
385 #endif
386   static void read_extra_data(const char* filename, TRAPS) NOT_CDS_RETURN;
387   static FileMapInfo* open_static_archive();
388   static FileMapInfo* open_dynamic_archive();
389   // use_requested_addr: If true (default), attempt to map at the address the
390   static MapArchiveResult map_archives(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo,
391                                        bool use_requested_addr);
392   static char* reserve_address_space_for_archives(FileMapInfo* static_mapinfo,
393                                                   FileMapInfo* dynamic_mapinfo,
394                                                   bool use_archive_base_addr,
395                                                   ReservedSpace&amp; archive_space_rs,
396                                                   ReservedSpace&amp; class_space_rs);
397   static void release_reserved_spaces(ReservedSpace&amp; archive_space_rs,
398                                       ReservedSpace&amp; class_space_rs);
399   static MapArchiveResult map_archive(FileMapInfo* mapinfo, char* mapped_base_address, ReservedSpace rs);
400   static void unmap_archive(FileMapInfo* mapinfo);
</pre>
</td>
</tr>
</table>
<center><a href="metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
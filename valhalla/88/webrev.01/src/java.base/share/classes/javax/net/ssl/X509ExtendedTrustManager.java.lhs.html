<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/javax/net/ssl/X509ExtendedTrustManager.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.net.ssl;
 27 
 28 import java.net.Socket;
 29 import javax.net.ssl.X509TrustManager;
 30 
 31 import java.security.cert.X509Certificate;
 32 import java.security.cert.CertificateException;
 33 
 34 /**
 35  * Extensions to the {@code X509TrustManager} interface to support
 36  * SSL/TLS/DTLS connection sensitive trust management.
 37  * &lt;p&gt;
 38  * To prevent man-in-the-middle attacks, hostname checks can be done
 39  * to verify that the hostname in an end-entity certificate matches the
 40  * targeted hostname.  TLS/DTLS does not require such checks, but some
 41  * protocols over TLS/DTLS (such as HTTPS) do.  In earlier versions of the
 42  * JDK, the certificate chain checks were done at the SSL/TLS/DTLS layer,
 43  * and the hostname verification checks were done at the layer over TLS/DTLS.
 44  * This class allows for the checking to be done during a single call to
 45  * this class.
 46  * &lt;p&gt;
 47  * RFC 2830 defines the server identification specification for the &quot;LDAPS&quot;
 48  * algorithm. RFC 2818 defines both the server identification and the
 49  * client identification specification for the &quot;HTTPS&quot; algorithm.
 50  *
 51  * @see X509TrustManager
 52  * @see HostnameVerifier
 53  *
 54  * @since 1.7
 55  */
 56 public abstract class X509ExtendedTrustManager implements X509TrustManager {
<a name="2" id="anc2"></a>




 57     /**
 58      * Given the partial or complete certificate chain provided by the
 59      * peer, build and validate the certificate path based on the
 60      * authentication type and ssl parameters.
 61      * &lt;p&gt;
 62      * The authentication type is determined by the actual certificate
 63      * used. For instance, if RSAPublicKey is used, the authType
 64      * should be &quot;RSA&quot;. Checking is case-sensitive.
 65      * &lt;p&gt;
 66      * If the {@code socket} parameter is an instance of
 67      * {@link javax.net.ssl.SSLSocket}, and the endpoint identification
 68      * algorithm of the {@code SSLParameters} is non-empty, to prevent
 69      * man-in-the-middle attacks, the address that the {@code socket}
 70      * connected to should be checked against the peer&#39;s identity presented
 71      * in the end-entity X509 certificate, as specified in the endpoint
 72      * identification algorithm.
 73      * &lt;p&gt;
 74      * If the {@code socket} parameter is an instance of
 75      * {@link javax.net.ssl.SSLSocket}, and the algorithm constraints of the
 76      * {@code SSLParameters} is non-null, for every certificate in the
 77      * certification path, fields such as subject public key, the signature
 78      * algorithm, key usage, extended key usage, etc. need to conform to the
 79      * algorithm constraints in place on this socket.
 80      *
 81      * @param chain the peer certificate chain
 82      * @param authType the key exchange algorithm used
 83      * @param socket the socket used for this connection. This parameter
 84      *        can be null, which indicates that implementations need not check
 85      *        the ssl parameters
 86      * @throws IllegalArgumentException if null or zero-length array is passed
 87      *        in for the {@code chain} parameter or if null or zero-length
 88      *        string is passed in for the {@code authType} parameter
 89      * @throws CertificateException if the certificate chain is not trusted
 90      *        by this TrustManager
 91      *
 92      * @see SSLParameters#getEndpointIdentificationAlgorithm
 93      * @see SSLParameters#setEndpointIdentificationAlgorithm(String)
 94      * @see SSLParameters#getAlgorithmConstraints
 95      * @see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)
 96      */
 97     public abstract void checkClientTrusted(X509Certificate[] chain,
 98             String authType, Socket socket) throws CertificateException;
 99 
100     /**
101      * Given the partial or complete certificate chain provided by the
102      * peer, build and validate the certificate path based on the
103      * authentication type and ssl parameters.
104      * &lt;p&gt;
105      * The authentication type is the key exchange algorithm portion
106      * of the cipher suites represented as a String, such as &quot;RSA&quot;,
107      * &quot;DHE_DSS&quot;. Note: for some exportable cipher suites, the key
108      * exchange algorithm is determined at run time during the
109      * handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,
110      * the authType should be RSA_EXPORT when an ephemeral RSA key is
111      * used for the key exchange, and RSA when the key from the server
112      * certificate is used. Checking is case-sensitive.
113      * &lt;p&gt;
114      * If the {@code socket} parameter is an instance of
115      * {@link javax.net.ssl.SSLSocket}, and the endpoint identification
116      * algorithm of the {@code SSLParameters} is non-empty, to prevent
117      * man-in-the-middle attacks, the address that the {@code socket}
118      * connected to should be checked against the peer&#39;s identity presented
119      * in the end-entity X509 certificate, as specified in the endpoint
120      * identification algorithm.
121      * &lt;p&gt;
122      * If the {@code socket} parameter is an instance of
123      * {@link javax.net.ssl.SSLSocket}, and the algorithm constraints of the
124      *  {@code SSLParameters} is non-null, for every certificate in the
125      * certification path, fields such as subject public key, the signature
126      * algorithm, key usage, extended key usage, etc. need to conform to the
127      * algorithm constraints in place on this socket.
128      *
129      * @param chain the peer certificate chain
130      * @param authType the key exchange algorithm used
131      * @param socket the socket used for this connection. This parameter
132      *        can be null, which indicates that implementations need not check
133      *        the ssl parameters
134      * @throws IllegalArgumentException if null or zero-length array is passed
135      *        in for the {@code chain} parameter or if null or zero-length
136      *        string is passed in for the {@code authType} parameter
137      * @throws CertificateException if the certificate chain is not trusted
138      *        by this TrustManager
139      *
140      * @see SSLParameters#getEndpointIdentificationAlgorithm
141      * @see SSLParameters#setEndpointIdentificationAlgorithm(String)
142      * @see SSLParameters#getAlgorithmConstraints
143      * @see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)
144      */
145     public abstract void checkServerTrusted(X509Certificate[] chain,
146         String authType, Socket socket) throws CertificateException;
147 
148     /**
149      * Given the partial or complete certificate chain provided by the
150      * peer, build and validate the certificate path based on the
151      * authentication type and ssl parameters.
152      * &lt;p&gt;
153      * The authentication type is determined by the actual certificate
154      * used. For instance, if RSAPublicKey is used, the authType
155      * should be &quot;RSA&quot;. Checking is case-sensitive.
156      * &lt;p&gt;
157      * If the {@code engine} parameter is available, and the endpoint
158      * identification algorithm of the {@code SSLParameters} is
159      * non-empty, to prevent man-in-the-middle attacks, the address that
160      * the {@code engine} connected to should be checked against
161      * the peer&#39;s identity presented in the end-entity X509 certificate,
162      * as specified in the endpoint identification algorithm.
163      * &lt;p&gt;
164      * If the {@code engine} parameter is available, and the algorithm
165      * constraints of the {@code SSLParameters} is non-null, for every
166      * certificate in the certification path, fields such as subject public
167      * key, the signature algorithm, key usage, extended key usage, etc.
168      * need to conform to the algorithm constraints in place on this engine.
169      *
170      * @param chain the peer certificate chain
171      * @param authType the key exchange algorithm used
172      * @param engine the engine used for this connection. This parameter
173      *        can be null, which indicates that implementations need not check
174      *        the ssl parameters
175      * @throws IllegalArgumentException if null or zero-length array is passed
176      *        in for the {@code chain} parameter or if null or zero-length
177      *        string is passed in for the {@code authType} parameter
178      * @throws CertificateException if the certificate chain is not trusted
179      *        by this TrustManager
180      *
181      * @see SSLParameters#getEndpointIdentificationAlgorithm
182      * @see SSLParameters#setEndpointIdentificationAlgorithm(String)
183      * @see SSLParameters#getAlgorithmConstraints
184      * @see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)
185      */
186     public abstract void checkClientTrusted(X509Certificate[] chain,
187         String authType, SSLEngine engine) throws CertificateException;
188 
189     /**
190      * Given the partial or complete certificate chain provided by the
191      * peer, build and validate the certificate path based on the
192      * authentication type and ssl parameters.
193      * &lt;p&gt;
194      * The authentication type is the key exchange algorithm portion
195      * of the cipher suites represented as a String, such as &quot;RSA&quot;,
196      * &quot;DHE_DSS&quot;. Note: for some exportable cipher suites, the key
197      * exchange algorithm is determined at run time during the
198      * handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,
199      * the authType should be RSA_EXPORT when an ephemeral RSA key is
200      * used for the key exchange, and RSA when the key from the server
201      * certificate is used. Checking is case-sensitive.
202      * &lt;p&gt;
203      * If the {@code engine} parameter is available, and the endpoint
204      * identification algorithm of the {@code SSLParameters} is
205      * non-empty, to prevent man-in-the-middle attacks, the address that
206      * the {@code engine} connected to should be checked against
207      * the peer&#39;s identity presented in the end-entity X509 certificate,
208      * as specified in the endpoint identification algorithm.
209      * &lt;p&gt;
210      * If the {@code engine} parameter is available, and the algorithm
211      * constraints of the {@code SSLParameters} is non-null, for every
212      * certificate in the certification path, fields such as subject public
213      * key, the signature algorithm, key usage, extended key usage, etc.
214      * need to conform to the algorithm constraints in place on this engine.
215      *
216      * @param chain the peer certificate chain
217      * @param authType the key exchange algorithm used
218      * @param engine the engine used for this connection. This parameter
219      *        can be null, which indicates that implementations need not check
220      *        the ssl parameters
221      * @throws IllegalArgumentException if null or zero-length array is passed
222      *        in for the {@code chain} parameter or if null or zero-length
223      *        string is passed in for the {@code authType} parameter
224      * @throws CertificateException if the certificate chain is not trusted
225      *        by this TrustManager
226      *
227      * @see SSLParameters#getEndpointIdentificationAlgorithm
228      * @see SSLParameters#setEndpointIdentificationAlgorithm(String)
229      * @see SSLParameters#getAlgorithmConstraints
230      * @see SSLParameters#setAlgorithmConstraints(AlgorithmConstraints)
231      */
232     public abstract void checkServerTrusted(X509Certificate[] chain,
233         String authType, SSLEngine engine) throws CertificateException;
234 
235 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
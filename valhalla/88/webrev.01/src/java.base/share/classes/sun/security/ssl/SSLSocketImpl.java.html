<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.EOFException;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InterruptedIOException;
  32 import java.io.OutputStream;
  33 import java.net.InetAddress;
  34 import java.net.InetSocketAddress;
  35 import java.net.Socket;
  36 import java.net.SocketAddress;
  37 import java.net.SocketException;
  38 import java.net.UnknownHostException;
  39 import java.nio.ByteBuffer;
  40 import java.util.List;
  41 import java.util.concurrent.TimeUnit;
  42 import java.util.concurrent.locks.ReentrantLock;
  43 import java.util.function.BiFunction;
  44 import javax.net.ssl.HandshakeCompletedListener;
  45 import javax.net.ssl.SSLException;
  46 import javax.net.ssl.SSLHandshakeException;
  47 import javax.net.ssl.SSLParameters;
  48 import javax.net.ssl.SSLProtocolException;
  49 import javax.net.ssl.SSLServerSocket;
  50 import javax.net.ssl.SSLSession;
  51 import javax.net.ssl.SSLSocket;
  52 import jdk.internal.access.JavaNetInetAddressAccess;
  53 import jdk.internal.access.SharedSecrets;
  54 
  55 /**
  56  * Implementation of an SSL socket.
  57  * &lt;P&gt;
  58  * This is a normal connection type socket, implementing SSL over some lower
  59  * level socket, such as TCP.  Because it is layered over some lower level
  60  * socket, it MUST override all default socket methods.
  61  * &lt;P&gt;
  62  * This API offers a non-traditional option for establishing SSL
  63  * connections.  You may first establish the connection directly, then pass
  64  * that connection to the SSL socket constructor with a flag saying which
  65  * role should be taken in the handshake protocol.  (The two ends of the
  66  * connection must not choose the same role!)  This allows setup of SSL
  67  * proxying or tunneling, and also allows the kind of &quot;role reversal&quot;
  68  * that is required for most FTP data transfers.
  69  *
  70  * @see javax.net.ssl.SSLSocket
  71  * @see SSLServerSocket
  72  *
  73  * @author David Brownell
  74  */
  75 public final class SSLSocketImpl
  76         extends BaseSSLSocketImpl implements SSLTransport {
  77 
  78     final SSLContextImpl            sslContext;
  79     final TransportContext          conContext;
  80 
  81     private final AppInputStream    appInput = new AppInputStream();
  82     private final AppOutputStream   appOutput = new AppOutputStream();
  83 
  84     private String                  peerHost;
  85     private boolean                 autoClose;
  86     private boolean                 isConnected = false;
  87     private volatile boolean        tlsIsClosed = false;
  88 
  89     private final ReentrantLock     socketLock = new ReentrantLock();
  90     private final ReentrantLock     handshakeLock = new ReentrantLock();
  91 
  92     /*
  93      * Is the local name service trustworthy?
  94      *
  95      * If the local name service is not trustworthy, reverse host name
  96      * resolution should not be performed for endpoint identification.
  97      */
  98     private static final boolean trustNameService =
  99             Utilities.getBooleanProperty(&quot;jdk.tls.trustNameService&quot;, false);
 100 
 101     /**
 102      * Package-private constructor used to instantiate an unconnected
 103      * socket.
 104      *
 105      * This instance is meant to set handshake state to use &quot;client mode&quot;.
 106      */
 107     SSLSocketImpl(SSLContextImpl sslContext) {
 108         super();
 109         this.sslContext = sslContext;
 110         HandshakeHash handshakeHash = new HandshakeHash();
 111         this.conContext = new TransportContext(sslContext, this,
 112                 new SSLSocketInputRecord(handshakeHash),
 113                 new SSLSocketOutputRecord(handshakeHash), true);
 114     }
 115 
 116     /**
 117      * Package-private constructor used to instantiate a server socket.
 118      *
 119      * This instance is meant to set handshake state to use &quot;server mode&quot;.
 120      */
 121     SSLSocketImpl(SSLContextImpl sslContext, SSLConfiguration sslConfig) {
 122         super();
 123         this.sslContext = sslContext;
 124         HandshakeHash handshakeHash = new HandshakeHash();
 125         this.conContext = new TransportContext(sslContext, this, sslConfig,
 126                 new SSLSocketInputRecord(handshakeHash),
 127                 new SSLSocketOutputRecord(handshakeHash));
 128     }
 129 
 130     /**
 131      * Constructs an SSL connection to a named host at a specified
 132      * port, using the authentication context provided.
 133      *
 134      * This endpoint acts as the client, and may rejoin an existing SSL session
 135      * if appropriate.
 136      */
 137     SSLSocketImpl(SSLContextImpl sslContext, String peerHost,
 138             int peerPort) throws IOException, UnknownHostException {
 139         super();
 140         this.sslContext = sslContext;
 141         HandshakeHash handshakeHash = new HandshakeHash();
 142         this.conContext = new TransportContext(sslContext, this,
 143                 new SSLSocketInputRecord(handshakeHash),
 144                 new SSLSocketOutputRecord(handshakeHash), true);
 145         this.peerHost = peerHost;
 146         SocketAddress socketAddress =
 147                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :
 148                new InetSocketAddress(InetAddress.getByName(null), peerPort);
 149         connect(socketAddress, 0);
 150     }
 151 
 152     /**
 153      * Constructs an SSL connection to a server at a specified
 154      * address, and TCP port, using the authentication context
 155      * provided.
 156      *
 157      * This endpoint acts as the client, and may rejoin an existing SSL
 158      * session if appropriate.
 159      */
 160     SSLSocketImpl(SSLContextImpl sslContext,
 161             InetAddress address, int peerPort) throws IOException {
 162         super();
 163         this.sslContext = sslContext;
 164         HandshakeHash handshakeHash = new HandshakeHash();
 165         this.conContext = new TransportContext(sslContext, this,
 166                 new SSLSocketInputRecord(handshakeHash),
 167                 new SSLSocketOutputRecord(handshakeHash), true);
 168 
 169         SocketAddress socketAddress = new InetSocketAddress(address, peerPort);
 170         connect(socketAddress, 0);
 171     }
 172 
 173     /**
 174      * Constructs an SSL connection to a named host at a specified
 175      * port, using the authentication context provided.
 176      *
 177      * This endpoint acts as the client, and may rejoin an existing SSL
 178      * session if appropriate.
 179      */
 180     SSLSocketImpl(SSLContextImpl sslContext,
 181             String peerHost, int peerPort, InetAddress localAddr,
 182             int localPort) throws IOException, UnknownHostException {
 183         super();
 184         this.sslContext = sslContext;
 185         HandshakeHash handshakeHash = new HandshakeHash();
 186         this.conContext = new TransportContext(sslContext, this,
 187                 new SSLSocketInputRecord(handshakeHash),
 188                 new SSLSocketOutputRecord(handshakeHash), true);
 189         this.peerHost = peerHost;
 190 
 191         bind(new InetSocketAddress(localAddr, localPort));
 192         SocketAddress socketAddress =
 193                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :
 194                new InetSocketAddress(InetAddress.getByName(null), peerPort);
 195         connect(socketAddress, 0);
 196     }
 197 
 198     /**
 199      * Constructs an SSL connection to a server at a specified
 200      * address, and TCP port, using the authentication context
 201      * provided.
 202      *
 203      * This endpoint acts as the client, and may rejoin an existing SSL
 204      * session if appropriate.
 205      */
 206     SSLSocketImpl(SSLContextImpl sslContext,
 207             InetAddress peerAddr, int peerPort,
 208             InetAddress localAddr, int localPort) throws IOException {
 209         super();
 210         this.sslContext = sslContext;
 211         HandshakeHash handshakeHash = new HandshakeHash();
 212         this.conContext = new TransportContext(sslContext, this,
 213                 new SSLSocketInputRecord(handshakeHash),
 214                 new SSLSocketOutputRecord(handshakeHash), true);
 215 
 216         bind(new InetSocketAddress(localAddr, localPort));
 217         SocketAddress socketAddress = new InetSocketAddress(peerAddr, peerPort);
 218         connect(socketAddress, 0);
 219     }
 220 
 221     /**
 222      * Creates a server mode {@link Socket} layered over an
 223      * existing connected socket, and is able to read data which has
 224      * already been consumed/removed from the {@link Socket}&#39;s
 225      * underlying {@link InputStream}.
 226      */
 227     SSLSocketImpl(SSLContextImpl sslContext, Socket sock,
 228             InputStream consumed, boolean autoClose) throws IOException {
 229         super(sock, consumed);
 230         // We always layer over a connected socket
 231         if (!sock.isConnected()) {
 232             throw new SocketException(&quot;Underlying socket is not connected&quot;);
 233         }
 234 
 235         this.sslContext = sslContext;
 236         HandshakeHash handshakeHash = new HandshakeHash();
 237         this.conContext = new TransportContext(sslContext, this,
 238                 new SSLSocketInputRecord(handshakeHash),
 239                 new SSLSocketOutputRecord(handshakeHash), false);
 240         this.autoClose = autoClose;
 241         doneConnect();
 242     }
 243 
 244     /**
 245      * Layer SSL traffic over an existing connection, rather than
 246      * creating a new connection.
 247      *
 248      * The existing connection may be used only for SSL traffic (using this
 249      * SSLSocket) until the SSLSocket.close() call returns. However, if a
 250      * protocol error is detected, that existing connection is automatically
 251      * closed.
 252      * &lt;p&gt;
 253      * This particular constructor always uses the socket in the
 254      * role of an SSL client. It may be useful in cases which start
 255      * using SSL after some initial data transfers, for example in some
 256      * SSL tunneling applications or as part of some kinds of application
 257      * protocols which negotiate use of a SSL based security.
 258      */
 259     SSLSocketImpl(SSLContextImpl sslContext, Socket sock,
 260             String peerHost, int port, boolean autoClose) throws IOException {
 261         super(sock);
 262         // We always layer over a connected socket
 263         if (!sock.isConnected()) {
 264             throw new SocketException(&quot;Underlying socket is not connected&quot;);
 265         }
 266 
 267         this.sslContext = sslContext;
 268         HandshakeHash handshakeHash = new HandshakeHash();
 269         this.conContext = new TransportContext(sslContext, this,
 270                 new SSLSocketInputRecord(handshakeHash),
 271                 new SSLSocketOutputRecord(handshakeHash), true);
 272         this.peerHost = peerHost;
 273         this.autoClose = autoClose;
 274         doneConnect();
 275     }
 276 
 277     @Override
 278     public void connect(SocketAddress endpoint,
 279             int timeout) throws IOException {
 280 
 281         if (isLayered()) {
 282             throw new SocketException(&quot;Already connected&quot;);
 283         }
 284 
 285         if (!(endpoint instanceof InetSocketAddress)) {
 286             throw new SocketException(
 287                     &quot;Cannot handle non-Inet socket addresses.&quot;);
 288         }
 289 
 290         super.connect(endpoint, timeout);
 291         doneConnect();
 292     }
 293 
 294     @Override
 295     public String[] getSupportedCipherSuites() {
 296         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 297     }
 298 
 299     @Override
 300     public String[] getEnabledCipherSuites() {
 301         socketLock.lock();
 302         try {
 303             return CipherSuite.namesOf(
 304                     conContext.sslConfig.enabledCipherSuites);
 305         } finally {
 306             socketLock.unlock();
 307         }
 308     }
 309 
 310     @Override
 311     public void setEnabledCipherSuites(String[] suites) {
 312         socketLock.lock();
 313         try {
 314             conContext.sslConfig.enabledCipherSuites =
 315                     CipherSuite.validValuesOf(suites);
 316         } finally {
 317             socketLock.unlock();
 318         }
 319     }
 320 
 321     @Override
 322     public String[] getSupportedProtocols() {
 323         return ProtocolVersion.toStringArray(
 324                 sslContext.getSupportedProtocolVersions());
 325     }
 326 
 327     @Override
 328     public String[] getEnabledProtocols() {
 329         socketLock.lock();
 330         try {
 331             return ProtocolVersion.toStringArray(
 332                     conContext.sslConfig.enabledProtocols);
 333         } finally {
 334             socketLock.unlock();
 335         }
 336     }
 337 
 338     @Override
 339     public void setEnabledProtocols(String[] protocols) {
 340         if (protocols == null) {
 341             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 342         }
 343 
 344         socketLock.lock();
 345         try {
 346             conContext.sslConfig.enabledProtocols =
 347                     ProtocolVersion.namesOf(protocols);
 348         } finally {
 349             socketLock.unlock();
 350         }
 351     }
 352 
 353     @Override
 354     public SSLSession getSession() {
 355         try {
 356             // start handshaking, if failed, the connection will be closed.
 357             ensureNegotiated(false);
 358         } catch (IOException ioe) {
 359             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 360                 SSLLogger.severe(&quot;handshake failed&quot;, ioe);
 361             }
 362 
 363             return new SSLSessionImpl();
 364         }
 365 
 366         return conContext.conSession;
 367     }
 368 
 369     @Override
 370     public SSLSession getHandshakeSession() {
 371         socketLock.lock();
 372         try {
 373             return conContext.handshakeContext == null ?
 374                     null : conContext.handshakeContext.handshakeSession;
 375         } finally {
 376             socketLock.unlock();
 377         }
 378     }
 379 
 380     @Override
 381     public void addHandshakeCompletedListener(
 382             HandshakeCompletedListener listener) {
 383         if (listener == null) {
 384             throw new IllegalArgumentException(&quot;listener is null&quot;);
 385         }
 386 
 387         socketLock.lock();
 388         try {
 389             conContext.sslConfig.addHandshakeCompletedListener(listener);
 390         } finally {
 391             socketLock.unlock();
 392         }
 393     }
 394 
 395     @Override
 396     public void removeHandshakeCompletedListener(
 397             HandshakeCompletedListener listener) {
 398         if (listener == null) {
 399             throw new IllegalArgumentException(&quot;listener is null&quot;);
 400         }
 401 
 402         socketLock.lock();
 403         try {
 404             conContext.sslConfig.removeHandshakeCompletedListener(listener);
 405         } finally {
 406             socketLock.unlock();
 407         }
 408     }
 409 
 410     @Override
 411     public void startHandshake() throws IOException {
 412         startHandshake(true);
 413     }
 414 
 415     private void startHandshake(boolean resumable) throws IOException {
 416         if (!isConnected) {
 417             throw new SocketException(&quot;Socket is not connected&quot;);
 418         }
 419 
 420         if (conContext.isBroken || conContext.isInboundClosed() ||
 421                 conContext.isOutboundClosed()) {
 422             throw new SocketException(&quot;Socket has been closed or broken&quot;);
 423         }
 424 
 425         handshakeLock.lock();
 426         try {
 427             // double check the context status
 428             if (conContext.isBroken || conContext.isInboundClosed() ||
 429                     conContext.isOutboundClosed()) {
 430                 throw new SocketException(&quot;Socket has been closed or broken&quot;);
 431             }
 432 
 433             try {
 434                 conContext.kickstart();
 435 
 436                 // All initial handshaking goes through this operation until we
 437                 // have a valid SSL connection.
 438                 //
 439                 // Handle handshake messages only, need no application data.
 440                 if (!conContext.isNegotiated) {
 441                     readHandshakeRecord();
 442                 }
 443             } catch (InterruptedIOException iioe) {
 444                 if(resumable){
 445                     handleException(iioe);
 446                 } else{
 447                     throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 448                             &quot;Couldn&#39;t kickstart handshaking&quot;, iioe);
 449                 }
 450             } catch (IOException ioe) {
 451                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 452                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 453             } catch (Exception oe) {    // including RuntimeException
 454                 handleException(oe);
 455             }
 456         } finally {
 457             handshakeLock.unlock();
 458         }
 459     }
 460 
 461     @Override
 462     public void setUseClientMode(boolean mode) {
 463         socketLock.lock();
 464         try {
 465             conContext.setUseClientMode(mode);
 466         } finally {
 467             socketLock.unlock();
 468         }
 469     }
 470 
 471     @Override
 472     public boolean getUseClientMode() {
 473         socketLock.lock();
 474         try {
 475             return conContext.sslConfig.isClientMode;
 476         } finally {
 477             socketLock.unlock();
 478         }
 479     }
 480 
 481     @Override
 482     public void setNeedClientAuth(boolean need) {
 483         socketLock.lock();
 484         try {
 485             conContext.sslConfig.clientAuthType =
 486                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :
 487                             ClientAuthType.CLIENT_AUTH_NONE);
 488         } finally {
 489             socketLock.unlock();
 490         }
 491     }
 492 
 493     @Override
 494     public boolean getNeedClientAuth() {
 495         socketLock.lock();
 496         try {
 497             return (conContext.sslConfig.clientAuthType ==
 498                         ClientAuthType.CLIENT_AUTH_REQUIRED);
 499         } finally {
 500             socketLock.unlock();
 501         }
 502     }
 503 
 504     @Override
 505     public void setWantClientAuth(boolean want) {
 506         socketLock.lock();
 507         try {
 508             conContext.sslConfig.clientAuthType =
 509                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :
 510                             ClientAuthType.CLIENT_AUTH_NONE);
 511         } finally {
 512             socketLock.unlock();
 513         }
 514     }
 515 
 516     @Override
 517     public boolean getWantClientAuth() {
 518         socketLock.lock();
 519         try {
 520             return (conContext.sslConfig.clientAuthType ==
 521                         ClientAuthType.CLIENT_AUTH_REQUESTED);
 522         } finally {
 523             socketLock.unlock();
 524         }
 525     }
 526 
 527     @Override
 528     public void setEnableSessionCreation(boolean flag) {
 529         socketLock.lock();
 530         try {
 531             conContext.sslConfig.enableSessionCreation = flag;
 532         } finally {
 533             socketLock.unlock();
 534         }
 535     }
 536 
 537     @Override
 538     public boolean getEnableSessionCreation() {
 539         socketLock.lock();
 540         try {
 541             return conContext.sslConfig.enableSessionCreation;
 542         } finally {
 543             socketLock.unlock();
 544         }
 545     }
 546 
 547     @Override
 548     public boolean isClosed() {
 549         return tlsIsClosed;
 550     }
 551 
 552     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 553     // locks may be deadlocked.
 554     @Override
 555     public void close() throws IOException {
 556         if (tlsIsClosed) {
 557             return;
 558         }
 559 
 560         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 561             SSLLogger.fine(&quot;duplex close of SSLSocket&quot;);
 562         }
 563 
 564         try {
 565             // shutdown output bound, which may have been closed previously.
 566             if (!isOutputShutdown()) {
 567                 duplexCloseOutput();
 568             }
 569 
 570             // shutdown input bound, which may have been closed previously.
 571             if (!isInputShutdown()) {
 572                 duplexCloseInput();
 573             }
 574 
 575             if (!isClosed()) {
 576                 // close the connection directly
 577                 closeSocket(false);
 578             }
 579         } catch (IOException ioe) {
 580             // ignore the exception
 581             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 582                 SSLLogger.warning(&quot;SSLSocket duplex close failed&quot;, ioe);
 583             }
 584         } finally {
 585             tlsIsClosed = true;
 586         }
 587     }
 588 
 589     /**
 590      * Duplex close, start from closing outbound.
 591      *
 592      * For TLS 1.2 [RFC 5246], unless some other fatal alert has been
 593      * transmitted, each party is required to send a close_notify alert
 594      * before closing the write side of the connection.  The other party
 595      * MUST respond with a close_notify alert of its own and close down
 596      * the connection immediately, discarding any pending writes.  It is
 597      * not required for the initiator of the close to wait for the responding
 598      * close_notify alert before closing the read side of the connection.
 599      *
 600      * For TLS 1.3, Each party MUST send a close_notify alert before
 601      * closing its write side of the connection, unless it has already sent
 602      * some error alert.  This does not have any effect on its read side of
 603      * the connection.  Both parties need not wait to receive a close_notify
 604      * alert before closing their read side of the connection, though doing
 605      * so would introduce the possibility of truncation.
 606      *
 607      * In order to support user initiated duplex-close for TLS 1.3 connections,
 608      * the user_canceled alert is used together with the close_notify alert.
 609      */
 610     private void duplexCloseOutput() throws IOException {
 611         boolean useUserCanceled = false;
 612         boolean hasCloseReceipt = false;
 613         if (conContext.isNegotiated) {
 614             if (!conContext.protocolVersion.useTLS13PlusSpec()) {
 615                 hasCloseReceipt = true;
 616             } else {
 617                 // Use a user_canceled alert for TLS 1.3 duplex close.
 618                 useUserCanceled = true;
 619             }
 620         } else if (conContext.handshakeContext != null) {   // initial handshake
 621             // Use user_canceled alert regardless the protocol versions.
 622             useUserCanceled = true;
 623 
 624             // The protocol version may have been negotiated.
 625             ProtocolVersion pv = conContext.handshakeContext.negotiatedProtocol;
 626             if (pv == null || (!pv.useTLS13PlusSpec())) {
 627                 hasCloseReceipt = true;
 628             }
 629         }
 630 
 631         // Deliver the user_canceled alert and the close notify alert.
 632         closeNotify(useUserCanceled);
 633 
 634         if (!isInputShutdown()) {
 635             bruteForceCloseInput(hasCloseReceipt);
 636         }
 637     }
 638 
 639     void closeNotify(boolean useUserCanceled) throws IOException {
 640         // Need a lock here so that the user_canceled alert and the
 641         // close_notify alert can be delivered together.
 642         int linger = getSoLinger();
 643         if (linger &gt;= 0) {
 644             // don&#39;t wait more than SO_LINGER for obtaining the
 645             // the lock.
 646             //
 647             // keep and clear the current thread interruption status.
 648             boolean interrupted = Thread.interrupted();
 649             try {
 650                 if (conContext.outputRecord.recordLock.tryLock() ||
 651                         conContext.outputRecord.recordLock.tryLock(
 652                                 linger, TimeUnit.SECONDS)) {
 653                     try {
 654                         deliverClosedNotify(useUserCanceled);
 655                     } finally {
 656                         conContext.outputRecord.recordLock.unlock();
 657                     }
 658                 } else {
 659                     // For layered, non-autoclose sockets, we are not
 660                     // able to bring them into a usable state, so we
 661                     // treat it as fatal error.
 662                     if (!super.isOutputShutdown()) {
 663                         if (isLayered() &amp;&amp; !autoClose) {
 664                             throw new SSLException(
 665                                     &quot;SO_LINGER timeout, &quot; +
 666                                     &quot;close_notify message cannot be sent.&quot;);
 667                         } else {
 668                             super.shutdownOutput();
 669                             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 670                                 SSLLogger.warning(
 671                                     &quot;SSLSocket output duplex close failed: &quot; +
 672                                     &quot;SO_LINGER timeout, &quot; +
 673                                     &quot;close_notify message cannot be sent.&quot;);
 674                             }
 675                         }
 676                     }
 677 
 678                     // RFC2246 requires that the session becomes
 679                     // unresumable if any connection is terminated
 680                     // without proper close_notify messages with
 681                     // level equal to warning.
 682                     //
 683                     // RFC4346 no longer requires that a session not be
 684                     // resumed if failure to properly close a connection.
 685                     //
 686                     // We choose to make the session unresumable if
 687                     // failed to send the close_notify message.
 688                     //
 689                     conContext.conSession.invalidate();
 690                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 691                         SSLLogger.warning(
 692                                 &quot;Invalidate the session: SO_LINGER timeout, &quot; +
 693                                 &quot;close_notify message cannot be sent.&quot;);
 694                     }
 695                 }
 696             } catch (InterruptedException ex) {
 697                 // keep interrupted status
 698                 interrupted = true;
 699             }
 700 
 701             // restore the interrupted status
 702             if (interrupted) {
 703                 Thread.currentThread().interrupt();
 704             }
 705         } else {
 706             conContext.outputRecord.recordLock.lock();
 707             try {
 708                 deliverClosedNotify(useUserCanceled);
 709             } finally {
 710                 conContext.outputRecord.recordLock.unlock();
 711             }
 712         }
 713     }
 714 
 715     private void deliverClosedNotify(
 716             boolean useUserCanceled) throws IOException {
 717         try {
 718             // send a user_canceled alert if needed.
 719             if (useUserCanceled) {
 720                 conContext.warning(Alert.USER_CANCELED);
 721             }
 722 
 723             // send a close_notify alert
 724             conContext.warning(Alert.CLOSE_NOTIFY);
 725         } finally {
 726             if (!conContext.isOutboundClosed()) {
 727                 conContext.outputRecord.close();
 728             }
 729 
 730             if (!super.isOutputShutdown() &amp;&amp;
 731                     (autoClose || !isLayered())) {
 732                 super.shutdownOutput();
 733             }
 734         }
 735     }
 736 
 737     /**
 738      * Duplex close, start from closing inbound.
 739      *
 740      * This method should only be called when the outbound has been closed,
 741      * but the inbound is still open.
 742      */
 743     private void duplexCloseInput() throws IOException {
 744         boolean hasCloseReceipt = false;
 745         if (conContext.isNegotiated &amp;&amp;
 746                 !conContext.protocolVersion.useTLS13PlusSpec()) {
 747             hasCloseReceipt = true;
 748         }   // No close receipt if handshake has no completed.
 749 
 750         bruteForceCloseInput(hasCloseReceipt);
 751     }
 752 
 753     /**
 754      * Brute force close the input bound.
 755      *
 756      * This method should only be called when the outbound has been closed,
 757      * but the inbound is still open.
 758      */
 759     private void bruteForceCloseInput(
 760             boolean hasCloseReceipt) throws IOException {
 761         if (hasCloseReceipt) {
 762             // It is not required for the initiator of the close to wait for
 763             // the responding close_notify alert before closing the read side
 764             // of the connection.  However, if the application protocol using
 765             // TLS provides that any data may be carried over the underlying
 766             // transport after the TLS connection is closed, the TLS
 767             // implementation MUST receive a &quot;close_notify&quot; alert before
 768             // indicating end-of-data to the application-layer.
 769             try {
 770                 this.shutdown();
 771             } finally {
 772                 if (!isInputShutdown()) {
 773                     shutdownInput(false);
 774                 }
 775             }
 776         } else {
 777             if (!conContext.isInboundClosed()) {
 778                 try (conContext.inputRecord) {
 779                     // Try the best to use up the input records and close the
 780                     // socket gracefully, without impact the performance too
 781                     // much.
 782                     appInput.deplete();
 783                 }
 784             }
 785 
 786             if ((autoClose || !isLayered()) &amp;&amp; !super.isInputShutdown()) {
 787                 super.shutdownInput();
 788             }
 789         }
 790     }
 791 
 792     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 793     // locks may be deadlocked.
 794     @Override
 795     public void shutdownInput() throws IOException {
 796         shutdownInput(true);
 797     }
 798 
 799     // It is not required to check the close_notify receipt unless an
 800     // application call shutdownInput() explicitly.
 801     private void shutdownInput(
 802             boolean checkCloseNotify) throws IOException {
 803         if (isInputShutdown()) {
 804             return;
 805         }
 806 
 807         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 808             SSLLogger.fine(&quot;close inbound of SSLSocket&quot;);
 809         }
 810 
 811         // Is it ready to close inbound?
 812         //
 813         // No need to throw exception if the initial handshake is not started.
 814         if (checkCloseNotify &amp;&amp; !conContext.isInputCloseNotified &amp;&amp;
 815             (conContext.isNegotiated || conContext.handshakeContext != null)) {
 816 
 817             throw conContext.fatal(Alert.INTERNAL_ERROR,
 818                     &quot;closing inbound before receiving peer&#39;s close_notify&quot;);
 819         }
 820 
 821         conContext.closeInbound();
 822         if ((autoClose || !isLayered()) &amp;&amp; !super.isInputShutdown()) {
 823             super.shutdownInput();
 824         }
 825     }
 826 
 827     @Override
 828     public boolean isInputShutdown() {
 829         return conContext.isInboundClosed() &amp;&amp;
 830                 ((autoClose || !isLayered()) ? super.isInputShutdown(): true);
 831     }
 832 
 833     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 834     // locks may be deadlocked.
 835     @Override
 836     public void shutdownOutput() throws IOException {
 837         if (isOutputShutdown()) {
 838             return;
 839         }
 840 
 841         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 842             SSLLogger.fine(&quot;close outbound of SSLSocket&quot;);
 843         }
 844         conContext.closeOutbound();
 845 
 846         if ((autoClose || !isLayered()) &amp;&amp; !super.isOutputShutdown()) {
 847             super.shutdownOutput();
 848         }
 849     }
 850 
 851     @Override
 852     public boolean isOutputShutdown() {
 853         return conContext.isOutboundClosed() &amp;&amp;
 854                 ((autoClose || !isLayered()) ? super.isOutputShutdown(): true);
 855     }
 856 
 857     @Override
 858     public InputStream getInputStream() throws IOException {
 859         socketLock.lock();
 860         try {
 861             if (isClosed()) {
 862                 throw new SocketException(&quot;Socket is closed&quot;);
 863             }
 864 
 865             if (!isConnected) {
 866                 throw new SocketException(&quot;Socket is not connected&quot;);
 867             }
 868 
 869             if (conContext.isInboundClosed() || isInputShutdown()) {
 870                 throw new SocketException(&quot;Socket input is already shutdown&quot;);
 871             }
 872 
 873             return appInput;
 874         } finally {
 875             socketLock.unlock();
 876         }
 877     }
 878 
 879     private void ensureNegotiated(boolean resumable) throws IOException {
 880         if (conContext.isNegotiated || conContext.isBroken ||
 881                 conContext.isInboundClosed() || conContext.isOutboundClosed()) {
 882             return;
 883         }
 884 
 885         handshakeLock.lock();
 886         try {
 887             // double check the context status
 888             if (conContext.isNegotiated || conContext.isBroken ||
 889                     conContext.isInboundClosed() ||
 890                     conContext.isOutboundClosed()) {
 891                 return;
 892             }
 893 
 894             startHandshake(resumable);
 895         } finally {
 896             handshakeLock.unlock();
 897         }
 898     }
 899 
 900     /**
 901      * InputStream for application data as returned by
 902      * SSLSocket.getInputStream().
 903      */
 904     private class AppInputStream extends InputStream {
 905         // One element array used to implement the single byte read() method
 906         private final byte[] oneByte = new byte[1];
 907 
 908         // the temporary buffer used to read network
 909         private ByteBuffer buffer;
 910 
 911         // Is application data available in the stream?
 912         private volatile boolean appDataIsAvailable;
 913 
 914         // reading lock
 915         private final ReentrantLock readLock = new ReentrantLock();
 916 
 917         // closing status
 918         private volatile boolean isClosing;
 919         private volatile boolean hasDepleted;
 920 
 921         AppInputStream() {
 922             this.appDataIsAvailable = false;
 923             this.buffer = ByteBuffer.allocate(4096);
 924         }
 925 
 926         /**
 927          * Return the minimum number of bytes that can be read
 928          * without blocking.
 929          */
 930         @Override
 931         public int available() throws IOException {
 932             // Currently not synchronized.
 933             if ((!appDataIsAvailable) || checkEOF()) {
 934                 return 0;
 935             }
 936 
 937             return buffer.remaining();
 938         }
 939 
 940         /**
 941          * Read a single byte, returning -1 on non-fault EOF status.
 942          */
 943         @Override
 944         public int read() throws IOException {
 945             int n = read(oneByte, 0, 1);
 946             if (n &lt;= 0) {   // EOF
 947                 return -1;
 948             }
 949 
 950             return oneByte[0] &amp; 0xFF;
 951         }
 952 
 953         /**
 954          * Reads up to {@code len} bytes of data from the input stream
 955          * into an array of bytes.
 956          *
 957          * An attempt is made to read as many as {@code len} bytes, but a
 958          * smaller number may be read. The number of bytes actually read
 959          * is returned as an integer.
 960          *
 961          * If the layer above needs more data, it asks for more, so we
 962          * are responsible only for blocking to fill at most one buffer,
 963          * and returning &quot;-1&quot; on non-fault EOF status.
 964          */
 965         @Override
 966         public int read(byte[] b, int off, int len) throws IOException {
 967             if (b == null) {
 968                 throw new NullPointerException(&quot;the target buffer is null&quot;);
 969             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
 970                 throw new IndexOutOfBoundsException(
 971                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
 972                         &quot;, bytes to read:&quot; + len);
 973             } else if (len == 0) {
 974                 return 0;
 975             }
 976 
 977             if (checkEOF()) {
 978                 return -1;
 979             }
 980 
 981             // start handshaking if the connection has not been negotiated.
 982             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 983                     !conContext.isInboundClosed() &amp;&amp;
 984                     !conContext.isOutboundClosed()) {
 985                 ensureNegotiated(true);
 986             }
 987 
 988             // Check if the Socket is invalid (error or closed).
 989             if (!conContext.isNegotiated ||
 990                     conContext.isBroken || conContext.isInboundClosed()) {
 991                 throw new SocketException(&quot;Connection or inbound has closed&quot;);
 992             }
 993 
 994             // Check if the input stream has been depleted.
 995             //
 996             // Note that the &quot;hasDepleted&quot; rather than the isClosing
 997             // filed is checked here, in case the closing process is
 998             // still in progress.
 999             if (hasDepleted) {
1000                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1001                     SSLLogger.fine(&quot;The input stream has been depleted&quot;);
1002                 }
1003 
1004                 return -1;
1005             }
1006 
1007             // Read the available bytes at first.
1008             //
1009             // Note that the receiving and processing of post-handshake message
1010             // are also synchronized with the read lock.
1011             readLock.lock();
1012             try {
1013                 // Double check if the Socket is invalid (error or closed).
1014                 if (conContext.isBroken || conContext.isInboundClosed()) {
1015                     throw new SocketException(
1016                             &quot;Connection or inbound has closed&quot;);
1017                 }
1018 
1019                 // Double check if the input stream has been depleted.
1020                 if (hasDepleted) {
1021                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1022                         SSLLogger.fine(&quot;The input stream is closing&quot;);
1023                     }
1024 
1025                     return -1;
1026                 }
1027 
1028                 int remains = available();
1029                 if (remains &gt; 0) {
1030                     int howmany = Math.min(remains, len);
1031                     buffer.get(b, off, howmany);
1032 
1033                     return howmany;
1034                 }
1035 
1036                 appDataIsAvailable = false;
1037                 try {
1038                     ByteBuffer bb = readApplicationRecord(buffer);
1039                     if (bb == null) {   // EOF
1040                         return -1;
1041                     } else {
1042                         // The buffer may be reallocated for bigger capacity.
1043                         buffer = bb;
1044                     }
1045 
1046                     bb.flip();
1047                     int volume = Math.min(len, bb.remaining());
1048                     buffer.get(b, off, volume);
1049                     appDataIsAvailable = true;
1050 
1051                     return volume;
1052                 } catch (Exception e) {   // including RuntimeException
1053                     // shutdown and rethrow (wrapped) exception as appropriate
1054                     handleException(e);
1055 
1056                     // dummy for compiler
1057                     return -1;
1058                 }
1059             } finally {
1060                 // Check if the input stream is closing.
1061                 //
1062                 // If the deplete() did not hold the lock, clean up the
1063                 // input stream here.
1064                 try {
1065                     if (isClosing) {
1066                         readLockedDeplete();
1067                     }
1068                 } finally {
1069                     readLock.unlock();
1070                 }
1071             }
1072         }
1073 
1074         /**
1075          * Skip n bytes.
1076          *
1077          * This implementation is somewhat less efficient than possible, but
1078          * not badly so (redundant copy).  We reuse the read() code to keep
1079          * things simpler.
1080          */
1081         @Override
1082         public long skip(long n) throws IOException {
1083             // dummy array used to implement skip()
1084             byte[] skipArray = new byte[256];
1085             long skipped = 0;
1086 
1087             readLock.lock();
1088             try {
1089                 while (n &gt; 0) {
1090                     int len = (int)Math.min(n, skipArray.length);
1091                     int r = read(skipArray, 0, len);
1092                     if (r &lt;= 0) {
1093                         break;
1094                     }
1095                     n -= r;
1096                     skipped += r;
1097                 }
1098             } finally {
1099                 readLock.unlock();
1100             }
1101 
1102             return skipped;
1103         }
1104 
1105         @Override
1106         public void close() throws IOException {
1107             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1108                 SSLLogger.finest(&quot;Closing input stream&quot;);
1109             }
1110 
1111             try {
1112                 SSLSocketImpl.this.close();
1113             } catch (IOException ioe) {
1114                 // ignore the exception
1115                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1116                     SSLLogger.warning(&quot;input stream close failed&quot;, ioe);
1117                 }
1118             }
1119         }
1120 
1121         /**
1122          * Return whether we have reached end-of-file.
1123          *
1124          * If the socket is not connected, has been shutdown because of an error
1125          * or has been closed, throw an Exception.
1126          */
1127         private boolean checkEOF() throws IOException {
1128             if (conContext.isBroken) {
1129                 if (conContext.closeReason == null) {
1130                     return true;
1131                 } else {
1132                     throw new SSLException(
1133                             &quot;Connection has closed: &quot; + conContext.closeReason,
1134                             conContext.closeReason);
1135                 }
1136             } else if (conContext.isInboundClosed()) {
1137                 return true;
1138             } else if (conContext.isInputCloseNotified) {
1139                 if (conContext.closeReason == null) {
1140                     return true;
1141                 } else {
1142                     throw new SSLException(
1143                         &quot;Connection has closed: &quot; + conContext.closeReason,
1144                         conContext.closeReason);
1145                 }
1146             }
1147 
1148             return false;
1149         }
1150 
1151         /**
1152          * Try the best to use up the input records so as to close the
1153          * socket gracefully, without impact the performance too much.
1154          */
1155         private void deplete() {
1156             if (conContext.isInboundClosed() || isClosing) {
1157                 return;
1158             }
1159 
1160             isClosing = true;
1161             if (readLock.tryLock()) {
1162                 try {
1163                     readLockedDeplete();
1164                 } finally {
1165                     readLock.unlock();
1166                 }
1167             }
1168         }
1169 
1170         /**
1171          * Try to use up the input records.
1172          *
1173          * Please don&#39;t call this method unless the readLock is held by
1174          * the current thread.
1175          */
1176         private void readLockedDeplete() {
1177             // double check
1178             if (hasDepleted || conContext.isInboundClosed()) {
1179                 return;
1180             }
1181 
1182             if (!(conContext.inputRecord instanceof SSLSocketInputRecord)) {
1183                 return;
1184             }
1185 
1186             SSLSocketInputRecord socketInputRecord =
1187                     (SSLSocketInputRecord)conContext.inputRecord;
1188             try {
1189                 socketInputRecord.deplete(
1190                     conContext.isNegotiated &amp;&amp; (getSoTimeout() &gt; 0));
1191             } catch (Exception ex) {
1192                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1193                     SSLLogger.warning(
1194                         &quot;input stream close depletion failed&quot;, ex);
1195                 }
1196             } finally {
1197                 hasDepleted = true;
1198             }
1199         }
1200     }
1201 
1202     @Override
1203     public OutputStream getOutputStream() throws IOException {
1204         socketLock.lock();
1205         try {
1206             if (isClosed()) {
1207                 throw new SocketException(&quot;Socket is closed&quot;);
1208             }
1209 
1210             if (!isConnected) {
1211                 throw new SocketException(&quot;Socket is not connected&quot;);
1212             }
1213 
1214             if (conContext.isOutboundDone() || isOutputShutdown()) {
1215                 throw new SocketException(&quot;Socket output is already shutdown&quot;);
1216             }
1217 
1218             return appOutput;
1219         } finally {
1220             socketLock.unlock();
1221         }
1222     }
1223 
1224 
1225     /**
1226      * OutputStream for application data as returned by
1227      * SSLSocket.getOutputStream().
1228      */
1229     private class AppOutputStream extends OutputStream {
1230         // One element array used to implement the write(byte) method
1231         private final byte[] oneByte = new byte[1];
1232 
1233         @Override
1234         public void write(int i) throws IOException {
1235             oneByte[0] = (byte)i;
1236             write(oneByte, 0, 1);
1237         }
1238 
1239         @Override
1240         public void write(byte[] b,
1241                 int off, int len) throws IOException {
1242             if (b == null) {
1243                 throw new NullPointerException(&quot;the source buffer is null&quot;);
1244             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
1245                 throw new IndexOutOfBoundsException(
1246                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
1247                         &quot;, bytes to read:&quot; + len);
1248             } else if (len == 0) {
1249                 //
1250                 // Don&#39;t bother to really write empty records.  We went this
1251                 // far to drive the handshake machinery, for correctness; not
1252                 // writing empty records improves performance by cutting CPU
1253                 // time and network resource usage.  However, some protocol
1254                 // implementations are fragile and don&#39;t like to see empty
1255                 // records, so this also increases robustness.
1256                 //
1257                 return;
1258             }
1259 
1260             // Start handshaking if the connection has not been negotiated.
1261             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
1262                     !conContext.isInboundClosed() &amp;&amp;
1263                     !conContext.isOutboundClosed()) {
1264                 ensureNegotiated(true);
1265             }
1266 
1267             // Check if the Socket is invalid (error or closed).
1268             if (!conContext.isNegotiated ||
1269                     conContext.isBroken || conContext.isOutboundClosed()) {
1270                 throw new SocketException(&quot;Connection or outbound has closed&quot;);
1271             }
1272 
1273             //
1274 
1275             // Delegate the writing to the underlying socket.
1276             try {
1277                 conContext.outputRecord.deliver(b, off, len);
1278             } catch (SSLHandshakeException she) {
1279                 // may be record sequence number overflow
1280                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
1281             } catch (SSLException ssle) {
1282                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, ssle);
1283             }   // re-throw other IOException, which should be caused by
1284                 // the underlying plain socket and could be handled by
1285                 // applications (for example, re-try the connection).
1286 
1287             // Is the sequence number is nearly overflow, or has the key usage
1288             // limit been reached?
1289             if (conContext.outputRecord.seqNumIsHuge() ||
1290                     conContext.outputRecord.writeCipher.atKeyLimit()) {
1291                 tryKeyUpdate();
1292             }
1293             // Check if NewSessionTicket PostHandshake message needs to be sent
1294             if (conContext.conSession.updateNST) {
1295                 conContext.conSession.updateNST = false;
1296                 tryNewSessionTicket();
1297             }
1298         }
1299 
1300         @Override
1301         public void close() throws IOException {
1302             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1303                 SSLLogger.finest(&quot;Closing output stream&quot;);
1304             }
1305 
1306             try {
1307                 SSLSocketImpl.this.close();
1308             } catch (IOException ioe) {
1309                 // ignore the exception
1310                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1311                     SSLLogger.warning(&quot;output stream close failed&quot;, ioe);
1312                 }
1313             }
1314         }
1315     }
1316 
1317     @Override
1318     public SSLParameters getSSLParameters() {
1319         socketLock.lock();
1320         try {
1321             return conContext.sslConfig.getSSLParameters();
1322         } finally {
1323             socketLock.unlock();
1324         }
1325     }
1326 
1327     @Override
1328     public void setSSLParameters(SSLParameters params) {
1329         socketLock.lock();
1330         try {
1331             conContext.sslConfig.setSSLParameters(params);
1332 
1333             if (conContext.sslConfig.maximumPacketSize != 0) {
1334                 conContext.outputRecord.changePacketSize(
1335                         conContext.sslConfig.maximumPacketSize);
1336             }
1337         } finally {
1338             socketLock.unlock();
1339         }
1340     }
1341 
1342     @Override
1343     public String getApplicationProtocol() {
1344         socketLock.lock();
1345         try {
1346             return conContext.applicationProtocol;
1347         } finally {
1348             socketLock.unlock();
1349         }
1350     }
1351 
1352     @Override
1353     public String getHandshakeApplicationProtocol() {
1354         socketLock.lock();
1355         try {
1356             if (conContext.handshakeContext != null) {
1357                 return conContext.handshakeContext.applicationProtocol;
1358             }
1359         } finally {
1360             socketLock.unlock();
1361         }
1362 
1363         return null;
1364     }
1365 
1366     @Override
1367     public void setHandshakeApplicationProtocolSelector(
1368             BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; selector) {
1369         socketLock.lock();
1370         try {
1371             conContext.sslConfig.socketAPSelector = selector;
1372         } finally {
1373             socketLock.unlock();
1374         }
1375     }
1376 
1377     @Override
1378     public BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt;
1379             getHandshakeApplicationProtocolSelector() {
1380         socketLock.lock();
1381         try {
1382             return conContext.sslConfig.socketAPSelector;
1383         } finally {
1384             socketLock.unlock();
1385         }
1386     }
1387 
1388     /**
1389      * Read the initial handshake records.
1390      */
1391     private int readHandshakeRecord() throws IOException {
1392         while (!conContext.isInboundClosed()) {
1393             try {
1394                 Plaintext plainText = decode(null);
1395                 if ((plainText.contentType == ContentType.HANDSHAKE.id) &amp;&amp;
1396                         conContext.isNegotiated) {
1397                     return 0;
1398                 }
1399             } catch (SSLException ssle) {
1400                 throw ssle;
1401             } catch (InterruptedIOException iioe) {
1402                 // don&#39;t change exception in case of timeouts or interrupts
1403                 throw iioe;
1404             } catch (IOException ioe) {
1405                 throw new SSLException(&quot;readHandshakeRecord&quot;, ioe);
1406             }
1407         }
1408 
1409         return -1;
1410     }
1411 
1412     /**
1413      * Read application data record. Used by AppInputStream only, but defined
1414      * here so as to use the socket level synchronization.
1415      *
1416      * Note that the connection guarantees that handshake, alert, and change
1417      * cipher spec data streams are handled as they arrive, so we never see
1418      * them here.
1419      *
1420      * Note: Please be careful about the synchronization, and don&#39;t use this
1421      * method other than in the AppInputStream class!
1422      */
1423     private ByteBuffer readApplicationRecord(
1424             ByteBuffer buffer) throws IOException {
1425         while (!conContext.isInboundClosed()) {
1426             /*
1427              * clean the buffer and check if it is too small, e.g. because
1428              * the AppInputStream did not have the chance to see the
1429              * current packet length but rather something like that of the
1430              * handshake before. In that case we return 0 at this point to
1431              * give the caller the chance to adjust the buffer.
1432              */
1433             buffer.clear();
1434             int inLen = conContext.inputRecord.bytesInCompletePacket();
1435             if (inLen &lt; 0) {    // EOF
1436                 handleEOF(null);
1437 
1438                 // if no exception thrown
1439                 return null;
1440             }
1441 
1442             // Is this packet bigger than SSL/TLS normally allows?
1443             if (inLen &gt; SSLRecord.maxLargeRecordSize) {
1444                 throw new SSLProtocolException(
1445                         &quot;Illegal packet size: &quot; + inLen);
1446             }
1447 
1448             if (inLen &gt; buffer.remaining()) {
1449                 buffer = ByteBuffer.allocate(inLen);
1450             }
1451 
1452             try {
1453                 Plaintext plainText;
1454                 socketLock.lock();
1455                 try {
1456                     plainText = decode(buffer);
1457                 } finally {
1458                     socketLock.unlock();
1459                 }
1460                 if (plainText.contentType == ContentType.APPLICATION_DATA.id &amp;&amp;
1461                         buffer.position() &gt; 0) {
1462                     return buffer;
1463                 }
1464             } catch (SSLException ssle) {
1465                 throw ssle;
1466             } catch (InterruptedIOException iioe) {
1467                 // don&#39;t change exception in case of timeouts or interrupts
1468                 throw iioe;
1469             } catch (IOException ioe) {
1470                 if (!(ioe instanceof SSLException)) {
1471                     throw new SSLException(&quot;readApplicationRecord&quot;, ioe);
1472                 } else {
1473                     throw ioe;
1474                 }
1475             }
1476         }
1477 
1478         //
1479         // couldn&#39;t read, due to some kind of error
1480         //
1481         return null;
1482     }
1483 
1484     private Plaintext decode(ByteBuffer destination) throws IOException {
1485         Plaintext plainText;
1486         try {
1487             if (destination == null) {
1488                 plainText = SSLTransport.decode(conContext,
1489                         null, 0, 0, null, 0, 0);
1490             } else {
1491                 plainText = SSLTransport.decode(conContext,
1492                         null, 0, 0, new ByteBuffer[]{destination}, 0, 1);
1493             }
1494         } catch (EOFException eofe) {
1495             // EOFException is special as it is related to close_notify.
1496             plainText = handleEOF(eofe);
1497         }
1498 
1499         // Is the sequence number is nearly overflow?
1500         if (plainText != Plaintext.PLAINTEXT_NULL &amp;&amp;
1501                 (conContext.inputRecord.seqNumIsHuge() ||
1502                 conContext.inputRecord.readCipher.atKeyLimit())) {
1503             tryKeyUpdate();
1504         }
1505 
1506         return plainText;
1507     }
1508 
1509     /**
1510      * Try key update for sequence number wrap or key usage limit.
1511      *
1512      * Note that in order to maintain the handshake status properly, we check
1513      * the sequence number and key usage limit after the last record
1514      * reading/writing process.
1515      *
1516      * As we request renegotiation or close the connection for wrapped sequence
1517      * number when there is enough sequence number space left to handle a few
1518      * more records, so the sequence number of the last record cannot be
1519      * wrapped.
1520      */
1521     private void tryKeyUpdate() throws IOException {
1522         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
1523         // connection is not duplex-open.
1524         if ((conContext.handshakeContext == null) &amp;&amp;
1525                 !conContext.isOutboundClosed() &amp;&amp;
1526                 !conContext.isInboundClosed() &amp;&amp;
1527                 !conContext.isBroken) {
1528             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1529                 SSLLogger.finest(&quot;trigger key update&quot;);
1530             }
1531             startHandshake();
1532         }
1533     }
1534 
1535     // Try to generate a PostHandshake NewSessionTicket message.  This is
1536     // TLS 1.3 only.
1537     private void tryNewSessionTicket() throws IOException {
1538         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
1539         // connection is not duplex-open.
1540         if (!conContext.sslConfig.isClientMode &amp;&amp;
1541                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;
1542                 conContext.handshakeContext == null &amp;&amp;
1543                 !conContext.isOutboundClosed() &amp;&amp;
1544                 !conContext.isInboundClosed() &amp;&amp;
1545                 !conContext.isBroken) {
1546             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1547                 SSLLogger.finest(&quot;trigger new session ticket&quot;);
1548             }
1549             NewSessionTicket.t13PosthandshakeProducer.produce(
1550                     new PostHandshakeContext(conContext));
1551         }
1552     }
1553 
1554     /**
1555      * Initialize the handshaker and socket streams.
1556      *
1557      * Called by connect, the layered constructor, and SSLServerSocket.
1558      */
1559     void doneConnect() throws IOException {
1560         socketLock.lock();
1561         try {
1562             // In server mode, it is not necessary to set host and serverNames.
1563             // Otherwise, would require a reverse DNS lookup to get
1564             // the hostname.
1565             if (peerHost == null || peerHost.isEmpty()) {
1566                 boolean useNameService =
1567                         trustNameService &amp;&amp; conContext.sslConfig.isClientMode;
1568                 useImplicitHost(useNameService);
1569             } else {
1570                 conContext.sslConfig.serverNames =
1571                         Utilities.addToSNIServerNameList(
1572                                 conContext.sslConfig.serverNames, peerHost);
1573             }
1574 
1575             InputStream sockInput = super.getInputStream();
1576             conContext.inputRecord.setReceiverStream(sockInput);
1577 
1578             OutputStream sockOutput = super.getOutputStream();
1579             conContext.inputRecord.setDeliverStream(sockOutput);
1580             conContext.outputRecord.setDeliverStream(sockOutput);
1581 
1582             this.isConnected = true;
1583         } finally {
1584             socketLock.unlock();
1585         }
1586     }
1587 
1588     private void useImplicitHost(boolean useNameService) {
1589         // Note: If the local name service is not trustworthy, reverse
1590         // host name resolution should not be performed for endpoint
1591         // identification.  Use the application original specified
1592         // hostname or IP address instead.
1593 
1594         // Get the original hostname via jdk.internal.access.SharedSecrets
1595         InetAddress inetAddress = getInetAddress();
1596         if (inetAddress == null) {      // not connected
1597             return;
1598         }
1599 
1600         JavaNetInetAddressAccess jna =
1601                 SharedSecrets.getJavaNetInetAddressAccess();
1602         String originalHostname = jna.getOriginalHostName(inetAddress);
1603         if (originalHostname != null &amp;&amp; !originalHostname.isEmpty()) {
1604 
1605             this.peerHost = originalHostname;
1606             if (conContext.sslConfig.serverNames.isEmpty() &amp;&amp;
1607                     !conContext.sslConfig.noSniExtension) {
1608                 conContext.sslConfig.serverNames =
1609                         Utilities.addToSNIServerNameList(
1610                                 conContext.sslConfig.serverNames, peerHost);
1611             }
1612 
1613             return;
1614         }
1615 
1616         // No explicitly specified hostname, no server name indication.
1617         if (!useNameService) {
1618             // The local name service is not trustworthy, use IP address.
1619             this.peerHost = inetAddress.getHostAddress();
1620         } else {
1621             // Use the underlying reverse host name resolution service.
1622             this.peerHost = getInetAddress().getHostName();
1623         }
1624     }
1625 
1626     // ONLY used by HttpsClient to setup the URI specified hostname
1627     //
1628     // Please NOTE that this method MUST be called before calling to
1629     // SSLSocket.setSSLParameters(). Otherwise, the {@code host} parameter
1630     // may override SNIHostName in the customized server name indication.
1631     public void setHost(String host) {
1632         socketLock.lock();
1633         try {
1634             this.peerHost = host;
1635             this.conContext.sslConfig.serverNames =
1636                     Utilities.addToSNIServerNameList(
1637                             conContext.sslConfig.serverNames, host);
1638         } finally {
1639             socketLock.unlock();
1640         }
1641     }
1642 
1643     /**
1644      * Handle an exception.
1645      *
1646      * This method is called by top level exception handlers (in read(),
1647      * write()) to make sure we always shutdown the connection correctly
1648      * and do not pass runtime exception to the application.
1649      *
1650      * This method never returns normally, it always throws an IOException.
1651      */
1652     private void handleException(Exception cause) throws IOException {
1653         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1654             SSLLogger.warning(&quot;handling exception&quot;, cause);
1655         }
1656 
1657         // Don&#39;t close the Socket in case of timeouts or interrupts.
1658         if (cause instanceof InterruptedIOException) {
1659             throw (IOException)cause;
1660         }
1661 
1662         // need to perform error shutdown
1663         boolean isSSLException = (cause instanceof SSLException);
1664         Alert alert;
1665         if (isSSLException) {
1666             if (cause instanceof SSLHandshakeException) {
1667                 alert = Alert.HANDSHAKE_FAILURE;
1668             } else {
1669                 alert = Alert.UNEXPECTED_MESSAGE;
1670             }
1671         } else {
1672             if (cause instanceof IOException) {
1673                 alert = Alert.UNEXPECTED_MESSAGE;
1674             } else {
1675                 // RuntimeException
1676                 alert = Alert.INTERNAL_ERROR;
1677             }
1678         }
1679 
1680         throw conContext.fatal(alert, cause);
1681     }
1682 
1683     private Plaintext handleEOF(EOFException eofe) throws IOException {
1684         if (requireCloseNotify || conContext.handshakeContext != null) {
1685             SSLException ssle;
1686             if (conContext.handshakeContext != null) {
1687                 ssle = new SSLHandshakeException(
1688                         &quot;Remote host terminated the handshake&quot;);
1689             } else {
1690                 ssle = new SSLProtocolException(
1691                         &quot;Remote host terminated the connection&quot;);
1692             }
1693 
1694             if (eofe != null) {
1695                 ssle.initCause(eofe);
1696             }
1697             throw ssle;
1698         } else {
1699             // treat as if we had received a close_notify
1700             conContext.isInputCloseNotified = true;
1701             shutdownInput();
1702 
1703             return Plaintext.PLAINTEXT_NULL;
1704         }
1705     }
1706 
1707 
1708     @Override
1709     public String getPeerHost() {
1710         return peerHost;
1711     }
1712 
1713     @Override
1714     public int getPeerPort() {
1715         return getPort();
1716     }
1717 
1718     @Override
1719     public boolean useDelegatedTask() {
1720         return false;
1721     }
1722 
1723     @Override
1724     public void shutdown() throws IOException {
1725         if (!isClosed()) {
1726             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1727                 SSLLogger.fine(&quot;close the underlying socket&quot;);
1728             }
1729 
1730             try {
1731                 if (conContext.isInputCloseNotified) {
1732                     // Close the connection, no wait for more peer response.
1733                     closeSocket(false);
1734                 } else {
1735                     // Close the connection, may wait for peer close_notify.
1736                     closeSocket(true);
1737                 }
1738             } finally {
1739                 tlsIsClosed = true;
1740             }
1741         }
1742     }
1743 
1744     private void closeSocket(boolean selfInitiated) throws IOException {
1745         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1746             SSLLogger.fine(&quot;close the SSL connection &quot; +
1747                 (selfInitiated ? &quot;(initiative)&quot; : &quot;(passive)&quot;));
1748         }
1749 
1750         if (autoClose || !isLayered()) {
1751             super.close();
1752         } else if (selfInitiated) {
1753             if (!conContext.isInboundClosed() &amp;&amp; !isInputShutdown()) {
1754                 // wait for close_notify alert to clear input stream.
1755                 waitForClose();
1756             }
1757         }
1758     }
1759 
1760    /**
1761     * Wait for close_notify alert for a graceful closure.
1762     *
1763     * [RFC 5246] If the application protocol using TLS provides that any
1764     * data may be carried over the underlying transport after the TLS
1765     * connection is closed, the TLS implementation must receive the responding
1766     * close_notify alert before indicating to the application layer that
1767     * the TLS connection has ended.  If the application protocol will not
1768     * transfer any additional data, but will only close the underlying
1769     * transport connection, then the implementation MAY choose to close the
1770     * transport without waiting for the responding close_notify.
1771     */
1772     private void waitForClose() throws IOException {
1773         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1774             SSLLogger.fine(&quot;wait for close_notify or alert&quot;);
1775         }
1776 
1777         while (!conContext.isInboundClosed()) {
1778             try {
1779                 Plaintext plainText = decode(null);
1780                 // discard and continue
1781                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1782                     SSLLogger.finest(
1783                         &quot;discard plaintext while waiting for close&quot;, plainText);
1784                 }
1785             } catch (Exception e) {   // including RuntimeException
1786                 handleException(e);
1787             }
1788         }
1789     }
1790 }
    </pre>
  </body>
</html>
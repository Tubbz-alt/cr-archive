<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../jdk/internal/org/objectweb/asm/Opcodes.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../java.compiler/share/classes/javax/lang/model/SourceVersion.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 337 
 338     @Override
 339     public void setEnabledProtocols(String[] protocols) {
 340         if (protocols == null) {
 341             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 342         }
 343 
 344         socketLock.lock();
 345         try {
 346             conContext.sslConfig.enabledProtocols =
 347                     ProtocolVersion.namesOf(protocols);
 348         } finally {
 349             socketLock.unlock();
 350         }
 351     }
 352 
 353     @Override
 354     public SSLSession getSession() {
 355         try {
 356             // start handshaking, if failed, the connection will be closed.
<span class="line-modified"> 357             ensureNegotiated();</span>
 358         } catch (IOException ioe) {
 359             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 360                 SSLLogger.severe(&quot;handshake failed&quot;, ioe);
 361             }
 362 
 363             return new SSLSessionImpl();
 364         }
 365 
 366         return conContext.conSession;
 367     }
 368 
 369     @Override
 370     public SSLSession getHandshakeSession() {
 371         socketLock.lock();
 372         try {
 373             return conContext.handshakeContext == null ?
 374                     null : conContext.handshakeContext.handshakeSession;
 375         } finally {
 376             socketLock.unlock();
 377         }
</pre>
<hr />
<pre>
 392         }
 393     }
 394 
 395     @Override
 396     public void removeHandshakeCompletedListener(
 397             HandshakeCompletedListener listener) {
 398         if (listener == null) {
 399             throw new IllegalArgumentException(&quot;listener is null&quot;);
 400         }
 401 
 402         socketLock.lock();
 403         try {
 404             conContext.sslConfig.removeHandshakeCompletedListener(listener);
 405         } finally {
 406             socketLock.unlock();
 407         }
 408     }
 409 
 410     @Override
 411     public void startHandshake() throws IOException {




 412         if (!isConnected) {
 413             throw new SocketException(&quot;Socket is not connected&quot;);
 414         }
 415 
 416         if (conContext.isBroken || conContext.isInboundClosed() ||
 417                 conContext.isOutboundClosed()) {
 418             throw new SocketException(&quot;Socket has been closed or broken&quot;);
 419         }
 420 
 421         handshakeLock.lock();
 422         try {
 423             // double check the context status
 424             if (conContext.isBroken || conContext.isInboundClosed() ||
 425                     conContext.isOutboundClosed()) {
 426                 throw new SocketException(&quot;Socket has been closed or broken&quot;);
 427             }
 428 
 429             try {
 430                 conContext.kickstart();
 431 
 432                 // All initial handshaking goes through this operation until we
 433                 // have a valid SSL connection.
 434                 //
 435                 // Handle handshake messages only, need no application data.
 436                 if (!conContext.isNegotiated) {
 437                     readHandshakeRecord();
 438                 }
 439             } catch (InterruptedIOException iioe) {
<span class="line-modified"> 440                 handleException(iioe);</span>





 441             } catch (IOException ioe) {
 442                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 443                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 444             } catch (Exception oe) {    // including RuntimeException
 445                 handleException(oe);
 446             }
 447         } finally {
 448             handshakeLock.unlock();
 449         }
 450     }
 451 
 452     @Override
 453     public void setUseClientMode(boolean mode) {
 454         socketLock.lock();
 455         try {
 456             conContext.setUseClientMode(mode);
 457         } finally {
 458             socketLock.unlock();
 459         }
 460     }
</pre>
<hr />
<pre>
 850         socketLock.lock();
 851         try {
 852             if (isClosed()) {
 853                 throw new SocketException(&quot;Socket is closed&quot;);
 854             }
 855 
 856             if (!isConnected) {
 857                 throw new SocketException(&quot;Socket is not connected&quot;);
 858             }
 859 
 860             if (conContext.isInboundClosed() || isInputShutdown()) {
 861                 throw new SocketException(&quot;Socket input is already shutdown&quot;);
 862             }
 863 
 864             return appInput;
 865         } finally {
 866             socketLock.unlock();
 867         }
 868     }
 869 
<span class="line-modified"> 870     private void ensureNegotiated() throws IOException {</span>
 871         if (conContext.isNegotiated || conContext.isBroken ||
 872                 conContext.isInboundClosed() || conContext.isOutboundClosed()) {
 873             return;
 874         }
 875 
 876         handshakeLock.lock();
 877         try {
 878             // double check the context status
 879             if (conContext.isNegotiated || conContext.isBroken ||
 880                     conContext.isInboundClosed() ||
 881                     conContext.isOutboundClosed()) {
 882                 return;
 883             }
 884 
<span class="line-modified"> 885             startHandshake();</span>
 886         } finally {
 887             handshakeLock.unlock();
 888         }
 889     }
 890 
 891     /**
 892      * InputStream for application data as returned by
 893      * SSLSocket.getInputStream().
 894      */
 895     private class AppInputStream extends InputStream {
 896         // One element array used to implement the single byte read() method
 897         private final byte[] oneByte = new byte[1];
 898 
 899         // the temporary buffer used to read network
 900         private ByteBuffer buffer;
 901 
 902         // Is application data available in the stream?
 903         private volatile boolean appDataIsAvailable;
 904 
 905         // reading lock
</pre>
<hr />
<pre>
 956         @Override
 957         public int read(byte[] b, int off, int len) throws IOException {
 958             if (b == null) {
 959                 throw new NullPointerException(&quot;the target buffer is null&quot;);
 960             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
 961                 throw new IndexOutOfBoundsException(
 962                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
 963                         &quot;, bytes to read:&quot; + len);
 964             } else if (len == 0) {
 965                 return 0;
 966             }
 967 
 968             if (checkEOF()) {
 969                 return -1;
 970             }
 971 
 972             // start handshaking if the connection has not been negotiated.
 973             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 974                     !conContext.isInboundClosed() &amp;&amp;
 975                     !conContext.isOutboundClosed()) {
<span class="line-modified"> 976                 ensureNegotiated();</span>
 977             }
 978 
 979             // Check if the Socket is invalid (error or closed).
 980             if (!conContext.isNegotiated ||
 981                     conContext.isBroken || conContext.isInboundClosed()) {
 982                 throw new SocketException(&quot;Connection or inbound has closed&quot;);
 983             }
 984 
 985             // Check if the input stream has been depleted.
 986             //
 987             // Note that the &quot;hasDepleted&quot; rather than the isClosing
 988             // filed is checked here, in case the closing process is
 989             // still in progress.
 990             if (hasDepleted) {
 991                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 992                     SSLLogger.fine(&quot;The input stream has been depleted&quot;);
 993                 }
 994 
 995                 return -1;
 996             }
</pre>
<hr />
<pre>
1235             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
1236                 throw new IndexOutOfBoundsException(
1237                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
1238                         &quot;, bytes to read:&quot; + len);
1239             } else if (len == 0) {
1240                 //
1241                 // Don&#39;t bother to really write empty records.  We went this
1242                 // far to drive the handshake machinery, for correctness; not
1243                 // writing empty records improves performance by cutting CPU
1244                 // time and network resource usage.  However, some protocol
1245                 // implementations are fragile and don&#39;t like to see empty
1246                 // records, so this also increases robustness.
1247                 //
1248                 return;
1249             }
1250 
1251             // Start handshaking if the connection has not been negotiated.
1252             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
1253                     !conContext.isInboundClosed() &amp;&amp;
1254                     !conContext.isOutboundClosed()) {
<span class="line-modified">1255                 ensureNegotiated();</span>
1256             }
1257 
1258             // Check if the Socket is invalid (error or closed).
1259             if (!conContext.isNegotiated ||
1260                     conContext.isBroken || conContext.isOutboundClosed()) {
1261                 throw new SocketException(&quot;Connection or outbound has closed&quot;);
1262             }
1263 
1264             //
1265 
1266             // Delegate the writing to the underlying socket.
1267             try {
1268                 conContext.outputRecord.deliver(b, off, len);
1269             } catch (SSLHandshakeException she) {
1270                 // may be record sequence number overflow
1271                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
1272             } catch (SSLException ssle) {
1273                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, ssle);
1274             }   // re-throw other IOException, which should be caused by
1275                 // the underlying plain socket and could be handled by
</pre>
</td>
<td>
<hr />
<pre>
 337 
 338     @Override
 339     public void setEnabledProtocols(String[] protocols) {
 340         if (protocols == null) {
 341             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 342         }
 343 
 344         socketLock.lock();
 345         try {
 346             conContext.sslConfig.enabledProtocols =
 347                     ProtocolVersion.namesOf(protocols);
 348         } finally {
 349             socketLock.unlock();
 350         }
 351     }
 352 
 353     @Override
 354     public SSLSession getSession() {
 355         try {
 356             // start handshaking, if failed, the connection will be closed.
<span class="line-modified"> 357             ensureNegotiated(false);</span>
 358         } catch (IOException ioe) {
 359             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 360                 SSLLogger.severe(&quot;handshake failed&quot;, ioe);
 361             }
 362 
 363             return new SSLSessionImpl();
 364         }
 365 
 366         return conContext.conSession;
 367     }
 368 
 369     @Override
 370     public SSLSession getHandshakeSession() {
 371         socketLock.lock();
 372         try {
 373             return conContext.handshakeContext == null ?
 374                     null : conContext.handshakeContext.handshakeSession;
 375         } finally {
 376             socketLock.unlock();
 377         }
</pre>
<hr />
<pre>
 392         }
 393     }
 394 
 395     @Override
 396     public void removeHandshakeCompletedListener(
 397             HandshakeCompletedListener listener) {
 398         if (listener == null) {
 399             throw new IllegalArgumentException(&quot;listener is null&quot;);
 400         }
 401 
 402         socketLock.lock();
 403         try {
 404             conContext.sslConfig.removeHandshakeCompletedListener(listener);
 405         } finally {
 406             socketLock.unlock();
 407         }
 408     }
 409 
 410     @Override
 411     public void startHandshake() throws IOException {
<span class="line-added"> 412         startHandshake(true);</span>
<span class="line-added"> 413     }</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415     private void startHandshake(boolean resumable) throws IOException {</span>
 416         if (!isConnected) {
 417             throw new SocketException(&quot;Socket is not connected&quot;);
 418         }
 419 
 420         if (conContext.isBroken || conContext.isInboundClosed() ||
 421                 conContext.isOutboundClosed()) {
 422             throw new SocketException(&quot;Socket has been closed or broken&quot;);
 423         }
 424 
 425         handshakeLock.lock();
 426         try {
 427             // double check the context status
 428             if (conContext.isBroken || conContext.isInboundClosed() ||
 429                     conContext.isOutboundClosed()) {
 430                 throw new SocketException(&quot;Socket has been closed or broken&quot;);
 431             }
 432 
 433             try {
 434                 conContext.kickstart();
 435 
 436                 // All initial handshaking goes through this operation until we
 437                 // have a valid SSL connection.
 438                 //
 439                 // Handle handshake messages only, need no application data.
 440                 if (!conContext.isNegotiated) {
 441                     readHandshakeRecord();
 442                 }
 443             } catch (InterruptedIOException iioe) {
<span class="line-modified"> 444                 if(resumable){</span>
<span class="line-added"> 445                     handleException(iioe);</span>
<span class="line-added"> 446                 } else{</span>
<span class="line-added"> 447                     throw conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-added"> 448                             &quot;Couldn&#39;t kickstart handshaking&quot;, iioe);</span>
<span class="line-added"> 449                 }</span>
 450             } catch (IOException ioe) {
 451                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 452                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 453             } catch (Exception oe) {    // including RuntimeException
 454                 handleException(oe);
 455             }
 456         } finally {
 457             handshakeLock.unlock();
 458         }
 459     }
 460 
 461     @Override
 462     public void setUseClientMode(boolean mode) {
 463         socketLock.lock();
 464         try {
 465             conContext.setUseClientMode(mode);
 466         } finally {
 467             socketLock.unlock();
 468         }
 469     }
</pre>
<hr />
<pre>
 859         socketLock.lock();
 860         try {
 861             if (isClosed()) {
 862                 throw new SocketException(&quot;Socket is closed&quot;);
 863             }
 864 
 865             if (!isConnected) {
 866                 throw new SocketException(&quot;Socket is not connected&quot;);
 867             }
 868 
 869             if (conContext.isInboundClosed() || isInputShutdown()) {
 870                 throw new SocketException(&quot;Socket input is already shutdown&quot;);
 871             }
 872 
 873             return appInput;
 874         } finally {
 875             socketLock.unlock();
 876         }
 877     }
 878 
<span class="line-modified"> 879     private void ensureNegotiated(boolean resumable) throws IOException {</span>
 880         if (conContext.isNegotiated || conContext.isBroken ||
 881                 conContext.isInboundClosed() || conContext.isOutboundClosed()) {
 882             return;
 883         }
 884 
 885         handshakeLock.lock();
 886         try {
 887             // double check the context status
 888             if (conContext.isNegotiated || conContext.isBroken ||
 889                     conContext.isInboundClosed() ||
 890                     conContext.isOutboundClosed()) {
 891                 return;
 892             }
 893 
<span class="line-modified"> 894             startHandshake(resumable);</span>
 895         } finally {
 896             handshakeLock.unlock();
 897         }
 898     }
 899 
 900     /**
 901      * InputStream for application data as returned by
 902      * SSLSocket.getInputStream().
 903      */
 904     private class AppInputStream extends InputStream {
 905         // One element array used to implement the single byte read() method
 906         private final byte[] oneByte = new byte[1];
 907 
 908         // the temporary buffer used to read network
 909         private ByteBuffer buffer;
 910 
 911         // Is application data available in the stream?
 912         private volatile boolean appDataIsAvailable;
 913 
 914         // reading lock
</pre>
<hr />
<pre>
 965         @Override
 966         public int read(byte[] b, int off, int len) throws IOException {
 967             if (b == null) {
 968                 throw new NullPointerException(&quot;the target buffer is null&quot;);
 969             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
 970                 throw new IndexOutOfBoundsException(
 971                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
 972                         &quot;, bytes to read:&quot; + len);
 973             } else if (len == 0) {
 974                 return 0;
 975             }
 976 
 977             if (checkEOF()) {
 978                 return -1;
 979             }
 980 
 981             // start handshaking if the connection has not been negotiated.
 982             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 983                     !conContext.isInboundClosed() &amp;&amp;
 984                     !conContext.isOutboundClosed()) {
<span class="line-modified"> 985                 ensureNegotiated(true);</span>
 986             }
 987 
 988             // Check if the Socket is invalid (error or closed).
 989             if (!conContext.isNegotiated ||
 990                     conContext.isBroken || conContext.isInboundClosed()) {
 991                 throw new SocketException(&quot;Connection or inbound has closed&quot;);
 992             }
 993 
 994             // Check if the input stream has been depleted.
 995             //
 996             // Note that the &quot;hasDepleted&quot; rather than the isClosing
 997             // filed is checked here, in case the closing process is
 998             // still in progress.
 999             if (hasDepleted) {
1000                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1001                     SSLLogger.fine(&quot;The input stream has been depleted&quot;);
1002                 }
1003 
1004                 return -1;
1005             }
</pre>
<hr />
<pre>
1244             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
1245                 throw new IndexOutOfBoundsException(
1246                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
1247                         &quot;, bytes to read:&quot; + len);
1248             } else if (len == 0) {
1249                 //
1250                 // Don&#39;t bother to really write empty records.  We went this
1251                 // far to drive the handshake machinery, for correctness; not
1252                 // writing empty records improves performance by cutting CPU
1253                 // time and network resource usage.  However, some protocol
1254                 // implementations are fragile and don&#39;t like to see empty
1255                 // records, so this also increases robustness.
1256                 //
1257                 return;
1258             }
1259 
1260             // Start handshaking if the connection has not been negotiated.
1261             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
1262                     !conContext.isInboundClosed() &amp;&amp;
1263                     !conContext.isOutboundClosed()) {
<span class="line-modified">1264                 ensureNegotiated(true);</span>
1265             }
1266 
1267             // Check if the Socket is invalid (error or closed).
1268             if (!conContext.isNegotiated ||
1269                     conContext.isBroken || conContext.isOutboundClosed()) {
1270                 throw new SocketException(&quot;Connection or outbound has closed&quot;);
1271             }
1272 
1273             //
1274 
1275             // Delegate the writing to the underlying socket.
1276             try {
1277                 conContext.outputRecord.deliver(b, off, len);
1278             } catch (SSLHandshakeException she) {
1279                 // may be record sequence number overflow
1280                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
1281             } catch (SSLException ssle) {
1282                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, ssle);
1283             }   // re-throw other IOException, which should be caused by
1284                 // the underlying plain socket and could be handled by
</pre>
</td>
</tr>
</table>
<center><a href="../../../jdk/internal/org/objectweb/asm/Opcodes.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../java.compiler/share/classes/javax/lang/model/SourceVersion.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
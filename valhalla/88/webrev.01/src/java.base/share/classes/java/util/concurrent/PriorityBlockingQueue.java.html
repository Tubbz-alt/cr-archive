<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent;
  37 
  38 import java.lang.invoke.MethodHandles;
  39 import java.lang.invoke.VarHandle;
  40 import java.util.AbstractQueue;
  41 import java.util.Arrays;
  42 import java.util.Collection;
  43 import java.util.Comparator;
  44 import java.util.Iterator;
  45 import java.util.NoSuchElementException;
  46 import java.util.Objects;
  47 import java.util.PriorityQueue;
  48 import java.util.Queue;
  49 import java.util.SortedSet;
  50 import java.util.Spliterator;
  51 import java.util.concurrent.locks.Condition;
  52 import java.util.concurrent.locks.ReentrantLock;
  53 import java.util.function.Consumer;
  54 import java.util.function.Predicate;
  55 import jdk.internal.access.SharedSecrets;
  56 import jdk.internal.util.ArraysSupport;
  57 
  58 /**
  59  * An unbounded {@linkplain BlockingQueue blocking queue} that uses
  60  * the same ordering rules as class {@link PriorityQueue} and supplies
  61  * blocking retrieval operations.  While this queue is logically
  62  * unbounded, attempted additions may fail due to resource exhaustion
  63  * (causing {@code OutOfMemoryError}). This class does not permit
  64  * {@code null} elements.  A priority queue relying on {@linkplain
  65  * Comparable natural ordering} also does not permit insertion of
  66  * non-comparable objects (doing so results in
  67  * {@code ClassCastException}).
  68  *
  69  * &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
  70  * methods of the {@link Collection} and {@link Iterator} interfaces.
  71  * The Iterator provided in method {@link #iterator()} and the
  72  * Spliterator provided in method {@link #spliterator()} are &lt;em&gt;not&lt;/em&gt;
  73  * guaranteed to traverse the elements of the PriorityBlockingQueue in
  74  * any particular order. If you need ordered traversal, consider using
  75  * {@code Arrays.sort(pq.toArray())}.  Also, method {@code drainTo} can
  76  * be used to &lt;em&gt;remove&lt;/em&gt; some or all elements in priority order and
  77  * place them in another collection.
  78  *
  79  * &lt;p&gt;Operations on this class make no guarantees about the ordering
  80  * of elements with equal priority. If you need to enforce an
  81  * ordering, you can define custom classes or comparators that use a
  82  * secondary key to break ties in primary priority values.  For
  83  * example, here is a class that applies first-in-first-out
  84  * tie-breaking to comparable elements. To use it, you would insert a
  85  * {@code new FIFOEntry(anEntry)} instead of a plain entry object.
  86  *
  87  * &lt;pre&gt; {@code
  88  * class FIFOEntry&lt;E extends Comparable&lt;? super E&gt;&gt;
  89  *     implements Comparable&lt;FIFOEntry&lt;E&gt;&gt; {
  90  *   static final AtomicLong seq = new AtomicLong(0);
  91  *   final long seqNum;
  92  *   final E entry;
  93  *   public FIFOEntry(E entry) {
  94  *     seqNum = seq.getAndIncrement();
  95  *     this.entry = entry;
  96  *   }
  97  *   public E getEntry() { return entry; }
  98  *   public int compareTo(FIFOEntry&lt;E&gt; other) {
  99  *     int res = entry.compareTo(other.entry);
 100  *     if (res == 0 &amp;&amp; other.entry != this.entry)
 101  *       res = (seqNum &lt; other.seqNum ? -1 : 1);
 102  *     return res;
 103  *   }
 104  * }}&lt;/pre&gt;
 105  *
 106  * &lt;p&gt;This class is a member of the
 107  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 108  * Java Collections Framework&lt;/a&gt;.
 109  *
 110  * @since 1.5
 111  * @author Doug Lea
 112  * @param &lt;E&gt; the type of elements held in this queue
 113  */
 114 @SuppressWarnings(&quot;unchecked&quot;)
 115 public class PriorityBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
 116     implements BlockingQueue&lt;E&gt;, java.io.Serializable {
 117     private static final long serialVersionUID = 5595510919245408276L;
 118 
 119     /*
 120      * The implementation uses an array-based binary heap, with public
 121      * operations protected with a single lock. However, allocation
 122      * during resizing uses a simple spinlock (used only while not
 123      * holding main lock) in order to allow takes to operate
 124      * concurrently with allocation.  This avoids repeated
 125      * postponement of waiting consumers and consequent element
 126      * build-up. The need to back away from lock during allocation
 127      * makes it impossible to simply wrap delegated
 128      * java.util.PriorityQueue operations within a lock, as was done
 129      * in a previous version of this class. To maintain
 130      * interoperability, a plain PriorityQueue is still used during
 131      * serialization, which maintains compatibility at the expense of
 132      * transiently doubling overhead.
 133      */
 134 
 135     /**
 136      * Default array capacity.
 137      */
 138     private static final int DEFAULT_INITIAL_CAPACITY = 11;
 139 
 140     /**
 141      * Priority queue represented as a balanced binary heap: the two
 142      * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The
 143      * priority queue is ordered by comparator, or by the elements&#39;
 144      * natural ordering, if comparator is null: For each node n in the
 145      * heap and each descendant d of n, n &lt;= d.  The element with the
 146      * lowest value is in queue[0], assuming the queue is nonempty.
 147      */
 148     private transient Object[] queue;
 149 
 150     /**
 151      * The number of elements in the priority queue.
 152      */
 153     private transient int size;
 154 
 155     /**
 156      * The comparator, or null if priority queue uses elements&#39;
 157      * natural ordering.
 158      */
 159     private transient Comparator&lt;? super E&gt; comparator;
 160 
 161     /**
 162      * Lock used for all public operations.
 163      */
 164     private final ReentrantLock lock = new ReentrantLock();
 165 
 166     /**
 167      * Condition for blocking when empty.
 168      */
 169     @SuppressWarnings(&quot;serial&quot;) // Classes implementing Condition may be serializable.
 170     private final Condition notEmpty = lock.newCondition();
 171 
 172     /**
 173      * Spinlock for allocation, acquired via CAS.
 174      */
 175     private transient volatile int allocationSpinLock;
 176 
 177     /**
 178      * A plain PriorityQueue used only for serialization,
 179      * to maintain compatibility with previous versions
 180      * of this class. Non-null only during serialization/deserialization.
 181      */
 182     private PriorityQueue&lt;E&gt; q;
 183 
 184     /**
 185      * Creates a {@code PriorityBlockingQueue} with the default
 186      * initial capacity (11) that orders its elements according to
 187      * their {@linkplain Comparable natural ordering}.
 188      */
 189     public PriorityBlockingQueue() {
 190         this(DEFAULT_INITIAL_CAPACITY, null);
 191     }
 192 
 193     /**
 194      * Creates a {@code PriorityBlockingQueue} with the specified
 195      * initial capacity that orders its elements according to their
 196      * {@linkplain Comparable natural ordering}.
 197      *
 198      * @param initialCapacity the initial capacity for this priority queue
 199      * @throws IllegalArgumentException if {@code initialCapacity} is less
 200      *         than 1
 201      */
 202     public PriorityBlockingQueue(int initialCapacity) {
 203         this(initialCapacity, null);
 204     }
 205 
 206     /**
 207      * Creates a {@code PriorityBlockingQueue} with the specified initial
 208      * capacity that orders its elements according to the specified
 209      * comparator.
 210      *
 211      * @param initialCapacity the initial capacity for this priority queue
 212      * @param  comparator the comparator that will be used to order this
 213      *         priority queue.  If {@code null}, the {@linkplain Comparable
 214      *         natural ordering} of the elements will be used.
 215      * @throws IllegalArgumentException if {@code initialCapacity} is less
 216      *         than 1
 217      */
 218     public PriorityBlockingQueue(int initialCapacity,
 219                                  Comparator&lt;? super E&gt; comparator) {
 220         if (initialCapacity &lt; 1)
 221             throw new IllegalArgumentException();
 222         this.comparator = comparator;
 223         this.queue = new Object[Math.max(1, initialCapacity)];
 224     }
 225 
 226     /**
 227      * Creates a {@code PriorityBlockingQueue} containing the elements
 228      * in the specified collection.  If the specified collection is a
 229      * {@link SortedSet} or a {@link PriorityQueue}, this
 230      * priority queue will be ordered according to the same ordering.
 231      * Otherwise, this priority queue will be ordered according to the
 232      * {@linkplain Comparable natural ordering} of its elements.
 233      *
 234      * @param  c the collection whose elements are to be placed
 235      *         into this priority queue
 236      * @throws ClassCastException if elements of the specified collection
 237      *         cannot be compared to one another according to the priority
 238      *         queue&#39;s ordering
 239      * @throws NullPointerException if the specified collection or any
 240      *         of its elements are null
 241      */
 242     public PriorityBlockingQueue(Collection&lt;? extends E&gt; c) {
 243         boolean heapify = true; // true if not known to be in heap order
 244         boolean screen = true;  // true if must screen for nulls
 245         if (c instanceof SortedSet&lt;?&gt;) {
 246             SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;
 247             this.comparator = (Comparator&lt;? super E&gt;) ss.comparator();
 248             heapify = false;
 249         }
 250         else if (c instanceof PriorityBlockingQueue&lt;?&gt;) {
 251             PriorityBlockingQueue&lt;? extends E&gt; pq =
 252                 (PriorityBlockingQueue&lt;? extends E&gt;) c;
 253             this.comparator = (Comparator&lt;? super E&gt;) pq.comparator();
 254             screen = false;
 255             if (pq.getClass() == PriorityBlockingQueue.class) // exact match
 256                 heapify = false;
 257         }
 258         Object[] es = c.toArray();
 259         int n = es.length;
 260         // If c.toArray incorrectly doesn&#39;t return Object[], copy it.
 261         if (es.getClass() != Object[].class)
 262             es = Arrays.copyOf(es, n, Object[].class);
 263         if (screen &amp;&amp; (n == 1 || this.comparator != null)) {
 264             for (Object e : es)
 265                 if (e == null)
 266                     throw new NullPointerException();
 267         }
 268         this.queue = ensureNonEmpty(es);
 269         this.size = n;
 270         if (heapify)
 271             heapify();
 272     }
 273 
 274     /** Ensures that queue[0] exists, helping peek() and poll(). */
 275     private static Object[] ensureNonEmpty(Object[] es) {
 276         return (es.length &gt; 0) ? es : new Object[1];
 277     }
 278 
 279     /**
 280      * Tries to grow array to accommodate at least one more element
 281      * (but normally expand by about 50%), giving up (allowing retry)
 282      * on contention (which we expect to be rare). Call only while
 283      * holding lock.
 284      *
 285      * @param array the heap array
 286      * @param oldCap the length of the array
 287      */
 288     private void tryGrow(Object[] array, int oldCap) {
 289         lock.unlock(); // must release and then re-acquire main lock
 290         Object[] newArray = null;
 291         if (allocationSpinLock == 0 &amp;&amp;
 292             ALLOCATIONSPINLOCK.compareAndSet(this, 0, 1)) {
 293             try {
 294                 int growth = oldCap &lt; 64 ? oldCap + 2 : oldCap &gt;&gt; 1;
 295                 int newCap = ArraysSupport.newLength(oldCap, 1, growth);
 296                 if (queue == array)
 297                     newArray = new Object[newCap];
 298             } finally {
 299                 allocationSpinLock = 0;
 300             }
 301         }
 302         if (newArray == null) // back off if another thread is allocating
 303             Thread.yield();
 304         lock.lock();
 305         if (newArray != null &amp;&amp; queue == array) {
 306             queue = newArray;
 307             System.arraycopy(array, 0, newArray, 0, oldCap);
 308         }
 309     }
 310 
 311     /**
 312      * Mechanics for poll().  Call only while holding lock.
 313      */
 314     private E dequeue() {
 315         // assert lock.isHeldByCurrentThread();
 316         final Object[] es;
 317         final E result;
 318 
 319         if ((result = (E) ((es = queue)[0])) != null) {
 320             final int n;
 321             final E x = (E) es[(n = --size)];
 322             es[n] = null;
 323             if (n &gt; 0) {
 324                 final Comparator&lt;? super E&gt; cmp;
 325                 if ((cmp = comparator) == null)
 326                     siftDownComparable(0, x, es, n);
 327                 else
 328                     siftDownUsingComparator(0, x, es, n, cmp);
 329             }
 330         }
 331         return result;
 332     }
 333 
 334     /**
 335      * Inserts item x at position k, maintaining heap invariant by
 336      * promoting x up the tree until it is greater than or equal to
 337      * its parent, or is the root.
 338      *
 339      * To simplify and speed up coercions and comparisons, the
 340      * Comparable and Comparator versions are separated into different
 341      * methods that are otherwise identical. (Similarly for siftDown.)
 342      *
 343      * @param k the position to fill
 344      * @param x the item to insert
 345      * @param es the heap array
 346      */
 347     private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] es) {
 348         Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x;
 349         while (k &gt; 0) {
 350             int parent = (k - 1) &gt;&gt;&gt; 1;
 351             Object e = es[parent];
 352             if (key.compareTo((T) e) &gt;= 0)
 353                 break;
 354             es[k] = e;
 355             k = parent;
 356         }
 357         es[k] = key;
 358     }
 359 
 360     private static &lt;T&gt; void siftUpUsingComparator(
 361         int k, T x, Object[] es, Comparator&lt;? super T&gt; cmp) {
 362         while (k &gt; 0) {
 363             int parent = (k - 1) &gt;&gt;&gt; 1;
 364             Object e = es[parent];
 365             if (cmp.compare(x, (T) e) &gt;= 0)
 366                 break;
 367             es[k] = e;
 368             k = parent;
 369         }
 370         es[k] = x;
 371     }
 372 
 373     /**
 374      * Inserts item x at position k, maintaining heap invariant by
 375      * demoting x down the tree repeatedly until it is less than or
 376      * equal to its children or is a leaf.
 377      *
 378      * @param k the position to fill
 379      * @param x the item to insert
 380      * @param es the heap array
 381      * @param n heap size
 382      */
 383     private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] es, int n) {
 384         // assert n &gt; 0;
 385         Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x;
 386         int half = n &gt;&gt;&gt; 1;           // loop while a non-leaf
 387         while (k &lt; half) {
 388             int child = (k &lt;&lt; 1) + 1; // assume left child is least
 389             Object c = es[child];
 390             int right = child + 1;
 391             if (right &lt; n &amp;&amp;
 392                 ((Comparable&lt;? super T&gt;) c).compareTo((T) es[right]) &gt; 0)
 393                 c = es[child = right];
 394             if (key.compareTo((T) c) &lt;= 0)
 395                 break;
 396             es[k] = c;
 397             k = child;
 398         }
 399         es[k] = key;
 400     }
 401 
 402     private static &lt;T&gt; void siftDownUsingComparator(
 403         int k, T x, Object[] es, int n, Comparator&lt;? super T&gt; cmp) {
 404         // assert n &gt; 0;
 405         int half = n &gt;&gt;&gt; 1;
 406         while (k &lt; half) {
 407             int child = (k &lt;&lt; 1) + 1;
 408             Object c = es[child];
 409             int right = child + 1;
 410             if (right &lt; n &amp;&amp; cmp.compare((T) c, (T) es[right]) &gt; 0)
 411                 c = es[child = right];
 412             if (cmp.compare(x, (T) c) &lt;= 0)
 413                 break;
 414             es[k] = c;
 415             k = child;
 416         }
 417         es[k] = x;
 418     }
 419 
 420     /**
 421      * Establishes the heap invariant (described above) in the entire tree,
 422      * assuming nothing about the order of the elements prior to the call.
 423      * This classic algorithm due to Floyd (1964) is known to be O(size).
 424      */
 425     private void heapify() {
 426         final Object[] es = queue;
 427         int n = size, i = (n &gt;&gt;&gt; 1) - 1;
 428         final Comparator&lt;? super E&gt; cmp;
 429         if ((cmp = comparator) == null)
 430             for (; i &gt;= 0; i--)
 431                 siftDownComparable(i, (E) es[i], es, n);
 432         else
 433             for (; i &gt;= 0; i--)
 434                 siftDownUsingComparator(i, (E) es[i], es, n, cmp);
 435     }
 436 
 437     /**
 438      * Inserts the specified element into this priority queue.
 439      *
 440      * @param e the element to add
 441      * @return {@code true} (as specified by {@link Collection#add})
 442      * @throws ClassCastException if the specified element cannot be compared
 443      *         with elements currently in the priority queue according to the
 444      *         priority queue&#39;s ordering
 445      * @throws NullPointerException if the specified element is null
 446      */
 447     public boolean add(E e) {
 448         return offer(e);
 449     }
 450 
 451     /**
 452      * Inserts the specified element into this priority queue.
 453      * As the queue is unbounded, this method will never return {@code false}.
 454      *
 455      * @param e the element to add
 456      * @return {@code true} (as specified by {@link Queue#offer})
 457      * @throws ClassCastException if the specified element cannot be compared
 458      *         with elements currently in the priority queue according to the
 459      *         priority queue&#39;s ordering
 460      * @throws NullPointerException if the specified element is null
 461      */
 462     public boolean offer(E e) {
 463         if (e == null)
 464             throw new NullPointerException();
 465         final ReentrantLock lock = this.lock;
 466         lock.lock();
 467         int n, cap;
 468         Object[] es;
 469         while ((n = size) &gt;= (cap = (es = queue).length))
 470             tryGrow(es, cap);
 471         try {
 472             final Comparator&lt;? super E&gt; cmp;
 473             if ((cmp = comparator) == null)
 474                 siftUpComparable(n, e, es);
 475             else
 476                 siftUpUsingComparator(n, e, es, cmp);
 477             size = n + 1;
 478             notEmpty.signal();
 479         } finally {
 480             lock.unlock();
 481         }
 482         return true;
 483     }
 484 
 485     /**
 486      * Inserts the specified element into this priority queue.
 487      * As the queue is unbounded, this method will never block.
 488      *
 489      * @param e the element to add
 490      * @throws ClassCastException if the specified element cannot be compared
 491      *         with elements currently in the priority queue according to the
 492      *         priority queue&#39;s ordering
 493      * @throws NullPointerException if the specified element is null
 494      */
 495     public void put(E e) {
 496         offer(e); // never need to block
 497     }
 498 
 499     /**
 500      * Inserts the specified element into this priority queue.
 501      * As the queue is unbounded, this method will never block or
 502      * return {@code false}.
 503      *
 504      * @param e the element to add
 505      * @param timeout This parameter is ignored as the method never blocks
 506      * @param unit This parameter is ignored as the method never blocks
 507      * @return {@code true} (as specified by
 508      *  {@link BlockingQueue#offer(Object,long,TimeUnit) BlockingQueue.offer})
 509      * @throws ClassCastException if the specified element cannot be compared
 510      *         with elements currently in the priority queue according to the
 511      *         priority queue&#39;s ordering
 512      * @throws NullPointerException if the specified element is null
 513      */
 514     public boolean offer(E e, long timeout, TimeUnit unit) {
 515         return offer(e); // never need to block
 516     }
 517 
 518     public E poll() {
 519         final ReentrantLock lock = this.lock;
 520         lock.lock();
 521         try {
 522             return dequeue();
 523         } finally {
 524             lock.unlock();
 525         }
 526     }
 527 
 528     public E take() throws InterruptedException {
 529         final ReentrantLock lock = this.lock;
 530         lock.lockInterruptibly();
 531         E result;
 532         try {
 533             while ( (result = dequeue()) == null)
 534                 notEmpty.await();
 535         } finally {
 536             lock.unlock();
 537         }
 538         return result;
 539     }
 540 
 541     public E poll(long timeout, TimeUnit unit) throws InterruptedException {
 542         long nanos = unit.toNanos(timeout);
 543         final ReentrantLock lock = this.lock;
 544         lock.lockInterruptibly();
 545         E result;
 546         try {
 547             while ( (result = dequeue()) == null &amp;&amp; nanos &gt; 0)
 548                 nanos = notEmpty.awaitNanos(nanos);
 549         } finally {
 550             lock.unlock();
 551         }
 552         return result;
 553     }
 554 
 555     public E peek() {
 556         final ReentrantLock lock = this.lock;
 557         lock.lock();
 558         try {
 559             return (E) queue[0];
 560         } finally {
 561             lock.unlock();
 562         }
 563     }
 564 
 565     /**
 566      * Returns the comparator used to order the elements in this queue,
 567      * or {@code null} if this queue uses the {@linkplain Comparable
 568      * natural ordering} of its elements.
 569      *
 570      * @return the comparator used to order the elements in this queue,
 571      *         or {@code null} if this queue uses the natural
 572      *         ordering of its elements
 573      */
 574     public Comparator&lt;? super E&gt; comparator() {
 575         return comparator;
 576     }
 577 
 578     public int size() {
 579         final ReentrantLock lock = this.lock;
 580         lock.lock();
 581         try {
 582             return size;
 583         } finally {
 584             lock.unlock();
 585         }
 586     }
 587 
 588     /**
 589      * Always returns {@code Integer.MAX_VALUE} because
 590      * a {@code PriorityBlockingQueue} is not capacity constrained.
 591      * @return {@code Integer.MAX_VALUE} always
 592      */
 593     public int remainingCapacity() {
 594         return Integer.MAX_VALUE;
 595     }
 596 
 597     private int indexOf(Object o) {
 598         if (o != null) {
 599             final Object[] es = queue;
 600             for (int i = 0, n = size; i &lt; n; i++)
 601                 if (o.equals(es[i]))
 602                     return i;
 603         }
 604         return -1;
 605     }
 606 
 607     /**
 608      * Removes the ith element from queue.
 609      */
 610     private void removeAt(int i) {
 611         final Object[] es = queue;
 612         final int n = size - 1;
 613         if (n == i) // removed last element
 614             es[i] = null;
 615         else {
 616             E moved = (E) es[n];
 617             es[n] = null;
 618             final Comparator&lt;? super E&gt; cmp;
 619             if ((cmp = comparator) == null)
 620                 siftDownComparable(i, moved, es, n);
 621             else
 622                 siftDownUsingComparator(i, moved, es, n, cmp);
 623             if (es[i] == moved) {
 624                 if (cmp == null)
 625                     siftUpComparable(i, moved, es);
 626                 else
 627                     siftUpUsingComparator(i, moved, es, cmp);
 628             }
 629         }
 630         size = n;
 631     }
 632 
 633     /**
 634      * Removes a single instance of the specified element from this queue,
 635      * if it is present.  More formally, removes an element {@code e} such
 636      * that {@code o.equals(e)}, if this queue contains one or more such
 637      * elements.  Returns {@code true} if and only if this queue contained
 638      * the specified element (or equivalently, if this queue changed as a
 639      * result of the call).
 640      *
 641      * @param o element to be removed from this queue, if present
 642      * @return {@code true} if this queue changed as a result of the call
 643      */
 644     public boolean remove(Object o) {
 645         final ReentrantLock lock = this.lock;
 646         lock.lock();
 647         try {
 648             int i = indexOf(o);
 649             if (i == -1)
 650                 return false;
 651             removeAt(i);
 652             return true;
 653         } finally {
 654             lock.unlock();
 655         }
 656     }
 657 
 658     /**
 659      * Identity-based version for use in Itr.remove.
 660      *
 661      * @param o element to be removed from this queue, if present
 662      */
 663     void removeEq(Object o) {
 664         final ReentrantLock lock = this.lock;
 665         lock.lock();
 666         try {
 667             final Object[] es = queue;
 668             for (int i = 0, n = size; i &lt; n; i++) {
 669                 if (o == es[i]) {
 670                     removeAt(i);
 671                     break;
 672                 }
 673             }
 674         } finally {
 675             lock.unlock();
 676         }
 677     }
 678 
 679     /**
 680      * Returns {@code true} if this queue contains the specified element.
 681      * More formally, returns {@code true} if and only if this queue contains
 682      * at least one element {@code e} such that {@code o.equals(e)}.
 683      *
 684      * @param o object to be checked for containment in this queue
 685      * @return {@code true} if this queue contains the specified element
 686      */
 687     public boolean contains(Object o) {
 688         final ReentrantLock lock = this.lock;
 689         lock.lock();
 690         try {
 691             return indexOf(o) != -1;
 692         } finally {
 693             lock.unlock();
 694         }
 695     }
 696 
 697     public String toString() {
 698         return Helpers.collectionToString(this);
 699     }
 700 
 701     /**
 702      * @throws UnsupportedOperationException {@inheritDoc}
 703      * @throws ClassCastException            {@inheritDoc}
 704      * @throws NullPointerException          {@inheritDoc}
 705      * @throws IllegalArgumentException      {@inheritDoc}
 706      */
 707     public int drainTo(Collection&lt;? super E&gt; c) {
 708         return drainTo(c, Integer.MAX_VALUE);
 709     }
 710 
 711     /**
 712      * @throws UnsupportedOperationException {@inheritDoc}
 713      * @throws ClassCastException            {@inheritDoc}
 714      * @throws NullPointerException          {@inheritDoc}
 715      * @throws IllegalArgumentException      {@inheritDoc}
 716      */
 717     public int drainTo(Collection&lt;? super E&gt; c, int maxElements) {
 718         Objects.requireNonNull(c);
 719         if (c == this)
 720             throw new IllegalArgumentException();
 721         if (maxElements &lt;= 0)
 722             return 0;
 723         final ReentrantLock lock = this.lock;
 724         lock.lock();
 725         try {
 726             int n = Math.min(size, maxElements);
 727             for (int i = 0; i &lt; n; i++) {
 728                 c.add((E) queue[0]); // In this order, in case add() throws.
 729                 dequeue();
 730             }
 731             return n;
 732         } finally {
 733             lock.unlock();
 734         }
 735     }
 736 
 737     /**
 738      * Atomically removes all of the elements from this queue.
 739      * The queue will be empty after this call returns.
 740      */
 741     public void clear() {
 742         final ReentrantLock lock = this.lock;
 743         lock.lock();
 744         try {
 745             final Object[] es = queue;
 746             for (int i = 0, n = size; i &lt; n; i++)
 747                 es[i] = null;
 748             size = 0;
 749         } finally {
 750             lock.unlock();
 751         }
 752     }
 753 
 754     /**
 755      * Returns an array containing all of the elements in this queue.
 756      * The returned array elements are in no particular order.
 757      *
 758      * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
 759      * maintained by this queue.  (In other words, this method must allocate
 760      * a new array).  The caller is thus free to modify the returned array.
 761      *
 762      * &lt;p&gt;This method acts as bridge between array-based and collection-based
 763      * APIs.
 764      *
 765      * @return an array containing all of the elements in this queue
 766      */
 767     public Object[] toArray() {
 768         final ReentrantLock lock = this.lock;
 769         lock.lock();
 770         try {
 771             return Arrays.copyOf(queue, size);
 772         } finally {
 773             lock.unlock();
 774         }
 775     }
 776 
 777     /**
 778      * Returns an array containing all of the elements in this queue; the
 779      * runtime type of the returned array is that of the specified array.
 780      * The returned array elements are in no particular order.
 781      * If the queue fits in the specified array, it is returned therein.
 782      * Otherwise, a new array is allocated with the runtime type of the
 783      * specified array and the size of this queue.
 784      *
 785      * &lt;p&gt;If this queue fits in the specified array with room to spare
 786      * (i.e., the array has more elements than this queue), the element in
 787      * the array immediately following the end of the queue is set to
 788      * {@code null}.
 789      *
 790      * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
 791      * array-based and collection-based APIs.  Further, this method allows
 792      * precise control over the runtime type of the output array, and may,
 793      * under certain circumstances, be used to save allocation costs.
 794      *
 795      * &lt;p&gt;Suppose {@code x} is a queue known to contain only strings.
 796      * The following code can be used to dump the queue into a newly
 797      * allocated array of {@code String}:
 798      *
 799      * &lt;pre&gt; {@code String[] y = x.toArray(new String[0]);}&lt;/pre&gt;
 800      *
 801      * Note that {@code toArray(new Object[0])} is identical in function to
 802      * {@code toArray()}.
 803      *
 804      * @param a the array into which the elements of the queue are to
 805      *          be stored, if it is big enough; otherwise, a new array of the
 806      *          same runtime type is allocated for this purpose
 807      * @return an array containing all of the elements in this queue
 808      * @throws ArrayStoreException if the runtime type of the specified array
 809      *         is not a supertype of the runtime type of every element in
 810      *         this queue
 811      * @throws NullPointerException if the specified array is null
 812      */
 813     public &lt;T&gt; T[] toArray(T[] a) {
 814         final ReentrantLock lock = this.lock;
 815         lock.lock();
 816         try {
 817             int n = size;
 818             if (a.length &lt; n)
 819                 // Make a new array of a&#39;s runtime type, but my contents:
 820                 return (T[]) Arrays.copyOf(queue, size, a.getClass());
 821             System.arraycopy(queue, 0, a, 0, n);
 822             if (a.length &gt; n)
 823                 a[n] = null;
 824             return a;
 825         } finally {
 826             lock.unlock();
 827         }
 828     }
 829 
 830     /**
 831      * Returns an iterator over the elements in this queue. The
 832      * iterator does not return the elements in any particular order.
 833      *
 834      * &lt;p&gt;The returned iterator is
 835      * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
 836      *
 837      * @return an iterator over the elements in this queue
 838      */
 839     public Iterator&lt;E&gt; iterator() {
 840         return new Itr(toArray());
 841     }
 842 
 843     /**
 844      * Snapshot iterator that works off copy of underlying q array.
 845      */
 846     final class Itr implements Iterator&lt;E&gt; {
 847         final Object[] array; // Array of all elements
 848         int cursor;           // index of next element to return
 849         int lastRet = -1;     // index of last element, or -1 if no such
 850 
 851         Itr(Object[] array) {
 852             this.array = array;
 853         }
 854 
 855         public boolean hasNext() {
 856             return cursor &lt; array.length;
 857         }
 858 
 859         public E next() {
 860             if (cursor &gt;= array.length)
 861                 throw new NoSuchElementException();
 862             return (E)array[lastRet = cursor++];
 863         }
 864 
 865         public void remove() {
 866             if (lastRet &lt; 0)
 867                 throw new IllegalStateException();
 868             removeEq(array[lastRet]);
 869             lastRet = -1;
 870         }
 871 
 872         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
 873             Objects.requireNonNull(action);
 874             final Object[] es = array;
 875             int i;
 876             if ((i = cursor) &lt; es.length) {
 877                 lastRet = -1;
 878                 cursor = es.length;
 879                 for (; i &lt; es.length; i++)
 880                     action.accept((E) es[i]);
 881                 lastRet = es.length - 1;
 882             }
 883         }
 884     }
 885 
 886     /**
 887      * Saves this queue to a stream (that is, serializes it).
 888      *
 889      * For compatibility with previous version of this class, elements
 890      * are first copied to a java.util.PriorityQueue, which is then
 891      * serialized.
 892      *
 893      * @param s the stream
 894      * @throws java.io.IOException if an I/O error occurs
 895      */
 896     private void writeObject(java.io.ObjectOutputStream s)
 897         throws java.io.IOException {
 898         lock.lock();
 899         try {
 900             // avoid zero capacity argument
 901             q = new PriorityQueue&lt;E&gt;(Math.max(size, 1), comparator);
 902             q.addAll(this);
 903             s.defaultWriteObject();
 904         } finally {
 905             q = null;
 906             lock.unlock();
 907         }
 908     }
 909 
 910     /**
 911      * Reconstitutes this queue from a stream (that is, deserializes it).
 912      * @param s the stream
 913      * @throws ClassNotFoundException if the class of a serialized object
 914      *         could not be found
 915      * @throws java.io.IOException if an I/O error occurs
 916      */
 917     private void readObject(java.io.ObjectInputStream s)
 918         throws java.io.IOException, ClassNotFoundException {
 919         try {
 920             s.defaultReadObject();
 921             int sz = q.size();
 922             SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, sz);
 923             this.queue = new Object[Math.max(1, sz)];
 924             comparator = q.comparator();
 925             addAll(q);
 926         } finally {
 927             q = null;
 928         }
 929     }
 930 
 931     /**
 932      * Immutable snapshot spliterator that binds to elements &quot;late&quot;.
 933      */
 934     final class PBQSpliterator implements Spliterator&lt;E&gt; {
 935         Object[] array;        // null until late-bound-initialized
 936         int index;
 937         int fence;
 938 
 939         PBQSpliterator() {}
 940 
 941         PBQSpliterator(Object[] array, int index, int fence) {
 942             this.array = array;
 943             this.index = index;
 944             this.fence = fence;
 945         }
 946 
 947         private int getFence() {
 948             if (array == null)
 949                 fence = (array = toArray()).length;
 950             return fence;
 951         }
 952 
 953         public PBQSpliterator trySplit() {
 954             int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
 955             return (lo &gt;= mid) ? null :
 956                 new PBQSpliterator(array, lo, index = mid);
 957         }
 958 
 959         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
 960             Objects.requireNonNull(action);
 961             final int hi = getFence(), lo = index;
 962             final Object[] es = array;
 963             index = hi;                 // ensure exhaustion
 964             for (int i = lo; i &lt; hi; i++)
 965                 action.accept((E) es[i]);
 966         }
 967 
 968         public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
 969             Objects.requireNonNull(action);
 970             if (getFence() &gt; index &amp;&amp; index &gt;= 0) {
 971                 action.accept((E) array[index++]);
 972                 return true;
 973             }
 974             return false;
 975         }
 976 
 977         public long estimateSize() { return getFence() - index; }
 978 
 979         public int characteristics() {
 980             return (Spliterator.NONNULL |
 981                     Spliterator.SIZED |
 982                     Spliterator.SUBSIZED);
 983         }
 984     }
 985 
 986     /**
 987      * Returns a {@link Spliterator} over the elements in this queue.
 988      * The spliterator does not traverse elements in any particular order
 989      * (the {@link Spliterator#ORDERED ORDERED} characteristic is not reported).
 990      *
 991      * &lt;p&gt;The returned spliterator is
 992      * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
 993      *
 994      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED} and
 995      * {@link Spliterator#NONNULL}.
 996      *
 997      * @implNote
 998      * The {@code Spliterator} additionally reports {@link Spliterator#SUBSIZED}.
 999      *
1000      * @return a {@code Spliterator} over the elements in this queue
1001      * @since 1.8
1002      */
1003     public Spliterator&lt;E&gt; spliterator() {
1004         return new PBQSpliterator();
1005     }
1006 
1007     /**
1008      * @throws NullPointerException {@inheritDoc}
1009      */
1010     public boolean removeIf(Predicate&lt;? super E&gt; filter) {
1011         Objects.requireNonNull(filter);
1012         return bulkRemove(filter);
1013     }
1014 
1015     /**
1016      * @throws NullPointerException {@inheritDoc}
1017      */
1018     public boolean removeAll(Collection&lt;?&gt; c) {
1019         Objects.requireNonNull(c);
1020         return bulkRemove(e -&gt; c.contains(e));
1021     }
1022 
1023     /**
1024      * @throws NullPointerException {@inheritDoc}
1025      */
1026     public boolean retainAll(Collection&lt;?&gt; c) {
1027         Objects.requireNonNull(c);
1028         return bulkRemove(e -&gt; !c.contains(e));
1029     }
1030 
1031     // A tiny bit set implementation
1032 
1033     private static long[] nBits(int n) {
1034         return new long[((n - 1) &gt;&gt; 6) + 1];
1035     }
1036     private static void setBit(long[] bits, int i) {
1037         bits[i &gt;&gt; 6] |= 1L &lt;&lt; i;
1038     }
1039     private static boolean isClear(long[] bits, int i) {
1040         return (bits[i &gt;&gt; 6] &amp; (1L &lt;&lt; i)) == 0;
1041     }
1042 
1043     /** Implementation of bulk remove methods. */
1044     private boolean bulkRemove(Predicate&lt;? super E&gt; filter) {
1045         final ReentrantLock lock = this.lock;
1046         lock.lock();
1047         try {
1048             final Object[] es = queue;
1049             final int end = size;
1050             int i;
1051             // Optimize for initial run of survivors
1052             for (i = 0; i &lt; end &amp;&amp; !filter.test((E) es[i]); i++)
1053                 ;
1054             if (i &gt;= end)
1055                 return false;
1056             // Tolerate predicates that reentrantly access the
1057             // collection for read, so traverse once to find elements
1058             // to delete, a second pass to physically expunge.
1059             final int beg = i;
1060             final long[] deathRow = nBits(end - beg);
1061             deathRow[0] = 1L;   // set bit 0
1062             for (i = beg + 1; i &lt; end; i++)
1063                 if (filter.test((E) es[i]))
1064                     setBit(deathRow, i - beg);
1065             int w = beg;
1066             for (i = beg; i &lt; end; i++)
1067                 if (isClear(deathRow, i - beg))
1068                     es[w++] = es[i];
1069             for (i = size = w; i &lt; end; i++)
1070                 es[i] = null;
1071             heapify();
1072             return true;
1073         } finally {
1074             lock.unlock();
1075         }
1076     }
1077 
1078     /**
1079      * @throws NullPointerException {@inheritDoc}
1080      */
1081     public void forEach(Consumer&lt;? super E&gt; action) {
1082         Objects.requireNonNull(action);
1083         final ReentrantLock lock = this.lock;
1084         lock.lock();
1085         try {
1086             final Object[] es = queue;
1087             for (int i = 0, n = size; i &lt; n; i++)
1088                 action.accept((E) es[i]);
1089         } finally {
1090             lock.unlock();
1091         }
1092     }
1093 
1094     // VarHandle mechanics
1095     private static final VarHandle ALLOCATIONSPINLOCK;
1096     static {
1097         try {
1098             MethodHandles.Lookup l = MethodHandles.lookup();
1099             ALLOCATIONSPINLOCK = l.findVarHandle(PriorityBlockingQueue.class,
1100                                                  &quot;allocationSpinLock&quot;,
1101                                                  int.class);
1102         } catch (ReflectiveOperationException e) {
1103             throw new ExceptionInInitializerError(e);
1104         }
1105     }
1106 }
    </pre>
  </body>
</html>
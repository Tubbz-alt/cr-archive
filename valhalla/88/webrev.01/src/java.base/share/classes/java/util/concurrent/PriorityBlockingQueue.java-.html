<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent;
  37 
  38 import java.lang.invoke.MethodHandles;
  39 import java.lang.invoke.VarHandle;
  40 import java.util.AbstractQueue;
  41 import java.util.Arrays;
  42 import java.util.Collection;
  43 import java.util.Comparator;
  44 import java.util.Iterator;
  45 import java.util.NoSuchElementException;
  46 import java.util.Objects;
  47 import java.util.PriorityQueue;
  48 import java.util.Queue;
  49 import java.util.SortedSet;
  50 import java.util.Spliterator;
  51 import java.util.concurrent.locks.Condition;
  52 import java.util.concurrent.locks.ReentrantLock;
  53 import java.util.function.Consumer;
  54 import java.util.function.Predicate;
  55 import jdk.internal.access.SharedSecrets;
  56 
  57 /**
  58  * An unbounded {@linkplain BlockingQueue blocking queue} that uses
  59  * the same ordering rules as class {@link PriorityQueue} and supplies
  60  * blocking retrieval operations.  While this queue is logically
  61  * unbounded, attempted additions may fail due to resource exhaustion
  62  * (causing {@code OutOfMemoryError}). This class does not permit
  63  * {@code null} elements.  A priority queue relying on {@linkplain
  64  * Comparable natural ordering} also does not permit insertion of
  65  * non-comparable objects (doing so results in
  66  * {@code ClassCastException}).
  67  *
  68  * &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
  69  * methods of the {@link Collection} and {@link Iterator} interfaces.
  70  * The Iterator provided in method {@link #iterator()} and the
  71  * Spliterator provided in method {@link #spliterator()} are &lt;em&gt;not&lt;/em&gt;
  72  * guaranteed to traverse the elements of the PriorityBlockingQueue in
  73  * any particular order. If you need ordered traversal, consider using
  74  * {@code Arrays.sort(pq.toArray())}.  Also, method {@code drainTo} can
  75  * be used to &lt;em&gt;remove&lt;/em&gt; some or all elements in priority order and
  76  * place them in another collection.
  77  *
  78  * &lt;p&gt;Operations on this class make no guarantees about the ordering
  79  * of elements with equal priority. If you need to enforce an
  80  * ordering, you can define custom classes or comparators that use a
  81  * secondary key to break ties in primary priority values.  For
  82  * example, here is a class that applies first-in-first-out
  83  * tie-breaking to comparable elements. To use it, you would insert a
  84  * {@code new FIFOEntry(anEntry)} instead of a plain entry object.
  85  *
  86  * &lt;pre&gt; {@code
  87  * class FIFOEntry&lt;E extends Comparable&lt;? super E&gt;&gt;
  88  *     implements Comparable&lt;FIFOEntry&lt;E&gt;&gt; {
  89  *   static final AtomicLong seq = new AtomicLong(0);
  90  *   final long seqNum;
  91  *   final E entry;
  92  *   public FIFOEntry(E entry) {
  93  *     seqNum = seq.getAndIncrement();
  94  *     this.entry = entry;
  95  *   }
  96  *   public E getEntry() { return entry; }
  97  *   public int compareTo(FIFOEntry&lt;E&gt; other) {
  98  *     int res = entry.compareTo(other.entry);
  99  *     if (res == 0 &amp;&amp; other.entry != this.entry)
 100  *       res = (seqNum &lt; other.seqNum ? -1 : 1);
 101  *     return res;
 102  *   }
 103  * }}&lt;/pre&gt;
 104  *
 105  * &lt;p&gt;This class is a member of the
 106  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 107  * Java Collections Framework&lt;/a&gt;.
 108  *
 109  * @since 1.5
 110  * @author Doug Lea
 111  * @param &lt;E&gt; the type of elements held in this queue
 112  */
 113 @SuppressWarnings(&quot;unchecked&quot;)
 114 public class PriorityBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
 115     implements BlockingQueue&lt;E&gt;, java.io.Serializable {
 116     private static final long serialVersionUID = 5595510919245408276L;
 117 
 118     /*
 119      * The implementation uses an array-based binary heap, with public
 120      * operations protected with a single lock. However, allocation
 121      * during resizing uses a simple spinlock (used only while not
 122      * holding main lock) in order to allow takes to operate
 123      * concurrently with allocation.  This avoids repeated
 124      * postponement of waiting consumers and consequent element
 125      * build-up. The need to back away from lock during allocation
 126      * makes it impossible to simply wrap delegated
 127      * java.util.PriorityQueue operations within a lock, as was done
 128      * in a previous version of this class. To maintain
 129      * interoperability, a plain PriorityQueue is still used during
 130      * serialization, which maintains compatibility at the expense of
 131      * transiently doubling overhead.
 132      */
 133 
 134     /**
 135      * Default array capacity.
 136      */
 137     private static final int DEFAULT_INITIAL_CAPACITY = 11;
 138 
 139     /**
 140      * The maximum size of array to allocate.
 141      * Some VMs reserve some header words in an array.
 142      * Attempts to allocate larger arrays may result in
 143      * OutOfMemoryError: Requested array size exceeds VM limit
 144      */
 145     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
 146 
 147     /**
 148      * Priority queue represented as a balanced binary heap: the two
 149      * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The
 150      * priority queue is ordered by comparator, or by the elements&#39;
 151      * natural ordering, if comparator is null: For each node n in the
 152      * heap and each descendant d of n, n &lt;= d.  The element with the
 153      * lowest value is in queue[0], assuming the queue is nonempty.
 154      */
 155     private transient Object[] queue;
 156 
 157     /**
 158      * The number of elements in the priority queue.
 159      */
 160     private transient int size;
 161 
 162     /**
 163      * The comparator, or null if priority queue uses elements&#39;
 164      * natural ordering.
 165      */
 166     private transient Comparator&lt;? super E&gt; comparator;
 167 
 168     /**
 169      * Lock used for all public operations.
 170      */
 171     private final ReentrantLock lock = new ReentrantLock();
 172 
 173     /**
 174      * Condition for blocking when empty.
 175      */
 176     @SuppressWarnings(&quot;serial&quot;) // Classes implementing Condition may be serializable.
 177     private final Condition notEmpty = lock.newCondition();
 178 
 179     /**
 180      * Spinlock for allocation, acquired via CAS.
 181      */
 182     private transient volatile int allocationSpinLock;
 183 
 184     /**
 185      * A plain PriorityQueue used only for serialization,
 186      * to maintain compatibility with previous versions
 187      * of this class. Non-null only during serialization/deserialization.
 188      */
 189     private PriorityQueue&lt;E&gt; q;
 190 
 191     /**
 192      * Creates a {@code PriorityBlockingQueue} with the default
 193      * initial capacity (11) that orders its elements according to
 194      * their {@linkplain Comparable natural ordering}.
 195      */
 196     public PriorityBlockingQueue() {
 197         this(DEFAULT_INITIAL_CAPACITY, null);
 198     }
 199 
 200     /**
 201      * Creates a {@code PriorityBlockingQueue} with the specified
 202      * initial capacity that orders its elements according to their
 203      * {@linkplain Comparable natural ordering}.
 204      *
 205      * @param initialCapacity the initial capacity for this priority queue
 206      * @throws IllegalArgumentException if {@code initialCapacity} is less
 207      *         than 1
 208      */
 209     public PriorityBlockingQueue(int initialCapacity) {
 210         this(initialCapacity, null);
 211     }
 212 
 213     /**
 214      * Creates a {@code PriorityBlockingQueue} with the specified initial
 215      * capacity that orders its elements according to the specified
 216      * comparator.
 217      *
 218      * @param initialCapacity the initial capacity for this priority queue
 219      * @param  comparator the comparator that will be used to order this
 220      *         priority queue.  If {@code null}, the {@linkplain Comparable
 221      *         natural ordering} of the elements will be used.
 222      * @throws IllegalArgumentException if {@code initialCapacity} is less
 223      *         than 1
 224      */
 225     public PriorityBlockingQueue(int initialCapacity,
 226                                  Comparator&lt;? super E&gt; comparator) {
 227         if (initialCapacity &lt; 1)
 228             throw new IllegalArgumentException();
 229         this.comparator = comparator;
 230         this.queue = new Object[Math.max(1, initialCapacity)];
 231     }
 232 
 233     /**
 234      * Creates a {@code PriorityBlockingQueue} containing the elements
 235      * in the specified collection.  If the specified collection is a
 236      * {@link SortedSet} or a {@link PriorityQueue}, this
 237      * priority queue will be ordered according to the same ordering.
 238      * Otherwise, this priority queue will be ordered according to the
 239      * {@linkplain Comparable natural ordering} of its elements.
 240      *
 241      * @param  c the collection whose elements are to be placed
 242      *         into this priority queue
 243      * @throws ClassCastException if elements of the specified collection
 244      *         cannot be compared to one another according to the priority
 245      *         queue&#39;s ordering
 246      * @throws NullPointerException if the specified collection or any
 247      *         of its elements are null
 248      */
 249     public PriorityBlockingQueue(Collection&lt;? extends E&gt; c) {
 250         boolean heapify = true; // true if not known to be in heap order
 251         boolean screen = true;  // true if must screen for nulls
 252         if (c instanceof SortedSet&lt;?&gt;) {
 253             SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;
 254             this.comparator = (Comparator&lt;? super E&gt;) ss.comparator();
 255             heapify = false;
 256         }
 257         else if (c instanceof PriorityBlockingQueue&lt;?&gt;) {
 258             PriorityBlockingQueue&lt;? extends E&gt; pq =
 259                 (PriorityBlockingQueue&lt;? extends E&gt;) c;
 260             this.comparator = (Comparator&lt;? super E&gt;) pq.comparator();
 261             screen = false;
 262             if (pq.getClass() == PriorityBlockingQueue.class) // exact match
 263                 heapify = false;
 264         }
 265         Object[] es = c.toArray();
 266         int n = es.length;
 267         // If c.toArray incorrectly doesn&#39;t return Object[], copy it.
 268         if (es.getClass() != Object[].class)
 269             es = Arrays.copyOf(es, n, Object[].class);
 270         if (screen &amp;&amp; (n == 1 || this.comparator != null)) {
 271             for (Object e : es)
 272                 if (e == null)
 273                     throw new NullPointerException();
 274         }
 275         this.queue = ensureNonEmpty(es);
 276         this.size = n;
 277         if (heapify)
 278             heapify();
 279     }
 280 
 281     /** Ensures that queue[0] exists, helping peek() and poll(). */
 282     private static Object[] ensureNonEmpty(Object[] es) {
 283         return (es.length &gt; 0) ? es : new Object[1];
 284     }
 285 
 286     /**
 287      * Tries to grow array to accommodate at least one more element
 288      * (but normally expand by about 50%), giving up (allowing retry)
 289      * on contention (which we expect to be rare). Call only while
 290      * holding lock.
 291      *
 292      * @param array the heap array
 293      * @param oldCap the length of the array
 294      */
 295     private void tryGrow(Object[] array, int oldCap) {
 296         lock.unlock(); // must release and then re-acquire main lock
 297         Object[] newArray = null;
 298         if (allocationSpinLock == 0 &amp;&amp;
 299             ALLOCATIONSPINLOCK.compareAndSet(this, 0, 1)) {
 300             try {
 301                 int newCap = oldCap + ((oldCap &lt; 64) ?
 302                                        (oldCap + 2) : // grow faster if small
 303                                        (oldCap &gt;&gt; 1));
 304                 if (newCap - MAX_ARRAY_SIZE &gt; 0) {    // possible overflow
 305                     int minCap = oldCap + 1;
 306                     if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)
 307                         throw new OutOfMemoryError();
 308                     newCap = MAX_ARRAY_SIZE;
 309                 }
 310                 if (newCap &gt; oldCap &amp;&amp; queue == array)
 311                     newArray = new Object[newCap];
 312             } finally {
 313                 allocationSpinLock = 0;
 314             }
 315         }
 316         if (newArray == null) // back off if another thread is allocating
 317             Thread.yield();
 318         lock.lock();
 319         if (newArray != null &amp;&amp; queue == array) {
 320             queue = newArray;
 321             System.arraycopy(array, 0, newArray, 0, oldCap);
 322         }
 323     }
 324 
 325     /**
 326      * Mechanics for poll().  Call only while holding lock.
 327      */
 328     private E dequeue() {
 329         // assert lock.isHeldByCurrentThread();
 330         final Object[] es;
 331         final E result;
 332 
 333         if ((result = (E) ((es = queue)[0])) != null) {
 334             final int n;
 335             final E x = (E) es[(n = --size)];
 336             es[n] = null;
 337             if (n &gt; 0) {
 338                 final Comparator&lt;? super E&gt; cmp;
 339                 if ((cmp = comparator) == null)
 340                     siftDownComparable(0, x, es, n);
 341                 else
 342                     siftDownUsingComparator(0, x, es, n, cmp);
 343             }
 344         }
 345         return result;
 346     }
 347 
 348     /**
 349      * Inserts item x at position k, maintaining heap invariant by
 350      * promoting x up the tree until it is greater than or equal to
 351      * its parent, or is the root.
 352      *
 353      * To simplify and speed up coercions and comparisons, the
 354      * Comparable and Comparator versions are separated into different
 355      * methods that are otherwise identical. (Similarly for siftDown.)
 356      *
 357      * @param k the position to fill
 358      * @param x the item to insert
 359      * @param es the heap array
 360      */
 361     private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] es) {
 362         Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x;
 363         while (k &gt; 0) {
 364             int parent = (k - 1) &gt;&gt;&gt; 1;
 365             Object e = es[parent];
 366             if (key.compareTo((T) e) &gt;= 0)
 367                 break;
 368             es[k] = e;
 369             k = parent;
 370         }
 371         es[k] = key;
 372     }
 373 
 374     private static &lt;T&gt; void siftUpUsingComparator(
 375         int k, T x, Object[] es, Comparator&lt;? super T&gt; cmp) {
 376         while (k &gt; 0) {
 377             int parent = (k - 1) &gt;&gt;&gt; 1;
 378             Object e = es[parent];
 379             if (cmp.compare(x, (T) e) &gt;= 0)
 380                 break;
 381             es[k] = e;
 382             k = parent;
 383         }
 384         es[k] = x;
 385     }
 386 
 387     /**
 388      * Inserts item x at position k, maintaining heap invariant by
 389      * demoting x down the tree repeatedly until it is less than or
 390      * equal to its children or is a leaf.
 391      *
 392      * @param k the position to fill
 393      * @param x the item to insert
 394      * @param es the heap array
 395      * @param n heap size
 396      */
 397     private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] es, int n) {
 398         // assert n &gt; 0;
 399         Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x;
 400         int half = n &gt;&gt;&gt; 1;           // loop while a non-leaf
 401         while (k &lt; half) {
 402             int child = (k &lt;&lt; 1) + 1; // assume left child is least
 403             Object c = es[child];
 404             int right = child + 1;
 405             if (right &lt; n &amp;&amp;
 406                 ((Comparable&lt;? super T&gt;) c).compareTo((T) es[right]) &gt; 0)
 407                 c = es[child = right];
 408             if (key.compareTo((T) c) &lt;= 0)
 409                 break;
 410             es[k] = c;
 411             k = child;
 412         }
 413         es[k] = key;
 414     }
 415 
 416     private static &lt;T&gt; void siftDownUsingComparator(
 417         int k, T x, Object[] es, int n, Comparator&lt;? super T&gt; cmp) {
 418         // assert n &gt; 0;
 419         int half = n &gt;&gt;&gt; 1;
 420         while (k &lt; half) {
 421             int child = (k &lt;&lt; 1) + 1;
 422             Object c = es[child];
 423             int right = child + 1;
 424             if (right &lt; n &amp;&amp; cmp.compare((T) c, (T) es[right]) &gt; 0)
 425                 c = es[child = right];
 426             if (cmp.compare(x, (T) c) &lt;= 0)
 427                 break;
 428             es[k] = c;
 429             k = child;
 430         }
 431         es[k] = x;
 432     }
 433 
 434     /**
 435      * Establishes the heap invariant (described above) in the entire tree,
 436      * assuming nothing about the order of the elements prior to the call.
 437      * This classic algorithm due to Floyd (1964) is known to be O(size).
 438      */
 439     private void heapify() {
 440         final Object[] es = queue;
 441         int n = size, i = (n &gt;&gt;&gt; 1) - 1;
 442         final Comparator&lt;? super E&gt; cmp;
 443         if ((cmp = comparator) == null)
 444             for (; i &gt;= 0; i--)
 445                 siftDownComparable(i, (E) es[i], es, n);
 446         else
 447             for (; i &gt;= 0; i--)
 448                 siftDownUsingComparator(i, (E) es[i], es, n, cmp);
 449     }
 450 
 451     /**
 452      * Inserts the specified element into this priority queue.
 453      *
 454      * @param e the element to add
 455      * @return {@code true} (as specified by {@link Collection#add})
 456      * @throws ClassCastException if the specified element cannot be compared
 457      *         with elements currently in the priority queue according to the
 458      *         priority queue&#39;s ordering
 459      * @throws NullPointerException if the specified element is null
 460      */
 461     public boolean add(E e) {
 462         return offer(e);
 463     }
 464 
 465     /**
 466      * Inserts the specified element into this priority queue.
 467      * As the queue is unbounded, this method will never return {@code false}.
 468      *
 469      * @param e the element to add
 470      * @return {@code true} (as specified by {@link Queue#offer})
 471      * @throws ClassCastException if the specified element cannot be compared
 472      *         with elements currently in the priority queue according to the
 473      *         priority queue&#39;s ordering
 474      * @throws NullPointerException if the specified element is null
 475      */
 476     public boolean offer(E e) {
 477         if (e == null)
 478             throw new NullPointerException();
 479         final ReentrantLock lock = this.lock;
 480         lock.lock();
 481         int n, cap;
 482         Object[] es;
 483         while ((n = size) &gt;= (cap = (es = queue).length))
 484             tryGrow(es, cap);
 485         try {
 486             final Comparator&lt;? super E&gt; cmp;
 487             if ((cmp = comparator) == null)
 488                 siftUpComparable(n, e, es);
 489             else
 490                 siftUpUsingComparator(n, e, es, cmp);
 491             size = n + 1;
 492             notEmpty.signal();
 493         } finally {
 494             lock.unlock();
 495         }
 496         return true;
 497     }
 498 
 499     /**
 500      * Inserts the specified element into this priority queue.
 501      * As the queue is unbounded, this method will never block.
 502      *
 503      * @param e the element to add
 504      * @throws ClassCastException if the specified element cannot be compared
 505      *         with elements currently in the priority queue according to the
 506      *         priority queue&#39;s ordering
 507      * @throws NullPointerException if the specified element is null
 508      */
 509     public void put(E e) {
 510         offer(e); // never need to block
 511     }
 512 
 513     /**
 514      * Inserts the specified element into this priority queue.
 515      * As the queue is unbounded, this method will never block or
 516      * return {@code false}.
 517      *
 518      * @param e the element to add
 519      * @param timeout This parameter is ignored as the method never blocks
 520      * @param unit This parameter is ignored as the method never blocks
 521      * @return {@code true} (as specified by
 522      *  {@link BlockingQueue#offer(Object,long,TimeUnit) BlockingQueue.offer})
 523      * @throws ClassCastException if the specified element cannot be compared
 524      *         with elements currently in the priority queue according to the
 525      *         priority queue&#39;s ordering
 526      * @throws NullPointerException if the specified element is null
 527      */
 528     public boolean offer(E e, long timeout, TimeUnit unit) {
 529         return offer(e); // never need to block
 530     }
 531 
 532     public E poll() {
 533         final ReentrantLock lock = this.lock;
 534         lock.lock();
 535         try {
 536             return dequeue();
 537         } finally {
 538             lock.unlock();
 539         }
 540     }
 541 
 542     public E take() throws InterruptedException {
 543         final ReentrantLock lock = this.lock;
 544         lock.lockInterruptibly();
 545         E result;
 546         try {
 547             while ( (result = dequeue()) == null)
 548                 notEmpty.await();
 549         } finally {
 550             lock.unlock();
 551         }
 552         return result;
 553     }
 554 
 555     public E poll(long timeout, TimeUnit unit) throws InterruptedException {
 556         long nanos = unit.toNanos(timeout);
 557         final ReentrantLock lock = this.lock;
 558         lock.lockInterruptibly();
 559         E result;
 560         try {
 561             while ( (result = dequeue()) == null &amp;&amp; nanos &gt; 0)
 562                 nanos = notEmpty.awaitNanos(nanos);
 563         } finally {
 564             lock.unlock();
 565         }
 566         return result;
 567     }
 568 
 569     public E peek() {
 570         final ReentrantLock lock = this.lock;
 571         lock.lock();
 572         try {
 573             return (E) queue[0];
 574         } finally {
 575             lock.unlock();
 576         }
 577     }
 578 
 579     /**
 580      * Returns the comparator used to order the elements in this queue,
 581      * or {@code null} if this queue uses the {@linkplain Comparable
 582      * natural ordering} of its elements.
 583      *
 584      * @return the comparator used to order the elements in this queue,
 585      *         or {@code null} if this queue uses the natural
 586      *         ordering of its elements
 587      */
 588     public Comparator&lt;? super E&gt; comparator() {
 589         return comparator;
 590     }
 591 
 592     public int size() {
 593         final ReentrantLock lock = this.lock;
 594         lock.lock();
 595         try {
 596             return size;
 597         } finally {
 598             lock.unlock();
 599         }
 600     }
 601 
 602     /**
 603      * Always returns {@code Integer.MAX_VALUE} because
 604      * a {@code PriorityBlockingQueue} is not capacity constrained.
 605      * @return {@code Integer.MAX_VALUE} always
 606      */
 607     public int remainingCapacity() {
 608         return Integer.MAX_VALUE;
 609     }
 610 
 611     private int indexOf(Object o) {
 612         if (o != null) {
 613             final Object[] es = queue;
 614             for (int i = 0, n = size; i &lt; n; i++)
 615                 if (o.equals(es[i]))
 616                     return i;
 617         }
 618         return -1;
 619     }
 620 
 621     /**
 622      * Removes the ith element from queue.
 623      */
 624     private void removeAt(int i) {
 625         final Object[] es = queue;
 626         final int n = size - 1;
 627         if (n == i) // removed last element
 628             es[i] = null;
 629         else {
 630             E moved = (E) es[n];
 631             es[n] = null;
 632             final Comparator&lt;? super E&gt; cmp;
 633             if ((cmp = comparator) == null)
 634                 siftDownComparable(i, moved, es, n);
 635             else
 636                 siftDownUsingComparator(i, moved, es, n, cmp);
 637             if (es[i] == moved) {
 638                 if (cmp == null)
 639                     siftUpComparable(i, moved, es);
 640                 else
 641                     siftUpUsingComparator(i, moved, es, cmp);
 642             }
 643         }
 644         size = n;
 645     }
 646 
 647     /**
 648      * Removes a single instance of the specified element from this queue,
 649      * if it is present.  More formally, removes an element {@code e} such
 650      * that {@code o.equals(e)}, if this queue contains one or more such
 651      * elements.  Returns {@code true} if and only if this queue contained
 652      * the specified element (or equivalently, if this queue changed as a
 653      * result of the call).
 654      *
 655      * @param o element to be removed from this queue, if present
 656      * @return {@code true} if this queue changed as a result of the call
 657      */
 658     public boolean remove(Object o) {
 659         final ReentrantLock lock = this.lock;
 660         lock.lock();
 661         try {
 662             int i = indexOf(o);
 663             if (i == -1)
 664                 return false;
 665             removeAt(i);
 666             return true;
 667         } finally {
 668             lock.unlock();
 669         }
 670     }
 671 
 672     /**
 673      * Identity-based version for use in Itr.remove.
 674      *
 675      * @param o element to be removed from this queue, if present
 676      */
 677     void removeEq(Object o) {
 678         final ReentrantLock lock = this.lock;
 679         lock.lock();
 680         try {
 681             final Object[] es = queue;
 682             for (int i = 0, n = size; i &lt; n; i++) {
 683                 if (o == es[i]) {
 684                     removeAt(i);
 685                     break;
 686                 }
 687             }
 688         } finally {
 689             lock.unlock();
 690         }
 691     }
 692 
 693     /**
 694      * Returns {@code true} if this queue contains the specified element.
 695      * More formally, returns {@code true} if and only if this queue contains
 696      * at least one element {@code e} such that {@code o.equals(e)}.
 697      *
 698      * @param o object to be checked for containment in this queue
 699      * @return {@code true} if this queue contains the specified element
 700      */
 701     public boolean contains(Object o) {
 702         final ReentrantLock lock = this.lock;
 703         lock.lock();
 704         try {
 705             return indexOf(o) != -1;
 706         } finally {
 707             lock.unlock();
 708         }
 709     }
 710 
 711     public String toString() {
 712         return Helpers.collectionToString(this);
 713     }
 714 
 715     /**
 716      * @throws UnsupportedOperationException {@inheritDoc}
 717      * @throws ClassCastException            {@inheritDoc}
 718      * @throws NullPointerException          {@inheritDoc}
 719      * @throws IllegalArgumentException      {@inheritDoc}
 720      */
 721     public int drainTo(Collection&lt;? super E&gt; c) {
 722         return drainTo(c, Integer.MAX_VALUE);
 723     }
 724 
 725     /**
 726      * @throws UnsupportedOperationException {@inheritDoc}
 727      * @throws ClassCastException            {@inheritDoc}
 728      * @throws NullPointerException          {@inheritDoc}
 729      * @throws IllegalArgumentException      {@inheritDoc}
 730      */
 731     public int drainTo(Collection&lt;? super E&gt; c, int maxElements) {
 732         Objects.requireNonNull(c);
 733         if (c == this)
 734             throw new IllegalArgumentException();
 735         if (maxElements &lt;= 0)
 736             return 0;
 737         final ReentrantLock lock = this.lock;
 738         lock.lock();
 739         try {
 740             int n = Math.min(size, maxElements);
 741             for (int i = 0; i &lt; n; i++) {
 742                 c.add((E) queue[0]); // In this order, in case add() throws.
 743                 dequeue();
 744             }
 745             return n;
 746         } finally {
 747             lock.unlock();
 748         }
 749     }
 750 
 751     /**
 752      * Atomically removes all of the elements from this queue.
 753      * The queue will be empty after this call returns.
 754      */
 755     public void clear() {
 756         final ReentrantLock lock = this.lock;
 757         lock.lock();
 758         try {
 759             final Object[] es = queue;
 760             for (int i = 0, n = size; i &lt; n; i++)
 761                 es[i] = null;
 762             size = 0;
 763         } finally {
 764             lock.unlock();
 765         }
 766     }
 767 
 768     /**
 769      * Returns an array containing all of the elements in this queue.
 770      * The returned array elements are in no particular order.
 771      *
 772      * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
 773      * maintained by this queue.  (In other words, this method must allocate
 774      * a new array).  The caller is thus free to modify the returned array.
 775      *
 776      * &lt;p&gt;This method acts as bridge between array-based and collection-based
 777      * APIs.
 778      *
 779      * @return an array containing all of the elements in this queue
 780      */
 781     public Object[] toArray() {
 782         final ReentrantLock lock = this.lock;
 783         lock.lock();
 784         try {
 785             return Arrays.copyOf(queue, size);
 786         } finally {
 787             lock.unlock();
 788         }
 789     }
 790 
 791     /**
 792      * Returns an array containing all of the elements in this queue; the
 793      * runtime type of the returned array is that of the specified array.
 794      * The returned array elements are in no particular order.
 795      * If the queue fits in the specified array, it is returned therein.
 796      * Otherwise, a new array is allocated with the runtime type of the
 797      * specified array and the size of this queue.
 798      *
 799      * &lt;p&gt;If this queue fits in the specified array with room to spare
 800      * (i.e., the array has more elements than this queue), the element in
 801      * the array immediately following the end of the queue is set to
 802      * {@code null}.
 803      *
 804      * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
 805      * array-based and collection-based APIs.  Further, this method allows
 806      * precise control over the runtime type of the output array, and may,
 807      * under certain circumstances, be used to save allocation costs.
 808      *
 809      * &lt;p&gt;Suppose {@code x} is a queue known to contain only strings.
 810      * The following code can be used to dump the queue into a newly
 811      * allocated array of {@code String}:
 812      *
 813      * &lt;pre&gt; {@code String[] y = x.toArray(new String[0]);}&lt;/pre&gt;
 814      *
 815      * Note that {@code toArray(new Object[0])} is identical in function to
 816      * {@code toArray()}.
 817      *
 818      * @param a the array into which the elements of the queue are to
 819      *          be stored, if it is big enough; otherwise, a new array of the
 820      *          same runtime type is allocated for this purpose
 821      * @return an array containing all of the elements in this queue
 822      * @throws ArrayStoreException if the runtime type of the specified array
 823      *         is not a supertype of the runtime type of every element in
 824      *         this queue
 825      * @throws NullPointerException if the specified array is null
 826      */
 827     public &lt;T&gt; T[] toArray(T[] a) {
 828         final ReentrantLock lock = this.lock;
 829         lock.lock();
 830         try {
 831             int n = size;
 832             if (a.length &lt; n)
 833                 // Make a new array of a&#39;s runtime type, but my contents:
 834                 return (T[]) Arrays.copyOf(queue, size, a.getClass());
 835             System.arraycopy(queue, 0, a, 0, n);
 836             if (a.length &gt; n)
 837                 a[n] = null;
 838             return a;
 839         } finally {
 840             lock.unlock();
 841         }
 842     }
 843 
 844     /**
 845      * Returns an iterator over the elements in this queue. The
 846      * iterator does not return the elements in any particular order.
 847      *
 848      * &lt;p&gt;The returned iterator is
 849      * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
 850      *
 851      * @return an iterator over the elements in this queue
 852      */
 853     public Iterator&lt;E&gt; iterator() {
 854         return new Itr(toArray());
 855     }
 856 
 857     /**
 858      * Snapshot iterator that works off copy of underlying q array.
 859      */
 860     final class Itr implements Iterator&lt;E&gt; {
 861         final Object[] array; // Array of all elements
 862         int cursor;           // index of next element to return
 863         int lastRet = -1;     // index of last element, or -1 if no such
 864 
 865         Itr(Object[] array) {
 866             this.array = array;
 867         }
 868 
 869         public boolean hasNext() {
 870             return cursor &lt; array.length;
 871         }
 872 
 873         public E next() {
 874             if (cursor &gt;= array.length)
 875                 throw new NoSuchElementException();
 876             return (E)array[lastRet = cursor++];
 877         }
 878 
 879         public void remove() {
 880             if (lastRet &lt; 0)
 881                 throw new IllegalStateException();
 882             removeEq(array[lastRet]);
 883             lastRet = -1;
 884         }
 885 
 886         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
 887             Objects.requireNonNull(action);
 888             final Object[] es = array;
 889             int i;
 890             if ((i = cursor) &lt; es.length) {
 891                 lastRet = -1;
 892                 cursor = es.length;
 893                 for (; i &lt; es.length; i++)
 894                     action.accept((E) es[i]);
 895                 lastRet = es.length - 1;
 896             }
 897         }
 898     }
 899 
 900     /**
 901      * Saves this queue to a stream (that is, serializes it).
 902      *
 903      * For compatibility with previous version of this class, elements
 904      * are first copied to a java.util.PriorityQueue, which is then
 905      * serialized.
 906      *
 907      * @param s the stream
 908      * @throws java.io.IOException if an I/O error occurs
 909      */
 910     private void writeObject(java.io.ObjectOutputStream s)
 911         throws java.io.IOException {
 912         lock.lock();
 913         try {
 914             // avoid zero capacity argument
 915             q = new PriorityQueue&lt;E&gt;(Math.max(size, 1), comparator);
 916             q.addAll(this);
 917             s.defaultWriteObject();
 918         } finally {
 919             q = null;
 920             lock.unlock();
 921         }
 922     }
 923 
 924     /**
 925      * Reconstitutes this queue from a stream (that is, deserializes it).
 926      * @param s the stream
 927      * @throws ClassNotFoundException if the class of a serialized object
 928      *         could not be found
 929      * @throws java.io.IOException if an I/O error occurs
 930      */
 931     private void readObject(java.io.ObjectInputStream s)
 932         throws java.io.IOException, ClassNotFoundException {
 933         try {
 934             s.defaultReadObject();
 935             int sz = q.size();
 936             SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, sz);
 937             this.queue = new Object[Math.max(1, sz)];
 938             comparator = q.comparator();
 939             addAll(q);
 940         } finally {
 941             q = null;
 942         }
 943     }
 944 
 945     /**
 946      * Immutable snapshot spliterator that binds to elements &quot;late&quot;.
 947      */
 948     final class PBQSpliterator implements Spliterator&lt;E&gt; {
 949         Object[] array;        // null until late-bound-initialized
 950         int index;
 951         int fence;
 952 
 953         PBQSpliterator() {}
 954 
 955         PBQSpliterator(Object[] array, int index, int fence) {
 956             this.array = array;
 957             this.index = index;
 958             this.fence = fence;
 959         }
 960 
 961         private int getFence() {
 962             if (array == null)
 963                 fence = (array = toArray()).length;
 964             return fence;
 965         }
 966 
 967         public PBQSpliterator trySplit() {
 968             int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
 969             return (lo &gt;= mid) ? null :
 970                 new PBQSpliterator(array, lo, index = mid);
 971         }
 972 
 973         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
 974             Objects.requireNonNull(action);
 975             final int hi = getFence(), lo = index;
 976             final Object[] es = array;
 977             index = hi;                 // ensure exhaustion
 978             for (int i = lo; i &lt; hi; i++)
 979                 action.accept((E) es[i]);
 980         }
 981 
 982         public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
 983             Objects.requireNonNull(action);
 984             if (getFence() &gt; index &amp;&amp; index &gt;= 0) {
 985                 action.accept((E) array[index++]);
 986                 return true;
 987             }
 988             return false;
 989         }
 990 
 991         public long estimateSize() { return getFence() - index; }
 992 
 993         public int characteristics() {
 994             return (Spliterator.NONNULL |
 995                     Spliterator.SIZED |
 996                     Spliterator.SUBSIZED);
 997         }
 998     }
 999 
1000     /**
1001      * Returns a {@link Spliterator} over the elements in this queue.
1002      * The spliterator does not traverse elements in any particular order
1003      * (the {@link Spliterator#ORDERED ORDERED} characteristic is not reported).
1004      *
1005      * &lt;p&gt;The returned spliterator is
1006      * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
1007      *
1008      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED} and
1009      * {@link Spliterator#NONNULL}.
1010      *
1011      * @implNote
1012      * The {@code Spliterator} additionally reports {@link Spliterator#SUBSIZED}.
1013      *
1014      * @return a {@code Spliterator} over the elements in this queue
1015      * @since 1.8
1016      */
1017     public Spliterator&lt;E&gt; spliterator() {
1018         return new PBQSpliterator();
1019     }
1020 
1021     /**
1022      * @throws NullPointerException {@inheritDoc}
1023      */
1024     public boolean removeIf(Predicate&lt;? super E&gt; filter) {
1025         Objects.requireNonNull(filter);
1026         return bulkRemove(filter);
1027     }
1028 
1029     /**
1030      * @throws NullPointerException {@inheritDoc}
1031      */
1032     public boolean removeAll(Collection&lt;?&gt; c) {
1033         Objects.requireNonNull(c);
1034         return bulkRemove(e -&gt; c.contains(e));
1035     }
1036 
1037     /**
1038      * @throws NullPointerException {@inheritDoc}
1039      */
1040     public boolean retainAll(Collection&lt;?&gt; c) {
1041         Objects.requireNonNull(c);
1042         return bulkRemove(e -&gt; !c.contains(e));
1043     }
1044 
1045     // A tiny bit set implementation
1046 
1047     private static long[] nBits(int n) {
1048         return new long[((n - 1) &gt;&gt; 6) + 1];
1049     }
1050     private static void setBit(long[] bits, int i) {
1051         bits[i &gt;&gt; 6] |= 1L &lt;&lt; i;
1052     }
1053     private static boolean isClear(long[] bits, int i) {
1054         return (bits[i &gt;&gt; 6] &amp; (1L &lt;&lt; i)) == 0;
1055     }
1056 
1057     /** Implementation of bulk remove methods. */
1058     private boolean bulkRemove(Predicate&lt;? super E&gt; filter) {
1059         final ReentrantLock lock = this.lock;
1060         lock.lock();
1061         try {
1062             final Object[] es = queue;
1063             final int end = size;
1064             int i;
1065             // Optimize for initial run of survivors
1066             for (i = 0; i &lt; end &amp;&amp; !filter.test((E) es[i]); i++)
1067                 ;
1068             if (i &gt;= end)
1069                 return false;
1070             // Tolerate predicates that reentrantly access the
1071             // collection for read, so traverse once to find elements
1072             // to delete, a second pass to physically expunge.
1073             final int beg = i;
1074             final long[] deathRow = nBits(end - beg);
1075             deathRow[0] = 1L;   // set bit 0
1076             for (i = beg + 1; i &lt; end; i++)
1077                 if (filter.test((E) es[i]))
1078                     setBit(deathRow, i - beg);
1079             int w = beg;
1080             for (i = beg; i &lt; end; i++)
1081                 if (isClear(deathRow, i - beg))
1082                     es[w++] = es[i];
1083             for (i = size = w; i &lt; end; i++)
1084                 es[i] = null;
1085             heapify();
1086             return true;
1087         } finally {
1088             lock.unlock();
1089         }
1090     }
1091 
1092     /**
1093      * @throws NullPointerException {@inheritDoc}
1094      */
1095     public void forEach(Consumer&lt;? super E&gt; action) {
1096         Objects.requireNonNull(action);
1097         final ReentrantLock lock = this.lock;
1098         lock.lock();
1099         try {
1100             final Object[] es = queue;
1101             for (int i = 0, n = size; i &lt; n; i++)
1102                 action.accept((E) es[i]);
1103         } finally {
1104             lock.unlock();
1105         }
1106     }
1107 
1108     // VarHandle mechanics
1109     private static final VarHandle ALLOCATIONSPINLOCK;
1110     static {
1111         try {
1112             MethodHandles.Lookup l = MethodHandles.lookup();
1113             ALLOCATIONSPINLOCK = l.findVarHandle(PriorityBlockingQueue.class,
1114                                                  &quot;allocationSpinLock&quot;,
1115                                                  int.class);
1116         } catch (ReflectiveOperationException e) {
1117             throw new ExceptionInInitializerError(e);
1118         }
1119     }
1120 }
    </pre>
  </body>
</html>
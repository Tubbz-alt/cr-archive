<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/share/native/applauncher/JvmLauncher.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;cstring&gt;
 27 #include &lt;jni.h&gt;
 28 #include &quot;JvmLauncher.h&quot;
 29 #include &quot;Log.h&quot;
 30 #include &quot;Dll.h&quot;
 31 #include &quot;CfgFile.h&quot;
 32 #include &quot;FileUtils.h&quot;
 33 #include &quot;Toolbox.h&quot;
 34 #include &quot;ErrorHandling.h&quot;
 35 
 36 
 37 Jvm&amp; Jvm::initFromConfigFile(const CfgFile&amp; cfgFile) {
 38     const CfgFile::Properties&amp; appOptions = cfgFile.getProperties(
 39             SectionName::Application);
 40 
 41     do {
 42         const CfgFile::Properties::const_iterator modulepath = appOptions.find(
 43                 PropertyName::modulepath);
 44         if (modulepath != appOptions.end()) {
 45             tstring_array::const_iterator it = modulepath-&gt;second.begin();
 46             const tstring_array::const_iterator end = modulepath-&gt;second.end();
 47             for (; it != end; ++it) {
 48                 addArgument(_T(&quot;--module-path&quot;));
 49                 addArgument(*it);
 50             };
 51         }
 52     } while (0);
 53 
 54     do {
 55         const CfgFile::Properties::const_iterator classpath = appOptions.find(
 56                 PropertyName::classpath);
 57         if (classpath != appOptions.end()) {
 58             addArgument(_T(&quot;-classpath&quot;));
 59             addArgument(CfgFile::asPathList(*classpath));
 60         }
 61     } while (0);
 62 
 63     do {
 64         const CfgFile::Properties::const_iterator splash = appOptions.find(
 65                 PropertyName::splash);
 66         if (splash != appOptions.end()) {
 67             const tstring splashPath = CfgFile::asString(*splash);
 68             if (FileUtils::isFileExists(splashPath)) {
 69                 addArgument(_T(&quot;-splash&quot;));
 70                 addArgument(splashPath);
 71             } else {
 72                 LOG_WARNING(tstrings::any()
 73                         &lt;&lt; &quot;Splash property ignored. File \&quot;&quot;
 74                         &lt;&lt; splashPath &lt;&lt; &quot;\&quot; not found&quot;);
 75             }
 76         }
 77     } while (0);
 78 
 79     do {
 80         const CfgFile::Properties&amp; section = cfgFile.getProperties(
 81                 SectionName::JavaOptions);
 82         const CfgFile::Properties::const_iterator javaOptions = section.find(
 83                 PropertyName::javaOptions);
 84         if (javaOptions != section.end()) {
 85             tstring_array::const_iterator it = javaOptions-&gt;second.begin();
 86             const tstring_array::const_iterator end = javaOptions-&gt;second.end();
 87             for (; it != end; ++it) {
 88                 addArgument(*it);
 89             };
 90         }
 91     } while (0);
 92 
 93     // No validation of data in config file related to how Java app should be
 94     // launched intentionally.
 95     // Just read what is in config file and put on jvm&#39;s command line as is.
 96 
 97     do { // Run modular app
 98         const CfgFile::Properties::const_iterator mainmodule = appOptions.find(
 99                 PropertyName::mainmodule);
100         if (mainmodule != appOptions.end()) {
101             addArgument(_T(&quot;-m&quot;));
102             addArgument(CfgFile::asString(*mainmodule));
103         }
104     } while (0);
105 
106     do { // Run main class
107         const CfgFile::Properties::const_iterator mainclass = appOptions.find(
108                 PropertyName::mainclass);
109         if (mainclass != appOptions.end()) {
110             addArgument(CfgFile::asString(*mainclass));
111         }
112     } while (0);
113 
114     do { // Run jar
115         const CfgFile::Properties::const_iterator mainjar = appOptions.find(
116                 PropertyName::mainjar);
117         if (mainjar != appOptions.end()) {
118             addArgument(_T(&quot;-jar&quot;));
119             addArgument(CfgFile::asString(*mainjar));
120         }
121     } while (0);
122 
123     do {
124         const CfgFile::Properties&amp; section = cfgFile.getProperties(
125                 SectionName::ArgOptions);
126         const CfgFile::Properties::const_iterator arguments = section.find(
127                 PropertyName::arguments);
128         if (arguments != section.end()) {
129             tstring_array::const_iterator it = arguments-&gt;second.begin();
130             const tstring_array::const_iterator end = arguments-&gt;second.end();
131             for (; it != end; ++it) {
132                 addArgument(*it);
133             };
134         }
135     } while (0);
136 
137     return *this;
138 }
139 
140 
141 namespace {
142 void convertArgs(const std::vector&lt;std::string&gt;&amp; args, std::vector&lt;char*&gt;&amp; argv) {
143     argv.reserve(args.size() + 1);
144     argv.resize(0);
145 
146     std::vector&lt;std::string&gt;::const_iterator it = args.begin();
147     const std::vector&lt;std::string&gt;::const_iterator end = args.end();
148 
149     for (; it != end; ++it) {
150         argv.push_back(const_cast&lt;char*&gt;(it-&gt;c_str()));
151     };
152 
153     // Add treminal &#39;0&#39;.
154     argv.push_back(0);
155 }
156 } // namespace
157 
158 void Jvm::launch() {
159     typedef int (JNICALL *LaunchFuncType)(int argc, char ** argv,
160         int jargc, const char** jargv,
161         int appclassc, const char** appclassv,
162         const char* fullversion,
163         const char* dotversion,
164         const char* pname,
165         const char* lname,
166         jboolean javaargs,
167         jboolean cpwildcard,
168         jboolean javaw,
169         jint ergo);
170 
171     std::vector&lt;char*&gt; argv;
172 #ifdef TSTRINGS_WITH_WCHAR
173     std::vector&lt;std::string&gt; mbcs_args;
174     do {
175         tstring_array::const_iterator it = args.begin();
176         const tstring_array::const_iterator end = args.end();
177         for (; it != end; ++it) {
178             mbcs_args.push_back(tstrings::toACP(*it));
179         }
180     } while (0);
181     convertArgs(mbcs_args, argv);
182 #else
183     convertArgs(args, argv);
184 #endif
185 
186     // Don&#39;t count terminal &#39;0&#39;.
187     const int argc = (int)argv.size() - 1;
188 
189     LOG_TRACE(tstrings::any() &lt;&lt; &quot;JVM library: \&quot;&quot; &lt;&lt; jvmPath &lt;&lt; &quot;\&quot;&quot;);
190 
191     DllFunction&lt;LaunchFuncType&gt; func(Dll(jvmPath), &quot;JLI_Launch&quot;);
192     int exitStatus = func(argc, argv.data(),
193         0, 0,
194         0, 0,
195         &quot;&quot;,
196         &quot;&quot;,
197         &quot;java&quot;,
198         &quot;java&quot;,
199         JNI_FALSE,
200         JNI_FALSE,
201         JNI_FALSE,
202         0);
203 
204     if (exitStatus != 0) {
205         JP_THROW(&quot;Failed to launch JVM&quot;);
206     }
207 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/cpCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassVtable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/cpCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
550     default:
551       break;
552     }
553   }
554   return NULL;
555 }
556 
557 
558 oop ConstantPoolCacheEntry::appendix_if_resolved(const constantPoolHandle&amp; cpool) {
559   if (!has_appendix())
560     return NULL;
561   const int ref_index = f2_as_index();
562   objArrayOop resolved_references = cpool-&gt;resolved_references();
563   return resolved_references-&gt;obj_at(ref_index);
564 }
565 
566 
567 #if INCLUDE_JVMTI
568 
569 void log_adjust(const char* entry_type, Method* old_method, Method* new_method, bool* trace_name_printed) {
<span class="line-modified">570   if (log_is_enabled(Info, redefine, class, update)) {</span>
<span class="line-modified">571     ResourceMark rm;</span>
<span class="line-modified">572     if (!(*trace_name_printed)) {</span>
<span class="line-modified">573       log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());</span>
<span class="line-modified">574       *trace_name_printed = true;</span>
<span class="line-removed">575     }</span>
<span class="line-removed">576     log_debug(redefine, class, update, constantpool)</span>
<span class="line-removed">577           (&quot;cpc %s entry update: %s(%s)&quot;, entry_type, new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());</span>
578   }


579 }
580 
581 // RedefineClasses() API support:
582 // If this ConstantPoolCacheEntry refers to old_method then update it
583 // to refer to new_method.
584 void ConstantPoolCacheEntry::adjust_method_entry(Method* old_method,
585        Method* new_method, bool * trace_name_printed) {
586 
587   if (is_vfinal()) {
588     // virtual and final so _f2 contains method ptr instead of vtable index
589     if (f2_as_vfinal_method() == old_method) {
590       // match old_method so need an update
591       // NOTE: can&#39;t use set_f2_as_vfinal_method as it asserts on different values
592       _f2 = (intptr_t)new_method;
593       log_adjust(&quot;vfinal&quot;, old_method, new_method, trace_name_printed);
594     }
595     return;
596   }
597 
598   assert (_f1 != NULL, &quot;should not call with uninteresting entry&quot;);
</pre>
<hr />
<pre>
798 // old_methods, replace it with the corresponding new_method.
799 void ConstantPoolCache::adjust_method_entries(bool * trace_name_printed) {
800   for (int i = 0; i &lt; length(); i++) {
801     ConstantPoolCacheEntry* entry = entry_at(i);
802     Method* old_method = entry-&gt;get_interesting_method_entry();
803     if (old_method == NULL || !old_method-&gt;is_old()) {
804       continue; // skip uninteresting entries
805     }
806     if (old_method-&gt;is_deleted()) {
807       // clean up entries with deleted methods
808       entry-&gt;initialize_entry(entry-&gt;constant_pool_index());
809       continue;
810     }
811     Method* new_method = old_method-&gt;get_new_method();
812     entry_at(i)-&gt;adjust_method_entry(old_method, new_method, trace_name_printed);
813   }
814 }
815 
816 // the constant pool cache should never contain old or obsolete methods
817 bool ConstantPoolCache::check_no_old_or_obsolete_entries() {

818   for (int i = 1; i &lt; length(); i++) {
<span class="line-modified">819     if (entry_at(i)-&gt;get_interesting_method_entry() != NULL &amp;&amp;</span>
<span class="line-modified">820         !entry_at(i)-&gt;check_no_old_or_obsolete_entries()) {</span>



821       return false;
822     }
823   }
824   return true;
825 }
826 
827 void ConstantPoolCache::dump_cache() {
828   for (int i = 1; i &lt; length(); i++) {
829     if (entry_at(i)-&gt;get_interesting_method_entry() != NULL) {
830       entry_at(i)-&gt;print(tty, i);
831     }
832   }
833 }
834 #endif // INCLUDE_JVMTI
835 
836 void ConstantPoolCache::metaspace_pointers_do(MetaspaceClosure* it) {
837   log_trace(cds)(&quot;Iter(ConstantPoolCache): %p&quot;, this);
838   it-&gt;push(&amp;_constant_pool);
839   it-&gt;push(&amp;_reference_map);
840 }
</pre>
</td>
<td>
<hr />
<pre>
550     default:
551       break;
552     }
553   }
554   return NULL;
555 }
556 
557 
558 oop ConstantPoolCacheEntry::appendix_if_resolved(const constantPoolHandle&amp; cpool) {
559   if (!has_appendix())
560     return NULL;
561   const int ref_index = f2_as_index();
562   objArrayOop resolved_references = cpool-&gt;resolved_references();
563   return resolved_references-&gt;obj_at(ref_index);
564 }
565 
566 
567 #if INCLUDE_JVMTI
568 
569 void log_adjust(const char* entry_type, Method* old_method, Method* new_method, bool* trace_name_printed) {
<span class="line-modified">570   ResourceMark rm;</span>
<span class="line-modified">571 </span>
<span class="line-modified">572   if (!(*trace_name_printed)) {</span>
<span class="line-modified">573     log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());</span>
<span class="line-modified">574     *trace_name_printed = true;</span>



575   }
<span class="line-added">576   log_trace(redefine, class, update, constantpool)</span>
<span class="line-added">577     (&quot;cpc %s entry update: %s&quot;, entry_type, new_method-&gt;external_name());</span>
578 }
579 
580 // RedefineClasses() API support:
581 // If this ConstantPoolCacheEntry refers to old_method then update it
582 // to refer to new_method.
583 void ConstantPoolCacheEntry::adjust_method_entry(Method* old_method,
584        Method* new_method, bool * trace_name_printed) {
585 
586   if (is_vfinal()) {
587     // virtual and final so _f2 contains method ptr instead of vtable index
588     if (f2_as_vfinal_method() == old_method) {
589       // match old_method so need an update
590       // NOTE: can&#39;t use set_f2_as_vfinal_method as it asserts on different values
591       _f2 = (intptr_t)new_method;
592       log_adjust(&quot;vfinal&quot;, old_method, new_method, trace_name_printed);
593     }
594     return;
595   }
596 
597   assert (_f1 != NULL, &quot;should not call with uninteresting entry&quot;);
</pre>
<hr />
<pre>
797 // old_methods, replace it with the corresponding new_method.
798 void ConstantPoolCache::adjust_method_entries(bool * trace_name_printed) {
799   for (int i = 0; i &lt; length(); i++) {
800     ConstantPoolCacheEntry* entry = entry_at(i);
801     Method* old_method = entry-&gt;get_interesting_method_entry();
802     if (old_method == NULL || !old_method-&gt;is_old()) {
803       continue; // skip uninteresting entries
804     }
805     if (old_method-&gt;is_deleted()) {
806       // clean up entries with deleted methods
807       entry-&gt;initialize_entry(entry-&gt;constant_pool_index());
808       continue;
809     }
810     Method* new_method = old_method-&gt;get_new_method();
811     entry_at(i)-&gt;adjust_method_entry(old_method, new_method, trace_name_printed);
812   }
813 }
814 
815 // the constant pool cache should never contain old or obsolete methods
816 bool ConstantPoolCache::check_no_old_or_obsolete_entries() {
<span class="line-added">817   ResourceMark rm;</span>
818   for (int i = 1; i &lt; length(); i++) {
<span class="line-modified">819     Method* m = entry_at(i)-&gt;get_interesting_method_entry();</span>
<span class="line-modified">820     if (m != NULL &amp;&amp; !entry_at(i)-&gt;check_no_old_or_obsolete_entries()) {</span>
<span class="line-added">821       log_trace(redefine, class, update, constantpool)</span>
<span class="line-added">822         (&quot;cpcache check found old method entry: class: %s, old: %d, obsolete: %d, method: %s&quot;,</span>
<span class="line-added">823          constant_pool()-&gt;pool_holder()-&gt;external_name(), m-&gt;is_old(), m-&gt;is_obsolete(), m-&gt;external_name());</span>
824       return false;
825     }
826   }
827   return true;
828 }
829 
830 void ConstantPoolCache::dump_cache() {
831   for (int i = 1; i &lt; length(); i++) {
832     if (entry_at(i)-&gt;get_interesting_method_entry() != NULL) {
833       entry_at(i)-&gt;print(tty, i);
834     }
835   }
836 }
837 #endif // INCLUDE_JVMTI
838 
839 void ConstantPoolCache::metaspace_pointers_do(MetaspaceClosure* it) {
840   log_trace(cds)(&quot;Iter(ConstantPoolCache): %p&quot;, this);
841   it-&gt;push(&amp;_constant_pool);
842   it-&gt;push(&amp;_reference_map);
843 }
</pre>
</td>
</tr>
</table>
<center><a href="../memory/metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassVtable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
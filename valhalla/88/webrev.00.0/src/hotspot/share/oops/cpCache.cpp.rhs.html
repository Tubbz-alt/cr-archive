<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/cpCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/resolutionErrors.hpp&quot;
 27 #include &quot;interpreter/bytecodeStream.hpp&quot;
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;interpreter/rewriter.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
 33 #include &quot;logging/logStream.hpp&quot;
 34 #include &quot;memory/heapShared.hpp&quot;
 35 #include &quot;memory/metadataFactory.hpp&quot;
 36 #include &quot;memory/metaspaceClosure.hpp&quot;
 37 #include &quot;memory/metaspaceShared.hpp&quot;
 38 #include &quot;memory/resourceArea.hpp&quot;
 39 #include &quot;oops/access.inline.hpp&quot;
 40 #include &quot;oops/compressedOops.hpp&quot;
 41 #include &quot;oops/constantPool.inline.hpp&quot;
 42 #include &quot;oops/cpCache.inline.hpp&quot;
 43 #include &quot;oops/objArrayOop.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;prims/methodHandles.hpp&quot;
 46 #include &quot;runtime/atomic.hpp&quot;
 47 #include &quot;runtime/handles.inline.hpp&quot;
 48 #include &quot;utilities/macros.hpp&quot;
 49 
 50 // Implementation of ConstantPoolCacheEntry
 51 
 52 void ConstantPoolCacheEntry::initialize_entry(int index) {
 53   assert(0 &lt; index &amp;&amp; index &lt; 0x10000, &quot;sanity check&quot;);
 54   _indices = index;
 55   _f1 = NULL;
 56   _f2 = _flags = 0;
 57   assert(constant_pool_index() == index, &quot;&quot;);
 58 }
 59 
 60 void ConstantPoolCacheEntry::verify_just_initialized(bool f2_used) {
 61   assert((_indices &amp; (~cp_index_mask)) == 0, &quot;sanity&quot;);
 62   assert(_f1 == NULL, &quot;sanity&quot;);
 63   assert(_flags == 0, &quot;sanity&quot;);
 64   if (!f2_used) {
 65     assert(_f2 == 0, &quot;sanity&quot;);
 66   }
 67 }
 68 
 69 void ConstantPoolCacheEntry::reinitialize(bool f2_used) {
 70   _indices &amp;= cp_index_mask;
 71   _f1 = NULL;
 72   _flags = 0;
 73   if (!f2_used) {
 74     _f2 = 0;
 75   }
 76 }
 77 
 78 int ConstantPoolCacheEntry::make_flags(TosState state,
 79                                        int option_bits,
 80                                        int field_index_or_method_params) {
 81   assert(state &lt; number_of_states, &quot;Invalid state in make_flags&quot;);
 82   int f = ((int)state &lt;&lt; tos_state_shift) | option_bits | field_index_or_method_params;
 83   // Preserve existing flag bit values
 84   // The low bits are a field offset, or else the method parameter size.
 85 #ifdef ASSERT
 86   TosState old_state = flag_state();
 87   assert(old_state == (TosState)0 || old_state == state,
 88          &quot;inconsistent cpCache flags state&quot;);
 89 #endif
 90   return (_flags | f) ;
 91 }
 92 
 93 void ConstantPoolCacheEntry::set_bytecode_1(Bytecodes::Code code) {
 94 #ifdef ASSERT
 95   // Read once.
 96   volatile Bytecodes::Code c = bytecode_1();
 97   assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
 98 #endif
 99   // Need to flush pending stores here before bytecode is written.
100   Atomic::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_1_shift));
101 }
102 
103 void ConstantPoolCacheEntry::set_bytecode_2(Bytecodes::Code code) {
104 #ifdef ASSERT
105   // Read once.
106   volatile Bytecodes::Code c = bytecode_2();
107   assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
108 #endif
109   // Need to flush pending stores here before bytecode is written.
110   Atomic::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_2_shift));
111 }
112 
113 // Sets f1, ordering with previous writes.
114 void ConstantPoolCacheEntry::release_set_f1(Metadata* f1) {
115   assert(f1 != NULL, &quot;&quot;);
116   Atomic::release_store(&amp;_f1, f1);
117 }
118 
119 void ConstantPoolCacheEntry::set_indy_resolution_failed() {
120   Atomic::release_store(&amp;_flags, _flags | (1 &lt;&lt; indy_resolution_failed_shift));
121 }
122 
123 // Note that concurrent update of both bytecodes can leave one of them
124 // reset to zero.  This is harmless; the interpreter will simply re-resolve
125 // the damaged entry.  More seriously, the memory synchronization is needed
126 // to flush other fields (f1, f2) completely to memory before the bytecodes
127 // are updated, lest other processors see a non-zero bytecode but zero f1/f2.
128 void ConstantPoolCacheEntry::set_field(Bytecodes::Code get_code,
129                                        Bytecodes::Code put_code,
130                                        Klass* field_holder,
131                                        int field_index,
132                                        int field_offset,
133                                        TosState field_type,
134                                        bool is_final,
135                                        bool is_volatile,
136                                        bool is_inlined,
137                                        bool is_inline_type,
138                                        Klass* root_klass) {
139   set_f1(field_holder);
140   set_f2(field_offset);
141   assert((field_index &amp; field_index_mask) == field_index,
142          &quot;field index does not fit in low flag bits&quot;);
143   assert(!is_inlined || is_inline_type, &quot;Sanity check&quot;);
144   set_field_flags(field_type,
145                   ((is_volatile ? 1 : 0) &lt;&lt; is_volatile_shift) |
146                   ((is_final    ? 1 : 0) &lt;&lt; is_final_shift) |
147                   ((is_inlined  ? 1 : 0) &lt;&lt; is_inlined_shift) |
148                   ((is_inline_type ? 1 : 0) &lt;&lt; is_inline_type_shift),
149                   field_index);
150   set_bytecode_1(get_code);
151   set_bytecode_2(put_code);
152   NOT_PRODUCT(verify(tty));
153 }
154 
155 void ConstantPoolCacheEntry::set_parameter_size(int value) {
156   // This routine is called only in corner cases where the CPCE is not yet initialized.
157   // See AbstractInterpreter::deopt_continue_after_entry.
158   assert(_flags == 0 || parameter_size() == 0 || parameter_size() == value,
159          &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
160   // Setting the parameter size by itself is only safe if the
161   // current value of _flags is 0, otherwise another thread may have
162   // updated it and we don&#39;t want to overwrite that value.  Don&#39;t
163   // bother trying to update it once it&#39;s nonzero but always make
164   // sure that the final parameter size agrees with what was passed.
165   if (_flags == 0) {
166     intx newflags = (value &amp; parameter_size_mask);
167     Atomic::cmpxchg(&amp;_flags, (intx)0, newflags);
168   }
169   guarantee(parameter_size() == value,
170             &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
171 }
172 
173 void ConstantPoolCacheEntry::set_direct_or_vtable_call(Bytecodes::Code invoke_code,
174                                                        const methodHandle&amp; method,
175                                                        int vtable_index,
176                                                        bool sender_is_interface) {
177   bool is_vtable_call = (vtable_index &gt;= 0);  // FIXME: split this method on this boolean
178   assert(method-&gt;interpreter_entry() != NULL, &quot;should have been set at this point&quot;);
179   assert(!method-&gt;is_obsolete(),  &quot;attempt to write obsolete method to cpCache&quot;);
180 
181   int byte_no = -1;
182   bool change_to_virtual = false;
183   InstanceKlass* holder = NULL;  // have to declare this outside the switch
184   switch (invoke_code) {
185     case Bytecodes::_invokeinterface:
186       holder = method-&gt;method_holder();
187       // check for private interface method invocations
188       if (vtable_index == Method::nonvirtual_vtable_index &amp;&amp; holder-&gt;is_interface() ) {
189         assert(method-&gt;is_private(), &quot;unexpected non-private method&quot;);
190         assert(method-&gt;can_be_statically_bound(), &quot;unexpected non-statically-bound method&quot;);
191         // set_f2_as_vfinal_method checks if is_vfinal flag is true.
192         set_method_flags(as_TosState(method-&gt;result_type()),
193                          (                             1      &lt;&lt; is_vfinal_shift) |
194                          ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift),
195                          method()-&gt;size_of_parameters());
196         set_f2_as_vfinal_method(method());
197         byte_no = 2;
198         set_f1(holder); // interface klass*
199         break;
200       }
201       else {
202         // We get here from InterpreterRuntime::resolve_invoke when an invokeinterface
203         // instruction links to a non-interface method (in Object). This can happen when
204         // an interface redeclares an Object method (like CharSequence declaring toString())
205         // or when invokeinterface is used explicitly.
206         // In that case, the method has no itable index and must be invoked as a virtual.
207         // Set a flag to keep track of this corner case.
208         assert(holder-&gt;is_interface() || holder == SystemDictionary::Object_klass(), &quot;unexpected holder class&quot;);
209         assert(method-&gt;is_public(), &quot;Calling non-public method in Object with invokeinterface&quot;);
210         change_to_virtual = true;
211 
212         // ...and fall through as if we were handling invokevirtual:
213       }
214     case Bytecodes::_invokevirtual:
215       {
216         if (!is_vtable_call) {
217           assert(method-&gt;can_be_statically_bound(), &quot;&quot;);
218           // set_f2_as_vfinal_method checks if is_vfinal flag is true.
219           set_method_flags(as_TosState(method-&gt;result_type()),
220                            (                             1      &lt;&lt; is_vfinal_shift) |
221                            ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift)  |
222                            ((change_to_virtual         ? 1 : 0) &lt;&lt; is_forced_virtual_shift),
223                            method()-&gt;size_of_parameters());
224           set_f2_as_vfinal_method(method());
225         } else {
226           assert(!method-&gt;can_be_statically_bound(), &quot;&quot;);
227           assert(vtable_index &gt;= 0, &quot;valid index&quot;);
228           assert(!method-&gt;is_final_method(), &quot;sanity&quot;);
229           set_method_flags(as_TosState(method-&gt;result_type()),
230                            ((change_to_virtual ? 1 : 0) &lt;&lt; is_forced_virtual_shift),
231                            method()-&gt;size_of_parameters());
232           set_f2(vtable_index);
233         }
234         byte_no = 2;
235         break;
236       }
237 
238     case Bytecodes::_invokespecial:
239     case Bytecodes::_invokestatic:
240       assert(!is_vtable_call, &quot;&quot;);
241       // Note:  Read and preserve the value of the is_vfinal flag on any
242       // invokevirtual bytecode shared with this constant pool cache entry.
243       // It is cheap and safe to consult is_vfinal() at all times.
244       // Once is_vfinal is set, it must stay that way, lest we get a dangling oop.
245       set_method_flags(as_TosState(method-&gt;result_type()),
246                        ((is_vfinal()               ? 1 : 0) &lt;&lt; is_vfinal_shift) |
247                        ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift),
248                        method()-&gt;size_of_parameters());
249       set_f1(method());
250       byte_no = 1;
251       break;
252     default:
253       ShouldNotReachHere();
254       break;
255   }
256 
257   // Note:  byte_no also appears in TemplateTable::resolve.
258   if (byte_no == 1) {
259     assert(invoke_code != Bytecodes::_invokevirtual &amp;&amp;
260            invoke_code != Bytecodes::_invokeinterface, &quot;&quot;);
261     bool do_resolve = true;
262     // Don&#39;t mark invokespecial to method as resolved if sender is an interface.  The receiver
263     // has to be checked that it is a subclass of the current class every time this bytecode
264     // is executed.
265     if (invoke_code == Bytecodes::_invokespecial &amp;&amp; sender_is_interface &amp;&amp;
266         method-&gt;name() != vmSymbols::object_initializer_name()) {
267       do_resolve = false;
268     }
269     if (invoke_code == Bytecodes::_invokestatic) {
270       assert(method-&gt;method_holder()-&gt;is_initialized() ||
271              method-&gt;method_holder()-&gt;is_reentrant_initialization(Thread::current()),
272              &quot;invalid class initialization state for invoke_static&quot;);
273 
274       if (!VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {
275         // Don&#39;t mark invokestatic to method as resolved if the holder class has not yet completed
276         // initialization. An invokestatic must only proceed if the class is initialized, but if
277         // we resolve it before then that class initialization check is skipped.
278         //
279         // When fast class initialization checks are supported (VM_Version::supports_fast_class_init_checks() == true),
280         // template interpreter supports fast class initialization check for
281         // invokestatic which doesn&#39;t require call site re-resolution to
282         // enforce class initialization barrier.
283         do_resolve = false;
284       }
285     }
286     if (do_resolve) {
287       set_bytecode_1(invoke_code);
288     }
289   } else if (byte_no == 2)  {
290     if (change_to_virtual) {
291       assert(invoke_code == Bytecodes::_invokeinterface, &quot;&quot;);
292       // NOTE: THIS IS A HACK - BE VERY CAREFUL!!!
293       //
294       // Workaround for the case where we encounter an invokeinterface, but we
295       // should really have an _invokevirtual since the resolved method is a
296       // virtual method in java.lang.Object. This is a corner case in the spec
297       // but is presumably legal. javac does not generate this code.
298       //
299       // We do not set bytecode_1() to _invokeinterface, because that is the
300       // bytecode # used by the interpreter to see if it is resolved.  In this
301       // case, the method gets reresolved with caller for each interface call
302       // because the actual selected method may not be public.
303       //
304       // We set bytecode_2() to _invokevirtual.
305       // See also interpreterRuntime.cpp. (8/25/2000)
306       invoke_code = Bytecodes::_invokevirtual;
307     } else {
308       assert(invoke_code == Bytecodes::_invokevirtual ||
309              (invoke_code == Bytecodes::_invokeinterface &amp;&amp;
310               ((method-&gt;is_private() ||
311                 (method-&gt;is_final() &amp;&amp; method-&gt;method_holder() == SystemDictionary::Object_klass())))),
312              &quot;unexpected invocation mode&quot;);
313       if (invoke_code == Bytecodes::_invokeinterface &amp;&amp;
314           (method-&gt;is_private() || method-&gt;is_final())) {
315         // We set bytecode_1() to _invokeinterface, because that is the
316         // bytecode # used by the interpreter to see if it is resolved.
317         // We set bytecode_2() to _invokevirtual.
318         set_bytecode_1(invoke_code);
319       }
320     }
321     // set up for invokevirtual, even if linking for invokeinterface also:
322     set_bytecode_2(invoke_code);
323   } else {
324     ShouldNotReachHere();
325   }
326   NOT_PRODUCT(verify(tty));
327 }
328 
329 void ConstantPoolCacheEntry::set_direct_call(Bytecodes::Code invoke_code, const methodHandle&amp; method,
330                                              bool sender_is_interface) {
331   int index = Method::nonvirtual_vtable_index;
332   // index &lt; 0; FIXME: inline and customize set_direct_or_vtable_call
333   set_direct_or_vtable_call(invoke_code, method, index, sender_is_interface);
334 }
335 
336 void ConstantPoolCacheEntry::set_vtable_call(Bytecodes::Code invoke_code, const methodHandle&amp; method, int index) {
337   // either the method is a miranda or its holder should accept the given index
338   assert(method-&gt;method_holder()-&gt;is_interface() || method-&gt;method_holder()-&gt;verify_vtable_index(index), &quot;&quot;);
339   // index &gt;= 0; FIXME: inline and customize set_direct_or_vtable_call
340   set_direct_or_vtable_call(invoke_code, method, index, false);
341 }
342 
343 void ConstantPoolCacheEntry::set_itable_call(Bytecodes::Code invoke_code,
344                                              Klass* referenced_klass,
345                                              const methodHandle&amp; method, int index) {
346   assert(method-&gt;method_holder()-&gt;verify_itable_index(index), &quot;&quot;);
347   assert(invoke_code == Bytecodes::_invokeinterface, &quot;&quot;);
348   InstanceKlass* interf = method-&gt;method_holder();
349   assert(interf-&gt;is_interface(), &quot;must be an interface&quot;);
350   assert(!method-&gt;is_final_method(), &quot;interfaces do not have final methods; cannot link to one here&quot;);
351   set_f1(referenced_klass);
352   set_f2((intx)method());
353   set_method_flags(as_TosState(method-&gt;result_type()),
354                    0,  // no option bits
355                    method()-&gt;size_of_parameters());
356   set_bytecode_1(Bytecodes::_invokeinterface);
357 }
358 
359 
360 void ConstantPoolCacheEntry::set_method_handle(const constantPoolHandle&amp; cpool, const CallInfo &amp;call_info) {
361   set_method_handle_common(cpool, Bytecodes::_invokehandle, call_info);
362 }
363 
364 void ConstantPoolCacheEntry::set_dynamic_call(const constantPoolHandle&amp; cpool, const CallInfo &amp;call_info) {
365   set_method_handle_common(cpool, Bytecodes::_invokedynamic, call_info);
366 }
367 
368 void ConstantPoolCacheEntry::set_method_handle_common(const constantPoolHandle&amp; cpool,
369                                                       Bytecodes::Code invoke_code,
370                                                       const CallInfo &amp;call_info) {
371   // NOTE: This CPCE can be the subject of data races.
372   // There are three words to update: flags, refs[f2], f1 (in that order).
373   // Writers must store all other values before f1.
374   // Readers must test f1 first for non-null before reading other fields.
375   // Competing writers must acquire exclusive access via a lock.
376   // A losing writer waits on the lock until the winner writes f1 and leaves
377   // the lock, so that when the losing writer returns, he can use the linked
378   // cache entry.
379 
380   objArrayHandle resolved_references(Thread::current(), cpool-&gt;resolved_references());
381   // Use the resolved_references() lock for this cpCache entry.
382   // resolved_references are created for all classes with Invokedynamic, MethodHandle
383   // or MethodType constant pool cache entries.
384   assert(resolved_references() != NULL,
385          &quot;a resolved_references array should have been created for this class&quot;);
386   ObjectLocker ol(resolved_references, Thread::current());
387   if (!is_f1_null()) {
388     return;
389   }
390 
391   if (indy_resolution_failed()) {
392     // Before we got here, another thread got a LinkageError exception during
393     // resolution.  Ignore our success and throw their exception.
394     ConstantPoolCache* cpCache = cpool-&gt;cache();
395     int index = -1;
396     for (int i = 0; i &lt; cpCache-&gt;length(); i++) {
397       if (cpCache-&gt;entry_at(i) == this) {
398         index = i;
399         break;
400       }
401     }
402     guarantee(index &gt;= 0, &quot;Didn&#39;t find cpCache entry!&quot;);
403     int encoded_index = ResolutionErrorTable::encode_cpcache_index(
404                           ConstantPool::encode_invokedynamic_index(index));
405     Thread* THREAD = Thread::current();
406     ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
407     return;
408   }
409 
410   Method* adapter            = call_info.resolved_method();
411   const Handle appendix      = call_info.resolved_appendix();
412   const bool has_appendix    = appendix.not_null();
413 
414   // Write the flags.
415   // MHs and indy are always sig-poly and have a local signature.
416   set_method_flags(as_TosState(adapter-&gt;result_type()),
417                    ((has_appendix    ? 1 : 0) &lt;&lt; has_appendix_shift        ) |
418                    (                   1      &lt;&lt; has_local_signature_shift ) |
419                    (                   1      &lt;&lt; is_final_shift            ),
420                    adapter-&gt;size_of_parameters());
421 
422   LogStream* log_stream = NULL;
423   LogStreamHandle(Debug, methodhandles, indy) lsh_indy;
424   if (lsh_indy.is_enabled()) {
425     ResourceMark rm;
426     log_stream = &amp;lsh_indy;
427     log_stream-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,
428                          invoke_code,
429                          p2i(appendix()),
430                          (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),
431                          p2i(adapter));
432     adapter-&gt;print_on(log_stream);
433     if (has_appendix)  appendix()-&gt;print_on(log_stream);
434   }
435 
436   // Method handle invokes and invokedynamic sites use both cp cache words.
437   // refs[f2], if not null, contains a value passed as a trailing argument to the adapter.
438   // In the general case, this could be the call site&#39;s MethodType,
439   // for use with java.lang.Invokers.checkExactType, or else a CallSite object.
440   // f1 contains the adapter method which manages the actual call.
441   // In the general case, this is a compiled LambdaForm.
442   // (The Java code is free to optimize these calls by binding other
443   // sorts of methods and appendices to call sites.)
444   // JVM-level linking is via f1, as if for invokespecial, and signatures are erased.
445   // The appendix argument (if any) is added to the signature, and is counted in the parameter_size bits.
446   // Even with the appendix, the method will never take more than 255 parameter slots.
447   //
448   // This means that given a call site like (List)mh.invoke(&quot;foo&quot;),
449   // the f1 method has signature &#39;(Ljl/Object;Ljl/invoke/MethodType;)Ljl/Object;&#39;,
450   // not &#39;(Ljava/lang/String;)Ljava/util/List;&#39;.
451   // The fact that String and List are involved is encoded in the MethodType in refs[f2].
452   // This allows us to create fewer Methods, while keeping type safety.
453   //
454 
455   // Store appendix, if any.
456   if (has_appendix) {
457     const int appendix_index = f2_as_index();
458     assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
459     assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
460     resolved_references-&gt;obj_at_put(appendix_index, appendix());
461   }
462 
463   release_set_f1(adapter);  // This must be the last one to set (see NOTE above)!
464 
465   // The interpreter assembly code does not check byte_2,
466   // but it is used by is_resolved, method_if_resolved, etc.
467   set_bytecode_1(invoke_code);
468   NOT_PRODUCT(verify(tty));
469 
470   if (log_stream != NULL) {
471     this-&gt;print(log_stream, 0);
472   }
473 
474   assert(has_appendix == this-&gt;has_appendix(), &quot;proper storage of appendix flag&quot;);
475   assert(this-&gt;has_local_signature(), &quot;proper storage of signature flag&quot;);
476 }
477 
478 bool ConstantPoolCacheEntry::save_and_throw_indy_exc(
479   const constantPoolHandle&amp; cpool, int cpool_index, int index, constantTag tag, TRAPS) {
480 
481   assert(HAS_PENDING_EXCEPTION, &quot;No exception got thrown!&quot;);
482   assert(PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass()),
483          &quot;No LinkageError exception&quot;);
484 
485   // Use the resolved_references() lock for this cpCache entry.
486   // resolved_references are created for all classes with Invokedynamic, MethodHandle
487   // or MethodType constant pool cache entries.
488   objArrayHandle resolved_references(Thread::current(), cpool-&gt;resolved_references());
489   assert(resolved_references() != NULL,
490          &quot;a resolved_references array should have been created for this class&quot;);
491   ObjectLocker ol(resolved_references, THREAD);
492 
493   // if f1 is not null or the indy_resolution_failed flag is set then another
494   // thread either succeeded in resolving the method or got a LinkageError
495   // exception, before this thread was able to record its failure.  So, clear
496   // this thread&#39;s exception and return false so caller can use the earlier
497   // thread&#39;s result.
498   if (!is_f1_null() || indy_resolution_failed()) {
499     CLEAR_PENDING_EXCEPTION;
500     return false;
501   }
502 
503   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
504   Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);
505 
506   SystemDictionary::add_resolution_error(cpool, index, error, message);
507   set_indy_resolution_failed();
508   return true;
509 }
510 
511 Method* ConstantPoolCacheEntry::method_if_resolved(const constantPoolHandle&amp; cpool) {
512   // Decode the action of set_method and set_interface_call
513   Bytecodes::Code invoke_code = bytecode_1();
514   if (invoke_code != (Bytecodes::Code)0) {
515     Metadata* f1 = f1_ord();
516     if (f1 != NULL) {
517       switch (invoke_code) {
518       case Bytecodes::_invokeinterface:
519         assert(f1-&gt;is_klass(), &quot;&quot;);
520         return f2_as_interface_method();
521       case Bytecodes::_invokestatic:
522       case Bytecodes::_invokespecial:
523         assert(!has_appendix(), &quot;&quot;);
524       case Bytecodes::_invokehandle:
525       case Bytecodes::_invokedynamic:
526         assert(f1-&gt;is_method(), &quot;&quot;);
527         return (Method*)f1;
528       default:
529         break;
530       }
531     }
532   }
533   invoke_code = bytecode_2();
534   if (invoke_code != (Bytecodes::Code)0) {
535     switch (invoke_code) {
536     case Bytecodes::_invokevirtual:
537       if (is_vfinal()) {
538         // invokevirtual
539         Method* m = f2_as_vfinal_method();
540         assert(m-&gt;is_method(), &quot;&quot;);
541         return m;
542       } else {
543         int holder_index = cpool-&gt;uncached_klass_ref_index_at(constant_pool_index());
544         if (cpool-&gt;tag_at(holder_index).is_klass()) {
545           Klass* klass = cpool-&gt;resolved_klass_at(holder_index);
546           return klass-&gt;method_at_vtable(f2_as_index());
547         }
548       }
549       break;
550     default:
551       break;
552     }
553   }
554   return NULL;
555 }
556 
557 
558 oop ConstantPoolCacheEntry::appendix_if_resolved(const constantPoolHandle&amp; cpool) {
559   if (!has_appendix())
560     return NULL;
561   const int ref_index = f2_as_index();
562   objArrayOop resolved_references = cpool-&gt;resolved_references();
563   return resolved_references-&gt;obj_at(ref_index);
564 }
565 
566 
567 #if INCLUDE_JVMTI
568 
569 void log_adjust(const char* entry_type, Method* old_method, Method* new_method, bool* trace_name_printed) {
<a name="1" id="anc1"></a><span class="line-modified">570   ResourceMark rm;</span>
<span class="line-modified">571 </span>
<span class="line-modified">572   if (!(*trace_name_printed)) {</span>
<span class="line-modified">573     log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());</span>
<span class="line-modified">574     *trace_name_printed = true;</span>



575   }
<a name="2" id="anc2"></a><span class="line-added">576   log_trace(redefine, class, update, constantpool)</span>
<span class="line-added">577     (&quot;cpc %s entry update: %s&quot;, entry_type, new_method-&gt;external_name());</span>
578 }
579 
580 // RedefineClasses() API support:
581 // If this ConstantPoolCacheEntry refers to old_method then update it
582 // to refer to new_method.
583 void ConstantPoolCacheEntry::adjust_method_entry(Method* old_method,
584        Method* new_method, bool * trace_name_printed) {
585 
586   if (is_vfinal()) {
587     // virtual and final so _f2 contains method ptr instead of vtable index
588     if (f2_as_vfinal_method() == old_method) {
589       // match old_method so need an update
590       // NOTE: can&#39;t use set_f2_as_vfinal_method as it asserts on different values
591       _f2 = (intptr_t)new_method;
592       log_adjust(&quot;vfinal&quot;, old_method, new_method, trace_name_printed);
593     }
594     return;
595   }
596 
597   assert (_f1 != NULL, &quot;should not call with uninteresting entry&quot;);
598 
599   if (!(_f1-&gt;is_method())) {
600     // _f1 is a Klass* for an interface, _f2 is the method
601     if (f2_as_interface_method() == old_method) {
602       _f2 = (intptr_t)new_method;
603       log_adjust(&quot;interface&quot;, old_method, new_method, trace_name_printed);
604     }
605   } else if (_f1 == old_method) {
606     _f1 = new_method;
607     log_adjust(&quot;special, static or dynamic&quot;, old_method, new_method, trace_name_printed);
608   }
609 }
610 
611 // a constant pool cache entry should never contain old or obsolete methods
612 bool ConstantPoolCacheEntry::check_no_old_or_obsolete_entries() {
613   Method* m = get_interesting_method_entry();
614   // return false if m refers to a non-deleted old or obsolete method
615   if (m != NULL) {
616     assert(m-&gt;is_valid() &amp;&amp; m-&gt;is_method(), &quot;m is a valid method&quot;);
617     return !m-&gt;is_old() &amp;&amp; !m-&gt;is_obsolete(); // old is always set for old and obsolete
618   } else {
619     return true;
620   }
621 }
622 
623 Method* ConstantPoolCacheEntry::get_interesting_method_entry() {
624   if (!is_method_entry()) {
625     // not a method entry so not interesting by default
626     return NULL;
627   }
628   Method* m = NULL;
629   if (is_vfinal()) {
630     // virtual and final so _f2 contains method ptr instead of vtable index
631     m = f2_as_vfinal_method();
632   } else if (is_f1_null()) {
633     // NULL _f1 means this is a virtual entry so also not interesting
634     return NULL;
635   } else {
636     if (!(_f1-&gt;is_method())) {
637       // _f1 is a Klass* for an interface
638       m = f2_as_interface_method();
639     } else {
640       m = f1_as_method();
641     }
642   }
643   assert(m != NULL &amp;&amp; m-&gt;is_method(), &quot;sanity check&quot;);
644   if (m == NULL || !m-&gt;is_method()) {
645     return NULL;
646   }
647   return m;
648 }
649 #endif // INCLUDE_JVMTI
650 
651 void ConstantPoolCacheEntry::print(outputStream* st, int index) const {
652   // print separator
653   if (index == 0) st-&gt;print_cr(&quot;                 -------------&quot;);
654   // print entry
655   st-&gt;print(&quot;%3d  (&quot; PTR_FORMAT &quot;)  &quot;, index, (intptr_t)this);
656   st-&gt;print_cr(&quot;[%02x|%02x|%5d]&quot;, bytecode_2(), bytecode_1(),
657                constant_pool_index());
658   st-&gt;print_cr(&quot;                 [   &quot; PTR_FORMAT &quot;]&quot;, (intptr_t)_f1);
659   st-&gt;print_cr(&quot;                 [   &quot; PTR_FORMAT &quot;]&quot;, (intptr_t)_f2);
660   st-&gt;print_cr(&quot;                 [   &quot; PTR_FORMAT &quot;]&quot;, (intptr_t)_flags);
661   st-&gt;print_cr(&quot;                 -------------&quot;);
662 }
663 
664 void ConstantPoolCacheEntry::verify(outputStream* st) const {
665   // not implemented yet
666 }
667 
668 // Implementation of ConstantPoolCache
669 
670 ConstantPoolCache* ConstantPoolCache::allocate(ClassLoaderData* loader_data,
671                                      const intStack&amp; index_map,
672                                      const intStack&amp; invokedynamic_index_map,
673                                      const intStack&amp; invokedynamic_map, TRAPS) {
674 
675   const int length = index_map.length() + invokedynamic_index_map.length();
676   int size = ConstantPoolCache::size(length);
677 
678   return new (loader_data, size, MetaspaceObj::ConstantPoolCacheType, THREAD)
679     ConstantPoolCache(length, index_map, invokedynamic_index_map, invokedynamic_map);
680 }
681 
682 void ConstantPoolCache::initialize(const intArray&amp; inverse_index_map,
683                                    const intArray&amp; invokedynamic_inverse_index_map,
684                                    const intArray&amp; invokedynamic_references_map) {
685   for (int i = 0; i &lt; inverse_index_map.length(); i++) {
686     ConstantPoolCacheEntry* e = entry_at(i);
687     int original_index = inverse_index_map.at(i);
688     e-&gt;initialize_entry(original_index);
689     assert(entry_at(i) == e, &quot;sanity&quot;);
690   }
691 
692   // Append invokedynamic entries at the end
693   int invokedynamic_offset = inverse_index_map.length();
694   for (int i = 0; i &lt; invokedynamic_inverse_index_map.length(); i++) {
695     int offset = i + invokedynamic_offset;
696     ConstantPoolCacheEntry* e = entry_at(offset);
697     int original_index = invokedynamic_inverse_index_map.at(i);
698     e-&gt;initialize_entry(original_index);
699     assert(entry_at(offset) == e, &quot;sanity&quot;);
700   }
701 
702   for (int ref = 0; ref &lt; invokedynamic_references_map.length(); ref++) {
703     const int cpci = invokedynamic_references_map.at(ref);
704     if (cpci &gt;= 0) {
705       entry_at(cpci)-&gt;initialize_resolved_reference_index(ref);
706     }
707   }
708 }
709 
710 void ConstantPoolCache::verify_just_initialized() {
711   DEBUG_ONLY(walk_entries_for_initialization(/*check_only = */ true));
712 }
713 
714 void ConstantPoolCache::remove_unshareable_info() {
715   walk_entries_for_initialization(/*check_only = */ false);
716 }
717 
718 void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {
719   Arguments::assert_is_dumping_archive();
720   // When dumping the archive, we want to clean up the ConstantPoolCache
721   // to remove any effect of linking due to the execution of Java code --
722   // each ConstantPoolCacheEntry will have the same contents as if
723   // ConstantPoolCache::initialize has just returned:
724   //
725   // - We keep the ConstantPoolCache::constant_pool_index() bits for all entries.
726   // - We keep the &quot;f2&quot; field for entries used by invokedynamic and invokehandle
727   // - All other bits in the entries are cleared to zero.
728   ResourceMark rm;
729 
730   InstanceKlass* ik = constant_pool()-&gt;pool_holder();
731   bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());
732   memset(f2_used, 0, sizeof(bool) * length());
733 
734   Thread* THREAD = Thread::current();
735 
736   // Find all the slots that we need to preserve f2
737   for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
738     Method* m = ik-&gt;methods()-&gt;at(i);
739     RawBytecodeStream bcs(methodHandle(THREAD, m));
740     while (!bcs.is_last_bytecode()) {
741       Bytecodes::Code opcode = bcs.raw_next();
742       switch (opcode) {
743       case Bytecodes::_invokedynamic: {
744           int index = Bytes::get_native_u4(bcs.bcp() + 1);
745           int cp_cache_index = constant_pool()-&gt;invokedynamic_cp_cache_index(index);
746           f2_used[cp_cache_index] = 1;
747         }
748         break;
749       case Bytecodes::_invokehandle: {
750           int cp_cache_index = Bytes::get_native_u2(bcs.bcp() + 1);
751           f2_used[cp_cache_index] = 1;
752         }
753         break;
754       default:
755         break;
756       }
757     }
758   }
759 
760   if (check_only) {
761     DEBUG_ONLY(
762       for (int i=0; i&lt;length(); i++) {
763         entry_at(i)-&gt;verify_just_initialized(f2_used[i]);
764       })
765   } else {
766     for (int i=0; i&lt;length(); i++) {
767       entry_at(i)-&gt;reinitialize(f2_used[i]);
768     }
769   }
770 }
771 
772 void ConstantPoolCache::deallocate_contents(ClassLoaderData* data) {
773   assert(!is_shared(), &quot;shared caches are not deallocated&quot;);
774   data-&gt;remove_handle(_resolved_references);
775   set_resolved_references(OopHandle());
776   MetadataFactory::free_array&lt;u2&gt;(data, _reference_map);
777   set_reference_map(NULL);
778 }
779 
780 #if INCLUDE_CDS_JAVA_HEAP
781 oop ConstantPoolCache::archived_references() {
782   if (CompressedOops::is_null(_archived_references)) {
783     return NULL;
784   }
785   return HeapShared::materialize_archived_object(_archived_references);
786 }
787 
788 void ConstantPoolCache::set_archived_references(oop o) {
789   assert(DumpSharedSpaces, &quot;called only during runtime&quot;);
790   _archived_references = CompressedOops::encode(o);
791 }
792 #endif
793 
794 #if INCLUDE_JVMTI
795 // RedefineClasses() API support:
796 // If any entry of this ConstantPoolCache points to any of
797 // old_methods, replace it with the corresponding new_method.
798 void ConstantPoolCache::adjust_method_entries(bool * trace_name_printed) {
799   for (int i = 0; i &lt; length(); i++) {
800     ConstantPoolCacheEntry* entry = entry_at(i);
801     Method* old_method = entry-&gt;get_interesting_method_entry();
802     if (old_method == NULL || !old_method-&gt;is_old()) {
803       continue; // skip uninteresting entries
804     }
805     if (old_method-&gt;is_deleted()) {
806       // clean up entries with deleted methods
807       entry-&gt;initialize_entry(entry-&gt;constant_pool_index());
808       continue;
809     }
810     Method* new_method = old_method-&gt;get_new_method();
811     entry_at(i)-&gt;adjust_method_entry(old_method, new_method, trace_name_printed);
812   }
813 }
814 
815 // the constant pool cache should never contain old or obsolete methods
816 bool ConstantPoolCache::check_no_old_or_obsolete_entries() {
<a name="3" id="anc3"></a><span class="line-added">817   ResourceMark rm;</span>
818   for (int i = 1; i &lt; length(); i++) {
<a name="4" id="anc4"></a><span class="line-modified">819     Method* m = entry_at(i)-&gt;get_interesting_method_entry();</span>
<span class="line-modified">820     if (m != NULL &amp;&amp; !entry_at(i)-&gt;check_no_old_or_obsolete_entries()) {</span>
<span class="line-added">821       log_trace(redefine, class, update, constantpool)</span>
<span class="line-added">822         (&quot;cpcache check found old method entry: class: %s, old: %d, obsolete: %d, method: %s&quot;,</span>
<span class="line-added">823          constant_pool()-&gt;pool_holder()-&gt;external_name(), m-&gt;is_old(), m-&gt;is_obsolete(), m-&gt;external_name());</span>
824       return false;
825     }
826   }
827   return true;
828 }
829 
830 void ConstantPoolCache::dump_cache() {
831   for (int i = 1; i &lt; length(); i++) {
832     if (entry_at(i)-&gt;get_interesting_method_entry() != NULL) {
833       entry_at(i)-&gt;print(tty, i);
834     }
835   }
836 }
837 #endif // INCLUDE_JVMTI
838 
839 void ConstantPoolCache::metaspace_pointers_do(MetaspaceClosure* it) {
840   log_trace(cds)(&quot;Iter(ConstantPoolCache): %p&quot;, this);
841   it-&gt;push(&amp;_constant_pool);
842   it-&gt;push(&amp;_reference_map);
843 }
844 
845 // Printing
846 
847 void ConstantPoolCache::print_on(outputStream* st) const {
848   st-&gt;print_cr(&quot;%s&quot;, internal_name());
849   // print constant pool cache entries
850   for (int i = 0; i &lt; length(); i++) entry_at(i)-&gt;print(st, i);
851 }
852 
853 void ConstantPoolCache::print_value_on(outputStream* st) const {
854   st-&gt;print(&quot;cache [%d]&quot;, length());
855   print_address_on(st);
856   st-&gt;print(&quot; for &quot;);
857   constant_pool()-&gt;print_value_on(st);
858 }
859 
860 
861 // Verification
862 
863 void ConstantPoolCache::verify_on(outputStream* st) {
864   // print constant pool cache entries
865   for (int i = 0; i &lt; length(); i++) entry_at(i)-&gt;verify(st);
866 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnv.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -68,12 +68,13 @@</span>
  Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  Method**  VM_RedefineClasses::_added_methods        = NULL;
  int       VM_RedefineClasses::_matching_methods_length = 0;
  int       VM_RedefineClasses::_deleted_methods_length  = 0;
  int       VM_RedefineClasses::_added_methods_length    = 0;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // This flag is global as the constructor does not reset it:</span>
  bool      VM_RedefineClasses::_has_redefined_Object = false;
<span class="udiff-line-removed">- bool      VM_RedefineClasses::_has_null_class_loader = false;</span>
  u8        VM_RedefineClasses::_id_counter = 0;
  
  VM_RedefineClasses::VM_RedefineClasses(jint class_count,
                                         const jvmtiClassDefinition *class_defs,
                                         JvmtiClassLoadKind class_load_kind) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -81,12 +82,10 @@</span>
    _class_defs = class_defs;
    _class_load_kind = class_load_kind;
    _any_class_has_resolved_methods = false;
    _res = JVMTI_ERROR_NONE;
    _the_class = NULL;
<span class="udiff-line-removed">-   _has_redefined_Object = false;</span>
<span class="udiff-line-removed">-   _has_null_class_loader = false;</span>
    _id = next_id();
  }
  
  static inline InstanceKlass* get_ik(jclass def) {
    oop mirror = JNIHandles::resolve_non_null(def);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3595,11 +3594,14 @@</span>
    // This is a very busy routine. We don&#39;t want too much tracing
    // printed out.
    bool trace_name_printed = false;
  
    // If the class being redefined is java.lang.Object, we need to fix all
<span class="udiff-line-modified-removed">-   // array class vtables also</span>
<span class="udiff-line-modified-added">+   // array class vtables also. The _has_redefined_Object flag is global.</span>
<span class="udiff-line-added">+   // Once the java.lang.Object has been redefined (by the current or one</span>
<span class="udiff-line-added">+   // of the previous VM_RedefineClasses operations) we have to always</span>
<span class="udiff-line-added">+   // adjust method entries for array classes.</span>
    if (k-&gt;is_array_klass() &amp;&amp; _has_redefined_Object) {
      k-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
  
    } else if (k-&gt;is_instance_klass()) {
      HandleMark hm(_thread);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3613,26 +3615,10 @@</span>
        if (methods-&gt;at(index)-&gt;method_data() != NULL) {
          methods-&gt;at(index)-&gt;method_data()-&gt;clean_weak_method_links();
        }
      }
  
<span class="udiff-line-removed">-     // HotSpot specific optimization! HotSpot does not currently</span>
<span class="udiff-line-removed">-     // support delegation from the bootstrap class loader to a</span>
<span class="udiff-line-removed">-     // user-defined class loader. This means that if the bootstrap</span>
<span class="udiff-line-removed">-     // class loader is the initiating class loader, then it will also</span>
<span class="udiff-line-removed">-     // be the defining class loader. This also means that classes</span>
<span class="udiff-line-removed">-     // loaded by the bootstrap class loader cannot refer to classes</span>
<span class="udiff-line-removed">-     // loaded by a user-defined class loader. Note: a user-defined</span>
<span class="udiff-line-removed">-     // class loader can delegate to the bootstrap class loader.</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // If the current class being redefined has a user-defined class</span>
<span class="udiff-line-removed">-     // loader as its defining class loader, then we can skip all</span>
<span class="udiff-line-removed">-     // classes loaded by the bootstrap class loader.</span>
<span class="udiff-line-removed">-     if (!_has_null_class_loader &amp;&amp; ik-&gt;class_loader() == NULL) {</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      // Adjust all vtables, default methods and itables, to clean out old methods.
      ResourceMark rm(_thread);
      if (ik-&gt;vtable_length() &gt; 0) {
        ik-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
        ik-&gt;adjust_default_methods(&amp;trace_name_printed);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3647,25 +3633,28 @@</span>
      // other_cp&#39;s cache. If other_cp has a previous version, then we
      // have to repeat the process for each previous version. The
      // constant pool cache holds the Method*s for non-virtual
      // methods and for virtual, final methods.
      //
<span class="udiff-line-modified-removed">-     // Special case: if the current class being redefined, then new_cp</span>
<span class="udiff-line-modified-removed">-     // has already been attached to the_class and old_cp has already</span>
<span class="udiff-line-modified-removed">-     // been added as a previous version. The new_cp doesn&#39;t have any</span>
<span class="udiff-line-modified-removed">-     // cached references to old methods so it doesn&#39;t need to be</span>
<span class="udiff-line-modified-removed">-     // updated. We can simply start with the previous version(s) in</span>
<span class="udiff-line-modified-removed">-     // that case.</span>
<span class="udiff-line-modified-added">+     // Special case: if the current class is being redefined by the current</span>
<span class="udiff-line-modified-added">+     // VM_RedefineClasses operation, then new_cp has already been attached</span>
<span class="udiff-line-modified-added">+     // to the_class and old_cp has already been added as a previous version.</span>
<span class="udiff-line-modified-added">+     // The new_cp doesn&#39;t have any cached references to old methods so it</span>
<span class="udiff-line-modified-added">+     // doesn&#39;t need to be updated and we could optimize by skipping it.</span>
<span class="udiff-line-modified-added">+     // However, the current class can be marked as being redefined by another</span>
<span class="udiff-line-added">+     // VM_RedefineClasses operation which has already executed its doit_prologue</span>
<span class="udiff-line-added">+     // and needs cpcache method entries adjusted. For simplicity, the cpcache</span>
<span class="udiff-line-added">+     // update is done unconditionally. It should result in doing nothing for</span>
<span class="udiff-line-added">+     // classes being redefined by the current VM_RedefineClasses operation.</span>
<span class="udiff-line-added">+     // Method entries in the previous version(s) are adjusted as well.</span>
      ConstantPoolCache* cp_cache;
  
<span class="udiff-line-modified-removed">-     if (!ik-&gt;is_being_redefined()) {</span>
<span class="udiff-line-modified-removed">-       // this klass&#39; constant pool cache may need adjustment</span>
<span class="udiff-line-modified-removed">-       ConstantPool* other_cp = ik-&gt;constants();</span>
<span class="udiff-line-modified-removed">-       cp_cache = other_cp-&gt;cache();</span>
<span class="udiff-line-modified-removed">-       if (cp_cache != NULL) {</span>
<span class="udiff-line-removed">-         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+     // this klass&#39; constant pool cache may need adjustment</span>
<span class="udiff-line-modified-added">+     ConstantPool* other_cp = ik-&gt;constants();</span>
<span class="udiff-line-modified-added">+     cp_cache = other_cp-&gt;cache();</span>
<span class="udiff-line-modified-added">+     if (cp_cache != NULL) {</span>
<span class="udiff-line-modified-added">+       cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);</span>
      }
  
      // the previous versions&#39; constant pool caches may need adjustment
      for (InstanceKlass* pv_node = ik-&gt;previous_versions();
           pv_node != NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4106,13 +4095,12 @@</span>
      _timer_rsc_phase1.start();
    }
  
    InstanceKlass* the_class = get_ik(the_jclass);
  
<span class="udiff-line-modified-removed">-   // Set some flags to control and optimize adjusting method entries</span>
<span class="udiff-line-modified-added">+   // Set a flag to control and optimize adjusting method entries</span>
    _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
<span class="udiff-line-removed">-   _has_null_class_loader |= the_class-&gt;class_loader() == NULL;</span>
  
    // Remove all breakpoints in methods of this class
    JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
    jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
  
</pre>
<center><a href="jvmtiEnv.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
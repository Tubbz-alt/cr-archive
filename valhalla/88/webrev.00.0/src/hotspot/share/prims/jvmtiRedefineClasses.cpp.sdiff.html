<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  53 #include &quot;prims/resolvedMethodTable.hpp&quot;
  54 #include &quot;prims/methodComparator.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/relocator.hpp&quot;
  60 #include &quot;runtime/safepointVerifiers.hpp&quot;
  61 #include &quot;utilities/bitMap.inline.hpp&quot;
  62 #include &quot;utilities/events.hpp&quot;
  63 
  64 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  65 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  67 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  68 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  69 Method**  VM_RedefineClasses::_added_methods        = NULL;
  70 int       VM_RedefineClasses::_matching_methods_length = 0;
  71 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  72 int       VM_RedefineClasses::_added_methods_length    = 0;


  73 bool      VM_RedefineClasses::_has_redefined_Object = false;
<span class="line-removed">  74 bool      VM_RedefineClasses::_has_null_class_loader = false;</span>
  75 u8        VM_RedefineClasses::_id_counter = 0;
  76 
  77 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  78                                        const jvmtiClassDefinition *class_defs,
  79                                        JvmtiClassLoadKind class_load_kind) {
  80   _class_count = class_count;
  81   _class_defs = class_defs;
  82   _class_load_kind = class_load_kind;
  83   _any_class_has_resolved_methods = false;
  84   _res = JVMTI_ERROR_NONE;
  85   _the_class = NULL;
<span class="line-removed">  86   _has_redefined_Object = false;</span>
<span class="line-removed">  87   _has_null_class_loader = false;</span>
  88   _id = next_id();
  89 }
  90 
  91 static inline InstanceKlass* get_ik(jclass def) {
  92   oop mirror = JNIHandles::resolve_non_null(def);
  93   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  94 }
  95 
  96 // If any of the classes are being redefined, wait
  97 // Parallel constant pool merging leads to indeterminate constant pools.
  98 void VM_RedefineClasses::lock_classes() {
  99   MonitorLocker ml(RedefineClasses_lock);
 100   bool has_redefined;
 101   do {
 102     has_redefined = false;
 103     // Go through classes each time until none are being redefined.
 104     for (int i = 0; i &lt; _class_count; i++) {
 105       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
 106         ml.wait();
 107         has_redefined = true;
</pre>
<hr />
<pre>
3580 
3581     rewrite_cp_refs_in_stack_map_table(method, THREAD);
3582   } // end for each method
3583 } // end set_new_constant_pool()
3584 
3585 
3586 // Unevolving classes may point to methods of the_class directly
3587 // from their constant pool caches, itables, and/or vtables. We
3588 // use the ClassLoaderDataGraph::classes_do() facility and this helper
3589 // to fix up these pointers.  MethodData also points to old methods and
3590 // must be cleaned.
3591 
3592 // Adjust cpools and vtables closure
3593 void VM_RedefineClasses::AdjustAndCleanMetadata::do_klass(Klass* k) {
3594 
3595   // This is a very busy routine. We don&#39;t want too much tracing
3596   // printed out.
3597   bool trace_name_printed = false;
3598 
3599   // If the class being redefined is java.lang.Object, we need to fix all
<span class="line-modified">3600   // array class vtables also</span>



3601   if (k-&gt;is_array_klass() &amp;&amp; _has_redefined_Object) {
3602     k-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3603 
3604   } else if (k-&gt;is_instance_klass()) {
3605     HandleMark hm(_thread);
3606     InstanceKlass *ik = InstanceKlass::cast(k);
3607 
3608     // Clean MethodData of this class&#39;s methods so they don&#39;t refer to
3609     // old methods that are no longer running.
3610     Array&lt;Method*&gt;* methods = ik-&gt;methods();
3611     int num_methods = methods-&gt;length();
3612     for (int index = 0; index &lt; num_methods; ++index) {
3613       if (methods-&gt;at(index)-&gt;method_data() != NULL) {
3614         methods-&gt;at(index)-&gt;method_data()-&gt;clean_weak_method_links();
3615       }
3616     }
3617 
<span class="line-removed">3618     // HotSpot specific optimization! HotSpot does not currently</span>
<span class="line-removed">3619     // support delegation from the bootstrap class loader to a</span>
<span class="line-removed">3620     // user-defined class loader. This means that if the bootstrap</span>
<span class="line-removed">3621     // class loader is the initiating class loader, then it will also</span>
<span class="line-removed">3622     // be the defining class loader. This also means that classes</span>
<span class="line-removed">3623     // loaded by the bootstrap class loader cannot refer to classes</span>
<span class="line-removed">3624     // loaded by a user-defined class loader. Note: a user-defined</span>
<span class="line-removed">3625     // class loader can delegate to the bootstrap class loader.</span>
<span class="line-removed">3626     //</span>
<span class="line-removed">3627     // If the current class being redefined has a user-defined class</span>
<span class="line-removed">3628     // loader as its defining class loader, then we can skip all</span>
<span class="line-removed">3629     // classes loaded by the bootstrap class loader.</span>
<span class="line-removed">3630     if (!_has_null_class_loader &amp;&amp; ik-&gt;class_loader() == NULL) {</span>
<span class="line-removed">3631       return;</span>
<span class="line-removed">3632     }</span>
<span class="line-removed">3633 </span>
3634     // Adjust all vtables, default methods and itables, to clean out old methods.
3635     ResourceMark rm(_thread);
3636     if (ik-&gt;vtable_length() &gt; 0) {
3637       ik-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3638       ik-&gt;adjust_default_methods(&amp;trace_name_printed);
3639     }
3640 
3641     if (ik-&gt;itable_length() &gt; 0) {
3642       ik-&gt;itable().adjust_method_entries(&amp;trace_name_printed);
3643     }
3644 
3645     // The constant pools in other classes (other_cp) can refer to
3646     // old methods.  We have to update method information in
3647     // other_cp&#39;s cache. If other_cp has a previous version, then we
3648     // have to repeat the process for each previous version. The
3649     // constant pool cache holds the Method*s for non-virtual
3650     // methods and for virtual, final methods.
3651     //
<span class="line-modified">3652     // Special case: if the current class being redefined, then new_cp</span>
<span class="line-modified">3653     // has already been attached to the_class and old_cp has already</span>
<span class="line-modified">3654     // been added as a previous version. The new_cp doesn&#39;t have any</span>
<span class="line-modified">3655     // cached references to old methods so it doesn&#39;t need to be</span>
<span class="line-modified">3656     // updated. We can simply start with the previous version(s) in</span>
<span class="line-modified">3657     // that case.</span>





3658     ConstantPoolCache* cp_cache;
3659 
<span class="line-modified">3660     if (!ik-&gt;is_being_redefined()) {</span>
<span class="line-modified">3661       // this klass&#39; constant pool cache may need adjustment</span>
<span class="line-modified">3662       ConstantPool* other_cp = ik-&gt;constants();</span>
<span class="line-modified">3663       cp_cache = other_cp-&gt;cache();</span>
<span class="line-modified">3664       if (cp_cache != NULL) {</span>
<span class="line-removed">3665         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);</span>
<span class="line-removed">3666       }</span>
3667     }
3668 
3669     // the previous versions&#39; constant pool caches may need adjustment
3670     for (InstanceKlass* pv_node = ik-&gt;previous_versions();
3671          pv_node != NULL;
3672          pv_node = pv_node-&gt;previous_versions()) {
3673       cp_cache = pv_node-&gt;constants()-&gt;cache();
3674       if (cp_cache != NULL) {
3675         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3676       }
3677     }
3678   }
3679 }
3680 
3681 void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {
3682   for (int j = 0; j &lt; _matching_methods_length; ++j) {
3683     Method* old_method = _matching_old_methods[j];
3684     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
3685     if (jmid != NULL) {
3686       // There is a jmethodID, change it to point to the new method
</pre>
<hr />
<pre>
4091 //    - replacing parts in the_class with parts from scratch_class
4092 //    - adding a weak reference to track the obsolete but interesting
4093 //      parts of the_class
4094 //    - adjusting constant pool caches and vtables in other classes
4095 //      that refer to methods in the_class. These adjustments use the
4096 //      ClassLoaderDataGraph::classes_do() facility which only allows
4097 //      a helper method to be specified. The interesting parameters
4098 //      that we would like to pass to the helper method are saved in
4099 //      static global fields in the VM operation.
4100 void VM_RedefineClasses::redefine_single_class(jclass the_jclass,
4101        InstanceKlass* scratch_class, TRAPS) {
4102 
4103   HandleMark hm(THREAD);   // make sure handles from this call are freed
4104 
4105   if (log_is_enabled(Info, redefine, class, timer)) {
4106     _timer_rsc_phase1.start();
4107   }
4108 
4109   InstanceKlass* the_class = get_ik(the_jclass);
4110 
<span class="line-modified">4111   // Set some flags to control and optimize adjusting method entries</span>
4112   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
<span class="line-removed">4113   _has_null_class_loader |= the_class-&gt;class_loader() == NULL;</span>
4114 
4115   // Remove all breakpoints in methods of this class
4116   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
4117   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
4118 
4119   // Mark all compiled code that depends on this class
4120   mark_dependent_code(the_class);
4121 
4122   _old_methods = the_class-&gt;methods();
4123   _new_methods = scratch_class-&gt;methods();
4124   _the_class = the_class;
4125   compute_added_deleted_matching_methods();
4126   update_jmethod_ids(THREAD);
4127 
4128   _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
4129 
4130   // Attach new constant pool to the original klass. The original
4131   // klass still refers to the old constant pool (for now).
4132   scratch_class-&gt;constants()-&gt;set_pool_holder(the_class);
4133 
</pre>
</td>
<td>
<hr />
<pre>
  53 #include &quot;prims/resolvedMethodTable.hpp&quot;
  54 #include &quot;prims/methodComparator.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/relocator.hpp&quot;
  60 #include &quot;runtime/safepointVerifiers.hpp&quot;
  61 #include &quot;utilities/bitMap.inline.hpp&quot;
  62 #include &quot;utilities/events.hpp&quot;
  63 
  64 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  65 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  67 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  68 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  69 Method**  VM_RedefineClasses::_added_methods        = NULL;
  70 int       VM_RedefineClasses::_matching_methods_length = 0;
  71 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  72 int       VM_RedefineClasses::_added_methods_length    = 0;
<span class="line-added">  73 </span>
<span class="line-added">  74 // This flag is global as the constructor does not reset it:</span>
  75 bool      VM_RedefineClasses::_has_redefined_Object = false;

  76 u8        VM_RedefineClasses::_id_counter = 0;
  77 
  78 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  79                                        const jvmtiClassDefinition *class_defs,
  80                                        JvmtiClassLoadKind class_load_kind) {
  81   _class_count = class_count;
  82   _class_defs = class_defs;
  83   _class_load_kind = class_load_kind;
  84   _any_class_has_resolved_methods = false;
  85   _res = JVMTI_ERROR_NONE;
  86   _the_class = NULL;


  87   _id = next_id();
  88 }
  89 
  90 static inline InstanceKlass* get_ik(jclass def) {
  91   oop mirror = JNIHandles::resolve_non_null(def);
  92   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  93 }
  94 
  95 // If any of the classes are being redefined, wait
  96 // Parallel constant pool merging leads to indeterminate constant pools.
  97 void VM_RedefineClasses::lock_classes() {
  98   MonitorLocker ml(RedefineClasses_lock);
  99   bool has_redefined;
 100   do {
 101     has_redefined = false;
 102     // Go through classes each time until none are being redefined.
 103     for (int i = 0; i &lt; _class_count; i++) {
 104       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
 105         ml.wait();
 106         has_redefined = true;
</pre>
<hr />
<pre>
3579 
3580     rewrite_cp_refs_in_stack_map_table(method, THREAD);
3581   } // end for each method
3582 } // end set_new_constant_pool()
3583 
3584 
3585 // Unevolving classes may point to methods of the_class directly
3586 // from their constant pool caches, itables, and/or vtables. We
3587 // use the ClassLoaderDataGraph::classes_do() facility and this helper
3588 // to fix up these pointers.  MethodData also points to old methods and
3589 // must be cleaned.
3590 
3591 // Adjust cpools and vtables closure
3592 void VM_RedefineClasses::AdjustAndCleanMetadata::do_klass(Klass* k) {
3593 
3594   // This is a very busy routine. We don&#39;t want too much tracing
3595   // printed out.
3596   bool trace_name_printed = false;
3597 
3598   // If the class being redefined is java.lang.Object, we need to fix all
<span class="line-modified">3599   // array class vtables also. The _has_redefined_Object flag is global.</span>
<span class="line-added">3600   // Once the java.lang.Object has been redefined (by the current or one</span>
<span class="line-added">3601   // of the previous VM_RedefineClasses operations) we have to always</span>
<span class="line-added">3602   // adjust method entries for array classes.</span>
3603   if (k-&gt;is_array_klass() &amp;&amp; _has_redefined_Object) {
3604     k-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3605 
3606   } else if (k-&gt;is_instance_klass()) {
3607     HandleMark hm(_thread);
3608     InstanceKlass *ik = InstanceKlass::cast(k);
3609 
3610     // Clean MethodData of this class&#39;s methods so they don&#39;t refer to
3611     // old methods that are no longer running.
3612     Array&lt;Method*&gt;* methods = ik-&gt;methods();
3613     int num_methods = methods-&gt;length();
3614     for (int index = 0; index &lt; num_methods; ++index) {
3615       if (methods-&gt;at(index)-&gt;method_data() != NULL) {
3616         methods-&gt;at(index)-&gt;method_data()-&gt;clean_weak_method_links();
3617       }
3618     }
3619 
















3620     // Adjust all vtables, default methods and itables, to clean out old methods.
3621     ResourceMark rm(_thread);
3622     if (ik-&gt;vtable_length() &gt; 0) {
3623       ik-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3624       ik-&gt;adjust_default_methods(&amp;trace_name_printed);
3625     }
3626 
3627     if (ik-&gt;itable_length() &gt; 0) {
3628       ik-&gt;itable().adjust_method_entries(&amp;trace_name_printed);
3629     }
3630 
3631     // The constant pools in other classes (other_cp) can refer to
3632     // old methods.  We have to update method information in
3633     // other_cp&#39;s cache. If other_cp has a previous version, then we
3634     // have to repeat the process for each previous version. The
3635     // constant pool cache holds the Method*s for non-virtual
3636     // methods and for virtual, final methods.
3637     //
<span class="line-modified">3638     // Special case: if the current class is being redefined by the current</span>
<span class="line-modified">3639     // VM_RedefineClasses operation, then new_cp has already been attached</span>
<span class="line-modified">3640     // to the_class and old_cp has already been added as a previous version.</span>
<span class="line-modified">3641     // The new_cp doesn&#39;t have any cached references to old methods so it</span>
<span class="line-modified">3642     // doesn&#39;t need to be updated and we could optimize by skipping it.</span>
<span class="line-modified">3643     // However, the current class can be marked as being redefined by another</span>
<span class="line-added">3644     // VM_RedefineClasses operation which has already executed its doit_prologue</span>
<span class="line-added">3645     // and needs cpcache method entries adjusted. For simplicity, the cpcache</span>
<span class="line-added">3646     // update is done unconditionally. It should result in doing nothing for</span>
<span class="line-added">3647     // classes being redefined by the current VM_RedefineClasses operation.</span>
<span class="line-added">3648     // Method entries in the previous version(s) are adjusted as well.</span>
3649     ConstantPoolCache* cp_cache;
3650 
<span class="line-modified">3651     // this klass&#39; constant pool cache may need adjustment</span>
<span class="line-modified">3652     ConstantPool* other_cp = ik-&gt;constants();</span>
<span class="line-modified">3653     cp_cache = other_cp-&gt;cache();</span>
<span class="line-modified">3654     if (cp_cache != NULL) {</span>
<span class="line-modified">3655       cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);</span>


3656     }
3657 
3658     // the previous versions&#39; constant pool caches may need adjustment
3659     for (InstanceKlass* pv_node = ik-&gt;previous_versions();
3660          pv_node != NULL;
3661          pv_node = pv_node-&gt;previous_versions()) {
3662       cp_cache = pv_node-&gt;constants()-&gt;cache();
3663       if (cp_cache != NULL) {
3664         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3665       }
3666     }
3667   }
3668 }
3669 
3670 void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {
3671   for (int j = 0; j &lt; _matching_methods_length; ++j) {
3672     Method* old_method = _matching_old_methods[j];
3673     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
3674     if (jmid != NULL) {
3675       // There is a jmethodID, change it to point to the new method
</pre>
<hr />
<pre>
4080 //    - replacing parts in the_class with parts from scratch_class
4081 //    - adding a weak reference to track the obsolete but interesting
4082 //      parts of the_class
4083 //    - adjusting constant pool caches and vtables in other classes
4084 //      that refer to methods in the_class. These adjustments use the
4085 //      ClassLoaderDataGraph::classes_do() facility which only allows
4086 //      a helper method to be specified. The interesting parameters
4087 //      that we would like to pass to the helper method are saved in
4088 //      static global fields in the VM operation.
4089 void VM_RedefineClasses::redefine_single_class(jclass the_jclass,
4090        InstanceKlass* scratch_class, TRAPS) {
4091 
4092   HandleMark hm(THREAD);   // make sure handles from this call are freed
4093 
4094   if (log_is_enabled(Info, redefine, class, timer)) {
4095     _timer_rsc_phase1.start();
4096   }
4097 
4098   InstanceKlass* the_class = get_ik(the_jclass);
4099 
<span class="line-modified">4100   // Set a flag to control and optimize adjusting method entries</span>
4101   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();

4102 
4103   // Remove all breakpoints in methods of this class
4104   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
4105   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
4106 
4107   // Mark all compiled code that depends on this class
4108   mark_dependent_code(the_class);
4109 
4110   _old_methods = the_class-&gt;methods();
4111   _new_methods = scratch_class-&gt;methods();
4112   _the_class = the_class;
4113   compute_added_deleted_matching_methods();
4114   update_jmethod_ids(THREAD);
4115 
4116   _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
4117 
4118   // Attach new constant pool to the original klass. The original
4119   // klass still refers to the old constant pool (for now).
4120   scratch_class-&gt;constants()-&gt;set_pool_holder(the_class);
4121 
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
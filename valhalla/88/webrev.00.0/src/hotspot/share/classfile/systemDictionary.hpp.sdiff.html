<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
623   // Basic loading operations
624   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
625                                                               Handle class_loader,
626                                                               Handle protection_domain,
627                                                               TRAPS);
628   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
629   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
630   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
631   // Wait on SystemDictionary_lock; unlocks lockObject before
632   // waiting; relocks lockObject with correct recursion count
633   // after waiting, but before reentering SystemDictionary_lock
634   // to preserve lock order semantics.
635   static void double_lock_wait(Handle lockObject, TRAPS);
636   static void define_instance_class(InstanceKlass* k, TRAPS);
637   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
638                                                 Handle class_loader,
639                                                 InstanceKlass* k, TRAPS);
640   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
641                                       PackageEntry* pkg_entry,
642                                       Handle class_loader, TRAPS);




643   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,
644                                             Handle class_loader,  Handle protection_domain,
645                                             bool is_superclass, TRAPS);
646   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
647                                                Handle protection_domain, TRAPS);
648   static InstanceKlass* load_shared_lambda_proxy_class(InstanceKlass* ik,
649                                                        Handle class_loader,
650                                                        Handle protection_domain,
651                                                        PackageEntry* pkg_entry,
652                                                        TRAPS);
653   static InstanceKlass* load_shared_class(InstanceKlass* ik,
654                                           Handle class_loader,
655                                           Handle protection_domain,
656                                           const ClassFileStream *cfs,
657                                           PackageEntry* pkg_entry,
658                                           TRAPS);
659   // Second part of load_shared_class
660   static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;
661   static InstanceKlass* load_shared_boot_class(Symbol* class_name,
662                                                PackageEntry* pkg_entry,
</pre>
</td>
<td>
<hr />
<pre>
623   // Basic loading operations
624   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
625                                                               Handle class_loader,
626                                                               Handle protection_domain,
627                                                               TRAPS);
628   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
629   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
630   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
631   // Wait on SystemDictionary_lock; unlocks lockObject before
632   // waiting; relocks lockObject with correct recursion count
633   // after waiting, but before reentering SystemDictionary_lock
634   // to preserve lock order semantics.
635   static void double_lock_wait(Handle lockObject, TRAPS);
636   static void define_instance_class(InstanceKlass* k, TRAPS);
637   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
638                                                 Handle class_loader,
639                                                 InstanceKlass* k, TRAPS);
640   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
641                                       PackageEntry* pkg_entry,
642                                       Handle class_loader, TRAPS);
<span class="line-added">643   static bool is_shared_class_visible_impl(Symbol* class_name,</span>
<span class="line-added">644                                            InstanceKlass* ik,</span>
<span class="line-added">645                                            PackageEntry* pkg_entry,</span>
<span class="line-added">646                                            Handle class_loader, TRAPS);</span>
647   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,
648                                             Handle class_loader,  Handle protection_domain,
649                                             bool is_superclass, TRAPS);
650   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
651                                                Handle protection_domain, TRAPS);
652   static InstanceKlass* load_shared_lambda_proxy_class(InstanceKlass* ik,
653                                                        Handle class_loader,
654                                                        Handle protection_domain,
655                                                        PackageEntry* pkg_entry,
656                                                        TRAPS);
657   static InstanceKlass* load_shared_class(InstanceKlass* ik,
658                                           Handle class_loader,
659                                           Handle protection_domain,
660                                           const ClassFileStream *cfs,
661                                           PackageEntry* pkg_entry,
662                                           TRAPS);
663   // Second part of load_shared_class
664   static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;
665   static InstanceKlass* load_shared_boot_class(Symbol* class_name,
666                                                PackageEntry* pkg_entry,
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
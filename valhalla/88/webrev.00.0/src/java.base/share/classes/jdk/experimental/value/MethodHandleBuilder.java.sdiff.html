<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../java/lang/reflect/ProxyGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/misc/Unsafe.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 76         String descriptor = type.toMethodDescriptorString();
 77         return loadCode(lookup, className, methodName, descriptor, MethodHandleCodeBuilder::new,
 78                     clazz -&gt; {
 79                         try {
 80                             return lookup.findStatic(clazz, methodName, MethodType.fromMethodDescriptorString(descriptor, lookup.lookupClass().getClassLoader()));
 81                         } catch (ReflectiveOperationException ex) {
 82                             throw new IllegalStateException(ex);
 83                         }
 84                     },
 85                     builder);
 86     }
 87 
 88     protected static &lt;Z, C extends CodeBuilder&lt;Class&lt;?&gt;, String, byte[], ?&gt;&gt; Z loadCode(
 89             Lookup lookup, String className, String methodName, String type,
 90             Function&lt;MethodBuilder&lt;Class&lt;?&gt;, String, byte[]&gt;, ? extends C&gt; builderFunc,
 91             Function&lt;Class&lt;?&gt;, Z&gt; resFunc, Consumer&lt;? super C&gt; builder) {
 92 
 93         IsolatedMethodBuilder isolatedMethodBuilder = new IsolatedMethodBuilder(className, lookup);
 94         isolatedMethodBuilder
 95                 .withSuperclass(Object.class)
<span class="line-modified"> 96                 .withMajorVersion(59)</span>
 97                 .withMinorVersion(0)
 98                 .withFlags(Flag.ACC_PUBLIC)
 99                 .withMethod(methodName, type, M -&gt;
100                         M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)
101                                 .withCode(builderFunc, builder));
102 
103         try {
104             byte[] barr = isolatedMethodBuilder.build();
105             maybeDump(className, barr);
106             Class&lt;?&gt; clazz = UNSAFE.defineAnonymousClass(lookup.lookupClass(), barr, isolatedMethodBuilder.patches());
107             UNSAFE.ensureClassInitialized(clazz);
108             return resFunc.apply(clazz);
109         } catch (Throwable e) {
110              throw new IllegalStateException(e);
111         }
112     }
113 
114     public static class IsolatedMethodBuilder extends ClassBuilder&lt;Class&lt;?&gt;, String, IsolatedMethodBuilder&gt; {
115 
116         private static final Class&lt;?&gt; THIS_CLASS = new Object() { }.getClass();
</pre>
</td>
<td>
<hr />
<pre>
 76         String descriptor = type.toMethodDescriptorString();
 77         return loadCode(lookup, className, methodName, descriptor, MethodHandleCodeBuilder::new,
 78                     clazz -&gt; {
 79                         try {
 80                             return lookup.findStatic(clazz, methodName, MethodType.fromMethodDescriptorString(descriptor, lookup.lookupClass().getClassLoader()));
 81                         } catch (ReflectiveOperationException ex) {
 82                             throw new IllegalStateException(ex);
 83                         }
 84                     },
 85                     builder);
 86     }
 87 
 88     protected static &lt;Z, C extends CodeBuilder&lt;Class&lt;?&gt;, String, byte[], ?&gt;&gt; Z loadCode(
 89             Lookup lookup, String className, String methodName, String type,
 90             Function&lt;MethodBuilder&lt;Class&lt;?&gt;, String, byte[]&gt;, ? extends C&gt; builderFunc,
 91             Function&lt;Class&lt;?&gt;, Z&gt; resFunc, Consumer&lt;? super C&gt; builder) {
 92 
 93         IsolatedMethodBuilder isolatedMethodBuilder = new IsolatedMethodBuilder(className, lookup);
 94         isolatedMethodBuilder
 95                 .withSuperclass(Object.class)
<span class="line-modified"> 96                 .withMajorVersion(60)</span>
 97                 .withMinorVersion(0)
 98                 .withFlags(Flag.ACC_PUBLIC)
 99                 .withMethod(methodName, type, M -&gt;
100                         M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)
101                                 .withCode(builderFunc, builder));
102 
103         try {
104             byte[] barr = isolatedMethodBuilder.build();
105             maybeDump(className, barr);
106             Class&lt;?&gt; clazz = UNSAFE.defineAnonymousClass(lookup.lookupClass(), barr, isolatedMethodBuilder.patches());
107             UNSAFE.ensureClassInitialized(clazz);
108             return resFunc.apply(clazz);
109         } catch (Throwable e) {
110              throw new IllegalStateException(e);
111         }
112     }
113 
114     public static class IsolatedMethodBuilder extends ClassBuilder&lt;Class&lt;?&gt;, String, IsolatedMethodBuilder&gt; {
115 
116         private static final Class&lt;?&gt; THIS_CLASS = new Object() { }.getClass();
</pre>
</td>
</tr>
</table>
<center><a href="../../../java/lang/reflect/ProxyGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/misc/Unsafe.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
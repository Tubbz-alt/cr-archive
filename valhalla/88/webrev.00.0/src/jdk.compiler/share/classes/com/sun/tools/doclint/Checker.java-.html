<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.doclint;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.net.URI;
  31 import java.net.URISyntaxException;
  32 import java.util.Deque;
  33 import java.util.EnumSet;
  34 import java.util.HashMap;
  35 import java.util.HashSet;
  36 import java.util.LinkedList;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.Set;
  40 import java.util.regex.Matcher;
  41 import java.util.regex.Pattern;
  42 
  43 import javax.lang.model.element.Element;
  44 import javax.lang.model.element.ElementKind;
  45 import javax.lang.model.element.ExecutableElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.VariableElement;
  48 import javax.lang.model.type.TypeKind;
  49 import javax.lang.model.type.TypeMirror;
  50 import javax.tools.Diagnostic.Kind;
  51 import javax.tools.JavaFileObject;
  52 
  53 import com.sun.source.doctree.AttributeTree;
  54 import com.sun.source.doctree.AuthorTree;
  55 import com.sun.source.doctree.DocCommentTree;
  56 import com.sun.source.doctree.DocRootTree;
  57 import com.sun.source.doctree.DocTree;
  58 import com.sun.source.doctree.EndElementTree;
  59 import com.sun.source.doctree.EntityTree;
  60 import com.sun.source.doctree.ErroneousTree;
  61 import com.sun.source.doctree.IdentifierTree;
  62 import com.sun.source.doctree.IndexTree;
  63 import com.sun.source.doctree.InheritDocTree;
  64 import com.sun.source.doctree.LinkTree;
  65 import com.sun.source.doctree.LiteralTree;
  66 import com.sun.source.doctree.ParamTree;
  67 import com.sun.source.doctree.ProvidesTree;
  68 import com.sun.source.doctree.ReferenceTree;
  69 import com.sun.source.doctree.ReturnTree;
  70 import com.sun.source.doctree.SerialDataTree;
  71 import com.sun.source.doctree.SerialFieldTree;
  72 import com.sun.source.doctree.SinceTree;
  73 import com.sun.source.doctree.StartElementTree;
  74 import com.sun.source.doctree.SummaryTree;
  75 import com.sun.source.doctree.SystemPropertyTree;
  76 import com.sun.source.doctree.TextTree;
  77 import com.sun.source.doctree.ThrowsTree;
  78 import com.sun.source.doctree.UnknownBlockTagTree;
  79 import com.sun.source.doctree.UnknownInlineTagTree;
  80 import com.sun.source.doctree.UsesTree;
  81 import com.sun.source.doctree.ValueTree;
  82 import com.sun.source.doctree.VersionTree;
  83 import com.sun.source.tree.Tree;
  84 import com.sun.source.util.DocTreePath;
  85 import com.sun.source.util.DocTreePathScanner;
  86 import com.sun.source.util.TreePath;
  87 import com.sun.tools.doclint.HtmlTag.AttrKind;
  88 import com.sun.tools.javac.tree.DocPretty;
  89 import com.sun.tools.javac.util.Assert;
  90 import com.sun.tools.javac.util.DefinedBy;
  91 import com.sun.tools.javac.util.DefinedBy.Api;
  92 import com.sun.tools.javac.util.StringUtils;
  93 
  94 import static com.sun.tools.doclint.Messages.Group.*;
  95 
  96 
  97 /**
  98  * Validate a doc comment.
  99  *
 100  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 101  * If you write code that depends on this, you do so at your own
 102  * risk.  This code and its internal interfaces are subject to change
 103  * or deletion without notice.&lt;/b&gt;&lt;/p&gt;
 104  */
 105 public class Checker extends DocTreePathScanner&lt;Void, Void&gt; {
 106     final Env env;
 107 
 108     Set&lt;Element&gt; foundParams = new HashSet&lt;&gt;();
 109     Set&lt;TypeMirror&gt; foundThrows = new HashSet&lt;&gt;();
 110     Map&lt;Element, Set&lt;String&gt;&gt; foundAnchors = new HashMap&lt;&gt;();
 111     boolean foundInheritDoc = false;
 112     boolean foundReturn = false;
 113     boolean hasNonWhitespaceText = false;
 114 
 115     public enum Flag {
 116         TABLE_HAS_CAPTION,
 117         HAS_ELEMENT,
 118         HAS_HEADING,
 119         HAS_INLINE_TAG,
 120         HAS_TEXT,
 121         REPORTED_BAD_INLINE
 122     }
 123 
 124     static class TagStackItem {
 125         final DocTree tree; // typically, but not always, StartElementTree
 126         final HtmlTag tag;
 127         final Set&lt;HtmlTag.Attr&gt; attrs;
 128         final Set&lt;Flag&gt; flags;
 129         TagStackItem(DocTree tree, HtmlTag tag) {
 130             this.tree = tree;
 131             this.tag = tag;
 132             attrs = EnumSet.noneOf(HtmlTag.Attr.class);
 133             flags = EnumSet.noneOf(Flag.class);
 134         }
 135         @Override
 136         public String toString() {
 137             return String.valueOf(tag);
 138         }
 139     }
 140 
 141     private final Deque&lt;TagStackItem&gt; tagStack; // TODO: maybe want to record starting tree as well
 142     private HtmlTag currHeadingTag;
 143 
 144     private int implicitHeadingRank;
 145 
 146     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Top level&quot;&gt;
 147 
 148     Checker(Env env) {
 149         this.env = Assert.checkNonNull(env);
 150         tagStack = new LinkedList&lt;&gt;();
 151     }
 152 
 153     public Void scan(DocCommentTree tree, TreePath p) {
 154         env.initTypes();
 155         env.setCurrent(p, tree);
 156 
 157         boolean isOverridingMethod = !env.currOverriddenMethods.isEmpty();
 158         JavaFileObject fo = p.getCompilationUnit().getSourceFile();
 159 
 160         if (p.getLeaf().getKind() == Tree.Kind.PACKAGE) {
 161             // If p points to a package, the implied declaration is the
 162             // package declaration (if any) for the compilation unit.
 163             // Handle this case specially, because doc comments are only
 164             // expected in package-info files.
 165             boolean isPkgInfo = fo.isNameCompatible(&quot;package-info&quot;, JavaFileObject.Kind.SOURCE);
 166             if (tree == null) {
 167                 if (isPkgInfo)
 168                     reportMissing(&quot;dc.missing.comment&quot;);
 169                 return null;
 170             } else {
 171                 if (!isPkgInfo)
 172                     reportReference(&quot;dc.unexpected.comment&quot;);
 173             }
 174         } else if (tree != null &amp;&amp; fo.isNameCompatible(&quot;package&quot;, JavaFileObject.Kind.HTML)) {
 175             // a package.html file with a DocCommentTree
 176             if (tree.getFullBody().isEmpty()) {
 177                 reportMissing(&quot;dc.missing.comment&quot;);
 178                 return null;
 179             }
 180         } else {
 181             if (tree == null) {
 182                 if (!isSynthetic() &amp;&amp; !isOverridingMethod)
 183                     reportMissing(&quot;dc.missing.comment&quot;);
 184                 return null;
 185             }
 186         }
 187 
 188         tagStack.clear();
 189         currHeadingTag = null;
 190 
 191         foundParams.clear();
 192         foundThrows.clear();
 193         foundInheritDoc = false;
 194         foundReturn = false;
 195         hasNonWhitespaceText = false;
 196 
 197         switch (p.getLeaf().getKind()) {
 198             // the following are for declarations that have their own top-level page,
 199             // and so the doc comment comes after the &lt;h1&gt; page title.
 200             case MODULE:
 201             case PACKAGE:
 202             case CLASS:
 203             case INTERFACE:
 204             case ENUM:
 205             case ANNOTATION_TYPE:
 206             case RECORD:
 207                 implicitHeadingRank = 1;
 208                 break;
 209 
 210             // this is for html files
 211             // ... if it is a legacy package.html, the doc comment comes after the &lt;h1&gt; page title
 212             // ... otherwise, (e.g. overview file and doc-files/*.html files) no additional headings are inserted
 213             case COMPILATION_UNIT:
 214                 implicitHeadingRank = fo.isNameCompatible(&quot;package&quot;, JavaFileObject.Kind.HTML) ? 1 : 0;
 215                 break;
 216 
 217             // the following are for member declarations, which appear in the page
 218             // for the enclosing type, and so appear after the &lt;h2&gt; &quot;Members&quot;
 219             // aggregate heading and the specific &lt;h3&gt; &quot;Member signature&quot; heading.
 220             case METHOD:
 221             case VARIABLE:
 222                 implicitHeadingRank = 3;
 223                 break;
 224 
 225             default:
 226                 Assert.error(&quot;unexpected tree kind: &quot; + p.getLeaf().getKind() + &quot; &quot; + fo);
 227         }
 228 
 229         scan(new DocTreePath(p, tree), null);
 230 
 231         if (!isOverridingMethod) {
 232             switch (env.currElement.getKind()) {
 233                 case METHOD:
 234                 case CONSTRUCTOR: {
 235                     ExecutableElement ee = (ExecutableElement) env.currElement;
 236                     checkParamsDocumented(ee.getTypeParameters());
 237                     checkParamsDocumented(ee.getParameters());
 238                     switch (ee.getReturnType().getKind()) {
 239                         case VOID:
 240                         case NONE:
 241                             break;
 242                         default:
 243                             if (!foundReturn
 244                                     &amp;&amp; !foundInheritDoc
 245                                     &amp;&amp; !env.types.isSameType(ee.getReturnType(), env.java_lang_Void)) {
 246                                 reportMissing(&quot;dc.missing.return&quot;);
 247                             }
 248                     }
 249                     checkThrowsDocumented(ee.getThrownTypes());
 250                 }
 251             }
 252         }
 253 
 254         return null;
 255     }
 256 
 257     private void reportMissing(String code, Object... args) {
 258         env.messages.report(MISSING, Kind.WARNING, env.currPath.getLeaf(), code, args);
 259     }
 260 
 261     private void reportReference(String code, Object... args) {
 262         env.messages.report(REFERENCE, Kind.WARNING, env.currPath.getLeaf(), code, args);
 263     }
 264 
 265     @Override @DefinedBy(Api.COMPILER_TREE)
 266     public Void visitDocComment(DocCommentTree tree, Void ignore) {
 267         super.visitDocComment(tree, ignore);
 268         for (TagStackItem tsi: tagStack) {
 269             warnIfEmpty(tsi, null);
 270             if (tsi.tree.getKind() == DocTree.Kind.START_ELEMENT
 271                     &amp;&amp; tsi.tag.endKind == HtmlTag.EndKind.REQUIRED) {
 272                 StartElementTree t = (StartElementTree) tsi.tree;
 273                 env.messages.error(HTML, t, &quot;dc.tag.not.closed&quot;, t.getName());
 274             }
 275         }
 276         return null;
 277     }
 278     // &lt;/editor-fold&gt;
 279 
 280     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Text and entities.&quot;&gt;
 281 
 282     @Override @DefinedBy(Api.COMPILER_TREE)
 283     public Void visitText(TextTree tree, Void ignore) {
 284         hasNonWhitespaceText = hasNonWhitespace(tree);
 285         if (hasNonWhitespaceText) {
 286             checkAllowsText(tree);
 287             markEnclosingTag(Flag.HAS_TEXT);
 288         }
 289         return null;
 290     }
 291 
 292     @Override @DefinedBy(Api.COMPILER_TREE)
 293     public Void visitEntity(EntityTree tree, Void ignore) {
 294         checkAllowsText(tree);
 295         markEnclosingTag(Flag.HAS_TEXT);
 296         String name = tree.getName().toString();
 297         if (name.startsWith(&quot;#&quot;)) {
 298             int v = StringUtils.toLowerCase(name).startsWith(&quot;#x&quot;)
 299                     ? Integer.parseInt(name.substring(2), 16)
 300                     : Integer.parseInt(name.substring(1), 10);
 301             if (!Entity.isValid(v)) {
 302                 env.messages.error(HTML, tree, &quot;dc.entity.invalid&quot;, name);
 303             }
 304         } else if (!Entity.isValid(name)) {
 305             env.messages.error(HTML, tree, &quot;dc.entity.invalid&quot;, name);
 306         }
 307         return null;
 308     }
 309 
 310     void checkAllowsText(DocTree tree) {
 311         TagStackItem top = tagStack.peek();
 312         if (top != null
 313                 &amp;&amp; top.tree.getKind() == DocTree.Kind.START_ELEMENT
 314                 &amp;&amp; !top.tag.acceptsText()) {
 315             if (top.flags.add(Flag.REPORTED_BAD_INLINE)) {
 316                 env.messages.error(HTML, tree, &quot;dc.text.not.allowed&quot;,
 317                         ((StartElementTree) top.tree).getName());
 318             }
 319         }
 320     }
 321 
 322     // &lt;/editor-fold&gt;
 323 
 324     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;HTML elements&quot;&gt;
 325 
 326     @Override @DefinedBy(Api.COMPILER_TREE)
 327     public Void visitStartElement(StartElementTree tree, Void ignore) {
 328         final Name treeName = tree.getName();
 329         final HtmlTag t = HtmlTag.get(treeName);
 330         if (t == null) {
 331             env.messages.error(HTML, tree, &quot;dc.tag.unknown&quot;, treeName);
 332         } else if (t.allowedVersion != HtmlVersion.ALL &amp;&amp; t.allowedVersion != env.htmlVersion) {
 333             env.messages.error(HTML, tree, &quot;dc.tag.not.supported&quot;, treeName);
 334         } else {
 335             boolean done = false;
 336             for (TagStackItem tsi: tagStack) {
 337                 if (tsi.tag.accepts(t)) {
 338                     while (tagStack.peek() != tsi) {
 339                         warnIfEmpty(tagStack.peek(), null);
 340                         tagStack.pop();
 341                     }
 342                     done = true;
 343                     break;
 344                 } else if (tsi.tag.endKind != HtmlTag.EndKind.OPTIONAL) {
 345                     done = true;
 346                     break;
 347                 }
 348             }
 349             if (!done &amp;&amp; HtmlTag.BODY.accepts(t)) {
 350                 while (!tagStack.isEmpty()) {
 351                     warnIfEmpty(tagStack.peek(), null);
 352                     tagStack.pop();
 353                 }
 354             }
 355 
 356             markEnclosingTag(Flag.HAS_ELEMENT);
 357             checkStructure(tree, t);
 358 
 359             // tag specific checks
 360             switch (t) {
 361                 // check for out of sequence headings, such as &lt;h1&gt;...&lt;/h1&gt;  &lt;h3&gt;...&lt;/h3&gt;
 362                 case H1: case H2: case H3: case H4: case H5: case H6:
 363                     checkHeading(tree, t);
 364                     break;
 365             }
 366 
 367             if (t.flags.contains(HtmlTag.Flag.NO_NEST)) {
 368                 for (TagStackItem i: tagStack) {
 369                     if (t == i.tag) {
 370                         env.messages.warning(HTML, tree, &quot;dc.tag.nested.not.allowed&quot;, treeName);
 371                         break;
 372                     }
 373                 }
 374             }
 375         }
 376 
 377         // check for self closing tags, such as &lt;a id=&quot;name&quot;/&gt;
 378         if (tree.isSelfClosing()) {
 379             env.messages.error(HTML, tree, &quot;dc.tag.self.closing&quot;, treeName);
 380         }
 381 
 382         try {
 383             TagStackItem parent = tagStack.peek();
 384             TagStackItem top = new TagStackItem(tree, t);
 385             tagStack.push(top);
 386 
 387             super.visitStartElement(tree, ignore);
 388 
 389             // handle attributes that may or may not have been found in start element
 390             if (t != null) {
 391                 switch (t) {
 392                     case CAPTION:
 393                         if (parent != null &amp;&amp; parent.tag == HtmlTag.TABLE)
 394                             parent.flags.add(Flag.TABLE_HAS_CAPTION);
 395                         break;
 396 
 397                     case H1: case H2: case H3: case H4: case H5: case H6:
 398                         if (parent != null &amp;&amp; (parent.tag == HtmlTag.SECTION || parent.tag == HtmlTag.ARTICLE)) {
 399                             parent.flags.add(Flag.HAS_HEADING);
 400                         }
 401                         break;
 402 
 403                     case IMG:
 404                         if (!top.attrs.contains(HtmlTag.Attr.ALT))
 405                             env.messages.error(ACCESSIBILITY, tree, &quot;dc.no.alt.attr.for.image&quot;);
 406                         break;
 407                 }
 408             }
 409 
 410             return null;
 411         } finally {
 412 
 413             if (t == null || t.endKind == HtmlTag.EndKind.NONE)
 414                 tagStack.pop();
 415         }
 416     }
 417 
 418     private void checkStructure(StartElementTree tree, HtmlTag t) {
 419         Name treeName = tree.getName();
 420         TagStackItem top = tagStack.peek();
 421         switch (t.blockType) {
 422             case BLOCK:
 423                 if (top == null || top.tag.accepts(t))
 424                     return;
 425 
 426                 switch (top.tree.getKind()) {
 427                     case START_ELEMENT: {
 428                         if (top.tag.blockType == HtmlTag.BlockType.INLINE) {
 429                             Name name = ((StartElementTree) top.tree).getName();
 430                             env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.inline.element&quot;,
 431                                     treeName, name);
 432                             return;
 433                         }
 434                     }
 435                     break;
 436 
 437                     case LINK:
 438                     case LINK_PLAIN: {
 439                         String name = top.tree.getKind().tagName;
 440                         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.inline.tag&quot;,
 441                                 treeName, name);
 442                         return;
 443                     }
 444                 }
 445                 break;
 446 
 447             case INLINE:
 448                 if (top == null || top.tag.accepts(t))
 449                     return;
 450                 break;
 451 
 452             case LIST_ITEM:
 453             case TABLE_ITEM:
 454                 if (top != null) {
 455                     // reset this flag so subsequent bad inline content gets reported
 456                     top.flags.remove(Flag.REPORTED_BAD_INLINE);
 457                     if (top.tag.accepts(t))
 458                         return;
 459                 }
 460                 break;
 461 
 462             case OTHER:
 463                 switch (t) {
 464                     case SCRIPT:
 465                         // &lt;script&gt; may or may not be allowed, depending on --allow-script-in-comments
 466                         // but we allow it here, and rely on a separate scanner to detect all uses
 467                         // of JavaScript, including &lt;script&gt; tags, and use in attributes, etc.
 468                         break;
 469 
 470                     default:
 471                         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed&quot;, treeName);
 472                 }
 473                 return;
 474         }
 475 
 476         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.here&quot;, treeName);
 477     }
 478 
 479     private void checkHeading(StartElementTree tree, HtmlTag tag) {
 480         // verify the new tag
 481         if (getHeadingRank(tag) &gt; getHeadingRank(currHeadingTag) + 1) {
 482             if (currHeadingTag == null) {
 483                 env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.1&quot;,
 484                         tag, implicitHeadingRank);
 485             } else {
 486                 env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.2&quot;,
 487                     tag, currHeadingTag);
 488             }
 489         } else if (getHeadingRank(tag) &lt;= implicitHeadingRank) {
 490             env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.3&quot;,
 491                     tag, implicitHeadingRank);
 492         }
 493 
 494         currHeadingTag = tag;
 495     }
 496 
 497     private int getHeadingRank(HtmlTag tag) {
 498         if (tag == null)
 499             return implicitHeadingRank;
 500         switch (tag) {
 501             case H1: return 1;
 502             case H2: return 2;
 503             case H3: return 3;
 504             case H4: return 4;
 505             case H5: return 5;
 506             case H6: return 6;
 507             default: throw new IllegalArgumentException();
 508         }
 509     }
 510 
 511     @Override @DefinedBy(Api.COMPILER_TREE)
 512     public Void visitEndElement(EndElementTree tree, Void ignore) {
 513         final Name treeName = tree.getName();
 514         final HtmlTag t = HtmlTag.get(treeName);
 515         if (t == null) {
 516             env.messages.error(HTML, tree, &quot;dc.tag.unknown&quot;, treeName);
 517         } else if (t.endKind == HtmlTag.EndKind.NONE) {
 518             env.messages.error(HTML, tree, &quot;dc.tag.end.not.permitted&quot;, treeName);
 519         } else {
 520             boolean done = false;
 521             while (!tagStack.isEmpty()) {
 522                 TagStackItem top = tagStack.peek();
 523                 if (t == top.tag) {
 524                     switch (t) {
 525                         case TABLE:
 526                             if (!top.attrs.contains(HtmlTag.Attr.SUMMARY)
 527                                     &amp;&amp; !top.flags.contains(Flag.TABLE_HAS_CAPTION)) {
 528                                 env.messages.error(ACCESSIBILITY, tree,
 529                                         &quot;dc.no.summary.or.caption.for.table&quot;);
 530                             }
 531                             break;
 532 
 533                         case SECTION:
 534                         case ARTICLE:
 535                             if (env.htmlVersion == HtmlVersion.HTML5 &amp;&amp; !top.flags.contains(Flag.HAS_HEADING)) {
 536                                 env.messages.error(HTML, tree, &quot;dc.tag.requires.heading&quot;, treeName);
 537                             }
 538                             break;
 539                     }
 540                     warnIfEmpty(top, tree);
 541                     tagStack.pop();
 542                     done = true;
 543                     break;
 544                 } else if (top.tag == null || top.tag.endKind != HtmlTag.EndKind.REQUIRED) {
 545                     tagStack.pop();
 546                 } else {
 547                     boolean found = false;
 548                     for (TagStackItem si: tagStack) {
 549                         if (si.tag == t) {
 550                             found = true;
 551                             break;
 552                         }
 553                     }
 554                     if (found &amp;&amp; top.tree.getKind() == DocTree.Kind.START_ELEMENT) {
 555                         env.messages.error(HTML, top.tree, &quot;dc.tag.start.unmatched&quot;,
 556                                 ((StartElementTree) top.tree).getName());
 557                         tagStack.pop();
 558                     } else {
 559                         env.messages.error(HTML, tree, &quot;dc.tag.end.unexpected&quot;, treeName);
 560                         done = true;
 561                         break;
 562                     }
 563                 }
 564             }
 565 
 566             if (!done &amp;&amp; tagStack.isEmpty()) {
 567                 env.messages.error(HTML, tree, &quot;dc.tag.end.unexpected&quot;, treeName);
 568             }
 569         }
 570 
 571         return super.visitEndElement(tree, ignore);
 572     }
 573 
 574     void warnIfEmpty(TagStackItem tsi, DocTree endTree) {
 575         if (tsi.tag != null &amp;&amp; tsi.tree instanceof StartElementTree) {
 576             if (tsi.tag.flags.contains(HtmlTag.Flag.EXPECT_CONTENT)
 577                     &amp;&amp; !tsi.flags.contains(Flag.HAS_TEXT)
 578                     &amp;&amp; !tsi.flags.contains(Flag.HAS_ELEMENT)
 579                     &amp;&amp; !tsi.flags.contains(Flag.HAS_INLINE_TAG)) {
 580                 DocTree tree = (endTree != null) ? endTree : tsi.tree;
 581                 Name treeName = ((StartElementTree) tsi.tree).getName();
 582                 env.messages.warning(HTML, tree, &quot;dc.tag.empty&quot;, treeName);
 583             }
 584         }
 585     }
 586 
 587     // &lt;/editor-fold&gt;
 588 
 589     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;HTML attributes&quot;&gt;
 590 
 591     @Override @DefinedBy(Api.COMPILER_TREE) @SuppressWarnings(&quot;fallthrough&quot;)
 592     public Void visitAttribute(AttributeTree tree, Void ignore) {
 593         HtmlTag currTag = tagStack.peek().tag;
 594         if (currTag != null) {
 595             Name name = tree.getName();
 596             HtmlTag.Attr attr = currTag.getAttr(name);
 597             if (attr != null) {
 598                 if (env.htmlVersion == HtmlVersion.HTML4 &amp;&amp; attr.name().contains(&quot;-&quot;)) {
 599                     env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html4&quot;, name);
 600                 }
 601                 boolean first = tagStack.peek().attrs.add(attr);
 602                 if (!first)
 603                     env.messages.error(HTML, tree, &quot;dc.attr.repeated&quot;, name);
 604             }
 605             // for now, doclint allows all attribute names beginning with &quot;on&quot; as event handler names,
 606             // without checking the validity or applicability of the name
 607             if (!name.toString().startsWith(&quot;on&quot;)) {
 608                 AttrKind k = currTag.getAttrKind(name);
 609                 switch (env.htmlVersion) {
 610                     case HTML4:
 611                         validateHtml4Attrs(tree, name, k);
 612                         break;
 613 
 614                     case HTML5:
 615                         validateHtml5Attrs(tree, name, k);
 616                         break;
 617                 }
 618             }
 619 
 620             if (attr != null) {
 621                 switch (attr) {
 622                     case NAME:
 623                         if (currTag != HtmlTag.A) {
 624                             break;
 625                         }
 626                         // fallthrough
 627                     case ID:
 628                         String value = getAttrValue(tree);
 629                         if (value == null) {
 630                             env.messages.error(HTML, tree, &quot;dc.anchor.value.missing&quot;);
 631                         } else {
 632                             if (!validName.matcher(value).matches()) {
 633                                 env.messages.error(HTML, tree, &quot;dc.invalid.anchor&quot;, value);
 634                             }
 635                             if (!checkAnchor(value)) {
 636                                 env.messages.error(HTML, tree, &quot;dc.anchor.already.defined&quot;, value);
 637                             }
 638                         }
 639                         break;
 640 
 641                     case HREF:
 642                         if (currTag == HtmlTag.A) {
 643                             String v = getAttrValue(tree);
 644                             if (v == null || v.isEmpty()) {
 645                                 env.messages.error(HTML, tree, &quot;dc.attr.lacks.value&quot;);
 646                             } else {
 647                                 Matcher m = docRoot.matcher(v);
 648                                 if (m.matches()) {
 649                                     String rest = m.group(2);
 650                                     if (!rest.isEmpty())
 651                                         checkURI(tree, rest);
 652                                 } else {
 653                                     checkURI(tree, v);
 654                                 }
 655                             }
 656                         }
 657                         break;
 658 
 659                     case VALUE:
 660                         if (currTag == HtmlTag.LI) {
 661                             String v = getAttrValue(tree);
 662                             if (v == null || v.isEmpty()) {
 663                                 env.messages.error(HTML, tree, &quot;dc.attr.lacks.value&quot;);
 664                             } else if (!validNumber.matcher(v).matches()) {
 665                                 env.messages.error(HTML, tree, &quot;dc.attr.not.number&quot;);
 666                             }
 667                         }
 668                         break;
 669 
 670                     case BORDER:
 671                         if (currTag == HtmlTag.TABLE) {
 672                             String v = getAttrValue(tree);
 673                             try {
 674                                 if (env.htmlVersion == HtmlVersion.HTML5
 675                                         &amp;&amp; (v == null || (!v.isEmpty() &amp;&amp; Integer.parseInt(v) != 1))) {
 676                                     env.messages.error(HTML, tree, &quot;dc.attr.table.border.html5&quot;, attr);
 677                                 }
 678                             } catch (NumberFormatException ex) {
 679                                 env.messages.error(HTML, tree, &quot;dc.attr.table.border.html5&quot;, attr);
 680                             }
 681                         }
 682                         break;
 683                 }
 684             }
 685         }
 686 
 687         // TODO: basic check on value
 688 
 689         return null;
 690     }
 691 
 692     private void validateHtml4Attrs(AttributeTree tree, Name name, AttrKind k) {
 693         switch (k) {
 694             case ALL:
 695             case HTML4:
 696                 break;
 697 
 698             case INVALID:
 699                 env.messages.error(HTML, tree, &quot;dc.attr.unknown&quot;, name);
 700                 break;
 701 
 702             case OBSOLETE:
 703                 env.messages.warning(HTML, tree, &quot;dc.attr.obsolete&quot;, name);
 704                 break;
 705 
 706             case USE_CSS:
 707                 env.messages.warning(HTML, tree, &quot;dc.attr.obsolete.use.css&quot;, name);
 708                 break;
 709 
 710             case HTML5:
 711                 env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html4&quot;, name);
 712                 break;
 713         }
 714     }
 715 
 716     private void validateHtml5Attrs(AttributeTree tree, Name name, AttrKind k) {
 717         switch (k) {
 718             case ALL:
 719             case HTML5:
 720                 break;
 721 
 722             case INVALID:
 723             case OBSOLETE:
 724             case USE_CSS:
 725             case HTML4:
 726                 env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html5&quot;, name);
 727                 break;
 728         }
 729     }
 730 
 731     private boolean checkAnchor(String name) {
 732         Element e = getEnclosingPackageOrClass(env.currElement);
 733         if (e == null)
 734             return true;
 735         Set&lt;String&gt; set = foundAnchors.get(e);
 736         if (set == null)
 737             foundAnchors.put(e, set = new HashSet&lt;&gt;());
 738         return set.add(name);
 739     }
 740 
 741     private Element getEnclosingPackageOrClass(Element e) {
 742         while (e != null) {
 743             switch (e.getKind()) {
 744                 case CLASS:
 745                 case ENUM:
 746                 case INTERFACE:
 747                 case PACKAGE:
 748                     return e;
 749                 default:
 750                     e = e.getEnclosingElement();
 751             }
 752         }
 753         return e;
 754     }
 755 
 756     // http://www.w3.org/TR/html401/types.html#type-name
 757     private static final Pattern validName = Pattern.compile(&quot;[A-Za-z][A-Za-z0-9-_:.]*&quot;);
 758 
 759     private static final Pattern validNumber = Pattern.compile(&quot;-?[0-9]+&quot;);
 760 
 761     // pattern to remove leading {@docRoot}/?
 762     private static final Pattern docRoot = Pattern.compile(&quot;(?i)(\\{@docRoot *\\}/?)?(.*)&quot;);
 763 
 764     private String getAttrValue(AttributeTree tree) {
 765         if (tree.getValue() == null)
 766             return null;
 767 
 768         StringWriter sw = new StringWriter();
 769         try {
 770             new DocPretty(sw).print(tree.getValue());
 771         } catch (IOException e) {
 772             // cannot happen
 773         }
 774         // ignore potential use of entities for now
 775         return sw.toString();
 776     }
 777 
 778     private void checkURI(AttributeTree tree, String uri) {
 779         // allow URIs beginning with javascript:, which would otherwise be rejected by the URI API.
 780         if (uri.startsWith(&quot;javascript:&quot;))
 781             return;
 782         try {
 783             URI u = new URI(uri);
 784         } catch (URISyntaxException e) {
 785             env.messages.error(HTML, tree, &quot;dc.invalid.uri&quot;, uri);
 786         }
 787     }
 788     // &lt;/editor-fold&gt;
 789 
 790     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;javadoc tags&quot;&gt;
 791 
 792     @Override @DefinedBy(Api.COMPILER_TREE)
 793     public Void visitAuthor(AuthorTree tree, Void ignore) {
 794         warnIfEmpty(tree, tree.getName());
 795         return super.visitAuthor(tree, ignore);
 796     }
 797 
 798     @Override @DefinedBy(Api.COMPILER_TREE)
 799     public Void visitDocRoot(DocRootTree tree, Void ignore) {
 800         markEnclosingTag(Flag.HAS_INLINE_TAG);
 801         return super.visitDocRoot(tree, ignore);
 802     }
 803 
 804     @Override @DefinedBy(Api.COMPILER_TREE)
 805     public Void visitIndex(IndexTree tree, Void ignore) {
 806         markEnclosingTag(Flag.HAS_INLINE_TAG);
 807         for (TagStackItem tsi : tagStack) {
 808             if (tsi.tag == HtmlTag.A) {
 809                 env.messages.warning(HTML, tree, &quot;dc.tag.a.within.a&quot;,
 810                         &quot;{@&quot; + tree.getTagName() + &quot;}&quot;);
 811                 break;
 812             }
 813         }
 814         return super.visitIndex(tree, ignore);
 815     }
 816 
 817     @Override @DefinedBy(Api.COMPILER_TREE)
 818     public Void visitInheritDoc(InheritDocTree tree, Void ignore) {
 819         markEnclosingTag(Flag.HAS_INLINE_TAG);
 820         // TODO: verify on overridden method
 821         foundInheritDoc = true;
 822         return super.visitInheritDoc(tree, ignore);
 823     }
 824 
 825     @Override @DefinedBy(Api.COMPILER_TREE)
 826     public Void visitLink(LinkTree tree, Void ignore) {
 827         markEnclosingTag(Flag.HAS_INLINE_TAG);
 828         // simulate inline context on tag stack
 829         HtmlTag t = (tree.getKind() == DocTree.Kind.LINK)
 830                 ? HtmlTag.CODE : HtmlTag.SPAN;
 831         tagStack.push(new TagStackItem(tree, t));
 832         try {
 833             return super.visitLink(tree, ignore);
 834         } finally {
 835             tagStack.pop();
 836         }
 837     }
 838 
 839     @Override @DefinedBy(Api.COMPILER_TREE)
 840     public Void visitLiteral(LiteralTree tree, Void ignore) {
 841         markEnclosingTag(Flag.HAS_INLINE_TAG);
 842         if (tree.getKind() == DocTree.Kind.CODE) {
 843             for (TagStackItem tsi: tagStack) {
 844                 if (tsi.tag == HtmlTag.CODE) {
 845                     env.messages.warning(HTML, tree, &quot;dc.tag.code.within.code&quot;);
 846                     break;
 847                 }
 848             }
 849         }
 850         return super.visitLiteral(tree, ignore);
 851     }
 852 
 853     @Override @DefinedBy(Api.COMPILER_TREE)
 854     @SuppressWarnings(&quot;fallthrough&quot;)
 855     public Void visitParam(ParamTree tree, Void ignore) {
 856         boolean typaram = tree.isTypeParameter();
 857         IdentifierTree nameTree = tree.getName();
 858         Element paramElement = nameTree != null ? env.trees.getElement(new DocTreePath(getCurrentPath(), nameTree)) : null;
 859 
 860         if (paramElement == null) {
 861             switch (env.currElement.getKind()) {
 862                 case CLASS: case INTERFACE: {
 863                     if (!typaram) {
 864                         env.messages.error(REFERENCE, tree, &quot;dc.invalid.param&quot;);
 865                         break;
 866                     }
 867                 }
 868                 case METHOD: case CONSTRUCTOR: {
 869                     env.messages.error(REFERENCE, nameTree, &quot;dc.param.name.not.found&quot;);
 870                     break;
 871                 }
 872 
 873                 default:
 874                     env.messages.error(REFERENCE, tree, &quot;dc.invalid.param&quot;);
 875                     break;
 876             }
 877         } else {
 878             boolean unique = foundParams.add(paramElement);
 879 
 880             if (!unique) {
 881                 env.messages.warning(REFERENCE, tree, &quot;dc.exists.param&quot;, nameTree);
 882             }
 883         }
 884 
 885         warnIfEmpty(tree, tree.getDescription());
 886         return super.visitParam(tree, ignore);
 887     }
 888 
 889     private void checkParamsDocumented(List&lt;? extends Element&gt; list) {
 890         if (foundInheritDoc)
 891             return;
 892 
 893         for (Element e: list) {
 894             if (!foundParams.contains(e)) {
 895                 CharSequence paramName = (e.getKind() == ElementKind.TYPE_PARAMETER)
 896                         ? &quot;&lt;&quot; + e.getSimpleName() + &quot;&gt;&quot;
 897                         : e.getSimpleName();
 898                 reportMissing(&quot;dc.missing.param&quot;, paramName);
 899             }
 900         }
 901     }
 902 
 903     @Override @DefinedBy(Api.COMPILER_TREE)
 904     public Void visitProvides(ProvidesTree tree, Void ignore) {
 905         Element e = env.trees.getElement(env.currPath);
 906         if (e.getKind() != ElementKind.MODULE) {
 907             env.messages.error(REFERENCE, tree, &quot;dc.invalid.provides&quot;);
 908         }
 909         ReferenceTree serviceType = tree.getServiceType();
 910         Element se = env.trees.getElement(new DocTreePath(getCurrentPath(), serviceType));
 911         if (se == null) {
 912             env.messages.error(REFERENCE, tree, &quot;dc.service.not.found&quot;);
 913         }
 914         return super.visitProvides(tree, ignore);
 915     }
 916 
 917     @Override @DefinedBy(Api.COMPILER_TREE)
 918     public Void visitReference(ReferenceTree tree, Void ignore) {
 919         Element e = env.trees.getElement(getCurrentPath());
 920         if (e == null)
 921             env.messages.error(REFERENCE, tree, &quot;dc.ref.not.found&quot;);
 922         return super.visitReference(tree, ignore);
 923     }
 924 
 925     @Override @DefinedBy(Api.COMPILER_TREE)
 926     public Void visitReturn(ReturnTree tree, Void ignore) {
 927         if (foundReturn) {
 928             env.messages.warning(REFERENCE, tree, &quot;dc.exists.return&quot;);
 929         }
 930 
 931         Element e = env.trees.getElement(env.currPath);
 932         if (e.getKind() != ElementKind.METHOD
 933                 || ((ExecutableElement) e).getReturnType().getKind() == TypeKind.VOID)
 934             env.messages.error(REFERENCE, tree, &quot;dc.invalid.return&quot;);
 935         foundReturn = true;
 936         warnIfEmpty(tree, tree.getDescription());
 937         return super.visitReturn(tree, ignore);
 938     }
 939 
 940     @Override @DefinedBy(Api.COMPILER_TREE)
 941     public Void visitSerialData(SerialDataTree tree, Void ignore) {
 942         warnIfEmpty(tree, tree.getDescription());
 943         return super.visitSerialData(tree, ignore);
 944     }
 945 
 946     @Override @DefinedBy(Api.COMPILER_TREE)
 947     public Void visitSerialField(SerialFieldTree tree, Void ignore) {
 948         warnIfEmpty(tree, tree.getDescription());
 949         return super.visitSerialField(tree, ignore);
 950     }
 951 
 952     @Override @DefinedBy(Api.COMPILER_TREE)
 953     public Void visitSince(SinceTree tree, Void ignore) {
 954         warnIfEmpty(tree, tree.getBody());
 955         return super.visitSince(tree, ignore);
 956     }
 957 
 958     @Override @DefinedBy(Api.COMPILER_TREE)
 959     public Void visitSummary(SummaryTree node, Void aVoid) {
 960         markEnclosingTag(Flag.HAS_INLINE_TAG);
 961         int idx = env.currDocComment.getFullBody().indexOf(node);
 962         // Warn if the node is preceded by non-whitespace characters,
 963         // or other non-text nodes.
 964         if ((idx == 1 &amp;&amp; hasNonWhitespaceText) || idx &gt; 1) {
 965             env.messages.warning(SYNTAX, node, &quot;dc.invalid.summary&quot;, node.getTagName());
 966         }
 967         return super.visitSummary(node, aVoid);
 968     }
 969 
 970     @Override @DefinedBy(Api.COMPILER_TREE)
 971     public Void visitSystemProperty(SystemPropertyTree tree, Void ignore) {
 972         markEnclosingTag(Flag.HAS_INLINE_TAG);
 973         for (TagStackItem tsi : tagStack) {
 974             if (tsi.tag == HtmlTag.A) {
 975                 env.messages.warning(HTML, tree, &quot;dc.tag.a.within.a&quot;,
 976                         &quot;{@&quot; + tree.getTagName() + &quot;}&quot;);
 977                 break;
 978             }
 979         }
 980         return super.visitSystemProperty(tree, ignore);
 981     }
 982 
 983     @Override @DefinedBy(Api.COMPILER_TREE)
 984     public Void visitThrows(ThrowsTree tree, Void ignore) {
 985         ReferenceTree exName = tree.getExceptionName();
 986         Element ex = env.trees.getElement(new DocTreePath(getCurrentPath(), exName));
 987         if (ex == null) {
 988             env.messages.error(REFERENCE, tree, &quot;dc.ref.not.found&quot;);
 989         } else if (isThrowable(ex.asType())) {
 990             switch (env.currElement.getKind()) {
 991                 case CONSTRUCTOR:
 992                 case METHOD:
 993                     if (isCheckedException(ex.asType())) {
 994                         ExecutableElement ee = (ExecutableElement) env.currElement;
 995                         checkThrowsDeclared(exName, ex.asType(), ee.getThrownTypes());
 996                     }
 997                     break;
 998                 default:
 999                     env.messages.error(REFERENCE, tree, &quot;dc.invalid.throws&quot;);
1000             }
1001         } else {
1002             env.messages.error(REFERENCE, tree, &quot;dc.invalid.throws&quot;);
1003         }
1004         warnIfEmpty(tree, tree.getDescription());
1005         return scan(tree.getDescription(), ignore);
1006     }
1007 
1008     private boolean isThrowable(TypeMirror tm) {
1009         switch (tm.getKind()) {
1010             case DECLARED:
1011             case TYPEVAR:
1012                 return env.types.isAssignable(tm, env.java_lang_Throwable);
1013         }
1014         return false;
1015     }
1016 
1017     private void checkThrowsDeclared(ReferenceTree tree, TypeMirror t, List&lt;? extends TypeMirror&gt; list) {
1018         boolean found = false;
1019         for (TypeMirror tl : list) {
1020             if (env.types.isAssignable(t, tl)) {
1021                 foundThrows.add(tl);
1022                 found = true;
1023             }
1024         }
1025         if (!found)
1026             env.messages.error(REFERENCE, tree, &quot;dc.exception.not.thrown&quot;, t);
1027     }
1028 
1029     private void checkThrowsDocumented(List&lt;? extends TypeMirror&gt; list) {
1030         if (foundInheritDoc)
1031             return;
1032 
1033         for (TypeMirror tl: list) {
1034             if (isCheckedException(tl) &amp;&amp; !foundThrows.contains(tl))
1035                 reportMissing(&quot;dc.missing.throws&quot;, tl);
1036         }
1037     }
1038 
1039     @Override @DefinedBy(Api.COMPILER_TREE)
1040     public Void visitUnknownBlockTag(UnknownBlockTagTree tree, Void ignore) {
1041         checkUnknownTag(tree, tree.getTagName());
1042         return super.visitUnknownBlockTag(tree, ignore);
1043     }
1044 
1045     @Override @DefinedBy(Api.COMPILER_TREE)
1046     public Void visitUnknownInlineTag(UnknownInlineTagTree tree, Void ignore) {
1047         markEnclosingTag(Flag.HAS_INLINE_TAG);
1048         checkUnknownTag(tree, tree.getTagName());
1049         return super.visitUnknownInlineTag(tree, ignore);
1050     }
1051 
1052     private void checkUnknownTag(DocTree tree, String tagName) {
1053         if (env.customTags != null &amp;&amp; !env.customTags.contains(tagName))
1054             env.messages.error(SYNTAX, tree, &quot;dc.tag.unknown&quot;, tagName);
1055     }
1056 
1057     @Override @DefinedBy(Api.COMPILER_TREE)
1058     public Void visitUses(UsesTree tree, Void ignore) {
1059         Element e = env.trees.getElement(env.currPath);
1060         if (e.getKind() != ElementKind.MODULE) {
1061             env.messages.error(REFERENCE, tree, &quot;dc.invalid.uses&quot;);
1062         }
1063         ReferenceTree serviceType = tree.getServiceType();
1064         Element se = env.trees.getElement(new DocTreePath(getCurrentPath(), serviceType));
1065         if (se == null) {
1066             env.messages.error(REFERENCE, tree, &quot;dc.service.not.found&quot;);
1067         }
1068         return super.visitUses(tree, ignore);
1069     }
1070 
1071     @Override @DefinedBy(Api.COMPILER_TREE)
1072     public Void visitValue(ValueTree tree, Void ignore) {
1073         ReferenceTree ref = tree.getReference();
1074         if (ref == null || ref.getSignature().isEmpty()) {
1075             if (!isConstant(env.currElement))
1076                 env.messages.error(REFERENCE, tree, &quot;dc.value.not.allowed.here&quot;);
1077         } else {
1078             Element e = env.trees.getElement(new DocTreePath(getCurrentPath(), ref));
1079             if (!isConstant(e))
1080                 env.messages.error(REFERENCE, tree, &quot;dc.value.not.a.constant&quot;);
1081         }
1082 
1083         markEnclosingTag(Flag.HAS_INLINE_TAG);
1084         return super.visitValue(tree, ignore);
1085     }
1086 
1087     private boolean isConstant(Element e) {
1088         if (e == null)
1089             return false;
1090 
1091         switch (e.getKind()) {
1092             case FIELD:
1093                 Object value = ((VariableElement) e).getConstantValue();
1094                 return (value != null); // can&#39;t distinguish &quot;not a constant&quot; from &quot;constant is null&quot;
1095             default:
1096                 return false;
1097         }
1098     }
1099 
1100     @Override @DefinedBy(Api.COMPILER_TREE)
1101     public Void visitVersion(VersionTree tree, Void ignore) {
1102         warnIfEmpty(tree, tree.getBody());
1103         return super.visitVersion(tree, ignore);
1104     }
1105 
1106     @Override @DefinedBy(Api.COMPILER_TREE)
1107     public Void visitErroneous(ErroneousTree tree, Void ignore) {
1108         env.messages.error(SYNTAX, tree, null, tree.getDiagnostic().getMessage(null));
1109         return null;
1110     }
1111     // &lt;/editor-fold&gt;
1112 
1113     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Utility methods&quot;&gt;
1114 
1115     private boolean isCheckedException(TypeMirror t) {
1116         return !(env.types.isAssignable(t, env.java_lang_Error)
1117                 || env.types.isAssignable(t, env.java_lang_RuntimeException));
1118     }
1119 
1120     private boolean isSynthetic() {
1121         switch (env.currElement.getKind()) {
1122             case CONSTRUCTOR:
1123                 // A synthetic default constructor has the same pos as the
1124                 // enclosing class
1125             case METHOD:
1126                 // Ditto for a synthetic method injected by the compiler (for value types)
1127                 TreePath p = env.currPath;
1128                 return env.getPos(p) == env.getPos(p.getParentPath());
1129         }
1130         return false;
1131     }
1132 
1133     void markEnclosingTag(Flag flag) {
1134         TagStackItem top = tagStack.peek();
1135         if (top != null)
1136             top.flags.add(flag);
1137     }
1138 
1139     String toString(TreePath p) {
1140         StringBuilder sb = new StringBuilder(&quot;TreePath[&quot;);
1141         toString(p, sb);
1142         sb.append(&quot;]&quot;);
1143         return sb.toString();
1144     }
1145 
1146     void toString(TreePath p, StringBuilder sb) {
1147         TreePath parent = p.getParentPath();
1148         if (parent != null) {
1149             toString(parent, sb);
1150             sb.append(&quot;,&quot;);
1151         }
1152        sb.append(p.getLeaf().getKind()).append(&quot;:&quot;).append(env.getPos(p)).append(&quot;:S&quot;).append(env.getStartPos(p));
1153     }
1154 
1155     void warnIfEmpty(DocTree tree, List&lt;? extends DocTree&gt; list) {
1156         for (DocTree d: list) {
1157             switch (d.getKind()) {
1158                 case TEXT:
1159                     if (hasNonWhitespace((TextTree) d))
1160                         return;
1161                     break;
1162                 default:
1163                     return;
1164             }
1165         }
1166         env.messages.warning(SYNTAX, tree, &quot;dc.empty&quot;, tree.getKind().tagName);
1167     }
1168 
1169     boolean hasNonWhitespace(TextTree tree) {
1170         String s = tree.getBody();
1171         for (int i = 0; i &lt; s.length(); i++) {
1172             Character c = s.charAt(i);
1173             if (!Character.isWhitespace(s.charAt(i)))
1174                 return true;
1175         }
1176         return false;
1177     }
1178 
1179     // &lt;/editor-fold&gt;
1180 
1181 }
    </pre>
  </body>
</html>
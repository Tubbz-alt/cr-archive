diff a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -643,5 +643,7 @@
 497fd9f9129c4928fd5a876dd55e0daf6298b511 jdk-15+24
 58833044988772ca06c97ab2f142474a8627af80 jdk-15+25
 58833044988772ca06c97ab2f142474a8627af80 jdk-15+25
 90b266a84c06f1b3dc0ed8767856793e8c1c357e jdk-15+25
 0a32396f7a690015d22ca3328ac441a358295d90 jdk-15+26
+506abc554caeb275928c02bf3a16e95d1978749f jdk-15+27
+93813843680bbe1b7efbca56c03fd137f20a2c31 jdk-16+0
diff a/make/Docs.gmk b/make/Docs.gmk
--- a/make/Docs.gmk
+++ b/make/Docs.gmk
@@ -61,11 +61,11 @@
 
 # URLs
 JAVADOC_BASE_URL := https://docs.oracle.com/pls/topic/lookup?ctx=javase$(VERSION_NUMBER)&amp;id=homepage
 BUG_SUBMIT_URL := https://bugreport.java.com/bugreport/
 COPYRIGHT_URL := legal/copyright.html
-LICENSE_URL := https://www.oracle.com/technetwork/java/javase/terms/license/java$(VERSION_NUMBER)speclicense.html
+LICENSE_URL := https://www.oracle.com/java/javase/terms/license/java$(VERSION_NUMBER)speclicense.html
 REDISTRIBUTION_URL := https://www.oracle.com/technetwork/java/redist-137594.html
 
 # In order to get a specific ordering it's necessary to specify the total
 # ordering of tags as the tags are otherwise ordered in order of definition.
 JAVADOC_TAGS := \
diff a/src/hotspot/share/ci/ciEnv.cpp b/src/hotspot/share/ci/ciEnv.cpp
--- a/src/hotspot/share/ci/ciEnv.cpp
+++ b/src/hotspot/share/ci/ciEnv.cpp
@@ -40,10 +40,11 @@
 #include "code/codeCache.hpp"
 #include "code/scopeDesc.hpp"
 #include "compiler/compileBroker.hpp"
 #include "compiler/compilerEvent.hpp"
 #include "compiler/compileLog.hpp"
+#include "compiler/compileTask.hpp"
 #include "compiler/disassembler.hpp"
 #include "gc/shared/collectedHeap.inline.hpp"
 #include "interpreter/linkResolver.hpp"
 #include "jfr/jfrEvents.hpp"
 #include "logging/log.hpp"
@@ -229,20 +230,21 @@
   )
 }
 
 // ------------------------------------------------------------------
 // Cache Jvmti state
-void ciEnv::cache_jvmti_state() {
+bool ciEnv::cache_jvmti_state() {
   VM_ENTRY_MARK;
   // Get Jvmti capabilities under lock to get consistant values.
   MutexLocker mu(JvmtiThreadState_lock);
   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();
   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint();
   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables();
   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions();
   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame();
   _jvmti_can_get_owned_monitor_info     = JvmtiExport::can_get_owned_monitor_info();
+  return _task != NULL && _task->method()->is_old();
 }
 
 bool ciEnv::jvmti_state_changed() const {
   // Some classes were redefined
   if (_jvmti_redefinition_count != JvmtiExport::redefinition_count()) {
diff a/src/hotspot/share/ci/ciEnv.hpp b/src/hotspot/share/ci/ciEnv.hpp
--- a/src/hotspot/share/ci/ciEnv.hpp
+++ b/src/hotspot/share/ci/ciEnv.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -345,11 +345,11 @@
 
   bool break_at_compile() { return _break_at_compile; }
   void set_break_at_compile(bool z) { _break_at_compile = z; }
 
   // Cache Jvmti state
-  void  cache_jvmti_state();
+  bool  cache_jvmti_state();
   bool  jvmti_state_changed() const;
   bool  should_retain_local_variables() const {
     return _jvmti_can_access_local_variables || _jvmti_can_pop_frame;
   }
   bool  jvmti_can_hotswap_or_post_breakpoint() const { return _jvmti_can_hotswap_or_post_breakpoint; }
diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -133,11 +133,13 @@
 
 #define JAVA_14_VERSION                   58
 
 #define JAVA_15_VERSION                   59
 
-#define CONSTANT_CLASS_DESCRIPTORS        59
+#define JAVA_16_VERSION                   60
+
+#define CONSTANT_CLASS_DESCRIPTORS        60
 
 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
   assert((bad_constant == JVM_CONSTANT_Module ||
           bad_constant == JVM_CONSTANT_Package) && _major_version >= JAVA_9_VERSION,
          "Unexpected bad constant pool entry");
diff a/src/hotspot/share/classfile/classLoader.cpp b/src/hotspot/share/classfile/classLoader.cpp
--- a/src/hotspot/share/classfile/classLoader.cpp
+++ b/src/hotspot/share/classfile/classLoader.cpp
@@ -1526,10 +1526,23 @@
   if (Arguments::is_dumping_archive()) {
     ClassLoaderExt::setup_module_paths(THREAD);
     FileMapInfo::allocate_shared_path_table();
   }
 }
+
+// Helper function used by CDS code to get the number of module path
+// entries during shared classpath setup time.
+int ClassLoader::num_module_path_entries() {
+  Arguments::assert_is_dumping_archive();
+  int num_entries = 0;
+  ClassPathEntry* e= ClassLoader::_module_path_entries;
+  while (e != NULL) {
+    num_entries ++;
+    e = e->next();
+  }
+  return num_entries;
+}
 #endif
 
 jlong ClassLoader::classloader_time_ms() {
   return UsePerfData ?
     Management::ticks_to_ms(_perf_accumulated_time->get_value()) : -1;
diff a/src/hotspot/share/classfile/systemDictionary.cpp b/src/hotspot/share/classfile/systemDictionary.cpp
--- a/src/hotspot/share/classfile/systemDictionary.cpp
+++ b/src/hotspot/share/classfile/systemDictionary.cpp
@@ -1277,10 +1277,11 @@
 // Load a class for boot loader from the shared spaces. This also
 // forces the super class and all interfaces to be loaded.
 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
                                                         PackageEntry* pkg_entry,
                                                         TRAPS) {
+  assert(UseSharedSpaces, "Sanity check");
   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
   if (ik != NULL && ik->is_shared_boot_class()) {
     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);
   }
   return NULL;
@@ -1296,22 +1297,34 @@
                                                InstanceKlass* ik,
                                                PackageEntry* pkg_entry,
                                                Handle class_loader, TRAPS) {
   assert(!ModuleEntryTable::javabase_moduleEntry()->is_patched(),
          "Cannot use sharing if java.base is patched");
-  ResourceMark rm(THREAD);
-  int path_index = ik->shared_classpath_index();
-  ClassLoaderData* loader_data = class_loader_data(class_loader);
-  if (path_index < 0) {
+  if (ik->shared_classpath_index() < 0) {
     // path_index < 0 indicates that the class is intended for a custom loader
     // and should not be loaded by boot/platform/app loaders
-    if (loader_data->is_builtin_class_loader_data()) {
+    if (is_builtin_class_loader(class_loader())) {
       return false;
     } else {
       return true;
     }
   }
+
+  // skip class visibility check
+  if (MetaspaceShared::use_optimized_module_handling()) {
+    assert(SystemDictionary::is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD), "Optimizing module handling failed.");
+    return true;
+  }
+  return is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD);
+}
+
+bool SystemDictionary::is_shared_class_visible_impl(Symbol* class_name,
+                                               InstanceKlass* ik,
+                                               PackageEntry* pkg_entry,
+                                               Handle class_loader, TRAPS) {
+  int path_index = ik->shared_classpath_index();
+  ClassLoaderData* loader_data = class_loader_data(class_loader);
   SharedClassPathEntry* ent =
             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
   if (!Universe::is_module_initialized()) {
     assert(ent != NULL && ent->is_modules_image(),
            "Loading non-bootstrap classes before the module system is initialized");
@@ -1641,15 +1654,17 @@
            !search_only_bootloader_append,
            "Attempt to load a class outside of boot loader's module path");
 
     // Search for classes in the CDS archive.
     InstanceKlass* k = NULL;
-    {
+
 #if INCLUDE_CDS
+    if (UseSharedSpaces)
+    {
       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
       k = load_shared_boot_class(class_name, pkg_entry, THREAD);
-#endif
+    }
     }
 
     if (k == NULL) {
       // Use VM class loader
       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
diff a/src/hotspot/share/classfile/systemDictionary.hpp b/src/hotspot/share/classfile/systemDictionary.hpp
--- a/src/hotspot/share/classfile/systemDictionary.hpp
+++ b/src/hotspot/share/classfile/systemDictionary.hpp
@@ -638,10 +638,14 @@
                                                 Handle class_loader,
                                                 InstanceKlass* k, TRAPS);
   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
                                       PackageEntry* pkg_entry,
                                       Handle class_loader, TRAPS);
+  static bool is_shared_class_visible_impl(Symbol* class_name,
+                                           InstanceKlass* ik,
+                                           PackageEntry* pkg_entry,
+                                           Handle class_loader, TRAPS);
   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,
                                             Handle class_loader,  Handle protection_domain,
                                             bool is_superclass, TRAPS);
   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
                                                Handle protection_domain, TRAPS);
diff a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -2147,18 +2147,18 @@
   if (UseJVMCICompiler && comp != NULL && comp->is_jvmci()) {
     JVMCICompiler* jvmci = (JVMCICompiler*) comp;
 
     TraceTime t1("compilation", &time);
     EventCompilation event;
+    JVMCICompileState compile_state(task);
 
     // Skip redefined methods
-    if (target_handle->is_old()) {
+    if (compile_state.target_method_is_old()) {
       failure_reason = "redefined method";
       retry_message = "not retryable";
       compilable = ciEnv::MethodCompilable_never;
     } else {
-      JVMCICompileState compile_state(task);
       JVMCIEnv env(thread, &compile_state, __FILE__, __LINE__);
       methodHandle method(thread, target_handle);
       env.runtime()->compile_method(&env, jvmci, method, osr_bci);
 
       failure_reason = compile_state.failure_reason();
@@ -2191,11 +2191,16 @@
     }
     assert(thread->env() == &ci_env, "set by ci_env");
     // The thread-env() field is cleared in ~CompileTaskWrapper.
 
     // Cache Jvmti state
-    ci_env.cache_jvmti_state();
+    bool method_is_old = ci_env.cache_jvmti_state();
+
+    // Skip redefined methods
+    if (method_is_old) {
+      ci_env.record_method_not_compilable("redefined method", true);
+    }
 
     // Cache DTrace flags
     ci_env.cache_dtrace_flags();
 
     ciMethod* target = ci_env.get_method_from_handle(target_handle);
@@ -2203,11 +2208,11 @@
     TraceTime t1("compilation", &time);
     EventCompilation event;
 
     if (comp == NULL) {
       ci_env.record_method_not_compilable("no compiler", !TieredCompilation);
-    } else {
+    } else if (!ci_env.failing()) {
       if (WhiteBoxAPI && WhiteBox::compilation_locked) {
         MonitorLocker locker(Compilation_lock, Mutex::_no_safepoint_check_flag);
         while (WhiteBox::compilation_locked) {
           locker.wait();
         }
diff a/src/hotspot/share/memory/dynamicArchive.cpp b/src/hotspot/share/memory/dynamicArchive.cpp
--- a/src/hotspot/share/memory/dynamicArchive.cpp
+++ b/src/hotspot/share/memory/dynamicArchive.cpp
@@ -1143,30 +1143,26 @@
 
 DynamicArchiveBuilder* DynamicArchive::_builder = NULL;
 
 
 bool DynamicArchive::validate(FileMapInfo* dynamic_info) {
+  assert(!dynamic_info->is_static(), "must be");
   // Check if the recorded base archive matches with the current one
   FileMapInfo* base_info = FileMapInfo::current_info();
   DynamicArchiveHeader* dynamic_header = dynamic_info->dynamic_header();
 
   // Check the header crc
   if (dynamic_header->base_header_crc() != base_info->crc()) {
-    FileMapInfo::fail_continue("Archive header checksum verification failed.");
+    FileMapInfo::fail_continue("Dynamic archive cannot be used: static archive header checksum verification failed.");
     return false;
   }
 
   // Check each space's crc
   for (int i = 0; i < MetaspaceShared::n_regions; i++) {
     if (dynamic_header->base_region_crc(i) != base_info->space_crc(i)) {
-      FileMapInfo::fail_continue("Archive region #%d checksum verification failed.", i);
+      FileMapInfo::fail_continue("Dynamic archive cannot be used: static archive region #%d checksum verification failed.", i);
       return false;
     }
   }
 
-  // Validate the dynamic archived shared path table, and set the global
-  // _shared_path_table to that.
-  if (!dynamic_info->validate_shared_path_table()) {
-    return false;
-  }
   return true;
 }
diff a/src/hotspot/share/memory/metaspaceShared.cpp b/src/hotspot/share/memory/metaspaceShared.cpp
--- a/src/hotspot/share/memory/metaspaceShared.cpp
+++ b/src/hotspot/share/memory/metaspaceShared.cpp
@@ -89,10 +89,11 @@
 address MetaspaceShared::_i2i_entry_code_buffers = NULL;
 size_t MetaspaceShared::_i2i_entry_code_buffers_size = 0;
 void* MetaspaceShared::_shared_metaspace_static_top = NULL;
 intx MetaspaceShared::_relocation_delta;
 char* MetaspaceShared::_requested_base_address;
+bool MetaspaceShared::_use_optimized_module_handling = true;
 
 // The CDS archive is divided into the following regions:
 //     mc  - misc code (the method entry trampolines, c++ vtables)
 //     rw  - read-write metadata
 //     ro  - read-only metadata and read-only tables
@@ -2287,10 +2288,11 @@
   char* mapped_base_address = reserve_address_space_for_archives(static_mapinfo, dynamic_mapinfo,
                                                                  use_requested_addr, archive_space_rs,
                                                                  class_space_rs);
   if (mapped_base_address == NULL) {
     result = MAP_ARCHIVE_MMAP_FAILURE;
+    log_debug(cds)("Failed to reserve spaces (use_requested_addr=%u)", (unsigned)use_requested_addr);
   } else {
 
 #ifdef ASSERT
     // Some sanity checks after reserving address spaces for archives
     //  and class space.
@@ -2394,10 +2396,11 @@
           // map_heap_regions() compares the current narrow oop and klass encodings
           // with the archived ones, so it must be done after all encodings are determined.
           static_mapinfo->map_heap_regions();
         }
       });
+    log_info(cds)("Using optimized module handling %s", MetaspaceShared::use_optimized_module_handling() ? "enabled" : "disabled");
   } else {
     unmap_archive(static_mapinfo);
     unmap_archive(dynamic_mapinfo);
     release_reserved_spaces(archive_space_rs, class_space_rs);
   }
@@ -2489,10 +2492,12 @@
     archive_space_rs = ReservedSpace(archive_space_size, archive_space_alignment,
                                      false /* bool large */, (char*)base_address);
     if (archive_space_rs.is_reserved()) {
       assert(base_address == NULL ||
              (address)archive_space_rs.base() == base_address, "Sanity");
+      // Register archive space with NMT.
+      MemTracker::record_virtual_memory_type(archive_space_rs.base(), mtClassShared);
       return archive_space_rs.base();
     }
     return NULL;
   }
 
@@ -2608,20 +2613,13 @@
   if (result != MAP_ARCHIVE_SUCCESS) {
     unmap_archive(mapinfo);
     return result;
   }
 
-  if (mapinfo->is_static()) {
-    if (!mapinfo->validate_shared_path_table()) {
-      unmap_archive(mapinfo);
-      return MAP_ARCHIVE_OTHER_FAILURE;
-    }
-  } else {
-    if (!DynamicArchive::validate(mapinfo)) {
-      unmap_archive(mapinfo);
-      return MAP_ARCHIVE_OTHER_FAILURE;
-    }
+  if (!mapinfo->validate_shared_path_table()) {
+    unmap_archive(mapinfo);
+    return MAP_ARCHIVE_OTHER_FAILURE;
   }
 
   mapinfo->set_is_mapped(true);
   return MAP_ARCHIVE_SUCCESS;
 }
diff a/src/hotspot/share/oops/cpCache.cpp b/src/hotspot/share/oops/cpCache.cpp
--- a/src/hotspot/share/oops/cpCache.cpp
+++ b/src/hotspot/share/oops/cpCache.cpp
@@ -565,19 +565,18 @@
 
 
 #if INCLUDE_JVMTI
 
 void log_adjust(const char* entry_type, Method* old_method, Method* new_method, bool* trace_name_printed) {
-  if (log_is_enabled(Info, redefine, class, update)) {
-    ResourceMark rm;
-    if (!(*trace_name_printed)) {
-      log_info(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
-      *trace_name_printed = true;
-    }
-    log_debug(redefine, class, update, constantpool)
-          ("cpc %s entry update: %s(%s)", entry_type, new_method->name()->as_C_string(), new_method->signature()->as_C_string());
+  ResourceMark rm;
+
+  if (!(*trace_name_printed)) {
+    log_info(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
+    *trace_name_printed = true;
   }
+  log_trace(redefine, class, update, constantpool)
+    ("cpc %s entry update: %s", entry_type, new_method->external_name());
 }
 
 // RedefineClasses() API support:
 // If this ConstantPoolCacheEntry refers to old_method then update it
 // to refer to new_method.
@@ -813,13 +812,17 @@
   }
 }
 
 // the constant pool cache should never contain old or obsolete methods
 bool ConstantPoolCache::check_no_old_or_obsolete_entries() {
+  ResourceMark rm;
   for (int i = 1; i < length(); i++) {
-    if (entry_at(i)->get_interesting_method_entry() != NULL &&
-        !entry_at(i)->check_no_old_or_obsolete_entries()) {
+    Method* m = entry_at(i)->get_interesting_method_entry();
+    if (m != NULL && !entry_at(i)->check_no_old_or_obsolete_entries()) {
+      log_trace(redefine, class, update, constantpool)
+        ("cpcache check found old method entry: class: %s, old: %d, obsolete: %d, method: %s",
+         constant_pool()->pool_holder()->external_name(), m->is_old(), m->is_obsolete(), m->external_name());
       return false;
     }
   }
   return true;
 }
diff a/src/hotspot/share/oops/klassVtable.cpp b/src/hotspot/share/oops/klassVtable.cpp
--- a/src/hotspot/share/oops/klassVtable.cpp
+++ b/src/hotspot/share/oops/klassVtable.cpp
@@ -959,10 +959,12 @@
 }
 
 // search the vtable for uses of either obsolete or EMCP methods
 void klassVtable::adjust_method_entries(bool * trace_name_printed) {
   int prn_enabled = 0;
+  ResourceMark rm;
+
   for (int index = 0; index < length(); index++) {
     Method* old_method = unchecked_method_at(index);
     if (old_method == NULL || !old_method->is_old()) {
       continue; // skip uninteresting entries
     }
@@ -976,31 +978,33 @@
     bool updated_default = false;
     if (old_method->is_default_method()) {
       updated_default = adjust_default_method(index, old_method, new_method);
     }
 
-    if (log_is_enabled(Info, redefine, class, update)) {
-      ResourceMark rm;
-      if (!(*trace_name_printed)) {
-        log_info(redefine, class, update)
-          ("adjust: klassname=%s for methods from name=%s",
-           _klass->external_name(), old_method->method_holder()->external_name());
-        *trace_name_printed = true;
-      }
-      log_debug(redefine, class, update, vtables)
-        ("vtable method update: %s(%s), updated default = %s",
-         new_method->name()->as_C_string(), new_method->signature()->as_C_string(), updated_default ? "true" : "false");
+    if (!(*trace_name_printed)) {
+      log_info(redefine, class, update)
+        ("adjust: klassname=%s for methods from name=%s",
+         _klass->external_name(), old_method->method_holder()->external_name());
+      *trace_name_printed = true;
     }
+    log_trace(redefine, class, update, vtables)
+      ("vtable method update: class: %s method: %s, updated default = %s",
+       _klass->external_name(), new_method->external_name(), updated_default ? "true" : "false");
   }
 }
 
 // a vtable should never contain old or obsolete methods
 bool klassVtable::check_no_old_or_obsolete_entries() {
+  ResourceMark rm;
+
   for (int i = 0; i < length(); i++) {
     Method* m = unchecked_method_at(i);
     if (m != NULL &&
         (NOT_PRODUCT(!m->is_valid() ||) m->is_old() || m->is_obsolete())) {
+      log_trace(redefine, class, update, vtables)
+        ("vtable check found old method entry: class: %s old: %d obsolete: %d, method: %s",
+         _klass->external_name(), m->is_old(), m->is_obsolete(), m->external_name());
       return false;
     }
   }
   return true;
 }
@@ -1280,40 +1284,43 @@
 }
 
 #if INCLUDE_JVMTI
 // search the itable for uses of either obsolete or EMCP methods
 void klassItable::adjust_method_entries(bool * trace_name_printed) {
-
+  ResourceMark rm;
   itableMethodEntry* ime = method_entry(0);
+
   for (int i = 0; i < _size_method_table; i++, ime++) {
     Method* old_method = ime->method();
     if (old_method == NULL || !old_method->is_old()) {
       continue; // skip uninteresting entries
     }
     assert(!old_method->is_deleted(), "itable methods may not be deleted");
     Method* new_method = old_method->get_new_method();
     ime->initialize(new_method);
 
-    if (log_is_enabled(Info, redefine, class, update)) {
-      ResourceMark rm;
-      if (!(*trace_name_printed)) {
-        log_info(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
-        *trace_name_printed = true;
-      }
-      log_trace(redefine, class, update, itables)
-        ("itable method update: %s(%s)", new_method->name()->as_C_string(), new_method->signature()->as_C_string());
+    if (!(*trace_name_printed)) {
+      log_info(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
+      *trace_name_printed = true;
     }
+    log_trace(redefine, class, update, itables)
+      ("itable method update: class: %s method: %s", _klass->external_name(), new_method->external_name());
   }
 }
 
 // an itable should never contain old or obsolete methods
 bool klassItable::check_no_old_or_obsolete_entries() {
+  ResourceMark rm;
   itableMethodEntry* ime = method_entry(0);
+
   for (int i = 0; i < _size_method_table; i++) {
     Method* m = ime->method();
     if (m != NULL &&
         (NOT_PRODUCT(!m->is_valid() ||) m->is_old() || m->is_obsolete())) {
+      log_trace(redefine, class, update, itables)
+        ("itable check found old method entry: class: %s old: %d obsolete: %d, method: %s",
+         _klass->external_name(), m->is_old(), m->is_obsolete(), m->external_name());
       return false;
     }
     ime++;
   }
   return true;
diff a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -3790,10 +3790,11 @@
                                               jobject methodType,
                                               jobject implMethodMember,
                                               jobject instantiatedMethodType,
                                               jclass lambdaProxyClass))
   JVMWrapper("JVM_RegisterLambdaProxyClassForArchiving");
+#if INCLUDE_CDS
   if (!DynamicDumpSharedSpaces) {
     return;
   }
 
   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
@@ -3826,11 +3827,11 @@
   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
 
   SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,
                                                  method_type, m, instantiated_method_type);
-
+#endif // INCLUDE_CDS
 JVM_END
 
 JVM_ENTRY(jclass, JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env,
                                                         jclass caller,
                                                         jstring invokedName,
@@ -3838,10 +3839,11 @@
                                                         jobject methodType,
                                                         jobject implMethodMember,
                                                         jobject instantiatedMethodType,
                                                         jboolean initialize))
   JVMWrapper("JVM_LookupLambdaProxyClassFromArchive");
+#if INCLUDE_CDS
   if (!DynamicArchive::is_mapped()) {
     return NULL;
   }
 
   if (invokedName == NULL || invokedType == NULL || methodType == NULL ||
@@ -3876,10 +3878,13 @@
   if (lambda_ik != NULL) {
     InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, initialize, THREAD);
     jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(env, loaded_lambda->java_mirror());
   }
   return jcls;
+#else
+  return NULL;
+#endif // INCLUDE_CDS
 JVM_END
 
 JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))
     JVMWrapper("JVM_IsCDSDumpingEnable");
     return DynamicDumpSharedSpaces;
diff a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -1198,22 +1198,23 @@
 // owned_monitor_count_ptr - pre-checked for NULL
 // owned_monitors_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetOwnedMonitorInfo(JavaThread* java_thread, jint* owned_monitor_count_ptr, jobject** owned_monitors_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
+  JavaThread* calling_thread = JavaThread::current();
 
   // growable array of jvmti monitors info on the C-heap
   GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =
       new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, true);
 
   // It is only safe to perform the direct operation on the current
   // thread. All other usage needs to use a direct handshake for safety.
-  if (java_thread == JavaThread::current()) {
-    err = get_owned_monitors(java_thread, owned_monitors_list);
+  if (java_thread == calling_thread) {
+    err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);
   } else {
     // get owned monitors info with handshake
-    GetOwnedMonitorInfoClosure op(this, owned_monitors_list);
+    GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);
     Handshake::execute_direct(&op, java_thread);
     err = op.result();
   }
   jint owned_monitor_count = owned_monitors_list->length();
   if (err == JVMTI_ERROR_NONE) {
@@ -1242,22 +1243,23 @@
 // monitor_info_count_ptr - pre-checked for NULL
 // monitor_info_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetOwnedMonitorStackDepthInfo(JavaThread* java_thread, jint* monitor_info_count_ptr, jvmtiMonitorStackDepthInfo** monitor_info_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
+  JavaThread* calling_thread = JavaThread::current();
 
   // growable array of jvmti monitors info on the C-heap
   GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =
          new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, true);
 
   // It is only safe to perform the direct operation on the current
   // thread. All other usage needs to use a direct handshake for safety.
-  if (java_thread == JavaThread::current()) {
-    err = get_owned_monitors(java_thread, owned_monitors_list);
+  if (java_thread == calling_thread) {
+    err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);
   } else {
     // get owned monitors info with handshake
-    GetOwnedMonitorInfoClosure op(this, owned_monitors_list);
+    GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);
     Handshake::execute_direct(&op, java_thread);
     err = op.result();
   }
 
   jint owned_monitor_count = owned_monitors_list->length();
@@ -1289,18 +1291,19 @@
 // java_thread - pre-checked
 // monitor_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetCurrentContendedMonitor(JavaThread* java_thread, jobject* monitor_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
+  JavaThread* calling_thread = JavaThread::current();
 
   // It is only safe to perform the direct operation on the current
   // thread. All other usage needs to use a direct handshake for safety.
-  if (java_thread == JavaThread::current()) {
-    err = get_current_contended_monitor(java_thread, monitor_ptr);
+  if (java_thread == calling_thread) {
+    err = get_current_contended_monitor(calling_thread, java_thread, monitor_ptr);
   } else {
     // get contended monitor information with handshake
-    GetCurrentContendedMonitorClosure op(this, monitor_ptr);
+    GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr);
     Handshake::execute_direct(&op, java_thread);
     err = op.result();
   }
   return err;
 } /* end GetCurrentContendedMonitor */
diff a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
--- a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
@@ -68,12 +68,13 @@
 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
 Method**  VM_RedefineClasses::_added_methods        = NULL;
 int       VM_RedefineClasses::_matching_methods_length = 0;
 int       VM_RedefineClasses::_deleted_methods_length  = 0;
 int       VM_RedefineClasses::_added_methods_length    = 0;
+
+// This flag is global as the constructor does not reset it:
 bool      VM_RedefineClasses::_has_redefined_Object = false;
-bool      VM_RedefineClasses::_has_null_class_loader = false;
 u8        VM_RedefineClasses::_id_counter = 0;
 
 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
                                        const jvmtiClassDefinition *class_defs,
                                        JvmtiClassLoadKind class_load_kind) {
@@ -81,12 +82,10 @@
   _class_defs = class_defs;
   _class_load_kind = class_load_kind;
   _any_class_has_resolved_methods = false;
   _res = JVMTI_ERROR_NONE;
   _the_class = NULL;
-  _has_redefined_Object = false;
-  _has_null_class_loader = false;
   _id = next_id();
 }
 
 static inline InstanceKlass* get_ik(jclass def) {
   oop mirror = JNIHandles::resolve_non_null(def);
@@ -3595,11 +3594,14 @@
   // This is a very busy routine. We don't want too much tracing
   // printed out.
   bool trace_name_printed = false;
 
   // If the class being redefined is java.lang.Object, we need to fix all
-  // array class vtables also
+  // array class vtables also. The _has_redefined_Object flag is global.
+  // Once the java.lang.Object has been redefined (by the current or one
+  // of the previous VM_RedefineClasses operations) we have to always
+  // adjust method entries for array classes.
   if (k->is_array_klass() && _has_redefined_Object) {
     k->vtable().adjust_method_entries(&trace_name_printed);
 
   } else if (k->is_instance_klass()) {
     HandleMark hm(_thread);
@@ -3613,26 +3615,10 @@
       if (methods->at(index)->method_data() != NULL) {
         methods->at(index)->method_data()->clean_weak_method_links();
       }
     }
 
-    // HotSpot specific optimization! HotSpot does not currently
-    // support delegation from the bootstrap class loader to a
-    // user-defined class loader. This means that if the bootstrap
-    // class loader is the initiating class loader, then it will also
-    // be the defining class loader. This also means that classes
-    // loaded by the bootstrap class loader cannot refer to classes
-    // loaded by a user-defined class loader. Note: a user-defined
-    // class loader can delegate to the bootstrap class loader.
-    //
-    // If the current class being redefined has a user-defined class
-    // loader as its defining class loader, then we can skip all
-    // classes loaded by the bootstrap class loader.
-    if (!_has_null_class_loader && ik->class_loader() == NULL) {
-      return;
-    }
-
     // Adjust all vtables, default methods and itables, to clean out old methods.
     ResourceMark rm(_thread);
     if (ik->vtable_length() > 0) {
       ik->vtable().adjust_method_entries(&trace_name_printed);
       ik->adjust_default_methods(&trace_name_printed);
@@ -3647,25 +3633,28 @@
     // other_cp's cache. If other_cp has a previous version, then we
     // have to repeat the process for each previous version. The
     // constant pool cache holds the Method*s for non-virtual
     // methods and for virtual, final methods.
     //
-    // Special case: if the current class being redefined, then new_cp
-    // has already been attached to the_class and old_cp has already
-    // been added as a previous version. The new_cp doesn't have any
-    // cached references to old methods so it doesn't need to be
-    // updated. We can simply start with the previous version(s) in
-    // that case.
+    // Special case: if the current class is being redefined by the current
+    // VM_RedefineClasses operation, then new_cp has already been attached
+    // to the_class and old_cp has already been added as a previous version.
+    // The new_cp doesn't have any cached references to old methods so it
+    // doesn't need to be updated and we could optimize by skipping it.
+    // However, the current class can be marked as being redefined by another
+    // VM_RedefineClasses operation which has already executed its doit_prologue
+    // and needs cpcache method entries adjusted. For simplicity, the cpcache
+    // update is done unconditionally. It should result in doing nothing for
+    // classes being redefined by the current VM_RedefineClasses operation.
+    // Method entries in the previous version(s) are adjusted as well.
     ConstantPoolCache* cp_cache;
 
-    if (!ik->is_being_redefined()) {
-      // this klass' constant pool cache may need adjustment
-      ConstantPool* other_cp = ik->constants();
-      cp_cache = other_cp->cache();
-      if (cp_cache != NULL) {
-        cp_cache->adjust_method_entries(&trace_name_printed);
-      }
+    // this klass' constant pool cache may need adjustment
+    ConstantPool* other_cp = ik->constants();
+    cp_cache = other_cp->cache();
+    if (cp_cache != NULL) {
+      cp_cache->adjust_method_entries(&trace_name_printed);
     }
 
     // the previous versions' constant pool caches may need adjustment
     for (InstanceKlass* pv_node = ik->previous_versions();
          pv_node != NULL;
@@ -4106,13 +4095,12 @@
     _timer_rsc_phase1.start();
   }
 
   InstanceKlass* the_class = get_ik(the_jclass);
 
-  // Set some flags to control and optimize adjusting method entries
+  // Set a flag to control and optimize adjusting method entries
   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
-  _has_null_class_loader |= the_class->class_loader() == NULL;
 
   // Remove all breakpoints in methods of this class
   JvmtiBreakpoints& jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
 
diff a/src/hotspot/share/runtime/arguments.cpp b/src/hotspot/share/runtime/arguments.cpp
--- a/src/hotspot/share/runtime/arguments.cpp
+++ b/src/hotspot/share/runtime/arguments.cpp
@@ -1465,10 +1465,16 @@
     key = tmp_key;
 
     value = &prop[key_len + 1];
   }
 
+  if (is_internal_module_property(key) ||
+      strcmp(key, "jdk.module.main") == 0) {
+    MetaspaceShared::disable_optimized_module_handling();
+    log_info(cds)("Using optimized module handling disabled due to incompatible property: %s=%s", key, value);
+  }
+
   if (strcmp(key, "java.compiler") == 0) {
     process_java_compiler_argument(value);
     // Record value in Arguments, but let it get passed to Java.
   } else if (strcmp(key, "sun.java.launcher.is_altjvm") == 0) {
     // sun.java.launcher.is_altjvm property is
@@ -2518,10 +2524,12 @@
           "-Xbootclasspath is no longer a supported option.\n");
         return JNI_EINVAL;
     // -bootclasspath/a:
     } else if (match_option(option, "-Xbootclasspath/a:", &tail)) {
       Arguments::append_sysclasspath(tail);
+      MetaspaceShared::disable_optimized_module_handling();
+      log_info(cds)("Using optimized module handling disabled due to bootclasspath was appended");
     // -bootclasspath/p:
     } else if (match_option(option, "-Xbootclasspath/p:", &tail)) {
         jio_fprintf(defaultStream::output_stream(),
           "-Xbootclasspath/p is no longer a supported option.\n");
         return JNI_EINVAL;
diff a/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java b/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
--- a/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
+++ b/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
@@ -444,11 +444,11 @@
     /**
      * Generate a class file for the proxy class.  This method drives the
      * class file generation process.
      */
     private byte[] generateClassFile() {
-        visit(V15, accessFlags, dotToSlash(className), null,
+        visit(V16, accessFlags, dotToSlash(className), null,
                 JLR_PROXY, typeNames(interfaces));
 
         /*
          * Add proxy methods for the hashCode, equals,
          * and toString methods of java.lang.Object.  This is done before
diff a/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java b/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java
--- a/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java
+++ b/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java
@@ -91,11 +91,11 @@
             Function<Class<?>, Z> resFunc, Consumer<? super C> builder) {
 
         IsolatedMethodBuilder isolatedMethodBuilder = new IsolatedMethodBuilder(className, lookup);
         isolatedMethodBuilder
                 .withSuperclass(Object.class)
-                .withMajorVersion(59)
+                .withMajorVersion(60)
                 .withMinorVersion(0)
                 .withFlags(Flag.ACC_PUBLIC)
                 .withMethod(methodName, type, M ->
                         M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)
                                 .withCode(builderFunc, builder));
diff a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
--- a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
+++ b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
@@ -747,11 +747,11 @@
             return 0;
         }
 
         long p = allocateMemory0(bytes);
         if (p == 0) {
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Unable to allocate " + bytes + " bytes");
         }
 
         return p;
     }
 
@@ -803,11 +803,11 @@
             return 0;
         }
 
         long p = (address == 0) ? allocateMemory0(bytes) : reallocateMemory0(address, bytes);
         if (p == 0) {
-            throw new OutOfMemoryError();
+            throw new OutOfMemoryError("Unable to allocate " + bytes + " bytes");
         }
 
         return p;
     }
 
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
@@ -220,11 +220,11 @@
             final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
         this.classFileBuffer = classFileBuffer;
         this.b = classFileBuffer;
         // Check the class' major_version. This field is after the magic and minor_version fields, which
         // use 4 and 2 bytes respectively.
-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V15) {
+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V16) {
             throw new IllegalArgumentException(
                     "Unsupported class file major version " + readShort(classFileOffset + 6));
         }
         // Create the constant pool arrays. The constant_pool_count field is after the magic,
         // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
@@ -309,10 +309,11 @@
     int V11 = 0 << 16 | 55;
     int V12 = 0 << 16 | 56;
     int V13 = 0 << 16 | 57;
     int V14 = 0 << 16 | 58;
     int V15 = 0 << 16 | 59;
+    int V16 = 0 << 16 | 60;
 
     /**
       * Version flag indicating that the class is using 'preview' features.
       *
       * <p>{@code version & V_PREVIEW == V_PREVIEW} tests if a version is flagged with {@code
diff a/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java b/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java
@@ -373,11 +373,11 @@
                 }
             }
         }
 
         // check for self closing tags, such as <a id="name"/>
-        if (tree.isSelfClosing()) {
+        if (tree.isSelfClosing() && !isSelfClosingAllowed(t)) {
             env.messages.error(HTML, tree, "dc.tag.self.closing", treeName);
         }
 
         try {
             TagStackItem parent = tagStack.peek();
@@ -413,10 +413,17 @@
             if (t == null || t.endKind == HtmlTag.EndKind.NONE)
                 tagStack.pop();
         }
     }
 
+    // so-called "self-closing" tags are only permitted in HTML 5, for void elements
+    // https://html.spec.whatwg.org/multipage/syntax.html#start-tags
+    private boolean isSelfClosingAllowed(HtmlTag tag) {
+        return env.htmlVersion == HtmlVersion.HTML5
+                && tag.endKind == HtmlTag.EndKind.NONE;
+    }
+
     private void checkStructure(StartElementTree tree, HtmlTag t) {
         Name treeName = tree.getName();
         TagStackItem top = tagStack.peek();
         switch (t.blockType) {
             case BLOCK:
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java
@@ -98,13 +98,18 @@
      * text blocks in preview
      */
     JDK14("14"),
 
     /**
-      * 15, tbd
+      * 15, text blocks
       */
-    JDK15("15");
+    JDK15("15"),
+
+    /**
+      * 16, tbd
+      */
+    JDK16("16");
 
     private static final Context.Key<Source> sourceKey = new Context.Key<>();
 
     public static Source instance(Context context) {
         Source instance = context.get(sourceKey);
@@ -151,23 +156,26 @@
     public boolean isSupported() {
         return this.compareTo(MIN) >= 0;
     }
 
     public Target requiredTarget() {
-        if (this.compareTo(JDK15) >= 0) return Target.JDK1_15;
-        if (this.compareTo(JDK14) >= 0) return Target.JDK1_14;
-        if (this.compareTo(JDK13) >= 0) return Target.JDK1_13;
-        if (this.compareTo(JDK12) >= 0) return Target.JDK1_12;
-        if (this.compareTo(JDK11) >= 0) return Target.JDK1_11;
-        if (this.compareTo(JDK10) >= 0) return Target.JDK1_10;
-        if (this.compareTo(JDK9) >= 0) return Target.JDK1_9;
-        if (this.compareTo(JDK8) >= 0) return Target.JDK1_8;
-        if (this.compareTo(JDK7) >= 0) return Target.JDK1_7;
-        if (this.compareTo(JDK6) >= 0) return Target.JDK1_6;
-        if (this.compareTo(JDK5) >= 0) return Target.JDK1_5;
-        if (this.compareTo(JDK1_4) >= 0) return Target.JDK1_4;
-        return Target.JDK1_1;
+        return switch(this) {
+        case JDK16  -> Target.JDK1_16;
+        case JDK15  -> Target.JDK1_15;
+        case JDK14  -> Target.JDK1_14;
+        case JDK13  -> Target.JDK1_13;
+        case JDK12  -> Target.JDK1_12;
+        case JDK11  -> Target.JDK1_11;
+        case JDK10  -> Target.JDK1_10;
+        case JDK9   -> Target.JDK1_9;
+        case JDK8   -> Target.JDK1_8;
+        case JDK7   -> Target.JDK1_7;
+        case JDK6   -> Target.JDK1_6;
+        case JDK5   -> Target.JDK1_5;
+        case JDK1_4 -> Target.JDK1_4;
+        default     -> Target.JDK1_1;
+        };
     }
 
     /**
      * Models a feature of the Java programming language. Each feature can be associated with a
      * minimum source level, a maximum source level and a diagnostic fragment describing the feature,
@@ -204,15 +212,15 @@
         IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES(JDK1_2, JDK8),
         SWITCH_MULTIPLE_CASE_LABELS(JDK14, Fragments.FeatureMultipleCaseLabels, DiagKind.PLURAL),
         SWITCH_RULE(JDK14, Fragments.FeatureSwitchRules, DiagKind.PLURAL),
         SWITCH_EXPRESSION(JDK14, Fragments.FeatureSwitchExpressions, DiagKind.PLURAL),
         TEXT_BLOCKS(JDK15, Fragments.FeatureTextBlocks, DiagKind.PLURAL),
-        PATTERN_MATCHING_IN_INSTANCEOF(JDK15, Fragments.FeaturePatternMatchingInstanceof, DiagKind.NORMAL),
-        REIFIABLE_TYPES_INSTANCEOF(JDK15, Fragments.FeatureReifiableTypesInstanceof, DiagKind.PLURAL),
-        RECORDS(JDK15, Fragments.FeatureRecords, DiagKind.PLURAL),
-        INLINE_TYPES(JDK15, Fragments.FeatureInlineType, DiagKind.NORMAL),
-        SEALED_CLASSES(JDK15, Fragments.FeatureSealedClasses, DiagKind.PLURAL),
+        PATTERN_MATCHING_IN_INSTANCEOF(JDK16, Fragments.FeaturePatternMatchingInstanceof, DiagKind.NORMAL),
+        REIFIABLE_TYPES_INSTANCEOF(JDK16, Fragments.FeatureReifiableTypesInstanceof, DiagKind.PLURAL),
+        RECORDS(JDK16, Fragments.FeatureRecords, DiagKind.PLURAL),
+        INLINE_TYPES(JDK16, Fragments.FeatureInlineType, DiagKind.NORMAL),
+        SEALED_CLASSES(JDK16, Fragments.FeatureSealedClasses, DiagKind.PLURAL),
         ;
 
         enum DiagKind {
             NORMAL,
             PLURAL;
@@ -271,39 +279,25 @@
                     Errors.FeatureNotSupportedInSourcePlural(optFragment, sourceName, minLevel.name);
         }
     }
 
     public static SourceVersion toSourceVersion(Source source) {
-        switch(source) {
-        case JDK1_2:
-            return RELEASE_2;
-        case JDK1_3:
-            return RELEASE_3;
-        case JDK1_4:
-            return RELEASE_4;
-        case JDK5:
-            return RELEASE_5;
-        case JDK6:
-            return RELEASE_6;
-        case JDK7:
-            return RELEASE_7;
-        case JDK8:
-            return RELEASE_8;
-        case JDK9:
-            return RELEASE_9;
-        case JDK10:
-            return RELEASE_10;
-        case JDK11:
-            return RELEASE_11;
-        case JDK12:
-            return RELEASE_12;
-        case JDK13:
-            return RELEASE_13;
-        case JDK14:
-            return RELEASE_14;
-        case JDK15:
-            return RELEASE_15;
-        default:
-            return null;
-        }
+        return switch(source) {
+        case JDK1_2 -> RELEASE_2;
+        case JDK1_3 -> RELEASE_3;
+        case JDK1_4 -> RELEASE_4;
+        case JDK5   -> RELEASE_5;
+        case JDK6   -> RELEASE_6;
+        case JDK7   -> RELEASE_7;
+        case JDK8   -> RELEASE_8;
+        case JDK9   -> RELEASE_9;
+        case JDK10  -> RELEASE_10;
+        case JDK11  -> RELEASE_11;
+        case JDK12  -> RELEASE_12;
+        case JDK13  -> RELEASE_13;
+        case JDK14  -> RELEASE_14;
+        case JDK15  -> RELEASE_15;
+        case JDK16  -> RELEASE_16;
+        default     -> null;
+        };
     }
 }
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -114,11 +114,12 @@
         V54(54, 0),   // JDK 10
         V55(55, 0),   // JDK 11: constant dynamic, nest mates
         V56(56, 0),   // JDK 12
         V57(57, 0),   // JDK 13
         V58(58, 0),   // JDK 14
-        V59(59, 0);   // JDK 15
+        V59(59, 0),   // JDK 15
+        V60(60, 0);   // JDK 16
         Version(int major, int minor) {
             this.major = major;
             this.minor = minor;
         }
         public final int major, minor;
diff a/test/hotspot/jtreg/ProblemList.txt b/test/hotspot/jtreg/ProblemList.txt
--- a/test/hotspot/jtreg/ProblemList.txt
+++ b/test/hotspot/jtreg/ProblemList.txt
@@ -145,12 +145,10 @@
 compiler/aot/fingerprint/SelfChangedCDS.java 8226295 generic-all
 compiler/aot/fingerprint/SuperChanged.java 8226295 generic-all
 
 compiler/c2/Test8004741.java 8235801 generic-all
 
-compiler/jsr292/CreatesInterfaceDotEqualsCallInfo.java 8242923 generic-all
-
 #############################################################################
 
 # :hotspot_gc
 
 gc/epsilon/TestMemoryMXBeans.java 8206434 generic-all
diff a/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java b/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java
@@ -66,16 +66,17 @@
         String forceRelocation = "-XX:ArchiveRelocationMode=1";
         String dumpRelocArg = dump_reloc ? forceRelocation : "-showversion";
         String runRelocArg  = run_reloc  ? forceRelocation : "-showversion";
         String logArg = "-Xlog:cds=debug,cds+reloc=debug";
         String unlockArg = "-XX:+UnlockDiagnosticVMOptions";
+        String nmtArg = "-XX:NativeMemoryTracking=detail";
 
         OutputAnalyzer out = TestCommon.dump(appJar,
                                              TestCommon.list(mainClass,
                                                              "HelloInlineClassApp",
                                                              "HelloInlineClassApp$Point"),
-                                             unlockArg, dumpRelocArg, logArg);
+                                             unlockArg, dumpRelocArg, logArg, nmtArg);
         if (dump_reloc) {
             out.shouldContain("ArchiveRelocationMode == 1: always allocate class space at an alternative address");
             out.shouldContain("Relocating archive from");
         }
 
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod
@@ -91,11 +91,11 @@
 //
 
 class WithFieldNoAccessTest$V {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [58] { // Constant Pool
     ; // first element is empty
     class #33; // #1     at 0x0A
     Field #1 #34; // #2     at 0x0D
     Field #1 #35; // #3     at 0x12
@@ -351,11 +351,11 @@
 
 
 class WithFieldNoAccessTest {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [91] { // Constant Pool
     ; // first element is empty
     Method #23 #39; // #1     at 0x0A
     long 0x0000000000000005;; // #2     at 0x0F
     Method #24 #40; // #4     at 0x18
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod
@@ -46,11 +46,11 @@
 // Test that class modifiers cannot have both ACC_VALUE and ACC_ABSTRACT set.
 //
 class ValueAbstract {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [28] { // Constant Pool
     ; // first element is empty
     Method #7 #23; // #1     at 0x0A
     Field #3 #24; // #2     at 0x0F
     class #9; // #3     at 0x14
@@ -202,11 +202,11 @@
 // Test that class modifiers cannot have both ACC_VALUE and ACC_ENUM set.
 //
 class ValueEnum {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [28] { // Constant Pool
     ; // first element is empty
     Method #7 #23; // #1     at 0x0A
     Field #3 #24; // #2     at 0x0F
     class #9; // #3     at 0x14
@@ -358,11 +358,11 @@
 // Test that inline type fields must be final.
 //
 class ValueFieldNotFinal {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [28] { // Constant Pool
     ; // first element is empty
     Method #7 #23; // #1     at 0x0A
     Field #3 #24; // #2     at 0x0F
     class #9; // #3     at 0x14
@@ -514,11 +514,11 @@
 // Test that class modifiers cannot have both ACC_VALUE and ACC_INTERFACE set.
 //
 class ValueInterface {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [27] { // Constant Pool
     ; // first element is empty
     Method #7 #21; // #1     at 0x0A
     Field #3 #22; // #2     at 0x0F
     class #23; // #3     at 0x14
@@ -621,11 +621,11 @@
 // }
 
 class ValueMethodSynch {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [46] { // Constant Pool
     ; // first element is empty
     class #23; // #1     at 0x0A
     Field #1 #24; // #2     at 0x0D
     InvokeDynamic 0s #27; // #3     at 0x12
@@ -876,11 +876,11 @@
 // }
 
 class Circ {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [61] { // Constant Pool
     ; // first element is empty
     class #34; // #1     at 0x0A
     Field #1 #35; // #2     at 0x0D
     class #36; // #3     at 0x12
@@ -1155,11 +1155,11 @@
 } // end class Circ
 
 class Circ2 {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [60] { // Constant Pool
     ; // first element is empty
     class #33; // #1     at 0x0A
     Field #1 #34; // #2     at 0x0D
     class #35; // #3     at 0x12
@@ -1469,11 +1469,11 @@
 // }
 
 class CircStaticA {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [61] { // Constant Pool
     ; // first element is empty
     class #34; // #1     at 0x0A
     Field #1 #35; // #2     at 0x0D
     InvokeDynamic 0s #38; // #3     at 0x12
@@ -1747,11 +1747,11 @@
 } // end class CircStaticA
 
 class CircStaticB {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [61] { // Constant Pool
     ; // first element is empty
     class #34; // #1     at 0x0A
     Field #1 #35; // #2     at 0x0D
     InvokeDynamic 0s #38; // #3     at 0x12
@@ -2034,11 +2034,11 @@
 //}
 
 class ValueCloneable {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [46] { // Constant Pool
     ; // first element is empty
     class #22; // #1     at 0x0A
     Field #1 #23; // #2     at 0x0D
     InvokeDynamic 0s #26; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod
@@ -1,9 +1,9 @@
 class IdentityType {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [] { // Constant Pool
     ; // first element is empty
     Method #2 #3; // #1
     class #4; // #2
     NameAndType #5 #6; // #3
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod
@@ -37,11 +37,11 @@
 
 // Inline class with a super class that is not abstract.
 class SuperNotAbstract {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperNotAbstract"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -297,11 +297,11 @@
 
 // Inline class with a super class that has instance fields.
 class SuperHasNonStaticFields {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperHasNonStaticFields"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -557,11 +557,11 @@
 
 // Inline class with a super class whose super class has a syncronized instance method.
 class SuperHasSynchMethod {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperHasSynchMethod"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -816,11 +816,11 @@
 
 // Inline class with a super class containing a constructor that has arguments.
 class SuperCtorHasArgs {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperCtorHasArgs"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -1077,11 +1077,11 @@
 // Inline class with a super class containing a constructor that has a non-empty
 // method body.
 class SuperCtorIsNotEmpty {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperCtorIsNotEmpty"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -1337,11 +1337,11 @@
 // Inline class that implements java.lang.IdentityObject.  Loading this
 // class should throw an ICCE.
 class InlineImplementsIdentityObject {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [53] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "InlineImplementsIdentityObject"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x28
@@ -1601,11 +1601,11 @@
 // Inline class with a super class that implements java.lang.IdentityObject.
 // Loading this class should throw an ICCE.
 class SuperImplementsIdentityObject {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperImplementsIdentityObject"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
@@ -1861,11 +1861,11 @@
 // Inline class with a super class that implements an interface that extends other
 // interfaces that eventually extend java.lang.IdentityObject
 class SuperIntfImplementsIdentityObject {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [51] { // Constant Pool
     ; // first element is empty
     class #2; // #1     at 0x0A
     Utf8 "SuperIntfImplementsIdentityObject"; // #2     at 0x0D
     Field #1 #4; // #3     at 0x20
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod
@@ -66,11 +66,11 @@
 // }
 
 class NoNullVT {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [63] { // Constant Pool
     ; // first element is empty
     class #36; // #1     at 0x0A
     Field #1 #37; // #2     at 0x0D
     Field #1 #38; // #3     at 0x12
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod
@@ -58,11 +58,11 @@
 // the constant pool, a VerifyError exception should get thrown.
 //
 class defValBadCP {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [27] { // Constant Pool
     ; // first element is empty
     Method #7 #21; // #1     at 0x0A
     Field #3 #22; // #2     at 0x0F
     class #23; // #3     at 0x14
@@ -260,11 +260,11 @@
 // entry instead of a Class entry, a VerifyError exception should get thrown.
 //
 class defValWrongCPType {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [27] { // Constant Pool
     ; // first element is empty
     Method #7 #21; // #1     at 0x0A
     Field #3 #22; // #2     at 0x0F
     class #23; // #3     at 0x14
@@ -361,11 +361,11 @@
 // the constant pool, a VerifyError exception should get thrown.
 //
 class wthFldBadCP {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [20] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -479,11 +479,11 @@
 // the type (int) of the field being assigned to.
 //
 class wthFldBadFldVal {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [20] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -596,11 +596,11 @@
 // for the withfield opcode (0xCC at bytecode position 6) must be a reference.
 //
 class wthFldBadFldRef {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [20] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -815,11 +815,11 @@
 // entry instead of a Field entry, a VerifyError exception should get thrown.
 //
 class wthFldWrongCPType {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [20] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -934,11 +934,11 @@
 // and the inline type on the stack, in this case 'wthFldObject', be identical.
 //
 class wthFldObject {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [22] { // Constant Pool
     ; // first element is empty
     Method #4 #17; // #1     at 0x0A
     Field #3 #18; // #2     at 0x0F
     class #12; // #3     at 0x14
@@ -1056,11 +1056,11 @@
 // cannot be an inline type.
 //
 class monEnterVT {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [46] { // Constant Pool
     ; // first element is empty
     class #23; // #1     at 0x0A
     Field #1 #24; // #2     at 0x0D
     InvokeDynamic 0s #27; // #3     at 0x12
@@ -1284,11 +1284,11 @@
 // must be an inline type.
 //
 class defValueObj {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [46] { // Constant Pool
     ; // first element is empty
     class #23; // #1     at 0x0A
     Field #1 #24; // #2     at 0x0D
     InvokeDynamic 0s #27; // #3     at 0x12
@@ -1512,11 +1512,11 @@
 // opcode must be an inline type.
 //
 class withfieldObj {
   0xCAFEBABE;
   0; // minor version
-  59; // version
+  60; // version
   [23] { // Constant Pool
     ; // first element is empty
     Method #5 #19; // #1     at 0x0A
     Field #3 #20; // #2     at 0x0F
     class #13; // #3     at 0x14

diff a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -487,10 +487,11 @@
 758deedaae8406ae60147486107a54e9864aa7b0 jdk-11+13
 3595bd343b65f8c37818ebe6a4c343ddeb1a5f88 jdk-11+14
 a11c1cb542bbd1671d25b85efe7d09b983c48525 jdk-11+15
 02934b0d661b82b7fe1052a04998d2091352e08d jdk-11+16
 64e4b1686141e57a681936a8283983341484676e jdk-11+17
+d2aa5d494481a1039a092d70efa1f5c9826c5b77 lw1_0
 e1b3def126240d5433902f3cb0e91a4c27f6db50 jdk-11+18
 36ca515343e00b021dcfc902e986d26ec994a2e5 jdk-11+19
 95aad0c785e497f1bade3955c4e4a677b629fa9d jdk-12+0
 9816d7cc655e53ba081f938b656e31971b8f097a jdk-11+20
 14708e1acdc3974f4539027cbbcfa6d69f83cf51 jdk-11+21
@@ -509,10 +510,11 @@
 ef57958c7c511162da8d9a75f0b977f0f7ac464e jdk-12+7
 76072a077ee1d815152d45d1692c4b36c53c5c49 jdk-11+28
 492b366f8e5784cc4927c2c98f9b8a3f16c067eb jdk-12+8
 31b159f30fb281016c5f0c103552809aeda84063 jdk-12+9
 8f594f75e0547d4ca16649cb3501659e3155e81b jdk-12+10
+6132641c6ff61b7b8f3f10b9cd385aafadbd72ef lworld_stable
 f0f5d23449d31f1b3580c8a73313918cafeaefd7 jdk-12+11
 15094d12a632f452a2064318a4e416d0c7a9ce0c jdk-12+12
 511a9946f83e3e3c7b9dbe1840367063fb39b4e1 jdk-12+13
 8897e41b327c0a5601c6ba2bba5d07f15a3ffc91 jdk-12+14
 8897e41b327c0a5601c6ba2bba5d07f15a3ffc91 jdk-12+14
@@ -565,10 +567,14 @@
 22b3b7983adab54e318f75aeb94471f7a4429c1e jdk-14+0
 22b3b7983adab54e318f75aeb94471f7a4429c1e jdk-13+25
 2f4e214781a1d597ed36bf5a36f20928c6c82996 jdk-14+1
 0692b67f54621991ba7afbf23e55b788f3555e69 jdk-13+26
 43627549a488b7d0b4df8fad436e36233df89877 jdk-14+2
+6132641c6ff61b7b8f3f10b9cd385aafadbd72ef lworld_stable
+2b098533f1e52d7d541121409b745d9420886945 lworld_stable
+2b098533f1e52d7d541121409b745d9420886945 lworld_stable
+7c637fd25e7d6fccdab1098bedd48ed195a86cc7 lworld_stable
 b7f68ddec66f996ae3aad03291d129ca9f02482d jdk-13+27
 e64383344f144217c36196c3c8a2df8f588a2af3 jdk-14+3
 1e95931e7d8fa7e3899340a9c7cb28dbea50c10c jdk-13+28
 19d0b382f0869f72d4381b54fa129f1c74b6e766 jdk-14+4
 3081f39a3d30d63b112098386ac2bb027c2b7223 jdk-13+29
diff a/make/Docs.gmk b/make/Docs.gmk
--- a/make/Docs.gmk
+++ b/make/Docs.gmk
@@ -104,13 +104,14 @@
 
 # Which doclint checks to ignore
 JAVADOC_DISABLED_DOCLINT := accessibility html missing syntax reference
 
 # The initial set of options for javadoc
-JAVADOC_OPTIONS := -use -keywords -notimestamp \
+JAVADOC_OPTIONS := -XDignore.symbol.file=true -use -keywords -notimestamp \
     -serialwarn -encoding ISO-8859-1 -docencoding UTF-8 -breakiterator \
     -splitIndex --system none -javafx --expand-requires transitive \
+    -XDenableValueTypes \
     --override-methods=summary
 
 # The reference options must stay stable to allow for comparisons across the
 # development cycle.
 REFERENCE_OPTIONS := -XDignore.symbol.file=true -use -keywords -notimestamp \
diff a/src/hotspot/share/ci/ciEnv.cpp b/src/hotspot/share/ci/ciEnv.cpp
--- a/src/hotspot/share/ci/ciEnv.cpp
+++ b/src/hotspot/share/ci/ciEnv.cpp
@@ -31,10 +31,11 @@
 #include "ci/ciInstanceKlass.hpp"
 #include "ci/ciMethod.hpp"
 #include "ci/ciNullObject.hpp"
 #include "ci/ciReplay.hpp"
 #include "ci/ciUtilities.inline.hpp"
+#include "ci/ciValueKlass.hpp"
 #include "classfile/symbolTable.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "code/codeCache.hpp"
 #include "code/scopeDesc.hpp"
@@ -466,11 +467,13 @@
   // In either case, if we can find the element type in the system dictionary,
   // we must build an array type around it.  The CI requires array klasses
   // to be loaded if their element klasses are loaded, except when memory
   // is exhausted.
   if (Signature::is_array(sym) &&
-      (sym->char_at(1) == JVM_SIGNATURE_ARRAY || sym->char_at(1) == JVM_SIGNATURE_CLASS)) {
+      (sym->char_at(1) == JVM_SIGNATURE_ARRAY ||
+       sym->char_at(1) == JVM_SIGNATURE_CLASS ||
+       sym->char_at(1) == JVM_SIGNATURE_INLINE_TYPE )) {
     // We have an unloaded array.
     // Build it on the fly if the element class exists.
     SignatureStream ss(sym, false);
     ss.skip_array_prefix(1);
     // Get element ciKlass recursively.
@@ -479,11 +482,11 @@
                              cpool,
                              get_symbol(ss.as_symbol()),
                              require_local);
     if (elem_klass != NULL && elem_klass->is_loaded()) {
       // Now make an array for it
-      return ciObjArrayKlass::make_impl(elem_klass);
+      return ciArrayKlass::make(elem_klass);
     }
   }
 
   if (found_klass == NULL && !cpool.is_null() && cpool->has_preresolution()) {
     // Look inside the constant pool for pre-resolved class entries.
@@ -505,10 +508,25 @@
 
   if (require_local)  return NULL;
 
   // Not yet loaded into the VM, or not governed by loader constraints.
   // Make a CI representative for it.
+  int i = 0;
+  while (sym->char_at(i) == JVM_SIGNATURE_ARRAY) {
+    i++;
+  }
+  if (i > 0 && sym->char_at(i) == JVM_SIGNATURE_INLINE_TYPE) {
+    // An unloaded array class of value types is an ObjArrayKlass, an
+    // unloaded value type class is an InstanceKlass. For consistency,
+    // make the signature of the unloaded array of value type use L
+    // rather than Q.
+    char *new_name = CURRENT_THREAD_ENV->name_buffer(sym->utf8_length()+1);
+    strncpy(new_name, (char*)sym->base(), sym->utf8_length());
+    new_name[i] = JVM_SIGNATURE_CLASS;
+    new_name[sym->utf8_length()] = '\0';
+    return get_unloaded_klass(accessing_klass, ciSymbol::make(new_name));
+  }
   return get_unloaded_klass(accessing_klass, name);
 }
 
 // ------------------------------------------------------------------
 // ciEnv::get_klass_by_name
@@ -535,11 +553,11 @@
 
   if (cpool->tag_at(index).is_symbol()) {
     klass_name = cpool->symbol_at(index);
   } else {
     // Check if it's resolved if it's not a symbol constant pool entry.
-    klass =  ConstantPool::klass_at_if_loaded(cpool, index);
+    klass = ConstantPool::klass_at_if_loaded(cpool, index);
     // Try to look it up by name.
     if (klass == NULL) {
       klass_name = cpool->klass_name_at(index);
     }
   }
@@ -587,10 +605,18 @@
                                    bool& is_accessible,
                                    ciInstanceKlass* accessor) {
   GUARDED_VM_ENTRY(return get_klass_by_index_impl(cpool, index, is_accessible, accessor);)
 }
 
+// ------------------------------------------------------------------
+// ciEnv::is_klass_never_null
+//
+// Get information about nullability from the constant pool.
+bool ciEnv::is_klass_never_null(const constantPoolHandle& cpool, int index) {
+  GUARDED_VM_ENTRY(return cpool->klass_name_at(index)->is_Q_signature();)
+}
+
 // ------------------------------------------------------------------
 // ciEnv::get_constant_by_index_impl
 //
 // Implementation of get_constant_by_index().
 ciConstant ciEnv::get_constant_by_index_impl(const constantPoolHandle& cpool,
diff a/src/hotspot/share/ci/ciEnv.hpp b/src/hotspot/share/ci/ciEnv.hpp
--- a/src/hotspot/share/ci/ciEnv.hpp
+++ b/src/hotspot/share/ci/ciEnv.hpp
@@ -132,10 +132,12 @@
   ciField*   get_field_by_index(ciInstanceKlass* loading_klass,
                                 int field_index);
   ciMethod*  get_method_by_index(const constantPoolHandle& cpool,
                                  int method_index, Bytecodes::Code bc,
                                  ciInstanceKlass* loading_klass);
+  bool       is_klass_never_null(const constantPoolHandle& cpool,
+                                 int klass_index);
 
   // Implementation methods for loading and constant pool access.
   ciKlass* get_klass_by_name_impl(ciKlass* accessing_klass,
                                   const constantPoolHandle& cpool,
                                   ciSymbol* klass_name,
@@ -196,10 +198,14 @@
 
   ciInstance* get_instance(oop o) {
     if (o == NULL) return NULL;
     return get_object(o)->as_instance();
   }
+  ciValueArrayKlass* get_value_array_klass(Klass* o) {
+    if (o == NULL) return NULL;
+    return get_metadata(o)->as_value_array_klass();
+  }
   ciObjArrayKlass* get_obj_array_klass(Klass* o) {
     if (o == NULL) return NULL;
     return get_metadata(o)->as_obj_array_klass();
   }
   ciTypeArrayKlass* get_type_array_klass(Klass* o) {
@@ -467,8 +473,12 @@
   void dump_replay_data(int compile_id);
   void dump_inline_data(int compile_id);
   void dump_replay_data(outputStream* out);
   void dump_replay_data_unsafe(outputStream* out);
   void dump_compile_data(outputStream* out);
+
+  ciWrapper* make_never_null_wrapper(ciType* type) {
+    return _factory->make_never_null_wrapper(type);
+  }
 };
 
 #endif // SHARE_CI_CIENV_HPP
diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -19,10 +19,11 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  *
  */
+
 #include "precompiled.hpp"
 #include "jvm.h"
 #include "aot/aotLoader.hpp"
 #include "classfile/classFileParser.hpp"
 #include "classfile/classFileStream.hpp"
@@ -56,10 +57,11 @@
 #include "oops/metadata.hpp"
 #include "oops/method.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/recordComponent.hpp"
 #include "oops/symbol.hpp"
+#include "oops/valueKlass.inline.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/jvmtiThreadState.hpp"
 #include "runtime/arguments.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/handles.inline.hpp"
@@ -79,10 +81,11 @@
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/growableArray.hpp"
 #include "utilities/macros.hpp"
 #include "utilities/ostream.hpp"
 #include "utilities/resourceHash.hpp"
+#include "utilities/stringUtils.hpp"
 #include "utilities/utf8.hpp"
 
 #if INCLUDE_CDS
 #include "classfile/systemDictionaryShared.hpp"
 #endif
@@ -132,10 +135,12 @@
 
 #define JAVA_15_VERSION                   59
 
 #define JAVA_16_VERSION                   60
 
+#define CONSTANT_CLASS_DESCRIPTORS        60
+
 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
   assert((bad_constant == JVM_CONSTANT_Module ||
           bad_constant == JVM_CONSTANT_Package) && _major_version >= JAVA_9_VERSION,
          "Unexpected bad constant pool entry");
   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
@@ -171,11 +176,11 @@
     // Each of the following case guarantees one more byte in the stream
     // for the following tag or the access_flags following constant pool,
     // so we don't need bounds-check for reading tag.
     const u1 tag = cfs->get_u1_fast();
     switch (tag) {
-      case JVM_CONSTANT_Class : {
+      case JVM_CONSTANT_Class: {
         cfs->guarantee_more(3, CHECK);  // name_index, tag/access_flags
         const u2 name_index = cfs->get_u2_fast();
         cp->klass_index_at_put(index, name_index);
         break;
       }
@@ -501,11 +506,18 @@
       case JVM_CONSTANT_ClassIndex: {
         const int class_index = cp->klass_index_at(index);
         check_property(valid_symbol_at(class_index),
           "Invalid constant pool index %u in class file %s",
           class_index, CHECK);
-        cp->unresolved_klass_at_put(index, class_index, num_klasses++);
+
+        Symbol* const name = cp->symbol_at(class_index);
+        const unsigned int name_len = name->utf8_length();
+        if (name->is_Q_signature()) {
+          cp->unresolved_qdescriptor_at_put(index, class_index, num_klasses++);
+        } else {
+          cp->unresolved_klass_at_put(index, class_index, num_klasses++);
+        }
         break;
       }
       case JVM_CONSTANT_StringIndex: {
         const int string_index = cp->string_index_at(index);
         check_property(valid_symbol_at(string_index),
@@ -755,18 +767,29 @@
             const int name_and_type_ref_index =
               cp->name_and_type_ref_index_at(ref_index);
             const int name_ref_index =
               cp->name_ref_index_at(name_and_type_ref_index);
             const Symbol* const name = cp->symbol_at(name_ref_index);
-            if (ref_kind == JVM_REF_newInvokeSpecial) {
-              if (name != vmSymbols::object_initializer_name()) {
+            if (name != vmSymbols::object_initializer_name()) {
+              if (ref_kind == JVM_REF_newInvokeSpecial) {
                 classfile_parse_error(
                   "Bad constructor name at constant pool index %u in class file %s",
                     name_ref_index, CHECK);
               }
             } else {
-              if (name == vmSymbols::object_initializer_name()) {
+              // The allowed invocation mode of <init> depends on its signature.
+              // This test corresponds to verify_invoke_instructions in the verifier.
+              const int signature_ref_index =
+                cp->signature_ref_index_at(name_and_type_ref_index);
+              const Symbol* const signature = cp->symbol_at(signature_ref_index);
+              if (signature->is_void_method_signature()
+                  && ref_kind == JVM_REF_newInvokeSpecial) {
+                // OK, could be a constructor call
+              } else if (!signature->is_void_method_signature()
+                         && ref_kind == JVM_REF_invokeStatic) {
+                // also OK, could be a static factory call
+              } else {
                 classfile_parse_error(
                   "Bad method name at constant pool index %u in class file %s",
                   name_ref_index, CHECK);
               }
             }
@@ -921,26 +944,33 @@
 
   return true;
 }
 
 // Side-effects: populates the _local_interfaces field
-void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,
-                                       const int itfs_len,
-                                       ConstantPool* const cp,
+void ClassFileParser::parse_interfaces(const ClassFileStream* stream,
+                                       int itfs_len,
+                                       ConstantPool* cp,
+                                       bool is_inline_type,
                                        bool* const has_nonstatic_concrete_methods,
+                                       // FIXME: lots of these functions
+                                       // declare their parameters as const,
+                                       // which adds only noise to the code.
+                                       // Remove the spurious const modifiers.
+                                       // Many are of the form "const int x"
+                                       // or "T* const x".
+                                       bool* const is_declared_atomic,
                                        TRAPS) {
   assert(stream != NULL, "invariant");
   assert(cp != NULL, "invariant");
   assert(has_nonstatic_concrete_methods != NULL, "invariant");
 
   if (itfs_len == 0) {
-    _local_interfaces = Universe::the_empty_instance_klass_array();
+    _temp_local_interfaces = new GrowableArray<InstanceKlass*>(0);
   } else {
     assert(itfs_len > 0, "only called for len>0");
-    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, NULL, CHECK);
-
-    int index;
+    _temp_local_interfaces = new GrowableArray<InstanceKlass*>(itfs_len);
+    int index = 0;
     for (index = 0; index < itfs_len; index++) {
       const u2 interface_index = stream->get_u2(CHECK);
       Klass* interf;
       check_property(
         valid_klass_reference_at(interface_index),
@@ -954,11 +984,11 @@
         // Don't need to check legal name because it's checked when parsing constant pool.
         // But need to make sure it's not an array type.
         guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,
                            "Bad interface name in class file %s", CHECK);
 
-        // Call resolve_super so classcircularity is checked
+        // Call resolve_super so class circularity is checked
         interf = SystemDictionary::resolve_super_or_fail(
                                                   _class_name,
                                                   unresolved_klass,
                                                   Handle(THREAD, _loader_data->class_loader()),
                                                   _protection_domain,
@@ -972,14 +1002,33 @@
                           _class_name->as_klass_external_name(),
                           interf->external_name(),
                           interf->class_in_module_of_loader()));
       }
 
-      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {
+      InstanceKlass* ik = InstanceKlass::cast(interf);
+      if (is_inline_type && ik->invalid_inline_super()) {
+        ResourceMark rm(THREAD);
+        Exceptions::fthrow(
+          THREAD_AND_LOCATION,
+          vmSymbols::java_lang_IncompatibleClassChangeError(),
+          "Inline type %s attempts to implement interface java.lang.IdentityObject",
+          _class_name->as_klass_external_name());
+        return;
+      }
+      if (ik->invalid_inline_super()) {
+        set_invalid_inline_super();
+      }
+      if (ik->has_nonstatic_concrete_methods()) {
         *has_nonstatic_concrete_methods = true;
       }
-      _local_interfaces->at_put(index, InstanceKlass::cast(interf));
+      if (ik->is_declared_atomic()) {
+        *is_declared_atomic = true;
+      }
+      if (ik->name() == vmSymbols::java_lang_IdentityObject()) {
+        _implements_identityObject = true;
+      }
+      _temp_local_interfaces->append(ik);
     }
 
     if (!_need_verify || itfs_len <= 1) {
       return;
     }
@@ -993,11 +1042,11 @@
     bool dup = false;
     const Symbol* name = NULL;
     {
       debug_only(NoSafepointVerifier nsv;)
       for (index = 0; index < itfs_len; index++) {
-        const InstanceKlass* const k = _local_interfaces->at(index);
+        const InstanceKlass* const k = _temp_local_interfaces->at(index);
         name = k->name();
         // If no duplicates, add (name, NULL) in hashtable interface_names.
         if (!put_after_lookup(name, NULL, interface_names)) {
           dup = true;
           break;
@@ -1469,15 +1518,17 @@
   STATIC_OOP,           // Oops
   STATIC_BYTE,          // Boolean, Byte, char
   STATIC_SHORT,         // shorts
   STATIC_WORD,          // ints
   STATIC_DOUBLE,        // aligned long or double
+  STATIC_INLINE,        // inline type field
   NONSTATIC_OOP,
   NONSTATIC_BYTE,
   NONSTATIC_SHORT,
   NONSTATIC_WORD,
   NONSTATIC_DOUBLE,
+  NONSTATIC_INLINE,
   MAX_FIELD_ALLOCATION_TYPE,
   BAD_ALLOCATION_TYPE = -1
 };
 
 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
@@ -1493,16 +1544,17 @@
   NONSTATIC_SHORT,     // T_SHORT       =  9,
   NONSTATIC_WORD,      // T_INT         = 10,
   NONSTATIC_DOUBLE,    // T_LONG        = 11,
   NONSTATIC_OOP,       // T_OBJECT      = 12,
   NONSTATIC_OOP,       // T_ARRAY       = 13,
-  BAD_ALLOCATION_TYPE, // T_VOID        = 14,
-  BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,
-  BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,
-  BAD_ALLOCATION_TYPE, // T_METADATA    = 17,
-  BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,
-  BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,
+  NONSTATIC_OOP,       // T_VALUETYPE   = 14,
+  BAD_ALLOCATION_TYPE, // T_VOID        = 15,
+  BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
+  BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
+  BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
+  BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
+  BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,
   BAD_ALLOCATION_TYPE, // 0
   BAD_ALLOCATION_TYPE, // 1
   BAD_ALLOCATION_TYPE, // 2
   BAD_ALLOCATION_TYPE, // 3
   STATIC_BYTE ,        // T_BOOLEAN     =  4,
@@ -1513,22 +1565,26 @@
   STATIC_SHORT,        // T_SHORT       =  9,
   STATIC_WORD,         // T_INT         = 10,
   STATIC_DOUBLE,       // T_LONG        = 11,
   STATIC_OOP,          // T_OBJECT      = 12,
   STATIC_OOP,          // T_ARRAY       = 13,
-  BAD_ALLOCATION_TYPE, // T_VOID        = 14,
-  BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,
-  BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,
-  BAD_ALLOCATION_TYPE, // T_METADATA    = 17,
-  BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,
-  BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,
+  STATIC_OOP,          // T_VALUETYPE   = 14,
+  BAD_ALLOCATION_TYPE, // T_VOID        = 15,
+  BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
+  BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
+  BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
+  BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
+  BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20
 };
 
-static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {
+static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_inline_type) {
   assert(type >= T_BOOLEAN && type < T_VOID, "only allowable values");
   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
   assert(result != BAD_ALLOCATION_TYPE, "bad type");
+  if (is_inline_type) {
+    result = is_static ? STATIC_INLINE : NONSTATIC_INLINE;
+  }
   return result;
 }
 
 class ClassFileParser::FieldAllocationCount : public ResourceObj {
  public:
@@ -1538,12 +1594,12 @@
     for (int i = 0; i < MAX_FIELD_ALLOCATION_TYPE; i++) {
       count[i] = 0;
     }
   }
 
-  FieldAllocationType update(bool is_static, BasicType type) {
-    FieldAllocationType atype = basic_type_to_atype(is_static, type);
+  FieldAllocationType update(bool is_static, BasicType type, bool is_inline_type) {
+    FieldAllocationType atype = basic_type_to_atype(is_static, type, is_inline_type);
     if (atype != BAD_ALLOCATION_TYPE) {
       // Make sure there is no overflow with injected fields.
       assert(count[atype] < 0xFFFF, "More than 65535 fields");
       count[atype]++;
     }
@@ -1553,10 +1609,11 @@
 
 // Side-effects: populates the _fields, _fields_annotations,
 // _fields_type_annotations fields
 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
                                    bool is_interface,
+                                   bool is_inline_type,
                                    FieldAllocationCount* const fac,
                                    ConstantPool* cp,
                                    const int cp_size,
                                    u2* const java_fields_count_ptr,
                                    TRAPS) {
@@ -1575,11 +1632,15 @@
   *java_fields_count_ptr = length;
 
   int num_injected = 0;
   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
                                                                   &num_injected);
-  const int total_fields = length + num_injected;
+
+  // two more slots are required for inline classes:
+  // one for the static field with a reference to the pre-allocated default value
+  // one for the field the JVM injects when detecting an empty inline class
+  const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);
 
   // The field array starts with tuples of shorts
   // [access, name index, sig index, initial value index, byte offset].
   // A generic signature slot only exists for field with generic
   // signature attribute. And the access flag is set with
@@ -1605,17 +1666,20 @@
                                               total_fields * (FieldInfo::field_slots + 1));
 
   // The generic signature slots start after all other fields' data.
   int generic_signature_slot = total_fields * FieldInfo::field_slots;
   int num_generic_signature = 0;
+  int instance_fields_count = 0;
   for (int n = 0; n < length; n++) {
     // access_flags, name_index, descriptor_index, attributes_count
     cfs->guarantee_more(8, CHECK);
 
+    jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
+
+    const jint flags = cfs->get_u2_fast() & recognized_modifiers;
+    verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);
     AccessFlags access_flags;
-    const jint flags = cfs->get_u2_fast() & JVM_RECOGNIZED_FIELD_MODIFIERS;
-    verify_legal_field_modifiers(flags, is_interface, CHECK);
     access_flags.set_flags(flags);
 
     const u2 name_index = cfs->get_u2_fast();
     check_property(valid_symbol_at(name_index),
       "Invalid constant pool index %u for field name in class file %s",
@@ -1627,10 +1691,11 @@
     check_property(valid_symbol_at(signature_index),
       "Invalid constant pool index %u for field signature in class file %s",
       signature_index, CHECK);
     const Symbol* const sig = cp->symbol_at(signature_index);
     verify_legal_field_signature(name, sig, CHECK);
+    if (!access_flags.is_static()) instance_fields_count++;
 
     u2 constantvalue_index = 0;
     bool is_synthetic = false;
     u2 generic_signature_index = 0;
     const bool is_static = access_flags.is_static();
@@ -1686,11 +1751,11 @@
                       signature_index,
                       constantvalue_index);
     const BasicType type = cp->basic_type_for_signature_at(signature_index);
 
     // Remember how many oops we encountered and compute allocation type
-    const FieldAllocationType atype = fac->update(is_static, type);
+    const FieldAllocationType atype = fac->update(is_static, type, type == T_VALUETYPE);
     field->set_allocation_type(atype);
 
     // After field is initialized with type, we can augment it with aux info
     if (parsed_annotations.has_any_annotations()) {
       parsed_annotations.apply_to(field);
@@ -1731,16 +1796,45 @@
                         0);
 
       const BasicType type = Signature::basic_type(injected[n].signature());
 
       // Remember how many oops we encountered and compute allocation type
-      const FieldAllocationType atype = fac->update(false, type);
+      const FieldAllocationType atype = fac->update(false, type, false);
       field->set_allocation_type(atype);
       index++;
     }
   }
 
+  if (is_inline_type) {
+    FieldInfo* const field = FieldInfo::from_field_array(fa, index);
+    field->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,
+                      vmSymbols::default_value_name_enum,
+                      vmSymbols::object_signature_enum,
+                      0);
+    const BasicType type = Signature::basic_type(vmSymbols::object_signature());
+    const FieldAllocationType atype = fac->update(true, type, false);
+    field->set_allocation_type(atype);
+    index++;
+  }
+
+  if (is_inline_type && instance_fields_count == 0) {
+    _is_empty_inline_type = true;
+    FieldInfo* const field = FieldInfo::from_field_array(fa, index);
+    field->initialize(JVM_ACC_FIELD_INTERNAL,
+        vmSymbols::empty_marker_name_enum,
+        vmSymbols::byte_signature_enum,
+        0);
+    const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
+    const FieldAllocationType atype = fac->update(false, type, false);
+    field->set_allocation_type(atype);
+    index++;
+  }
+
+  if (instance_fields_count > 0) {
+    _has_nonstatic_fields = true;
+  }
+
   assert(NULL == _fields, "invariant");
 
   _fields =
     MetadataFactory::new_array<u2>(_loader_data,
                                    index * FieldInfo::field_slots + num_generic_signature,
@@ -2052,15 +2146,20 @@
                                             const Symbol* sig,
                                             TRAPS) const {
   assert(name != NULL, "invariant");
   assert(sig != NULL, "invariant");
 
+  const char* class_note = "";
+  if (is_inline_type() && name == vmSymbols::object_initializer_name()) {
+    class_note = " (an inline class)";
+  }
+
   ResourceMark rm(THREAD);
   Exceptions::fthrow(THREAD_AND_LOCATION,
       vmSymbols::java_lang_ClassFormatError(),
-      "%s \"%s\" in class %s has illegal signature \"%s\"", type,
-      name->as_C_string(), _class_name->as_C_string(), sig->as_C_string());
+      "%s \"%s\" in class %s%s has illegal signature \"%s\"", type,
+      name->as_C_string(), _class_name->as_C_string(), class_note, sig->as_C_string());
 }
 
 AnnotationCollector::ID
 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
                                       const Symbol* name,
@@ -2321,10 +2420,11 @@
 // from the method back up to the containing klass. These flag values
 // are added to klass's access_flags.
 
 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
                                       bool is_interface,
+                                      bool is_inline_type,
                                       const ConstantPool* cp,
                                       AccessFlags* const promoted_flags,
                                       TRAPS) {
   assert(cfs != NULL, "invariant");
   assert(cp != NULL, "invariant");
@@ -2361,15 +2461,57 @@
       flags &= JVM_ACC_STATIC | JVM_ACC_STRICT;
     } else {
       classfile_parse_error("Method <clinit> is not static in class file %s", CHECK_NULL);
     }
   } else {
-    verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);
-  }
-
-  if (name == vmSymbols::object_initializer_name() && is_interface) {
-    classfile_parse_error("Interface cannot have a method named <init>, class file %s", CHECK_NULL);
+    verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);
+  }
+
+  if (name == vmSymbols::object_initializer_name()) {
+    if (is_interface) {
+      classfile_parse_error("Interface cannot have a method named <init>, class file %s", CHECK_NULL);
+    } else if (!is_inline_type && signature->is_void_method_signature()) {
+      // OK, a constructor
+    } else if (is_inline_type && !signature->is_void_method_signature()) {
+      // also OK, a static factory, as long as the return value is good
+      bool ok = false;
+      SignatureStream ss((Symbol*) signature, true);
+      while (!ss.at_return_type())  ss.next();
+      if (ss.is_reference()) {
+        Symbol* ret = ss.as_symbol();
+        const Symbol* required = class_name();
+        if (is_unsafe_anonymous()) {
+          // The original class name in the UAC byte stream gets changed.  So
+          // using the original name in the return type is no longer valid.
+          required = vmSymbols::java_lang_Object();
+        }
+        ok = (ret == required);
+      }
+      if (!ok) {
+        throwIllegalSignature("Method", name, signature, CHECK_0);
+      }
+    } else {
+      // not OK, so throw the same error as in verify_legal_method_signature.
+      throwIllegalSignature("Method", name, signature, CHECK_0);
+    }
+    // A declared <init> method must always be either a non-static
+    // object constructor, with a void return, or else it must be a
+    // static factory method, with a non-void return.  No other
+    // definition of <init> is possible.
+    //
+    // The verifier (in verify_invoke_instructions) will inspect the
+    // signature of any attempt to invoke <init>, and ensures that it
+    // returns non-void if and only if it is being invoked by
+    // invokestatic, and void if and only if it is being invoked by
+    // invokespecial.
+    //
+    // When a symbolic reference to <init> is resolved for a
+    // particular invocation mode (special or static), the mode is
+    // matched to the JVM_ACC_STATIC modifier of the <init> method.
+    // Thus, it is impossible to statically invoke a constructor, and
+    // impossible to "new + invokespecial" a static factory, either
+    // through bytecode or through reflection.
   }
 
   int args_size = -1;  // only used when _need_verify is true
   if (_need_verify) {
     args_size = ((flags & JVM_ACC_STATIC) ? 0 : 1) +
@@ -2916,10 +3058,11 @@
 // from the methods back up to the containing klass. These flag values
 // are added to klass's access_flags.
 // Side-effects: populates the _methods field in the parser
 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
                                     bool is_interface,
+                                    bool is_inline_type,
                                     AccessFlags* promoted_flags,
                                     bool* has_final_method,
                                     bool* declares_nonstatic_concrete_methods,
                                     TRAPS) {
   assert(cfs != NULL, "invariant");
@@ -2940,10 +3083,11 @@
                                                    CHECK);
 
     for (int index = 0; index < length; index++) {
       Method* method = parse_method(cfs,
                                     is_interface,
+                                    is_inline_type,
                                     _cp,
                                     promoted_flags,
                                     CHECK);
 
       if (method->is_final()) {
@@ -3132,18 +3276,24 @@
       inner_name_index, CHECK_0);
     if (_need_verify) {
       guarantee_property(inner_class_info_index != outer_class_info_index,
                          "Class is both outer and inner class in class file %s", CHECK_0);
     }
-    // Access flags
-    jint flags;
+
+    jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;
     // JVM_ACC_MODULE is defined in JDK-9 and later.
     if (_major_version >= JAVA_9_VERSION) {
-      flags = cfs->get_u2_fast() & (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);
-    } else {
-      flags = cfs->get_u2_fast() & RECOGNIZED_INNER_CLASS_MODIFIERS;
+      recognized_modifiers |= JVM_ACC_MODULE;
+    }
+    // JVM_ACC_VALUE is defined for class file version 55 and later
+    if (supports_inline_types()) {
+      recognized_modifiers |= JVM_ACC_VALUE;
     }
+
+    // Access flags
+    jint flags = cfs->get_u2_fast() & recognized_modifiers;
+
     if ((flags & JVM_ACC_INTERFACE) && _major_version < JAVA_6_VERSION) {
       // Set abstract bit for old class files for backward compatibility
       flags |= JVM_ACC_ABSTRACT;
     }
     verify_legal_class_modifiers(flags, CHECK_0);
@@ -3999,11 +4149,12 @@
                                                         TRAPS) {
   assert(cp != NULL, "invariant");
   const InstanceKlass* super_klass = NULL;
 
   if (super_class_index == 0) {
-    check_property(_class_name == vmSymbols::java_lang_Object(),
+    check_property(_class_name == vmSymbols::java_lang_Object()
+                   || (_access_flags.get_flags() & JVM_ACC_VALUE),
                    "Invalid superclass index %u in class file %s",
                    super_class_index,
                    CHECK_NULL);
   } else {
     check_property(valid_klass_reference_at(super_class_index),
@@ -4179,10 +4330,29 @@
 
 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
   print_on(st);
 }
 
+void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,
+                                                const char* msg,
+                                                const Symbol* name,
+                                                const Symbol* sig) const {
+
+  ResourceMark rm(THREAD);
+  if (name == NULL || sig == NULL) {
+    Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
+        vmSymbols::java_lang_ClassFormatError(),
+        "class: %s - %s", _class_name->as_C_string(), msg);
+  }
+  else {
+    Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
+        vmSymbols::java_lang_ClassFormatError(),
+        "\"%s\" sig: \"%s\" class: %s - %s", name->as_C_string(), sig->as_C_string(),
+        _class_name->as_C_string(), msg);
+  }
+}
+
 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
 void ClassFileParser::layout_fields(ConstantPool* cp,
                                     const FieldAllocationCount* fac,
                                     const ClassAnnotationCollector* parsed_annotations,
                                     FieldLayoutInfo* info,
@@ -4191,10 +4361,16 @@
   assert(cp != NULL, "invariant");
 
   // Field size and offset computation
   int nonstatic_field_size = _super_klass == NULL ? 0 :
                                _super_klass->nonstatic_field_size();
+  int next_nonstatic_inline_type_offset = 0;
+  int first_nonstatic_inline_type_offset = 0;
+
+  // Fields that are inline types are handled differently depending if they are static or not:
+  // - static fields are oops
+  // - non-static fields are embedded
 
   // Count the contended fields by type.
   //
   // We ignore static fields, because @Contended is not supported for them.
   // The layout code below will also ignore the static fields.
@@ -4211,12 +4387,13 @@
   }
 
 
   // Calculate the starting byte offsets
   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
+  // Inline types in static fields are not embedded, they are handled with oops
   int next_static_double_offset = next_static_oop_offset +
-                                      ((fac->count[STATIC_OOP]) * heapOopSize);
+                                  ((fac->count[STATIC_OOP] + fac->count[STATIC_INLINE]) * heapOopSize);
   if (fac->count[STATIC_DOUBLE]) {
     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
   }
 
   int next_static_word_offset   = next_static_double_offset +
@@ -4227,50 +4404,151 @@
                                   ((fac->count[STATIC_SHORT]) * BytesPerShort);
 
   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
                                 nonstatic_field_size * heapOopSize;
 
+  // First field of inline types is aligned on a long boundary in order to ease
+  // in-lining of inline types (with header removal) in packed arrays and
+  // inlined fields
+  int initial_inline_type_padding = 0;
+  if (is_inline_type()) {
+    int old = nonstatic_fields_start;
+    nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
+    initial_inline_type_padding = nonstatic_fields_start - old;
+  }
+
   int next_nonstatic_field_offset = nonstatic_fields_start;
 
   const bool is_contended_class     = parsed_annotations->is_contended();
 
   // Class is contended, pad before all the fields
   if (is_contended_class) {
     next_nonstatic_field_offset += ContendedPaddingWidth;
   }
 
+  // Temporary inline types restrictions
+  if (is_inline_type()) {
+    if (is_contended_class) {
+      throwInlineTypeLimitation(THREAD_AND_LOCATION, "Inline Types do not support @Contended annotation yet");
+      return;
+    }
+  }
+
   // Compute the non-contended fields count.
   // The packing code below relies on these counts to determine if some field
   // can be squeezed into the alignment gap. Contended fields are obviously
   // exempt from that.
   unsigned int nonstatic_double_count = fac->count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
   unsigned int nonstatic_word_count   = fac->count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
   unsigned int nonstatic_short_count  = fac->count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
   unsigned int nonstatic_byte_count   = fac->count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
   unsigned int nonstatic_oop_count    = fac->count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
 
+  int static_inline_type_count = 0;
+  int nonstatic_inline_type_count = 0;
+  int* nonstatic_inline_type_indexes = NULL;
+  Klass** nonstatic_inline_type_klasses = NULL;
+  unsigned int inline_type_oop_map_count = 0;
+  int inline_types_not_inlined = 0;
+  int not_atomic_inline_types = 0;
+
+  int max_nonstatic_inline_type = fac->count[NONSTATIC_INLINE] + 1;
+
+  nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,
+                                                               max_nonstatic_inline_type);
+  for (int i = 0; i < max_nonstatic_inline_type; i++) {
+    nonstatic_inline_type_indexes[i] = -1;
+  }
+  nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,
+                                                               max_nonstatic_inline_type);
+
+  for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
+    if (fs.allocation_type() == STATIC_INLINE) {
+      ResourceMark rm;
+      if (!fs.signature()->is_Q_signature()) {
+        THROW(vmSymbols::java_lang_ClassFormatError());
+      }
+      static_inline_type_count++;
+    } else if (fs.allocation_type() == NONSTATIC_INLINE) {
+      // Pre-resolve the inline field and check for inline type circularity issues.
+      ResourceMark rm;
+      if (!fs.signature()->is_Q_signature()) {
+        THROW(vmSymbols::java_lang_ClassFormatError());
+      }
+      Klass* klass =
+        SystemDictionary::resolve_inline_type_field_or_fail(&fs,
+                                                            Handle(THREAD, _loader_data->class_loader()),
+                                                            _protection_domain, true, CHECK);
+      assert(klass != NULL, "Sanity check");
+      if (!klass->access_flags().is_inline_type()) {
+        THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
+      }
+      ValueKlass* vk = ValueKlass::cast(klass);
+      // Conditions to apply flattening or not should be defined in a single place
+      bool too_big_to_allocate_inline = (InlineFieldMaxFlatSize >= 0 &&
+                                 (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);
+      bool too_atomic_to_allocate_inline = vk->is_declared_atomic();
+      bool too_volatile_to_allocate_inline = fs.access_flags().is_volatile();
+      if (vk->is_naturally_atomic()) {
+        too_atomic_to_allocate_inline = false;
+        // too_volatile_to_allocate_inline = false; //FIXME
+        // volatile fields are currently never inlined, this could change in the future
+      }
+      if (!(too_big_to_allocate_inline | too_atomic_to_allocate_inline | too_volatile_to_allocate_inline)) {
+        nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();
+        nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;
+        nonstatic_inline_type_count++;
+
+        ValueKlass* vklass = ValueKlass::cast(klass);
+        if (vklass->contains_oops()) {
+          inline_type_oop_map_count += vklass->nonstatic_oop_map_count();
+        }
+        fs.set_inlined(true);
+        if (!vk->is_atomic()) {  // flat and non-atomic: take note
+          not_atomic_inline_types++;
+        }
+      } else {
+        inline_types_not_inlined++;
+        fs.set_inlined(false);
+      }
+    }
+  }
+
+  // Adjusting non_static_oop_count to take into account inline types fields not inlined;
+  nonstatic_oop_count += inline_types_not_inlined;
+
   // Total non-static fields count, including every contended field
   unsigned int nonstatic_fields_count = fac->count[NONSTATIC_DOUBLE] + fac->count[NONSTATIC_WORD] +
                                         fac->count[NONSTATIC_SHORT] + fac->count[NONSTATIC_BYTE] +
-                                        fac->count[NONSTATIC_OOP];
+                                        fac->count[NONSTATIC_OOP] + fac->count[NONSTATIC_INLINE];
 
   const bool super_has_nonstatic_fields =
           (_super_klass != NULL && _super_klass->has_nonstatic_fields());
   const bool has_nonstatic_fields =
     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
+  const bool has_nonstatic_inline_fields = nonstatic_inline_type_count > 0;
 
+  if (is_inline_type() && (!has_nonstatic_fields)) {
+    // There are a number of fixes required throughout the type system and JIT
+    throwInlineTypeLimitation(THREAD_AND_LOCATION, "Inline Types do not support zero instance size yet");
+    return;
+  }
 
   // Prepare list of oops for oop map generation.
   //
   // "offset" and "count" lists are describing the set of contiguous oop
   // regions. offset[i] is the start of the i-th region, which then has
   // count[i] oops following. Before we know how many regions are required,
   // we pessimistically allocate the maps to fit all the oops into the
   // distinct regions.
-
+  //
   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass->nonstatic_oop_map_count();
-  int max_oop_map_count = super_oop_map_count + fac->count[NONSTATIC_OOP];
+  int max_oop_map_count =
+      super_oop_map_count +
+      fac->count[NONSTATIC_OOP] +
+      inline_type_oop_map_count +
+      inline_types_not_inlined;
 
   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
   if (super_oop_map_count > 0) {
     nonstatic_oop_maps->initialize_inherited_blocks(_super_klass->start_of_nonstatic_oop_maps(),
                                                     _super_klass->nonstatic_oop_map_count());
@@ -4361,10 +4639,20 @@
       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
     }
     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
   }
 
+  // Aligning embedded inline types
+  // bug below, the current algorithm to layout embedded inline types always put them at the
+  // end of the layout, which doesn't match the different allocation policies the VM is
+  // supposed to provide => FixMe
+  // Note also that the current alignment policy is to make each inline type starting on a
+  // 64 bits boundary. This could be optimized later. For instance, it could be nice to
+  // align inline types according to their most constrained internal type.
+  next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
+  int next_inline_type_index = 0;
+
   // Iterate over fields again and compute correct offsets.
   // The field allocation type was temporarily stored in the offset slot.
   // oop fields are located before non-oop fields (static and non-static).
   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
 
@@ -4377,10 +4665,12 @@
     int real_offset = 0;
     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
 
     // pack the rest of the fields
     switch (atype) {
+      // Inline types in static fields are handled with oops
+      case STATIC_INLINE:   // Fallthrough
       case STATIC_OOP:
         real_offset = next_static_oop_offset;
         next_static_oop_offset += heapOopSize;
         break;
       case STATIC_BYTE:
@@ -4397,10 +4687,35 @@
         break;
       case STATIC_DOUBLE:
         real_offset = next_static_double_offset;
         next_static_double_offset += BytesPerLong;
         break;
+      case NONSTATIC_INLINE:
+        if (fs.is_inlined()) {
+          Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];
+          assert(klass != NULL, "Klass should have been loaded and resolved earlier");
+          assert(klass->access_flags().is_inline_type(),"Must be an inline type");
+          ValueKlass* vklass = ValueKlass::cast(klass);
+          real_offset = next_nonstatic_inline_type_offset;
+          next_nonstatic_inline_type_offset += (vklass->size_helper()) * wordSize - vklass->first_field_offset();
+          // aligning next inline type on a 64 bits boundary
+          next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);
+          next_inline_type_index += 1;
+
+          if (vklass->contains_oops()) { // add flatten oop maps
+            int diff = real_offset - vklass->first_field_offset();
+            const OopMapBlock* map = vklass->start_of_nonstatic_oop_maps();
+            const OopMapBlock* const last_map = map + vklass->nonstatic_oop_map_count();
+            while (map < last_map) {
+              nonstatic_oop_maps->add(map->offset() + diff, map->count());
+              map++;
+            }
+          }
+          break;
+        } else {
+          // Fall through
+        }
       case NONSTATIC_OOP:
         if( nonstatic_oop_space_count > 0 ) {
           real_offset = nonstatic_oop_space_offset;
           nonstatic_oop_space_offset += heapOopSize;
           nonstatic_oop_space_count  -= 1;
@@ -4515,10 +4830,16 @@
             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
             real_offset = next_nonstatic_padded_offset;
             next_nonstatic_padded_offset += BytesPerLong;
             break;
 
+            // Inline types in static fields are handled with oops
+          case NONSTATIC_INLINE:
+            throwInlineTypeLimitation(THREAD_AND_LOCATION,
+                                      "@Contended annotation not supported for inline types yet", fs.name(), fs.signature());
+            return;
+
           case NONSTATIC_OOP:
             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
             real_offset = next_nonstatic_padded_offset;
             next_nonstatic_padded_offset += heapOopSize;
             nonstatic_oop_maps->add(real_offset, 1);
@@ -4554,16 +4875,28 @@
 
   // Entire class is contended, pad in the back.
   // This helps to alleviate memory contention effects for subclass fields
   // and/or adjacent object.
   if (is_contended_class) {
+    assert(!is_inline_type(), "@Contended not supported for inline types yet");
     next_nonstatic_padded_offset += ContendedPaddingWidth;
   }
 
-  int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
+  int notaligned_nonstatic_fields_end;
+  if (nonstatic_inline_type_count != 0) {
+    notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;
+  } else {
+    notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
+  }
 
-  int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);
+  int nonstatic_field_sz_align = heapOopSize;
+  if (is_inline_type()) {
+    if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) > heapOopSize) {
+      nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy
+    }
+  }
+  int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);
   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
 
   int static_field_size         = (static_fields_end -
                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
@@ -4571,12 +4904,13 @@
                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
 
   int instance_size             = align_object_size(instance_end / wordSize);
 
   assert(instance_size == align_object_size(align_up(
-         (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),
-          wordSize) / wordSize), "consistent layout helper value");
+         (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
+         + initial_inline_type_padding, wordSize) / wordSize), "consistent layout helper value");
+
 
   // Invariant: nonstatic_field end/start should only change if there are
   // nonstatic fields in the class, or if the class is contended. We compare
   // against the non-aligned value, so that end alignment will not fail the
   // assert without actually having the fields.
@@ -4586,27 +4920,49 @@
 
   // Number of non-static oop map blocks allocated at end of klass.
   nonstatic_oop_maps->compact();
 
 #ifndef PRODUCT
-  if (PrintFieldLayout) {
+  if ((PrintFieldLayout && !is_inline_type()) ||
+      (PrintInlineLayout && (is_inline_type() || has_nonstatic_inline_fields))) {
     print_field_layout(_class_name,
           _fields,
           cp,
           instance_size,
           nonstatic_fields_start,
           nonstatic_fields_end,
           static_fields_end);
+    nonstatic_oop_maps->print_on(tty);
+    tty->print("\n");
+    tty->print_cr("Instance size = %d", instance_size);
+    tty->print_cr("Nonstatic_field_size = %d", nonstatic_field_size);
+    tty->print_cr("Static_field_size = %d", static_field_size);
+    tty->print_cr("Has nonstatic fields = %d", has_nonstatic_fields);
+    tty->print_cr("---");
   }
 
 #endif
   // Pass back information needed for InstanceKlass creation
   info->oop_map_blocks = nonstatic_oop_maps;
   info->_instance_size = instance_size;
   info->_static_field_size = static_field_size;
   info->_nonstatic_field_size = nonstatic_field_size;
   info->_has_nonstatic_fields = has_nonstatic_fields;
+  info->_has_inline_fields = nonstatic_inline_type_count > 0;
+
+  // An inline type is naturally atomic if it has just one field, and
+  // that field is simple enough.
+  info->_is_naturally_atomic = (is_inline_type() &&
+                                !super_has_nonstatic_fields &&
+                                (nonstatic_fields_count <= 1) &&
+                                (not_atomic_inline_types == 0) &&
+                                (nonstatic_contended_count == 0));
+  // This may be too restrictive, since if all the fields fit in 64
+  // bits we could make the decision to align instances of this class
+  // to 64-bit boundaries, and load and store them as single words.
+  // And on machines which supported larger atomics we could similarly
+  // allow larger values to be atomic, if properly aligned.
 }
 
 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
   assert(ik != NULL, "invariant");
 
@@ -4638,10 +4994,15 @@
 #endif
 
   // Check if this klass supports the java.lang.Cloneable interface
   if (SystemDictionary::Cloneable_klass_loaded()) {
     if (ik->is_subtype_of(SystemDictionary::Cloneable_klass())) {
+      if (ik->is_value()) {
+        Thread *THREAD = Thread::current();
+        throwInlineTypeLimitation(THREAD_AND_LOCATION, "Inline Types do not support Cloneable");
+        return;
+      }
       ik->set_is_cloneable();
     }
   }
 
   // Check if this klass has a vanilla default constructor
@@ -4678,10 +5039,15 @@
     const jint lh = Klass::instance_layout_helper(ik->size_helper(), true);
     ik->set_layout_helper(lh);
   }
 }
 
+bool ClassFileParser::supports_inline_types() const {
+  // Inline types are only supported by class file version 55 and later
+  return _major_version >= JAVA_11_VERSION;
+}
+
 // utility methods for appending an array with check for duplicates
 
 static void append_interfaces(GrowableArray<InstanceKlass*>* result,
                               const Array<InstanceKlass*>* const ifs) {
   // iterate over new interfaces
@@ -4721,13 +5087,14 @@
     // no interfaces, use canonicalized array
     return Universe::the_empty_instance_klass_array();
   } else if (max_transitive_size == super_size) {
     // no new local interfaces added, share superklass' transitive interface array
     return super->transitive_interfaces();
-  } else if (max_transitive_size == local_size) {
-    // only local interfaces added, share local interface array
-    return local_ifs;
+    // The three lines below are commented to work around bug JDK-8245487
+//  } else if (max_transitive_size == local_size) {
+//    // only local interfaces added, share local interface array
+//    return local_ifs;
   } else {
     ResourceMark rm;
     GrowableArray<InstanceKlass*>* const result = new GrowableArray<InstanceKlass*>(max_transitive_size);
 
     // Copy down from superclass
@@ -4744,10 +5111,15 @@
     append_interfaces(result, local_ifs);
 
     // length will be less than the max_transitive_size if duplicates were removed
     const int length = result->length();
     assert(length <= max_transitive_size, "just checking");
+
+    if (length == 1 && result->at(0) == SystemDictionary::IdentityObject_klass()) {
+      return Universe::the_single_IdentityObject_klass_array();
+    }
+
     Array<InstanceKlass*>* const new_result =
       MetadataFactory::new_array<InstanceKlass*>(loader_data, length, CHECK_NULL);
     for (int i = 0; i < length; i++) {
       InstanceKlass* const e = result->at(i);
       assert(e != NULL, "just checking");
@@ -4976,21 +5348,33 @@
 
 // utility methods for format checking
 
 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
   const bool is_module = (flags & JVM_ACC_MODULE) != 0;
+  const bool is_inline_type = (flags & JVM_ACC_VALUE) != 0;
   assert(_major_version >= JAVA_9_VERSION || !is_module, "JVM_ACC_MODULE should not be set");
+  assert(supports_inline_types() || !is_inline_type, "JVM_ACC_VALUE should not be set");
   if (is_module) {
     ResourceMark rm(THREAD);
     Exceptions::fthrow(
       THREAD_AND_LOCATION,
       vmSymbols::java_lang_NoClassDefFoundError(),
       "%s is not a class because access_flag ACC_MODULE is set",
       _class_name->as_C_string());
     return;
   }
 
+  if (is_inline_type && !EnableValhalla) {
+    ResourceMark rm(THREAD);
+    Exceptions::fthrow(
+      THREAD_AND_LOCATION,
+      vmSymbols::java_lang_ClassFormatError(),
+      "Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla",
+      _class_name->as_C_string()
+    );
+  }
+
   if (!_need_verify) { return; }
 
   const bool is_interface  = (flags & JVM_ACC_INTERFACE)  != 0;
   const bool is_abstract   = (flags & JVM_ACC_ABSTRACT)   != 0;
   const bool is_final      = (flags & JVM_ACC_FINAL)      != 0;
@@ -5001,17 +5385,20 @@
   const bool major_gte_14  = _major_version >= JAVA_14_VERSION;
 
   if ((is_abstract && is_final) ||
       (is_interface && !is_abstract) ||
       (is_interface && major_gte_1_5 && (is_super || is_enum)) ||
-      (!is_interface && major_gte_1_5 && is_annotation)) {
+      (!is_interface && major_gte_1_5 && is_annotation) ||
+      (is_inline_type && (is_interface || is_abstract || is_enum || !is_final))) {
     ResourceMark rm(THREAD);
+    const char* class_note = "";
+    if (is_inline_type)  class_note = " (an inline class)";
     Exceptions::fthrow(
       THREAD_AND_LOCATION,
       vmSymbols::java_lang_ClassFormatError(),
-      "Illegal class modifiers in class %s: 0x%X",
-      _class_name->as_C_string(), flags
+      "Illegal class modifiers in class %s%s: 0x%X",
+      _class_name->as_C_string(), class_note, flags
     );
     return;
   }
 }
 
@@ -5086,10 +5473,11 @@
   }
 }
 
 void ClassFileParser::verify_legal_field_modifiers(jint flags,
                                                    bool is_interface,
+                                                   bool is_inline_type,
                                                    TRAPS) const {
   if (!_need_verify) { return; }
 
   const bool is_public    = (flags & JVM_ACC_PUBLIC)    != 0;
   const bool is_protected = (flags & JVM_ACC_PROTECTED) != 0;
@@ -5110,10 +5498,14 @@
       is_illegal = true;
     }
   } else { // not interface
     if (has_illegal_visibility(flags) || (is_final && is_volatile)) {
       is_illegal = true;
+    } else {
+      if (is_inline_type && !is_static && !is_final) {
+        is_illegal = true;
+      }
     }
   }
 
   if (is_illegal) {
     ResourceMark rm(THREAD);
@@ -5126,10 +5518,11 @@
   }
 }
 
 void ClassFileParser::verify_legal_method_modifiers(jint flags,
                                                     bool is_interface,
+                                                    bool is_inline_type,
                                                     const Symbol* name,
                                                     TRAPS) const {
   if (!_need_verify) { return; }
 
   const bool is_public       = (flags & JVM_ACC_PUBLIC)       != 0;
@@ -5146,10 +5539,12 @@
   const bool major_gte_8     = _major_version >= JAVA_8_VERSION;
   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
 
   bool is_illegal = false;
 
+  const char* class_note = "";
+
   if (is_interface) {
     if (major_gte_8) {
       // Class file version is JAVA_8_VERSION or later Methods of
       // interfaces may set any of the flags except ACC_PROTECTED,
       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
@@ -5180,19 +5575,33 @@
   } else { // not interface
     if (has_illegal_visibility(flags)) {
       is_illegal = true;
     } else {
       if (is_initializer) {
-        if (is_static || is_final || is_synchronized || is_native ||
+        if (is_final || is_synchronized || is_native ||
             is_abstract || (major_gte_1_5 && is_bridge)) {
           is_illegal = true;
         }
+        if (!is_static && !is_inline_type) {
+          // OK, an object constructor in a regular class
+        } else if (is_static && is_inline_type) {
+          // OK, a static init factory in an inline class
+        } else {
+          // but no other combinations are allowed
+          is_illegal = true;
+          class_note = (is_inline_type ? " (an inline class)" : " (not an inline class)");
+        }
       } else { // not initializer
-        if (is_abstract) {
-          if ((is_final || is_native || is_private || is_static ||
-              (major_gte_1_5 && (is_synchronized || is_strict)))) {
-            is_illegal = true;
+        if (is_inline_type && is_synchronized && !is_static) {
+          is_illegal = true;
+          class_note = " (an inline class)";
+        } else {
+          if (is_abstract) {
+            if ((is_final || is_native || is_private || is_static ||
+                (major_gte_1_5 && (is_synchronized || is_strict)))) {
+              is_illegal = true;
+            }
           }
         }
       }
     }
   }
@@ -5200,12 +5609,12 @@
   if (is_illegal) {
     ResourceMark rm(THREAD);
     Exceptions::fthrow(
       THREAD_AND_LOCATION,
       vmSymbols::java_lang_ClassFormatError(),
-      "Method %s in class %s has illegal modifiers: 0x%X",
-      name->as_C_string(), _class_name->as_C_string(), flags);
+      "Method %s in class %s%s has illegal modifiers: 0x%X",
+      name->as_C_string(), _class_name->as_C_string(), class_note, flags);
     return;
   }
 }
 
 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
@@ -5359,22 +5768,31 @@
     case JVM_SIGNATURE_INT:
     case JVM_SIGNATURE_FLOAT:
     case JVM_SIGNATURE_LONG:
     case JVM_SIGNATURE_DOUBLE:
       return signature + 1;
-    case JVM_SIGNATURE_CLASS: {
+    case JVM_SIGNATURE_INLINE_TYPE:
+      // Can't enable this check until JDK upgrades the bytecode generators
+      // if (_major_version < CONSTANT_CLASS_DESCRIPTORS ) {
+      //   classfile_parse_error("Class name contains illegal Q-signature "
+      //                                    "in descriptor in class file %s",
+      //                                    CHECK_0);
+      // }
+      // fall through
+    case JVM_SIGNATURE_CLASS:
+    {
       if (_major_version < JAVA_1_5_VERSION) {
         // Skip over the class name if one is there
         const char* const p = skip_over_field_name(signature + 1, true, --length);
 
         // The next character better be a semicolon
         if (p && (p - signature) > 1 && p[0] == JVM_SIGNATURE_ENDCLASS) {
           return p + 1;
         }
       }
       else {
-        // Skip leading 'L' and ignore first appearance of ';'
+        // Skip leading 'L' or 'Q' and ignore first appearance of ';'
         signature++;
         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
         // Format check signature
         if (c != NULL) {
           int newlen = c - (char*) signature;
@@ -5425,10 +5843,13 @@
     } else if (_major_version < JAVA_1_5_VERSION) {
       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
         p = skip_over_field_name(bytes, true, length);
         legal = (p != NULL) && ((p - bytes) == (int)length);
       }
+    } else if (_major_version >= CONSTANT_CLASS_DESCRIPTORS && bytes[length - 1] == ';' ) {
+      // Support for L...; and Q...; descriptors
+      legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);
     } else {
       // 4900761: relax the constraints based on JSR202 spec
       // Class names may be drawn from the entire Unicode character set.
       // Identifiers between '/' must be unqualified names.
       // The utf8 string has been verified when parsing cpool entries.
@@ -5574,14 +5995,30 @@
     }
     // The first non-signature thing better be a ')'
     if ((length > 0) && (*p++ == JVM_SIGNATURE_ENDFUNC)) {
       length--;
       if (name->utf8_length() > 0 && name->char_at(0) == JVM_SIGNATURE_SPECIAL) {
-        // All internal methods must return void
+        // All constructor methods must return void
         if ((length == 1) && (p[0] == JVM_SIGNATURE_VOID)) {
           return args_size;
         }
+        // All static init methods must return the current class
+        if ((length >= 3) && (p[length-1] == JVM_SIGNATURE_ENDCLASS)
+            && name == vmSymbols::object_initializer_name()) {
+          nextp = skip_over_field_signature(p, true, length, CHECK_0);
+          if (nextp && ((int)length == (nextp - p))) {
+            // The actual class will be checked against current class
+            // when the method is defined (see parse_method).
+            // A reference to a static init with a bad return type
+            // will load and verify OK, but will fail to link.
+            return args_size;
+          }
+        }
+        // The distinction between static factory methods and
+        // constructors depends on the JVM_ACC_STATIC modifier.
+        // This distinction must be reflected in a void or non-void
+        // return. For declared methods, the check is in parse_method.
       } else {
         // Now we better just have a return value
         nextp = skip_over_field_signature(p, true, length, CHECK_0);
         if (nextp && ((int)length == (nextp - p))) {
           return args_size;
@@ -5735,13 +6172,53 @@
       log_info(class, fingerprint)("%s :  expected = " PTR64_FORMAT " actual = " PTR64_FORMAT,
                                  ik->external_name(), aot_fp, _stream->compute_fingerprint());
     }
   }
 
+  if (ik->is_value()) {
+    ValueKlass* vk = ValueKlass::cast(ik);
+    oop val = ik->allocate_instance(CHECK_NULL);
+    vk->set_default_value(val);
+  }
+
   return ik;
 }
 
+// Return true if the specified class is not a valid super class for an inline type.
+// A valid super class for an inline type is abstract, has no instance fields,
+// does not implement interface java.lang.IdentityObject (checked elsewhere), has
+// an empty body-less no-arg constructor, and no synchronized instance methods.
+// This function doesn't check if the class's super types are invalid.  Those checks
+// are done elsewhere.  The final determination of whether or not a class is an
+// invalid super type for an inline class is done in fill_instance_klass().
+bool ClassFileParser::is_invalid_super_for_inline_type() {
+  if (class_name() == vmSymbols::java_lang_IdentityObject()) {
+    return true;
+  }
+  if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {
+    return false;
+  }
+  if (!access_flags().is_abstract() || _has_nonstatic_fields) {
+    return true;
+  } else {
+    // Look at each method
+    for (int x = 0; x < _methods->length(); x++) {
+      const Method* const method = _methods->at(x);
+      if (method->is_synchronized() && !method->is_static()) {
+        return true;
+
+      } else if (method->name() == vmSymbols::object_initializer_name()) {
+        if (method->signature() != vmSymbols::void_method_signature() ||
+            !method->is_vanilla_constructor()) {
+          return true;
+        }
+      }
+    }
+  }
+  return false;
+}
+
 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
                                           bool changed_by_loadhook,
                                           const ClassInstanceInfo& cl_inst_info,
                                           TRAPS) {
   assert(ik != NULL, "invariant");
@@ -5770,12 +6247,27 @@
   ik->set_should_verify_class(_need_verify);
 
   // Not yet: supers are done below to support the new subtype-checking fields
   ik->set_nonstatic_field_size(_field_info->_nonstatic_field_size);
   ik->set_has_nonstatic_fields(_field_info->_has_nonstatic_fields);
+  if (_field_info->_is_naturally_atomic && ik->is_value()) {
+    ik->set_is_naturally_atomic();
+  }
+  if (_is_empty_inline_type) {
+    ik->set_is_empty_inline_type();
+  }
+
+  if (this->_invalid_inline_super) {
+    ik->set_invalid_inline_super();
+  }
+
+  if (_has_injected_identityObject) {
+    ik->set_has_injected_identityObject();
+  }
+
   assert(_fac != NULL, "invariant");
-  ik->set_static_oop_field_count(_fac->count[STATIC_OOP]);
+  ik->set_static_oop_field_count(_fac->count[STATIC_OOP] + _fac->count[STATIC_INLINE]);
 
   // this transfers ownership of a lot of arrays from
   // the parser onto the InstanceKlass*
   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
 
@@ -5821,10 +6313,13 @@
 
   ik->set_minor_version(_minor_version);
   ik->set_major_version(_major_version);
   ik->set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
   ik->set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
+  if (_is_declared_atomic) {
+    ik->set_is_declared_atomic();
+  }
 
   if (_unsafe_anonymous_host != NULL) {
     assert (ik->is_unsafe_anonymous(), "should be the same");
     ik->set_unsafe_anonymous_host(_unsafe_anonymous_host);
   }
@@ -5932,10 +6427,44 @@
       // We won a potential race
       JvmtiExport::add_default_read_edges(module_handle, THREAD);
     }
   }
 
+  int nfields = ik->java_fields_count();
+  if (ik->is_value()) nfields++;
+  for (int i = 0; i < nfields; i++) {
+    if (ik->field_is_inline_type(i)) {
+      Symbol* klass_name = ik->field_signature(i)->fundamental_name(CHECK);
+      // Inline classes for instance fields must have been pre-loaded
+      // Inline classes for static fields might not have been loaded yet
+      Klass* klass = SystemDictionary::find(klass_name,
+          Handle(THREAD, ik->class_loader()),
+          Handle(THREAD, ik->protection_domain()), CHECK);
+      if (klass != NULL) {
+        assert(klass->access_flags().is_inline_type(), "Inline type expected");
+        ik->set_value_field_klass(i, klass);
+      }
+      klass_name->decrement_refcount();
+    } else
+      if (is_inline_type() && ((ik->field_access_flags(i) & JVM_ACC_FIELD_INTERNAL) != 0)
+        && ((ik->field_access_flags(i) & JVM_ACC_STATIC) != 0)) {
+      ValueKlass::cast(ik)->set_default_value_offset(ik->field_offset(i));
+    }
+  }
+
+  if (is_inline_type()) {
+    ValueKlass* vk = ValueKlass::cast(ik);
+    if (UseNewFieldLayout) {
+      vk->set_alignment(_alignment);
+      vk->set_first_field_offset(_first_field_offset);
+      vk->set_exact_size_in_bytes(_exact_size_in_bytes);
+    } else {
+      vk->set_first_field_offset(vk->first_field_offset_old());
+    }
+    ValueKlass::cast(ik)->initialize_calling_convention(CHECK);
+  }
+
   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
 
   if (!is_internal()) {
     if (log_is_enabled(Info, class, load)) {
       ResourceMark rm;
@@ -5981,10 +6510,14 @@
   set_klass_to_deallocate(NULL);
 
   // it's official
   set_klass(ik);
 
+  if (ik->name() == vmSymbols::java_lang_IdentityObject()) {
+    Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);
+  }
+
   debug_only(ik->verify();)
 }
 
 void ClassFileParser::update_class_name(Symbol* new_class_name) {
   // Decrement the refcount in the old name, since we're clobbering it.
@@ -6083,10 +6616,11 @@
   _inner_classes(NULL),
   _nest_members(NULL),
   _nest_host(0),
   _permitted_subclasses(NULL),
   _record_components(NULL),
+  _temp_local_interfaces(NULL),
   _local_interfaces(NULL),
   _transitive_interfaces(NULL),
   _combined_annotations(NULL),
   _class_annotations(NULL),
   _class_type_annotations(NULL),
@@ -6122,10 +6656,19 @@
   _relax_verify(false),
   _has_nonstatic_concrete_methods(false),
   _declares_nonstatic_concrete_methods(false),
   _has_final_method(false),
   _has_contended_fields(false),
+  _has_inline_type_fields(false),
+  _has_nonstatic_fields(false),
+  _is_empty_inline_type(false),
+  _is_naturally_atomic(false),
+  _is_declared_atomic(false),
+  _invalid_inline_super(false),
+  _invalid_identity_super(false),
+  _implements_identityObject(false),
+  _has_injected_identityObject(false),
   _has_finalizer(false),
   _has_empty_finalizer(false),
   _has_vanilla_constructor(false),
   _max_bootstrap_specifier_index(-1) {
 
@@ -6332,19 +6875,23 @@
   assert(cp_size == (const u2)cp->length(), "invariant");
 
   // ACCESS FLAGS
   stream->guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
 
-  // Access flags
-  jint flags;
+  jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;
   // JVM_ACC_MODULE is defined in JDK-9 and later.
   if (_major_version >= JAVA_9_VERSION) {
-    flags = stream->get_u2_fast() & (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);
-  } else {
-    flags = stream->get_u2_fast() & JVM_RECOGNIZED_CLASS_MODIFIERS;
+    recognized_modifiers |= JVM_ACC_MODULE;
+  }
+  // JVM_ACC_VALUE is defined for class file version 55 and later
+  if (supports_inline_types()) {
+    recognized_modifiers |= JVM_ACC_VALUE;
   }
 
+  // Access flags
+  jint flags = stream->get_u2_fast() & recognized_modifiers;
+
   if ((flags & JVM_ACC_INTERFACE) && _major_version < JAVA_6_VERSION) {
     // Set abstract bit for old class files for backward compatibility
     flags |= JVM_ACC_ABSTRACT;
   }
 
@@ -6498,19 +7045,22 @@
   // Interfaces
   _itfs_len = stream->get_u2_fast();
   parse_interfaces(stream,
                    _itfs_len,
                    cp,
+                   is_inline_type(),
                    &_has_nonstatic_concrete_methods,
+                   &_is_declared_atomic,
                    CHECK);
 
-  assert(_local_interfaces != NULL, "invariant");
+  assert(_temp_local_interfaces != NULL, "invariant");
 
   // Fields (offsets are filled in later)
   _fac = new FieldAllocationCount();
   parse_fields(stream,
-               _access_flags.is_interface(),
+               is_interface(),
+               is_inline_type(),
                _fac,
                cp,
                cp_size,
                &_java_fields_count,
                CHECK);
@@ -6518,11 +7068,12 @@
   assert(_fields != NULL, "invariant");
 
   // Methods
   AccessFlags promoted_flags;
   parse_methods(stream,
-                _access_flags.is_interface(),
+                is_interface(),
+                is_inline_type(),
                 &promoted_flags,
                 &_has_final_method,
                 &_declares_nonstatic_concrete_methods,
                 CHECK);
 
@@ -6589,18 +7140,18 @@
   assert(stream->at_eos(), "invariant");
   assert(cp != NULL, "invariant");
   assert(_loader_data != NULL, "invariant");
 
   if (_class_name == vmSymbols::java_lang_Object()) {
-    check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
-                   "java.lang.Object cannot implement an interface in class file %s",
-                   CHECK);
+    check_property(_temp_local_interfaces->length() == 0,
+        "java.lang.Object cannot implement an interface in class file %s",
+        CHECK);
   }
   // We check super class after class file is parsed and format is checked
   if (_super_class_index > 0 && NULL ==_super_klass) {
     Symbol* const super_class_name = cp->klass_name_at(_super_class_index);
-    if (_access_flags.is_interface()) {
+    if (is_interface()) {
       // Before attempting to resolve the superclass, check for class format
       // errors not checked yet.
       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
         "Interfaces must have java.lang.Object as superclass in class file %s",
         CHECK);
@@ -6617,10 +7168,13 @@
 
   if (_super_klass != NULL) {
     if (_super_klass->has_nonstatic_concrete_methods()) {
       _has_nonstatic_concrete_methods = true;
     }
+    if (_super_klass->is_declared_atomic()) {
+      _is_declared_atomic = true;
+    }
 
     if (_super_klass->is_interface()) {
       ResourceMark rm(THREAD);
       Exceptions::fthrow(
         THREAD_AND_LOCATION,
@@ -6629,12 +7183,68 @@
         _class_name->as_klass_external_name(),
         _super_klass->external_name()
       );
       return;
     }
+
+    // For an inline class, only java/lang/Object or special abstract classes
+    // are acceptable super classes.
+    if (is_inline_type()) {
+      const InstanceKlass* super_ik = _super_klass;
+      if (super_ik->invalid_inline_super()) {
+        ResourceMark rm(THREAD);
+        Exceptions::fthrow(
+          THREAD_AND_LOCATION,
+          vmSymbols::java_lang_IncompatibleClassChangeError(),
+          "inline class %s has an invalid super class %s",
+          _class_name->as_klass_external_name(),
+          _super_klass->external_name());
+        return;
+      }
+    }
+  }
+
+  if (_class_name == vmSymbols::java_lang_NonTearable() && _loader_data->class_loader() == NULL) {
+    // This is the original source of this condition.
+    // It propagates by inheritance, as if testing "instanceof NonTearable".
+    _is_declared_atomic = true;
+  } else if (*ForceNonTearable != '\0') {
+    // Allow a command line switch to force the same atomicity property:
+    const char* class_name_str = _class_name->as_C_string();
+    if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
+      _is_declared_atomic = true;
+    }
+  }
+
+  // Set ik->invalid_inline_super field to TRUE if already marked as invalid,
+  // if super is marked invalid, or if is_invalid_super_for_inline_type()
+  // returns true
+  if (invalid_inline_super() ||
+      (_super_klass != NULL && _super_klass->invalid_inline_super()) ||
+      is_invalid_super_for_inline_type()) {
+    set_invalid_inline_super();
   }
 
+  if (!is_inline_type() && invalid_inline_super() && (_super_klass == NULL || !_super_klass->invalid_inline_super())
+      && !_implements_identityObject && class_name() != vmSymbols::java_lang_IdentityObject()) {
+    _temp_local_interfaces->append(SystemDictionary::IdentityObject_klass());
+    _has_injected_identityObject = true;
+  }
+  int itfs_len = _temp_local_interfaces->length();
+  if (itfs_len == 0) {
+    _local_interfaces = Universe::the_empty_instance_klass_array();
+  } else if (itfs_len == 1 && _temp_local_interfaces->at(0) == SystemDictionary::IdentityObject_klass()) {
+    _local_interfaces = Universe::the_single_IdentityObject_klass_array();
+  } else {
+    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, NULL, CHECK);
+    for (int i = 0; i < itfs_len; i++) {
+      _local_interfaces->at_put(i, _temp_local_interfaces->at(i));
+    }
+  }
+  _temp_local_interfaces = NULL;
+  assert(_local_interfaces != NULL, "invariant");
+
   // Compute the transitive list of all unique interfaces implemented by this class
   _transitive_interfaces =
     compute_transitive_interfaces(_super_klass,
                                   _local_interfaces,
                                   _loader_data,
@@ -6659,28 +7269,46 @@
                                                     _class_name,
                                                     _local_interfaces,
                                                     CHECK);
 
   // Size of Java itable (in words)
-  _itable_size = _access_flags.is_interface() ? 0 :
+  _itable_size = is_interface() ? 0 :
     klassItable::compute_itable_size(_transitive_interfaces);
 
   assert(_fac != NULL, "invariant");
   assert(_parsed_annotations != NULL, "invariant");
 
+
+  for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
+    if (Signature::basic_type(fs.signature()) == T_VALUETYPE  && !fs.access_flags().is_static()) {
+      // Pre-load inline class
+      Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&fs,
+          Handle(THREAD, _loader_data->class_loader()),
+          _protection_domain, true, CHECK);
+      assert(klass != NULL, "Sanity check");
+      assert(klass->access_flags().is_inline_type(), "Value type expected");
+    }
+  }
+
   _field_info = new FieldLayoutInfo();
   if (UseNewFieldLayout) {
     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
-                          _parsed_annotations->is_contended(), _field_info);
-    lb.build_layout();
+        _parsed_annotations->is_contended(), is_inline_type(),
+        loader_data(), _protection_domain, _field_info);
+    lb.build_layout(CHECK);
+    if (is_inline_type()) {
+      _alignment = lb.get_alignment();
+      _first_field_offset = lb.get_first_field_offset();
+      _exact_size_in_bytes = lb.get_exact_size_in_byte();
+    }
   } else {
     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
   }
+  _has_inline_type_fields = _field_info->_has_inline_fields;
 
-  // Compute reference typ
+  // Compute reference type
   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass->reference_type();
-
 }
 
 void ClassFileParser::set_klass(InstanceKlass* klass) {
 
 #ifdef ASSERT
@@ -6708,10 +7336,11 @@
 const ClassFileStream* ClassFileParser::clone_stream() const {
   assert(_stream != NULL, "invariant");
 
   return _stream->clone();
 }
+
 // ----------------------------------------------------------------------------
 // debugging
 
 #ifdef ASSERT
 
diff a/src/hotspot/share/classfile/classLoader.cpp b/src/hotspot/share/classfile/classLoader.cpp
--- a/src/hotspot/share/classfile/classLoader.cpp
+++ b/src/hotspot/share/classfile/classLoader.cpp
@@ -200,11 +200,11 @@
 
     // Fully qualified class names should not contain a 'L'.
     // Set bad_class_name to true to indicate that the package name
     // could not be obtained due to an error condition.
     // In this situation, is_same_class_package returns false.
-    if (*start == JVM_SIGNATURE_CLASS) {
+    if (*start == JVM_SIGNATURE_CLASS || *start == JVM_SIGNATURE_INLINE_TYPE) {
       if (bad_class_name != NULL) {
         *bad_class_name = true;
       }
       return NULL;
     }
diff a/src/hotspot/share/classfile/systemDictionary.cpp b/src/hotspot/share/classfile/systemDictionary.cpp
--- a/src/hotspot/share/classfile/systemDictionary.cpp
+++ b/src/hotspot/share/classfile/systemDictionary.cpp
@@ -56,10 +56,11 @@
 #include "memory/metaspaceClosure.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/access.inline.hpp"
+#include "oops/fieldStreams.inline.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/instanceRefKlass.hpp"
 #include "oops/klass.inline.hpp"
 #include "oops/method.inline.hpp"
 #include "oops/methodData.hpp"
@@ -67,18 +68,20 @@
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/oopHandle.inline.hpp"
 #include "oops/symbol.hpp"
 #include "oops/typeArrayKlass.hpp"
+#include "oops/valueKlass.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/methodHandles.hpp"
 #include "runtime/arguments.hpp"
 #include "runtime/biasedLocking.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/java.hpp"
 #include "runtime/javaCalls.hpp"
 #include "runtime/mutexLocker.hpp"
+#include "runtime/os.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/signature.hpp"
 #include "services/classLoadingService.hpp"
 #include "services/diagnosticCommand.hpp"
 #include "services/threadService.hpp"
@@ -322,11 +325,11 @@
                                                                        Handle protection_domain,
                                                                        TRAPS) {
   assert(class_name != NULL && !Signature::is_array(class_name), "must be");
   if (Signature::has_envelope(class_name)) {
     ResourceMark rm(THREAD);
-    // Ignore wrapping L and ;.
+    // Ignore wrapping L and ;. (and Q and ; for value types);
     TempNewSymbol name = SymbolTable::new_symbol(class_name->as_C_string() + 1,
                                                  class_name->utf8_length() - 2);
     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
   } else {
     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
@@ -363,11 +366,10 @@
     k = TypeArrayKlass::cast(k)->array_klass(ndims, CHECK_NULL);
   }
   return k;
 }
 
-
 // Must be called for any super-class or super-interface resolution
 // during class definition to allow class circularity checking
 // super-interface callers:
 //    parse_interfaces - for defineClass & jvmtiRedefineClasses
 // super-class callers:
@@ -507,10 +509,55 @@
   }
 
   return superk;
 }
 
+Klass* SystemDictionary::resolve_inline_type_field_or_fail(AllFieldStream* fs,
+                                                           Handle class_loader,
+                                                           Handle protection_domain,
+                                                           bool throw_error,
+                                                           TRAPS) {
+  Symbol* class_name = fs->signature()->fundamental_name(THREAD);
+  class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
+  ClassLoaderData* loader_data = class_loader_data(class_loader);
+  unsigned int p_hash = placeholders()->compute_hash(class_name);
+  int p_index = placeholders()->hash_to_index(p_hash);
+  bool throw_circularity_error = false;
+  PlaceholderEntry* oldprobe;
+
+  {
+    MutexLocker mu(THREAD, SystemDictionary_lock);
+    oldprobe = placeholders()->get_entry(p_index, p_hash, class_name, loader_data);
+    if (oldprobe != NULL &&
+      oldprobe->check_seen_thread(THREAD, PlaceholderTable::INLINE_TYPE_FIELD)) {
+      throw_circularity_error = true;
+
+    } else {
+      placeholders()->find_and_add(p_index, p_hash, class_name, loader_data,
+                                   PlaceholderTable::INLINE_TYPE_FIELD, NULL, THREAD);
+    }
+  }
+
+  Klass* klass = NULL;
+  if (!throw_circularity_error) {
+    klass = SystemDictionary::resolve_or_fail(class_name, class_loader,
+                                               protection_domain, true, THREAD);
+  } else {
+    ResourceMark rm(THREAD);
+    THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name->as_C_string());
+  }
+
+  {
+    MutexLocker mu(THREAD, SystemDictionary_lock);
+    placeholders()->find_and_remove(p_index, p_hash, class_name, loader_data,
+                                    PlaceholderTable::INLINE_TYPE_FIELD, THREAD);
+  }
+
+  class_name->decrement_refcount();
+  return klass;
+}
+
 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
                                                   Handle class_loader,
                                                   Handle protection_domain,
                                                   TRAPS) {
   // Now we have to call back to java to check if the initating class has access
@@ -1035,11 +1082,11 @@
     // dimension and object_key in FieldArrayInfo are assigned as a
     // side-effect of this call
     SignatureStream ss(class_name, false);
     int ndims = ss.skip_array_prefix();  // skip all '['s
     BasicType t = ss.type();
-    if (t != T_OBJECT) {
+    if (t != T_OBJECT && t != T_VALUETYPE) {
       k = Universe::typeArrayKlassObj(t);
     } else {
       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
     }
     if (k != NULL) {
@@ -2345,11 +2392,11 @@
     // For array classes, their Klass*s are not kept in the
     // constraint table. The element Klass*s are.
     SignatureStream ss(class_name, false);
     int ndims = ss.skip_array_prefix();  // skip all '['s
     BasicType t = ss.type();
-    if (t != T_OBJECT) {
+    if (t != T_OBJECT && t != T_VALUETYPE) {
       klass = Universe::typeArrayKlassObj(t);
     } else {
       MutexLocker mu(THREAD, SystemDictionary_lock);
       klass = constraints()->find_constrained_klass(ss.as_symbol(), class_loader);
     }
diff a/src/hotspot/share/classfile/systemDictionary.hpp b/src/hotspot/share/classfile/systemDictionary.hpp
--- a/src/hotspot/share/classfile/systemDictionary.hpp
+++ b/src/hotspot/share/classfile/systemDictionary.hpp
@@ -122,10 +122,11 @@
 //
 
 class BootstrapInfo;
 class ClassFileStream;
 class Dictionary;
+class AllFieldStream;
 class PlaceholderTable;
 class LoaderConstraintTable;
 template <MEMFLAGS F> class HashtableBucket;
 class ResolutionErrorTable;
 class SymbolPropertyTable;
@@ -149,10 +150,11 @@
 // of the VM start-up sequence.
 //
 #define WK_KLASSES_DO(do_klass)                                                                                 \
   /* well-known classes */                                                                                      \
   do_klass(Object_klass,                                java_lang_Object                                      ) \
+  do_klass(IdentityObject_klass,                        java_lang_IdentityObject                              ) \
   do_klass(String_klass,                                java_lang_String                                      ) \
   do_klass(Class_klass,                                 java_lang_Class                                       ) \
   do_klass(Cloneable_klass,                             java_lang_Cloneable                                   ) \
   do_klass(ClassLoader_klass,                           java_lang_ClassLoader                                 ) \
   do_klass(Serializable_klass,                          java_io_Serializable                                  ) \
@@ -219,10 +221,11 @@
   do_klass(BootstrapMethodError_klass,                  java_lang_BootstrapMethodError                        ) \
   do_klass(CallSite_klass,                              java_lang_invoke_CallSite                             ) \
   do_klass(Context_klass,                               java_lang_invoke_MethodHandleNatives_CallSiteContext  ) \
   do_klass(ConstantCallSite_klass,                      java_lang_invoke_ConstantCallSite                     ) \
   do_klass(MutableCallSite_klass,                       java_lang_invoke_MutableCallSite                      ) \
+  do_klass(ValueBootstrapMethods_klass,                 java_lang_invoke_ValueBootstrapMethods                ) \
   do_klass(VolatileCallSite_klass,                      java_lang_invoke_VolatileCallSite                     ) \
   /* Note: MethodHandle must be first, and VolatileCallSite last in group */                                    \
                                                                                                                 \
   do_klass(AssertionStatusDirectives_klass,             java_lang_AssertionStatusDirectives                   ) \
   do_klass(StringBuffer_klass,                          java_lang_StringBuffer                                ) \
@@ -265,10 +268,11 @@
   do_klass(Long_klass,                                  java_lang_Long                                        ) \
                                                                                                                 \
   /* force inline of iterators */                                                                               \
   do_klass(Iterator_klass,                              java_util_Iterator                                    ) \
                                                                                                                 \
+  do_klass(jdk_internal_vm_jni_SubElementSelector_klass, jdk_internal_vm_jni_SubElementSelector               ) \
   /* support for records */                                                                                     \
   do_klass(RecordComponent_klass,                       java_lang_reflect_RecordComponent                     ) \
                                                                                                                 \
   /*end*/
 
@@ -318,10 +322,16 @@
                                               Handle class_loader,
                                               Handle protection_domain,
                                               bool is_superclass,
                                               TRAPS);
 
+  static Klass* resolve_inline_type_field_or_fail(AllFieldStream* fs,
+                                                  Handle class_loader,
+                                                  Handle protection_domain,
+                                                  bool throw_error,
+                                                  TRAPS);
+
   // Parse new stream. This won't update the dictionary or class
   // hierarchy, simply parse the stream. Used by JVMTI RedefineClasses
   // and by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.
   static InstanceKlass* parse_stream(Symbol* class_name,
                                      Handle class_loader,
@@ -407,10 +417,11 @@
     assert(k != NULL, "klass not loaded");
     return k;
   }
 
   static bool resolve_wk_klass(WKID id, TRAPS);
+  static InstanceKlass* check_klass_ValhallaClasses(InstanceKlass* k) { return k; }
   static void resolve_wk_klasses_until(WKID limit_id, WKID &start_id, TRAPS);
   static void resolve_wk_klasses_through(WKID end_id, WKID &start_id, TRAPS) {
     int limit = (int)end_id + 1;
     resolve_wk_klasses_until((WKID) limit, start_id, THREAD);
   }
diff a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -1181,11 +1181,11 @@
 
       if (!UseJVMCINativeLibrary) {
         // Don't allow blocking compiles if inside a class initializer or while performing class loading
         vframeStream vfst((JavaThread*) thread);
         for (; !vfst.at_end(); vfst.next()) {
-          if (vfst.method()->is_static_initializer() ||
+        if (vfst.method()->is_class_initializer() ||
               (vfst.method()->method_holder()->is_subclass_of(SystemDictionary::ClassLoader_klass()) &&
                   vfst.method()->name() == vmSymbols::loadClass_name())) {
             blocking = false;
             break;
           }
diff a/src/hotspot/share/memory/dynamicArchive.cpp b/src/hotspot/share/memory/dynamicArchive.cpp
--- a/src/hotspot/share/memory/dynamicArchive.cpp
+++ b/src/hotspot/share/memory/dynamicArchive.cpp
@@ -259,16 +259,30 @@
 
       return true; // keep recursing until every object is visited exactly once.
     }
 
     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
-      assert(type == _method_entry_ref, "only special type allowed for now");
+      // TODO:CDS - JDK-8234693 will consolidate this with an almost identical method in metaspaceShared.cpp
+      assert_valid(type);
       address obj = ref->obj();
       address new_obj = _builder->get_new_loc(ref);
       size_t offset = pointer_delta(p, obj,  sizeof(u1));
       intptr_t* new_p = (intptr_t*)(new_obj + offset);
-      assert(*p == *new_p, "must be a copy");
+      switch (type) {
+      case _method_entry_ref:
+        assert(*p == *new_p, "must be a copy");
+        break;
+      case _internal_pointer_ref:
+        {
+          size_t off = pointer_delta(*((address*)p), obj, sizeof(u1));
+          assert(0 <= intx(off) && intx(off) < ref->size() * BytesPerWord, "must point to internal address");
+          *((address*)new_p) = new_obj + off;
+        }
+        break;
+      default:
+        ShouldNotReachHere();
+      }
       ArchivePtrMarker::mark_pointer((address*)new_p);
     }
   };
 
   class EmbeddedRefUpdater: public MetaspaceClosure {
@@ -791,11 +805,11 @@
 }
 
 size_t DynamicArchiveBuilder::estimate_trampoline_size() {
   size_t total = 0;
   size_t each_method_bytes =
-    align_up(SharedRuntime::trampoline_size(), BytesPerWord) +
+    align_up(SharedRuntime::trampoline_size(), BytesPerWord) * 3 +
     align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);
 
   for (int i = 0; i < _klasses->length(); i++) {
     InstanceKlass* ik = _klasses->at(i);
     Array<Method*>* methods = ik->methods();
@@ -814,15 +828,27 @@
   for (int i = 0; i < _klasses->length(); i++) {
     InstanceKlass* ik = _klasses->at(i);
     Array<Method*>* methods = ik->methods();
     for (int j = 0; j < methods->length(); j++) {
       Method* m = methods->at(j);
+
+      // TODO:CDS - JDK-8234693 will consolidate this with Method::unlink()
       address c2i_entry_trampoline = (address)p;
       p += SharedRuntime::trampoline_size();
       assert(p >= mc_space->base() && p <= mc_space->top(), "must be");
       m->set_from_compiled_entry(to_target(c2i_entry_trampoline));
 
+      address c2i_value_ro_entry_trampoline = (address)p;
+      p += SharedRuntime::trampoline_size();
+      assert(p >= mc_space->base() && p <= mc_space->top(), "must be");
+      m->set_from_compiled_value_ro_entry(to_target(c2i_value_ro_entry_trampoline));
+
+      address c2i_value_entry_trampoline = (address)p;
+      p +=  SharedRuntime::trampoline_size();
+      assert(p >= mc_space->base() && p <= mc_space->top(), "must be");
+      m->set_from_compiled_value_entry(to_target(c2i_value_entry_trampoline));
+
       AdapterHandlerEntry** adapter_trampoline =(AdapterHandlerEntry**)p;
       p += sizeof(AdapterHandlerEntry*);
       assert(p >= mc_space->base() && p <= mc_space->top(), "must be");
       *adapter_trampoline = NULL;
       m->set_adapter_trampoline(to_target(adapter_trampoline));
diff a/src/hotspot/share/memory/metaspaceShared.cpp b/src/hotspot/share/memory/metaspaceShared.cpp
--- a/src/hotspot/share/memory/metaspaceShared.cpp
+++ b/src/hotspot/share/memory/metaspaceShared.cpp
@@ -57,10 +57,12 @@
 #include "oops/methodData.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayKlass.hpp"
+#include "oops/valueArrayKlass.hpp"
+#include "oops/valueKlass.hpp"
 #include "prims/jvmtiRedefineClasses.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/os.hpp"
 #include "runtime/safepointVerifiers.hpp"
 #include "runtime/signature.hpp"
@@ -758,17 +760,19 @@
 //                  into our own tables.
 
 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
   f(ConstantPool) \
-  f(InstanceKlass) \
+  f(InstanceClassLoaderKlass) \
   f(InstanceClassLoaderKlass) \
   f(InstanceMirrorKlass) \
   f(InstanceRefKlass) \
   f(Method) \
   f(ObjArrayKlass) \
-  f(TypeArrayKlass)
+  f(TypeArrayKlass) \
+  f(ValueArrayKlass) \
+  f(ValueKlass)
 
 class CppVtableInfo {
   intptr_t _vtable_size;
   intptr_t _cloned_vtable[1];
 public:
@@ -952,11 +956,13 @@
     break;
   case MetaspaceObj::ClassType:
     {
       Klass* k = (Klass*)obj;
       assert(k->is_klass(), "must be");
-      if (k->is_instance_klass()) {
+      if (k->is_value()) {
+        kind = ValueKlass_Kind;
+      } else if (k->is_instance_klass()) {
         InstanceKlass* ik = InstanceKlass::cast(k);
         if (ik->is_class_loader_instance_klass()) {
           kind = InstanceClassLoaderKlass_Kind;
         } else if (ik->is_reference_instance_klass()) {
           kind = InstanceRefKlass_Kind;
@@ -1380,16 +1386,30 @@
       RefRelocator refer;
       ref->metaspace_pointers_do_at(&refer, new_loc);
       return true; // recurse into ref.obj()
     }
     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
-      assert(type == _method_entry_ref, "only special type allowed for now");
+      assert_valid(type);
+
       address obj = ref->obj();
       address new_obj = get_new_loc(ref);
       size_t offset = pointer_delta(p, obj,  sizeof(u1));
       intptr_t* new_p = (intptr_t*)(new_obj + offset);
-      assert(*p == *new_p, "must be a copy");
+      switch (type) {
+      case _method_entry_ref:
+        assert(*p == *new_p, "must be a copy");
+        break;
+      case _internal_pointer_ref:
+        {
+          size_t off = pointer_delta(*((address*)p), obj, sizeof(u1));
+          assert(0 <= intx(off) && intx(off) < ref->size() * BytesPerWord, "must point to internal address");
+          *((address*)new_p) = new_obj + off;
+        }
+        break;
+      default:
+        ShouldNotReachHere();
+      }
       ArchivePtrMarker::mark_pointer((address*)new_p);
     }
   };
 
   // Relocate a reference to point to its shallow copy
diff a/src/hotspot/share/oops/cpCache.cpp b/src/hotspot/share/oops/cpCache.cpp
--- a/src/hotspot/share/oops/cpCache.cpp
+++ b/src/hotspot/share/oops/cpCache.cpp
@@ -131,18 +131,23 @@
                                        int field_index,
                                        int field_offset,
                                        TosState field_type,
                                        bool is_final,
                                        bool is_volatile,
+                                       bool is_inlined,
+                                       bool is_inline_type,
                                        Klass* root_klass) {
   set_f1(field_holder);
   set_f2(field_offset);
   assert((field_index & field_index_mask) == field_index,
          "field index does not fit in low flag bits");
+  assert(!is_inlined || is_inline_type, "Sanity check");
   set_field_flags(field_type,
                   ((is_volatile ? 1 : 0) << is_volatile_shift) |
-                  ((is_final    ? 1 : 0) << is_final_shift),
+                  ((is_final    ? 1 : 0) << is_final_shift) |
+                  ((is_inlined  ? 1 : 0) << is_inlined_shift) |
+                  ((is_inline_type ? 1 : 0) << is_inline_type_shift),
                   field_index);
   set_bytecode_1(get_code);
   set_bytecode_2(put_code);
   NOT_PRODUCT(verify(tty));
 }
@@ -296,10 +301,11 @@
       // case, the method gets reresolved with caller for each interface call
       // because the actual selected method may not be public.
       //
       // We set bytecode_2() to _invokevirtual.
       // See also interpreterRuntime.cpp. (8/25/2000)
+      invoke_code = Bytecodes::_invokevirtual;
     } else {
       assert(invoke_code == Bytecodes::_invokevirtual ||
              (invoke_code == Bytecodes::_invokeinterface &&
               ((method->is_private() ||
                 (method->is_final() && method->method_holder() == SystemDictionary::Object_klass())))),
@@ -311,11 +317,11 @@
         // We set bytecode_2() to _invokevirtual.
         set_bytecode_1(invoke_code);
       }
     }
     // set up for invokevirtual, even if linking for invokeinterface also:
-    set_bytecode_2(Bytecodes::_invokevirtual);
+    set_bytecode_2(invoke_code);
   } else {
     ShouldNotReachHere();
   }
   NOT_PRODUCT(verify(tty));
 }
diff a/src/hotspot/share/oops/klassVtable.cpp b/src/hotspot/share/oops/klassVtable.cpp
--- a/src/hotspot/share/oops/klassVtable.cpp
+++ b/src/hotspot/share/oops/klassVtable.cpp
@@ -1114,13 +1114,14 @@
   guarantee(ioe->interface_klass() == NULL && ioe->offset() == 0, "terminator entry missing");
 }
 
 
 inline bool interface_method_needs_itable_index(Method* m) {
-  if (m->is_static())           return false;   // e.g., Stream.empty
-  if (m->is_initializer())      return false;   // <init> or <clinit>
-  if (m->is_private())          return false;   // uses direct call
+  if (m->is_static())             return false;   // e.g., Stream.empty
+  if (m->is_private())            return false;   // uses direct call
+  if (m->is_object_constructor()) return false;   // <init>(...)V
+  if (m->is_class_initializer())  return false;   // <clinit>()V
   // If an interface redeclares a method from java.lang.Object,
   // it should already have a vtable index, don't touch it.
   // e.g., CharSequence.toString (from initialize_vtable)
   // if (m->has_vtable_index())  return false; // NO!
   return true;
@@ -1349,10 +1350,22 @@
 class InterfaceVisiterClosure : public StackObj {
  public:
   virtual void doit(InstanceKlass* intf, int method_count) = 0;
 };
 
+int count_interface_methods_needing_itable_index(Array<Method*>* methods) {
+  int method_count = 0;
+  if (methods->length() > 0) {
+    for (int i = methods->length(); --i >= 0; ) {
+      if (interface_method_needs_itable_index(methods->at(i))) {
+        method_count++;
+      }
+    }
+  }
+  return method_count;
+}
+
 // Visit all interfaces with at least one itable method
 void visit_all_interfaces(Array<InstanceKlass*>* transitive_intf, InterfaceVisiterClosure *blk) {
   // Handle array argument
   for(int i = 0; i < transitive_intf->length(); i++) {
     InstanceKlass* intf = transitive_intf->at(i);
@@ -1417,11 +1430,11 @@
 int klassItable::compute_itable_size(Array<InstanceKlass*>* transitive_interfaces) {
   // Count no of interfaces and total number of interface methods
   CountInterfacesClosure cic;
   visit_all_interfaces(transitive_interfaces, &cic);
 
-  // There's alway an extra itable entry so we can null-terminate it.
+  // There's always an extra itable entry so we can null-terminate it.
   int itable_size = calc_itable_size(cic.nof_interfaces() + 1, cic.nof_methods());
 
   // Statistics
   update_stats(itable_size * wordSize);
 
diff a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -55,10 +55,11 @@
 #include "oops/method.hpp"
 #include "oops/recordComponent.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
+#include "oops/valueArrayKlass.hpp"
 #include "prims/jvm_misc.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/jvmtiThreadState.hpp"
 #include "prims/nativeLookup.hpp"
 #include "prims/stackwalk.hpp"
@@ -711,10 +712,11 @@
 
   // Check if class of obj supports the Cloneable interface.
   // All arrays are considered to be cloneable (See JLS 20.1.5).
   // All j.l.r.Reference classes are considered non-cloneable.
   if (!klass->is_cloneable() ||
+       klass->is_value() ||
       (klass->is_instance_klass() &&
        InstanceKlass::cast(klass)->reference_type() != REF_NONE)) {
     ResourceMark rm(THREAD);
     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass->external_name());
   }
@@ -1254,30 +1256,39 @@
 
   Klass* klass = java_lang_Class::as_Klass(mirror);
   // Figure size of result array
   int size;
   if (klass->is_instance_klass()) {
-    size = InstanceKlass::cast(klass)->local_interfaces()->length();
+    InstanceKlass* ik = InstanceKlass::cast(klass);
+    size = ik->local_interfaces()->length();
+    if (ik->has_injected_identityObject()) {
+      size--;
+    }
   } else {
     assert(klass->is_objArray_klass() || klass->is_typeArray_klass(), "Illegal mirror klass");
-    size = 2;
+    size = 3;
   }
 
   // Allocate result array
   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
   objArrayHandle result (THREAD, r);
   // Fill in result
   if (klass->is_instance_klass()) {
     // Regular instance klass, fill in all local interfaces
+    int cursor = 0;
     for (int index = 0; index < size; index++) {
-      Klass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);
-      result->obj_at_put(index, k->java_mirror());
+      InstanceKlass* ik = InstanceKlass::cast(klass);
+      Klass* k = ik->local_interfaces()->at(index);
+      if (!ik->has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {
+        result->obj_at_put(cursor++, k->java_mirror());
+      }
     }
   } else {
-    // All arrays implement java.lang.Cloneable and java.io.Serializable
+    // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject
     result->obj_at_put(0, SystemDictionary::Cloneable_klass()->java_mirror());
     result->obj_at_put(1, SystemDictionary::Serializable_klass()->java_mirror());
+    result->obj_at_put(2, SystemDictionary::IdentityObject_klass()->java_mirror());
   }
   return (jobjectArray) JNIHandles::make_local(env, result());
 JVM_END
 
 
@@ -1893,14 +1904,18 @@
   return (jobjectArray)JNIHandles::make_local(env, result);
 }
 JVM_END
 
 static bool select_method(const methodHandle& method, bool want_constructor) {
+  bool is_ctor = (method->is_object_constructor() ||
+                  method->is_static_init_factory());
   if (want_constructor) {
-    return (method->is_initializer() && !method->is_static());
+    return is_ctor;
   } else {
-    return  (!method->is_initializer() && !method->is_overpass());
+    return (!is_ctor &&
+            !method->is_class_initializer() &&
+            !method->is_overpass());
   }
 }
 
 static jobjectArray get_class_declared_methods_helper(
                                   JNIEnv *env,
@@ -1958,10 +1973,12 @@
       // Otherwise should probably put a method that throws NSME
       result->obj_at_put(i, NULL);
     } else {
       oop m;
       if (want_constructor) {
+        assert(method->is_object_constructor() ||
+               method->is_static_init_factory(), "must be");
         m = Reflection::new_constructor(method, CHECK_NULL);
       } else {
         m = Reflection::new_method(method, false, CHECK_NULL);
       }
       result->obj_at_put(i, m);
@@ -2215,14 +2232,14 @@
   methodHandle m (THREAD, k->find_method(name, sig));
   if (m.is_null()) {
     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), "Unable to look up method in target class");
   }
   oop method;
-  if (!m->is_initializer() || m->is_static()) {
-    method = Reflection::new_method(m, true, CHECK_NULL);
-  } else {
+  if (m->is_object_constructor()) {
     method = Reflection::new_constructor(m, CHECK_NULL);
+  } else {
+    method = Reflection::new_method(m, true, CHECK_NULL);
   }
   return JNIHandles::make_local(method);
 }
 
 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
@@ -2506,10 +2523,49 @@
   JvmtiVMObjectAllocEventCollector oam;
   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
   return JNIHandles::make_local(env, asd);
 JVM_END
 
+// Arrays support /////////////////////////////////////////////////////////////
+
+JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))
+  JVMWrapper("JVM_ArrayIsAccessAtomic");
+  oop o = JNIHandles::resolve(array);
+  Klass* k = o->klass();
+  if ((o == NULL) || (!k->is_array_klass())) {
+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());
+  }
+  return ArrayKlass::cast(k)->element_access_is_atomic();
+JVM_END
+
+JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))
+  JVMWrapper("JVM_ArrayEnsureAccessAtomic");
+  oop o = JNIHandles::resolve(array);
+  Klass* k = o->klass();
+  if ((o == NULL) || (!k->is_array_klass())) {
+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());
+  }
+  if (k->is_valueArray_klass()) {
+    ValueArrayKlass* vk = ValueArrayKlass::cast(k);
+    if (!vk->element_access_is_atomic()) {
+      /**
+       * Need to decide how to implement:
+       *
+       * 1) Change to objArrayOop layout, therefore oop->klass() differs so
+       * then "<atomic>[Qfoo;" klass needs to subclass "[Qfoo;" to pass through
+       * "checkcast" & "instanceof"
+       *
+       * 2) Use extra header in the valueArrayOop to flag atomicity required and
+       * possibly per instance lock structure. Said info, could be placed in
+       * "trailer" rather than disturb the current arrayOop
+       */
+      Unimplemented();
+    }
+  }
+  return array;
+JVM_END
+
 // Verification ////////////////////////////////////////////////////////////////////////////////
 
 // Reflection for the verifier /////////////////////////////////////////////////////////////////
 
 // RedefineClasses support: bug 6214132 caused verification to fail.
@@ -2685,11 +2741,11 @@
   JVMWrapper("JVM_IsConstructorIx");
   ResourceMark rm(THREAD);
   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
   Method* method = InstanceKlass::cast(k)->methods()->at(method_index);
-  return method->name() == vmSymbols::object_initializer_name();
+  return method->is_object_constructor();
 JVM_END
 
 
 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
   JVMWrapper("JVM_IsVMGeneratedMethodIx");
@@ -3680,11 +3736,11 @@
   JVMWrapper("JVM_InvokeMethod");
   Handle method_handle;
   if (thread->stack_available((address) &method_handle) >= JVMInvokeMethodSlack) {
     method_handle = Handle(THREAD, JNIHandles::resolve(method));
     Handle receiver(THREAD, JNIHandles::resolve(obj));
-    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
+    objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
     jobject res = JNIHandles::make_local(env, result);
     if (JvmtiExport::should_post_vm_object_alloc()) {
       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
       assert(ret_type != NULL, "sanity check: ret_type oop must not be NULL!");
@@ -3701,12 +3757,12 @@
 JVM_END
 
 
 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
   JVMWrapper("JVM_NewInstanceFromConstructor");
+  objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
   oop constructor_mirror = JNIHandles::resolve(c);
-  objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
   jobject res = JNIHandles::make_local(env, result);
   if (JvmtiExport::should_post_vm_object_alloc()) {
     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
   }
diff a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -2592,11 +2592,12 @@
   int id_index = (result_count - 1);
 
   for (FilteredFieldStream src_st(ik, true, true); !src_st.eos(); src_st.next()) {
     result_list[id_index--] = jfieldIDWorkaround::to_jfieldID(
                                             ik, src_st.offset(),
-                                            src_st.access_flags().is_static());
+                                            src_st.access_flags().is_static(),
+                                            src_st.field_descriptor().is_inlined());
   }
   assert(id_index == -1, "just checking");
   // Fill in the results
   *field_count_ptr = result_count;
   *fields_ptr = result_list;
diff a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
--- a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
@@ -560,12 +560,11 @@
     case JVM_CONSTANT_Invalid: // fall through
 
     // At this stage, String could be here, but not StringIndex
     case JVM_CONSTANT_StringIndex: // fall through
 
-    // At this stage JVM_CONSTANT_UnresolvedClassInError should not be
-    // here
+    // At this stage JVM_CONSTANT_UnresolvedClassInError should not be here
     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 
     default:
     {
       // leave a breadcrumb
diff a/src/hotspot/share/runtime/arguments.cpp b/src/hotspot/share/runtime/arguments.cpp
--- a/src/hotspot/share/runtime/arguments.cpp
+++ b/src/hotspot/share/runtime/arguments.cpp
@@ -2165,10 +2165,20 @@
   }
 #endif
 
   status = status && GCArguments::check_args_consistency();
 
+  if (AMD64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypePassFieldsAsArgs)) {
+    FLAG_SET_CMDLINE(InlineTypePassFieldsAsArgs, false);
+    warning("InlineTypePassFieldsAsArgs is not supported on this platform");
+  }
+
+  if (AMD64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {
+    FLAG_SET_CMDLINE(InlineTypeReturnedAsFields, false);
+    warning("InlineTypeReturnedAsFields is not supported on this platform");
+  }
+
   return status;
 }
 
 bool Arguments::is_bad_option(const JavaVMOption* option, jboolean ignore,
   const char* option_type) {
@@ -3085,10 +3095,28 @@
     } else if (is_bad_option(option, args->ignoreUnrecognized)) {
       return JNI_ERR;
     }
   }
 
+  if (EnableValhalla) {
+    // create_property("valhalla.enableValhalla", "true", InternalProperty)
+    const char* prop_name = "valhalla.enableValhalla";
+    const char* prop_value = "true";
+    const size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;
+    char* property = AllocateHeap(prop_len, mtArguments);
+    int ret = jio_snprintf(property, prop_len, "%s=%s", prop_name, prop_value);
+    if (ret < 0 || ret >= (int)prop_len) {
+      FreeHeap(property);
+      return JNI_ENOMEM;
+    }
+    bool added = add_property(property, UnwriteableProperty, InternalProperty);
+    FreeHeap(property);
+    if (!added) {
+      return JNI_ENOMEM;
+    }
+  }
+
   // PrintSharedArchiveAndExit will turn on
   //   -Xshare:on
   //   -Xlog:class+path=info
   if (PrintSharedArchiveAndExit) {
     if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {
@@ -4179,10 +4207,15 @@
   // verification is not as if both were enabled.
   if (BytecodeVerificationLocal && !BytecodeVerificationRemote) {
     log_info(verification)("Turning on remote verification because local verification is on");
     FLAG_SET_DEFAULT(BytecodeVerificationRemote, true);
   }
+  if (!EnableValhalla || (is_interpreter_only() && !is_dumping_archive())) {
+    // Disable calling convention optimizations if inline types are not supported
+    InlineTypePassFieldsAsArgs = false;
+    InlineTypeReturnedAsFields = false;
+  }
 
 #ifndef PRODUCT
   if (!LogVMOutput && FLAG_IS_DEFAULT(LogVMOutput)) {
     if (use_vm_log()) {
       LogVMOutput = true;
diff a/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java b/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
--- a/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
+++ b/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
@@ -444,11 +444,11 @@
     /**
      * Generate a class file for the proxy class.  This method drives the
      * class file generation process.
      */
     private byte[] generateClassFile() {
-        visit(V14, accessFlags, dotToSlash(className), null,
+        visit(V16, accessFlags, dotToSlash(className), null,
                 JLR_PROXY, typeNames(interfaces));
 
         /*
          * Add proxy methods for the hashCode, equals,
          * and toString methods of java.lang.Object.  This is done before
@@ -811,11 +811,15 @@
                     mv.visitInsn(DRETURN);
                 } else {
                     throw new AssertionError();
                 }
             } else {
-                mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));
+                String internalName = dotToSlash(type.getName());
+                if (type.isInlineClass()) {
+                    internalName = 'Q' + internalName + ";";
+                }
+                mv.visitTypeInsn(CHECKCAST, internalName);
                 mv.visitInsn(ARETURN);
             }
         }
 
         /**
@@ -862,13 +866,15 @@
          * =============== Code Generation Utility Methods ===============
          */
 
         /**
          * Generate code to invoke the Class.forName with the name of the given
-         * class to get its Class object at runtime.  The code is written to
-         * the supplied stream.  Note that the code generated by this method
-         * may cause the checked ClassNotFoundException to be thrown.
+         * class to get its Class object at runtime.  And also generate code
+         * to invoke Class.asPrimaryType if the class is regular value type.
+         *
+         * The code is written to the supplied stream.  Note that the code generated
+         * by this method may caused the checked ClassNotFoundException to be thrown.
          */
         private void codeClassForName(MethodVisitor mv, Class<?> cl) {
             mv.visitLdcInsn(cl.getName());
             mv.visitMethodInsn(INVOKESTATIC,
                     JL_CLASS,
diff a/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java b/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java
--- /dev/null
+++ b/src/java.base/share/classes/jdk/experimental/value/MethodHandleBuilder.java
@@ -0,0 +1,354 @@
+/*
+ * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.experimental.value;
+
+import jdk.experimental.bytecode.BytePoolHelper;
+import jdk.experimental.bytecode.BasicTypeHelper;
+import jdk.experimental.bytecode.ClassBuilder;
+import jdk.experimental.bytecode.CodeBuilder;
+import jdk.experimental.bytecode.Flag;
+import jdk.experimental.bytecode.MethodBuilder;
+import jdk.experimental.bytecode.TypeHelper;
+import jdk.experimental.bytecode.TypeTag;
+import jdk.experimental.bytecode.TypedCodeBuilder;
+import jdk.experimental.value.MethodHandleBuilder.IsolatedMethodBuilder.IsolatedMethodPoolHelper;
+import jdk.internal.misc.Unsafe;
+import sun.security.action.GetPropertyAction;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.UncheckedIOException;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.invoke.MethodType;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+/**
+ * Utility class for building method handles.
+ */
+public class MethodHandleBuilder {
+
+    static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+    public static final boolean ENABLE_POOL_PATCHES;
+    public static final String DUMP_CLASS_FILES_DIR;
+
+    static {
+        Properties props = GetPropertyAction.privilegedGetProperties();
+        ENABLE_POOL_PATCHES = Boolean.parseBoolean(
+                props.getProperty("valhalla.enablePoolPatches"));
+        DUMP_CLASS_FILES_DIR = props.getProperty("valhalla.DUMP_CLASS_FILES_DIR");
+    }
+
+    public static MethodHandle loadCode(Lookup lookup, String name, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {
+        return loadCode(lookup, name, name, type, builder);
+    }
+
+    public static MethodHandle loadCode(Lookup lookup, String className, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {
+        String descriptor = type.toMethodDescriptorString();
+        return loadCode(lookup, className, methodName, descriptor, MethodHandleCodeBuilder::new,
+                    clazz -> {
+                        try {
+                            return lookup.findStatic(clazz, methodName, MethodType.fromMethodDescriptorString(descriptor, lookup.lookupClass().getClassLoader()));
+                        } catch (ReflectiveOperationException ex) {
+                            throw new IllegalStateException(ex);
+                        }
+                    },
+                    builder);
+    }
+
+    protected static <Z, C extends CodeBuilder<Class<?>, String, byte[], ?>> Z loadCode(
+            Lookup lookup, String className, String methodName, String type,
+            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,
+            Function<Class<?>, Z> resFunc, Consumer<? super C> builder) {
+
+        IsolatedMethodBuilder isolatedMethodBuilder = new IsolatedMethodBuilder(className, lookup);
+        isolatedMethodBuilder
+                .withSuperclass(Object.class)
+                .withMajorVersion(60)
+                .withMinorVersion(0)
+                .withFlags(Flag.ACC_PUBLIC)
+                .withMethod(methodName, type, M ->
+                        M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)
+                                .withCode(builderFunc, builder));
+
+        try {
+            byte[] barr = isolatedMethodBuilder.build();
+            maybeDump(className, barr);
+            Class<?> clazz = UNSAFE.defineAnonymousClass(lookup.lookupClass(), barr, isolatedMethodBuilder.patches());
+            UNSAFE.ensureClassInitialized(clazz);
+            return resFunc.apply(clazz);
+        } catch (Throwable e) {
+             throw new IllegalStateException(e);
+        }
+    }
+
+    public static class IsolatedMethodBuilder extends ClassBuilder<Class<?>, String, IsolatedMethodBuilder> {
+
+        private static final Class<?> THIS_CLASS = new Object() { }.getClass();
+
+        public IsolatedMethodBuilder(String clazz, Lookup lookup) {
+            super(ENABLE_POOL_PATCHES ?
+                            new IsolatedMethodPatchingPoolHelper(clazz) :
+                            new IsolatedMethodPoolHelper(clazz),
+                  new IsolatedMethodTypeHelper(lookup));
+            withThisClass(THIS_CLASS);
+        }
+
+        public Class<?> thisClass() {
+            return THIS_CLASS;
+        }
+
+        Object[] patches() {
+            return ((IsolatedMethodPoolHelper)poolHelper).patches();
+        }
+
+        static String classToInternalName(Class<?> c) {
+            return c.getName().replace('.', '/');
+        }
+
+        static class IsolatedMethodTypeHelper implements TypeHelper<Class<?>, String> {
+
+            BasicTypeHelper basicTypeHelper = new BasicTypeHelper();
+            Lookup lookup;
+
+            IsolatedMethodTypeHelper(Lookup lookup) {
+                this.lookup = lookup;
+            }
+
+            @Override
+            public String elemtype(String s) {
+                return basicTypeHelper.elemtype(s);
+            }
+
+            @Override
+            public String arrayOf(String s) {
+                return basicTypeHelper.arrayOf(s);
+            }
+
+            @Override
+            public Iterator<String> parameterTypes(String s) {
+                return basicTypeHelper.parameterTypes(s);
+            }
+
+            @Override
+            public String fromTag(TypeTag tag) {
+                return basicTypeHelper.fromTag(tag);
+            }
+
+            @Override
+            public String returnType(String s) {
+                return basicTypeHelper.returnType(s);
+            }
+
+            @Override
+            public String type(Class<?> aClass) {
+                if (aClass.isArray()) {
+                    return classToInternalName(aClass);
+                } else {
+                    return (aClass.isInlineClass() ? "Q" : "L") + classToInternalName(aClass) + ";";
+                }
+            }
+
+            @Override
+            public boolean isValue(String desc) {
+                Class<?> aClass = symbol(desc);
+                return aClass != null && aClass.isInlineClass();
+            }
+
+            @Override
+            public Class<?> symbol(String desc) {
+                try {
+                    if (desc.startsWith("[")) {
+                        return Class.forName(desc.replaceAll("/", "."), true, lookup.lookupClass().getClassLoader());
+                    } else {
+                        return Class.forName(basicTypeHelper.symbol(desc).replaceAll("/", "."), true, lookup.lookupClass().getClassLoader());
+                    }
+                } catch (ReflectiveOperationException ex) {
+                    throw new AssertionError(ex);
+                }
+            }
+
+            @Override
+            public TypeTag tag(String s) {
+                return basicTypeHelper.tag(s);
+            }
+
+            @Override
+            public Class<?> symbolFrom(String s) {
+                return symbol(s);
+            }
+
+            @Override
+            public String commonSupertype(String t1, String t2) {
+                return basicTypeHelper.commonSupertype(t1, t2);
+            }
+
+            @Override
+            public String nullType() {
+                return basicTypeHelper.nullType();
+            }
+        }
+
+        static class IsolatedMethodPoolHelper extends BytePoolHelper<Class<?>, String> {
+            final String clazz;
+
+            IsolatedMethodPoolHelper(String clazz) {
+                super(c -> from(c, clazz), s->s);
+                this.clazz = clazz;
+            }
+
+            Object[] patches() {
+                return null;
+            }
+
+            static String from(Class<?> c, String clazz) {
+                return c == THIS_CLASS ? clazz.replace('.', '/')
+                                       : classToInternalName(c);
+            }
+        }
+
+        @Override
+        public byte[] build() {
+            return super.build();
+        }
+    }
+
+    static class IsolatedMethodPatchingPoolHelper extends IsolatedMethodPoolHelper {
+
+        public IsolatedMethodPatchingPoolHelper(String clazz) {
+            super(clazz);
+        }
+
+        Map<Object, CpPatch> cpPatches = new HashMap<>();
+        int cph = 0;  // for counting constant placeholders
+
+        static class CpPatch {
+
+            final int index;
+            final String placeholder;
+            final Object value;
+
+            CpPatch(int index, String placeholder, Object value) {
+                this.index = index;
+                this.placeholder = placeholder;
+                this.value = value;
+            }
+
+            public String toString() {
+                return "CpPatch/index="+index+",placeholder="+placeholder+",value="+value;
+            }
+        }
+
+        @Override
+        public int putValue(Object v) {
+            if (v instanceof String || v instanceof Integer || v instanceof Float || v instanceof Double || v instanceof Long) {
+                return super.putValue(v);
+            }
+            assert (!v.getClass().isPrimitive()) : v;
+            return patchPoolEntry(v); // CP patching support
+        }
+
+        int patchPoolEntry(Object v) {
+            String cpPlaceholder = "CONSTANT_PLACEHOLDER_" + cph++;
+            if (cpPatches.containsKey(cpPlaceholder)) {
+                throw new InternalError("observed CP placeholder twice: " + cpPlaceholder);
+            }
+            // insert placeholder in CP and remember the patch
+            int index = super.putValue(cpPlaceholder);  // TODO check if already in the constant pool
+            cpPatches.put(cpPlaceholder, new CpPatch(index, cpPlaceholder, v));
+            return index;
+        }
+
+        @Override
+        Object[] patches() {
+            int size = size();
+            Object[] res = new Object[size];
+            for (CpPatch p : cpPatches.values()) {
+                if (p.index >= size)
+                    throw new InternalError("bad cp patch index");
+                res[p.index] = p.value;
+            }
+            return res;
+        }
+
+        private static String debugString(Object arg) {
+            // @@@ Cannot crack open a MH like with InvokerByteCodeGenerator.debugString
+            return arg.toString();
+        }
+    }
+
+    public static class MethodHandleCodeBuilder<T extends MethodHandleCodeBuilder<T>> extends TypedCodeBuilder<Class<?>, String, byte[], T> {
+
+        BasicTypeHelper basicTypeHelper = new BasicTypeHelper();
+
+        public MethodHandleCodeBuilder(jdk.experimental.bytecode.MethodBuilder<Class<?>, String, byte[]> methodBuilder) {
+            super(methodBuilder);
+        }
+
+        TypeTag getTagType(String s) {
+            return basicTypeHelper.tag(s);
+        }
+
+        public T ifcmp(String s, CondKind cond, CharSequence label) {
+            return super.ifcmp(getTagType(s), cond, label);
+        }
+
+        public T return_(String s) {
+            return super.return_(getTagType(s));
+        }
+    }
+
+    static void maybeDump(final String className, final byte[] classFile) {
+        if (DUMP_CLASS_FILES_DIR != null) {
+            java.security.AccessController.doPrivileged(
+                new java.security.PrivilegedAction<>() {
+                    public Void run() {
+                        String dumpName = className.replace('.','/');
+                        Path dumpFile = Paths.get(DUMP_CLASS_FILES_DIR, dumpName + ".class");
+                        try {
+                            Files.createDirectories(dumpFile.getParent());
+                        } catch (IOException e) {
+                            throw new UncheckedIOException(e);
+                        }
+
+                        System.out.println("dump: " + dumpFile);
+                        try (OutputStream os = Files.newOutputStream(dumpFile)) {
+                            os.write(classFile);
+                        } catch (IOException ex) {
+                            throw new UncheckedIOException(ex);
+                        }
+                        return null;
+                    }
+                });
+        }
+    }
+}
diff a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
--- a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
+++ b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
@@ -175,19 +175,38 @@
      *         {@link NullPointerException}
      */
     @HotSpotIntrinsicCandidate
     public native void putInt(Object o, long offset, int x);
 
+    private static final int JVM_ACC_FIELD_INLINED = 0x00008000; // HotSpot-specific bit
+
+    /**
+     * Returns true if the given field is flattened.
+     */
+    public boolean isFlattened(Field f) {
+        return (f.getModifiers() & JVM_ACC_FIELD_INLINED) == JVM_ACC_FIELD_INLINED;
+    }
+
+    /**
+     * Returns true if the given class is a flattened array.
+     */
+    public native boolean isFlattenedArray(Class<?> arrayClass);
+
     /**
      * Fetches a reference value from a given Java variable.
+     * This method can return a reference to either an object or value
+     * or a null reference.
+     *
      * @see #getInt(Object, long)
      */
     @HotSpotIntrinsicCandidate
     public native Object getReference(Object o, long offset);
 
     /**
      * Stores a reference value into a given Java variable.
+     * This method can store a reference to either an object or value
+     * or a null reference.
      * <p>
      * Unless the reference {@code x} being stored is either null
      * or matches the field type, the results are undefined.
      * If the reference {@code o} is non-null, card marks or
      * other store barriers for that object (if the VM requires them)
@@ -195,10 +214,111 @@
      * @see #putInt(Object, long, int)
      */
     @HotSpotIntrinsicCandidate
     public native void putReference(Object o, long offset, Object x);
 
+    /**
+     * Fetches a value of type {@code <V>} from a given Java variable.
+     * More specifically, fetches a field or array element within the given
+     * {@code o} object at the given offset, or (if {@code o} is null)
+     * from the memory address whose numerical value is the given offset.
+     *
+     * @param o Java heap object in which the variable resides, if any, else
+     *        null
+     * @param offset indication of where the variable resides in a Java heap
+     *        object, if any, else a memory address locating the variable
+     *        statically
+     * @param vc inline class
+     * @param <V> the type of a value
+     * @return the value fetched from the indicated Java variable
+     * @throws RuntimeException No defined exceptions are thrown, not even
+     *         {@link NullPointerException}
+     */
+    @HotSpotIntrinsicCandidate
+    public native <V> V getValue(Object o, long offset, Class<?> vc);
+
+    /**
+     * Stores the given value into a given Java variable.
+     *
+     * Unless the reference {@code o} being stored is either null
+     * or matches the field type, the results are undefined.
+     *
+     * @param o Java heap object in which the variable resides, if any, else
+     *        null
+     * @param offset indication of where the variable resides in a Java heap
+     *        object, if any, else a memory address locating the variable
+     *        statically
+     * @param vc inline class
+     * @param v the value to store into the indicated Java variable
+     * @param <V> the type of a value
+     * @throws RuntimeException No defined exceptions are thrown, not even
+     *         {@link NullPointerException}
+     */
+    @HotSpotIntrinsicCandidate
+    public native <V> void putValue(Object o, long offset, Class<?> vc, V v);
+
+    /**
+     * Fetches a reference value of type {@code vc} from a given Java variable.
+     * This method can return a reference to a value or a null reference
+     * for a nullable-projection of an inline type.
+     *
+     * @param vc inline class
+     */
+    public Object getReference(Object o, long offset, Class<?> vc) {
+        Object ref = getReference(o, offset);
+        if (ref == null && vc.isInlineClass()) {
+            // If the type of the returned reference is a regular inline type
+            // return an uninitialized default value if null
+            ref = uninitializedDefaultValue(vc);
+        }
+        return ref;
+    }
+
+    public Object getReferenceVolatile(Object o, long offset, Class<?> vc) {
+        Object ref = getReferenceVolatile(o, offset);
+        if (ref == null && vc.isInlineClass()) {
+            // If the type of the returned reference is a regular inline type
+            // return an uninitialized default value if null
+            ref = uninitializedDefaultValue(vc);
+        }
+        return ref;
+    }
+
+    /**
+     * Returns an uninitialized default value of the given inline class.
+     */
+    public native <V> V uninitializedDefaultValue(Class<?> vc);
+
+    /**
+     * Returns an object instance with a private buffered value whose layout
+     * and contents is exactly the given value instance.  The return object
+     * is in the larval state that can be updated using the unsafe put operation.
+     *
+     * @param value a value instance
+     * @param <V> the type of the given value instance
+     */
+    @HotSpotIntrinsicCandidate
+    public native <V> V makePrivateBuffer(V value);
+
+    /**
+     * Exits the larval state and returns a value instance.
+     *
+     * @param value a value instance
+     * @param <V> the type of the given value instance
+     */
+    @HotSpotIntrinsicCandidate
+    public native <V> V finishPrivateBuffer(V value);
+
+    /**
+     * Returns the header size of the given inline class
+     *
+     * @param vc inline class
+     * @param <V> value clas
+     * @return the header size of the inline class
+     */
+    public native <V> long valueHeaderSize(Class<V> vc);
+
     /** @see #getInt(Object, long) */
     @HotSpotIntrinsicCandidate
     public native boolean getBoolean(Object o, long offset);
 
     /** @see #putInt(Object, long, int) */
@@ -1227,10 +1347,21 @@
         }
 
         return arrayIndexScale0(arrayClass);
     }
 
+    /**
+     * Return the size of the object in the heap.
+     * @param o an object
+     * @return the objects's size
+     * @since Valhalla
+     */
+    public long getObjectSize(Object o) {
+        if (o == null)
+            throw new NullPointerException();
+        return getObjectSize0(o);
+    }
 
     /** The value of {@code arrayIndexScale(boolean[].class)} */
     public static final int ARRAY_BOOLEAN_INDEX_SCALE
             = theUnsafe.arrayIndexScale(boolean[].class);
 
@@ -1432,57 +1563,241 @@
     @HotSpotIntrinsicCandidate
     public final native boolean compareAndSetReference(Object o, long offset,
                                                        Object expected,
                                                        Object x);
 
+    private final boolean isInlineType(Object o) {
+        return o != null && o.getClass().isInlineClass();
+    }
+
+    /*
+     * For inline type, CAS should do substitutability test as opposed
+     * to two pointers comparison.
+     *
+     * Perhaps we can keep the xxxObject methods for compatibility and
+     * change the JDK 13 xxxReference method signature freely.
+     */
+    public final <V> boolean compareAndSetReference(Object o, long offset,
+                                                    Class<?> valueType,
+                                                    V expected,
+                                                    V x) {
+        if (valueType.isInlineClass() || isInlineType(expected)) {
+            synchronized (valueLock) {
+                Object witness = getReference(o, offset);
+                if (witness == expected) {
+                    putReference(o, offset, x);
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        } else {
+            return compareAndSetReference(o, offset, expected, x);
+        }
+    }
+
+    @ForceInline
+    public final <V> boolean compareAndSetValue(Object o, long offset,
+                                                Class<?> valueType,
+                                                V expected,
+                                                V x) {
+        synchronized (valueLock) {
+            Object witness = getValue(o, offset, valueType);
+            if (witness == expected) {
+                putValue(o, offset, valueType, x);
+                return true;
+            }
+            else {
+                return false;
+            }
+        }
+    }
+
     @HotSpotIntrinsicCandidate
     public final native Object compareAndExchangeReference(Object o, long offset,
                                                            Object expected,
                                                            Object x);
 
+    public final <V> Object compareAndExchangeReference(Object o, long offset,
+                                                        Class<?> valueType,
+                                                        V expected,
+                                                        V x) {
+        if (valueType.isInlineClass() || isInlineType(expected)) {
+            synchronized (valueLock) {
+                Object witness = getReference(o, offset);
+                if (witness == expected) {
+                    putReference(o, offset, x);
+                }
+                return witness;
+            }
+        } else {
+            return compareAndExchangeReference(o, offset, expected, x);
+        }
+    }
+
+    @ForceInline
+    public final <V> Object compareAndExchangeValue(Object o, long offset,
+                                                    Class<?> valueType,
+                                                    V expected,
+                                                    V x) {
+        synchronized (valueLock) {
+            Object witness = getValue(o, offset, valueType);
+            if (witness == expected) {
+                putValue(o, offset, valueType, x);
+            }
+            return witness;
+        }
+    }
+
     @HotSpotIntrinsicCandidate
     public final Object compareAndExchangeReferenceAcquire(Object o, long offset,
                                                            Object expected,
                                                            Object x) {
         return compareAndExchangeReference(o, offset, expected, x);
     }
 
+    public final <V> Object compareAndExchangeReferenceAcquire(Object o, long offset,
+                                                               Class<?> valueType,
+                                                               V expected,
+                                                               V x) {
+        return compareAndExchangeReference(o, offset, valueType, expected, x);
+    }
+
+    @ForceInline
+    public final <V> Object compareAndExchangeValueAcquire(Object o, long offset,
+                                                           Class<?> valueType,
+                                                           V expected,
+                                                           V x) {
+        return compareAndExchangeValue(o, offset, valueType, expected, x);
+    }
+
     @HotSpotIntrinsicCandidate
     public final Object compareAndExchangeReferenceRelease(Object o, long offset,
                                                            Object expected,
                                                            Object x) {
         return compareAndExchangeReference(o, offset, expected, x);
     }
 
+    public final <V> Object compareAndExchangeReferenceRelease(Object o, long offset,
+                                                               Class<?> valueType,
+                                                               V expected,
+                                                               V x) {
+        return compareAndExchangeReference(o, offset, valueType, expected, x);
+    }
+
+    @ForceInline
+    public final <V> Object compareAndExchangeValueRelease(Object o, long offset,
+                                                           Class<?> valueType,
+                                                           V expected,
+                                                           V x) {
+        return compareAndExchangeValue(o, offset, valueType, expected, x);
+    }
+
     @HotSpotIntrinsicCandidate
     public final boolean weakCompareAndSetReferencePlain(Object o, long offset,
                                                          Object expected,
                                                          Object x) {
         return compareAndSetReference(o, offset, expected, x);
     }
 
+    public final <V> boolean weakCompareAndSetReferencePlain(Object o, long offset,
+                                                             Class<?> valueType,
+                                                             V expected,
+                                                             V x) {
+        if (valueType.isInlineClass() || isInlineType(expected)) {
+            return compareAndSetReference(o, offset, valueType, expected, x);
+        } else {
+            return weakCompareAndSetReferencePlain(o, offset, expected, x);
+        }
+    }
+
+    @ForceInline
+    public final <V> boolean weakCompareAndSetValuePlain(Object o, long offset,
+                                                         Class<?> valueType,
+                                                         V expected,
+                                                         V x) {
+        return compareAndSetValue(o, offset, valueType, expected, x);
+    }
+
     @HotSpotIntrinsicCandidate
     public final boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
                                                            Object expected,
                                                            Object x) {
         return compareAndSetReference(o, offset, expected, x);
     }
 
+    public final <V> boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
+                                                               Class<?> valueType,
+                                                               V expected,
+                                                               V x) {
+        if (valueType.isInlineClass() || isInlineType(expected)) {
+            return compareAndSetReference(o, offset, valueType, expected, x);
+        } else {
+            return weakCompareAndSetReferencePlain(o, offset, expected, x);
+        }
+    }
+
+    @ForceInline
+    public final <V> boolean weakCompareAndSetValueAcquire(Object o, long offset,
+                                                           Class<?> valueType,
+                                                           V expected,
+                                                           V x) {
+        return compareAndSetValue(o, offset, valueType, expected, x);
+    }
+
     @HotSpotIntrinsicCandidate
     public final boolean weakCompareAndSetReferenceRelease(Object o, long offset,
                                                            Object expected,
                                                            Object x) {
         return compareAndSetReference(o, offset, expected, x);
     }
 
+    public final <V> boolean weakCompareAndSetReferenceRelease(Object o, long offset,
+                                                               Class<?> valueType,
+                                                               V expected,
+                                                               V x) {
+        if (valueType.isInlineClass() || isInlineType(expected)) {
+            return compareAndSetReference(o, offset, valueType, expected, x);
+        } else {
+            return weakCompareAndSetReferencePlain(o, offset, expected, x);
+        }
+    }
+
+    @ForceInline
+    public final <V> boolean weakCompareAndSetValueRelease(Object o, long offset,
+                                                           Class<?> valueType,
+                                                           V expected,
+                                                           V x) {
+        return compareAndSetValue(o, offset, valueType, expected, x);
+    }
+
     @HotSpotIntrinsicCandidate
     public final boolean weakCompareAndSetReference(Object o, long offset,
                                                     Object expected,
                                                     Object x) {
         return compareAndSetReference(o, offset, expected, x);
     }
 
+    public final <V> boolean weakCompareAndSetReference(Object o, long offset,
+                                                        Class<?> valueType,
+                                                        V expected,
+                                                        V x) {
+        if (valueType.isInlineClass() || isInlineType(expected)) {
+            return compareAndSetReference(o, offset, valueType, expected, x);
+        } else {
+            return weakCompareAndSetReferencePlain(o, offset, expected, x);
+        }
+    }
+
+    @ForceInline
+    public final <V> boolean weakCompareAndSetValue(Object o, long offset,
+                                                    Class<?> valueType,
+                                                    V expected,
+                                                    V x) {
+        return compareAndSetValue(o, offset, valueType, expected, x);
+    }
+
     /**
      * Atomically updates Java variable to {@code x} if it is currently
      * holding {@code expected}.
      *
      * <p>This operation has memory semantics of a {@code volatile} read
@@ -2094,17 +2409,36 @@
      * load semantics. Otherwise identical to {@link #getReference(Object, long)}
      */
     @HotSpotIntrinsicCandidate
     public native Object getReferenceVolatile(Object o, long offset);
 
+    /**
+     * Global lock for atomic and volatile strength access to any value of
+     * an inline type.  This is a temporary workaround until better localized
+     * atomic access mechanisms are supported for inline types.
+     */
+    private static final Object valueLock = new Object();
+
+    public final <V> Object getValueVolatile(Object base, long offset, Class<?> valueType) {
+        synchronized (valueLock) {
+            return getValue(base, offset, valueType);
+        }
+    }
+
     /**
      * Stores a reference value into a given Java variable, with
      * volatile store semantics. Otherwise identical to {@link #putReference(Object, long, Object)}
      */
     @HotSpotIntrinsicCandidate
     public native void putReferenceVolatile(Object o, long offset, Object x);
 
+    public final <V> void putValueVolatile(Object o, long offset, Class<?> valueType, V x) {
+        synchronized (valueLock) {
+            putValue(o, offset, valueType, x);
+        }
+    }
+
     /** Volatile version of {@link #getInt(Object, long)}  */
     @HotSpotIntrinsicCandidate
     public native int     getIntVolatile(Object o, long offset);
 
     /** Volatile version of {@link #putInt(Object, long, int)}  */
@@ -2173,10 +2507,14 @@
     @HotSpotIntrinsicCandidate
     public final Object getReferenceAcquire(Object o, long offset) {
         return getReferenceVolatile(o, offset);
     }
 
+    public final <V> Object getValueAcquire(Object base, long offset, Class<?> valueType) {
+        return getValueVolatile(base, offset, valueType);
+    }
+
     /** Acquire version of {@link #getBooleanVolatile(Object, long)} */
     @HotSpotIntrinsicCandidate
     public final boolean getBooleanAcquire(Object o, long offset) {
         return getBooleanVolatile(o, offset);
     }
@@ -2237,10 +2575,14 @@
     @HotSpotIntrinsicCandidate
     public final void putReferenceRelease(Object o, long offset, Object x) {
         putReferenceVolatile(o, offset, x);
     }
 
+    public final <V> void putValueRelease(Object o, long offset, Class<?> valueType, V x) {
+        putValueVolatile(o, offset, valueType, x);
+    }
+
     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
     @HotSpotIntrinsicCandidate
     public final void putBooleanRelease(Object o, long offset, boolean x) {
         putBooleanVolatile(o, offset, x);
     }
@@ -2293,10 +2635,14 @@
     @HotSpotIntrinsicCandidate
     public final Object getReferenceOpaque(Object o, long offset) {
         return getReferenceVolatile(o, offset);
     }
 
+    public final <V> Object getValueOpaque(Object base, long offset, Class<?> valueType) {
+        return getValueVolatile(base, offset, valueType);
+    }
+
     /** Opaque version of {@link #getBooleanVolatile(Object, long)} */
     @HotSpotIntrinsicCandidate
     public final boolean getBooleanOpaque(Object o, long offset) {
         return getBooleanVolatile(o, offset);
     }
@@ -2347,10 +2693,14 @@
     @HotSpotIntrinsicCandidate
     public final void putReferenceOpaque(Object o, long offset, Object x) {
         putReferenceVolatile(o, offset, x);
     }
 
+    public final <V> void putValueOpaque(Object o, long offset, Class<?> valueType, V x) {
+        putValueVolatile(o, offset, valueType, x);
+    }
+
     /** Opaque version of {@link #putBooleanVolatile(Object, long, boolean)} */
     @HotSpotIntrinsicCandidate
     public final void putBooleanOpaque(Object o, long offset, boolean x) {
         putBooleanVolatile(o, offset, x);
     }
@@ -2781,28 +3131,47 @@
             v = getReferenceVolatile(o, offset);
         } while (!weakCompareAndSetReference(o, offset, v, newValue));
         return v;
     }
 
+    @SuppressWarnings("unchecked")
+    public final <V> Object getAndSetValue(Object o, long offset, Class<?> valueType, V newValue) {
+        synchronized (valueLock) {
+            Object oldValue = getValue(o, offset, valueType);
+            putValue(o, offset, valueType, newValue);
+            return oldValue;
+        }
+    }
+
     @ForceInline
     public final Object getAndSetReferenceRelease(Object o, long offset, Object newValue) {
         Object v;
         do {
             v = getReference(o, offset);
         } while (!weakCompareAndSetReferenceRelease(o, offset, v, newValue));
         return v;
     }
 
+    @ForceInline
+    public final <V> Object getAndSetValueRelease(Object o, long offset, Class<?> valueType, V newValue) {
+        return getAndSetValue(o, offset, valueType, newValue);
+    }
+
     @ForceInline
     public final Object getAndSetReferenceAcquire(Object o, long offset, Object newValue) {
         Object v;
         do {
             v = getReferenceAcquire(o, offset);
         } while (!weakCompareAndSetReferenceAcquire(o, offset, v, newValue));
         return v;
     }
 
+    @ForceInline
+    public final <V> Object getAndSetValueAcquire(Object o, long offset, Class<?> valueType, V newValue) {
+        return getAndSetValue(o, offset, valueType, newValue);
+    }
+
     @HotSpotIntrinsicCandidate
     public final byte getAndSetByte(Object o, long offset, byte newValue) {
         byte v;
         do {
             v = getByteVolatile(o, offset);
@@ -3843,10 +4212,11 @@
     private native Object staticFieldBase0(Field f);
     private native boolean shouldBeInitialized0(Class<?> c);
     private native void ensureClassInitialized0(Class<?> c);
     private native int arrayBaseOffset0(Class<?> arrayClass);
     private native int arrayIndexScale0(Class<?> arrayClass);
+    private native long getObjectSize0(Object o);
     private native Class<?> defineAnonymousClass0(Class<?> hostClass, byte[] data, Object[] cpPatches);
     private native int getLoadAverage0(double[] loadavg, int nelems);
 
 
     /**
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
@@ -1823,10 +1823,12 @@
                 case Constants.LDC2_W:
                 case Opcodes.GETSTATIC:
                 case Opcodes.PUTSTATIC:
                 case Opcodes.GETFIELD:
                 case Opcodes.PUTFIELD:
+                case Opcodes.DEFAULT:
+                case Opcodes.WITHFIELD:
                 case Opcodes.INVOKEVIRTUAL:
                 case Opcodes.INVOKESPECIAL:
                 case Opcodes.INVOKESTATIC:
                 case Opcodes.NEW:
                 case Opcodes.ANEWARRAY:
@@ -2435,22 +2437,23 @@
                 case Opcodes.PUTFIELD:
                 case Opcodes.INVOKEVIRTUAL:
                 case Opcodes.INVOKESPECIAL:
                 case Opcodes.INVOKESTATIC:
                 case Opcodes.INVOKEINTERFACE:
+                case Opcodes.WITHFIELD:
                     {
                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
                         String owner = readClass(cpInfoOffset, charBuffer);
                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
-                        if (opcode < Opcodes.INVOKEVIRTUAL) {
-                            methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);
-                        } else {
+                        if (opcode >= Opcodes.INVOKEVIRTUAL && opcode <= Opcodes.INVOKEINTERFACE) {
                             boolean isInterface =
                                     classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
                             methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+                        } else {
+                            methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);
                         }
                         if (opcode == Opcodes.INVOKEINTERFACE) {
                             currentOffset += 5;
                         } else {
                             currentOffset += 3;
@@ -2481,10 +2484,11 @@
                     }
                 case Opcodes.NEW:
                 case Opcodes.ANEWARRAY:
                 case Opcodes.CHECKCAST:
                 case Opcodes.INSTANCEOF:
+                case Opcodes.DEFAULT:
                     methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));
                     currentOffset += 3;
                     break;
                 case Opcodes.IINC:
                     methodVisitor.visitIincInsn(
@@ -3232,11 +3236,12 @@
                     break;
                 case '[':
                     while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {
                         ++currentMethodDescritorOffset;
                     }
-                    if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {
+                    char descType = methodDescriptor.charAt(currentMethodDescritorOffset);
+                    if (descType == 'L' || descType == 'Q') {
                         ++currentMethodDescritorOffset;
                         while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {
                             ++currentMethodDescritorOffset;
                         }
                     }
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
@@ -584,6 +584,8 @@
     int MONITORENTER = 194; // visitInsn
     int MONITOREXIT = 195; // -
     int MULTIANEWARRAY = 197; // visitMultiANewArrayInsn
     int IFNULL = 198; // visitJumpInsn
     int IFNONNULL = 199; // -
+    int DEFAULT = 203; // visitTypeInsn
+    int WITHFIELD = 204; // visitFieldInsn
 }
diff a/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java b/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java
@@ -1127,10 +1127,12 @@
     private boolean isSynthetic() {
         switch (env.currElement.getKind()) {
             case CONSTRUCTOR:
                 // A synthetic default constructor has the same pos as the
                 // enclosing class
+            case METHOD:
+                // Ditto for a synthetic method injected by the compiler (for value types)
                 TreePath p = env.currPath;
                 return env.getPos(p) == env.getPos(p.getParentPath());
         }
         return false;
     }
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Source.java
@@ -215,10 +215,11 @@
         SWITCH_EXPRESSION(JDK14, Fragments.FeatureSwitchExpressions, DiagKind.PLURAL),
         TEXT_BLOCKS(JDK15, Fragments.FeatureTextBlocks, DiagKind.PLURAL),
         PATTERN_MATCHING_IN_INSTANCEOF(JDK16, Fragments.FeaturePatternMatchingInstanceof, DiagKind.NORMAL),
         REIFIABLE_TYPES_INSTANCEOF(JDK16, Fragments.FeatureReifiableTypesInstanceof, DiagKind.PLURAL),
         RECORDS(JDK16, Fragments.FeatureRecords, DiagKind.PLURAL),
+        INLINE_TYPES(JDK16, Fragments.FeatureInlineType, DiagKind.NORMAL),
         SEALED_CLASSES(JDK16, Fragments.FeatureSealedClasses, DiagKind.PLURAL),
         ;
 
         enum DiagKind {
             NORMAL,
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java
@@ -45,11 +45,11 @@
  *  </pre>
  *  <p>The type syntax in signatures is extended as follows:
  *  <pre>{@literal
  *     type       ::= ... | classtype | methodtype | typevar
  *     classtype  ::= classsig { '.' classsig }
- *     classig    ::= 'L' name [typeargs] ';'
+ *     classig    ::= 'L' name [typeargs] ';' | 'Q' name [typeargs] ';'
  *     methodtype ::= [ typeparams ] '(' { type } ')' type
  *     typevar    ::= 'T' name ';'
  *     typeargs   ::= '<' type { type } '>'
  *     typeparams ::= '<' typeparam { typeparam } '>'
  *     typeparam  ::= name ':' type
diff a/test/hotspot/jtreg/ProblemList.txt b/test/hotspot/jtreg/ProblemList.txt
--- a/test/hotspot/jtreg/ProblemList.txt
+++ b/test/hotspot/jtreg/ProblemList.txt
@@ -66,10 +66,87 @@
 compiler/rtm/locking/TestRTMSpinLoopCount.java 8183263 generic-x64
 compiler/rtm/locking/TestUseRTMDeopt.java 8183263 generic-x64
 compiler/rtm/locking/TestUseRTMXendForLockBusy.java 8183263 generic-x64
 compiler/rtm/print/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64
 
+# Valhalla
+compiler/arguments/CheckCICompilerCount.java                        8205030 generic-all
+compiler/arguments/CheckCompileThresholdScaling.java                8205030 generic-all
+compiler/codecache/CheckSegmentedCodeCache.java                     8205030 generic-all
+compiler/codecache/cli/TestSegmentedCodeCacheOption.java            8205030 generic-all
+compiler/codecache/cli/codeheapsize/TestCodeHeapSizeOptions.java    8205030 generic-all
+compiler/codecache/cli/printcodecache/TestPrintCodeCacheOption.java 8205030 generic-all
+compiler/whitebox/OSRFailureLevel4Test.java                         8205030 generic-all
+
+compiler/aot/cli/DisabledAOTWithLibraryTest.java 8226295 generic-all
+compiler/aot/cli/SingleAOTOptionTest.java 8226295 generic-all
+compiler/aot/cli/MultipleAOTLibraryTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/CompileClassWithDebugTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/CompileModuleTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/AtFileTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/ListOptionWrongFileTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/ClasspathOptionUnknownClassTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/CompileDirectoryTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/ListOptionTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/ListOptionNotExistingTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/CompileClassTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/CompileJarTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/IgnoreErrorsTest.java 8226295 generic-all
+compiler/aot/cli/jaotc/CompileAbsoluteDirectoryTest.java 8226295 generic-all
+compiler/aot/cli/NonExistingAOTLibraryTest.java 8226295 generic-all
+compiler/aot/cli/SingleAOTLibraryTest.java 8226295 generic-all
+compiler/aot/cli/IncorrectAOTLibraryTest.java 8226295 generic-all
+compiler/aot/RecompilationTest.java 8226295 generic-all
+compiler/aot/SharedUsageTest.java 8226295 generic-all
+compiler/aot/jdk.tools.jaotc.test/src/jdk/tools/jaotc/test/collect/ClassSearchTest.java 8226295 generic-all
+compiler/aot/jdk.tools.jaotc.test/src/jdk/tools/jaotc/test/collect/SearchPathTest.java 8226295 generic-all
+compiler/aot/jdk.tools.jaotc.test/src/jdk/tools/jaotc/test/collect/module/ModuleSourceProviderTest.java 8226295 generic-all
+compiler/aot/jdk.tools.jaotc.test/src/jdk/tools/jaotc/test/collect/ClassSourceTest.java 8226295 generic-all
+compiler/aot/jdk.tools.jaotc.test/src/jdk/tools/jaotc/test/collect/directory/DirectorySourceProviderTest.java 8226295 generic-all
+compiler/aot/jdk.tools.jaotc.test/src/jdk/tools/jaotc/test/collect/jar/JarSourceProviderTest.java 8226295 generic-all
+compiler/aot/jdk.tools.jaotc.test/src/jdk/tools/jaotc/test/NativeOrderOutputStreamTest.java 8226295 generic-all
+compiler/aot/verification/vmflags/TrackedFlagTest.java 8226295 generic-all
+compiler/aot/verification/vmflags/NotTrackedFlagTest.java 8226295 generic-all
+compiler/aot/verification/ClassAndLibraryNotMatchTest.java 8226295 generic-all
+compiler/aot/DeoptimizationTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeVirtual2NativeTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeStatic2CompiledTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeSpecial2CompiledTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeVirtual2CompiledTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeVirtual2InterpretedTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeDynamic2NativeTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeDynamic2InterpretedTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeStatic2InterpretedTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeInterface2InterpretedTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeVirtual2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeInterface2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeSpecial2NativeTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeDynamic2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeInterface2NativeTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeStatic2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeInterface2CompiledTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeDynamic2CompiledTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeStatic2NativeTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeSpecial2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromAot/AotInvokeSpecial2InterpretedTest.java 8226295 generic-all
+compiler/aot/calls/fromNative/NativeInvokeStatic2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromNative/NativeInvokeSpecial2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromNative/NativeInvokeVirtual2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromCompiled/CompiledInvokeInterface2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromCompiled/CompiledInvokeVirtual2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromCompiled/CompiledInvokeDynamic2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromCompiled/CompiledInvokeStatic2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromCompiled/CompiledInvokeSpecial2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromInterpreted/InterpretedInvokeDynamic2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromInterpreted/InterpretedInvokeStatic2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromInterpreted/InterpretedInvokeVirtual2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromInterpreted/InterpretedInvokeSpecial2AotTest.java 8226295 generic-all
+compiler/aot/calls/fromInterpreted/InterpretedInvokeInterface2AotTest.java 8226295 generic-all
+compiler/aot/fingerprint/SelfChanged.java 8226295 generic-all
+compiler/aot/fingerprint/SelfChangedCDS.java 8226295 generic-all
+compiler/aot/fingerprint/SuperChanged.java 8226295 generic-all
+
 compiler/c2/Test8004741.java 8235801 generic-all
 
 #############################################################################
 
 # :hotspot_gc
@@ -89,10 +166,32 @@
 # :hotspot_runtime
 
 runtime/jni/terminatedThread/TestTerminatedThread.java 8219652 aix-ppc64
 runtime/ReservedStack/ReservedStackTest.java 8231031 generic-all
 
+# Valhalla TODO:
+runtime/CompressedOops/CompressedClassPointers.java 8210258 generic-all
+runtime/RedefineTests/RedefineLeak.java 8205032 generic-all
+runtime/SharedArchiveFile/BootAppendTests.java 8210258 generic-all
+runtime/SharedArchiveFile/CdsDifferentCompactStrings.java 8210258 generic-all
+runtime/SharedArchiveFile/CdsDifferentObjectAlignment.java 8210258 generic-all
+runtime/SharedArchiveFile/NonBootLoaderClasses.java 8210258 generic-all
+runtime/SharedArchiveFile/PrintSharedArchiveAndExit.java 8210258 generic-all
+runtime/SharedArchiveFile/SharedArchiveFile.java 8210258 generic-all
+runtime/SharedArchiveFile/SharedStringsDedup.java 8210258 generic-all
+runtime/SharedArchiveFile/SharedStringsRunAuto.java 8210258 generic-all
+runtime/SharedArchiveFile/SharedSymbolTableBucketSize.java 8210258 generic-all
+runtime/SharedArchiveFile/SpaceUtilizationCheck.java 8210258 generic-all
+runtime/SharedArchiveFile/TestInterpreterMethodEntries.java 8210258 generic-all
+runtime/SharedArchiveFile/serviceability/transformRelatedClasses/TransformInterfaceAndImplementor.java 8210258 generic-all
+runtime/SharedArchiveFile/serviceability/transformRelatedClasses/TransformSuperAndSubClasses.java 8210258 generic-all
+runtime/SharedArchiveFile/serviceability/transformRelatedClasses/TransformSuperSubTwoPckgs.java 8210258 generic-all
+runtime/appcds/ClassLoaderTest.java 8210258 generic-all
+runtime/appcds/HelloTest.java 8210258 generic-all
+runtime/appcds/sharedStrings/SharedStringsBasic.java 8210258 generic-all
+
+
 #############################################################################
 
 # :hotspot_serviceability
 
 serviceability/sa/sadebugd/DebugdConnectTest.java 8239062 macosx-x64
@@ -101,10 +200,36 @@
 serviceability/sa/TestRevPtrsForInvokeDynamic.java 8241235 generic-all
 
 serviceability/jvmti/HeapMonitor/MyPackage/HeapMonitorStatIntervalTest.java 8214032 generic-all
 serviceability/jvmti/HeapMonitor/MyPackage/HeapMonitorStatArrayCorrectnessTest.java 8224150 generic-all
 
+# Valhalla TODO:
+serviceability/sa/ClhsdbCDSCore.java 8190936 generic-all
+serviceability/sa/ClhsdbCDSJstackPrintAll.java 8190936 generic-all
+serviceability/sa/ClhsdbFindPC.java 8190936 generic-all
+serviceability/sa/ClhsdbInspect.java 8190936 generic-all
+serviceability/sa/ClhsdbJdis.java 8190936 generic-all
+serviceability/sa/ClhsdbJstack.java 8190936 generic-all
+serviceability/sa/ClhsdbPrintAll.java 8190936 generic-all
+serviceability/sa/ClhsdbPrintAs.java 8190936 generic-all
+serviceability/sa/ClhsdbPrintStatics.java 8190936 generic-all
+serviceability/sa/ClhsdbSource.java 8190936 generic-all
+serviceability/sa/ClhsdbSymbol.java 8190936 generic-all
+serviceability/sa/ClhsdbWhere.java 8190936 generic-all
+serviceability/sa/JhsdbThreadInfoTest.java 8190936 generic-all
+serviceability/sa/TestClassDump.java 8190936 generic-all
+serviceability/sa/TestClhsdbJstackLock.java 8190936 generic-all
+serviceability/sa/TestCpoolForInvokeDynamic.java 8190936 generic-all
+serviceability/sa/TestHeapDumpForInvokeDynamic.java 8190936 generic-all
+serviceability/sa/TestHeapDumpForLargeArray.java 8190936 generic-all
+serviceability/sa/TestIntConstant.java 8190936 generic-all
+serviceability/sa/TestJhsdbJstackLock.java 8190936 generic-all
+serviceability/sa/TestJmapCore.java 8190936 generic-all
+serviceability/sa/TestJmapCoreMetaspace.java 8190936 generic-all
+serviceability/sa/TestPrintMdo.java 8190936 generic-all
+serviceability/sa/jmap-hprof/JMapHProfLargeHeapTest.java 8190936 generic-all
+
 #############################################################################
 
 # :hotspot_misc
 
 #############################################################################
diff a/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java b/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/ArchiveRelocationTest.java
@@ -27,12 +27,12 @@
  * @requires vm.cds
  * @summary Testing relocation of CDS archive (during both dump time and run time)
  * @comment JDK-8231610 Relocate the CDS archive if it cannot be mapped to the requested address
  * @bug 8231610
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds/test-classes
- * @build Hello
- * @run driver ClassFileInstaller -jar hello.jar Hello
+ * @build HelloRelocation
+ * @run driver ClassFileInstaller -jar hello.jar HelloRelocation HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Point$ref
  * @run driver ArchiveRelocationTest
  */
 
 import jdk.test.lib.process.OutputAnalyzer;
 import jtreg.SkippedException;
@@ -60,20 +60,22 @@
                            + ", run = " + run_reloc);
         System.out.println("============================================================");
 
 
         String appJar = ClassFileInstaller.getJarPath("hello.jar");
-        String mainClass = "Hello";
+        String mainClass = "HelloRelocation";
         String forceRelocation = "-XX:ArchiveRelocationMode=1";
         String dumpRelocArg = dump_reloc ? forceRelocation : "-showversion";
         String runRelocArg  = run_reloc  ? forceRelocation : "-showversion";
         String logArg = "-Xlog:cds=debug,cds+reloc=debug";
         String unlockArg = "-XX:+UnlockDiagnosticVMOptions";
         String nmtArg = "-XX:NativeMemoryTracking=detail";
 
         OutputAnalyzer out = TestCommon.dump(appJar,
-                                             TestCommon.list(mainClass),
+                                             TestCommon.list(mainClass,
+                                                             "HelloInlineClassApp",
+                                                             "HelloInlineClassApp$Point"),
                                              unlockArg, dumpRelocArg, logArg, nmtArg);
         if (dump_reloc) {
             out.shouldContain("ArchiveRelocationMode == 1: always allocate class space at an alternative address");
             out.shouldContain("Relocating archive from");
         }
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod
@@ -0,0 +1,588 @@
+/*
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ * @test
+ * @bug 8210351
+ * @summary Check that IllegalAccessError exceptions get thrown if a class that
+ *          is not a nestmate of an inline type tries to write to the inline type's
+ *          final fields.
+ * @compile -XDemitQtypes WithFieldNoAccessTest.jcod
+ * @run main/othervm WithFieldNoAccessTest
+ */
+
+// This test is based on the below Java program.  The only difference is that
+// the nestmate attributes have been removed.  So, inline type WithFieldNoAccessTest
+// and WithFieldNoAccessTest$V are no longer nestmates.  This should cause
+// IllegalAccessError exceptions when WithFieldNoAccessTest tries to write, using
+// withfield, to inline type WithFieldNoAccessTest$V's final fields.
+//
+// public class WithFieldNoAccessTest {
+//
+//  public static final inline class V {
+//      public final char c;
+//      protected final long l;
+//      private final int i;
+//      V() {
+//          this.c = '0';
+//          this.l = 0;
+//          this.i = 0;
+//      }
+//
+//      public static V make(char c, long l, int i) {
+//          V v = V.default;
+//          v = __WithField(v.c, c);
+//          v = __WithField(v.l, l);
+//          v = __WithField(v.i, i);
+//          return v;
+//      }
+//  }
+//
+//  public static void main(String... args) throws Throwable {
+//      try {
+//          V v = __WithField(V.make('a', 5, 10).c, 'b');
+//          throw new RuntimeException("Failed to throw IllegalAccessError exception for final public field");
+//      } catch (java.lang.IllegalAccessError e) {
+//          if (!e.toString().contains("Update to non-static final field WithFieldNoAccessTest$V.c attempted")) {
+//              throw new RuntimeException("Unexpected IllegalAccessError: " + e.toString());
+//          }
+//      }
+//
+//      try {
+//          V v = __WithField(V.make('a', 5, 10).l, 25);
+//          throw new RuntimeException("Failed to throw IllegalAccessError exception for final protected field");
+//      } catch (java.lang.IllegalAccessError e) {
+//          if (!e.toString().contains("Update to non-static final field WithFieldNoAccessTest$V.l attempted")) {
+//              throw new RuntimeException("Unexpected IllegalAccessError: " +  e.toString());
+//          }
+//      }
+//
+//      try {
+//          V v = __WithField(V.make('a', 5, 10).i, 20);
+//          throw new RuntimeException("Failed to throw IllegalAccessError exception for final private field");
+//      } catch (java.lang.IllegalAccessError e) {
+//          if (!e.toString().contains("WithFieldNoAccessTest tried to access private field WithFieldNoAccessTest$V.i")) {
+//              throw new RuntimeException("Unexpected IllegalAccessError: " + e.toString());
+//          }
+//      }
+//  }
+// }
+//
+
+class WithFieldNoAccessTest$V {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [58] { // Constant Pool
+    ; // first element is empty
+    class #33; // #1     at 0x0A
+    Field #1 #34; // #2     at 0x0D
+    Field #1 #35; // #3     at 0x12
+    Field #1 #36; // #4     at 0x17
+    InvokeDynamic 0s #39; // #5     at 0x1C
+    InvokeDynamic 0s #40; // #6     at 0x21
+    InvokeDynamic 0s #41; // #7     at 0x26
+    class #42; // #8     at 0x2B
+    Utf8 "c"; // #9     at 0x2E
+    Utf8 "C"; // #10     at 0x32
+    Utf8 "l"; // #11     at 0x36
+    Utf8 "J"; // #12     at 0x3A
+    Utf8 "i"; // #13     at 0x3E
+    Utf8 "I"; // #14     at 0x42
+    Utf8 "make"; // #15     at 0x46
+    Utf8 "V"; // #16     at 0x4D
+    Utf8 "InnerClasses"; // #17     at 0x51
+    Utf8 "(CJI)QWithFieldNoAccessTest$V;"; // #18     at 0x60
+    Utf8 "Code"; // #19     at 0x81
+    Utf8 "LineNumberTable"; // #20     at 0x88
+    Utf8 "hashCode"; // #21     at 0x9A
+    Utf8 "()I"; // #22     at 0xA5
+    Utf8 "equals"; // #23     at 0xAB
+    Utf8 "(Ljava/lang/Object;)Z"; // #24     at 0xB4
+    Utf8 "toString"; // #25     at 0xCC
+    Utf8 "()Ljava/lang/String;"; // #26     at 0xD7
+    Utf8 "<init>"; // #27     at 0xEE
+    Utf8 "()QWithFieldNoAccessTest$V;"; // #28     at 0xF7
+    Utf8 "SourceFile"; // #29     at 0x0115
+    Utf8 "WithFieldNoAccessTest.java"; // #30     at 0x0122
+    Utf8 "NestHost"; // #31     at 0x013F
+    class #43; // #32     at 0x014A
+    Utf8 "WithFieldNoAccessTest$V"; // #33     at 0x014D
+    NameAndType #9 #10; // #34     at 0x0167
+    NameAndType #11 #12; // #35     at 0x016C
+    NameAndType #13 #14; // #36     at 0x0171
+    Utf8 "BootstrapMethods"; // #37     at 0x0176
+    MethodHandle 6b #44; // #38     at 0x0189
+    NameAndType #21 #45; // #39     at 0x018D
+    NameAndType #23 #46; // #40     at 0x0192
+    NameAndType #25 #47; // #41     at 0x0197
+    Utf8 "java/lang/Object"; // #42     at 0x019C
+    Utf8 "WithFieldNoAccessTest"; // #43     at 0x01AF
+    Method #48 #49; // #44     at 0x01C7
+    Utf8 "(QWithFieldNoAccessTest$V;)I"; // #45     at 0x01CC
+    Utf8 "(QWithFieldNoAccessTest$V;Ljava/lang/Object;)Z"; // #46     at 0x01EB
+    Utf8 "(QWithFieldNoAccessTest$V;)Ljava/lang/String;"; // #47     at 0x021C
+    class #50; // #48     at 0x024C
+    NameAndType #51 #54; // #49     at 0x024F
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #50     at 0x0254
+    Utf8 "makeBootstrapMethod"; // #51     at 0x027D
+    class #56; // #52     at 0x0293
+    Utf8 "Lookup"; // #53     at 0x0296
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #54     at 0x029F
+    class #57; // #55     at 0x0315
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #56     at 0x0318
+    Utf8 "java/lang/invoke/MethodHandles"; // #57     at 0x0340
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #8;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [3] { // fields
+    { // Member at 0x036B
+      0x0011; // access
+      #9; // name_cpx
+      #10; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0373
+      0x0014; // access
+      #11; // name_cpx
+      #12; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x037B
+      0x0012; // access
+      #13; // name_cpx
+      #14; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [5] { // methods
+    { // Member at 0x0385
+      0x0009; // access
+      #15; // name_cpx
+      #18; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 76) { // Code at 0x038D
+          4; // max_stack
+          5; // max_locals
+          Bytes[36]{
+            0xCB00013A041A1904;
+            0x5FCC00023A041F19;
+            0x045B57CC00033A04;
+            0x1D19045FCC00043A;
+            0x041904B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 22) { // LineNumberTable at 0x03C3
+              [5] { // LineNumberTable
+                0  14; //  at 0x03CF
+                5  15; //  at 0x03D3
+                14  16; //  at 0x03D7
+                24  17; //  at 0x03DB
+                33  18; //  at 0x03DF
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03DF
+      0x0011; // access
+      #21; // name_cpx
+      #22; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 31) { // Code at 0x03E7
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00050000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 6) { // LineNumberTable at 0x0400
+              [1] { // LineNumberTable
+                0  3; //  at 0x040C
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x040C
+      0x0011; // access
+      #23; // name_cpx
+      #24; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 32) { // Code at 0x0414
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA00060000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 6) { // LineNumberTable at 0x042E
+              [1] { // LineNumberTable
+                0  3; //  at 0x043A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x043A
+      0x0011; // access
+      #25; // name_cpx
+      #26; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 31) { // Code at 0x0442
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00070000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 6) { // LineNumberTable at 0x045B
+              [1] { // LineNumberTable
+                0  3; //  at 0x0467
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0467
+      0x0008; // access
+      #27; // name_cpx
+      #28; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 69) { // Code at 0x046F
+          4; // max_stack
+          1; // max_locals
+          Bytes[29]{
+            0xCB00014B10302A5F;
+            0xCC00024B092A5B57;
+            0xCC00034B032A5FCC;
+            0x00044B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 22) { // LineNumberTable at 0x049E
+              [5] { // LineNumberTable
+                0  7; //  at 0x04AA
+                4  8; //  at 0x04AE
+                12  9; //  at 0x04B2
+                20  10; //  at 0x04B6
+                27  11; //  at 0x04BA
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#29, 2) { // SourceFile at 0x04BC
+      #30;
+    } // end SourceFile
+    ;
+    Attr(#17, 18) { // InnerClasses at 0x04CC
+      [2] { // InnerClasses
+        #1 #32 #16 281; //  at 0x04DC
+        #52 #55 #53 25; //  at 0x04E4
+      }
+    } // end InnerClasses
+    ;
+    Attr(#37, 6) { // BootstrapMethods at 0x04E4
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #38; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class WithFieldNoAccessTest$V
+
+
+class WithFieldNoAccessTest {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [91] { // Constant Pool
+    ; // first element is empty
+    Method #23 #39; // #1     at 0x0A
+    long 0x0000000000000005;; // #2     at 0x0F
+    Method #24 #40; // #4     at 0x18
+    Field #24 #41; // #5     at 0x1D
+    class #42; // #6     at 0x22
+    String #43; // #7     at 0x25
+    Method #6 #44; // #8     at 0x28
+    class #45; // #9     at 0x2D
+    Method #9 #46; // #10     at 0x30
+    String #47; // #11     at 0x35
+    Method #48 #49; // #12     at 0x38
+    InvokeDynamic 0s #53; // #13     at 0x3D
+    long 0x0000000000000019;; // #14     at 0x42
+    Field #24 #54; // #16     at 0x4B
+    String #55; // #17     at 0x50
+    String #56; // #18     at 0x53
+    Field #24 #57; // #19     at 0x56
+    String #58; // #20     at 0x5B
+    String #59; // #21     at 0x5E
+    class #60; // #22     at 0x61
+    class #61; // #23     at 0x64
+    class #62; // #24     at 0x67
+    Utf8 "V"; // #25     at 0x6A
+    Utf8 "InnerClasses"; // #26     at 0x6E
+    Utf8 "<init>"; // #27     at 0x7D
+    Utf8 "()V"; // #28     at 0x86
+    Utf8 "Code"; // #29     at 0x8C
+    Utf8 "LineNumberTable"; // #30     at 0x93
+    Utf8 "main"; // #31     at 0xA5
+    Utf8 "([Ljava/lang/String;)V"; // #32     at 0xAC
+    Utf8 "StackMapTable"; // #33     at 0xC5
+    Utf8 "Exceptions"; // #34     at 0xD5
+    class #63; // #35     at 0xE2
+    Utf8 "SourceFile"; // #36     at 0xE5
+    Utf8 "WithFieldNoAccessTest.java"; // #37     at 0xF2
+    Utf8 "NestMembers"; // #38     at 0x010F
+    NameAndType #27 #28; // #39     at 0x011D
+    NameAndType #64 #65; // #40     at 0x0122
+    NameAndType #66 #67; // #41     at 0x0127
+    Utf8 "java/lang/RuntimeException"; // #42     at 0x012C
+    Utf8 "Failed to throw IllegalAccessError exception for final public field"; // #43     at 0x0149
+    NameAndType #27 #68; // #44     at 0x018F
+    Utf8 "java/lang/IllegalAccessError"; // #45     at 0x0194
+    NameAndType #69 #70; // #46     at 0x01B3
+    Utf8 "Update to non-static final field WithFieldNoAccessTest$V.c attempted"; // #47     at 0x01B8
+    class #71; // #48     at 0x01FF
+    NameAndType #72 #73; // #49     at 0x0202
+    Utf8 "BootstrapMethods"; // #50     at 0x0207
+    MethodHandle 6b #74; // #51     at 0x021A
+    String #75; // #52     at 0x021E
+    NameAndType #76 #77; // #53     at 0x0221
+    NameAndType #78 #79; // #54     at 0x0226
+    Utf8 "Failed to throw IllegalAccessError exception for final protected field"; // #55     at 0x022B
+    Utf8 "Update to non-static final field WithFieldNoAccessTest$V.l attempted"; // #56     at 0x0274
+    NameAndType #80 #81; // #57     at 0x02BB
+    Utf8 "Failed to throw IllegalAccessError exception for final private field"; // #58     at 0x02C0
+    Utf8 "WithFieldNoAccessTest tried to access private field WithFieldNoAccessTest$V.i"; // #59     at 0x0307
+    Utf8 "WithFieldNoAccessTest"; // #60     at 0x0357
+    Utf8 "java/lang/Object"; // #61     at 0x036F
+    Utf8 "WithFieldNoAccessTest$V"; // #62     at 0x0382
+    Utf8 "java/lang/Throwable"; // #63     at 0x039C
+    Utf8 "make"; // #64     at 0x03B2
+    Utf8 "(CJI)QWithFieldNoAccessTest$V;"; // #65     at 0x03B9
+    Utf8 "c"; // #66     at 0x03DA
+    Utf8 "C"; // #67     at 0x03DE
+    Utf8 "(Ljava/lang/String;)V"; // #68     at 0x03E2
+    Utf8 "toString"; // #69     at 0x03FA
+    Utf8 "()Ljava/lang/String;"; // #70     at 0x0405
+    Utf8 "java/lang/String"; // #71     at 0x041C
+    Utf8 "contains"; // #72     at 0x042F
+    Utf8 "(Ljava/lang/CharSequence;)Z"; // #73     at 0x043A
+    Method #82 #83; // #74     at 0x0458
+    Utf8 "Unexpected IllegalAccessError: "; // #75     at 0x045D
+    Utf8 "makeConcatWithConstants"; // #76     at 0x0480
+    Utf8 "(Ljava/lang/String;)Ljava/lang/String;"; // #77     at 0x049A
+    Utf8 "l"; // #78     at 0x04C3
+    Utf8 "J"; // #79     at 0x04C7
+    Utf8 "i"; // #80     at 0x04CB
+    Utf8 "I"; // #81     at 0x04CF
+    class #84; // #82     at 0x04D3
+    NameAndType #76 #87; // #83     at 0x04D6
+    Utf8 "java/lang/invoke/StringConcatFactory"; // #84     at 0x04DB
+    class #89; // #85     at 0x0502
+    Utf8 "Lookup"; // #86     at 0x0505
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;"; // #87     at 0x050E
+    class #90; // #88     at 0x05A9
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #89     at 0x05AC
+    Utf8 "java/lang/invoke/MethodHandles"; // #90     at 0x05D4
+  } // Constant Pool
+
+  0x0021; // access [ ACC_PUBLIC ACC_SUPER ]
+  #22;// this_cpx
+  #23;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [0] { // fields
+  } // fields
+
+  [2] { // methods
+    { // Member at 0x0601
+      0x0001; // access
+      #27; // name_cpx
+      #28; // sig_cpx
+      [1] { // Attributes
+        Attr(#29, 29) { // Code at 0x0609
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB70001B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#30, 6) { // LineNumberTable at 0x0620
+              [1] { // LineNumberTable
+                0  1; //  at 0x062C
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x062C
+      0x0089; // access
+      #31; // name_cpx
+      #32; // sig_cpx
+      [2] { // Attributes
+        Attr(#29, 305) { // Code at 0x0634
+          6; // max_stack
+          2; // max_locals
+          Bytes[174]{
+            0x1062106114000210;
+            0x0AB800045FCC0005;
+            0x4CBB0006591207B7;
+            0x0008BF4C2BB6000A;
+            0x120BB6000C9A0014;
+            0xBB0006592BB6000A;
+            0xBA000D0000B70008;
+            0xBF14000E10611400;
+            0x02100AB800045B57;
+            0xCC00104CBB000659;
+            0x1211B70008BF4C2B;
+            0xB6000A1212B6000C;
+            0x9A0014BB0006592B;
+            0xB6000ABA000D0000;
+            0xB70008BF10141061;
+            0x140002100AB80004;
+            0x5FCC00134CBB0006;
+            0x591214B70008BF4C;
+            0x2BB6000A1215B600;
+            0x0C9A0014BB000659;
+            0x2BB6000ABA000D00;
+            0x00B70008BFB1;
+          };
+          [3] { // Traps
+            0 27 27 9; //  at 0x06FA
+            57 86 86 9; //  at 0x0702
+            116 143 143 9; //  at 0x070A
+          } // end Traps
+          [2] { // Attributes
+            Attr(#30, 66) { // LineNumberTable at 0x070C
+              [16] { // LineNumberTable
+                0  24; //  at 0x0718
+                17  25; //  at 0x071C
+                27  26; //  at 0x0720
+                28  27; //  at 0x0724
+                40  28; //  at 0x0728
+                57  33; //  at 0x072C
+                76  34; //  at 0x0730
+                86  35; //  at 0x0734
+                87  36; //  at 0x0738
+                99  37; //  at 0x073C
+                116  42; //  at 0x0740
+                133  43; //  at 0x0744
+                143  44; //  at 0x0748
+                144  45; //  at 0x074C
+                156  46; //  at 0x0750
+                173  49; //  at 0x0754
+              }
+            } // end LineNumberTable
+            ;
+            Attr(#33, 17) { // StackMapTable at 0x0754
+              [6] { //
+                91b, [1]z{7b,9}; // same_locals_1_stack_item_frame
+                29b; // same_frame
+                92b, [1]z{7b,9}; // same_locals_1_stack_item_frame
+                29b; // same_frame
+                90b, [1]z{7b,9}; // same_locals_1_stack_item_frame
+                29b; // same_frame
+              }
+            } // end StackMapTable
+          } // Attributes
+        } // end Code
+        ;
+        Attr(#34, 4) { // Exceptions at 0x076B
+          [1] { // Exceptions
+            #35; //  at 0x0775
+          }
+        } // end Exceptions
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#36, 2) { // SourceFile at 0x0777
+      #37;
+    } // end SourceFile
+    ;
+    Attr(#26, 18) { // InnerClasses at 0x0789
+      [2] { // InnerClasses
+        #24 #22 #25 281; //  at 0x0799
+        #85 #88 #86 25; //  at 0x07A1
+      }
+    } // end InnerClasses
+    ;
+    Attr(#50, 8) { // BootstrapMethods at 0x07A1
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #51; // bootstrap_method_ref
+          [1] { // bootstrap_arguments
+            #52; //  at 0x07AF
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class WithFieldNoAccessTest
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod
@@ -0,0 +1,2227 @@
+/*
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+// This file contains multiple illegal inline type classes that should cause
+// ClassFormatError exceptions when attempted to be loaded.
+//
+// The .jcod classes were originally generated from this Java file and then
+// modified to cause ClassFormatError or ClassCircularityError exceptions.  The
+// '(bad)' comments in most of the tests show where the modifications were made.
+//
+// final inline class Value {
+//     static final Value VT = makeValue(0x01234567);
+//     final int int_v;
+//     Value() {
+//         int_v = 1;
+//     }
+//     static Value makeValue(int x) {
+//         Value v = Value.default;
+//         v = __WithField(v.int_v, x);
+//         return v;
+//     }
+// }
+
+
+// Test that class modifiers cannot have both ACC_VALUE and ACC_ABSTRACT set.
+//
+class ValueAbstract {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [28] { // Constant Pool
+    ; // first element is empty
+    Method #7 #23; // #1     at 0x0A
+    Field #3 #24; // #2     at 0x0F
+    class #9; // #3     at 0x14
+    int 0x01234567; // #4     at 0x17
+    Method #3 #25; // #5     at 0x1C
+    Field #3 #26; // #6     at 0x21
+    class #27; // #7     at 0x26
+    Utf8 "VT"; // #8     at 0x29
+    Utf8 "ValueAbstract"; // #9     at 0x2E
+    Utf8 "ValueTypes"; // #10     at 0x36
+    Utf8 "LValueAbstract;"; // #11     at 0x43
+    Utf8 "int_v"; // #12     at 0x4D
+    Utf8 "I"; // #13     at 0x55
+    Utf8 "<init>"; // #14     at 0x59
+    Utf8 "()V"; // #15     at 0x62
+    Utf8 "Code"; // #16     at 0x68
+    Utf8 "LineNumberTable"; // #17     at 0x6F
+    Utf8 "makeValueAbstract"; // #18     at 0x81
+    Utf8 "(I)LValueAbstract;"; // #19     at 0x8D
+    Utf8 "<clinit>"; // #20     at 0x9A
+    Utf8 "SourceFile"; // #21     at 0xA5
+    Utf8 "ValueAbstract.java"; // #22     at 0xB2
+    NameAndType #14 #15; // #23     at 0xBF
+    NameAndType #12 #13; // #24     at 0xC4
+    NameAndType #18 #19; // #25     at 0xC9
+    NameAndType #8 #11; // #26     at 0xCE
+    Utf8 "java/lang/Object"; // #27     at 0xD3
+  } // Constant Pool
+
+  0x0530; // access [  ACC_VALUE ACC_ABSTRACT(bad) ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #7;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0xF0
+      0x0118; // access
+      #8; // name_cpx
+      #11; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0xF8
+      0x0010; // access
+      #12; // name_cpx
+      #13; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [3] { // methods
+    { // Member at 0x0102
+      0x0000; // access
+      #14; // name_cpx
+      #15; // sig_cpx
+      [1] { // Attributes
+        Attr(#16, 42) { // Code at 0x010A
+          2; // max_stack
+          1; // max_locals
+          Bytes[10]{
+            0x2AB700012A04B500;
+            0x02B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#17, 14) { // LineNumberTable at 0x0126
+              [3] { // LineNumberTable
+                0  4; //  at 0x0132
+                4  5; //  at 0x0136
+                9  6; //  at 0x013A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x013A
+      0x0008; // access
+      #18; // name_cpx
+      #19; // sig_cpx
+      [1] { // Attributes
+        Attr(#16, 44) { // Code at 0x0142
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00034C2B1ACC00;
+            0x024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#17, 14) { // LineNumberTable at 0x0160
+              [3] { // LineNumberTable
+                0  8; //  at 0x016C
+                4  9; //  at 0x0170
+                10  10; //  at 0x0174
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0174
+      0x0008; // access
+      #20; // name_cpx
+      #15; // sig_cpx
+      [1] { // Attributes
+        Attr(#16, 33) { // Code at 0x017C
+          1; // max_stack
+          0; // max_locals
+          Bytes[9]{
+            0x1204B80005B30006;
+            0xB1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#17, 6) { // LineNumberTable at 0x0197
+              [1] { // LineNumberTable
+                0  2; //  at 0x01A3
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [2] { // Attributes
+    Attr(#21, 2) { // SourceFile at 0x01A5
+      #22;
+    } // end SourceFile
+    ;
+    Attr(#10, 4) { // ValueTypes at 0x01AD
+      0x00010003;
+    } // end ValueTypes
+  } // Attributes
+} // end class ValueAbstract
+
+//////////////////////////////////////////////////////////////////////
+
+// Test that class modifiers cannot have both ACC_VALUE and ACC_ENUM set.
+//
+class ValueEnum {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [28] { // Constant Pool
+    ; // first element is empty
+    Method #7 #23; // #1     at 0x0A
+    Field #3 #24; // #2     at 0x0F
+    class #9; // #3     at 0x14
+    int 0x01234567; // #4     at 0x17
+    Method #3 #25; // #5     at 0x1C
+    Field #3 #26; // #6     at 0x21
+    class #27; // #7     at 0x26
+    Utf8 "VT"; // #8     at 0x29
+    Utf8 "ValueEnum"; // #9     at 0x2E
+    Utf8 "ValueTypes"; // #10     at 0x36
+    Utf8 "LValueEnum;"; // #11     at 0x43
+    Utf8 "int_v"; // #12     at 0x4D
+    Utf8 "I"; // #13     at 0x55
+    Utf8 "<init>"; // #14     at 0x59
+    Utf8 "()V"; // #15     at 0x62
+    Utf8 "Code"; // #16     at 0x68
+    Utf8 "LineNumberTable"; // #17     at 0x6F
+    Utf8 "makeValueEnum"; // #18     at 0x81
+    Utf8 "(I)LValueEnum;"; // #19     at 0x8D
+    Utf8 "<clinit>"; // #20     at 0x9A
+    Utf8 "SourceFile"; // #21     at 0xA5
+    Utf8 "ValueEnum.java"; // #22     at 0xB2
+    NameAndType #14 #15; // #23     at 0xBF
+    NameAndType #12 #13; // #24     at 0xC4
+    NameAndType #18 #19; // #25     at 0xC9
+    NameAndType #8 #11; // #26     at 0xCE
+    Utf8 "java/lang/Object"; // #27     at 0xD3
+  } // Constant Pool
+
+  0x04130; // access [  ACC_VALUE ACC_ENUM(bad) ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #7;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0xF0
+      0x0118; // access
+      #8; // name_cpx
+      #11; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0xF8
+      0x0010; // access
+      #12; // name_cpx
+      #13; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [3] { // methods
+    { // Member at 0x0102
+      0x0000; // access
+      #14; // name_cpx
+      #15; // sig_cpx
+      [1] { // Attributes
+        Attr(#16, 42) { // Code at 0x010A
+          2; // max_stack
+          1; // max_locals
+          Bytes[10]{
+            0x2AB700012A04B500;
+            0x02B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#17, 14) { // LineNumberTable at 0x0126
+              [3] { // LineNumberTable
+                0  4; //  at 0x0132
+                4  5; //  at 0x0136
+                9  6; //  at 0x013A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x013A
+      0x0008; // access
+      #18; // name_cpx
+      #19; // sig_cpx
+      [1] { // Attributes
+        Attr(#16, 44) { // Code at 0x0142
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00034C2B1ACC00;
+            0x024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#17, 14) { // LineNumberTable at 0x0160
+              [3] { // LineNumberTable
+                0  8; //  at 0x016C
+                4  9; //  at 0x0170
+                10  10; //  at 0x0174
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0174
+      0x0008; // access
+      #20; // name_cpx
+      #15; // sig_cpx
+      [1] { // Attributes
+        Attr(#16, 33) { // Code at 0x017C
+          1; // max_stack
+          0; // max_locals
+          Bytes[9]{
+            0x1204B80005B30006;
+            0xB1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#17, 6) { // LineNumberTable at 0x0197
+              [1] { // LineNumberTable
+                0  2; //  at 0x01A3
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [2] { // Attributes
+    Attr(#21, 2) { // SourceFile at 0x01A5
+      #22;
+    } // end SourceFile
+    ;
+    Attr(#10, 4) { // ValueTypes at 0x01AD
+      0x00010003;
+    } // end ValueTypes
+  } // Attributes
+} // end class ValueEnum
+
+//////////////////////////////////////////////////////////////////////
+
+// Test that inline type fields must be final.
+//
+class ValueFieldNotFinal {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [28] { // Constant Pool
+    ; // first element is empty
+    Method #7 #23; // #1     at 0x0A
+    Field #3 #24; // #2     at 0x0F
+    class #9; // #3     at 0x14
+    int 0x01234567; // #4     at 0x17
+    Method #3 #25; // #5     at 0x1C
+    Field #3 #26; // #6     at 0x21
+    class #27; // #7     at 0x26
+    Utf8 "VT"; // #8     at 0x29
+    Utf8 "ValueFieldNotFinal"; // #9     at 0x2E
+    Utf8 "ValueTypes"; // #10     at 0x36
+    Utf8 "LValueFieldNotFinal;"; // #11     at 0x43
+    Utf8 "int_v"; // #12     at 0x4D
+    Utf8 "I"; // #13     at 0x55
+    Utf8 "<init>"; // #14     at 0x59
+    Utf8 "()V"; // #15     at 0x62
+    Utf8 "Code"; // #16     at 0x68
+    Utf8 "LineNumberTable"; // #17     at 0x6F
+    Utf8 "makeValueFieldNotFinal"; // #18     at 0x81
+    Utf8 "(I)LValueFieldNotFinal;"; // #19     at 0x8D
+    Utf8 "<clinit>"; // #20     at 0x9A
+    Utf8 "SourceFile"; // #21     at 0xA5
+    Utf8 "ValueFieldNotFinal.java"; // #22     at 0xB2
+    NameAndType #14 #15; // #23     at 0xBF
+    NameAndType #12 #13; // #24     at 0xC4
+    NameAndType #18 #19; // #25     at 0xC9
+    NameAndType #8 #11; // #26     at 0xCE
+    Utf8 "java/lang/Object"; // #27     at 0xD3
+  } // Constant Pool
+
+  0x0130; // access [ ACC_VALUE ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #7;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0xF0
+      0x0118; // access
+      #8; // name_cpx
+      #11; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0xF8
+      0x0000; // access [ Field not ACC_FINAL(bad) ]
+      #12; // name_cpx
+      #13; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [3] { // methods
+    { // Member at 0x0102
+      0x0000; // access
+      #14; // name_cpx
+      #15; // sig_cpx
+      [1] { // Attributes
+        Attr(#16, 42) { // Code at 0x010A
+          2; // max_stack
+          1; // max_locals
+          Bytes[10]{
+            0x2AB700012A04B500;
+            0x02B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#17, 14) { // LineNumberTable at 0x0126
+              [3] { // LineNumberTable
+                0  4; //  at 0x0132
+                4  5; //  at 0x0136
+                9  6; //  at 0x013A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x013A
+      0x0008; // access
+      #18; // name_cpx
+      #19; // sig_cpx
+      [1] { // Attributes
+        Attr(#16, 44) { // Code at 0x0142
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00034C2B1ACC00;
+            0x024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#17, 14) { // LineNumberTable at 0x0160
+              [3] { // LineNumberTable
+                0  8; //  at 0x016C
+                4  9; //  at 0x0170
+                10  10; //  at 0x0174
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0174
+      0x0008; // access
+      #20; // name_cpx
+      #15; // sig_cpx
+      [1] { // Attributes
+        Attr(#16, 33) { // Code at 0x017C
+          1; // max_stack
+          0; // max_locals
+          Bytes[9]{
+            0x1204B80005B30006;
+            0xB1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#17, 6) { // LineNumberTable at 0x0197
+              [1] { // LineNumberTable
+                0  2; //  at 0x01A3
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [2] { // Attributes
+    Attr(#21, 2) { // SourceFile at 0x01A5
+      #22;
+    } // end SourceFile
+    ;
+    Attr(#10, 4) { // ValueTypes at 0x01AD
+      0x00010003;
+    } // end ValueTypes
+  } // Attributes
+} // end class ValueFieldNotFinal
+
+//////////////////////////////////////////////////////////////////////
+
+// Test that class modifiers cannot have both ACC_VALUE and ACC_INTERFACE set.
+//
+class ValueInterface {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [27] { // Constant Pool
+    ; // first element is empty
+    Method #7 #21; // #1     at 0x0A
+    Field #3 #22; // #2     at 0x0F
+    class #23; // #3     at 0x14
+    int 0x01234567; // #4     at 0x17
+    Method #3 #24; // #5     at 0x1C
+    Field #3 #25; // #6     at 0x21
+    class #26; // #7     at 0x26
+    Utf8 "VT"; // #8     at 0x29
+    Utf8 "LValueInterface;"; // #9     at 0x2E
+    Utf8 "int_v"; // #10     at 0x3C
+    Utf8 "I"; // #11     at 0x44
+    Utf8 "<init>"; // #12     at 0x48
+    Utf8 "()V"; // #13     at 0x51
+    Utf8 "Code"; // #14     at 0x57
+    Utf8 "LineNumberTable"; // #15     at 0x5E
+    Utf8 "makeValueInterface"; // #16     at 0x70
+    Utf8 "(I)LValueInterface;"; // #17     at 0x80
+    Utf8 "<clinit>"; // #18     at 0x91
+    Utf8 "SourceFile"; // #19     at 0x9C
+    Utf8 "ValueInterface.java"; // #20     at 0xA9
+    NameAndType #12 #13; // #21     at 0xBA
+    NameAndType #10 #11; // #22     at 0xBF
+    Utf8 "ValueInterface"; // #23     at 0xC4
+    NameAndType #16 #17; // #24     at 0xD0
+    NameAndType #8 #9; // #25     at 0xD5
+    Utf8 "java/lang/Object"; // #26     at 0xDA
+  } // Constant Pool
+
+  0x0330; // access [ ACC_VALUE ACC_INTERFACE(bad) ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #7;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0xF7
+      0x0018; // access
+      #8; // name_cpx
+      #9; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0xFF
+      0x0010; // access
+      #10; // name_cpx
+      #11; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [1] { // methods
+    { // Member at 0x0141
+      0x0008; // access
+      #16; // name_cpx
+      #17; // sig_cpx
+      [1] { // Attributes
+        Attr(#14, 44) { // Code at 0x0149
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00034C2B1ACC00;
+            0x024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#15, 14) { // LineNumberTable at 0x0167
+              [3] { // LineNumberTable
+                0  8; //  at 0x0173
+                4  9; //  at 0x0177
+                10  10; //  at 0x017B
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [1] { // Attributes
+    Attr(#19, 2) { // SourceFile at 0x01AC
+      #20;
+    } // end SourceFile
+  } // Attributes
+} // end class ValueInterface
+
+//////////////////////////////////////////////////////////////////////
+
+// Test that inline type instance methods cannot be synchronized.
+//
+// final inline class ValueMethodSynch {
+//     final int int_v;
+//
+//     ValueMethodSynch() { int_v = 1; }
+//
+//     int getInt(int x) { return x; }
+// }
+
+class ValueMethodSynch {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [46] { // Constant Pool
+    ; // first element is empty
+    class #23; // #1     at 0x0A
+    Field #1 #24; // #2     at 0x0D
+    InvokeDynamic 0s #27; // #3     at 0x12
+    InvokeDynamic 0s #28; // #4     at 0x17
+    InvokeDynamic 0s #29; // #5     at 0x1C
+    class #30; // #6     at 0x21
+    Utf8 "int_v"; // #7     at 0x24
+    Utf8 "I"; // #8     at 0x2C
+    Utf8 "getInt"; // #9     at 0x30
+    Utf8 "(I)I"; // #10     at 0x39
+    Utf8 "Code"; // #11     at 0x40
+    Utf8 "LineNumberTable"; // #12     at 0x47
+    Utf8 "hashCode"; // #13     at 0x59
+    Utf8 "()I"; // #14     at 0x64
+    Utf8 "equals"; // #15     at 0x6A
+    Utf8 "(Ljava/lang/Object;)Z"; // #16     at 0x73
+    Utf8 "toString"; // #17     at 0x8B
+    Utf8 "()Ljava/lang/String;"; // #18     at 0x96
+    Utf8 "<init>"; // #19     at 0xAD
+    Utf8 "()QValueMethodSynch;"; // #20     at 0xB6
+    Utf8 "SourceFile"; // #21     at 0xCD
+    Utf8 "ValueMethodSynch.java"; // #22     at 0xDA
+    Utf8 "ValueMethodSynch"; // #23     at 0xF2
+    NameAndType #7 #8; // #24     at 0x0105
+    Utf8 "BootstrapMethods"; // #25     at 0x010A
+    MethodHandle 6b #31; // #26     at 0x011D
+    NameAndType #13 #32; // #27     at 0x0121
+    NameAndType #15 #33; // #28     at 0x0126
+    NameAndType #17 #34; // #29     at 0x012B
+    Utf8 "java/lang/Object"; // #30     at 0x0130
+    Method #35 #36; // #31     at 0x0143
+    Utf8 "(QValueMethodSynch;)I"; // #32     at 0x0148
+    Utf8 "(QValueMethodSynch;Ljava/lang/Object;)Z"; // #33     at 0x0160
+    Utf8 "(QValueMethodSynch;)Ljava/lang/String;"; // #34     at 0x018A
+    class #37; // #35     at 0x01B3
+    NameAndType #38 #42; // #36     at 0x01B6
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #37     at 0x01BB
+    Utf8 "makeBootstrapMethod"; // #38     at 0x01E4
+    class #44; // #39     at 0x01FA
+    Utf8 "Lookup"; // #40     at 0x01FD
+    Utf8 "InnerClasses"; // #41     at 0x0206
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #42     at 0x0215
+    class #45; // #43     at 0x028B
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #44     at 0x028E
+    Utf8 "java/lang/invoke/MethodHandles"; // #45     at 0x02B6
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #6;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0x02E1
+      0x0010; // access
+      #7; // name_cpx
+      #8; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [5] { // methods
+    { // Member at 0x02EB
+      0x0020; // access [ ACC_SYNCHRONIZED(bad) ]
+      #9; // name_cpx
+      #10; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 26) { // Code at 0x02F3
+          1; // max_stack
+          2; // max_locals
+          Bytes[2]{
+            0x1BAC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x0307
+              [1] { // LineNumberTable
+                0  9; //  at 0x0313
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0313
+      0x0011; // access
+      #13; // name_cpx
+      #14; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 31) { // Code at 0x031B
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00030000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x0334
+              [1] { // LineNumberTable
+                0  1; //  at 0x0340
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0340
+      0x0011; // access
+      #15; // name_cpx
+      #16; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 32) { // Code at 0x0348
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA00040000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x0362
+              [1] { // LineNumberTable
+                0  1; //  at 0x036E
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x036E
+      0x0011; // access
+      #17; // name_cpx
+      #18; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 31) { // Code at 0x0376
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00050000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x038F
+              [1] { // LineNumberTable
+                0  1; //  at 0x039B
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x039B
+      0x0008; // access
+      #19; // name_cpx
+      #20; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 45) { // Code at 0x03A3
+          2; // max_stack
+          1; // max_locals
+          Bytes[13]{
+            0xCB00014B042A5FCC;
+            0x00024B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 14) { // LineNumberTable at 0x03C2
+              [3] { // LineNumberTable
+                0  4; //  at 0x03CE
+                4  5; //  at 0x03D2
+                11  6; //  at 0x03D6
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#21, 2) { // SourceFile at 0x03D8
+      #22;
+    } // end SourceFile
+    ;
+    Attr(#41, 10) { // InnerClasses at 0x03E0
+      [1] { // InnerClasses
+        #39 #43 #40 25; //  at 0x03F0
+      }
+    } // end InnerClasses
+    ;
+    Attr(#25, 6) { // BootstrapMethods at 0x03F0
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #26; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class ValueMethodSynch
+
+//////////////////////////////////////////////////////////////////////
+
+// Value types Circ and Circ2 have fields of each other's type.  This should
+// cause a ClassCircularityError exception when one of them is being loaded.
+//
+// The inline types are based on these two Java classes:
+//
+// final inline class Circ {
+//     static final Circ VT = makeCirc(0x01234567);
+//     final int int_v;
+//     final Circ2 v2;
+//     Circ() {
+//         int_v = 1;
+//         v2 = Circ2.default;
+//     }
+//     static Circ makeCirc(int x) {
+//         Circ v = Circ.default;
+//         v = __WithField(v.int_v, x);
+//         return v;
+//     }
+// }
+//----------------------------------------------------------------
+// final inline class Circ2 {
+//     static final Circ2 VT = makeCirc2('\u0123');
+//     final char char_v;
+//     final Circ vv;
+//     Circ2() {
+//         char_v = 'z';
+//         vv = Circ.default;
+//     }
+//     static Circ2 makeCirc2(char c) {
+//         Circ2 v = Circ2.default;
+//         v = __WithField(v.char_v, c);
+//         return v;
+//     }
+// }
+
+class Circ {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [61] { // Constant Pool
+    ; // first element is empty
+    class #34; // #1     at 0x0A
+    Field #1 #35; // #2     at 0x0D
+    class #36; // #3     at 0x12
+    Field #1 #37; // #4     at 0x15
+    InvokeDynamic 0s #40; // #5     at 0x1A
+    InvokeDynamic 0s #41; // #6     at 0x1F
+    InvokeDynamic 0s #42; // #7     at 0x24
+    int 0x01234567; // #8     at 0x29
+    Method #1 #43; // #9     at 0x2E
+    Field #1 #44; // #10     at 0x33
+    class #45; // #11     at 0x38
+    Utf8 "VT"; // #12     at 0x3B
+    Utf8 "QCirc;"; // #13     at 0x40
+    Utf8 "int_v"; // #14     at 0x49
+    Utf8 "I"; // #15     at 0x51
+    Utf8 "v2"; // #16     at 0x55
+    Utf8 "QCirc2;"; // #17     at 0x5A
+    Utf8 "makeCirc"; // #18     at 0x64
+    Utf8 "(I)QCirc;"; // #19     at 0x6F
+    Utf8 "Code"; // #20     at 0x7B
+    Utf8 "LineNumberTable"; // #21     at 0x82
+    Utf8 "hashCode"; // #22     at 0x94
+    Utf8 "()I"; // #23     at 0x9F
+    Utf8 "equals"; // #24     at 0xA5
+    Utf8 "(Ljava/lang/Object;)Z"; // #25     at 0xAE
+    Utf8 "toString"; // #26     at 0xC6
+    Utf8 "()Ljava/lang/String;"; // #27     at 0xD1
+    Utf8 "<clinit>"; // #28     at 0xE8
+    Utf8 "()V"; // #29     at 0xF3
+    Utf8 "<init>"; // #30     at 0xF9
+    Utf8 "()QCirc;"; // #31     at 0x0102
+    Utf8 "SourceFile"; // #32     at 0x010D
+    Utf8 "Circ.java"; // #33     at 0x011A
+    Utf8 "Circ"; // #34     at 0x0126
+    NameAndType #14 #15; // #35     at 0x012D
+    Utf8 "Circ2"; // #36     at 0x0132
+    NameAndType #16 #17; // #37     at 0x013A
+    Utf8 "BootstrapMethods"; // #38     at 0x013F
+    MethodHandle 6b #46; // #39     at 0x0152
+    NameAndType #22 #47; // #40     at 0x0156
+    NameAndType #24 #48; // #41     at 0x015B
+    NameAndType #26 #49; // #42     at 0x0160
+    NameAndType #18 #19; // #43     at 0x0165
+    NameAndType #12 #13; // #44     at 0x016A
+    Utf8 "java/lang/Object"; // #45     at 0x016F
+    Method #50 #51; // #46     at 0x0182
+    Utf8 "(QCirc;)I"; // #47     at 0x0187
+    Utf8 "(QCirc;Ljava/lang/Object;)Z"; // #48     at 0x0193
+    Utf8 "(QCirc;)Ljava/lang/String;"; // #49     at 0x01B1
+    class #52; // #50     at 0x01CE
+    NameAndType #53 #57; // #51     at 0x01D1
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #52     at 0x01D6
+    Utf8 "makeBootstrapMethod"; // #53     at 0x01FF
+    class #59; // #54     at 0x0215
+    Utf8 "Lookup"; // #55     at 0x0218
+    Utf8 "InnerClasses"; // #56     at 0x0221
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #57     at 0x0230
+    class #60; // #58     at 0x02A6
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #59     at 0x02A9
+    Utf8 "java/lang/invoke/MethodHandles"; // #60     at 0x02D1
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #11;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [3] { // fields
+    { // Member at 0x02FC
+      0x0018; // access
+      #12; // name_cpx
+      #13; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0304
+      0x0010; // access
+      #14; // name_cpx
+      #15; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x030C
+      0x0010; // access
+      #16; // name_cpx
+      #17; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0316
+      0x0008; // access
+      #18; // name_cpx
+      #19; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 45) { // Code at 0x031E
+          2; // max_stack
+          2; // max_locals
+          Bytes[13]{
+            0xCB00014C1A2B5FCC;
+            0x00024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 14) { // LineNumberTable at 0x033D
+              [3] { // LineNumberTable
+                0  12; //  at 0x0349
+                4  13; //  at 0x034D
+                11  14; //  at 0x0351
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0351
+      0x0011; // access
+      #22; // name_cpx
+      #23; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 31) { // Code at 0x0359
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00050000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x0372
+              [1] { // LineNumberTable
+                0  1; //  at 0x037E
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x037E
+      0x0011; // access
+      #24; // name_cpx
+      #25; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 32) { // Code at 0x0386
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA00060000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x03A0
+              [1] { // LineNumberTable
+                0  1; //  at 0x03AC
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03AC
+      0x0011; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 31) { // Code at 0x03B4
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00070000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x03CD
+              [1] { // LineNumberTable
+                0  1; //  at 0x03D9
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03D9
+      0x0008; // access
+      #28; // name_cpx
+      #29; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 33) { // Code at 0x03E1
+          1; // max_stack
+          0; // max_locals
+          Bytes[9]{
+            0x1208B80009B3000A;
+            0xB1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x03FC
+              [1] { // LineNumberTable
+                0  2; //  at 0x0408
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0408
+      0x0008; // access
+      #30; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 58) { // Code at 0x0410
+          2; // max_stack
+          1; // max_locals
+          Bytes[22]{
+            0xCB00014B042A5FCC;
+            0x00024BCB00032A5F;
+            0xCC00044B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 18) { // LineNumberTable at 0x0438
+              [4] { // LineNumberTable
+                0  6; //  at 0x0444
+                4  7; //  at 0x0448
+                11  8; //  at 0x044C
+                20  9; //  at 0x0450
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#32, 2) { // SourceFile at 0x0452
+      #33;
+    } // end SourceFile
+    ;
+    Attr(#56, 10) { // InnerClasses at 0x045A
+      [1] { // InnerClasses
+        #54 #58 #55 25; //  at 0x046A
+      }
+    } // end InnerClasses
+    ;
+    Attr(#38, 6) { // BootstrapMethods at 0x046A
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #39; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class Circ
+
+class Circ2 {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [60] { // Constant Pool
+    ; // first element is empty
+    class #33; // #1     at 0x0A
+    Field #1 #34; // #2     at 0x0D
+    class #35; // #3     at 0x12
+    Field #1 #36; // #4     at 0x15
+    InvokeDynamic 0s #39; // #5     at 0x1A
+    InvokeDynamic 0s #40; // #6     at 0x1F
+    InvokeDynamic 0s #41; // #7     at 0x24
+    Method #1 #42; // #8     at 0x29
+    Field #1 #43; // #9     at 0x2E
+    class #44; // #10     at 0x33
+    Utf8 "VT"; // #11     at 0x36
+    Utf8 "QCirc2;"; // #12     at 0x3B
+    Utf8 "char_v"; // #13     at 0x45
+    Utf8 "C"; // #14     at 0x4E
+    Utf8 "vv"; // #15     at 0x52
+    Utf8 "QCirc;"; // #16     at 0x57
+    Utf8 "makeCirc2"; // #17     at 0x60
+    Utf8 "(C)QCirc2;"; // #18     at 0x6C
+    Utf8 "Code"; // #19     at 0x79
+    Utf8 "LineNumberTable"; // #20     at 0x80
+    Utf8 "hashCode"; // #21     at 0x92
+    Utf8 "()I"; // #22     at 0x9D
+    Utf8 "equals"; // #23     at 0xA3
+    Utf8 "(Ljava/lang/Object;)Z"; // #24     at 0xAC
+    Utf8 "toString"; // #25     at 0xC4
+    Utf8 "()Ljava/lang/String;"; // #26     at 0xCF
+    Utf8 "<clinit>"; // #27     at 0xE6
+    Utf8 "()V"; // #28     at 0xF1
+    Utf8 "<init>"; // #29     at 0xF7
+    Utf8 "()QCirc2;"; // #30     at 0x0100
+    Utf8 "SourceFile"; // #31     at 0x010C
+    Utf8 "Circ2.java"; // #32     at 0x0119
+    Utf8 "Circ2"; // #33     at 0x0126
+    NameAndType #13 #14; // #34     at 0x012E
+    Utf8 "Circ"; // #35     at 0x0133
+    NameAndType #15 #16; // #36     at 0x013A
+    Utf8 "BootstrapMethods"; // #37     at 0x013F
+    MethodHandle 6b #45; // #38     at 0x0152
+    NameAndType #21 #46; // #39     at 0x0156
+    NameAndType #23 #47; // #40     at 0x015B
+    NameAndType #25 #48; // #41     at 0x0160
+    NameAndType #17 #18; // #42     at 0x0165
+    NameAndType #11 #12; // #43     at 0x016A
+    Utf8 "java/lang/Object"; // #44     at 0x016F
+    Method #49 #50; // #45     at 0x0182
+    Utf8 "(QCirc2;)I"; // #46     at 0x0187
+    Utf8 "(QCirc2;Ljava/lang/Object;)Z"; // #47     at 0x0194
+    Utf8 "(QCirc2;)Ljava/lang/String;"; // #48     at 0x01B3
+    class #51; // #49     at 0x01D1
+    NameAndType #52 #56; // #50     at 0x01D4
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #51     at 0x01D9
+    Utf8 "makeBootstrapMethod"; // #52     at 0x0202
+    class #58; // #53     at 0x0218
+    Utf8 "Lookup"; // #54     at 0x021B
+    Utf8 "InnerClasses"; // #55     at 0x0224
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #56     at 0x0233
+    class #59; // #57     at 0x02A9
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #58     at 0x02AC
+    Utf8 "java/lang/invoke/MethodHandles"; // #59     at 0x02D4
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #10;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [3] { // fields
+    { // Member at 0x02FF
+      0x0018; // access
+      #11; // name_cpx
+      #12; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0307
+      0x0010; // access
+      #13; // name_cpx
+      #14; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x030F
+      0x0010; // access
+      #15; // name_cpx
+      #16; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0319
+      0x0008; // access
+      #17; // name_cpx
+      #18; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 45) { // Code at 0x0321
+          2; // max_stack
+          2; // max_locals
+          Bytes[13]{
+            0xCB00014C1A2B5FCC;
+            0x00024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 14) { // LineNumberTable at 0x0340
+              [3] { // LineNumberTable
+                0  12; //  at 0x034C
+                4  13; //  at 0x0350
+                11  14; //  at 0x0354
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0354
+      0x0011; // access
+      #21; // name_cpx
+      #22; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 31) { // Code at 0x035C
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00050000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 6) { // LineNumberTable at 0x0375
+              [1] { // LineNumberTable
+                0  1; //  at 0x0381
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0381
+      0x0011; // access
+      #23; // name_cpx
+      #24; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 32) { // Code at 0x0389
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA00060000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 6) { // LineNumberTable at 0x03A3
+              [1] { // LineNumberTable
+                0  1; //  at 0x03AF
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03AF
+      0x0011; // access
+      #25; // name_cpx
+      #26; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 31) { // Code at 0x03B7
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00070000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 6) { // LineNumberTable at 0x03D0
+              [1] { // LineNumberTable
+                0  1; //  at 0x03DC
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03DC
+      0x0008; // access
+      #27; // name_cpx
+      #28; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 34) { // Code at 0x03E4
+          1; // max_stack
+          0; // max_locals
+          Bytes[10]{
+            0x110123B80008B300;
+            0x09B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 6) { // LineNumberTable at 0x0400
+              [1] { // LineNumberTable
+                0  2; //  at 0x040C
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x040C
+      0x0008; // access
+      #29; // name_cpx
+      #30; // sig_cpx
+      [1] { // Attributes
+        Attr(#19, 59) { // Code at 0x0414
+          2; // max_stack
+          1; // max_locals
+          Bytes[23]{
+            0xCB00014B107A2A5F;
+            0xCC00024BCB00032A;
+            0x5FCC00044B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#20, 18) { // LineNumberTable at 0x043D
+              [4] { // LineNumberTable
+                0  6; //  at 0x0449
+                4  7; //  at 0x044D
+                12  8; //  at 0x0451
+                21  9; //  at 0x0455
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#31, 2) { // SourceFile at 0x0457
+      #32;
+    } // end SourceFile
+    ;
+    Attr(#55, 10) { // InnerClasses at 0x045F
+      [1] { // InnerClasses
+        #53 #57 #54 25; //  at 0x046F
+      }
+    } // end InnerClasses
+    ;
+    Attr(#37, 6) { // BootstrapMethods at 0x046F
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #38; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class Circ2
+
+//////////////////////////////////////////////////////////////////////
+
+// Value types CircStaticA and CircStaticB have static fields of each other's
+// type.  This should cause a ClassCircularityError exception when one of them
+// is being loaded.
+//
+// The inline types are based on these two Java classes:
+//
+// final inline class CircStaticA {
+//     static final CircStaticA VT = makeCircStaticA(0x01234567);
+//     final int int_v;
+//     static final CircStaticB v2 = CircStaticB.default;
+//     CircStaticA() {
+//         int_v = 1;
+//     }
+//     static CircStaticA makeCircStaticA(int x) {
+//         CircStaticA v = CircStaticA.default;
+//         v = __WithField(v.int_v, x);
+//         return v;
+//     }
+// }
+//----------------------------------------------------------------
+// final inline class CircStaticB {
+//     static final CircStaticB VT = makeCircStaticB(0x01234567);
+//     final int int_v;
+//     static final CircStaticA v2 = CircStaticA.default;
+//     CircStaticB() {
+//         int_v = 1;
+//     }
+//     static CircStaticB makeCircStaticB(int x) {
+//         CircStaticB v = CircStaticB.default;
+//         v = __WithField(v.int_v, x);
+//         return v;
+//     }
+// }
+
+class CircStaticA {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [61] { // Constant Pool
+    ; // first element is empty
+    class #34; // #1     at 0x0A
+    Field #1 #35; // #2     at 0x0D
+    InvokeDynamic 0s #38; // #3     at 0x12
+    InvokeDynamic 0s #39; // #4     at 0x17
+    InvokeDynamic 0s #40; // #5     at 0x1C
+    int 0x01234567; // #6     at 0x21
+    Method #1 #41; // #7     at 0x26
+    Field #1 #42; // #8     at 0x2B
+    class #43; // #9     at 0x30
+    Field #1 #44; // #10     at 0x33
+    class #45; // #11     at 0x38
+    Utf8 "VT"; // #12     at 0x3B
+    Utf8 "QCircStaticA;"; // #13     at 0x40
+    Utf8 "int_v"; // #14     at 0x50
+    Utf8 "I"; // #15     at 0x58
+    Utf8 "v2"; // #16     at 0x5C
+    Utf8 "QCircStaticB;"; // #17     at 0x61
+    Utf8 "makeCircStaticA"; // #18     at 0x71
+    Utf8 "(I)QCircStaticA;"; // #19     at 0x83
+    Utf8 "Code"; // #20     at 0x96
+    Utf8 "LineNumberTable"; // #21     at 0x9D
+    Utf8 "hashCode"; // #22     at 0xAF
+    Utf8 "()I"; // #23     at 0xBA
+    Utf8 "equals"; // #24     at 0xC0
+    Utf8 "(Ljava/lang/Object;)Z"; // #25     at 0xC9
+    Utf8 "toString"; // #26     at 0xE1
+    Utf8 "()Ljava/lang/String;"; // #27     at 0xEC
+    Utf8 "<clinit>"; // #28     at 0x0103
+    Utf8 "()V"; // #29     at 0x010E
+    Utf8 "<init>"; // #30     at 0x0114
+    Utf8 "()QCircStaticA;"; // #31     at 0x011D
+    Utf8 "SourceFile"; // #32     at 0x012F
+    Utf8 "CircStaticA.java"; // #33     at 0x013C
+    Utf8 "CircStaticA"; // #34     at 0x014F
+    NameAndType #14 #15; // #35     at 0x015D
+    Utf8 "BootstrapMethods"; // #36     at 0x0162
+    MethodHandle 6b #46; // #37     at 0x0175
+    NameAndType #22 #47; // #38     at 0x0179
+    NameAndType #24 #48; // #39     at 0x017E
+    NameAndType #26 #49; // #40     at 0x0183
+    NameAndType #18 #19; // #41     at 0x0188
+    NameAndType #12 #13; // #42     at 0x018D
+    Utf8 "CircStaticB"; // #43     at 0x0192
+    NameAndType #16 #17; // #44     at 0x01A0
+    Utf8 "java/lang/Object"; // #45     at 0x01A5
+    Method #50 #51; // #46     at 0x01B8
+    Utf8 "(QCircStaticA;)I"; // #47     at 0x01BD
+    Utf8 "(QCircStaticA;Ljava/lang/Object;)Z"; // #48     at 0x01D0
+    Utf8 "(QCircStaticA;)Ljava/lang/String;"; // #49     at 0x01F5
+    class #52; // #50     at 0x0219
+    NameAndType #53 #57; // #51     at 0x021C
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #52     at 0x0221
+    Utf8 "makeBootstrapMethod"; // #53     at 0x024A
+    class #59; // #54     at 0x0260
+    Utf8 "Lookup"; // #55     at 0x0263
+    Utf8 "InnerClasses"; // #56     at 0x026C
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #57     at 0x027B
+    class #60; // #58     at 0x02F1
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #59     at 0x02F4
+    Utf8 "java/lang/invoke/MethodHandles"; // #60     at 0x031C
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #11;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [3] { // fields
+    { // Member at 0x0347
+      0x0018; // access
+      #12; // name_cpx
+      #13; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x034F
+      0x0010; // access
+      #14; // name_cpx
+      #15; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0357
+      0x0018; // access
+      #16; // name_cpx
+      #17; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0361
+      0x0008; // access
+      #18; // name_cpx
+      #19; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 45) { // Code at 0x0369
+          2; // max_stack
+          2; // max_locals
+          Bytes[13]{
+            0xCB00014C1A2B5FCC;
+            0x00024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 14) { // LineNumberTable at 0x0388
+              [3] { // LineNumberTable
+                0  11; //  at 0x0394
+                4  12; //  at 0x0398
+                11  13; //  at 0x039C
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x039C
+      0x0011; // access
+      #22; // name_cpx
+      #23; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 31) { // Code at 0x03A4
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00030000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x03BD
+              [1] { // LineNumberTable
+                0  1; //  at 0x03C9
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03C9
+      0x0011; // access
+      #24; // name_cpx
+      #25; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 32) { // Code at 0x03D1
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA00040000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x03EB
+              [1] { // LineNumberTable
+                0  1; //  at 0x03F7
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03F7
+      0x0011; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 31) { // Code at 0x03FF
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00050000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x0418
+              [1] { // LineNumberTable
+                0  1; //  at 0x0424
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0424
+      0x0008; // access
+      #28; // name_cpx
+      #29; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 43) { // Code at 0x042C
+          1; // max_stack
+          0; // max_locals
+          Bytes[15]{
+            0x1206B80007B30008;
+            0xCB0009B3000AB1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 10) { // LineNumberTable at 0x044D
+              [2] { // LineNumberTable
+                0  2; //  at 0x0459
+                8  4; //  at 0x045D
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x045D
+      0x0008; // access
+      #30; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 45) { // Code at 0x0465
+          2; // max_stack
+          1; // max_locals
+          Bytes[13]{
+            0xCB00014B042A5FCC;
+            0x00024B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 14) { // LineNumberTable at 0x0484
+              [3] { // LineNumberTable
+                0  6; //  at 0x0490
+                4  7; //  at 0x0494
+                11  8; //  at 0x0498
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#32, 2) { // SourceFile at 0x049A
+      #33;
+    } // end SourceFile
+    ;
+    Attr(#56, 10) { // InnerClasses at 0x04A2
+      [1] { // InnerClasses
+        #54 #58 #55 25; //  at 0x04B2
+      }
+    } // end InnerClasses
+    ;
+    Attr(#36, 6) { // BootstrapMethods at 0x04B2
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #37; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class CircStaticA
+
+class CircStaticB {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [61] { // Constant Pool
+    ; // first element is empty
+    class #34; // #1     at 0x0A
+    Field #1 #35; // #2     at 0x0D
+    InvokeDynamic 0s #38; // #3     at 0x12
+    InvokeDynamic 0s #39; // #4     at 0x17
+    InvokeDynamic 0s #40; // #5     at 0x1C
+    int 0x01234567; // #6     at 0x21
+    Method #1 #41; // #7     at 0x26
+    Field #1 #42; // #8     at 0x2B
+    class #43; // #9     at 0x30
+    Field #1 #44; // #10     at 0x33
+    class #45; // #11     at 0x38
+    Utf8 "VT"; // #12     at 0x3B
+    Utf8 "QCircStaticB;"; // #13     at 0x40
+    Utf8 "int_v"; // #14     at 0x50
+    Utf8 "I"; // #15     at 0x58
+    Utf8 "v2"; // #16     at 0x5C
+    Utf8 "QCircStaticA;"; // #17     at 0x61
+    Utf8 "makeCircStaticB"; // #18     at 0x71
+    Utf8 "(I)QCircStaticB;"; // #19     at 0x83
+    Utf8 "Code"; // #20     at 0x96
+    Utf8 "LineNumberTable"; // #21     at 0x9D
+    Utf8 "hashCode"; // #22     at 0xAF
+    Utf8 "()I"; // #23     at 0xBA
+    Utf8 "equals"; // #24     at 0xC0
+    Utf8 "(Ljava/lang/Object;)Z"; // #25     at 0xC9
+    Utf8 "toString"; // #26     at 0xE1
+    Utf8 "()Ljava/lang/String;"; // #27     at 0xEC
+    Utf8 "<clinit>"; // #28     at 0x0103
+    Utf8 "()V"; // #29     at 0x010E
+    Utf8 "<init>"; // #30     at 0x0114
+    Utf8 "()QCircStaticB;"; // #31     at 0x011D
+    Utf8 "SourceFile"; // #32     at 0x012F
+    Utf8 "CircStaticB.java"; // #33     at 0x013C
+    Utf8 "CircStaticB"; // #34     at 0x014F
+    NameAndType #14 #15; // #35     at 0x015D
+    Utf8 "BootstrapMethods"; // #36     at 0x0162
+    MethodHandle 6b #46; // #37     at 0x0175
+    NameAndType #22 #47; // #38     at 0x0179
+    NameAndType #24 #48; // #39     at 0x017E
+    NameAndType #26 #49; // #40     at 0x0183
+    NameAndType #18 #19; // #41     at 0x0188
+    NameAndType #12 #13; // #42     at 0x018D
+    Utf8 "CircStaticA"; // #43     at 0x0192
+    NameAndType #16 #17; // #44     at 0x01A0
+    Utf8 "java/lang/Object"; // #45     at 0x01A5
+    Method #50 #51; // #46     at 0x01B8
+    Utf8 "(QCircStaticB;)I"; // #47     at 0x01BD
+    Utf8 "(QCircStaticB;Ljava/lang/Object;)Z"; // #48     at 0x01D0
+    Utf8 "(QCircStaticB;)Ljava/lang/String;"; // #49     at 0x01F5
+    class #52; // #50     at 0x0219
+    NameAndType #53 #57; // #51     at 0x021C
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #52     at 0x0221
+    Utf8 "makeBootstrapMethod"; // #53     at 0x024A
+    class #59; // #54     at 0x0260
+    Utf8 "Lookup"; // #55     at 0x0263
+    Utf8 "InnerClasses"; // #56     at 0x026C
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #57     at 0x027B
+    class #60; // #58     at 0x02F1
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #59     at 0x02F4
+    Utf8 "java/lang/invoke/MethodHandles"; // #60     at 0x031C
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #11;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [3] { // fields
+    { // Member at 0x0347
+      0x0018; // access
+      #12; // name_cpx
+      #13; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x034F
+      0x0010; // access
+      #14; // name_cpx
+      #15; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0357
+      0x0018; // access
+      #16; // name_cpx
+      #17; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0361
+      0x0008; // access
+      #18; // name_cpx
+      #19; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 45) { // Code at 0x0369
+          2; // max_stack
+          2; // max_locals
+          Bytes[13]{
+            0xCB00014C1A2B5FCC;
+            0x00024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 14) { // LineNumberTable at 0x0388
+              [3] { // LineNumberTable
+                0  11; //  at 0x0394
+                4  12; //  at 0x0398
+                11  13; //  at 0x039C
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x039C
+      0x0011; // access
+      #22; // name_cpx
+      #23; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 31) { // Code at 0x03A4
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00030000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x03BD
+              [1] { // LineNumberTable
+                0  1; //  at 0x03C9
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03C9
+      0x0011; // access
+      #24; // name_cpx
+      #25; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 32) { // Code at 0x03D1
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA00040000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x03EB
+              [1] { // LineNumberTable
+                0  1; //  at 0x03F7
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03F7
+      0x0011; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 31) { // Code at 0x03FF
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00050000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 6) { // LineNumberTable at 0x0418
+              [1] { // LineNumberTable
+                0  1; //  at 0x0424
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0424
+      0x0008; // access
+      #28; // name_cpx
+      #29; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 43) { // Code at 0x042C
+          1; // max_stack
+          0; // max_locals
+          Bytes[15]{
+            0x1206B80007B30008;
+            0xCB0009B3000AB1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 10) { // LineNumberTable at 0x044D
+              [2] { // LineNumberTable
+                0  2; //  at 0x0459
+                8  4; //  at 0x045D
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x045D
+      0x0008; // access
+      #30; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#20, 45) { // Code at 0x0465
+          2; // max_stack
+          1; // max_locals
+          Bytes[13]{
+            0xCB00014B042A5FCC;
+            0x00024B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#21, 14) { // LineNumberTable at 0x0484
+              [3] { // LineNumberTable
+                0  6; //  at 0x0490
+                4  7; //  at 0x0494
+                11  8; //  at 0x0498
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#32, 2) { // SourceFile at 0x049A
+      #33;
+    } // end SourceFile
+    ;
+    Attr(#56, 10) { // InnerClasses at 0x04A2
+      [1] { // InnerClasses
+        #54 #58 #55 25; //  at 0x04B2
+      }
+    } // end InnerClasses
+    ;
+    Attr(#36, 6) { // BootstrapMethods at 0x04B2
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #37; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class CircStaticB
+
+//////////////////////////////////////////////////////////////////////
+
+// Test that an inline type cannot be Cloneable.
+//
+// final inline class ValueCloneable implements Cloneable {
+//    final int field;
+//    private ValueCloneable() { field = 0; }
+//}
+
+class ValueCloneable {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [46] { // Constant Pool
+    ; // first element is empty
+    class #22; // #1     at 0x0A
+    Field #1 #23; // #2     at 0x0D
+    InvokeDynamic 0s #26; // #3     at 0x12
+    InvokeDynamic 0s #27; // #4     at 0x17
+    InvokeDynamic 0s #28; // #5     at 0x1C
+    class #29; // #6     at 0x21
+    class #30; // #7     at 0x24
+    Utf8 "field"; // #8     at 0x27
+    Utf8 "I"; // #9     at 0x2F
+    Utf8 "hashCode"; // #10     at 0x33
+    Utf8 "()I"; // #11     at 0x3E
+    Utf8 "Code"; // #12     at 0x44
+    Utf8 "LineNumberTable"; // #13     at 0x4B
+    Utf8 "equals"; // #14     at 0x5D
+    Utf8 "(Ljava/lang/Object;)Z"; // #15     at 0x66
+    Utf8 "toString"; // #16     at 0x7E
+    Utf8 "()Ljava/lang/String;"; // #17     at 0x89
+    Utf8 "<init>"; // #18     at 0xA0
+    Utf8 "()QValueCloneable;"; // #19     at 0xA9
+    Utf8 "SourceFile"; // #20     at 0xBE
+    Utf8 "ValueCloneable.java"; // #21     at 0xCB
+    Utf8 "ValueCloneable"; // #22     at 0xE1
+    NameAndType #8 #9; // #23     at 0xF2
+    Utf8 "BootstrapMethods"; // #24     at 0xF7
+    MethodHandle 6b #31; // #25     at 0x010A
+    NameAndType #10 #32; // #26     at 0x010E
+    NameAndType #14 #33; // #27     at 0x0113
+    NameAndType #16 #34; // #28     at 0x0118
+    Utf8 "java/lang/Object"; // #29     at 0x011D
+    Utf8 "java/lang/Cloneable"; // #30     at 0x0130
+    Method #35 #36; // #31     at 0x0146
+    Utf8 "(QValueCloneable;)I"; // #32     at 0x014B
+    Utf8 "(QValueCloneable;Ljava/lang/Object;)Z"; // #33     at 0x0161
+    Utf8 "(QValueCloneable;)Ljava/lang/String;"; // #34     at 0x0189
+    class #37; // #35     at 0x01B0
+    NameAndType #38 #42; // #36     at 0x01B3
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #37     at 0x01B8
+    Utf8 "makeBootstrapMethod"; // #38     at 0x01E1
+    class #44; // #39     at 0x01F7
+    Utf8 "Lookup"; // #40     at 0x01FA
+    Utf8 "InnerClasses"; // #41     at 0x0203
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #42     at 0x0212
+    class #45; // #43     at 0x0288
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #44     at 0x028B
+    Utf8 "java/lang/invoke/MethodHandles"; // #45     at 0x02B3
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #6;// super_cpx
+
+  [1] { // Interfaces
+    #7;
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0x02E0
+      0x0010; // access
+      #8; // name_cpx
+      #9; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [4] { // methods
+    { // Member at 0x02EA
+      0x0011; // access
+      #10; // name_cpx
+      #11; // sig_cpx
+      [1] { // Attributes
+        Attr(#12, 31) { // Code at 0x02F2
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00030000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#13, 6) { // LineNumberTable at 0x030B
+              [1] { // LineNumberTable
+                0  1; //  at 0x0317
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0317
+      0x0011; // access
+      #14; // name_cpx
+      #15; // sig_cpx
+      [1] { // Attributes
+        Attr(#12, 32) { // Code at 0x031F
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA00040000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#13, 6) { // LineNumberTable at 0x0339
+              [1] { // LineNumberTable
+                0  1; //  at 0x0345
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0345
+      0x0011; // access
+      #16; // name_cpx
+      #17; // sig_cpx
+      [1] { // Attributes
+        Attr(#12, 31) { // Code at 0x034D
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00050000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#13, 6) { // LineNumberTable at 0x0366
+              [1] { // LineNumberTable
+                0  1; //  at 0x0372
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0372
+      0x0008; // access
+      #18; // name_cpx
+      #19; // sig_cpx
+      [1] { // Attributes
+        Attr(#12, 37) { // Code at 0x037A
+          2; // max_stack
+          1; // max_locals
+          Bytes[13]{
+            0xCB00014B032A5FCC;
+            0x00024B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#13, 6) { // LineNumberTable at 0x0399
+              [1] { // LineNumberTable
+                0  3; //  at 0x03A5
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#20, 2) { // SourceFile at 0x03A7
+      #21;
+    } // end SourceFile
+    ;
+    Attr(#41, 10) { // InnerClasses at 0x03AF
+      [1] { // InnerClasses
+        #39 #43 #40 25; //  at 0x03BF
+      }
+    } // end InnerClasses
+    ;
+    Attr(#24, 6) { // BootstrapMethods at 0x03BF
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #25; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class ValueCloneable
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod
@@ -0,0 +1,62 @@
+class IdentityType {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [] { // Constant Pool
+    ; // first element is empty
+    Method #2 #3; // #1
+    class #4; // #2
+    NameAndType #5 #6; // #3
+    Utf8 "java/lang/Object"; // #4
+    Utf8 "<init>"; // #5
+    Utf8 "()V"; // #6
+    class #8; // #7
+    Utf8 "IdentityType"; // #8
+    Utf8 "Code"; // #9
+    Utf8 "LineNumberTable"; // #10
+    Utf8 "SourceFile"; // #11
+    Utf8 "IdentityType.java"; // #12
+  } // Constant Pool
+
+  0x0021; // access
+  #7;// this_cpx
+  #2;// super_cpx
+
+  [] { // Interfaces
+  } // Interfaces
+
+  [] { // Fields
+  } // Fields
+
+  [] { // Methods
+    {  // method
+      0x0001; // access
+      #5; // name_index
+      #6; // descriptor_index
+      [] { // Attributes
+        Attr(#9) { // Code
+          1; // max_stack
+          1; // max_locals
+          Bytes[]{
+            0x2AB70001B1;
+          }
+          [] { // Traps
+          } // end Traps
+          [] { // Attributes
+            Attr(#10) { // LineNumberTable
+              [] { // line_number_table
+                0  1;
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    }
+  } // Methods
+
+  [] { // Attributes
+    Attr(#11) { // SourceFile
+      #12;
+    } // end SourceFile
+  } // Attributes
+} // end class IdentityType
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod
@@ -0,0 +1,2118 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+// The test cases in this .jcod file are based on this .java file:
+// public inline final class Point extends AbstractClass {
+//     final int x;
+//     final int y;
+//
+//     private Point() {
+//         x = 0;
+//         y = 0;
+//     }
+//
+//     public int getX() { return x; }
+//     public int getY() { return y; }
+// }
+
+// Inline class with a super class that is not abstract.
+class SuperNotAbstract {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [51] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1     at 0x0A
+    Utf8 "SuperNotAbstract"; // #2     at 0x0D
+    Field #1 #4; // #3     at 0x20
+    NameAndType #5 #6; // #4     at 0x25
+    Utf8 "x"; // #5     at 0x2A
+    Utf8 "I"; // #6     at 0x2E
+    Field #1 #8; // #7     at 0x32
+    NameAndType #9 #6; // #8     at 0x37
+    Utf8 "y"; // #9     at 0x3C
+    InvokeDynamic 0s #11; // #10     at 0x40
+    NameAndType #12 #13; // #11     at 0x45
+    Utf8 "hashCode"; // #12     at 0x4A
+    Utf8 "(QSuperNotAbstract;)I"; // #13     at 0x55
+    InvokeDynamic 0s #15; // #14     at 0x6D
+    NameAndType #16 #17; // #15     at 0x72
+    Utf8 "equals"; // #16     at 0x77
+    Utf8 "(QSuperNotAbstract;Ljava/lang/Object;)Z"; // #17     at 0x80
+    InvokeDynamic 0s #19; // #18     at 0xAA
+    NameAndType #20 #21; // #19     at 0xAF
+    Utf8 "toString"; // #20     at 0xB4
+    Utf8 "(QSuperNotAbstract;)Ljava/lang/String;"; // #21     at 0xBF
+    class #23; // #22     at 0xE8
+    Utf8 "NotAbstract"; // #23     at 0xEB
+    class #25; // #24     at 0xF9
+    Utf8 "Unused"; // #25     at 0xFC
+    Utf8 "getX"; // #26     at 0x0115
+    Utf8 "()I"; // #27     at 0x011C
+    Utf8 "Code"; // #28     at 0x0122
+    Utf8 "LineNumberTable"; // #29     at 0x0129
+    Utf8 "getY"; // #30     at 0x013B
+    Utf8 "(Ljava/lang/Object;)Z"; // #31     at 0x0142
+    Utf8 "()Ljava/lang/String;"; // #32     at 0x015A
+    Utf8 "<init>"; // #33     at 0x0171
+    Utf8 "()QSuperNotAbstract;"; // #34     at 0x017A
+    Utf8 "SourceFile"; // #35     at 0x0191
+    Utf8 "SuperNotAbstract.java"; // #36     at 0x019E
+    Utf8 "BootstrapMethods"; // #37     at 0x01B6
+    MethodHandle 6b #39; // #38     at 0x01C9
+    Method #40 #41; // #39     at 0x01CD
+    class #42; // #40     at 0x01D2
+    NameAndType #43 #44; // #41     at 0x01D5
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #42     at 0x01DA
+    Utf8 "makeBootstrapMethod"; // #43     at 0x0203
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #44     at 0x0219
+    Utf8 "InnerClasses"; // #45     at 0x028F
+    class #47; // #46     at 0x029E
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #47     at 0x02A1
+    class #49; // #48     at 0x02C9
+    Utf8 "java/lang/invoke/MethodHandles"; // #49     at 0x02CC
+    Utf8 "Lookup"; // #50     at 0x02ED
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #22;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0x0302
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x030A
+      0x0010; // access
+      #9; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0314
+      0x0001; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x031C
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40003AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x0333
+              [1] { // LineNumberTable
+                0  10; //  at 0x033F
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x033F
+      0x0001; // access
+      #30; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x0347
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40007AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x035E
+              [1] { // LineNumberTable
+                0  11; //  at 0x036A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x036A
+      0x0011; // access
+      #12; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x0372
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA000A0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x038B
+              [1] { // LineNumberTable
+                0  1; //  at 0x0397
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0397
+      0x0011; // access
+      #16; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 32) { // Code at 0x039F
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA000E0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03B9
+              [1] { // LineNumberTable
+                0  1; //  at 0x03C5
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03C5
+      0x0011; // access
+      #20; // name_cpx
+      #32; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x03CD
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00120000B0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03E6
+              [1] { // LineNumberTable
+                0  1; //  at 0x03F2
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03F2
+      0x000A; // access
+      #33; // name_cpx
+      #34; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 56) { // Code at 0x03FA
+          2; // max_stack
+          1; // max_locals
+          Bytes[20]{
+            0xCB00014B032A5FCC;
+            0x00034B032A5FCC00;
+            0x074B2AB0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 18) { // LineNumberTable at 0x0420
+              [4] { // LineNumberTable
+                0  5; //  at 0x042C
+                4  6; //  at 0x0430
+                11  7; //  at 0x0434
+                18  8; //  at 0x0438
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#35, 2) { // SourceFile at 0x043A
+      #36;
+    } // end SourceFile
+    ;
+    Attr(#37, 6) { // BootstrapMethods at 0x0442
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #38; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#45, 10) { // InnerClasses at 0x044E
+      [1] { // InnerClasses
+        #46 #48 #50 25; //  at 0x045E
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class SuperNotAbstract
+
+
+
+// Inline class with a super class that has instance fields.
+class SuperHasNonStaticFields {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [51] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1     at 0x0A
+    Utf8 "SuperHasNonStaticFields"; // #2     at 0x0D
+    Field #1 #4; // #3     at 0x20
+    NameAndType #5 #6; // #4     at 0x25
+    Utf8 "x"; // #5     at 0x2A
+    Utf8 "I"; // #6     at 0x2E
+    Field #1 #8; // #7     at 0x32
+    NameAndType #9 #6; // #8     at 0x37
+    Utf8 "y"; // #9     at 0x3C
+    InvokeDynamic 0s #11; // #10     at 0x40
+    NameAndType #12 #13; // #11     at 0x45
+    Utf8 "hashCode"; // #12     at 0x4A
+    Utf8 "(QSuperHasNonStaticFields;)I"; // #13     at 0x55
+    InvokeDynamic 0s #15; // #14     at 0x6D
+    NameAndType #16 #17; // #15     at 0x72
+    Utf8 "equals"; // #16     at 0x77
+    Utf8 "(QSuperHasNonStaticFields;Ljava/lang/Object;)Z"; // #17     at 0x80
+    InvokeDynamic 0s #19; // #18     at 0xAA
+    NameAndType #20 #21; // #19     at 0xAF
+    Utf8 "toString"; // #20     at 0xB4
+    Utf8 "(QSuperHasNonStaticFields;)Ljava/lang/String;"; // #21     at 0xBF
+    class #23; // #22     at 0xE8
+    Utf8 "HasNonStaticFields"; // #23     at 0xEB
+    class #25; // #24     at 0xF9
+    Utf8 "Unused"; // #25     at 0xFC
+    Utf8 "getX"; // #26     at 0x0115
+    Utf8 "()I"; // #27     at 0x011C
+    Utf8 "Code"; // #28     at 0x0122
+    Utf8 "LineNumberTable"; // #29     at 0x0129
+    Utf8 "getY"; // #30     at 0x013B
+    Utf8 "(Ljava/lang/Object;)Z"; // #31     at 0x0142
+    Utf8 "()Ljava/lang/String;"; // #32     at 0x015A
+    Utf8 "<init>"; // #33     at 0x0171
+    Utf8 "()QSuperHasNonStaticFields;"; // #34     at 0x017A
+    Utf8 "SourceFile"; // #35     at 0x0191
+    Utf8 "SuperHasNonStaticFields.java"; // #36     at 0x019E
+    Utf8 "BootstrapMethods"; // #37     at 0x01B6
+    MethodHandle 6b #39; // #38     at 0x01C9
+    Method #40 #41; // #39     at 0x01CD
+    class #42; // #40     at 0x01D2
+    NameAndType #43 #44; // #41     at 0x01D5
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #42     at 0x01DA
+    Utf8 "makeBootstrapMethod"; // #43     at 0x0203
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #44     at 0x0219
+    Utf8 "InnerClasses"; // #45     at 0x028F
+    class #47; // #46     at 0x029E
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #47     at 0x02A1
+    class #49; // #48     at 0x02C9
+    Utf8 "java/lang/invoke/MethodHandles"; // #49     at 0x02CC
+    Utf8 "Lookup"; // #50     at 0x02ED
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #22;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0x0302
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x030A
+      0x0010; // access
+      #9; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0314
+      0x0001; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x031C
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40003AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x0333
+              [1] { // LineNumberTable
+                0  10; //  at 0x033F
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x033F
+      0x0001; // access
+      #30; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x0347
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40007AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x035E
+              [1] { // LineNumberTable
+                0  11; //  at 0x036A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x036A
+      0x0011; // access
+      #12; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x0372
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA000A0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x038B
+              [1] { // LineNumberTable
+                0  1; //  at 0x0397
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0397
+      0x0011; // access
+      #16; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 32) { // Code at 0x039F
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA000E0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03B9
+              [1] { // LineNumberTable
+                0  1; //  at 0x03C5
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03C5
+      0x0011; // access
+      #20; // name_cpx
+      #32; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x03CD
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00120000B0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03E6
+              [1] { // LineNumberTable
+                0  1; //  at 0x03F2
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03F2
+      0x000A; // access
+      #33; // name_cpx
+      #34; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 56) { // Code at 0x03FA
+          2; // max_stack
+          1; // max_locals
+          Bytes[20]{
+            0xCB00014B032A5FCC;
+            0x00034B032A5FCC00;
+            0x074B2AB0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 18) { // LineNumberTable at 0x0420
+              [4] { // LineNumberTable
+                0  5; //  at 0x042C
+                4  6; //  at 0x0430
+                11  7; //  at 0x0434
+                18  8; //  at 0x0438
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#35, 2) { // SourceFile at 0x043A
+      #36;
+    } // end SourceFile
+    ;
+    Attr(#37, 6) { // BootstrapMethods at 0x0442
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #38; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#45, 10) { // InnerClasses at 0x044E
+      [1] { // InnerClasses
+        #46 #48 #50 25; //  at 0x045E
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class SuperHasNonStaticFields
+
+
+
+// Inline class with a super class whose super class has a syncronized instance method.
+class SuperHasSynchMethod {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [51] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1     at 0x0A
+    Utf8 "SuperHasSynchMethod"; // #2     at 0x0D
+    Field #1 #4; // #3     at 0x20
+    NameAndType #5 #6; // #4     at 0x25
+    Utf8 "x"; // #5     at 0x2A
+    Utf8 "I"; // #6     at 0x2E
+    Field #1 #8; // #7     at 0x32
+    NameAndType #9 #6; // #8     at 0x37
+    Utf8 "y"; // #9     at 0x3C
+    InvokeDynamic 0s #11; // #10     at 0x40
+    NameAndType #12 #13; // #11     at 0x45
+    Utf8 "hashCode"; // #12     at 0x4A
+    Utf8 "(QSuperHasSynchMethod;)I"; // #13     at 0x55
+    InvokeDynamic 0s #15; // #14     at 0x6D
+    NameAndType #16 #17; // #15     at 0x72
+    Utf8 "equals"; // #16     at 0x77
+    Utf8 "(QSuperHasSynchMethod;Ljava/lang/Object;)Z"; // #17     at 0x80
+    InvokeDynamic 0s #19; // #18     at 0xAA
+    NameAndType #20 #21; // #19     at 0xAF
+    Utf8 "toString"; // #20     at 0xB4
+    Utf8 "(QSuperHasSynchMethod;)Ljava/lang/String;"; // #21     at 0xBF
+    class #23; // #22     at 0xE8
+    Utf8 "ValidSuper"; // #23     at 0xEB
+    class #25; // #24     at 0xF9
+    Utf8 "Unused"; // #25     at 0xFC
+    Utf8 "getX"; // #26     at 0x0115
+    Utf8 "()I"; // #27     at 0x011C
+    Utf8 "Code"; // #28     at 0x0122
+    Utf8 "LineNumberTable"; // #29     at 0x0129
+    Utf8 "getY"; // #30     at 0x013B
+    Utf8 "(Ljava/lang/Object;)Z"; // #31     at 0x0142
+    Utf8 "()Ljava/lang/String;"; // #32     at 0x015A
+    Utf8 "<init>"; // #33     at 0x0171
+    Utf8 "()QSuperHasSynchMethod;"; // #34     at 0x017A
+    Utf8 "SourceFile"; // #35     at 0x0191
+    Utf8 "SuperHasSynchMethod.java"; // #36     at 0x019E
+    Utf8 "BootstrapMethods"; // #37     at 0x01B6
+    MethodHandle 6b #39; // #38     at 0x01C9
+    Method #40 #41; // #39     at 0x01CD
+    class #42; // #40     at 0x01D2
+    NameAndType #43 #44; // #41     at 0x01D5
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #42     at 0x01DA
+    Utf8 "makeBootstrapMethod"; // #43     at 0x0203
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #44     at 0x0219
+    Utf8 "InnerClasses"; // #45     at 0x028F
+    class #47; // #46     at 0x029E
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #47     at 0x02A1
+    class #49; // #48     at 0x02C9
+    Utf8 "java/lang/invoke/MethodHandles"; // #49     at 0x02CC
+    Utf8 "Lookup"; // #50     at 0x02ED
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #22;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0x0302
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x030A
+      0x0010; // access
+      #9; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0314
+      0x0001; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x031C
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40003AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x0333
+              [1] { // LineNumberTable
+                0  10; //  at 0x033F
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x033F
+      0x0001; // access
+      #30; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x0347
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40007AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x035E
+              [1] { // LineNumberTable
+                0  11; //  at 0x036A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x036A
+      0x0011; // access
+      #12; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x0372
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA000A0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x038B
+              [1] { // LineNumberTable
+                0  1; //  at 0x0397
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0397
+      0x0011; // access
+      #16; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 32) { // Code at 0x039F
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA000E0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03B9
+              [1] { // LineNumberTable
+                0  1; //  at 0x03C5
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03C5
+      0x0011; // access
+      #20; // name_cpx
+      #32; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x03CD
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00120000B0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03E6
+              [1] { // LineNumberTable
+                0  1; //  at 0x03F2
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03F2
+      0x000A; // access
+      #33; // name_cpx
+      #34; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 56) { // Code at 0x03FA
+          2; // max_stack
+          1; // max_locals
+          Bytes[20]{
+            0xCB00014B032A5FCC;
+            0x00034B032A5FCC00;
+            0x074B2AB0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 18) { // LineNumberTable at 0x0420
+              [4] { // LineNumberTable
+                0  5; //  at 0x042C
+                4  6; //  at 0x0430
+                11  7; //  at 0x0434
+                18  8; //  at 0x0438
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#35, 2) { // SourceFile at 0x043A
+      #36;
+    } // end SourceFile
+    ;
+    Attr(#37, 6) { // BootstrapMethods at 0x0442
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #38; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#45, 10) { // InnerClasses at 0x044E
+      [1] { // InnerClasses
+        #46 #48 #50 25; //  at 0x045E
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class SuperHasSynchMethod
+
+
+// Inline class with a super class containing a constructor that has arguments.
+class SuperCtorHasArgs {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [51] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1     at 0x0A
+    Utf8 "SuperCtorHasArgs"; // #2     at 0x0D
+    Field #1 #4; // #3     at 0x20
+    NameAndType #5 #6; // #4     at 0x25
+    Utf8 "x"; // #5     at 0x2A
+    Utf8 "I"; // #6     at 0x2E
+    Field #1 #8; // #7     at 0x32
+    NameAndType #9 #6; // #8     at 0x37
+    Utf8 "y"; // #9     at 0x3C
+    InvokeDynamic 0s #11; // #10     at 0x40
+    NameAndType #12 #13; // #11     at 0x45
+    Utf8 "hashCode"; // #12     at 0x4A
+    Utf8 "(QSuperCtorHasArgs;)I"; // #13     at 0x55
+    InvokeDynamic 0s #15; // #14     at 0x6D
+    NameAndType #16 #17; // #15     at 0x72
+    Utf8 "equals"; // #16     at 0x77
+    Utf8 "(QSuperCtorHasArgs;Ljava/lang/Object;)Z"; // #17     at 0x80
+    InvokeDynamic 0s #19; // #18     at 0xAA
+    NameAndType #20 #21; // #19     at 0xAF
+    Utf8 "toString"; // #20     at 0xB4
+    Utf8 "(QSuperCtorHasArgs;)Ljava/lang/String;"; // #21     at 0xBF
+    class #23; // #22     at 0xE8
+    Utf8 "CtorHasArgs"; // #23     at 0xEB
+    class #25; // #24     at 0xF9
+    Utf8 "Unused"; // #25     at 0xFC
+    Utf8 "getX"; // #26     at 0x0115
+    Utf8 "()I"; // #27     at 0x011C
+    Utf8 "Code"; // #28     at 0x0122
+    Utf8 "LineNumberTable"; // #29     at 0x0129
+    Utf8 "getY"; // #30     at 0x013B
+    Utf8 "(Ljava/lang/Object;)Z"; // #31     at 0x0142
+    Utf8 "()Ljava/lang/String;"; // #32     at 0x015A
+    Utf8 "<init>"; // #33     at 0x0171
+    Utf8 "()QSuperCtorHasArgs;"; // #34     at 0x017A
+    Utf8 "SourceFile"; // #35     at 0x0191
+    Utf8 "SuperCtorHasArgs.java"; // #36     at 0x019E
+    Utf8 "BootstrapMethods"; // #37     at 0x01B6
+    MethodHandle 6b #39; // #38     at 0x01C9
+    Method #40 #41; // #39     at 0x01CD
+    class #42; // #40     at 0x01D2
+    NameAndType #43 #44; // #41     at 0x01D5
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #42     at 0x01DA
+    Utf8 "makeBootstrapMethod"; // #43     at 0x0203
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #44     at 0x0219
+    Utf8 "InnerClasses"; // #45     at 0x028F
+    class #47; // #46     at 0x029E
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #47     at 0x02A1
+    class #49; // #48     at 0x02C9
+    Utf8 "java/lang/invoke/MethodHandles"; // #49     at 0x02CC
+    Utf8 "Lookup"; // #50     at 0x02ED
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #22;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0x0302
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x030A
+      0x0010; // access
+      #9; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0314
+      0x0001; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x031C
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40003AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x0333
+              [1] { // LineNumberTable
+                0  10; //  at 0x033F
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x033F
+      0x0001; // access
+      #30; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x0347
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40007AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x035E
+              [1] { // LineNumberTable
+                0  11; //  at 0x036A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x036A
+      0x0011; // access
+      #12; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x0372
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA000A0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x038B
+              [1] { // LineNumberTable
+                0  1; //  at 0x0397
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0397
+      0x0011; // access
+      #16; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 32) { // Code at 0x039F
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA000E0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03B9
+              [1] { // LineNumberTable
+                0  1; //  at 0x03C5
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03C5
+      0x0011; // access
+      #20; // name_cpx
+      #32; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x03CD
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00120000B0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03E6
+              [1] { // LineNumberTable
+                0  1; //  at 0x03F2
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03F2
+      0x000A; // access
+      #33; // name_cpx
+      #34; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 56) { // Code at 0x03FA
+          2; // max_stack
+          1; // max_locals
+          Bytes[20]{
+            0xCB00014B032A5FCC;
+            0x00034B032A5FCC00;
+            0x074B2AB0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 18) { // LineNumberTable at 0x0420
+              [4] { // LineNumberTable
+                0  5; //  at 0x042C
+                4  6; //  at 0x0430
+                11  7; //  at 0x0434
+                18  8; //  at 0x0438
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#35, 2) { // SourceFile at 0x043A
+      #36;
+    } // end SourceFile
+    ;
+    Attr(#37, 6) { // BootstrapMethods at 0x0442
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #38; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#45, 10) { // InnerClasses at 0x044E
+      [1] { // InnerClasses
+        #46 #48 #50 25; //  at 0x045E
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class SuperCtorHasArgs
+
+
+
+// Inline class with a super class containing a constructor that has a non-empty
+// method body.
+class SuperCtorIsNotEmpty {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [51] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1     at 0x0A
+    Utf8 "SuperCtorIsNotEmpty"; // #2     at 0x0D
+    Field #1 #4; // #3     at 0x20
+    NameAndType #5 #6; // #4     at 0x25
+    Utf8 "x"; // #5     at 0x2A
+    Utf8 "I"; // #6     at 0x2E
+    Field #1 #8; // #7     at 0x32
+    NameAndType #9 #6; // #8     at 0x37
+    Utf8 "y"; // #9     at 0x3C
+    InvokeDynamic 0s #11; // #10     at 0x40
+    NameAndType #12 #13; // #11     at 0x45
+    Utf8 "hashCode"; // #12     at 0x4A
+    Utf8 "(QSuperCtorIsNotEmpty;)I"; // #13     at 0x55
+    InvokeDynamic 0s #15; // #14     at 0x6D
+    NameAndType #16 #17; // #15     at 0x72
+    Utf8 "equals"; // #16     at 0x77
+    Utf8 "(QSuperCtorIsNotEmpty;Ljava/lang/Object;)Z"; // #17     at 0x80
+    InvokeDynamic 0s #19; // #18     at 0xAA
+    NameAndType #20 #21; // #19     at 0xAF
+    Utf8 "toString"; // #20     at 0xB4
+    Utf8 "(QSuperCtorIsNotEmpty;)Ljava/lang/String;"; // #21     at 0xBF
+    class #23; // #22     at 0xE8
+    Utf8 "CtorIsNotEmpty"; // #23     at 0xEB
+    class #25; // #24     at 0xF9
+    Utf8 "Unused"; // #25     at 0xFC
+    Utf8 "getX"; // #26     at 0x0115
+    Utf8 "()I"; // #27     at 0x011C
+    Utf8 "Code"; // #28     at 0x0122
+    Utf8 "LineNumberTable"; // #29     at 0x0129
+    Utf8 "getY"; // #30     at 0x013B
+    Utf8 "(Ljava/lang/Object;)Z"; // #31     at 0x0142
+    Utf8 "()Ljava/lang/String;"; // #32     at 0x015A
+    Utf8 "<init>"; // #33     at 0x0171
+    Utf8 "()QSuperCtorIsNotEmpty;"; // #34     at 0x017A
+    Utf8 "SourceFile"; // #35     at 0x0191
+    Utf8 "SuperCtorIsNotEmpty.java"; // #36     at 0x019E
+    Utf8 "BootstrapMethods"; // #37     at 0x01B6
+    MethodHandle 6b #39; // #38     at 0x01C9
+    Method #40 #41; // #39     at 0x01CD
+    class #42; // #40     at 0x01D2
+    NameAndType #43 #44; // #41     at 0x01D5
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #42     at 0x01DA
+    Utf8 "makeBootstrapMethod"; // #43     at 0x0203
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #44     at 0x0219
+    Utf8 "InnerClasses"; // #45     at 0x028F
+    class #47; // #46     at 0x029E
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #47     at 0x02A1
+    class #49; // #48     at 0x02C9
+    Utf8 "java/lang/invoke/MethodHandles"; // #49     at 0x02CC
+    Utf8 "Lookup"; // #50     at 0x02ED
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #22;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0x0302
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x030A
+      0x0010; // access
+      #9; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0314
+      0x0001; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x031C
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40003AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x0333
+              [1] { // LineNumberTable
+                0  10; //  at 0x033F
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x033F
+      0x0001; // access
+      #30; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x0347
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40007AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x035E
+              [1] { // LineNumberTable
+                0  11; //  at 0x036A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x036A
+      0x0011; // access
+      #12; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x0372
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA000A0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x038B
+              [1] { // LineNumberTable
+                0  1; //  at 0x0397
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0397
+      0x0011; // access
+      #16; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 32) { // Code at 0x039F
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA000E0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03B9
+              [1] { // LineNumberTable
+                0  1; //  at 0x03C5
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03C5
+      0x0011; // access
+      #20; // name_cpx
+      #32; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x03CD
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00120000B0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03E6
+              [1] { // LineNumberTable
+                0  1; //  at 0x03F2
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03F2
+      0x000A; // access
+      #33; // name_cpx
+      #34; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 56) { // Code at 0x03FA
+          2; // max_stack
+          1; // max_locals
+          Bytes[20]{
+            0xCB00014B032A5FCC;
+            0x00034B032A5FCC00;
+            0x074B2AB0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 18) { // LineNumberTable at 0x0420
+              [4] { // LineNumberTable
+                0  5; //  at 0x042C
+                4  6; //  at 0x0430
+                11  7; //  at 0x0434
+                18  8; //  at 0x0438
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#35, 2) { // SourceFile at 0x043A
+      #36;
+    } // end SourceFile
+    ;
+    Attr(#37, 6) { // BootstrapMethods at 0x0442
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #38; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#45, 10) { // InnerClasses at 0x044E
+      [1] { // InnerClasses
+        #46 #48 #50 25; //  at 0x045E
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class SuperCtorIsNotEmpty
+
+
+// Inline class that implements java.lang.IdentityObject.  Loading this
+// class should throw an ICCE.
+class InlineImplementsIdentityObject {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [53] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1     at 0x0A
+    Utf8 "InlineImplementsIdentityObject"; // #2     at 0x0D
+    Field #1 #4; // #3     at 0x28
+    NameAndType #5 #6; // #4     at 0x2D
+    Utf8 "x"; // #5     at 0x32
+    Utf8 "I"; // #6     at 0x36
+    Field #1 #8; // #7     at 0x3A
+    NameAndType #9 #6; // #8     at 0x3F
+    Utf8 "y"; // #9     at 0x44
+    InvokeDynamic 0s #11; // #10     at 0x48
+    NameAndType #12 #13; // #11     at 0x4D
+    Utf8 "hashCode"; // #12     at 0x52
+    Utf8 "(QInlineImplementsIdentityObject;)I"; // #13     at 0x5D
+    InvokeDynamic 0s #15; // #14     at 0x7D
+    NameAndType #16 #17; // #15     at 0x82
+    Utf8 "equals"; // #16     at 0x87
+    Utf8 "(QInlineImplementsIdentityObject;Ljava/lang/Object;)Z"; // #17     at 0x90
+    InvokeDynamic 0s #19; // #18     at 0xC2
+    NameAndType #20 #21; // #19     at 0xC7
+    Utf8 "toString"; // #20     at 0xCC
+    Utf8 "(QInlineImplementsIdentityObject;)Ljava/lang/String;"; // #21     at 0xD7
+    class #23; // #22     at 0x0108
+    Utf8 "java/lang/Object"; // #23     at 0x010B
+    class #25; // #24     at 0x011E
+    Utf8 "java/lang/IdentityObject"; // #25     at 0x0121
+    class #27; // #26     at 0x0126
+    Utf8 "Unused"; // #27     at 0x0129
+    Utf8 "getX"; // #28     at 0x0142
+    Utf8 "()I"; // #29     at 0x0149
+    Utf8 "Code"; // #30     at 0x014F
+    Utf8 "LineNumberTable"; // #31     at 0x0156
+    Utf8 "getY"; // #32     at 0x0168
+    Utf8 "(Ljava/lang/Object;)Z"; // #33     at 0x016F
+    Utf8 "()Ljava/lang/String;"; // #34     at 0x0187
+    Utf8 "<init>"; // #35     at 0x019E
+    Utf8 "()QInlineImplementsIdentityObject;"; // #36     at 0x01A7
+    Utf8 "SourceFile"; // #37     at 0x01C6
+    Utf8 "InlineImplementsIdentityObject.java"; // #38     at 0x01D3
+    Utf8 "BootstrapMethods"; // #39     at 0x01F3
+    MethodHandle 6b #41; // #40     at 0x0206
+    Method #42 #43; // #41     at 0x020A
+    class #44; // #42     at 0x020F
+    NameAndType #45 #46; // #43     at 0x0212
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #44     at 0x0217
+    Utf8 "makeBootstrapMethod"; // #45     at 0x0240
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #46     at 0x0256
+    Utf8 "InnerClasses"; // #47     at 0x02CC
+    class #49; // #48     at 0x02DB
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #49     at 0x02DE
+    class #51; // #50     at 0x0306
+    Utf8 "java/lang/invoke/MethodHandles"; // #51     at 0x0309
+    Utf8 "Lookup"; // #52     at 0x032A
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #22;// super_cpx
+
+  [1] { // Interfaces
+    #24;
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0x0341
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0349
+      0x0010; // access
+      #9; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0353
+      0x0001; // access
+      #28; // name_cpx
+      #29; // sig_cpx
+      [1] { // Attributes
+        Attr(#30, 29) { // Code at 0x035B
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40003AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#31, 6) { // LineNumberTable at 0x0372
+              [1] { // LineNumberTable
+                0  11; //  at 0x037E
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x037E
+      0x0001; // access
+      #32; // name_cpx
+      #29; // sig_cpx
+      [1] { // Attributes
+        Attr(#30, 29) { // Code at 0x0386
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40007AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#31, 6) { // LineNumberTable at 0x039D
+              [1] { // LineNumberTable
+                0  12; //  at 0x03A9
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03A9
+      0x0011; // access
+      #12; // name_cpx
+      #29; // sig_cpx
+      [1] { // Attributes
+        Attr(#30, 31) { // Code at 0x03B1
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA000A0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#31, 6) { // LineNumberTable at 0x03CA
+              [1] { // LineNumberTable
+                0  2; //  at 0x03D6
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03D6
+      0x0011; // access
+      #16; // name_cpx
+      #33; // sig_cpx
+      [1] { // Attributes
+        Attr(#30, 32) { // Code at 0x03DE
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA000E0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#31, 6) { // LineNumberTable at 0x03F8
+              [1] { // LineNumberTable
+                0  2; //  at 0x0404
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0404
+      0x0011; // access
+      #20; // name_cpx
+      #34; // sig_cpx
+      [1] { // Attributes
+        Attr(#30, 31) { // Code at 0x040C
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00120000B0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#31, 6) { // LineNumberTable at 0x0425
+              [1] { // LineNumberTable
+                0  2; //  at 0x0431
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0431
+      0x000A; // access
+      #35; // name_cpx
+      #36; // sig_cpx
+      [1] { // Attributes
+        Attr(#30, 56) { // Code at 0x0439
+          2; // max_stack
+          1; // max_locals
+          Bytes[20]{
+            0xCB00014B032A5FCC;
+            0x00034B032A5FCC00;
+            0x074B2AB0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#31, 18) { // LineNumberTable at 0x045F
+              [4] { // LineNumberTable
+                0  6; //  at 0x046B
+                4  7; //  at 0x046F
+                11  8; //  at 0x0473
+                18  9; //  at 0x0477
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#37, 2) { // SourceFile at 0x0479
+      #38;
+    } // end SourceFile
+    ;
+    Attr(#39, 6) { // BootstrapMethods at 0x0481
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #40; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#47, 10) { // InnerClasses at 0x048D
+      [1] { // InnerClasses
+        #48 #50 #52 25; //  at 0x049D
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class InlineImplementsIdentityObject
+
+
+
+// Inline class with a super class that implements java.lang.IdentityObject.
+// Loading this class should throw an ICCE.
+class SuperImplementsIdentityObject {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [51] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1     at 0x0A
+    Utf8 "SuperImplementsIdentityObject"; // #2     at 0x0D
+    Field #1 #4; // #3     at 0x20
+    NameAndType #5 #6; // #4     at 0x25
+    Utf8 "x"; // #5     at 0x2A
+    Utf8 "I"; // #6     at 0x2E
+    Field #1 #8; // #7     at 0x32
+    NameAndType #9 #6; // #8     at 0x37
+    Utf8 "y"; // #9     at 0x3C
+    InvokeDynamic 0s #11; // #10     at 0x40
+    NameAndType #12 #13; // #11     at 0x45
+    Utf8 "hashCode"; // #12     at 0x4A
+    Utf8 "(QSuperImplementsIdentityObject;)I"; // #13     at 0x55
+    InvokeDynamic 0s #15; // #14     at 0x6D
+    NameAndType #16 #17; // #15     at 0x72
+    Utf8 "equals"; // #16     at 0x77
+    Utf8 "(QSuperImplementsIdentityObject;Ljava/lang/Object;)Z"; // #17     at 0x80
+    InvokeDynamic 0s #19; // #18     at 0xAA
+    NameAndType #20 #21; // #19     at 0xAF
+    Utf8 "toString"; // #20     at 0xB4
+    Utf8 "(QSuperImplementsIdentityObject;)Ljava/lang/String;"; // #21     at 0xBF
+    class #23; // #22     at 0xE8
+    Utf8 "ImplementsIdentityObject"; // #23     at 0xEB
+    class #25; // #24     at 0xF9
+    Utf8 "Unused"; // #25     at 0xFC
+    Utf8 "getX"; // #26     at 0x0115
+    Utf8 "()I"; // #27     at 0x011C
+    Utf8 "Code"; // #28     at 0x0122
+    Utf8 "LineNumberTable"; // #29     at 0x0129
+    Utf8 "getY"; // #30     at 0x013B
+    Utf8 "(Ljava/lang/Object;)Z"; // #31     at 0x0142
+    Utf8 "()Ljava/lang/String;"; // #32     at 0x015A
+    Utf8 "<init>"; // #33     at 0x0171
+    Utf8 "()QSuperImplementsIdentityObject;"; // #34     at 0x017A
+    Utf8 "SourceFile"; // #35     at 0x0191
+    Utf8 "SuperImplementsIdentityObject.java"; // #36     at 0x019E
+    Utf8 "BootstrapMethods"; // #37     at 0x01B6
+    MethodHandle 6b #39; // #38     at 0x01C9
+    Method #40 #41; // #39     at 0x01CD
+    class #42; // #40     at 0x01D2
+    NameAndType #43 #44; // #41     at 0x01D5
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #42     at 0x01DA
+    Utf8 "makeBootstrapMethod"; // #43     at 0x0203
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #44     at 0x0219
+    Utf8 "InnerClasses"; // #45     at 0x028F
+    class #47; // #46     at 0x029E
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #47     at 0x02A1
+    class #49; // #48     at 0x02C9
+    Utf8 "java/lang/invoke/MethodHandles"; // #49     at 0x02CC
+    Utf8 "Lookup"; // #50     at 0x02ED
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #22;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0x0302
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x030A
+      0x0010; // access
+      #9; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0314
+      0x0001; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x031C
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40003AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x0333
+              [1] { // LineNumberTable
+                0  10; //  at 0x033F
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x033F
+      0x0001; // access
+      #30; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x0347
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40007AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x035E
+              [1] { // LineNumberTable
+                0  11; //  at 0x036A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x036A
+      0x0011; // access
+      #12; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x0372
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA000A0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x038B
+              [1] { // LineNumberTable
+                0  1; //  at 0x0397
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0397
+      0x0011; // access
+      #16; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 32) { // Code at 0x039F
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA000E0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03B9
+              [1] { // LineNumberTable
+                0  1; //  at 0x03C5
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03C5
+      0x0011; // access
+      #20; // name_cpx
+      #32; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x03CD
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00120000B0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03E6
+              [1] { // LineNumberTable
+                0  1; //  at 0x03F2
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03F2
+      0x000A; // access
+      #33; // name_cpx
+      #34; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 56) { // Code at 0x03FA
+          2; // max_stack
+          1; // max_locals
+          Bytes[20]{
+            0xCB00014B032A5FCC;
+            0x00034B032A5FCC00;
+            0x074B2AB0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 18) { // LineNumberTable at 0x0420
+              [4] { // LineNumberTable
+                0  5; //  at 0x042C
+                4  6; //  at 0x0430
+                11  7; //  at 0x0434
+                18  8; //  at 0x0438
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#35, 2) { // SourceFile at 0x043A
+      #36;
+    } // end SourceFile
+    ;
+    Attr(#37, 6) { // BootstrapMethods at 0x0442
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #38; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#45, 10) { // InnerClasses at 0x044E
+      [1] { // InnerClasses
+        #46 #48 #50 25; //  at 0x045E
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class SuperImplementsIdentityObject
+
+
+// Inline class with a super class that implements an interface that extends other
+// interfaces that eventually extend java.lang.IdentityObject
+class SuperIntfImplementsIdentityObject {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [51] { // Constant Pool
+    ; // first element is empty
+    class #2; // #1     at 0x0A
+    Utf8 "SuperIntfImplementsIdentityObject"; // #2     at 0x0D
+    Field #1 #4; // #3     at 0x20
+    NameAndType #5 #6; // #4     at 0x25
+    Utf8 "x"; // #5     at 0x2A
+    Utf8 "I"; // #6     at 0x2E
+    Field #1 #8; // #7     at 0x32
+    NameAndType #9 #6; // #8     at 0x37
+    Utf8 "y"; // #9     at 0x3C
+    InvokeDynamic 0s #11; // #10     at 0x40
+    NameAndType #12 #13; // #11     at 0x45
+    Utf8 "hashCode"; // #12     at 0x4A
+    Utf8 "(QSuperIntfImplementsIdentityObject;)I"; // #13     at 0x55
+    InvokeDynamic 0s #15; // #14     at 0x6D
+    NameAndType #16 #17; // #15     at 0x72
+    Utf8 "equals"; // #16     at 0x77
+    Utf8 "(QSuperIntfImplementsIdentityObject;Ljava/lang/Object;)Z"; // #17     at 0x80
+    InvokeDynamic 0s #19; // #18     at 0xAA
+    NameAndType #20 #21; // #19     at 0xAF
+    Utf8 "toString"; // #20     at 0xB4
+    Utf8 "(QSuperIntfImplementsIdentityObject;)Ljava/lang/String;"; // #21     at 0xBF
+    class #23; // #22     at 0xE8
+    Utf8 "IntfImplementsIdentityObject"; // #23     at 0xEB
+    class #25; // #24     at 0xF9
+    Utf8 "Unused"; // #25     at 0xFC
+    Utf8 "getX"; // #26     at 0x0115
+    Utf8 "()I"; // #27     at 0x011C
+    Utf8 "Code"; // #28     at 0x0122
+    Utf8 "LineNumberTable"; // #29     at 0x0129
+    Utf8 "getY"; // #30     at 0x013B
+    Utf8 "(Ljava/lang/Object;)Z"; // #31     at 0x0142
+    Utf8 "()Ljava/lang/String;"; // #32     at 0x015A
+    Utf8 "<init>"; // #33     at 0x0171
+    Utf8 "()QSuperIntfImplementsIdentityObject;"; // #34     at 0x017A
+    Utf8 "SourceFile"; // #35     at 0x0191
+    Utf8 "SuperIntfImplementsIdentityObject.java"; // #36     at 0x019E
+    Utf8 "BootstrapMethods"; // #37     at 0x01B6
+    MethodHandle 6b #39; // #38     at 0x01C9
+    Method #40 #41; // #39     at 0x01CD
+    class #42; // #40     at 0x01D2
+    NameAndType #43 #44; // #41     at 0x01D5
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #42     at 0x01DA
+    Utf8 "makeBootstrapMethod"; // #43     at 0x0203
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #44     at 0x0219
+    Utf8 "InnerClasses"; // #45     at 0x028F
+    class #47; // #46     at 0x029E
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #47     at 0x02A1
+    class #49; // #48     at 0x02C9
+    Utf8 "java/lang/invoke/MethodHandles"; // #49     at 0x02CC
+    Utf8 "Lookup"; // #50     at 0x02ED
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #22;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0x0302
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x030A
+      0x0010; // access
+      #9; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [6] { // methods
+    { // Member at 0x0314
+      0x0001; // access
+      #26; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x031C
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40003AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x0333
+              [1] { // LineNumberTable
+                0  10; //  at 0x033F
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x033F
+      0x0001; // access
+      #30; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 29) { // Code at 0x0347
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40007AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x035E
+              [1] { // LineNumberTable
+                0  11; //  at 0x036A
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x036A
+      0x0011; // access
+      #12; // name_cpx
+      #27; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x0372
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA000A0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x038B
+              [1] { // LineNumberTable
+                0  1; //  at 0x0397
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0397
+      0x0011; // access
+      #16; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 32) { // Code at 0x039F
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA000E0000AC;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03B9
+              [1] { // LineNumberTable
+                0  1; //  at 0x03C5
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03C5
+      0x0011; // access
+      #20; // name_cpx
+      #32; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 31) { // Code at 0x03CD
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00120000B0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 6) { // LineNumberTable at 0x03E6
+              [1] { // LineNumberTable
+                0  1; //  at 0x03F2
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03F2
+      0x000A; // access
+      #33; // name_cpx
+      #34; // sig_cpx
+      [1] { // Attributes
+        Attr(#28, 56) { // Code at 0x03FA
+          2; // max_stack
+          1; // max_locals
+          Bytes[20]{
+            0xCB00014B032A5FCC;
+            0x00034B032A5FCC00;
+            0x074B2AB0;
+          }
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#29, 18) { // LineNumberTable at 0x0420
+              [4] { // LineNumberTable
+                0  5; //  at 0x042C
+                4  6; //  at 0x0430
+                11  7; //  at 0x0434
+                18  8; //  at 0x0438
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#35, 2) { // SourceFile at 0x043A
+      #36;
+    } // end SourceFile
+    ;
+    Attr(#37, 6) { // BootstrapMethods at 0x0442
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #38; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+    ;
+    Attr(#45, 10) { // InnerClasses at 0x044E
+      [1] { // InnerClasses
+        #46 #48 #50 25; //  at 0x045E
+      }
+    } // end InnerClasses
+  } // Attributes
+} // end class SuperIntfImplementsIdentityObject
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+// Test that a VerifyError exception is thrown when trying to pass a null
+// when the formal parameter is an inline type.
+//
+// // Java program emulating the jcod contents.
+// public inline final class NoNullVT {
+//     final int x;
+//     final int y;
+//
+//     private NoNullVT() {
+//         x = 0;
+//         y = 0;
+//     }
+//
+//     public int getX() { return x; }
+//     public int getY() { return y; }
+//
+//     public boolean isSameNoNullVT(NoNullVT that) {
+//         return this.getX() == that.getX() && this.getY() == that.getY();
+//     }
+//
+//     public boolean equals(Object o) {
+//         if(o instanceof NoNullVT) {
+//             return ((NoNullVT)o).x == x &&  ((NoNullVT)o).y == y;
+//         } else {
+//             return false;
+//         }
+//     }
+//
+//     public static NoNullVT createNoNullVT(int x, int y) {
+//         NoNullVT p = NoNullVT.default;
+//         p = __WithField(p.x, x);
+//         p = __WithField(p.y, y);
+//         return p;
+//     }
+//
+//     public static void main(String[] args) {
+//         String str = null;
+//         NoNullVT a = createNoNullVT(3, 4);
+//         NoNullVT b = createNoNullVT(2, 4);
+//         boolean res = a.isSameNoNullVT(null); // Should throw VerifyError
+//     }
+// }
+
+class NoNullVT {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [63] { // Constant Pool
+    ; // first element is empty
+    class #36; // #1     at 0x0A
+    Field #1 #37; // #2     at 0x0D
+    Field #1 #38; // #3     at 0x12
+    Method #1 #39; // #4     at 0x17
+    Method #1 #40; // #5     at 0x1C
+    class #41; // #6     at 0x21
+    Method #1 #42; // #7     at 0x24
+    Method #1 #43; // #8     at 0x29
+    InvokeDynamic 0s #46; // #9     at 0x2E
+    InvokeDynamic 0s #47; // #10     at 0x33
+    class #48; // #11     at 0x38
+    Utf8 "x"; // #12     at 0x3B
+    Utf8 "I"; // #13     at 0x3F
+    Utf8 "y"; // #14     at 0x43
+    Utf8 "getX"; // #15     at 0x47
+    Utf8 "()I"; // #16     at 0x4E
+    Utf8 "Code"; // #17     at 0x54
+    Utf8 "LineNumberTable"; // #18     at 0x5B
+    Utf8 "getY"; // #19     at 0x6D
+    Utf8 "isSameNoNullVT"; // #20     at 0x74
+    Utf8 "(QNoNullVT;)Z"; // #21     at 0x85
+    Utf8 "StackMapTable"; // #22     at 0x95
+    Utf8 "equals"; // #23     at 0xA5
+    Utf8 "(Ljava/lang/Object;)Z"; // #24     at 0xAE
+    Utf8 "createNoNullVT"; // #25     at 0xC6
+    Utf8 "(II)QNoNullVT;"; // #26     at 0xD7
+    Utf8 "main"; // #27     at 0xE8
+    Utf8 "([Ljava/lang/String;)V"; // #28     at 0xEF
+    Utf8 "hashCode"; // #29     at 0x0108
+    Utf8 "toString"; // #30     at 0x0113
+    Utf8 "()Ljava/lang/String;"; // #31     at 0x011E
+    Utf8 "<init>"; // #32     at 0x0135
+    Utf8 "()QNoNullVT;"; // #33     at 0x013E
+    Utf8 "SourceFile"; // #34     at 0x014D
+    Utf8 "NoNullVT.java"; // #35     at 0x015A
+    Utf8 "NoNullVT"; // #36     at 0x016A
+    NameAndType #12 #13; // #37     at 0x0175
+    NameAndType #14 #13; // #38     at 0x017A
+    NameAndType #15 #16; // #39     at 0x017F
+    NameAndType #19 #16; // #40     at 0x0184
+    Utf8 "QNoNullVT;"; // #41     at 0x0189
+    NameAndType #25 #26; // #42     at 0x0196
+    NameAndType #20 #21; // #43     at 0x019B
+    Utf8 "BootstrapMethods"; // #44     at 0x01A0
+    MethodHandle 6b #49; // #45     at 0x01B3
+    NameAndType #29 #50; // #46     at 0x01B7
+    NameAndType #30 #51; // #47     at 0x01BC
+    Utf8 "java/lang/Object"; // #48     at 0x01C1
+    Method #52 #53; // #49     at 0x01D4
+    Utf8 "(QNoNullVT;)I"; // #50     at 0x01D9
+    Utf8 "(QNoNullVT;)Ljava/lang/String;"; // #51     at 0x01E9
+    class #54; // #52     at 0x020A
+    NameAndType #55 #59; // #53     at 0x020D
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #54     at 0x0212
+    Utf8 "makeBootstrapMethod"; // #55     at 0x023B
+    class #61; // #56     at 0x0251
+    Utf8 "Lookup"; // #57     at 0x0254
+    Utf8 "InnerClasses"; // #58     at 0x025D
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #59     at 0x026C
+    class #62; // #60     at 0x02E2
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #61     at 0x02E5
+    Utf8 "java/lang/invoke/MethodHandles"; // #62     at 0x030D
+  } // Constant Pool
+
+  0x0131; // access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #11;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0x0338
+      0x0010; // access
+      #12; // name_cpx
+      #13; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0340
+      0x0010; // access
+      #14; // name_cpx
+      #13; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [9] { // methods
+    { // Member at 0x034A
+      0x0001; // access
+      #15; // name_cpx
+      #16; // sig_cpx
+      [1] { // Attributes
+        Attr(#17, 29) { // Code at 0x0352
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40002AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#18, 6) { // LineNumberTable at 0x0369
+              [1] { // LineNumberTable
+                0  10; //  at 0x0375
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0375
+      0x0001; // access
+      #19; // name_cpx
+      #16; // sig_cpx
+      [1] { // Attributes
+        Attr(#17, 29) { // Code at 0x037D
+          1; // max_stack
+          1; // max_locals
+          Bytes[5]{
+            0x2AB40003AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#18, 6) { // LineNumberTable at 0x0394
+              [1] { // LineNumberTable
+                0  11; //  at 0x03A0
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03A0
+      0x0001; // access
+      #20; // name_cpx
+      #21; // sig_cpx
+      [1] { // Attributes
+        Attr(#17, 63) { // Code at 0x03A8
+          2; // max_stack
+          2; // max_locals
+          Bytes[28]{
+            0x2AB600042BB60004;
+            0xA000122AB600052B;
+            0xB60005A0000704A7;
+            0x000403AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [2] { // Attributes
+            Attr(#18, 6) { // LineNumberTable at 0x03D6
+              [1] { // LineNumberTable
+                0  14; //  at 0x03E2
+              }
+            } // end LineNumberTable
+            ;
+            Attr(#22, 5) { // StackMapTable at 0x03E2
+              [2] { // 
+                26b; // same_frame
+                64b, [1]z{1b}; // same_locals_1_stack_item_frame
+              }
+            } // end StackMapTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x03ED
+      0x0001; // access
+      #23; // name_cpx
+      #24; // sig_cpx
+      [1] { // Attributes
+        Attr(#17, 87) { // Code at 0x03F5
+          2; // max_stack
+          2; // max_locals
+          Bytes[43]{
+            0x2BC100019900252B;
+            0xC00006B400022AB4;
+            0x0002A000152BC000;
+            0x06B400032AB40003;
+            0xA0000704A7000403;
+            0xAC03AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [2] { // Attributes
+            Attr(#18, 14) { // LineNumberTable at 0x0432
+              [3] { // LineNumberTable
+                0  18; //  at 0x043E
+                7  19; //  at 0x0442
+                41  21; //  at 0x0446
+              }
+            } // end LineNumberTable
+            ;
+            Attr(#22, 6) { // StackMapTable at 0x0446
+              [3] { // 
+                39b; // same_frame
+                64b, [1]z{1b}; // same_locals_1_stack_item_frame
+                0b; // same_frame
+              }
+            } // end StackMapTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0452
+      0x0009; // access
+      #25; // name_cpx
+      #26; // sig_cpx
+      [1] { // Attributes
+        Attr(#17, 56) { // Code at 0x045A
+          2; // max_stack
+          3; // max_locals
+          Bytes[20]{
+            0xCB00014D1A2C5FCC;
+            0x00024D1B2C5FCC00;
+            0x034D2CB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#18, 18) { // LineNumberTable at 0x0480
+              [4] { // LineNumberTable
+                0  26; //  at 0x048C
+                4  27; //  at 0x0490
+                11  28; //  at 0x0494
+                18  29; //  at 0x0498
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0498
+      0x0009; // access
+      #27; // name_cpx
+      #28; // sig_cpx
+      [1] { // Attributes
+        Attr(#17, 62) { // Code at 0x04A0
+          2; // max_stack
+          5; // max_locals
+          Bytes[22]{
+            0x014C0607B800074D;
+            0x0507B800074E2C2B; // Change last nibble from C to B to load null
+            0xB600083604B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#18, 22) { // LineNumberTable at 0x04C8
+              [5] { // LineNumberTable
+                0  33; //  at 0x04D4
+                2  34; //  at 0x04D8
+                8  35; //  at 0x04DC
+                14  36; //  at 0x04E0
+                21  37; //  at 0x04E4
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x04E4
+      0x0011; // access
+      #29; // name_cpx
+      #16; // sig_cpx
+      [1] { // Attributes
+        Attr(#17, 31) { // Code at 0x04EC
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00090000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#18, 6) { // LineNumberTable at 0x0505
+              [1] { // LineNumberTable
+                0  1; //  at 0x0511
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0511
+      0x0011; // access
+      #30; // name_cpx
+      #31; // sig_cpx
+      [1] { // Attributes
+        Attr(#17, 31) { // Code at 0x0519
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA000A0000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#18, 6) { // LineNumberTable at 0x0532
+              [1] { // LineNumberTable
+                0  1; //  at 0x053E
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x053E
+      0x000A; // access
+      #32; // name_cpx
+      #33; // sig_cpx
+      [1] { // Attributes
+        Attr(#17, 56) { // Code at 0x0546
+          2; // max_stack
+          1; // max_locals
+          Bytes[20]{
+            0xCB00014B032A5FCC;
+            0x00024B032A5FCC00;
+            0x034B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#18, 18) { // LineNumberTable at 0x056C
+              [4] { // LineNumberTable
+                0  5; //  at 0x0578
+                4  6; //  at 0x057C
+                11  7; //  at 0x0580
+                18  8; //  at 0x0584
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#34, 2) { // SourceFile at 0x0586
+      #35;
+    } // end SourceFile
+    ;
+    Attr(#58, 10) { // InnerClasses at 0x058E
+      [1] { // InnerClasses
+        #56 #60 #57 25; //  at 0x059E
+      }
+    } // end InnerClasses
+    ;
+    Attr(#44, 6) { // BootstrapMethods at 0x059E
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #45; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class NoNullVT
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod
@@ -0,0 +1,1634 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+// The jcod classes in this file were derived from this Java inline type:
+//
+// final inline class Value {
+//     static final Value VT = makeValue(0x01234567);
+//     final int int_v;
+//     Value() {
+//         int_v = 1;
+//     }
+//     static Value makeValue(int x) {
+//         Value v = Value.default;
+//         v = __WithField(v.int_v, x);
+//         return v;
+//     }
+// }
+//
+// The changes for each test were made to the bytecodes for method makeValue(int x).
+// Its bytecodes are:
+//
+//  static Value makeValue(int); descriptor: (I)LValue; flags: (0x0008) ACC_STATIC
+//    Code:
+//      stack=2, locals=2, args_size=1
+//         0: defaultvalue  #3                  // class Value
+//         3: astore_1
+//         4: aload_1
+//         5: iload_0
+//         6: withfield     #2                  // Field int_v:I
+//         9: astore_1
+//        10: aload_1
+//        11: areturn
+
+
+// The constant pool index of the defaultvalue opcode (0xCB) in the Code
+// attribute was changed to 0x93.  Since this index is outside the range of
+// the constant pool, a VerifyError exception should get thrown.
+//
+class defValBadCP {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [27] { // Constant Pool
+    ; // first element is empty
+    Method #7 #21; // #1     at 0x0A
+    Field #3 #22; // #2     at 0x0F
+    class #23; // #3     at 0x14
+    int 0x01234567; // #4     at 0x17
+    Method #3 #24; // #5     at 0x1C
+    Field #3 #25; // #6     at 0x21
+    class #26; // #7     at 0x26
+    Utf8 "VT"; // #8     at 0x29
+    Utf8 "LdefValBadCP;"; // #9     at 0x2E
+    Utf8 "int_v"; // #10     at 0x38
+    Utf8 "I"; // #11     at 0x40
+    Utf8 "<init>"; // #12     at 0x44
+    Utf8 "()V"; // #13     at 0x4D
+    Utf8 "Code"; // #14     at 0x53
+    Utf8 "LineNumberTable"; // #15     at 0x5A
+    Utf8 "makeValue"; // #16     at 0x6C
+    Utf8 "(I)LdefValBadCP;"; // #17     at 0x78
+    Utf8 "<clinit>"; // #18     at 0x85
+    Utf8 "SourceFile"; // #19     at 0x90
+    Utf8 "defValBadCP.java"; // #20     at 0x9D
+    NameAndType #12 #13; // #21     at 0xAA
+    NameAndType #10 #11; // #22     at 0xAF
+    Utf8 "defValBadCP"; // #23     at 0xB4
+    NameAndType #16 #17; // #24     at 0xBC
+    NameAndType #8 #9; // #25     at 0xC1
+    Utf8 "java/lang/Object"; // #26     at 0xC6
+  } // Constant Pool
+
+  0x0130; // access [ ACC_VALUE ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #7;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0xE3
+      0x0018; // access
+      #8; // name_cpx
+      #9; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0xEB
+      0x0010; // access
+      #10; // name_cpx
+      #11; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [1] { // methods
+    { // Member at 0x012D
+      0x0008; // access
+      #16; // name_cpx
+      #17; // sig_cpx
+      [1] { // Attributes
+        Attr(#14, 44) { // Code at 0x0135
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00934C2B1ACC00; // Changed CP index from 3 to 0x93 for opcode 0xCB (defaultvalue)
+            0x024C2BB0;         // so that the index is outside of the range of the constant pool.
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#15, 14) { // LineNumberTable at 0x0153
+              [3] { // LineNumberTable
+                0  8; //  at 0x015F
+                4  9; //  at 0x0163
+                10  10; //  at 0x0167
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [1] { // Attributes
+    Attr(#19, 2) { // SourceFile at 0x0198
+      #20;
+    } // end SourceFile
+  } // Attributes
+} // end class defValBadCP
+
+///////////////////////////////////////////////////////////
+
+// The class's major version was changed to 54.  Since this class has a
+// defaultvalue opcode (0xCB), this should cause a ClassFormatError
+// exception to get thrown.
+//
+class defValBadMajorVersion {
+  0xCAFEBABE;
+  0; // minor version
+  54; // version
+  [27] { // Constant Pool
+    ; // first element is empty
+    Method #7 #21; // #1     at 0x0A
+    Field #3 #22; // #2     at 0x0F
+    class #23; // #3     at 0x14
+    int 0x01234567; // #4     at 0x17
+    Method #3 #24; // #5     at 0x1C
+    Field #3 #25; // #6     at 0x21
+    class #26; // #7     at 0x26
+    Utf8 "VT"; // #8     at 0x29
+    Utf8 "LdefValBadMajorVersion;"; // #9     at 0x2E
+    Utf8 "int_v"; // #10     at 0x38
+    Utf8 "I"; // #11     at 0x40
+    Utf8 "<init>"; // #12     at 0x44
+    Utf8 "()V"; // #13     at 0x4D
+    Utf8 "Code"; // #14     at 0x53
+    Utf8 "LineNumberTable"; // #15     at 0x5A
+    Utf8 "makeValue"; // #16     at 0x6C
+    Utf8 "(I)LdefValBadMajorVersion;"; // #17     at 0x78
+    Utf8 "<clinit>"; // #18     at 0x85
+    Utf8 "SourceFile"; // #19     at 0x90
+    Utf8 "defValBadMajorVersion.java"; // #20     at 0x9D
+    NameAndType #12 #13; // #21     at 0xAA
+    NameAndType #10 #11; // #22     at 0xAF
+    Utf8 "defValBadMajorVersion"; // #23     at 0xB4
+    NameAndType #16 #17; // #24     at 0xBC
+    NameAndType #8 #9; // #25     at 0xC1
+    Utf8 "java/lang/Object"; // #26     at 0xC6
+  } // Constant Pool
+
+  0x0130; // access [ ACC_VALUE ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #7;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0xE3
+      0x0018; // access
+      #8; // name_cpx
+      #9; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0xEB
+      0x0010; // access
+      #10; // name_cpx
+      #11; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [1] { // methods
+    { // Member at 0x012D
+      0x0008; // access
+      #16; // name_cpx
+      #17; // sig_cpx
+      [1] { // Attributes
+        Attr(#14, 44) { // Code at 0x0135
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00034C2B1ACC00;
+            0x024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#15, 14) { // LineNumberTable at 0x0153
+              [3] { // LineNumberTable
+                0  8; //  at 0x015F
+                4  9; //  at 0x0163
+                10  10; //  at 0x0167
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [1] { // Attributes
+    Attr(#19, 2) { // SourceFile at 0x0198
+      #20;
+    } // end SourceFile
+  } // Attributes
+} // end class defValBadMajorVersion
+
+///////////////////////////////////////////////////////////
+
+// The constant pool index of a defaultvalue opcode (0xCB) in the Code
+// attribute was changed to 2.  Since this index now points to a Field
+// entry instead of a Class entry, a VerifyError exception should get thrown.
+//
+class defValWrongCPType {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [27] { // Constant Pool
+    ; // first element is empty
+    Method #7 #21; // #1     at 0x0A
+    Field #3 #22; // #2     at 0x0F
+    class #23; // #3     at 0x14
+    int 0x01234567; // #4     at 0x17
+    Method #3 #24; // #5     at 0x1C
+    Field #3 #25; // #6     at 0x21
+    class #26; // #7     at 0x26
+    Utf8 "VT"; // #8     at 0x29
+    Utf8 "LdefValWrongCPType;"; // #9     at 0x2E
+    Utf8 "int_v"; // #10     at 0x38
+    Utf8 "I"; // #11     at 0x40
+    Utf8 "<init>"; // #12     at 0x44
+    Utf8 "()V"; // #13     at 0x4D
+    Utf8 "Code"; // #14     at 0x53
+    Utf8 "LineNumberTable"; // #15     at 0x5A
+    Utf8 "makeValue"; // #16     at 0x6C
+    Utf8 "(I)LdefValWrongCPType;"; // #17     at 0x78
+    Utf8 "<clinit>"; // #18     at 0x85
+    Utf8 "SourceFile"; // #19     at 0x90
+    Utf8 "defValWrongCPType.java"; // #20     at 0x9D
+    NameAndType #12 #13; // #21     at 0xAA
+    NameAndType #10 #11; // #22     at 0xAF
+    Utf8 "defValWrongCPType"; // #23     at 0xB4
+    NameAndType #16 #17; // #24     at 0xBC
+    NameAndType #8 #9; // #25     at 0xC1
+    Utf8 "java/lang/Object"; // #26     at 0xC6
+  } // Constant Pool
+
+  0x0130; // access [ ACC_VALUE ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #7;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0xE3
+      0x0018; // access
+      #8; // name_cpx
+      #9; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0xEB
+      0x0010; // access
+      #10; // name_cpx
+      #11; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [1] { // methods
+    { // Member at 0x012D
+      0x0008; // access
+      #16; // name_cpx
+      #17; // sig_cpx
+      [1] { // Attributes
+        Attr(#14, 44) { // Code at 0x0135
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00024C2B1ACC00; // Changed CP index from 3 to 2 for opcode 0xCB (defaultvalue)
+            0x024C2BB0;         // so that the cp index no longer points to a cp Class entry.
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#15, 14) { // LineNumberTable at 0x0153
+              [3] { // LineNumberTable
+                0  8; //  at 0x015F
+                4  9; //  at 0x0163
+                10  10; //  at 0x0167
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [1] { // Attributes
+    Attr(#19, 2) { // SourceFile at 0x0198
+      #20;
+    } // end SourceFile
+  } // Attributes
+} // end class defValWrongCPType
+
+///////////////////////////////////////////////////////////
+
+// The constant pool index of the withfield opcode (0xCC) in the Code
+// attribute was changed to 0x82.  Since this index is outside the range of
+// the constant pool, a VerifyError exception should get thrown.
+//
+class wthFldBadCP {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [20] { // Constant Pool
+    ; // first element is empty
+    Method #4 #17; // #1     at 0x0A
+    Field #3 #18; // #2     at 0x0F
+    class #12; // #3     at 0x14
+    class #19; // #4     at 0x17
+    Utf8 "int_v"; // #5     at 0x1A
+    Utf8 "I"; // #6     at 0x22
+    Utf8 "<init>"; // #7     at 0x26
+    Utf8 "()V"; // #8     at 0x2F
+    Utf8 "Code"; // #9     at 0x35
+    Utf8 "LineNumberTable"; // #10     at 0x3C
+    Utf8 "makewthFldBadCP"; // #11     at 0x4E
+    Utf8 "wthFldBadCP"; // #12     at 0x60
+    Utf8 "ValueTypes"; // #13     at 0x6E
+    Utf8 "(I)LwthFldBadCP;"; // #14     at 0x7B
+    Utf8 "SourceFile"; // #15     at 0x8E
+    Utf8 "wthFldBadCP.java"; // #16     at 0x9B
+    NameAndType #7 #8; // #17     at 0xAE
+    NameAndType #5 #6; // #18     at 0xB3
+    Utf8 "java/lang/Object"; // #19     at 0xB8
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #4;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0xD5
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [2] { // methods
+    { // Member at 0xDF
+      0x0000; // access
+      #7; // name_cpx
+      #8; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 42) { // Code at 0xE7
+          2; // max_stack
+          1; // max_locals
+          Bytes[10]{
+            0x2AB700012A04B500;
+            0x02B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x0103
+              [3] { // LineNumberTable
+                0  4; //  at 0x010F
+                4  5; //  at 0x0113
+                9  6; //  at 0x0117
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0117
+      0x0008; // access
+      #11; // name_cpx
+      #14; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 44) { // Code at 0x011F
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00034C2B1ACC00; // Changed CP index from 2 to 0x82 for opcode 0xCC (withfield)
+            0x824C2BB0;         // so that the index is outside of the range of the constant pool.
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x013D
+              [3] { // LineNumberTable
+                0  8; //  at 0x0149
+                4  9; //  at 0x014D
+                10  10; //  at 0x0151
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [2] { // Attributes
+    Attr(#15, 2) { // SourceFile at 0x0153
+      #16;
+    } // end SourceFile
+    ;
+    Attr(#13, 4) { // ValueTypes at 0x015B
+      0x00010003;
+    } // end ValueTypes
+  } // Attributes
+} // end class wthFldBadCP
+
+///////////////////////////////////////////////////////////
+
+// The opcode at bytecode position 5 in the Code array was changed to aload_1
+// (0x2B).  This should cause a VerifyError because now the first operand on the
+// stack for the withfield opcode (0xCC at bytecode position 6) does not match
+// the type (int) of the field being assigned to.
+//
+class wthFldBadFldVal {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [20] { // Constant Pool
+    ; // first element is empty
+    Method #4 #17; // #1     at 0x0A
+    Field #3 #18; // #2     at 0x0F
+    class #12; // #3     at 0x14
+    class #19; // #4     at 0x17
+    Utf8 "int_v"; // #5     at 0x1A
+    Utf8 "I"; // #6     at 0x22
+    Utf8 "<init>"; // #7     at 0x26
+    Utf8 "()V"; // #8     at 0x2F
+    Utf8 "Code"; // #9     at 0x35
+    Utf8 "LineNumberTable"; // #10     at 0x3C
+    Utf8 "makewthFldBadFldVal"; // #11     at 0x4E
+    Utf8 "wthFldBadFldVal"; // #12     at 0x60
+    Utf8 "ValueTypes"; // #13     at 0x6E
+    Utf8 "(I)LwthFldBadFldVal;"; // #14     at 0x7B
+    Utf8 "SourceFile"; // #15     at 0x8E
+    Utf8 "wthFldBadFldVal.java"; // #16     at 0x9B
+    NameAndType #7 #8; // #17     at 0xAE
+    NameAndType #5 #6; // #18     at 0xB3
+    Utf8 "java/lang/Object"; // #19     at 0xB8
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #4;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0xD5
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [2] { // methods
+    { // Member at 0xDF
+      0x0000; // access
+      #7; // name_cpx
+      #8; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 42) { // Code at 0xE7
+          2; // max_stack
+          1; // max_locals
+          Bytes[10]{
+            0x2AB700012A04B500;
+            0x02B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x0103
+              [3] { // LineNumberTable
+                0  4; //  at 0x010F
+                4  5; //  at 0x0113
+                9  6; //  at 0x0117
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0117
+      0x0008; // access
+      #11; // name_cpx
+      #14; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 44) { // Code at 0x011F
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00034C2B2BCC00; // Changed opcode at bytecode 5 from iload_0 to aload_1
+            0x024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x013D
+              [3] { // LineNumberTable
+                0  8; //  at 0x0149
+                4  9; //  at 0x014D
+                10  10; //  at 0x0151
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [2] { // Attributes
+    Attr(#15, 2) { // SourceFile at 0x0153
+      #16;
+    } // end SourceFile
+    ;
+    Attr(#13, 4) { // ValueTypes at 0x015B
+      0x00010003;
+    } // end ValueTypes
+  } // Attributes
+} // end class wthFldBadFldVal
+
+///////////////////////////////////////////////////////////
+
+// The opcode at bytecode position 4 in the Code array was changed to iload_1
+// (0x1A).  This should cause a VerifyError because the second operand on the stack
+// for the withfield opcode (0xCC at bytecode position 6) must be a reference.
+//
+class wthFldBadFldRef {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [20] { // Constant Pool
+    ; // first element is empty
+    Method #4 #17; // #1     at 0x0A
+    Field #3 #18; // #2     at 0x0F
+    class #12; // #3     at 0x14
+    class #19; // #4     at 0x17
+    Utf8 "int_v"; // #5     at 0x1A
+    Utf8 "I"; // #6     at 0x22
+    Utf8 "<init>"; // #7     at 0x26
+    Utf8 "()V"; // #8     at 0x2F
+    Utf8 "Code"; // #9     at 0x35
+    Utf8 "LineNumberTable"; // #10     at 0x3C
+    Utf8 "makewthFldBadFldRef"; // #11     at 0x4E
+    Utf8 "wthFldBadFldRef"; // #12     at 0x60
+    Utf8 "ValueTypes"; // #13     at 0x6E
+    Utf8 "(I)LwthFldBadFldRef;"; // #14     at 0x7B
+    Utf8 "SourceFile"; // #15     at 0x8E
+    Utf8 "wthFldBadFldRef.java"; // #16     at 0x9B
+    NameAndType #7 #8; // #17     at 0xAE
+    NameAndType #5 #6; // #18     at 0xB3
+    Utf8 "java/lang/Object"; // #19     at 0xB8
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #4;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0xD5
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [2] { // methods
+    { // Member at 0xDF
+      0x0000; // access
+      #7; // name_cpx
+      #8; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 42) { // Code at 0xE7
+          2; // max_stack
+          1; // max_locals
+          Bytes[10]{
+            0x2AB700012A04B500;
+            0x02B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x0103
+              [3] { // LineNumberTable
+                0  4; //  at 0x010F
+                4  5; //  at 0x0113
+                9  6; //  at 0x0117
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0117
+      0x0008; // access
+      #11; // name_cpx
+      #14; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 44) { // Code at 0x011F
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00034C1A1ACC00; // Changed opcode at bytecode 4 from aload_1 to iload_0
+            0x024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x013D
+              [3] { // LineNumberTable
+                0  8; //  at 0x0149
+                4  9; //  at 0x014D
+                10  10; //  at 0x0151
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [2] { // Attributes
+    Attr(#15, 2) { // SourceFile at 0x0153
+      #16;
+    } // end SourceFile
+    ;
+    Attr(#13, 4) { // ValueTypes at 0x015B
+      0x00010003;
+    } // end ValueTypes
+  } // Attributes
+} // end class wthFldBadFldRef
+
+///////////////////////////////////////////////////////////
+
+// The class's major version was changed to 54 and the first opcode in the Code
+// attribute was changed to a withfield (0xCC)..  Since withfield opcodes are not
+// allowed in classes with major version 54, this should cause a ClassFormatError
+// exception to get thrown.
+//
+class wthFldBadMajorVersion {
+  0xCAFEBABE;
+  0; // minor version
+  54; // version
+  [27] { // Constant Pool
+    ; // first element is empty
+    Method #7 #21; // #1     at 0x0A
+    Field #3 #22; // #2     at 0x0F
+    class #23; // #3     at 0x14
+    int 0x01234567; // #4     at 0x17
+    Method #3 #24; // #5     at 0x1C
+    Field #3 #25; // #6     at 0x21
+    class #26; // #7     at 0x26
+    Utf8 "VT"; // #8     at 0x29
+    Utf8 "LwthFldBadMajorVersion;"; // #9     at 0x2E
+    Utf8 "int_v"; // #10     at 0x38
+    Utf8 "I"; // #11     at 0x40
+    Utf8 "<init>"; // #12     at 0x44
+    Utf8 "()V"; // #13     at 0x4D
+    Utf8 "Code"; // #14     at 0x53
+    Utf8 "LineNumberTable"; // #15     at 0x5A
+    Utf8 "makeValue"; // #16     at 0x6C
+    Utf8 "(I)LwthFldBadMajorVersion;"; // #17     at 0x78
+    Utf8 "<clinit>"; // #18     at 0x85
+    Utf8 "SourceFile"; // #19     at 0x90
+    Utf8 "wthFldBadMajorVersion.java"; // #20     at 0x9D
+    NameAndType #12 #13; // #21     at 0xAA
+    NameAndType #10 #11; // #22     at 0xAF
+    Utf8 "wthFldBadMajorVersion"; // #23     at 0xB4
+    NameAndType #16 #17; // #24     at 0xBC
+    NameAndType #8 #9; // #25     at 0xC1
+    Utf8 "java/lang/Object"; // #26     at 0xC6
+  } // Constant Pool
+
+  0x0130; // access [ ACC_VALUE ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #7;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [2] { // fields
+    { // Member at 0xE3
+      0x0018; // access
+      #8; // name_cpx
+      #9; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0xEB
+      0x0010; // access
+      #10; // name_cpx
+      #11; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [1] { // methods
+    { // Member at 0x012D
+      0x0008; // access
+      #16; // name_cpx
+      #17; // sig_cpx
+      [1] { // Attributes
+        Attr(#14, 44) { // Code at 0x0135
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCC00034C2B1ACC00; // Changed the first opcode to 0xCC (withfield) in order to
+            0x024C2BB0;         // test withfield opcode with an illegal major version.
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#15, 14) { // LineNumberTable at 0x0153
+              [3] { // LineNumberTable
+                0  8; //  at 0x015F
+                4  9; //  at 0x0163
+                10  10; //  at 0x0167
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [1] { // Attributes
+    Attr(#19, 2) { // SourceFile at 0x0198
+      #20;
+    } // end SourceFile
+  } // Attributes
+} // end class wthFldBadMajorVersion
+
+///////////////////////////////////////////////////////////
+
+// The constant pool index of a withfield opcode (0xCC) in the Code
+// attribute was changed to 1.  Since this index now points to a Method
+// entry instead of a Field entry, a VerifyError exception should get thrown.
+//
+class wthFldWrongCPType {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [20] { // Constant Pool
+    ; // first element is empty
+    Method #4 #17; // #1     at 0x0A
+    Field #3 #18; // #2     at 0x0F
+    class #12; // #3     at 0x14
+    class #19; // #4     at 0x17
+    Utf8 "int_v"; // #5     at 0x1A
+    Utf8 "I"; // #6     at 0x22
+    Utf8 "<init>"; // #7     at 0x26
+    Utf8 "()V"; // #8     at 0x2F
+    Utf8 "Code"; // #9     at 0x35
+    Utf8 "LineNumberTable"; // #10     at 0x3C
+    Utf8 "makewthFldWrongCPType"; // #11     at 0x4E
+    Utf8 "wthFldWrongCPType"; // #12     at 0x60
+    Utf8 "ValueTypes"; // #13     at 0x6E
+    Utf8 "(I)LwthFldWrongCPType;"; // #14     at 0x7B
+    Utf8 "SourceFile"; // #15     at 0x8E
+    Utf8 "wthFldWrongCPType.java"; // #16     at 0x9B
+    NameAndType #7 #8; // #17     at 0xAE
+    NameAndType #5 #6; // #18     at 0xB3
+    Utf8 "java/lang/Object"; // #19     at 0xB8
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #4;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0xD5
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [2] { // methods
+    { // Member at 0xDF
+      0x0000; // access
+      #7; // name_cpx
+      #8; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 42) { // Code at 0xE7
+          2; // max_stack
+          1; // max_locals
+          Bytes[10]{
+            0x2AB700012A04B500;
+            0x02B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x0103
+              [3] { // LineNumberTable
+                0  4; //  at 0x010F
+                4  5; //  at 0x0113
+                9  6; //  at 0x0117
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0117
+      0x0008; // access
+      #11; // name_cpx
+      #14; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 44) { // Code at 0x011F
+          2; // max_stack
+          2; // max_locals
+          Bytes[12]{
+            0xCB00034C2B1ACC00; // Changed CP index from 2 to 1 for opcode 0xCC (withfield)
+            0x014C2BB0;         // so that the cp index no longer points to a cp Field entry.
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x013D
+              [3] { // LineNumberTable
+                0  8; //  at 0x0149
+                4  9; //  at 0x014D
+                10  10; //  at 0x0151
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [2] { // Attributes
+    Attr(#15, 2) { // SourceFile at 0x0153
+      #16;
+    } // end SourceFile
+    ;
+    Attr(#13, 4) { // ValueTypes at 0x015B
+      0x00010003;
+    } // end ValueTypes
+  } // Attributes
+} // end class wthFldWrongCPType
+
+///////////////////////////////////////////////////////////
+
+// A new fieldRef was added to the constant pool to point to a field in
+// java/lang/Object.  The withfield opcode (0XCC) was changed to use this new
+// cp entry.  This should cause a VerifyError because even though inline types
+// are assignable to java.lang.Object, withfield requires that the cp field class
+// and the inline type on the stack, in this case 'wthFldObject', be identical.
+//
+class wthFldObject {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [22] { // Constant Pool
+    ; // first element is empty
+    Method #4 #17; // #1     at 0x0A
+    Field #3 #18; // #2     at 0x0F
+    class #12; // #3     at 0x14
+    class #19; // #4     at 0x17
+    Utf8 "int_v"; // #5     at 0x1A
+    Utf8 "I"; // #6     at 0x22
+    Utf8 "<init>"; // #7     at 0x26
+    Utf8 "()V"; // #8     at 0x2F
+    Utf8 "Code"; // #9     at 0x35
+    Utf8 "LineNumberTable"; // #10     at 0x3C
+    Utf8 "makewthFldObject"; // #11     at 0x4E
+    Utf8 "wthFldObject"; // #12     at 0x60
+    Utf8 "ValueTypes"; // #13     at 0x6E
+    Utf8 "(I)LwthFldObject;"; // #14     at 0x7B
+    Utf8 "SourceFile"; // #15     at 0x8E
+    Utf8 "wthFldObject.java"; // #16     at 0x9B
+    NameAndType #7 #8; // #17     at 0xAE
+    NameAndType #5 #6; // #18     at 0xB3
+    Utf8 "java/lang/Object"; // #19     at 0xB8
+    class #19; // #20  // NEW ClassRef
+    Field #20 #18; // #21  // New FieldRef
+
+  } // Constant Pool
+
+  0x0130; // access [ ACC_VALUE, ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #4;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0xD5
+      0x0010; // access
+      #5; // name_cpx
+      #6; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [2] { // methods
+    { // Member at 0xDF
+      0x0000; // access
+      #7; // name_cpx
+      #8; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 42) { // Code at 0xE7
+          2; // max_stack
+          1; // max_locals
+          Bytes[10]{
+            0x2AB700012A04B500;
+            0x02B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x0103
+              [3] { // LineNumberTable
+                0  4; //  at 0x010F
+                4  5; //  at 0x0113
+                9  6; //  at 0x0117
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0117
+      0x0008; // access
+      #11; // name_cpx
+      #14; // sig_cpx
+      [1] { // Attributes
+        Attr(#9, 47) { // Code at 0x011F
+          2; // max_stack
+          2; // max_locals
+          Bytes[15]{
+            0xCB00034C2B1ACC00; // Changed withfield (0xCC) cp index at byte 8 to point to a field in
+            0x154C2BCB0003B0;   // in j.l.Object. Also, added a defaultvalue opcode at byte 11 to push
+          };                    // a Value ref so that the verifier won't complain if it sees the areturn.
+
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#10, 14) { // LineNumberTable at 0x013D
+              [3] { // LineNumberTable
+                0  8; //  at 0x0149
+                4  9; //  at 0x014D
+                10  10; //  at 0x0151
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [2] { // Attributes
+    Attr(#15, 2) { // SourceFile at 0x0153
+      #16;
+    } // end SourceFile
+    ;
+    Attr(#13, 4) { // ValueTypes at 0x015B
+      0x00010003;
+    } // end ValueTypes
+  } // Attributes
+} // end class wthFldObject
+
+///////////////////////////////////////////////////////////
+
+// The astore_1 opcode (0x4C) was changed to a monitorenter (0xC2) opcode but
+// the operand on the stack is an inline type.
+// This should cause a VerifyError because the operand for opcode monitorenter
+// cannot be an inline type.
+//
+class monEnterVT {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [46] { // Constant Pool
+    ; // first element is empty
+    class #23; // #1     at 0x0A
+    Field #1 #24; // #2     at 0x0D
+    InvokeDynamic 0s #27; // #3     at 0x12
+    InvokeDynamic 0s #28; // #4     at 0x17
+    InvokeDynamic 0s #29; // #5     at 0x1C
+    class #30; // #6     at 0x21
+    Utf8 "int_v"; // #7     at 0x24
+    Utf8 "I"; // #8     at 0x2C
+    Utf8 "makemonEnterVT"; // #9     at 0x30
+    Utf8 "(I)QmonEnterVT;"; // #10     at 0x41
+    Utf8 "Code"; // #11     at 0x53
+    Utf8 "LineNumberTable"; // #12     at 0x5A
+    Utf8 "hashCode"; // #13     at 0x6C
+    Utf8 "()I"; // #14     at 0x77
+    Utf8 "equals"; // #15     at 0x7D
+    Utf8 "(Ljava/lang/Object;)Z"; // #16     at 0x86
+    Utf8 "toString"; // #17     at 0x9E
+    Utf8 "()Ljava/lang/String;"; // #18     at 0xA9
+    Utf8 "<init>"; // #19     at 0xC0
+    Utf8 "()QmonEnterVT;"; // #20     at 0xC9
+    Utf8 "SourceFile"; // #21     at 0xDA
+    Utf8 "monEnterVT.java"; // #22     at 0xE7
+    Utf8 "monEnterVT"; // #23     at 0xF9
+    NameAndType #7 #8; // #24     at 0x0106
+    Utf8 "BootstrapMethods"; // #25     at 0x010B
+    MethodHandle 6b #31; // #26     at 0x011E
+    NameAndType #13 #32; // #27     at 0x0122
+    NameAndType #15 #33; // #28     at 0x0127
+    NameAndType #17 #34; // #29     at 0x012C
+    Utf8 "java/lang/Object"; // #30     at 0x0131
+    Method #35 #36; // #31     at 0x0144
+    Utf8 "(QmonEnterVT;)I"; // #32     at 0x0149
+    Utf8 "(QmonEnterVT;Ljava/lang/Object;)Z"; // #33     at 0x015B
+    Utf8 "(QmonEnterVT;)Ljava/lang/String;"; // #34     at 0x017F
+    class #37; // #35     at 0x01A2
+    NameAndType #38 #42; // #36     at 0x01A5
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #37     at 0x01AA
+    Utf8 "makeBootstrapMethod"; // #38     at 0x01D3
+    class #44; // #39     at 0x01E9
+    Utf8 "Lookup"; // #40     at 0x01EC
+    Utf8 "InnerClasses"; // #41     at 0x01F5
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #42     at 0x0204
+    class #45; // #43     at 0x027A
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #44     at 0x027D
+    Utf8 "java/lang/invoke/MethodHandles"; // #45     at 0x02A5
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #6;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0x02D0
+      0x0010; // access
+      #7; // name_cpx
+      #8; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [5] { // methods
+    { // Member at 0x02DA
+      0x0008; // access
+      #9; // name_cpx
+      #10; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 45) { // Code at 0x02E2
+          2; // max_stack
+          2; // max_locals
+          Bytes[13]{
+            0xCB0001C21A2B5FCC; // Changed bytecode at byte 3 from astore_1 to monitorenter.
+            0x00024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 14) { // LineNumberTable at 0x0301
+              [3] { // LineNumberTable
+                0  8; //  at 0x030D
+                4  9; //  at 0x0311
+                11  10; //  at 0x0315
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0315
+      0x0011; // access
+      #13; // name_cpx
+      #14; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 31) { // Code at 0x031D
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00030000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x0336
+              [1] { // LineNumberTable
+                0  1; //  at 0x0342
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0342
+      0x0011; // access
+      #15; // name_cpx
+      #16; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 32) { // Code at 0x034A
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA00040000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x0364
+              [1] { // LineNumberTable
+                0  1; //  at 0x0370
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0370
+      0x0011; // access
+      #17; // name_cpx
+      #18; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 31) { // Code at 0x0378
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00050000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x0391
+              [1] { // LineNumberTable
+                0  1; //  at 0x039D
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x039D
+      0x0008; // access
+      #19; // name_cpx
+      #20; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 45) { // Code at 0x03A5
+          2; // max_stack
+          1; // max_locals
+          Bytes[13]{
+            0xCB00014B042A5FCC;
+            0x00024B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 14) { // LineNumberTable at 0x03C4
+              [3] { // LineNumberTable
+                0  4; //  at 0x03D0
+                4  5; //  at 0x03D4
+                11  6; //  at 0x03D8
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#21, 2) { // SourceFile at 0x03DA
+      #22;
+    } // end SourceFile
+    ;
+    Attr(#41, 10) { // InnerClasses at 0x03E2
+      [1] { // InnerClasses
+        #39 #43 #40 25; //  at 0x03F2
+      }
+    } // end InnerClasses
+    ;
+    Attr(#25, 6) { // BootstrapMethods at 0x03F2
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #26; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class monEnterVT
+
+///////////////////////////////////////////////////////////
+
+// The cp entry for the defaultvalue opcode was changed to a reference that
+// is not an inline type.
+// This should cause a VerifyError because the cp entry for opcode defaultvalue
+// must be an inline type.
+//
+class defValueObj {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [46] { // Constant Pool
+    ; // first element is empty
+    class #23; // #1     at 0x0A
+    Field #1 #24; // #2     at 0x0D
+    InvokeDynamic 0s #27; // #3     at 0x12
+    InvokeDynamic 0s #28; // #4     at 0x17
+    InvokeDynamic 0s #29; // #5     at 0x1C
+    class #30; // #6     at 0x21
+    Utf8 "int_v"; // #7     at 0x24
+    Utf8 "I"; // #8     at 0x2C
+    Utf8 "makedefValueObj"; // #9     at 0x30
+    Utf8 "(I)QdefValueObj;"; // #10     at 0x41
+    Utf8 "Code"; // #11     at 0x53
+    Utf8 "LineNumberTable"; // #12     at 0x5A
+    Utf8 "hashCode"; // #13     at 0x6C
+    Utf8 "()I"; // #14     at 0x77
+    Utf8 "equals"; // #15     at 0x7D
+    Utf8 "(Ljava/lang/Object;)Z"; // #16     at 0x86
+    Utf8 "toString"; // #17     at 0x9E
+    Utf8 "()Ljava/lang/String;"; // #18     at 0xA9
+    Utf8 "<init>"; // #19     at 0xC0
+    Utf8 "()QdefValueObj;"; // #20     at 0xC9
+    Utf8 "SourceFile"; // #21     at 0xDA
+    Utf8 "defValueObj.java"; // #22     at 0xE7
+    Utf8 "defValueObj"; // #23     at 0xF9
+    NameAndType #7 #8; // #24     at 0x0106
+    Utf8 "BootstrapMethods"; // #25     at 0x010B
+    MethodHandle 6b #31; // #26     at 0x011E
+    NameAndType #13 #32; // #27     at 0x0122
+    NameAndType #15 #33; // #28     at 0x0127
+    NameAndType #17 #34; // #29     at 0x012C
+    Utf8 "java/lang/Object"; // #30     at 0x0131
+    Method #35 #36; // #31     at 0x0144
+    Utf8 "(QdefValueObj;)I"; // #32     at 0x0149
+    Utf8 "(QdefValueObj;Ljava/lang/Object;)Z"; // #33     at 0x015B
+    Utf8 "(QdefValueObj;)Ljava/lang/String;"; // #34     at 0x017F
+    class #37; // #35     at 0x01A2
+    NameAndType #38 #42; // #36     at 0x01A5
+    Utf8 "java/lang/invoke/ValueBootstrapMethods"; // #37     at 0x01AA
+    Utf8 "makeBootstrapMethod"; // #38     at 0x01D3
+    class #44; // #39     at 0x01E9
+    Utf8 "Lookup"; // #40     at 0x01EC
+    Utf8 "InnerClasses"; // #41     at 0x01F5
+    Utf8 "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"; // #42     at 0x0204
+    class #45; // #43     at 0x027A
+    Utf8 "java/lang/invoke/MethodHandles$Lookup"; // #44     at 0x027D
+    Utf8 "java/lang/invoke/MethodHandles"; // #45     at 0x02A5
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #1;// this_cpx
+  #6;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0x02D0
+      0x0010; // access
+      #7; // name_cpx
+      #8; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [5] { // methods
+    { // Member at 0x02DA
+      0x0008; // access
+      #9; // name_cpx
+      #10; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 45) { // Code at 0x02E2
+          2; // max_stack
+          2; // max_locals
+          Bytes[13]{
+            0xCB00044C1A2B5FCC; // Changed defaultvalue's cp index at byte 3 from 3 to 4.
+            0x00024C2BB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 14) { // LineNumberTable at 0x0301
+              [3] { // LineNumberTable
+                0  8; //  at 0x030D
+                4  9; //  at 0x0311
+                11  10; //  at 0x0315
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0315
+      0x0011; // access
+      #13; // name_cpx
+      #14; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 31) { // Code at 0x031D
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00030000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x0336
+              [1] { // LineNumberTable
+                0  1; //  at 0x0342
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0342
+      0x0011; // access
+      #15; // name_cpx
+      #16; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 32) { // Code at 0x034A
+          2; // max_stack
+          2; // max_locals
+          Bytes[8]{
+            0x2A2BBA00040000AC;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x0364
+              [1] { // LineNumberTable
+                0  1; //  at 0x0370
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0370
+      0x0011; // access
+      #17; // name_cpx
+      #18; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 31) { // Code at 0x0378
+          1; // max_stack
+          1; // max_locals
+          Bytes[7]{
+            0x2ABA00050000B0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 6) { // LineNumberTable at 0x0391
+              [1] { // LineNumberTable
+                0  1; //  at 0x039D
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x039D
+      0x0008; // access
+      #19; // name_cpx
+      #20; // sig_cpx
+      [1] { // Attributes
+        Attr(#11, 45) { // Code at 0x03A5
+          2; // max_stack
+          1; // max_locals
+          Bytes[13]{
+            0xCB00014B042A5FCC;
+            0x00024B2AB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#12, 14) { // LineNumberTable at 0x03C4
+              [3] { // LineNumberTable
+                0  4; //  at 0x03D0
+                4  5; //  at 0x03D4
+                11  6; //  at 0x03D8
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [3] { // Attributes
+    Attr(#21, 2) { // SourceFile at 0x03DA
+      #22;
+    } // end SourceFile
+    ;
+    Attr(#41, 10) { // InnerClasses at 0x03E2
+      [1] { // InnerClasses
+        #39 #43 #40 25; //  at 0x03F2
+      }
+    } // end InnerClasses
+    ;
+    Attr(#25, 6) { // BootstrapMethods at 0x03F2
+      [1] { // bootstrap_methods
+        {  //  bootstrap_method
+          #26; // bootstrap_method_ref
+          [0] { // bootstrap_arguments
+          }  //  bootstrap_arguments
+        }  //  bootstrap_method
+      }
+    } // end BootstrapMethods
+  } // Attributes
+} // end class defValueObj
+
+///////////////////////////////////////////////////////////
+
+// The operand for the inline type for the defaultvalue opcode was changed to a
+// reference that is not an inline type.
+// This should cause a VerifyError because the reference operand for a withfield
+// opcode must be an inline type.
+//
+class withfieldObj {
+  0xCAFEBABE;
+  0; // minor version
+  60; // version
+  [23] { // Constant Pool
+    ; // first element is empty
+    Method #5 #19; // #1     at 0x0A
+    Field #3 #20; // #2     at 0x0F
+    class #13; // #3     at 0x14
+    String #21; // #4     at 0x17
+    class #22; // #5     at 0x1A
+    Utf8 "int_v"; // #6     at 0x1D
+    Utf8 "I"; // #7     at 0x25
+    Utf8 "<init>"; // #8     at 0x29
+    Utf8 "()V"; // #9     at 0x32
+    Utf8 "Code"; // #10     at 0x38
+    Utf8 "LineNumberTable"; // #11     at 0x3F
+    Utf8 "makewithfieldObj"; // #12     at 0x51
+    Utf8 "withfieldObj"; // #13     at 0x64
+    Utf8 "ValueTypes"; // #14     at 0x73
+    Utf8 "(ILjava/lang/String;)LwithfieldObj;"; // #15     at 0x80
+    Utf8 "StackMapTable"; // #16     at 0xA6
+    Utf8 "SourceFile"; // #17     at 0xB6
+    Utf8 "withfieldObj.java"; // #18     at 0xC3
+    NameAndType #8 #9; // #19     at 0xD7
+    NameAndType #6 #7; // #20     at 0xDC
+    Utf8 "CDE"; // #21     at 0xE1
+    Utf8 "java/lang/Object"; // #22     at 0xE7
+  } // Constant Pool
+
+  0x0130; // access [ ACC_SUPER ACC_FINAL ]
+  #3;// this_cpx
+  #5;// super_cpx
+
+  [0] { // Interfaces
+  } // Interfaces
+
+  [1] { // fields
+    { // Member at 0x0104
+      0x0010; // access
+      #6; // name_cpx
+      #7; // sig_cpx
+      [0] { // Attributes
+      } // Attributes
+    } // Member
+  } // fields
+
+  [2] { // methods
+    { // Member at 0x010E
+      0x0000; // access
+      #8; // name_cpx
+      #9; // sig_cpx
+      [1] { // Attributes
+        Attr(#10, 42) { // Code at 0x0116
+          2; // max_stack
+          1; // max_locals
+          Bytes[10]{
+            0x2AB700012A04B500;
+            0x02B1;
+          };
+          [0] { // Traps
+          } // end Traps
+          [1] { // Attributes
+            Attr(#11, 14) { // LineNumberTable at 0x0132
+              [3] { // LineNumberTable
+                0  3; //  at 0x013E
+                4  4; //  at 0x0142
+                9  5; //  at 0x0146
+              }
+            } // end LineNumberTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+    ;
+    { // Member at 0x0146
+      0x0008; // access
+      #12; // name_cpx
+      #15; // sig_cpx
+      [1] { // Attributes
+        Attr(#10, 68) { // Code at 0x014E
+          2; // max_stack
+          3; // max_locals
+          Bytes[18]{
+            0xCB00034D2B1204A5;
+            0x00092B1ACC00024D; // Changed aload_2 (0x2C) to aload_1 (0x2B) at byte 3.
+            0x2CB0;
+          };
+          [0] { // Traps
+          } // end Traps
+          [2] { // Attributes
+            Attr(#11, 18) { // LineNumberTable at 0x0172
+              [4] { // LineNumberTable
+                0  7; //  at 0x017E
+                4  8; //  at 0x0182
+                10  9; //  at 0x0186
+                16  11; //  at 0x018A
+              }
+            } // end LineNumberTable
+            ;
+            Attr(#16, 8) { // StackMapTable at 0x018A
+              [1] { //
+                252b, 16, [1]z{7b,3}; // append_frame 1
+              }
+            } // end StackMapTable
+          } // Attributes
+        } // end Code
+      } // Attributes
+    } // Member
+  } // methods
+
+  [2] { // Attributes
+    Attr(#17, 2) { // SourceFile at 0x019A
+      #18;
+    } // end SourceFile
+    ;
+    Attr(#14, 4) { // ValueTypes at 0x01A2
+      0x00010003;
+    } // end ValueTypes
+  } // Attributes
+} // end class withfieldObj

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciEnv.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */

  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/packageEntry.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/verificationType.hpp&quot;
  40 #include &quot;classfile/verifier.hpp&quot;
  41 #include &quot;classfile/vmSymbols.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/annotations.hpp&quot;
  50 #include &quot;oops/constantPool.inline.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  54 #include &quot;oops/klass.inline.hpp&quot;
  55 #include &quot;oops/klassVtable.hpp&quot;
  56 #include &quot;oops/metadata.hpp&quot;
  57 #include &quot;oops/method.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/recordComponent.hpp&quot;
  60 #include &quot;oops/symbol.hpp&quot;

  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/os.hpp&quot;
  68 #include &quot;runtime/perfData.hpp&quot;
  69 #include &quot;runtime/reflection.hpp&quot;
  70 #include &quot;runtime/safepointVerifiers.hpp&quot;
  71 #include &quot;runtime/signature.hpp&quot;
  72 #include &quot;runtime/timer.hpp&quot;
  73 #include &quot;services/classLoadingService.hpp&quot;
  74 #include &quot;services/threadService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/bitMap.inline.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/exceptions.hpp&quot;
  79 #include &quot;utilities/globalDefinitions.hpp&quot;
  80 #include &quot;utilities/growableArray.hpp&quot;
  81 #include &quot;utilities/macros.hpp&quot;
  82 #include &quot;utilities/ostream.hpp&quot;
  83 #include &quot;utilities/resourceHash.hpp&quot;

  84 #include &quot;utilities/utf8.hpp&quot;
  85 
  86 #if INCLUDE_CDS
  87 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  88 #endif
  89 #if INCLUDE_JFR
  90 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  91 #endif
  92 
  93 // We generally try to create the oops directly when parsing, rather than
  94 // allocating temporary data structures and copying the bytes twice. A
  95 // temporary area is only needed when parsing utf8 entries in the constant
  96 // pool and when parsing line number tables.
  97 
  98 // We add assert in debug mode when class format is not checked.
  99 
 100 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 101 #define JAVA_MIN_SUPPORTED_VERSION        45
 102 #define JAVA_PREVIEW_MINOR_VERSION        65535
 103 
</pre>
<hr />
<pre>
 117 
 118 // Extension method support.
 119 #define JAVA_8_VERSION                    52
 120 
 121 #define JAVA_9_VERSION                    53
 122 
 123 #define JAVA_10_VERSION                   54
 124 
 125 #define JAVA_11_VERSION                   55
 126 
 127 #define JAVA_12_VERSION                   56
 128 
 129 #define JAVA_13_VERSION                   57
 130 
 131 #define JAVA_14_VERSION                   58
 132 
 133 #define JAVA_15_VERSION                   59
 134 
 135 #define JAVA_16_VERSION                   60
 136 


 137 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 138   assert((bad_constant == JVM_CONSTANT_Module ||
 139           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 140          &quot;Unexpected bad constant pool entry&quot;);
 141   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 142 }
 143 
 144 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 145                                                   ConstantPool* cp,
 146                                                   const int length,
 147                                                   TRAPS) {
 148   assert(stream != NULL, &quot;invariant&quot;);
 149   assert(cp != NULL, &quot;invariant&quot;);
 150 
 151   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 152   // this function (_current can be allocated in a register, with scalar
 153   // replacement of aggregates). The _current pointer is copied back to
 154   // stream() when this function returns. DON&#39;T call another method within
 155   // this method that uses stream().
 156   const ClassFileStream cfs1 = *stream;
 157   const ClassFileStream* const cfs = &amp;cfs1;
 158 
 159   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 160   debug_only(const u1* const old_current = stream-&gt;current();)
 161 
 162   // Used for batching symbol allocations.
 163   const char* names[SymbolTable::symbol_alloc_batch_size];
 164   int lengths[SymbolTable::symbol_alloc_batch_size];
 165   int indices[SymbolTable::symbol_alloc_batch_size];
 166   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 167   int names_count = 0;
 168 
 169   // parsing  Index 0 is unused
 170   for (int index = 1; index &lt; length; index++) {
 171     // Each of the following case guarantees one more byte in the stream
 172     // for the following tag or the access_flags following constant pool,
 173     // so we don&#39;t need bounds-check for reading tag.
 174     const u1 tag = cfs-&gt;get_u1_fast();
 175     switch (tag) {
<span class="line-modified"> 176       case JVM_CONSTANT_Class : {</span>
 177         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 178         const u2 name_index = cfs-&gt;get_u2_fast();
 179         cp-&gt;klass_index_at_put(index, name_index);
 180         break;
 181       }
 182       case JVM_CONSTANT_Fieldref: {
 183         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 184         const u2 class_index = cfs-&gt;get_u2_fast();
 185         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 186         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 187         break;
 188       }
 189       case JVM_CONSTANT_Methodref: {
 190         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 191         const u2 class_index = cfs-&gt;get_u2_fast();
 192         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 193         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 194         break;
 195       }
 196       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 486         check_property(valid_symbol_at(name_ref_index),
 487           &quot;Invalid constant pool index %u in class file %s&quot;,
 488           name_ref_index, CHECK);
 489         check_property(valid_symbol_at(signature_ref_index),
 490           &quot;Invalid constant pool index %u in class file %s&quot;,
 491           signature_ref_index, CHECK);
 492         break;
 493       }
 494       case JVM_CONSTANT_Utf8:
 495         break;
 496       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 497       case JVM_CONSTANT_UnresolvedClassInError: {
 498         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 499         break;
 500       }
 501       case JVM_CONSTANT_ClassIndex: {
 502         const int class_index = cp-&gt;klass_index_at(index);
 503         check_property(valid_symbol_at(class_index),
 504           &quot;Invalid constant pool index %u in class file %s&quot;,
 505           class_index, CHECK);
<span class="line-modified"> 506         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>







 507         break;
 508       }
 509       case JVM_CONSTANT_StringIndex: {
 510         const int string_index = cp-&gt;string_index_at(index);
 511         check_property(valid_symbol_at(string_index),
 512           &quot;Invalid constant pool index %u in class file %s&quot;,
 513           string_index, CHECK);
 514         Symbol* const sym = cp-&gt;symbol_at(string_index);
 515         cp-&gt;unresolved_string_at_put(index, sym);
 516         break;
 517       }
 518       case JVM_CONSTANT_MethodHandle: {
 519         const int ref_index = cp-&gt;method_handle_index_at(index);
 520         check_property(valid_cp_range(ref_index, length),
 521           &quot;Invalid constant pool index %u in class file %s&quot;,
 522           ref_index, CHECK);
 523         const constantTag tag = cp-&gt;tag_at(ref_index);
 524         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 525 
 526         switch (ref_kind) {
</pre>
<hr />
<pre>
 740             classfile_parse_error(
 741               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 742               name_ref_index, CHECK);
 743           }
 744         }
 745         break;
 746       }
 747       case JVM_CONSTANT_MethodHandle: {
 748         const int ref_index = cp-&gt;method_handle_index_at(index);
 749         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 750         switch (ref_kind) {
 751           case JVM_REF_invokeVirtual:
 752           case JVM_REF_invokeStatic:
 753           case JVM_REF_invokeSpecial:
 754           case JVM_REF_newInvokeSpecial: {
 755             const int name_and_type_ref_index =
 756               cp-&gt;name_and_type_ref_index_at(ref_index);
 757             const int name_ref_index =
 758               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 759             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 760             if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-modified"> 761               if (name != vmSymbols::object_initializer_name()) {</span>
 762                 classfile_parse_error(
 763                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 764                     name_ref_index, CHECK);
 765               }
 766             } else {
<span class="line-modified"> 767               if (name == vmSymbols::object_initializer_name()) {</span>











 768                 classfile_parse_error(
 769                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 770                   name_ref_index, CHECK);
 771               }
 772             }
 773             break;
 774           }
 775           // Other ref_kinds are already fully checked in previous pass.
 776         } // switch(ref_kind)
 777         break;
 778       }
 779       case JVM_CONSTANT_MethodType: {
 780         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 781         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 782         verify_legal_method_signature(no_name, signature, CHECK);
 783         break;
 784       }
 785       case JVM_CONSTANT_Utf8: {
 786         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 787       }
</pre>
<hr />
<pre>
 906   while (entry != NULL) {
 907     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 908       return false;
 909     }
 910     entry = entry-&gt;_next;
 911   }
 912 
 913   // No duplicate is found, allocate a new entry and fill it.
 914   entry = new NameSigHash();
 915   entry-&gt;_name = name;
 916   entry-&gt;_sig = sig;
 917 
 918   // Insert into hash table
 919   entry-&gt;_next = table[index];
 920   table[index] = entry;
 921 
 922   return true;
 923 }
 924 
 925 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 926 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified"> 927                                        const int itfs_len,</span>
<span class="line-modified"> 928                                        ConstantPool* const cp,</span>

 929                                        bool* const has_nonstatic_concrete_methods,







 930                                        TRAPS) {
 931   assert(stream != NULL, &quot;invariant&quot;);
 932   assert(cp != NULL, &quot;invariant&quot;);
 933   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 934 
 935   if (itfs_len == 0) {
<span class="line-modified"> 936     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
 937   } else {
 938     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 939     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-modified"> 940 </span>
<span class="line-removed"> 941     int index;</span>
 942     for (index = 0; index &lt; itfs_len; index++) {
 943       const u2 interface_index = stream-&gt;get_u2(CHECK);
 944       Klass* interf;
 945       check_property(
 946         valid_klass_reference_at(interface_index),
 947         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 948         interface_index, CHECK);
 949       if (cp-&gt;tag_at(interface_index).is_klass()) {
 950         interf = cp-&gt;resolved_klass_at(interface_index);
 951       } else {
 952         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 953 
 954         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 955         // But need to make sure it&#39;s not an array type.
 956         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 957                            &quot;Bad interface name in class file %s&quot;, CHECK);
 958 
<span class="line-modified"> 959         // Call resolve_super so classcircularity is checked</span>
 960         interf = SystemDictionary::resolve_super_or_fail(
 961                                                   _class_name,
 962                                                   unresolved_klass,
 963                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 964                                                   _protection_domain,
 965                                                   false,
 966                                                   CHECK);
 967       }
 968 
 969       if (!interf-&gt;is_interface()) {
 970         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 971                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 972                           _class_name-&gt;as_klass_external_name(),
 973                           interf-&gt;external_name(),
 974                           interf-&gt;class_in_module_of_loader()));
 975       }
 976 
<span class="line-modified"> 977       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>













 978         *has_nonstatic_concrete_methods = true;
 979       }
<span class="line-modified"> 980       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>






 981     }
 982 
 983     if (!_need_verify || itfs_len &lt;= 1) {
 984       return;
 985     }
 986 
 987     // Check if there&#39;s any duplicates in interfaces
 988     ResourceMark rm(THREAD);
 989     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 990                                                                  NameSigHash*,
 991                                                                  HASH_ROW_SIZE);
 992     initialize_hashtable(interface_names);
 993     bool dup = false;
 994     const Symbol* name = NULL;
 995     {
 996       debug_only(NoSafepointVerifier nsv;)
 997       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified"> 998         const InstanceKlass* const k = _local_interfaces-&gt;at(index);</span>
 999         name = k-&gt;name();
1000         // If no duplicates, add (name, NULL) in hashtable interface_names.
1001         if (!put_after_lookup(name, NULL, interface_names)) {
1002           dup = true;
1003           break;
1004         }
1005       }
1006     }
1007     if (dup) {
1008       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1009                              name-&gt;as_C_string(), CHECK);
1010     }
1011   }
1012 }
1013 
1014 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1015                                            int constantvalue_index,
1016                                            int signature_index,
1017                                            TRAPS) const {
1018   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1454                                             CHECK);
1455   parsed_annotations-&gt;set_field_annotations(a);
1456   a = assemble_annotations(runtime_visible_type_annotations,
1457                            runtime_visible_type_annotations_length,
1458                            runtime_invisible_type_annotations,
1459                            runtime_invisible_type_annotations_length,
1460                            CHECK);
1461   parsed_annotations-&gt;set_field_type_annotations(a);
1462   return;
1463 }
1464 
1465 
1466 // Field allocation types. Used for computing field offsets.
1467 
1468 enum FieldAllocationType {
1469   STATIC_OOP,           // Oops
1470   STATIC_BYTE,          // Boolean, Byte, char
1471   STATIC_SHORT,         // shorts
1472   STATIC_WORD,          // ints
1473   STATIC_DOUBLE,        // aligned long or double

1474   NONSTATIC_OOP,
1475   NONSTATIC_BYTE,
1476   NONSTATIC_SHORT,
1477   NONSTATIC_WORD,
1478   NONSTATIC_DOUBLE,

1479   MAX_FIELD_ALLOCATION_TYPE,
1480   BAD_ALLOCATION_TYPE = -1
1481 };
1482 
1483 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1484   BAD_ALLOCATION_TYPE, // 0
1485   BAD_ALLOCATION_TYPE, // 1
1486   BAD_ALLOCATION_TYPE, // 2
1487   BAD_ALLOCATION_TYPE, // 3
1488   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1489   NONSTATIC_SHORT,     // T_CHAR        =  5,
1490   NONSTATIC_WORD,      // T_FLOAT       =  6,
1491   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1492   NONSTATIC_BYTE,      // T_BYTE        =  8,
1493   NONSTATIC_SHORT,     // T_SHORT       =  9,
1494   NONSTATIC_WORD,      // T_INT         = 10,
1495   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1496   NONSTATIC_OOP,       // T_OBJECT      = 12,
1497   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1498   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1499   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1500   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1501   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1502   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1503   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1504   BAD_ALLOCATION_TYPE, // 0
1505   BAD_ALLOCATION_TYPE, // 1
1506   BAD_ALLOCATION_TYPE, // 2
1507   BAD_ALLOCATION_TYPE, // 3
1508   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1509   STATIC_SHORT,        // T_CHAR        =  5,
1510   STATIC_WORD,         // T_FLOAT       =  6,
1511   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1512   STATIC_BYTE,         // T_BYTE        =  8,
1513   STATIC_SHORT,        // T_SHORT       =  9,
1514   STATIC_WORD,         // T_INT         = 10,
1515   STATIC_DOUBLE,       // T_LONG        = 11,
1516   STATIC_OOP,          // T_OBJECT      = 12,
1517   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1518   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1519   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1520   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1521   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1522   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1523   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1524 };
1525 
<span class="line-modified">1526 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {</span>
1527   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1528   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1529   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);



1530   return result;
1531 }
1532 
1533 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1534  public:
1535   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1536 
1537   FieldAllocationCount() {
1538     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1539       count[i] = 0;
1540     }
1541   }
1542 
<span class="line-modified">1543   FieldAllocationType update(bool is_static, BasicType type) {</span>
<span class="line-modified">1544     FieldAllocationType atype = basic_type_to_atype(is_static, type);</span>
1545     if (atype != BAD_ALLOCATION_TYPE) {
1546       // Make sure there is no overflow with injected fields.
1547       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1548       count[atype]++;
1549     }
1550     return atype;
1551   }
1552 };
1553 
1554 // Side-effects: populates the _fields, _fields_annotations,
1555 // _fields_type_annotations fields
1556 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1557                                    bool is_interface,

1558                                    FieldAllocationCount* const fac,
1559                                    ConstantPool* cp,
1560                                    const int cp_size,
1561                                    u2* const java_fields_count_ptr,
1562                                    TRAPS) {
1563 
1564   assert(cfs != NULL, &quot;invariant&quot;);
1565   assert(fac != NULL, &quot;invariant&quot;);
1566   assert(cp != NULL, &quot;invariant&quot;);
1567   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1568 
1569   assert(NULL == _fields, &quot;invariant&quot;);
1570   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1571   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1572 
1573   cfs-&gt;guarantee_more(2, CHECK);  // length
1574   const u2 length = cfs-&gt;get_u2_fast();
1575   *java_fields_count_ptr = length;
1576 
1577   int num_injected = 0;
1578   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1579                                                                   &amp;num_injected);
<span class="line-modified">1580   const int total_fields = length + num_injected;</span>




1581 
1582   // The field array starts with tuples of shorts
1583   // [access, name index, sig index, initial value index, byte offset].
1584   // A generic signature slot only exists for field with generic
1585   // signature attribute. And the access flag is set with
1586   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1587   // signature slots are at the end of the field array and after all
1588   // other fields data.
1589   //
1590   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1591   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1592   //       ...
1593   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1594   //       [generic signature index]
1595   //       [generic signature index]
1596   //       ...
1597   //
1598   // Allocate a temporary resource array for field data. For each field,
1599   // a slot is reserved in the temporary array for the generic signature
1600   // index. After parsing all fields, the data are copied to a permanent
1601   // array and any unused slots will be discarded.
1602   ResourceMark rm(THREAD);
1603   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1604                                               u2,
1605                                               total_fields * (FieldInfo::field_slots + 1));
1606 
1607   // The generic signature slots start after all other fields&#39; data.
1608   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1609   int num_generic_signature = 0;

1610   for (int n = 0; n &lt; length; n++) {
1611     // access_flags, name_index, descriptor_index, attributes_count
1612     cfs-&gt;guarantee_more(8, CHECK);
1613 




1614     AccessFlags access_flags;
<span class="line-removed">1615     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-removed">1616     verify_legal_field_modifiers(flags, is_interface, CHECK);</span>
1617     access_flags.set_flags(flags);
1618 
1619     const u2 name_index = cfs-&gt;get_u2_fast();
1620     check_property(valid_symbol_at(name_index),
1621       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1622       name_index, CHECK);
1623     const Symbol* const name = cp-&gt;symbol_at(name_index);
1624     verify_legal_field_name(name, CHECK);
1625 
1626     const u2 signature_index = cfs-&gt;get_u2_fast();
1627     check_property(valid_symbol_at(signature_index),
1628       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1629       signature_index, CHECK);
1630     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1631     verify_legal_field_signature(name, sig, CHECK);

1632 
1633     u2 constantvalue_index = 0;
1634     bool is_synthetic = false;
1635     u2 generic_signature_index = 0;
1636     const bool is_static = access_flags.is_static();
1637     FieldAnnotationCollector parsed_annotations(_loader_data);
1638 
1639     const u2 attributes_count = cfs-&gt;get_u2_fast();
1640     if (attributes_count &gt; 0) {
1641       parse_field_attributes(cfs,
1642                              attributes_count,
1643                              is_static,
1644                              signature_index,
1645                              &amp;constantvalue_index,
1646                              &amp;is_synthetic,
1647                              &amp;generic_signature_index,
1648                              &amp;parsed_annotations,
1649                              CHECK);
1650 
1651       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1671 
1672       if (is_synthetic) {
1673         access_flags.set_is_synthetic();
1674       }
1675       if (generic_signature_index != 0) {
1676         access_flags.set_field_has_generic_signature();
1677         fa[generic_signature_slot] = generic_signature_index;
1678         generic_signature_slot ++;
1679         num_generic_signature ++;
1680       }
1681     }
1682 
1683     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1684     field-&gt;initialize(access_flags.as_short(),
1685                       name_index,
1686                       signature_index,
1687                       constantvalue_index);
1688     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1689 
1690     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1691     const FieldAllocationType atype = fac-&gt;update(is_static, type);</span>
1692     field-&gt;set_allocation_type(atype);
1693 
1694     // After field is initialized with type, we can augment it with aux info
1695     if (parsed_annotations.has_any_annotations()) {
1696       parsed_annotations.apply_to(field);
1697       if (field-&gt;is_contended()) {
1698         _has_contended_fields = true;
1699       }
1700     }
1701   }
1702 
1703   int index = length;
1704   if (num_injected != 0) {
1705     for (int n = 0; n &lt; num_injected; n++) {
1706       // Check for duplicates
1707       if (injected[n].may_be_java) {
1708         const Symbol* const name      = injected[n].name();
1709         const Symbol* const signature = injected[n].signature();
1710         bool duplicate = false;
1711         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1716             duplicate = true;
1717             break;
1718           }
1719         }
1720         if (duplicate) {
1721           // These will be removed from the field array at the end
1722           continue;
1723         }
1724       }
1725 
1726       // Injected field
1727       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1728       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1729                         injected[n].name_index,
1730                         injected[n].signature_index,
1731                         0);
1732 
1733       const BasicType type = Signature::basic_type(injected[n].signature());
1734 
1735       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1736       const FieldAllocationType atype = fac-&gt;update(false, type);</span>
1737       field-&gt;set_allocation_type(atype);
1738       index++;
1739     }
1740   }
1741 





























1742   assert(NULL == _fields, &quot;invariant&quot;);
1743 
1744   _fields =
1745     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1746                                    index * FieldInfo::field_slots + num_generic_signature,
1747                                    CHECK);
1748   // Sometimes injected fields already exist in the Java source so
1749   // the fields array could be too long.  In that case the
1750   // fields array is trimed. Also unused slots that were reserved
1751   // for generic signature indexes are discarded.
1752   {
1753     int i = 0;
1754     for (; i &lt; index * FieldInfo::field_slots; i++) {
1755       _fields-&gt;at_put(i, fa[i]);
1756     }
1757     for (int j = total_fields * FieldInfo::field_slots;
1758          j &lt; generic_signature_slot; j++) {
1759       _fields-&gt;at_put(i++, fa[j]);
1760     }
1761     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2037         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2038         checked_exception, CHECK_NULL);
2039     }
2040   }
2041   // check exceptions attribute length
2042   if (_need_verify) {
2043     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2044                                                    sizeof(u2) * size),
2045                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2046   }
2047   return checked_exceptions_start;
2048 }
2049 
2050 void ClassFileParser::throwIllegalSignature(const char* type,
2051                                             const Symbol* name,
2052                                             const Symbol* sig,
2053                                             TRAPS) const {
2054   assert(name != NULL, &quot;invariant&quot;);
2055   assert(sig != NULL, &quot;invariant&quot;);
2056 





2057   ResourceMark rm(THREAD);
2058   Exceptions::fthrow(THREAD_AND_LOCATION,
2059       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2060       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2061       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());</span>
2062 }
2063 
2064 AnnotationCollector::ID
2065 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2066                                       const Symbol* name,
2067                                       const bool can_access_vm_annotations) {
2068   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2069   // Privileged code can use all annotations.  Other code silently drops some.
2070   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2071                           loader_data-&gt;is_platform_class_loader_data() ||
2072                           can_access_vm_annotations;
2073   switch (sid) {
2074     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2075       if (_location != _in_method)  break;  // only allow for methods
2076       if (!privileged)              break;  // only allow in privileged code
2077       return _method_CallerSensitive;
2078     }
2079     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2080       if (_location != _in_method)  break;  // only allow for methods
2081       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2306                              runtime_visible_type_annotations_length,
2307                              runtime_invisible_type_annotations,
2308                              runtime_invisible_type_annotations_length,
2309                              CHECK);
2310     cm-&gt;set_type_annotations(a);
2311   }
2312 }
2313 
2314 
2315 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2316 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2317 // Method* to save footprint, so we only know the size of the resulting Method* when the
2318 // entire method attribute is parsed.
2319 //
2320 // The promoted_flags parameter is used to pass relevant access_flags
2321 // from the method back up to the containing klass. These flag values
2322 // are added to klass&#39;s access_flags.
2323 
2324 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2325                                       bool is_interface,

2326                                       const ConstantPool* cp,
2327                                       AccessFlags* const promoted_flags,
2328                                       TRAPS) {
2329   assert(cfs != NULL, &quot;invariant&quot;);
2330   assert(cp != NULL, &quot;invariant&quot;);
2331   assert(promoted_flags != NULL, &quot;invariant&quot;);
2332 
2333   ResourceMark rm(THREAD);
2334   // Parse fixed parts:
2335   // access_flags, name_index, descriptor_index, attributes_count
2336   cfs-&gt;guarantee_more(8, CHECK_NULL);
2337 
2338   int flags = cfs-&gt;get_u2_fast();
2339   const u2 name_index = cfs-&gt;get_u2_fast();
2340   const int cp_size = cp-&gt;length();
2341   check_property(
2342     valid_symbol_at(name_index),
2343     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2344     name_index, CHECK_NULL);
2345   const Symbol* const name = cp-&gt;symbol_at(name_index);
2346   verify_legal_method_name(name, CHECK_NULL);
2347 
2348   const u2 signature_index = cfs-&gt;get_u2_fast();
2349   guarantee_property(
2350     valid_symbol_at(signature_index),
2351     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2352     signature_index, CHECK_NULL);
2353   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2354 
2355   if (name == vmSymbols::class_initializer_name()) {
2356     // We ignore the other access flags for a valid class initializer.
2357     // (JVM Spec 2nd ed., chapter 4.6)
2358     if (_major_version &lt; 51) { // backward compatibility
2359       flags = JVM_ACC_STATIC;
2360     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2361       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2362     } else {
2363       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2364     }
2365   } else {
<span class="line-modified">2366     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);</span>
<span class="line-modified">2367   }</span>
<span class="line-modified">2368 </span>
<span class="line-modified">2369   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {</span>
<span class="line-modified">2370     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>










































2371   }
2372 
2373   int args_size = -1;  // only used when _need_verify is true
2374   if (_need_verify) {
2375     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2376                  verify_legal_method_signature(name, signature, CHECK_NULL);
2377     if (args_size &gt; MAX_ARGS_SIZE) {
2378       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2379     }
2380   }
2381 
2382   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2383 
2384   // Default values for code and exceptions attribute elements
2385   u2 max_stack = 0;
2386   u2 max_locals = 0;
2387   u4 code_length = 0;
2388   const u1* code_start = 0;
2389   u2 exception_table_length = 0;
2390   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
2901       _has_finalizer = true;
2902     }
2903   }
2904   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2905       signature == vmSymbols::void_method_signature() &amp;&amp;
2906       m-&gt;is_vanilla_constructor()) {
2907     _has_vanilla_constructor = true;
2908   }
2909 
2910   NOT_PRODUCT(m-&gt;verify());
2911   return m;
2912 }
2913 
2914 
2915 // The promoted_flags parameter is used to pass relevant access_flags
2916 // from the methods back up to the containing klass. These flag values
2917 // are added to klass&#39;s access_flags.
2918 // Side-effects: populates the _methods field in the parser
2919 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2920                                     bool is_interface,

2921                                     AccessFlags* promoted_flags,
2922                                     bool* has_final_method,
2923                                     bool* declares_nonstatic_concrete_methods,
2924                                     TRAPS) {
2925   assert(cfs != NULL, &quot;invariant&quot;);
2926   assert(promoted_flags != NULL, &quot;invariant&quot;);
2927   assert(has_final_method != NULL, &quot;invariant&quot;);
2928   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2929 
2930   assert(NULL == _methods, &quot;invariant&quot;);
2931 
2932   cfs-&gt;guarantee_more(2, CHECK);  // length
2933   const u2 length = cfs-&gt;get_u2_fast();
2934   if (length == 0) {
2935     _methods = Universe::the_empty_method_array();
2936   } else {
2937     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2938                                                    length,
2939                                                    NULL,
2940                                                    CHECK);
2941 
2942     for (int index = 0; index &lt; length; index++) {
2943       Method* method = parse_method(cfs,
2944                                     is_interface,

2945                                     _cp,
2946                                     promoted_flags,
2947                                     CHECK);
2948 
2949       if (method-&gt;is_final()) {
2950         *has_final_method = true;
2951       }
2952       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2953       // used for interface initialization, and default method inheritance analysis
2954       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2955         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2956         *declares_nonstatic_concrete_methods = true;
2957       }
2958       _methods-&gt;at_put(index, method);
2959     }
2960 
2961     if (_need_verify &amp;&amp; length &gt; 1) {
2962       // Check duplicated methods
2963       ResourceMark rm(THREAD);
2964       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3117       valid_klass_reference_at(inner_class_info_index),
3118       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3119       inner_class_info_index, CHECK_0);
3120     // Outer class index
3121     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3122     check_property(
3123       outer_class_info_index == 0 ||
3124         valid_klass_reference_at(outer_class_info_index),
3125       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3126       outer_class_info_index, CHECK_0);
3127     // Inner class name
3128     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3129     check_property(
3130       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3131       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3132       inner_name_index, CHECK_0);
3133     if (_need_verify) {
3134       guarantee_property(inner_class_info_index != outer_class_info_index,
3135                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3136     }
<span class="line-modified">3137     // Access flags</span>
<span class="line-modified">3138     jint flags;</span>
3139     // JVM_ACC_MODULE is defined in JDK-9 and later.
3140     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3141       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">3142     } else {</span>
<span class="line-modified">3143       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;</span>


3144     }




3145     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3146       // Set abstract bit for old class files for backward compatibility
3147       flags |= JVM_ACC_ABSTRACT;
3148     }
3149     verify_legal_class_modifiers(flags, CHECK_0);
3150     AccessFlags inner_access_flags(flags);
3151 
3152     inner_classes-&gt;at_put(index++, inner_class_info_index);
3153     inner_classes-&gt;at_put(index++, outer_class_info_index);
3154     inner_classes-&gt;at_put(index++, inner_name_index);
3155     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3156   }
3157 
3158   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3159   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3160     for(int i = 0; i &lt; length * 4; i += 4) {
3161       for(int j = i + 4; j &lt; length * 4; j += 4) {
3162         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3163                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3164                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
3984       }
3985     }
3986     if (runtime_invisible_annotations != NULL) {
3987       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3988         int append = runtime_visible_annotations_length+i;
3989         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3990       }
3991     }
3992   }
3993   return annotations;
3994 }
3995 
3996 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3997                                                         const int super_class_index,
3998                                                         const bool need_verify,
3999                                                         TRAPS) {
4000   assert(cp != NULL, &quot;invariant&quot;);
4001   const InstanceKlass* super_klass = NULL;
4002 
4003   if (super_class_index == 0) {
<span class="line-modified">4004     check_property(_class_name == vmSymbols::java_lang_Object(),</span>

4005                    &quot;Invalid superclass index %u in class file %s&quot;,
4006                    super_class_index,
4007                    CHECK_NULL);
4008   } else {
4009     check_property(valid_klass_reference_at(super_class_index),
4010                    &quot;Invalid superclass index %u in class file %s&quot;,
4011                    super_class_index,
4012                    CHECK_NULL);
4013     // The class name should be legal because it is checked when parsing constant pool.
4014     // However, make sure it is not an array type.
4015     bool is_array = false;
4016     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4017       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4018       if (need_verify)
4019         is_array = super_klass-&gt;is_array_klass();
4020     } else if (need_verify) {
4021       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4022     }
4023     if (need_verify) {
4024       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4164 }
4165 
4166 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4167   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4168   if (_nonstatic_oop_map_count &gt; 0) {
4169     OopMapBlock* map = _nonstatic_oop_maps;
4170     OopMapBlock* last_map = last_oop_map();
4171     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4172     while (map &lt;= last_map) {
4173       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4174                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4175       map++;
4176     }
4177   }
4178 }
4179 
4180 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4181   print_on(st);
4182 }
4183 



















4184 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4185 void ClassFileParser::layout_fields(ConstantPool* cp,
4186                                     const FieldAllocationCount* fac,
4187                                     const ClassAnnotationCollector* parsed_annotations,
4188                                     FieldLayoutInfo* info,
4189                                     TRAPS) {
4190 
4191   assert(cp != NULL, &quot;invariant&quot;);
4192 
4193   // Field size and offset computation
4194   int nonstatic_field_size = _super_klass == NULL ? 0 :
4195                                _super_klass-&gt;nonstatic_field_size();






4196 
4197   // Count the contended fields by type.
4198   //
4199   // We ignore static fields, because @Contended is not supported for them.
4200   // The layout code below will also ignore the static fields.
4201   int nonstatic_contended_count = 0;
4202   FieldAllocationCount fac_contended;
4203   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4204     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4205     if (fs.is_contended()) {
4206       fac_contended.count[atype]++;
4207       if (!fs.access_flags().is_static()) {
4208         nonstatic_contended_count++;
4209       }
4210     }
4211   }
4212 
4213 
4214   // Calculate the starting byte offsets
4215   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();

4216   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4217                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);</span>
4218   if (fac-&gt;count[STATIC_DOUBLE]) {
4219     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4220   }
4221 
4222   int next_static_word_offset   = next_static_double_offset +
4223                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4224   int next_static_short_offset  = next_static_word_offset +
4225                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4226   int next_static_byte_offset   = next_static_short_offset +
4227                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4228 
4229   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4230                                 nonstatic_field_size * heapOopSize;
4231 










4232   int next_nonstatic_field_offset = nonstatic_fields_start;
4233 
4234   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4235 
4236   // Class is contended, pad before all the fields
4237   if (is_contended_class) {
4238     next_nonstatic_field_offset += ContendedPaddingWidth;
4239   }
4240 








4241   // Compute the non-contended fields count.
4242   // The packing code below relies on these counts to determine if some field
4243   // can be squeezed into the alignment gap. Contended fields are obviously
4244   // exempt from that.
4245   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4246   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4247   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4248   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4249   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4250 









































































4251   // Total non-static fields count, including every contended field
4252   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4253                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4254                                         fac-&gt;count[NONSTATIC_OOP];</span>
4255 
4256   const bool super_has_nonstatic_fields =
4257           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4258   const bool has_nonstatic_fields =
4259     super_has_nonstatic_fields || (nonstatic_fields_count != 0);

4260 





4261 
4262   // Prepare list of oops for oop map generation.
4263   //
4264   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4265   // regions. offset[i] is the start of the i-th region, which then has
4266   // count[i] oops following. Before we know how many regions are required,
4267   // we pessimistically allocate the maps to fit all the oops into the
4268   // distinct regions.
<span class="line-modified">4269 </span>
4270   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4271   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];</span>




4272 
4273   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4274   if (super_oop_map_count &gt; 0) {
4275     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4276                                                     _super_klass-&gt;nonstatic_oop_map_count());
4277   }
4278 
4279   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4280 
4281   bool compact_fields  = true;
4282   bool allocate_oops_first = false;
4283 
4284   int next_nonstatic_oop_offset = 0;
4285   int next_nonstatic_double_offset = 0;
4286 
4287   // Rearrange fields for a given allocation style
4288   if (allocate_oops_first) {
4289     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4290     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4291     next_nonstatic_double_offset = next_nonstatic_oop_offset +
</pre>
<hr />
<pre>
4346   }
4347 
4348   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4349                                      (nonstatic_double_count * BytesPerLong);
4350   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4351                                       (nonstatic_word_count * BytesPerInt);
4352   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4353                                      (nonstatic_short_count * BytesPerShort);
4354   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4355                                        nonstatic_byte_count;
4356 
4357   // let oops jump before padding with this allocation style
4358   if (!allocate_oops_first) {
4359     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4360     if( nonstatic_oop_count &gt; 0 ) {
4361       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4362     }
4363     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4364   }
4365 










4366   // Iterate over fields again and compute correct offsets.
4367   // The field allocation type was temporarily stored in the offset slot.
4368   // oop fields are located before non-oop fields (static and non-static).
4369   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4370 
4371     // skip already laid out fields
4372     if (fs.is_offset_set()) continue;
4373 
4374     // contended instance fields are handled below
4375     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4376 
4377     int real_offset = 0;
4378     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4379 
4380     // pack the rest of the fields
4381     switch (atype) {


4382       case STATIC_OOP:
4383         real_offset = next_static_oop_offset;
4384         next_static_oop_offset += heapOopSize;
4385         break;
4386       case STATIC_BYTE:
4387         real_offset = next_static_byte_offset;
4388         next_static_byte_offset += 1;
4389         break;
4390       case STATIC_SHORT:
4391         real_offset = next_static_short_offset;
4392         next_static_short_offset += BytesPerShort;
4393         break;
4394       case STATIC_WORD:
4395         real_offset = next_static_word_offset;
4396         next_static_word_offset += BytesPerInt;
4397         break;
4398       case STATIC_DOUBLE:
4399         real_offset = next_static_double_offset;
4400         next_static_double_offset += BytesPerLong;
4401         break;

























4402       case NONSTATIC_OOP:
4403         if( nonstatic_oop_space_count &gt; 0 ) {
4404           real_offset = nonstatic_oop_space_offset;
4405           nonstatic_oop_space_offset += heapOopSize;
4406           nonstatic_oop_space_count  -= 1;
4407         } else {
4408           real_offset = next_nonstatic_oop_offset;
4409           next_nonstatic_oop_offset += heapOopSize;
4410         }
4411         nonstatic_oop_maps-&gt;add(real_offset, 1);
4412         break;
4413       case NONSTATIC_BYTE:
4414         if( nonstatic_byte_space_count &gt; 0 ) {
4415           real_offset = nonstatic_byte_space_offset;
4416           nonstatic_byte_space_offset += 1;
4417           nonstatic_byte_space_count  -= 1;
4418         } else {
4419           real_offset = next_nonstatic_byte_offset;
4420           next_nonstatic_byte_offset += 1;
4421         }
</pre>
<hr />
<pre>
4500             break;
4501 
4502           case NONSTATIC_SHORT:
4503             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4504             real_offset = next_nonstatic_padded_offset;
4505             next_nonstatic_padded_offset += BytesPerShort;
4506             break;
4507 
4508           case NONSTATIC_WORD:
4509             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4510             real_offset = next_nonstatic_padded_offset;
4511             next_nonstatic_padded_offset += BytesPerInt;
4512             break;
4513 
4514           case NONSTATIC_DOUBLE:
4515             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4516             real_offset = next_nonstatic_padded_offset;
4517             next_nonstatic_padded_offset += BytesPerLong;
4518             break;
4519 






4520           case NONSTATIC_OOP:
4521             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4522             real_offset = next_nonstatic_padded_offset;
4523             next_nonstatic_padded_offset += heapOopSize;
4524             nonstatic_oop_maps-&gt;add(real_offset, 1);
4525             break;
4526 
4527           default:
4528             ShouldNotReachHere();
4529         }
4530 
4531         if (fs.contended_group() == 0) {
4532           // Contended group defines the equivalence class over the fields:
4533           // the fields within the same contended group are not inter-padded.
4534           // The only exception is default group, which does not incur the
4535           // equivalence, and so requires intra-padding.
4536           next_nonstatic_padded_offset += ContendedPaddingWidth;
4537         }
4538 
4539         fs.set_offset(real_offset);
4540       } // for
4541 
4542       // Start laying out the next group.
4543       // Note that this will effectively pad the last group in the back;
4544       // this is expected to alleviate memory contention effects for
4545       // subclass fields and/or adjacent object.
4546       // If this was the default group, the padding is already in place.
4547       if (current_group != 0) {
4548         next_nonstatic_padded_offset += ContendedPaddingWidth;
4549       }
4550     }
4551 
4552     // handle static fields
4553   }
4554 
4555   // Entire class is contended, pad in the back.
4556   // This helps to alleviate memory contention effects for subclass fields
4557   // and/or adjacent object.
4558   if (is_contended_class) {

4559     next_nonstatic_padded_offset += ContendedPaddingWidth;
4560   }
4561 
<span class="line-modified">4562   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>





4563 
<span class="line-modified">4564   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);</span>






4565   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4566   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4567 
4568   int static_field_size         = (static_fields_end -
4569                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4570   nonstatic_field_size          = nonstatic_field_size +
4571                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4572 
4573   int instance_size             = align_object_size(instance_end / wordSize);
4574 
4575   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4576          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),</span>
<span class="line-modified">4577           wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>

4578 
4579   // Invariant: nonstatic_field end/start should only change if there are
4580   // nonstatic fields in the class, or if the class is contended. We compare
4581   // against the non-aligned value, so that end alignment will not fail the
4582   // assert without actually having the fields.
4583   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4584          is_contended_class ||
4585          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4586 
4587   // Number of non-static oop map blocks allocated at end of klass.
4588   nonstatic_oop_maps-&gt;compact();
4589 
4590 #ifndef PRODUCT
<span class="line-modified">4591   if (PrintFieldLayout) {</span>

4592     print_field_layout(_class_name,
4593           _fields,
4594           cp,
4595           instance_size,
4596           nonstatic_fields_start,
4597           nonstatic_fields_end,
4598           static_fields_end);







4599   }
4600 
4601 #endif
4602   // Pass back information needed for InstanceKlass creation
4603   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4604   info-&gt;_instance_size = instance_size;
4605   info-&gt;_static_field_size = static_field_size;
4606   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4607   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;














4608 }
4609 
4610 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4611   assert(ik != NULL, &quot;invariant&quot;);
4612 
4613   const Klass* const super = ik-&gt;super();
4614 
4615   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4616   // in which case we don&#39;t have to register objects as finalizable
4617   if (!_has_empty_finalizer) {
4618     if (_has_finalizer ||
4619         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4620       ik-&gt;set_has_finalizer();
4621     }
4622   }
4623 
4624 #ifdef ASSERT
4625   bool f = false;
4626   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4627                                            vmSymbols::void_method_signature());
4628   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4629       f = true;
4630   }
4631 
4632   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4633   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4634   // will not work as expected we shouldn&#39;t abort vm in this case
4635   if (!ik-&gt;has_redefined_this_or_super()) {
4636     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4637   }
4638 #endif
4639 
4640   // Check if this klass supports the java.lang.Cloneable interface
4641   if (SystemDictionary::Cloneable_klass_loaded()) {
4642     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {





4643       ik-&gt;set_is_cloneable();
4644     }
4645   }
4646 
4647   // Check if this klass has a vanilla default constructor
4648   if (super == NULL) {
4649     // java.lang.Object has empty default constructor
4650     ik-&gt;set_has_vanilla_constructor();
4651   } else {
4652     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4653         _has_vanilla_constructor) {
4654       ik-&gt;set_has_vanilla_constructor();
4655     }
4656 #ifdef ASSERT
4657     bool v = false;
4658     if (super-&gt;has_vanilla_constructor()) {
4659       const Method* const constructor =
4660         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4661                        vmSymbols::void_method_signature());
4662       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4663         v = true;
4664       }
4665     }
4666     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4667 #endif
4668   }
4669 
4670   // If it cannot be fast-path allocated, set a bit in the layout helper.
4671   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4672   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4673   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4674       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4675       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4676       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4677     // Forbid fast-path allocation.
4678     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4679     ik-&gt;set_layout_helper(lh);
4680   }
4681 }
4682 





4683 // utility methods for appending an array with check for duplicates
4684 
4685 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4686                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4687   // iterate over new interfaces
4688   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4689     InstanceKlass* const e = ifs-&gt;at(i);
4690     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4691     // add new interface
4692     result-&gt;append_if_missing(e);
4693   }
4694 }
4695 
4696 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4697                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4698                                                             ClassLoaderData* loader_data,
4699                                                             TRAPS) {
4700   assert(local_ifs != NULL, &quot;invariant&quot;);
4701   assert(loader_data != NULL, &quot;invariant&quot;);
4702 
</pre>
<hr />
<pre>
4706   // Add superclass transitive interfaces size
4707   if (super != NULL) {
4708     super_size = super-&gt;transitive_interfaces()-&gt;length();
4709     max_transitive_size += super_size;
4710   }
4711   // Add local interfaces&#39; super interfaces
4712   const int local_size = local_ifs-&gt;length();
4713   for (int i = 0; i &lt; local_size; i++) {
4714     InstanceKlass* const l = local_ifs-&gt;at(i);
4715     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4716   }
4717   // Finally add local interfaces
4718   max_transitive_size += local_size;
4719   // Construct array
4720   if (max_transitive_size == 0) {
4721     // no interfaces, use canonicalized array
4722     return Universe::the_empty_instance_klass_array();
4723   } else if (max_transitive_size == super_size) {
4724     // no new local interfaces added, share superklass&#39; transitive interface array
4725     return super-&gt;transitive_interfaces();
<span class="line-modified">4726   } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">4727     // only local interfaces added, share local interface array</span>
<span class="line-modified">4728     return local_ifs;</span>

4729   } else {
4730     ResourceMark rm;
4731     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4732 
4733     // Copy down from superclass
4734     if (super != NULL) {
4735       append_interfaces(result, super-&gt;transitive_interfaces());
4736     }
4737 
4738     // Copy down from local interfaces&#39; superinterfaces
4739     for (int i = 0; i &lt; local_size; i++) {
4740       InstanceKlass* const l = local_ifs-&gt;at(i);
4741       append_interfaces(result, l-&gt;transitive_interfaces());
4742     }
4743     // Finally add local interfaces
4744     append_interfaces(result, local_ifs);
4745 
4746     // length will be less than the max_transitive_size if duplicates were removed
4747     const int length = result-&gt;length();
4748     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);





4749     Array&lt;InstanceKlass*&gt;* const new_result =
4750       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4751     for (int i = 0; i &lt; length; i++) {
4752       InstanceKlass* const e = result-&gt;at(i);
4753       assert(e != NULL, &quot;just checking&quot;);
4754       new_result-&gt;at_put(i, e);
4755     }
4756     return new_result;
4757   }
4758 }
4759 
4760 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4761   assert(this_klass != NULL, &quot;invariant&quot;);
4762   const Klass* const super = this_klass-&gt;super();
4763 
4764   if (super != NULL) {
4765     const InstanceKlass* super_ik = InstanceKlass::cast(super);
4766 
4767     if (super-&gt;is_final()) {
4768       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
4961     const Method* const m = methods-&gt;at(index);
4962     // if m is static and not the init method, throw a verify error
4963     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4964       ResourceMark rm(THREAD);
4965       Exceptions::fthrow(
4966         THREAD_AND_LOCATION,
4967         vmSymbols::java_lang_VerifyError(),
4968         &quot;Illegal static method %s in interface %s&quot;,
4969         m-&gt;name()-&gt;as_C_string(),
4970         this_klass-&gt;external_name()
4971       );
4972       return;
4973     }
4974   }
4975 }
4976 
4977 // utility methods for format checking
4978 
4979 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4980   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;

4981   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);

4982   if (is_module) {
4983     ResourceMark rm(THREAD);
4984     Exceptions::fthrow(
4985       THREAD_AND_LOCATION,
4986       vmSymbols::java_lang_NoClassDefFoundError(),
4987       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4988       _class_name-&gt;as_C_string());
4989     return;
4990   }
4991 










4992   if (!_need_verify) { return; }
4993 
4994   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4995   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4996   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4997   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4998   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4999   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5000   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5001   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5002 
5003   if ((is_abstract &amp;&amp; is_final) ||
5004       (is_interface &amp;&amp; !is_abstract) ||
5005       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">5006       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>

5007     ResourceMark rm(THREAD);


5008     Exceptions::fthrow(
5009       THREAD_AND_LOCATION,
5010       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5011       &quot;Illegal class modifiers in class %s: 0x%X&quot;,</span>
<span class="line-modified">5012       _class_name-&gt;as_C_string(), flags</span>
5013     );
5014     return;
5015   }
5016 }
5017 
5018 static bool has_illegal_visibility(jint flags) {
5019   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5020   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5021   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5022 
5023   return ((is_public &amp;&amp; is_protected) ||
5024           (is_public &amp;&amp; is_private) ||
5025           (is_protected &amp;&amp; is_private));
5026 }
5027 
5028 // A legal major_version.minor_version must be one of the following:
5029 //
5030 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5031 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5032 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
5071     if (!Arguments::enable_preview()) {
5072       Exceptions::fthrow(
5073         THREAD_AND_LOCATION,
5074         vmSymbols::java_lang_UnsupportedClassVersionError(),
5075         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5076         class_name-&gt;as_C_string(), major, minor);
5077       return;
5078     }
5079 
5080   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5081     Exceptions::fthrow(
5082         THREAD_AND_LOCATION,
5083         vmSymbols::java_lang_UnsupportedClassVersionError(),
5084         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5085         class_name-&gt;as_C_string(), major, minor);
5086   }
5087 }
5088 
5089 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5090                                                    bool is_interface,

5091                                                    TRAPS) const {
5092   if (!_need_verify) { return; }
5093 
5094   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5095   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5096   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5097   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5098   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5099   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5100   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5101   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5102   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5103 
5104   bool is_illegal = false;
5105 
5106   if (is_interface) {
5107     if (!is_public || !is_static || !is_final || is_private ||
5108         is_protected || is_volatile || is_transient ||
5109         (major_gte_1_5 &amp;&amp; is_enum)) {
5110       is_illegal = true;
5111     }
5112   } else { // not interface
5113     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5114       is_illegal = true;




5115     }
5116   }
5117 
5118   if (is_illegal) {
5119     ResourceMark rm(THREAD);
5120     Exceptions::fthrow(
5121       THREAD_AND_LOCATION,
5122       vmSymbols::java_lang_ClassFormatError(),
5123       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5124       _class_name-&gt;as_C_string(), flags);
5125     return;
5126   }
5127 }
5128 
5129 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5130                                                     bool is_interface,

5131                                                     const Symbol* name,
5132                                                     TRAPS) const {
5133   if (!_need_verify) { return; }
5134 
5135   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5136   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5137   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5138   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5139   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5140   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5141   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5142   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5143   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5144   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5145   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5146   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5147   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5148 
5149   bool is_illegal = false;
5150 


5151   if (is_interface) {
5152     if (major_gte_8) {
5153       // Class file version is JAVA_8_VERSION or later Methods of
5154       // interfaces may set any of the flags except ACC_PROTECTED,
5155       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5156       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5157       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5158           (is_native || is_protected || is_final || is_synchronized) ||
5159           // If a specific method of a class or interface has its
5160           // ACC_ABSTRACT flag set, it must not have any of its
5161           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5162           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5163           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5164           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5165           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5166         is_illegal = true;
5167       }
5168     } else if (major_gte_1_5) {
5169       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5170       if (!is_public || is_private || is_protected || is_static || is_final ||
5171           is_synchronized || is_native || !is_abstract || is_strict) {
5172         is_illegal = true;
5173       }
5174     } else {
5175       // Class file version is pre-JAVA_1_5_VERSION
5176       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5177         is_illegal = true;
5178       }
5179     }
5180   } else { // not interface
5181     if (has_illegal_visibility(flags)) {
5182       is_illegal = true;
5183     } else {
5184       if (is_initializer) {
<span class="line-modified">5185         if (is_static || is_final || is_synchronized || is_native ||</span>
5186             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5187           is_illegal = true;
5188         }









5189       } else { // not initializer
<span class="line-modified">5190         if (is_abstract) {</span>
<span class="line-modified">5191           if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-modified">5192               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-modified">5193             is_illegal = true;</span>





5194           }
5195         }
5196       }
5197     }
5198   }
5199 
5200   if (is_illegal) {
5201     ResourceMark rm(THREAD);
5202     Exceptions::fthrow(
5203       THREAD_AND_LOCATION,
5204       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5205       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5206       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);</span>
5207     return;
5208   }
5209 }
5210 
5211 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5212                                         int length,
5213                                         TRAPS) const {
5214   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5215   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5216     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5217   }
5218 }
5219 
5220 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5221 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5222 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5223 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5224 // method.  Because these names have been checked as special cases before
5225 // calling this method in verify_legal_method_name.
5226 //
</pre>
<hr />
<pre>
5344 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5345 // Return a pointer to just past the signature.
5346 // Return NULL if no legal signature is found.
5347 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5348                                                        bool void_ok,
5349                                                        unsigned int length,
5350                                                        TRAPS) const {
5351   unsigned int array_dim = 0;
5352   while (length &gt; 0) {
5353     switch (signature[0]) {
5354     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5355     case JVM_SIGNATURE_BOOLEAN:
5356     case JVM_SIGNATURE_BYTE:
5357     case JVM_SIGNATURE_CHAR:
5358     case JVM_SIGNATURE_SHORT:
5359     case JVM_SIGNATURE_INT:
5360     case JVM_SIGNATURE_FLOAT:
5361     case JVM_SIGNATURE_LONG:
5362     case JVM_SIGNATURE_DOUBLE:
5363       return signature + 1;
<span class="line-modified">5364     case JVM_SIGNATURE_CLASS: {</span>









5365       if (_major_version &lt; JAVA_1_5_VERSION) {
5366         // Skip over the class name if one is there
5367         const char* const p = skip_over_field_name(signature + 1, true, --length);
5368 
5369         // The next character better be a semicolon
5370         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5371           return p + 1;
5372         }
5373       }
5374       else {
<span class="line-modified">5375         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;</span>
5376         signature++;
5377         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5378         // Format check signature
5379         if (c != NULL) {
5380           int newlen = c - (char*) signature;
5381           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5382           if (!legal) {
5383             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5384                                   &quot;in descriptor in class file %s&quot;,
5385                                   CHECK_NULL);
5386             return NULL;
5387           }
5388           return signature + newlen + 1;
5389         }
5390       }
5391       return NULL;
5392     }
5393     case JVM_SIGNATURE_ARRAY:
5394       array_dim++;
5395       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5410 
5411 // Checks if name is a legal class name.
5412 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5413   if (!_need_verify || _relax_verify) { return; }
5414 
5415   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5416   char* bytes = (char*)name-&gt;bytes();
5417   unsigned int length = name-&gt;utf8_length();
5418   bool legal = false;
5419 
5420   if (length &gt; 0) {
5421     const char* p;
5422     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5423       p = skip_over_field_signature(bytes, false, length, CHECK);
5424       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5425     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5426       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5427         p = skip_over_field_name(bytes, true, length);
5428         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5429       }



5430     } else {
5431       // 4900761: relax the constraints based on JSR202 spec
5432       // Class names may be drawn from the entire Unicode character set.
5433       // Identifiers between &#39;/&#39; must be unqualified names.
5434       // The utf8 string has been verified when parsing cpool entries.
5435       legal = verify_unqualified_name(bytes, length, LegalClass);
5436     }
5437   }
5438   if (!legal) {
5439     ResourceMark rm(THREAD);
5440     assert(_class_name != NULL, &quot;invariant&quot;);
5441     Exceptions::fthrow(
5442       THREAD_AND_LOCATION,
5443       vmSymbols::java_lang_ClassFormatError(),
5444       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5445       _class_name-&gt;as_C_string()
5446     );
5447     return;
5448   }
5449 }
</pre>
<hr />
<pre>
5559   const char* nextp;
5560 
5561   // The first character must be a &#39;(&#39;
5562   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5563     length--;
5564     // Skip over legal field signatures
5565     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5566     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5567       args_size++;
5568       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5569         args_size++;
5570       }
5571       length -= nextp - p;
5572       p = nextp;
5573       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5574     }
5575     // The first non-signature thing better be a &#39;)&#39;
5576     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5577       length--;
5578       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5579         // All internal methods must return void</span>
5580         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5581           return args_size;
5582         }
















5583       } else {
5584         // Now we better just have a return value
5585         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5586         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5587           return args_size;
5588         }
5589       }
5590     }
5591   }
5592   // Report error
5593   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5594   return 0;
5595 }
5596 
5597 int ClassFileParser::static_field_size() const {
5598   assert(_field_info != NULL, &quot;invariant&quot;);
5599   return _field_info-&gt;_static_field_size;
5600 }
5601 
5602 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
5720 
5721 
5722   if (ik-&gt;should_store_fingerprint()) {
5723     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5724   }
5725 
5726   ik-&gt;set_has_passed_fingerprint_check(false);
5727   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5728     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5729     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5730     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5731       // This class matches with a class saved in an AOT library
5732       ik-&gt;set_has_passed_fingerprint_check(true);
5733     } else {
5734       ResourceMark rm;
5735       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5736                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5737     }
5738   }
5739 






5740   return ik;
5741 }
5742 


































5743 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
5744                                           bool changed_by_loadhook,
5745                                           const ClassInstanceInfo&amp; cl_inst_info,
5746                                           TRAPS) {
5747   assert(ik != NULL, &quot;invariant&quot;);
5748 
5749   // Set name and CLD before adding to CLD
5750   ik-&gt;set_class_loader_data(_loader_data);
5751   ik-&gt;set_name(_class_name);
5752 
5753   // Add all classes to our internal class loader list here,
5754   // including classes in the bootstrap (NULL) class loader.
5755   const bool publicize = !is_internal();
5756 
5757   _loader_data-&gt;add_class(ik, publicize);
5758 
5759   set_klass_to_deallocate(ik);
5760 
5761   assert(_field_info != NULL, &quot;invariant&quot;);
5762   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
5763   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
5764          &quot;sanity&quot;);
5765 
5766   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5767   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
5768 
5769   // Fill in information already parsed
5770   ik-&gt;set_should_verify_class(_need_verify);
5771 
5772   // Not yet: supers are done below to support the new subtype-checking fields
5773   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
5774   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);















5775   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">5776   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);</span>
5777 
5778   // this transfers ownership of a lot of arrays from
5779   // the parser onto the InstanceKlass*
5780   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5781 
5782   // can only set dynamic nest-host after static nest information is set
5783   if (cl_inst_info.dynamic_nest_host() != NULL) {
5784     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
5785   }
5786 
5787   // note that is not safe to use the fields in the parser from this point on
5788   assert(NULL == _cp, &quot;invariant&quot;);
5789   assert(NULL == _fields, &quot;invariant&quot;);
5790   assert(NULL == _methods, &quot;invariant&quot;);
5791   assert(NULL == _inner_classes, &quot;invariant&quot;);
5792   assert(NULL == _nest_members, &quot;invariant&quot;);
5793   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5794   assert(NULL == _record_components, &quot;invariant&quot;);
5795   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
5796 
</pre>
<hr />
<pre>
5806   // has to be changed accordingly.
5807   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5808 
5809   ik-&gt;set_this_class_index(_this_class_index);
5810 
5811   if (_is_hidden || is_unsafe_anonymous()) {
5812     // _this_class_index is a CONSTANT_Class entry that refers to this
5813     // hidden or anonymous class itself. If this class needs to refer to its own
5814     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
5815     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
5816     // not stored in SystemDictionary), _this_class_index cannot be resolved
5817     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5818     // Therefore, we must eagerly resolve _this_class_index now.
5819     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5820   }
5821 
5822   ik-&gt;set_minor_version(_minor_version);
5823   ik-&gt;set_major_version(_major_version);
5824   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5825   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);



5826 
5827   if (_unsafe_anonymous_host != NULL) {
5828     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5829     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5830   }
5831   if (_is_hidden) {
5832     ik-&gt;set_is_hidden();
5833   }
5834 
5835   // Set PackageEntry for this_klass
5836   oop cl = ik-&gt;class_loader();
5837   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5838   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5839   ik-&gt;set_package(cld, NULL, CHECK);
5840 
5841   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5842   assert(methods != NULL, &quot;invariant&quot;);
5843   const int methods_len = methods-&gt;length();
5844 
5845   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
5917 
5918   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5919 
5920   // Generate any default methods - default methods are public interface methods
5921   // that have a default implementation.  This is new with Java 8.
5922   if (_has_nonstatic_concrete_methods) {
5923     DefaultMethods::generate_default_methods(ik,
5924                                              _all_mirandas,
5925                                              CHECK);
5926   }
5927 
5928   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5929   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5930       !module_entry-&gt;has_default_read_edges()) {
5931     if (!module_entry-&gt;set_has_default_read_edges()) {
5932       // We won a potential race
5933       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5934     }
5935   }
5936 


































5937   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5938 
5939   if (!is_internal()) {
5940     if (log_is_enabled(Info, class, load)) {
5941       ResourceMark rm;
5942       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5943       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5944     }
5945 
5946     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5947         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5948         log_is_enabled(Info, class, preview)) {
5949       ResourceMark rm;
5950       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5951                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5952     }
5953 
5954     if (log_is_enabled(Debug, class, resolve))  {
5955       ResourceMark rm;
5956       // print out the superclass.
</pre>
<hr />
<pre>
5966         const int length = local_interfaces-&gt;length();
5967         for (int i = 0; i &lt; length; i++) {
5968           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5969           const char * to = k-&gt;external_name();
5970           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5971         }
5972       }
5973     }
5974   }
5975 
5976   JFR_ONLY(INIT_ID(ik);)
5977 
5978   // If we reach here, all is well.
5979   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5980   // in order for it to not be destroyed in the ClassFileParser destructor.
5981   set_klass_to_deallocate(NULL);
5982 
5983   // it&#39;s official
5984   set_klass(ik);
5985 




5986   debug_only(ik-&gt;verify();)
5987 }
5988 
5989 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5990   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5991   _class_name-&gt;decrement_refcount();
5992 
5993   _class_name = new_class_name;
5994   // Increment the refcount of the new name.
5995   // Now the ClassFileParser owns this name and will decrement in
5996   // the destructor.
5997   _class_name-&gt;increment_refcount();
5998 }
5999 
6000 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6001 // package by prepending its host class&#39;s package name to its class name and setting
6002 // its _class_name field.
6003 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6004   ResourceMark rm(THREAD);
6005   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
6068   _stream(stream),
6069   _class_name(NULL),
6070   _loader_data(loader_data),
6071   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6072   _cp_patches(cl_info-&gt;cp_patches()),
6073   _is_hidden(cl_info-&gt;is_hidden()),
6074   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6075   _num_patched_klasses(0),
6076   _max_num_patched_klasses(0),
6077   _orig_cp_size(0),
6078   _first_patched_klass_resolved_index(0),
6079   _super_klass(),
6080   _cp(NULL),
6081   _fields(NULL),
6082   _methods(NULL),
6083   _inner_classes(NULL),
6084   _nest_members(NULL),
6085   _nest_host(0),
6086   _permitted_subclasses(NULL),
6087   _record_components(NULL),

6088   _local_interfaces(NULL),
6089   _transitive_interfaces(NULL),
6090   _combined_annotations(NULL),
6091   _class_annotations(NULL),
6092   _class_type_annotations(NULL),
6093   _fields_annotations(NULL),
6094   _fields_type_annotations(NULL),
6095   _klass(NULL),
6096   _klass_to_deallocate(NULL),
6097   _parsed_annotations(NULL),
6098   _fac(NULL),
6099   _field_info(NULL),
6100   _method_ordering(NULL),
6101   _all_mirandas(NULL),
6102   _vtable_size(0),
6103   _itable_size(0),
6104   _num_miranda_methods(0),
6105   _rt(REF_NONE),
6106   _protection_domain(cl_info-&gt;protection_domain()),
6107   _access_flags(),
6108   _pub_level(pub_level),
6109   _bad_constant_seen(0),
6110   _synthetic_flag(false),
6111   _sde_length(false),
6112   _sde_buffer(NULL),
6113   _sourcefile_index(0),
6114   _generic_signature_index(0),
6115   _major_version(0),
6116   _minor_version(0),
6117   _this_class_index(0),
6118   _super_class_index(0),
6119   _itfs_len(0),
6120   _java_fields_count(0),
6121   _need_verify(false),
6122   _relax_verify(false),
6123   _has_nonstatic_concrete_methods(false),
6124   _declares_nonstatic_concrete_methods(false),
6125   _has_final_method(false),
6126   _has_contended_fields(false),









6127   _has_finalizer(false),
6128   _has_empty_finalizer(false),
6129   _has_vanilla_constructor(false),
6130   _max_bootstrap_specifier_index(-1) {
6131 
6132   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6133   _class_name-&gt;increment_refcount();
6134 
6135   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6136   assert(_loader_data != NULL, &quot;invariant&quot;);
6137   assert(stream != NULL, &quot;invariant&quot;);
6138   assert(_stream != NULL, &quot;invariant&quot;);
6139   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6140   assert(_class_name != NULL, &quot;invariant&quot;);
6141   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6142 
6143   // Figure out whether we can skip format checking (matching classic VM behavior)
6144   if (DumpSharedSpaces) {
6145     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6146     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6317   } else {
6318     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6319       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6320     }
6321     cp_size += _max_num_patched_klasses;
6322   }
6323 
6324   _cp = ConstantPool::allocate(_loader_data,
6325                                cp_size,
6326                                CHECK);
6327 
6328   ConstantPool* const cp = _cp;
6329 
6330   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6331 
6332   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6333 
6334   // ACCESS FLAGS
6335   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6336 
<span class="line-modified">6337   // Access flags</span>
<span class="line-removed">6338   jint flags;</span>
6339   // JVM_ACC_MODULE is defined in JDK-9 and later.
6340   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6341     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">6342   } else {</span>
<span class="line-modified">6343     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;</span>


6344   }
6345 



6346   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6347     // Set abstract bit for old class files for backward compatibility
6348     flags |= JVM_ACC_ABSTRACT;
6349   }
6350 
6351   verify_legal_class_modifiers(flags, CHECK);
6352 
6353   short bad_constant = class_bad_constant_seen();
6354   if (bad_constant != 0) {
6355     // Do not throw CFE until after the access_flags are checked because if
6356     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6357     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6358   }
6359 
6360   _access_flags.set_flags(flags);
6361 
6362   // This class and superclass
6363   _this_class_index = stream-&gt;get_u2_fast();
6364   check_property(
6365     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6483           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6484           classlist_file-&gt;flush();
6485         }
6486       }
6487     }
6488 #endif
6489   }
6490 
6491   // SUPERKLASS
6492   _super_class_index = stream-&gt;get_u2_fast();
6493   _super_klass = parse_super_class(cp,
6494                                    _super_class_index,
6495                                    _need_verify,
6496                                    CHECK);
6497 
6498   // Interfaces
6499   _itfs_len = stream-&gt;get_u2_fast();
6500   parse_interfaces(stream,
6501                    _itfs_len,
6502                    cp,

6503                    &amp;_has_nonstatic_concrete_methods,

6504                    CHECK);
6505 
<span class="line-modified">6506   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
6507 
6508   // Fields (offsets are filled in later)
6509   _fac = new FieldAllocationCount();
6510   parse_fields(stream,
<span class="line-modified">6511                _access_flags.is_interface(),</span>

6512                _fac,
6513                cp,
6514                cp_size,
6515                &amp;_java_fields_count,
6516                CHECK);
6517 
6518   assert(_fields != NULL, &quot;invariant&quot;);
6519 
6520   // Methods
6521   AccessFlags promoted_flags;
6522   parse_methods(stream,
<span class="line-modified">6523                 _access_flags.is_interface(),</span>

6524                 &amp;promoted_flags,
6525                 &amp;_has_final_method,
6526                 &amp;_declares_nonstatic_concrete_methods,
6527                 CHECK);
6528 
6529   assert(_methods != NULL, &quot;invariant&quot;);
6530 
6531   // promote flags from parse_methods() to the klass&#39; flags
6532   _access_flags.add_promoted_flags(promoted_flags.as_int());
6533 
6534   if (_declares_nonstatic_concrete_methods) {
6535     _has_nonstatic_concrete_methods = true;
6536   }
6537 
6538   // Additional attributes/annotations
6539   _parsed_annotations = new ClassAnnotationCollector();
6540   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6541 
6542   assert(_inner_classes != NULL, &quot;invariant&quot;);
6543 
</pre>
<hr />
<pre>
6574 
6575   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
6576   // We have to update the resolved_klass_index and the name_index together
6577   // so extract the existing resolved_klass_index first.
6578   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
6579   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
6580   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
6581   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
6582          &quot;Bad name_index&quot;);
6583 }
6584 
6585 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6586                                                  ConstantPool* cp,
6587                                                  TRAPS) {
6588   assert(stream != NULL, &quot;invariant&quot;);
6589   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6590   assert(cp != NULL, &quot;invariant&quot;);
6591   assert(_loader_data != NULL, &quot;invariant&quot;);
6592 
6593   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6594     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),</span>
<span class="line-modified">6595                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6596                    CHECK);</span>
6597   }
6598   // We check super class after class file is parsed and format is checked
6599   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6600     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6601     if (_access_flags.is_interface()) {</span>
6602       // Before attempting to resolve the superclass, check for class format
6603       // errors not checked yet.
6604       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6605         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6606         CHECK);
6607     }
6608     Handle loader(THREAD, _loader_data-&gt;class_loader());
6609     _super_klass = (const InstanceKlass*)
6610                        SystemDictionary::resolve_super_or_fail(_class_name,
6611                                                                super_class_name,
6612                                                                loader,
6613                                                                _protection_domain,
6614                                                                true,
6615                                                                CHECK);
6616   }
6617 
6618   if (_super_klass != NULL) {
6619     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6620       _has_nonstatic_concrete_methods = true;
6621     }



6622 
6623     if (_super_klass-&gt;is_interface()) {
6624       ResourceMark rm(THREAD);
6625       Exceptions::fthrow(
6626         THREAD_AND_LOCATION,
6627         vmSymbols::java_lang_IncompatibleClassChangeError(),
6628         &quot;class %s has interface %s as super class&quot;,
6629         _class_name-&gt;as_klass_external_name(),
6630         _super_klass-&gt;external_name()
6631       );
6632       return;
6633     }





































6634   }
6635 



















6636   // Compute the transitive list of all unique interfaces implemented by this class
6637   _transitive_interfaces =
6638     compute_transitive_interfaces(_super_klass,
6639                                   _local_interfaces,
6640                                   _loader_data,
6641                                   CHECK);
6642 
6643   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6644 
6645   // sort methods
6646   _method_ordering = sort_methods(_methods);
6647 
6648   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6649 
6650   Handle loader(THREAD, _loader_data-&gt;class_loader());
6651   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6652                                                     &amp;_num_miranda_methods,
6653                                                     _all_mirandas,
6654                                                     _super_klass,
6655                                                     _methods,
6656                                                     _access_flags,
6657                                                     _major_version,
6658                                                     loader,
6659                                                     _class_name,
6660                                                     _local_interfaces,
6661                                                     CHECK);
6662 
6663   // Size of Java itable (in words)
<span class="line-modified">6664   _itable_size = _access_flags.is_interface() ? 0 :</span>
6665     klassItable::compute_itable_size(_transitive_interfaces);
6666 
6667   assert(_fac != NULL, &quot;invariant&quot;);
6668   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6669 












6670   _field_info = new FieldLayoutInfo();
6671   if (UseNewFieldLayout) {
6672     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">6673                           _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-modified">6674     lb.build_layout();</span>






6675   } else {
6676     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6677   }

6678 
<span class="line-modified">6679   // Compute reference typ</span>
6680   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
<span class="line-removed">6681 </span>
6682 }
6683 
6684 void ClassFileParser::set_klass(InstanceKlass* klass) {
6685 
6686 #ifdef ASSERT
6687   if (klass != NULL) {
6688     assert(NULL == _klass, &quot;leaking?&quot;);
6689   }
6690 #endif
6691 
6692   _klass = klass;
6693 }
6694 
6695 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6696 
6697 #ifdef ASSERT
6698   if (klass != NULL) {
6699     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6700   }
6701 #endif
6702 
6703   _klass_to_deallocate = klass;
6704 }
6705 
6706 // Caller responsible for ResourceMark
6707 // clone stream with rewound position
6708 const ClassFileStream* ClassFileParser::clone_stream() const {
6709   assert(_stream != NULL, &quot;invariant&quot;);
6710 
6711   return _stream-&gt;clone();
6712 }

6713 // ----------------------------------------------------------------------------
6714 // debugging
6715 
6716 #ifdef ASSERT
6717 
6718 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6719 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6720   if (class_name != NULL) {
6721     ResourceMark rm;
6722     char* name = class_name-&gt;as_C_string();
6723     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6724   } else {
6725     return true;
6726   }
6727 }
6728 
6729 #endif
</pre>
</td>
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
<span class="line-added">  24 </span>
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/defaultMethods.hpp&quot;
  33 #include &quot;classfile/dictionary.hpp&quot;
  34 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/moduleEntry.hpp&quot;
  37 #include &quot;classfile/packageEntry.hpp&quot;
  38 #include &quot;classfile/symbolTable.hpp&quot;
  39 #include &quot;classfile/systemDictionary.hpp&quot;
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
  52 #include &quot;oops/fieldStreams.inline.hpp&quot;
  53 #include &quot;oops/instanceKlass.hpp&quot;
  54 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  55 #include &quot;oops/klass.inline.hpp&quot;
  56 #include &quot;oops/klassVtable.hpp&quot;
  57 #include &quot;oops/metadata.hpp&quot;
  58 #include &quot;oops/method.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/recordComponent.hpp&quot;
  61 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">  86 #include &quot;utilities/stringUtils.hpp&quot;</span>
  87 #include &quot;utilities/utf8.hpp&quot;
  88 
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
</pre>
<hr />
<pre>
 120 
 121 // Extension method support.
 122 #define JAVA_8_VERSION                    52
 123 
 124 #define JAVA_9_VERSION                    53
 125 
 126 #define JAVA_10_VERSION                   54
 127 
 128 #define JAVA_11_VERSION                   55
 129 
 130 #define JAVA_12_VERSION                   56
 131 
 132 #define JAVA_13_VERSION                   57
 133 
 134 #define JAVA_14_VERSION                   58
 135 
 136 #define JAVA_15_VERSION                   59
 137 
 138 #define JAVA_16_VERSION                   60
 139 
<span class="line-added"> 140 #define CONSTANT_CLASS_DESCRIPTORS        60</span>
<span class="line-added"> 141 </span>
 142 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 143   assert((bad_constant == JVM_CONSTANT_Module ||
 144           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 145          &quot;Unexpected bad constant pool entry&quot;);
 146   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 147 }
 148 
 149 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 150                                                   ConstantPool* cp,
 151                                                   const int length,
 152                                                   TRAPS) {
 153   assert(stream != NULL, &quot;invariant&quot;);
 154   assert(cp != NULL, &quot;invariant&quot;);
 155 
 156   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 157   // this function (_current can be allocated in a register, with scalar
 158   // replacement of aggregates). The _current pointer is copied back to
 159   // stream() when this function returns. DON&#39;T call another method within
 160   // this method that uses stream().
 161   const ClassFileStream cfs1 = *stream;
 162   const ClassFileStream* const cfs = &amp;cfs1;
 163 
 164   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 165   debug_only(const u1* const old_current = stream-&gt;current();)
 166 
 167   // Used for batching symbol allocations.
 168   const char* names[SymbolTable::symbol_alloc_batch_size];
 169   int lengths[SymbolTable::symbol_alloc_batch_size];
 170   int indices[SymbolTable::symbol_alloc_batch_size];
 171   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 172   int names_count = 0;
 173 
 174   // parsing  Index 0 is unused
 175   for (int index = 1; index &lt; length; index++) {
 176     // Each of the following case guarantees one more byte in the stream
 177     // for the following tag or the access_flags following constant pool,
 178     // so we don&#39;t need bounds-check for reading tag.
 179     const u1 tag = cfs-&gt;get_u1_fast();
 180     switch (tag) {
<span class="line-modified"> 181       case JVM_CONSTANT_Class: {</span>
 182         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 183         const u2 name_index = cfs-&gt;get_u2_fast();
 184         cp-&gt;klass_index_at_put(index, name_index);
 185         break;
 186       }
 187       case JVM_CONSTANT_Fieldref: {
 188         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 189         const u2 class_index = cfs-&gt;get_u2_fast();
 190         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 191         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 192         break;
 193       }
 194       case JVM_CONSTANT_Methodref: {
 195         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 196         const u2 class_index = cfs-&gt;get_u2_fast();
 197         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 198         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 199         break;
 200       }
 201       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 491         check_property(valid_symbol_at(name_ref_index),
 492           &quot;Invalid constant pool index %u in class file %s&quot;,
 493           name_ref_index, CHECK);
 494         check_property(valid_symbol_at(signature_ref_index),
 495           &quot;Invalid constant pool index %u in class file %s&quot;,
 496           signature_ref_index, CHECK);
 497         break;
 498       }
 499       case JVM_CONSTANT_Utf8:
 500         break;
 501       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 502       case JVM_CONSTANT_UnresolvedClassInError: {
 503         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 504         break;
 505       }
 506       case JVM_CONSTANT_ClassIndex: {
 507         const int class_index = cp-&gt;klass_index_at(index);
 508         check_property(valid_symbol_at(class_index),
 509           &quot;Invalid constant pool index %u in class file %s&quot;,
 510           class_index, CHECK);
<span class="line-modified"> 511 </span>
<span class="line-added"> 512         Symbol* const name = cp-&gt;symbol_at(class_index);</span>
<span class="line-added"> 513         const unsigned int name_len = name-&gt;utf8_length();</span>
<span class="line-added"> 514         if (name-&gt;is_Q_signature()) {</span>
<span class="line-added"> 515           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 516         } else {</span>
<span class="line-added"> 517           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 518         }</span>
 519         break;
 520       }
 521       case JVM_CONSTANT_StringIndex: {
 522         const int string_index = cp-&gt;string_index_at(index);
 523         check_property(valid_symbol_at(string_index),
 524           &quot;Invalid constant pool index %u in class file %s&quot;,
 525           string_index, CHECK);
 526         Symbol* const sym = cp-&gt;symbol_at(string_index);
 527         cp-&gt;unresolved_string_at_put(index, sym);
 528         break;
 529       }
 530       case JVM_CONSTANT_MethodHandle: {
 531         const int ref_index = cp-&gt;method_handle_index_at(index);
 532         check_property(valid_cp_range(ref_index, length),
 533           &quot;Invalid constant pool index %u in class file %s&quot;,
 534           ref_index, CHECK);
 535         const constantTag tag = cp-&gt;tag_at(ref_index);
 536         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 537 
 538         switch (ref_kind) {
</pre>
<hr />
<pre>
 752             classfile_parse_error(
 753               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 754               name_ref_index, CHECK);
 755           }
 756         }
 757         break;
 758       }
 759       case JVM_CONSTANT_MethodHandle: {
 760         const int ref_index = cp-&gt;method_handle_index_at(index);
 761         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 762         switch (ref_kind) {
 763           case JVM_REF_invokeVirtual:
 764           case JVM_REF_invokeStatic:
 765           case JVM_REF_invokeSpecial:
 766           case JVM_REF_newInvokeSpecial: {
 767             const int name_and_type_ref_index =
 768               cp-&gt;name_and_type_ref_index_at(ref_index);
 769             const int name_ref_index =
 770               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 771             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 772             if (name != vmSymbols::object_initializer_name()) {</span>
<span class="line-modified"> 773               if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
 774                 classfile_parse_error(
 775                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 776                     name_ref_index, CHECK);
 777               }
 778             } else {
<span class="line-modified"> 779               // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="line-added"> 780               // This test corresponds to verify_invoke_instructions in the verifier.</span>
<span class="line-added"> 781               const int signature_ref_index =</span>
<span class="line-added"> 782                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);</span>
<span class="line-added"> 783               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);</span>
<span class="line-added"> 784               if (signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 785                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-added"> 786                 // OK, could be a constructor call</span>
<span class="line-added"> 787               } else if (!signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 788                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {</span>
<span class="line-added"> 789                 // also OK, could be a static factory call</span>
<span class="line-added"> 790               } else {</span>
 791                 classfile_parse_error(
 792                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 793                   name_ref_index, CHECK);
 794               }
 795             }
 796             break;
 797           }
 798           // Other ref_kinds are already fully checked in previous pass.
 799         } // switch(ref_kind)
 800         break;
 801       }
 802       case JVM_CONSTANT_MethodType: {
 803         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 804         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 805         verify_legal_method_signature(no_name, signature, CHECK);
 806         break;
 807       }
 808       case JVM_CONSTANT_Utf8: {
 809         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 810       }
</pre>
<hr />
<pre>
 929   while (entry != NULL) {
 930     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 931       return false;
 932     }
 933     entry = entry-&gt;_next;
 934   }
 935 
 936   // No duplicate is found, allocate a new entry and fill it.
 937   entry = new NameSigHash();
 938   entry-&gt;_name = name;
 939   entry-&gt;_sig = sig;
 940 
 941   // Insert into hash table
 942   entry-&gt;_next = table[index];
 943   table[index] = entry;
 944 
 945   return true;
 946 }
 947 
 948 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 949 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,</span>
<span class="line-modified"> 950                                        int itfs_len,</span>
<span class="line-modified"> 951                                        ConstantPool* cp,</span>
<span class="line-added"> 952                                        bool is_inline_type,</span>
 953                                        bool* const has_nonstatic_concrete_methods,
<span class="line-added"> 954                                        // FIXME: lots of these functions</span>
<span class="line-added"> 955                                        // declare their parameters as const,</span>
<span class="line-added"> 956                                        // which adds only noise to the code.</span>
<span class="line-added"> 957                                        // Remove the spurious const modifiers.</span>
<span class="line-added"> 958                                        // Many are of the form &quot;const int x&quot;</span>
<span class="line-added"> 959                                        // or &quot;T* const x&quot;.</span>
<span class="line-added"> 960                                        bool* const is_declared_atomic,</span>
 961                                        TRAPS) {
 962   assert(stream != NULL, &quot;invariant&quot;);
 963   assert(cp != NULL, &quot;invariant&quot;);
 964   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 965 
 966   if (itfs_len == 0) {
<span class="line-modified"> 967     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);</span>
 968   } else {
 969     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 970     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);</span>
<span class="line-modified"> 971     int index = 0;</span>

 972     for (index = 0; index &lt; itfs_len; index++) {
 973       const u2 interface_index = stream-&gt;get_u2(CHECK);
 974       Klass* interf;
 975       check_property(
 976         valid_klass_reference_at(interface_index),
 977         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 978         interface_index, CHECK);
 979       if (cp-&gt;tag_at(interface_index).is_klass()) {
 980         interf = cp-&gt;resolved_klass_at(interface_index);
 981       } else {
 982         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 983 
 984         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 985         // But need to make sure it&#39;s not an array type.
 986         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 987                            &quot;Bad interface name in class file %s&quot;, CHECK);
 988 
<span class="line-modified"> 989         // Call resolve_super so class circularity is checked</span>
 990         interf = SystemDictionary::resolve_super_or_fail(
 991                                                   _class_name,
 992                                                   unresolved_klass,
 993                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 994                                                   _protection_domain,
 995                                                   false,
 996                                                   CHECK);
 997       }
 998 
 999       if (!interf-&gt;is_interface()) {
1000         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
1001                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1002                           _class_name-&gt;as_klass_external_name(),
1003                           interf-&gt;external_name(),
1004                           interf-&gt;class_in_module_of_loader()));
1005       }
1006 
<span class="line-modified">1007       InstanceKlass* ik = InstanceKlass::cast(interf);</span>
<span class="line-added">1008       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1009         ResourceMark rm(THREAD);</span>
<span class="line-added">1010         Exceptions::fthrow(</span>
<span class="line-added">1011           THREAD_AND_LOCATION,</span>
<span class="line-added">1012           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">1013           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,</span>
<span class="line-added">1014           _class_name-&gt;as_klass_external_name());</span>
<span class="line-added">1015         return;</span>
<span class="line-added">1016       }</span>
<span class="line-added">1017       if (ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1018         set_invalid_inline_super();</span>
<span class="line-added">1019       }</span>
<span class="line-added">1020       if (ik-&gt;has_nonstatic_concrete_methods()) {</span>
1021         *has_nonstatic_concrete_methods = true;
1022       }
<span class="line-modified">1023       if (ik-&gt;is_declared_atomic()) {</span>
<span class="line-added">1024         *is_declared_atomic = true;</span>
<span class="line-added">1025       }</span>
<span class="line-added">1026       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">1027         _implements_identityObject = true;</span>
<span class="line-added">1028       }</span>
<span class="line-added">1029       _temp_local_interfaces-&gt;append(ik);</span>
1030     }
1031 
1032     if (!_need_verify || itfs_len &lt;= 1) {
1033       return;
1034     }
1035 
1036     // Check if there&#39;s any duplicates in interfaces
1037     ResourceMark rm(THREAD);
1038     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1039                                                                  NameSigHash*,
1040                                                                  HASH_ROW_SIZE);
1041     initialize_hashtable(interface_names);
1042     bool dup = false;
1043     const Symbol* name = NULL;
1044     {
1045       debug_only(NoSafepointVerifier nsv;)
1046       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">1047         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);</span>
1048         name = k-&gt;name();
1049         // If no duplicates, add (name, NULL) in hashtable interface_names.
1050         if (!put_after_lookup(name, NULL, interface_names)) {
1051           dup = true;
1052           break;
1053         }
1054       }
1055     }
1056     if (dup) {
1057       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1058                              name-&gt;as_C_string(), CHECK);
1059     }
1060   }
1061 }
1062 
1063 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1064                                            int constantvalue_index,
1065                                            int signature_index,
1066                                            TRAPS) const {
1067   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1503                                             CHECK);
1504   parsed_annotations-&gt;set_field_annotations(a);
1505   a = assemble_annotations(runtime_visible_type_annotations,
1506                            runtime_visible_type_annotations_length,
1507                            runtime_invisible_type_annotations,
1508                            runtime_invisible_type_annotations_length,
1509                            CHECK);
1510   parsed_annotations-&gt;set_field_type_annotations(a);
1511   return;
1512 }
1513 
1514 
1515 // Field allocation types. Used for computing field offsets.
1516 
1517 enum FieldAllocationType {
1518   STATIC_OOP,           // Oops
1519   STATIC_BYTE,          // Boolean, Byte, char
1520   STATIC_SHORT,         // shorts
1521   STATIC_WORD,          // ints
1522   STATIC_DOUBLE,        // aligned long or double
<span class="line-added">1523   STATIC_INLINE,        // inline type field</span>
1524   NONSTATIC_OOP,
1525   NONSTATIC_BYTE,
1526   NONSTATIC_SHORT,
1527   NONSTATIC_WORD,
1528   NONSTATIC_DOUBLE,
<span class="line-added">1529   NONSTATIC_INLINE,</span>
1530   MAX_FIELD_ALLOCATION_TYPE,
1531   BAD_ALLOCATION_TYPE = -1
1532 };
1533 
1534 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1535   BAD_ALLOCATION_TYPE, // 0
1536   BAD_ALLOCATION_TYPE, // 1
1537   BAD_ALLOCATION_TYPE, // 2
1538   BAD_ALLOCATION_TYPE, // 3
1539   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1540   NONSTATIC_SHORT,     // T_CHAR        =  5,
1541   NONSTATIC_WORD,      // T_FLOAT       =  6,
1542   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1543   NONSTATIC_BYTE,      // T_BYTE        =  8,
1544   NONSTATIC_SHORT,     // T_SHORT       =  9,
1545   NONSTATIC_WORD,      // T_INT         = 10,
1546   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1547   NONSTATIC_OOP,       // T_OBJECT      = 12,
1548   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1549   NONSTATIC_OOP,       // T_VALUETYPE   = 14,</span>
<span class="line-modified">1550   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1551   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1552   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1553   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1554   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1555   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,</span>
1556   BAD_ALLOCATION_TYPE, // 0
1557   BAD_ALLOCATION_TYPE, // 1
1558   BAD_ALLOCATION_TYPE, // 2
1559   BAD_ALLOCATION_TYPE, // 3
1560   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1561   STATIC_SHORT,        // T_CHAR        =  5,
1562   STATIC_WORD,         // T_FLOAT       =  6,
1563   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1564   STATIC_BYTE,         // T_BYTE        =  8,
1565   STATIC_SHORT,        // T_SHORT       =  9,
1566   STATIC_WORD,         // T_INT         = 10,
1567   STATIC_DOUBLE,       // T_LONG        = 11,
1568   STATIC_OOP,          // T_OBJECT      = 12,
1569   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1570   STATIC_OOP,          // T_VALUETYPE   = 14,</span>
<span class="line-modified">1571   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1572   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1573   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1574   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1575   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1576   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20</span>
1577 };
1578 
<span class="line-modified">1579 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_inline_type) {</span>
1580   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1581   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1582   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<span class="line-added">1583   if (is_inline_type) {</span>
<span class="line-added">1584     result = is_static ? STATIC_INLINE : NONSTATIC_INLINE;</span>
<span class="line-added">1585   }</span>
1586   return result;
1587 }
1588 
1589 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1590  public:
1591   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1592 
1593   FieldAllocationCount() {
1594     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1595       count[i] = 0;
1596     }
1597   }
1598 
<span class="line-modified">1599   FieldAllocationType update(bool is_static, BasicType type, bool is_inline_type) {</span>
<span class="line-modified">1600     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_inline_type);</span>
1601     if (atype != BAD_ALLOCATION_TYPE) {
1602       // Make sure there is no overflow with injected fields.
1603       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1604       count[atype]++;
1605     }
1606     return atype;
1607   }
1608 };
1609 
1610 // Side-effects: populates the _fields, _fields_annotations,
1611 // _fields_type_annotations fields
1612 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1613                                    bool is_interface,
<span class="line-added">1614                                    bool is_inline_type,</span>
1615                                    FieldAllocationCount* const fac,
1616                                    ConstantPool* cp,
1617                                    const int cp_size,
1618                                    u2* const java_fields_count_ptr,
1619                                    TRAPS) {
1620 
1621   assert(cfs != NULL, &quot;invariant&quot;);
1622   assert(fac != NULL, &quot;invariant&quot;);
1623   assert(cp != NULL, &quot;invariant&quot;);
1624   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1625 
1626   assert(NULL == _fields, &quot;invariant&quot;);
1627   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1628   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1629 
1630   cfs-&gt;guarantee_more(2, CHECK);  // length
1631   const u2 length = cfs-&gt;get_u2_fast();
1632   *java_fields_count_ptr = length;
1633 
1634   int num_injected = 0;
1635   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1636                                                                   &amp;num_injected);
<span class="line-modified">1637 </span>
<span class="line-added">1638   // two more slots are required for inline classes:</span>
<span class="line-added">1639   // one for the static field with a reference to the pre-allocated default value</span>
<span class="line-added">1640   // one for the field the JVM injects when detecting an empty inline class</span>
<span class="line-added">1641   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);</span>
1642 
1643   // The field array starts with tuples of shorts
1644   // [access, name index, sig index, initial value index, byte offset].
1645   // A generic signature slot only exists for field with generic
1646   // signature attribute. And the access flag is set with
1647   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1648   // signature slots are at the end of the field array and after all
1649   // other fields data.
1650   //
1651   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1652   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1653   //       ...
1654   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1655   //       [generic signature index]
1656   //       [generic signature index]
1657   //       ...
1658   //
1659   // Allocate a temporary resource array for field data. For each field,
1660   // a slot is reserved in the temporary array for the generic signature
1661   // index. After parsing all fields, the data are copied to a permanent
1662   // array and any unused slots will be discarded.
1663   ResourceMark rm(THREAD);
1664   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1665                                               u2,
1666                                               total_fields * (FieldInfo::field_slots + 1));
1667 
1668   // The generic signature slots start after all other fields&#39; data.
1669   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1670   int num_generic_signature = 0;
<span class="line-added">1671   int instance_fields_count = 0;</span>
1672   for (int n = 0; n &lt; length; n++) {
1673     // access_flags, name_index, descriptor_index, attributes_count
1674     cfs-&gt;guarantee_more(8, CHECK);
1675 
<span class="line-added">1676     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-added">1677 </span>
<span class="line-added">1678     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">1679     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);</span>
1680     AccessFlags access_flags;


1681     access_flags.set_flags(flags);
1682 
1683     const u2 name_index = cfs-&gt;get_u2_fast();
1684     check_property(valid_symbol_at(name_index),
1685       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1686       name_index, CHECK);
1687     const Symbol* const name = cp-&gt;symbol_at(name_index);
1688     verify_legal_field_name(name, CHECK);
1689 
1690     const u2 signature_index = cfs-&gt;get_u2_fast();
1691     check_property(valid_symbol_at(signature_index),
1692       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1693       signature_index, CHECK);
1694     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1695     verify_legal_field_signature(name, sig, CHECK);
<span class="line-added">1696     if (!access_flags.is_static()) instance_fields_count++;</span>
1697 
1698     u2 constantvalue_index = 0;
1699     bool is_synthetic = false;
1700     u2 generic_signature_index = 0;
1701     const bool is_static = access_flags.is_static();
1702     FieldAnnotationCollector parsed_annotations(_loader_data);
1703 
1704     const u2 attributes_count = cfs-&gt;get_u2_fast();
1705     if (attributes_count &gt; 0) {
1706       parse_field_attributes(cfs,
1707                              attributes_count,
1708                              is_static,
1709                              signature_index,
1710                              &amp;constantvalue_index,
1711                              &amp;is_synthetic,
1712                              &amp;generic_signature_index,
1713                              &amp;parsed_annotations,
1714                              CHECK);
1715 
1716       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1736 
1737       if (is_synthetic) {
1738         access_flags.set_is_synthetic();
1739       }
1740       if (generic_signature_index != 0) {
1741         access_flags.set_field_has_generic_signature();
1742         fa[generic_signature_slot] = generic_signature_index;
1743         generic_signature_slot ++;
1744         num_generic_signature ++;
1745       }
1746     }
1747 
1748     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1749     field-&gt;initialize(access_flags.as_short(),
1750                       name_index,
1751                       signature_index,
1752                       constantvalue_index);
1753     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1754 
1755     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1756     const FieldAllocationType atype = fac-&gt;update(is_static, type, type == T_VALUETYPE);</span>
1757     field-&gt;set_allocation_type(atype);
1758 
1759     // After field is initialized with type, we can augment it with aux info
1760     if (parsed_annotations.has_any_annotations()) {
1761       parsed_annotations.apply_to(field);
1762       if (field-&gt;is_contended()) {
1763         _has_contended_fields = true;
1764       }
1765     }
1766   }
1767 
1768   int index = length;
1769   if (num_injected != 0) {
1770     for (int n = 0; n &lt; num_injected; n++) {
1771       // Check for duplicates
1772       if (injected[n].may_be_java) {
1773         const Symbol* const name      = injected[n].name();
1774         const Symbol* const signature = injected[n].signature();
1775         bool duplicate = false;
1776         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1781             duplicate = true;
1782             break;
1783           }
1784         }
1785         if (duplicate) {
1786           // These will be removed from the field array at the end
1787           continue;
1788         }
1789       }
1790 
1791       // Injected field
1792       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1793       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1794                         injected[n].name_index,
1795                         injected[n].signature_index,
1796                         0);
1797 
1798       const BasicType type = Signature::basic_type(injected[n].signature());
1799 
1800       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1801       const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
1802       field-&gt;set_allocation_type(atype);
1803       index++;
1804     }
1805   }
1806 
<span class="line-added">1807   if (is_inline_type) {</span>
<span class="line-added">1808     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1809     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,</span>
<span class="line-added">1810                       vmSymbols::default_value_name_enum,</span>
<span class="line-added">1811                       vmSymbols::object_signature_enum,</span>
<span class="line-added">1812                       0);</span>
<span class="line-added">1813     const BasicType type = Signature::basic_type(vmSymbols::object_signature());</span>
<span class="line-added">1814     const FieldAllocationType atype = fac-&gt;update(true, type, false);</span>
<span class="line-added">1815     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1816     index++;</span>
<span class="line-added">1817   }</span>
<span class="line-added">1818 </span>
<span class="line-added">1819   if (is_inline_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-added">1820     _is_empty_inline_type = true;</span>
<span class="line-added">1821     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1822     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,</span>
<span class="line-added">1823         vmSymbols::empty_marker_name_enum,</span>
<span class="line-added">1824         vmSymbols::byte_signature_enum,</span>
<span class="line-added">1825         0);</span>
<span class="line-added">1826     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());</span>
<span class="line-added">1827     const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
<span class="line-added">1828     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1829     index++;</span>
<span class="line-added">1830   }</span>
<span class="line-added">1831 </span>
<span class="line-added">1832   if (instance_fields_count &gt; 0) {</span>
<span class="line-added">1833     _has_nonstatic_fields = true;</span>
<span class="line-added">1834   }</span>
<span class="line-added">1835 </span>
1836   assert(NULL == _fields, &quot;invariant&quot;);
1837 
1838   _fields =
1839     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1840                                    index * FieldInfo::field_slots + num_generic_signature,
1841                                    CHECK);
1842   // Sometimes injected fields already exist in the Java source so
1843   // the fields array could be too long.  In that case the
1844   // fields array is trimed. Also unused slots that were reserved
1845   // for generic signature indexes are discarded.
1846   {
1847     int i = 0;
1848     for (; i &lt; index * FieldInfo::field_slots; i++) {
1849       _fields-&gt;at_put(i, fa[i]);
1850     }
1851     for (int j = total_fields * FieldInfo::field_slots;
1852          j &lt; generic_signature_slot; j++) {
1853       _fields-&gt;at_put(i++, fa[j]);
1854     }
1855     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2131         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2132         checked_exception, CHECK_NULL);
2133     }
2134   }
2135   // check exceptions attribute length
2136   if (_need_verify) {
2137     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2138                                                    sizeof(u2) * size),
2139                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2140   }
2141   return checked_exceptions_start;
2142 }
2143 
2144 void ClassFileParser::throwIllegalSignature(const char* type,
2145                                             const Symbol* name,
2146                                             const Symbol* sig,
2147                                             TRAPS) const {
2148   assert(name != NULL, &quot;invariant&quot;);
2149   assert(sig != NULL, &quot;invariant&quot;);
2150 
<span class="line-added">2151   const char* class_note = &quot;&quot;;</span>
<span class="line-added">2152   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2153     class_note = &quot; (an inline class)&quot;;</span>
<span class="line-added">2154   }</span>
<span class="line-added">2155 </span>
2156   ResourceMark rm(THREAD);
2157   Exceptions::fthrow(THREAD_AND_LOCATION,
2158       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2159       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2160       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());</span>
2161 }
2162 
2163 AnnotationCollector::ID
2164 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2165                                       const Symbol* name,
2166                                       const bool can_access_vm_annotations) {
2167   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2168   // Privileged code can use all annotations.  Other code silently drops some.
2169   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2170                           loader_data-&gt;is_platform_class_loader_data() ||
2171                           can_access_vm_annotations;
2172   switch (sid) {
2173     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2174       if (_location != _in_method)  break;  // only allow for methods
2175       if (!privileged)              break;  // only allow in privileged code
2176       return _method_CallerSensitive;
2177     }
2178     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2179       if (_location != _in_method)  break;  // only allow for methods
2180       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2405                              runtime_visible_type_annotations_length,
2406                              runtime_invisible_type_annotations,
2407                              runtime_invisible_type_annotations_length,
2408                              CHECK);
2409     cm-&gt;set_type_annotations(a);
2410   }
2411 }
2412 
2413 
2414 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2415 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2416 // Method* to save footprint, so we only know the size of the resulting Method* when the
2417 // entire method attribute is parsed.
2418 //
2419 // The promoted_flags parameter is used to pass relevant access_flags
2420 // from the method back up to the containing klass. These flag values
2421 // are added to klass&#39;s access_flags.
2422 
2423 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2424                                       bool is_interface,
<span class="line-added">2425                                       bool is_inline_type,</span>
2426                                       const ConstantPool* cp,
2427                                       AccessFlags* const promoted_flags,
2428                                       TRAPS) {
2429   assert(cfs != NULL, &quot;invariant&quot;);
2430   assert(cp != NULL, &quot;invariant&quot;);
2431   assert(promoted_flags != NULL, &quot;invariant&quot;);
2432 
2433   ResourceMark rm(THREAD);
2434   // Parse fixed parts:
2435   // access_flags, name_index, descriptor_index, attributes_count
2436   cfs-&gt;guarantee_more(8, CHECK_NULL);
2437 
2438   int flags = cfs-&gt;get_u2_fast();
2439   const u2 name_index = cfs-&gt;get_u2_fast();
2440   const int cp_size = cp-&gt;length();
2441   check_property(
2442     valid_symbol_at(name_index),
2443     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2444     name_index, CHECK_NULL);
2445   const Symbol* const name = cp-&gt;symbol_at(name_index);
2446   verify_legal_method_name(name, CHECK_NULL);
2447 
2448   const u2 signature_index = cfs-&gt;get_u2_fast();
2449   guarantee_property(
2450     valid_symbol_at(signature_index),
2451     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2452     signature_index, CHECK_NULL);
2453   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2454 
2455   if (name == vmSymbols::class_initializer_name()) {
2456     // We ignore the other access flags for a valid class initializer.
2457     // (JVM Spec 2nd ed., chapter 4.6)
2458     if (_major_version &lt; 51) { // backward compatibility
2459       flags = JVM_ACC_STATIC;
2460     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2461       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2462     } else {
2463       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2464     }
2465   } else {
<span class="line-modified">2466     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);</span>
<span class="line-modified">2467   }</span>
<span class="line-modified">2468 </span>
<span class="line-modified">2469   if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">2470     if (is_interface) {</span>
<span class="line-added">2471       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>
<span class="line-added">2472     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2473       // OK, a constructor</span>
<span class="line-added">2474     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2475       // also OK, a static factory, as long as the return value is good</span>
<span class="line-added">2476       bool ok = false;</span>
<span class="line-added">2477       SignatureStream ss((Symbol*) signature, true);</span>
<span class="line-added">2478       while (!ss.at_return_type())  ss.next();</span>
<span class="line-added">2479       if (ss.is_reference()) {</span>
<span class="line-added">2480         Symbol* ret = ss.as_symbol();</span>
<span class="line-added">2481         const Symbol* required = class_name();</span>
<span class="line-added">2482         if (is_unsafe_anonymous()) {</span>
<span class="line-added">2483           // The original class name in the UAC byte stream gets changed.  So</span>
<span class="line-added">2484           // using the original name in the return type is no longer valid.</span>
<span class="line-added">2485           required = vmSymbols::java_lang_Object();</span>
<span class="line-added">2486         }</span>
<span class="line-added">2487         ok = (ret == required);</span>
<span class="line-added">2488       }</span>
<span class="line-added">2489       if (!ok) {</span>
<span class="line-added">2490         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2491       }</span>
<span class="line-added">2492     } else {</span>
<span class="line-added">2493       // not OK, so throw the same error as in verify_legal_method_signature.</span>
<span class="line-added">2494       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2495     }</span>
<span class="line-added">2496     // A declared &lt;init&gt; method must always be either a non-static</span>
<span class="line-added">2497     // object constructor, with a void return, or else it must be a</span>
<span class="line-added">2498     // static factory method, with a non-void return.  No other</span>
<span class="line-added">2499     // definition of &lt;init&gt; is possible.</span>
<span class="line-added">2500     //</span>
<span class="line-added">2501     // The verifier (in verify_invoke_instructions) will inspect the</span>
<span class="line-added">2502     // signature of any attempt to invoke &lt;init&gt;, and ensures that it</span>
<span class="line-added">2503     // returns non-void if and only if it is being invoked by</span>
<span class="line-added">2504     // invokestatic, and void if and only if it is being invoked by</span>
<span class="line-added">2505     // invokespecial.</span>
<span class="line-added">2506     //</span>
<span class="line-added">2507     // When a symbolic reference to &lt;init&gt; is resolved for a</span>
<span class="line-added">2508     // particular invocation mode (special or static), the mode is</span>
<span class="line-added">2509     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.</span>
<span class="line-added">2510     // Thus, it is impossible to statically invoke a constructor, and</span>
<span class="line-added">2511     // impossible to &quot;new + invokespecial&quot; a static factory, either</span>
<span class="line-added">2512     // through bytecode or through reflection.</span>
2513   }
2514 
2515   int args_size = -1;  // only used when _need_verify is true
2516   if (_need_verify) {
2517     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2518                  verify_legal_method_signature(name, signature, CHECK_NULL);
2519     if (args_size &gt; MAX_ARGS_SIZE) {
2520       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2521     }
2522   }
2523 
2524   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2525 
2526   // Default values for code and exceptions attribute elements
2527   u2 max_stack = 0;
2528   u2 max_locals = 0;
2529   u4 code_length = 0;
2530   const u1* code_start = 0;
2531   u2 exception_table_length = 0;
2532   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
3043       _has_finalizer = true;
3044     }
3045   }
3046   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3047       signature == vmSymbols::void_method_signature() &amp;&amp;
3048       m-&gt;is_vanilla_constructor()) {
3049     _has_vanilla_constructor = true;
3050   }
3051 
3052   NOT_PRODUCT(m-&gt;verify());
3053   return m;
3054 }
3055 
3056 
3057 // The promoted_flags parameter is used to pass relevant access_flags
3058 // from the methods back up to the containing klass. These flag values
3059 // are added to klass&#39;s access_flags.
3060 // Side-effects: populates the _methods field in the parser
3061 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3062                                     bool is_interface,
<span class="line-added">3063                                     bool is_inline_type,</span>
3064                                     AccessFlags* promoted_flags,
3065                                     bool* has_final_method,
3066                                     bool* declares_nonstatic_concrete_methods,
3067                                     TRAPS) {
3068   assert(cfs != NULL, &quot;invariant&quot;);
3069   assert(promoted_flags != NULL, &quot;invariant&quot;);
3070   assert(has_final_method != NULL, &quot;invariant&quot;);
3071   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3072 
3073   assert(NULL == _methods, &quot;invariant&quot;);
3074 
3075   cfs-&gt;guarantee_more(2, CHECK);  // length
3076   const u2 length = cfs-&gt;get_u2_fast();
3077   if (length == 0) {
3078     _methods = Universe::the_empty_method_array();
3079   } else {
3080     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3081                                                    length,
3082                                                    NULL,
3083                                                    CHECK);
3084 
3085     for (int index = 0; index &lt; length; index++) {
3086       Method* method = parse_method(cfs,
3087                                     is_interface,
<span class="line-added">3088                                     is_inline_type,</span>
3089                                     _cp,
3090                                     promoted_flags,
3091                                     CHECK);
3092 
3093       if (method-&gt;is_final()) {
3094         *has_final_method = true;
3095       }
3096       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3097       // used for interface initialization, and default method inheritance analysis
3098       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3099         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3100         *declares_nonstatic_concrete_methods = true;
3101       }
3102       _methods-&gt;at_put(index, method);
3103     }
3104 
3105     if (_need_verify &amp;&amp; length &gt; 1) {
3106       // Check duplicated methods
3107       ResourceMark rm(THREAD);
3108       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3261       valid_klass_reference_at(inner_class_info_index),
3262       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3263       inner_class_info_index, CHECK_0);
3264     // Outer class index
3265     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3266     check_property(
3267       outer_class_info_index == 0 ||
3268         valid_klass_reference_at(outer_class_info_index),
3269       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3270       outer_class_info_index, CHECK_0);
3271     // Inner class name
3272     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3273     check_property(
3274       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3275       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3276       inner_name_index, CHECK_0);
3277     if (_need_verify) {
3278       guarantee_property(inner_class_info_index != outer_class_info_index,
3279                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3280     }
<span class="line-modified">3281 </span>
<span class="line-modified">3282     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
3283     // JVM_ACC_MODULE is defined in JDK-9 and later.
3284     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3285       recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">3286     }</span>
<span class="line-modified">3287     // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">3288     if (supports_inline_types()) {</span>
<span class="line-added">3289       recognized_modifiers |= JVM_ACC_VALUE;</span>
3290     }
<span class="line-added">3291 </span>
<span class="line-added">3292     // Access flags</span>
<span class="line-added">3293     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">3294 </span>
3295     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3296       // Set abstract bit for old class files for backward compatibility
3297       flags |= JVM_ACC_ABSTRACT;
3298     }
3299     verify_legal_class_modifiers(flags, CHECK_0);
3300     AccessFlags inner_access_flags(flags);
3301 
3302     inner_classes-&gt;at_put(index++, inner_class_info_index);
3303     inner_classes-&gt;at_put(index++, outer_class_info_index);
3304     inner_classes-&gt;at_put(index++, inner_name_index);
3305     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3306   }
3307 
3308   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3309   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3310     for(int i = 0; i &lt; length * 4; i += 4) {
3311       for(int j = i + 4; j &lt; length * 4; j += 4) {
3312         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3313                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3314                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
4134       }
4135     }
4136     if (runtime_invisible_annotations != NULL) {
4137       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
4138         int append = runtime_visible_annotations_length+i;
4139         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
4140       }
4141     }
4142   }
4143   return annotations;
4144 }
4145 
4146 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
4147                                                         const int super_class_index,
4148                                                         const bool need_verify,
4149                                                         TRAPS) {
4150   assert(cp != NULL, &quot;invariant&quot;);
4151   const InstanceKlass* super_klass = NULL;
4152 
4153   if (super_class_index == 0) {
<span class="line-modified">4154     check_property(_class_name == vmSymbols::java_lang_Object()</span>
<span class="line-added">4155                    || (_access_flags.get_flags() &amp; JVM_ACC_VALUE),</span>
4156                    &quot;Invalid superclass index %u in class file %s&quot;,
4157                    super_class_index,
4158                    CHECK_NULL);
4159   } else {
4160     check_property(valid_klass_reference_at(super_class_index),
4161                    &quot;Invalid superclass index %u in class file %s&quot;,
4162                    super_class_index,
4163                    CHECK_NULL);
4164     // The class name should be legal because it is checked when parsing constant pool.
4165     // However, make sure it is not an array type.
4166     bool is_array = false;
4167     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4168       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4169       if (need_verify)
4170         is_array = super_klass-&gt;is_array_klass();
4171     } else if (need_verify) {
4172       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4173     }
4174     if (need_verify) {
4175       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4315 }
4316 
4317 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4318   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4319   if (_nonstatic_oop_map_count &gt; 0) {
4320     OopMapBlock* map = _nonstatic_oop_maps;
4321     OopMapBlock* last_map = last_oop_map();
4322     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4323     while (map &lt;= last_map) {
4324       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4325                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4326       map++;
4327     }
4328   }
4329 }
4330 
4331 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4332   print_on(st);
4333 }
4334 
<span class="line-added">4335 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-added">4336                                                 const char* msg,</span>
<span class="line-added">4337                                                 const Symbol* name,</span>
<span class="line-added">4338                                                 const Symbol* sig) const {</span>
<span class="line-added">4339 </span>
<span class="line-added">4340   ResourceMark rm(THREAD);</span>
<span class="line-added">4341   if (name == NULL || sig == NULL) {</span>
<span class="line-added">4342     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4343         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4344         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4345   }</span>
<span class="line-added">4346   else {</span>
<span class="line-added">4347     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4348         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4349         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),</span>
<span class="line-added">4350         _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4351   }</span>
<span class="line-added">4352 }</span>
<span class="line-added">4353 </span>
4354 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4355 void ClassFileParser::layout_fields(ConstantPool* cp,
4356                                     const FieldAllocationCount* fac,
4357                                     const ClassAnnotationCollector* parsed_annotations,
4358                                     FieldLayoutInfo* info,
4359                                     TRAPS) {
4360 
4361   assert(cp != NULL, &quot;invariant&quot;);
4362 
4363   // Field size and offset computation
4364   int nonstatic_field_size = _super_klass == NULL ? 0 :
4365                                _super_klass-&gt;nonstatic_field_size();
<span class="line-added">4366   int next_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">4367   int first_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">4368 </span>
<span class="line-added">4369   // Fields that are inline types are handled differently depending if they are static or not:</span>
<span class="line-added">4370   // - static fields are oops</span>
<span class="line-added">4371   // - non-static fields are embedded</span>
4372 
4373   // Count the contended fields by type.
4374   //
4375   // We ignore static fields, because @Contended is not supported for them.
4376   // The layout code below will also ignore the static fields.
4377   int nonstatic_contended_count = 0;
4378   FieldAllocationCount fac_contended;
4379   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4380     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4381     if (fs.is_contended()) {
4382       fac_contended.count[atype]++;
4383       if (!fs.access_flags().is_static()) {
4384         nonstatic_contended_count++;
4385       }
4386     }
4387   }
4388 
4389 
4390   // Calculate the starting byte offsets
4391   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-added">4392   // Inline types in static fields are not embedded, they are handled with oops</span>
4393   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4394                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_INLINE]) * heapOopSize);</span>
4395   if (fac-&gt;count[STATIC_DOUBLE]) {
4396     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4397   }
4398 
4399   int next_static_word_offset   = next_static_double_offset +
4400                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4401   int next_static_short_offset  = next_static_word_offset +
4402                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4403   int next_static_byte_offset   = next_static_short_offset +
4404                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4405 
4406   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4407                                 nonstatic_field_size * heapOopSize;
4408 
<span class="line-added">4409   // First field of inline types is aligned on a long boundary in order to ease</span>
<span class="line-added">4410   // in-lining of inline types (with header removal) in packed arrays and</span>
<span class="line-added">4411   // inlined fields</span>
<span class="line-added">4412   int initial_inline_type_padding = 0;</span>
<span class="line-added">4413   if (is_inline_type()) {</span>
<span class="line-added">4414     int old = nonstatic_fields_start;</span>
<span class="line-added">4415     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);</span>
<span class="line-added">4416     initial_inline_type_padding = nonstatic_fields_start - old;</span>
<span class="line-added">4417   }</span>
<span class="line-added">4418 </span>
4419   int next_nonstatic_field_offset = nonstatic_fields_start;
4420 
4421   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4422 
4423   // Class is contended, pad before all the fields
4424   if (is_contended_class) {
4425     next_nonstatic_field_offset += ContendedPaddingWidth;
4426   }
4427 
<span class="line-added">4428   // Temporary inline types restrictions</span>
<span class="line-added">4429   if (is_inline_type()) {</span>
<span class="line-added">4430     if (is_contended_class) {</span>
<span class="line-added">4431       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
<span class="line-added">4432       return;</span>
<span class="line-added">4433     }</span>
<span class="line-added">4434   }</span>
<span class="line-added">4435 </span>
4436   // Compute the non-contended fields count.
4437   // The packing code below relies on these counts to determine if some field
4438   // can be squeezed into the alignment gap. Contended fields are obviously
4439   // exempt from that.
4440   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4441   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4442   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4443   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4444   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4445 
<span class="line-added">4446   int static_inline_type_count = 0;</span>
<span class="line-added">4447   int nonstatic_inline_type_count = 0;</span>
<span class="line-added">4448   int* nonstatic_inline_type_indexes = NULL;</span>
<span class="line-added">4449   Klass** nonstatic_inline_type_klasses = NULL;</span>
<span class="line-added">4450   unsigned int inline_type_oop_map_count = 0;</span>
<span class="line-added">4451   int inline_types_not_inlined = 0;</span>
<span class="line-added">4452   int not_atomic_inline_types = 0;</span>
<span class="line-added">4453 </span>
<span class="line-added">4454   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_INLINE] + 1;</span>
<span class="line-added">4455 </span>
<span class="line-added">4456   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-added">4457                                                                max_nonstatic_inline_type);</span>
<span class="line-added">4458   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {</span>
<span class="line-added">4459     nonstatic_inline_type_indexes[i] = -1;</span>
<span class="line-added">4460   }</span>
<span class="line-added">4461   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-added">4462                                                                max_nonstatic_inline_type);</span>
<span class="line-added">4463 </span>
<span class="line-added">4464   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {</span>
<span class="line-added">4465     if (fs.allocation_type() == STATIC_INLINE) {</span>
<span class="line-added">4466       ResourceMark rm;</span>
<span class="line-added">4467       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4468         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4469       }</span>
<span class="line-added">4470       static_inline_type_count++;</span>
<span class="line-added">4471     } else if (fs.allocation_type() == NONSTATIC_INLINE) {</span>
<span class="line-added">4472       // Pre-resolve the inline field and check for inline type circularity issues.</span>
<span class="line-added">4473       ResourceMark rm;</span>
<span class="line-added">4474       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4475         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4476       }</span>
<span class="line-added">4477       Klass* klass =</span>
<span class="line-added">4478         SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-added">4479                                                             Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">4480                                                             _protection_domain, true, CHECK);</span>
<span class="line-added">4481       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">4482       if (!klass-&gt;access_flags().is_inline_type()) {</span>
<span class="line-added">4483         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">4484       }</span>
<span class="line-added">4485       ValueKlass* vk = ValueKlass::cast(klass);</span>
<span class="line-added">4486       // Conditions to apply flattening or not should be defined in a single place</span>
<span class="line-added">4487       bool too_big_to_allocate_inline = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-added">4488                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
<span class="line-added">4489       bool too_atomic_to_allocate_inline = vk-&gt;is_declared_atomic();</span>
<span class="line-added">4490       bool too_volatile_to_allocate_inline = fs.access_flags().is_volatile();</span>
<span class="line-added">4491       if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-added">4492         too_atomic_to_allocate_inline = false;</span>
<span class="line-added">4493         // too_volatile_to_allocate_inline = false; //FIXME</span>
<span class="line-added">4494         // volatile fields are currently never inlined, this could change in the future</span>
<span class="line-added">4495       }</span>
<span class="line-added">4496       if (!(too_big_to_allocate_inline | too_atomic_to_allocate_inline | too_volatile_to_allocate_inline)) {</span>
<span class="line-added">4497         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();</span>
<span class="line-added">4498         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;</span>
<span class="line-added">4499         nonstatic_inline_type_count++;</span>
<span class="line-added">4500 </span>
<span class="line-added">4501         ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4502         if (vklass-&gt;contains_oops()) {</span>
<span class="line-added">4503           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4504         }</span>
<span class="line-added">4505         fs.set_inlined(true);</span>
<span class="line-added">4506         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-added">4507           not_atomic_inline_types++;</span>
<span class="line-added">4508         }</span>
<span class="line-added">4509       } else {</span>
<span class="line-added">4510         inline_types_not_inlined++;</span>
<span class="line-added">4511         fs.set_inlined(false);</span>
<span class="line-added">4512       }</span>
<span class="line-added">4513     }</span>
<span class="line-added">4514   }</span>
<span class="line-added">4515 </span>
<span class="line-added">4516   // Adjusting non_static_oop_count to take into account inline types fields not inlined;</span>
<span class="line-added">4517   nonstatic_oop_count += inline_types_not_inlined;</span>
<span class="line-added">4518 </span>
4519   // Total non-static fields count, including every contended field
4520   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4521                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4522                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_INLINE];</span>
4523 
4524   const bool super_has_nonstatic_fields =
4525           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4526   const bool has_nonstatic_fields =
4527     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-added">4528   const bool has_nonstatic_inline_fields = nonstatic_inline_type_count &gt; 0;</span>
4529 
<span class="line-added">4530   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
<span class="line-added">4531     // There are a number of fixes required throughout the type system and JIT</span>
<span class="line-added">4532     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
<span class="line-added">4533     return;</span>
<span class="line-added">4534   }</span>
4535 
4536   // Prepare list of oops for oop map generation.
4537   //
4538   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4539   // regions. offset[i] is the start of the i-th region, which then has
4540   // count[i] oops following. Before we know how many regions are required,
4541   // we pessimistically allocate the maps to fit all the oops into the
4542   // distinct regions.
<span class="line-modified">4543   //</span>
4544   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4545   int max_oop_map_count =</span>
<span class="line-added">4546       super_oop_map_count +</span>
<span class="line-added">4547       fac-&gt;count[NONSTATIC_OOP] +</span>
<span class="line-added">4548       inline_type_oop_map_count +</span>
<span class="line-added">4549       inline_types_not_inlined;</span>
4550 
4551   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4552   if (super_oop_map_count &gt; 0) {
4553     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4554                                                     _super_klass-&gt;nonstatic_oop_map_count());
4555   }
4556 
4557   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4558 
4559   bool compact_fields  = true;
4560   bool allocate_oops_first = false;
4561 
4562   int next_nonstatic_oop_offset = 0;
4563   int next_nonstatic_double_offset = 0;
4564 
4565   // Rearrange fields for a given allocation style
4566   if (allocate_oops_first) {
4567     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4568     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4569     next_nonstatic_double_offset = next_nonstatic_oop_offset +
</pre>
<hr />
<pre>
4624   }
4625 
4626   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4627                                      (nonstatic_double_count * BytesPerLong);
4628   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4629                                       (nonstatic_word_count * BytesPerInt);
4630   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4631                                      (nonstatic_short_count * BytesPerShort);
4632   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4633                                        nonstatic_byte_count;
4634 
4635   // let oops jump before padding with this allocation style
4636   if (!allocate_oops_first) {
4637     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4638     if( nonstatic_oop_count &gt; 0 ) {
4639       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4640     }
4641     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4642   }
4643 
<span class="line-added">4644   // Aligning embedded inline types</span>
<span class="line-added">4645   // bug below, the current algorithm to layout embedded inline types always put them at the</span>
<span class="line-added">4646   // end of the layout, which doesn&#39;t match the different allocation policies the VM is</span>
<span class="line-added">4647   // supposed to provide =&gt; FixMe</span>
<span class="line-added">4648   // Note also that the current alignment policy is to make each inline type starting on a</span>
<span class="line-added">4649   // 64 bits boundary. This could be optimized later. For instance, it could be nice to</span>
<span class="line-added">4650   // align inline types according to their most constrained internal type.</span>
<span class="line-added">4651   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-added">4652   int next_inline_type_index = 0;</span>
<span class="line-added">4653 </span>
4654   // Iterate over fields again and compute correct offsets.
4655   // The field allocation type was temporarily stored in the offset slot.
4656   // oop fields are located before non-oop fields (static and non-static).
4657   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4658 
4659     // skip already laid out fields
4660     if (fs.is_offset_set()) continue;
4661 
4662     // contended instance fields are handled below
4663     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4664 
4665     int real_offset = 0;
4666     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4667 
4668     // pack the rest of the fields
4669     switch (atype) {
<span class="line-added">4670       // Inline types in static fields are handled with oops</span>
<span class="line-added">4671       case STATIC_INLINE:   // Fallthrough</span>
4672       case STATIC_OOP:
4673         real_offset = next_static_oop_offset;
4674         next_static_oop_offset += heapOopSize;
4675         break;
4676       case STATIC_BYTE:
4677         real_offset = next_static_byte_offset;
4678         next_static_byte_offset += 1;
4679         break;
4680       case STATIC_SHORT:
4681         real_offset = next_static_short_offset;
4682         next_static_short_offset += BytesPerShort;
4683         break;
4684       case STATIC_WORD:
4685         real_offset = next_static_word_offset;
4686         next_static_word_offset += BytesPerInt;
4687         break;
4688       case STATIC_DOUBLE:
4689         real_offset = next_static_double_offset;
4690         next_static_double_offset += BytesPerLong;
4691         break;
<span class="line-added">4692       case NONSTATIC_INLINE:</span>
<span class="line-added">4693         if (fs.is_inlined()) {</span>
<span class="line-added">4694           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];</span>
<span class="line-added">4695           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);</span>
<span class="line-added">4696           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);</span>
<span class="line-added">4697           ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4698           real_offset = next_nonstatic_inline_type_offset;</span>
<span class="line-added">4699           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-added">4700           // aligning next inline type on a 64 bits boundary</span>
<span class="line-added">4701           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);</span>
<span class="line-added">4702           next_inline_type_index += 1;</span>
<span class="line-added">4703 </span>
<span class="line-added">4704           if (vklass-&gt;contains_oops()) { // add flatten oop maps</span>
<span class="line-added">4705             int diff = real_offset - vklass-&gt;first_field_offset();</span>
<span class="line-added">4706             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">4707             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4708             while (map &lt; last_map) {</span>
<span class="line-added">4709               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());</span>
<span class="line-added">4710               map++;</span>
<span class="line-added">4711             }</span>
<span class="line-added">4712           }</span>
<span class="line-added">4713           break;</span>
<span class="line-added">4714         } else {</span>
<span class="line-added">4715           // Fall through</span>
<span class="line-added">4716         }</span>
4717       case NONSTATIC_OOP:
4718         if( nonstatic_oop_space_count &gt; 0 ) {
4719           real_offset = nonstatic_oop_space_offset;
4720           nonstatic_oop_space_offset += heapOopSize;
4721           nonstatic_oop_space_count  -= 1;
4722         } else {
4723           real_offset = next_nonstatic_oop_offset;
4724           next_nonstatic_oop_offset += heapOopSize;
4725         }
4726         nonstatic_oop_maps-&gt;add(real_offset, 1);
4727         break;
4728       case NONSTATIC_BYTE:
4729         if( nonstatic_byte_space_count &gt; 0 ) {
4730           real_offset = nonstatic_byte_space_offset;
4731           nonstatic_byte_space_offset += 1;
4732           nonstatic_byte_space_count  -= 1;
4733         } else {
4734           real_offset = next_nonstatic_byte_offset;
4735           next_nonstatic_byte_offset += 1;
4736         }
</pre>
<hr />
<pre>
4815             break;
4816 
4817           case NONSTATIC_SHORT:
4818             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4819             real_offset = next_nonstatic_padded_offset;
4820             next_nonstatic_padded_offset += BytesPerShort;
4821             break;
4822 
4823           case NONSTATIC_WORD:
4824             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4825             real_offset = next_nonstatic_padded_offset;
4826             next_nonstatic_padded_offset += BytesPerInt;
4827             break;
4828 
4829           case NONSTATIC_DOUBLE:
4830             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4831             real_offset = next_nonstatic_padded_offset;
4832             next_nonstatic_padded_offset += BytesPerLong;
4833             break;
4834 
<span class="line-added">4835             // Inline types in static fields are handled with oops</span>
<span class="line-added">4836           case NONSTATIC_INLINE:</span>
<span class="line-added">4837             throwInlineTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-added">4838                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
<span class="line-added">4839             return;</span>
<span class="line-added">4840 </span>
4841           case NONSTATIC_OOP:
4842             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4843             real_offset = next_nonstatic_padded_offset;
4844             next_nonstatic_padded_offset += heapOopSize;
4845             nonstatic_oop_maps-&gt;add(real_offset, 1);
4846             break;
4847 
4848           default:
4849             ShouldNotReachHere();
4850         }
4851 
4852         if (fs.contended_group() == 0) {
4853           // Contended group defines the equivalence class over the fields:
4854           // the fields within the same contended group are not inter-padded.
4855           // The only exception is default group, which does not incur the
4856           // equivalence, and so requires intra-padding.
4857           next_nonstatic_padded_offset += ContendedPaddingWidth;
4858         }
4859 
4860         fs.set_offset(real_offset);
4861       } // for
4862 
4863       // Start laying out the next group.
4864       // Note that this will effectively pad the last group in the back;
4865       // this is expected to alleviate memory contention effects for
4866       // subclass fields and/or adjacent object.
4867       // If this was the default group, the padding is already in place.
4868       if (current_group != 0) {
4869         next_nonstatic_padded_offset += ContendedPaddingWidth;
4870       }
4871     }
4872 
4873     // handle static fields
4874   }
4875 
4876   // Entire class is contended, pad in the back.
4877   // This helps to alleviate memory contention effects for subclass fields
4878   // and/or adjacent object.
4879   if (is_contended_class) {
<span class="line-added">4880     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);</span>
4881     next_nonstatic_padded_offset += ContendedPaddingWidth;
4882   }
4883 
<span class="line-modified">4884   int notaligned_nonstatic_fields_end;</span>
<span class="line-added">4885   if (nonstatic_inline_type_count != 0) {</span>
<span class="line-added">4886     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;</span>
<span class="line-added">4887   } else {</span>
<span class="line-added">4888     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>
<span class="line-added">4889   }</span>
4890 
<span class="line-modified">4891   int nonstatic_field_sz_align = heapOopSize;</span>
<span class="line-added">4892   if (is_inline_type()) {</span>
<span class="line-added">4893     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {</span>
<span class="line-added">4894       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy</span>
<span class="line-added">4895     }</span>
<span class="line-added">4896   }</span>
<span class="line-added">4897   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);</span>
4898   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4899   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4900 
4901   int static_field_size         = (static_fields_end -
4902                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4903   nonstatic_field_size          = nonstatic_field_size +
4904                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4905 
4906   int instance_size             = align_object_size(instance_end / wordSize);
4907 
4908   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4909          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)</span>
<span class="line-modified">4910          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
<span class="line-added">4911 </span>
4912 
4913   // Invariant: nonstatic_field end/start should only change if there are
4914   // nonstatic fields in the class, or if the class is contended. We compare
4915   // against the non-aligned value, so that end alignment will not fail the
4916   // assert without actually having the fields.
4917   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4918          is_contended_class ||
4919          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4920 
4921   // Number of non-static oop map blocks allocated at end of klass.
4922   nonstatic_oop_maps-&gt;compact();
4923 
4924 #ifndef PRODUCT
<span class="line-modified">4925   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||</span>
<span class="line-added">4926       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_inline_fields))) {</span>
4927     print_field_layout(_class_name,
4928           _fields,
4929           cp,
4930           instance_size,
4931           nonstatic_fields_start,
4932           nonstatic_fields_end,
4933           static_fields_end);
<span class="line-added">4934     nonstatic_oop_maps-&gt;print_on(tty);</span>
<span class="line-added">4935     tty-&gt;print(&quot;\n&quot;);</span>
<span class="line-added">4936     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);</span>
<span class="line-added">4937     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);</span>
<span class="line-added">4938     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);</span>
<span class="line-added">4939     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);</span>
<span class="line-added">4940     tty-&gt;print_cr(&quot;---&quot;);</span>
4941   }
4942 
4943 #endif
4944   // Pass back information needed for InstanceKlass creation
4945   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4946   info-&gt;_instance_size = instance_size;
4947   info-&gt;_static_field_size = static_field_size;
4948   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4949   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<span class="line-added">4950   info-&gt;_has_inline_fields = nonstatic_inline_type_count &gt; 0;</span>
<span class="line-added">4951 </span>
<span class="line-added">4952   // An inline type is naturally atomic if it has just one field, and</span>
<span class="line-added">4953   // that field is simple enough.</span>
<span class="line-added">4954   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;</span>
<span class="line-added">4955                                 !super_has_nonstatic_fields &amp;&amp;</span>
<span class="line-added">4956                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;</span>
<span class="line-added">4957                                 (not_atomic_inline_types == 0) &amp;&amp;</span>
<span class="line-added">4958                                 (nonstatic_contended_count == 0));</span>
<span class="line-added">4959   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="line-added">4960   // bits we could make the decision to align instances of this class</span>
<span class="line-added">4961   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="line-added">4962   // And on machines which supported larger atomics we could similarly</span>
<span class="line-added">4963   // allow larger values to be atomic, if properly aligned.</span>
4964 }
4965 
4966 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4967   assert(ik != NULL, &quot;invariant&quot;);
4968 
4969   const Klass* const super = ik-&gt;super();
4970 
4971   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4972   // in which case we don&#39;t have to register objects as finalizable
4973   if (!_has_empty_finalizer) {
4974     if (_has_finalizer ||
4975         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4976       ik-&gt;set_has_finalizer();
4977     }
4978   }
4979 
4980 #ifdef ASSERT
4981   bool f = false;
4982   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4983                                            vmSymbols::void_method_signature());
4984   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4985       f = true;
4986   }
4987 
4988   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4989   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4990   // will not work as expected we shouldn&#39;t abort vm in this case
4991   if (!ik-&gt;has_redefined_this_or_super()) {
4992     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4993   }
4994 #endif
4995 
4996   // Check if this klass supports the java.lang.Cloneable interface
4997   if (SystemDictionary::Cloneable_klass_loaded()) {
4998     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
<span class="line-added">4999       if (ik-&gt;is_value()) {</span>
<span class="line-added">5000         Thread *THREAD = Thread::current();</span>
<span class="line-added">5001         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
<span class="line-added">5002         return;</span>
<span class="line-added">5003       }</span>
5004       ik-&gt;set_is_cloneable();
5005     }
5006   }
5007 
5008   // Check if this klass has a vanilla default constructor
5009   if (super == NULL) {
5010     // java.lang.Object has empty default constructor
5011     ik-&gt;set_has_vanilla_constructor();
5012   } else {
5013     if (super-&gt;has_vanilla_constructor() &amp;&amp;
5014         _has_vanilla_constructor) {
5015       ik-&gt;set_has_vanilla_constructor();
5016     }
5017 #ifdef ASSERT
5018     bool v = false;
5019     if (super-&gt;has_vanilla_constructor()) {
5020       const Method* const constructor =
5021         ik-&gt;find_method(vmSymbols::object_initializer_name(),
5022                        vmSymbols::void_method_signature());
5023       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
5024         v = true;
5025       }
5026     }
5027     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
5028 #endif
5029   }
5030 
5031   // If it cannot be fast-path allocated, set a bit in the layout helper.
5032   // See documentation of InstanceKlass::can_be_fastpath_allocated().
5033   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
5034   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
5035       || ik-&gt;is_abstract() || ik-&gt;is_interface()
5036       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
5037       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
5038     // Forbid fast-path allocation.
5039     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
5040     ik-&gt;set_layout_helper(lh);
5041   }
5042 }
5043 
<span class="line-added">5044 bool ClassFileParser::supports_inline_types() const {</span>
<span class="line-added">5045   // Inline types are only supported by class file version 55 and later</span>
<span class="line-added">5046   return _major_version &gt;= JAVA_11_VERSION;</span>
<span class="line-added">5047 }</span>
<span class="line-added">5048 </span>
5049 // utility methods for appending an array with check for duplicates
5050 
5051 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
5052                               const Array&lt;InstanceKlass*&gt;* const ifs) {
5053   // iterate over new interfaces
5054   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
5055     InstanceKlass* const e = ifs-&gt;at(i);
5056     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
5057     // add new interface
5058     result-&gt;append_if_missing(e);
5059   }
5060 }
5061 
5062 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
5063                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
5064                                                             ClassLoaderData* loader_data,
5065                                                             TRAPS) {
5066   assert(local_ifs != NULL, &quot;invariant&quot;);
5067   assert(loader_data != NULL, &quot;invariant&quot;);
5068 
</pre>
<hr />
<pre>
5072   // Add superclass transitive interfaces size
5073   if (super != NULL) {
5074     super_size = super-&gt;transitive_interfaces()-&gt;length();
5075     max_transitive_size += super_size;
5076   }
5077   // Add local interfaces&#39; super interfaces
5078   const int local_size = local_ifs-&gt;length();
5079   for (int i = 0; i &lt; local_size; i++) {
5080     InstanceKlass* const l = local_ifs-&gt;at(i);
5081     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5082   }
5083   // Finally add local interfaces
5084   max_transitive_size += local_size;
5085   // Construct array
5086   if (max_transitive_size == 0) {
5087     // no interfaces, use canonicalized array
5088     return Universe::the_empty_instance_klass_array();
5089   } else if (max_transitive_size == super_size) {
5090     // no new local interfaces added, share superklass&#39; transitive interface array
5091     return super-&gt;transitive_interfaces();
<span class="line-modified">5092     // The three lines below are commented to work around bug JDK-8245487</span>
<span class="line-modified">5093 //  } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">5094 //    // only local interfaces added, share local interface array</span>
<span class="line-added">5095 //    return local_ifs;</span>
5096   } else {
5097     ResourceMark rm;
5098     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5099 
5100     // Copy down from superclass
5101     if (super != NULL) {
5102       append_interfaces(result, super-&gt;transitive_interfaces());
5103     }
5104 
5105     // Copy down from local interfaces&#39; superinterfaces
5106     for (int i = 0; i &lt; local_size; i++) {
5107       InstanceKlass* const l = local_ifs-&gt;at(i);
5108       append_interfaces(result, l-&gt;transitive_interfaces());
5109     }
5110     // Finally add local interfaces
5111     append_interfaces(result, local_ifs);
5112 
5113     // length will be less than the max_transitive_size if duplicates were removed
5114     const int length = result-&gt;length();
5115     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
<span class="line-added">5116 </span>
<span class="line-added">5117     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">5118       return Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">5119     }</span>
<span class="line-added">5120 </span>
5121     Array&lt;InstanceKlass*&gt;* const new_result =
5122       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5123     for (int i = 0; i &lt; length; i++) {
5124       InstanceKlass* const e = result-&gt;at(i);
5125       assert(e != NULL, &quot;just checking&quot;);
5126       new_result-&gt;at_put(i, e);
5127     }
5128     return new_result;
5129   }
5130 }
5131 
5132 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5133   assert(this_klass != NULL, &quot;invariant&quot;);
5134   const Klass* const super = this_klass-&gt;super();
5135 
5136   if (super != NULL) {
5137     const InstanceKlass* super_ik = InstanceKlass::cast(super);
5138 
5139     if (super-&gt;is_final()) {
5140       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
5333     const Method* const m = methods-&gt;at(index);
5334     // if m is static and not the init method, throw a verify error
5335     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5336       ResourceMark rm(THREAD);
5337       Exceptions::fthrow(
5338         THREAD_AND_LOCATION,
5339         vmSymbols::java_lang_VerifyError(),
5340         &quot;Illegal static method %s in interface %s&quot;,
5341         m-&gt;name()-&gt;as_C_string(),
5342         this_klass-&gt;external_name()
5343       );
5344       return;
5345     }
5346   }
5347 }
5348 
5349 // utility methods for format checking
5350 
5351 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5352   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-added">5353   const bool is_inline_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
5354   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-added">5355   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
5356   if (is_module) {
5357     ResourceMark rm(THREAD);
5358     Exceptions::fthrow(
5359       THREAD_AND_LOCATION,
5360       vmSymbols::java_lang_NoClassDefFoundError(),
5361       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5362       _class_name-&gt;as_C_string());
5363     return;
5364   }
5365 
<span class="line-added">5366   if (is_inline_type &amp;&amp; !EnableValhalla) {</span>
<span class="line-added">5367     ResourceMark rm(THREAD);</span>
<span class="line-added">5368     Exceptions::fthrow(</span>
<span class="line-added">5369       THREAD_AND_LOCATION,</span>
<span class="line-added">5370       vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">5371       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,</span>
<span class="line-added">5372       _class_name-&gt;as_C_string()</span>
<span class="line-added">5373     );</span>
<span class="line-added">5374   }</span>
<span class="line-added">5375 </span>
5376   if (!_need_verify) { return; }
5377 
5378   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5379   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5380   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5381   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5382   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5383   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5384   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5385   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5386 
5387   if ((is_abstract &amp;&amp; is_final) ||
5388       (is_interface &amp;&amp; !is_abstract) ||
5389       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">5390       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||</span>
<span class="line-added">5391       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
5392     ResourceMark rm(THREAD);
<span class="line-added">5393     const char* class_note = &quot;&quot;;</span>
<span class="line-added">5394     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;</span>
5395     Exceptions::fthrow(
5396       THREAD_AND_LOCATION,
5397       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5398       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,</span>
<span class="line-modified">5399       _class_name-&gt;as_C_string(), class_note, flags</span>
5400     );
5401     return;
5402   }
5403 }
5404 
5405 static bool has_illegal_visibility(jint flags) {
5406   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5407   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5408   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5409 
5410   return ((is_public &amp;&amp; is_protected) ||
5411           (is_public &amp;&amp; is_private) ||
5412           (is_protected &amp;&amp; is_private));
5413 }
5414 
5415 // A legal major_version.minor_version must be one of the following:
5416 //
5417 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5418 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5419 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
5458     if (!Arguments::enable_preview()) {
5459       Exceptions::fthrow(
5460         THREAD_AND_LOCATION,
5461         vmSymbols::java_lang_UnsupportedClassVersionError(),
5462         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5463         class_name-&gt;as_C_string(), major, minor);
5464       return;
5465     }
5466 
5467   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5468     Exceptions::fthrow(
5469         THREAD_AND_LOCATION,
5470         vmSymbols::java_lang_UnsupportedClassVersionError(),
5471         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5472         class_name-&gt;as_C_string(), major, minor);
5473   }
5474 }
5475 
5476 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5477                                                    bool is_interface,
<span class="line-added">5478                                                    bool is_inline_type,</span>
5479                                                    TRAPS) const {
5480   if (!_need_verify) { return; }
5481 
5482   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5483   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5484   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5485   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5486   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5487   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5488   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5489   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5490   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5491 
5492   bool is_illegal = false;
5493 
5494   if (is_interface) {
5495     if (!is_public || !is_static || !is_final || is_private ||
5496         is_protected || is_volatile || is_transient ||
5497         (major_gte_1_5 &amp;&amp; is_enum)) {
5498       is_illegal = true;
5499     }
5500   } else { // not interface
5501     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5502       is_illegal = true;
<span class="line-added">5503     } else {</span>
<span class="line-added">5504       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
<span class="line-added">5505         is_illegal = true;</span>
<span class="line-added">5506       }</span>
5507     }
5508   }
5509 
5510   if (is_illegal) {
5511     ResourceMark rm(THREAD);
5512     Exceptions::fthrow(
5513       THREAD_AND_LOCATION,
5514       vmSymbols::java_lang_ClassFormatError(),
5515       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5516       _class_name-&gt;as_C_string(), flags);
5517     return;
5518   }
5519 }
5520 
5521 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5522                                                     bool is_interface,
<span class="line-added">5523                                                     bool is_inline_type,</span>
5524                                                     const Symbol* name,
5525                                                     TRAPS) const {
5526   if (!_need_verify) { return; }
5527 
5528   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5529   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5530   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5531   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5532   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5533   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5534   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5535   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5536   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5537   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5538   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5539   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5540   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5541 
5542   bool is_illegal = false;
5543 
<span class="line-added">5544   const char* class_note = &quot;&quot;;</span>
<span class="line-added">5545 </span>
5546   if (is_interface) {
5547     if (major_gte_8) {
5548       // Class file version is JAVA_8_VERSION or later Methods of
5549       // interfaces may set any of the flags except ACC_PROTECTED,
5550       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5551       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5552       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5553           (is_native || is_protected || is_final || is_synchronized) ||
5554           // If a specific method of a class or interface has its
5555           // ACC_ABSTRACT flag set, it must not have any of its
5556           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5557           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5558           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5559           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5560           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5561         is_illegal = true;
5562       }
5563     } else if (major_gte_1_5) {
5564       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5565       if (!is_public || is_private || is_protected || is_static || is_final ||
5566           is_synchronized || is_native || !is_abstract || is_strict) {
5567         is_illegal = true;
5568       }
5569     } else {
5570       // Class file version is pre-JAVA_1_5_VERSION
5571       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5572         is_illegal = true;
5573       }
5574     }
5575   } else { // not interface
5576     if (has_illegal_visibility(flags)) {
5577       is_illegal = true;
5578     } else {
5579       if (is_initializer) {
<span class="line-modified">5580         if (is_final || is_synchronized || is_native ||</span>
5581             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5582           is_illegal = true;
5583         }
<span class="line-added">5584         if (!is_static &amp;&amp; !is_inline_type) {</span>
<span class="line-added">5585           // OK, an object constructor in a regular class</span>
<span class="line-added">5586         } else if (is_static &amp;&amp; is_inline_type) {</span>
<span class="line-added">5587           // OK, a static init factory in an inline class</span>
<span class="line-added">5588         } else {</span>
<span class="line-added">5589           // but no other combinations are allowed</span>
<span class="line-added">5590           is_illegal = true;</span>
<span class="line-added">5591           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
<span class="line-added">5592         }</span>
5593       } else { // not initializer
<span class="line-modified">5594         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
<span class="line-modified">5595           is_illegal = true;</span>
<span class="line-modified">5596           class_note = &quot; (an inline class)&quot;;</span>
<span class="line-modified">5597         } else {</span>
<span class="line-added">5598           if (is_abstract) {</span>
<span class="line-added">5599             if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-added">5600                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-added">5601               is_illegal = true;</span>
<span class="line-added">5602             }</span>
5603           }
5604         }
5605       }
5606     }
5607   }
5608 
5609   if (is_illegal) {
5610     ResourceMark rm(THREAD);
5611     Exceptions::fthrow(
5612       THREAD_AND_LOCATION,
5613       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5614       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5615       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);</span>
5616     return;
5617   }
5618 }
5619 
5620 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5621                                         int length,
5622                                         TRAPS) const {
5623   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5624   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5625     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5626   }
5627 }
5628 
5629 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5630 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5631 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5632 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5633 // method.  Because these names have been checked as special cases before
5634 // calling this method in verify_legal_method_name.
5635 //
</pre>
<hr />
<pre>
5753 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5754 // Return a pointer to just past the signature.
5755 // Return NULL if no legal signature is found.
5756 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5757                                                        bool void_ok,
5758                                                        unsigned int length,
5759                                                        TRAPS) const {
5760   unsigned int array_dim = 0;
5761   while (length &gt; 0) {
5762     switch (signature[0]) {
5763     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5764     case JVM_SIGNATURE_BOOLEAN:
5765     case JVM_SIGNATURE_BYTE:
5766     case JVM_SIGNATURE_CHAR:
5767     case JVM_SIGNATURE_SHORT:
5768     case JVM_SIGNATURE_INT:
5769     case JVM_SIGNATURE_FLOAT:
5770     case JVM_SIGNATURE_LONG:
5771     case JVM_SIGNATURE_DOUBLE:
5772       return signature + 1;
<span class="line-modified">5773     case JVM_SIGNATURE_INLINE_TYPE:</span>
<span class="line-added">5774       // Can&#39;t enable this check until JDK upgrades the bytecode generators</span>
<span class="line-added">5775       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {</span>
<span class="line-added">5776       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;</span>
<span class="line-added">5777       //                                    &quot;in descriptor in class file %s&quot;,</span>
<span class="line-added">5778       //                                    CHECK_0);</span>
<span class="line-added">5779       // }</span>
<span class="line-added">5780       // fall through</span>
<span class="line-added">5781     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added">5782     {</span>
5783       if (_major_version &lt; JAVA_1_5_VERSION) {
5784         // Skip over the class name if one is there
5785         const char* const p = skip_over_field_name(signature + 1, true, --length);
5786 
5787         // The next character better be a semicolon
5788         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5789           return p + 1;
5790         }
5791       }
5792       else {
<span class="line-modified">5793         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;</span>
5794         signature++;
5795         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5796         // Format check signature
5797         if (c != NULL) {
5798           int newlen = c - (char*) signature;
5799           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5800           if (!legal) {
5801             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5802                                   &quot;in descriptor in class file %s&quot;,
5803                                   CHECK_NULL);
5804             return NULL;
5805           }
5806           return signature + newlen + 1;
5807         }
5808       }
5809       return NULL;
5810     }
5811     case JVM_SIGNATURE_ARRAY:
5812       array_dim++;
5813       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5828 
5829 // Checks if name is a legal class name.
5830 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5831   if (!_need_verify || _relax_verify) { return; }
5832 
5833   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5834   char* bytes = (char*)name-&gt;bytes();
5835   unsigned int length = name-&gt;utf8_length();
5836   bool legal = false;
5837 
5838   if (length &gt; 0) {
5839     const char* p;
5840     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5841       p = skip_over_field_signature(bytes, false, length, CHECK);
5842       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5843     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5844       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5845         p = skip_over_field_name(bytes, true, length);
5846         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5847       }
<span class="line-added">5848     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {</span>
<span class="line-added">5849       // Support for L...; and Q...; descriptors</span>
<span class="line-added">5850       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);</span>
5851     } else {
5852       // 4900761: relax the constraints based on JSR202 spec
5853       // Class names may be drawn from the entire Unicode character set.
5854       // Identifiers between &#39;/&#39; must be unqualified names.
5855       // The utf8 string has been verified when parsing cpool entries.
5856       legal = verify_unqualified_name(bytes, length, LegalClass);
5857     }
5858   }
5859   if (!legal) {
5860     ResourceMark rm(THREAD);
5861     assert(_class_name != NULL, &quot;invariant&quot;);
5862     Exceptions::fthrow(
5863       THREAD_AND_LOCATION,
5864       vmSymbols::java_lang_ClassFormatError(),
5865       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5866       _class_name-&gt;as_C_string()
5867     );
5868     return;
5869   }
5870 }
</pre>
<hr />
<pre>
5980   const char* nextp;
5981 
5982   // The first character must be a &#39;(&#39;
5983   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5984     length--;
5985     // Skip over legal field signatures
5986     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5987     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5988       args_size++;
5989       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5990         args_size++;
5991       }
5992       length -= nextp - p;
5993       p = nextp;
5994       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5995     }
5996     // The first non-signature thing better be a &#39;)&#39;
5997     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5998       length--;
5999       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">6000         // All constructor methods must return void</span>
6001         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
6002           return args_size;
6003         }
<span class="line-added">6004         // All static init methods must return the current class</span>
<span class="line-added">6005         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)</span>
<span class="line-added">6006             &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">6007           nextp = skip_over_field_signature(p, true, length, CHECK_0);</span>
<span class="line-added">6008           if (nextp &amp;&amp; ((int)length == (nextp - p))) {</span>
<span class="line-added">6009             // The actual class will be checked against current class</span>
<span class="line-added">6010             // when the method is defined (see parse_method).</span>
<span class="line-added">6011             // A reference to a static init with a bad return type</span>
<span class="line-added">6012             // will load and verify OK, but will fail to link.</span>
<span class="line-added">6013             return args_size;</span>
<span class="line-added">6014           }</span>
<span class="line-added">6015         }</span>
<span class="line-added">6016         // The distinction between static factory methods and</span>
<span class="line-added">6017         // constructors depends on the JVM_ACC_STATIC modifier.</span>
<span class="line-added">6018         // This distinction must be reflected in a void or non-void</span>
<span class="line-added">6019         // return. For declared methods, the check is in parse_method.</span>
6020       } else {
6021         // Now we better just have a return value
6022         nextp = skip_over_field_signature(p, true, length, CHECK_0);
6023         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
6024           return args_size;
6025         }
6026       }
6027     }
6028   }
6029   // Report error
6030   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
6031   return 0;
6032 }
6033 
6034 int ClassFileParser::static_field_size() const {
6035   assert(_field_info != NULL, &quot;invariant&quot;);
6036   return _field_info-&gt;_static_field_size;
6037 }
6038 
6039 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
6157 
6158 
6159   if (ik-&gt;should_store_fingerprint()) {
6160     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6161   }
6162 
6163   ik-&gt;set_has_passed_fingerprint_check(false);
6164   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6165     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6166     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6167     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6168       // This class matches with a class saved in an AOT library
6169       ik-&gt;set_has_passed_fingerprint_check(true);
6170     } else {
6171       ResourceMark rm;
6172       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6173                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6174     }
6175   }
6176 
<span class="line-added">6177   if (ik-&gt;is_value()) {</span>
<span class="line-added">6178     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6179     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">6180     vk-&gt;set_default_value(val);</span>
<span class="line-added">6181   }</span>
<span class="line-added">6182 </span>
6183   return ik;
6184 }
6185 
<span class="line-added">6186 // Return true if the specified class is not a valid super class for an inline type.</span>
<span class="line-added">6187 // A valid super class for an inline type is abstract, has no instance fields,</span>
<span class="line-added">6188 // does not implement interface java.lang.IdentityObject (checked elsewhere), has</span>
<span class="line-added">6189 // an empty body-less no-arg constructor, and no synchronized instance methods.</span>
<span class="line-added">6190 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks</span>
<span class="line-added">6191 // are done elsewhere.  The final determination of whether or not a class is an</span>
<span class="line-added">6192 // invalid super type for an inline class is done in fill_instance_klass().</span>
<span class="line-added">6193 bool ClassFileParser::is_invalid_super_for_inline_type() {</span>
<span class="line-added">6194   if (class_name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6195     return true;</span>
<span class="line-added">6196   }</span>
<span class="line-added">6197   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {</span>
<span class="line-added">6198     return false;</span>
<span class="line-added">6199   }</span>
<span class="line-added">6200   if (!access_flags().is_abstract() || _has_nonstatic_fields) {</span>
<span class="line-added">6201     return true;</span>
<span class="line-added">6202   } else {</span>
<span class="line-added">6203     // Look at each method</span>
<span class="line-added">6204     for (int x = 0; x &lt; _methods-&gt;length(); x++) {</span>
<span class="line-added">6205       const Method* const method = _methods-&gt;at(x);</span>
<span class="line-added">6206       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {</span>
<span class="line-added">6207         return true;</span>
<span class="line-added">6208 </span>
<span class="line-added">6209       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">6210         if (method-&gt;signature() != vmSymbols::void_method_signature() ||</span>
<span class="line-added">6211             !method-&gt;is_vanilla_constructor()) {</span>
<span class="line-added">6212           return true;</span>
<span class="line-added">6213         }</span>
<span class="line-added">6214       }</span>
<span class="line-added">6215     }</span>
<span class="line-added">6216   }</span>
<span class="line-added">6217   return false;</span>
<span class="line-added">6218 }</span>
<span class="line-added">6219 </span>
6220 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
6221                                           bool changed_by_loadhook,
6222                                           const ClassInstanceInfo&amp; cl_inst_info,
6223                                           TRAPS) {
6224   assert(ik != NULL, &quot;invariant&quot;);
6225 
6226   // Set name and CLD before adding to CLD
6227   ik-&gt;set_class_loader_data(_loader_data);
6228   ik-&gt;set_name(_class_name);
6229 
6230   // Add all classes to our internal class loader list here,
6231   // including classes in the bootstrap (NULL) class loader.
6232   const bool publicize = !is_internal();
6233 
6234   _loader_data-&gt;add_class(ik, publicize);
6235 
6236   set_klass_to_deallocate(ik);
6237 
6238   assert(_field_info != NULL, &quot;invariant&quot;);
6239   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6240   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6241          &quot;sanity&quot;);
6242 
6243   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6244   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6245 
6246   // Fill in information already parsed
6247   ik-&gt;set_should_verify_class(_need_verify);
6248 
6249   // Not yet: supers are done below to support the new subtype-checking fields
6250   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6251   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<span class="line-added">6252   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {</span>
<span class="line-added">6253     ik-&gt;set_is_naturally_atomic();</span>
<span class="line-added">6254   }</span>
<span class="line-added">6255   if (_is_empty_inline_type) {</span>
<span class="line-added">6256     ik-&gt;set_is_empty_inline_type();</span>
<span class="line-added">6257   }</span>
<span class="line-added">6258 </span>
<span class="line-added">6259   if (this-&gt;_invalid_inline_super) {</span>
<span class="line-added">6260     ik-&gt;set_invalid_inline_super();</span>
<span class="line-added">6261   }</span>
<span class="line-added">6262 </span>
<span class="line-added">6263   if (_has_injected_identityObject) {</span>
<span class="line-added">6264     ik-&gt;set_has_injected_identityObject();</span>
<span class="line-added">6265   }</span>
<span class="line-added">6266 </span>
6267   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">6268   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_INLINE]);</span>
6269 
6270   // this transfers ownership of a lot of arrays from
6271   // the parser onto the InstanceKlass*
6272   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6273 
6274   // can only set dynamic nest-host after static nest information is set
6275   if (cl_inst_info.dynamic_nest_host() != NULL) {
6276     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6277   }
6278 
6279   // note that is not safe to use the fields in the parser from this point on
6280   assert(NULL == _cp, &quot;invariant&quot;);
6281   assert(NULL == _fields, &quot;invariant&quot;);
6282   assert(NULL == _methods, &quot;invariant&quot;);
6283   assert(NULL == _inner_classes, &quot;invariant&quot;);
6284   assert(NULL == _nest_members, &quot;invariant&quot;);
6285   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6286   assert(NULL == _record_components, &quot;invariant&quot;);
6287   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
6288 
</pre>
<hr />
<pre>
6298   // has to be changed accordingly.
6299   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6300 
6301   ik-&gt;set_this_class_index(_this_class_index);
6302 
6303   if (_is_hidden || is_unsafe_anonymous()) {
6304     // _this_class_index is a CONSTANT_Class entry that refers to this
6305     // hidden or anonymous class itself. If this class needs to refer to its own
6306     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
6307     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
6308     // not stored in SystemDictionary), _this_class_index cannot be resolved
6309     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6310     // Therefore, we must eagerly resolve _this_class_index now.
6311     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6312   }
6313 
6314   ik-&gt;set_minor_version(_minor_version);
6315   ik-&gt;set_major_version(_major_version);
6316   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6317   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<span class="line-added">6318   if (_is_declared_atomic) {</span>
<span class="line-added">6319     ik-&gt;set_is_declared_atomic();</span>
<span class="line-added">6320   }</span>
6321 
6322   if (_unsafe_anonymous_host != NULL) {
6323     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6324     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6325   }
6326   if (_is_hidden) {
6327     ik-&gt;set_is_hidden();
6328   }
6329 
6330   // Set PackageEntry for this_klass
6331   oop cl = ik-&gt;class_loader();
6332   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6333   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6334   ik-&gt;set_package(cld, NULL, CHECK);
6335 
6336   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6337   assert(methods != NULL, &quot;invariant&quot;);
6338   const int methods_len = methods-&gt;length();
6339 
6340   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
6412 
6413   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6414 
6415   // Generate any default methods - default methods are public interface methods
6416   // that have a default implementation.  This is new with Java 8.
6417   if (_has_nonstatic_concrete_methods) {
6418     DefaultMethods::generate_default_methods(ik,
6419                                              _all_mirandas,
6420                                              CHECK);
6421   }
6422 
6423   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6424   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6425       !module_entry-&gt;has_default_read_edges()) {
6426     if (!module_entry-&gt;set_has_default_read_edges()) {
6427       // We won a potential race
6428       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6429     }
6430   }
6431 
<span class="line-added">6432   int nfields = ik-&gt;java_fields_count();</span>
<span class="line-added">6433   if (ik-&gt;is_value()) nfields++;</span>
<span class="line-added">6434   for (int i = 0; i &lt; nfields; i++) {</span>
<span class="line-added">6435     if (ik-&gt;field_is_inline_type(i)) {</span>
<span class="line-added">6436       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);</span>
<span class="line-added">6437       // Inline classes for instance fields must have been pre-loaded</span>
<span class="line-added">6438       // Inline classes for static fields might not have been loaded yet</span>
<span class="line-added">6439       Klass* klass = SystemDictionary::find(klass_name,</span>
<span class="line-added">6440           Handle(THREAD, ik-&gt;class_loader()),</span>
<span class="line-added">6441           Handle(THREAD, ik-&gt;protection_domain()), CHECK);</span>
<span class="line-added">6442       if (klass != NULL) {</span>
<span class="line-added">6443         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">6444         ik-&gt;set_value_field_klass(i, klass);</span>
<span class="line-added">6445       }</span>
<span class="line-added">6446       klass_name-&gt;decrement_refcount();</span>
<span class="line-added">6447     } else</span>
<span class="line-added">6448       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
<span class="line-added">6449         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {</span>
<span class="line-added">6450       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));</span>
<span class="line-added">6451     }</span>
<span class="line-added">6452   }</span>
<span class="line-added">6453 </span>
<span class="line-added">6454   if (is_inline_type()) {</span>
<span class="line-added">6455     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6456     if (UseNewFieldLayout) {</span>
<span class="line-added">6457       vk-&gt;set_alignment(_alignment);</span>
<span class="line-added">6458       vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="line-added">6459       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
<span class="line-added">6460     } else {</span>
<span class="line-added">6461       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());</span>
<span class="line-added">6462     }</span>
<span class="line-added">6463     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">6464   }</span>
<span class="line-added">6465 </span>
6466   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6467 
6468   if (!is_internal()) {
6469     if (log_is_enabled(Info, class, load)) {
6470       ResourceMark rm;
6471       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6472       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6473     }
6474 
6475     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
6476         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
6477         log_is_enabled(Info, class, preview)) {
6478       ResourceMark rm;
6479       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
6480                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
6481     }
6482 
6483     if (log_is_enabled(Debug, class, resolve))  {
6484       ResourceMark rm;
6485       // print out the superclass.
</pre>
<hr />
<pre>
6495         const int length = local_interfaces-&gt;length();
6496         for (int i = 0; i &lt; length; i++) {
6497           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6498           const char * to = k-&gt;external_name();
6499           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6500         }
6501       }
6502     }
6503   }
6504 
6505   JFR_ONLY(INIT_ID(ik);)
6506 
6507   // If we reach here, all is well.
6508   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6509   // in order for it to not be destroyed in the ClassFileParser destructor.
6510   set_klass_to_deallocate(NULL);
6511 
6512   // it&#39;s official
6513   set_klass(ik);
6514 
<span class="line-added">6515   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6516     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);</span>
<span class="line-added">6517   }</span>
<span class="line-added">6518 </span>
6519   debug_only(ik-&gt;verify();)
6520 }
6521 
6522 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6523   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6524   _class_name-&gt;decrement_refcount();
6525 
6526   _class_name = new_class_name;
6527   // Increment the refcount of the new name.
6528   // Now the ClassFileParser owns this name and will decrement in
6529   // the destructor.
6530   _class_name-&gt;increment_refcount();
6531 }
6532 
6533 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6534 // package by prepending its host class&#39;s package name to its class name and setting
6535 // its _class_name field.
6536 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6537   ResourceMark rm(THREAD);
6538   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
6601   _stream(stream),
6602   _class_name(NULL),
6603   _loader_data(loader_data),
6604   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6605   _cp_patches(cl_info-&gt;cp_patches()),
6606   _is_hidden(cl_info-&gt;is_hidden()),
6607   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6608   _num_patched_klasses(0),
6609   _max_num_patched_klasses(0),
6610   _orig_cp_size(0),
6611   _first_patched_klass_resolved_index(0),
6612   _super_klass(),
6613   _cp(NULL),
6614   _fields(NULL),
6615   _methods(NULL),
6616   _inner_classes(NULL),
6617   _nest_members(NULL),
6618   _nest_host(0),
6619   _permitted_subclasses(NULL),
6620   _record_components(NULL),
<span class="line-added">6621   _temp_local_interfaces(NULL),</span>
6622   _local_interfaces(NULL),
6623   _transitive_interfaces(NULL),
6624   _combined_annotations(NULL),
6625   _class_annotations(NULL),
6626   _class_type_annotations(NULL),
6627   _fields_annotations(NULL),
6628   _fields_type_annotations(NULL),
6629   _klass(NULL),
6630   _klass_to_deallocate(NULL),
6631   _parsed_annotations(NULL),
6632   _fac(NULL),
6633   _field_info(NULL),
6634   _method_ordering(NULL),
6635   _all_mirandas(NULL),
6636   _vtable_size(0),
6637   _itable_size(0),
6638   _num_miranda_methods(0),
6639   _rt(REF_NONE),
6640   _protection_domain(cl_info-&gt;protection_domain()),
6641   _access_flags(),
6642   _pub_level(pub_level),
6643   _bad_constant_seen(0),
6644   _synthetic_flag(false),
6645   _sde_length(false),
6646   _sde_buffer(NULL),
6647   _sourcefile_index(0),
6648   _generic_signature_index(0),
6649   _major_version(0),
6650   _minor_version(0),
6651   _this_class_index(0),
6652   _super_class_index(0),
6653   _itfs_len(0),
6654   _java_fields_count(0),
6655   _need_verify(false),
6656   _relax_verify(false),
6657   _has_nonstatic_concrete_methods(false),
6658   _declares_nonstatic_concrete_methods(false),
6659   _has_final_method(false),
6660   _has_contended_fields(false),
<span class="line-added">6661   _has_inline_type_fields(false),</span>
<span class="line-added">6662   _has_nonstatic_fields(false),</span>
<span class="line-added">6663   _is_empty_inline_type(false),</span>
<span class="line-added">6664   _is_naturally_atomic(false),</span>
<span class="line-added">6665   _is_declared_atomic(false),</span>
<span class="line-added">6666   _invalid_inline_super(false),</span>
<span class="line-added">6667   _invalid_identity_super(false),</span>
<span class="line-added">6668   _implements_identityObject(false),</span>
<span class="line-added">6669   _has_injected_identityObject(false),</span>
6670   _has_finalizer(false),
6671   _has_empty_finalizer(false),
6672   _has_vanilla_constructor(false),
6673   _max_bootstrap_specifier_index(-1) {
6674 
6675   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6676   _class_name-&gt;increment_refcount();
6677 
6678   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6679   assert(_loader_data != NULL, &quot;invariant&quot;);
6680   assert(stream != NULL, &quot;invariant&quot;);
6681   assert(_stream != NULL, &quot;invariant&quot;);
6682   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6683   assert(_class_name != NULL, &quot;invariant&quot;);
6684   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6685 
6686   // Figure out whether we can skip format checking (matching classic VM behavior)
6687   if (DumpSharedSpaces) {
6688     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6689     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6860   } else {
6861     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6862       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6863     }
6864     cp_size += _max_num_patched_klasses;
6865   }
6866 
6867   _cp = ConstantPool::allocate(_loader_data,
6868                                cp_size,
6869                                CHECK);
6870 
6871   ConstantPool* const cp = _cp;
6872 
6873   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6874 
6875   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6876 
6877   // ACCESS FLAGS
6878   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6879 
<span class="line-modified">6880   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;</span>

6881   // JVM_ACC_MODULE is defined in JDK-9 and later.
6882   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6883     recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">6884   }</span>
<span class="line-modified">6885   // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">6886   if (supports_inline_types()) {</span>
<span class="line-added">6887     recognized_modifiers |= JVM_ACC_VALUE;</span>
6888   }
6889 
<span class="line-added">6890   // Access flags</span>
<span class="line-added">6891   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">6892 </span>
6893   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6894     // Set abstract bit for old class files for backward compatibility
6895     flags |= JVM_ACC_ABSTRACT;
6896   }
6897 
6898   verify_legal_class_modifiers(flags, CHECK);
6899 
6900   short bad_constant = class_bad_constant_seen();
6901   if (bad_constant != 0) {
6902     // Do not throw CFE until after the access_flags are checked because if
6903     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6904     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6905   }
6906 
6907   _access_flags.set_flags(flags);
6908 
6909   // This class and superclass
6910   _this_class_index = stream-&gt;get_u2_fast();
6911   check_property(
6912     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
7030           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
7031           classlist_file-&gt;flush();
7032         }
7033       }
7034     }
7035 #endif
7036   }
7037 
7038   // SUPERKLASS
7039   _super_class_index = stream-&gt;get_u2_fast();
7040   _super_klass = parse_super_class(cp,
7041                                    _super_class_index,
7042                                    _need_verify,
7043                                    CHECK);
7044 
7045   // Interfaces
7046   _itfs_len = stream-&gt;get_u2_fast();
7047   parse_interfaces(stream,
7048                    _itfs_len,
7049                    cp,
<span class="line-added">7050                    is_inline_type(),</span>
7051                    &amp;_has_nonstatic_concrete_methods,
<span class="line-added">7052                    &amp;_is_declared_atomic,</span>
7053                    CHECK);
7054 
<span class="line-modified">7055   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);</span>
7056 
7057   // Fields (offsets are filled in later)
7058   _fac = new FieldAllocationCount();
7059   parse_fields(stream,
<span class="line-modified">7060                is_interface(),</span>
<span class="line-added">7061                is_inline_type(),</span>
7062                _fac,
7063                cp,
7064                cp_size,
7065                &amp;_java_fields_count,
7066                CHECK);
7067 
7068   assert(_fields != NULL, &quot;invariant&quot;);
7069 
7070   // Methods
7071   AccessFlags promoted_flags;
7072   parse_methods(stream,
<span class="line-modified">7073                 is_interface(),</span>
<span class="line-added">7074                 is_inline_type(),</span>
7075                 &amp;promoted_flags,
7076                 &amp;_has_final_method,
7077                 &amp;_declares_nonstatic_concrete_methods,
7078                 CHECK);
7079 
7080   assert(_methods != NULL, &quot;invariant&quot;);
7081 
7082   // promote flags from parse_methods() to the klass&#39; flags
7083   _access_flags.add_promoted_flags(promoted_flags.as_int());
7084 
7085   if (_declares_nonstatic_concrete_methods) {
7086     _has_nonstatic_concrete_methods = true;
7087   }
7088 
7089   // Additional attributes/annotations
7090   _parsed_annotations = new ClassAnnotationCollector();
7091   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
7092 
7093   assert(_inner_classes != NULL, &quot;invariant&quot;);
7094 
</pre>
<hr />
<pre>
7125 
7126   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
7127   // We have to update the resolved_klass_index and the name_index together
7128   // so extract the existing resolved_klass_index first.
7129   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
7130   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
7131   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
7132   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
7133          &quot;Bad name_index&quot;);
7134 }
7135 
7136 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
7137                                                  ConstantPool* cp,
7138                                                  TRAPS) {
7139   assert(stream != NULL, &quot;invariant&quot;);
7140   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
7141   assert(cp != NULL, &quot;invariant&quot;);
7142   assert(_loader_data != NULL, &quot;invariant&quot;);
7143 
7144   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">7145     check_property(_temp_local_interfaces-&gt;length() == 0,</span>
<span class="line-modified">7146         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">7147         CHECK);</span>
7148   }
7149   // We check super class after class file is parsed and format is checked
7150   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
7151     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">7152     if (is_interface()) {</span>
7153       // Before attempting to resolve the superclass, check for class format
7154       // errors not checked yet.
7155       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
7156         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
7157         CHECK);
7158     }
7159     Handle loader(THREAD, _loader_data-&gt;class_loader());
7160     _super_klass = (const InstanceKlass*)
7161                        SystemDictionary::resolve_super_or_fail(_class_name,
7162                                                                super_class_name,
7163                                                                loader,
7164                                                                _protection_domain,
7165                                                                true,
7166                                                                CHECK);
7167   }
7168 
7169   if (_super_klass != NULL) {
7170     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
7171       _has_nonstatic_concrete_methods = true;
7172     }
<span class="line-added">7173     if (_super_klass-&gt;is_declared_atomic()) {</span>
<span class="line-added">7174       _is_declared_atomic = true;</span>
<span class="line-added">7175     }</span>
7176 
7177     if (_super_klass-&gt;is_interface()) {
7178       ResourceMark rm(THREAD);
7179       Exceptions::fthrow(
7180         THREAD_AND_LOCATION,
7181         vmSymbols::java_lang_IncompatibleClassChangeError(),
7182         &quot;class %s has interface %s as super class&quot;,
7183         _class_name-&gt;as_klass_external_name(),
7184         _super_klass-&gt;external_name()
7185       );
7186       return;
7187     }
<span class="line-added">7188 </span>
<span class="line-added">7189     // For an inline class, only java/lang/Object or special abstract classes</span>
<span class="line-added">7190     // are acceptable super classes.</span>
<span class="line-added">7191     if (is_inline_type()) {</span>
<span class="line-added">7192       const InstanceKlass* super_ik = _super_klass;</span>
<span class="line-added">7193       if (super_ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">7194         ResourceMark rm(THREAD);</span>
<span class="line-added">7195         Exceptions::fthrow(</span>
<span class="line-added">7196           THREAD_AND_LOCATION,</span>
<span class="line-added">7197           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">7198           &quot;inline class %s has an invalid super class %s&quot;,</span>
<span class="line-added">7199           _class_name-&gt;as_klass_external_name(),</span>
<span class="line-added">7200           _super_klass-&gt;external_name());</span>
<span class="line-added">7201         return;</span>
<span class="line-added">7202       }</span>
<span class="line-added">7203     }</span>
<span class="line-added">7204   }</span>
<span class="line-added">7205 </span>
<span class="line-added">7206   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {</span>
<span class="line-added">7207     // This is the original source of this condition.</span>
<span class="line-added">7208     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.</span>
<span class="line-added">7209     _is_declared_atomic = true;</span>
<span class="line-added">7210   } else if (*ForceNonTearable != &#39;\0&#39;) {</span>
<span class="line-added">7211     // Allow a command line switch to force the same atomicity property:</span>
<span class="line-added">7212     const char* class_name_str = _class_name-&gt;as_C_string();</span>
<span class="line-added">7213     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {</span>
<span class="line-added">7214       _is_declared_atomic = true;</span>
<span class="line-added">7215     }</span>
<span class="line-added">7216   }</span>
<span class="line-added">7217 </span>
<span class="line-added">7218   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-added">7219   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-added">7220   // returns true</span>
<span class="line-added">7221   if (invalid_inline_super() ||</span>
<span class="line-added">7222       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-added">7223       is_invalid_super_for_inline_type()) {</span>
<span class="line-added">7224     set_invalid_inline_super();</span>
7225   }
7226 
<span class="line-added">7227   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
<span class="line-added">7228       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">7229     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());</span>
<span class="line-added">7230     _has_injected_identityObject = true;</span>
<span class="line-added">7231   }</span>
<span class="line-added">7232   int itfs_len = _temp_local_interfaces-&gt;length();</span>
<span class="line-added">7233   if (itfs_len == 0) {</span>
<span class="line-added">7234     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
<span class="line-added">7235   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">7236     _local_interfaces = Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">7237   } else {</span>
<span class="line-added">7238     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-added">7239     for (int i = 0; i &lt; itfs_len; i++) {</span>
<span class="line-added">7240       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));</span>
<span class="line-added">7241     }</span>
<span class="line-added">7242   }</span>
<span class="line-added">7243   _temp_local_interfaces = NULL;</span>
<span class="line-added">7244   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
<span class="line-added">7245 </span>
7246   // Compute the transitive list of all unique interfaces implemented by this class
7247   _transitive_interfaces =
7248     compute_transitive_interfaces(_super_klass,
7249                                   _local_interfaces,
7250                                   _loader_data,
7251                                   CHECK);
7252 
7253   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7254 
7255   // sort methods
7256   _method_ordering = sort_methods(_methods);
7257 
7258   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7259 
7260   Handle loader(THREAD, _loader_data-&gt;class_loader());
7261   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7262                                                     &amp;_num_miranda_methods,
7263                                                     _all_mirandas,
7264                                                     _super_klass,
7265                                                     _methods,
7266                                                     _access_flags,
7267                                                     _major_version,
7268                                                     loader,
7269                                                     _class_name,
7270                                                     _local_interfaces,
7271                                                     CHECK);
7272 
7273   // Size of Java itable (in words)
<span class="line-modified">7274   _itable_size = is_interface() ? 0 :</span>
7275     klassItable::compute_itable_size(_transitive_interfaces);
7276 
7277   assert(_fac != NULL, &quot;invariant&quot;);
7278   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7279 
<span class="line-added">7280 </span>
<span class="line-added">7281   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-added">7282     if (Signature::basic_type(fs.signature()) == T_VALUETYPE  &amp;&amp; !fs.access_flags().is_static()) {</span>
<span class="line-added">7283       // Pre-load inline class</span>
<span class="line-added">7284       Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-added">7285           Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">7286           _protection_domain, true, CHECK);</span>
<span class="line-added">7287       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">7288       assert(klass-&gt;access_flags().is_inline_type(), &quot;Value type expected&quot;);</span>
<span class="line-added">7289     }</span>
<span class="line-added">7290   }</span>
<span class="line-added">7291 </span>
7292   _field_info = new FieldLayoutInfo();
7293   if (UseNewFieldLayout) {
7294     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">7295         _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="line-modified">7296         loader_data(), _protection_domain, _field_info);</span>
<span class="line-added">7297     lb.build_layout(CHECK);</span>
<span class="line-added">7298     if (is_inline_type()) {</span>
<span class="line-added">7299       _alignment = lb.get_alignment();</span>
<span class="line-added">7300       _first_field_offset = lb.get_first_field_offset();</span>
<span class="line-added">7301       _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
<span class="line-added">7302     }</span>
7303   } else {
7304     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7305   }
<span class="line-added">7306   _has_inline_type_fields = _field_info-&gt;_has_inline_fields;</span>
7307 
<span class="line-modified">7308   // Compute reference type</span>
7309   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();

7310 }
7311 
7312 void ClassFileParser::set_klass(InstanceKlass* klass) {
7313 
7314 #ifdef ASSERT
7315   if (klass != NULL) {
7316     assert(NULL == _klass, &quot;leaking?&quot;);
7317   }
7318 #endif
7319 
7320   _klass = klass;
7321 }
7322 
7323 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7324 
7325 #ifdef ASSERT
7326   if (klass != NULL) {
7327     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
7328   }
7329 #endif
7330 
7331   _klass_to_deallocate = klass;
7332 }
7333 
7334 // Caller responsible for ResourceMark
7335 // clone stream with rewound position
7336 const ClassFileStream* ClassFileParser::clone_stream() const {
7337   assert(_stream != NULL, &quot;invariant&quot;);
7338 
7339   return _stream-&gt;clone();
7340 }
<span class="line-added">7341 </span>
7342 // ----------------------------------------------------------------------------
7343 // debugging
7344 
7345 #ifdef ASSERT
7346 
7347 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
7348 bool ClassFileParser::is_internal_format(Symbol* class_name) {
7349   if (class_name != NULL) {
7350     ResourceMark rm;
7351     char* name = class_name-&gt;as_C_string();
7352     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
7353   } else {
7354     return true;
7355   }
7356 }
7357 
7358 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciEnv.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
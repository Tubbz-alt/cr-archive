<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/classLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;jimage.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/javaClasses.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  40 #include &quot;classfile/vmSymbols.hpp&quot;
  41 #include &quot;compiler/compileBroker.hpp&quot;
  42 #include &quot;interpreter/bytecodeStream.hpp&quot;
  43 #include &quot;interpreter/oopMapCache.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;logging/logStream.hpp&quot;
  46 #include &quot;logging/logTag.hpp&quot;
  47 #include &quot;memory/allocation.inline.hpp&quot;
  48 #include &quot;memory/filemap.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;memory/universe.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceRefKlass.hpp&quot;
  54 #include &quot;oops/method.inline.hpp&quot;
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
  57 #include &quot;oops/symbol.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;runtime/arguments.hpp&quot;
  60 #include &quot;runtime/handles.inline.hpp&quot;
  61 #include &quot;runtime/init.hpp&quot;
  62 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  63 #include &quot;runtime/java.hpp&quot;
  64 #include &quot;runtime/javaCalls.hpp&quot;
  65 #include &quot;runtime/os.inline.hpp&quot;
  66 #include &quot;runtime/threadCritical.hpp&quot;
  67 #include &quot;runtime/timer.hpp&quot;
  68 #include &quot;runtime/vm_version.hpp&quot;
  69 #include &quot;services/management.hpp&quot;
  70 #include &quot;services/threadService.hpp&quot;
  71 #include &quot;utilities/classpathStream.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;
  75 #include &quot;utilities/utf8.hpp&quot;
  76 
  77 // Entry point in java.dll for path canonicalization
  78 
  79 typedef int (*canonicalize_fn_t)(const char *orig, char *out, int len);
  80 
  81 static canonicalize_fn_t CanonicalizeEntry  = NULL;
  82 
  83 // Entry points in zip.dll for loading zip/jar file entries
  84 
  85 typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
  86 typedef void     (*ZipClose_t)(jzfile *zip);
  87 typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  88 typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  89 typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);
  90 typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  91 
  92 static ZipOpen_t         ZipOpen            = NULL;
  93 static ZipClose_t        ZipClose           = NULL;
  94 static FindEntry_t       FindEntry          = NULL;
  95 static ReadEntry_t       ReadEntry          = NULL;
  96 static GetNextEntry_t    GetNextEntry       = NULL;
  97 static Crc32_t           Crc32              = NULL;
  98 int ClassLoader::_libzip_loaded = 0;
  99 
 100 // Entry points for jimage.dll for loading jimage file entries
 101 
 102 static JImageOpen_t                    JImageOpen             = NULL;
 103 static JImageClose_t                   JImageClose            = NULL;
 104 static JImagePackageToModule_t         JImagePackageToModule  = NULL;
 105 static JImageFindResource_t            JImageFindResource     = NULL;
 106 static JImageGetResource_t             JImageGetResource      = NULL;
 107 static JImageResourceIterator_t        JImageResourceIterator = NULL;
 108 
 109 // Globals
 110 
 111 PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;
 112 PerfCounter*    ClassLoader::_perf_classes_inited = NULL;
 113 PerfCounter*    ClassLoader::_perf_class_init_time = NULL;
 114 PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;
 115 PerfCounter*    ClassLoader::_perf_classes_verified = NULL;
 116 PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;
 117 PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;
 118 PerfCounter*    ClassLoader::_perf_classes_linked = NULL;
 119 PerfCounter*    ClassLoader::_perf_class_link_time = NULL;
 120 PerfCounter*    ClassLoader::_perf_class_link_selftime = NULL;
 121 PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = NULL;
 122 PerfCounter*    ClassLoader::_perf_shared_classload_time = NULL;
 123 PerfCounter*    ClassLoader::_perf_sys_classload_time = NULL;
 124 PerfCounter*    ClassLoader::_perf_app_classload_time = NULL;
 125 PerfCounter*    ClassLoader::_perf_app_classload_selftime = NULL;
 126 PerfCounter*    ClassLoader::_perf_app_classload_count = NULL;
 127 PerfCounter*    ClassLoader::_perf_define_appclasses = NULL;
 128 PerfCounter*    ClassLoader::_perf_define_appclass_time = NULL;
 129 PerfCounter*    ClassLoader::_perf_define_appclass_selftime = NULL;
 130 PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = NULL;
 131 PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = NULL;
 132 PerfCounter*    ClassLoader::_sync_systemLoaderLockContentionRate = NULL;
 133 PerfCounter*    ClassLoader::_sync_nonSystemLoaderLockContentionRate = NULL;
 134 PerfCounter*    ClassLoader::_sync_JVMFindLoadedClassLockFreeCounter = NULL;
 135 PerfCounter*    ClassLoader::_sync_JVMDefineClassLockFreeCounter = NULL;
 136 PerfCounter*    ClassLoader::_sync_JNIDefineClassLockFreeCounter = NULL;
 137 PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = NULL;
 138 
 139 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_patch_mod_entries = NULL;
 140 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_exploded_entries = NULL;
 141 ClassPathEntry* ClassLoader::_jrt_entry = NULL;
 142 ClassPathEntry* ClassLoader::_first_append_entry = NULL;
 143 ClassPathEntry* ClassLoader::_last_append_entry  = NULL;
 144 #if INCLUDE_CDS
 145 ClassPathEntry* ClassLoader::_app_classpath_entries = NULL;
 146 ClassPathEntry* ClassLoader::_last_app_classpath_entry = NULL;
 147 ClassPathEntry* ClassLoader::_module_path_entries = NULL;
 148 ClassPathEntry* ClassLoader::_last_module_path_entry = NULL;
 149 #endif
 150 
 151 // helper routines
 152 bool string_starts_with(const char* str, const char* str_to_find) {
 153   size_t str_len = strlen(str);
 154   size_t str_to_find_len = strlen(str_to_find);
 155   if (str_to_find_len &gt; str_len) {
 156     return false;
 157   }
 158   return (strncmp(str, str_to_find, str_to_find_len) == 0);
 159 }
 160 
 161 static const char* get_jimage_version_string() {
 162   static char version_string[10] = &quot;&quot;;
 163   if (version_string[0] == &#39;\0&#39;) {
 164     jio_snprintf(version_string, sizeof(version_string), &quot;%d.%d&quot;,
 165                  VM_Version::vm_major_version(), VM_Version::vm_minor_version());
 166   }
 167   return (const char*)version_string;
 168 }
 169 
 170 bool ClassLoader::string_ends_with(const char* str, const char* str_to_find) {
 171   size_t str_len = strlen(str);
 172   size_t str_to_find_len = strlen(str_to_find);
 173   if (str_to_find_len &gt; str_len) {
 174     return false;
 175   }
 176   return (strncmp(str + (str_len - str_to_find_len), str_to_find, str_to_find_len) == 0);
 177 }
 178 
 179 // Used to obtain the package name from a fully qualified class name.
 180 Symbol* ClassLoader::package_from_class_name(const Symbol* name, bool* bad_class_name) {
 181   if (name == NULL) {
 182     if (bad_class_name != NULL) {
 183       *bad_class_name = true;
 184     }
 185     return NULL;
 186   }
 187 
 188   int utf_len = name-&gt;utf8_length();
 189   const jbyte* base = (const jbyte*)name-&gt;base();
 190   const jbyte* start = base;
 191   const jbyte* end = UTF8::strrchr(start, utf_len, JVM_SIGNATURE_SLASH);
 192   if (end == NULL) {
 193     return NULL;
 194   }
 195   // Skip over &#39;[&#39;s
 196   if (*start == JVM_SIGNATURE_ARRAY) {
 197     do {
 198       start++;
 199     } while (start &lt; end &amp;&amp; *start == JVM_SIGNATURE_ARRAY);
 200 
 201     // Fully qualified class names should not contain a &#39;L&#39;.
 202     // Set bad_class_name to true to indicate that the package name
 203     // could not be obtained due to an error condition.
 204     // In this situation, is_same_class_package returns false.
 205     if (*start == JVM_SIGNATURE_CLASS) {
 206       if (bad_class_name != NULL) {
 207         *bad_class_name = true;
 208       }
 209       return NULL;
 210     }
 211   }
 212   // A class name could have just the slash character in the name,
 213   // in which case start &gt; end
 214   if (start &gt;= end) {
 215     // No package name
 216     if (bad_class_name != NULL) {
 217       *bad_class_name = true;
 218     }
 219     return NULL;
 220   }
 221   return SymbolTable::new_symbol(name, start - base, end - base);
 222 }
 223 
 224 // Given a fully qualified package name, find its defining package in the class loader&#39;s
 225 // package entry table.
 226 PackageEntry* ClassLoader::get_package_entry(Symbol* pkg_name, ClassLoaderData* loader_data) {
 227   if (pkg_name == NULL) {
 228     return NULL;
 229   }
 230   PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
 231   return pkgEntryTable-&gt;lookup_only(pkg_name);
 232 }
 233 
 234 const char* ClassPathEntry::copy_path(const char* path) {
 235   char* copy = NEW_C_HEAP_ARRAY(char, strlen(path)+1, mtClass);
 236   strcpy(copy, path);
 237   return copy;
 238 }
 239 
 240 ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {
 241   // construct full path name
 242   assert((_dir != NULL) &amp;&amp; (name != NULL), &quot;sanity&quot;);
 243   size_t path_len = strlen(_dir) + strlen(name) + strlen(os::file_separator()) + 1;
 244   char* path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, path_len);
 245   int len = jio_snprintf(path, path_len, &quot;%s%s%s&quot;, _dir, os::file_separator(), name);
 246   assert(len == (int)(path_len - 1), &quot;sanity&quot;);
 247   // check if file exists
 248   struct stat st;
 249   if (os::stat(path, &amp;st) == 0) {
 250     // found file, open it
 251     int file_handle = os::open(path, 0, 0);
 252     if (file_handle != -1) {
 253       // read contents into resource array
 254       u1* buffer = NEW_RESOURCE_ARRAY(u1, st.st_size);
 255       size_t num_read = os::read(file_handle, (char*) buffer, st.st_size);
 256       // close file
 257       os::close(file_handle);
 258       // construct ClassFileStream
 259       if (num_read == (size_t)st.st_size) {
 260         if (UsePerfData) {
 261           ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(num_read);
 262         }
 263         FREE_RESOURCE_ARRAY(char, path, path_len);
 264         // Resource allocated
 265         return new ClassFileStream(buffer,
 266                                    st.st_size,
 267                                    _dir,
 268                                    ClassFileStream::verify);
 269       }
 270     }
 271   }
 272   FREE_RESOURCE_ARRAY(char, path, path_len);
 273   return NULL;
 274 }
 275 
 276 ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name,
 277                                      bool is_boot_append, bool from_class_path_attr) : ClassPathEntry() {
 278   _zip = zip;
 279   _zip_name = copy_path(zip_name);
 280   _from_class_path_attr = from_class_path_attr;
 281 }
 282 
 283 ClassPathZipEntry::~ClassPathZipEntry() {
 284   (*ZipClose)(_zip);
 285   FREE_C_HEAP_ARRAY(char, _zip_name);
 286 }
 287 
 288 u1* ClassPathZipEntry::open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS) {
 289     // enable call to C land
 290   JavaThread* thread = JavaThread::current();
 291   ThreadToNativeFromVM ttn(thread);
 292   // check whether zip archive contains name
 293   jint name_len;
 294   jzentry* entry = (*FindEntry)(_zip, name, filesize, &amp;name_len);
 295   if (entry == NULL) return NULL;
 296   u1* buffer;
 297   char name_buf[128];
 298   char* filename;
 299   if (name_len &lt; 128) {
 300     filename = name_buf;
 301   } else {
 302     filename = NEW_RESOURCE_ARRAY(char, name_len + 1);
 303   }
 304 
 305   // read contents into resource array
 306   int size = (*filesize) + ((nul_terminate) ? 1 : 0);
 307   buffer = NEW_RESOURCE_ARRAY(u1, size);
 308   if (!(*ReadEntry)(_zip, entry, buffer, filename)) return NULL;
 309 
 310   // return result
 311   if (nul_terminate) {
 312     buffer[*filesize] = 0;
 313   }
 314   return buffer;
 315 }
 316 
 317 ClassFileStream* ClassPathZipEntry::open_stream(const char* name, TRAPS) {
 318   jint filesize;
 319   u1* buffer = open_entry(name, &amp;filesize, false, CHECK_NULL);
 320   if (buffer == NULL) {
 321     return NULL;
 322   }
 323   if (UsePerfData) {
 324     ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(filesize);
 325   }
 326   // Resource allocated
 327   return new ClassFileStream(buffer,
 328                              filesize,
 329                              _zip_name,
 330                              ClassFileStream::verify);
 331 }
 332 
 333 // invoke function for each entry in the zip file
 334 void ClassPathZipEntry::contents_do(void f(const char* name, void* context), void* context) {
 335   JavaThread* thread = JavaThread::current();
 336   HandleMark  handle_mark(thread);
 337   ThreadToNativeFromVM ttn(thread);
 338   for (int n = 0; ; n++) {
 339     jzentry * ze = ((*GetNextEntry)(_zip, n));
 340     if (ze == NULL) break;
 341     (*f)(ze-&gt;name, context);
 342   }
 343 }
 344 
 345 DEBUG_ONLY(ClassPathImageEntry* ClassPathImageEntry::_singleton = NULL;)
 346 
 347 void ClassPathImageEntry::close_jimage() {
 348   if (_jimage != NULL) {
 349     (*JImageClose)(_jimage);
 350     _jimage = NULL;
 351   }
 352 }
 353 
 354 ClassPathImageEntry::ClassPathImageEntry(JImageFile* jimage, const char* name) :
 355   ClassPathEntry(),
 356   _jimage(jimage) {
 357   guarantee(jimage != NULL, &quot;jimage file is null&quot;);
 358   guarantee(name != NULL, &quot;jimage file name is null&quot;);
 359   assert(_singleton == NULL, &quot;VM supports only one jimage&quot;);
 360   DEBUG_ONLY(_singleton = this);
 361   size_t len = strlen(name) + 1;
 362   _name = copy_path(name);
 363 }
 364 
 365 ClassPathImageEntry::~ClassPathImageEntry() {
 366   assert(_singleton == this, &quot;must be&quot;);
 367   DEBUG_ONLY(_singleton = NULL);
 368 
 369   FREE_C_HEAP_ARRAY(const char, _name);
 370 
 371   if (_jimage != NULL) {
 372     (*JImageClose)(_jimage);
 373     _jimage = NULL;
 374   }
 375 }
 376 
 377 ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {
 378   return open_stream_for_loader(name, ClassLoaderData::the_null_class_loader_data(), THREAD);
 379 }
 380 
 381 // For a class in a named module, look it up in the jimage file using this syntax:
 382 //    /&lt;module-name&gt;/&lt;package-name&gt;/&lt;base-class&gt;
 383 //
 384 // Assumptions:
 385 //     1. There are no unnamed modules in the jimage file.
 386 //     2. A package is in at most one module in the jimage file.
 387 //
 388 ClassFileStream* ClassPathImageEntry::open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {
 389   jlong size;
 390   JImageLocationRef location = (*JImageFindResource)(_jimage, &quot;&quot;, get_jimage_version_string(), name, &amp;size);
 391 
 392   if (location == 0) {
 393     TempNewSymbol class_name = SymbolTable::new_symbol(name);
 394     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
 395 
 396     if (pkg_name != NULL) {
 397       if (!Universe::is_module_initialized()) {
 398         location = (*JImageFindResource)(_jimage, JAVA_BASE_NAME, get_jimage_version_string(), name, &amp;size);
 399       } else {
 400         PackageEntry* package_entry = ClassLoader::get_package_entry(pkg_name, loader_data);
 401         if (package_entry != NULL) {
 402           ResourceMark rm(THREAD);
 403           // Get the module name
 404           ModuleEntry* module = package_entry-&gt;module();
 405           assert(module != NULL, &quot;Boot classLoader package missing module&quot;);
 406           assert(module-&gt;is_named(), &quot;Boot classLoader package is in unnamed module&quot;);
 407           const char* module_name = module-&gt;name()-&gt;as_C_string();
 408           if (module_name != NULL) {
 409             location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &amp;size);
 410           }
 411         }
 412       }
 413     }
 414   }
 415   if (location != 0) {
 416     if (UsePerfData) {
 417       ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(size);
 418     }
 419     char* data = NEW_RESOURCE_ARRAY(char, size);
 420     (*JImageGetResource)(_jimage, location, data, size);
 421     // Resource allocated
 422     assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be&quot;);
 423     return new ClassFileStream((u1*)data,
 424                                (int)size,
 425                                _name,
 426                                ClassFileStream::verify,
 427                                true); // from_boot_loader_modules_image
 428   }
 429 
 430   return NULL;
 431 }
 432 
 433 JImageLocationRef ClassLoader::jimage_find_resource(JImageFile* jf,
 434                                                     const char* module_name,
 435                                                     const char* file_name,
 436                                                     jlong &amp;size) {
 437   return ((*JImageFindResource)(jf, module_name, get_jimage_version_string(), file_name, &amp;size));
 438 }
 439 
 440 bool ClassPathImageEntry::is_modules_image() const {
 441   assert(this == _singleton, &quot;VM supports a single jimage&quot;);
 442   assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be used for jrt entry&quot;);
 443   return true;
 444 }
 445 
 446 #if INCLUDE_CDS
 447 void ClassLoader::exit_with_path_failure(const char* error, const char* message) {
 448   Arguments::assert_is_dumping_archive();
 449   tty-&gt;print_cr(&quot;Hint: enable -Xlog:class+path=info to diagnose the failure&quot;);
 450   vm_exit_during_initialization(error, message);
 451 }
 452 #endif
 453 
 454 ModuleClassPathList::ModuleClassPathList(Symbol* module_name) {
 455   _module_name = module_name;
 456   _module_first_entry = NULL;
 457   _module_last_entry = NULL;
 458 }
 459 
 460 ModuleClassPathList::~ModuleClassPathList() {
 461   // Clean out each ClassPathEntry on list
 462   ClassPathEntry* e = _module_first_entry;
 463   while (e != NULL) {
 464     ClassPathEntry* next_entry = e-&gt;next();
 465     delete e;
 466     e = next_entry;
 467   }
 468 }
 469 
 470 void ModuleClassPathList::add_to_list(ClassPathEntry* new_entry) {
 471   if (new_entry != NULL) {
 472     if (_module_last_entry == NULL) {
 473       _module_first_entry = _module_last_entry = new_entry;
 474     } else {
 475       _module_last_entry-&gt;set_next(new_entry);
 476       _module_last_entry = new_entry;
 477     }
 478   }
 479 }
 480 
 481 void ClassLoader::trace_class_path(const char* msg, const char* name) {
 482   LogTarget(Info, class, path) lt;
 483   if (lt.is_enabled()) {
 484     LogStream ls(lt);
 485     if (msg) {
 486       ls.print(&quot;%s&quot;, msg);
 487     }
 488     if (name) {
 489       if (strlen(name) &lt; 256) {
 490         ls.print(&quot;%s&quot;, name);
 491       } else {
 492         // For very long paths, we need to print each character separately,
 493         // as print_cr() has a length limit
 494         while (name[0] != &#39;\0&#39;) {
 495           ls.print(&quot;%c&quot;, name[0]);
 496           name++;
 497         }
 498       }
 499     }
 500     ls.cr();
 501   }
 502 }
 503 
 504 void ClassLoader::setup_bootstrap_search_path() {
 505   const char* sys_class_path = Arguments::get_sysclasspath();
 506   assert(sys_class_path != NULL, &quot;System boot class path must not be NULL&quot;);
 507   if (PrintSharedArchiveAndExit) {
 508     // Don&#39;t print sys_class_path - this is the bootcp of this current VM process, not necessarily
 509     // the same as the bootcp of the shared archive.
 510   } else {
 511     trace_class_path(&quot;bootstrap loader class path=&quot;, sys_class_path);
 512   }
 513   setup_boot_search_path(sys_class_path);
 514 }
 515 
 516 #if INCLUDE_CDS
 517 void ClassLoader::setup_app_search_path(const char *class_path) {
 518   Arguments::assert_is_dumping_archive();
 519 
 520   ResourceMark rm;
 521   ClasspathStream cp_stream(class_path);
 522 
 523   while (cp_stream.has_next()) {
 524     const char* path = cp_stream.get_next();
 525     update_class_path_entry_list(path, false, false, false);
 526   }
 527 }
 528 
 529 void ClassLoader::add_to_module_path_entries(const char* path,
 530                                              ClassPathEntry* entry) {
 531   assert(entry != NULL, &quot;ClassPathEntry should not be NULL&quot;);
 532   Arguments::assert_is_dumping_archive();
 533 
 534   // The entry does not exist, add to the list
 535   if (_module_path_entries == NULL) {
 536     assert(_last_module_path_entry == NULL, &quot;Sanity&quot;);
 537     _module_path_entries = _last_module_path_entry = entry;
 538   } else {
 539     _last_module_path_entry-&gt;set_next(entry);
 540     _last_module_path_entry = entry;
 541   }
 542 }
 543 
 544 // Add a module path to the _module_path_entries list.
 545 void ClassLoader::update_module_path_entry_list(const char *path, TRAPS) {
 546   Arguments::assert_is_dumping_archive();
 547   struct stat st;
 548   if (os::stat(path, &amp;st) != 0) {
 549     tty-&gt;print_cr(&quot;os::stat error %d (%s). CDS dump aborted (path was \&quot;%s\&quot;).&quot;,
 550       errno, os::errno_name(errno), path);
 551     vm_exit_during_initialization();
 552   }
 553   // File or directory found
 554   ClassPathEntry* new_entry = NULL;
 555   new_entry = create_class_path_entry(path, &amp;st, true /* throw_exception */,
 556                                       false /*is_boot_append */, false /* from_class_path_attr */, CHECK);
 557   if (new_entry == NULL) {
 558     return;
 559   }
 560 
 561   add_to_module_path_entries(path, new_entry);
 562   return;
 563 }
 564 
 565 void ClassLoader::setup_module_search_path(const char* path, TRAPS) {
 566   update_module_path_entry_list(path, THREAD);
 567 }
 568 
 569 #endif // INCLUDE_CDS
 570 
 571 void ClassLoader::close_jrt_image() {
 572   // Not applicable for exploded builds
 573   if (!ClassLoader::has_jrt_entry()) return;
 574   _jrt_entry-&gt;close_jimage();
 575 }
 576 
 577 // Construct the array of module/path pairs as specified to --patch-module
 578 // for the boot loader to search ahead of the jimage, if the class being
 579 // loaded is defined to a module that has been specified to --patch-module.
 580 void ClassLoader::setup_patch_mod_entries() {
 581   Thread* THREAD = Thread::current();
 582   GrowableArray&lt;ModulePatchPath*&gt;* patch_mod_args = Arguments::get_patch_mod_prefix();
 583   int num_of_entries = patch_mod_args-&gt;length();
 584 
 585   // Set up the boot loader&#39;s _patch_mod_entries list
 586   _patch_mod_entries = new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;ModuleClassPathList*&gt;(num_of_entries, true);
 587 
 588   for (int i = 0; i &lt; num_of_entries; i++) {
 589     const char* module_name = (patch_mod_args-&gt;at(i))-&gt;module_name();
 590     Symbol* const module_sym = SymbolTable::new_symbol(module_name);
 591     assert(module_sym != NULL, &quot;Failed to obtain Symbol for module name&quot;);
 592     ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 593 
 594     char* class_path = (patch_mod_args-&gt;at(i))-&gt;path_string();
 595     ResourceMark rm(THREAD);
 596     ClasspathStream cp_stream(class_path);
 597 
 598     while (cp_stream.has_next()) {
 599       const char* path = cp_stream.get_next();
 600       struct stat st;
 601       if (os::stat(path, &amp;st) == 0) {
 602         // File or directory found
 603         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);
 604         // If the path specification is valid, enter it into this module&#39;s list
 605         if (new_entry != NULL) {
 606           module_cpl-&gt;add_to_list(new_entry);
 607         }
 608       }
 609     }
 610 
 611     // Record the module into the list of --patch-module entries only if
 612     // valid ClassPathEntrys have been created
 613     if (module_cpl-&gt;module_first_entry() != NULL) {
 614       _patch_mod_entries-&gt;push(module_cpl);
 615     }
 616   }
 617 }
 618 
 619 // Determine whether the module has been patched via the command-line
 620 // option --patch-module
 621 bool ClassLoader::is_in_patch_mod_entries(Symbol* module_name) {
 622   if (_patch_mod_entries != NULL &amp;&amp; _patch_mod_entries-&gt;is_nonempty()) {
 623     int table_len = _patch_mod_entries-&gt;length();
 624     for (int i = 0; i &lt; table_len; i++) {
 625       ModuleClassPathList* patch_mod = _patch_mod_entries-&gt;at(i);
 626       if (module_name-&gt;fast_compare(patch_mod-&gt;module_name()) == 0) {
 627         return true;
 628       }
 629     }
 630   }
 631   return false;
 632 }
 633 
 634 // Set up the _jrt_entry if present and boot append path
 635 void ClassLoader::setup_boot_search_path(const char *class_path) {
 636   EXCEPTION_MARK;
 637   ResourceMark rm(THREAD);
 638   ClasspathStream cp_stream(class_path);
 639   bool set_base_piece = true;
 640 
 641 #if INCLUDE_CDS
 642   if (Arguments::is_dumping_archive()) {
 643     if (!Arguments::has_jimage()) {
 644       vm_exit_during_initialization(&quot;CDS is not supported in exploded JDK build&quot;, NULL);
 645     }
 646   }
 647 #endif
 648 
 649   while (cp_stream.has_next()) {
 650     const char* path = cp_stream.get_next();
 651 
 652     if (set_base_piece) {
 653       // The first time through the bootstrap_search setup, it must be determined
 654       // what the base or core piece of the boot loader search is.  Either a java runtime
 655       // image is present or this is an exploded module build situation.
 656       assert(string_ends_with(path, MODULES_IMAGE_NAME) || string_ends_with(path, JAVA_BASE_NAME),
 657              &quot;Incorrect boot loader search path, no java runtime image or &quot; JAVA_BASE_NAME &quot; exploded build&quot;);
 658       struct stat st;
 659       if (os::stat(path, &amp;st) == 0) {
 660         // Directory found
 661         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);
 662 
 663         // Check for a jimage
 664         if (Arguments::has_jimage()) {
 665           assert(_jrt_entry == NULL, &quot;should not setup bootstrap class search path twice&quot;);
 666           _jrt_entry = new_entry;
 667           assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_modules_image(), &quot;No java runtime image present&quot;);
 668           assert(_jrt_entry-&gt;jimage() != NULL, &quot;No java runtime image&quot;);
 669         }
 670       } else {
 671         // If path does not exist, exit
 672         vm_exit_during_initialization(&quot;Unable to establish the boot loader search path&quot;, path);
 673       }
 674       set_base_piece = false;
 675     } else {
 676       // Every entry on the system boot class path after the initial base piece,
 677       // which is set by os::set_boot_path(), is considered an appended entry.
 678       update_class_path_entry_list(path, false, true, false);
 679     }
 680   }
 681 }
 682 
 683 // During an exploded modules build, each module defined to the boot loader
 684 // will be added to the ClassLoader::_exploded_entries array.
 685 void ClassLoader::add_to_exploded_build_list(Symbol* module_sym, TRAPS) {
 686   assert(!ClassLoader::has_jrt_entry(), &quot;Exploded build not applicable&quot;);
 687   assert(_exploded_entries != NULL, &quot;_exploded_entries was not initialized&quot;);
 688 
 689   // Find the module&#39;s symbol
 690   ResourceMark rm(THREAD);
 691   const char *module_name = module_sym-&gt;as_C_string();
 692   const char *home = Arguments::get_java_home();
 693   const char file_sep = os::file_separator()[0];
 694   // 10 represents the length of &quot;modules&quot; + 2 file separators + \0
 695   size_t len = strlen(home) + strlen(module_name) + 10;
 696   char *path = NEW_RESOURCE_ARRAY(char, len);
 697   jio_snprintf(path, len, &quot;%s%cmodules%c%s&quot;, home, file_sep, file_sep, module_name);
 698 
 699   struct stat st;
 700   if (os::stat(path, &amp;st) == 0) {
 701     // Directory found
 702     ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);
 703 
 704     // If the path specification is valid, enter it into this module&#39;s list.
 705     // There is no need to check for duplicate modules in the exploded entry list,
 706     // since no two modules with the same name can be defined to the boot loader.
 707     // This is checked at module definition time in Modules::define_module.
 708     if (new_entry != NULL) {
 709       ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 710       module_cpl-&gt;add_to_list(new_entry);
 711       {
 712         MutexLocker ml(THREAD, Module_lock);
 713         _exploded_entries-&gt;push(module_cpl);
 714       }
 715       log_info(class, load)(&quot;path: %s&quot;, path);
 716     }
 717   }
 718 }
 719 
 720 ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const struct stat* st,
 721                                                      bool throw_exception,
 722                                                      bool is_boot_append,
 723                                                      bool from_class_path_attr,
 724                                                      TRAPS) {
 725   JavaThread* thread = JavaThread::current();
 726   ClassPathEntry* new_entry = NULL;
 727   if ((st-&gt;st_mode &amp; S_IFMT) == S_IFREG) {
 728     ResourceMark rm(thread);
 729     // Regular file, should be a zip or jimage file
 730     // Canonicalized filename
 731     char* canonical_path = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, JVM_MAXPATHLEN);
 732     if (!get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 733       // This matches the classic VM
 734       if (throw_exception) {
 735         THROW_MSG_(vmSymbols::java_io_IOException(), &quot;Bad pathname&quot;, NULL);
 736       } else {
 737         return NULL;
 738       }
 739     }
 740     jint error;
 741     JImageFile* jimage =(*JImageOpen)(canonical_path, &amp;error);
 742     if (jimage != NULL) {
 743       new_entry = new ClassPathImageEntry(jimage, canonical_path);
 744     } else {
 745       char* error_msg = NULL;
 746       jzfile* zip;
 747       {
 748         // enable call to C land
 749         ThreadToNativeFromVM ttn(thread);
 750         HandleMark hm(thread);
 751         load_zip_library_if_needed();
 752         zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 753       }
 754       if (zip != NULL &amp;&amp; error_msg == NULL) {
 755         new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr);
 756       } else {
 757         char *msg;
 758         if (error_msg == NULL) {
 759           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;
 760           jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
 761         } else {
 762           int len = (int)(strlen(path) + strlen(error_msg) + 128);
 763           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, len); ;
 764           jio_snprintf(msg, len - 1, &quot;error in opening JAR file &lt;%s&gt; %s&quot;, error_msg, path);
 765         }
 766         // Don&#39;t complain about bad jar files added via -Xbootclasspath/a:.
 767         if (throw_exception &amp;&amp; is_init_completed()) {
 768           THROW_MSG_(vmSymbols::java_lang_ClassNotFoundException(), msg, NULL);
 769         } else {
 770           return NULL;
 771         }
 772       }
 773     }
 774     log_info(class, path)(&quot;opened: %s&quot;, path);
 775     log_info(class, load)(&quot;opened: %s&quot;, path);
 776   } else {
 777     // Directory
 778     new_entry = new ClassPathDirEntry(path);
 779     log_info(class, load)(&quot;path: %s&quot;, path);
 780   }
 781   return new_entry;
 782 }
 783 
 784 
 785 // Create a class path zip entry for a given path (return NULL if not found
 786 // or zip/JAR file cannot be opened)
 787 ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bool is_boot_append) {
 788   // check for a regular file
 789   struct stat st;
 790   if (os::stat(path, &amp;st) == 0) {
 791     if ((st.st_mode &amp; S_IFMT) == S_IFREG) {
 792       char canonical_path[JVM_MAXPATHLEN];
 793       if (get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 794         char* error_msg = NULL;
 795         jzfile* zip;
 796         {
 797           // enable call to C land
 798           JavaThread* thread = JavaThread::current();
 799           ThreadToNativeFromVM ttn(thread);
 800           HandleMark hm(thread);
 801           load_zip_library_if_needed();
 802           zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 803         }
 804         if (zip != NULL &amp;&amp; error_msg == NULL) {
 805           // create using canonical path
 806           return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false);
 807         }
 808       }
 809     }
 810   }
 811   return NULL;
 812 }
 813 
 814 // returns true if entry already on class path
 815 bool ClassLoader::contains_append_entry(const char* name) {
 816   ClassPathEntry* e = _first_append_entry;
 817   while (e != NULL) {
 818     // assume zip entries have been canonicalized
 819     if (strcmp(name, e-&gt;name()) == 0) {
 820       return true;
 821     }
 822     e = e-&gt;next();
 823   }
 824   return false;
 825 }
 826 
 827 void ClassLoader::add_to_boot_append_entries(ClassPathEntry *new_entry) {
 828   if (new_entry != NULL) {
 829     if (_last_append_entry == NULL) {
 830       assert(_first_append_entry == NULL, &quot;boot loader&#39;s append class path entry list not empty&quot;);
 831       _first_append_entry = _last_append_entry = new_entry;
 832     } else {
 833       _last_append_entry-&gt;set_next(new_entry);
 834       _last_append_entry = new_entry;
 835     }
 836   }
 837 }
 838 
 839 // Record the path entries specified in -cp during dump time. The recorded
 840 // information will be used at runtime for loading the archived app classes.
 841 //
 842 // Note that at dump time, ClassLoader::_app_classpath_entries are NOT used for
 843 // loading app classes. Instead, the app class are loaded by the
 844 // jdk/internal/loader/ClassLoaders$AppClassLoader instance.
 845 void ClassLoader::add_to_app_classpath_entries(const char* path,
 846                                                ClassPathEntry* entry,
 847                                                bool check_for_duplicates) {
 848 #if INCLUDE_CDS
 849   assert(entry != NULL, &quot;ClassPathEntry should not be NULL&quot;);
 850   ClassPathEntry* e = _app_classpath_entries;
 851   if (check_for_duplicates) {
 852     while (e != NULL) {
 853       if (strcmp(e-&gt;name(), entry-&gt;name()) == 0) {
 854         // entry already exists
 855         return;
 856       }
 857       e = e-&gt;next();
 858     }
 859   }
 860 
 861   // The entry does not exist, add to the list
 862   if (_app_classpath_entries == NULL) {
 863     assert(_last_app_classpath_entry == NULL, &quot;Sanity&quot;);
 864     _app_classpath_entries = _last_app_classpath_entry = entry;
 865   } else {
 866     _last_app_classpath_entry-&gt;set_next(entry);
 867     _last_app_classpath_entry = entry;
 868   }
 869 
 870   if (entry-&gt;is_jar_file()) {
 871     ClassLoaderExt::process_jar_manifest(entry, check_for_duplicates);
 872   }
 873 #endif
 874 }
 875 
 876 // Returns true IFF the file/dir exists and the entry was successfully created.
 877 bool ClassLoader::update_class_path_entry_list(const char *path,
 878                                                bool check_for_duplicates,
 879                                                bool is_boot_append,
 880                                                bool from_class_path_attr,
 881                                                bool throw_exception) {
 882   struct stat st;
 883   if (os::stat(path, &amp;st) == 0) {
 884     // File or directory found
 885     ClassPathEntry* new_entry = NULL;
 886     Thread* THREAD = Thread::current();
 887     new_entry = create_class_path_entry(path, &amp;st, throw_exception, is_boot_append, from_class_path_attr, CHECK_(false));
 888     if (new_entry == NULL) {
 889       return false;
 890     }
 891 
 892     // Do not reorder the bootclasspath which would break get_system_package().
 893     // Add new entry to linked list
 894     if (is_boot_append) {
 895       add_to_boot_append_entries(new_entry);
 896     } else {
 897       add_to_app_classpath_entries(path, new_entry, check_for_duplicates);
 898     }
 899     return true;
 900   } else {
 901     return false;
 902   }
 903 }
 904 
 905 static void print_module_entry_table(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list) {
 906   ResourceMark rm;
 907   int num_of_entries = module_list-&gt;length();
 908   for (int i = 0; i &lt; num_of_entries; i++) {
 909     ClassPathEntry* e;
 910     ModuleClassPathList* mpl = module_list-&gt;at(i);
 911     tty-&gt;print(&quot;%s=&quot;, mpl-&gt;module_name()-&gt;as_C_string());
 912     e = mpl-&gt;module_first_entry();
 913     while (e != NULL) {
 914       tty-&gt;print(&quot;%s&quot;, e-&gt;name());
 915       e = e-&gt;next();
 916       if (e != NULL) {
 917         tty-&gt;print(&quot;%s&quot;, os::path_separator());
 918       }
 919     }
 920     tty-&gt;print(&quot; ;&quot;);
 921   }
 922 }
 923 
 924 void ClassLoader::print_bootclasspath() {
 925   ClassPathEntry* e;
 926   tty-&gt;print(&quot;[bootclasspath= &quot;);
 927 
 928   // Print --patch-module module/path specifications first
 929   if (_patch_mod_entries != NULL) {
 930     print_module_entry_table(_patch_mod_entries);
 931   }
 932 
 933   // [jimage | exploded modules build]
 934   if (has_jrt_entry()) {
 935     // Print the location of the java runtime image
 936     tty-&gt;print(&quot;%s ;&quot;, _jrt_entry-&gt;name());
 937   } else {
 938     // Print exploded module build path specifications
 939     if (_exploded_entries != NULL) {
 940       print_module_entry_table(_exploded_entries);
 941     }
 942   }
 943 
 944   // appended entries
 945   e = _first_append_entry;
 946   while (e != NULL) {
 947     tty-&gt;print(&quot;%s ;&quot;, e-&gt;name());
 948     e = e-&gt;next();
 949   }
 950   tty-&gt;print_cr(&quot;]&quot;);
 951 }
 952 
 953 void* ClassLoader::dll_lookup(void* lib, const char* name, const char* path) {
 954   void* func = os::dll_lookup(lib, name);
 955   if (func == NULL) {
 956     char msg[256] = &quot;&quot;;
 957     jio_snprintf(msg, sizeof(msg), &quot;Could not resolve \&quot;%s\&quot;&quot;, name);
 958     vm_exit_during_initialization(msg, path);
 959   }
 960   return func;
 961 }
 962 
 963 void ClassLoader::load_java_library() {
 964   assert(CanonicalizeEntry == NULL, &quot;should not load java library twice&quot;);
 965   void *javalib_handle = os::native_java_library();
 966   if (javalib_handle == NULL) {
 967     vm_exit_during_initialization(&quot;Unable to load java library&quot;, NULL);
 968   }
 969 
 970   CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, &quot;JDK_Canonicalize&quot;, NULL));
 971 }
 972 
 973 void ClassLoader::release_load_zip_library() {
 974   MutexLocker locker(Zip_lock, Monitor::_no_safepoint_check_flag);
 975   if (_libzip_loaded == 0) {
 976     load_zip_library();
 977     Atomic::release_store(&amp;_libzip_loaded, 1);
 978   }
 979 }
 980 
 981 void ClassLoader::load_zip_library() {
 982   assert(ZipOpen == NULL, &quot;should not load zip library twice&quot;);
 983   char path[JVM_MAXPATHLEN];
 984   char ebuf[1024];
 985   void* handle = NULL;
 986   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;zip&quot;)) {
 987     handle = os::dll_load(path, ebuf, sizeof ebuf);
 988   }
 989   if (handle == NULL) {
 990     vm_exit_during_initialization(&quot;Unable to load zip library&quot;, path);
 991   }
 992 
 993   ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(handle, &quot;ZIP_Open&quot;, path));
 994   ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(handle, &quot;ZIP_Close&quot;, path));
 995   FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(handle, &quot;ZIP_FindEntry&quot;, path));
 996   ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(handle, &quot;ZIP_ReadEntry&quot;, path));
 997   GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(handle, &quot;ZIP_GetNextEntry&quot;, path));
 998   Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(handle, &quot;ZIP_CRC32&quot;, path));
 999 }
1000 
1001 void ClassLoader::load_jimage_library() {
1002   assert(JImageOpen == NULL, &quot;should not load jimage library twice&quot;);
1003   char path[JVM_MAXPATHLEN];
1004   char ebuf[1024];
1005   void* handle = NULL;
1006   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
1007     handle = os::dll_load(path, ebuf, sizeof ebuf);
1008   }
1009   if (handle == NULL) {
1010     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1011   }
1012 
1013   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));
1014   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));
1015   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));
1016   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));
1017   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));
1018   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));
1019 }
1020 
1021 int ClassLoader::crc32(int crc, const char* buf, int len) {
1022   load_zip_library_if_needed();
1023   return (*Crc32)(crc, (const jbyte*)buf, len);
1024 }
1025 
1026 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1027   // Look up the name in the boot loader&#39;s package entry table.
1028   if (name != NULL) {
1029     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
1030     // Look for the package entry in the boot loader&#39;s package entry table.
1031     PackageEntry* package =
1032       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1033 
1034     // Return NULL if package does not exist or if no classes in that package
1035     // have been loaded.
1036     if (package != NULL &amp;&amp; package-&gt;has_loaded_class()) {
1037       ModuleEntry* module = package-&gt;module();
1038       if (module-&gt;location() != NULL) {
1039         ResourceMark rm(THREAD);
1040         Handle ml = java_lang_String::create_from_str(
1041           module-&gt;location()-&gt;as_C_string(), THREAD);
1042         return ml();
1043       }
1044       // Return entry on boot loader class path.
1045       Handle cph = java_lang_String::create_from_str(
1046         ClassLoader::classpath_entry(package-&gt;classpath_index())-&gt;name(), THREAD);
1047       return cph();
1048     }
1049   }
1050   return NULL;
1051 }
1052 
1053 objArrayOop ClassLoader::get_system_packages(TRAPS) {
1054   ResourceMark rm(THREAD);
1055   // List of pointers to PackageEntrys that have loaded classes.
1056   GrowableArray&lt;PackageEntry*&gt;* loaded_class_pkgs = new GrowableArray&lt;PackageEntry*&gt;(50);
1057   {
1058     MutexLocker ml(THREAD, Module_lock);
1059 
1060     PackageEntryTable* pe_table =
1061       ClassLoaderData::the_null_class_loader_data()-&gt;packages();
1062 
1063     // Collect the packages that have at least one loaded class.
1064     for (int x = 0; x &lt; pe_table-&gt;table_size(); x++) {
1065       for (PackageEntry* package_entry = pe_table-&gt;bucket(x);
1066            package_entry != NULL;
1067            package_entry = package_entry-&gt;next()) {
1068         if (package_entry-&gt;has_loaded_class()) {
1069           loaded_class_pkgs-&gt;append(package_entry);
1070         }
1071       }
1072     }
1073   }
1074 
1075 
1076   // Allocate objArray and fill with java.lang.String
1077   objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
1078                                            loaded_class_pkgs-&gt;length(), CHECK_NULL);
1079   objArrayHandle result(THREAD, r);
1080   for (int x = 0; x &lt; loaded_class_pkgs-&gt;length(); x++) {
1081     PackageEntry* package_entry = loaded_class_pkgs-&gt;at(x);
1082     Handle str = java_lang_String::create_from_symbol(package_entry-&gt;name(), CHECK_NULL);
1083     result-&gt;obj_at_put(x, str());
1084   }
1085   return result();
1086 }
1087 
1088 // caller needs ResourceMark
1089 const char* ClassLoader::file_name_for_class_name(const char* class_name,
1090                                                   int class_name_len) {
1091   assert(class_name != NULL, &quot;invariant&quot;);
1092   assert((int)strlen(class_name) == class_name_len, &quot;invariant&quot;);
1093 
1094   static const char class_suffix[] = &quot;.class&quot;;
1095   size_t class_suffix_len = sizeof(class_suffix);
1096 
1097   char* const file_name = NEW_RESOURCE_ARRAY(char,
1098                                              class_name_len +
1099                                              class_suffix_len); // includes term NULL
1100 
1101   strncpy(file_name, class_name, class_name_len);
1102   strncpy(&amp;file_name[class_name_len], class_suffix, class_suffix_len);
1103 
1104   return file_name;
1105 }
1106 
1107 ClassPathEntry* find_first_module_cpe(ModuleEntry* mod_entry,
1108                                       const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list) {
1109   int num_of_entries = module_list-&gt;length();
1110   const Symbol* class_module_name = mod_entry-&gt;name();
1111 
1112   // Loop through all the modules in either the patch-module or exploded entries looking for module
1113   for (int i = 0; i &lt; num_of_entries; i++) {
1114     ModuleClassPathList* module_cpl = module_list-&gt;at(i);
1115     Symbol* module_cpl_name = module_cpl-&gt;module_name();
1116 
1117     if (module_cpl_name-&gt;fast_compare(class_module_name) == 0) {
1118       // Class&#39; module has been located.
1119       return module_cpl-&gt;module_first_entry();
1120     }
1121   }
1122   return NULL;
1123 }
1124 
1125 
1126 // Search either the patch-module or exploded build entries for class.
1127 ClassFileStream* ClassLoader::search_module_entries(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list,
1128                                                     const char* const class_name,
1129                                                     const char* const file_name,
1130                                                     TRAPS) {
1131   ClassFileStream* stream = NULL;
1132 
1133   // Find the class&#39; defining module in the boot loader&#39;s module entry table
1134   TempNewSymbol class_name_symbol = SymbolTable::new_symbol(class_name);
1135   TempNewSymbol pkg_name = package_from_class_name(class_name_symbol);
1136   PackageEntry* pkg_entry = get_package_entry(pkg_name, ClassLoaderData::the_null_class_loader_data());
1137   ModuleEntry* mod_entry = (pkg_entry != NULL) ? pkg_entry-&gt;module() : NULL;
1138 
1139   // If the module system has not defined java.base yet, then
1140   // classes loaded are assumed to be defined to java.base.
1141   // When java.base is eventually defined by the module system,
1142   // all packages of classes that have been previously loaded
1143   // are verified in ModuleEntryTable::verify_javabase_packages().
1144   if (!Universe::is_module_initialized() &amp;&amp;
1145       !ModuleEntryTable::javabase_defined() &amp;&amp;
1146       mod_entry == NULL) {
1147     mod_entry = ModuleEntryTable::javabase_moduleEntry();
1148   }
1149 
1150   // The module must be a named module
1151   ClassPathEntry* e = NULL;
1152   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_named()) {
1153     if (module_list == _exploded_entries) {
1154       // The exploded build entries can be added to at any time so a lock is
1155       // needed when searching them.
1156       assert(!ClassLoader::has_jrt_entry(), &quot;Must be exploded build&quot;);
1157       MutexLocker ml(THREAD, Module_lock);
1158       e = find_first_module_cpe(mod_entry, module_list);
1159     } else {
1160       e = find_first_module_cpe(mod_entry, module_list);
1161     }
1162   }
1163 
1164   // Try to load the class from the module&#39;s ClassPathEntry list.
1165   while (e != NULL) {
1166     stream = e-&gt;open_stream(file_name, CHECK_NULL);
1167     // No context.check is required since CDS is not supported
1168     // for an exploded modules build or if --patch-module is specified.
1169     if (NULL != stream) {
1170       return stream;
1171     }
1172     e = e-&gt;next();
1173   }
1174   // If the module was located, break out even if the class was not
1175   // located successfully from that module&#39;s ClassPathEntry list.
1176   // There will not be another valid entry for that module.
1177   return NULL;
1178 }
1179 
1180 // Called by the boot classloader to load classes
1181 InstanceKlass* ClassLoader::load_class(Symbol* name, bool search_append_only, TRAPS) {
1182   assert(name != NULL, &quot;invariant&quot;);
1183   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1184 
1185   ResourceMark rm(THREAD);
1186   HandleMark hm(THREAD);
1187 
1188   const char* const class_name = name-&gt;as_C_string();
1189 
1190   EventMark m(&quot;loading class %s&quot;, class_name);
1191 
1192   const char* const file_name = file_name_for_class_name(class_name,
1193                                                          name-&gt;utf8_length());
1194   assert(file_name != NULL, &quot;invariant&quot;);
1195 
1196   // Lookup stream for parsing .class file
1197   ClassFileStream* stream = NULL;
1198   s2 classpath_index = 0;
1199   ClassPathEntry* e = NULL;
1200 
1201   // If search_append_only is true, boot loader visibility boundaries are
1202   // set to be _first_append_entry to the end. This includes:
1203   //   [-Xbootclasspath/a]; [jvmti appended entries]
1204   //
1205   // If search_append_only is false, boot loader visibility boundaries are
1206   // set to be the --patch-module entries plus the base piece. This includes:
1207   //   [--patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*]; [jimage | exploded module build]
1208   //
1209 
1210   // Load Attempt #1: --patch-module
1211   // Determine the class&#39; defining module.  If it appears in the _patch_mod_entries,
1212   // attempt to load the class from those locations specific to the module.
1213   // Specifications to --patch-module can contain a partial number of classes
1214   // that are part of the overall module definition.  So if a particular class is not
1215   // found within its module specification, the search should continue to Load Attempt #2.
1216   // Note: The --patch-module entries are never searched if the boot loader&#39;s
1217   //       visibility boundary is limited to only searching the append entries.
1218   if (_patch_mod_entries != NULL &amp;&amp; !search_append_only) {
1219     // At CDS dump time, the --patch-module entries are ignored. That means a
1220     // class is still loaded from the runtime image even if it might
1221     // appear in the _patch_mod_entries. The runtime shared class visibility
1222     // check will determine if a shared class is visible based on the runtime
1223     // environemnt, including the runtime --patch-module setting.
1224     //
1225     // DynamicDumpSharedSpaces requires UseSharedSpaces to be enabled. Since --patch-module
1226     // is not supported with UseSharedSpaces, it is not supported with DynamicDumpSharedSpaces.
1227     assert(!DynamicDumpSharedSpaces, &quot;sanity&quot;);
1228     if (!DumpSharedSpaces) {
1229       stream = search_module_entries(_patch_mod_entries, class_name, file_name, CHECK_NULL);
1230     }
1231   }
1232 
1233   // Load Attempt #2: [jimage | exploded build]
1234   if (!search_append_only &amp;&amp; (NULL == stream)) {
1235     if (has_jrt_entry()) {
1236       e = _jrt_entry;
1237       stream = _jrt_entry-&gt;open_stream(file_name, CHECK_NULL);
1238     } else {
1239       // Exploded build - attempt to locate class in its defining module&#39;s location.
1240       assert(_exploded_entries != NULL, &quot;No exploded build entries present&quot;);
1241       stream = search_module_entries(_exploded_entries, class_name, file_name, CHECK_NULL);
1242     }
1243   }
1244 
1245   // Load Attempt #3: [-Xbootclasspath/a]; [jvmti appended entries]
1246   if (search_append_only &amp;&amp; (NULL == stream)) {
1247     // For the boot loader append path search, the starting classpath_index
1248     // for the appended piece is always 1 to account for either the
1249     // _jrt_entry or the _exploded_entries.
1250     assert(classpath_index == 0, &quot;The classpath_index has been incremented incorrectly&quot;);
1251     classpath_index = 1;
1252 
1253     e = _first_append_entry;
1254     while (e != NULL) {
1255       stream = e-&gt;open_stream(file_name, CHECK_NULL);
1256       if (NULL != stream) {
1257         break;
1258       }
1259       e = e-&gt;next();
1260       ++classpath_index;
1261     }
1262   }
1263 
1264   if (NULL == stream) {
1265     return NULL;
1266   }
1267 
1268   stream-&gt;set_verify(ClassLoaderExt::should_verify(classpath_index));
1269 
1270   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
1271   Handle protection_domain;
1272   ClassLoadInfo cl_info(protection_domain);
1273 
1274   InstanceKlass* result = KlassFactory::create_from_stream(stream,
1275                                                            name,
1276                                                            loader_data,
1277                                                            cl_info,
1278                                                            THREAD);
1279   if (HAS_PENDING_EXCEPTION) {
1280     if (DumpSharedSpaces) {
1281       log_error(cds)(&quot;Preload Error: Failed to load %s&quot;, class_name);
1282     }
1283     return NULL;
1284   }
1285 
1286   result-&gt;set_classpath_index(classpath_index, THREAD);
1287   return result;
1288 }
1289 
1290 #if INCLUDE_CDS
1291 char* ClassLoader::skip_uri_protocol(char* source) {
1292   if (strncmp(source, &quot;file:&quot;, 5) == 0) {
1293     // file: protocol path could start with file:/ or file:///
1294     // locate the char after all the forward slashes
1295     int offset = 5;
1296     while (*(source + offset) == &#39;/&#39;) {
1297         offset++;
1298     }
1299     source += offset;
1300   // for non-windows platforms, move back one char as the path begins with a &#39;/&#39;
1301 #ifndef _WINDOWS
1302     source -= 1;
1303 #endif
1304   } else if (strncmp(source, &quot;jrt:/&quot;, 5) == 0) {
1305     source += 5;
1306   }
1307   return source;
1308 }
1309 
1310 // Record the shared classpath index and loader type for classes loaded
1311 // by the builtin loaders at dump time.
1312 void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {
1313   Arguments::assert_is_dumping_archive();
1314   assert(stream != NULL, &quot;sanity&quot;);
1315 
1316   if (ik-&gt;is_hidden() || ik-&gt;is_unsafe_anonymous()) {
1317     // We do not archive hidden or unsafe anonymous classes.
1318     return;
1319   }
1320 
1321   oop loader = ik-&gt;class_loader();
1322   char* src = (char*)stream-&gt;source();
1323   if (src == NULL) {
1324     if (loader == NULL) {
1325       // JFR classes
1326       ik-&gt;set_shared_classpath_index(0);
1327       ik-&gt;set_shared_class_loader_type(ClassLoader::BOOT_LOADER);
1328     }
1329     return;
1330   }
1331 
1332   assert(has_jrt_entry(), &quot;CDS dumping does not support exploded JDK build&quot;);
1333 
1334   ResourceMark rm(THREAD);
1335   int classpath_index = -1;
1336   PackageEntry* pkg_entry = ik-&gt;package();
1337 
1338   if (FileMapInfo::get_number_of_shared_paths() &gt; 0) {
1339     char* canonical_path_table_entry = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, JVM_MAXPATHLEN);
1340 
1341     // save the path from the file: protocol or the module name from the jrt: protocol
1342     // if no protocol prefix is found, path is the same as stream-&gt;source()
1343     char* path = skip_uri_protocol(src);
1344     char* canonical_class_src_path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, JVM_MAXPATHLEN);
1345     bool success = get_canonical_path(path, canonical_class_src_path, JVM_MAXPATHLEN);
1346     // The path is from the ClassFileStream. Since a ClassFileStream has been created successfully in functions
1347     // such as ClassLoader::load_class(), its source path must be valid.
1348     assert(success, &quot;must be valid path&quot;);
1349     for (int i = 0; i &lt; FileMapInfo::get_number_of_shared_paths(); i++) {
1350       SharedClassPathEntry* ent = FileMapInfo::shared_path(i);
1351       success = get_canonical_path(ent-&gt;name(), canonical_path_table_entry, JVM_MAXPATHLEN);
1352       // A shared path has been validated during its creation in ClassLoader::create_class_path_entry(),
1353       // it must be valid here.
1354       assert(success, &quot;must be valid path&quot;);
1355       // If the path (from the class stream source) is the same as the shared
1356       // class or module path, then we have a match.
1357       if (strcmp(canonical_path_table_entry, canonical_class_src_path) == 0) {
1358         // NULL pkg_entry and pkg_entry in an unnamed module implies the class
1359         // is from the -cp or boot loader append path which consists of -Xbootclasspath/a
1360         // and jvmti appended entries.
1361         if ((pkg_entry == NULL) || (pkg_entry-&gt;in_unnamed_module())) {
1362           // Ensure the index is within the -cp range before assigning
1363           // to the classpath_index.
1364           if (SystemDictionary::is_system_class_loader(loader) &amp;&amp;
1365               (i &gt;= ClassLoaderExt::app_class_paths_start_index()) &amp;&amp;
1366               (i &lt; ClassLoaderExt::app_module_paths_start_index())) {
1367             classpath_index = i;
1368             break;
1369           } else {
1370             if ((i &gt;= 1) &amp;&amp;
1371                 (i &lt; ClassLoaderExt::app_class_paths_start_index())) {
1372               // The class must be from boot loader append path which consists of
1373               // -Xbootclasspath/a and jvmti appended entries.
1374               assert(loader == NULL, &quot;sanity&quot;);
1375               classpath_index = i;
1376               break;
1377             }
1378           }
1379         } else {
1380           // A class from a named module from the --module-path. Ensure the index is
1381           // within the --module-path range before assigning to the classpath_index.
1382           if ((pkg_entry != NULL) &amp;&amp; !(pkg_entry-&gt;in_unnamed_module()) &amp;&amp; (i &gt; 0)) {
1383             if (i &gt;= ClassLoaderExt::app_module_paths_start_index() &amp;&amp;
1384                 i &lt; FileMapInfo::get_number_of_shared_paths()) {
1385               classpath_index = i;
1386               break;
1387             }
1388           }
1389         }
1390       }
1391       // for index 0 and the stream-&gt;source() is the modules image or has the jrt: protocol.
1392       // The class must be from the runtime modules image.
1393       if (i == 0 &amp;&amp; (stream-&gt;from_boot_loader_modules_image() || string_starts_with(src, &quot;jrt:&quot;))) {
1394         classpath_index = i;
1395         break;
1396       }
1397     }
1398 
1399     // No path entry found for this class. Must be a shared class loaded by the
1400     // user defined classloader.
1401     if (classpath_index &lt; 0) {
1402       assert(ik-&gt;shared_classpath_index() &lt; 0, &quot;Sanity&quot;);
1403       ik-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);
1404       SystemDictionaryShared::set_shared_class_misc_info(ik, (ClassFileStream*)stream);
1405       return;
1406     }
1407   } else {
1408     // The shared path table is set up after module system initialization.
1409     // The path table contains no entry before that. Any classes loaded prior
1410     // to the setup of the shared path table must be from the modules image.
1411     assert(stream-&gt;from_boot_loader_modules_image(), &quot;stream must be loaded by boot loader from modules image&quot;);
1412     assert(FileMapInfo::get_number_of_shared_paths() == 0, &quot;shared path table must not have been setup&quot;);
1413     classpath_index = 0;
1414   }
1415 
1416   const char* const class_name = ik-&gt;name()-&gt;as_C_string();
1417   const char* const file_name = file_name_for_class_name(class_name,
1418                                                          ik-&gt;name()-&gt;utf8_length());
1419   assert(file_name != NULL, &quot;invariant&quot;);
1420 
1421   ClassLoaderExt::record_result(classpath_index, ik, THREAD);
1422 }
1423 #endif // INCLUDE_CDS
1424 
1425 // Initialize the class loader&#39;s access to methods in libzip.  Parse and
1426 // process the boot classpath into a list ClassPathEntry objects.  Once
1427 // this list has been created, it must not change order (see class PackageInfo)
1428 // it can be appended to and is by jvmti and the kernel vm.
1429 
1430 void ClassLoader::initialize() {
1431   EXCEPTION_MARK;
1432 
1433   if (UsePerfData) {
1434     // jvmstat performance counters
1435     NEWPERFTICKCOUNTER(_perf_accumulated_time, SUN_CLS, &quot;time&quot;);
1436     NEWPERFTICKCOUNTER(_perf_class_init_time, SUN_CLS, &quot;classInitTime&quot;);
1437     NEWPERFTICKCOUNTER(_perf_class_init_selftime, SUN_CLS, &quot;classInitTime.self&quot;);
1438     NEWPERFTICKCOUNTER(_perf_class_verify_time, SUN_CLS, &quot;classVerifyTime&quot;);
1439     NEWPERFTICKCOUNTER(_perf_class_verify_selftime, SUN_CLS, &quot;classVerifyTime.self&quot;);
1440     NEWPERFTICKCOUNTER(_perf_class_link_time, SUN_CLS, &quot;classLinkedTime&quot;);
1441     NEWPERFTICKCOUNTER(_perf_class_link_selftime, SUN_CLS, &quot;classLinkedTime.self&quot;);
1442     NEWPERFEVENTCOUNTER(_perf_classes_inited, SUN_CLS, &quot;initializedClasses&quot;);
1443     NEWPERFEVENTCOUNTER(_perf_classes_linked, SUN_CLS, &quot;linkedClasses&quot;);
1444     NEWPERFEVENTCOUNTER(_perf_classes_verified, SUN_CLS, &quot;verifiedClasses&quot;);
1445 
1446     NEWPERFTICKCOUNTER(_perf_sys_class_lookup_time, SUN_CLS, &quot;lookupSysClassTime&quot;);
1447     NEWPERFTICKCOUNTER(_perf_shared_classload_time, SUN_CLS, &quot;sharedClassLoadTime&quot;);
1448     NEWPERFTICKCOUNTER(_perf_sys_classload_time, SUN_CLS, &quot;sysClassLoadTime&quot;);
1449     NEWPERFTICKCOUNTER(_perf_app_classload_time, SUN_CLS, &quot;appClassLoadTime&quot;);
1450     NEWPERFTICKCOUNTER(_perf_app_classload_selftime, SUN_CLS, &quot;appClassLoadTime.self&quot;);
1451     NEWPERFEVENTCOUNTER(_perf_app_classload_count, SUN_CLS, &quot;appClassLoadCount&quot;);
1452     NEWPERFTICKCOUNTER(_perf_define_appclasses, SUN_CLS, &quot;defineAppClasses&quot;);
1453     NEWPERFTICKCOUNTER(_perf_define_appclass_time, SUN_CLS, &quot;defineAppClassTime&quot;);
1454     NEWPERFTICKCOUNTER(_perf_define_appclass_selftime, SUN_CLS, &quot;defineAppClassTime.self&quot;);
1455     NEWPERFBYTECOUNTER(_perf_app_classfile_bytes_read, SUN_CLS, &quot;appClassBytes&quot;);
1456     NEWPERFBYTECOUNTER(_perf_sys_classfile_bytes_read, SUN_CLS, &quot;sysClassBytes&quot;);
1457 
1458 
1459     // The following performance counters are added for measuring the impact
1460     // of the bug fix of 6365597. They are mainly focused on finding out
1461     // the behavior of system &amp; user-defined classloader lock, whether
1462     // ClassLoader.loadClass/findClass is being called synchronized or not.
1463     NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,
1464                         &quot;systemLoaderLockContentionRate&quot;);
1465     NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,
1466                         &quot;nonSystemLoaderLockContentionRate&quot;);
1467     NEWPERFEVENTCOUNTER(_sync_JVMFindLoadedClassLockFreeCounter, SUN_CLS,
1468                         &quot;jvmFindLoadedClassNoLockCalls&quot;);
1469     NEWPERFEVENTCOUNTER(_sync_JVMDefineClassLockFreeCounter, SUN_CLS,
1470                         &quot;jvmDefineClassNoLockCalls&quot;);
1471 
1472     NEWPERFEVENTCOUNTER(_sync_JNIDefineClassLockFreeCounter, SUN_CLS,
1473                         &quot;jniDefineClassNoLockCalls&quot;);
1474 
1475     NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,
1476                         &quot;unsafeDefineClassCalls&quot;);
1477   }
1478 
1479   // lookup java library entry points
1480   load_java_library();
1481   // jimage library entry points are loaded below, in lookup_vm_options
1482   setup_bootstrap_search_path();
1483 }
1484 
1485 char* lookup_vm_resource(JImageFile *jimage, const char *jimage_version, const char *path) {
1486   jlong size;
1487   JImageLocationRef location = (*JImageFindResource)(jimage, &quot;java.base&quot;, jimage_version, path, &amp;size);
1488   if (location == 0)
1489     return NULL;
1490   char *val = NEW_C_HEAP_ARRAY(char, size+1, mtClass);
1491   (*JImageGetResource)(jimage, location, val, size);
1492   val[size] = &#39;\0&#39;;
1493   return val;
1494 }
1495 
1496 // Lookup VM options embedded in the modules jimage file
1497 char* ClassLoader::lookup_vm_options() {
1498   jint error;
1499   char modules_path[JVM_MAXPATHLEN];
1500   const char* fileSep = os::file_separator();
1501 
1502   // Initialize jimage library entry points
1503   load_jimage_library();
1504 
1505   jio_snprintf(modules_path, JVM_MAXPATHLEN, &quot;%s%slib%smodules&quot;, Arguments::get_java_home(), fileSep, fileSep);
1506   JImageFile* jimage =(*JImageOpen)(modules_path, &amp;error);
1507   if (jimage == NULL) {
1508     return NULL;
1509   }
1510 
1511   const char *jimage_version = get_jimage_version_string();
1512   char *options = lookup_vm_resource(jimage, jimage_version, &quot;jdk/internal/vm/options&quot;);
1513 
1514   (*JImageClose)(jimage);
1515   return options;
1516 }
1517 
1518 #if INCLUDE_CDS
1519 void ClassLoader::initialize_shared_path() {
1520   if (Arguments::is_dumping_archive()) {
1521     ClassLoaderExt::setup_search_paths();
1522   }
1523 }
1524 
1525 void ClassLoader::initialize_module_path(TRAPS) {
1526   if (Arguments::is_dumping_archive()) {
1527     ClassLoaderExt::setup_module_paths(THREAD);
1528     FileMapInfo::allocate_shared_path_table();
1529   }
1530 }
1531 
1532 // Helper function used by CDS code to get the number of module path
1533 // entries during shared classpath setup time.
1534 int ClassLoader::num_module_path_entries() {
1535   Arguments::assert_is_dumping_archive();
1536   int num_entries = 0;
1537   ClassPathEntry* e= ClassLoader::_module_path_entries;
1538   while (e != NULL) {
1539     num_entries ++;
1540     e = e-&gt;next();
1541   }
1542   return num_entries;
1543 }
1544 #endif
1545 
1546 jlong ClassLoader::classloader_time_ms() {
1547   return UsePerfData ?
1548     Management::ticks_to_ms(_perf_accumulated_time-&gt;get_value()) : -1;
1549 }
1550 
1551 jlong ClassLoader::class_init_count() {
1552   return UsePerfData ? _perf_classes_inited-&gt;get_value() : -1;
1553 }
1554 
1555 jlong ClassLoader::class_init_time_ms() {
1556   return UsePerfData ?
1557     Management::ticks_to_ms(_perf_class_init_time-&gt;get_value()) : -1;
1558 }
1559 
1560 jlong ClassLoader::class_verify_time_ms() {
1561   return UsePerfData ?
1562     Management::ticks_to_ms(_perf_class_verify_time-&gt;get_value()) : -1;
1563 }
1564 
1565 jlong ClassLoader::class_link_count() {
1566   return UsePerfData ? _perf_classes_linked-&gt;get_value() : -1;
1567 }
1568 
1569 jlong ClassLoader::class_link_time_ms() {
1570   return UsePerfData ?
1571     Management::ticks_to_ms(_perf_class_link_time-&gt;get_value()) : -1;
1572 }
1573 
1574 int ClassLoader::compute_Object_vtable() {
1575   // hardwired for JDK1.2 -- would need to duplicate class file parsing
1576   // code to determine actual value from file
1577   // Would be value &#39;11&#39; if finals were in vtable
1578   int JDK_1_2_Object_vtable_size = 5;
1579   return JDK_1_2_Object_vtable_size * vtableEntry::size();
1580 }
1581 
1582 
1583 void classLoader_init1() {
1584   ClassLoader::initialize();
1585 }
1586 
1587 // Complete the ClassPathEntry setup for the boot loader
1588 void ClassLoader::classLoader_init2(TRAPS) {
1589   // Setup the list of module/path pairs for --patch-module processing
1590   // This must be done after the SymbolTable is created in order
1591   // to use fast_compare on module names instead of a string compare.
1592   if (Arguments::get_patch_mod_prefix() != NULL) {
1593     setup_patch_mod_entries();
1594   }
1595 
1596   // Create the ModuleEntry for java.base (must occur after setup_patch_mod_entries
1597   // to successfully determine if java.base has been patched)
1598   create_javabase();
1599 
1600   // Setup the initial java.base/path pair for the exploded build entries.
1601   // As more modules are defined during module system initialization, more
1602   // entries will be added to the exploded build array.
1603   if (!has_jrt_entry()) {
1604     assert(!DumpSharedSpaces, &quot;DumpSharedSpaces not supported with exploded module builds&quot;);
1605     assert(!DynamicDumpSharedSpaces, &quot;DynamicDumpSharedSpaces not supported with exploded module builds&quot;);
1606     assert(!UseSharedSpaces, &quot;UsedSharedSpaces not supported with exploded module builds&quot;);
1607     // Set up the boot loader&#39;s _exploded_entries list.  Note that this gets
1608     // done before loading any classes, by the same thread that will
1609     // subsequently do the first class load. So, no lock is needed for this.
1610     assert(_exploded_entries == NULL, &quot;Should only get initialized once&quot;);
1611     _exploded_entries = new (ResourceObj::C_HEAP, mtModule)
1612       GrowableArray&lt;ModuleClassPathList*&gt;(EXPLODED_ENTRY_SIZE, true);
1613     add_to_exploded_build_list(vmSymbols::java_base(), CHECK);
1614   }
1615 }
1616 
1617 bool ClassLoader::get_canonical_path(const char* orig, char* out, int len) {
1618   assert(orig != NULL &amp;&amp; out != NULL &amp;&amp; len &gt; 0, &quot;bad arguments&quot;);
1619   JavaThread* THREAD = JavaThread::current();
1620   ResourceMark rm(THREAD);
1621 
1622   // os::native_path writes into orig_copy
1623   char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(orig)+1);
1624   strcpy(orig_copy, orig);
1625   if ((CanonicalizeEntry)(os::native_path(orig_copy), out, len) &lt; 0) {
1626     return false;
1627   }
1628   return true;
1629 }
1630 
1631 void ClassLoader::create_javabase() {
1632   Thread* THREAD = Thread::current();
1633 
1634   // Create java.base&#39;s module entry for the boot
1635   // class loader prior to loading j.l.Ojbect.
1636   ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
1637 
1638   // Get module entry table
1639   ModuleEntryTable* null_cld_modules = null_cld-&gt;modules();
1640   if (null_cld_modules == NULL) {
1641     vm_exit_during_initialization(&quot;No ModuleEntryTable for the boot class loader&quot;);
1642   }
1643 
1644   {
1645     MutexLocker ml(THREAD, Module_lock);
1646     ModuleEntry* jb_module = null_cld_modules-&gt;locked_create_entry(Handle(),
1647                                false, vmSymbols::java_base(), NULL, NULL, null_cld);
1648     if (jb_module == NULL) {
1649       vm_exit_during_initialization(&quot;Unable to create ModuleEntry for &quot; JAVA_BASE_NAME);
1650     }
1651     ModuleEntryTable::set_javabase_moduleEntry(jb_module);
1652   }
1653 }
1654 
1655 // Please keep following two functions at end of this file. With them placed at top or in middle of the file,
1656 // they could get inlined by agressive compiler, an unknown trick, see bug 6966589.
1657 void PerfClassTraceTime::initialize() {
1658   if (!UsePerfData) return;
1659 
1660   if (_eventp != NULL) {
1661     // increment the event counter
1662     _eventp-&gt;inc();
1663   }
1664 
1665   // stop the current active thread-local timer to measure inclusive time
1666   _prev_active_event = -1;
1667   for (int i=0; i &lt; EVENT_TYPE_COUNT; i++) {
1668      if (_timers[i].is_active()) {
1669        assert(_prev_active_event == -1, &quot;should have only one active timer&quot;);
1670        _prev_active_event = i;
1671        _timers[i].stop();
1672      }
1673   }
1674 
1675   if (_recursion_counters == NULL || (_recursion_counters[_event_type])++ == 0) {
1676     // start the inclusive timer if not recursively called
1677     _t.start();
1678   }
1679 
1680   // start thread-local timer of the given event type
1681    if (!_timers[_event_type].is_active()) {
1682     _timers[_event_type].start();
1683   }
1684 }
1685 
1686 PerfClassTraceTime::~PerfClassTraceTime() {
1687   if (!UsePerfData) return;
1688 
1689   // stop the thread-local timer as the event completes
1690   // and resume the thread-local timer of the event next on the stack
1691   _timers[_event_type].stop();
1692   jlong selftime = _timers[_event_type].ticks();
1693 
1694   if (_prev_active_event &gt;= 0) {
1695     _timers[_prev_active_event].start();
1696   }
1697 
1698   if (_recursion_counters != NULL &amp;&amp; --(_recursion_counters[_event_type]) &gt; 0) return;
1699 
1700   // increment the counters only on the leaf call
1701   _t.stop();
1702   _timep-&gt;inc(_t.ticks());
1703   if (_selftimep != NULL) {
1704     _selftimep-&gt;inc(selftime);
1705   }
1706   // add all class loading related event selftime to the accumulated time counter
1707   ClassLoader::perf_accumulated_time()-&gt;inc(selftime);
1708 
1709   // reset the timer
1710   _timers[_event_type].reset();
1711 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/klassVtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klassVtable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1099 
1100 
1101     // Iterate through all interfaces
1102     int i;
1103     for(i = 0; i &lt; num_interfaces; i++) {
1104       itableOffsetEntry* ioe = offset_entry(i);
1105       HandleMark hm(THREAD);
1106       Klass* interf = ioe-&gt;interface_klass();
1107       assert(interf != NULL &amp;&amp; ioe-&gt;offset() != 0, &quot;bad offset entry in itable&quot;);
1108       initialize_itable_for_interface(ioe-&gt;offset(), InstanceKlass::cast(interf), checkconstraints, CHECK);
1109     }
1110 
1111   }
1112   // Check that the last entry is empty
1113   itableOffsetEntry* ioe = offset_entry(size_offset_table() - 1);
1114   guarantee(ioe-&gt;interface_klass() == NULL &amp;&amp; ioe-&gt;offset() == 0, &quot;terminator entry missing&quot;);
1115 }
1116 
1117 
1118 inline bool interface_method_needs_itable_index(Method* m) {
<span class="line-modified">1119   if (m-&gt;is_static())           return false;   // e.g., Stream.empty</span>
<span class="line-modified">1120   if (m-&gt;is_initializer())      return false;   // &lt;init&gt; or &lt;clinit&gt;</span>
<span class="line-modified">1121   if (m-&gt;is_private())          return false;   // uses direct call</span>

1122   // If an interface redeclares a method from java.lang.Object,
1123   // it should already have a vtable index, don&#39;t touch it.
1124   // e.g., CharSequence.toString (from initialize_vtable)
1125   // if (m-&gt;has_vtable_index())  return false; // NO!
1126   return true;
1127 }
1128 
1129 int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS) {
1130   // an interface does not have an itable, but its methods need to be numbered
1131   ResourceMark rm(THREAD);
1132   log_develop_debug(itables)(&quot;%3d: Initializing itable indices for interface %s&quot;,
1133                              ++initialize_count, klass-&gt;name()-&gt;as_C_string());
1134   Array&lt;Method*&gt;* methods = klass-&gt;methods();
1135   int nof_methods = methods-&gt;length();
1136   int ime_num = 0;
1137   for (int i = 0; i &lt; nof_methods; i++) {
1138     Method* m = methods-&gt;at(i);
1139     if (interface_method_needs_itable_index(m)) {
1140       assert(!m-&gt;is_final_method(), &quot;no final interface methods&quot;);
1141       // If m is already assigned a vtable index, do not disturb it.
</pre>
<hr />
<pre>
1334       tty-&gt;print(&quot;      (%5d)  &quot;, i);
1335       m-&gt;access_flags().print_on(tty);
1336       if (m-&gt;is_default_method()) {
1337         tty-&gt;print(&quot;default &quot;);
1338       }
1339       tty-&gt;print(&quot; --  &quot;);
1340       m-&gt;print_name(tty);
1341       tty-&gt;cr();
1342     }
1343     ime++;
1344   }
1345 }
1346 #endif // INCLUDE_JVMTI
1347 
1348 // Setup
1349 class InterfaceVisiterClosure : public StackObj {
1350  public:
1351   virtual void doit(InstanceKlass* intf, int method_count) = 0;
1352 };
1353 












1354 // Visit all interfaces with at least one itable method
1355 void visit_all_interfaces(Array&lt;InstanceKlass*&gt;* transitive_intf, InterfaceVisiterClosure *blk) {
1356   // Handle array argument
1357   for(int i = 0; i &lt; transitive_intf-&gt;length(); i++) {
1358     InstanceKlass* intf = transitive_intf-&gt;at(i);
1359     assert(intf-&gt;is_interface(), &quot;sanity check&quot;);
1360 
1361     // Find no. of itable methods
1362     int method_count = 0;
1363     // method_count = klassItable::method_count_for_interface(intf);
1364     Array&lt;Method*&gt;* methods = intf-&gt;methods();
1365     if (methods-&gt;length() &gt; 0) {
1366       for (int i = methods-&gt;length(); --i &gt;= 0; ) {
1367         if (interface_method_needs_itable_index(methods-&gt;at(i))) {
1368           method_count++;
1369         }
1370       }
1371     }
1372 
1373     // Visit all interfaces which either have any methods or can participate in receiver type check.
</pre>
<hr />
<pre>
1402     _klass_begin  = klass_begin;
1403     _offset_entry = offset_entry;
1404     _method_entry = method_entry;
1405   }
1406 
1407   itableMethodEntry* method_entry() const { return _method_entry; }
1408 
1409   void doit(InstanceKlass* intf, int method_count) {
1410     int offset = ((address)_method_entry) - _klass_begin;
1411     _offset_entry-&gt;initialize(intf, offset);
1412     _offset_entry++;
1413     _method_entry += method_count;
1414   }
1415 };
1416 
1417 int klassItable::compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
1418   // Count no of interfaces and total number of interface methods
1419   CountInterfacesClosure cic;
1420   visit_all_interfaces(transitive_interfaces, &amp;cic);
1421 
<span class="line-modified">1422   // There&#39;s alway an extra itable entry so we can null-terminate it.</span>
1423   int itable_size = calc_itable_size(cic.nof_interfaces() + 1, cic.nof_methods());
1424 
1425   // Statistics
1426   update_stats(itable_size * wordSize);
1427 
1428   return itable_size;
1429 }
1430 
1431 
1432 // Fill out offset table and interface klasses into the itable space
1433 void klassItable::setup_itable_offset_table(InstanceKlass* klass) {
1434   if (klass-&gt;itable_length() == 0) return;
1435   assert(!klass-&gt;is_interface(), &quot;Should have zero length itable&quot;);
1436 
1437   // Count no of interfaces and total number of interface methods
1438   CountInterfacesClosure cic;
1439   visit_all_interfaces(klass-&gt;transitive_interfaces(), &amp;cic);
1440   int nof_methods    = cic.nof_methods();
1441   int nof_interfaces = cic.nof_interfaces();
1442 
</pre>
</td>
<td>
<hr />
<pre>
1099 
1100 
1101     // Iterate through all interfaces
1102     int i;
1103     for(i = 0; i &lt; num_interfaces; i++) {
1104       itableOffsetEntry* ioe = offset_entry(i);
1105       HandleMark hm(THREAD);
1106       Klass* interf = ioe-&gt;interface_klass();
1107       assert(interf != NULL &amp;&amp; ioe-&gt;offset() != 0, &quot;bad offset entry in itable&quot;);
1108       initialize_itable_for_interface(ioe-&gt;offset(), InstanceKlass::cast(interf), checkconstraints, CHECK);
1109     }
1110 
1111   }
1112   // Check that the last entry is empty
1113   itableOffsetEntry* ioe = offset_entry(size_offset_table() - 1);
1114   guarantee(ioe-&gt;interface_klass() == NULL &amp;&amp; ioe-&gt;offset() == 0, &quot;terminator entry missing&quot;);
1115 }
1116 
1117 
1118 inline bool interface_method_needs_itable_index(Method* m) {
<span class="line-modified">1119   if (m-&gt;is_static())             return false;   // e.g., Stream.empty</span>
<span class="line-modified">1120   if (m-&gt;is_private())            return false;   // uses direct call</span>
<span class="line-modified">1121   if (m-&gt;is_object_constructor()) return false;   // &lt;init&gt;(...)V</span>
<span class="line-added">1122   if (m-&gt;is_class_initializer())  return false;   // &lt;clinit&gt;()V</span>
1123   // If an interface redeclares a method from java.lang.Object,
1124   // it should already have a vtable index, don&#39;t touch it.
1125   // e.g., CharSequence.toString (from initialize_vtable)
1126   // if (m-&gt;has_vtable_index())  return false; // NO!
1127   return true;
1128 }
1129 
1130 int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS) {
1131   // an interface does not have an itable, but its methods need to be numbered
1132   ResourceMark rm(THREAD);
1133   log_develop_debug(itables)(&quot;%3d: Initializing itable indices for interface %s&quot;,
1134                              ++initialize_count, klass-&gt;name()-&gt;as_C_string());
1135   Array&lt;Method*&gt;* methods = klass-&gt;methods();
1136   int nof_methods = methods-&gt;length();
1137   int ime_num = 0;
1138   for (int i = 0; i &lt; nof_methods; i++) {
1139     Method* m = methods-&gt;at(i);
1140     if (interface_method_needs_itable_index(m)) {
1141       assert(!m-&gt;is_final_method(), &quot;no final interface methods&quot;);
1142       // If m is already assigned a vtable index, do not disturb it.
</pre>
<hr />
<pre>
1335       tty-&gt;print(&quot;      (%5d)  &quot;, i);
1336       m-&gt;access_flags().print_on(tty);
1337       if (m-&gt;is_default_method()) {
1338         tty-&gt;print(&quot;default &quot;);
1339       }
1340       tty-&gt;print(&quot; --  &quot;);
1341       m-&gt;print_name(tty);
1342       tty-&gt;cr();
1343     }
1344     ime++;
1345   }
1346 }
1347 #endif // INCLUDE_JVMTI
1348 
1349 // Setup
1350 class InterfaceVisiterClosure : public StackObj {
1351  public:
1352   virtual void doit(InstanceKlass* intf, int method_count) = 0;
1353 };
1354 
<span class="line-added">1355 int count_interface_methods_needing_itable_index(Array&lt;Method*&gt;* methods) {</span>
<span class="line-added">1356   int method_count = 0;</span>
<span class="line-added">1357   if (methods-&gt;length() &gt; 0) {</span>
<span class="line-added">1358     for (int i = methods-&gt;length(); --i &gt;= 0; ) {</span>
<span class="line-added">1359       if (interface_method_needs_itable_index(methods-&gt;at(i))) {</span>
<span class="line-added">1360         method_count++;</span>
<span class="line-added">1361       }</span>
<span class="line-added">1362     }</span>
<span class="line-added">1363   }</span>
<span class="line-added">1364   return method_count;</span>
<span class="line-added">1365 }</span>
<span class="line-added">1366 </span>
1367 // Visit all interfaces with at least one itable method
1368 void visit_all_interfaces(Array&lt;InstanceKlass*&gt;* transitive_intf, InterfaceVisiterClosure *blk) {
1369   // Handle array argument
1370   for(int i = 0; i &lt; transitive_intf-&gt;length(); i++) {
1371     InstanceKlass* intf = transitive_intf-&gt;at(i);
1372     assert(intf-&gt;is_interface(), &quot;sanity check&quot;);
1373 
1374     // Find no. of itable methods
1375     int method_count = 0;
1376     // method_count = klassItable::method_count_for_interface(intf);
1377     Array&lt;Method*&gt;* methods = intf-&gt;methods();
1378     if (methods-&gt;length() &gt; 0) {
1379       for (int i = methods-&gt;length(); --i &gt;= 0; ) {
1380         if (interface_method_needs_itable_index(methods-&gt;at(i))) {
1381           method_count++;
1382         }
1383       }
1384     }
1385 
1386     // Visit all interfaces which either have any methods or can participate in receiver type check.
</pre>
<hr />
<pre>
1415     _klass_begin  = klass_begin;
1416     _offset_entry = offset_entry;
1417     _method_entry = method_entry;
1418   }
1419 
1420   itableMethodEntry* method_entry() const { return _method_entry; }
1421 
1422   void doit(InstanceKlass* intf, int method_count) {
1423     int offset = ((address)_method_entry) - _klass_begin;
1424     _offset_entry-&gt;initialize(intf, offset);
1425     _offset_entry++;
1426     _method_entry += method_count;
1427   }
1428 };
1429 
1430 int klassItable::compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
1431   // Count no of interfaces and total number of interface methods
1432   CountInterfacesClosure cic;
1433   visit_all_interfaces(transitive_interfaces, &amp;cic);
1434 
<span class="line-modified">1435   // There&#39;s always an extra itable entry so we can null-terminate it.</span>
1436   int itable_size = calc_itable_size(cic.nof_interfaces() + 1, cic.nof_methods());
1437 
1438   // Statistics
1439   update_stats(itable_size * wordSize);
1440 
1441   return itable_size;
1442 }
1443 
1444 
1445 // Fill out offset table and interface klasses into the itable space
1446 void klassItable::setup_itable_offset_table(InstanceKlass* klass) {
1447   if (klass-&gt;itable_length() == 0) return;
1448   assert(!klass-&gt;is_interface(), &quot;Should have zero length itable&quot;);
1449 
1450   // Count no of interfaces and total number of interface methods
1451   CountInterfacesClosure cic;
1452   visit_all_interfaces(klass-&gt;transitive_interfaces(), &amp;cic);
1453   int nof_methods    = cic.nof_methods();
1454   int nof_interfaces = cic.nof_interfaces();
1455 
</pre>
</td>
</tr>
</table>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
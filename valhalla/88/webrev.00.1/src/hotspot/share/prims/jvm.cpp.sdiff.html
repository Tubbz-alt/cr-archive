<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/klassVtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;
  54 #include &quot;oops/instanceKlass.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/recordComponent.hpp&quot;
  57 #include &quot;oops/objArrayKlass.hpp&quot;
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;

  60 #include &quot;prims/jvm_misc.hpp&quot;
  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;prims/nativeLookup.hpp&quot;
  64 #include &quot;prims/stackwalk.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/init.hpp&quot;
  69 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  70 #include &quot;runtime/deoptimization.hpp&quot;
  71 #include &quot;runtime/handshake.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/os.inline.hpp&quot;
  77 #include &quot;runtime/perfData.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/synchronizer.hpp&quot;
</pre>
<hr />
<pre>
 696   JVMWrapper(&quot;JVM_Clone&quot;);
 697   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 698   Klass* klass = obj-&gt;klass();
 699   JvmtiVMObjectAllocEventCollector oam;
 700 
 701 #ifdef ASSERT
 702   // Just checking that the cloneable flag is set correct
 703   if (obj-&gt;is_array()) {
 704     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 705   } else {
 706     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 707     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 708     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 709   }
 710 #endif
 711 
 712   // Check if class of obj supports the Cloneable interface.
 713   // All arrays are considered to be cloneable (See JLS 20.1.5).
 714   // All j.l.r.Reference classes are considered non-cloneable.
 715   if (!klass-&gt;is_cloneable() ||

 716       (klass-&gt;is_instance_klass() &amp;&amp;
 717        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 718     ResourceMark rm(THREAD);
 719     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 720   }
 721 
 722   // Make shallow object copy
 723   const int size = obj-&gt;size();
 724   oop new_obj_oop = NULL;
 725   if (obj-&gt;is_array()) {
 726     const int length = ((arrayOop)obj())-&gt;length();
 727     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 728                                                    /* do_zero */ true, CHECK_NULL);
 729   } else {
 730     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 731   }
 732 
 733   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 734 
 735   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1239   return (jstring) JNIHandles::make_local(env, result);
1240 JVM_END
1241 
1242 
1243 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1244   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1245   JvmtiVMObjectAllocEventCollector oam;
1246   oop mirror = JNIHandles::resolve_non_null(cls);
1247 
1248   // Special handling for primitive objects
1249   if (java_lang_Class::is_primitive(mirror)) {
1250     // Primitive objects does not have any interfaces
1251     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1252     return (jobjectArray) JNIHandles::make_local(env, r);
1253   }
1254 
1255   Klass* klass = java_lang_Class::as_Klass(mirror);
1256   // Figure size of result array
1257   int size;
1258   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1259     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();</span>




1260   } else {
1261     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1262     size = 2;</span>
1263   }
1264 
1265   // Allocate result array
1266   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1267   objArrayHandle result (THREAD, r);
1268   // Fill in result
1269   if (klass-&gt;is_instance_klass()) {
1270     // Regular instance klass, fill in all local interfaces

1271     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1272       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-modified">1273       result-&gt;obj_at_put(index, k-&gt;java_mirror());</span>



1274     }
1275   } else {
<span class="line-modified">1276     // All arrays implement java.lang.Cloneable and java.io.Serializable</span>
1277     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1278     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());

1279   }
1280   return (jobjectArray) JNIHandles::make_local(env, result());
1281 JVM_END
1282 
1283 
1284 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1285   JVMWrapper(&quot;JVM_IsInterface&quot;);
1286   oop mirror = JNIHandles::resolve_non_null(cls);
1287   if (java_lang_Class::is_primitive(mirror)) {
1288     return JNI_FALSE;
1289   }
1290   Klass* k = java_lang_Class::as_Klass(mirror);
1291   jboolean result = k-&gt;is_interface();
1292   assert(!result || k-&gt;is_instance_klass(),
1293          &quot;all interfaces are instance types&quot;);
1294   // The compiler intrinsic for isInterface tests the
1295   // Klass::_access_flags bits in the same way.
1296   return result;
1297 JVM_END
1298 
</pre>
<hr />
<pre>
1878         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1879       objArrayHandle components_h (THREAD, record_components);
1880 
1881       for (int x = 0; x &lt; length; x++) {
1882         RecordComponent* component = components-&gt;at(x);
1883         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1884         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1885         components_h-&gt;obj_at_put(x, component_oop);
1886       }
1887       return (jobjectArray)JNIHandles::make_local(components_h());
1888     }
1889   }
1890 
1891   // Return empty array if ofClass is not a record.
1892   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1893   return (jobjectArray)JNIHandles::make_local(env, result);
1894 }
1895 JVM_END
1896 
1897 static bool select_method(const methodHandle&amp; method, bool want_constructor) {


1898   if (want_constructor) {
<span class="line-modified">1899     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());</span>
1900   } else {
<span class="line-modified">1901     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());</span>


1902   }
1903 }
1904 
1905 static jobjectArray get_class_declared_methods_helper(
1906                                   JNIEnv *env,
1907                                   jclass ofClass, jboolean publicOnly,
1908                                   bool want_constructor,
1909                                   Klass* klass, TRAPS) {
1910 
1911   JvmtiVMObjectAllocEventCollector oam;
1912 
1913   // Exclude primitive types and array types
1914   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1915       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1916     // Return empty array
1917     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1918     return (jobjectArray) JNIHandles::make_local(env, res);
1919   }
1920 
1921   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1943     }
1944   }
1945 
1946   // Allocate result
1947   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1948   objArrayHandle result (THREAD, r);
1949 
1950   // Now just put the methods that we selected above, but go by their idnum
1951   // in case of redefinition.  The methods can be redefined at any safepoint,
1952   // so above when allocating the oop array and below when creating reflect
1953   // objects.
1954   for (int i = 0; i &lt; num_methods; i++) {
1955     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1956     if (method.is_null()) {
1957       // Method may have been deleted and seems this API can handle null
1958       // Otherwise should probably put a method that throws NSME
1959       result-&gt;obj_at_put(i, NULL);
1960     } else {
1961       oop m;
1962       if (want_constructor) {


1963         m = Reflection::new_constructor(method, CHECK_NULL);
1964       } else {
1965         m = Reflection::new_method(method, false, CHECK_NULL);
1966       }
1967       result-&gt;obj_at_put(i, m);
1968     }
1969   }
1970 
1971   return (jobjectArray) JNIHandles::make_local(env, result());
1972 }
1973 
1974 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1975 {
1976   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1977   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1978                                            /*want_constructor*/ false,
1979                                            SystemDictionary::reflect_Method_klass(), THREAD);
1980 }
1981 JVM_END
1982 
</pre>
<hr />
<pre>
2200   constantTag tag = cp-&gt;tag_at(index);
2201   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2202     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2203   }
2204   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2205   Klass* k_o;
2206   if (force_resolution) {
2207     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2208   } else {
2209     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2210     if (k_o == NULL) return NULL;
2211   }
2212   InstanceKlass* k = InstanceKlass::cast(k_o);
2213   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2214   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2215   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2216   if (m.is_null()) {
2217     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2218   }
2219   oop method;
<span class="line-modified">2220   if (!m-&gt;is_initializer() || m-&gt;is_static()) {</span>
<span class="line-removed">2221     method = Reflection::new_method(m, true, CHECK_NULL);</span>
<span class="line-removed">2222   } else {</span>
2223     method = Reflection::new_constructor(m, CHECK_NULL);


2224   }
2225   return JNIHandles::make_local(method);
2226 }
2227 
2228 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2229 {
2230   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2231   JvmtiVMObjectAllocEventCollector oam;
2232   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2233   bounds_check(cp, index, CHECK_NULL);
2234   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2235   return res;
2236 }
2237 JVM_END
2238 
2239 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2240 {
2241   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2242   JvmtiVMObjectAllocEventCollector oam;
2243   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2491   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2492   if (!k-&gt;is_instance_klass()) return false;
2493 
2494   ResourceMark rm(THREAD);
2495   const char* name = k-&gt;name()-&gt;as_C_string();
2496   bool system_class = k-&gt;class_loader() == NULL;
2497   return JavaAssertions::enabled(name, system_class);
2498 
2499 JVM_END
2500 
2501 
2502 // Return a new AssertionStatusDirectives object with the fields filled in with
2503 // command-line assertion arguments (i.e., -ea, -da).
2504 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2505   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2506   JvmtiVMObjectAllocEventCollector oam;
2507   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2508   return JNIHandles::make_local(env, asd);
2509 JVM_END
2510 







































2511 // Verification ////////////////////////////////////////////////////////////////////////////////
2512 
2513 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2514 
2515 // RedefineClasses support: bug 6214132 caused verification to fail.
2516 // All functions from this section should call the jvmtiThreadSate function:
2517 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2518 // The function returns a Klass* of the _scratch_class if the verifier
2519 // was invoked in the middle of the class redefinition.
2520 // Otherwise it returns its argument value which is the _the_class Klass*.
2521 // Please, refer to the description in the jvmtiThreadSate.hpp.
2522 
2523 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2524   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2525   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2526   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2527   return k-&gt;name()-&gt;as_utf8();
2528 JVM_END
2529 
2530 
</pre>
<hr />
<pre>
2670   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2671   return method-&gt;size_of_parameters();
2672 JVM_END
2673 
2674 
2675 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2676   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2677   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2678   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2679   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2680   return method-&gt;verifier_max_stack();
2681 JVM_END
2682 
2683 
2684 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2685   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2686   ResourceMark rm(THREAD);
2687   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2688   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2689   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2690   return method-&gt;name() == vmSymbols::object_initializer_name();</span>
2691 JVM_END
2692 
2693 
2694 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2695   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2696   ResourceMark rm(THREAD);
2697   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2698   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2699   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2700   return method-&gt;is_overpass();
2701 JVM_END
2702 
2703 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2704   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2705   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2706   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2707   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2708   return method-&gt;name()-&gt;as_utf8();
2709 JVM_END
2710 
</pre>
<hr />
<pre>
3665   //   protection_domain. The protection_domain is passed as NULL by the java code
3666   //   if there is no security manager in 3-arg Class.forName().
3667   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3668 
3669   // Check if we should initialize the class
3670   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3671     klass-&gt;initialize(CHECK_NULL);
3672   }
3673   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3674 }
3675 
3676 
3677 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3678 
3679 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3680   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3681   Handle method_handle;
3682   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3683     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3684     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3685     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3686     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3687     jobject res = JNIHandles::make_local(env, result);
3688     if (JvmtiExport::should_post_vm_object_alloc()) {
3689       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3690       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3691       if (java_lang_Class::is_primitive(ret_type)) {
3692         // Only for primitive type vm allocates memory for java object.
3693         // See box() method.
3694         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3695       }
3696     }
3697     return res;
3698   } else {
3699     THROW_0(vmSymbols::java_lang_StackOverflowError());
3700   }
3701 JVM_END
3702 
3703 
3704 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3705   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);

3706   oop constructor_mirror = JNIHandles::resolve(c);
<span class="line-removed">3707   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3708   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3709   jobject res = JNIHandles::make_local(env, result);
3710   if (JvmtiExport::should_post_vm_object_alloc()) {
3711     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3712   }
3713   return res;
3714 JVM_END
3715 
3716 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3717 
3718 JVM_LEAF(jboolean, JVM_SupportsCX8())
3719   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3720   return VM_Version::supports_cx8();
3721 JVM_END
3722 
3723 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3724   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3725   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3726   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3727   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
<td>
<hr />
<pre>
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;
  54 #include &quot;oops/instanceKlass.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/recordComponent.hpp&quot;
  57 #include &quot;oops/objArrayKlass.hpp&quot;
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  60 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
  61 #include &quot;prims/jvm_misc.hpp&quot;
  62 #include &quot;prims/jvmtiExport.hpp&quot;
  63 #include &quot;prims/jvmtiThreadState.hpp&quot;
  64 #include &quot;prims/nativeLookup.hpp&quot;
  65 #include &quot;prims/stackwalk.hpp&quot;
  66 #include &quot;runtime/arguments.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/init.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/deoptimization.hpp&quot;
  72 #include &quot;runtime/handshake.hpp&quot;
  73 #include &quot;runtime/java.hpp&quot;
  74 #include &quot;runtime/javaCalls.hpp&quot;
  75 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  76 #include &quot;runtime/jniHandles.inline.hpp&quot;
  77 #include &quot;runtime/os.inline.hpp&quot;
  78 #include &quot;runtime/perfData.hpp&quot;
  79 #include &quot;runtime/reflection.hpp&quot;
  80 #include &quot;runtime/synchronizer.hpp&quot;
</pre>
<hr />
<pre>
 697   JVMWrapper(&quot;JVM_Clone&quot;);
 698   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 699   Klass* klass = obj-&gt;klass();
 700   JvmtiVMObjectAllocEventCollector oam;
 701 
 702 #ifdef ASSERT
 703   // Just checking that the cloneable flag is set correct
 704   if (obj-&gt;is_array()) {
 705     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 706   } else {
 707     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 708     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 709     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 710   }
 711 #endif
 712 
 713   // Check if class of obj supports the Cloneable interface.
 714   // All arrays are considered to be cloneable (See JLS 20.1.5).
 715   // All j.l.r.Reference classes are considered non-cloneable.
 716   if (!klass-&gt;is_cloneable() ||
<span class="line-added"> 717        klass-&gt;is_value() ||</span>
 718       (klass-&gt;is_instance_klass() &amp;&amp;
 719        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 720     ResourceMark rm(THREAD);
 721     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 722   }
 723 
 724   // Make shallow object copy
 725   const int size = obj-&gt;size();
 726   oop new_obj_oop = NULL;
 727   if (obj-&gt;is_array()) {
 728     const int length = ((arrayOop)obj())-&gt;length();
 729     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 730                                                    /* do_zero */ true, CHECK_NULL);
 731   } else {
 732     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 733   }
 734 
 735   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 736 
 737   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1241   return (jstring) JNIHandles::make_local(env, result);
1242 JVM_END
1243 
1244 
1245 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1246   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1247   JvmtiVMObjectAllocEventCollector oam;
1248   oop mirror = JNIHandles::resolve_non_null(cls);
1249 
1250   // Special handling for primitive objects
1251   if (java_lang_Class::is_primitive(mirror)) {
1252     // Primitive objects does not have any interfaces
1253     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1254     return (jobjectArray) JNIHandles::make_local(env, r);
1255   }
1256 
1257   Klass* klass = java_lang_Class::as_Klass(mirror);
1258   // Figure size of result array
1259   int size;
1260   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1261     InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-added">1262     size = ik-&gt;local_interfaces()-&gt;length();</span>
<span class="line-added">1263     if (ik-&gt;has_injected_identityObject()) {</span>
<span class="line-added">1264       size--;</span>
<span class="line-added">1265     }</span>
1266   } else {
1267     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1268     size = 3;</span>
1269   }
1270 
1271   // Allocate result array
1272   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1273   objArrayHandle result (THREAD, r);
1274   // Fill in result
1275   if (klass-&gt;is_instance_klass()) {
1276     // Regular instance klass, fill in all local interfaces
<span class="line-added">1277     int cursor = 0;</span>
1278     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1279       InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-modified">1280       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-added">1281       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">1282         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());</span>
<span class="line-added">1283       }</span>
1284     }
1285   } else {
<span class="line-modified">1286     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject</span>
1287     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1288     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
<span class="line-added">1289     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());</span>
1290   }
1291   return (jobjectArray) JNIHandles::make_local(env, result());
1292 JVM_END
1293 
1294 
1295 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1296   JVMWrapper(&quot;JVM_IsInterface&quot;);
1297   oop mirror = JNIHandles::resolve_non_null(cls);
1298   if (java_lang_Class::is_primitive(mirror)) {
1299     return JNI_FALSE;
1300   }
1301   Klass* k = java_lang_Class::as_Klass(mirror);
1302   jboolean result = k-&gt;is_interface();
1303   assert(!result || k-&gt;is_instance_klass(),
1304          &quot;all interfaces are instance types&quot;);
1305   // The compiler intrinsic for isInterface tests the
1306   // Klass::_access_flags bits in the same way.
1307   return result;
1308 JVM_END
1309 
</pre>
<hr />
<pre>
1889         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1890       objArrayHandle components_h (THREAD, record_components);
1891 
1892       for (int x = 0; x &lt; length; x++) {
1893         RecordComponent* component = components-&gt;at(x);
1894         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1895         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1896         components_h-&gt;obj_at_put(x, component_oop);
1897       }
1898       return (jobjectArray)JNIHandles::make_local(components_h());
1899     }
1900   }
1901 
1902   // Return empty array if ofClass is not a record.
1903   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1904   return (jobjectArray)JNIHandles::make_local(env, result);
1905 }
1906 JVM_END
1907 
1908 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
<span class="line-added">1909   bool is_ctor = (method-&gt;is_object_constructor() ||</span>
<span class="line-added">1910                   method-&gt;is_static_init_factory());</span>
1911   if (want_constructor) {
<span class="line-modified">1912     return is_ctor;</span>
1913   } else {
<span class="line-modified">1914     return (!is_ctor &amp;&amp;</span>
<span class="line-added">1915             !method-&gt;is_class_initializer() &amp;&amp;</span>
<span class="line-added">1916             !method-&gt;is_overpass());</span>
1917   }
1918 }
1919 
1920 static jobjectArray get_class_declared_methods_helper(
1921                                   JNIEnv *env,
1922                                   jclass ofClass, jboolean publicOnly,
1923                                   bool want_constructor,
1924                                   Klass* klass, TRAPS) {
1925 
1926   JvmtiVMObjectAllocEventCollector oam;
1927 
1928   // Exclude primitive types and array types
1929   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1930       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1931     // Return empty array
1932     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1933     return (jobjectArray) JNIHandles::make_local(env, res);
1934   }
1935 
1936   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1958     }
1959   }
1960 
1961   // Allocate result
1962   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1963   objArrayHandle result (THREAD, r);
1964 
1965   // Now just put the methods that we selected above, but go by their idnum
1966   // in case of redefinition.  The methods can be redefined at any safepoint,
1967   // so above when allocating the oop array and below when creating reflect
1968   // objects.
1969   for (int i = 0; i &lt; num_methods; i++) {
1970     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1971     if (method.is_null()) {
1972       // Method may have been deleted and seems this API can handle null
1973       // Otherwise should probably put a method that throws NSME
1974       result-&gt;obj_at_put(i, NULL);
1975     } else {
1976       oop m;
1977       if (want_constructor) {
<span class="line-added">1978         assert(method-&gt;is_object_constructor() ||</span>
<span class="line-added">1979                method-&gt;is_static_init_factory(), &quot;must be&quot;);</span>
1980         m = Reflection::new_constructor(method, CHECK_NULL);
1981       } else {
1982         m = Reflection::new_method(method, false, CHECK_NULL);
1983       }
1984       result-&gt;obj_at_put(i, m);
1985     }
1986   }
1987 
1988   return (jobjectArray) JNIHandles::make_local(env, result());
1989 }
1990 
1991 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1992 {
1993   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1994   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1995                                            /*want_constructor*/ false,
1996                                            SystemDictionary::reflect_Method_klass(), THREAD);
1997 }
1998 JVM_END
1999 
</pre>
<hr />
<pre>
2217   constantTag tag = cp-&gt;tag_at(index);
2218   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2219     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2220   }
2221   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2222   Klass* k_o;
2223   if (force_resolution) {
2224     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2225   } else {
2226     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2227     if (k_o == NULL) return NULL;
2228   }
2229   InstanceKlass* k = InstanceKlass::cast(k_o);
2230   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2231   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2232   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2233   if (m.is_null()) {
2234     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2235   }
2236   oop method;
<span class="line-modified">2237   if (m-&gt;is_object_constructor()) {</span>


2238     method = Reflection::new_constructor(m, CHECK_NULL);
<span class="line-added">2239   } else {</span>
<span class="line-added">2240     method = Reflection::new_method(m, true, CHECK_NULL);</span>
2241   }
2242   return JNIHandles::make_local(method);
2243 }
2244 
2245 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2246 {
2247   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2248   JvmtiVMObjectAllocEventCollector oam;
2249   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2250   bounds_check(cp, index, CHECK_NULL);
2251   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2252   return res;
2253 }
2254 JVM_END
2255 
2256 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2257 {
2258   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2259   JvmtiVMObjectAllocEventCollector oam;
2260   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2508   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2509   if (!k-&gt;is_instance_klass()) return false;
2510 
2511   ResourceMark rm(THREAD);
2512   const char* name = k-&gt;name()-&gt;as_C_string();
2513   bool system_class = k-&gt;class_loader() == NULL;
2514   return JavaAssertions::enabled(name, system_class);
2515 
2516 JVM_END
2517 
2518 
2519 // Return a new AssertionStatusDirectives object with the fields filled in with
2520 // command-line assertion arguments (i.e., -ea, -da).
2521 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2522   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2523   JvmtiVMObjectAllocEventCollector oam;
2524   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2525   return JNIHandles::make_local(env, asd);
2526 JVM_END
2527 
<span class="line-added">2528 // Arrays support /////////////////////////////////////////////////////////////</span>
<span class="line-added">2529 </span>
<span class="line-added">2530 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2531   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);</span>
<span class="line-added">2532   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2533   Klass* k = o-&gt;klass();</span>
<span class="line-added">2534   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2535     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2536   }</span>
<span class="line-added">2537   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();</span>
<span class="line-added">2538 JVM_END</span>
<span class="line-added">2539 </span>
<span class="line-added">2540 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2541   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);</span>
<span class="line-added">2542   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2543   Klass* k = o-&gt;klass();</span>
<span class="line-added">2544   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2545     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2546   }</span>
<span class="line-added">2547   if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added">2548     ValueArrayKlass* vk = ValueArrayKlass::cast(k);</span>
<span class="line-added">2549     if (!vk-&gt;element_access_is_atomic()) {</span>
<span class="line-added">2550       /**</span>
<span class="line-added">2551        * Need to decide how to implement:</span>
<span class="line-added">2552        *</span>
<span class="line-added">2553        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so</span>
<span class="line-added">2554        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through</span>
<span class="line-added">2555        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;</span>
<span class="line-added">2556        *</span>
<span class="line-added">2557        * 2) Use extra header in the valueArrayOop to flag atomicity required and</span>
<span class="line-added">2558        * possibly per instance lock structure. Said info, could be placed in</span>
<span class="line-added">2559        * &quot;trailer&quot; rather than disturb the current arrayOop</span>
<span class="line-added">2560        */</span>
<span class="line-added">2561       Unimplemented();</span>
<span class="line-added">2562     }</span>
<span class="line-added">2563   }</span>
<span class="line-added">2564   return array;</span>
<span class="line-added">2565 JVM_END</span>
<span class="line-added">2566 </span>
2567 // Verification ////////////////////////////////////////////////////////////////////////////////
2568 
2569 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2570 
2571 // RedefineClasses support: bug 6214132 caused verification to fail.
2572 // All functions from this section should call the jvmtiThreadSate function:
2573 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2574 // The function returns a Klass* of the _scratch_class if the verifier
2575 // was invoked in the middle of the class redefinition.
2576 // Otherwise it returns its argument value which is the _the_class Klass*.
2577 // Please, refer to the description in the jvmtiThreadSate.hpp.
2578 
2579 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2580   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2581   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2582   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2583   return k-&gt;name()-&gt;as_utf8();
2584 JVM_END
2585 
2586 
</pre>
<hr />
<pre>
2726   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2727   return method-&gt;size_of_parameters();
2728 JVM_END
2729 
2730 
2731 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2732   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2733   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2734   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2735   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2736   return method-&gt;verifier_max_stack();
2737 JVM_END
2738 
2739 
2740 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2741   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2742   ResourceMark rm(THREAD);
2743   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2744   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2745   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2746   return method-&gt;is_object_constructor();</span>
2747 JVM_END
2748 
2749 
2750 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2751   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2752   ResourceMark rm(THREAD);
2753   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2754   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2755   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2756   return method-&gt;is_overpass();
2757 JVM_END
2758 
2759 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2760   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2761   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2762   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2763   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2764   return method-&gt;name()-&gt;as_utf8();
2765 JVM_END
2766 
</pre>
<hr />
<pre>
3721   //   protection_domain. The protection_domain is passed as NULL by the java code
3722   //   if there is no security manager in 3-arg Class.forName().
3723   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3724 
3725   // Check if we should initialize the class
3726   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3727     klass-&gt;initialize(CHECK_NULL);
3728   }
3729   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3730 }
3731 
3732 
3733 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3734 
3735 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3736   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3737   Handle method_handle;
3738   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3739     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3740     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3741     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3742     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3743     jobject res = JNIHandles::make_local(env, result);
3744     if (JvmtiExport::should_post_vm_object_alloc()) {
3745       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3746       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3747       if (java_lang_Class::is_primitive(ret_type)) {
3748         // Only for primitive type vm allocates memory for java object.
3749         // See box() method.
3750         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3751       }
3752     }
3753     return res;
3754   } else {
3755     THROW_0(vmSymbols::java_lang_StackOverflowError());
3756   }
3757 JVM_END
3758 
3759 
3760 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3761   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
<span class="line-added">3762   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3763   oop constructor_mirror = JNIHandles::resolve(c);

3764   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3765   jobject res = JNIHandles::make_local(env, result);
3766   if (JvmtiExport::should_post_vm_object_alloc()) {
3767     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3768   }
3769   return res;
3770 JVM_END
3771 
3772 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3773 
3774 JVM_LEAF(jboolean, JVM_SupportsCX8())
3775   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3776   return VM_Version::supports_cx8();
3777 JVM_END
3778 
3779 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3780   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3781   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3782   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3783   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
</tr>
</table>
<center><a href="../oops/klassVtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
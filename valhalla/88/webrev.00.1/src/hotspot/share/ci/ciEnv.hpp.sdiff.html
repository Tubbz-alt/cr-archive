<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciEnv.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classFileParser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciEnv.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
117   // The CI treats a klass as loaded if it is consistently defined in
118   // another loader, even if it hasn&#39;t yet been loaded in all loaders
119   // that could potentially see it via delegation.
120   ciKlass* get_klass_by_name(ciKlass* accessing_klass,
121                              ciSymbol* klass_name,
122                              bool require_local);
123 
124   // Constant pool access.
125   ciKlass*   get_klass_by_index(const constantPoolHandle&amp; cpool,
126                                 int klass_index,
127                                 bool&amp; is_accessible,
128                                 ciInstanceKlass* loading_klass);
129   ciConstant get_constant_by_index(const constantPoolHandle&amp; cpool,
130                                    int pool_index, int cache_index,
131                                    ciInstanceKlass* accessor);
132   ciField*   get_field_by_index(ciInstanceKlass* loading_klass,
133                                 int field_index);
134   ciMethod*  get_method_by_index(const constantPoolHandle&amp; cpool,
135                                  int method_index, Bytecodes::Code bc,
136                                  ciInstanceKlass* loading_klass);


137 
138   // Implementation methods for loading and constant pool access.
139   ciKlass* get_klass_by_name_impl(ciKlass* accessing_klass,
140                                   const constantPoolHandle&amp; cpool,
141                                   ciSymbol* klass_name,
142                                   bool require_local);
143   ciKlass*   get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
144                                      int klass_index,
145                                      bool&amp; is_accessible,
146                                      ciInstanceKlass* loading_klass);
147   ciConstant get_constant_by_index_impl(const constantPoolHandle&amp; cpool,
148                                         int pool_index, int cache_index,
149                                         ciInstanceKlass* loading_klass);
150   ciField*   get_field_by_index_impl(ciInstanceKlass* loading_klass,
151                                      int field_index);
152   ciMethod*  get_method_by_index_impl(const constantPoolHandle&amp; cpool,
153                                       int method_index, Bytecodes::Code bc,
154                                       ciInstanceKlass* loading_klass);
155 
156   // Helper methods
</pre>
<hr />
<pre>
181       return _factory-&gt;get_symbol(o);
182     }
183   }
184 
185   ciMetadata* get_metadata(Metadata* o) {
186     if (o == NULL) {
187       return NULL;
188     } else {
189       return _factory-&gt;get_metadata(o);
190     }
191   }
192 
193   ciMetadata* cached_metadata(Metadata* o) {
194     return _factory-&gt;cached_metadata(o);
195   }
196 
197   ciInstance* get_instance(oop o) {
198     if (o == NULL) return NULL;
199     return get_object(o)-&gt;as_instance();
200   }




201   ciObjArrayKlass* get_obj_array_klass(Klass* o) {
202     if (o == NULL) return NULL;
203     return get_metadata(o)-&gt;as_obj_array_klass();
204   }
205   ciTypeArrayKlass* get_type_array_klass(Klass* o) {
206     if (o == NULL) return NULL;
207     return get_metadata(o)-&gt;as_type_array_klass();
208   }
209   ciKlass* get_klass(Klass* o) {
210     if (o == NULL) return NULL;
211     return get_metadata(o)-&gt;as_klass();
212   }
213   ciInstanceKlass* get_instance_klass(Klass* o) {
214     if (o == NULL) return NULL;
215     return get_metadata(o)-&gt;as_instance_klass();
216   }
217   ciMethod* get_method(Method* o) {
218     if (o == NULL) return NULL;
219     return get_metadata(o)-&gt;as_method();
220   }
</pre>
<hr />
<pre>
452   int num_inlined_bytecodes() const;
453 
454   // Output stream for logging compilation info.
455   CompileLog* log() { return _log; }
456   void set_log(CompileLog* log) { _log = log; }
457 
458   void record_failure(const char* reason);      // Record failure and report later
459   void report_failure(const char* reason);      // Report failure immediately
460   void record_method_not_compilable(const char* reason, bool all_tiers = true);
461   void record_out_of_memory_failure();
462 
463   // RedefineClasses support
464   void metadata_do(MetadataClosure* f) { _factory-&gt;metadata_do(f); }
465 
466   // Dump the compilation replay data for the ciEnv to the stream.
467   void dump_replay_data(int compile_id);
468   void dump_inline_data(int compile_id);
469   void dump_replay_data(outputStream* out);
470   void dump_replay_data_unsafe(outputStream* out);
471   void dump_compile_data(outputStream* out);




472 };
473 
474 #endif // SHARE_CI_CIENV_HPP
</pre>
</td>
<td>
<hr />
<pre>
117   // The CI treats a klass as loaded if it is consistently defined in
118   // another loader, even if it hasn&#39;t yet been loaded in all loaders
119   // that could potentially see it via delegation.
120   ciKlass* get_klass_by_name(ciKlass* accessing_klass,
121                              ciSymbol* klass_name,
122                              bool require_local);
123 
124   // Constant pool access.
125   ciKlass*   get_klass_by_index(const constantPoolHandle&amp; cpool,
126                                 int klass_index,
127                                 bool&amp; is_accessible,
128                                 ciInstanceKlass* loading_klass);
129   ciConstant get_constant_by_index(const constantPoolHandle&amp; cpool,
130                                    int pool_index, int cache_index,
131                                    ciInstanceKlass* accessor);
132   ciField*   get_field_by_index(ciInstanceKlass* loading_klass,
133                                 int field_index);
134   ciMethod*  get_method_by_index(const constantPoolHandle&amp; cpool,
135                                  int method_index, Bytecodes::Code bc,
136                                  ciInstanceKlass* loading_klass);
<span class="line-added">137   bool       is_klass_never_null(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">138                                  int klass_index);</span>
139 
140   // Implementation methods for loading and constant pool access.
141   ciKlass* get_klass_by_name_impl(ciKlass* accessing_klass,
142                                   const constantPoolHandle&amp; cpool,
143                                   ciSymbol* klass_name,
144                                   bool require_local);
145   ciKlass*   get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
146                                      int klass_index,
147                                      bool&amp; is_accessible,
148                                      ciInstanceKlass* loading_klass);
149   ciConstant get_constant_by_index_impl(const constantPoolHandle&amp; cpool,
150                                         int pool_index, int cache_index,
151                                         ciInstanceKlass* loading_klass);
152   ciField*   get_field_by_index_impl(ciInstanceKlass* loading_klass,
153                                      int field_index);
154   ciMethod*  get_method_by_index_impl(const constantPoolHandle&amp; cpool,
155                                       int method_index, Bytecodes::Code bc,
156                                       ciInstanceKlass* loading_klass);
157 
158   // Helper methods
</pre>
<hr />
<pre>
183       return _factory-&gt;get_symbol(o);
184     }
185   }
186 
187   ciMetadata* get_metadata(Metadata* o) {
188     if (o == NULL) {
189       return NULL;
190     } else {
191       return _factory-&gt;get_metadata(o);
192     }
193   }
194 
195   ciMetadata* cached_metadata(Metadata* o) {
196     return _factory-&gt;cached_metadata(o);
197   }
198 
199   ciInstance* get_instance(oop o) {
200     if (o == NULL) return NULL;
201     return get_object(o)-&gt;as_instance();
202   }
<span class="line-added">203   ciValueArrayKlass* get_value_array_klass(Klass* o) {</span>
<span class="line-added">204     if (o == NULL) return NULL;</span>
<span class="line-added">205     return get_metadata(o)-&gt;as_value_array_klass();</span>
<span class="line-added">206   }</span>
207   ciObjArrayKlass* get_obj_array_klass(Klass* o) {
208     if (o == NULL) return NULL;
209     return get_metadata(o)-&gt;as_obj_array_klass();
210   }
211   ciTypeArrayKlass* get_type_array_klass(Klass* o) {
212     if (o == NULL) return NULL;
213     return get_metadata(o)-&gt;as_type_array_klass();
214   }
215   ciKlass* get_klass(Klass* o) {
216     if (o == NULL) return NULL;
217     return get_metadata(o)-&gt;as_klass();
218   }
219   ciInstanceKlass* get_instance_klass(Klass* o) {
220     if (o == NULL) return NULL;
221     return get_metadata(o)-&gt;as_instance_klass();
222   }
223   ciMethod* get_method(Method* o) {
224     if (o == NULL) return NULL;
225     return get_metadata(o)-&gt;as_method();
226   }
</pre>
<hr />
<pre>
458   int num_inlined_bytecodes() const;
459 
460   // Output stream for logging compilation info.
461   CompileLog* log() { return _log; }
462   void set_log(CompileLog* log) { _log = log; }
463 
464   void record_failure(const char* reason);      // Record failure and report later
465   void report_failure(const char* reason);      // Report failure immediately
466   void record_method_not_compilable(const char* reason, bool all_tiers = true);
467   void record_out_of_memory_failure();
468 
469   // RedefineClasses support
470   void metadata_do(MetadataClosure* f) { _factory-&gt;metadata_do(f); }
471 
472   // Dump the compilation replay data for the ciEnv to the stream.
473   void dump_replay_data(int compile_id);
474   void dump_inline_data(int compile_id);
475   void dump_replay_data(outputStream* out);
476   void dump_replay_data_unsafe(outputStream* out);
477   void dump_compile_data(outputStream* out);
<span class="line-added">478 </span>
<span class="line-added">479   ciWrapper* make_never_null_wrapper(ciType* type) {</span>
<span class="line-added">480     return _factory-&gt;make_never_null_wrapper(type);</span>
<span class="line-added">481   }</span>
482 };
483 
484 #endif // SHARE_CI_CIENV_HPP
</pre>
</td>
</tr>
</table>
<center><a href="ciEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classFileParser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
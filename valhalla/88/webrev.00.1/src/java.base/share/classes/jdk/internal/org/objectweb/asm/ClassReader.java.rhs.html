<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * ASM: a very small and fast Java bytecode manipulation framework
  32  * Copyright (c) 2000-2011 INRIA, France Telecom
  33  * All rights reserved.
  34  *
  35  * Redistribution and use in source and binary forms, with or without
  36  * modification, are permitted provided that the following conditions
  37  * are met:
  38  * 1. Redistributions of source code must retain the above copyright
  39  *    notice, this list of conditions and the following disclaimer.
  40  * 2. Redistributions in binary form must reproduce the above copyright
  41  *    notice, this list of conditions and the following disclaimer in the
  42  *    documentation and/or other materials provided with the distribution.
  43  * 3. Neither the name of the copyright holders nor the names of its
  44  *    contributors may be used to endorse or promote products derived from
  45  *    this software without specific prior written permission.
  46  *
  47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  57  * THE POSSIBILITY OF SUCH DAMAGE.
  58  */
  59 package jdk.internal.org.objectweb.asm;
  60 
  61 import java.io.ByteArrayOutputStream;
  62 import java.io.IOException;
  63 import java.io.InputStream;
  64 
  65 /**
  66  * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java
  67  * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the
  68  * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode
  69  * instruction encountered.
  70  *
  71  * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html&quot;&gt;JVMS 4&lt;/a&gt;
  72  * @author Eric Bruneton
  73  * @author Eugene Kuleshov
  74  */
  75 public class ClassReader {
  76 
  77     /**
  78       * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed
  79       * nor visited.
  80       */
  81     public static final int SKIP_CODE = 1;
  82 
  83     /**
  84       * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,
  85       * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set
  86       * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link
  87       * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link
  88       * MethodVisitor#visitParameter} are not called).
  89       */
  90     public static final int SKIP_DEBUG = 2;
  91 
  92     /**
  93       * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
  94       * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag
  95       * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames
  96       * that will be ignored and recomputed from scratch.
  97       */
  98     public static final int SKIP_FRAMES = 4;
  99 
 100     /**
 101       * A flag to expand the stack map frames. By default stack map frames are visited in their
 102       * original format (i.e. &quot;expanded&quot; for classes whose version is less than V1_6, and &quot;compressed&quot;
 103       * for the other classes). If this flag is set, stack map frames are always visited in expanded
 104       * format (this option adds a decompression/compression step in ClassReader and ClassWriter which
 105       * degrades performance quite a lot).
 106       */
 107     public static final int EXPAND_FRAMES = 8;
 108 
 109     /**
 110       * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode
 111       * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset
 112       * reserved for it is not sufficient to store the bytecode offset. In this case the jump
 113       * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes
 114       * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing
 115       * such instructions, in order to replace them with standard instructions. In addition, when this
 116       * flag is used, goto_w and jsr_w are &lt;i&gt;not&lt;/i&gt; converted into goto and jsr, to make sure that
 117       * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a
 118       * goto_w in ClassWriter cannot occur.
 119       */
 120     static final int EXPAND_ASM_INSNS = 256;
 121 
 122     /** The size of the temporary byte array used to read class input streams chunk by chunk. */
 123     private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;
 124 
 125     /**
 126       * A byte array containing the JVMS ClassFile structure to be parsed.
 127       *
 128       * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will
 129       *     eventually be deleted.
 130       */
 131     @Deprecated
 132     // DontCheck(MemberName): can&#39;t be renamed (for backward binary compatibility).
 133     public final byte[] b;
 134 
 135     /**
 136       * A byte array containing the JVMS ClassFile structure to be parsed. &lt;i&gt;The content of this array
 137       * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
 138       * not needed by class visitors.&lt;/i&gt;
 139       *
 140       * &lt;p&gt;NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
 141       * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
 142       * ClassFile element offsets within this byte array.
 143       */
 144     final byte[] classFileBuffer;
 145 
 146     /**
 147       * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile&#39;s
 148       * constant_pool array, &lt;i&gt;plus one&lt;/i&gt;. In other words, the offset of constant pool entry i is
 149       * given by cpInfoOffsets[i] - 1, i.e. its cp_info&#39;s tag field is given by b[cpInfoOffsets[i] -
 150       * 1].
 151       */
 152     private final int[] cpInfoOffsets;
 153 
 154     /**
 155       * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids
 156       * multiple parsing of a given CONSTANT_Utf8 constant pool item.
 157       */
 158     private final String[] constantUtf8Values;
 159 
 160     /**
 161       * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This
 162       * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.
 163       */
 164     private final ConstantDynamic[] constantDynamicValues;
 165 
 166     /**
 167       * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array
 168       * (in the BootstrapMethods attribute).
 169       *
 170       * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23&quot;&gt;JVMS
 171       *     4.7.23&lt;/a&gt;
 172       */
 173     private final int[] bootstrapMethodOffsets;
 174 
 175     /**
 176       * A conservative estimate of the maximum length of the strings contained in the constant pool of
 177       * the class.
 178       */
 179     private final int maxStringLength;
 180 
 181     /** The offset in bytes of the ClassFile&#39;s access_flags field. */
 182     public final int header;
 183 
 184     // -----------------------------------------------------------------------------------------------
 185     // Constructors
 186     // -----------------------------------------------------------------------------------------------
 187 
 188     /**
 189       * Constructs a new {@link ClassReader} object.
 190       *
 191       * @param classFile the JVMS ClassFile structure to be read.
 192       */
 193     public ClassReader(final byte[] classFile) {
 194         this(classFile, 0, classFile.length);
 195     }
 196 
 197     /**
 198       * Constructs a new {@link ClassReader} object.
 199       *
 200       * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
 201       * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
 202       * @param classFileLength the length in bytes of the ClassFile to be read.
 203       */
 204     public ClassReader(
 205             final byte[] classFileBuffer,
 206             final int classFileOffset,
 207             final int classFileLength) { // NOPMD(UnusedFormalParameter) used for backward compatibility.
 208         this(classFileBuffer, classFileOffset, /* checkClassVersion = */ true);
 209     }
 210 
 211     /**
 212       * Constructs a new {@link ClassReader} object. &lt;i&gt;This internal constructor must not be exposed
 213       * as a public API&lt;/i&gt;.
 214       *
 215       * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
 216       * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
 217       * @param checkClassVersion whether to check the class version or not.
 218       */
 219     ClassReader(
 220             final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
 221         this.classFileBuffer = classFileBuffer;
 222         this.b = classFileBuffer;
 223         // Check the class&#39; major_version. This field is after the magic and minor_version fields, which
 224         // use 4 and 2 bytes respectively.
 225         if (checkClassVersion &amp;&amp; readShort(classFileOffset + 6) &gt; Opcodes.V16) {
 226             throw new IllegalArgumentException(
 227                     &quot;Unsupported class file major version &quot; + readShort(classFileOffset + 6));
 228         }
 229         // Create the constant pool arrays. The constant_pool_count field is after the magic,
 230         // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.
 231         int constantPoolCount = readUnsignedShort(classFileOffset + 8);
 232         cpInfoOffsets = new int[constantPoolCount];
 233         constantUtf8Values = new String[constantPoolCount];
 234         // Compute the offset of each constant pool entry, as well as a conservative estimate of the
 235         // maximum length of the constant pool strings. The first constant pool entry is after the
 236         // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
 237         // bytes respectively.
 238         int currentCpInfoIndex = 1;
 239         int currentCpInfoOffset = classFileOffset + 10;
 240         int currentMaxStringLength = 0;
 241         boolean hasBootstrapMethods = false;
 242         boolean hasConstantDynamic = false;
 243         // The offset of the other entries depend on the total size of all the previous entries.
 244         while (currentCpInfoIndex &lt; constantPoolCount) {
 245             cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;
 246             int cpInfoSize;
 247             switch (classFileBuffer[currentCpInfoOffset]) {
 248                 case Symbol.CONSTANT_FIELDREF_TAG:
 249                 case Symbol.CONSTANT_METHODREF_TAG:
 250                 case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
 251                 case Symbol.CONSTANT_INTEGER_TAG:
 252                 case Symbol.CONSTANT_FLOAT_TAG:
 253                 case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
 254                     cpInfoSize = 5;
 255                     break;
 256                 case Symbol.CONSTANT_DYNAMIC_TAG:
 257                     cpInfoSize = 5;
 258                     hasBootstrapMethods = true;
 259                     hasConstantDynamic = true;
 260                     break;
 261                 case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
 262                     cpInfoSize = 5;
 263                     hasBootstrapMethods = true;
 264                     break;
 265                 case Symbol.CONSTANT_LONG_TAG:
 266                 case Symbol.CONSTANT_DOUBLE_TAG:
 267                     cpInfoSize = 9;
 268                     currentCpInfoIndex++;
 269                     break;
 270                 case Symbol.CONSTANT_UTF8_TAG:
 271                     cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);
 272                     if (cpInfoSize &gt; currentMaxStringLength) {
 273                         // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate
 274                         // of the length in characters of the corresponding string, and is much cheaper to
 275                         // compute than this exact length.
 276                         currentMaxStringLength = cpInfoSize;
 277                     }
 278                     break;
 279                 case Symbol.CONSTANT_METHOD_HANDLE_TAG:
 280                     cpInfoSize = 4;
 281                     break;
 282                 case Symbol.CONSTANT_CLASS_TAG:
 283                 case Symbol.CONSTANT_STRING_TAG:
 284                 case Symbol.CONSTANT_METHOD_TYPE_TAG:
 285                 case Symbol.CONSTANT_PACKAGE_TAG:
 286                 case Symbol.CONSTANT_MODULE_TAG:
 287                     cpInfoSize = 3;
 288                     break;
 289                 default:
 290                     throw new IllegalArgumentException();
 291             }
 292             currentCpInfoOffset += cpInfoSize;
 293         }
 294         maxStringLength = currentMaxStringLength;
 295         // The Classfile&#39;s access_flags field is just after the last constant pool entry.
 296         header = currentCpInfoOffset;
 297 
 298         // Allocate the cache of ConstantDynamic values, if there is at least one.
 299         constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;
 300 
 301         // Read the BootstrapMethods attribute, if any (only get the offset of each method).
 302         bootstrapMethodOffsets =
 303                 hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;
 304     }
 305 
 306     /**
 307       * Constructs a new {@link ClassReader} object.
 308       *
 309       * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input
 310       *     stream must contain nothing more than the ClassFile structure itself. It is read from its
 311       *     current position to its end.
 312       * @throws IOException if a problem occurs during reading.
 313       */
 314     public ClassReader(final InputStream inputStream) throws IOException {
 315         this(readStream(inputStream, false));
 316     }
 317 
 318     /**
 319       * Constructs a new {@link ClassReader} object.
 320       *
 321       * @param className the fully qualified name of the class to be read. The ClassFile structure is
 322       *     retrieved with the current class loader&#39;s {@link ClassLoader#getSystemResourceAsStream}.
 323       * @throws IOException if an exception occurs during reading.
 324       */
 325     public ClassReader(final String className) throws IOException {
 326         this(
 327                 readStream(
 328                         ClassLoader.getSystemResourceAsStream(className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;), true));
 329     }
 330 
 331     /**
 332       * Reads the given input stream and returns its content as a byte array.
 333       *
 334       * @param inputStream an input stream.
 335       * @param close true to close the input stream after reading.
 336       * @return the content of the given input stream.
 337       * @throws IOException if a problem occurs during reading.
 338       */
 339     private static byte[] readStream(final InputStream inputStream, final boolean close)
 340             throws IOException {
 341         if (inputStream == null) {
 342             throw new IOException(&quot;Class not found&quot;);
 343         }
 344         try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
 345             byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];
 346             int bytesRead;
 347             while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
 348                 outputStream.write(data, 0, bytesRead);
 349             }
 350             outputStream.flush();
 351             return outputStream.toByteArray();
 352         } finally {
 353             if (close) {
 354                 inputStream.close();
 355             }
 356         }
 357     }
 358 
 359     // -----------------------------------------------------------------------------------------------
 360     // Accessors
 361     // -----------------------------------------------------------------------------------------------
 362 
 363     /**
 364       * Returns the class&#39;s access flags (see {@link Opcodes}). This value may not reflect Deprecated
 365       * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.
 366       *
 367       * @return the class access flags.
 368       * @see ClassVisitor#visit(int, int, String, String, String, String[])
 369       */
 370     public int getAccess() {
 371         return readUnsignedShort(header);
 372     }
 373 
 374     /**
 375       * Returns the internal name of the class (see {@link Type#getInternalName()}).
 376       *
 377       * @return the internal class name.
 378       * @see ClassVisitor#visit(int, int, String, String, String, String[])
 379       */
 380     public String getClassName() {
 381         // this_class is just after the access_flags field (using 2 bytes).
 382         return readClass(header + 2, new char[maxStringLength]);
 383     }
 384 
 385     /**
 386       * Returns the internal of name of the super class (see {@link Type#getInternalName()}). For
 387       * interfaces, the super class is {@link Object}.
 388       *
 389       * @return the internal name of the super class, or {@literal null} for {@link Object} class.
 390       * @see ClassVisitor#visit(int, int, String, String, String, String[])
 391       */
 392     public String getSuperName() {
 393         // super_class is after the access_flags and this_class fields (2 bytes each).
 394         return readClass(header + 4, new char[maxStringLength]);
 395     }
 396 
 397     /**
 398       * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).
 399       *
 400       * @return the internal names of the directly implemented interfaces. Inherited implemented
 401       *     interfaces are not returned.
 402       * @see ClassVisitor#visit(int, int, String, String, String, String[])
 403       */
 404     public String[] getInterfaces() {
 405         // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).
 406         int currentOffset = header + 6;
 407         int interfacesCount = readUnsignedShort(currentOffset);
 408         String[] interfaces = new String[interfacesCount];
 409         if (interfacesCount &gt; 0) {
 410             char[] charBuffer = new char[maxStringLength];
 411             for (int i = 0; i &lt; interfacesCount; ++i) {
 412                 currentOffset += 2;
 413                 interfaces[i] = readClass(currentOffset, charBuffer);
 414             }
 415         }
 416         return interfaces;
 417     }
 418 
 419     // -----------------------------------------------------------------------------------------------
 420     // Public methods
 421     // -----------------------------------------------------------------------------------------------
 422 
 423     /**
 424       * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
 425       * {@link ClassReader}.
 426       *
 427       * @param classVisitor the visitor that must visit this class.
 428       * @param parsingOptions the options to use to parse this class. One or more of {@link
 429       *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
 430       */
 431     public void accept(final ClassVisitor classVisitor, final int parsingOptions) {
 432         accept(classVisitor, new Attribute[0], parsingOptions);
 433     }
 434 
 435     /**
 436       * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
 437       * {@link ClassReader}.
 438       *
 439       * @param classVisitor the visitor that must visit this class.
 440       * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
 441       *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
 442       *     be parsed: its byte array value will be passed unchanged to the ClassWriter. &lt;i&gt;This may
 443       *     corrupt it if this value contains references to the constant pool, or has syntactic or
 444       *     semantic links with a class element that has been transformed by a class adapter between
 445       *     the reader and the writer&lt;/i&gt;.
 446       * @param parsingOptions the options to use to parse this class. One or more of {@link
 447       *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
 448       */
 449     @SuppressWarnings(&quot;deprecation&quot;)
 450     public void accept(
 451             final ClassVisitor classVisitor,
 452             final Attribute[] attributePrototypes,
 453             final int parsingOptions) {
 454         Context context = new Context();
 455         context.attributePrototypes = attributePrototypes;
 456         context.parsingOptions = parsingOptions;
 457         context.charBuffer = new char[maxStringLength];
 458 
 459         // Read the access_flags, this_class, super_class, interface_count and interfaces fields.
 460         char[] charBuffer = context.charBuffer;
 461         int currentOffset = header;
 462         int accessFlags = readUnsignedShort(currentOffset);
 463         String thisClass = readClass(currentOffset + 2, charBuffer);
 464         String superClass = readClass(currentOffset + 4, charBuffer);
 465         String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];
 466         currentOffset += 8;
 467         for (int i = 0; i &lt; interfaces.length; ++i) {
 468             interfaces[i] = readClass(currentOffset, charBuffer);
 469             currentOffset += 2;
 470         }
 471 
 472         // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).
 473         // Attribute offsets exclude the attribute_name_index and attribute_length fields.
 474         // - The offset of the InnerClasses attribute, or 0.
 475         int innerClassesOffset = 0;
 476         // - The offset of the EnclosingMethod attribute, or 0.
 477         int enclosingMethodOffset = 0;
 478         // - The string corresponding to the Signature attribute, or null.
 479         String signature = null;
 480         // - The string corresponding to the SourceFile attribute, or null.
 481         String sourceFile = null;
 482         // - The string corresponding to the SourceDebugExtension attribute, or null.
 483         String sourceDebugExtension = null;
 484         // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
 485         int runtimeVisibleAnnotationsOffset = 0;
 486         // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
 487         int runtimeInvisibleAnnotationsOffset = 0;
 488         // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
 489         int runtimeVisibleTypeAnnotationsOffset = 0;
 490         // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
 491         int runtimeInvisibleTypeAnnotationsOffset = 0;
 492         // - The offset of the Module attribute, or 0.
 493         int moduleOffset = 0;
 494         // - The offset of the ModulePackages attribute, or 0.
 495         int modulePackagesOffset = 0;
 496         // - The string corresponding to the ModuleMainClass attribute, or null.
 497         String moduleMainClass = null;
 498         // - The string corresponding to the NestHost attribute, or null.
 499         String nestHostClass = null;
 500         // - The offset of the NestMembers attribute, or 0.
 501         int nestMembersOffset = 0;
 502         // - The offset of the PermittedSubclasses attribute, or 0
 503         int permittedSubclassesOffset = 0;
 504         // - The offset of the Record attribute, or 0.
 505         int recordOffset = 0;
 506         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
 507         //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
 508         Attribute attributes = null;
 509 
 510         int currentAttributeOffset = getFirstAttributeOffset();
 511         for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {
 512             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
 513             String attributeName = readUTF8(currentAttributeOffset, charBuffer);
 514             int attributeLength = readInt(currentAttributeOffset + 2);
 515             currentAttributeOffset += 6;
 516             // The tests are sorted in decreasing frequency order (based on frequencies observed on
 517             // typical classes).
 518             if (Constants.SOURCE_FILE.equals(attributeName)) {
 519                 sourceFile = readUTF8(currentAttributeOffset, charBuffer);
 520             } else if (Constants.INNER_CLASSES.equals(attributeName)) {
 521                 innerClassesOffset = currentAttributeOffset;
 522             } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {
 523                 enclosingMethodOffset = currentAttributeOffset;
 524             } else if (Constants.NEST_HOST.equals(attributeName)) {
 525                 nestHostClass = readClass(currentAttributeOffset, charBuffer);
 526             } else if (Constants.NEST_MEMBERS.equals(attributeName)) {
 527                 nestMembersOffset = currentAttributeOffset;
 528             } else if (Constants.PERMITTED_SUBCLASSES.equals(attributeName)) {
 529                 permittedSubclassesOffset = currentAttributeOffset;
 530             } else if (Constants.SIGNATURE.equals(attributeName)) {
 531                 signature = readUTF8(currentAttributeOffset, charBuffer);
 532             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
 533                 runtimeVisibleAnnotationsOffset = currentAttributeOffset;
 534             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
 535                 runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;
 536             } else if (Constants.DEPRECATED.equals(attributeName)) {
 537                 accessFlags |= Opcodes.ACC_DEPRECATED;
 538             } else if (Constants.SYNTHETIC.equals(attributeName)) {
 539                 accessFlags |= Opcodes.ACC_SYNTHETIC;
 540             } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {
 541                 sourceDebugExtension =
 542                         readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);
 543             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
 544                 runtimeInvisibleAnnotationsOffset = currentAttributeOffset;
 545             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
 546                 runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;
 547             } else if (Constants.RECORD.equals(attributeName)) {
 548                 recordOffset = currentAttributeOffset;
 549                 accessFlags |= Opcodes.ACC_RECORD;
 550             } else if (Constants.MODULE.equals(attributeName)) {
 551                 moduleOffset = currentAttributeOffset;
 552             } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {
 553                 moduleMainClass = readClass(currentAttributeOffset, charBuffer);
 554             } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {
 555                 modulePackagesOffset = currentAttributeOffset;
 556             } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
 557                 // The BootstrapMethods attribute is read in the constructor.
 558                 Attribute attribute =
 559                         readAttribute(
 560                                 attributePrototypes,
 561                                 attributeName,
 562                                 currentAttributeOffset,
 563                                 attributeLength,
 564                                 charBuffer,
 565                                 -1,
 566                                 null);
 567                 attribute.nextAttribute = attributes;
 568                 attributes = attribute;
 569             }
 570             currentAttributeOffset += attributeLength;
 571         }
 572 
 573         // Visit the class declaration. The minor_version and major_version fields start 6 bytes before
 574         // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).
 575         classVisitor.visit(
 576                 readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);
 577 
 578         // Visit the SourceFile and SourceDebugExtenstion attributes.
 579         if ((parsingOptions &amp; SKIP_DEBUG) == 0
 580                 &amp;&amp; (sourceFile != null || sourceDebugExtension != null)) {
 581             classVisitor.visitSource(sourceFile, sourceDebugExtension);
 582         }
 583 
 584         // Visit the Module, ModulePackages and ModuleMainClass attributes.
 585         if (moduleOffset != 0) {
 586             readModuleAttributes(
 587                     classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);
 588         }
 589 
 590         // Visit the NestHost attribute.
 591         if (nestHostClass != null) {
 592             classVisitor.visitNestHost(nestHostClass);
 593         }
 594 
 595         // Visit the EnclosingMethod attribute.
 596         if (enclosingMethodOffset != 0) {
 597             String className = readClass(enclosingMethodOffset, charBuffer);
 598             int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);
 599             String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);
 600             String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);
 601             classVisitor.visitOuterClass(className, name, type);
 602         }
 603 
 604         // Visit the RuntimeVisibleAnnotations attribute.
 605         if (runtimeVisibleAnnotationsOffset != 0) {
 606             int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
 607             int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
 608             while (numAnnotations-- &gt; 0) {
 609                 // Parse the type_index field.
 610                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
 611                 currentAnnotationOffset += 2;
 612                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
 613                 currentAnnotationOffset =
 614                         readElementValues(
 615                                 classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),
 616                                 currentAnnotationOffset,
 617                                 /* named = */ true,
 618                                 charBuffer);
 619             }
 620         }
 621 
 622         // Visit the RuntimeInvisibleAnnotations attribute.
 623         if (runtimeInvisibleAnnotationsOffset != 0) {
 624             int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
 625             int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
 626             while (numAnnotations-- &gt; 0) {
 627                 // Parse the type_index field.
 628                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
 629                 currentAnnotationOffset += 2;
 630                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
 631                 currentAnnotationOffset =
 632                         readElementValues(
 633                                 classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),
 634                                 currentAnnotationOffset,
 635                                 /* named = */ true,
 636                                 charBuffer);
 637             }
 638         }
 639 
 640         // Visit the RuntimeVisibleTypeAnnotations attribute.
 641         if (runtimeVisibleTypeAnnotationsOffset != 0) {
 642             int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
 643             int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
 644             while (numAnnotations-- &gt; 0) {
 645                 // Parse the target_type, target_info and target_path fields.
 646                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
 647                 // Parse the type_index field.
 648                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
 649                 currentAnnotationOffset += 2;
 650                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
 651                 currentAnnotationOffset =
 652                         readElementValues(
 653                                 classVisitor.visitTypeAnnotation(
 654                                         context.currentTypeAnnotationTarget,
 655                                         context.currentTypeAnnotationTargetPath,
 656                                         annotationDescriptor,
 657                                         /* visible = */ true),
 658                                 currentAnnotationOffset,
 659                                 /* named = */ true,
 660                                 charBuffer);
 661             }
 662         }
 663 
 664         // Visit the RuntimeInvisibleTypeAnnotations attribute.
 665         if (runtimeInvisibleTypeAnnotationsOffset != 0) {
 666             int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
 667             int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
 668             while (numAnnotations-- &gt; 0) {
 669                 // Parse the target_type, target_info and target_path fields.
 670                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
 671                 // Parse the type_index field.
 672                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
 673                 currentAnnotationOffset += 2;
 674                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
 675                 currentAnnotationOffset =
 676                         readElementValues(
 677                                 classVisitor.visitTypeAnnotation(
 678                                         context.currentTypeAnnotationTarget,
 679                                         context.currentTypeAnnotationTargetPath,
 680                                         annotationDescriptor,
 681                                         /* visible = */ false),
 682                                 currentAnnotationOffset,
 683                                 /* named = */ true,
 684                                 charBuffer);
 685             }
 686         }
 687 
 688         // Visit the non standard attributes.
 689         while (attributes != null) {
 690             // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.
 691             Attribute nextAttribute = attributes.nextAttribute;
 692             attributes.nextAttribute = null;
 693             classVisitor.visitAttribute(attributes);
 694             attributes = nextAttribute;
 695         }
 696 
 697         // Visit the NestedMembers attribute.
 698         if (nestMembersOffset != 0) {
 699             int numberOfNestMembers = readUnsignedShort(nestMembersOffset);
 700             int currentNestMemberOffset = nestMembersOffset + 2;
 701             while (numberOfNestMembers-- &gt; 0) {
 702                 classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));
 703                 currentNestMemberOffset += 2;
 704             }
 705         }
 706 
 707         // Visit the PermittedSubclasses attribute.
 708         if (permittedSubclassesOffset != 0) {
 709             int numberOfPermittedSubclasses = readUnsignedShort(permittedSubclassesOffset);
 710             int currentPermittedSubclassOffset = permittedSubclassesOffset + 2;
 711             while (numberOfPermittedSubclasses-- &gt; 0) {
 712                 classVisitor.visitPermittedSubclassExperimental(
 713                         readClass(currentPermittedSubclassOffset, charBuffer));
 714                 currentPermittedSubclassOffset += 2;
 715             }
 716         }
 717 
 718         // Visit the InnerClasses attribute.
 719         if (innerClassesOffset != 0) {
 720             int numberOfClasses = readUnsignedShort(innerClassesOffset);
 721             int currentClassesOffset = innerClassesOffset + 2;
 722             while (numberOfClasses-- &gt; 0) {
 723                 classVisitor.visitInnerClass(
 724                         readClass(currentClassesOffset, charBuffer),
 725                         readClass(currentClassesOffset + 2, charBuffer),
 726                         readUTF8(currentClassesOffset + 4, charBuffer),
 727                         readUnsignedShort(currentClassesOffset + 6));
 728                 currentClassesOffset += 8;
 729             }
 730         }
 731 
 732         // Visit Record components.
 733         if (recordOffset != 0) {
 734             int recordComponentsCount = readUnsignedShort(recordOffset);
 735             recordOffset += 2;
 736             while (recordComponentsCount-- &gt; 0) {
 737                 recordOffset = readRecordComponent(classVisitor, context, recordOffset);
 738             }
 739         }
 740 
 741         // Visit the fields and methods.
 742         int fieldsCount = readUnsignedShort(currentOffset);
 743         currentOffset += 2;
 744         while (fieldsCount-- &gt; 0) {
 745             currentOffset = readField(classVisitor, context, currentOffset);
 746         }
 747         int methodsCount = readUnsignedShort(currentOffset);
 748         currentOffset += 2;
 749         while (methodsCount-- &gt; 0) {
 750             currentOffset = readMethod(classVisitor, context, currentOffset);
 751         }
 752 
 753         // Visit the end of the class.
 754         classVisitor.visitEnd();
 755     }
 756 
 757     // ----------------------------------------------------------------------------------------------
 758     // Methods to parse modules, fields and methods
 759     // ----------------------------------------------------------------------------------------------
 760 
 761     /**
 762       * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.
 763       *
 764       * @param classVisitor the current class visitor
 765       * @param context information about the class being parsed.
 766       * @param moduleOffset the offset of the Module attribute (excluding the attribute_info&#39;s
 767       *     attribute_name_index and attribute_length fields).
 768       * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
 769       *     attribute_info&#39;s attribute_name_index and attribute_length fields), or 0.
 770       * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal
 771       *     null}.
 772       */
 773     private void readModuleAttributes(
 774             final ClassVisitor classVisitor,
 775             final Context context,
 776             final int moduleOffset,
 777             final int modulePackagesOffset,
 778             final String moduleMainClass) {
 779         char[] buffer = context.charBuffer;
 780 
 781         // Read the module_name_index, module_flags and module_version_index fields and visit them.
 782         int currentOffset = moduleOffset;
 783         String moduleName = readModule(currentOffset, buffer);
 784         int moduleFlags = readUnsignedShort(currentOffset + 2);
 785         String moduleVersion = readUTF8(currentOffset + 4, buffer);
 786         currentOffset += 6;
 787         ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);
 788         if (moduleVisitor == null) {
 789             return;
 790         }
 791 
 792         // Visit the ModuleMainClass attribute.
 793         if (moduleMainClass != null) {
 794             moduleVisitor.visitMainClass(moduleMainClass);
 795         }
 796 
 797         // Visit the ModulePackages attribute.
 798         if (modulePackagesOffset != 0) {
 799             int packageCount = readUnsignedShort(modulePackagesOffset);
 800             int currentPackageOffset = modulePackagesOffset + 2;
 801             while (packageCount-- &gt; 0) {
 802                 moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));
 803                 currentPackageOffset += 2;
 804             }
 805         }
 806 
 807         // Read the &#39;requires_count&#39; and &#39;requires&#39; fields.
 808         int requiresCount = readUnsignedShort(currentOffset);
 809         currentOffset += 2;
 810         while (requiresCount-- &gt; 0) {
 811             // Read the requires_index, requires_flags and requires_version fields and visit them.
 812             String requires = readModule(currentOffset, buffer);
 813             int requiresFlags = readUnsignedShort(currentOffset + 2);
 814             String requiresVersion = readUTF8(currentOffset + 4, buffer);
 815             currentOffset += 6;
 816             moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);
 817         }
 818 
 819         // Read the &#39;exports_count&#39; and &#39;exports&#39; fields.
 820         int exportsCount = readUnsignedShort(currentOffset);
 821         currentOffset += 2;
 822         while (exportsCount-- &gt; 0) {
 823             // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields
 824             // and visit them.
 825             String exports = readPackage(currentOffset, buffer);
 826             int exportsFlags = readUnsignedShort(currentOffset + 2);
 827             int exportsToCount = readUnsignedShort(currentOffset + 4);
 828             currentOffset += 6;
 829             String[] exportsTo = null;
 830             if (exportsToCount != 0) {
 831                 exportsTo = new String[exportsToCount];
 832                 for (int i = 0; i &lt; exportsToCount; ++i) {
 833                     exportsTo[i] = readModule(currentOffset, buffer);
 834                     currentOffset += 2;
 835                 }
 836             }
 837             moduleVisitor.visitExport(exports, exportsFlags, exportsTo);
 838         }
 839 
 840         // Reads the &#39;opens_count&#39; and &#39;opens&#39; fields.
 841         int opensCount = readUnsignedShort(currentOffset);
 842         currentOffset += 2;
 843         while (opensCount-- &gt; 0) {
 844             // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.
 845             String opens = readPackage(currentOffset, buffer);
 846             int opensFlags = readUnsignedShort(currentOffset + 2);
 847             int opensToCount = readUnsignedShort(currentOffset + 4);
 848             currentOffset += 6;
 849             String[] opensTo = null;
 850             if (opensToCount != 0) {
 851                 opensTo = new String[opensToCount];
 852                 for (int i = 0; i &lt; opensToCount; ++i) {
 853                     opensTo[i] = readModule(currentOffset, buffer);
 854                     currentOffset += 2;
 855                 }
 856             }
 857             moduleVisitor.visitOpen(opens, opensFlags, opensTo);
 858         }
 859 
 860         // Read the &#39;uses_count&#39; and &#39;uses&#39; fields.
 861         int usesCount = readUnsignedShort(currentOffset);
 862         currentOffset += 2;
 863         while (usesCount-- &gt; 0) {
 864             moduleVisitor.visitUse(readClass(currentOffset, buffer));
 865             currentOffset += 2;
 866         }
 867 
 868         // Read the  &#39;provides_count&#39; and &#39;provides&#39; fields.
 869         int providesCount = readUnsignedShort(currentOffset);
 870         currentOffset += 2;
 871         while (providesCount-- &gt; 0) {
 872             // Read the provides_index, provides_with_count and provides_with_index fields and visit them.
 873             String provides = readClass(currentOffset, buffer);
 874             int providesWithCount = readUnsignedShort(currentOffset + 2);
 875             currentOffset += 4;
 876             String[] providesWith = new String[providesWithCount];
 877             for (int i = 0; i &lt; providesWithCount; ++i) {
 878                 providesWith[i] = readClass(currentOffset, buffer);
 879                 currentOffset += 2;
 880             }
 881             moduleVisitor.visitProvide(provides, providesWith);
 882         }
 883 
 884         // Visit the end of the module attributes.
 885         moduleVisitor.visitEnd();
 886     }
 887 
 888     /**
 889       * Reads a record component and visit it.
 890       *
 891       * @param classVisitor the current class visitor
 892       * @param context information about the class being parsed.
 893       * @param recordComponentOffset the offset of the current record component.
 894       * @return the offset of the first byte following the record component.
 895       */
 896     private int readRecordComponent(
 897             final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {
 898         char[] charBuffer = context.charBuffer;
 899 
 900         int currentOffset = recordComponentOffset;
 901         String name = readUTF8(currentOffset, charBuffer);
 902         String descriptor = readUTF8(currentOffset + 2, charBuffer);
 903         currentOffset += 4;
 904 
 905         // Read the record component attributes (the variables are ordered as in Section 4.7 of the
 906         // JVMS).
 907 
 908         // Attribute offsets exclude the attribute_name_index and attribute_length fields.
 909         // - The string corresponding to the Signature attribute, or null.
 910         String signature = null;
 911         // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
 912         int runtimeVisibleAnnotationsOffset = 0;
 913         // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
 914         int runtimeInvisibleAnnotationsOffset = 0;
 915         // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
 916         int runtimeVisibleTypeAnnotationsOffset = 0;
 917         // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
 918         int runtimeInvisibleTypeAnnotationsOffset = 0;
 919         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
 920         //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
 921         Attribute attributes = null;
 922 
 923         int attributesCount = readUnsignedShort(currentOffset);
 924         currentOffset += 2;
 925         while (attributesCount-- &gt; 0) {
 926             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
 927             String attributeName = readUTF8(currentOffset, charBuffer);
 928             int attributeLength = readInt(currentOffset + 2);
 929             currentOffset += 6;
 930             // The tests are sorted in decreasing frequency order (based on frequencies observed on
 931             // typical classes).
 932             if (Constants.SIGNATURE.equals(attributeName)) {
 933                 signature = readUTF8(currentOffset, charBuffer);
 934             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
 935                 runtimeVisibleAnnotationsOffset = currentOffset;
 936             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
 937                 runtimeVisibleTypeAnnotationsOffset = currentOffset;
 938             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
 939                 runtimeInvisibleAnnotationsOffset = currentOffset;
 940             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
 941                 runtimeInvisibleTypeAnnotationsOffset = currentOffset;
 942             } else {
 943                 Attribute attribute =
 944                         readAttribute(
 945                                 context.attributePrototypes,
 946                                 attributeName,
 947                                 currentOffset,
 948                                 attributeLength,
 949                                 charBuffer,
 950                                 -1,
 951                                 null);
 952                 attribute.nextAttribute = attributes;
 953                 attributes = attribute;
 954             }
 955             currentOffset += attributeLength;
 956         }
 957 
 958         RecordComponentVisitor recordComponentVisitor =
 959                 classVisitor.visitRecordComponent(name, descriptor, signature);
 960         if (recordComponentVisitor == null) {
 961             return currentOffset;
 962         }
 963 
 964         // Visit the RuntimeVisibleAnnotations attribute.
 965         if (runtimeVisibleAnnotationsOffset != 0) {
 966             int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
 967             int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
 968             while (numAnnotations-- &gt; 0) {
 969                 // Parse the type_index field.
 970                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
 971                 currentAnnotationOffset += 2;
 972                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
 973                 currentAnnotationOffset =
 974                         readElementValues(
 975                                 recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),
 976                                 currentAnnotationOffset,
 977                                 /* named = */ true,
 978                                 charBuffer);
 979             }
 980         }
 981 
 982         // Visit the RuntimeInvisibleAnnotations attribute.
 983         if (runtimeInvisibleAnnotationsOffset != 0) {
 984             int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
 985             int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
 986             while (numAnnotations-- &gt; 0) {
 987                 // Parse the type_index field.
 988                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
 989                 currentAnnotationOffset += 2;
 990                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
 991                 currentAnnotationOffset =
 992                         readElementValues(
 993                                 recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),
 994                                 currentAnnotationOffset,
 995                                 /* named = */ true,
 996                                 charBuffer);
 997             }
 998         }
 999 
1000         // Visit the RuntimeVisibleTypeAnnotations attribute.
1001         if (runtimeVisibleTypeAnnotationsOffset != 0) {
1002             int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
1003             int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
1004             while (numAnnotations-- &gt; 0) {
1005                 // Parse the target_type, target_info and target_path fields.
1006                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
1007                 // Parse the type_index field.
1008                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1009                 currentAnnotationOffset += 2;
1010                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1011                 currentAnnotationOffset =
1012                         readElementValues(
1013                                 recordComponentVisitor.visitTypeAnnotation(
1014                                         context.currentTypeAnnotationTarget,
1015                                         context.currentTypeAnnotationTargetPath,
1016                                         annotationDescriptor,
1017                                         /* visible = */ true),
1018                                 currentAnnotationOffset,
1019                                 /* named = */ true,
1020                                 charBuffer);
1021             }
1022         }
1023 
1024         // Visit the RuntimeInvisibleTypeAnnotations attribute.
1025         if (runtimeInvisibleTypeAnnotationsOffset != 0) {
1026             int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
1027             int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
1028             while (numAnnotations-- &gt; 0) {
1029                 // Parse the target_type, target_info and target_path fields.
1030                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
1031                 // Parse the type_index field.
1032                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1033                 currentAnnotationOffset += 2;
1034                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1035                 currentAnnotationOffset =
1036                         readElementValues(
1037                                 recordComponentVisitor.visitTypeAnnotation(
1038                                         context.currentTypeAnnotationTarget,
1039                                         context.currentTypeAnnotationTargetPath,
1040                                         annotationDescriptor,
1041                                         /* visible = */ false),
1042                                 currentAnnotationOffset,
1043                                 /* named = */ true,
1044                                 charBuffer);
1045             }
1046         }
1047 
1048         // Visit the non standard attributes.
1049         while (attributes != null) {
1050             // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.
1051             Attribute nextAttribute = attributes.nextAttribute;
1052             attributes.nextAttribute = null;
1053             recordComponentVisitor.visitAttribute(attributes);
1054             attributes = nextAttribute;
1055         }
1056 
1057         // Visit the end of the field.
1058         recordComponentVisitor.visitEnd();
1059         return currentOffset;
1060     }
1061 
1062     /**
1063       * Reads a JVMS field_info structure and makes the given visitor visit it.
1064       *
1065       * @param classVisitor the visitor that must visit the field.
1066       * @param context information about the class being parsed.
1067       * @param fieldInfoOffset the start offset of the field_info structure.
1068       * @return the offset of the first byte following the field_info structure.
1069       */
1070     private int readField(
1071             final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {
1072         char[] charBuffer = context.charBuffer;
1073 
1074         // Read the access_flags, name_index and descriptor_index fields.
1075         int currentOffset = fieldInfoOffset;
1076         int accessFlags = readUnsignedShort(currentOffset);
1077         String name = readUTF8(currentOffset + 2, charBuffer);
1078         String descriptor = readUTF8(currentOffset + 4, charBuffer);
1079         currentOffset += 6;
1080 
1081         // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).
1082         // Attribute offsets exclude the attribute_name_index and attribute_length fields.
1083         // - The value corresponding to the ConstantValue attribute, or null.
1084         Object constantValue = null;
1085         // - The string corresponding to the Signature attribute, or null.
1086         String signature = null;
1087         // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
1088         int runtimeVisibleAnnotationsOffset = 0;
1089         // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
1090         int runtimeInvisibleAnnotationsOffset = 0;
1091         // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
1092         int runtimeVisibleTypeAnnotationsOffset = 0;
1093         // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
1094         int runtimeInvisibleTypeAnnotationsOffset = 0;
1095         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
1096         //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
1097         Attribute attributes = null;
1098 
1099         int attributesCount = readUnsignedShort(currentOffset);
1100         currentOffset += 2;
1101         while (attributesCount-- &gt; 0) {
1102             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
1103             String attributeName = readUTF8(currentOffset, charBuffer);
1104             int attributeLength = readInt(currentOffset + 2);
1105             currentOffset += 6;
1106             // The tests are sorted in decreasing frequency order (based on frequencies observed on
1107             // typical classes).
1108             if (Constants.CONSTANT_VALUE.equals(attributeName)) {
1109                 int constantvalueIndex = readUnsignedShort(currentOffset);
1110                 constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);
1111             } else if (Constants.SIGNATURE.equals(attributeName)) {
1112                 signature = readUTF8(currentOffset, charBuffer);
1113             } else if (Constants.DEPRECATED.equals(attributeName)) {
1114                 accessFlags |= Opcodes.ACC_DEPRECATED;
1115             } else if (Constants.SYNTHETIC.equals(attributeName)) {
1116                 accessFlags |= Opcodes.ACC_SYNTHETIC;
1117             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
1118                 runtimeVisibleAnnotationsOffset = currentOffset;
1119             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
1120                 runtimeVisibleTypeAnnotationsOffset = currentOffset;
1121             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
1122                 runtimeInvisibleAnnotationsOffset = currentOffset;
1123             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
1124                 runtimeInvisibleTypeAnnotationsOffset = currentOffset;
1125             } else {
1126                 Attribute attribute =
1127                         readAttribute(
1128                                 context.attributePrototypes,
1129                                 attributeName,
1130                                 currentOffset,
1131                                 attributeLength,
1132                                 charBuffer,
1133                                 -1,
1134                                 null);
1135                 attribute.nextAttribute = attributes;
1136                 attributes = attribute;
1137             }
1138             currentOffset += attributeLength;
1139         }
1140 
1141         // Visit the field declaration.
1142         FieldVisitor fieldVisitor =
1143                 classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);
1144         if (fieldVisitor == null) {
1145             return currentOffset;
1146         }
1147 
1148         // Visit the RuntimeVisibleAnnotations attribute.
1149         if (runtimeVisibleAnnotationsOffset != 0) {
1150             int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
1151             int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
1152             while (numAnnotations-- &gt; 0) {
1153                 // Parse the type_index field.
1154                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1155                 currentAnnotationOffset += 2;
1156                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1157                 currentAnnotationOffset =
1158                         readElementValues(
1159                                 fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),
1160                                 currentAnnotationOffset,
1161                                 /* named = */ true,
1162                                 charBuffer);
1163             }
1164         }
1165 
1166         // Visit the RuntimeInvisibleAnnotations attribute.
1167         if (runtimeInvisibleAnnotationsOffset != 0) {
1168             int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
1169             int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
1170             while (numAnnotations-- &gt; 0) {
1171                 // Parse the type_index field.
1172                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1173                 currentAnnotationOffset += 2;
1174                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1175                 currentAnnotationOffset =
1176                         readElementValues(
1177                                 fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),
1178                                 currentAnnotationOffset,
1179                                 /* named = */ true,
1180                                 charBuffer);
1181             }
1182         }
1183 
1184         // Visit the RuntimeVisibleTypeAnnotations attribute.
1185         if (runtimeVisibleTypeAnnotationsOffset != 0) {
1186             int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
1187             int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
1188             while (numAnnotations-- &gt; 0) {
1189                 // Parse the target_type, target_info and target_path fields.
1190                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
1191                 // Parse the type_index field.
1192                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1193                 currentAnnotationOffset += 2;
1194                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1195                 currentAnnotationOffset =
1196                         readElementValues(
1197                                 fieldVisitor.visitTypeAnnotation(
1198                                         context.currentTypeAnnotationTarget,
1199                                         context.currentTypeAnnotationTargetPath,
1200                                         annotationDescriptor,
1201                                         /* visible = */ true),
1202                                 currentAnnotationOffset,
1203                                 /* named = */ true,
1204                                 charBuffer);
1205             }
1206         }
1207 
1208         // Visit the RuntimeInvisibleTypeAnnotations attribute.
1209         if (runtimeInvisibleTypeAnnotationsOffset != 0) {
1210             int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
1211             int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
1212             while (numAnnotations-- &gt; 0) {
1213                 // Parse the target_type, target_info and target_path fields.
1214                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
1215                 // Parse the type_index field.
1216                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1217                 currentAnnotationOffset += 2;
1218                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1219                 currentAnnotationOffset =
1220                         readElementValues(
1221                                 fieldVisitor.visitTypeAnnotation(
1222                                         context.currentTypeAnnotationTarget,
1223                                         context.currentTypeAnnotationTargetPath,
1224                                         annotationDescriptor,
1225                                         /* visible = */ false),
1226                                 currentAnnotationOffset,
1227                                 /* named = */ true,
1228                                 charBuffer);
1229             }
1230         }
1231 
1232         // Visit the non standard attributes.
1233         while (attributes != null) {
1234             // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.
1235             Attribute nextAttribute = attributes.nextAttribute;
1236             attributes.nextAttribute = null;
1237             fieldVisitor.visitAttribute(attributes);
1238             attributes = nextAttribute;
1239         }
1240 
1241         // Visit the end of the field.
1242         fieldVisitor.visitEnd();
1243         return currentOffset;
1244     }
1245 
1246     /**
1247       * Reads a JVMS method_info structure and makes the given visitor visit it.
1248       *
1249       * @param classVisitor the visitor that must visit the method.
1250       * @param context information about the class being parsed.
1251       * @param methodInfoOffset the start offset of the method_info structure.
1252       * @return the offset of the first byte following the method_info structure.
1253       */
1254     private int readMethod(
1255             final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {
1256         char[] charBuffer = context.charBuffer;
1257 
1258         // Read the access_flags, name_index and descriptor_index fields.
1259         int currentOffset = methodInfoOffset;
1260         context.currentMethodAccessFlags = readUnsignedShort(currentOffset);
1261         context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);
1262         context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);
1263         currentOffset += 6;
1264 
1265         // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).
1266         // Attribute offsets exclude the attribute_name_index and attribute_length fields.
1267         // - The offset of the Code attribute, or 0.
1268         int codeOffset = 0;
1269         // - The offset of the Exceptions attribute, or 0.
1270         int exceptionsOffset = 0;
1271         // - The strings corresponding to the Exceptions attribute, or null.
1272         String[] exceptions = null;
1273         // - Whether the method has a Synthetic attribute.
1274         boolean synthetic = false;
1275         // - The constant pool index contained in the Signature attribute, or 0.
1276         int signatureIndex = 0;
1277         // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
1278         int runtimeVisibleAnnotationsOffset = 0;
1279         // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
1280         int runtimeInvisibleAnnotationsOffset = 0;
1281         // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.
1282         int runtimeVisibleParameterAnnotationsOffset = 0;
1283         // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.
1284         int runtimeInvisibleParameterAnnotationsOffset = 0;
1285         // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
1286         int runtimeVisibleTypeAnnotationsOffset = 0;
1287         // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
1288         int runtimeInvisibleTypeAnnotationsOffset = 0;
1289         // - The offset of the AnnotationDefault attribute, or 0.
1290         int annotationDefaultOffset = 0;
1291         // - The offset of the MethodParameters attribute, or 0.
1292         int methodParametersOffset = 0;
1293         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
1294         //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
1295         Attribute attributes = null;
1296 
1297         int attributesCount = readUnsignedShort(currentOffset);
1298         currentOffset += 2;
1299         while (attributesCount-- &gt; 0) {
1300             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
1301             String attributeName = readUTF8(currentOffset, charBuffer);
1302             int attributeLength = readInt(currentOffset + 2);
1303             currentOffset += 6;
1304             // The tests are sorted in decreasing frequency order (based on frequencies observed on
1305             // typical classes).
1306             if (Constants.CODE.equals(attributeName)) {
1307                 if ((context.parsingOptions &amp; SKIP_CODE) == 0) {
1308                     codeOffset = currentOffset;
1309                 }
1310             } else if (Constants.EXCEPTIONS.equals(attributeName)) {
1311                 exceptionsOffset = currentOffset;
1312                 exceptions = new String[readUnsignedShort(exceptionsOffset)];
1313                 int currentExceptionOffset = exceptionsOffset + 2;
1314                 for (int i = 0; i &lt; exceptions.length; ++i) {
1315                     exceptions[i] = readClass(currentExceptionOffset, charBuffer);
1316                     currentExceptionOffset += 2;
1317                 }
1318             } else if (Constants.SIGNATURE.equals(attributeName)) {
1319                 signatureIndex = readUnsignedShort(currentOffset);
1320             } else if (Constants.DEPRECATED.equals(attributeName)) {
1321                 context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;
1322             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
1323                 runtimeVisibleAnnotationsOffset = currentOffset;
1324             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
1325                 runtimeVisibleTypeAnnotationsOffset = currentOffset;
1326             } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {
1327                 annotationDefaultOffset = currentOffset;
1328             } else if (Constants.SYNTHETIC.equals(attributeName)) {
1329                 synthetic = true;
1330                 context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;
1331             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
1332                 runtimeInvisibleAnnotationsOffset = currentOffset;
1333             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
1334                 runtimeInvisibleTypeAnnotationsOffset = currentOffset;
1335             } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {
1336                 runtimeVisibleParameterAnnotationsOffset = currentOffset;
1337             } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {
1338                 runtimeInvisibleParameterAnnotationsOffset = currentOffset;
1339             } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {
1340                 methodParametersOffset = currentOffset;
1341             } else {
1342                 Attribute attribute =
1343                         readAttribute(
1344                                 context.attributePrototypes,
1345                                 attributeName,
1346                                 currentOffset,
1347                                 attributeLength,
1348                                 charBuffer,
1349                                 -1,
1350                                 null);
1351                 attribute.nextAttribute = attributes;
1352                 attributes = attribute;
1353             }
1354             currentOffset += attributeLength;
1355         }
1356 
1357         // Visit the method declaration.
1358         MethodVisitor methodVisitor =
1359                 classVisitor.visitMethod(
1360                         context.currentMethodAccessFlags,
1361                         context.currentMethodName,
1362                         context.currentMethodDescriptor,
1363                         signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer),
1364                         exceptions);
1365         if (methodVisitor == null) {
1366             return currentOffset;
1367         }
1368 
1369         // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method
1370         // adapter between the reader and the writer. In this case, it might be possible to copy
1371         // the method attributes directly into the writer. If so, return early without visiting
1372         // the content of these attributes.
1373         if (methodVisitor instanceof MethodWriter) {
1374             MethodWriter methodWriter = (MethodWriter) methodVisitor;
1375             if (methodWriter.canCopyMethodAttributes(
1376                     this,
1377                     synthetic,
1378                     (context.currentMethodAccessFlags &amp; Opcodes.ACC_DEPRECATED) != 0,
1379                     readUnsignedShort(methodInfoOffset + 4),
1380                     signatureIndex,
1381                     exceptionsOffset)) {
1382                 methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);
1383                 return currentOffset;
1384             }
1385         }
1386 
1387         // Visit the MethodParameters attribute.
1388         if (methodParametersOffset != 0 &amp;&amp; (context.parsingOptions &amp; SKIP_DEBUG) == 0) {
1389             int parametersCount = readByte(methodParametersOffset);
1390             int currentParameterOffset = methodParametersOffset + 1;
1391             while (parametersCount-- &gt; 0) {
1392                 // Read the name_index and access_flags fields and visit them.
1393                 methodVisitor.visitParameter(
1394                         readUTF8(currentParameterOffset, charBuffer),
1395                         readUnsignedShort(currentParameterOffset + 2));
1396                 currentParameterOffset += 4;
1397             }
1398         }
1399 
1400         // Visit the AnnotationDefault attribute.
1401         if (annotationDefaultOffset != 0) {
1402             AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();
1403             readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);
1404             if (annotationVisitor != null) {
1405                 annotationVisitor.visitEnd();
1406             }
1407         }
1408 
1409         // Visit the RuntimeVisibleAnnotations attribute.
1410         if (runtimeVisibleAnnotationsOffset != 0) {
1411             int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
1412             int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
1413             while (numAnnotations-- &gt; 0) {
1414                 // Parse the type_index field.
1415                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1416                 currentAnnotationOffset += 2;
1417                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1418                 currentAnnotationOffset =
1419                         readElementValues(
1420                                 methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),
1421                                 currentAnnotationOffset,
1422                                 /* named = */ true,
1423                                 charBuffer);
1424             }
1425         }
1426 
1427         // Visit the RuntimeInvisibleAnnotations attribute.
1428         if (runtimeInvisibleAnnotationsOffset != 0) {
1429             int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
1430             int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
1431             while (numAnnotations-- &gt; 0) {
1432                 // Parse the type_index field.
1433                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1434                 currentAnnotationOffset += 2;
1435                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1436                 currentAnnotationOffset =
1437                         readElementValues(
1438                                 methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),
1439                                 currentAnnotationOffset,
1440                                 /* named = */ true,
1441                                 charBuffer);
1442             }
1443         }
1444 
1445         // Visit the RuntimeVisibleTypeAnnotations attribute.
1446         if (runtimeVisibleTypeAnnotationsOffset != 0) {
1447             int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
1448             int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
1449             while (numAnnotations-- &gt; 0) {
1450                 // Parse the target_type, target_info and target_path fields.
1451                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
1452                 // Parse the type_index field.
1453                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1454                 currentAnnotationOffset += 2;
1455                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1456                 currentAnnotationOffset =
1457                         readElementValues(
1458                                 methodVisitor.visitTypeAnnotation(
1459                                         context.currentTypeAnnotationTarget,
1460                                         context.currentTypeAnnotationTargetPath,
1461                                         annotationDescriptor,
1462                                         /* visible = */ true),
1463                                 currentAnnotationOffset,
1464                                 /* named = */ true,
1465                                 charBuffer);
1466             }
1467         }
1468 
1469         // Visit the RuntimeInvisibleTypeAnnotations attribute.
1470         if (runtimeInvisibleTypeAnnotationsOffset != 0) {
1471             int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
1472             int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
1473             while (numAnnotations-- &gt; 0) {
1474                 // Parse the target_type, target_info and target_path fields.
1475                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
1476                 // Parse the type_index field.
1477                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
1478                 currentAnnotationOffset += 2;
1479                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
1480                 currentAnnotationOffset =
1481                         readElementValues(
1482                                 methodVisitor.visitTypeAnnotation(
1483                                         context.currentTypeAnnotationTarget,
1484                                         context.currentTypeAnnotationTargetPath,
1485                                         annotationDescriptor,
1486                                         /* visible = */ false),
1487                                 currentAnnotationOffset,
1488                                 /* named = */ true,
1489                                 charBuffer);
1490             }
1491         }
1492 
1493         // Visit the RuntimeVisibleParameterAnnotations attribute.
1494         if (runtimeVisibleParameterAnnotationsOffset != 0) {
1495             readParameterAnnotations(
1496                     methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible = */ true);
1497         }
1498 
1499         // Visit the RuntimeInvisibleParameterAnnotations attribute.
1500         if (runtimeInvisibleParameterAnnotationsOffset != 0) {
1501             readParameterAnnotations(
1502                     methodVisitor,
1503                     context,
1504                     runtimeInvisibleParameterAnnotationsOffset,
1505                     /* visible = */ false);
1506         }
1507 
1508         // Visit the non standard attributes.
1509         while (attributes != null) {
1510             // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.
1511             Attribute nextAttribute = attributes.nextAttribute;
1512             attributes.nextAttribute = null;
1513             methodVisitor.visitAttribute(attributes);
1514             attributes = nextAttribute;
1515         }
1516 
1517         // Visit the Code attribute.
1518         if (codeOffset != 0) {
1519             methodVisitor.visitCode();
1520             readCode(methodVisitor, context, codeOffset);
1521         }
1522 
1523         // Visit the end of the method.
1524         methodVisitor.visitEnd();
1525         return currentOffset;
1526     }
1527 
1528     // ----------------------------------------------------------------------------------------------
1529     // Methods to parse a Code attribute
1530     // ----------------------------------------------------------------------------------------------
1531 
1532     /**
1533       * Reads a JVMS &#39;Code&#39; attribute and makes the given visitor visit it.
1534       *
1535       * @param methodVisitor the visitor that must visit the Code attribute.
1536       * @param context information about the class being parsed.
1537       * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding
1538       *     its attribute_name_index and attribute_length fields.
1539       */
1540     private void readCode(
1541             final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
1542         int currentOffset = codeOffset;
1543 
1544         // Read the max_stack, max_locals and code_length fields.
1545         final byte[] classBuffer = classFileBuffer;
1546         final char[] charBuffer = context.charBuffer;
1547         final int maxStack = readUnsignedShort(currentOffset);
1548         final int maxLocals = readUnsignedShort(currentOffset + 2);
1549         final int codeLength = readInt(currentOffset + 4);
1550         currentOffset += 8;
1551 
1552         // Read the bytecode &#39;code&#39; array to create a label for each referenced instruction.
1553         final int bytecodeStartOffset = currentOffset;
1554         final int bytecodeEndOffset = currentOffset + codeLength;
1555         final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];
1556         while (currentOffset &lt; bytecodeEndOffset) {
1557             final int bytecodeOffset = currentOffset - bytecodeStartOffset;
1558             final int opcode = classBuffer[currentOffset] &amp; 0xFF;
1559             switch (opcode) {
1560                 case Opcodes.NOP:
1561                 case Opcodes.ACONST_NULL:
1562                 case Opcodes.ICONST_M1:
1563                 case Opcodes.ICONST_0:
1564                 case Opcodes.ICONST_1:
1565                 case Opcodes.ICONST_2:
1566                 case Opcodes.ICONST_3:
1567                 case Opcodes.ICONST_4:
1568                 case Opcodes.ICONST_5:
1569                 case Opcodes.LCONST_0:
1570                 case Opcodes.LCONST_1:
1571                 case Opcodes.FCONST_0:
1572                 case Opcodes.FCONST_1:
1573                 case Opcodes.FCONST_2:
1574                 case Opcodes.DCONST_0:
1575                 case Opcodes.DCONST_1:
1576                 case Opcodes.IALOAD:
1577                 case Opcodes.LALOAD:
1578                 case Opcodes.FALOAD:
1579                 case Opcodes.DALOAD:
1580                 case Opcodes.AALOAD:
1581                 case Opcodes.BALOAD:
1582                 case Opcodes.CALOAD:
1583                 case Opcodes.SALOAD:
1584                 case Opcodes.IASTORE:
1585                 case Opcodes.LASTORE:
1586                 case Opcodes.FASTORE:
1587                 case Opcodes.DASTORE:
1588                 case Opcodes.AASTORE:
1589                 case Opcodes.BASTORE:
1590                 case Opcodes.CASTORE:
1591                 case Opcodes.SASTORE:
1592                 case Opcodes.POP:
1593                 case Opcodes.POP2:
1594                 case Opcodes.DUP:
1595                 case Opcodes.DUP_X1:
1596                 case Opcodes.DUP_X2:
1597                 case Opcodes.DUP2:
1598                 case Opcodes.DUP2_X1:
1599                 case Opcodes.DUP2_X2:
1600                 case Opcodes.SWAP:
1601                 case Opcodes.IADD:
1602                 case Opcodes.LADD:
1603                 case Opcodes.FADD:
1604                 case Opcodes.DADD:
1605                 case Opcodes.ISUB:
1606                 case Opcodes.LSUB:
1607                 case Opcodes.FSUB:
1608                 case Opcodes.DSUB:
1609                 case Opcodes.IMUL:
1610                 case Opcodes.LMUL:
1611                 case Opcodes.FMUL:
1612                 case Opcodes.DMUL:
1613                 case Opcodes.IDIV:
1614                 case Opcodes.LDIV:
1615                 case Opcodes.FDIV:
1616                 case Opcodes.DDIV:
1617                 case Opcodes.IREM:
1618                 case Opcodes.LREM:
1619                 case Opcodes.FREM:
1620                 case Opcodes.DREM:
1621                 case Opcodes.INEG:
1622                 case Opcodes.LNEG:
1623                 case Opcodes.FNEG:
1624                 case Opcodes.DNEG:
1625                 case Opcodes.ISHL:
1626                 case Opcodes.LSHL:
1627                 case Opcodes.ISHR:
1628                 case Opcodes.LSHR:
1629                 case Opcodes.IUSHR:
1630                 case Opcodes.LUSHR:
1631                 case Opcodes.IAND:
1632                 case Opcodes.LAND:
1633                 case Opcodes.IOR:
1634                 case Opcodes.LOR:
1635                 case Opcodes.IXOR:
1636                 case Opcodes.LXOR:
1637                 case Opcodes.I2L:
1638                 case Opcodes.I2F:
1639                 case Opcodes.I2D:
1640                 case Opcodes.L2I:
1641                 case Opcodes.L2F:
1642                 case Opcodes.L2D:
1643                 case Opcodes.F2I:
1644                 case Opcodes.F2L:
1645                 case Opcodes.F2D:
1646                 case Opcodes.D2I:
1647                 case Opcodes.D2L:
1648                 case Opcodes.D2F:
1649                 case Opcodes.I2B:
1650                 case Opcodes.I2C:
1651                 case Opcodes.I2S:
1652                 case Opcodes.LCMP:
1653                 case Opcodes.FCMPL:
1654                 case Opcodes.FCMPG:
1655                 case Opcodes.DCMPL:
1656                 case Opcodes.DCMPG:
1657                 case Opcodes.IRETURN:
1658                 case Opcodes.LRETURN:
1659                 case Opcodes.FRETURN:
1660                 case Opcodes.DRETURN:
1661                 case Opcodes.ARETURN:
1662                 case Opcodes.RETURN:
1663                 case Opcodes.ARRAYLENGTH:
1664                 case Opcodes.ATHROW:
1665                 case Opcodes.MONITORENTER:
1666                 case Opcodes.MONITOREXIT:
1667                 case Constants.ILOAD_0:
1668                 case Constants.ILOAD_1:
1669                 case Constants.ILOAD_2:
1670                 case Constants.ILOAD_3:
1671                 case Constants.LLOAD_0:
1672                 case Constants.LLOAD_1:
1673                 case Constants.LLOAD_2:
1674                 case Constants.LLOAD_3:
1675                 case Constants.FLOAD_0:
1676                 case Constants.FLOAD_1:
1677                 case Constants.FLOAD_2:
1678                 case Constants.FLOAD_3:
1679                 case Constants.DLOAD_0:
1680                 case Constants.DLOAD_1:
1681                 case Constants.DLOAD_2:
1682                 case Constants.DLOAD_3:
1683                 case Constants.ALOAD_0:
1684                 case Constants.ALOAD_1:
1685                 case Constants.ALOAD_2:
1686                 case Constants.ALOAD_3:
1687                 case Constants.ISTORE_0:
1688                 case Constants.ISTORE_1:
1689                 case Constants.ISTORE_2:
1690                 case Constants.ISTORE_3:
1691                 case Constants.LSTORE_0:
1692                 case Constants.LSTORE_1:
1693                 case Constants.LSTORE_2:
1694                 case Constants.LSTORE_3:
1695                 case Constants.FSTORE_0:
1696                 case Constants.FSTORE_1:
1697                 case Constants.FSTORE_2:
1698                 case Constants.FSTORE_3:
1699                 case Constants.DSTORE_0:
1700                 case Constants.DSTORE_1:
1701                 case Constants.DSTORE_2:
1702                 case Constants.DSTORE_3:
1703                 case Constants.ASTORE_0:
1704                 case Constants.ASTORE_1:
1705                 case Constants.ASTORE_2:
1706                 case Constants.ASTORE_3:
1707                     currentOffset += 1;
1708                     break;
1709                 case Opcodes.IFEQ:
1710                 case Opcodes.IFNE:
1711                 case Opcodes.IFLT:
1712                 case Opcodes.IFGE:
1713                 case Opcodes.IFGT:
1714                 case Opcodes.IFLE:
1715                 case Opcodes.IF_ICMPEQ:
1716                 case Opcodes.IF_ICMPNE:
1717                 case Opcodes.IF_ICMPLT:
1718                 case Opcodes.IF_ICMPGE:
1719                 case Opcodes.IF_ICMPGT:
1720                 case Opcodes.IF_ICMPLE:
1721                 case Opcodes.IF_ACMPEQ:
1722                 case Opcodes.IF_ACMPNE:
1723                 case Opcodes.GOTO:
1724                 case Opcodes.JSR:
1725                 case Opcodes.IFNULL:
1726                 case Opcodes.IFNONNULL:
1727                     createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);
1728                     currentOffset += 3;
1729                     break;
1730                 case Constants.ASM_IFEQ:
1731                 case Constants.ASM_IFNE:
1732                 case Constants.ASM_IFLT:
1733                 case Constants.ASM_IFGE:
1734                 case Constants.ASM_IFGT:
1735                 case Constants.ASM_IFLE:
1736                 case Constants.ASM_IF_ICMPEQ:
1737                 case Constants.ASM_IF_ICMPNE:
1738                 case Constants.ASM_IF_ICMPLT:
1739                 case Constants.ASM_IF_ICMPGE:
1740                 case Constants.ASM_IF_ICMPGT:
1741                 case Constants.ASM_IF_ICMPLE:
1742                 case Constants.ASM_IF_ACMPEQ:
1743                 case Constants.ASM_IF_ACMPNE:
1744                 case Constants.ASM_GOTO:
1745                 case Constants.ASM_JSR:
1746                 case Constants.ASM_IFNULL:
1747                 case Constants.ASM_IFNONNULL:
1748                     createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);
1749                     currentOffset += 3;
1750                     break;
1751                 case Constants.GOTO_W:
1752                 case Constants.JSR_W:
1753                 case Constants.ASM_GOTO_W:
1754                     createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);
1755                     currentOffset += 5;
1756                     break;
1757                 case Constants.WIDE:
1758                     switch (classBuffer[currentOffset + 1] &amp; 0xFF) {
1759                         case Opcodes.ILOAD:
1760                         case Opcodes.FLOAD:
1761                         case Opcodes.ALOAD:
1762                         case Opcodes.LLOAD:
1763                         case Opcodes.DLOAD:
1764                         case Opcodes.ISTORE:
1765                         case Opcodes.FSTORE:
1766                         case Opcodes.ASTORE:
1767                         case Opcodes.LSTORE:
1768                         case Opcodes.DSTORE:
1769                         case Opcodes.RET:
1770                             currentOffset += 4;
1771                             break;
1772                         case Opcodes.IINC:
1773                             currentOffset += 6;
1774                             break;
1775                         default:
1776                             throw new IllegalArgumentException();
1777                     }
1778                     break;
1779                 case Opcodes.TABLESWITCH:
1780                     // Skip 0 to 3 padding bytes.
1781                     currentOffset += 4 - (bytecodeOffset &amp; 3);
1782                     // Read the default label and the number of table entries.
1783                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
1784                     int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;
1785                     currentOffset += 12;
1786                     // Read the table labels.
1787                     while (numTableEntries-- &gt; 0) {
1788                         createLabel(bytecodeOffset + readInt(currentOffset), labels);
1789                         currentOffset += 4;
1790                     }
1791                     break;
1792                 case Opcodes.LOOKUPSWITCH:
1793                     // Skip 0 to 3 padding bytes.
1794                     currentOffset += 4 - (bytecodeOffset &amp; 3);
1795                     // Read the default label and the number of switch cases.
1796                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
1797                     int numSwitchCases = readInt(currentOffset + 4);
1798                     currentOffset += 8;
1799                     // Read the switch labels.
1800                     while (numSwitchCases-- &gt; 0) {
1801                         createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);
1802                         currentOffset += 8;
1803                     }
1804                     break;
1805                 case Opcodes.ILOAD:
1806                 case Opcodes.LLOAD:
1807                 case Opcodes.FLOAD:
1808                 case Opcodes.DLOAD:
1809                 case Opcodes.ALOAD:
1810                 case Opcodes.ISTORE:
1811                 case Opcodes.LSTORE:
1812                 case Opcodes.FSTORE:
1813                 case Opcodes.DSTORE:
1814                 case Opcodes.ASTORE:
1815                 case Opcodes.RET:
1816                 case Opcodes.BIPUSH:
1817                 case Opcodes.NEWARRAY:
1818                 case Opcodes.LDC:
1819                     currentOffset += 2;
1820                     break;
1821                 case Opcodes.SIPUSH:
1822                 case Constants.LDC_W:
1823                 case Constants.LDC2_W:
1824                 case Opcodes.GETSTATIC:
1825                 case Opcodes.PUTSTATIC:
1826                 case Opcodes.GETFIELD:
1827                 case Opcodes.PUTFIELD:
<a name="1" id="anc1"></a><span class="line-added">1828                 case Opcodes.DEFAULT:</span>
<span class="line-added">1829                 case Opcodes.WITHFIELD:</span>
1830                 case Opcodes.INVOKEVIRTUAL:
1831                 case Opcodes.INVOKESPECIAL:
1832                 case Opcodes.INVOKESTATIC:
1833                 case Opcodes.NEW:
1834                 case Opcodes.ANEWARRAY:
1835                 case Opcodes.CHECKCAST:
1836                 case Opcodes.INSTANCEOF:
1837                 case Opcodes.IINC:
1838                     currentOffset += 3;
1839                     break;
1840                 case Opcodes.INVOKEINTERFACE:
1841                 case Opcodes.INVOKEDYNAMIC:
1842                     currentOffset += 5;
1843                     break;
1844                 case Opcodes.MULTIANEWARRAY:
1845                     currentOffset += 4;
1846                     break;
1847                 default:
1848                     throw new IllegalArgumentException();
1849             }
1850         }
1851 
1852         // Read the &#39;exception_table_length&#39; and &#39;exception_table&#39; field to create a label for each
1853         // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.
1854         int exceptionTableLength = readUnsignedShort(currentOffset);
1855         currentOffset += 2;
1856         while (exceptionTableLength-- &gt; 0) {
1857             Label start = createLabel(readUnsignedShort(currentOffset), labels);
1858             Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);
1859             Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);
1860             String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);
1861             currentOffset += 8;
1862             methodVisitor.visitTryCatchBlock(start, end, handler, catchType);
1863         }
1864 
1865         // Read the Code attributes to create a label for each referenced instruction (the variables
1866         // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the
1867         // attribute_name_index and attribute_length fields.
1868         // - The offset of the current &#39;stack_map_frame&#39; in the StackMap[Table] attribute, or 0.
1869         // Initially, this is the offset of the first &#39;stack_map_frame&#39; entry. Then this offset is
1870         // updated after each stack_map_frame is read.
1871         int stackMapFrameOffset = 0;
1872         // - The end offset of the StackMap[Table] attribute, or 0.
1873         int stackMapTableEndOffset = 0;
1874         // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.
1875         boolean compressedFrames = true;
1876         // - The offset of the LocalVariableTable attribute, or 0.
1877         int localVariableTableOffset = 0;
1878         // - The offset of the LocalVariableTypeTable attribute, or 0.
1879         int localVariableTypeTableOffset = 0;
1880         // - The offset of each &#39;type_annotation&#39; entry in the RuntimeVisibleTypeAnnotations
1881         // attribute, or null.
1882         int[] visibleTypeAnnotationOffsets = null;
1883         // - The offset of each &#39;type_annotation&#39; entry in the RuntimeInvisibleTypeAnnotations
1884         // attribute, or null.
1885         int[] invisibleTypeAnnotationOffsets = null;
1886         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
1887         //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
1888         Attribute attributes = null;
1889 
1890         int attributesCount = readUnsignedShort(currentOffset);
1891         currentOffset += 2;
1892         while (attributesCount-- &gt; 0) {
1893             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
1894             String attributeName = readUTF8(currentOffset, charBuffer);
1895             int attributeLength = readInt(currentOffset + 2);
1896             currentOffset += 6;
1897             if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {
1898                 if ((context.parsingOptions &amp; SKIP_DEBUG) == 0) {
1899                     localVariableTableOffset = currentOffset;
1900                     // Parse the attribute to find the corresponding (debug only) labels.
1901                     int currentLocalVariableTableOffset = currentOffset;
1902                     int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);
1903                     currentLocalVariableTableOffset += 2;
1904                     while (localVariableTableLength-- &gt; 0) {
1905                         int startPc = readUnsignedShort(currentLocalVariableTableOffset);
1906                         createDebugLabel(startPc, labels);
1907                         int length = readUnsignedShort(currentLocalVariableTableOffset + 2);
1908                         createDebugLabel(startPc + length, labels);
1909                         // Skip the name_index, descriptor_index and index fields (2 bytes each).
1910                         currentLocalVariableTableOffset += 10;
1911                     }
1912                 }
1913             } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {
1914                 localVariableTypeTableOffset = currentOffset;
1915                 // Here we do not extract the labels corresponding to the attribute content. We assume they
1916                 // are the same or a subset of those of the LocalVariableTable attribute.
1917             } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {
1918                 if ((context.parsingOptions &amp; SKIP_DEBUG) == 0) {
1919                     // Parse the attribute to find the corresponding (debug only) labels.
1920                     int currentLineNumberTableOffset = currentOffset;
1921                     int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);
1922                     currentLineNumberTableOffset += 2;
1923                     while (lineNumberTableLength-- &gt; 0) {
1924                         int startPc = readUnsignedShort(currentLineNumberTableOffset);
1925                         int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);
1926                         currentLineNumberTableOffset += 4;
1927                         createDebugLabel(startPc, labels);
1928                         labels[startPc].addLineNumber(lineNumber);
1929                     }
1930                 }
1931             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
1932                 visibleTypeAnnotationOffsets =
1933                         readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ true);
1934                 // Here we do not extract the labels corresponding to the attribute content. This would
1935                 // require a full parsing of the attribute, which would need to be repeated when parsing
1936                 // the bytecode instructions (see below). Instead, the content of the attribute is read one
1937                 // type annotation at a time (i.e. after a type annotation has been visited, the next type
1938                 // annotation is read), and the labels it contains are also extracted one annotation at a
1939                 // time. This assumes that type annotations are ordered by increasing bytecode offset.
1940             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
1941                 invisibleTypeAnnotationOffsets =
1942                         readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ false);
1943                 // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.
1944             } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {
1945                 if ((context.parsingOptions &amp; SKIP_FRAMES) == 0) {
1946                     stackMapFrameOffset = currentOffset + 2;
1947                     stackMapTableEndOffset = currentOffset + attributeLength;
1948                 }
1949                 // Here we do not extract the labels corresponding to the attribute content. This would
1950                 // require a full parsing of the attribute, which would need to be repeated when parsing
1951                 // the bytecode instructions (see below). Instead, the content of the attribute is read one
1952                 // frame at a time (i.e. after a frame has been visited, the next frame is read), and the
1953                 // labels it contains are also extracted one frame at a time. Thanks to the ordering of
1954                 // frames, having only a &quot;one frame lookahead&quot; is not a problem, i.e. it is not possible to
1955                 // see an offset smaller than the offset of the current instruction and for which no Label
1956                 // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map
1957                 // table without a full decoding (see below).
1958             } else if (&quot;StackMap&quot;.equals(attributeName)) {
1959                 if ((context.parsingOptions &amp; SKIP_FRAMES) == 0) {
1960                     stackMapFrameOffset = currentOffset + 2;
1961                     stackMapTableEndOffset = currentOffset + attributeLength;
1962                     compressedFrames = false;
1963                 }
1964                 // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,
1965                 // although this is not guaranteed by the attribute format. This allows an incremental
1966                 // extraction of the labels corresponding to this attribute (see the comment above for the
1967                 // StackMapTable attribute).
1968             } else {
1969                 Attribute attribute =
1970                         readAttribute(
1971                                 context.attributePrototypes,
1972                                 attributeName,
1973                                 currentOffset,
1974                                 attributeLength,
1975                                 charBuffer,
1976                                 codeOffset,
1977                                 labels);
1978                 attribute.nextAttribute = attributes;
1979                 attributes = attribute;
1980             }
1981             currentOffset += attributeLength;
1982         }
1983 
1984         // Initialize the context fields related to stack map frames, and generate the first
1985         // (implicit) stack map frame, if needed.
1986         final boolean expandFrames = (context.parsingOptions &amp; EXPAND_FRAMES) != 0;
1987         if (stackMapFrameOffset != 0) {
1988             // The bytecode offset of the first explicit frame is not offset_delta + 1 but only
1989             // offset_delta. Setting the implicit frame offset to -1 allows us to use of the
1990             // &quot;offset_delta + 1&quot; rule in all cases.
1991             context.currentFrameOffset = -1;
1992             context.currentFrameType = 0;
1993             context.currentFrameLocalCount = 0;
1994             context.currentFrameLocalCountDelta = 0;
1995             context.currentFrameLocalTypes = new Object[maxLocals];
1996             context.currentFrameStackCount = 0;
1997             context.currentFrameStackTypes = new Object[maxStack];
1998             if (expandFrames) {
1999                 computeImplicitFrame(context);
2000             }
2001             // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the
2002             // stack map table, we look for 3 consecutive bytes that &quot;look like&quot; an UNINITIALIZED type
2003             // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).
2004             // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
2005             // and the only consequence will be the creation of an unneeded label. This is better than
2006             // creating a label for each NEW instruction, and faster than fully decoding the whole stack
2007             // map table.
2008             for (int offset = stackMapFrameOffset; offset &lt; stackMapTableEndOffset - 2; ++offset) {
2009                 if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {
2010                     int potentialBytecodeOffset = readUnsignedShort(offset + 1);
2011                     if (potentialBytecodeOffset &gt;= 0
2012                             &amp;&amp; potentialBytecodeOffset &lt; codeLength
2013                             &amp;&amp; (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] &amp; 0xFF)
2014                                     == Opcodes.NEW) {
2015                         createLabel(potentialBytecodeOffset, labels);
2016                     }
2017                 }
2018             }
2019         }
2020         if (expandFrames &amp;&amp; (context.parsingOptions &amp; EXPAND_ASM_INSNS) != 0) {
2021             // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method
2022             // does not currently have any frame. These inserted frames must be computed by simulating the
2023             // effect of the bytecode instructions, one by one, starting from the implicit first frame.
2024             // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To
2025             // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is
2026             // computed in MethodWriter).
2027             methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);
2028         }
2029 
2030         // Visit the bytecode instructions. First, introduce state variables for the incremental parsing
2031         // of the type annotations.
2032 
2033         // Index of the next runtime visible type annotation to read (in the
2034         // visibleTypeAnnotationOffsets array).
2035         int currentVisibleTypeAnnotationIndex = 0;
2036         // The bytecode offset of the next runtime visible type annotation to read, or -1.
2037         int currentVisibleTypeAnnotationBytecodeOffset =
2038                 getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);
2039         // Index of the next runtime invisible type annotation to read (in the
2040         // invisibleTypeAnnotationOffsets array).
2041         int currentInvisibleTypeAnnotationIndex = 0;
2042         // The bytecode offset of the next runtime invisible type annotation to read, or -1.
2043         int currentInvisibleTypeAnnotationBytecodeOffset =
2044                 getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);
2045 
2046         // Whether a F_INSERT stack map frame must be inserted before the current instruction.
2047         boolean insertFrame = false;
2048 
2049         // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr
2050         // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific
2051         // instructions).
2052         final int wideJumpOpcodeDelta =
2053                 (context.parsingOptions &amp; EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;
2054 
2055         currentOffset = bytecodeStartOffset;
2056         while (currentOffset &lt; bytecodeEndOffset) {
2057             final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;
2058 
2059             // Visit the label and the line number(s) for this bytecode offset, if any.
2060             Label currentLabel = labels[currentBytecodeOffset];
2061             if (currentLabel != null) {
2062                 currentLabel.accept(methodVisitor, (context.parsingOptions &amp; SKIP_DEBUG) == 0);
2063             }
2064 
2065             // Visit the stack map frame for this bytecode offset, if any.
2066             while (stackMapFrameOffset != 0
2067                     &amp;&amp; (context.currentFrameOffset == currentBytecodeOffset
2068                             || context.currentFrameOffset == -1)) {
2069                 // If there is a stack map frame for this offset, make methodVisitor visit it, and read the
2070                 // next stack map frame if there is one.
2071                 if (context.currentFrameOffset != -1) {
2072                     if (!compressedFrames || expandFrames) {
2073                         methodVisitor.visitFrame(
2074                                 Opcodes.F_NEW,
2075                                 context.currentFrameLocalCount,
2076                                 context.currentFrameLocalTypes,
2077                                 context.currentFrameStackCount,
2078                                 context.currentFrameStackTypes);
2079                     } else {
2080                         methodVisitor.visitFrame(
2081                                 context.currentFrameType,
2082                                 context.currentFrameLocalCountDelta,
2083                                 context.currentFrameLocalTypes,
2084                                 context.currentFrameStackCount,
2085                                 context.currentFrameStackTypes);
2086                     }
2087                     // Since there is already a stack map frame for this bytecode offset, there is no need to
2088                     // insert a new one.
2089                     insertFrame = false;
2090                 }
2091                 if (stackMapFrameOffset &lt; stackMapTableEndOffset) {
2092                     stackMapFrameOffset =
2093                             readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);
2094                 } else {
2095                     stackMapFrameOffset = 0;
2096                 }
2097             }
2098 
2099             // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to
2100             // true during the previous iteration. The actual frame content is computed in MethodWriter.
2101             if (insertFrame) {
2102                 if ((context.parsingOptions &amp; EXPAND_FRAMES) != 0) {
2103                     methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);
2104                 }
2105                 insertFrame = false;
2106             }
2107 
2108             // Visit the instruction at this bytecode offset.
2109             int opcode = classBuffer[currentOffset] &amp; 0xFF;
2110             switch (opcode) {
2111                 case Opcodes.NOP:
2112                 case Opcodes.ACONST_NULL:
2113                 case Opcodes.ICONST_M1:
2114                 case Opcodes.ICONST_0:
2115                 case Opcodes.ICONST_1:
2116                 case Opcodes.ICONST_2:
2117                 case Opcodes.ICONST_3:
2118                 case Opcodes.ICONST_4:
2119                 case Opcodes.ICONST_5:
2120                 case Opcodes.LCONST_0:
2121                 case Opcodes.LCONST_1:
2122                 case Opcodes.FCONST_0:
2123                 case Opcodes.FCONST_1:
2124                 case Opcodes.FCONST_2:
2125                 case Opcodes.DCONST_0:
2126                 case Opcodes.DCONST_1:
2127                 case Opcodes.IALOAD:
2128                 case Opcodes.LALOAD:
2129                 case Opcodes.FALOAD:
2130                 case Opcodes.DALOAD:
2131                 case Opcodes.AALOAD:
2132                 case Opcodes.BALOAD:
2133                 case Opcodes.CALOAD:
2134                 case Opcodes.SALOAD:
2135                 case Opcodes.IASTORE:
2136                 case Opcodes.LASTORE:
2137                 case Opcodes.FASTORE:
2138                 case Opcodes.DASTORE:
2139                 case Opcodes.AASTORE:
2140                 case Opcodes.BASTORE:
2141                 case Opcodes.CASTORE:
2142                 case Opcodes.SASTORE:
2143                 case Opcodes.POP:
2144                 case Opcodes.POP2:
2145                 case Opcodes.DUP:
2146                 case Opcodes.DUP_X1:
2147                 case Opcodes.DUP_X2:
2148                 case Opcodes.DUP2:
2149                 case Opcodes.DUP2_X1:
2150                 case Opcodes.DUP2_X2:
2151                 case Opcodes.SWAP:
2152                 case Opcodes.IADD:
2153                 case Opcodes.LADD:
2154                 case Opcodes.FADD:
2155                 case Opcodes.DADD:
2156                 case Opcodes.ISUB:
2157                 case Opcodes.LSUB:
2158                 case Opcodes.FSUB:
2159                 case Opcodes.DSUB:
2160                 case Opcodes.IMUL:
2161                 case Opcodes.LMUL:
2162                 case Opcodes.FMUL:
2163                 case Opcodes.DMUL:
2164                 case Opcodes.IDIV:
2165                 case Opcodes.LDIV:
2166                 case Opcodes.FDIV:
2167                 case Opcodes.DDIV:
2168                 case Opcodes.IREM:
2169                 case Opcodes.LREM:
2170                 case Opcodes.FREM:
2171                 case Opcodes.DREM:
2172                 case Opcodes.INEG:
2173                 case Opcodes.LNEG:
2174                 case Opcodes.FNEG:
2175                 case Opcodes.DNEG:
2176                 case Opcodes.ISHL:
2177                 case Opcodes.LSHL:
2178                 case Opcodes.ISHR:
2179                 case Opcodes.LSHR:
2180                 case Opcodes.IUSHR:
2181                 case Opcodes.LUSHR:
2182                 case Opcodes.IAND:
2183                 case Opcodes.LAND:
2184                 case Opcodes.IOR:
2185                 case Opcodes.LOR:
2186                 case Opcodes.IXOR:
2187                 case Opcodes.LXOR:
2188                 case Opcodes.I2L:
2189                 case Opcodes.I2F:
2190                 case Opcodes.I2D:
2191                 case Opcodes.L2I:
2192                 case Opcodes.L2F:
2193                 case Opcodes.L2D:
2194                 case Opcodes.F2I:
2195                 case Opcodes.F2L:
2196                 case Opcodes.F2D:
2197                 case Opcodes.D2I:
2198                 case Opcodes.D2L:
2199                 case Opcodes.D2F:
2200                 case Opcodes.I2B:
2201                 case Opcodes.I2C:
2202                 case Opcodes.I2S:
2203                 case Opcodes.LCMP:
2204                 case Opcodes.FCMPL:
2205                 case Opcodes.FCMPG:
2206                 case Opcodes.DCMPL:
2207                 case Opcodes.DCMPG:
2208                 case Opcodes.IRETURN:
2209                 case Opcodes.LRETURN:
2210                 case Opcodes.FRETURN:
2211                 case Opcodes.DRETURN:
2212                 case Opcodes.ARETURN:
2213                 case Opcodes.RETURN:
2214                 case Opcodes.ARRAYLENGTH:
2215                 case Opcodes.ATHROW:
2216                 case Opcodes.MONITORENTER:
2217                 case Opcodes.MONITOREXIT:
2218                     methodVisitor.visitInsn(opcode);
2219                     currentOffset += 1;
2220                     break;
2221                 case Constants.ILOAD_0:
2222                 case Constants.ILOAD_1:
2223                 case Constants.ILOAD_2:
2224                 case Constants.ILOAD_3:
2225                 case Constants.LLOAD_0:
2226                 case Constants.LLOAD_1:
2227                 case Constants.LLOAD_2:
2228                 case Constants.LLOAD_3:
2229                 case Constants.FLOAD_0:
2230                 case Constants.FLOAD_1:
2231                 case Constants.FLOAD_2:
2232                 case Constants.FLOAD_3:
2233                 case Constants.DLOAD_0:
2234                 case Constants.DLOAD_1:
2235                 case Constants.DLOAD_2:
2236                 case Constants.DLOAD_3:
2237                 case Constants.ALOAD_0:
2238                 case Constants.ALOAD_1:
2239                 case Constants.ALOAD_2:
2240                 case Constants.ALOAD_3:
2241                     opcode -= Constants.ILOAD_0;
2242                     methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode &gt;&gt; 2), opcode &amp; 0x3);
2243                     currentOffset += 1;
2244                     break;
2245                 case Constants.ISTORE_0:
2246                 case Constants.ISTORE_1:
2247                 case Constants.ISTORE_2:
2248                 case Constants.ISTORE_3:
2249                 case Constants.LSTORE_0:
2250                 case Constants.LSTORE_1:
2251                 case Constants.LSTORE_2:
2252                 case Constants.LSTORE_3:
2253                 case Constants.FSTORE_0:
2254                 case Constants.FSTORE_1:
2255                 case Constants.FSTORE_2:
2256                 case Constants.FSTORE_3:
2257                 case Constants.DSTORE_0:
2258                 case Constants.DSTORE_1:
2259                 case Constants.DSTORE_2:
2260                 case Constants.DSTORE_3:
2261                 case Constants.ASTORE_0:
2262                 case Constants.ASTORE_1:
2263                 case Constants.ASTORE_2:
2264                 case Constants.ASTORE_3:
2265                     opcode -= Constants.ISTORE_0;
2266                     methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode &gt;&gt; 2), opcode &amp; 0x3);
2267                     currentOffset += 1;
2268                     break;
2269                 case Opcodes.IFEQ:
2270                 case Opcodes.IFNE:
2271                 case Opcodes.IFLT:
2272                 case Opcodes.IFGE:
2273                 case Opcodes.IFGT:
2274                 case Opcodes.IFLE:
2275                 case Opcodes.IF_ICMPEQ:
2276                 case Opcodes.IF_ICMPNE:
2277                 case Opcodes.IF_ICMPLT:
2278                 case Opcodes.IF_ICMPGE:
2279                 case Opcodes.IF_ICMPGT:
2280                 case Opcodes.IF_ICMPLE:
2281                 case Opcodes.IF_ACMPEQ:
2282                 case Opcodes.IF_ACMPNE:
2283                 case Opcodes.GOTO:
2284                 case Opcodes.JSR:
2285                 case Opcodes.IFNULL:
2286                 case Opcodes.IFNONNULL:
2287                     methodVisitor.visitJumpInsn(
2288                             opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);
2289                     currentOffset += 3;
2290                     break;
2291                 case Constants.GOTO_W:
2292                 case Constants.JSR_W:
2293                     methodVisitor.visitJumpInsn(
2294                             opcode - wideJumpOpcodeDelta,
2295                             labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
2296                     currentOffset += 5;
2297                     break;
2298                 case Constants.ASM_IFEQ:
2299                 case Constants.ASM_IFNE:
2300                 case Constants.ASM_IFLT:
2301                 case Constants.ASM_IFGE:
2302                 case Constants.ASM_IFGT:
2303                 case Constants.ASM_IFLE:
2304                 case Constants.ASM_IF_ICMPEQ:
2305                 case Constants.ASM_IF_ICMPNE:
2306                 case Constants.ASM_IF_ICMPLT:
2307                 case Constants.ASM_IF_ICMPGE:
2308                 case Constants.ASM_IF_ICMPGT:
2309                 case Constants.ASM_IF_ICMPLE:
2310                 case Constants.ASM_IF_ACMPEQ:
2311                 case Constants.ASM_IF_ACMPNE:
2312                 case Constants.ASM_GOTO:
2313                 case Constants.ASM_JSR:
2314                 case Constants.ASM_IFNULL:
2315                 case Constants.ASM_IFNONNULL:
2316                     {
2317                         // A forward jump with an offset &gt; 32767. In this case we automatically replace ASM_GOTO
2318                         // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx &lt;l&gt; with IFNOTxxx &lt;L&gt; GOTO_W &lt;l&gt; L:...,
2319                         // where IFNOTxxx is the &quot;opposite&quot; opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and
2320                         // where &lt;L&gt; designates the instruction just after the GOTO_W.
2321                         // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and
2322                         // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.
2323                         opcode =
2324                                 opcode &lt; Constants.ASM_IFNULL
2325                                         ? opcode - Constants.ASM_OPCODE_DELTA
2326                                         : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;
2327                         Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];
2328                         if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {
2329                             // Replace GOTO with GOTO_W and JSR with JSR_W.
2330                             methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);
2331                         } else {
2332                             // Compute the &quot;opposite&quot; of opcode. This can be done by flipping the least
2333                             // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ
2334                             // (with a pre and post offset by 1).
2335                             opcode = opcode &lt; Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;
2336                             Label endif = createLabel(currentBytecodeOffset + 3, labels);
2337                             methodVisitor.visitJumpInsn(opcode, endif);
2338                             methodVisitor.visitJumpInsn(Constants.GOTO_W, target);
2339                             // endif designates the instruction just after GOTO_W, and is visited as part of the
2340                             // next instruction. Since it is a jump target, we need to insert a frame here.
2341                             insertFrame = true;
2342                         }
2343                         currentOffset += 3;
2344                         break;
2345                     }
2346                 case Constants.ASM_GOTO_W:
2347                     // Replace ASM_GOTO_W with GOTO_W.
2348                     methodVisitor.visitJumpInsn(
2349                             Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
2350                     // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns
2351                     // IFNOTxxx &lt;L&gt; ASM_GOTO_W &lt;l&gt; L:..., see MethodWriter), so we need to insert a frame
2352                     // here.
2353                     insertFrame = true;
2354                     currentOffset += 5;
2355                     break;
2356                 case Constants.WIDE:
2357                     opcode = classBuffer[currentOffset + 1] &amp; 0xFF;
2358                     if (opcode == Opcodes.IINC) {
2359                         methodVisitor.visitIincInsn(
2360                                 readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));
2361                         currentOffset += 6;
2362                     } else {
2363                         methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));
2364                         currentOffset += 4;
2365                     }
2366                     break;
2367                 case Opcodes.TABLESWITCH:
2368                     {
2369                         // Skip 0 to 3 padding bytes.
2370                         currentOffset += 4 - (currentBytecodeOffset &amp; 3);
2371                         // Read the instruction.
2372                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
2373                         int low = readInt(currentOffset + 4);
2374                         int high = readInt(currentOffset + 8);
2375                         currentOffset += 12;
2376                         Label[] table = new Label[high - low + 1];
2377                         for (int i = 0; i &lt; table.length; ++i) {
2378                             table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];
2379                             currentOffset += 4;
2380                         }
2381                         methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);
2382                         break;
2383                     }
2384                 case Opcodes.LOOKUPSWITCH:
2385                     {
2386                         // Skip 0 to 3 padding bytes.
2387                         currentOffset += 4 - (currentBytecodeOffset &amp; 3);
2388                         // Read the instruction.
2389                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
2390                         int numPairs = readInt(currentOffset + 4);
2391                         currentOffset += 8;
2392                         int[] keys = new int[numPairs];
2393                         Label[] values = new Label[numPairs];
2394                         for (int i = 0; i &lt; numPairs; ++i) {
2395                             keys[i] = readInt(currentOffset);
2396                             values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];
2397                             currentOffset += 8;
2398                         }
2399                         methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);
2400                         break;
2401                     }
2402                 case Opcodes.ILOAD:
2403                 case Opcodes.LLOAD:
2404                 case Opcodes.FLOAD:
2405                 case Opcodes.DLOAD:
2406                 case Opcodes.ALOAD:
2407                 case Opcodes.ISTORE:
2408                 case Opcodes.LSTORE:
2409                 case Opcodes.FSTORE:
2410                 case Opcodes.DSTORE:
2411                 case Opcodes.ASTORE:
2412                 case Opcodes.RET:
2413                     methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] &amp; 0xFF);
2414                     currentOffset += 2;
2415                     break;
2416                 case Opcodes.BIPUSH:
2417                 case Opcodes.NEWARRAY:
2418                     methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);
2419                     currentOffset += 2;
2420                     break;
2421                 case Opcodes.SIPUSH:
2422                     methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));
2423                     currentOffset += 3;
2424                     break;
2425                 case Opcodes.LDC:
2426                     methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] &amp; 0xFF, charBuffer));
2427                     currentOffset += 2;
2428                     break;
2429                 case Constants.LDC_W:
2430                 case Constants.LDC2_W:
2431                     methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));
2432                     currentOffset += 3;
2433                     break;
2434                 case Opcodes.GETSTATIC:
2435                 case Opcodes.PUTSTATIC:
2436                 case Opcodes.GETFIELD:
2437                 case Opcodes.PUTFIELD:
2438                 case Opcodes.INVOKEVIRTUAL:
2439                 case Opcodes.INVOKESPECIAL:
2440                 case Opcodes.INVOKESTATIC:
2441                 case Opcodes.INVOKEINTERFACE:
<a name="2" id="anc2"></a><span class="line-added">2442                 case Opcodes.WITHFIELD:</span>
2443                     {
2444                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
2445                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
2446                         String owner = readClass(cpInfoOffset, charBuffer);
2447                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
2448                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
<a name="3" id="anc3"></a><span class="line-modified">2449                         if (opcode &gt;= Opcodes.INVOKEVIRTUAL &amp;&amp; opcode &lt;= Opcodes.INVOKEINTERFACE) {</span>


2450                             boolean isInterface =
2451                                     classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
2452                             methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
<a name="4" id="anc4"></a><span class="line-added">2453                         } else {</span>
<span class="line-added">2454                             methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);</span>
2455                         }
2456                         if (opcode == Opcodes.INVOKEINTERFACE) {
2457                             currentOffset += 5;
2458                         } else {
2459                             currentOffset += 3;
2460                         }
2461                         break;
2462                     }
2463                 case Opcodes.INVOKEDYNAMIC:
2464                     {
2465                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
2466                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
2467                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
2468                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
2469                         int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];
2470                         Handle handle =
2471                                 (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
2472                         Object[] bootstrapMethodArguments =
2473                                 new Object[readUnsignedShort(bootstrapMethodOffset + 2)];
2474                         bootstrapMethodOffset += 4;
2475                         for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {
2476                             bootstrapMethodArguments[i] =
2477                                     readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
2478                             bootstrapMethodOffset += 2;
2479                         }
2480                         methodVisitor.visitInvokeDynamicInsn(
2481                                 name, descriptor, handle, bootstrapMethodArguments);
2482                         currentOffset += 5;
2483                         break;
2484                     }
2485                 case Opcodes.NEW:
2486                 case Opcodes.ANEWARRAY:
2487                 case Opcodes.CHECKCAST:
2488                 case Opcodes.INSTANCEOF:
<a name="5" id="anc5"></a><span class="line-added">2489                 case Opcodes.DEFAULT:</span>
2490                     methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));
2491                     currentOffset += 3;
2492                     break;
2493                 case Opcodes.IINC:
2494                     methodVisitor.visitIincInsn(
2495                             classBuffer[currentOffset + 1] &amp; 0xFF, classBuffer[currentOffset + 2]);
2496                     currentOffset += 3;
2497                     break;
2498                 case Opcodes.MULTIANEWARRAY:
2499                     methodVisitor.visitMultiANewArrayInsn(
2500                             readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] &amp; 0xFF);
2501                     currentOffset += 4;
2502                     break;
2503                 default:
2504                     throw new AssertionError();
2505             }
2506 
2507             // Visit the runtime visible instruction annotations, if any.
2508             while (visibleTypeAnnotationOffsets != null
2509                     &amp;&amp; currentVisibleTypeAnnotationIndex &lt; visibleTypeAnnotationOffsets.length
2510                     &amp;&amp; currentVisibleTypeAnnotationBytecodeOffset &lt;= currentBytecodeOffset) {
2511                 if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {
2512                     // Parse the target_type, target_info and target_path fields.
2513                     int currentAnnotationOffset =
2514                             readTypeAnnotationTarget(
2515                                     context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);
2516                     // Parse the type_index field.
2517                     String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
2518                     currentAnnotationOffset += 2;
2519                     // Parse num_element_value_pairs and element_value_pairs and visit these values.
2520                     readElementValues(
2521                             methodVisitor.visitInsnAnnotation(
2522                                     context.currentTypeAnnotationTarget,
2523                                     context.currentTypeAnnotationTargetPath,
2524                                     annotationDescriptor,
2525                                     /* visible = */ true),
2526                             currentAnnotationOffset,
2527                             /* named = */ true,
2528                             charBuffer);
2529                 }
2530                 currentVisibleTypeAnnotationBytecodeOffset =
2531                         getTypeAnnotationBytecodeOffset(
2532                                 visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);
2533             }
2534 
2535             // Visit the runtime invisible instruction annotations, if any.
2536             while (invisibleTypeAnnotationOffsets != null
2537                     &amp;&amp; currentInvisibleTypeAnnotationIndex &lt; invisibleTypeAnnotationOffsets.length
2538                     &amp;&amp; currentInvisibleTypeAnnotationBytecodeOffset &lt;= currentBytecodeOffset) {
2539                 if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {
2540                     // Parse the target_type, target_info and target_path fields.
2541                     int currentAnnotationOffset =
2542                             readTypeAnnotationTarget(
2543                                     context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);
2544                     // Parse the type_index field.
2545                     String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
2546                     currentAnnotationOffset += 2;
2547                     // Parse num_element_value_pairs and element_value_pairs and visit these values.
2548                     readElementValues(
2549                             methodVisitor.visitInsnAnnotation(
2550                                     context.currentTypeAnnotationTarget,
2551                                     context.currentTypeAnnotationTargetPath,
2552                                     annotationDescriptor,
2553                                     /* visible = */ false),
2554                             currentAnnotationOffset,
2555                             /* named = */ true,
2556                             charBuffer);
2557                 }
2558                 currentInvisibleTypeAnnotationBytecodeOffset =
2559                         getTypeAnnotationBytecodeOffset(
2560                                 invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);
2561             }
2562         }
2563         if (labels[codeLength] != null) {
2564             methodVisitor.visitLabel(labels[codeLength]);
2565         }
2566 
2567         // Visit LocalVariableTable and LocalVariableTypeTable attributes.
2568         if (localVariableTableOffset != 0 &amp;&amp; (context.parsingOptions &amp; SKIP_DEBUG) == 0) {
2569             // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.
2570             int[] typeTable = null;
2571             if (localVariableTypeTableOffset != 0) {
2572                 typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];
2573                 currentOffset = localVariableTypeTableOffset + 2;
2574                 int typeTableIndex = typeTable.length;
2575                 while (typeTableIndex &gt; 0) {
2576                     // Store the offset of &#39;signature_index&#39;, and the value of &#39;index&#39; and &#39;start_pc&#39;.
2577                     typeTable[--typeTableIndex] = currentOffset + 6;
2578                     typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);
2579                     typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);
2580                     currentOffset += 10;
2581                 }
2582             }
2583             int localVariableTableLength = readUnsignedShort(localVariableTableOffset);
2584             currentOffset = localVariableTableOffset + 2;
2585             while (localVariableTableLength-- &gt; 0) {
2586                 int startPc = readUnsignedShort(currentOffset);
2587                 int length = readUnsignedShort(currentOffset + 2);
2588                 String name = readUTF8(currentOffset + 4, charBuffer);
2589                 String descriptor = readUTF8(currentOffset + 6, charBuffer);
2590                 int index = readUnsignedShort(currentOffset + 8);
2591                 currentOffset += 10;
2592                 String signature = null;
2593                 if (typeTable != null) {
2594                     for (int i = 0; i &lt; typeTable.length; i += 3) {
2595                         if (typeTable[i] == startPc &amp;&amp; typeTable[i + 1] == index) {
2596                             signature = readUTF8(typeTable[i + 2], charBuffer);
2597                             break;
2598                         }
2599                     }
2600                 }
2601                 methodVisitor.visitLocalVariable(
2602                         name, descriptor, signature, labels[startPc], labels[startPc + length], index);
2603             }
2604         }
2605 
2606         // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.
2607         if (visibleTypeAnnotationOffsets != null) {
2608             for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {
2609                 int targetType = readByte(typeAnnotationOffset);
2610                 if (targetType == TypeReference.LOCAL_VARIABLE
2611                         || targetType == TypeReference.RESOURCE_VARIABLE) {
2612                     // Parse the target_type, target_info and target_path fields.
2613                     currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);
2614                     // Parse the type_index field.
2615                     String annotationDescriptor = readUTF8(currentOffset, charBuffer);
2616                     currentOffset += 2;
2617                     // Parse num_element_value_pairs and element_value_pairs and visit these values.
2618                     readElementValues(
2619                             methodVisitor.visitLocalVariableAnnotation(
2620                                     context.currentTypeAnnotationTarget,
2621                                     context.currentTypeAnnotationTargetPath,
2622                                     context.currentLocalVariableAnnotationRangeStarts,
2623                                     context.currentLocalVariableAnnotationRangeEnds,
2624                                     context.currentLocalVariableAnnotationRangeIndices,
2625                                     annotationDescriptor,
2626                                     /* visible = */ true),
2627                             currentOffset,
2628                             /* named = */ true,
2629                             charBuffer);
2630                 }
2631             }
2632         }
2633 
2634         // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.
2635         if (invisibleTypeAnnotationOffsets != null) {
2636             for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {
2637                 int targetType = readByte(typeAnnotationOffset);
2638                 if (targetType == TypeReference.LOCAL_VARIABLE
2639                         || targetType == TypeReference.RESOURCE_VARIABLE) {
2640                     // Parse the target_type, target_info and target_path fields.
2641                     currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);
2642                     // Parse the type_index field.
2643                     String annotationDescriptor = readUTF8(currentOffset, charBuffer);
2644                     currentOffset += 2;
2645                     // Parse num_element_value_pairs and element_value_pairs and visit these values.
2646                     readElementValues(
2647                             methodVisitor.visitLocalVariableAnnotation(
2648                                     context.currentTypeAnnotationTarget,
2649                                     context.currentTypeAnnotationTargetPath,
2650                                     context.currentLocalVariableAnnotationRangeStarts,
2651                                     context.currentLocalVariableAnnotationRangeEnds,
2652                                     context.currentLocalVariableAnnotationRangeIndices,
2653                                     annotationDescriptor,
2654                                     /* visible = */ false),
2655                             currentOffset,
2656                             /* named = */ true,
2657                             charBuffer);
2658                 }
2659             }
2660         }
2661 
2662         // Visit the non standard attributes.
2663         while (attributes != null) {
2664             // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.
2665             Attribute nextAttribute = attributes.nextAttribute;
2666             attributes.nextAttribute = null;
2667             methodVisitor.visitAttribute(attributes);
2668             attributes = nextAttribute;
2669         }
2670 
2671         // Visit the max stack and max locals values.
2672         methodVisitor.visitMaxs(maxStack, maxLocals);
2673     }
2674 
2675     /**
2676       * Returns the label corresponding to the given bytecode offset. The default implementation of
2677       * this method creates a label for the given offset if it has not been already created.
2678       *
2679       * @param bytecodeOffset a bytecode offset in a method.
2680       * @param labels the already created labels, indexed by their offset. If a label already exists
2681       *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new
2682       *     label in this array.
2683       * @return a non null Label, which must be equal to labels[bytecodeOffset].
2684       */
2685     protected Label readLabel(final int bytecodeOffset, final Label[] labels) {
2686         if (labels[bytecodeOffset] == null) {
2687             labels[bytecodeOffset] = new Label();
2688         }
2689         return labels[bytecodeOffset];
2690     }
2691 
2692     /**
2693       * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode
2694       * offset. The label is created with a call to {@link #readLabel} and its {@link
2695       * Label#FLAG_DEBUG_ONLY} flag is cleared.
2696       *
2697       * @param bytecodeOffset a bytecode offset in a method.
2698       * @param labels the already created labels, indexed by their offset.
2699       * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.
2700       */
2701     private Label createLabel(final int bytecodeOffset, final Label[] labels) {
2702         Label label = readLabel(bytecodeOffset, labels);
2703         label.flags &amp;= ~Label.FLAG_DEBUG_ONLY;
2704         return label;
2705     }
2706 
2707     /**
2708       * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already
2709       * existing label for the given bytecode offset (otherwise does nothing). The label is created
2710       * with a call to {@link #readLabel}.
2711       *
2712       * @param bytecodeOffset a bytecode offset in a method.
2713       * @param labels the already created labels, indexed by their offset.
2714       */
2715     private void createDebugLabel(final int bytecodeOffset, final Label[] labels) {
2716         if (labels[bytecodeOffset] == null) {
2717             readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;
2718         }
2719     }
2720 
2721     // ----------------------------------------------------------------------------------------------
2722     // Methods to parse annotations, type annotations and parameter annotations
2723     // ----------------------------------------------------------------------------------------------
2724 
2725     /**
2726       * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation
2727       * entry it contains, to find the corresponding labels, and to visit the try catch block
2728       * annotations.
2729       *
2730       * @param methodVisitor the method visitor to be used to visit the try catch block annotations.
2731       * @param context information about the class being parsed.
2732       * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations
2733       *     attribute, excluding the attribute_info&#39;s attribute_name_index and attribute_length fields.
2734       * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,
2735       *     false it is a RuntimeInvisibleTypeAnnotations attribute.
2736       * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute&#39;s
2737       *     &#39;annotations&#39; array field.
2738       */
2739     private int[] readTypeAnnotations(
2740             final MethodVisitor methodVisitor,
2741             final Context context,
2742             final int runtimeTypeAnnotationsOffset,
2743             final boolean visible) {
2744         char[] charBuffer = context.charBuffer;
2745         int currentOffset = runtimeTypeAnnotationsOffset;
2746         // Read the num_annotations field and create an array to store the type_annotation offsets.
2747         int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];
2748         currentOffset += 2;
2749         // Parse the &#39;annotations&#39; array field.
2750         for (int i = 0; i &lt; typeAnnotationsOffsets.length; ++i) {
2751             typeAnnotationsOffsets[i] = currentOffset;
2752             // Parse the type_annotation&#39;s target_type and the target_info fields. The size of the
2753             // target_info field depends on the value of target_type.
2754             int targetType = readInt(currentOffset);
2755             switch (targetType &gt;&gt;&gt; 24) {
2756                 case TypeReference.LOCAL_VARIABLE:
2757                 case TypeReference.RESOURCE_VARIABLE:
2758                     // A localvar_target has a variable size, which depends on the value of their table_length
2759                     // field. It also references bytecode offsets, for which we need labels.
2760                     int tableLength = readUnsignedShort(currentOffset + 1);
2761                     currentOffset += 3;
2762                     while (tableLength-- &gt; 0) {
2763                         int startPc = readUnsignedShort(currentOffset);
2764                         int length = readUnsignedShort(currentOffset + 2);
2765                         // Skip the index field (2 bytes).
2766                         currentOffset += 6;
2767                         createLabel(startPc, context.currentMethodLabels);
2768                         createLabel(startPc + length, context.currentMethodLabels);
2769                     }
2770                     break;
2771                 case TypeReference.CAST:
2772                 case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
2773                 case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
2774                 case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
2775                 case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
2776                     currentOffset += 4;
2777                     break;
2778                 case TypeReference.CLASS_EXTENDS:
2779                 case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
2780                 case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
2781                 case TypeReference.THROWS:
2782                 case TypeReference.EXCEPTION_PARAMETER:
2783                 case TypeReference.INSTANCEOF:
2784                 case TypeReference.NEW:
2785                 case TypeReference.CONSTRUCTOR_REFERENCE:
2786                 case TypeReference.METHOD_REFERENCE:
2787                     currentOffset += 3;
2788                     break;
2789                 case TypeReference.CLASS_TYPE_PARAMETER:
2790                 case TypeReference.METHOD_TYPE_PARAMETER:
2791                 case TypeReference.METHOD_FORMAL_PARAMETER:
2792                 case TypeReference.FIELD:
2793                 case TypeReference.METHOD_RETURN:
2794                 case TypeReference.METHOD_RECEIVER:
2795                 default:
2796                     // TypeReference type which can&#39;t be used in Code attribute, or which is unknown.
2797                     throw new IllegalArgumentException();
2798             }
2799             // Parse the rest of the type_annotation structure, starting with the target_path structure
2800             // (whose size depends on its path_length field).
2801             int pathLength = readByte(currentOffset);
2802             if ((targetType &gt;&gt;&gt; 24) == TypeReference.EXCEPTION_PARAMETER) {
2803                 // Parse the target_path structure and create a corresponding TypePath.
2804                 TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);
2805                 currentOffset += 1 + 2 * pathLength;
2806                 // Parse the type_index field.
2807                 String annotationDescriptor = readUTF8(currentOffset, charBuffer);
2808                 currentOffset += 2;
2809                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
2810                 currentOffset =
2811                         readElementValues(
2812                                 methodVisitor.visitTryCatchAnnotation(
2813                                         targetType &amp; 0xFFFFFF00, path, annotationDescriptor, visible),
2814                                 currentOffset,
2815                                 /* named = */ true,
2816                                 charBuffer);
2817             } else {
2818                 // We don&#39;t want to visit the other target_type annotations, so we just skip them (which
2819                 // requires some parsing because the element_value_pairs array has a variable size). First,
2820                 // skip the target_path structure:
2821                 currentOffset += 3 + 2 * pathLength;
2822                 // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them
2823                 // with a null AnnotationVisitor).
2824                 currentOffset =
2825                         readElementValues(
2826                                 /* annotationVisitor = */ null, currentOffset, /* named = */ true, charBuffer);
2827             }
2828         }
2829         return typeAnnotationsOffsets;
2830     }
2831 
2832     /**
2833       * Returns the bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or
2834       * -1 if there is no such type_annotation of if it does not have a bytecode offset.
2835       *
2836       * @param typeAnnotationOffsets the offset of each &#39;type_annotation&#39; entry in a
2837       *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.
2838       * @param typeAnnotationIndex the index a &#39;type_annotation&#39; entry in typeAnnotationOffsets.
2839       * @return bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or -1
2840       *     if there is no such type_annotation of if it does not have a bytecode offset.
2841       */
2842     private int getTypeAnnotationBytecodeOffset(
2843             final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {
2844         if (typeAnnotationOffsets == null
2845                 || typeAnnotationIndex &gt;= typeAnnotationOffsets.length
2846                 || readByte(typeAnnotationOffsets[typeAnnotationIndex]) &lt; TypeReference.INSTANCEOF) {
2847             return -1;
2848         }
2849         return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);
2850     }
2851 
2852     /**
2853       * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info
2854       * and target_path (the result is stored in the given context), and returns the start offset of
2855       * the rest of the type_annotation structure.
2856       *
2857       * @param context information about the class being parsed. This is where the extracted
2858       *     target_type and target_path must be stored.
2859       * @param typeAnnotationOffset the start offset of a type_annotation structure.
2860       * @return the start offset of the rest of the type_annotation structure.
2861       */
2862     private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {
2863         int currentOffset = typeAnnotationOffset;
2864         // Parse and store the target_type structure.
2865         int targetType = readInt(typeAnnotationOffset);
2866         switch (targetType &gt;&gt;&gt; 24) {
2867             case TypeReference.CLASS_TYPE_PARAMETER:
2868             case TypeReference.METHOD_TYPE_PARAMETER:
2869             case TypeReference.METHOD_FORMAL_PARAMETER:
2870                 targetType &amp;= 0xFFFF0000;
2871                 currentOffset += 2;
2872                 break;
2873             case TypeReference.FIELD:
2874             case TypeReference.METHOD_RETURN:
2875             case TypeReference.METHOD_RECEIVER:
2876                 targetType &amp;= 0xFF000000;
2877                 currentOffset += 1;
2878                 break;
2879             case TypeReference.LOCAL_VARIABLE:
2880             case TypeReference.RESOURCE_VARIABLE:
2881                 targetType &amp;= 0xFF000000;
2882                 int tableLength = readUnsignedShort(currentOffset + 1);
2883                 currentOffset += 3;
2884                 context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];
2885                 context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];
2886                 context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];
2887                 for (int i = 0; i &lt; tableLength; ++i) {
2888                     int startPc = readUnsignedShort(currentOffset);
2889                     int length = readUnsignedShort(currentOffset + 2);
2890                     int index = readUnsignedShort(currentOffset + 4);
2891                     currentOffset += 6;
2892                     context.currentLocalVariableAnnotationRangeStarts[i] =
2893                             createLabel(startPc, context.currentMethodLabels);
2894                     context.currentLocalVariableAnnotationRangeEnds[i] =
2895                             createLabel(startPc + length, context.currentMethodLabels);
2896                     context.currentLocalVariableAnnotationRangeIndices[i] = index;
2897                 }
2898                 break;
2899             case TypeReference.CAST:
2900             case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
2901             case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
2902             case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
2903             case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
2904                 targetType &amp;= 0xFF0000FF;
2905                 currentOffset += 4;
2906                 break;
2907             case TypeReference.CLASS_EXTENDS:
2908             case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
2909             case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
2910             case TypeReference.THROWS:
2911             case TypeReference.EXCEPTION_PARAMETER:
2912                 targetType &amp;= 0xFFFFFF00;
2913                 currentOffset += 3;
2914                 break;
2915             case TypeReference.INSTANCEOF:
2916             case TypeReference.NEW:
2917             case TypeReference.CONSTRUCTOR_REFERENCE:
2918             case TypeReference.METHOD_REFERENCE:
2919                 targetType &amp;= 0xFF000000;
2920                 currentOffset += 3;
2921                 break;
2922             default:
2923                 throw new IllegalArgumentException();
2924         }
2925         context.currentTypeAnnotationTarget = targetType;
2926         // Parse and store the target_path structure.
2927         int pathLength = readByte(currentOffset);
2928         context.currentTypeAnnotationTargetPath =
2929                 pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);
2930         // Return the start offset of the rest of the type_annotation structure.
2931         return currentOffset + 1 + 2 * pathLength;
2932     }
2933 
2934     /**
2935       * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.
2936       *
2937       * @param methodVisitor the visitor that must visit the parameter annotations.
2938       * @param context information about the class being parsed.
2939       * @param runtimeParameterAnnotationsOffset the start offset of a
2940       *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info&#39;s
2941       *     attribute_name_index and attribute_length fields.
2942       * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations
2943       *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.
2944       */
2945     private void readParameterAnnotations(
2946             final MethodVisitor methodVisitor,
2947             final Context context,
2948             final int runtimeParameterAnnotationsOffset,
2949             final boolean visible) {
2950         int currentOffset = runtimeParameterAnnotationsOffset;
2951         int numParameters = classFileBuffer[currentOffset++] &amp; 0xFF;
2952         methodVisitor.visitAnnotableParameterCount(numParameters, visible);
2953         char[] charBuffer = context.charBuffer;
2954         for (int i = 0; i &lt; numParameters; ++i) {
2955             int numAnnotations = readUnsignedShort(currentOffset);
2956             currentOffset += 2;
2957             while (numAnnotations-- &gt; 0) {
2958                 // Parse the type_index field.
2959                 String annotationDescriptor = readUTF8(currentOffset, charBuffer);
2960                 currentOffset += 2;
2961                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
2962                 currentOffset =
2963                         readElementValues(
2964                                 methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible),
2965                                 currentOffset,
2966                                 /* named = */ true,
2967                                 charBuffer);
2968             }
2969         }
2970     }
2971 
2972     /**
2973       * Reads the element values of a JVMS &#39;annotation&#39; structure and makes the given visitor visit
2974       * them. This method can also be used to read the values of the JVMS &#39;array_value&#39; field of an
2975       * annotation&#39;s &#39;element_value&#39;.
2976       *
2977       * @param annotationVisitor the visitor that must visit the values.
2978       * @param annotationOffset the start offset of an &#39;annotation&#39; structure (excluding its type_index
2979       *     field) or of an &#39;array_value&#39; structure.
2980       * @param named if the annotation values are named or not. This should be true to parse the values
2981       *     of a JVMS &#39;annotation&#39; structure, and false to parse the JVMS &#39;array_value&#39; of an
2982       *     annotation&#39;s element_value.
2983       * @param charBuffer the buffer used to read strings in the constant pool.
2984       * @return the end offset of the JVMS &#39;annotation&#39; or &#39;array_value&#39; structure.
2985       */
2986     private int readElementValues(
2987             final AnnotationVisitor annotationVisitor,
2988             final int annotationOffset,
2989             final boolean named,
2990             final char[] charBuffer) {
2991         int currentOffset = annotationOffset;
2992         // Read the num_element_value_pairs field (or num_values field for an array_value).
2993         int numElementValuePairs = readUnsignedShort(currentOffset);
2994         currentOffset += 2;
2995         if (named) {
2996             // Parse the element_value_pairs array.
2997             while (numElementValuePairs-- &gt; 0) {
2998                 String elementName = readUTF8(currentOffset, charBuffer);
2999                 currentOffset =
3000                         readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);
3001             }
3002         } else {
3003             // Parse the array_value array.
3004             while (numElementValuePairs-- &gt; 0) {
3005                 currentOffset =
3006                         readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer);
3007             }
3008         }
3009         if (annotationVisitor != null) {
3010             annotationVisitor.visitEnd();
3011         }
3012         return currentOffset;
3013     }
3014 
3015     /**
3016       * Reads a JVMS &#39;element_value&#39; structure and makes the given visitor visit it.
3017       *
3018       * @param annotationVisitor the visitor that must visit the element_value structure.
3019       * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value
3020       *     structure to be read.
3021       * @param elementName the name of the element_value structure to be read, or {@literal null}.
3022       * @param charBuffer the buffer used to read strings in the constant pool.
3023       * @return the end offset of the JVMS &#39;element_value&#39; structure.
3024       */
3025     private int readElementValue(
3026             final AnnotationVisitor annotationVisitor,
3027             final int elementValueOffset,
3028             final String elementName,
3029             final char[] charBuffer) {
3030         int currentOffset = elementValueOffset;
3031         if (annotationVisitor == null) {
3032             switch (classFileBuffer[currentOffset] &amp; 0xFF) {
3033                 case &#39;e&#39;: // enum_const_value
3034                     return currentOffset + 5;
3035                 case &#39;@&#39;: // annotation_value
3036                     return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);
3037                 case &#39;[&#39;: // array_value
3038                     return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);
3039                 default:
3040                     return currentOffset + 3;
3041             }
3042         }
3043         switch (classFileBuffer[currentOffset++] &amp; 0xFF) {
3044             case &#39;B&#39;: // const_value_index, CONSTANT_Integer
3045                 annotationVisitor.visit(
3046                         elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
3047                 currentOffset += 2;
3048                 break;
3049             case &#39;C&#39;: // const_value_index, CONSTANT_Integer
3050                 annotationVisitor.visit(
3051                         elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
3052                 currentOffset += 2;
3053                 break;
3054             case &#39;D&#39;: // const_value_index, CONSTANT_Double
3055             case &#39;F&#39;: // const_value_index, CONSTANT_Float
3056             case &#39;I&#39;: // const_value_index, CONSTANT_Integer
3057             case &#39;J&#39;: // const_value_index, CONSTANT_Long
3058                 annotationVisitor.visit(
3059                         elementName, readConst(readUnsignedShort(currentOffset), charBuffer));
3060                 currentOffset += 2;
3061                 break;
3062             case &#39;S&#39;: // const_value_index, CONSTANT_Integer
3063                 annotationVisitor.visit(
3064                         elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
3065                 currentOffset += 2;
3066                 break;
3067 
3068             case &#39;Z&#39;: // const_value_index, CONSTANT_Integer
3069                 annotationVisitor.visit(
3070                         elementName,
3071                         readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0
3072                                 ? Boolean.FALSE
3073                                 : Boolean.TRUE);
3074                 currentOffset += 2;
3075                 break;
3076             case &#39;s&#39;: // const_value_index, CONSTANT_Utf8
3077                 annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));
3078                 currentOffset += 2;
3079                 break;
3080             case &#39;e&#39;: // enum_const_value
3081                 annotationVisitor.visitEnum(
3082                         elementName,
3083                         readUTF8(currentOffset, charBuffer),
3084                         readUTF8(currentOffset + 2, charBuffer));
3085                 currentOffset += 4;
3086                 break;
3087             case &#39;c&#39;: // class_info
3088                 annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));
3089                 currentOffset += 2;
3090                 break;
3091             case &#39;@&#39;: // annotation_value
3092                 currentOffset =
3093                         readElementValues(
3094                                 annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)),
3095                                 currentOffset + 2,
3096                                 true,
3097                                 charBuffer);
3098                 break;
3099             case &#39;[&#39;: // array_value
3100                 int numValues = readUnsignedShort(currentOffset);
3101                 currentOffset += 2;
3102                 if (numValues == 0) {
3103                     return readElementValues(
3104                             annotationVisitor.visitArray(elementName),
3105                             currentOffset - 2,
3106                             /* named = */ false,
3107                             charBuffer);
3108                 }
3109                 switch (classFileBuffer[currentOffset] &amp; 0xFF) {
3110                     case &#39;B&#39;:
3111                         byte[] byteValues = new byte[numValues];
3112                         for (int i = 0; i &lt; numValues; i++) {
3113                             byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
3114                             currentOffset += 3;
3115                         }
3116                         annotationVisitor.visit(elementName, byteValues);
3117                         break;
3118                     case &#39;Z&#39;:
3119                         boolean[] booleanValues = new boolean[numValues];
3120                         for (int i = 0; i &lt; numValues; i++) {
3121                             booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;
3122                             currentOffset += 3;
3123                         }
3124                         annotationVisitor.visit(elementName, booleanValues);
3125                         break;
3126                     case &#39;S&#39;:
3127                         short[] shortValues = new short[numValues];
3128                         for (int i = 0; i &lt; numValues; i++) {
3129                             shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
3130                             currentOffset += 3;
3131                         }
3132                         annotationVisitor.visit(elementName, shortValues);
3133                         break;
3134                     case &#39;C&#39;:
3135                         char[] charValues = new char[numValues];
3136                         for (int i = 0; i &lt; numValues; i++) {
3137                             charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
3138                             currentOffset += 3;
3139                         }
3140                         annotationVisitor.visit(elementName, charValues);
3141                         break;
3142                     case &#39;I&#39;:
3143                         int[] intValues = new int[numValues];
3144                         for (int i = 0; i &lt; numValues; i++) {
3145                             intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
3146                             currentOffset += 3;
3147                         }
3148                         annotationVisitor.visit(elementName, intValues);
3149                         break;
3150                     case &#39;J&#39;:
3151                         long[] longValues = new long[numValues];
3152                         for (int i = 0; i &lt; numValues; i++) {
3153                             longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
3154                             currentOffset += 3;
3155                         }
3156                         annotationVisitor.visit(elementName, longValues);
3157                         break;
3158                     case &#39;F&#39;:
3159                         float[] floatValues = new float[numValues];
3160                         for (int i = 0; i &lt; numValues; i++) {
3161                             floatValues[i] =
3162                                     Float.intBitsToFloat(
3163                                             readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));
3164                             currentOffset += 3;
3165                         }
3166                         annotationVisitor.visit(elementName, floatValues);
3167                         break;
3168                     case &#39;D&#39;:
3169                         double[] doubleValues = new double[numValues];
3170                         for (int i = 0; i &lt; numValues; i++) {
3171                             doubleValues[i] =
3172                                     Double.longBitsToDouble(
3173                                             readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));
3174                             currentOffset += 3;
3175                         }
3176                         annotationVisitor.visit(elementName, doubleValues);
3177                         break;
3178                     default:
3179                         currentOffset =
3180                                 readElementValues(
3181                                         annotationVisitor.visitArray(elementName),
3182                                         currentOffset - 2,
3183                                         /* named = */ false,
3184                                         charBuffer);
3185                         break;
3186                 }
3187                 break;
3188             default:
3189                 throw new IllegalArgumentException();
3190         }
3191         return currentOffset;
3192     }
3193 
3194     // ----------------------------------------------------------------------------------------------
3195     // Methods to parse stack map frames
3196     // ----------------------------------------------------------------------------------------------
3197 
3198     /**
3199       * Computes the implicit frame of the method currently being parsed (as defined in the given
3200       * {@link Context}) and stores it in the given context.
3201       *
3202       * @param context information about the class being parsed.
3203       */
3204     private void computeImplicitFrame(final Context context) {
3205         String methodDescriptor = context.currentMethodDescriptor;
3206         Object[] locals = context.currentFrameLocalTypes;
3207         int numLocal = 0;
3208         if ((context.currentMethodAccessFlags &amp; Opcodes.ACC_STATIC) == 0) {
3209             if (&quot;&lt;init&gt;&quot;.equals(context.currentMethodName)) {
3210                 locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;
3211             } else {
3212                 locals[numLocal++] = readClass(header + 2, context.charBuffer);
3213             }
3214         }
3215         // Parse the method descriptor, one argument type descriptor at each iteration. Start by
3216         // skipping the first method descriptor character, which is always &#39;(&#39;.
3217         int currentMethodDescritorOffset = 1;
3218         while (true) {
3219             int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;
3220             switch (methodDescriptor.charAt(currentMethodDescritorOffset++)) {
3221                 case &#39;Z&#39;:
3222                 case &#39;C&#39;:
3223                 case &#39;B&#39;:
3224                 case &#39;S&#39;:
3225                 case &#39;I&#39;:
3226                     locals[numLocal++] = Opcodes.INTEGER;
3227                     break;
3228                 case &#39;F&#39;:
3229                     locals[numLocal++] = Opcodes.FLOAT;
3230                     break;
3231                 case &#39;J&#39;:
3232                     locals[numLocal++] = Opcodes.LONG;
3233                     break;
3234                 case &#39;D&#39;:
3235                     locals[numLocal++] = Opcodes.DOUBLE;
3236                     break;
3237                 case &#39;[&#39;:
3238                     while (methodDescriptor.charAt(currentMethodDescritorOffset) == &#39;[&#39;) {
3239                         ++currentMethodDescritorOffset;
3240                     }
<a name="6" id="anc6"></a><span class="line-modified">3241                     char descType = methodDescriptor.charAt(currentMethodDescritorOffset);</span>
<span class="line-added">3242                     if (descType == &#39;L&#39; || descType == &#39;Q&#39;) {</span>
3243                         ++currentMethodDescritorOffset;
3244                         while (methodDescriptor.charAt(currentMethodDescritorOffset) != &#39;;&#39;) {
3245                             ++currentMethodDescritorOffset;
3246                         }
3247                     }
3248                     locals[numLocal++] =
3249                             methodDescriptor.substring(
3250                                     currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);
3251                     break;
3252                 case &#39;L&#39;:
3253                     while (methodDescriptor.charAt(currentMethodDescritorOffset) != &#39;;&#39;) {
3254                         ++currentMethodDescritorOffset;
3255                     }
3256                     locals[numLocal++] =
3257                             methodDescriptor.substring(
3258                                     currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);
3259                     break;
3260                 default:
3261                     context.currentFrameLocalCount = numLocal;
3262                     return;
3263             }
3264         }
3265     }
3266 
3267     /**
3268       * Reads a JVMS &#39;stack_map_frame&#39; structure and stores the result in the given {@link Context}
3269       * object. This method can also be used to read a full_frame structure, excluding its frame_type
3270       * field (this is used to parse the legacy StackMap attributes).
3271       *
3272       * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the
3273       *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure
3274       *     (excluding its frame_type field).
3275       * @param compressed true to read a &#39;stack_map_frame&#39; structure, false to read a &#39;full_frame&#39;
3276       *     structure without its frame_type field.
3277       * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
3278       * @param context where the parsed stack map frame must be stored.
3279       * @return the end offset of the JVMS &#39;stack_map_frame&#39; or &#39;full_frame&#39; structure.
3280       */
3281     private int readStackMapFrame(
3282             final int stackMapFrameOffset,
3283             final boolean compressed,
3284             final boolean expand,
3285             final Context context) {
3286         int currentOffset = stackMapFrameOffset;
3287         final char[] charBuffer = context.charBuffer;
3288         final Label[] labels = context.currentMethodLabels;
3289         int frameType;
3290         if (compressed) {
3291             // Read the frame_type field.
3292             frameType = classFileBuffer[currentOffset++] &amp; 0xFF;
3293         } else {
3294             frameType = Frame.FULL_FRAME;
3295             context.currentFrameOffset = -1;
3296         }
3297         int offsetDelta;
3298         context.currentFrameLocalCountDelta = 0;
3299         if (frameType &lt; Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {
3300             offsetDelta = frameType;
3301             context.currentFrameType = Opcodes.F_SAME;
3302             context.currentFrameStackCount = 0;
3303         } else if (frameType &lt; Frame.RESERVED) {
3304             offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;
3305             currentOffset =
3306                     readVerificationTypeInfo(
3307                             currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
3308             context.currentFrameType = Opcodes.F_SAME1;
3309             context.currentFrameStackCount = 1;
3310         } else if (frameType &gt;= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
3311             offsetDelta = readUnsignedShort(currentOffset);
3312             currentOffset += 2;
3313             if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
3314                 currentOffset =
3315                         readVerificationTypeInfo(
3316                                 currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
3317                 context.currentFrameType = Opcodes.F_SAME1;
3318                 context.currentFrameStackCount = 1;
3319             } else if (frameType &gt;= Frame.CHOP_FRAME &amp;&amp; frameType &lt; Frame.SAME_FRAME_EXTENDED) {
3320                 context.currentFrameType = Opcodes.F_CHOP;
3321                 context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;
3322                 context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;
3323                 context.currentFrameStackCount = 0;
3324             } else if (frameType == Frame.SAME_FRAME_EXTENDED) {
3325                 context.currentFrameType = Opcodes.F_SAME;
3326                 context.currentFrameStackCount = 0;
3327             } else if (frameType &lt; Frame.FULL_FRAME) {
3328                 int local = expand ? context.currentFrameLocalCount : 0;
3329                 for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k &gt; 0; k--) {
3330                     currentOffset =
3331                             readVerificationTypeInfo(
3332                                     currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);
3333                 }
3334                 context.currentFrameType = Opcodes.F_APPEND;
3335                 context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;
3336                 context.currentFrameLocalCount += context.currentFrameLocalCountDelta;
3337                 context.currentFrameStackCount = 0;
3338             } else {
3339                 final int numberOfLocals = readUnsignedShort(currentOffset);
3340                 currentOffset += 2;
3341                 context.currentFrameType = Opcodes.F_FULL;
3342                 context.currentFrameLocalCountDelta = numberOfLocals;
3343                 context.currentFrameLocalCount = numberOfLocals;
3344                 for (int local = 0; local &lt; numberOfLocals; ++local) {
3345                     currentOffset =
3346                             readVerificationTypeInfo(
3347                                     currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);
3348                 }
3349                 final int numberOfStackItems = readUnsignedShort(currentOffset);
3350                 currentOffset += 2;
3351                 context.currentFrameStackCount = numberOfStackItems;
3352                 for (int stack = 0; stack &lt; numberOfStackItems; ++stack) {
3353                     currentOffset =
3354                             readVerificationTypeInfo(
3355                                     currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);
3356                 }
3357             }
3358         } else {
3359             throw new IllegalArgumentException();
3360         }
3361         context.currentFrameOffset += offsetDelta + 1;
3362         createLabel(context.currentFrameOffset, labels);
3363         return currentOffset;
3364     }
3365 
3366     /**
3367       * Reads a JVMS &#39;verification_type_info&#39; structure and stores it at the given index in the given
3368       * array.
3369       *
3370       * @param verificationTypeInfoOffset the start offset of the &#39;verification_type_info&#39; structure to
3371       *     read.
3372       * @param frame the array where the parsed type must be stored.
3373       * @param index the index in &#39;frame&#39; where the parsed type must be stored.
3374       * @param charBuffer the buffer used to read strings in the constant pool.
3375       * @param labels the labels of the method currently being parsed, indexed by their offset. If the
3376       *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is
3377       *     stored in this array if it does not already exist.
3378       * @return the end offset of the JVMS &#39;verification_type_info&#39; structure.
3379       */
3380     private int readVerificationTypeInfo(
3381             final int verificationTypeInfoOffset,
3382             final Object[] frame,
3383             final int index,
3384             final char[] charBuffer,
3385             final Label[] labels) {
3386         int currentOffset = verificationTypeInfoOffset;
3387         int tag = classFileBuffer[currentOffset++] &amp; 0xFF;
3388         switch (tag) {
3389             case Frame.ITEM_TOP:
3390                 frame[index] = Opcodes.TOP;
3391                 break;
3392             case Frame.ITEM_INTEGER:
3393                 frame[index] = Opcodes.INTEGER;
3394                 break;
3395             case Frame.ITEM_FLOAT:
3396                 frame[index] = Opcodes.FLOAT;
3397                 break;
3398             case Frame.ITEM_DOUBLE:
3399                 frame[index] = Opcodes.DOUBLE;
3400                 break;
3401             case Frame.ITEM_LONG:
3402                 frame[index] = Opcodes.LONG;
3403                 break;
3404             case Frame.ITEM_NULL:
3405                 frame[index] = Opcodes.NULL;
3406                 break;
3407             case Frame.ITEM_UNINITIALIZED_THIS:
3408                 frame[index] = Opcodes.UNINITIALIZED_THIS;
3409                 break;
3410             case Frame.ITEM_OBJECT:
3411                 frame[index] = readClass(currentOffset, charBuffer);
3412                 currentOffset += 2;
3413                 break;
3414             case Frame.ITEM_UNINITIALIZED:
3415                 frame[index] = createLabel(readUnsignedShort(currentOffset), labels);
3416                 currentOffset += 2;
3417                 break;
3418             default:
3419                 throw new IllegalArgumentException();
3420         }
3421         return currentOffset;
3422     }
3423 
3424     // ----------------------------------------------------------------------------------------------
3425     // Methods to parse attributes
3426     // ----------------------------------------------------------------------------------------------
3427 
3428     /**
3429       * Returns the offset in {@link #classFileBuffer} of the first ClassFile&#39;s &#39;attributes&#39; array
3430       * field entry.
3431       *
3432       * @return the offset in {@link #classFileBuffer} of the first ClassFile&#39;s &#39;attributes&#39; array
3433       *     field entry.
3434       */
3435     final int getFirstAttributeOffset() {
3436         // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
3437         // each), as well as the interfaces array field (2 bytes per interface).
3438         int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;
3439 
3440         // Read the fields_count field.
3441         int fieldsCount = readUnsignedShort(currentOffset);
3442         currentOffset += 2;
3443         // Skip the &#39;fields&#39; array field.
3444         while (fieldsCount-- &gt; 0) {
3445             // Invariant: currentOffset is the offset of a field_info structure.
3446             // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the
3447             // attributes_count field.
3448             int attributesCount = readUnsignedShort(currentOffset + 6);
3449             currentOffset += 8;
3450             // Skip the &#39;attributes&#39; array field.
3451             while (attributesCount-- &gt; 0) {
3452                 // Invariant: currentOffset is the offset of an attribute_info structure.
3453                 // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip
3454                 // this many bytes, plus 6 for the attribute_name_index and attribute_length fields
3455                 // (yielding the total size of the attribute_info structure).
3456                 currentOffset += 6 + readInt(currentOffset + 2);
3457             }
3458         }
3459 
3460         // Skip the methods_count and &#39;methods&#39; fields, using the same method as above.
3461         int methodsCount = readUnsignedShort(currentOffset);
3462         currentOffset += 2;
3463         while (methodsCount-- &gt; 0) {
3464             int attributesCount = readUnsignedShort(currentOffset + 6);
3465             currentOffset += 8;
3466             while (attributesCount-- &gt; 0) {
3467                 currentOffset += 6 + readInt(currentOffset + 2);
3468             }
3469         }
3470 
3471         // Skip the ClassFile&#39;s attributes_count field.
3472         return currentOffset + 2;
3473     }
3474 
3475     /**
3476       * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
3477       *
3478       * @param maxStringLength a conservative estimate of the maximum length of the strings contained
3479       *     in the constant pool of the class.
3480       * @return the offsets of the bootstrap methods.
3481       */
3482     private int[] readBootstrapMethodsAttribute(final int maxStringLength) {
3483         char[] charBuffer = new char[maxStringLength];
3484         int currentAttributeOffset = getFirstAttributeOffset();
3485         int[] currentBootstrapMethodOffsets = null;
3486         for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {
3487             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
3488             String attributeName = readUTF8(currentAttributeOffset, charBuffer);
3489             int attributeLength = readInt(currentAttributeOffset + 2);
3490             currentAttributeOffset += 6;
3491             if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
3492                 // Read the num_bootstrap_methods field and create an array of this size.
3493                 currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];
3494                 // Compute and store the offset of each &#39;bootstrap_methods&#39; array field entry.
3495                 int currentBootstrapMethodOffset = currentAttributeOffset + 2;
3496                 for (int j = 0; j &lt; currentBootstrapMethodOffsets.length; ++j) {
3497                     currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;
3498                     // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),
3499                     // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).
3500                     currentBootstrapMethodOffset +=
3501                             4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;
3502                 }
3503                 return currentBootstrapMethodOffsets;
3504             }
3505             currentAttributeOffset += attributeLength;
3506         }
3507         throw new IllegalArgumentException();
3508     }
3509 
3510     /**
3511       * Reads a non standard JVMS &#39;attribute&#39; structure in {@link #classFileBuffer}.
3512       *
3513       * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
3514       *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
3515       *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
3516       * @param type the type of the attribute.
3517       * @param offset the start offset of the JVMS &#39;attribute&#39; structure in {@link #classFileBuffer}.
3518       *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into
3519       *     account here.
3520       * @param length the length of the attribute&#39;s content (excluding the 6 attribute header bytes).
3521       * @param charBuffer the buffer to be used to read strings in the constant pool.
3522       * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link
3523       *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6
3524       *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
3525       *     account here.
3526       * @param labels the labels of the method&#39;s code, or {@literal null} if the attribute to be read
3527       *     is not a code attribute.
3528       * @return the attribute that has been read.
3529       */
3530     private Attribute readAttribute(
3531             final Attribute[] attributePrototypes,
3532             final String type,
3533             final int offset,
3534             final int length,
3535             final char[] charBuffer,
3536             final int codeAttributeOffset,
3537             final Label[] labels) {
3538         for (Attribute attributePrototype : attributePrototypes) {
3539             if (attributePrototype.type.equals(type)) {
3540                 return attributePrototype.read(
3541                         this, offset, length, charBuffer, codeAttributeOffset, labels);
3542             }
3543         }
3544         return new Attribute(type).read(this, offset, length, null, -1, null);
3545     }
3546 
3547     // -----------------------------------------------------------------------------------------------
3548     // Utility methods: low level parsing
3549     // -----------------------------------------------------------------------------------------------
3550 
3551     /**
3552       * Returns the number of entries in the class&#39;s constant pool table.
3553       *
3554       * @return the number of entries in the class&#39;s constant pool table.
3555       */
3556     public int getItemCount() {
3557         return cpInfoOffsets.length;
3558     }
3559 
3560     /**
3561       * Returns the start offset in this {@link ClassReader} of a JVMS &#39;cp_info&#39; structure (i.e. a
3562       * constant pool entry), plus one. &lt;i&gt;This method is intended for {@link Attribute} sub classes,
3563       * and is normally not needed by class generators or adapters.&lt;/i&gt;
3564       *
3565       * @param constantPoolEntryIndex the index a constant pool entry in the class&#39;s constant pool
3566       *     table.
3567       * @return the start offset in this {@link ClassReader} of the corresponding JVMS &#39;cp_info&#39;
3568       *     structure, plus one.
3569       */
3570     public int getItem(final int constantPoolEntryIndex) {
3571         return cpInfoOffsets[constantPoolEntryIndex];
3572     }
3573 
3574     /**
3575       * Returns a conservative estimate of the maximum length of the strings contained in the class&#39;s
3576       * constant pool table.
3577       *
3578       * @return a conservative estimate of the maximum length of the strings contained in the class&#39;s
3579       *     constant pool table.
3580       */
3581     public int getMaxStringLength() {
3582         return maxStringLength;
3583     }
3584 
3585     /**
3586       * Reads a byte value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link
3587       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
3588       *
3589       * @param offset the start offset of the value to be read in this {@link ClassReader}.
3590       * @return the read value.
3591       */
3592     public int readByte(final int offset) {
3593         return classFileBuffer[offset] &amp; 0xFF;
3594     }
3595 
3596     /**
3597       * Reads an unsigned short value in this {@link ClassReader}. &lt;i&gt;This method is intended for
3598       * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
3599       *
3600       * @param offset the start index of the value to be read in this {@link ClassReader}.
3601       * @return the read value.
3602       */
3603     public int readUnsignedShort(final int offset) {
3604         byte[] classBuffer = classFileBuffer;
3605         return ((classBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classBuffer[offset + 1] &amp; 0xFF);
3606     }
3607 
3608     /**
3609       * Reads a signed short value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link
3610       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
3611       *
3612       * @param offset the start offset of the value to be read in this {@link ClassReader}.
3613       * @return the read value.
3614       */
3615     public short readShort(final int offset) {
3616         byte[] classBuffer = classFileBuffer;
3617         return (short) (((classBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classBuffer[offset + 1] &amp; 0xFF));
3618     }
3619 
3620     /**
3621       * Reads a signed int value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link
3622       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
3623       *
3624       * @param offset the start offset of the value to be read in this {@link ClassReader}.
3625       * @return the read value.
3626       */
3627     public int readInt(final int offset) {
3628         byte[] classBuffer = classFileBuffer;
3629         return ((classBuffer[offset] &amp; 0xFF) &lt;&lt; 24)
3630                 | ((classBuffer[offset + 1] &amp; 0xFF) &lt;&lt; 16)
3631                 | ((classBuffer[offset + 2] &amp; 0xFF) &lt;&lt; 8)
3632                 | (classBuffer[offset + 3] &amp; 0xFF);
3633     }
3634 
3635     /**
3636       * Reads a signed long value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link
3637       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
3638       *
3639       * @param offset the start offset of the value to be read in this {@link ClassReader}.
3640       * @return the read value.
3641       */
3642     public long readLong(final int offset) {
3643         long l1 = readInt(offset);
3644         long l0 = readInt(offset + 4) &amp; 0xFFFFFFFFL;
3645         return (l1 &lt;&lt; 32) | l0;
3646     }
3647 
3648     /**
3649       * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
3650       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
3651       * adapters.&lt;/i&gt;
3652       *
3653       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
3654       *     value is the index of a CONSTANT_Utf8 entry in the class&#39;s constant pool table.
3655       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3656       *     large. It is not automatically resized.
3657       * @return the String corresponding to the specified CONSTANT_Utf8 entry.
3658       */
3659     // DontCheck(AbbreviationAsWordInName): can&#39;t be renamed (for backward binary compatibility).
3660     public String readUTF8(final int offset, final char[] charBuffer) {
3661         int constantPoolEntryIndex = readUnsignedShort(offset);
3662         if (offset == 0 || constantPoolEntryIndex == 0) {
3663             return null;
3664         }
3665         return readUtf(constantPoolEntryIndex, charBuffer);
3666     }
3667 
3668     /**
3669       * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.
3670       *
3671       * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class&#39;s constant pool
3672       *     table.
3673       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3674       *     large. It is not automatically resized.
3675       * @return the String corresponding to the specified CONSTANT_Utf8 entry.
3676       */
3677     final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {
3678         String value = constantUtf8Values[constantPoolEntryIndex];
3679         if (value != null) {
3680             return value;
3681         }
3682         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
3683         return constantUtf8Values[constantPoolEntryIndex] =
3684                 readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);
3685     }
3686 
3687     /**
3688       * Reads an UTF8 string in {@link #classFileBuffer}.
3689       *
3690       * @param utfOffset the start offset of the UTF8 string to be read.
3691       * @param utfLength the length of the UTF8 string to be read.
3692       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3693       *     large. It is not automatically resized.
3694       * @return the String corresponding to the specified UTF8 string.
3695       */
3696     private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {
3697         int currentOffset = utfOffset;
3698         int endOffset = currentOffset + utfLength;
3699         int strLength = 0;
3700         byte[] classBuffer = classFileBuffer;
3701         while (currentOffset &lt; endOffset) {
3702             int currentByte = classBuffer[currentOffset++];
3703             if ((currentByte &amp; 0x80) == 0) {
3704                 charBuffer[strLength++] = (char) (currentByte &amp; 0x7F);
3705             } else if ((currentByte &amp; 0xE0) == 0xC0) {
3706                 charBuffer[strLength++] =
3707                         (char) (((currentByte &amp; 0x1F) &lt;&lt; 6) + (classBuffer[currentOffset++] &amp; 0x3F));
3708             } else {
3709                 charBuffer[strLength++] =
3710                         (char)
3711                                 (((currentByte &amp; 0xF) &lt;&lt; 12)
3712                                         + ((classBuffer[currentOffset++] &amp; 0x3F) &lt;&lt; 6)
3713                                         + (classBuffer[currentOffset++] &amp; 0x3F));
3714             }
3715         }
3716         return new String(charBuffer, 0, strLength);
3717     }
3718 
3719     /**
3720       * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
3721       * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. &lt;i&gt;This method is intended
3722       * for {@link Attribute} sub classes, and is normally not needed by class generators or
3723       * adapters.&lt;/i&gt;
3724       *
3725       * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose
3726       *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
3727       *     CONSTANT_Module or CONSTANT_Package entry in class&#39;s constant pool table.
3728       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3729       *     large. It is not automatically resized.
3730       * @return the String corresponding to the specified constant pool entry.
3731       */
3732     private String readStringish(final int offset, final char[] charBuffer) {
3733         // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry
3734         // designated by the first two bytes of this cp_info.
3735         return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);
3736     }
3737 
3738     /**
3739       * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
3740       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
3741       * adapters.&lt;/i&gt;
3742       *
3743       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
3744       *     value is the index of a CONSTANT_Class entry in class&#39;s constant pool table.
3745       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3746       *     large. It is not automatically resized.
3747       * @return the String corresponding to the specified CONSTANT_Class entry.
3748       */
3749     public String readClass(final int offset, final char[] charBuffer) {
3750         return readStringish(offset, charBuffer);
3751     }
3752 
3753     /**
3754       * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
3755       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
3756       * adapters.&lt;/i&gt;
3757       *
3758       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
3759       *     value is the index of a CONSTANT_Module entry in class&#39;s constant pool table.
3760       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3761       *     large. It is not automatically resized.
3762       * @return the String corresponding to the specified CONSTANT_Module entry.
3763       */
3764     public String readModule(final int offset, final char[] charBuffer) {
3765         return readStringish(offset, charBuffer);
3766     }
3767 
3768     /**
3769       * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
3770       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
3771       * adapters.&lt;/i&gt;
3772       *
3773       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
3774       *     value is the index of a CONSTANT_Package entry in class&#39;s constant pool table.
3775       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3776       *     large. It is not automatically resized.
3777       * @return the String corresponding to the specified CONSTANT_Package entry.
3778       */
3779     public String readPackage(final int offset, final char[] charBuffer) {
3780         return readStringish(offset, charBuffer);
3781     }
3782 
3783     /**
3784       * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.
3785       *
3786       * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class&#39;s constant
3787       *     pool table.
3788       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3789       *     large. It is not automatically resized.
3790       * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.
3791       */
3792     private ConstantDynamic readConstantDynamic(
3793             final int constantPoolEntryIndex, final char[] charBuffer) {
3794         ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];
3795         if (constantDynamic != null) {
3796             return constantDynamic;
3797         }
3798         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
3799         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
3800         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
3801         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
3802         int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];
3803         Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
3804         Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];
3805         bootstrapMethodOffset += 4;
3806         for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {
3807             bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
3808             bootstrapMethodOffset += 2;
3809         }
3810         return constantDynamicValues[constantPoolEntryIndex] =
3811                 new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);
3812     }
3813 
3814     /**
3815       * Reads a numeric or string constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is
3816       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
3817       * adapters.&lt;/i&gt;
3818       *
3819       * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
3820       *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
3821       *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class&#39;s constant pool.
3822       * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
3823       *     large. It is not automatically resized.
3824       * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},
3825       *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
3826       *     constant pool entry.
3827       */
3828     public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
3829         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
3830         switch (classFileBuffer[cpInfoOffset - 1]) {
3831             case Symbol.CONSTANT_INTEGER_TAG:
3832                 return readInt(cpInfoOffset);
3833             case Symbol.CONSTANT_FLOAT_TAG:
3834                 return Float.intBitsToFloat(readInt(cpInfoOffset));
3835             case Symbol.CONSTANT_LONG_TAG:
3836                 return readLong(cpInfoOffset);
3837             case Symbol.CONSTANT_DOUBLE_TAG:
3838                 return Double.longBitsToDouble(readLong(cpInfoOffset));
3839             case Symbol.CONSTANT_CLASS_TAG:
3840                 return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));
3841             case Symbol.CONSTANT_STRING_TAG:
3842                 return readUTF8(cpInfoOffset, charBuffer);
3843             case Symbol.CONSTANT_METHOD_TYPE_TAG:
3844                 return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));
3845             case Symbol.CONSTANT_METHOD_HANDLE_TAG:
3846                 int referenceKind = readByte(cpInfoOffset);
3847                 int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];
3848                 int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];
3849                 String owner = readClass(referenceCpInfoOffset, charBuffer);
3850                 String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
3851                 String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
3852                 boolean isInterface =
3853                         classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
3854                 return new Handle(referenceKind, owner, name, descriptor, isInterface);
3855             case Symbol.CONSTANT_DYNAMIC_TAG:
3856                 return readConstantDynamic(constantPoolEntryIndex, charBuffer);
3857             default:
3858                 throw new IllegalArgumentException();
3859         }
3860     }
3861 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../java/lang/reflect/ProxyGenerator.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../org/objectweb/asm/ClassReader.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/misc/Unsafe.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -175,19 +175,38 @@</span>
       *         {@link NullPointerException}
       */
      @HotSpotIntrinsicCandidate
      public native void putInt(Object o, long offset, int x);
  
<span class="udiff-line-added">+     private static final int JVM_ACC_FIELD_INLINED = 0x00008000; // HotSpot-specific bit</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Returns true if the given field is flattened.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public boolean isFlattened(Field f) {</span>
<span class="udiff-line-added">+         return (f.getModifiers() &amp; JVM_ACC_FIELD_INLINED) == JVM_ACC_FIELD_INLINED;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Returns true if the given class is a flattened array.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public native boolean isFlattenedArray(Class&lt;?&gt; arrayClass);</span>
<span class="udiff-line-added">+ </span>
      /**
       * Fetches a reference value from a given Java variable.
<span class="udiff-line-added">+      * This method can return a reference to either an object or value</span>
<span class="udiff-line-added">+      * or a null reference.</span>
<span class="udiff-line-added">+      *</span>
       * @see #getInt(Object, long)
       */
      @HotSpotIntrinsicCandidate
      public native Object getReference(Object o, long offset);
  
      /**
       * Stores a reference value into a given Java variable.
<span class="udiff-line-added">+      * This method can store a reference to either an object or value</span>
<span class="udiff-line-added">+      * or a null reference.</span>
       * &lt;p&gt;
       * Unless the reference {@code x} being stored is either null
       * or matches the field type, the results are undefined.
       * If the reference {@code o} is non-null, card marks or
       * other store barriers for that object (if the VM requires them)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -195,10 +214,111 @@</span>
       * @see #putInt(Object, long, int)
       */
      @HotSpotIntrinsicCandidate
      public native void putReference(Object o, long offset, Object x);
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Fetches a value of type {@code &lt;V&gt;} from a given Java variable.</span>
<span class="udiff-line-added">+      * More specifically, fetches a field or array element within the given</span>
<span class="udiff-line-added">+      * {@code o} object at the given offset, or (if {@code o} is null)</span>
<span class="udiff-line-added">+      * from the memory address whose numerical value is the given offset.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param o Java heap object in which the variable resides, if any, else</span>
<span class="udiff-line-added">+      *        null</span>
<span class="udiff-line-added">+      * @param offset indication of where the variable resides in a Java heap</span>
<span class="udiff-line-added">+      *        object, if any, else a memory address locating the variable</span>
<span class="udiff-line-added">+      *        statically</span>
<span class="udiff-line-added">+      * @param vc inline class</span>
<span class="udiff-line-added">+      * @param &lt;V&gt; the type of a value</span>
<span class="udiff-line-added">+      * @return the value fetched from the indicated Java variable</span>
<span class="udiff-line-added">+      * @throws RuntimeException No defined exceptions are thrown, not even</span>
<span class="udiff-line-added">+      *         {@link NullPointerException}</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="udiff-line-added">+     public native &lt;V&gt; V getValue(Object o, long offset, Class&lt;?&gt; vc);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Stores the given value into a given Java variable.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Unless the reference {@code o} being stored is either null</span>
<span class="udiff-line-added">+      * or matches the field type, the results are undefined.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param o Java heap object in which the variable resides, if any, else</span>
<span class="udiff-line-added">+      *        null</span>
<span class="udiff-line-added">+      * @param offset indication of where the variable resides in a Java heap</span>
<span class="udiff-line-added">+      *        object, if any, else a memory address locating the variable</span>
<span class="udiff-line-added">+      *        statically</span>
<span class="udiff-line-added">+      * @param vc inline class</span>
<span class="udiff-line-added">+      * @param v the value to store into the indicated Java variable</span>
<span class="udiff-line-added">+      * @param &lt;V&gt; the type of a value</span>
<span class="udiff-line-added">+      * @throws RuntimeException No defined exceptions are thrown, not even</span>
<span class="udiff-line-added">+      *         {@link NullPointerException}</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="udiff-line-added">+     public native &lt;V&gt; void putValue(Object o, long offset, Class&lt;?&gt; vc, V v);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Fetches a reference value of type {@code vc} from a given Java variable.</span>
<span class="udiff-line-added">+      * This method can return a reference to a value or a null reference</span>
<span class="udiff-line-added">+      * for a nullable-projection of an inline type.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param vc inline class</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public Object getReference(Object o, long offset, Class&lt;?&gt; vc) {</span>
<span class="udiff-line-added">+         Object ref = getReference(o, offset);</span>
<span class="udiff-line-added">+         if (ref == null &amp;&amp; vc.isInlineClass()) {</span>
<span class="udiff-line-added">+             // If the type of the returned reference is a regular inline type</span>
<span class="udiff-line-added">+             // return an uninitialized default value if null</span>
<span class="udiff-line-added">+             ref = uninitializedDefaultValue(vc);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return ref;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public Object getReferenceVolatile(Object o, long offset, Class&lt;?&gt; vc) {</span>
<span class="udiff-line-added">+         Object ref = getReferenceVolatile(o, offset);</span>
<span class="udiff-line-added">+         if (ref == null &amp;&amp; vc.isInlineClass()) {</span>
<span class="udiff-line-added">+             // If the type of the returned reference is a regular inline type</span>
<span class="udiff-line-added">+             // return an uninitialized default value if null</span>
<span class="udiff-line-added">+             ref = uninitializedDefaultValue(vc);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return ref;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Returns an uninitialized default value of the given inline class.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public native &lt;V&gt; V uninitializedDefaultValue(Class&lt;?&gt; vc);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Returns an object instance with a private buffered value whose layout</span>
<span class="udiff-line-added">+      * and contents is exactly the given value instance.  The return object</span>
<span class="udiff-line-added">+      * is in the larval state that can be updated using the unsafe put operation.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param value a value instance</span>
<span class="udiff-line-added">+      * @param &lt;V&gt; the type of the given value instance</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="udiff-line-added">+     public native &lt;V&gt; V makePrivateBuffer(V value);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Exits the larval state and returns a value instance.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param value a value instance</span>
<span class="udiff-line-added">+      * @param &lt;V&gt; the type of the given value instance</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="udiff-line-added">+     public native &lt;V&gt; V finishPrivateBuffer(V value);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Returns the header size of the given inline class</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param vc inline class</span>
<span class="udiff-line-added">+      * @param &lt;V&gt; value clas</span>
<span class="udiff-line-added">+      * @return the header size of the inline class</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public native &lt;V&gt; long valueHeaderSize(Class&lt;V&gt; vc);</span>
<span class="udiff-line-added">+ </span>
      /** @see #getInt(Object, long) */
      @HotSpotIntrinsicCandidate
      public native boolean getBoolean(Object o, long offset);
  
      /** @see #putInt(Object, long, int) */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1227,10 +1347,21 @@</span>
          }
  
          return arrayIndexScale0(arrayClass);
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Return the size of the object in the heap.</span>
<span class="udiff-line-added">+      * @param o an object</span>
<span class="udiff-line-added">+      * @return the objects&#39;s size</span>
<span class="udiff-line-added">+      * @since Valhalla</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public long getObjectSize(Object o) {</span>
<span class="udiff-line-added">+         if (o == null)</span>
<span class="udiff-line-added">+             throw new NullPointerException();</span>
<span class="udiff-line-added">+         return getObjectSize0(o);</span>
<span class="udiff-line-added">+     }</span>
  
      /** The value of {@code arrayIndexScale(boolean[].class)} */
      public static final int ARRAY_BOOLEAN_INDEX_SCALE
              = theUnsafe.arrayIndexScale(boolean[].class);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1432,57 +1563,241 @@</span>
      @HotSpotIntrinsicCandidate
      public final native boolean compareAndSetReference(Object o, long offset,
                                                         Object expected,
                                                         Object x);
  
<span class="udiff-line-added">+     private final boolean isInlineType(Object o) {</span>
<span class="udiff-line-added">+         return o != null &amp;&amp; o.getClass().isInlineClass();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /*</span>
<span class="udiff-line-added">+      * For inline type, CAS should do substitutability test as opposed</span>
<span class="udiff-line-added">+      * to two pointers comparison.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Perhaps we can keep the xxxObject methods for compatibility and</span>
<span class="udiff-line-added">+      * change the JDK 13 xxxReference method signature freely.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public final &lt;V&gt; boolean compareAndSetReference(Object o, long offset,</span>
<span class="udiff-line-added">+                                                     Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                     V expected,</span>
<span class="udiff-line-added">+                                                     V x) {</span>
<span class="udiff-line-added">+         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="udiff-line-added">+             synchronized (valueLock) {</span>
<span class="udiff-line-added">+                 Object witness = getReference(o, offset);</span>
<span class="udiff-line-added">+                 if (witness == expected) {</span>
<span class="udiff-line-added">+                     putReference(o, offset, x);</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             return compareAndSetReference(o, offset, expected, x);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; boolean compareAndSetValue(Object o, long offset,</span>
<span class="udiff-line-added">+                                                 Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                 V expected,</span>
<span class="udiff-line-added">+                                                 V x) {</span>
<span class="udiff-line-added">+         synchronized (valueLock) {</span>
<span class="udiff-line-added">+             Object witness = getValue(o, offset, valueType);</span>
<span class="udiff-line-added">+             if (witness == expected) {</span>
<span class="udiff-line-added">+                 putValue(o, offset, valueType, x);</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             else {</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @HotSpotIntrinsicCandidate
      public final native Object compareAndExchangeReference(Object o, long offset,
                                                             Object expected,
                                                             Object x);
  
<span class="udiff-line-added">+     public final &lt;V&gt; Object compareAndExchangeReference(Object o, long offset,</span>
<span class="udiff-line-added">+                                                         Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                         V expected,</span>
<span class="udiff-line-added">+                                                         V x) {</span>
<span class="udiff-line-added">+         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="udiff-line-added">+             synchronized (valueLock) {</span>
<span class="udiff-line-added">+                 Object witness = getReference(o, offset);</span>
<span class="udiff-line-added">+                 if (witness == expected) {</span>
<span class="udiff-line-added">+                     putReference(o, offset, x);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return witness;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             return compareAndExchangeReference(o, offset, expected, x);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; Object compareAndExchangeValue(Object o, long offset,</span>
<span class="udiff-line-added">+                                                     Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                     V expected,</span>
<span class="udiff-line-added">+                                                     V x) {</span>
<span class="udiff-line-added">+         synchronized (valueLock) {</span>
<span class="udiff-line-added">+             Object witness = getValue(o, offset, valueType);</span>
<span class="udiff-line-added">+             if (witness == expected) {</span>
<span class="udiff-line-added">+                 putValue(o, offset, valueType, x);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return witness;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @HotSpotIntrinsicCandidate
      public final Object compareAndExchangeReferenceAcquire(Object o, long offset,
                                                             Object expected,
                                                             Object x) {
          return compareAndExchangeReference(o, offset, expected, x);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; Object compareAndExchangeReferenceAcquire(Object o, long offset,</span>
<span class="udiff-line-added">+                                                                Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                                V expected,</span>
<span class="udiff-line-added">+                                                                V x) {</span>
<span class="udiff-line-added">+         return compareAndExchangeReference(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; Object compareAndExchangeValueAcquire(Object o, long offset,</span>
<span class="udiff-line-added">+                                                            Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                            V expected,</span>
<span class="udiff-line-added">+                                                            V x) {</span>
<span class="udiff-line-added">+         return compareAndExchangeValue(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @HotSpotIntrinsicCandidate
      public final Object compareAndExchangeReferenceRelease(Object o, long offset,
                                                             Object expected,
                                                             Object x) {
          return compareAndExchangeReference(o, offset, expected, x);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; Object compareAndExchangeReferenceRelease(Object o, long offset,</span>
<span class="udiff-line-added">+                                                                Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                                V expected,</span>
<span class="udiff-line-added">+                                                                V x) {</span>
<span class="udiff-line-added">+         return compareAndExchangeReference(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; Object compareAndExchangeValueRelease(Object o, long offset,</span>
<span class="udiff-line-added">+                                                            Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                            V expected,</span>
<span class="udiff-line-added">+                                                            V x) {</span>
<span class="udiff-line-added">+         return compareAndExchangeValue(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @HotSpotIntrinsicCandidate
      public final boolean weakCompareAndSetReferencePlain(Object o, long offset,
                                                           Object expected,
                                                           Object x) {
          return compareAndSetReference(o, offset, expected, x);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; boolean weakCompareAndSetReferencePlain(Object o, long offset,</span>
<span class="udiff-line-added">+                                                              Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                              V expected,</span>
<span class="udiff-line-added">+                                                              V x) {</span>
<span class="udiff-line-added">+         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="udiff-line-added">+             return compareAndSetReference(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             return weakCompareAndSetReferencePlain(o, offset, expected, x);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; boolean weakCompareAndSetValuePlain(Object o, long offset,</span>
<span class="udiff-line-added">+                                                          Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                          V expected,</span>
<span class="udiff-line-added">+                                                          V x) {</span>
<span class="udiff-line-added">+         return compareAndSetValue(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @HotSpotIntrinsicCandidate
      public final boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
                                                             Object expected,
                                                             Object x) {
          return compareAndSetReference(o, offset, expected, x);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; boolean weakCompareAndSetReferenceAcquire(Object o, long offset,</span>
<span class="udiff-line-added">+                                                                Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                                V expected,</span>
<span class="udiff-line-added">+                                                                V x) {</span>
<span class="udiff-line-added">+         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="udiff-line-added">+             return compareAndSetReference(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             return weakCompareAndSetReferencePlain(o, offset, expected, x);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; boolean weakCompareAndSetValueAcquire(Object o, long offset,</span>
<span class="udiff-line-added">+                                                            Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                            V expected,</span>
<span class="udiff-line-added">+                                                            V x) {</span>
<span class="udiff-line-added">+         return compareAndSetValue(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @HotSpotIntrinsicCandidate
      public final boolean weakCompareAndSetReferenceRelease(Object o, long offset,
                                                             Object expected,
                                                             Object x) {
          return compareAndSetReference(o, offset, expected, x);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; boolean weakCompareAndSetReferenceRelease(Object o, long offset,</span>
<span class="udiff-line-added">+                                                                Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                                V expected,</span>
<span class="udiff-line-added">+                                                                V x) {</span>
<span class="udiff-line-added">+         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="udiff-line-added">+             return compareAndSetReference(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             return weakCompareAndSetReferencePlain(o, offset, expected, x);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; boolean weakCompareAndSetValueRelease(Object o, long offset,</span>
<span class="udiff-line-added">+                                                            Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                            V expected,</span>
<span class="udiff-line-added">+                                                            V x) {</span>
<span class="udiff-line-added">+         return compareAndSetValue(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @HotSpotIntrinsicCandidate
      public final boolean weakCompareAndSetReference(Object o, long offset,
                                                      Object expected,
                                                      Object x) {
          return compareAndSetReference(o, offset, expected, x);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; boolean weakCompareAndSetReference(Object o, long offset,</span>
<span class="udiff-line-added">+                                                         Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                         V expected,</span>
<span class="udiff-line-added">+                                                         V x) {</span>
<span class="udiff-line-added">+         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="udiff-line-added">+             return compareAndSetReference(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             return weakCompareAndSetReferencePlain(o, offset, expected, x);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; boolean weakCompareAndSetValue(Object o, long offset,</span>
<span class="udiff-line-added">+                                                     Class&lt;?&gt; valueType,</span>
<span class="udiff-line-added">+                                                     V expected,</span>
<span class="udiff-line-added">+                                                     V x) {</span>
<span class="udiff-line-added">+         return compareAndSetValue(o, offset, valueType, expected, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Atomically updates Java variable to {@code x} if it is currently
       * holding {@code expected}.
       *
       * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2094,17 +2409,36 @@</span>
       * load semantics. Otherwise identical to {@link #getReference(Object, long)}
       */
      @HotSpotIntrinsicCandidate
      public native Object getReferenceVolatile(Object o, long offset);
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Global lock for atomic and volatile strength access to any value of</span>
<span class="udiff-line-added">+      * an inline type.  This is a temporary workaround until better localized</span>
<span class="udiff-line-added">+      * atomic access mechanisms are supported for inline types.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static final Object valueLock = new Object();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public final &lt;V&gt; Object getValueVolatile(Object base, long offset, Class&lt;?&gt; valueType) {</span>
<span class="udiff-line-added">+         synchronized (valueLock) {</span>
<span class="udiff-line-added">+             return getValue(base, offset, valueType);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Stores a reference value into a given Java variable, with
       * volatile store semantics. Otherwise identical to {@link #putReference(Object, long, Object)}
       */
      @HotSpotIntrinsicCandidate
      public native void putReferenceVolatile(Object o, long offset, Object x);
  
<span class="udiff-line-added">+     public final &lt;V&gt; void putValueVolatile(Object o, long offset, Class&lt;?&gt; valueType, V x) {</span>
<span class="udiff-line-added">+         synchronized (valueLock) {</span>
<span class="udiff-line-added">+             putValue(o, offset, valueType, x);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** Volatile version of {@link #getInt(Object, long)}  */
      @HotSpotIntrinsicCandidate
      public native int     getIntVolatile(Object o, long offset);
  
      /** Volatile version of {@link #putInt(Object, long, int)}  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2173,10 +2507,14 @@</span>
      @HotSpotIntrinsicCandidate
      public final Object getReferenceAcquire(Object o, long offset) {
          return getReferenceVolatile(o, offset);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; Object getValueAcquire(Object base, long offset, Class&lt;?&gt; valueType) {</span>
<span class="udiff-line-added">+         return getValueVolatile(base, offset, valueType);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** Acquire version of {@link #getBooleanVolatile(Object, long)} */
      @HotSpotIntrinsicCandidate
      public final boolean getBooleanAcquire(Object o, long offset) {
          return getBooleanVolatile(o, offset);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2237,10 +2575,14 @@</span>
      @HotSpotIntrinsicCandidate
      public final void putReferenceRelease(Object o, long offset, Object x) {
          putReferenceVolatile(o, offset, x);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; void putValueRelease(Object o, long offset, Class&lt;?&gt; valueType, V x) {</span>
<span class="udiff-line-added">+         putValueVolatile(o, offset, valueType, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
      @HotSpotIntrinsicCandidate
      public final void putBooleanRelease(Object o, long offset, boolean x) {
          putBooleanVolatile(o, offset, x);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2293,10 +2635,14 @@</span>
      @HotSpotIntrinsicCandidate
      public final Object getReferenceOpaque(Object o, long offset) {
          return getReferenceVolatile(o, offset);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; Object getValueOpaque(Object base, long offset, Class&lt;?&gt; valueType) {</span>
<span class="udiff-line-added">+         return getValueVolatile(base, offset, valueType);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** Opaque version of {@link #getBooleanVolatile(Object, long)} */
      @HotSpotIntrinsicCandidate
      public final boolean getBooleanOpaque(Object o, long offset) {
          return getBooleanVolatile(o, offset);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2347,10 +2693,14 @@</span>
      @HotSpotIntrinsicCandidate
      public final void putReferenceOpaque(Object o, long offset, Object x) {
          putReferenceVolatile(o, offset, x);
      }
  
<span class="udiff-line-added">+     public final &lt;V&gt; void putValueOpaque(Object o, long offset, Class&lt;?&gt; valueType, V x) {</span>
<span class="udiff-line-added">+         putValueVolatile(o, offset, valueType, x);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** Opaque version of {@link #putBooleanVolatile(Object, long, boolean)} */
      @HotSpotIntrinsicCandidate
      public final void putBooleanOpaque(Object o, long offset, boolean x) {
          putBooleanVolatile(o, offset, x);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2781,28 +3131,47 @@</span>
              v = getReferenceVolatile(o, offset);
          } while (!weakCompareAndSetReference(o, offset, v, newValue));
          return v;
      }
  
<span class="udiff-line-added">+     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="udiff-line-added">+     public final &lt;V&gt; Object getAndSetValue(Object o, long offset, Class&lt;?&gt; valueType, V newValue) {</span>
<span class="udiff-line-added">+         synchronized (valueLock) {</span>
<span class="udiff-line-added">+             Object oldValue = getValue(o, offset, valueType);</span>
<span class="udiff-line-added">+             putValue(o, offset, valueType, newValue);</span>
<span class="udiff-line-added">+             return oldValue;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @ForceInline
      public final Object getAndSetReferenceRelease(Object o, long offset, Object newValue) {
          Object v;
          do {
              v = getReference(o, offset);
          } while (!weakCompareAndSetReferenceRelease(o, offset, v, newValue));
          return v;
      }
  
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; Object getAndSetValueRelease(Object o, long offset, Class&lt;?&gt; valueType, V newValue) {</span>
<span class="udiff-line-added">+         return getAndSetValue(o, offset, valueType, newValue);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @ForceInline
      public final Object getAndSetReferenceAcquire(Object o, long offset, Object newValue) {
          Object v;
          do {
              v = getReferenceAcquire(o, offset);
          } while (!weakCompareAndSetReferenceAcquire(o, offset, v, newValue));
          return v;
      }
  
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     public final &lt;V&gt; Object getAndSetValueAcquire(Object o, long offset, Class&lt;?&gt; valueType, V newValue) {</span>
<span class="udiff-line-added">+         return getAndSetValue(o, offset, valueType, newValue);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @HotSpotIntrinsicCandidate
      public final byte getAndSetByte(Object o, long offset, byte newValue) {
          byte v;
          do {
              v = getByteVolatile(o, offset);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3843,10 +4212,11 @@</span>
      private native Object staticFieldBase0(Field f);
      private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
      private native void ensureClassInitialized0(Class&lt;?&gt; c);
      private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
      private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);
<span class="udiff-line-added">+     private native long getObjectSize0(Object o);</span>
      private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
      private native int getLoadAverage0(double[] loadavg, int nelems);
  
  
      /**
</pre>
<center><a href="../../../java/lang/reflect/ProxyGenerator.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../org/objectweb/asm/ClassReader.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
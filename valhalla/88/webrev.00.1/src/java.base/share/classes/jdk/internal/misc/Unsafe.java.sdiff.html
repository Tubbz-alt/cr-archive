<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../java/lang/reflect/ProxyGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../org/objectweb/asm/ClassReader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/misc/Unsafe.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 160      * The first two parameters are interpreted exactly as with
 161      * {@link #getInt(Object, long)} to refer to a specific
 162      * Java variable (field or array element).  The given value
 163      * is stored into that variable.
 164      * &lt;p&gt;
 165      * The variable must be of the same type as the method
 166      * parameter {@code x}.
 167      *
 168      * @param o Java heap object in which the variable resides, if any, else
 169      *        null
 170      * @param offset indication of where the variable resides in a Java heap
 171      *        object, if any, else a memory address locating the variable
 172      *        statically
 173      * @param x the value to store into the indicated Java variable
 174      * @throws RuntimeException No defined exceptions are thrown, not even
 175      *         {@link NullPointerException}
 176      */
 177     @HotSpotIntrinsicCandidate
 178     public native void putInt(Object o, long offset, int x);
 179 














 180     /**
 181      * Fetches a reference value from a given Java variable.



 182      * @see #getInt(Object, long)
 183      */
 184     @HotSpotIntrinsicCandidate
 185     public native Object getReference(Object o, long offset);
 186 
 187     /**
 188      * Stores a reference value into a given Java variable.


 189      * &lt;p&gt;
 190      * Unless the reference {@code x} being stored is either null
 191      * or matches the field type, the results are undefined.
 192      * If the reference {@code o} is non-null, card marks or
 193      * other store barriers for that object (if the VM requires them)
 194      * are updated.
 195      * @see #putInt(Object, long, int)
 196      */
 197     @HotSpotIntrinsicCandidate
 198     public native void putReference(Object o, long offset, Object x);
 199 





































































































 200     /** @see #getInt(Object, long) */
 201     @HotSpotIntrinsicCandidate
 202     public native boolean getBoolean(Object o, long offset);
 203 
 204     /** @see #putInt(Object, long, int) */
 205     @HotSpotIntrinsicCandidate
 206     public native void    putBoolean(Object o, long offset, boolean x);
 207 
 208     /** @see #getInt(Object, long) */
 209     @HotSpotIntrinsicCandidate
 210     public native byte    getByte(Object o, long offset);
 211 
 212     /** @see #putInt(Object, long, int) */
 213     @HotSpotIntrinsicCandidate
 214     public native void    putByte(Object o, long offset, byte x);
 215 
 216     /** @see #getInt(Object, long) */
 217     @HotSpotIntrinsicCandidate
 218     public native short   getShort(Object o, long offset);
 219 
</pre>
<hr />
<pre>
1212 
1213     /**
1214      * Reports the scale factor for addressing elements in the storage
1215      * allocation of a given array class.  However, arrays of &quot;narrow&quot; types
1216      * will generally not work properly with accessors like {@link
1217      * #getByte(Object, long)}, so the scale factor for such classes is reported
1218      * as zero.
1219      *
1220      * @see #arrayBaseOffset
1221      * @see #getInt(Object, long)
1222      * @see #putInt(Object, long, int)
1223      */
1224     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
1225         if (arrayClass == null) {
1226             throw new NullPointerException();
1227         }
1228 
1229         return arrayIndexScale0(arrayClass);
1230     }
1231 











1232 
1233     /** The value of {@code arrayIndexScale(boolean[].class)} */
1234     public static final int ARRAY_BOOLEAN_INDEX_SCALE
1235             = theUnsafe.arrayIndexScale(boolean[].class);
1236 
1237     /** The value of {@code arrayIndexScale(byte[].class)} */
1238     public static final int ARRAY_BYTE_INDEX_SCALE
1239             = theUnsafe.arrayIndexScale(byte[].class);
1240 
1241     /** The value of {@code arrayIndexScale(short[].class)} */
1242     public static final int ARRAY_SHORT_INDEX_SCALE
1243             = theUnsafe.arrayIndexScale(short[].class);
1244 
1245     /** The value of {@code arrayIndexScale(char[].class)} */
1246     public static final int ARRAY_CHAR_INDEX_SCALE
1247             = theUnsafe.arrayIndexScale(char[].class);
1248 
1249     /** The value of {@code arrayIndexScale(int[].class)} */
1250     public static final int ARRAY_INT_INDEX_SCALE
1251             = theUnsafe.arrayIndexScale(int[].class);
</pre>
<hr />
<pre>
1417        return null;
1418     }
1419 
1420     /** Throws the exception without telling the verifier. */
1421     public native void throwException(Throwable ee);
1422 
1423     /**
1424      * Atomically updates Java variable to {@code x} if it is currently
1425      * holding {@code expected}.
1426      *
1427      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1428      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1429      *
1430      * @return {@code true} if successful
1431      */
1432     @HotSpotIntrinsicCandidate
1433     public final native boolean compareAndSetReference(Object o, long offset,
1434                                                        Object expected,
1435                                                        Object x);
1436 















































1437     @HotSpotIntrinsicCandidate
1438     public final native Object compareAndExchangeReference(Object o, long offset,
1439                                                            Object expected,
1440                                                            Object x);
1441 































1442     @HotSpotIntrinsicCandidate
1443     public final Object compareAndExchangeReferenceAcquire(Object o, long offset,
1444                                                            Object expected,
1445                                                            Object x) {
1446         return compareAndExchangeReference(o, offset, expected, x);
1447     }
1448 















1449     @HotSpotIntrinsicCandidate
1450     public final Object compareAndExchangeReferenceRelease(Object o, long offset,
1451                                                            Object expected,
1452                                                            Object x) {
1453         return compareAndExchangeReference(o, offset, expected, x);
1454     }
1455 















1456     @HotSpotIntrinsicCandidate
1457     public final boolean weakCompareAndSetReferencePlain(Object o, long offset,
1458                                                          Object expected,
1459                                                          Object x) {
1460         return compareAndSetReference(o, offset, expected, x);
1461     }
1462 



















1463     @HotSpotIntrinsicCandidate
1464     public final boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
1465                                                            Object expected,
1466                                                            Object x) {
1467         return compareAndSetReference(o, offset, expected, x);
1468     }
1469 



















1470     @HotSpotIntrinsicCandidate
1471     public final boolean weakCompareAndSetReferenceRelease(Object o, long offset,
1472                                                            Object expected,
1473                                                            Object x) {
1474         return compareAndSetReference(o, offset, expected, x);
1475     }
1476 



















1477     @HotSpotIntrinsicCandidate
1478     public final boolean weakCompareAndSetReference(Object o, long offset,
1479                                                     Object expected,
1480                                                     Object x) {
1481         return compareAndSetReference(o, offset, expected, x);
1482     }
1483 



















1484     /**
1485      * Atomically updates Java variable to {@code x} if it is currently
1486      * holding {@code expected}.
1487      *
1488      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1489      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1490      *
1491      * @return {@code true} if successful
1492      */
1493     @HotSpotIntrinsicCandidate
1494     public final native boolean compareAndSetInt(Object o, long offset,
1495                                                  int expected,
1496                                                  int x);
1497 
1498     @HotSpotIntrinsicCandidate
1499     public final native int compareAndExchangeInt(Object o, long offset,
1500                                                   int expected,
1501                                                   int x);
1502 
1503     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
2079     public final boolean weakCompareAndSetLongRelease(Object o, long offset,
2080                                                       long expected,
2081                                                       long x) {
2082         return compareAndSetLong(o, offset, expected, x);
2083     }
2084 
2085     @HotSpotIntrinsicCandidate
2086     public final boolean weakCompareAndSetLong(Object o, long offset,
2087                                                long expected,
2088                                                long x) {
2089         return compareAndSetLong(o, offset, expected, x);
2090     }
2091 
2092     /**
2093      * Fetches a reference value from a given Java variable, with volatile
2094      * load semantics. Otherwise identical to {@link #getReference(Object, long)}
2095      */
2096     @HotSpotIntrinsicCandidate
2097     public native Object getReferenceVolatile(Object o, long offset);
2098 













2099     /**
2100      * Stores a reference value into a given Java variable, with
2101      * volatile store semantics. Otherwise identical to {@link #putReference(Object, long, Object)}
2102      */
2103     @HotSpotIntrinsicCandidate
2104     public native void putReferenceVolatile(Object o, long offset, Object x);
2105 






2106     /** Volatile version of {@link #getInt(Object, long)}  */
2107     @HotSpotIntrinsicCandidate
2108     public native int     getIntVolatile(Object o, long offset);
2109 
2110     /** Volatile version of {@link #putInt(Object, long, int)}  */
2111     @HotSpotIntrinsicCandidate
2112     public native void    putIntVolatile(Object o, long offset, int x);
2113 
2114     /** Volatile version of {@link #getBoolean(Object, long)}  */
2115     @HotSpotIntrinsicCandidate
2116     public native boolean getBooleanVolatile(Object o, long offset);
2117 
2118     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
2119     @HotSpotIntrinsicCandidate
2120     public native void    putBooleanVolatile(Object o, long offset, boolean x);
2121 
2122     /** Volatile version of {@link #getByte(Object, long)}  */
2123     @HotSpotIntrinsicCandidate
2124     public native byte    getByteVolatile(Object o, long offset);
2125 
</pre>
<hr />
<pre>
2158     /** Volatile version of {@link #putFloat(Object, long, float)}  */
2159     @HotSpotIntrinsicCandidate
2160     public native void    putFloatVolatile(Object o, long offset, float x);
2161 
2162     /** Volatile version of {@link #getDouble(Object, long)}  */
2163     @HotSpotIntrinsicCandidate
2164     public native double  getDoubleVolatile(Object o, long offset);
2165 
2166     /** Volatile version of {@link #putDouble(Object, long, double)}  */
2167     @HotSpotIntrinsicCandidate
2168     public native void    putDoubleVolatile(Object o, long offset, double x);
2169 
2170 
2171 
2172     /** Acquire version of {@link #getReferenceVolatile(Object, long)} */
2173     @HotSpotIntrinsicCandidate
2174     public final Object getReferenceAcquire(Object o, long offset) {
2175         return getReferenceVolatile(o, offset);
2176     }
2177 




2178     /** Acquire version of {@link #getBooleanVolatile(Object, long)} */
2179     @HotSpotIntrinsicCandidate
2180     public final boolean getBooleanAcquire(Object o, long offset) {
2181         return getBooleanVolatile(o, offset);
2182     }
2183 
2184     /** Acquire version of {@link #getByteVolatile(Object, long)} */
2185     @HotSpotIntrinsicCandidate
2186     public final byte getByteAcquire(Object o, long offset) {
2187         return getByteVolatile(o, offset);
2188     }
2189 
2190     /** Acquire version of {@link #getShortVolatile(Object, long)} */
2191     @HotSpotIntrinsicCandidate
2192     public final short getShortAcquire(Object o, long offset) {
2193         return getShortVolatile(o, offset);
2194     }
2195 
2196     /** Acquire version of {@link #getCharVolatile(Object, long)} */
2197     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
2222     public final double getDoubleAcquire(Object o, long offset) {
2223         return getDoubleVolatile(o, offset);
2224     }
2225 
2226     /*
2227      * Versions of {@link #putReferenceVolatile(Object, long, Object)}
2228      * that do not guarantee immediate visibility of the store to
2229      * other threads. This method is generally only useful if the
2230      * underlying field is a Java volatile (or if an array cell, one
2231      * that is otherwise only accessed using volatile accesses).
2232      *
2233      * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
2234      */
2235 
2236     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2237     @HotSpotIntrinsicCandidate
2238     public final void putReferenceRelease(Object o, long offset, Object x) {
2239         putReferenceVolatile(o, offset, x);
2240     }
2241 




2242     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2243     @HotSpotIntrinsicCandidate
2244     public final void putBooleanRelease(Object o, long offset, boolean x) {
2245         putBooleanVolatile(o, offset, x);
2246     }
2247 
2248     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2249     @HotSpotIntrinsicCandidate
2250     public final void putByteRelease(Object o, long offset, byte x) {
2251         putByteVolatile(o, offset, x);
2252     }
2253 
2254     /** Release version of {@link #putShortVolatile(Object, long, short)} */
2255     @HotSpotIntrinsicCandidate
2256     public final void putShortRelease(Object o, long offset, short x) {
2257         putShortVolatile(o, offset, x);
2258     }
2259 
2260     /** Release version of {@link #putCharVolatile(Object, long, char)} */
2261     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
2278     /** Release version of {@link #putLongVolatile(Object, long, long)} */
2279     @HotSpotIntrinsicCandidate
2280     public final void putLongRelease(Object o, long offset, long x) {
2281         putLongVolatile(o, offset, x);
2282     }
2283 
2284     /** Release version of {@link #putDoubleVolatile(Object, long, double)} */
2285     @HotSpotIntrinsicCandidate
2286     public final void putDoubleRelease(Object o, long offset, double x) {
2287         putDoubleVolatile(o, offset, x);
2288     }
2289 
2290     // ------------------------------ Opaque --------------------------------------
2291 
2292     /** Opaque version of {@link #getReferenceVolatile(Object, long)} */
2293     @HotSpotIntrinsicCandidate
2294     public final Object getReferenceOpaque(Object o, long offset) {
2295         return getReferenceVolatile(o, offset);
2296     }
2297 




2298     /** Opaque version of {@link #getBooleanVolatile(Object, long)} */
2299     @HotSpotIntrinsicCandidate
2300     public final boolean getBooleanOpaque(Object o, long offset) {
2301         return getBooleanVolatile(o, offset);
2302     }
2303 
2304     /** Opaque version of {@link #getByteVolatile(Object, long)} */
2305     @HotSpotIntrinsicCandidate
2306     public final byte getByteOpaque(Object o, long offset) {
2307         return getByteVolatile(o, offset);
2308     }
2309 
2310     /** Opaque version of {@link #getShortVolatile(Object, long)} */
2311     @HotSpotIntrinsicCandidate
2312     public final short getShortOpaque(Object o, long offset) {
2313         return getShortVolatile(o, offset);
2314     }
2315 
2316     /** Opaque version of {@link #getCharVolatile(Object, long)} */
2317     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
2332     }
2333 
2334     /** Opaque version of {@link #getLongVolatile(Object, long)} */
2335     @HotSpotIntrinsicCandidate
2336     public final long getLongOpaque(Object o, long offset) {
2337         return getLongVolatile(o, offset);
2338     }
2339 
2340     /** Opaque version of {@link #getDoubleVolatile(Object, long)} */
2341     @HotSpotIntrinsicCandidate
2342     public final double getDoubleOpaque(Object o, long offset) {
2343         return getDoubleVolatile(o, offset);
2344     }
2345 
2346     /** Opaque version of {@link #putReferenceVolatile(Object, long, Object)} */
2347     @HotSpotIntrinsicCandidate
2348     public final void putReferenceOpaque(Object o, long offset, Object x) {
2349         putReferenceVolatile(o, offset, x);
2350     }
2351 




2352     /** Opaque version of {@link #putBooleanVolatile(Object, long, boolean)} */
2353     @HotSpotIntrinsicCandidate
2354     public final void putBooleanOpaque(Object o, long offset, boolean x) {
2355         putBooleanVolatile(o, offset, x);
2356     }
2357 
2358     /** Opaque version of {@link #putByteVolatile(Object, long, byte)} */
2359     @HotSpotIntrinsicCandidate
2360     public final void putByteOpaque(Object o, long offset, byte x) {
2361         putByteVolatile(o, offset, x);
2362     }
2363 
2364     /** Opaque version of {@link #putShortVolatile(Object, long, short)} */
2365     @HotSpotIntrinsicCandidate
2366     public final void putShortOpaque(Object o, long offset, short x) {
2367         putShortVolatile(o, offset, x);
2368     }
2369 
2370     /** Opaque version of {@link #putCharVolatile(Object, long, char)} */
2371     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
2766     /**
2767      * Atomically exchanges the given reference value with the current
2768      * reference value of a field or array element within the given
2769      * object {@code o} at the given {@code offset}.
2770      *
2771      * @param o object/array to update the field/element in
2772      * @param offset field/element offset
2773      * @param newValue new value
2774      * @return the previous value
2775      * @since 1.8
2776      */
2777     @HotSpotIntrinsicCandidate
2778     public final Object getAndSetReference(Object o, long offset, Object newValue) {
2779         Object v;
2780         do {
2781             v = getReferenceVolatile(o, offset);
2782         } while (!weakCompareAndSetReference(o, offset, v, newValue));
2783         return v;
2784     }
2785 









2786     @ForceInline
2787     public final Object getAndSetReferenceRelease(Object o, long offset, Object newValue) {
2788         Object v;
2789         do {
2790             v = getReference(o, offset);
2791         } while (!weakCompareAndSetReferenceRelease(o, offset, v, newValue));
2792         return v;
2793     }
2794 





2795     @ForceInline
2796     public final Object getAndSetReferenceAcquire(Object o, long offset, Object newValue) {
2797         Object v;
2798         do {
2799             v = getReferenceAcquire(o, offset);
2800         } while (!weakCompareAndSetReferenceAcquire(o, offset, v, newValue));
2801         return v;
2802     }
2803 





2804     @HotSpotIntrinsicCandidate
2805     public final byte getAndSetByte(Object o, long offset, byte newValue) {
2806         byte v;
2807         do {
2808             v = getByteVolatile(o, offset);
2809         } while (!weakCompareAndSetByte(o, offset, v, newValue));
2810         return v;
2811     }
2812 
2813     @ForceInline
2814     public final byte getAndSetByteRelease(Object o, long offset, byte newValue) {
2815         byte v;
2816         do {
2817             v = getByte(o, offset);
2818         } while (!weakCompareAndSetByteRelease(o, offset, v, newValue));
2819         return v;
2820     }
2821 
2822     @ForceInline
2823     public final byte getAndSetByteAcquire(Object o, long offset, byte newValue) {
</pre>
<hr />
<pre>
3828     private static int convEndian(boolean big, int n)     { return big == BIG_ENDIAN ? n : Integer.reverseBytes(n)  ; }
3829     private static long convEndian(boolean big, long n)   { return big == BIG_ENDIAN ? n : Long.reverseBytes(n)     ; }
3830 
3831 
3832 
3833     private native long allocateMemory0(long bytes);
3834     private native long reallocateMemory0(long address, long bytes);
3835     private native void freeMemory0(long address);
3836     private native void setMemory0(Object o, long offset, long bytes, byte value);
3837     @HotSpotIntrinsicCandidate
3838     private native void copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
3839     private native void copySwapMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes, long elemSize);
3840     private native long objectFieldOffset0(Field f);
3841     private native long objectFieldOffset1(Class&lt;?&gt; c, String name);
3842     private native long staticFieldOffset0(Field f);
3843     private native Object staticFieldBase0(Field f);
3844     private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
3845     private native void ensureClassInitialized0(Class&lt;?&gt; c);
3846     private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
3847     private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);

3848     private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
3849     private native int getLoadAverage0(double[] loadavg, int nelems);
3850 
3851 
3852     /**
3853      * Invokes the given direct byte buffer&#39;s cleaner, if any.
3854      *
3855      * @param directBuffer a direct byte buffer
3856      * @throws NullPointerException     if {@code directBuffer} is null
3857      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
3858      *                                  or is a {@link java.nio.Buffer#slice slice}, or is a
3859      *                                  {@link java.nio.Buffer#duplicate duplicate}
3860      */
3861     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
3862         if (!directBuffer.isDirect())
3863             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
3864 
3865         DirectBuffer db = (DirectBuffer) directBuffer;
3866         if (db.attachment() != null)
3867             throw new IllegalArgumentException(&quot;duplicate or slice&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 160      * The first two parameters are interpreted exactly as with
 161      * {@link #getInt(Object, long)} to refer to a specific
 162      * Java variable (field or array element).  The given value
 163      * is stored into that variable.
 164      * &lt;p&gt;
 165      * The variable must be of the same type as the method
 166      * parameter {@code x}.
 167      *
 168      * @param o Java heap object in which the variable resides, if any, else
 169      *        null
 170      * @param offset indication of where the variable resides in a Java heap
 171      *        object, if any, else a memory address locating the variable
 172      *        statically
 173      * @param x the value to store into the indicated Java variable
 174      * @throws RuntimeException No defined exceptions are thrown, not even
 175      *         {@link NullPointerException}
 176      */
 177     @HotSpotIntrinsicCandidate
 178     public native void putInt(Object o, long offset, int x);
 179 
<span class="line-added"> 180     private static final int JVM_ACC_FIELD_INLINED = 0x00008000; // HotSpot-specific bit</span>
<span class="line-added"> 181 </span>
<span class="line-added"> 182     /**</span>
<span class="line-added"> 183      * Returns true if the given field is flattened.</span>
<span class="line-added"> 184      */</span>
<span class="line-added"> 185     public boolean isFlattened(Field f) {</span>
<span class="line-added"> 186         return (f.getModifiers() &amp; JVM_ACC_FIELD_INLINED) == JVM_ACC_FIELD_INLINED;</span>
<span class="line-added"> 187     }</span>
<span class="line-added"> 188 </span>
<span class="line-added"> 189     /**</span>
<span class="line-added"> 190      * Returns true if the given class is a flattened array.</span>
<span class="line-added"> 191      */</span>
<span class="line-added"> 192     public native boolean isFlattenedArray(Class&lt;?&gt; arrayClass);</span>
<span class="line-added"> 193 </span>
 194     /**
 195      * Fetches a reference value from a given Java variable.
<span class="line-added"> 196      * This method can return a reference to either an object or value</span>
<span class="line-added"> 197      * or a null reference.</span>
<span class="line-added"> 198      *</span>
 199      * @see #getInt(Object, long)
 200      */
 201     @HotSpotIntrinsicCandidate
 202     public native Object getReference(Object o, long offset);
 203 
 204     /**
 205      * Stores a reference value into a given Java variable.
<span class="line-added"> 206      * This method can store a reference to either an object or value</span>
<span class="line-added"> 207      * or a null reference.</span>
 208      * &lt;p&gt;
 209      * Unless the reference {@code x} being stored is either null
 210      * or matches the field type, the results are undefined.
 211      * If the reference {@code o} is non-null, card marks or
 212      * other store barriers for that object (if the VM requires them)
 213      * are updated.
 214      * @see #putInt(Object, long, int)
 215      */
 216     @HotSpotIntrinsicCandidate
 217     public native void putReference(Object o, long offset, Object x);
 218 
<span class="line-added"> 219     /**</span>
<span class="line-added"> 220      * Fetches a value of type {@code &lt;V&gt;} from a given Java variable.</span>
<span class="line-added"> 221      * More specifically, fetches a field or array element within the given</span>
<span class="line-added"> 222      * {@code o} object at the given offset, or (if {@code o} is null)</span>
<span class="line-added"> 223      * from the memory address whose numerical value is the given offset.</span>
<span class="line-added"> 224      *</span>
<span class="line-added"> 225      * @param o Java heap object in which the variable resides, if any, else</span>
<span class="line-added"> 226      *        null</span>
<span class="line-added"> 227      * @param offset indication of where the variable resides in a Java heap</span>
<span class="line-added"> 228      *        object, if any, else a memory address locating the variable</span>
<span class="line-added"> 229      *        statically</span>
<span class="line-added"> 230      * @param vc inline class</span>
<span class="line-added"> 231      * @param &lt;V&gt; the type of a value</span>
<span class="line-added"> 232      * @return the value fetched from the indicated Java variable</span>
<span class="line-added"> 233      * @throws RuntimeException No defined exceptions are thrown, not even</span>
<span class="line-added"> 234      *         {@link NullPointerException}</span>
<span class="line-added"> 235      */</span>
<span class="line-added"> 236     @HotSpotIntrinsicCandidate</span>
<span class="line-added"> 237     public native &lt;V&gt; V getValue(Object o, long offset, Class&lt;?&gt; vc);</span>
<span class="line-added"> 238 </span>
<span class="line-added"> 239     /**</span>
<span class="line-added"> 240      * Stores the given value into a given Java variable.</span>
<span class="line-added"> 241      *</span>
<span class="line-added"> 242      * Unless the reference {@code o} being stored is either null</span>
<span class="line-added"> 243      * or matches the field type, the results are undefined.</span>
<span class="line-added"> 244      *</span>
<span class="line-added"> 245      * @param o Java heap object in which the variable resides, if any, else</span>
<span class="line-added"> 246      *        null</span>
<span class="line-added"> 247      * @param offset indication of where the variable resides in a Java heap</span>
<span class="line-added"> 248      *        object, if any, else a memory address locating the variable</span>
<span class="line-added"> 249      *        statically</span>
<span class="line-added"> 250      * @param vc inline class</span>
<span class="line-added"> 251      * @param v the value to store into the indicated Java variable</span>
<span class="line-added"> 252      * @param &lt;V&gt; the type of a value</span>
<span class="line-added"> 253      * @throws RuntimeException No defined exceptions are thrown, not even</span>
<span class="line-added"> 254      *         {@link NullPointerException}</span>
<span class="line-added"> 255      */</span>
<span class="line-added"> 256     @HotSpotIntrinsicCandidate</span>
<span class="line-added"> 257     public native &lt;V&gt; void putValue(Object o, long offset, Class&lt;?&gt; vc, V v);</span>
<span class="line-added"> 258 </span>
<span class="line-added"> 259     /**</span>
<span class="line-added"> 260      * Fetches a reference value of type {@code vc} from a given Java variable.</span>
<span class="line-added"> 261      * This method can return a reference to a value or a null reference</span>
<span class="line-added"> 262      * for a nullable-projection of an inline type.</span>
<span class="line-added"> 263      *</span>
<span class="line-added"> 264      * @param vc inline class</span>
<span class="line-added"> 265      */</span>
<span class="line-added"> 266     public Object getReference(Object o, long offset, Class&lt;?&gt; vc) {</span>
<span class="line-added"> 267         Object ref = getReference(o, offset);</span>
<span class="line-added"> 268         if (ref == null &amp;&amp; vc.isInlineClass()) {</span>
<span class="line-added"> 269             // If the type of the returned reference is a regular inline type</span>
<span class="line-added"> 270             // return an uninitialized default value if null</span>
<span class="line-added"> 271             ref = uninitializedDefaultValue(vc);</span>
<span class="line-added"> 272         }</span>
<span class="line-added"> 273         return ref;</span>
<span class="line-added"> 274     }</span>
<span class="line-added"> 275 </span>
<span class="line-added"> 276     public Object getReferenceVolatile(Object o, long offset, Class&lt;?&gt; vc) {</span>
<span class="line-added"> 277         Object ref = getReferenceVolatile(o, offset);</span>
<span class="line-added"> 278         if (ref == null &amp;&amp; vc.isInlineClass()) {</span>
<span class="line-added"> 279             // If the type of the returned reference is a regular inline type</span>
<span class="line-added"> 280             // return an uninitialized default value if null</span>
<span class="line-added"> 281             ref = uninitializedDefaultValue(vc);</span>
<span class="line-added"> 282         }</span>
<span class="line-added"> 283         return ref;</span>
<span class="line-added"> 284     }</span>
<span class="line-added"> 285 </span>
<span class="line-added"> 286     /**</span>
<span class="line-added"> 287      * Returns an uninitialized default value of the given inline class.</span>
<span class="line-added"> 288      */</span>
<span class="line-added"> 289     public native &lt;V&gt; V uninitializedDefaultValue(Class&lt;?&gt; vc);</span>
<span class="line-added"> 290 </span>
<span class="line-added"> 291     /**</span>
<span class="line-added"> 292      * Returns an object instance with a private buffered value whose layout</span>
<span class="line-added"> 293      * and contents is exactly the given value instance.  The return object</span>
<span class="line-added"> 294      * is in the larval state that can be updated using the unsafe put operation.</span>
<span class="line-added"> 295      *</span>
<span class="line-added"> 296      * @param value a value instance</span>
<span class="line-added"> 297      * @param &lt;V&gt; the type of the given value instance</span>
<span class="line-added"> 298      */</span>
<span class="line-added"> 299     @HotSpotIntrinsicCandidate</span>
<span class="line-added"> 300     public native &lt;V&gt; V makePrivateBuffer(V value);</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302     /**</span>
<span class="line-added"> 303      * Exits the larval state and returns a value instance.</span>
<span class="line-added"> 304      *</span>
<span class="line-added"> 305      * @param value a value instance</span>
<span class="line-added"> 306      * @param &lt;V&gt; the type of the given value instance</span>
<span class="line-added"> 307      */</span>
<span class="line-added"> 308     @HotSpotIntrinsicCandidate</span>
<span class="line-added"> 309     public native &lt;V&gt; V finishPrivateBuffer(V value);</span>
<span class="line-added"> 310 </span>
<span class="line-added"> 311     /**</span>
<span class="line-added"> 312      * Returns the header size of the given inline class</span>
<span class="line-added"> 313      *</span>
<span class="line-added"> 314      * @param vc inline class</span>
<span class="line-added"> 315      * @param &lt;V&gt; value clas</span>
<span class="line-added"> 316      * @return the header size of the inline class</span>
<span class="line-added"> 317      */</span>
<span class="line-added"> 318     public native &lt;V&gt; long valueHeaderSize(Class&lt;V&gt; vc);</span>
<span class="line-added"> 319 </span>
 320     /** @see #getInt(Object, long) */
 321     @HotSpotIntrinsicCandidate
 322     public native boolean getBoolean(Object o, long offset);
 323 
 324     /** @see #putInt(Object, long, int) */
 325     @HotSpotIntrinsicCandidate
 326     public native void    putBoolean(Object o, long offset, boolean x);
 327 
 328     /** @see #getInt(Object, long) */
 329     @HotSpotIntrinsicCandidate
 330     public native byte    getByte(Object o, long offset);
 331 
 332     /** @see #putInt(Object, long, int) */
 333     @HotSpotIntrinsicCandidate
 334     public native void    putByte(Object o, long offset, byte x);
 335 
 336     /** @see #getInt(Object, long) */
 337     @HotSpotIntrinsicCandidate
 338     public native short   getShort(Object o, long offset);
 339 
</pre>
<hr />
<pre>
1332 
1333     /**
1334      * Reports the scale factor for addressing elements in the storage
1335      * allocation of a given array class.  However, arrays of &quot;narrow&quot; types
1336      * will generally not work properly with accessors like {@link
1337      * #getByte(Object, long)}, so the scale factor for such classes is reported
1338      * as zero.
1339      *
1340      * @see #arrayBaseOffset
1341      * @see #getInt(Object, long)
1342      * @see #putInt(Object, long, int)
1343      */
1344     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
1345         if (arrayClass == null) {
1346             throw new NullPointerException();
1347         }
1348 
1349         return arrayIndexScale0(arrayClass);
1350     }
1351 
<span class="line-added">1352     /**</span>
<span class="line-added">1353      * Return the size of the object in the heap.</span>
<span class="line-added">1354      * @param o an object</span>
<span class="line-added">1355      * @return the objects&#39;s size</span>
<span class="line-added">1356      * @since Valhalla</span>
<span class="line-added">1357      */</span>
<span class="line-added">1358     public long getObjectSize(Object o) {</span>
<span class="line-added">1359         if (o == null)</span>
<span class="line-added">1360             throw new NullPointerException();</span>
<span class="line-added">1361         return getObjectSize0(o);</span>
<span class="line-added">1362     }</span>
1363 
1364     /** The value of {@code arrayIndexScale(boolean[].class)} */
1365     public static final int ARRAY_BOOLEAN_INDEX_SCALE
1366             = theUnsafe.arrayIndexScale(boolean[].class);
1367 
1368     /** The value of {@code arrayIndexScale(byte[].class)} */
1369     public static final int ARRAY_BYTE_INDEX_SCALE
1370             = theUnsafe.arrayIndexScale(byte[].class);
1371 
1372     /** The value of {@code arrayIndexScale(short[].class)} */
1373     public static final int ARRAY_SHORT_INDEX_SCALE
1374             = theUnsafe.arrayIndexScale(short[].class);
1375 
1376     /** The value of {@code arrayIndexScale(char[].class)} */
1377     public static final int ARRAY_CHAR_INDEX_SCALE
1378             = theUnsafe.arrayIndexScale(char[].class);
1379 
1380     /** The value of {@code arrayIndexScale(int[].class)} */
1381     public static final int ARRAY_INT_INDEX_SCALE
1382             = theUnsafe.arrayIndexScale(int[].class);
</pre>
<hr />
<pre>
1548        return null;
1549     }
1550 
1551     /** Throws the exception without telling the verifier. */
1552     public native void throwException(Throwable ee);
1553 
1554     /**
1555      * Atomically updates Java variable to {@code x} if it is currently
1556      * holding {@code expected}.
1557      *
1558      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1559      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1560      *
1561      * @return {@code true} if successful
1562      */
1563     @HotSpotIntrinsicCandidate
1564     public final native boolean compareAndSetReference(Object o, long offset,
1565                                                        Object expected,
1566                                                        Object x);
1567 
<span class="line-added">1568     private final boolean isInlineType(Object o) {</span>
<span class="line-added">1569         return o != null &amp;&amp; o.getClass().isInlineClass();</span>
<span class="line-added">1570     }</span>
<span class="line-added">1571 </span>
<span class="line-added">1572     /*</span>
<span class="line-added">1573      * For inline type, CAS should do substitutability test as opposed</span>
<span class="line-added">1574      * to two pointers comparison.</span>
<span class="line-added">1575      *</span>
<span class="line-added">1576      * Perhaps we can keep the xxxObject methods for compatibility and</span>
<span class="line-added">1577      * change the JDK 13 xxxReference method signature freely.</span>
<span class="line-added">1578      */</span>
<span class="line-added">1579     public final &lt;V&gt; boolean compareAndSetReference(Object o, long offset,</span>
<span class="line-added">1580                                                     Class&lt;?&gt; valueType,</span>
<span class="line-added">1581                                                     V expected,</span>
<span class="line-added">1582                                                     V x) {</span>
<span class="line-added">1583         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="line-added">1584             synchronized (valueLock) {</span>
<span class="line-added">1585                 Object witness = getReference(o, offset);</span>
<span class="line-added">1586                 if (witness == expected) {</span>
<span class="line-added">1587                     putReference(o, offset, x);</span>
<span class="line-added">1588                     return true;</span>
<span class="line-added">1589                 } else {</span>
<span class="line-added">1590                     return false;</span>
<span class="line-added">1591                 }</span>
<span class="line-added">1592             }</span>
<span class="line-added">1593         } else {</span>
<span class="line-added">1594             return compareAndSetReference(o, offset, expected, x);</span>
<span class="line-added">1595         }</span>
<span class="line-added">1596     }</span>
<span class="line-added">1597 </span>
<span class="line-added">1598     @ForceInline</span>
<span class="line-added">1599     public final &lt;V&gt; boolean compareAndSetValue(Object o, long offset,</span>
<span class="line-added">1600                                                 Class&lt;?&gt; valueType,</span>
<span class="line-added">1601                                                 V expected,</span>
<span class="line-added">1602                                                 V x) {</span>
<span class="line-added">1603         synchronized (valueLock) {</span>
<span class="line-added">1604             Object witness = getValue(o, offset, valueType);</span>
<span class="line-added">1605             if (witness == expected) {</span>
<span class="line-added">1606                 putValue(o, offset, valueType, x);</span>
<span class="line-added">1607                 return true;</span>
<span class="line-added">1608             }</span>
<span class="line-added">1609             else {</span>
<span class="line-added">1610                 return false;</span>
<span class="line-added">1611             }</span>
<span class="line-added">1612         }</span>
<span class="line-added">1613     }</span>
<span class="line-added">1614 </span>
1615     @HotSpotIntrinsicCandidate
1616     public final native Object compareAndExchangeReference(Object o, long offset,
1617                                                            Object expected,
1618                                                            Object x);
1619 
<span class="line-added">1620     public final &lt;V&gt; Object compareAndExchangeReference(Object o, long offset,</span>
<span class="line-added">1621                                                         Class&lt;?&gt; valueType,</span>
<span class="line-added">1622                                                         V expected,</span>
<span class="line-added">1623                                                         V x) {</span>
<span class="line-added">1624         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="line-added">1625             synchronized (valueLock) {</span>
<span class="line-added">1626                 Object witness = getReference(o, offset);</span>
<span class="line-added">1627                 if (witness == expected) {</span>
<span class="line-added">1628                     putReference(o, offset, x);</span>
<span class="line-added">1629                 }</span>
<span class="line-added">1630                 return witness;</span>
<span class="line-added">1631             }</span>
<span class="line-added">1632         } else {</span>
<span class="line-added">1633             return compareAndExchangeReference(o, offset, expected, x);</span>
<span class="line-added">1634         }</span>
<span class="line-added">1635     }</span>
<span class="line-added">1636 </span>
<span class="line-added">1637     @ForceInline</span>
<span class="line-added">1638     public final &lt;V&gt; Object compareAndExchangeValue(Object o, long offset,</span>
<span class="line-added">1639                                                     Class&lt;?&gt; valueType,</span>
<span class="line-added">1640                                                     V expected,</span>
<span class="line-added">1641                                                     V x) {</span>
<span class="line-added">1642         synchronized (valueLock) {</span>
<span class="line-added">1643             Object witness = getValue(o, offset, valueType);</span>
<span class="line-added">1644             if (witness == expected) {</span>
<span class="line-added">1645                 putValue(o, offset, valueType, x);</span>
<span class="line-added">1646             }</span>
<span class="line-added">1647             return witness;</span>
<span class="line-added">1648         }</span>
<span class="line-added">1649     }</span>
<span class="line-added">1650 </span>
1651     @HotSpotIntrinsicCandidate
1652     public final Object compareAndExchangeReferenceAcquire(Object o, long offset,
1653                                                            Object expected,
1654                                                            Object x) {
1655         return compareAndExchangeReference(o, offset, expected, x);
1656     }
1657 
<span class="line-added">1658     public final &lt;V&gt; Object compareAndExchangeReferenceAcquire(Object o, long offset,</span>
<span class="line-added">1659                                                                Class&lt;?&gt; valueType,</span>
<span class="line-added">1660                                                                V expected,</span>
<span class="line-added">1661                                                                V x) {</span>
<span class="line-added">1662         return compareAndExchangeReference(o, offset, valueType, expected, x);</span>
<span class="line-added">1663     }</span>
<span class="line-added">1664 </span>
<span class="line-added">1665     @ForceInline</span>
<span class="line-added">1666     public final &lt;V&gt; Object compareAndExchangeValueAcquire(Object o, long offset,</span>
<span class="line-added">1667                                                            Class&lt;?&gt; valueType,</span>
<span class="line-added">1668                                                            V expected,</span>
<span class="line-added">1669                                                            V x) {</span>
<span class="line-added">1670         return compareAndExchangeValue(o, offset, valueType, expected, x);</span>
<span class="line-added">1671     }</span>
<span class="line-added">1672 </span>
1673     @HotSpotIntrinsicCandidate
1674     public final Object compareAndExchangeReferenceRelease(Object o, long offset,
1675                                                            Object expected,
1676                                                            Object x) {
1677         return compareAndExchangeReference(o, offset, expected, x);
1678     }
1679 
<span class="line-added">1680     public final &lt;V&gt; Object compareAndExchangeReferenceRelease(Object o, long offset,</span>
<span class="line-added">1681                                                                Class&lt;?&gt; valueType,</span>
<span class="line-added">1682                                                                V expected,</span>
<span class="line-added">1683                                                                V x) {</span>
<span class="line-added">1684         return compareAndExchangeReference(o, offset, valueType, expected, x);</span>
<span class="line-added">1685     }</span>
<span class="line-added">1686 </span>
<span class="line-added">1687     @ForceInline</span>
<span class="line-added">1688     public final &lt;V&gt; Object compareAndExchangeValueRelease(Object o, long offset,</span>
<span class="line-added">1689                                                            Class&lt;?&gt; valueType,</span>
<span class="line-added">1690                                                            V expected,</span>
<span class="line-added">1691                                                            V x) {</span>
<span class="line-added">1692         return compareAndExchangeValue(o, offset, valueType, expected, x);</span>
<span class="line-added">1693     }</span>
<span class="line-added">1694 </span>
1695     @HotSpotIntrinsicCandidate
1696     public final boolean weakCompareAndSetReferencePlain(Object o, long offset,
1697                                                          Object expected,
1698                                                          Object x) {
1699         return compareAndSetReference(o, offset, expected, x);
1700     }
1701 
<span class="line-added">1702     public final &lt;V&gt; boolean weakCompareAndSetReferencePlain(Object o, long offset,</span>
<span class="line-added">1703                                                              Class&lt;?&gt; valueType,</span>
<span class="line-added">1704                                                              V expected,</span>
<span class="line-added">1705                                                              V x) {</span>
<span class="line-added">1706         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="line-added">1707             return compareAndSetReference(o, offset, valueType, expected, x);</span>
<span class="line-added">1708         } else {</span>
<span class="line-added">1709             return weakCompareAndSetReferencePlain(o, offset, expected, x);</span>
<span class="line-added">1710         }</span>
<span class="line-added">1711     }</span>
<span class="line-added">1712 </span>
<span class="line-added">1713     @ForceInline</span>
<span class="line-added">1714     public final &lt;V&gt; boolean weakCompareAndSetValuePlain(Object o, long offset,</span>
<span class="line-added">1715                                                          Class&lt;?&gt; valueType,</span>
<span class="line-added">1716                                                          V expected,</span>
<span class="line-added">1717                                                          V x) {</span>
<span class="line-added">1718         return compareAndSetValue(o, offset, valueType, expected, x);</span>
<span class="line-added">1719     }</span>
<span class="line-added">1720 </span>
1721     @HotSpotIntrinsicCandidate
1722     public final boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
1723                                                            Object expected,
1724                                                            Object x) {
1725         return compareAndSetReference(o, offset, expected, x);
1726     }
1727 
<span class="line-added">1728     public final &lt;V&gt; boolean weakCompareAndSetReferenceAcquire(Object o, long offset,</span>
<span class="line-added">1729                                                                Class&lt;?&gt; valueType,</span>
<span class="line-added">1730                                                                V expected,</span>
<span class="line-added">1731                                                                V x) {</span>
<span class="line-added">1732         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="line-added">1733             return compareAndSetReference(o, offset, valueType, expected, x);</span>
<span class="line-added">1734         } else {</span>
<span class="line-added">1735             return weakCompareAndSetReferencePlain(o, offset, expected, x);</span>
<span class="line-added">1736         }</span>
<span class="line-added">1737     }</span>
<span class="line-added">1738 </span>
<span class="line-added">1739     @ForceInline</span>
<span class="line-added">1740     public final &lt;V&gt; boolean weakCompareAndSetValueAcquire(Object o, long offset,</span>
<span class="line-added">1741                                                            Class&lt;?&gt; valueType,</span>
<span class="line-added">1742                                                            V expected,</span>
<span class="line-added">1743                                                            V x) {</span>
<span class="line-added">1744         return compareAndSetValue(o, offset, valueType, expected, x);</span>
<span class="line-added">1745     }</span>
<span class="line-added">1746 </span>
1747     @HotSpotIntrinsicCandidate
1748     public final boolean weakCompareAndSetReferenceRelease(Object o, long offset,
1749                                                            Object expected,
1750                                                            Object x) {
1751         return compareAndSetReference(o, offset, expected, x);
1752     }
1753 
<span class="line-added">1754     public final &lt;V&gt; boolean weakCompareAndSetReferenceRelease(Object o, long offset,</span>
<span class="line-added">1755                                                                Class&lt;?&gt; valueType,</span>
<span class="line-added">1756                                                                V expected,</span>
<span class="line-added">1757                                                                V x) {</span>
<span class="line-added">1758         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="line-added">1759             return compareAndSetReference(o, offset, valueType, expected, x);</span>
<span class="line-added">1760         } else {</span>
<span class="line-added">1761             return weakCompareAndSetReferencePlain(o, offset, expected, x);</span>
<span class="line-added">1762         }</span>
<span class="line-added">1763     }</span>
<span class="line-added">1764 </span>
<span class="line-added">1765     @ForceInline</span>
<span class="line-added">1766     public final &lt;V&gt; boolean weakCompareAndSetValueRelease(Object o, long offset,</span>
<span class="line-added">1767                                                            Class&lt;?&gt; valueType,</span>
<span class="line-added">1768                                                            V expected,</span>
<span class="line-added">1769                                                            V x) {</span>
<span class="line-added">1770         return compareAndSetValue(o, offset, valueType, expected, x);</span>
<span class="line-added">1771     }</span>
<span class="line-added">1772 </span>
1773     @HotSpotIntrinsicCandidate
1774     public final boolean weakCompareAndSetReference(Object o, long offset,
1775                                                     Object expected,
1776                                                     Object x) {
1777         return compareAndSetReference(o, offset, expected, x);
1778     }
1779 
<span class="line-added">1780     public final &lt;V&gt; boolean weakCompareAndSetReference(Object o, long offset,</span>
<span class="line-added">1781                                                         Class&lt;?&gt; valueType,</span>
<span class="line-added">1782                                                         V expected,</span>
<span class="line-added">1783                                                         V x) {</span>
<span class="line-added">1784         if (valueType.isInlineClass() || isInlineType(expected)) {</span>
<span class="line-added">1785             return compareAndSetReference(o, offset, valueType, expected, x);</span>
<span class="line-added">1786         } else {</span>
<span class="line-added">1787             return weakCompareAndSetReferencePlain(o, offset, expected, x);</span>
<span class="line-added">1788         }</span>
<span class="line-added">1789     }</span>
<span class="line-added">1790 </span>
<span class="line-added">1791     @ForceInline</span>
<span class="line-added">1792     public final &lt;V&gt; boolean weakCompareAndSetValue(Object o, long offset,</span>
<span class="line-added">1793                                                     Class&lt;?&gt; valueType,</span>
<span class="line-added">1794                                                     V expected,</span>
<span class="line-added">1795                                                     V x) {</span>
<span class="line-added">1796         return compareAndSetValue(o, offset, valueType, expected, x);</span>
<span class="line-added">1797     }</span>
<span class="line-added">1798 </span>
1799     /**
1800      * Atomically updates Java variable to {@code x} if it is currently
1801      * holding {@code expected}.
1802      *
1803      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1804      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1805      *
1806      * @return {@code true} if successful
1807      */
1808     @HotSpotIntrinsicCandidate
1809     public final native boolean compareAndSetInt(Object o, long offset,
1810                                                  int expected,
1811                                                  int x);
1812 
1813     @HotSpotIntrinsicCandidate
1814     public final native int compareAndExchangeInt(Object o, long offset,
1815                                                   int expected,
1816                                                   int x);
1817 
1818     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
2394     public final boolean weakCompareAndSetLongRelease(Object o, long offset,
2395                                                       long expected,
2396                                                       long x) {
2397         return compareAndSetLong(o, offset, expected, x);
2398     }
2399 
2400     @HotSpotIntrinsicCandidate
2401     public final boolean weakCompareAndSetLong(Object o, long offset,
2402                                                long expected,
2403                                                long x) {
2404         return compareAndSetLong(o, offset, expected, x);
2405     }
2406 
2407     /**
2408      * Fetches a reference value from a given Java variable, with volatile
2409      * load semantics. Otherwise identical to {@link #getReference(Object, long)}
2410      */
2411     @HotSpotIntrinsicCandidate
2412     public native Object getReferenceVolatile(Object o, long offset);
2413 
<span class="line-added">2414     /**</span>
<span class="line-added">2415      * Global lock for atomic and volatile strength access to any value of</span>
<span class="line-added">2416      * an inline type.  This is a temporary workaround until better localized</span>
<span class="line-added">2417      * atomic access mechanisms are supported for inline types.</span>
<span class="line-added">2418      */</span>
<span class="line-added">2419     private static final Object valueLock = new Object();</span>
<span class="line-added">2420 </span>
<span class="line-added">2421     public final &lt;V&gt; Object getValueVolatile(Object base, long offset, Class&lt;?&gt; valueType) {</span>
<span class="line-added">2422         synchronized (valueLock) {</span>
<span class="line-added">2423             return getValue(base, offset, valueType);</span>
<span class="line-added">2424         }</span>
<span class="line-added">2425     }</span>
<span class="line-added">2426 </span>
2427     /**
2428      * Stores a reference value into a given Java variable, with
2429      * volatile store semantics. Otherwise identical to {@link #putReference(Object, long, Object)}
2430      */
2431     @HotSpotIntrinsicCandidate
2432     public native void putReferenceVolatile(Object o, long offset, Object x);
2433 
<span class="line-added">2434     public final &lt;V&gt; void putValueVolatile(Object o, long offset, Class&lt;?&gt; valueType, V x) {</span>
<span class="line-added">2435         synchronized (valueLock) {</span>
<span class="line-added">2436             putValue(o, offset, valueType, x);</span>
<span class="line-added">2437         }</span>
<span class="line-added">2438     }</span>
<span class="line-added">2439 </span>
2440     /** Volatile version of {@link #getInt(Object, long)}  */
2441     @HotSpotIntrinsicCandidate
2442     public native int     getIntVolatile(Object o, long offset);
2443 
2444     /** Volatile version of {@link #putInt(Object, long, int)}  */
2445     @HotSpotIntrinsicCandidate
2446     public native void    putIntVolatile(Object o, long offset, int x);
2447 
2448     /** Volatile version of {@link #getBoolean(Object, long)}  */
2449     @HotSpotIntrinsicCandidate
2450     public native boolean getBooleanVolatile(Object o, long offset);
2451 
2452     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
2453     @HotSpotIntrinsicCandidate
2454     public native void    putBooleanVolatile(Object o, long offset, boolean x);
2455 
2456     /** Volatile version of {@link #getByte(Object, long)}  */
2457     @HotSpotIntrinsicCandidate
2458     public native byte    getByteVolatile(Object o, long offset);
2459 
</pre>
<hr />
<pre>
2492     /** Volatile version of {@link #putFloat(Object, long, float)}  */
2493     @HotSpotIntrinsicCandidate
2494     public native void    putFloatVolatile(Object o, long offset, float x);
2495 
2496     /** Volatile version of {@link #getDouble(Object, long)}  */
2497     @HotSpotIntrinsicCandidate
2498     public native double  getDoubleVolatile(Object o, long offset);
2499 
2500     /** Volatile version of {@link #putDouble(Object, long, double)}  */
2501     @HotSpotIntrinsicCandidate
2502     public native void    putDoubleVolatile(Object o, long offset, double x);
2503 
2504 
2505 
2506     /** Acquire version of {@link #getReferenceVolatile(Object, long)} */
2507     @HotSpotIntrinsicCandidate
2508     public final Object getReferenceAcquire(Object o, long offset) {
2509         return getReferenceVolatile(o, offset);
2510     }
2511 
<span class="line-added">2512     public final &lt;V&gt; Object getValueAcquire(Object base, long offset, Class&lt;?&gt; valueType) {</span>
<span class="line-added">2513         return getValueVolatile(base, offset, valueType);</span>
<span class="line-added">2514     }</span>
<span class="line-added">2515 </span>
2516     /** Acquire version of {@link #getBooleanVolatile(Object, long)} */
2517     @HotSpotIntrinsicCandidate
2518     public final boolean getBooleanAcquire(Object o, long offset) {
2519         return getBooleanVolatile(o, offset);
2520     }
2521 
2522     /** Acquire version of {@link #getByteVolatile(Object, long)} */
2523     @HotSpotIntrinsicCandidate
2524     public final byte getByteAcquire(Object o, long offset) {
2525         return getByteVolatile(o, offset);
2526     }
2527 
2528     /** Acquire version of {@link #getShortVolatile(Object, long)} */
2529     @HotSpotIntrinsicCandidate
2530     public final short getShortAcquire(Object o, long offset) {
2531         return getShortVolatile(o, offset);
2532     }
2533 
2534     /** Acquire version of {@link #getCharVolatile(Object, long)} */
2535     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
2560     public final double getDoubleAcquire(Object o, long offset) {
2561         return getDoubleVolatile(o, offset);
2562     }
2563 
2564     /*
2565      * Versions of {@link #putReferenceVolatile(Object, long, Object)}
2566      * that do not guarantee immediate visibility of the store to
2567      * other threads. This method is generally only useful if the
2568      * underlying field is a Java volatile (or if an array cell, one
2569      * that is otherwise only accessed using volatile accesses).
2570      *
2571      * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
2572      */
2573 
2574     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2575     @HotSpotIntrinsicCandidate
2576     public final void putReferenceRelease(Object o, long offset, Object x) {
2577         putReferenceVolatile(o, offset, x);
2578     }
2579 
<span class="line-added">2580     public final &lt;V&gt; void putValueRelease(Object o, long offset, Class&lt;?&gt; valueType, V x) {</span>
<span class="line-added">2581         putValueVolatile(o, offset, valueType, x);</span>
<span class="line-added">2582     }</span>
<span class="line-added">2583 </span>
2584     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2585     @HotSpotIntrinsicCandidate
2586     public final void putBooleanRelease(Object o, long offset, boolean x) {
2587         putBooleanVolatile(o, offset, x);
2588     }
2589 
2590     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2591     @HotSpotIntrinsicCandidate
2592     public final void putByteRelease(Object o, long offset, byte x) {
2593         putByteVolatile(o, offset, x);
2594     }
2595 
2596     /** Release version of {@link #putShortVolatile(Object, long, short)} */
2597     @HotSpotIntrinsicCandidate
2598     public final void putShortRelease(Object o, long offset, short x) {
2599         putShortVolatile(o, offset, x);
2600     }
2601 
2602     /** Release version of {@link #putCharVolatile(Object, long, char)} */
2603     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
2620     /** Release version of {@link #putLongVolatile(Object, long, long)} */
2621     @HotSpotIntrinsicCandidate
2622     public final void putLongRelease(Object o, long offset, long x) {
2623         putLongVolatile(o, offset, x);
2624     }
2625 
2626     /** Release version of {@link #putDoubleVolatile(Object, long, double)} */
2627     @HotSpotIntrinsicCandidate
2628     public final void putDoubleRelease(Object o, long offset, double x) {
2629         putDoubleVolatile(o, offset, x);
2630     }
2631 
2632     // ------------------------------ Opaque --------------------------------------
2633 
2634     /** Opaque version of {@link #getReferenceVolatile(Object, long)} */
2635     @HotSpotIntrinsicCandidate
2636     public final Object getReferenceOpaque(Object o, long offset) {
2637         return getReferenceVolatile(o, offset);
2638     }
2639 
<span class="line-added">2640     public final &lt;V&gt; Object getValueOpaque(Object base, long offset, Class&lt;?&gt; valueType) {</span>
<span class="line-added">2641         return getValueVolatile(base, offset, valueType);</span>
<span class="line-added">2642     }</span>
<span class="line-added">2643 </span>
2644     /** Opaque version of {@link #getBooleanVolatile(Object, long)} */
2645     @HotSpotIntrinsicCandidate
2646     public final boolean getBooleanOpaque(Object o, long offset) {
2647         return getBooleanVolatile(o, offset);
2648     }
2649 
2650     /** Opaque version of {@link #getByteVolatile(Object, long)} */
2651     @HotSpotIntrinsicCandidate
2652     public final byte getByteOpaque(Object o, long offset) {
2653         return getByteVolatile(o, offset);
2654     }
2655 
2656     /** Opaque version of {@link #getShortVolatile(Object, long)} */
2657     @HotSpotIntrinsicCandidate
2658     public final short getShortOpaque(Object o, long offset) {
2659         return getShortVolatile(o, offset);
2660     }
2661 
2662     /** Opaque version of {@link #getCharVolatile(Object, long)} */
2663     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
2678     }
2679 
2680     /** Opaque version of {@link #getLongVolatile(Object, long)} */
2681     @HotSpotIntrinsicCandidate
2682     public final long getLongOpaque(Object o, long offset) {
2683         return getLongVolatile(o, offset);
2684     }
2685 
2686     /** Opaque version of {@link #getDoubleVolatile(Object, long)} */
2687     @HotSpotIntrinsicCandidate
2688     public final double getDoubleOpaque(Object o, long offset) {
2689         return getDoubleVolatile(o, offset);
2690     }
2691 
2692     /** Opaque version of {@link #putReferenceVolatile(Object, long, Object)} */
2693     @HotSpotIntrinsicCandidate
2694     public final void putReferenceOpaque(Object o, long offset, Object x) {
2695         putReferenceVolatile(o, offset, x);
2696     }
2697 
<span class="line-added">2698     public final &lt;V&gt; void putValueOpaque(Object o, long offset, Class&lt;?&gt; valueType, V x) {</span>
<span class="line-added">2699         putValueVolatile(o, offset, valueType, x);</span>
<span class="line-added">2700     }</span>
<span class="line-added">2701 </span>
2702     /** Opaque version of {@link #putBooleanVolatile(Object, long, boolean)} */
2703     @HotSpotIntrinsicCandidate
2704     public final void putBooleanOpaque(Object o, long offset, boolean x) {
2705         putBooleanVolatile(o, offset, x);
2706     }
2707 
2708     /** Opaque version of {@link #putByteVolatile(Object, long, byte)} */
2709     @HotSpotIntrinsicCandidate
2710     public final void putByteOpaque(Object o, long offset, byte x) {
2711         putByteVolatile(o, offset, x);
2712     }
2713 
2714     /** Opaque version of {@link #putShortVolatile(Object, long, short)} */
2715     @HotSpotIntrinsicCandidate
2716     public final void putShortOpaque(Object o, long offset, short x) {
2717         putShortVolatile(o, offset, x);
2718     }
2719 
2720     /** Opaque version of {@link #putCharVolatile(Object, long, char)} */
2721     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
3116     /**
3117      * Atomically exchanges the given reference value with the current
3118      * reference value of a field or array element within the given
3119      * object {@code o} at the given {@code offset}.
3120      *
3121      * @param o object/array to update the field/element in
3122      * @param offset field/element offset
3123      * @param newValue new value
3124      * @return the previous value
3125      * @since 1.8
3126      */
3127     @HotSpotIntrinsicCandidate
3128     public final Object getAndSetReference(Object o, long offset, Object newValue) {
3129         Object v;
3130         do {
3131             v = getReferenceVolatile(o, offset);
3132         } while (!weakCompareAndSetReference(o, offset, v, newValue));
3133         return v;
3134     }
3135 
<span class="line-added">3136     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">3137     public final &lt;V&gt; Object getAndSetValue(Object o, long offset, Class&lt;?&gt; valueType, V newValue) {</span>
<span class="line-added">3138         synchronized (valueLock) {</span>
<span class="line-added">3139             Object oldValue = getValue(o, offset, valueType);</span>
<span class="line-added">3140             putValue(o, offset, valueType, newValue);</span>
<span class="line-added">3141             return oldValue;</span>
<span class="line-added">3142         }</span>
<span class="line-added">3143     }</span>
<span class="line-added">3144 </span>
3145     @ForceInline
3146     public final Object getAndSetReferenceRelease(Object o, long offset, Object newValue) {
3147         Object v;
3148         do {
3149             v = getReference(o, offset);
3150         } while (!weakCompareAndSetReferenceRelease(o, offset, v, newValue));
3151         return v;
3152     }
3153 
<span class="line-added">3154     @ForceInline</span>
<span class="line-added">3155     public final &lt;V&gt; Object getAndSetValueRelease(Object o, long offset, Class&lt;?&gt; valueType, V newValue) {</span>
<span class="line-added">3156         return getAndSetValue(o, offset, valueType, newValue);</span>
<span class="line-added">3157     }</span>
<span class="line-added">3158 </span>
3159     @ForceInline
3160     public final Object getAndSetReferenceAcquire(Object o, long offset, Object newValue) {
3161         Object v;
3162         do {
3163             v = getReferenceAcquire(o, offset);
3164         } while (!weakCompareAndSetReferenceAcquire(o, offset, v, newValue));
3165         return v;
3166     }
3167 
<span class="line-added">3168     @ForceInline</span>
<span class="line-added">3169     public final &lt;V&gt; Object getAndSetValueAcquire(Object o, long offset, Class&lt;?&gt; valueType, V newValue) {</span>
<span class="line-added">3170         return getAndSetValue(o, offset, valueType, newValue);</span>
<span class="line-added">3171     }</span>
<span class="line-added">3172 </span>
3173     @HotSpotIntrinsicCandidate
3174     public final byte getAndSetByte(Object o, long offset, byte newValue) {
3175         byte v;
3176         do {
3177             v = getByteVolatile(o, offset);
3178         } while (!weakCompareAndSetByte(o, offset, v, newValue));
3179         return v;
3180     }
3181 
3182     @ForceInline
3183     public final byte getAndSetByteRelease(Object o, long offset, byte newValue) {
3184         byte v;
3185         do {
3186             v = getByte(o, offset);
3187         } while (!weakCompareAndSetByteRelease(o, offset, v, newValue));
3188         return v;
3189     }
3190 
3191     @ForceInline
3192     public final byte getAndSetByteAcquire(Object o, long offset, byte newValue) {
</pre>
<hr />
<pre>
4197     private static int convEndian(boolean big, int n)     { return big == BIG_ENDIAN ? n : Integer.reverseBytes(n)  ; }
4198     private static long convEndian(boolean big, long n)   { return big == BIG_ENDIAN ? n : Long.reverseBytes(n)     ; }
4199 
4200 
4201 
4202     private native long allocateMemory0(long bytes);
4203     private native long reallocateMemory0(long address, long bytes);
4204     private native void freeMemory0(long address);
4205     private native void setMemory0(Object o, long offset, long bytes, byte value);
4206     @HotSpotIntrinsicCandidate
4207     private native void copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
4208     private native void copySwapMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes, long elemSize);
4209     private native long objectFieldOffset0(Field f);
4210     private native long objectFieldOffset1(Class&lt;?&gt; c, String name);
4211     private native long staticFieldOffset0(Field f);
4212     private native Object staticFieldBase0(Field f);
4213     private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
4214     private native void ensureClassInitialized0(Class&lt;?&gt; c);
4215     private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
4216     private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);
<span class="line-added">4217     private native long getObjectSize0(Object o);</span>
4218     private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
4219     private native int getLoadAverage0(double[] loadavg, int nelems);
4220 
4221 
4222     /**
4223      * Invokes the given direct byte buffer&#39;s cleaner, if any.
4224      *
4225      * @param directBuffer a direct byte buffer
4226      * @throws NullPointerException     if {@code directBuffer} is null
4227      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
4228      *                                  or is a {@link java.nio.Buffer#slice slice}, or is a
4229      *                                  {@link java.nio.Buffer#duplicate duplicate}
4230      */
4231     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
4232         if (!directBuffer.isDirect())
4233             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
4234 
4235         DirectBuffer db = (DirectBuffer) directBuffer;
4236         if (db.attachment() != null)
4237             throw new IllegalArgumentException(&quot;duplicate or slice&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="../../../java/lang/reflect/ProxyGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../org/objectweb/asm/ClassReader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
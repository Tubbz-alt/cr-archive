<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_32.ad.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;interpreter/interpreter.hpp&quot;
  29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  30 #include &quot;interpreter/interp_masm.hpp&quot;
  31 #include &quot;interpreter/templateTable.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/methodData.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;

  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/safepointMechanism.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 
  44 #define __ Disassembler::hook&lt;InterpreterMacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
  45 
  46 // Global Register Names
  47 static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);
  48 static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);
  49 
  50 // Platform-dependent initialization
  51 void TemplateTable::pd_initialize() {
  52   // No x86 specific initialization
  53 }
  54 
  55 // Address Computation: local variables
</pre>
<hr />
<pre>
 137   case TemplateTable::less_equal   : return Assembler::greater;
 138   case TemplateTable::greater      : return Assembler::lessEqual;
 139   case TemplateTable::greater_equal: return Assembler::less;
 140   }
 141   ShouldNotReachHere();
 142   return Assembler::zero;
 143 }
 144 
 145 
 146 
 147 // Miscelaneous helper routines
 148 // Store an oop (or NULL) at the address described by obj.
 149 // If val == noreg this means store a NULL
 150 
 151 
 152 static void do_oop_store(InterpreterMacroAssembler* _masm,
 153                          Address dst,
 154                          Register val,
 155                          DecoratorSet decorators = 0) {
 156   assert(val == noreg || val == rax, &quot;parameter is just for looks&quot;);
<span class="line-modified"> 157   __ store_heap_oop(dst, val, rdx, rbx, decorators);</span>
 158 }
 159 
 160 static void do_oop_load(InterpreterMacroAssembler* _masm,
 161                         Address src,
 162                         Register dst,
 163                         DecoratorSet decorators = 0) {
 164   __ load_heap_oop(dst, src, rdx, rbx, decorators);
 165 }
 166 
 167 Address TemplateTable::at_bcp(int offset) {
 168   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 169   return Address(rbcp, offset);
 170 }
 171 
 172 
 173 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 174                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 175                                    int byte_no) {
 176   if (!RewriteBytecodes)  return;
 177   Label L_patch_done;
 178 
 179   switch (bc) {

 180   case Bytecodes::_fast_aputfield:
 181   case Bytecodes::_fast_bputfield:
 182   case Bytecodes::_fast_zputfield:
 183   case Bytecodes::_fast_cputfield:
 184   case Bytecodes::_fast_dputfield:
 185   case Bytecodes::_fast_fputfield:
 186   case Bytecodes::_fast_iputfield:
 187   case Bytecodes::_fast_lputfield:
 188   case Bytecodes::_fast_sputfield:
 189     {
 190       // We skip bytecode quickening for putfield instructions when
 191       // the put_code written to the constant pool cache is zero.
 192       // This is required so that every execution of this instruction
 193       // calls out to InterpreterRuntime::resolve_get_put to do
 194       // additional, required work.
 195       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 196       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 197       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 198       __ movl(bc_reg, bc);
 199       __ cmpl(temp_reg, (int) 0);
</pre>
<hr />
<pre>
 352   __ sarl(rax, 16);
 353 }
 354 
 355 void TemplateTable::ldc(bool wide) {
 356   transition(vtos, vtos);
 357   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 358   Label call_ldc, notFloat, notClass, notInt, Done;
 359 
 360   if (wide) {
 361     __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 362   } else {
 363     __ load_unsigned_byte(rbx, at_bcp(1));
 364   }
 365 
 366   __ get_cpool_and_tags(rcx, rax);
 367   const int base_offset = ConstantPool::header_size() * wordSize;
 368   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 369 
 370   // get type
 371   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));

 372 
 373   // unresolved class - get the resolved class
 374   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClass);
 375   __ jccb(Assembler::equal, call_ldc);
 376 
 377   // unresolved class in error state - call into runtime to throw the error
 378   // from the first resolution attempt
 379   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClassInError);
 380   __ jccb(Assembler::equal, call_ldc);
 381 
 382   // resolved class - need to call vm to get java mirror of the class
 383   __ cmpl(rdx, JVM_CONSTANT_Class);
 384   __ jcc(Assembler::notEqual, notClass);
 385 
 386   __ bind(call_ldc);
 387 
 388   __ movl(rarg, wide);
 389   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), rarg);
 390 
 391   __ push(atos);
</pre>
<hr />
<pre>
 802                     Address(rdx, rax,
 803                             Address::times_4,
 804                             arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
 805                     noreg, noreg);
 806 }
 807 
 808 void TemplateTable::daload() {
 809   transition(itos, dtos);
 810   // rax: index
 811   // rdx: array
 812   index_check(rdx, rax); // kills rbx
 813   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg /* dtos */,
 814                     Address(rdx, rax,
 815                             Address::times_8,
 816                             arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
 817                     noreg, noreg);
 818 }
 819 
 820 void TemplateTable::aaload() {
 821   transition(itos, atos);
<span class="line-modified"> 822   // rax: index</span>
<span class="line-modified"> 823   // rdx: array</span>
<span class="line-modified"> 824   index_check(rdx, rax); // kills rbx</span>
<span class="line-modified"> 825   do_oop_load(_masm,</span>
<span class="line-modified"> 826               Address(rdx, rax,</span>
<span class="line-modified"> 827                       UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="line-modified"> 828                       arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="line-modified"> 829               rax,</span>
<span class="line-modified"> 830               IS_ARRAY);</span>


















 831 }
 832 
 833 void TemplateTable::baload() {
 834   transition(itos, itos);
 835   // rax: index
 836   // rdx: array
 837   index_check(rdx, rax); // kills rbx
 838   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax,
 839                     Address(rdx, rax, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_BYTE)),
 840                     noreg, noreg);
 841 }
 842 
 843 void TemplateTable::caload() {
 844   transition(itos, itos);
 845   // rax: index
 846   // rdx: array
 847   index_check(rdx, rax); // kills rbx
 848   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,
 849                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),
 850                     noreg, noreg);
</pre>
<hr />
<pre>
1096   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY,
1097                      Address(rdx, rbx, Address::times_4,
1098                              arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
1099                      noreg /* ftos */, noreg, noreg);
1100 }
1101 
1102 void TemplateTable::dastore() {
1103   transition(dtos, vtos);
1104   __ pop_i(rbx);
1105   // value is in UseSSE &gt;= 2 ? xmm0 : ST(0)
1106   // rbx:  index
1107   // rdx:  array
1108   index_check(rdx, rbx); // prefer index in rbx
1109   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY,
1110                      Address(rdx, rbx, Address::times_8,
1111                              arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
1112                      noreg /* dtos */, noreg, noreg);
1113 }
1114 
1115 void TemplateTable::aastore() {
<span class="line-modified">1116   Label is_null, ok_is_subtype, done;</span>
1117   transition(vtos, vtos);
1118   // stack: ..., array, index, value
1119   __ movptr(rax, at_tos());    // value
1120   __ movl(rcx, at_tos_p1()); // index
1121   __ movptr(rdx, at_tos_p2()); // array
1122 
1123   Address element_address(rdx, rcx,
1124                           UseCompressedOops? Address::times_4 : Address::times_ptr,
1125                           arrayOopDesc::base_offset_in_bytes(T_OBJECT));
1126 
1127   index_check_without_pop(rdx, rcx);     // kills rbx




1128   __ testptr(rax, rax);
1129   __ jcc(Assembler::zero, is_null);
1130 






1131   // Move subklass into rbx
1132   __ load_klass(rbx, rax);
<span class="line-modified">1133   // Move superklass into rax</span>
<span class="line-modified">1134   __ load_klass(rax, rdx);</span>
<span class="line-removed">1135   __ movptr(rax, Address(rax,</span>
1136                          ObjArrayKlass::element_klass_offset()));
1137 
1138   // Generate subtype check.  Blows rcx, rdi
1139   // Superklass in rax.  Subklass in rbx.
<span class="line-modified">1140   __ gen_subtype_check(rbx, ok_is_subtype);</span>

1141 
1142   // Come here on failure
1143   // object is at TOS
1144   __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
1145 
1146   // Come here on success
1147   __ bind(ok_is_subtype);
1148 
1149   // Get the value we will store
1150   __ movptr(rax, at_tos());
1151   __ movl(rcx, at_tos_p1()); // index
1152   // Now store using the appropriate barrier
1153   do_oop_store(_masm, element_address, rax, IS_ARRAY);
1154   __ jmp(done);
1155 
1156   // Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]
1157   __ bind(is_null);
<span class="line-modified">1158   __ profile_null_seen(rbx);</span>

1159 









1160   // Store a NULL
1161   do_oop_store(_masm, element_address, noreg, IS_ARRAY);







1162 



























1163   // Pop stack arguments
1164   __ bind(done);
1165   __ addptr(rsp, 3 * Interpreter::stackElementSize);
1166 }
1167 
1168 void TemplateTable::bastore() {
1169   transition(itos, vtos);
1170   __ pop_i(rbx);
1171   // rax: value
1172   // rbx: index
1173   // rdx: array
1174   index_check(rdx, rbx); // prefer index in rbx
1175   // Need to check whether array is boolean or byte
1176   // since both types share the bastore bytecode.
1177   __ load_klass(rcx, rdx);
1178   __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
1179   int diffbit = Klass::layout_helper_boolean_diffbit();
1180   __ testl(rcx, diffbit);
1181   Label L_skip;
1182   __ jccb(Assembler::zero, L_skip);
</pre>
<hr />
<pre>
2388   __ jcc(j_not(cc), not_taken);
2389   branch(false, false);
2390   __ bind(not_taken);
2391   __ profile_not_taken_branch(rax);
2392 }
2393 
2394 void TemplateTable::if_nullcmp(Condition cc) {
2395   transition(atos, vtos);
2396   // assume branch is more often taken than not (loops use backward branches)
2397   Label not_taken;
2398   __ testptr(rax, rax);
2399   __ jcc(j_not(cc), not_taken);
2400   branch(false, false);
2401   __ bind(not_taken);
2402   __ profile_not_taken_branch(rax);
2403 }
2404 
2405 void TemplateTable::if_acmp(Condition cc) {
2406   transition(atos, vtos);
2407   // assume branch is more often taken than not (loops use backward branches)
<span class="line-modified">2408   Label not_taken;</span>
2409   __ pop_ptr(rdx);




































2410   __ cmpoop(rdx, rax);
2411   __ jcc(j_not(cc), not_taken);

2412   branch(false, false);
2413   __ bind(not_taken);
2414   __ profile_not_taken_branch(rax);
2415 }
2416 









2417 void TemplateTable::ret() {
2418   transition(vtos, vtos);
2419   locals_index(rbx);
2420   LP64_ONLY(__ movslq(rbx, iaddress(rbx))); // get return bci, compute return bcp
2421   NOT_LP64(__ movptr(rbx, iaddress(rbx)));
2422   __ profile_ret(rbx, rcx);
2423   __ get_method(rax);
2424   __ movptr(rbcp, Address(rax, Method::const_offset()));
2425   __ lea(rbcp, Address(rbcp, rbx, Address::times_1,
2426                       ConstMethod::codes_offset()));
2427   __ dispatch_next(vtos, 0, true);
2428 }
2429 
2430 void TemplateTable::wide_ret() {
2431   transition(vtos, vtos);
2432   locals_index_wide(rbx);
2433   __ movptr(rbx, aaddress(rbx)); // get return bci, compute return bcp
2434   __ profile_ret(rbx, rcx);
2435   __ get_method(rax);
2436   __ movptr(rbcp, Address(rax, Method::const_offset()));
</pre>
<hr />
<pre>
2662     __ testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2663 #else
2664     const Register thread = rdi;
2665     __ get_thread(thread);
2666     __ testb(Address(thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2667 #endif
2668     __ jcc(Assembler::zero, no_safepoint);
2669     __ push(state);
2670     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2671                                     InterpreterRuntime::at_safepoint));
2672     __ pop(state);
2673     __ bind(no_safepoint);
2674   }
2675 
2676   // Narrow result if state is itos but result type is smaller.
2677   // Need to narrow in the return bytecode rather than in generate_return_entry
2678   // since compiled code callers expect the result to already be narrowed.
2679   if (state == itos) {
2680     __ narrow(rax);
2681   }
<span class="line-modified">2682   __ remove_activation(state, rbcp);</span>

2683 
2684   __ jmp(rbcp);
2685 }
2686 
2687 // ----------------------------------------------------------------------------
2688 // Volatile variables demand their effects be made known to all CPU&#39;s
2689 // in order.  Store buffers on most chips allow reads &amp; writes to
2690 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2691 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2692 // the interpreter does not reorder volatile references, the hardware
2693 // also must not reorder them).
2694 //
2695 // According to the new Java Memory Model (JMM):
2696 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2697 //     writes act as aquire &amp; release, so:
2698 // (2) A read cannot let unrelated NON-volatile memory refs that
2699 //     happen after the read float up to before the read.  It&#39;s OK for
2700 //     non-volatile memory refs that happen before the volatile read to
2701 //     float down below it.
2702 // (3) Similar a volatile write cannot let unrelated NON-volatile
</pre>
<hr />
<pre>
2860     __ get_cache_and_index_at_bcp(cache, index, 1);
2861     __ bind(L1);
2862   }
2863 }
2864 
2865 void TemplateTable::pop_and_check_object(Register r) {
2866   __ pop_ptr(r);
2867   __ null_check(r);  // for field access must check obj.
2868   __ verify_oop(r);
2869 }
2870 
2871 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2872   transition(vtos, vtos);
2873 
2874   const Register cache = rcx;
2875   const Register index = rdx;
2876   const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
2877   const Register off   = rbx;
2878   const Register flags = rax;
2879   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // uses same reg as obj, so don&#39;t mix them

2880 
2881   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2882   jvmti_post_field_access(cache, index, is_static, false);
2883   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2884 
<span class="line-removed">2885   if (!is_static) pop_and_check_object(obj);</span>
<span class="line-removed">2886 </span>
2887   const Address field(obj, off, Address::times_1, 0*wordSize);
2888 
<span class="line-modified">2889   Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj;</span>








2890 
2891   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
2892   // Make sure we don&#39;t need to mask edx after the above shift
2893   assert(btos == 0, &quot;change code, btos != 0&quot;);
2894 
2895   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
2896 
2897   __ jcc(Assembler::notZero, notByte);
2898   // btos

2899   __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
2900   __ push(btos);
2901   // Rewrite bytecode to be faster
2902   if (!is_static &amp;&amp; rc == may_rewrite) {
2903     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
2904   }
2905   __ jmp(Done);
2906 
2907   __ bind(notByte);

2908   __ cmpl(flags, ztos);
2909   __ jcc(Assembler::notEqual, notBool);
<span class="line-modified">2910 </span>
2911   // ztos (same code as btos)
2912   __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);
2913   __ push(ztos);
2914   // Rewrite bytecode to be faster
2915   if (!is_static &amp;&amp; rc == may_rewrite) {
2916     // use btos rewriting, no truncating to t/f bit is needed for getfield.
2917     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
2918   }
2919   __ jmp(Done);
2920 
2921   __ bind(notBool);
2922   __ cmpl(flags, atos);
2923   __ jcc(Assembler::notEqual, notObj);
2924   // atos
<span class="line-modified">2925   do_oop_load(_masm, field, rax);</span>
<span class="line-modified">2926   __ push(atos);</span>
<span class="line-modified">2927   if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="line-modified">2928     patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span>













































































2929   }
<span class="line-removed">2930   __ jmp(Done);</span>
2931 
2932   __ bind(notObj);



2933   __ cmpl(flags, itos);
2934   __ jcc(Assembler::notEqual, notInt);
2935   // itos
2936   __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
2937   __ push(itos);
2938   // Rewrite bytecode to be faster
2939   if (!is_static &amp;&amp; rc == may_rewrite) {
2940     patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
2941   }
2942   __ jmp(Done);
2943 
2944   __ bind(notInt);
2945   __ cmpl(flags, ctos);
2946   __ jcc(Assembler::notEqual, notChar);
2947   // ctos
2948   __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
2949   __ push(ctos);
2950   // Rewrite bytecode to be faster
2951   if (!is_static &amp;&amp; rc == may_rewrite) {
2952     patch_bytecode(Bytecodes::_fast_cgetfield, bc, rbx);
</pre>
<hr />
<pre>
3012 #endif
3013 
3014   __ bind(Done);
3015   // [jk] not needed currently
3016   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadLoad |
3017   //                                              Assembler::LoadStore));
3018 }
3019 
3020 void TemplateTable::getfield(int byte_no) {
3021   getfield_or_static(byte_no, false);
3022 }
3023 
3024 void TemplateTable::nofast_getfield(int byte_no) {
3025   getfield_or_static(byte_no, false, may_not_rewrite);
3026 }
3027 
3028 void TemplateTable::getstatic(int byte_no) {
3029   getfield_or_static(byte_no, true);
3030 }
3031 















3032 
3033 // The registers cache and index expected to be set before call.
3034 // The function may destroy various registers, just not the cache and index registers.
3035 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
3036 
3037   const Register robj = LP64_ONLY(c_rarg2)   NOT_LP64(rax);
3038   const Register RBX  = LP64_ONLY(c_rarg1)   NOT_LP64(rbx);
3039   const Register RCX  = LP64_ONLY(c_rarg3)   NOT_LP64(rcx);
3040   const Register RDX  = LP64_ONLY(rscratch1) NOT_LP64(rdx);
3041 
3042   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
3043 
3044   if (JvmtiExport::can_post_field_modification()) {
3045     // Check to see if a field modification watch has been set before
3046     // we take the time to call into the VM.
3047     Label L1;
3048     assert_different_registers(cache, index, rax);
3049     __ mov32(rax, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3050     __ testl(rax, rax);
3051     __ jcc(Assembler::zero, L1);
</pre>
<hr />
<pre>
3107     // c_rarg1: object pointer set up above (NULL if static)
3108     // c_rarg2: cache entry pointer
3109     // c_rarg3: jvalue object on the stack
3110     __ call_VM(noreg,
3111                CAST_FROM_FN_PTR(address,
3112                                 InterpreterRuntime::post_field_modification),
3113                RBX, robj, RCX);
3114     __ get_cache_and_index_at_bcp(cache, index, 1);
3115     __ bind(L1);
3116   }
3117 }
3118 
3119 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
3120   transition(vtos, vtos);
3121 
3122   const Register cache = rcx;
3123   const Register index = rdx;
3124   const Register obj   = rcx;
3125   const Register off   = rbx;
3126   const Register flags = rax;

3127 
3128   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3129   jvmti_post_field_mod(cache, index, is_static);
3130   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3131 
3132   // [jk] not needed currently
3133   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3134   //                                              Assembler::StoreStore));
3135 
3136   Label notVolatile, Done;
3137   __ movl(rdx, flags);
3138   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3139   __ andl(rdx, 0x1);
3140 
3141   // Check for volatile store
3142   __ testl(rdx, rdx);

3143   __ jcc(Assembler::zero, notVolatile);
3144 
<span class="line-modified">3145   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);</span>
3146   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3147                                                Assembler::StoreStore));
3148   __ jmp(Done);
3149   __ bind(notVolatile);
3150 
<span class="line-modified">3151   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);</span>
3152 
3153   __ bind(Done);
3154 }
3155 
3156 void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
<span class="line-modified">3157                                               Register obj, Register off, Register flags) {</span>
3158 
3159   // field addresses
3160   const Address field(obj, off, Address::times_1, 0*wordSize);
3161   NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
3162 
3163   Label notByte, notBool, notInt, notShort, notChar,
<span class="line-modified">3164         notLong, notFloat, notObj;</span>
3165   Label Done;
3166 
3167   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3168 
3169   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3170 
3171   assert(btos == 0, &quot;change code, btos != 0&quot;);
3172   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3173   __ jcc(Assembler::notZero, notByte);
3174 
3175   // btos
3176   {
3177     __ pop(btos);
3178     if (!is_static) pop_and_check_object(obj);
3179     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3180     if (!is_static &amp;&amp; rc == may_rewrite) {
3181       patch_bytecode(Bytecodes::_fast_bputfield, bc, rbx, true, byte_no);
3182     }
3183     __ jmp(Done);
3184   }
</pre>
<hr />
<pre>
3187   __ cmpl(flags, ztos);
3188   __ jcc(Assembler::notEqual, notBool);
3189 
3190   // ztos
3191   {
3192     __ pop(ztos);
3193     if (!is_static) pop_and_check_object(obj);
3194     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3195     if (!is_static &amp;&amp; rc == may_rewrite) {
3196       patch_bytecode(Bytecodes::_fast_zputfield, bc, rbx, true, byte_no);
3197     }
3198     __ jmp(Done);
3199   }
3200 
3201   __ bind(notBool);
3202   __ cmpl(flags, atos);
3203   __ jcc(Assembler::notEqual, notObj);
3204 
3205   // atos
3206   {
<span class="line-modified">3207     __ pop(atos);</span>
<span class="line-modified">3208     if (!is_static) pop_and_check_object(obj);</span>
<span class="line-modified">3209     // Store into the field</span>
<span class="line-modified">3210     do_oop_store(_masm, field, rax);</span>
<span class="line-modified">3211     if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="line-modified">3212       patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);</span>














































3213     }
<span class="line-removed">3214     __ jmp(Done);</span>
3215   }
3216 
3217   __ bind(notObj);
3218   __ cmpl(flags, itos);
3219   __ jcc(Assembler::notEqual, notInt);
3220 
3221   // itos
3222   {
3223     __ pop(itos);
3224     if (!is_static) pop_and_check_object(obj);
3225     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3226     if (!is_static &amp;&amp; rc == may_rewrite) {
3227       patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
3228     }
3229     __ jmp(Done);
3230   }
3231 
3232   __ bind(notInt);
3233   __ cmpl(flags, ctos);
3234   __ jcc(Assembler::notEqual, notChar);
</pre>
<hr />
<pre>
3333 }
3334 
3335 void TemplateTable::jvmti_post_fast_field_mod() {
3336 
3337   const Register scratch = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3338 
3339   if (JvmtiExport::can_post_field_modification()) {
3340     // Check to see if a field modification watch has been set before
3341     // we take the time to call into the VM.
3342     Label L2;
3343     __ mov32(scratch, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3344     __ testl(scratch, scratch);
3345     __ jcc(Assembler::zero, L2);
3346     __ pop_ptr(rbx);                  // copy the object pointer from tos
3347     __ verify_oop(rbx);
3348     __ push_ptr(rbx);                 // put the object pointer back on tos
3349     // Save tos values before call_VM() clobbers them. Since we have
3350     // to do it for every data type, we use the saved values as the
3351     // jvalue object.
3352     switch (bytecode()) {          // load values into the jvalue object

3353     case Bytecodes::_fast_aputfield: __ push_ptr(rax); break;
3354     case Bytecodes::_fast_bputfield: // fall through
3355     case Bytecodes::_fast_zputfield: // fall through
3356     case Bytecodes::_fast_sputfield: // fall through
3357     case Bytecodes::_fast_cputfield: // fall through
3358     case Bytecodes::_fast_iputfield: __ push_i(rax); break;
3359     case Bytecodes::_fast_dputfield: __ push(dtos); break;
3360     case Bytecodes::_fast_fputfield: __ push(ftos); break;
3361     case Bytecodes::_fast_lputfield: __ push_l(rax); break;
3362 
3363     default:
3364       ShouldNotReachHere();
3365     }
3366     __ mov(scratch, rsp);             // points to jvalue on the stack
3367     // access constant pool cache entry
3368     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rax, 1));
3369     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rax, rdx, 1));
3370     __ verify_oop(rbx);
3371     // rbx: object pointer copied above
3372     // c_rarg2: cache entry pointer
3373     // c_rarg3: jvalue object on the stack
3374     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));
3375     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));
3376 
3377     switch (bytecode()) {             // restore tos values

3378     case Bytecodes::_fast_aputfield: __ pop_ptr(rax); break;
3379     case Bytecodes::_fast_bputfield: // fall through
3380     case Bytecodes::_fast_zputfield: // fall through
3381     case Bytecodes::_fast_sputfield: // fall through
3382     case Bytecodes::_fast_cputfield: // fall through
3383     case Bytecodes::_fast_iputfield: __ pop_i(rax); break;
3384     case Bytecodes::_fast_dputfield: __ pop(dtos); break;
3385     case Bytecodes::_fast_fputfield: __ pop(ftos); break;
3386     case Bytecodes::_fast_lputfield: __ pop_l(rax); break;
3387     default: break;
3388     }
3389     __ bind(L2);
3390   }
3391 }
3392 
3393 void TemplateTable::fast_storefield(TosState state) {
3394   transition(state, vtos);
3395 
3396   ByteSize base = ConstantPoolCache::base_offset();
3397 
3398   jvmti_post_fast_field_mod();
3399 
3400   // access constant pool cache
3401   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3402 
3403   // test for volatile with rdx but rdx is tos register for lputfield.
3404   __ movl(rdx, Address(rcx, rbx, Address::times_ptr,
3405                        in_bytes(base +
3406                                 ConstantPoolCacheEntry::flags_offset())));
3407 
3408   // replace index with field offset from cache entry
3409   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,
3410                          in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3411 
3412   // [jk] not needed currently
3413   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3414   //                                              Assembler::StoreStore));
3415 
3416   Label notVolatile, Done;




3417   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3418   __ andl(rdx, 0x1);
3419 
3420   // Get object from stack
3421   pop_and_check_object(rcx);
3422 
3423   // field address
3424   const Address field(rcx, rbx, Address::times_1);
3425 
3426   // Check for volatile store
3427   __ testl(rdx, rdx);
3428   __ jcc(Assembler::zero, notVolatile);
3429 
<span class="line-modified">3430   fast_storefield_helper(field, rax);</span>



3431   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3432                                                Assembler::StoreStore));
3433   __ jmp(Done);
3434   __ bind(notVolatile);
3435 
<span class="line-modified">3436   fast_storefield_helper(field, rax);</span>



3437 
3438   __ bind(Done);
3439 }
3440 
<span class="line-modified">3441 void TemplateTable::fast_storefield_helper(Address field, Register rax) {</span>
3442 
3443   // access field
3444   switch (bytecode()) {

















3445   case Bytecodes::_fast_aputfield:
<span class="line-modified">3446     do_oop_store(_masm, field, rax);</span>


3447     break;
3448   case Bytecodes::_fast_lputfield:
3449 #ifdef _LP64
3450     __ access_store_at(T_LONG, IN_HEAP, field, noreg /* ltos */, noreg, noreg);
3451 #else
3452   __ stop(&quot;should not be rewritten&quot;);
3453 #endif
3454     break;
3455   case Bytecodes::_fast_iputfield:
3456     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3457     break;
3458   case Bytecodes::_fast_zputfield:
3459     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3460     break;
3461   case Bytecodes::_fast_bputfield:
3462     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3463     break;
3464   case Bytecodes::_fast_sputfield:
3465     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3466     break;
</pre>
<hr />
<pre>
3496     __ push_ptr(rax);  // save object pointer before call_VM() clobbers it
3497     LP64_ONLY(__ mov(c_rarg1, rax));
3498     // c_rarg1: object pointer copied above
3499     // c_rarg2: cache entry pointer
3500     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2));
3501     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), rax, rcx));
3502     __ pop_ptr(rax); // restore object pointer
3503     __ bind(L1);
3504   }
3505 
3506   // access constant pool cache
3507   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3508   // replace index with field offset from cache entry
3509   // [jk] not needed currently
3510   // __ movl(rdx, Address(rcx, rbx, Address::times_8,
3511   //                      in_bytes(ConstantPoolCache::base_offset() +
3512   //                               ConstantPoolCacheEntry::flags_offset())));
3513   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3514   // __ andl(rdx, 0x1);
3515   //
<span class="line-modified">3516   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,</span>
3517                          in_bytes(ConstantPoolCache::base_offset() +
3518                                   ConstantPoolCacheEntry::f2_offset())));
3519 
3520   // rax: object
3521   __ verify_oop(rax);
3522   __ null_check(rax);
<span class="line-modified">3523   Address field(rax, rbx, Address::times_1);</span>
3524 
3525   // access field
3526   switch (bytecode()) {






































3527   case Bytecodes::_fast_agetfield:
3528     do_oop_load(_masm, field, rax);
3529     __ verify_oop(rax);
3530     break;
3531   case Bytecodes::_fast_lgetfield:
3532 #ifdef _LP64
3533     __ access_load_at(T_LONG, IN_HEAP, noreg /* ltos */, field, noreg, noreg);
3534 #else
3535   __ stop(&quot;should not be rewritten&quot;);
3536 #endif
3537     break;
3538   case Bytecodes::_fast_igetfield:
3539     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3540     break;
3541   case Bytecodes::_fast_bgetfield:
3542     __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3543     break;
3544   case Bytecodes::_fast_sgetfield:
3545     __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3546     break;
</pre>
<hr />
<pre>
3978 
3979   // Note:  rax_callsite is already pushed by prepare_invoke
3980 
3981   // %%% should make a type profile for any invokedynamic that takes a ref argument
3982   // profile this call
3983   __ profile_call(rbcp);
3984   __ profile_arguments_type(rdx, rbx_method, rbcp, false);
3985 
3986   __ verify_oop(rax_callsite);
3987 
3988   __ jump_from_interpreted(rbx_method, rdx);
3989 }
3990 
3991 //-----------------------------------------------------------------------------
3992 // Allocation
3993 
3994 void TemplateTable::_new() {
3995   transition(vtos, atos);
3996   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
3997   Label slow_case;
<span class="line-modified">3998   Label slow_case_no_pop;</span>
<span class="line-removed">3999   Label done;</span>
<span class="line-removed">4000   Label initialize_header;</span>
4001   Label initialize_object;  // including clearing the fields
4002 
4003   __ get_cpool_and_tags(rcx, rax);
4004 
4005   // Make sure the class we&#39;re about to instantiate has been resolved.
4006   // This is done before loading InstanceKlass to be consistent with the order
4007   // how Constant Pool is updated (see ConstantPool::klass_at_put)
4008   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
4009   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);
<span class="line-modified">4010   __ jcc(Assembler::notEqual, slow_case_no_pop);</span>
4011 
4012   // get InstanceKlass
4013   __ load_resolved_klass_at_index(rcx, rcx, rdx);
<span class="line-modified">4014   __ push(rcx);  // save the contexts of klass for initializing the header</span>








4015 
4016   // make sure klass is initialized &amp; doesn&#39;t have finalizer
<span class="line-removed">4017   // make sure klass is fully initialized</span>
4018   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
4019   __ jcc(Assembler::notEqual, slow_case);
4020 
<span class="line-modified">4021   // get instance_size in InstanceKlass (scaled to a count of bytes)</span>
<span class="line-modified">4022   __ movl(rdx, Address(rcx, Klass::layout_helper_offset()));</span>
<span class="line-removed">4023   // test to see if it has a finalizer or is malformed in some way</span>
<span class="line-removed">4024   __ testl(rdx, Klass::_lh_instance_slow_path_bit);</span>
<span class="line-removed">4025   __ jcc(Assembler::notZero, slow_case);</span>
<span class="line-removed">4026 </span>
<span class="line-removed">4027   // Allocate the instance:</span>
<span class="line-removed">4028   //  If TLAB is enabled:</span>
<span class="line-removed">4029   //    Try to allocate in the TLAB.</span>
<span class="line-removed">4030   //    If fails, go to the slow path.</span>
<span class="line-removed">4031   //  Else If inline contiguous allocations are enabled:</span>
<span class="line-removed">4032   //    Try to allocate in eden.</span>
<span class="line-removed">4033   //    If fails due to heap end, go to slow path.</span>
<span class="line-removed">4034   //</span>
<span class="line-removed">4035   //  If TLAB is enabled OR inline contiguous is enabled:</span>
<span class="line-removed">4036   //    Initialize the allocation.</span>
<span class="line-removed">4037   //    Exit.</span>
<span class="line-removed">4038   //</span>
<span class="line-removed">4039   //  Go to slow path.</span>
4040 
<span class="line-modified">4041   const bool allow_shared_alloc =</span>
<span class="line-modified">4042     Universe::heap()-&gt;supports_inline_contig_alloc();</span>
4043 
<span class="line-modified">4044   const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);</span>
<span class="line-modified">4045 #ifndef _LP64</span>
<span class="line-removed">4046   if (UseTLAB || allow_shared_alloc) {</span>
<span class="line-removed">4047     __ get_thread(thread);</span>
<span class="line-removed">4048   }</span>
<span class="line-removed">4049 #endif // _LP64</span>
4050 
<span class="line-modified">4051   if (UseTLAB) {</span>
<span class="line-modified">4052     __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);</span>
<span class="line-modified">4053     if (ZeroTLAB) {</span>
<span class="line-modified">4054       // the fields have been already cleared</span>
<span class="line-removed">4055       __ jmp(initialize_header);</span>
<span class="line-removed">4056     } else {</span>
<span class="line-removed">4057       // initialize both the header and fields</span>
<span class="line-removed">4058       __ jmp(initialize_object);</span>
<span class="line-removed">4059     }</span>
<span class="line-removed">4060   } else {</span>
<span class="line-removed">4061     // Allocation in the shared Eden, if allowed.</span>
<span class="line-removed">4062     //</span>
<span class="line-removed">4063     // rdx: instance size in bytes</span>
<span class="line-removed">4064     __ eden_allocate(thread, rax, rdx, 0, rbx, slow_case);</span>
<span class="line-removed">4065   }</span>
4066 
<span class="line-modified">4067   // If UseTLAB or allow_shared_alloc are true, the object is created above and</span>
<span class="line-modified">4068   // there is an initialize need. Otherwise, skip and go to the slow path.</span>
<span class="line-modified">4069   if (UseTLAB || allow_shared_alloc) {</span>
<span class="line-removed">4070     // The object is initialized before the header.  If the object size is</span>
<span class="line-removed">4071     // zero, go directly to the header initialization.</span>
<span class="line-removed">4072     __ bind(initialize_object);</span>
<span class="line-removed">4073     __ decrement(rdx, sizeof(oopDesc));</span>
<span class="line-removed">4074     __ jcc(Assembler::zero, initialize_header);</span>
<span class="line-removed">4075 </span>
<span class="line-removed">4076     // Initialize topmost object field, divide rdx by 8, check if odd and</span>
<span class="line-removed">4077     // test if zero.</span>
<span class="line-removed">4078     __ xorl(rcx, rcx);    // use zero reg to clear memory (shorter code)</span>
<span class="line-removed">4079     __ shrl(rdx, LogBytesPerLong); // divide by 2*oopSize and set carry flag if odd</span>
<span class="line-removed">4080 </span>
<span class="line-removed">4081     // rdx must have been multiple of 8</span>
<span class="line-removed">4082 #ifdef ASSERT</span>
<span class="line-removed">4083     // make sure rdx was multiple of 8</span>
<span class="line-removed">4084     Label L;</span>
<span class="line-removed">4085     // Ignore partial flag stall after shrl() since it is debug VM</span>
<span class="line-removed">4086     __ jcc(Assembler::carryClear, L);</span>
<span class="line-removed">4087     __ stop(&quot;object size is not multiple of 2 - adjust this code&quot;);</span>
<span class="line-removed">4088     __ bind(L);</span>
<span class="line-removed">4089     // rdx must be &gt; 0, no extra check needed here</span>
<span class="line-removed">4090 #endif</span>
4091 
<span class="line-modified">4092     // initialize remaining object fields: rdx was a multiple of 8</span>
<span class="line-modified">4093     { Label loop;</span>
<span class="line-removed">4094     __ bind(loop);</span>
<span class="line-removed">4095     __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);</span>
<span class="line-removed">4096     NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));</span>
<span class="line-removed">4097     __ decrement(rdx);</span>
<span class="line-removed">4098     __ jcc(Assembler::notZero, loop);</span>
<span class="line-removed">4099     }</span>
4100 
<span class="line-modified">4101     // initialize object header only.</span>
<span class="line-modified">4102     __ bind(initialize_header);</span>
<span class="line-modified">4103     if (UseBiasedLocking) {</span>
<span class="line-removed">4104       __ pop(rcx);   // get saved klass back in the register.</span>
<span class="line-removed">4105       __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));</span>
<span class="line-removed">4106       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);</span>
<span class="line-removed">4107     } else {</span>
<span class="line-removed">4108       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),</span>
<span class="line-removed">4109                 (intptr_t)markWord::prototype().value()); // header</span>
<span class="line-removed">4110       __ pop(rcx);   // get saved klass back in the register.</span>
<span class="line-removed">4111     }</span>
<span class="line-removed">4112 #ifdef _LP64</span>
<span class="line-removed">4113     __ xorl(rsi, rsi); // use zero reg to clear memory (shorter code)</span>
<span class="line-removed">4114     __ store_klass_gap(rax, rsi);  // zero klass gap for compressed oops</span>
<span class="line-removed">4115 #endif</span>
<span class="line-removed">4116     __ store_klass(rax, rcx);  // klass</span>
4117 
<span class="line-modified">4118     {</span>
<span class="line-modified">4119       SkipIfEqual skip_if(_masm, &amp;DTraceAllocProbes, 0);</span>
<span class="line-removed">4120       // Trigger dtrace event for fastpath</span>
<span class="line-removed">4121       __ push(atos);</span>
<span class="line-removed">4122       __ call_VM_leaf(</span>
<span class="line-removed">4123            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), rax);</span>
<span class="line-removed">4124       __ pop(atos);</span>
<span class="line-removed">4125     }</span>
4126 
<span class="line-modified">4127     __ jmp(done);</span>
<span class="line-modified">4128   }</span>

























4129 
<span class="line-modified">4130   // slow case</span>
<span class="line-removed">4131   __ bind(slow_case);</span>
<span class="line-removed">4132   __ pop(rcx);   // restore stack pointer to what it was when we came in.</span>
<span class="line-removed">4133   __ bind(slow_case_no_pop);</span>
4134 
4135   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);
4136   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4137 
<span class="line-modified">4138   __ get_constant_pool(rarg1);</span>
<span class="line-modified">4139   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);</span>
<span class="line-modified">4140   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);</span>

4141    __ verify_oop(rax);
4142 
<span class="line-modified">4143   // continue</span>
4144   __ bind(done);
4145 }
4146 
4147 void TemplateTable::newarray() {
4148   transition(itos, atos);
4149   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4150   __ load_unsigned_byte(rarg1, at_bcp(1));
4151   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
4152           rarg1, rax);
4153 }
4154 
4155 void TemplateTable::anewarray() {
4156   transition(itos, atos);
4157 
4158   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4159   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4160 
4161   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4162   __ get_constant_pool(rarg1);
4163   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
4164           rarg1, rarg2, rax);
4165 }
4166 
4167 void TemplateTable::arraylength() {
4168   transition(atos, itos);
4169   __ null_check(rax, arrayOopDesc::length_offset_in_bytes());
4170   __ movl(rax, Address(rax, arrayOopDesc::length_offset_in_bytes()));
4171 }
4172 
4173 void TemplateTable::checkcast() {
4174   transition(atos, atos);
4175   Label done, is_null, ok_is_subtype, quicked, resolved;
4176   __ testptr(rax, rax); // object is in rax
4177   __ jcc(Assembler::zero, is_null);
4178 
4179   // Get cpool &amp; tags index
4180   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4181   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4182   // See if bytecode has already been quicked
<span class="line-modified">4183   __ cmpb(Address(rdx, rbx,</span>
<span class="line-modified">4184                   Address::times_1,</span>
<span class="line-modified">4185                   Array&lt;u1&gt;::base_offset_in_bytes()),</span>
<span class="line-modified">4186           JVM_CONSTANT_Class);</span>

4187   __ jcc(Assembler::equal, quicked);
4188   __ push(atos); // save receiver for result, and for GC
4189   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4190 
4191   // vm_result_2 has metadata result
4192 #ifndef _LP64
4193   // borrow rdi from locals
4194   __ get_thread(rdi);
4195   __ get_vm_result_2(rax, rdi);
4196   __ restore_locals();
4197 #else
4198   __ get_vm_result_2(rax, r15_thread);
4199 #endif
4200 
4201   __ pop_ptr(rdx); // restore receiver
4202   __ jmpb(resolved);
4203 
4204   // Get superklass in rax and subklass in rbx
4205   __ bind(quicked);
4206   __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
4207   __ load_resolved_klass_at_index(rax, rcx, rbx);
4208 
4209   __ bind(resolved);
4210   __ load_klass(rbx, rdx);
4211 
4212   // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
4213   // Superklass in rax.  Subklass in rbx.
4214   __ gen_subtype_check(rbx, ok_is_subtype);
4215 
4216   // Come here on failure
4217   __ push_ptr(rdx);
4218   // object is at TOS
4219   __ jump(ExternalAddress(Interpreter::_throw_ClassCastException_entry));
4220 
4221   // Come here on success
4222   __ bind(ok_is_subtype);
4223   __ mov(rax, rdx); // Restore object in rdx



4224 
4225   // Collect counts on whether this check-cast sees NULLs a lot or not.
4226   if (ProfileInterpreter) {
<span class="line-modified">4227     __ jmp(done);</span>
<span class="line-modified">4228     __ bind(is_null);</span>
<span class="line-modified">4229     __ profile_null_seen(rcx);</span>
<span class="line-modified">4230   } else {</span>











4231     __ bind(is_null);   // same as &#39;done&#39;
4232   }
4233   __ bind(done);
4234 }
4235 
4236 void TemplateTable::instanceof() {
4237   transition(atos, itos);
4238   Label done, is_null, ok_is_subtype, quicked, resolved;
4239   __ testptr(rax, rax);
4240   __ jcc(Assembler::zero, is_null);
4241 
4242   // Get cpool &amp; tags index
4243   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4244   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4245   // See if bytecode has already been quicked
<span class="line-modified">4246   __ cmpb(Address(rdx, rbx,</span>
<span class="line-modified">4247                   Address::times_1,</span>
<span class="line-modified">4248                   Array&lt;u1&gt;::base_offset_in_bytes()),</span>
<span class="line-modified">4249           JVM_CONSTANT_Class);</span>

4250   __ jcc(Assembler::equal, quicked);
4251 
4252   __ push(atos); // save receiver for result, and for GC
4253   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4254   // vm_result_2 has metadata result
4255 
4256 #ifndef _LP64
4257   // borrow rdi from locals
4258   __ get_thread(rdi);
4259   __ get_vm_result_2(rax, rdi);
4260   __ restore_locals();
4261 #else
4262   __ get_vm_result_2(rax, r15_thread);
4263 #endif
4264 
4265   __ pop_ptr(rdx); // restore receiver
4266   __ verify_oop(rdx);
4267   __ load_klass(rdx, rdx);
4268   __ jmpb(resolved);
4269 
</pre>
<hr />
<pre>
4281   // Come here on failure
4282   __ xorl(rax, rax);
4283   __ jmpb(done);
4284   // Come here on success
4285   __ bind(ok_is_subtype);
4286   __ movl(rax, 1);
4287 
4288   // Collect counts on whether this test sees NULLs a lot or not.
4289   if (ProfileInterpreter) {
4290     __ jmp(done);
4291     __ bind(is_null);
4292     __ profile_null_seen(rcx);
4293   } else {
4294     __ bind(is_null);   // same as &#39;done&#39;
4295   }
4296   __ bind(done);
4297   // rax = 0: obj == NULL or  obj is not an instanceof the specified klass
4298   // rax = 1: obj != NULL and obj is     an instanceof the specified klass
4299 }
4300 
<span class="line-removed">4301 </span>
4302 //----------------------------------------------------------------------------------------------------
4303 // Breakpoints
4304 void TemplateTable::_breakpoint() {
4305   // Note: We get here even if we are single stepping..
4306   // jbug insists on setting breakpoints at every bytecode
4307   // even if we are in single step mode.
4308 
4309   transition(vtos, vtos);
4310 
4311   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4312 
4313   // get the unpatched byte code
4314   __ get_method(rarg);
4315   __ call_VM(noreg,
4316              CAST_FROM_FN_PTR(address,
4317                               InterpreterRuntime::get_original_bytecode_at),
4318              rarg, rbcp);
4319   __ mov(rbx, rax);  // why?
4320 
4321   // post the breakpoint event
</pre>
<hr />
<pre>
4345 //
4346 // Stack layout:
4347 //
4348 // [expressions  ] &lt;--- rsp               = expression stack top
4349 // ..
4350 // [expressions  ]
4351 // [monitor entry] &lt;--- monitor block top = expression stack bot
4352 // ..
4353 // [monitor entry]
4354 // [frame data   ] &lt;--- monitor block bot
4355 // ...
4356 // [saved rbp    ] &lt;--- rbp
4357 void TemplateTable::monitorenter() {
4358   transition(atos, vtos);
4359 
4360   // check for NULL object
4361   __ null_check(rax);
4362 
4363   __ resolve(IS_NOT_NULL, rax);
4364 











4365   const Address monitor_block_top(
4366         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4367   const Address monitor_block_bot(
4368         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4369   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4370 
4371   Label allocated;
4372 
4373   Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
4374   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4375   Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4376 
4377   // initialize entry pointer
4378   __ xorl(rmon, rmon); // points to free slot or NULL
4379 
4380   // find a free slot in the monitor block (result in rmon)
4381   {
4382     Label entry, loop, exit;
4383     __ movptr(rtop, monitor_block_top); // points to current entry,
4384                                         // starting with top-most entry
</pre>
<hr />
<pre>
4444   __ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);
4445   __ lock_object(rmon);
4446 
4447   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4448   __ save_bcp();  // in case of exception
4449   __ generate_stack_overflow_check(0);
4450 
4451   // The bcp has already been incremented. Just need to dispatch to
4452   // next instruction.
4453   __ dispatch_next(vtos);
4454 }
4455 
4456 void TemplateTable::monitorexit() {
4457   transition(atos, vtos);
4458 
4459   // check for NULL object
4460   __ null_check(rax);
4461 
4462   __ resolve(IS_NOT_NULL, rax);
4463 











4464   const Address monitor_block_top(
4465         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4466   const Address monitor_block_bot(
4467         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4468   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4469 
4470   Register rtop = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4471   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4472 
4473   Label found;
4474 
4475   // find matching slot
4476   {
4477     Label entry, loop;
4478     __ movptr(rtop, monitor_block_top); // points to current entry,
4479                                         // starting with top-most entry
4480     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4481                                         // of monitor block
4482     __ jmpb(entry);
4483 
</pre>
</td>
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;interpreter/interpreter.hpp&quot;
  29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  30 #include &quot;interpreter/interp_masm.hpp&quot;
  31 #include &quot;interpreter/templateTable.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/methodData.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  36 #include &quot;oops/valueKlass.hpp&quot;</span>
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
  44 
  45 #define __ Disassembler::hook&lt;InterpreterMacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
  46 
  47 // Global Register Names
  48 static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);
  49 static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);
  50 
  51 // Platform-dependent initialization
  52 void TemplateTable::pd_initialize() {
  53   // No x86 specific initialization
  54 }
  55 
  56 // Address Computation: local variables
</pre>
<hr />
<pre>
 138   case TemplateTable::less_equal   : return Assembler::greater;
 139   case TemplateTable::greater      : return Assembler::lessEqual;
 140   case TemplateTable::greater_equal: return Assembler::less;
 141   }
 142   ShouldNotReachHere();
 143   return Assembler::zero;
 144 }
 145 
 146 
 147 
 148 // Miscelaneous helper routines
 149 // Store an oop (or NULL) at the address described by obj.
 150 // If val == noreg this means store a NULL
 151 
 152 
 153 static void do_oop_store(InterpreterMacroAssembler* _masm,
 154                          Address dst,
 155                          Register val,
 156                          DecoratorSet decorators = 0) {
 157   assert(val == noreg || val == rax, &quot;parameter is just for looks&quot;);
<span class="line-modified"> 158   __ store_heap_oop(dst, val, rdx, rbx, noreg, decorators);</span>
 159 }
 160 
 161 static void do_oop_load(InterpreterMacroAssembler* _masm,
 162                         Address src,
 163                         Register dst,
 164                         DecoratorSet decorators = 0) {
 165   __ load_heap_oop(dst, src, rdx, rbx, decorators);
 166 }
 167 
 168 Address TemplateTable::at_bcp(int offset) {
 169   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 170   return Address(rbcp, offset);
 171 }
 172 
 173 
 174 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 175                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 176                                    int byte_no) {
 177   if (!RewriteBytecodes)  return;
 178   Label L_patch_done;
 179 
 180   switch (bc) {
<span class="line-added"> 181   case Bytecodes::_fast_qputfield:</span>
 182   case Bytecodes::_fast_aputfield:
 183   case Bytecodes::_fast_bputfield:
 184   case Bytecodes::_fast_zputfield:
 185   case Bytecodes::_fast_cputfield:
 186   case Bytecodes::_fast_dputfield:
 187   case Bytecodes::_fast_fputfield:
 188   case Bytecodes::_fast_iputfield:
 189   case Bytecodes::_fast_lputfield:
 190   case Bytecodes::_fast_sputfield:
 191     {
 192       // We skip bytecode quickening for putfield instructions when
 193       // the put_code written to the constant pool cache is zero.
 194       // This is required so that every execution of this instruction
 195       // calls out to InterpreterRuntime::resolve_get_put to do
 196       // additional, required work.
 197       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 198       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 199       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 200       __ movl(bc_reg, bc);
 201       __ cmpl(temp_reg, (int) 0);
</pre>
<hr />
<pre>
 354   __ sarl(rax, 16);
 355 }
 356 
 357 void TemplateTable::ldc(bool wide) {
 358   transition(vtos, vtos);
 359   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 360   Label call_ldc, notFloat, notClass, notInt, Done;
 361 
 362   if (wide) {
 363     __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 364   } else {
 365     __ load_unsigned_byte(rbx, at_bcp(1));
 366   }
 367 
 368   __ get_cpool_and_tags(rcx, rax);
 369   const int base_offset = ConstantPool::header_size() * wordSize;
 370   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 371 
 372   // get type
 373   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));
<span class="line-added"> 374   __ andl(rdx, ~JVM_CONSTANT_QDescBit);</span>
 375 
 376   // unresolved class - get the resolved class
 377   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClass);
 378   __ jccb(Assembler::equal, call_ldc);
 379 
 380   // unresolved class in error state - call into runtime to throw the error
 381   // from the first resolution attempt
 382   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClassInError);
 383   __ jccb(Assembler::equal, call_ldc);
 384 
 385   // resolved class - need to call vm to get java mirror of the class
 386   __ cmpl(rdx, JVM_CONSTANT_Class);
 387   __ jcc(Assembler::notEqual, notClass);
 388 
 389   __ bind(call_ldc);
 390 
 391   __ movl(rarg, wide);
 392   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), rarg);
 393 
 394   __ push(atos);
</pre>
<hr />
<pre>
 805                     Address(rdx, rax,
 806                             Address::times_4,
 807                             arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
 808                     noreg, noreg);
 809 }
 810 
 811 void TemplateTable::daload() {
 812   transition(itos, dtos);
 813   // rax: index
 814   // rdx: array
 815   index_check(rdx, rax); // kills rbx
 816   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg /* dtos */,
 817                     Address(rdx, rax,
 818                             Address::times_8,
 819                             arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
 820                     noreg, noreg);
 821 }
 822 
 823 void TemplateTable::aaload() {
 824   transition(itos, atos);
<span class="line-modified"> 825   Register array = rdx;</span>
<span class="line-modified"> 826   Register index = rax;</span>
<span class="line-modified"> 827 </span>
<span class="line-modified"> 828   index_check(array, index); // kills rbx</span>
<span class="line-modified"> 829   __ profile_array(rbx, array, rcx);</span>
<span class="line-modified"> 830   if (ValueArrayFlatten) {</span>
<span class="line-modified"> 831     Label is_flat_array, done;</span>
<span class="line-modified"> 832     __ test_flattened_array_oop(array, rbx, is_flat_array);</span>
<span class="line-modified"> 833     do_oop_load(_masm,</span>
<span class="line-added"> 834                 Address(array, index,</span>
<span class="line-added"> 835                         UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="line-added"> 836                         arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="line-added"> 837                 rax,</span>
<span class="line-added"> 838                 IS_ARRAY);</span>
<span class="line-added"> 839     __ jmp(done);</span>
<span class="line-added"> 840     __ bind(is_flat_array);</span>
<span class="line-added"> 841     __ read_flattened_element(array, index, rbx, rcx, rax);</span>
<span class="line-added"> 842     __ bind(done);</span>
<span class="line-added"> 843   } else {</span>
<span class="line-added"> 844     do_oop_load(_masm,</span>
<span class="line-added"> 845                 Address(array, index,</span>
<span class="line-added"> 846                         UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="line-added"> 847                         arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="line-added"> 848                 rax,</span>
<span class="line-added"> 849                 IS_ARRAY);</span>
<span class="line-added"> 850   }</span>
<span class="line-added"> 851   __ profile_element(rbx, rax, rcx);</span>
 852 }
 853 
 854 void TemplateTable::baload() {
 855   transition(itos, itos);
 856   // rax: index
 857   // rdx: array
 858   index_check(rdx, rax); // kills rbx
 859   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax,
 860                     Address(rdx, rax, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_BYTE)),
 861                     noreg, noreg);
 862 }
 863 
 864 void TemplateTable::caload() {
 865   transition(itos, itos);
 866   // rax: index
 867   // rdx: array
 868   index_check(rdx, rax); // kills rbx
 869   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,
 870                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),
 871                     noreg, noreg);
</pre>
<hr />
<pre>
1117   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY,
1118                      Address(rdx, rbx, Address::times_4,
1119                              arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
1120                      noreg /* ftos */, noreg, noreg);
1121 }
1122 
1123 void TemplateTable::dastore() {
1124   transition(dtos, vtos);
1125   __ pop_i(rbx);
1126   // value is in UseSSE &gt;= 2 ? xmm0 : ST(0)
1127   // rbx:  index
1128   // rdx:  array
1129   index_check(rdx, rbx); // prefer index in rbx
1130   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY,
1131                      Address(rdx, rbx, Address::times_8,
1132                              arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
1133                      noreg /* dtos */, noreg, noreg);
1134 }
1135 
1136 void TemplateTable::aastore() {
<span class="line-modified">1137   Label is_null, is_flat_array, ok_is_subtype, done;</span>
1138   transition(vtos, vtos);
1139   // stack: ..., array, index, value
1140   __ movptr(rax, at_tos());    // value
1141   __ movl(rcx, at_tos_p1()); // index
1142   __ movptr(rdx, at_tos_p2()); // array
1143 
1144   Address element_address(rdx, rcx,
1145                           UseCompressedOops? Address::times_4 : Address::times_ptr,
1146                           arrayOopDesc::base_offset_in_bytes(T_OBJECT));
1147 
1148   index_check_without_pop(rdx, rcx);     // kills rbx
<span class="line-added">1149 </span>
<span class="line-added">1150   __ profile_array(rdi, rdx, rbx);</span>
<span class="line-added">1151   __ profile_element(rdi, rax, rbx);</span>
<span class="line-added">1152 </span>
1153   __ testptr(rax, rax);
1154   __ jcc(Assembler::zero, is_null);
1155 
<span class="line-added">1156   // Move array class to rdi</span>
<span class="line-added">1157   __ load_klass(rdi, rdx);</span>
<span class="line-added">1158   if (ValueArrayFlatten) {</span>
<span class="line-added">1159     __ test_flattened_array_oop(rdx, rbx, is_flat_array);</span>
<span class="line-added">1160   }</span>
<span class="line-added">1161 </span>
1162   // Move subklass into rbx
1163   __ load_klass(rbx, rax);
<span class="line-modified">1164   // Move array element superklass into rax</span>
<span class="line-modified">1165   __ movptr(rax, Address(rdi,</span>

1166                          ObjArrayKlass::element_klass_offset()));
1167 
1168   // Generate subtype check.  Blows rcx, rdi
1169   // Superklass in rax.  Subklass in rbx.
<span class="line-modified">1170   // is &quot;rbx &lt;: rax&quot; ? (value subclass &lt;: array element superclass)</span>
<span class="line-added">1171   __ gen_subtype_check(rbx, ok_is_subtype, false);</span>
1172 
1173   // Come here on failure
1174   // object is at TOS
1175   __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
1176 
1177   // Come here on success
1178   __ bind(ok_is_subtype);
1179 
1180   // Get the value we will store
1181   __ movptr(rax, at_tos());
1182   __ movl(rcx, at_tos_p1()); // index
1183   // Now store using the appropriate barrier
1184   do_oop_store(_masm, element_address, rax, IS_ARRAY);
1185   __ jmp(done);
1186 
1187   // Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]
1188   __ bind(is_null);
<span class="line-modified">1189   if (EnableValhalla) {</span>
<span class="line-added">1190     Label is_null_into_value_array_npe, store_null;</span>
1191 
<span class="line-added">1192     // No way to store null in null-free array</span>
<span class="line-added">1193     __ test_null_free_array_oop(rdx, rbx, is_null_into_value_array_npe);</span>
<span class="line-added">1194     __ jmp(store_null);</span>
<span class="line-added">1195 </span>
<span class="line-added">1196     __ bind(is_null_into_value_array_npe);</span>
<span class="line-added">1197     __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));</span>
<span class="line-added">1198 </span>
<span class="line-added">1199     __ bind(store_null);</span>
<span class="line-added">1200   }</span>
1201   // Store a NULL
1202   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
<span class="line-added">1203   __ jmp(done);</span>
<span class="line-added">1204 </span>
<span class="line-added">1205   if (EnableValhalla) {</span>
<span class="line-added">1206     Label is_type_ok;</span>
<span class="line-added">1207     __ bind(is_flat_array); // Store non-null value to flat</span>
<span class="line-added">1208 </span>
<span class="line-added">1209     // Simplistic type check...</span>
1210 
<span class="line-added">1211     // Profile the not-null value&#39;s klass.</span>
<span class="line-added">1212     __ load_klass(rbx, rax);</span>
<span class="line-added">1213     // Move element klass into rax</span>
<span class="line-added">1214     __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));</span>
<span class="line-added">1215     // flat value array needs exact type match</span>
<span class="line-added">1216     // is &quot;rax == rbx&quot; (value subclass == array element superclass)</span>
<span class="line-added">1217     __ cmpptr(rax, rbx);</span>
<span class="line-added">1218     __ jccb(Assembler::equal, is_type_ok);</span>
<span class="line-added">1219 </span>
<span class="line-added">1220     __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));</span>
<span class="line-added">1221 </span>
<span class="line-added">1222     __ bind(is_type_ok);</span>
<span class="line-added">1223     // rbx: value&#39;s klass</span>
<span class="line-added">1224     // rdx: array</span>
<span class="line-added">1225     // rdi: array klass</span>
<span class="line-added">1226     __ test_klass_is_empty_value(rbx, rax, done);</span>
<span class="line-added">1227 </span>
<span class="line-added">1228     // calc dst for copy</span>
<span class="line-added">1229     __ movl(rax, at_tos_p1()); // index</span>
<span class="line-added">1230     __ data_for_value_array_index(rdx, rdi, rax, rax);</span>
<span class="line-added">1231 </span>
<span class="line-added">1232     // ...and src for copy</span>
<span class="line-added">1233     __ movptr(rcx, at_tos());  // value</span>
<span class="line-added">1234     __ data_for_oop(rcx, rcx, rbx);</span>
<span class="line-added">1235 </span>
<span class="line-added">1236     __ access_value_copy(IN_HEAP, rcx, rax, rbx);</span>
<span class="line-added">1237   }</span>
1238   // Pop stack arguments
1239   __ bind(done);
1240   __ addptr(rsp, 3 * Interpreter::stackElementSize);
1241 }
1242 
1243 void TemplateTable::bastore() {
1244   transition(itos, vtos);
1245   __ pop_i(rbx);
1246   // rax: value
1247   // rbx: index
1248   // rdx: array
1249   index_check(rdx, rbx); // prefer index in rbx
1250   // Need to check whether array is boolean or byte
1251   // since both types share the bastore bytecode.
1252   __ load_klass(rcx, rdx);
1253   __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
1254   int diffbit = Klass::layout_helper_boolean_diffbit();
1255   __ testl(rcx, diffbit);
1256   Label L_skip;
1257   __ jccb(Assembler::zero, L_skip);
</pre>
<hr />
<pre>
2463   __ jcc(j_not(cc), not_taken);
2464   branch(false, false);
2465   __ bind(not_taken);
2466   __ profile_not_taken_branch(rax);
2467 }
2468 
2469 void TemplateTable::if_nullcmp(Condition cc) {
2470   transition(atos, vtos);
2471   // assume branch is more often taken than not (loops use backward branches)
2472   Label not_taken;
2473   __ testptr(rax, rax);
2474   __ jcc(j_not(cc), not_taken);
2475   branch(false, false);
2476   __ bind(not_taken);
2477   __ profile_not_taken_branch(rax);
2478 }
2479 
2480 void TemplateTable::if_acmp(Condition cc) {
2481   transition(atos, vtos);
2482   // assume branch is more often taken than not (loops use backward branches)
<span class="line-modified">2483   Label taken, not_taken;</span>
2484   __ pop_ptr(rdx);
<span class="line-added">2485 </span>
<span class="line-added">2486   const int is_value_mask = markWord::always_locked_pattern;</span>
<span class="line-added">2487   if (EnableValhalla) {</span>
<span class="line-added">2488     __ cmpoop(rdx, rax);</span>
<span class="line-added">2489     __ jcc(Assembler::equal, (cc == equal) ? taken : not_taken);</span>
<span class="line-added">2490 </span>
<span class="line-added">2491     // might be substitutable, test if either rax or rdx is null</span>
<span class="line-added">2492     __ movptr(rbx, rdx);</span>
<span class="line-added">2493     __ andptr(rbx, rax);</span>
<span class="line-added">2494     __ testptr(rbx, rbx);</span>
<span class="line-added">2495     __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);</span>
<span class="line-added">2496 </span>
<span class="line-added">2497     // and both are values ?</span>
<span class="line-added">2498     __ movptr(rbx, Address(rdx, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">2499     __ andptr(rbx, is_value_mask);</span>
<span class="line-added">2500     __ movptr(rcx, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">2501     __ andptr(rbx, is_value_mask);</span>
<span class="line-added">2502     __ andptr(rbx, rcx);</span>
<span class="line-added">2503     __ cmpl(rbx, is_value_mask);</span>
<span class="line-added">2504     __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);</span>
<span class="line-added">2505 </span>
<span class="line-added">2506     // same value klass ?</span>
<span class="line-added">2507     __ load_metadata(rbx, rdx);</span>
<span class="line-added">2508     __ load_metadata(rcx, rax);</span>
<span class="line-added">2509     __ cmpptr(rbx, rcx);</span>
<span class="line-added">2510     __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);</span>
<span class="line-added">2511 </span>
<span class="line-added">2512     // Know both are the same type, let&#39;s test for substitutability...</span>
<span class="line-added">2513     if (cc == equal) {</span>
<span class="line-added">2514       invoke_is_substitutable(rax, rdx, taken, not_taken);</span>
<span class="line-added">2515     } else {</span>
<span class="line-added">2516       invoke_is_substitutable(rax, rdx, not_taken, taken);</span>
<span class="line-added">2517     }</span>
<span class="line-added">2518     __ stop(&quot;Not reachable&quot;);</span>
<span class="line-added">2519   }</span>
<span class="line-added">2520 </span>
2521   __ cmpoop(rdx, rax);
2522   __ jcc(j_not(cc), not_taken);
<span class="line-added">2523   __ bind(taken);</span>
2524   branch(false, false);
2525   __ bind(not_taken);
2526   __ profile_not_taken_branch(rax);
2527 }
2528 
<span class="line-added">2529 void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,</span>
<span class="line-added">2530                                             Label&amp; is_subst, Label&amp; not_subst) {</span>
<span class="line-added">2531   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);</span>
<span class="line-added">2532   // Restored...rax answer, jmp to outcome...</span>
<span class="line-added">2533   __ testl(rax, rax);</span>
<span class="line-added">2534   __ jcc(Assembler::zero, not_subst);</span>
<span class="line-added">2535   __ jmp(is_subst);</span>
<span class="line-added">2536 }</span>
<span class="line-added">2537 </span>
2538 void TemplateTable::ret() {
2539   transition(vtos, vtos);
2540   locals_index(rbx);
2541   LP64_ONLY(__ movslq(rbx, iaddress(rbx))); // get return bci, compute return bcp
2542   NOT_LP64(__ movptr(rbx, iaddress(rbx)));
2543   __ profile_ret(rbx, rcx);
2544   __ get_method(rax);
2545   __ movptr(rbcp, Address(rax, Method::const_offset()));
2546   __ lea(rbcp, Address(rbcp, rbx, Address::times_1,
2547                       ConstMethod::codes_offset()));
2548   __ dispatch_next(vtos, 0, true);
2549 }
2550 
2551 void TemplateTable::wide_ret() {
2552   transition(vtos, vtos);
2553   locals_index_wide(rbx);
2554   __ movptr(rbx, aaddress(rbx)); // get return bci, compute return bcp
2555   __ profile_ret(rbx, rcx);
2556   __ get_method(rax);
2557   __ movptr(rbcp, Address(rax, Method::const_offset()));
</pre>
<hr />
<pre>
2783     __ testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2784 #else
2785     const Register thread = rdi;
2786     __ get_thread(thread);
2787     __ testb(Address(thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2788 #endif
2789     __ jcc(Assembler::zero, no_safepoint);
2790     __ push(state);
2791     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2792                                     InterpreterRuntime::at_safepoint));
2793     __ pop(state);
2794     __ bind(no_safepoint);
2795   }
2796 
2797   // Narrow result if state is itos but result type is smaller.
2798   // Need to narrow in the return bytecode rather than in generate_return_entry
2799   // since compiled code callers expect the result to already be narrowed.
2800   if (state == itos) {
2801     __ narrow(rax);
2802   }
<span class="line-modified">2803 </span>
<span class="line-added">2804   __ remove_activation(state, rbcp, true, true, true);</span>
2805 
2806   __ jmp(rbcp);
2807 }
2808 
2809 // ----------------------------------------------------------------------------
2810 // Volatile variables demand their effects be made known to all CPU&#39;s
2811 // in order.  Store buffers on most chips allow reads &amp; writes to
2812 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2813 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2814 // the interpreter does not reorder volatile references, the hardware
2815 // also must not reorder them).
2816 //
2817 // According to the new Java Memory Model (JMM):
2818 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2819 //     writes act as aquire &amp; release, so:
2820 // (2) A read cannot let unrelated NON-volatile memory refs that
2821 //     happen after the read float up to before the read.  It&#39;s OK for
2822 //     non-volatile memory refs that happen before the volatile read to
2823 //     float down below it.
2824 // (3) Similar a volatile write cannot let unrelated NON-volatile
</pre>
<hr />
<pre>
2982     __ get_cache_and_index_at_bcp(cache, index, 1);
2983     __ bind(L1);
2984   }
2985 }
2986 
2987 void TemplateTable::pop_and_check_object(Register r) {
2988   __ pop_ptr(r);
2989   __ null_check(r);  // for field access must check obj.
2990   __ verify_oop(r);
2991 }
2992 
2993 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2994   transition(vtos, vtos);
2995 
2996   const Register cache = rcx;
2997   const Register index = rdx;
2998   const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
2999   const Register off   = rbx;
3000   const Register flags = rax;
3001   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // uses same reg as obj, so don&#39;t mix them
<span class="line-added">3002   const Register flags2 = rdx;</span>
3003 
3004   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3005   jvmti_post_field_access(cache, index, is_static, false);
3006   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3007 


3008   const Address field(obj, off, Address::times_1, 0*wordSize);
3009 
<span class="line-modified">3010   Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj, notValueType;</span>
<span class="line-added">3011 </span>
<span class="line-added">3012   if (!is_static) {</span>
<span class="line-added">3013     __ movptr(rcx, Address(cache, index, Address::times_ptr,</span>
<span class="line-added">3014                            in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3015                                     ConstantPoolCacheEntry::f1_offset())));</span>
<span class="line-added">3016   }</span>
<span class="line-added">3017 </span>
<span class="line-added">3018   __ movl(flags2, flags);</span>
3019 
3020   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3021   // Make sure we don&#39;t need to mask edx after the above shift
3022   assert(btos == 0, &quot;change code, btos != 0&quot;);
3023 
3024   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3025 
3026   __ jcc(Assembler::notZero, notByte);
3027   // btos
<span class="line-added">3028   if (!is_static) pop_and_check_object(obj);</span>
3029   __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3030   __ push(btos);
3031   // Rewrite bytecode to be faster
3032   if (!is_static &amp;&amp; rc == may_rewrite) {
3033     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3034   }
3035   __ jmp(Done);
3036 
3037   __ bind(notByte);
<span class="line-added">3038 </span>
3039   __ cmpl(flags, ztos);
3040   __ jcc(Assembler::notEqual, notBool);
<span class="line-modified">3041    if (!is_static) pop_and_check_object(obj);</span>
3042   // ztos (same code as btos)
3043   __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);
3044   __ push(ztos);
3045   // Rewrite bytecode to be faster
3046   if (!is_static &amp;&amp; rc == may_rewrite) {
3047     // use btos rewriting, no truncating to t/f bit is needed for getfield.
3048     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3049   }
3050   __ jmp(Done);
3051 
3052   __ bind(notBool);
3053   __ cmpl(flags, atos);
3054   __ jcc(Assembler::notEqual, notObj);
3055   // atos
<span class="line-modified">3056   if (!EnableValhalla) {</span>
<span class="line-modified">3057     if (!is_static) pop_and_check_object(obj);</span>
<span class="line-modified">3058     do_oop_load(_masm, field, rax);</span>
<span class="line-modified">3059     __ push(atos);</span>
<span class="line-added">3060     if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="line-added">3061       patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span>
<span class="line-added">3062     }</span>
<span class="line-added">3063     __ jmp(Done);</span>
<span class="line-added">3064   } else {</span>
<span class="line-added">3065     if (is_static) {</span>
<span class="line-added">3066       __ load_heap_oop(rax, field);</span>
<span class="line-added">3067       Label isFlattenable, uninitialized;</span>
<span class="line-added">3068       // Issue below if the static field has not been initialized yet</span>
<span class="line-added">3069       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="line-added">3070         // Not flattenable case</span>
<span class="line-added">3071         __ push(atos);</span>
<span class="line-added">3072         __ jmp(Done);</span>
<span class="line-added">3073       // Flattenable case, must not return null even if uninitialized</span>
<span class="line-added">3074       __ bind(isFlattenable);</span>
<span class="line-added">3075         __ testptr(rax, rax);</span>
<span class="line-added">3076         __ jcc(Assembler::zero, uninitialized);</span>
<span class="line-added">3077           __ push(atos);</span>
<span class="line-added">3078           __ jmp(Done);</span>
<span class="line-added">3079         __ bind(uninitialized);</span>
<span class="line-added">3080           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3081 #ifdef _LP64</span>
<span class="line-added">3082           Label slow_case, finish;</span>
<span class="line-added">3083           __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);</span>
<span class="line-added">3084           __ jcc(Assembler::notEqual, slow_case);</span>
<span class="line-added">3085         __ get_default_value_oop(rcx, off, rax);</span>
<span class="line-added">3086         __ jmp(finish);</span>
<span class="line-added">3087         __ bind(slow_case);</span>
<span class="line-added">3088 #endif // LP64</span>
<span class="line-added">3089           __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_value_field),</span>
<span class="line-added">3090                  obj, flags2);</span>
<span class="line-added">3091 #ifdef _LP64</span>
<span class="line-added">3092           __ bind(finish);</span>
<span class="line-added">3093 #endif // _LP64</span>
<span class="line-added">3094           __ verify_oop(rax);</span>
<span class="line-added">3095           __ push(atos);</span>
<span class="line-added">3096           __ jmp(Done);</span>
<span class="line-added">3097     } else {</span>
<span class="line-added">3098       Label isFlattened, nonnull, isFlattenable, rewriteFlattenable;</span>
<span class="line-added">3099       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="line-added">3100         // Non-flattenable field case, also covers the object case</span>
<span class="line-added">3101         pop_and_check_object(obj);</span>
<span class="line-added">3102         __ load_heap_oop(rax, field);</span>
<span class="line-added">3103         __ push(atos);</span>
<span class="line-added">3104         if (rc == may_rewrite) {</span>
<span class="line-added">3105           patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span>
<span class="line-added">3106         }</span>
<span class="line-added">3107         __ jmp(Done);</span>
<span class="line-added">3108       __ bind(isFlattenable);</span>
<span class="line-added">3109         __ test_field_is_flattened(flags2, rscratch1, isFlattened);</span>
<span class="line-added">3110           // Non-flattened field case</span>
<span class="line-added">3111           __ movptr(rax, rcx);  // small dance required to preserve the klass_holder somewhere</span>
<span class="line-added">3112           pop_and_check_object(obj);</span>
<span class="line-added">3113           __ push(rax);</span>
<span class="line-added">3114           __ load_heap_oop(rax, field);</span>
<span class="line-added">3115           __ pop(rcx);</span>
<span class="line-added">3116           __ testptr(rax, rax);</span>
<span class="line-added">3117           __ jcc(Assembler::notZero, nonnull);</span>
<span class="line-added">3118             __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3119             __ get_value_field_klass(rcx, flags2, rbx);</span>
<span class="line-added">3120             __ get_default_value_oop(rbx, rcx, rax);</span>
<span class="line-added">3121           __ bind(nonnull);</span>
<span class="line-added">3122           __ verify_oop(rax);</span>
<span class="line-added">3123           __ push(atos);</span>
<span class="line-added">3124           __ jmp(rewriteFlattenable);</span>
<span class="line-added">3125         __ bind(isFlattened);</span>
<span class="line-added">3126           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3127           pop_and_check_object(rax);</span>
<span class="line-added">3128           __ read_flattened_field(rcx, flags2, rbx, rax);</span>
<span class="line-added">3129           __ verify_oop(rax);</span>
<span class="line-added">3130           __ push(atos);</span>
<span class="line-added">3131       __ bind(rewriteFlattenable);</span>
<span class="line-added">3132       if (rc == may_rewrite) {</span>
<span class="line-added">3133         patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);</span>
<span class="line-added">3134       }</span>
<span class="line-added">3135       __ jmp(Done);</span>
<span class="line-added">3136     }</span>
3137   }

3138 
3139   __ bind(notObj);
<span class="line-added">3140 </span>
<span class="line-added">3141   if (!is_static) pop_and_check_object(obj);</span>
<span class="line-added">3142 </span>
3143   __ cmpl(flags, itos);
3144   __ jcc(Assembler::notEqual, notInt);
3145   // itos
3146   __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3147   __ push(itos);
3148   // Rewrite bytecode to be faster
3149   if (!is_static &amp;&amp; rc == may_rewrite) {
3150     patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
3151   }
3152   __ jmp(Done);
3153 
3154   __ bind(notInt);
3155   __ cmpl(flags, ctos);
3156   __ jcc(Assembler::notEqual, notChar);
3157   // ctos
3158   __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
3159   __ push(ctos);
3160   // Rewrite bytecode to be faster
3161   if (!is_static &amp;&amp; rc == may_rewrite) {
3162     patch_bytecode(Bytecodes::_fast_cgetfield, bc, rbx);
</pre>
<hr />
<pre>
3222 #endif
3223 
3224   __ bind(Done);
3225   // [jk] not needed currently
3226   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadLoad |
3227   //                                              Assembler::LoadStore));
3228 }
3229 
3230 void TemplateTable::getfield(int byte_no) {
3231   getfield_or_static(byte_no, false);
3232 }
3233 
3234 void TemplateTable::nofast_getfield(int byte_no) {
3235   getfield_or_static(byte_no, false, may_not_rewrite);
3236 }
3237 
3238 void TemplateTable::getstatic(int byte_no) {
3239   getfield_or_static(byte_no, true);
3240 }
3241 
<span class="line-added">3242 void TemplateTable::withfield() {</span>
<span class="line-added">3243   transition(vtos, atos);</span>
<span class="line-added">3244 </span>
<span class="line-added">3245   Register cache = LP64_ONLY(c_rarg1) NOT_LP64(rcx);</span>
<span class="line-added">3246   Register index = LP64_ONLY(c_rarg2) NOT_LP64(rdx);</span>
<span class="line-added">3247 </span>
<span class="line-added">3248   resolve_cache_and_index(f2_byte, cache, index, sizeof(u2));</span>
<span class="line-added">3249 </span>
<span class="line-added">3250   call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cache);</span>
<span class="line-added">3251   // new value type is returned in rbx</span>
<span class="line-added">3252   // stack adjustement is returned in rax</span>
<span class="line-added">3253   __ verify_oop(rbx);</span>
<span class="line-added">3254   __ addptr(rsp, rax);</span>
<span class="line-added">3255   __ movptr(rax, rbx);</span>
<span class="line-added">3256 }</span>
3257 
3258 // The registers cache and index expected to be set before call.
3259 // The function may destroy various registers, just not the cache and index registers.
3260 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
3261 
3262   const Register robj = LP64_ONLY(c_rarg2)   NOT_LP64(rax);
3263   const Register RBX  = LP64_ONLY(c_rarg1)   NOT_LP64(rbx);
3264   const Register RCX  = LP64_ONLY(c_rarg3)   NOT_LP64(rcx);
3265   const Register RDX  = LP64_ONLY(rscratch1) NOT_LP64(rdx);
3266 
3267   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
3268 
3269   if (JvmtiExport::can_post_field_modification()) {
3270     // Check to see if a field modification watch has been set before
3271     // we take the time to call into the VM.
3272     Label L1;
3273     assert_different_registers(cache, index, rax);
3274     __ mov32(rax, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3275     __ testl(rax, rax);
3276     __ jcc(Assembler::zero, L1);
</pre>
<hr />
<pre>
3332     // c_rarg1: object pointer set up above (NULL if static)
3333     // c_rarg2: cache entry pointer
3334     // c_rarg3: jvalue object on the stack
3335     __ call_VM(noreg,
3336                CAST_FROM_FN_PTR(address,
3337                                 InterpreterRuntime::post_field_modification),
3338                RBX, robj, RCX);
3339     __ get_cache_and_index_at_bcp(cache, index, 1);
3340     __ bind(L1);
3341   }
3342 }
3343 
3344 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
3345   transition(vtos, vtos);
3346 
3347   const Register cache = rcx;
3348   const Register index = rdx;
3349   const Register obj   = rcx;
3350   const Register off   = rbx;
3351   const Register flags = rax;
<span class="line-added">3352   const Register flags2 = rdx;</span>
3353 
3354   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3355   jvmti_post_field_mod(cache, index, is_static);
3356   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3357 
3358   // [jk] not needed currently
3359   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3360   //                                              Assembler::StoreStore));
3361 
3362   Label notVolatile, Done;
3363   __ movl(rdx, flags);
3364   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3365   __ andl(rdx, 0x1);
3366 
3367   // Check for volatile store
3368   __ testl(rdx, rdx);
<span class="line-added">3369   __ movl(flags2, flags);</span>
3370   __ jcc(Assembler::zero, notVolatile);
3371 
<span class="line-modified">3372   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);</span>
3373   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3374                                                Assembler::StoreStore));
3375   __ jmp(Done);
3376   __ bind(notVolatile);
3377 
<span class="line-modified">3378   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);</span>
3379 
3380   __ bind(Done);
3381 }
3382 
3383 void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
<span class="line-modified">3384                                               Register obj, Register off, Register flags, Register flags2) {</span>
3385 
3386   // field addresses
3387   const Address field(obj, off, Address::times_1, 0*wordSize);
3388   NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
3389 
3390   Label notByte, notBool, notInt, notShort, notChar,
<span class="line-modified">3391         notLong, notFloat, notObj, notValueType;</span>
3392   Label Done;
3393 
3394   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3395 
3396   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3397 
3398   assert(btos == 0, &quot;change code, btos != 0&quot;);
3399   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3400   __ jcc(Assembler::notZero, notByte);
3401 
3402   // btos
3403   {
3404     __ pop(btos);
3405     if (!is_static) pop_and_check_object(obj);
3406     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3407     if (!is_static &amp;&amp; rc == may_rewrite) {
3408       patch_bytecode(Bytecodes::_fast_bputfield, bc, rbx, true, byte_no);
3409     }
3410     __ jmp(Done);
3411   }
</pre>
<hr />
<pre>
3414   __ cmpl(flags, ztos);
3415   __ jcc(Assembler::notEqual, notBool);
3416 
3417   // ztos
3418   {
3419     __ pop(ztos);
3420     if (!is_static) pop_and_check_object(obj);
3421     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3422     if (!is_static &amp;&amp; rc == may_rewrite) {
3423       patch_bytecode(Bytecodes::_fast_zputfield, bc, rbx, true, byte_no);
3424     }
3425     __ jmp(Done);
3426   }
3427 
3428   __ bind(notBool);
3429   __ cmpl(flags, atos);
3430   __ jcc(Assembler::notEqual, notObj);
3431 
3432   // atos
3433   {
<span class="line-modified">3434     if (!EnableValhalla) {</span>
<span class="line-modified">3435       __ pop(atos);</span>
<span class="line-modified">3436       if (!is_static) pop_and_check_object(obj);</span>
<span class="line-modified">3437       // Store into the field</span>
<span class="line-modified">3438       do_oop_store(_masm, field, rax);</span>
<span class="line-modified">3439       if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="line-added">3440         patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);</span>
<span class="line-added">3441       }</span>
<span class="line-added">3442       __ jmp(Done);</span>
<span class="line-added">3443     } else {</span>
<span class="line-added">3444       __ pop(atos);</span>
<span class="line-added">3445       if (is_static) {</span>
<span class="line-added">3446         Label notFlattenable, notBuffered;</span>
<span class="line-added">3447         __ test_field_is_not_flattenable(flags2, rscratch1, notFlattenable);</span>
<span class="line-added">3448         __ null_check(rax);</span>
<span class="line-added">3449         __ bind(notFlattenable);</span>
<span class="line-added">3450         do_oop_store(_masm, field, rax);</span>
<span class="line-added">3451         __ jmp(Done);</span>
<span class="line-added">3452       } else {</span>
<span class="line-added">3453         Label isFlattenable, isFlattened, notBuffered, notBuffered2, rewriteNotFlattenable, rewriteFlattenable;</span>
<span class="line-added">3454         __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="line-added">3455         // Not flattenable case, covers not flattenable values and objects</span>
<span class="line-added">3456         pop_and_check_object(obj);</span>
<span class="line-added">3457         // Store into the field</span>
<span class="line-added">3458         do_oop_store(_masm, field, rax);</span>
<span class="line-added">3459         __ bind(rewriteNotFlattenable);</span>
<span class="line-added">3460         if (rc == may_rewrite) {</span>
<span class="line-added">3461           patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);</span>
<span class="line-added">3462         }</span>
<span class="line-added">3463         __ jmp(Done);</span>
<span class="line-added">3464         // Implementation of the flattenable semantic</span>
<span class="line-added">3465         __ bind(isFlattenable);</span>
<span class="line-added">3466         __ null_check(rax);</span>
<span class="line-added">3467         __ test_field_is_flattened(flags2, rscratch1, isFlattened);</span>
<span class="line-added">3468         // Not flattened case</span>
<span class="line-added">3469         pop_and_check_object(obj);</span>
<span class="line-added">3470         // Store into the field</span>
<span class="line-added">3471         do_oop_store(_masm, field, rax);</span>
<span class="line-added">3472         __ jmp(rewriteFlattenable);</span>
<span class="line-added">3473         __ bind(isFlattened);</span>
<span class="line-added">3474         pop_and_check_object(obj);</span>
<span class="line-added">3475         assert_different_registers(rax, rdx, obj, off);</span>
<span class="line-added">3476         __ load_klass(rdx, rax);</span>
<span class="line-added">3477         __ data_for_oop(rax, rax, rdx);</span>
<span class="line-added">3478         __ addptr(obj, off);</span>
<span class="line-added">3479         __ access_value_copy(IN_HEAP, rax, obj, rdx);</span>
<span class="line-added">3480         __ bind(rewriteFlattenable);</span>
<span class="line-added">3481         if (rc == may_rewrite) {</span>
<span class="line-added">3482           patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);</span>
<span class="line-added">3483         }</span>
<span class="line-added">3484         __ jmp(Done);</span>
<span class="line-added">3485       }</span>
3486     }

3487   }
3488 
3489   __ bind(notObj);
3490   __ cmpl(flags, itos);
3491   __ jcc(Assembler::notEqual, notInt);
3492 
3493   // itos
3494   {
3495     __ pop(itos);
3496     if (!is_static) pop_and_check_object(obj);
3497     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3498     if (!is_static &amp;&amp; rc == may_rewrite) {
3499       patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
3500     }
3501     __ jmp(Done);
3502   }
3503 
3504   __ bind(notInt);
3505   __ cmpl(flags, ctos);
3506   __ jcc(Assembler::notEqual, notChar);
</pre>
<hr />
<pre>
3605 }
3606 
3607 void TemplateTable::jvmti_post_fast_field_mod() {
3608 
3609   const Register scratch = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3610 
3611   if (JvmtiExport::can_post_field_modification()) {
3612     // Check to see if a field modification watch has been set before
3613     // we take the time to call into the VM.
3614     Label L2;
3615     __ mov32(scratch, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3616     __ testl(scratch, scratch);
3617     __ jcc(Assembler::zero, L2);
3618     __ pop_ptr(rbx);                  // copy the object pointer from tos
3619     __ verify_oop(rbx);
3620     __ push_ptr(rbx);                 // put the object pointer back on tos
3621     // Save tos values before call_VM() clobbers them. Since we have
3622     // to do it for every data type, we use the saved values as the
3623     // jvalue object.
3624     switch (bytecode()) {          // load values into the jvalue object
<span class="line-added">3625     case Bytecodes::_fast_qputfield: //fall through</span>
3626     case Bytecodes::_fast_aputfield: __ push_ptr(rax); break;
3627     case Bytecodes::_fast_bputfield: // fall through
3628     case Bytecodes::_fast_zputfield: // fall through
3629     case Bytecodes::_fast_sputfield: // fall through
3630     case Bytecodes::_fast_cputfield: // fall through
3631     case Bytecodes::_fast_iputfield: __ push_i(rax); break;
3632     case Bytecodes::_fast_dputfield: __ push(dtos); break;
3633     case Bytecodes::_fast_fputfield: __ push(ftos); break;
3634     case Bytecodes::_fast_lputfield: __ push_l(rax); break;
3635 
3636     default:
3637       ShouldNotReachHere();
3638     }
3639     __ mov(scratch, rsp);             // points to jvalue on the stack
3640     // access constant pool cache entry
3641     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rax, 1));
3642     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rax, rdx, 1));
3643     __ verify_oop(rbx);
3644     // rbx: object pointer copied above
3645     // c_rarg2: cache entry pointer
3646     // c_rarg3: jvalue object on the stack
3647     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));
3648     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));
3649 
3650     switch (bytecode()) {             // restore tos values
<span class="line-added">3651     case Bytecodes::_fast_qputfield: // fall through</span>
3652     case Bytecodes::_fast_aputfield: __ pop_ptr(rax); break;
3653     case Bytecodes::_fast_bputfield: // fall through
3654     case Bytecodes::_fast_zputfield: // fall through
3655     case Bytecodes::_fast_sputfield: // fall through
3656     case Bytecodes::_fast_cputfield: // fall through
3657     case Bytecodes::_fast_iputfield: __ pop_i(rax); break;
3658     case Bytecodes::_fast_dputfield: __ pop(dtos); break;
3659     case Bytecodes::_fast_fputfield: __ pop(ftos); break;
3660     case Bytecodes::_fast_lputfield: __ pop_l(rax); break;
3661     default: break;
3662     }
3663     __ bind(L2);
3664   }
3665 }
3666 
3667 void TemplateTable::fast_storefield(TosState state) {
3668   transition(state, vtos);
3669 
3670   ByteSize base = ConstantPoolCache::base_offset();
3671 
3672   jvmti_post_fast_field_mod();
3673 
3674   // access constant pool cache
3675   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3676 
3677   // test for volatile with rdx but rdx is tos register for lputfield.
3678   __ movl(rdx, Address(rcx, rbx, Address::times_ptr,
3679                        in_bytes(base +
3680                                 ConstantPoolCacheEntry::flags_offset())));
3681 
3682   // replace index with field offset from cache entry
3683   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,
3684                          in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3685 
3686   // [jk] not needed currently
3687   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3688   //                                              Assembler::StoreStore));
3689 
3690   Label notVolatile, Done;
<span class="line-added">3691   if (bytecode() == Bytecodes::_fast_qputfield) {</span>
<span class="line-added">3692     __ movl(rscratch2, rdx);  // saving flags for isFlattened test</span>
<span class="line-added">3693   }</span>
<span class="line-added">3694 </span>
3695   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3696   __ andl(rdx, 0x1);
3697 
3698   // Get object from stack
3699   pop_and_check_object(rcx);
3700 
3701   // field address
3702   const Address field(rcx, rbx, Address::times_1);
3703 
3704   // Check for volatile store
3705   __ testl(rdx, rdx);
3706   __ jcc(Assembler::zero, notVolatile);
3707 
<span class="line-modified">3708   if (bytecode() == Bytecodes::_fast_qputfield) {</span>
<span class="line-added">3709     __ movl(rdx, rscratch2);  // restoring flags for isFlattened test</span>
<span class="line-added">3710   }</span>
<span class="line-added">3711   fast_storefield_helper(field, rax, rdx);</span>
3712   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3713                                                Assembler::StoreStore));
3714   __ jmp(Done);
3715   __ bind(notVolatile);
3716 
<span class="line-modified">3717   if (bytecode() == Bytecodes::_fast_qputfield) {</span>
<span class="line-added">3718     __ movl(rdx, rscratch2);  // restoring flags for isFlattened test</span>
<span class="line-added">3719   }</span>
<span class="line-added">3720   fast_storefield_helper(field, rax, rdx);</span>
3721 
3722   __ bind(Done);
3723 }
3724 
<span class="line-modified">3725 void TemplateTable::fast_storefield_helper(Address field, Register rax, Register flags) {</span>
3726 
3727   // access field
3728   switch (bytecode()) {
<span class="line-added">3729   case Bytecodes::_fast_qputfield:</span>
<span class="line-added">3730     {</span>
<span class="line-added">3731       Label isFlattened, done;</span>
<span class="line-added">3732       __ null_check(rax);</span>
<span class="line-added">3733       __ test_field_is_flattened(flags, rscratch1, isFlattened);</span>
<span class="line-added">3734       // No Flattened case</span>
<span class="line-added">3735       do_oop_store(_masm, field, rax);</span>
<span class="line-added">3736       __ jmp(done);</span>
<span class="line-added">3737       __ bind(isFlattened);</span>
<span class="line-added">3738       // Flattened case</span>
<span class="line-added">3739       __ load_klass(rdx, rax);</span>
<span class="line-added">3740       __ data_for_oop(rax, rax, rdx);</span>
<span class="line-added">3741       __ lea(rcx, field);</span>
<span class="line-added">3742       __ access_value_copy(IN_HEAP, rax, rcx, rdx);</span>
<span class="line-added">3743       __ bind(done);</span>
<span class="line-added">3744     }</span>
<span class="line-added">3745     break;</span>
3746   case Bytecodes::_fast_aputfield:
<span class="line-modified">3747     {</span>
<span class="line-added">3748       do_oop_store(_masm, field, rax);</span>
<span class="line-added">3749     }</span>
3750     break;
3751   case Bytecodes::_fast_lputfield:
3752 #ifdef _LP64
3753     __ access_store_at(T_LONG, IN_HEAP, field, noreg /* ltos */, noreg, noreg);
3754 #else
3755   __ stop(&quot;should not be rewritten&quot;);
3756 #endif
3757     break;
3758   case Bytecodes::_fast_iputfield:
3759     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3760     break;
3761   case Bytecodes::_fast_zputfield:
3762     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3763     break;
3764   case Bytecodes::_fast_bputfield:
3765     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3766     break;
3767   case Bytecodes::_fast_sputfield:
3768     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3769     break;
</pre>
<hr />
<pre>
3799     __ push_ptr(rax);  // save object pointer before call_VM() clobbers it
3800     LP64_ONLY(__ mov(c_rarg1, rax));
3801     // c_rarg1: object pointer copied above
3802     // c_rarg2: cache entry pointer
3803     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2));
3804     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), rax, rcx));
3805     __ pop_ptr(rax); // restore object pointer
3806     __ bind(L1);
3807   }
3808 
3809   // access constant pool cache
3810   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3811   // replace index with field offset from cache entry
3812   // [jk] not needed currently
3813   // __ movl(rdx, Address(rcx, rbx, Address::times_8,
3814   //                      in_bytes(ConstantPoolCache::base_offset() +
3815   //                               ConstantPoolCacheEntry::flags_offset())));
3816   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3817   // __ andl(rdx, 0x1);
3818   //
<span class="line-modified">3819   __ movptr(rdx, Address(rcx, rbx, Address::times_ptr,</span>
3820                          in_bytes(ConstantPoolCache::base_offset() +
3821                                   ConstantPoolCacheEntry::f2_offset())));
3822 
3823   // rax: object
3824   __ verify_oop(rax);
3825   __ null_check(rax);
<span class="line-modified">3826   Address field(rax, rdx, Address::times_1);</span>
3827 
3828   // access field
3829   switch (bytecode()) {
<span class="line-added">3830   case Bytecodes::_fast_qgetfield:</span>
<span class="line-added">3831     {</span>
<span class="line-added">3832       Label isFlattened, nonnull, Done;</span>
<span class="line-added">3833       __ movptr(rscratch1, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3834                                    in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3835                                             ConstantPoolCacheEntry::flags_offset())));</span>
<span class="line-added">3836       __ test_field_is_flattened(rscratch1, rscratch2, isFlattened);</span>
<span class="line-added">3837         // Non-flattened field case</span>
<span class="line-added">3838         __ load_heap_oop(rax, field);</span>
<span class="line-added">3839         __ testptr(rax, rax);</span>
<span class="line-added">3840         __ jcc(Assembler::notZero, nonnull);</span>
<span class="line-added">3841           __ movl(rdx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3842                              in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3843                                       ConstantPoolCacheEntry::flags_offset())));</span>
<span class="line-added">3844           __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3845           __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3846                                        in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3847                                                 ConstantPoolCacheEntry::f1_offset())));</span>
<span class="line-added">3848           __ get_value_field_klass(rcx, rdx, rbx);</span>
<span class="line-added">3849           __ get_default_value_oop(rbx, rcx, rax);</span>
<span class="line-added">3850         __ bind(nonnull);</span>
<span class="line-added">3851         __ verify_oop(rax);</span>
<span class="line-added">3852         __ jmp(Done);</span>
<span class="line-added">3853       __ bind(isFlattened);</span>
<span class="line-added">3854         __ push(rdx); // save offset</span>
<span class="line-added">3855         __ movl(rdx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3856                            in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3857                                     ConstantPoolCacheEntry::flags_offset())));</span>
<span class="line-added">3858         __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3859         __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3860                                      in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3861                                               ConstantPoolCacheEntry::f1_offset())));</span>
<span class="line-added">3862         __ pop(rbx); // restore offset</span>
<span class="line-added">3863         __ read_flattened_field(rcx, rdx, rbx, rax);</span>
<span class="line-added">3864       __ bind(Done);</span>
<span class="line-added">3865       __ verify_oop(rax);</span>
<span class="line-added">3866     }</span>
<span class="line-added">3867     break;</span>
3868   case Bytecodes::_fast_agetfield:
3869     do_oop_load(_masm, field, rax);
3870     __ verify_oop(rax);
3871     break;
3872   case Bytecodes::_fast_lgetfield:
3873 #ifdef _LP64
3874     __ access_load_at(T_LONG, IN_HEAP, noreg /* ltos */, field, noreg, noreg);
3875 #else
3876   __ stop(&quot;should not be rewritten&quot;);
3877 #endif
3878     break;
3879   case Bytecodes::_fast_igetfield:
3880     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3881     break;
3882   case Bytecodes::_fast_bgetfield:
3883     __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3884     break;
3885   case Bytecodes::_fast_sgetfield:
3886     __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3887     break;
</pre>
<hr />
<pre>
4319 
4320   // Note:  rax_callsite is already pushed by prepare_invoke
4321 
4322   // %%% should make a type profile for any invokedynamic that takes a ref argument
4323   // profile this call
4324   __ profile_call(rbcp);
4325   __ profile_arguments_type(rdx, rbx_method, rbcp, false);
4326 
4327   __ verify_oop(rax_callsite);
4328 
4329   __ jump_from_interpreted(rbx_method, rdx);
4330 }
4331 
4332 //-----------------------------------------------------------------------------
4333 // Allocation
4334 
4335 void TemplateTable::_new() {
4336   transition(vtos, atos);
4337   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
4338   Label slow_case;
<span class="line-modified">4339   Label done;</span>


4340   Label is_not_value;
4341 
4342   __ get_cpool_and_tags(rcx, rax);
4343 
4344   // Make sure the class we&#39;re about to instantiate has been resolved.
4345   // This is done before loading InstanceKlass to be consistent with the order
4346   // how Constant Pool is updated (see ConstantPool::klass_at_put)
4347   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
4348   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);
<span class="line-modified">4349   __ jcc(Assembler::notEqual, slow_case);</span>
4350 
4351   // get InstanceKlass
4352   __ load_resolved_klass_at_index(rcx, rcx, rdx);
<span class="line-modified">4353 </span>
<span class="line-added">4354   __ movl(rdx, Address(rcx, InstanceKlass::misc_flags_offset()));</span>
<span class="line-added">4355   __ andl(rdx, InstanceKlass::_misc_kind_field_mask);</span>
<span class="line-added">4356   __ cmpl(rdx, InstanceKlass::_misc_kind_value_type);</span>
<span class="line-added">4357   __ jcc(Assembler::notEqual, is_not_value);</span>
<span class="line-added">4358 </span>
<span class="line-added">4359   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));</span>
<span class="line-added">4360 </span>
<span class="line-added">4361   __ bind(is_not_value);</span>
4362 
4363   // make sure klass is initialized &amp; doesn&#39;t have finalizer

4364   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
4365   __ jcc(Assembler::notEqual, slow_case);
4366 
<span class="line-modified">4367   __ allocate_instance(rcx, rax, rdx, rbx, true, slow_case);</span>
<span class="line-modified">4368   __ jmp(done);</span>

















4369 
<span class="line-modified">4370   // slow case</span>
<span class="line-modified">4371   __ bind(slow_case);</span>
4372 
<span class="line-modified">4373   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);</span>
<span class="line-modified">4374   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);</span>




4375 
<span class="line-modified">4376   __ get_constant_pool(rarg1);</span>
<span class="line-modified">4377   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);</span>
<span class="line-modified">4378   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);</span>
<span class="line-modified">4379    __ verify_oop(rax);</span>











4380 
<span class="line-modified">4381   // continue</span>
<span class="line-modified">4382   __ bind(done);</span>
<span class="line-modified">4383 }</span>





















4384 
<span class="line-modified">4385 void TemplateTable::defaultvalue() {</span>
<span class="line-modified">4386   transition(vtos, atos);</span>






4387 
<span class="line-modified">4388   Label slow_case;</span>
<span class="line-modified">4389   Label done;</span>
<span class="line-modified">4390   Label is_value;</span>













4391 
<span class="line-modified">4392   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);</span>
<span class="line-modified">4393   __ get_cpool_and_tags(rcx, rax);</span>






4394 
<span class="line-modified">4395   // Make sure the class we&#39;re about to instantiate has been resolved.</span>
<span class="line-modified">4396   // This is done before loading InstanceKlass to be consistent with the order</span>
<span class="line-added">4397   // how Constant Pool is updated (see ConstantPool::klass_at_put)</span>
<span class="line-added">4398   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();</span>
<span class="line-added">4399   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);</span>
<span class="line-added">4400   __ jcc(Assembler::notEqual, slow_case);</span>
<span class="line-added">4401 </span>
<span class="line-added">4402   // get InstanceKlass</span>
<span class="line-added">4403   __ load_resolved_klass_at_index(rcx, rcx, rdx);</span>
<span class="line-added">4404 </span>
<span class="line-added">4405   __ movl(rdx, Address(rcx, InstanceKlass::misc_flags_offset()));</span>
<span class="line-added">4406   __ andl(rdx, InstanceKlass::_misc_kind_field_mask);</span>
<span class="line-added">4407   __ cmpl(rdx, InstanceKlass::_misc_kind_value_type);</span>
<span class="line-added">4408   __ jcc(Assembler::equal, is_value);</span>
<span class="line-added">4409 </span>
<span class="line-added">4410   // in the future, defaultvalue will just return null instead of throwing an exception</span>
<span class="line-added">4411   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeError));</span>
<span class="line-added">4412 </span>
<span class="line-added">4413   __ bind(is_value);</span>
<span class="line-added">4414 </span>
<span class="line-added">4415   // make sure klass is fully initialized</span>
<span class="line-added">4416   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);</span>
<span class="line-added">4417   __ jcc(Assembler::notEqual, slow_case);</span>
<span class="line-added">4418 </span>
<span class="line-added">4419   // have a resolved ValueKlass in rcx, return the default value oop from it</span>
<span class="line-added">4420   __ get_default_value_oop(rcx, rdx, rax);</span>
<span class="line-added">4421   __ jmp(done);</span>
4422 
<span class="line-modified">4423   __ bind(slow_case);</span>



4424 
4425   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4426   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4427 
<span class="line-modified">4428   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);</span>
<span class="line-modified">4429   __ get_constant_pool(rarg1);</span>
<span class="line-modified">4430 </span>
<span class="line-added">4431   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::defaultvalue),</span>
4432       rarg1, rarg2);
4433 
<span class="line-modified">4434   __ bind(done);</span>
4435   __ verify_oop(rax);
4436 }
4437 
4438 void TemplateTable::newarray() {
4439   transition(itos, atos);
4440   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4441   __ load_unsigned_byte(rarg1, at_bcp(1));
4442   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
4443           rarg1, rax);
4444 }
4445 
4446 void TemplateTable::anewarray() {
4447   transition(itos, atos);
4448 
4449   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4450   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4451 
4452   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4453   __ get_constant_pool(rarg1);
4454   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
4455           rarg1, rarg2, rax);
4456 }
4457 
4458 void TemplateTable::arraylength() {
4459   transition(atos, itos);
4460   __ null_check(rax, arrayOopDesc::length_offset_in_bytes());
4461   __ movl(rax, Address(rax, arrayOopDesc::length_offset_in_bytes()));
4462 }
4463 
4464 void TemplateTable::checkcast() {
4465   transition(atos, atos);
4466   Label done, is_null, ok_is_subtype, quicked, resolved;
4467   __ testptr(rax, rax); // object is in rax
4468   __ jcc(Assembler::zero, is_null);
4469 
4470   // Get cpool &amp; tags index
4471   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4472   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4473   // See if bytecode has already been quicked
<span class="line-modified">4474   __ movzbl(rdx, Address(rdx, rbx,</span>
<span class="line-modified">4475       Address::times_1,</span>
<span class="line-modified">4476       Array&lt;u1&gt;::base_offset_in_bytes()));</span>
<span class="line-modified">4477   __ andl (rdx, ~JVM_CONSTANT_QDescBit);</span>
<span class="line-added">4478   __ cmpl(rdx, JVM_CONSTANT_Class);</span>
4479   __ jcc(Assembler::equal, quicked);
4480   __ push(atos); // save receiver for result, and for GC
4481   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4482 
4483   // vm_result_2 has metadata result
4484 #ifndef _LP64
4485   // borrow rdi from locals
4486   __ get_thread(rdi);
4487   __ get_vm_result_2(rax, rdi);
4488   __ restore_locals();
4489 #else
4490   __ get_vm_result_2(rax, r15_thread);
4491 #endif
4492 
4493   __ pop_ptr(rdx); // restore receiver
4494   __ jmpb(resolved);
4495 
4496   // Get superklass in rax and subklass in rbx
4497   __ bind(quicked);
4498   __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
4499   __ load_resolved_klass_at_index(rax, rcx, rbx);
4500 
4501   __ bind(resolved);
4502   __ load_klass(rbx, rdx);
4503 
4504   // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
4505   // Superklass in rax.  Subklass in rbx.
4506   __ gen_subtype_check(rbx, ok_is_subtype);
4507 
4508   // Come here on failure
4509   __ push_ptr(rdx);
4510   // object is at TOS
4511   __ jump(ExternalAddress(Interpreter::_throw_ClassCastException_entry));
4512 
4513   // Come here on success
4514   __ bind(ok_is_subtype);
4515   __ mov(rax, rdx); // Restore object in rdx
<span class="line-added">4516   __ jmp(done);</span>
<span class="line-added">4517 </span>
<span class="line-added">4518   __ bind(is_null);</span>
4519 
4520   // Collect counts on whether this check-cast sees NULLs a lot or not.
4521   if (ProfileInterpreter) {
<span class="line-modified">4522     __ profile_null_seen(rcx);</span>
<span class="line-modified">4523   }</span>
<span class="line-modified">4524 </span>
<span class="line-modified">4525   if (EnableValhalla) {</span>
<span class="line-added">4526     // Get cpool &amp; tags index</span>
<span class="line-added">4527     __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array</span>
<span class="line-added">4528     __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index</span>
<span class="line-added">4529     // See if CP entry is a Q-descriptor</span>
<span class="line-added">4530     __ movzbl(rcx, Address(rdx, rbx,</span>
<span class="line-added">4531         Address::times_1,</span>
<span class="line-added">4532         Array&lt;u1&gt;::base_offset_in_bytes()));</span>
<span class="line-added">4533     __ andl (rcx, JVM_CONSTANT_QDescBit);</span>
<span class="line-added">4534     __ cmpl(rcx, JVM_CONSTANT_QDescBit);</span>
<span class="line-added">4535     __ jcc(Assembler::notEqual, done);</span>
<span class="line-added">4536     __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));</span>
4537   }
4538 
4539   __ bind(done);
4540 }
4541 
4542 void TemplateTable::instanceof() {
4543   transition(atos, itos);
4544   Label done, is_null, ok_is_subtype, quicked, resolved;
4545   __ testptr(rax, rax);
4546   __ jcc(Assembler::zero, is_null);
4547 
4548   // Get cpool &amp; tags index
4549   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4550   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4551   // See if bytecode has already been quicked
<span class="line-modified">4552   __ movzbl(rdx, Address(rdx, rbx,</span>
<span class="line-modified">4553         Address::times_1,</span>
<span class="line-modified">4554         Array&lt;u1&gt;::base_offset_in_bytes()));</span>
<span class="line-modified">4555   __ andl (rdx, ~JVM_CONSTANT_QDescBit);</span>
<span class="line-added">4556   __ cmpl(rdx, JVM_CONSTANT_Class);</span>
4557   __ jcc(Assembler::equal, quicked);
4558 
4559   __ push(atos); // save receiver for result, and for GC
4560   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4561   // vm_result_2 has metadata result
4562 
4563 #ifndef _LP64
4564   // borrow rdi from locals
4565   __ get_thread(rdi);
4566   __ get_vm_result_2(rax, rdi);
4567   __ restore_locals();
4568 #else
4569   __ get_vm_result_2(rax, r15_thread);
4570 #endif
4571 
4572   __ pop_ptr(rdx); // restore receiver
4573   __ verify_oop(rdx);
4574   __ load_klass(rdx, rdx);
4575   __ jmpb(resolved);
4576 
</pre>
<hr />
<pre>
4588   // Come here on failure
4589   __ xorl(rax, rax);
4590   __ jmpb(done);
4591   // Come here on success
4592   __ bind(ok_is_subtype);
4593   __ movl(rax, 1);
4594 
4595   // Collect counts on whether this test sees NULLs a lot or not.
4596   if (ProfileInterpreter) {
4597     __ jmp(done);
4598     __ bind(is_null);
4599     __ profile_null_seen(rcx);
4600   } else {
4601     __ bind(is_null);   // same as &#39;done&#39;
4602   }
4603   __ bind(done);
4604   // rax = 0: obj == NULL or  obj is not an instanceof the specified klass
4605   // rax = 1: obj != NULL and obj is     an instanceof the specified klass
4606 }
4607 

4608 //----------------------------------------------------------------------------------------------------
4609 // Breakpoints
4610 void TemplateTable::_breakpoint() {
4611   // Note: We get here even if we are single stepping..
4612   // jbug insists on setting breakpoints at every bytecode
4613   // even if we are in single step mode.
4614 
4615   transition(vtos, vtos);
4616 
4617   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4618 
4619   // get the unpatched byte code
4620   __ get_method(rarg);
4621   __ call_VM(noreg,
4622              CAST_FROM_FN_PTR(address,
4623                               InterpreterRuntime::get_original_bytecode_at),
4624              rarg, rbcp);
4625   __ mov(rbx, rax);  // why?
4626 
4627   // post the breakpoint event
</pre>
<hr />
<pre>
4651 //
4652 // Stack layout:
4653 //
4654 // [expressions  ] &lt;--- rsp               = expression stack top
4655 // ..
4656 // [expressions  ]
4657 // [monitor entry] &lt;--- monitor block top = expression stack bot
4658 // ..
4659 // [monitor entry]
4660 // [frame data   ] &lt;--- monitor block bot
4661 // ...
4662 // [saved rbp    ] &lt;--- rbp
4663 void TemplateTable::monitorenter() {
4664   transition(atos, vtos);
4665 
4666   // check for NULL object
4667   __ null_check(rax);
4668 
4669   __ resolve(IS_NOT_NULL, rax);
4670 
<span class="line-added">4671   const int is_value_mask = markWord::always_locked_pattern;</span>
<span class="line-added">4672   Label has_identity;</span>
<span class="line-added">4673   __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">4674   __ andptr(rbx, is_value_mask);</span>
<span class="line-added">4675   __ cmpl(rbx, is_value_mask);</span>
<span class="line-added">4676   __ jcc(Assembler::notEqual, has_identity);</span>
<span class="line-added">4677   __ call_VM(noreg, CAST_FROM_FN_PTR(address,</span>
<span class="line-added">4678                      InterpreterRuntime::throw_illegal_monitor_state_exception));</span>
<span class="line-added">4679   __ should_not_reach_here();</span>
<span class="line-added">4680   __ bind(has_identity);</span>
<span class="line-added">4681 </span>
4682   const Address monitor_block_top(
4683         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4684   const Address monitor_block_bot(
4685         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4686   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4687 
4688   Label allocated;
4689 
4690   Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
4691   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4692   Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4693 
4694   // initialize entry pointer
4695   __ xorl(rmon, rmon); // points to free slot or NULL
4696 
4697   // find a free slot in the monitor block (result in rmon)
4698   {
4699     Label entry, loop, exit;
4700     __ movptr(rtop, monitor_block_top); // points to current entry,
4701                                         // starting with top-most entry
</pre>
<hr />
<pre>
4761   __ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);
4762   __ lock_object(rmon);
4763 
4764   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4765   __ save_bcp();  // in case of exception
4766   __ generate_stack_overflow_check(0);
4767 
4768   // The bcp has already been incremented. Just need to dispatch to
4769   // next instruction.
4770   __ dispatch_next(vtos);
4771 }
4772 
4773 void TemplateTable::monitorexit() {
4774   transition(atos, vtos);
4775 
4776   // check for NULL object
4777   __ null_check(rax);
4778 
4779   __ resolve(IS_NOT_NULL, rax);
4780 
<span class="line-added">4781   const int is_value_mask = markWord::always_locked_pattern;</span>
<span class="line-added">4782   Label has_identity;</span>
<span class="line-added">4783   __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">4784   __ andptr(rbx, is_value_mask);</span>
<span class="line-added">4785   __ cmpl(rbx, is_value_mask);</span>
<span class="line-added">4786   __ jcc(Assembler::notEqual, has_identity);</span>
<span class="line-added">4787   __ call_VM(noreg, CAST_FROM_FN_PTR(address,</span>
<span class="line-added">4788                      InterpreterRuntime::throw_illegal_monitor_state_exception));</span>
<span class="line-added">4789   __ should_not_reach_here();</span>
<span class="line-added">4790   __ bind(has_identity);</span>
<span class="line-added">4791 </span>
4792   const Address monitor_block_top(
4793         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4794   const Address monitor_block_bot(
4795         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4796   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4797 
4798   Register rtop = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4799   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4800 
4801   Label found;
4802 
4803   // find matching slot
4804   {
4805     Label entry, loop;
4806     __ movptr(rtop, monitor_block_top); // points to current entry,
4807                                         // starting with top-most entry
4808     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4809                                         // of monitor block
4810     __ jmpb(entry);
4811 
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_32.ad.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // X86 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // architecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // Previously set EBX, ESI, and EDI as save-on-entry for java code
   64 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   65 // Now that allocator is better, turn on ESI and EDI as SOE registers.
   66 
   67 reg_def EBX(SOC, SOE, Op_RegI, 3, rbx-&gt;as_VMReg());
   68 reg_def ECX(SOC, SOC, Op_RegI, 1, rcx-&gt;as_VMReg());
   69 reg_def ESI(SOC, SOE, Op_RegI, 6, rsi-&gt;as_VMReg());
   70 reg_def EDI(SOC, SOE, Op_RegI, 7, rdi-&gt;as_VMReg());
   71 // now that adapter frames are gone EBP is always saved and restored by the prolog/epilog code
   72 reg_def EBP(NS, SOE, Op_RegI, 5, rbp-&gt;as_VMReg());
   73 reg_def EDX(SOC, SOC, Op_RegI, 2, rdx-&gt;as_VMReg());
   74 reg_def EAX(SOC, SOC, Op_RegI, 0, rax-&gt;as_VMReg());
   75 reg_def ESP( NS,  NS, Op_RegI, 4, rsp-&gt;as_VMReg());
   76 
   77 // Float registers.  We treat TOS/FPR0 special.  It is invisible to the
   78 // allocator, and only shows up in the encodings.
   79 reg_def FPR0L( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   80 reg_def FPR0H( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   81 // Ok so here&#39;s the trick FPR1 is really st(0) except in the midst
   82 // of emission of assembly for a machnode. During the emission the fpu stack
   83 // is pushed making FPR1 == st(1) temporarily. However at any safepoint
   84 // the stack will not have this element so FPR1 == st(0) from the
   85 // oopMap viewpoint. This same weirdness with numbering causes
   86 // instruction encoding to have to play games with the register
   87 // encode to correct for this 0/1 issue. See MachSpillCopyNode::implementation
   88 // where it does flt-&gt;flt moves to see an example
   89 //
   90 reg_def FPR1L( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg());
   91 reg_def FPR1H( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg()-&gt;next());
   92 reg_def FPR2L( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg());
   93 reg_def FPR2H( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg()-&gt;next());
   94 reg_def FPR3L( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg());
   95 reg_def FPR3H( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg()-&gt;next());
   96 reg_def FPR4L( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg());
   97 reg_def FPR4H( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg()-&gt;next());
   98 reg_def FPR5L( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg());
   99 reg_def FPR5H( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg()-&gt;next());
  100 reg_def FPR6L( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg());
  101 reg_def FPR6H( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg()-&gt;next());
  102 reg_def FPR7L( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg());
  103 reg_def FPR7H( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg()-&gt;next());
  104 //
  105 // Empty fill registers, which are never used, but supply alignment to xmm regs
  106 //
  107 reg_def FILL0( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());
  108 reg_def FILL1( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());
  109 reg_def FILL2( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());
  110 reg_def FILL3( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());
  111 reg_def FILL4( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());
  112 reg_def FILL5( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());
  113 reg_def FILL6( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());
  114 reg_def FILL7( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());
  115 
  116 // Specify priority of register selection within phases of register
  117 // allocation.  Highest priority is first.  A useful heuristic is to
  118 // give registers a low priority when they are required by machine
  119 // instructions, like EAX and EDX.  Registers which are used as
  120 // pairs must fall on an even boundary (witness the FPR#L&#39;s in this list).
  121 // For the Intel integer registers, the equivalent Long pairs are
  122 // EDX:EAX, EBX:ECX, and EDI:EBP.
  123 alloc_class chunk0( ECX,   EBX,   EBP,   EDI,   EAX,   EDX,   ESI, ESP,
  124                     FPR0L, FPR0H, FPR1L, FPR1H, FPR2L, FPR2H,
  125                     FPR3L, FPR3H, FPR4L, FPR4H, FPR5L, FPR5H,
  126                     FPR6L, FPR6H, FPR7L, FPR7H,
  127                     FILL0, FILL1, FILL2, FILL3, FILL4, FILL5, FILL6, FILL7);
  128 
  129 
  130 //----------Architecture Description Register Classes--------------------------
  131 // Several register classes are automatically defined based upon information in
  132 // this architecture description.
  133 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  134 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  135 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  136 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  137 //
  138 // Class for no registers (empty set).
  139 reg_class no_reg();
  140 
  141 // Class for all registers
  142 reg_class any_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX, ESP);
  143 // Class for all registers (excluding EBP)
  144 reg_class any_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX, ESP);
  145 // Dynamic register class that selects at runtime between register classes
  146 // any_reg and any_no_ebp_reg (depending on the value of the flag PreserveFramePointer).
  147 // Equivalent to: return PreserveFramePointer ? any_no_ebp_reg : any_reg;
  148 reg_class_dynamic any_reg(any_reg_no_ebp, any_reg_with_ebp, %{ PreserveFramePointer %});
  149 
  150 // Class for general registers
  151 reg_class int_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX);
  152 // Class for general registers (excluding EBP).
  153 // This register class can be used for implicit null checks on win95.
  154 // It is also safe for use by tailjumps (we don&#39;t want to allocate in ebp).
  155 // Used also if the PreserveFramePointer flag is true.
  156 reg_class int_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX);
  157 // Dynamic register class that selects between int_reg and int_reg_no_ebp.
  158 reg_class_dynamic int_reg(int_reg_no_ebp, int_reg_with_ebp, %{ PreserveFramePointer %});
  159 
  160 // Class of &quot;X&quot; registers
  161 reg_class int_x_reg(EBX, ECX, EDX, EAX);
  162 
  163 // Class of registers that can appear in an address with no offset.
  164 // EBP and ESP require an extra instruction byte for zero offset.
  165 // Used in fast-unlock
  166 reg_class p_reg(EDX, EDI, ESI, EBX);
  167 
  168 // Class for general registers excluding ECX
  169 reg_class ncx_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, EBX);
  170 // Class for general registers excluding ECX (and EBP)
  171 reg_class ncx_reg_no_ebp(EAX, EDX, EDI, ESI, EBX);
  172 // Dynamic register class that selects between ncx_reg and ncx_reg_no_ebp.
  173 reg_class_dynamic ncx_reg(ncx_reg_no_ebp, ncx_reg_with_ebp, %{ PreserveFramePointer %});
  174 
  175 // Class for general registers excluding EAX
  176 reg_class nax_reg(EDX, EDI, ESI, ECX, EBX);
  177 
  178 // Class for general registers excluding EAX and EBX.
  179 reg_class nabx_reg_with_ebp(EDX, EDI, ESI, ECX, EBP);
  180 // Class for general registers excluding EAX and EBX (and EBP)
  181 reg_class nabx_reg_no_ebp(EDX, EDI, ESI, ECX);
  182 // Dynamic register class that selects between nabx_reg and nabx_reg_no_ebp.
  183 reg_class_dynamic nabx_reg(nabx_reg_no_ebp, nabx_reg_with_ebp, %{ PreserveFramePointer %});
  184 
  185 // Class of EAX (for multiply and divide operations)
  186 reg_class eax_reg(EAX);
  187 
  188 // Class of EBX (for atomic add)
  189 reg_class ebx_reg(EBX);
  190 
  191 // Class of ECX (for shift and JCXZ operations and cmpLTMask)
  192 reg_class ecx_reg(ECX);
  193 
  194 // Class of EDX (for multiply and divide operations)
  195 reg_class edx_reg(EDX);
  196 
  197 // Class of EDI (for synchronization)
  198 reg_class edi_reg(EDI);
  199 
  200 // Class of ESI (for synchronization)
  201 reg_class esi_reg(ESI);
  202 
  203 // Singleton class for stack pointer
  204 reg_class sp_reg(ESP);
  205 
  206 // Singleton class for instruction pointer
  207 // reg_class ip_reg(EIP);
  208 
  209 // Class of integer register pairs
  210 reg_class long_reg_with_ebp( EAX,EDX, ECX,EBX, EBP,EDI );
  211 // Class of integer register pairs (excluding EBP and EDI);
  212 reg_class long_reg_no_ebp( EAX,EDX, ECX,EBX );
  213 // Dynamic register class that selects between long_reg and long_reg_no_ebp.
  214 reg_class_dynamic long_reg(long_reg_no_ebp, long_reg_with_ebp, %{ PreserveFramePointer %});
  215 
  216 // Class of integer register pairs that aligns with calling convention
  217 reg_class eadx_reg( EAX,EDX );
  218 reg_class ebcx_reg( ECX,EBX );
  219 
  220 // Not AX or DX, used in divides
  221 reg_class nadx_reg_with_ebp(EBX, ECX, ESI, EDI, EBP);
  222 // Not AX or DX (and neither EBP), used in divides
  223 reg_class nadx_reg_no_ebp(EBX, ECX, ESI, EDI);
  224 // Dynamic register class that selects between nadx_reg and nadx_reg_no_ebp.
  225 reg_class_dynamic nadx_reg(nadx_reg_no_ebp, nadx_reg_with_ebp, %{ PreserveFramePointer %});
  226 
  227 // Floating point registers.  Notice FPR0 is not a choice.
  228 // FPR0 is not ever allocated; we use clever encodings to fake
  229 // a 2-address instructions out of Intels FP stack.
  230 reg_class fp_flt_reg( FPR1L,FPR2L,FPR3L,FPR4L,FPR5L,FPR6L,FPR7L );
  231 
  232 reg_class fp_dbl_reg( FPR1L,FPR1H, FPR2L,FPR2H, FPR3L,FPR3H,
  233                       FPR4L,FPR4H, FPR5L,FPR5H, FPR6L,FPR6H,
  234                       FPR7L,FPR7H );
  235 
  236 reg_class fp_flt_reg0( FPR1L );
  237 reg_class fp_dbl_reg0( FPR1L,FPR1H );
  238 reg_class fp_dbl_reg1( FPR2L,FPR2H );
  239 reg_class fp_dbl_notreg0( FPR2L,FPR2H, FPR3L,FPR3H, FPR4L,FPR4H,
  240                           FPR5L,FPR5H, FPR6L,FPR6H, FPR7L,FPR7H );
  241 
  242 %}
  243 
  244 
  245 //----------SOURCE BLOCK-------------------------------------------------------
  246 // This is a block of C++ code which provides values, functions, and
  247 // definitions necessary in the rest of the architecture description
  248 source_hpp %{
  249 // Must be visible to the DFA in dfa_x86_32.cpp
  250 extern bool is_operand_hi32_zero(Node* n);
  251 %}
  252 
  253 source %{
  254 #define   RELOC_IMM32    Assembler::imm_operand
  255 #define   RELOC_DISP32   Assembler::disp32_operand
  256 
  257 #define __ _masm.
  258 
  259 // How to find the high register of a Long pair, given the low register
  260 #define   HIGH_FROM_LOW(x) ((x)+2)
  261 
  262 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  263 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  264 // fast versions of NegF/NegD and AbsF/AbsD.
  265 
  266 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  267 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  268   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  269   // of 128-bits operands for SSE instructions.
  270   jlong *operand = (jlong*)(((uintptr_t)adr)&amp;((uintptr_t)(~0xF)));
  271   // Store the value to a 128-bits operand.
  272   operand[0] = lo;
  273   operand[1] = hi;
  274   return operand;
  275 }
  276 
  277 // Buffer for 128-bits masks used by SSE instructions.
  278 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  279 
  280 // Static initialization during VM startup.
  281 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2], CONST64(0x7FFFFFFF7FFFFFFF), CONST64(0x7FFFFFFF7FFFFFFF));
  282 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2], CONST64(0x7FFFFFFFFFFFFFFF), CONST64(0x7FFFFFFFFFFFFFFF));
  283 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], CONST64(0x8000000080000000), CONST64(0x8000000080000000));
  284 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], CONST64(0x8000000000000000), CONST64(0x8000000000000000));
  285 
  286 // Offset hacking within calls.
  287 static int pre_call_resets_size() {
  288   int size = 0;
  289   Compile* C = Compile::current();
  290   if (C-&gt;in_24_bit_fp_mode()) {
  291     size += 6; // fldcw
  292   }
  293   if (VM_Version::supports_vzeroupper()) {
  294     size += 3; // vzeroupper
  295   }
  296   return size;
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 
  317 //
  318 // Compute padding required for nodes which need alignment
  319 //
  320 
  321 // The address of the call instruction needs to be 4-byte aligned to
  322 // ensure that it does not span a cache line so that it can be patched.
  323 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  324   current_offset += pre_call_resets_size();  // skip fldcw, if any
  325   current_offset += 1;      // skip call opcode byte
  326   return align_up(current_offset, alignment_required()) - current_offset;
  327 }
  328 
  329 // The address of the call instruction needs to be 4-byte aligned to
  330 // ensure that it does not span a cache line so that it can be patched.
  331 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  332   current_offset += pre_call_resets_size();  // skip fldcw, if any
  333   current_offset += 5;      // skip MOV instruction
  334   current_offset += 1;      // skip call opcode byte
  335   return align_up(current_offset, alignment_required()) - current_offset;
  336 }
  337 
  338 // EMIT_RM()
  339 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  340   unsigned char c = (unsigned char)((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  341   cbuf.insts()-&gt;emit_int8(c);
  342 }
  343 
  344 // EMIT_CC()
  345 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  346   unsigned char c = (unsigned char)( f1 | f2 );
  347   cbuf.insts()-&gt;emit_int8(c);
  348 }
  349 
  350 // EMIT_OPCODE()
  351 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  352   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  353 }
  354 
  355 // EMIT_OPCODE() w/ relocation information
  356 void emit_opcode(CodeBuffer &amp;cbuf, int code, relocInfo::relocType reloc, int offset = 0) {
  357   cbuf.relocate(cbuf.insts_mark() + offset, reloc);
  358   emit_opcode(cbuf, code);
  359 }
  360 
  361 // EMIT_D8()
  362 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  363   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  364 }
  365 
  366 // EMIT_D16()
  367 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  368   cbuf.insts()-&gt;emit_int16(d16);
  369 }
  370 
  371 // EMIT_D32()
  372 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  373   cbuf.insts()-&gt;emit_int32(d32);
  374 }
  375 
  376 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  377 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, relocInfo::relocType reloc,
  378         int format) {
  379   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  380   cbuf.insts()-&gt;emit_int32(d32);
  381 }
  382 
  383 // emit 32 bit value and construct relocation entry from RelocationHolder
  384 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, RelocationHolder const&amp; rspec,
  385         int format) {
  386 #ifdef ASSERT
  387   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp; d32 != 0 &amp;&amp; d32 != (int)Universe::non_oop_word()) {
  388     assert(oopDesc::is_oop(cast_to_oop(d32)), &quot;cannot embed broken oops in code&quot;);
  389   }
  390 #endif
  391   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  392   cbuf.insts()-&gt;emit_int32(d32);
  393 }
  394 
  395 // Access stack slot for load or store
  396 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp) {
  397   emit_opcode( cbuf, opcode );               // (e.g., FILD   [ESP+src])
  398   if( -128 &lt;= disp &amp;&amp; disp &lt;= 127 ) {
  399     emit_rm( cbuf, 0x01, rm_field, ESP_enc );  // R/M byte
  400     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  401     emit_d8 (cbuf, disp);     // Displacement  // R/M byte
  402   } else {
  403     emit_rm( cbuf, 0x02, rm_field, ESP_enc );  // R/M byte
  404     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  405     emit_d32(cbuf, disp);     // Displacement  // R/M byte
  406   }
  407 }
  408 
  409    // rRegI ereg, memory mem) %{    // emit_reg_mem
  410 void encode_RegMem( CodeBuffer &amp;cbuf, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {
  411   // There is no index &amp; no scale, use form without SIB byte
  412   if ((index == 0x4) &amp;&amp;
  413       (scale == 0) &amp;&amp; (base != ESP_enc)) {
  414     // If no displacement, mode is 0x0; unless base is [EBP]
  415     if ( (displace == 0) &amp;&amp; (base != EBP_enc) ) {
  416       emit_rm(cbuf, 0x0, reg_encoding, base);
  417     }
  418     else {                    // If 8-bit displacement, mode 0x1
  419       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  420           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  421         emit_rm(cbuf, 0x1, reg_encoding, base);
  422         emit_d8(cbuf, displace);
  423       }
  424       else {                  // If 32-bit displacement
  425         if (base == -1) { // Special flag for absolute address
  426           emit_rm(cbuf, 0x0, reg_encoding, 0x5);
  427           // (manual lies; no SIB needed here)
  428           if ( disp_reloc != relocInfo::none ) {
  429             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  430           } else {
  431             emit_d32      (cbuf, displace);
  432           }
  433         }
  434         else {                // Normal base + offset
  435           emit_rm(cbuf, 0x2, reg_encoding, base);
  436           if ( disp_reloc != relocInfo::none ) {
  437             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  438           } else {
  439             emit_d32      (cbuf, displace);
  440           }
  441         }
  442       }
  443     }
  444   }
  445   else {                      // Else, encode with the SIB byte
  446     // If no displacement, mode is 0x0; unless base is [EBP]
  447     if (displace == 0 &amp;&amp; (base != EBP_enc)) {  // If no displacement
  448       emit_rm(cbuf, 0x0, reg_encoding, 0x4);
  449       emit_rm(cbuf, scale, index, base);
  450     }
  451     else {                    // If 8-bit displacement, mode 0x1
  452       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  453           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  454         emit_rm(cbuf, 0x1, reg_encoding, 0x4);
  455         emit_rm(cbuf, scale, index, base);
  456         emit_d8(cbuf, displace);
  457       }
  458       else {                  // If 32-bit displacement
  459         if (base == 0x04 ) {
  460           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  461           emit_rm(cbuf, scale, index, 0x04);
  462         } else {
  463           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  464           emit_rm(cbuf, scale, index, base);
  465         }
  466         if ( disp_reloc != relocInfo::none ) {
  467           emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  468         } else {
  469           emit_d32      (cbuf, displace);
  470         }
  471       }
  472     }
  473   }
  474 }
  475 
  476 
  477 void encode_Copy( CodeBuffer &amp;cbuf, int dst_encoding, int src_encoding ) {
  478   if( dst_encoding == src_encoding ) {
  479     // reg-reg copy, use an empty encoding
  480   } else {
  481     emit_opcode( cbuf, 0x8B );
  482     emit_rm(cbuf, 0x3, dst_encoding, src_encoding );
  483   }
  484 }
  485 
  486 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  487   Label exit;
  488   __ jccb(Assembler::noParity, exit);
  489   __ pushf();
  490   //
  491   // comiss/ucomiss instructions set ZF,PF,CF flags and
  492   // zero OF,AF,SF for NaN values.
  493   // Fixup flags by zeroing ZF,PF so that compare of NaN
  494   // values returns &#39;less than&#39; result (CF is set).
  495   // Leave the rest of flags unchanged.
  496   //
  497   //    7 6 5 4 3 2 1 0
  498   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  499   //    0 0 1 0 1 0 1 1   (0x2B)
  500   //
  501   __ andl(Address(rsp, 0), 0xffffff2b);
  502   __ popf();
  503   __ bind(exit);
  504 }
  505 
  506 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  507   Label done;
  508   __ movl(dst, -1);
  509   __ jcc(Assembler::parity, done);
  510   __ jcc(Assembler::below, done);
  511   __ setb(Assembler::notEqual, dst);
  512   __ movzbl(dst, dst);
  513   __ bind(done);
  514 }
  515 
  516 
  517 //=============================================================================
  518 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  519 
  520 int ConstantTable::calculate_table_base_offset() const {
  521   return 0;  // absolute addressing, no offset
  522 }
  523 
  524 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  525 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  526   ShouldNotReachHere();
  527 }
  528 
  529 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  530   // Empty encoding
  531 }
  532 
  533 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  534   return 0;
  535 }
  536 
  537 #ifndef PRODUCT
  538 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  539   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  540 }
  541 #endif
  542 
  543 
  544 //=============================================================================
  545 #ifndef PRODUCT
  546 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  547   Compile* C = ra_-&gt;C;
  548 
  549   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  550   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  551   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  552   // Remove wordSize for return addr which is already pushed.
  553   framesize -= wordSize;
  554 
  555   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  556     framesize -= wordSize;
  557     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  558     st-&gt;print(&quot;\n\t&quot;);
  559     st-&gt;print(&quot;PUSH   EBP\t# Save EBP&quot;);
  560     if (PreserveFramePointer) {
  561       st-&gt;print(&quot;\n\t&quot;);
  562       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  563     }
  564     if (framesize) {
  565       st-&gt;print(&quot;\n\t&quot;);
  566       st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  567     }
  568   } else {
  569     st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  570     st-&gt;print(&quot;\n\t&quot;);
  571     framesize -= wordSize;
  572     st-&gt;print(&quot;MOV    [ESP + #%d], EBP\t# Save EBP&quot;,framesize);
  573     if (PreserveFramePointer) {
  574       st-&gt;print(&quot;\n\t&quot;);
  575       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  576       if (framesize &gt; 0) {
  577         st-&gt;print(&quot;\n\t&quot;);
  578         st-&gt;print(&quot;ADD    EBP, #%d&quot;, framesize);
  579       }
  580     }
  581   }
  582 
  583   if (VerifyStackAtCalls) {
  584     st-&gt;print(&quot;\n\t&quot;);
  585     framesize -= wordSize;
  586     st-&gt;print(&quot;MOV    [ESP + #%d], 0xBADB100D\t# Majik cookie for stack depth check&quot;,framesize);
  587   }
  588 
  589   if( C-&gt;in_24_bit_fp_mode() ) {
  590     st-&gt;print(&quot;\n\t&quot;);
  591     st-&gt;print(&quot;FLDCW  \t# load 24 bit fpu control word&quot;);
  592   }
  593   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
  594     st-&gt;print(&quot;\n\t&quot;);
  595     st-&gt;print(&quot;# verify FPU stack (must be clean on entry)&quot;);
  596   }
  597 
  598 #ifdef ASSERT
  599   if (VerifyStackAtCalls) {
  600     st-&gt;print(&quot;\n\t&quot;);
  601     st-&gt;print(&quot;# stack alignment check&quot;);
  602   }
  603 #endif
  604   st-&gt;cr();
  605 }
  606 #endif
  607 
  608 
  609 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  610   Compile* C = ra_-&gt;C;
  611   MacroAssembler _masm(&amp;cbuf);
  612 
<a name="1" id="anc1"></a><span class="line-modified">  613   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-removed">  614   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-removed">  615 </span>
<span class="line-removed">  616   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, C-&gt;in_24_bit_fp_mode(), C-&gt;stub_function() != NULL);</span>
  617 
  618   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  619 
  620   if (C-&gt;has_mach_constant_base_node()) {
  621     // NOTE: We set the table base offset here because users might be
  622     // emitted before MachConstantBaseNode.
  623     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  624     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  625   }
  626 }
  627 
  628 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  629   return MachNode::size(ra_); // too many variables; just compute it the hard way
  630 }
  631 
  632 int MachPrologNode::reloc() const {
  633   return 0; // a large enough number
  634 }
  635 
  636 //=============================================================================
  637 #ifndef PRODUCT
  638 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  639   Compile *C = ra_-&gt;C;
  640   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  641   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  642   // Remove two words for return addr and rbp,
  643   framesize -= 2*wordSize;
  644 
  645   if (C-&gt;max_vector_size() &gt; 16) {
  646     st-&gt;print(&quot;VZEROUPPER&quot;);
  647     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  648   }
  649   if (C-&gt;in_24_bit_fp_mode()) {
  650     st-&gt;print(&quot;FLDCW  standard control word&quot;);
  651     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  652   }
  653   if (framesize) {
  654     st-&gt;print(&quot;ADD    ESP,%d\t# Destroy frame&quot;,framesize);
  655     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  656   }
  657   st-&gt;print_cr(&quot;POPL   EBP&quot;); st-&gt;print(&quot;\t&quot;);
  658   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  659     st-&gt;print(&quot;TEST   PollPage,EAX\t! Poll Safepoint&quot;);
  660     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  661   }
  662 }
  663 #endif
  664 
  665 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  666   Compile *C = ra_-&gt;C;
  667   MacroAssembler _masm(&amp;cbuf);
  668 
  669   if (C-&gt;max_vector_size() &gt; 16) {
  670     // Clear upper bits of YMM registers when current compiled code uses
  671     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  672     _masm.vzeroupper();
  673   }
  674   // If method set FPU control word, restore to standard control word
  675   if (C-&gt;in_24_bit_fp_mode()) {
  676     _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
  677   }
  678 
  679   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  680   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  681   // Remove two words for return addr and rbp,
  682   framesize -= 2*wordSize;
  683 
  684   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  685 
  686   if (framesize &gt;= 128) {
  687     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  688     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  689     emit_d32(cbuf, framesize);
  690   } else if (framesize) {
  691     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  692     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  693     emit_d8(cbuf, framesize);
  694   }
  695 
  696   emit_opcode(cbuf, 0x58 | EBP_enc);
  697 
  698   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  699     __ reserved_stack_check();
  700   }
  701 
  702   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  703     Register pollReg = as_Register(EBX_enc);
  704     MacroAssembler masm(&amp;cbuf);
  705     masm.get_thread(pollReg);
  706     masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));
  707     masm.relocate(relocInfo::poll_return_type);
  708     masm.testl(rax, Address(pollReg, 0));
  709   }
  710 }
  711 
  712 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  713   return MachNode::size(ra_); // too many variables; just compute it
  714                               // the hard way
  715 }
  716 
  717 int MachEpilogNode::reloc() const {
  718   return 0; // a large enough number
  719 }
  720 
  721 const Pipeline * MachEpilogNode::pipeline() const {
  722   return MachNode::pipeline_class();
  723 }
  724 
  725 //=============================================================================
  726 
  727 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  728 static enum RC rc_class( OptoReg::Name reg ) {
  729 
  730   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  731   if (OptoReg::is_stack(reg)) return rc_stack;
  732 
  733   VMReg r = OptoReg::as_VMReg(reg);
  734   if (r-&gt;is_Register()) return rc_int;
  735   if (r-&gt;is_FloatRegister()) {
  736     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  737     return rc_float;
  738   }
  739   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  740   return rc_xmm;
  741 }
  742 
  743 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  744                         int opcode, const char *op_str, int size, outputStream* st ) {
  745   if( cbuf ) {
  746     emit_opcode  (*cbuf, opcode );
  747     encode_RegMem(*cbuf, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);
  748 #ifndef PRODUCT
  749   } else if( !do_size ) {
  750     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  751     if( opcode == 0x8B || opcode == 0x89 ) { // MOV
  752       if( is_load ) st-&gt;print(&quot;%s   %s,[ESP + #%d]&quot;,op_str,Matcher::regName[reg],offset);
  753       else          st-&gt;print(&quot;%s   [ESP + #%d],%s&quot;,op_str,offset,Matcher::regName[reg]);
  754     } else { // FLD, FST, PUSH, POP
  755       st-&gt;print(&quot;%s [ESP + #%d]&quot;,op_str,offset);
  756     }
  757 #endif
  758   }
  759   int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  760   return size+3+offset_size;
  761 }
  762 
  763 // Helper for XMM registers.  Extra opcode bits, limited syntax.
  764 static int impl_x_helper( CodeBuffer *cbuf, bool do_size, bool is_load,
  765                          int offset, int reg_lo, int reg_hi, int size, outputStream* st ) {
  766   int in_size_in_bits = Assembler::EVEX_32bit;
  767   int evex_encoding = 0;
  768   if (reg_lo+1 == reg_hi) {
  769     in_size_in_bits = Assembler::EVEX_64bit;
  770     evex_encoding = Assembler::VEX_W;
  771   }
  772   if (cbuf) {
  773     MacroAssembler _masm(cbuf);
  774     // EVEX spills remain EVEX: Compressed displacemement is better than AVX on spill mem operations,
  775     //                          it maps more cases to single byte displacement
  776     _masm.set_managed();
  777     if (reg_lo+1 == reg_hi) { // double move?
  778       if (is_load) {
  779         __ movdbl(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  780       } else {
  781         __ movdbl(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  782       }
  783     } else {
  784       if (is_load) {
  785         __ movflt(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  786       } else {
  787         __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  788       }
  789     }
  790 #ifndef PRODUCT
  791   } else if (!do_size) {
  792     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  793     if (reg_lo+1 == reg_hi) { // double move?
  794       if (is_load) st-&gt;print(&quot;%s %s,[ESP + #%d]&quot;,
  795                               UseXmmLoadAndClearUpper ? &quot;MOVSD &quot; : &quot;MOVLPD&quot;,
  796                               Matcher::regName[reg_lo], offset);
  797       else         st-&gt;print(&quot;MOVSD  [ESP + #%d],%s&quot;,
  798                               offset, Matcher::regName[reg_lo]);
  799     } else {
  800       if (is_load) st-&gt;print(&quot;MOVSS  %s,[ESP + #%d]&quot;,
  801                               Matcher::regName[reg_lo], offset);
  802       else         st-&gt;print(&quot;MOVSS  [ESP + #%d],%s&quot;,
  803                               offset, Matcher::regName[reg_lo]);
  804     }
  805 #endif
  806   }
  807   bool is_single_byte = false;
  808   if ((UseAVX &gt; 2) &amp;&amp; (offset != 0)) {
  809     is_single_byte = Assembler::query_compressed_disp_byte(offset, true, 0, Assembler::EVEX_T1S, in_size_in_bits, evex_encoding);
  810   }
  811   int offset_size = 0;
  812   if (UseAVX &gt; 2 ) {
  813     offset_size = (offset == 0) ? 0 : ((is_single_byte) ? 1 : 4);
  814   } else {
  815     offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  816   }
  817   size += (UseAVX &gt; 2) ? 2 : 0; // Need an additional two bytes for EVEX
  818   // VEX_2bytes prefix is used if UseAVX &gt; 0, so it takes the same 2 bytes as SIMD prefix.
  819   return size+5+offset_size;
  820 }
  821 
  822 
  823 static int impl_movx_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  824                             int src_hi, int dst_hi, int size, outputStream* st ) {
  825   if (cbuf) {
  826     MacroAssembler _masm(cbuf);
  827     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  828     _masm.set_managed();
  829     if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  830       __ movdbl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  831                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  832     } else {
  833       __ movflt(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  834                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  835     }
  836 #ifndef PRODUCT
  837   } else if (!do_size) {
  838     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  839     if (UseXmmRegToRegMoveAll) {//Use movaps,movapd to move between xmm registers
  840       if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  841         st-&gt;print(&quot;MOVAPD %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  842       } else {
  843         st-&gt;print(&quot;MOVAPS %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  844       }
  845     } else {
  846       if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double move?
  847         st-&gt;print(&quot;MOVSD  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  848       } else {
  849         st-&gt;print(&quot;MOVSS  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  850       }
  851     }
  852 #endif
  853   }
  854   // VEX_2bytes prefix is used if UseAVX &gt; 0, and it takes the same 2 bytes as SIMD prefix.
  855   // Only MOVAPS SSE prefix uses 1 byte.  EVEX uses an additional 2 bytes.
  856   int sz = (UseAVX &gt; 2) ? 6 : 4;
  857   if (!(src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) &amp;&amp;
  858       UseXmmRegToRegMoveAll &amp;&amp; (UseAVX == 0)) sz = 3;
  859   return size + sz;
  860 }
  861 
  862 static int impl_movgpr2x_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  863                             int src_hi, int dst_hi, int size, outputStream* st ) {
  864   // 32-bit
  865   if (cbuf) {
  866     MacroAssembler _masm(cbuf);
  867     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  868     _masm.set_managed();
  869     __ movdl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  870              as_Register(Matcher::_regEncode[src_lo]));
  871 #ifndef PRODUCT
  872   } else if (!do_size) {
  873     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  874 #endif
  875   }
  876   return (UseAVX&gt; 2) ? 6 : 4;
  877 }
  878 
  879 
  880 static int impl_movx2gpr_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  881                                  int src_hi, int dst_hi, int size, outputStream* st ) {
  882   // 32-bit
  883   if (cbuf) {
  884     MacroAssembler _masm(cbuf);
  885     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  886     _masm.set_managed();
  887     __ movdl(as_Register(Matcher::_regEncode[dst_lo]),
  888              as_XMMRegister(Matcher::_regEncode[src_lo]));
  889 #ifndef PRODUCT
  890   } else if (!do_size) {
  891     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  892 #endif
  893   }
  894   return (UseAVX&gt; 2) ? 6 : 4;
  895 }
  896 
  897 static int impl_mov_helper( CodeBuffer *cbuf, bool do_size, int src, int dst, int size, outputStream* st ) {
  898   if( cbuf ) {
  899     emit_opcode(*cbuf, 0x8B );
  900     emit_rm    (*cbuf, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );
  901 #ifndef PRODUCT
  902   } else if( !do_size ) {
  903     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  904     st-&gt;print(&quot;MOV    %s,%s&quot;,Matcher::regName[dst],Matcher::regName[src]);
  905 #endif
  906   }
  907   return size+2;
  908 }
  909 
  910 static int impl_fp_store_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,
  911                                  int offset, int size, outputStream* st ) {
  912   if( src_lo != FPR1L_num ) {      // Move value to top of FP stack, if not already there
  913     if( cbuf ) {
  914       emit_opcode( *cbuf, 0xD9 );  // FLD (i.e., push it)
  915       emit_d8( *cbuf, 0xC0-1+Matcher::_regEncode[src_lo] );
  916 #ifndef PRODUCT
  917     } else if( !do_size ) {
  918       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  919       st-&gt;print(&quot;FLD    %s&quot;,Matcher::regName[src_lo]);
  920 #endif
  921     }
  922     size += 2;
  923   }
  924 
  925   int st_op = (src_lo != FPR1L_num) ? EBX_num /*store &amp; pop*/ : EDX_num /*store no pop*/;
  926   const char *op_str;
  927   int op;
  928   if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double store?
  929     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_D&quot; : &quot;FST_D &quot;;
  930     op = 0xDD;
  931   } else {                   // 32-bit store
  932     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_S&quot; : &quot;FST_S &quot;;
  933     op = 0xD9;
  934     assert( !OptoReg::is_valid(src_hi) &amp;&amp; !OptoReg::is_valid(dst_hi), &quot;no non-adjacent float-stores&quot; );
  935   }
  936 
  937   return impl_helper(cbuf,do_size,false,offset,st_op,op,op_str,size, st);
  938 }
  939 
  940 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
  941 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  942                           int src_hi, int dst_hi, uint ireg, outputStream* st);
  943 
  944 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
  945                             int stack_offset, int reg, uint ireg, outputStream* st);
  946 
  947 static int vec_stack_to_stack_helper(CodeBuffer *cbuf, bool do_size, int src_offset,
  948                                      int dst_offset, uint ireg, outputStream* st) {
  949   int calc_size = 0;
  950   int src_offset_size = (src_offset == 0) ? 0 : ((src_offset &lt; 0x80) ? 1 : 4);
  951   int dst_offset_size = (dst_offset == 0) ? 0 : ((dst_offset &lt; 0x80) ? 1 : 4);
  952   switch (ireg) {
  953   case Op_VecS:
  954     calc_size = 3+src_offset_size + 3+dst_offset_size;
  955     break;
  956   case Op_VecD: {
  957     calc_size = 3+src_offset_size + 3+dst_offset_size;
  958     int tmp_src_offset = src_offset + 4;
  959     int tmp_dst_offset = dst_offset + 4;
  960     src_offset_size = (tmp_src_offset == 0) ? 0 : ((tmp_src_offset &lt; 0x80) ? 1 : 4);
  961     dst_offset_size = (tmp_dst_offset == 0) ? 0 : ((tmp_dst_offset &lt; 0x80) ? 1 : 4);
  962     calc_size += 3+src_offset_size + 3+dst_offset_size;
  963     break;
  964   }
  965   case Op_VecX:
  966   case Op_VecY:
  967   case Op_VecZ:
  968     calc_size = 6 + 6 + 5+src_offset_size + 5+dst_offset_size;
  969     break;
  970   default:
  971     ShouldNotReachHere();
  972   }
  973   if (cbuf) {
  974     MacroAssembler _masm(cbuf);
  975     int offset = __ offset();
  976     switch (ireg) {
  977     case Op_VecS:
  978       __ pushl(Address(rsp, src_offset));
  979       __ popl (Address(rsp, dst_offset));
  980       break;
  981     case Op_VecD:
  982       __ pushl(Address(rsp, src_offset));
  983       __ popl (Address(rsp, dst_offset));
  984       __ pushl(Address(rsp, src_offset+4));
  985       __ popl (Address(rsp, dst_offset+4));
  986       break;
  987     case Op_VecX:
  988       __ movdqu(Address(rsp, -16), xmm0);
  989       __ movdqu(xmm0, Address(rsp, src_offset));
  990       __ movdqu(Address(rsp, dst_offset), xmm0);
  991       __ movdqu(xmm0, Address(rsp, -16));
  992       break;
  993     case Op_VecY:
  994       __ vmovdqu(Address(rsp, -32), xmm0);
  995       __ vmovdqu(xmm0, Address(rsp, src_offset));
  996       __ vmovdqu(Address(rsp, dst_offset), xmm0);
  997       __ vmovdqu(xmm0, Address(rsp, -32));
  998       break;
  999     case Op_VecZ:
 1000       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1001       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1002       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1003       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1004       break;
 1005     default:
 1006       ShouldNotReachHere();
 1007     }
 1008     int size = __ offset() - offset;
 1009     assert(size == calc_size, &quot;incorrect size calculation&quot;);
 1010     return size;
 1011 #ifndef PRODUCT
 1012   } else if (!do_size) {
 1013     switch (ireg) {
 1014     case Op_VecS:
 1015       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 32-bit mem-mem spill\n\t&quot;
 1016                 &quot;popl    [rsp + #%d]&quot;,
 1017                 src_offset, dst_offset);
 1018       break;
 1019     case Op_VecD:
 1020       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1021                 &quot;popq    [rsp + #%d]\n\t&quot;
 1022                 &quot;pushl   [rsp + #%d]\n\t&quot;
 1023                 &quot;popq    [rsp + #%d]&quot;,
 1024                 src_offset, dst_offset, src_offset+4, dst_offset+4);
 1025       break;
 1026      case Op_VecX:
 1027       st-&gt;print(&quot;movdqu  [rsp - #16], xmm0\t# 128-bit mem-mem spill\n\t&quot;
 1028                 &quot;movdqu  xmm0, [rsp + #%d]\n\t&quot;
 1029                 &quot;movdqu  [rsp + #%d], xmm0\n\t&quot;
 1030                 &quot;movdqu  xmm0, [rsp - #16]&quot;,
 1031                 src_offset, dst_offset);
 1032       break;
 1033     case Op_VecY:
 1034       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1035                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1036                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1037                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1038                 src_offset, dst_offset);
 1039       break;
 1040     case Op_VecZ:
 1041       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1042                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1043                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1044                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1045                 src_offset, dst_offset);
 1046       break;
 1047     default:
 1048       ShouldNotReachHere();
 1049     }
 1050 #endif
 1051   }
 1052   return calc_size;
 1053 }
 1054 
 1055 uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {
 1056   // Get registers to move
 1057   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1058   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1059   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this );
 1060   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this );
 1061 
 1062   enum RC src_second_rc = rc_class(src_second);
 1063   enum RC src_first_rc = rc_class(src_first);
 1064   enum RC dst_second_rc = rc_class(dst_second);
 1065   enum RC dst_first_rc = rc_class(dst_first);
 1066 
 1067   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
 1068 
 1069   // Generate spill code!
 1070   int size = 0;
 1071 
 1072   if( src_first == dst_first &amp;&amp; src_second == dst_second )
 1073     return size;            // Self copy, no move
 1074 
 1075   if (bottom_type()-&gt;isa_vect() != NULL) {
 1076     uint ireg = ideal_reg();
 1077     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1078     assert((src_first_rc != rc_float &amp;&amp; dst_first_rc != rc_float), &quot;sanity&quot;);
 1079     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1080     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1081       // mem -&gt; mem
 1082       int src_offset = ra_-&gt;reg2offset(src_first);
 1083       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1084       return vec_stack_to_stack_helper(cbuf, do_size, src_offset, dst_offset, ireg, st);
 1085     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1086       return vec_mov_helper(cbuf, do_size, src_first, dst_first, src_second, dst_second, ireg, st);
 1087     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1088       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1089       return vec_spill_helper(cbuf, do_size, false, stack_offset, src_first, ireg, st);
 1090     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_xmm ) {
 1091       int stack_offset = ra_-&gt;reg2offset(src_first);
 1092       return vec_spill_helper(cbuf, do_size, true,  stack_offset, dst_first, ireg, st);
 1093     } else {
 1094       ShouldNotReachHere();
 1095     }
 1096   }
 1097 
 1098   // --------------------------------------
 1099   // Check for mem-mem move.  push/pop to move.
 1100   if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1101     if( src_second == dst_first ) { // overlapping stack copy ranges
 1102       assert( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack, &quot;we only expect a stk-stk copy here&quot; );
 1103       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1104       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1105       src_second_rc = dst_second_rc = rc_bad;  // flag as already moved the second bits
 1106     }
 1107     // move low bits
 1108     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1109     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1110     if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) { // mov second bits
 1111       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1112       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1113     }
 1114     return size;
 1115   }
 1116 
 1117   // --------------------------------------
 1118   // Check for integer reg-reg copy
 1119   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int )
 1120     size = impl_mov_helper(cbuf,do_size,src_first,dst_first,size, st);
 1121 
 1122   // Check for integer store
 1123   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack )
 1124     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first,0x89,&quot;MOV &quot;,size, st);
 1125 
 1126   // Check for integer load
 1127   if( dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack )
 1128     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first,0x8B,&quot;MOV &quot;,size, st);
 1129 
 1130   // Check for integer reg-xmm reg copy
 1131   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_xmm ) {
 1132     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1133             &quot;no 64 bit integer-float reg moves&quot; );
 1134     return impl_movgpr2x_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1135   }
 1136   // --------------------------------------
 1137   // Check for float reg-reg copy
 1138   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1139     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1140             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second), &quot;no non-adjacent float-moves&quot; );
 1141     if( cbuf ) {
 1142 
 1143       // Note the mucking with the register encode to compensate for the 0/1
 1144       // indexing issue mentioned in a comment in the reg_def sections
 1145       // for FPR registers many lines above here.
 1146 
 1147       if( src_first != FPR1L_num ) {
 1148         emit_opcode  (*cbuf, 0xD9 );           // FLD    ST(i)
 1149         emit_d8      (*cbuf, 0xC0+Matcher::_regEncode[src_first]-1 );
 1150         emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1151         emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1152      } else {
 1153         emit_opcode  (*cbuf, 0xDD );           // FST    ST(i)
 1154         emit_d8      (*cbuf, 0xD0+Matcher::_regEncode[dst_first]-1 );
 1155      }
 1156 #ifndef PRODUCT
 1157     } else if( !do_size ) {
 1158       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1159       if( src_first != FPR1L_num ) st-&gt;print(&quot;FLD    %s\n\tFSTP   %s&quot;,Matcher::regName[src_first],Matcher::regName[dst_first]);
 1160       else                      st-&gt;print(             &quot;FST    %s&quot;,                            Matcher::regName[dst_first]);
 1161 #endif
 1162     }
 1163     return size + ((src_first != FPR1L_num) ? 2+2 : 2);
 1164   }
 1165 
 1166   // Check for float store
 1167   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1168     return impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,ra_-&gt;reg2offset(dst_first),size, st);
 1169   }
 1170 
 1171   // Check for float load
 1172   if( dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack ) {
 1173     int offset = ra_-&gt;reg2offset(src_first);
 1174     const char *op_str;
 1175     int op;
 1176     if( src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second ) { // double load?
 1177       op_str = &quot;FLD_D&quot;;
 1178       op = 0xDD;
 1179     } else {                   // 32-bit load
 1180       op_str = &quot;FLD_S&quot;;
 1181       op = 0xD9;
 1182       assert( src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad, &quot;no non-adjacent float-loads&quot; );
 1183     }
 1184     if( cbuf ) {
 1185       emit_opcode  (*cbuf, op );
 1186       encode_RegMem(*cbuf, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);
 1187       emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1188       emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1189 #ifndef PRODUCT
 1190     } else if( !do_size ) {
 1191       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1192       st-&gt;print(&quot;%s  ST,[ESP + #%d]\n\tFSTP   %s&quot;,op_str, offset,Matcher::regName[dst_first]);
 1193 #endif
 1194     }
 1195     int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
 1196     return size + 3+offset_size+2;
 1197   }
 1198 
 1199   // Check for xmm reg-reg copy
 1200   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1201     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1202             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second),
 1203             &quot;no non-adjacent float-moves&quot; );
 1204     return impl_movx_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1205   }
 1206 
 1207   // Check for xmm reg-integer reg copy
 1208   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_int ) {
 1209     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1210             &quot;no 64 bit float-integer reg moves&quot; );
 1211     return impl_movx2gpr_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1212   }
 1213 
 1214   // Check for xmm store
 1215   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1216     return impl_x_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first, src_second, size, st);
 1217   }
 1218 
 1219   // Check for float xmm load
 1220   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_stack ) {
 1221     return impl_x_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first, dst_second, size, st);
 1222   }
 1223 
 1224   // Copy from float reg to xmm reg
 1225   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_float ) {
 1226     // copy to the top of stack from floating point reg
 1227     // and use LEA to preserve flags
 1228     if( cbuf ) {
 1229       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP-8]
 1230       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1231       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1232       emit_d8(*cbuf,0xF8);
 1233 #ifndef PRODUCT
 1234     } else if( !do_size ) {
 1235       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1236       st-&gt;print(&quot;LEA    ESP,[ESP-8]&quot;);
 1237 #endif
 1238     }
 1239     size += 4;
 1240 
 1241     size = impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,0,size, st);
 1242 
 1243     // Copy from the temp memory to the xmm reg.
 1244     size = impl_x_helper(cbuf,do_size,true ,0,dst_first, dst_second, size, st);
 1245 
 1246     if( cbuf ) {
 1247       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP+8]
 1248       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1249       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1250       emit_d8(*cbuf,0x08);
 1251 #ifndef PRODUCT
 1252     } else if( !do_size ) {
 1253       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1254       st-&gt;print(&quot;LEA    ESP,[ESP+8]&quot;);
 1255 #endif
 1256     }
 1257     size += 4;
 1258     return size;
 1259   }
 1260 
 1261   assert( size &gt; 0, &quot;missed a case&quot; );
 1262 
 1263   // --------------------------------------------------------------------
 1264   // Check for second bits still needing moving.
 1265   if( src_second == dst_second )
 1266     return size;               // Self copy; no move
 1267   assert( src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot; );
 1268 
 1269   // Check for second word int-int move
 1270   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_int )
 1271     return impl_mov_helper(cbuf,do_size,src_second,dst_second,size, st);
 1272 
 1273   // Check for second word integer store
 1274   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_stack )
 1275     return impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),src_second,0x89,&quot;MOV &quot;,size, st);
 1276 
 1277   // Check for second word integer load
 1278   if( dst_second_rc == rc_int &amp;&amp; src_second_rc == rc_stack )
 1279     return impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),dst_second,0x8B,&quot;MOV &quot;,size, st);
 1280 
 1281 
 1282   Unimplemented();
 1283   return 0; // Mute compiler
 1284 }
 1285 
 1286 #ifndef PRODUCT
 1287 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1288   implementation( NULL, ra_, false, st );
 1289 }
 1290 #endif
 1291 
 1292 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1293   implementation( &amp;cbuf, ra_, false, NULL );
 1294 }
 1295 
 1296 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1297   return MachNode::size(ra_);
 1298 }
 1299 
 1300 
 1301 //=============================================================================
 1302 #ifndef PRODUCT
 1303 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1304   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1305   int reg = ra_-&gt;get_reg_first(this);
 1306   st-&gt;print(&quot;LEA    %s,[ESP + #%d]&quot;,Matcher::regName[reg],offset);
 1307 }
 1308 #endif
 1309 
 1310 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1311   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1312   int reg = ra_-&gt;get_encode(this);
 1313   if( offset &gt;= 128 ) {
 1314     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1315     emit_rm(cbuf, 0x2, reg, 0x04);
 1316     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1317     emit_d32(cbuf, offset);
 1318   }
 1319   else {
 1320     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1321     emit_rm(cbuf, 0x1, reg, 0x04);
 1322     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1323     emit_d8(cbuf, offset);
 1324   }
 1325 }
 1326 
 1327 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1328   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1329   if( offset &gt;= 128 ) {
 1330     return 7;
 1331   }
 1332   else {
 1333     return 4;
 1334   }
 1335 }
 1336 
 1337 //=============================================================================
 1338 #ifndef PRODUCT
 1339 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1340   st-&gt;print_cr(  &quot;CMP    EAX,[ECX+4]\t# Inline cache check&quot;);
 1341   st-&gt;print_cr(&quot;\tJNE    SharedRuntime::handle_ic_miss_stub&quot;);
 1342   st-&gt;print_cr(&quot;\tNOP&quot;);
 1343   st-&gt;print_cr(&quot;\tNOP&quot;);
 1344   if( !OptoBreakpoint )
 1345     st-&gt;print_cr(&quot;\tNOP&quot;);
 1346 }
 1347 #endif
 1348 
 1349 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1350   MacroAssembler masm(&amp;cbuf);
 1351 #ifdef ASSERT
 1352   uint insts_size = cbuf.insts_size();
 1353 #endif
 1354   masm.cmpptr(rax, Address(rcx, oopDesc::klass_offset_in_bytes()));
 1355   masm.jump_cc(Assembler::notEqual,
 1356                RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1357   /* WARNING these NOPs are critical so that verified entry point is properly
 1358      aligned for patching by NativeJump::patch_verified_entry() */
 1359   int nops_cnt = 2;
 1360   if( !OptoBreakpoint ) // Leave space for int3
 1361      nops_cnt += 1;
 1362   masm.nop(nops_cnt);
 1363 
 1364   assert(cbuf.insts_size() - insts_size == size(ra_), &quot;checking code size of inline cache node&quot;);
 1365 }
 1366 
 1367 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1368   return OptoBreakpoint ? 11 : 12;
 1369 }
 1370 
 1371 
 1372 //=============================================================================
 1373 
 1374 int Matcher::regnum_to_fpu_offset(int regnum) {
 1375   return regnum - 32; // The FP registers are in the second chunk
 1376 }
 1377 
 1378 // This is UltraSparc specific, true just means we have fast l2f conversion
 1379 const bool Matcher::convL2FSupported(void) {
 1380   return true;
 1381 }
 1382 
 1383 // Is this branch offset short enough that a short branch can be used?
 1384 //
 1385 // NOTE: If the platform does not provide any short branch variants, then
 1386 //       this method should return false for offset 0.
 1387 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1388   // The passed offset is relative to address of the branch.
 1389   // On 86 a branch displacement is calculated relative to address
 1390   // of a next instruction.
 1391   offset -= br_size;
 1392 
 1393   // the short version of jmpConUCF2 contains multiple branches,
 1394   // making the reach slightly less
 1395   if (rule == jmpConUCF2_rule)
 1396     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1397   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1398 }
 1399 
 1400 const bool Matcher::isSimpleConstant64(jlong value) {
 1401   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1402   return false;
 1403 }
 1404 
 1405 // The ecx parameter to rep stos for the ClearArray node is in dwords.
 1406 const bool Matcher::init_array_count_is_in_bytes = false;
 1407 
 1408 // Needs 2 CMOV&#39;s for longs.
 1409 const int Matcher::long_cmove_cost() { return 1; }
 1410 
 1411 // No CMOVF/CMOVD with SSE/SSE2
 1412 const int Matcher::float_cmove_cost() { return (UseSSE&gt;=1) ? ConditionalMoveLimit : 0; }
 1413 
 1414 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1415 const bool Matcher::require_postalloc_expand = false;
 1416 
 1417 // Do we need to mask the count passed to shift instructions or does
 1418 // the cpu only look at the lower 5/6 bits anyway?
 1419 const bool Matcher::need_masked_shift_count = false;
 1420 
 1421 bool Matcher::narrow_oop_use_complex_address() {
 1422   ShouldNotCallThis();
 1423   return true;
 1424 }
 1425 
 1426 bool Matcher::narrow_klass_use_complex_address() {
 1427   ShouldNotCallThis();
 1428   return true;
 1429 }
 1430 
 1431 bool Matcher::const_oop_prefer_decode() {
 1432   ShouldNotCallThis();
 1433   return true;
 1434 }
 1435 
 1436 bool Matcher::const_klass_prefer_decode() {
 1437   ShouldNotCallThis();
 1438   return true;
 1439 }
 1440 
 1441 // Is it better to copy float constants, or load them directly from memory?
 1442 // Intel can load a float constant from a direct address, requiring no
 1443 // extra registers.  Most RISCs will have to materialize an address into a
 1444 // register first, so they would do better to copy the constant from stack.
 1445 const bool Matcher::rematerialize_float_constants = true;
 1446 
 1447 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1448 // needed.  Else we split the double into 2 integer pieces and move it
 1449 // piece-by-piece.  Only happens when passing doubles into C code as the
 1450 // Java calling convention forces doubles to be aligned.
 1451 const bool Matcher::misaligned_doubles_ok = true;
 1452 
 1453 
 1454 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1455   // Get the memory operand from the node
 1456   uint numopnds = node-&gt;num_opnds();        // Virtual call for number of operands
 1457   uint skipped  = node-&gt;oper_input_base();  // Sum of leaves skipped so far
 1458   assert( idx &gt;= skipped, &quot;idx too low in pd_implicit_null_fixup&quot; );
 1459   uint opcnt     = 1;                 // First operand
 1460   uint num_edges = node-&gt;_opnds[1]-&gt;num_edges(); // leaves for first operand
 1461   while( idx &gt;= skipped+num_edges ) {
 1462     skipped += num_edges;
 1463     opcnt++;                          // Bump operand count
 1464     assert( opcnt &lt; numopnds, &quot;Accessing non-existent operand&quot; );
 1465     num_edges = node-&gt;_opnds[opcnt]-&gt;num_edges(); // leaves for next operand
 1466   }
 1467 
 1468   MachOper *memory = node-&gt;_opnds[opcnt];
 1469   MachOper *new_memory = NULL;
 1470   switch (memory-&gt;opcode()) {
 1471   case DIRECT:
 1472   case INDOFFSET32X:
 1473     // No transformation necessary.
 1474     return;
 1475   case INDIRECT:
 1476     new_memory = new indirect_win95_safeOper( );
 1477     break;
 1478   case INDOFFSET8:
 1479     new_memory = new indOffset8_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1480     break;
 1481   case INDOFFSET32:
 1482     new_memory = new indOffset32_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1483     break;
 1484   case INDINDEXOFFSET:
 1485     new_memory = new indIndexOffset_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1486     break;
 1487   case INDINDEXSCALE:
 1488     new_memory = new indIndexScale_win95_safeOper(memory-&gt;scale());
 1489     break;
 1490   case INDINDEXSCALEOFFSET:
 1491     new_memory = new indIndexScaleOffset_win95_safeOper(memory-&gt;scale(), memory-&gt;disp(NULL, NULL, 0));
 1492     break;
 1493   case LOAD_LONG_INDIRECT:
 1494   case LOAD_LONG_INDOFFSET32:
 1495     // Does not use EBP as address register, use { EDX, EBX, EDI, ESI}
 1496     return;
 1497   default:
 1498     assert(false, &quot;unexpected memory operand in pd_implicit_null_fixup()&quot;);
 1499     return;
 1500   }
 1501   node-&gt;_opnds[opcnt] = new_memory;
 1502 }
 1503 
 1504 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1505 const bool Matcher::strict_fp_requires_explicit_rounding = true;
 1506 
 1507 // Are floats conerted to double when stored to stack during deoptimization?
 1508 // On x32 it is stored with convertion only when FPU is used for floats.
 1509 bool Matcher::float_in_double() { return (UseSSE == 0); }
 1510 
 1511 // Do ints take an entire long register or just half?
 1512 const bool Matcher::int_in_long = false;
 1513 
 1514 // Return whether or not this register is ever used as an argument.  This
 1515 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1516 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1517 // arguments in those registers not be available to the callee.
 1518 bool Matcher::can_be_java_arg( int reg ) {
 1519   if(  reg == ECX_num   || reg == EDX_num   ) return true;
 1520   if( (reg == XMM0_num  || reg == XMM1_num ) &amp;&amp; UseSSE&gt;=1 ) return true;
 1521   if( (reg == XMM0b_num || reg == XMM1b_num) &amp;&amp; UseSSE&gt;=2 ) return true;
 1522   return false;
 1523 }
 1524 
 1525 bool Matcher::is_spillable_arg( int reg ) {
 1526   return can_be_java_arg(reg);
 1527 }
 1528 
 1529 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1530   // Use hardware integer DIV instruction when
 1531   // it is faster than a code which use multiply.
 1532   // Only when constant divisor fits into 32 bit
 1533   // (min_jint is excluded to get only correct
 1534   // positive 32 bit values from negative).
 1535   return VM_Version::has_fast_idiv() &amp;&amp;
 1536          (divisor == (int)divisor &amp;&amp; divisor != min_jint);
 1537 }
 1538 
 1539 // Register for DIVI projection of divmodI
 1540 RegMask Matcher::divI_proj_mask() {
 1541   return EAX_REG_mask();
 1542 }
 1543 
 1544 // Register for MODI projection of divmodI
 1545 RegMask Matcher::modI_proj_mask() {
 1546   return EDX_REG_mask();
 1547 }
 1548 
 1549 // Register for DIVL projection of divmodL
 1550 RegMask Matcher::divL_proj_mask() {
 1551   ShouldNotReachHere();
 1552   return RegMask();
 1553 }
 1554 
 1555 // Register for MODL projection of divmodL
 1556 RegMask Matcher::modL_proj_mask() {
 1557   ShouldNotReachHere();
 1558   return RegMask();
 1559 }
 1560 
 1561 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1562   return NO_REG_mask();
 1563 }
 1564 
 1565 // Returns true if the high 32 bits of the value is known to be zero.
 1566 bool is_operand_hi32_zero(Node* n) {
 1567   int opc = n-&gt;Opcode();
 1568   if (opc == Op_AndL) {
 1569     Node* o2 = n-&gt;in(2);
 1570     if (o2-&gt;is_Con() &amp;&amp; (o2-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1571       return true;
 1572     }
 1573   }
 1574   if (opc == Op_ConL &amp;&amp; (n-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1575     return true;
 1576   }
 1577   return false;
 1578 }
 1579 
 1580 %}
 1581 
 1582 //----------ENCODING BLOCK-----------------------------------------------------
 1583 // This block specifies the encoding classes used by the compiler to output
 1584 // byte streams.  Encoding classes generate functions which are called by
 1585 // Machine Instruction Nodes in order to generate the bit encoding of the
 1586 // instruction.  Operands specify their base encoding interface with the
 1587 // interface keyword.  There are currently supported four interfaces,
 1588 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1589 // operand to generate a function which returns its register number when
 1590 // queried.   CONST_INTER causes an operand to generate a function which
 1591 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1592 // operand to generate four functions which return the Base Register, the
 1593 // Index Register, the Scale Value, and the Offset Value of the operand when
 1594 // queried.  COND_INTER causes an operand to generate six functions which
 1595 // return the encoding code (ie - encoding bits for the instruction)
 1596 // associated with each basic boolean condition for a conditional instruction.
 1597 // Instructions specify two basic values for encoding.  They use the
 1598 // ins_encode keyword to specify their encoding class (which must be one of
 1599 // the class names specified in the encoding block), and they use the
 1600 // opcode keyword to specify, in order, their primary, secondary, and
 1601 // tertiary opcode.  Only the opcode sections which a particular instruction
 1602 // needs for encoding need to be specified.
 1603 encode %{
 1604   // Build emit functions for each basic byte or larger field in the intel
 1605   // encoding scheme (opcode, rm, sib, immediate), and call them from C++
 1606   // code in the enc_class source block.  Emit functions will live in the
 1607   // main source block for now.  In future, we can generalize this by
 1608   // adding a syntax that specifies the sizes of fields in an order,
 1609   // so that the adlc can build the emit functions automagically
 1610 
 1611   // Emit primary opcode
 1612   enc_class OpcP %{
 1613     emit_opcode(cbuf, $primary);
 1614   %}
 1615 
 1616   // Emit secondary opcode
 1617   enc_class OpcS %{
 1618     emit_opcode(cbuf, $secondary);
 1619   %}
 1620 
 1621   // Emit opcode directly
 1622   enc_class Opcode(immI d8) %{
 1623     emit_opcode(cbuf, $d8$$constant);
 1624   %}
 1625 
 1626   enc_class SizePrefix %{
 1627     emit_opcode(cbuf,0x66);
 1628   %}
 1629 
 1630   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 1631     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1632   %}
 1633 
 1634   enc_class OpcRegReg (immI opcode, rRegI dst, rRegI src) %{    // OpcRegReg(Many)
 1635     emit_opcode(cbuf,$opcode$$constant);
 1636     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1637   %}
 1638 
 1639   enc_class mov_r32_imm0( rRegI dst ) %{
 1640     emit_opcode( cbuf, 0xB8 + $dst$$reg ); // 0xB8+ rd   -- MOV r32  ,imm32
 1641     emit_d32   ( cbuf, 0x0  );             //                         imm32==0x0
 1642   %}
 1643 
 1644   enc_class cdq_enc %{
 1645     // Full implementation of Java idiv and irem; checks for
 1646     // special case as described in JVM spec., p.243 &amp; p.271.
 1647     //
 1648     //         normal case                           special case
 1649     //
 1650     // input : rax,: dividend                         min_int
 1651     //         reg: divisor                          -1
 1652     //
 1653     // output: rax,: quotient  (= rax, idiv reg)       min_int
 1654     //         rdx: remainder (= rax, irem reg)       0
 1655     //
 1656     //  Code sequnce:
 1657     //
 1658     //  81 F8 00 00 00 80    cmp         rax,80000000h
 1659     //  0F 85 0B 00 00 00    jne         normal_case
 1660     //  33 D2                xor         rdx,edx
 1661     //  83 F9 FF             cmp         rcx,0FFh
 1662     //  0F 84 03 00 00 00    je          done
 1663     //                  normal_case:
 1664     //  99                   cdq
 1665     //  F7 F9                idiv        rax,ecx
 1666     //                  done:
 1667     //
 1668     emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);
 1669     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);
 1670     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     // cmp rax,80000000h
 1671     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);
 1672     emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);
 1673     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // jne normal_case
 1674     emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     // xor rdx,edx
 1675     emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); // cmp rcx,0FFh
 1676     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);
 1677     emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);
 1678     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // je done
 1679     // normal_case:
 1680     emit_opcode(cbuf,0x99);                                         // cdq
 1681     // idiv (note: must be emitted by the user of this rule)
 1682     // normal:
 1683   %}
 1684 
 1685   // Dense encoding for older common ops
 1686   enc_class Opc_plus(immI opcode, rRegI reg) %{
 1687     emit_opcode(cbuf, $opcode$$constant + $reg$$reg);
 1688   %}
 1689 
 1690 
 1691   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1692   enc_class OpcSE (immI imm) %{ // Emit primary opcode and set sign-extend bit
 1693     // Check for 8-bit immediate, and set sign extend bit in opcode
 1694     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1695       emit_opcode(cbuf, $primary | 0x02);
 1696     }
 1697     else {                          // If 32-bit immediate
 1698       emit_opcode(cbuf, $primary);
 1699     }
 1700   %}
 1701 
 1702   enc_class OpcSErm (rRegI dst, immI imm) %{    // OpcSEr/m
 1703     // Emit primary opcode and set sign-extend bit
 1704     // Check for 8-bit immediate, and set sign extend bit in opcode
 1705     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1706       emit_opcode(cbuf, $primary | 0x02);    }
 1707     else {                          // If 32-bit immediate
 1708       emit_opcode(cbuf, $primary);
 1709     }
 1710     // Emit r/m byte with secondary opcode, after primary opcode.
 1711     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1712   %}
 1713 
 1714   enc_class Con8or32 (immI imm) %{    // Con8or32(storeImmI), 8 or 32 bits
 1715     // Check for 8-bit immediate, and set sign extend bit in opcode
 1716     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1717       $$$emit8$imm$$constant;
 1718     }
 1719     else {                          // If 32-bit immediate
 1720       // Output immediate
 1721       $$$emit32$imm$$constant;
 1722     }
 1723   %}
 1724 
 1725   enc_class Long_OpcSErm_Lo(eRegL dst, immL imm) %{
 1726     // Emit primary opcode and set sign-extend bit
 1727     // Check for 8-bit immediate, and set sign extend bit in opcode
 1728     int con = (int)$imm$$constant; // Throw away top bits
 1729     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1730     // Emit r/m byte with secondary opcode, after primary opcode.
 1731     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1732     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1733     else                               emit_d32(cbuf,con);
 1734   %}
 1735 
 1736   enc_class Long_OpcSErm_Hi(eRegL dst, immL imm) %{
 1737     // Emit primary opcode and set sign-extend bit
 1738     // Check for 8-bit immediate, and set sign extend bit in opcode
 1739     int con = (int)($imm$$constant &gt;&gt; 32); // Throw away bottom bits
 1740     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1741     // Emit r/m byte with tertiary opcode, after primary opcode.
 1742     emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));
 1743     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1744     else                               emit_d32(cbuf,con);
 1745   %}
 1746 
 1747   enc_class OpcSReg (rRegI dst) %{    // BSWAP
 1748     emit_cc(cbuf, $secondary, $dst$$reg );
 1749   %}
 1750 
 1751   enc_class bswap_long_bytes(eRegL dst) %{ // BSWAP
 1752     int destlo = $dst$$reg;
 1753     int desthi = HIGH_FROM_LOW(destlo);
 1754     // bswap lo
 1755     emit_opcode(cbuf, 0x0F);
 1756     emit_cc(cbuf, 0xC8, destlo);
 1757     // bswap hi
 1758     emit_opcode(cbuf, 0x0F);
 1759     emit_cc(cbuf, 0xC8, desthi);
 1760     // xchg lo and hi
 1761     emit_opcode(cbuf, 0x87);
 1762     emit_rm(cbuf, 0x3, destlo, desthi);
 1763   %}
 1764 
 1765   enc_class RegOpc (rRegI div) %{    // IDIV, IMOD, JMP indirect, ...
 1766     emit_rm(cbuf, 0x3, $secondary, $div$$reg );
 1767   %}
 1768 
 1769   enc_class enc_cmov(cmpOp cop ) %{ // CMOV
 1770     $$$emit8$primary;
 1771     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 1772   %}
 1773 
 1774   enc_class enc_cmov_dpr(cmpOp cop, regDPR src ) %{ // CMOV
 1775     int op = 0xDA00 + $cop$$cmpcode + ($src$$reg-1);
 1776     emit_d8(cbuf, op &gt;&gt; 8 );
 1777     emit_d8(cbuf, op &amp; 255);
 1778   %}
 1779 
 1780   // emulate a CMOV with a conditional branch around a MOV
 1781   enc_class enc_cmov_branch( cmpOp cop, immI brOffs ) %{ // CMOV
 1782     // Invert sense of branch from sense of CMOV
 1783     emit_cc( cbuf, 0x70, ($cop$$cmpcode^1) );
 1784     emit_d8( cbuf, $brOffs$$constant );
 1785   %}
 1786 
 1787   enc_class enc_PartialSubtypeCheck( ) %{
 1788     Register Redi = as_Register(EDI_enc); // result register
 1789     Register Reax = as_Register(EAX_enc); // super class
 1790     Register Recx = as_Register(ECX_enc); // killed
 1791     Register Resi = as_Register(ESI_enc); // sub class
 1792     Label miss;
 1793 
 1794     MacroAssembler _masm(&amp;cbuf);
 1795     __ check_klass_subtype_slow_path(Resi, Reax, Recx, Redi,
 1796                                      NULL, &amp;miss,
 1797                                      /*set_cond_codes:*/ true);
 1798     if ($primary) {
 1799       __ xorptr(Redi, Redi);
 1800     }
 1801     __ bind(miss);
 1802   %}
 1803 
 1804   enc_class FFree_Float_Stack_All %{    // Free_Float_Stack_All
 1805     MacroAssembler masm(&amp;cbuf);
 1806     int start = masm.offset();
 1807     if (UseSSE &gt;= 2) {
 1808       if (VerifyFPU) {
 1809         masm.verify_FPU(0, &quot;must be empty in SSE2+ mode&quot;);
 1810       }
 1811     } else {
 1812       // External c_calling_convention expects the FPU stack to be &#39;clean&#39;.
 1813       // Compiled code leaves it dirty.  Do cleanup now.
 1814       masm.empty_FPU_stack();
 1815     }
 1816     if (sizeof_FFree_Float_Stack_All == -1) {
 1817       sizeof_FFree_Float_Stack_All = masm.offset() - start;
 1818     } else {
 1819       assert(masm.offset() - start == sizeof_FFree_Float_Stack_All, &quot;wrong size&quot;);
 1820     }
 1821   %}
 1822 
 1823   enc_class Verify_FPU_For_Leaf %{
 1824     if( VerifyFPU ) {
 1825       MacroAssembler masm(&amp;cbuf);
 1826       masm.verify_FPU( -3, &quot;Returning from Runtime Leaf call&quot;);
 1827     }
 1828   %}
 1829 
 1830   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime, Java_To_Runtime_Leaf
 1831     // This is the instruction starting address for relocation info.
 1832     cbuf.set_insts_mark();
 1833     $$$emit8$primary;
 1834     // CALL directly to the runtime
 1835     emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1836                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1837 
 1838     if (UseSSE &gt;= 2) {
 1839       MacroAssembler _masm(&amp;cbuf);
 1840       BasicType rt = tf()-&gt;return_type();
 1841 
 1842       if ((rt == T_FLOAT || rt == T_DOUBLE) &amp;&amp; !return_value_is_used()) {
 1843         // A C runtime call where the return value is unused.  In SSE2+
 1844         // mode the result needs to be removed from the FPU stack.  It&#39;s
 1845         // likely that this function call could be removed by the
 1846         // optimizer if the C function is a pure function.
 1847         __ ffree(0);
 1848       } else if (rt == T_FLOAT) {
 1849         __ lea(rsp, Address(rsp, -4));
 1850         __ fstp_s(Address(rsp, 0));
 1851         __ movflt(xmm0, Address(rsp, 0));
 1852         __ lea(rsp, Address(rsp,  4));
 1853       } else if (rt == T_DOUBLE) {
 1854         __ lea(rsp, Address(rsp, -8));
 1855         __ fstp_d(Address(rsp, 0));
 1856         __ movdbl(xmm0, Address(rsp, 0));
 1857         __ lea(rsp, Address(rsp,  8));
 1858       }
 1859     }
 1860   %}
 1861 
 1862   enc_class pre_call_resets %{
 1863     // If method sets FPU control word restore it here
 1864     debug_only(int off0 = cbuf.insts_size());
 1865     if (ra_-&gt;C-&gt;in_24_bit_fp_mode()) {
 1866       MacroAssembler _masm(&amp;cbuf);
 1867       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
 1868     }
 1869     // Clear upper bits of YMM registers when current compiled code uses
 1870     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 1871     MacroAssembler _masm(&amp;cbuf);
 1872     __ vzeroupper();
 1873     debug_only(int off1 = cbuf.insts_size());
 1874     assert(off1 - off0 == pre_call_resets_size(), &quot;correct size prediction&quot;);
 1875   %}
 1876 
 1877   enc_class post_call_FPU %{
 1878     // If method sets FPU control word do it here also
 1879     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
 1880       MacroAssembler masm(&amp;cbuf);
 1881       masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 1882     }
 1883   %}
 1884 
 1885   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 1886     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1887     // who we intended to call.
 1888     cbuf.set_insts_mark();
 1889     $$$emit8$primary;
 1890 
 1891     if (!_method) {
 1892       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1893                      runtime_call_Relocation::spec(),
 1894                      RELOC_IMM32);
 1895     } else {
 1896       int method_index = resolved_method_index(cbuf);
 1897       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1898                                                   : static_call_Relocation::spec(method_index);
 1899       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1900                      rspec, RELOC_DISP32);
 1901       // Emit stubs for static call.
 1902       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1903       if (stub == NULL) {
 1904         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1905         return;
 1906       }
 1907     }
 1908   %}
 1909 
 1910   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
 1911     MacroAssembler _masm(&amp;cbuf);
 1912     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 1913   %}
 1914 
 1915   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
 1916     int disp = in_bytes(Method::from_compiled_offset());
 1917     assert( -128 &lt;= disp &amp;&amp; disp &lt;= 127, &quot;compiled_code_offset isn&#39;t small&quot;);
 1918 
 1919     // CALL *[EAX+in_bytes(Method::from_compiled_code_entry_point_offset())]
 1920     cbuf.set_insts_mark();
 1921     $$$emit8$primary;
 1922     emit_rm(cbuf, 0x01, $secondary, EAX_enc );  // R/M byte
 1923     emit_d8(cbuf, disp);             // Displacement
 1924 
 1925   %}
 1926 
 1927 //   Following encoding is no longer used, but may be restored if calling
 1928 //   convention changes significantly.
 1929 //   Became: Xor_Reg(EBP), Java_To_Runtime( labl )
 1930 //
 1931 //   enc_class Java_Interpreter_Call (label labl) %{    // JAVA INTERPRETER CALL
 1932 //     // int ic_reg     = Matcher::inline_cache_reg();
 1933 //     // int ic_encode  = Matcher::_regEncode[ic_reg];
 1934 //     // int imo_reg    = Matcher::interpreter_method_oop_reg();
 1935 //     // int imo_encode = Matcher::_regEncode[imo_reg];
 1936 //
 1937 //     // // Interpreter expects method_oop in EBX, currently a callee-saved register,
 1938 //     // // so we load it immediately before the call
 1939 //     // emit_opcode(cbuf, 0x8B);                     // MOV    imo_reg,ic_reg  # method_oop
 1940 //     // emit_rm(cbuf, 0x03, imo_encode, ic_encode ); // R/M byte
 1941 //
 1942 //     // xor rbp,ebp
 1943 //     emit_opcode(cbuf, 0x33);
 1944 //     emit_rm(cbuf, 0x3, EBP_enc, EBP_enc);
 1945 //
 1946 //     // CALL to interpreter.
 1947 //     cbuf.set_insts_mark();
 1948 //     $$$emit8$primary;
 1949 //     emit_d32_reloc(cbuf, ($labl$$label - (int)(cbuf.insts_end()) - 4),
 1950 //                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1951 //   %}
 1952 
 1953   enc_class RegOpcImm (rRegI dst, immI8 shift) %{    // SHL, SAR, SHR
 1954     $$$emit8$primary;
 1955     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1956     $$$emit8$shift$$constant;
 1957   %}
 1958 
 1959   enc_class LdImmI (rRegI dst, immI src) %{    // Load Immediate
 1960     // Load immediate does not have a zero or sign extended version
 1961     // for 8-bit immediates
 1962     emit_opcode(cbuf, 0xB8 + $dst$$reg);
 1963     $$$emit32$src$$constant;
 1964   %}
 1965 
 1966   enc_class LdImmP (rRegI dst, immI src) %{    // Load Immediate
 1967     // Load immediate does not have a zero or sign extended version
 1968     // for 8-bit immediates
 1969     emit_opcode(cbuf, $primary + $dst$$reg);
 1970     $$$emit32$src$$constant;
 1971   %}
 1972 
 1973   enc_class LdImmL_Lo( eRegL dst, immL src) %{    // Load Immediate
 1974     // Load immediate does not have a zero or sign extended version
 1975     // for 8-bit immediates
 1976     int dst_enc = $dst$$reg;
 1977     int src_con = $src$$constant &amp; 0x0FFFFFFFFL;
 1978     if (src_con == 0) {
 1979       // xor dst, dst
 1980       emit_opcode(cbuf, 0x33);
 1981       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 1982     } else {
 1983       emit_opcode(cbuf, $primary + dst_enc);
 1984       emit_d32(cbuf, src_con);
 1985     }
 1986   %}
 1987 
 1988   enc_class LdImmL_Hi( eRegL dst, immL src) %{    // Load Immediate
 1989     // Load immediate does not have a zero or sign extended version
 1990     // for 8-bit immediates
 1991     int dst_enc = $dst$$reg + 2;
 1992     int src_con = ((julong)($src$$constant)) &gt;&gt; 32;
 1993     if (src_con == 0) {
 1994       // xor dst, dst
 1995       emit_opcode(cbuf, 0x33);
 1996       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 1997     } else {
 1998       emit_opcode(cbuf, $primary + dst_enc);
 1999       emit_d32(cbuf, src_con);
 2000     }
 2001   %}
 2002 
 2003 
 2004   // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2005   enc_class enc_Copy( rRegI dst, rRegI src ) %{
 2006     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2007   %}
 2008 
 2009   enc_class enc_CopyL_Lo( rRegI dst, eRegL src ) %{
 2010     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2011   %}
 2012 
 2013   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 2014     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2015   %}
 2016 
 2017   enc_class RegReg_Lo(eRegL dst, eRegL src) %{    // RegReg(Many)
 2018     $$$emit8$primary;
 2019     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2020   %}
 2021 
 2022   enc_class RegReg_Hi(eRegL dst, eRegL src) %{    // RegReg(Many)
 2023     $$$emit8$secondary;
 2024     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2025   %}
 2026 
 2027   enc_class RegReg_Lo2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2028     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2029   %}
 2030 
 2031   enc_class RegReg_Hi2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2032     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2033   %}
 2034 
 2035   enc_class RegReg_HiLo( eRegL src, rRegI dst ) %{
 2036     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));
 2037   %}
 2038 
 2039   enc_class Con32 (immI src) %{    // Con32(storeImmI)
 2040     // Output immediate
 2041     $$$emit32$src$$constant;
 2042   %}
 2043 
 2044   enc_class Con32FPR_as_bits(immFPR src) %{        // storeF_imm
 2045     // Output Float immediate bits
 2046     jfloat jf = $src$$constant;
 2047     int    jf_as_bits = jint_cast( jf );
 2048     emit_d32(cbuf, jf_as_bits);
 2049   %}
 2050 
 2051   enc_class Con32F_as_bits(immF src) %{      // storeX_imm
 2052     // Output Float immediate bits
 2053     jfloat jf = $src$$constant;
 2054     int    jf_as_bits = jint_cast( jf );
 2055     emit_d32(cbuf, jf_as_bits);
 2056   %}
 2057 
 2058   enc_class Con16 (immI src) %{    // Con16(storeImmI)
 2059     // Output immediate
 2060     $$$emit16$src$$constant;
 2061   %}
 2062 
 2063   enc_class Con_d32(immI src) %{
 2064     emit_d32(cbuf,$src$$constant);
 2065   %}
 2066 
 2067   enc_class conmemref (eRegP t1) %{    // Con32(storeImmI)
 2068     // Output immediate memory reference
 2069     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2070     emit_d32(cbuf, 0x00);
 2071   %}
 2072 
 2073   enc_class lock_prefix( ) %{
 2074     emit_opcode(cbuf,0xF0);         // [Lock]
 2075   %}
 2076 
 2077   // Cmp-xchg long value.
 2078   // Note: we need to swap rbx, and rcx before and after the
 2079   //       cmpxchg8 instruction because the instruction uses
 2080   //       rcx as the high order word of the new value to store but
 2081   //       our register encoding uses rbx,.
 2082   enc_class enc_cmpxchg8(eSIRegP mem_ptr) %{
 2083 
 2084     // XCHG  rbx,ecx
 2085     emit_opcode(cbuf,0x87);
 2086     emit_opcode(cbuf,0xD9);
 2087     // [Lock]
 2088     emit_opcode(cbuf,0xF0);
 2089     // CMPXCHG8 [Eptr]
 2090     emit_opcode(cbuf,0x0F);
 2091     emit_opcode(cbuf,0xC7);
 2092     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2093     // XCHG  rbx,ecx
 2094     emit_opcode(cbuf,0x87);
 2095     emit_opcode(cbuf,0xD9);
 2096   %}
 2097 
 2098   enc_class enc_cmpxchg(eSIRegP mem_ptr) %{
 2099     // [Lock]
 2100     emit_opcode(cbuf,0xF0);
 2101 
 2102     // CMPXCHG [Eptr]
 2103     emit_opcode(cbuf,0x0F);
 2104     emit_opcode(cbuf,0xB1);
 2105     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2106   %}
 2107 
 2108   enc_class enc_cmpxchgb(eSIRegP mem_ptr) %{
 2109     // [Lock]
 2110     emit_opcode(cbuf,0xF0);
 2111 
 2112     // CMPXCHGB [Eptr]
 2113     emit_opcode(cbuf,0x0F);
 2114     emit_opcode(cbuf,0xB0);
 2115     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2116   %}
 2117 
 2118   enc_class enc_cmpxchgw(eSIRegP mem_ptr) %{
 2119     // [Lock]
 2120     emit_opcode(cbuf,0xF0);
 2121 
 2122     // 16-bit mode
 2123     emit_opcode(cbuf, 0x66);
 2124 
 2125     // CMPXCHGW [Eptr]
 2126     emit_opcode(cbuf,0x0F);
 2127     emit_opcode(cbuf,0xB1);
 2128     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2129   %}
 2130 
 2131   enc_class enc_flags_ne_to_boolean( iRegI res ) %{
 2132     int res_encoding = $res$$reg;
 2133 
 2134     // MOV  res,0
 2135     emit_opcode( cbuf, 0xB8 + res_encoding);
 2136     emit_d32( cbuf, 0 );
 2137     // JNE,s  fail
 2138     emit_opcode(cbuf,0x75);
 2139     emit_d8(cbuf, 5 );
 2140     // MOV  res,1
 2141     emit_opcode( cbuf, 0xB8 + res_encoding);
 2142     emit_d32( cbuf, 1 );
 2143     // fail:
 2144   %}
 2145 
 2146   enc_class set_instruction_start( ) %{
 2147     cbuf.set_insts_mark();            // Mark start of opcode for reloc info in mem operand
 2148   %}
 2149 
 2150   enc_class RegMem (rRegI ereg, memory mem) %{    // emit_reg_mem
 2151     int reg_encoding = $ereg$$reg;
 2152     int base  = $mem$$base;
 2153     int index = $mem$$index;
 2154     int scale = $mem$$scale;
 2155     int displace = $mem$$disp;
 2156     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2157     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2158   %}
 2159 
 2160   enc_class RegMem_Hi(eRegL ereg, memory mem) %{    // emit_reg_mem
 2161     int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  // Hi register of pair, computed from lo
 2162     int base  = $mem$$base;
 2163     int index = $mem$$index;
 2164     int scale = $mem$$scale;
 2165     int displace = $mem$$disp + 4;      // Offset is 4 further in memory
 2166     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;Cannot add 4 to oop&quot; );
 2167     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, relocInfo::none);
 2168   %}
 2169 
 2170   enc_class move_long_small_shift( eRegL dst, immI_1_31 cnt ) %{
 2171     int r1, r2;
 2172     if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2173     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2174     emit_opcode(cbuf,0x0F);
 2175     emit_opcode(cbuf,$tertiary);
 2176     emit_rm(cbuf, 0x3, r1, r2);
 2177     emit_d8(cbuf,$cnt$$constant);
 2178     emit_d8(cbuf,$primary);
 2179     emit_rm(cbuf, 0x3, $secondary, r1);
 2180     emit_d8(cbuf,$cnt$$constant);
 2181   %}
 2182 
 2183   enc_class move_long_big_shift_sign( eRegL dst, immI_32_63 cnt ) %{
 2184     emit_opcode( cbuf, 0x8B ); // Move
 2185     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2186     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2187       emit_d8(cbuf,$primary);
 2188       emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 2189       emit_d8(cbuf,$cnt$$constant-32);
 2190     }
 2191     emit_d8(cbuf,$primary);
 2192     emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));
 2193     emit_d8(cbuf,31);
 2194   %}
 2195 
 2196   enc_class move_long_big_shift_clr( eRegL dst, immI_32_63 cnt ) %{
 2197     int r1, r2;
 2198     if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2199     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2200 
 2201     emit_opcode( cbuf, 0x8B ); // Move r1,r2
 2202     emit_rm(cbuf, 0x3, r1, r2);
 2203     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2204       emit_opcode(cbuf,$primary);
 2205       emit_rm(cbuf, 0x3, $secondary, r1);
 2206       emit_d8(cbuf,$cnt$$constant-32);
 2207     }
 2208     emit_opcode(cbuf,0x33);  // XOR r2,r2
 2209     emit_rm(cbuf, 0x3, r2, r2);
 2210   %}
 2211 
 2212   // Clone of RegMem but accepts an extra parameter to access each
 2213   // half of a double in memory; it never needs relocation info.
 2214   enc_class Mov_MemD_half_to_Reg (immI opcode, memory mem, immI disp_for_half, rRegI rm_reg) %{
 2215     emit_opcode(cbuf,$opcode$$constant);
 2216     int reg_encoding = $rm_reg$$reg;
 2217     int base     = $mem$$base;
 2218     int index    = $mem$$index;
 2219     int scale    = $mem$$scale;
 2220     int displace = $mem$$disp + $disp_for_half$$constant;
 2221     relocInfo::relocType disp_reloc = relocInfo::none;
 2222     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2223   %}
 2224 
 2225   // !!!!! Special Custom Code used by MemMove, and stack access instructions !!!!!
 2226   //
 2227   // Clone of RegMem except the RM-byte&#39;s reg/opcode field is an ADLC-time constant
 2228   // and it never needs relocation information.
 2229   // Frequently used to move data between FPU&#39;s Stack Top and memory.
 2230   enc_class RMopc_Mem_no_oop (immI rm_opcode, memory mem) %{
 2231     int rm_byte_opcode = $rm_opcode$$constant;
 2232     int base     = $mem$$base;
 2233     int index    = $mem$$index;
 2234     int scale    = $mem$$scale;
 2235     int displace = $mem$$disp;
 2236     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;No oops here because no reloc info allowed&quot; );
 2237     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, relocInfo::none);
 2238   %}
 2239 
 2240   enc_class RMopc_Mem (immI rm_opcode, memory mem) %{
 2241     int rm_byte_opcode = $rm_opcode$$constant;
 2242     int base     = $mem$$base;
 2243     int index    = $mem$$index;
 2244     int scale    = $mem$$scale;
 2245     int displace = $mem$$disp;
 2246     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2247     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 2248   %}
 2249 
 2250   enc_class RegLea (rRegI dst, rRegI src0, immI src1 ) %{    // emit_reg_lea
 2251     int reg_encoding = $dst$$reg;
 2252     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2253     int index        = 0x04;            // 0x04 indicates no index
 2254     int scale        = 0x00;            // 0x00 indicates no scale
 2255     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2256     relocInfo::relocType disp_reloc = relocInfo::none;
 2257     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2258   %}
 2259 
 2260   enc_class min_enc (rRegI dst, rRegI src) %{    // MIN
 2261     // Compare dst,src
 2262     emit_opcode(cbuf,0x3B);
 2263     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2264     // jmp dst &lt; src around move
 2265     emit_opcode(cbuf,0x7C);
 2266     emit_d8(cbuf,2);
 2267     // move dst,src
 2268     emit_opcode(cbuf,0x8B);
 2269     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2270   %}
 2271 
 2272   enc_class max_enc (rRegI dst, rRegI src) %{    // MAX
 2273     // Compare dst,src
 2274     emit_opcode(cbuf,0x3B);
 2275     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2276     // jmp dst &gt; src around move
 2277     emit_opcode(cbuf,0x7F);
 2278     emit_d8(cbuf,2);
 2279     // move dst,src
 2280     emit_opcode(cbuf,0x8B);
 2281     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2282   %}
 2283 
 2284   enc_class enc_FPR_store(memory mem, regDPR src) %{
 2285     // If src is FPR1, we can just FST to store it.
 2286     // Else we need to FLD it to FPR1, then FSTP to store/pop it.
 2287     int reg_encoding = 0x2; // Just store
 2288     int base  = $mem$$base;
 2289     int index = $mem$$index;
 2290     int scale = $mem$$scale;
 2291     int displace = $mem$$disp;
 2292     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2293     if( $src$$reg != FPR1L_enc ) {
 2294       reg_encoding = 0x3;  // Store &amp; pop
 2295       emit_opcode( cbuf, 0xD9 ); // FLD (i.e., push it)
 2296       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2297     }
 2298     cbuf.set_insts_mark();       // Mark start of opcode for reloc info in mem operand
 2299     emit_opcode(cbuf,$primary);
 2300     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2301   %}
 2302 
 2303   enc_class neg_reg(rRegI dst) %{
 2304     // NEG $dst
 2305     emit_opcode(cbuf,0xF7);
 2306     emit_rm(cbuf, 0x3, 0x03, $dst$$reg );
 2307   %}
 2308 
 2309   enc_class setLT_reg(eCXRegI dst) %{
 2310     // SETLT $dst
 2311     emit_opcode(cbuf,0x0F);
 2312     emit_opcode(cbuf,0x9C);
 2313     emit_rm( cbuf, 0x3, 0x4, $dst$$reg );
 2314   %}
 2315 
 2316   enc_class enc_cmpLTP(ncxRegI p, ncxRegI q, ncxRegI y, eCXRegI tmp) %{    // cadd_cmpLT
 2317     int tmpReg = $tmp$$reg;
 2318 
 2319     // SUB $p,$q
 2320     emit_opcode(cbuf,0x2B);
 2321     emit_rm(cbuf, 0x3, $p$$reg, $q$$reg);
 2322     // SBB $tmp,$tmp
 2323     emit_opcode(cbuf,0x1B);
 2324     emit_rm(cbuf, 0x3, tmpReg, tmpReg);
 2325     // AND $tmp,$y
 2326     emit_opcode(cbuf,0x23);
 2327     emit_rm(cbuf, 0x3, tmpReg, $y$$reg);
 2328     // ADD $p,$tmp
 2329     emit_opcode(cbuf,0x03);
 2330     emit_rm(cbuf, 0x3, $p$$reg, tmpReg);
 2331   %}
 2332 
 2333   enc_class shift_left_long( eRegL dst, eCXRegI shift ) %{
 2334     // TEST shift,32
 2335     emit_opcode(cbuf,0xF7);
 2336     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2337     emit_d32(cbuf,0x20);
 2338     // JEQ,s small
 2339     emit_opcode(cbuf, 0x74);
 2340     emit_d8(cbuf, 0x04);
 2341     // MOV    $dst.hi,$dst.lo
 2342     emit_opcode( cbuf, 0x8B );
 2343     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2344     // CLR    $dst.lo
 2345     emit_opcode(cbuf, 0x33);
 2346     emit_rm(cbuf, 0x3, $dst$$reg, $dst$$reg);
 2347 // small:
 2348     // SHLD   $dst.hi,$dst.lo,$shift
 2349     emit_opcode(cbuf,0x0F);
 2350     emit_opcode(cbuf,0xA5);
 2351     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2352     // SHL    $dst.lo,$shift&quot;
 2353     emit_opcode(cbuf,0xD3);
 2354     emit_rm(cbuf, 0x3, 0x4, $dst$$reg );
 2355   %}
 2356 
 2357   enc_class shift_right_long( eRegL dst, eCXRegI shift ) %{
 2358     // TEST shift,32
 2359     emit_opcode(cbuf,0xF7);
 2360     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2361     emit_d32(cbuf,0x20);
 2362     // JEQ,s small
 2363     emit_opcode(cbuf, 0x74);
 2364     emit_d8(cbuf, 0x04);
 2365     // MOV    $dst.lo,$dst.hi
 2366     emit_opcode( cbuf, 0x8B );
 2367     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2368     // CLR    $dst.hi
 2369     emit_opcode(cbuf, 0x33);
 2370     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));
 2371 // small:
 2372     // SHRD   $dst.lo,$dst.hi,$shift
 2373     emit_opcode(cbuf,0x0F);
 2374     emit_opcode(cbuf,0xAD);
 2375     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2376     // SHR    $dst.hi,$shift&quot;
 2377     emit_opcode(cbuf,0xD3);
 2378     emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );
 2379   %}
 2380 
 2381   enc_class shift_right_arith_long( eRegL dst, eCXRegI shift ) %{
 2382     // TEST shift,32
 2383     emit_opcode(cbuf,0xF7);
 2384     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2385     emit_d32(cbuf,0x20);
 2386     // JEQ,s small
 2387     emit_opcode(cbuf, 0x74);
 2388     emit_d8(cbuf, 0x05);
 2389     // MOV    $dst.lo,$dst.hi
 2390     emit_opcode( cbuf, 0x8B );
 2391     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2392     // SAR    $dst.hi,31
 2393     emit_opcode(cbuf, 0xC1);
 2394     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );
 2395     emit_d8(cbuf, 0x1F );
 2396 // small:
 2397     // SHRD   $dst.lo,$dst.hi,$shift
 2398     emit_opcode(cbuf,0x0F);
 2399     emit_opcode(cbuf,0xAD);
 2400     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2401     // SAR    $dst.hi,$shift&quot;
 2402     emit_opcode(cbuf,0xD3);
 2403     emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );
 2404   %}
 2405 
 2406 
 2407   // ----------------- Encodings for floating point unit -----------------
 2408   // May leave result in FPU-TOS or FPU reg depending on opcodes
 2409   enc_class OpcReg_FPR(regFPR src) %{    // FMUL, FDIV
 2410     $$$emit8$primary;
 2411     emit_rm(cbuf, 0x3, $secondary, $src$$reg );
 2412   %}
 2413 
 2414   // Pop argument in FPR0 with FSTP ST(0)
 2415   enc_class PopFPU() %{
 2416     emit_opcode( cbuf, 0xDD );
 2417     emit_d8( cbuf, 0xD8 );
 2418   %}
 2419 
 2420   // !!!!! equivalent to Pop_Reg_F
 2421   enc_class Pop_Reg_DPR( regDPR dst ) %{
 2422     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2423     emit_d8( cbuf, 0xD8+$dst$$reg );
 2424   %}
 2425 
 2426   enc_class Push_Reg_DPR( regDPR dst ) %{
 2427     emit_opcode( cbuf, 0xD9 );
 2428     emit_d8( cbuf, 0xC0-1+$dst$$reg );   // FLD ST(i-1)
 2429   %}
 2430 
 2431   enc_class strictfp_bias1( regDPR dst ) %{
 2432     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2433     emit_opcode( cbuf, 0x2D );
 2434     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias1() );
 2435     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2436     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2437   %}
 2438 
 2439   enc_class strictfp_bias2( regDPR dst ) %{
 2440     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2441     emit_opcode( cbuf, 0x2D );
 2442     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias2() );
 2443     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2444     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2445   %}
 2446 
 2447   // Special case for moving an integer register to a stack slot.
 2448   enc_class OpcPRegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2449     store_to_stackslot( cbuf, $primary, $src$$reg, $dst$$disp );
 2450   %}
 2451 
 2452   // Special case for moving a register to a stack slot.
 2453   enc_class RegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2454     // Opcode already emitted
 2455     emit_rm( cbuf, 0x02, $src$$reg, ESP_enc );   // R/M byte
 2456     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);          // SIB byte
 2457     emit_d32(cbuf, $dst$$disp);   // Displacement
 2458   %}
 2459 
 2460   // Push the integer in stackSlot &#39;src&#39; onto FP-stack
 2461   enc_class Push_Mem_I( memory src ) %{    // FILD   [ESP+src]
 2462     store_to_stackslot( cbuf, $primary, $secondary, $src$$disp );
 2463   %}
 2464 
 2465   // Push FPU&#39;s TOS float to a stack-slot, and pop FPU-stack
 2466   enc_class Pop_Mem_FPR( stackSlotF dst ) %{ // FSTP_S [ESP+dst]
 2467     store_to_stackslot( cbuf, 0xD9, 0x03, $dst$$disp );
 2468   %}
 2469 
 2470   // Same as Pop_Mem_F except for opcode
 2471   // Push FPU&#39;s TOS double to a stack-slot, and pop FPU-stack
 2472   enc_class Pop_Mem_DPR( stackSlotD dst ) %{ // FSTP_D [ESP+dst]
 2473     store_to_stackslot( cbuf, 0xDD, 0x03, $dst$$disp );
 2474   %}
 2475 
 2476   enc_class Pop_Reg_FPR( regFPR dst ) %{
 2477     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2478     emit_d8( cbuf, 0xD8+$dst$$reg );
 2479   %}
 2480 
 2481   enc_class Push_Reg_FPR( regFPR dst ) %{
 2482     emit_opcode( cbuf, 0xD9 );           // FLD    ST(i-1)
 2483     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2484   %}
 2485 
 2486   // Push FPU&#39;s float to a stack-slot, and pop FPU-stack
 2487   enc_class Pop_Mem_Reg_FPR( stackSlotF dst, regFPR src ) %{
 2488     int pop = 0x02;
 2489     if ($src$$reg != FPR1L_enc) {
 2490       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2491       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2492       pop = 0x03;
 2493     }
 2494     store_to_stackslot( cbuf, 0xD9, pop, $dst$$disp ); // FST&lt;P&gt;_S  [ESP+dst]
 2495   %}
 2496 
 2497   // Push FPU&#39;s double to a stack-slot, and pop FPU-stack
 2498   enc_class Pop_Mem_Reg_DPR( stackSlotD dst, regDPR src ) %{
 2499     int pop = 0x02;
 2500     if ($src$$reg != FPR1L_enc) {
 2501       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2502       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2503       pop = 0x03;
 2504     }
 2505     store_to_stackslot( cbuf, 0xDD, pop, $dst$$disp ); // FST&lt;P&gt;_D  [ESP+dst]
 2506   %}
 2507 
 2508   // Push FPU&#39;s double to a FPU-stack-slot, and pop FPU-stack
 2509   enc_class Pop_Reg_Reg_DPR( regDPR dst, regFPR src ) %{
 2510     int pop = 0xD0 - 1; // -1 since we skip FLD
 2511     if ($src$$reg != FPR1L_enc) {
 2512       emit_opcode( cbuf, 0xD9 );         // FLD    ST(src-1)
 2513       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2514       pop = 0xD8;
 2515     }
 2516     emit_opcode( cbuf, 0xDD );
 2517     emit_d8( cbuf, pop+$dst$$reg );      // FST&lt;P&gt; ST(i)
 2518   %}
 2519 
 2520 
 2521   enc_class Push_Reg_Mod_DPR( regDPR dst, regDPR src) %{
 2522     // load dst in FPR0
 2523     emit_opcode( cbuf, 0xD9 );
 2524     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2525     if ($src$$reg != FPR1L_enc) {
 2526       // fincstp
 2527       emit_opcode (cbuf, 0xD9);
 2528       emit_opcode (cbuf, 0xF7);
 2529       // swap src with FPR1:
 2530       // FXCH FPR1 with src
 2531       emit_opcode(cbuf, 0xD9);
 2532       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2533       // fdecstp
 2534       emit_opcode (cbuf, 0xD9);
 2535       emit_opcode (cbuf, 0xF6);
 2536     }
 2537   %}
 2538 
 2539   enc_class Push_ModD_encoding(regD src0, regD src1) %{
 2540     MacroAssembler _masm(&amp;cbuf);
 2541     __ subptr(rsp, 8);
 2542     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
 2543     __ fld_d(Address(rsp, 0));
 2544     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
 2545     __ fld_d(Address(rsp, 0));
 2546   %}
 2547 
 2548   enc_class Push_ModF_encoding(regF src0, regF src1) %{
 2549     MacroAssembler _masm(&amp;cbuf);
 2550     __ subptr(rsp, 4);
 2551     __ movflt(Address(rsp, 0), $src1$$XMMRegister);
 2552     __ fld_s(Address(rsp, 0));
 2553     __ movflt(Address(rsp, 0), $src0$$XMMRegister);
 2554     __ fld_s(Address(rsp, 0));
 2555   %}
 2556 
 2557   enc_class Push_ResultD(regD dst) %{
 2558     MacroAssembler _masm(&amp;cbuf);
 2559     __ fstp_d(Address(rsp, 0));
 2560     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2561     __ addptr(rsp, 8);
 2562   %}
 2563 
 2564   enc_class Push_ResultF(regF dst, immI d8) %{
 2565     MacroAssembler _masm(&amp;cbuf);
 2566     __ fstp_s(Address(rsp, 0));
 2567     __ movflt($dst$$XMMRegister, Address(rsp, 0));
 2568     __ addptr(rsp, $d8$$constant);
 2569   %}
 2570 
 2571   enc_class Push_SrcD(regD src) %{
 2572     MacroAssembler _masm(&amp;cbuf);
 2573     __ subptr(rsp, 8);
 2574     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2575     __ fld_d(Address(rsp, 0));
 2576   %}
 2577 
 2578   enc_class push_stack_temp_qword() %{
 2579     MacroAssembler _masm(&amp;cbuf);
 2580     __ subptr(rsp, 8);
 2581   %}
 2582 
 2583   enc_class pop_stack_temp_qword() %{
 2584     MacroAssembler _masm(&amp;cbuf);
 2585     __ addptr(rsp, 8);
 2586   %}
 2587 
 2588   enc_class push_xmm_to_fpr1(regD src) %{
 2589     MacroAssembler _masm(&amp;cbuf);
 2590     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2591     __ fld_d(Address(rsp, 0));
 2592   %}
 2593 
 2594   enc_class Push_Result_Mod_DPR( regDPR src) %{
 2595     if ($src$$reg != FPR1L_enc) {
 2596       // fincstp
 2597       emit_opcode (cbuf, 0xD9);
 2598       emit_opcode (cbuf, 0xF7);
 2599       // FXCH FPR1 with src
 2600       emit_opcode(cbuf, 0xD9);
 2601       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2602       // fdecstp
 2603       emit_opcode (cbuf, 0xD9);
 2604       emit_opcode (cbuf, 0xF6);
 2605     }
 2606     // // following asm replaced with Pop_Reg_F or Pop_Mem_F
 2607     // // FSTP   FPR$dst$$reg
 2608     // emit_opcode( cbuf, 0xDD );
 2609     // emit_d8( cbuf, 0xD8+$dst$$reg );
 2610   %}
 2611 
 2612   enc_class fnstsw_sahf_skip_parity() %{
 2613     // fnstsw ax
 2614     emit_opcode( cbuf, 0xDF );
 2615     emit_opcode( cbuf, 0xE0 );
 2616     // sahf
 2617     emit_opcode( cbuf, 0x9E );
 2618     // jnp  ::skip
 2619     emit_opcode( cbuf, 0x7B );
 2620     emit_opcode( cbuf, 0x05 );
 2621   %}
 2622 
 2623   enc_class emitModDPR() %{
 2624     // fprem must be iterative
 2625     // :: loop
 2626     // fprem
 2627     emit_opcode( cbuf, 0xD9 );
 2628     emit_opcode( cbuf, 0xF8 );
 2629     // wait
 2630     emit_opcode( cbuf, 0x9b );
 2631     // fnstsw ax
 2632     emit_opcode( cbuf, 0xDF );
 2633     emit_opcode( cbuf, 0xE0 );
 2634     // sahf
 2635     emit_opcode( cbuf, 0x9E );
 2636     // jp  ::loop
 2637     emit_opcode( cbuf, 0x0F );
 2638     emit_opcode( cbuf, 0x8A );
 2639     emit_opcode( cbuf, 0xF4 );
 2640     emit_opcode( cbuf, 0xFF );
 2641     emit_opcode( cbuf, 0xFF );
 2642     emit_opcode( cbuf, 0xFF );
 2643   %}
 2644 
 2645   enc_class fpu_flags() %{
 2646     // fnstsw_ax
 2647     emit_opcode( cbuf, 0xDF);
 2648     emit_opcode( cbuf, 0xE0);
 2649     // test ax,0x0400
 2650     emit_opcode( cbuf, 0x66 );   // operand-size prefix for 16-bit immediate
 2651     emit_opcode( cbuf, 0xA9 );
 2652     emit_d16   ( cbuf, 0x0400 );
 2653     // // // This sequence works, but stalls for 12-16 cycles on PPro
 2654     // // test rax,0x0400
 2655     // emit_opcode( cbuf, 0xA9 );
 2656     // emit_d32   ( cbuf, 0x00000400 );
 2657     //
 2658     // jz exit (no unordered comparison)
 2659     emit_opcode( cbuf, 0x74 );
 2660     emit_d8    ( cbuf, 0x02 );
 2661     // mov ah,1 - treat as LT case (set carry flag)
 2662     emit_opcode( cbuf, 0xB4 );
 2663     emit_d8    ( cbuf, 0x01 );
 2664     // sahf
 2665     emit_opcode( cbuf, 0x9E);
 2666   %}
 2667 
 2668   enc_class cmpF_P6_fixup() %{
 2669     // Fixup the integer flags in case comparison involved a NaN
 2670     //
 2671     // JNP exit (no unordered comparison, P-flag is set by NaN)
 2672     emit_opcode( cbuf, 0x7B );
 2673     emit_d8    ( cbuf, 0x03 );
 2674     // MOV AH,1 - treat as LT case (set carry flag)
 2675     emit_opcode( cbuf, 0xB4 );
 2676     emit_d8    ( cbuf, 0x01 );
 2677     // SAHF
 2678     emit_opcode( cbuf, 0x9E);
 2679     // NOP     // target for branch to avoid branch to branch
 2680     emit_opcode( cbuf, 0x90);
 2681   %}
 2682 
 2683 //     fnstsw_ax();
 2684 //     sahf();
 2685 //     movl(dst, nan_result);
 2686 //     jcc(Assembler::parity, exit);
 2687 //     movl(dst, less_result);
 2688 //     jcc(Assembler::below, exit);
 2689 //     movl(dst, equal_result);
 2690 //     jcc(Assembler::equal, exit);
 2691 //     movl(dst, greater_result);
 2692 
 2693 // less_result     =  1;
 2694 // greater_result  = -1;
 2695 // equal_result    = 0;
 2696 // nan_result      = -1;
 2697 
 2698   enc_class CmpF_Result(rRegI dst) %{
 2699     // fnstsw_ax();
 2700     emit_opcode( cbuf, 0xDF);
 2701     emit_opcode( cbuf, 0xE0);
 2702     // sahf
 2703     emit_opcode( cbuf, 0x9E);
 2704     // movl(dst, nan_result);
 2705     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2706     emit_d32( cbuf, -1 );
 2707     // jcc(Assembler::parity, exit);
 2708     emit_opcode( cbuf, 0x7A );
 2709     emit_d8    ( cbuf, 0x13 );
 2710     // movl(dst, less_result);
 2711     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2712     emit_d32( cbuf, -1 );
 2713     // jcc(Assembler::below, exit);
 2714     emit_opcode( cbuf, 0x72 );
 2715     emit_d8    ( cbuf, 0x0C );
 2716     // movl(dst, equal_result);
 2717     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2718     emit_d32( cbuf, 0 );
 2719     // jcc(Assembler::equal, exit);
 2720     emit_opcode( cbuf, 0x74 );
 2721     emit_d8    ( cbuf, 0x05 );
 2722     // movl(dst, greater_result);
 2723     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2724     emit_d32( cbuf, 1 );
 2725   %}
 2726 
 2727 
 2728   // Compare the longs and set flags
 2729   // BROKEN!  Do Not use as-is
 2730   enc_class cmpl_test( eRegL src1, eRegL src2 ) %{
 2731     // CMP    $src1.hi,$src2.hi
 2732     emit_opcode( cbuf, 0x3B );
 2733     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2734     // JNE,s  done
 2735     emit_opcode(cbuf,0x75);
 2736     emit_d8(cbuf, 2 );
 2737     // CMP    $src1.lo,$src2.lo
 2738     emit_opcode( cbuf, 0x3B );
 2739     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2740 // done:
 2741   %}
 2742 
 2743   enc_class convert_int_long( regL dst, rRegI src ) %{
 2744     // mov $dst.lo,$src
 2745     int dst_encoding = $dst$$reg;
 2746     int src_encoding = $src$$reg;
 2747     encode_Copy( cbuf, dst_encoding  , src_encoding );
 2748     // mov $dst.hi,$src
 2749     encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );
 2750     // sar $dst.hi,31
 2751     emit_opcode( cbuf, 0xC1 );
 2752     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );
 2753     emit_d8(cbuf, 0x1F );
 2754   %}
 2755 
 2756   enc_class convert_long_double( eRegL src ) %{
 2757     // push $src.hi
 2758     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2759     // push $src.lo
 2760     emit_opcode(cbuf, 0x50+$src$$reg  );
 2761     // fild 64-bits at [SP]
 2762     emit_opcode(cbuf,0xdf);
 2763     emit_d8(cbuf, 0x6C);
 2764     emit_d8(cbuf, 0x24);
 2765     emit_d8(cbuf, 0x00);
 2766     // pop stack
 2767     emit_opcode(cbuf, 0x83); // add  SP, #8
 2768     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2769     emit_d8(cbuf, 0x8);
 2770   %}
 2771 
 2772   enc_class multiply_con_and_shift_high( eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr ) %{
 2773     // IMUL   EDX:EAX,$src1
 2774     emit_opcode( cbuf, 0xF7 );
 2775     emit_rm( cbuf, 0x3, 0x5, $src1$$reg );
 2776     // SAR    EDX,$cnt-32
 2777     int shift_count = ((int)$cnt$$constant) - 32;
 2778     if (shift_count &gt; 0) {
 2779       emit_opcode(cbuf, 0xC1);
 2780       emit_rm(cbuf, 0x3, 7, $dst$$reg );
 2781       emit_d8(cbuf, shift_count);
 2782     }
 2783   %}
 2784 
 2785   // this version doesn&#39;t have add sp, 8
 2786   enc_class convert_long_double2( eRegL src ) %{
 2787     // push $src.hi
 2788     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2789     // push $src.lo
 2790     emit_opcode(cbuf, 0x50+$src$$reg  );
 2791     // fild 64-bits at [SP]
 2792     emit_opcode(cbuf,0xdf);
 2793     emit_d8(cbuf, 0x6C);
 2794     emit_d8(cbuf, 0x24);
 2795     emit_d8(cbuf, 0x00);
 2796   %}
 2797 
 2798   enc_class long_int_multiply( eADXRegL dst, nadxRegI src) %{
 2799     // Basic idea: long = (long)int * (long)int
 2800     // IMUL EDX:EAX, src
 2801     emit_opcode( cbuf, 0xF7 );
 2802     emit_rm( cbuf, 0x3, 0x5, $src$$reg);
 2803   %}
 2804 
 2805   enc_class long_uint_multiply( eADXRegL dst, nadxRegI src) %{
 2806     // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 2807     // MUL EDX:EAX, src
 2808     emit_opcode( cbuf, 0xF7 );
 2809     emit_rm( cbuf, 0x3, 0x4, $src$$reg);
 2810   %}
 2811 
 2812   enc_class long_multiply( eADXRegL dst, eRegL src, rRegI tmp ) %{
 2813     // Basic idea: lo(result) = lo(x_lo * y_lo)
 2814     //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 2815     // MOV    $tmp,$src.lo
 2816     encode_Copy( cbuf, $tmp$$reg, $src$$reg );
 2817     // IMUL   $tmp,EDX
 2818     emit_opcode( cbuf, 0x0F );
 2819     emit_opcode( cbuf, 0xAF );
 2820     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2821     // MOV    EDX,$src.hi
 2822     encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );
 2823     // IMUL   EDX,EAX
 2824     emit_opcode( cbuf, 0x0F );
 2825     emit_opcode( cbuf, 0xAF );
 2826     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2827     // ADD    $tmp,EDX
 2828     emit_opcode( cbuf, 0x03 );
 2829     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2830     // MUL   EDX:EAX,$src.lo
 2831     emit_opcode( cbuf, 0xF7 );
 2832     emit_rm( cbuf, 0x3, 0x4, $src$$reg );
 2833     // ADD    EDX,ESI
 2834     emit_opcode( cbuf, 0x03 );
 2835     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );
 2836   %}
 2837 
 2838   enc_class long_multiply_con( eADXRegL dst, immL_127 src, rRegI tmp ) %{
 2839     // Basic idea: lo(result) = lo(src * y_lo)
 2840     //             hi(result) = hi(src * y_lo) + lo(src * y_hi)
 2841     // IMUL   $tmp,EDX,$src
 2842     emit_opcode( cbuf, 0x6B );
 2843     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2844     emit_d8( cbuf, (int)$src$$constant );
 2845     // MOV    EDX,$src
 2846     emit_opcode(cbuf, 0xB8 + EDX_enc);
 2847     emit_d32( cbuf, (int)$src$$constant );
 2848     // MUL   EDX:EAX,EDX
 2849     emit_opcode( cbuf, 0xF7 );
 2850     emit_rm( cbuf, 0x3, 0x4, EDX_enc );
 2851     // ADD    EDX,ESI
 2852     emit_opcode( cbuf, 0x03 );
 2853     emit_rm( cbuf, 0x3, EDX_enc, $tmp$$reg );
 2854   %}
 2855 
 2856   enc_class long_div( eRegL src1, eRegL src2 ) %{
 2857     // PUSH src1.hi
 2858     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2859     // PUSH src1.lo
 2860     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2861     // PUSH src2.hi
 2862     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2863     // PUSH src2.lo
 2864     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2865     // CALL directly to the runtime
 2866     cbuf.set_insts_mark();
 2867     emit_opcode(cbuf,0xE8);       // Call into runtime
 2868     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2869     // Restore stack
 2870     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2871     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2872     emit_d8(cbuf, 4*4);
 2873   %}
 2874 
 2875   enc_class long_mod( eRegL src1, eRegL src2 ) %{
 2876     // PUSH src1.hi
 2877     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2878     // PUSH src1.lo
 2879     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2880     // PUSH src2.hi
 2881     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2882     // PUSH src2.lo
 2883     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2884     // CALL directly to the runtime
 2885     cbuf.set_insts_mark();
 2886     emit_opcode(cbuf,0xE8);       // Call into runtime
 2887     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2888     // Restore stack
 2889     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2890     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2891     emit_d8(cbuf, 4*4);
 2892   %}
 2893 
 2894   enc_class long_cmp_flags0( eRegL src, rRegI tmp ) %{
 2895     // MOV   $tmp,$src.lo
 2896     emit_opcode(cbuf, 0x8B);
 2897     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg);
 2898     // OR    $tmp,$src.hi
 2899     emit_opcode(cbuf, 0x0B);
 2900     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));
 2901   %}
 2902 
 2903   enc_class long_cmp_flags1( eRegL src1, eRegL src2 ) %{
 2904     // CMP    $src1.lo,$src2.lo
 2905     emit_opcode( cbuf, 0x3B );
 2906     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2907     // JNE,s  skip
 2908     emit_cc(cbuf, 0x70, 0x5);
 2909     emit_d8(cbuf,2);
 2910     // CMP    $src1.hi,$src2.hi
 2911     emit_opcode( cbuf, 0x3B );
 2912     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2913   %}
 2914 
 2915   enc_class long_cmp_flags2( eRegL src1, eRegL src2, rRegI tmp ) %{
 2916     // CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits
 2917     emit_opcode( cbuf, 0x3B );
 2918     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2919     // MOV    $tmp,$src1.hi
 2920     emit_opcode( cbuf, 0x8B );
 2921     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );
 2922     // SBB   $tmp,$src2.hi\t! Compute flags for long compare
 2923     emit_opcode( cbuf, 0x1B );
 2924     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );
 2925   %}
 2926 
 2927   enc_class long_cmp_flags3( eRegL src, rRegI tmp ) %{
 2928     // XOR    $tmp,$tmp
 2929     emit_opcode(cbuf,0x33);  // XOR
 2930     emit_rm(cbuf,0x3, $tmp$$reg, $tmp$$reg);
 2931     // CMP    $tmp,$src.lo
 2932     emit_opcode( cbuf, 0x3B );
 2933     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg );
 2934     // SBB    $tmp,$src.hi
 2935     emit_opcode( cbuf, 0x1B );
 2936     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );
 2937   %}
 2938 
 2939  // Sniff, sniff... smells like Gnu Superoptimizer
 2940   enc_class neg_long( eRegL dst ) %{
 2941     emit_opcode(cbuf,0xF7);    // NEG hi
 2942     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2943     emit_opcode(cbuf,0xF7);    // NEG lo
 2944     emit_rm    (cbuf,0x3, 0x3,               $dst$$reg );
 2945     emit_opcode(cbuf,0x83);    // SBB hi,0
 2946     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2947     emit_d8    (cbuf,0 );
 2948   %}
 2949 
 2950   enc_class enc_pop_rdx() %{
 2951     emit_opcode(cbuf,0x5A);
 2952   %}
 2953 
 2954   enc_class enc_rethrow() %{
 2955     cbuf.set_insts_mark();
 2956     emit_opcode(cbuf, 0xE9);        // jmp    entry
 2957     emit_d32_reloc(cbuf, (int)OptoRuntime::rethrow_stub() - ((int)cbuf.insts_end())-4,
 2958                    runtime_call_Relocation::spec(), RELOC_IMM32 );
 2959   %}
 2960 
 2961 
 2962   // Convert a double to an int.  Java semantics require we do complex
 2963   // manglelations in the corner cases.  So we set the rounding mode to
 2964   // &#39;zero&#39;, store the darned double down as an int, and reset the
 2965   // rounding mode to &#39;nearest&#39;.  The hardware throws an exception which
 2966   // patches up the correct value directly to the stack.
 2967   enc_class DPR2I_encoding( regDPR src ) %{
 2968     // Flip to round-to-zero mode.  We attempted to allow invalid-op
 2969     // exceptions here, so that a NAN or other corner-case value will
 2970     // thrown an exception (but normal values get converted at full speed).
 2971     // However, I2C adapters and other float-stack manglers leave pending
 2972     // invalid-op exceptions hanging.  We would have to clear them before
 2973     // enabling them and that is more expensive than just testing for the
 2974     // invalid value Intel stores down in the corner cases.
 2975     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 2976     emit_opcode(cbuf,0x2D);
 2977     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 2978     // Allocate a word
 2979     emit_opcode(cbuf,0x83);            // SUB ESP,4
 2980     emit_opcode(cbuf,0xEC);
 2981     emit_d8(cbuf,0x04);
 2982     // Encoding assumes a double has been pushed into FPR0.
 2983     // Store down the double as an int, popping the FPU stack
 2984     emit_opcode(cbuf,0xDB);            // FISTP [ESP]
 2985     emit_opcode(cbuf,0x1C);
 2986     emit_d8(cbuf,0x24);
 2987     // Restore the rounding mode; mask the exception
 2988     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 2989     emit_opcode(cbuf,0x2D);
 2990     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 2991         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 2992         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 2993 
 2994     // Load the converted int; adjust CPU stack
 2995     emit_opcode(cbuf,0x58);       // POP EAX
 2996     emit_opcode(cbuf,0x3D);       // CMP EAX,imm
 2997     emit_d32   (cbuf,0x80000000); //         0x80000000
 2998     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 2999     emit_d8    (cbuf,0x07);       // Size of slow_call
 3000     // Push src onto stack slow-path
 3001     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3002     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3003     // CALL directly to the runtime
 3004     cbuf.set_insts_mark();
 3005     emit_opcode(cbuf,0xE8);       // Call into runtime
 3006     emit_d32_reloc(cbuf, (StubRoutines::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3007     // Carry on here...
 3008   %}
 3009 
 3010   enc_class DPR2L_encoding( regDPR src ) %{
 3011     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 3012     emit_opcode(cbuf,0x2D);
 3013     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 3014     // Allocate a word
 3015     emit_opcode(cbuf,0x83);            // SUB ESP,8
 3016     emit_opcode(cbuf,0xEC);
 3017     emit_d8(cbuf,0x08);
 3018     // Encoding assumes a double has been pushed into FPR0.
 3019     // Store down the double as a long, popping the FPU stack
 3020     emit_opcode(cbuf,0xDF);            // FISTP [ESP]
 3021     emit_opcode(cbuf,0x3C);
 3022     emit_d8(cbuf,0x24);
 3023     // Restore the rounding mode; mask the exception
 3024     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 3025     emit_opcode(cbuf,0x2D);
 3026     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 3027         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 3028         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 3029 
 3030     // Load the converted int; adjust CPU stack
 3031     emit_opcode(cbuf,0x58);       // POP EAX
 3032     emit_opcode(cbuf,0x5A);       // POP EDX
 3033     emit_opcode(cbuf,0x81);       // CMP EDX,imm
 3034     emit_d8    (cbuf,0xFA);       // rdx
 3035     emit_d32   (cbuf,0x80000000); //         0x80000000
 3036     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3037     emit_d8    (cbuf,0x07+4);     // Size of slow_call
 3038     emit_opcode(cbuf,0x85);       // TEST EAX,EAX
 3039     emit_opcode(cbuf,0xC0);       // 2/rax,/rax,
 3040     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3041     emit_d8    (cbuf,0x07);       // Size of slow_call
 3042     // Push src onto stack slow-path
 3043     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3044     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3045     // CALL directly to the runtime
 3046     cbuf.set_insts_mark();
 3047     emit_opcode(cbuf,0xE8);       // Call into runtime
 3048     emit_d32_reloc(cbuf, (StubRoutines::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3049     // Carry on here...
 3050   %}
 3051 
 3052   enc_class FMul_ST_reg( eRegFPR src1 ) %{
 3053     // Operand was loaded from memory into fp ST (stack top)
 3054     // FMUL   ST,$src  /* D8 C8+i */
 3055     emit_opcode(cbuf, 0xD8);
 3056     emit_opcode(cbuf, 0xC8 + $src1$$reg);
 3057   %}
 3058 
 3059   enc_class FAdd_ST_reg( eRegFPR src2 ) %{
 3060     // FADDP  ST,src2  /* D8 C0+i */
 3061     emit_opcode(cbuf, 0xD8);
 3062     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3063     //could use FADDP  src2,fpST  /* DE C0+i */
 3064   %}
 3065 
 3066   enc_class FAddP_reg_ST( eRegFPR src2 ) %{
 3067     // FADDP  src2,ST  /* DE C0+i */
 3068     emit_opcode(cbuf, 0xDE);
 3069     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3070   %}
 3071 
 3072   enc_class subFPR_divFPR_encode( eRegFPR src1, eRegFPR src2) %{
 3073     // Operand has been loaded into fp ST (stack top)
 3074       // FSUB   ST,$src1
 3075       emit_opcode(cbuf, 0xD8);
 3076       emit_opcode(cbuf, 0xE0 + $src1$$reg);
 3077 
 3078       // FDIV
 3079       emit_opcode(cbuf, 0xD8);
 3080       emit_opcode(cbuf, 0xF0 + $src2$$reg);
 3081   %}
 3082 
 3083   enc_class MulFAddF (eRegFPR src1, eRegFPR src2) %{
 3084     // Operand was loaded from memory into fp ST (stack top)
 3085     // FADD   ST,$src  /* D8 C0+i */
 3086     emit_opcode(cbuf, 0xD8);
 3087     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3088 
 3089     // FMUL  ST,src2  /* D8 C*+i */
 3090     emit_opcode(cbuf, 0xD8);
 3091     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3092   %}
 3093 
 3094 
 3095   enc_class MulFAddFreverse (eRegFPR src1, eRegFPR src2) %{
 3096     // Operand was loaded from memory into fp ST (stack top)
 3097     // FADD   ST,$src  /* D8 C0+i */
 3098     emit_opcode(cbuf, 0xD8);
 3099     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3100 
 3101     // FMULP  src2,ST  /* DE C8+i */
 3102     emit_opcode(cbuf, 0xDE);
 3103     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3104   %}
 3105 
 3106   // Atomically load the volatile long
 3107   enc_class enc_loadL_volatile( memory mem, stackSlotL dst ) %{
 3108     emit_opcode(cbuf,0xDF);
 3109     int rm_byte_opcode = 0x05;
 3110     int base     = $mem$$base;
 3111     int index    = $mem$$index;
 3112     int scale    = $mem$$scale;
 3113     int displace = $mem$$disp;
 3114     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3115     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3116     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3117   %}
 3118 
 3119   // Volatile Store Long.  Must be atomic, so move it into
 3120   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3121   // target address before the store (for null-ptr checks)
 3122   // so the memory operand is used twice in the encoding.
 3123   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3124     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3125     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3126     emit_opcode(cbuf,0xDF);
 3127     int rm_byte_opcode = 0x07;
 3128     int base     = $mem$$base;
 3129     int index    = $mem$$index;
 3130     int scale    = $mem$$scale;
 3131     int displace = $mem$$disp;
 3132     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3133     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3134   %}
 3135 
 3136 %}
 3137 
 3138 
 3139 //----------FRAME--------------------------------------------------------------
 3140 // Definition of frame structure and management information.
 3141 //
 3142 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3143 //                             |   (to get allocators register number
 3144 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3145 //  r   CALLER     |        |
 3146 //  o     |        +--------+      pad to even-align allocators stack-slot
 3147 //  w     V        |  pad0  |        numbers; owned by CALLER
 3148 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3149 //  h     ^        |   in   |  5
 3150 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3151 //  |     |        |        |  3
 3152 //  |     |        +--------+
 3153 //  V     |        | old out|      Empty on Intel, window on Sparc
 3154 //        |    old |preserve|      Must be even aligned.
 3155 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 3156 //        |        |   in   |  3   area for Intel ret address
 3157 //     Owned by    |preserve|      Empty on Sparc.
 3158 //       SELF      +--------+
 3159 //        |        |  pad2  |  2   pad to align old SP
 3160 //        |        +--------+  1
 3161 //        |        | locks  |  0
 3162 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 3163 //        |        |  pad1  | 11   pad to align new SP
 3164 //        |        +--------+
 3165 //        |        |        | 10
 3166 //        |        | spills |  9   spills
 3167 //        V        |        |  8   (pad0 slot for callee)
 3168 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 3169 //        ^        |  out   |  7
 3170 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 3171 //     Owned by    +--------+
 3172 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 3173 //        |    new |preserve|      Must be even-aligned.
 3174 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 3175 //        |        |        |
 3176 //
 3177 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 3178 //         known from SELF&#39;s arguments and the Java calling convention.
 3179 //         Region 6-7 is determined per call site.
 3180 // Note 2: If the calling convention leaves holes in the incoming argument
 3181 //         area, those holes are owned by SELF.  Holes in the outgoing area
 3182 //         are owned by the CALLEE.  Holes should not be nessecary in the
 3183 //         incoming area, as the Java calling convention is completely under
 3184 //         the control of the AD file.  Doubles can be sorted and packed to
 3185 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 3186 //         varargs C calling conventions.
 3187 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 3188 //         even aligned with pad0 as needed.
 3189 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 3190 //         region 6-11 is even aligned; it may be padded out more so that
 3191 //         the region from SP to FP meets the minimum stack alignment.
 3192 
 3193 frame %{
 3194   // What direction does stack grow in (assumed to be same for C &amp; Java)
 3195   stack_direction(TOWARDS_LOW);
 3196 
 3197   // These three registers define part of the calling convention
 3198   // between compiled code and the interpreter.
 3199   inline_cache_reg(EAX);                // Inline Cache Register
 3200   interpreter_method_oop_reg(EBX);      // Method Oop Register when calling interpreter
 3201 
 3202   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 3203   cisc_spilling_operand_name(indOffset32);
 3204 
 3205   // Number of stack slots consumed by locking an object
 3206   sync_stack_slots(1);
 3207 
 3208   // Compiled code&#39;s Frame Pointer
 3209   frame_pointer(ESP);
 3210   // Interpreter stores its frame pointer in a register which is
 3211   // stored to the stack by I2CAdaptors.
 3212   // I2CAdaptors convert from interpreted java to compiled java.
 3213   interpreter_frame_pointer(EBP);
 3214 
 3215   // Stack alignment requirement
 3216   // Alignment size in bytes (128-bit -&gt; 16 bytes)
 3217   stack_alignment(StackAlignmentInBytes);
 3218 
 3219   // Number of stack slots between incoming argument block and the start of
 3220   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3221   // EPILOG must remove this many slots.  Intel needs one slot for
 3222   // return address and one for rbp, (must save rbp)
 3223   in_preserve_stack_slots(2+VerifyStackAtCalls);
 3224 
 3225   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3226   // for calls to C.  Supports the var-args backing area for register parms.
 3227   varargs_C_out_slots_killed(0);
 3228 
 3229   // The after-PROLOG location of the return address.  Location of
 3230   // return address specifies a type (REG or STACK) and a number
 3231   // representing the register number (i.e. - use a register name) or
 3232   // stack slot.
 3233   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 3234   // Otherwise, it is above the locks and verification slot and alignment word
 3235   return_addr(STACK - 1 +
 3236               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 3237                         Compile::current()-&gt;fixed_slots()),
 3238                        stack_alignment_in_slots()));
 3239 
 3240   // Body of function which returns an integer array locating
 3241   // arguments either in registers or in stack slots.  Passed an array
 3242   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3243   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3244   // arguments for a CALLEE.  Incoming stack arguments are
 3245   // automatically biased by the preserve_stack_slots field above.
 3246   calling_convention %{
 3247     // No difference between ingoing/outgoing just pass false
 3248     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 3249   %}
 3250 
 3251 
 3252   // Body of function which returns an integer array locating
 3253   // arguments either in registers or in stack slots.  Passed an array
 3254   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3255   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3256   // arguments for a CALLEE.  Incoming stack arguments are
 3257   // automatically biased by the preserve_stack_slots field above.
 3258   c_calling_convention %{
 3259     // This is obviously always outgoing
 3260     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3261   %}
 3262 
 3263   // Location of C &amp; interpreter return values
 3264   c_return_value %{
 3265     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3266     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3267     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3268 
 3269     // in SSE2+ mode we want to keep the FPU stack clean so pretend
 3270     // that C functions return float and double results in XMM0.
 3271     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3272       return OptoRegPair(XMM0b_num,XMM0_num);
 3273     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=2 )
 3274       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3275 
 3276     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3277   %}
 3278 
 3279   // Location of return values
 3280   return_value %{
 3281     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3282     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3283     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3284     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3285       return OptoRegPair(XMM0b_num,XMM0_num);
 3286     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=1 )
 3287       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3288     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3289   %}
 3290 
 3291 %}
 3292 
 3293 //----------ATTRIBUTES---------------------------------------------------------
 3294 //----------Operand Attributes-------------------------------------------------
 3295 op_attrib op_cost(0);        // Required cost attribute
 3296 
 3297 //----------Instruction Attributes---------------------------------------------
 3298 ins_attrib ins_cost(100);       // Required cost attribute
 3299 ins_attrib ins_size(8);         // Required size attribute (in bits)
 3300 ins_attrib ins_short_branch(0); // Required flag: is this instruction a
 3301                                 // non-matching short branch variant of some
 3302                                                             // long branch?
 3303 ins_attrib ins_alignment(1);    // Required alignment attribute (must be a power of 2)
 3304                                 // specifies the alignment that some part of the instruction (not
 3305                                 // necessarily the start) requires.  If &gt; 1, a compute_padding()
 3306                                 // function must be provided for the instruction
 3307 
 3308 //----------OPERANDS-----------------------------------------------------------
 3309 // Operand definitions must precede instruction definitions for correct parsing
 3310 // in the ADLC because operands constitute user defined types which are used in
 3311 // instruction definitions.
 3312 
 3313 //----------Simple Operands----------------------------------------------------
 3314 // Immediate Operands
 3315 // Integer Immediate
 3316 operand immI() %{
 3317   match(ConI);
 3318 
 3319   op_cost(10);
 3320   format %{ %}
 3321   interface(CONST_INTER);
 3322 %}
 3323 
 3324 // Constant for test vs zero
 3325 operand immI0() %{
 3326   predicate(n-&gt;get_int() == 0);
 3327   match(ConI);
 3328 
 3329   op_cost(0);
 3330   format %{ %}
 3331   interface(CONST_INTER);
 3332 %}
 3333 
 3334 // Constant for increment
 3335 operand immI1() %{
 3336   predicate(n-&gt;get_int() == 1);
 3337   match(ConI);
 3338 
 3339   op_cost(0);
 3340   format %{ %}
 3341   interface(CONST_INTER);
 3342 %}
 3343 
 3344 // Constant for decrement
 3345 operand immI_M1() %{
 3346   predicate(n-&gt;get_int() == -1);
 3347   match(ConI);
 3348 
 3349   op_cost(0);
 3350   format %{ %}
 3351   interface(CONST_INTER);
 3352 %}
 3353 
 3354 // Valid scale values for addressing modes
 3355 operand immI2() %{
 3356   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3357   match(ConI);
 3358 
 3359   format %{ %}
 3360   interface(CONST_INTER);
 3361 %}
 3362 
 3363 operand immI8() %{
 3364   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3365   match(ConI);
 3366 
 3367   op_cost(5);
 3368   format %{ %}
 3369   interface(CONST_INTER);
 3370 %}
 3371 
 3372 operand immU8() %{
 3373   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 3374   match(ConI);
 3375 
 3376   op_cost(5);
 3377   format %{ %}
 3378   interface(CONST_INTER);
 3379 %}
 3380 
 3381 operand immI16() %{
 3382   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3383   match(ConI);
 3384 
 3385   op_cost(10);
 3386   format %{ %}
 3387   interface(CONST_INTER);
 3388 %}
 3389 
 3390 // Int Immediate non-negative
 3391 operand immU31()
 3392 %{
 3393   predicate(n-&gt;get_int() &gt;= 0);
 3394   match(ConI);
 3395 
 3396   op_cost(0);
 3397   format %{ %}
 3398   interface(CONST_INTER);
 3399 %}
 3400 
 3401 // Constant for long shifts
 3402 operand immI_32() %{
 3403   predicate( n-&gt;get_int() == 32 );
 3404   match(ConI);
 3405 
 3406   op_cost(0);
 3407   format %{ %}
 3408   interface(CONST_INTER);
 3409 %}
 3410 
 3411 operand immI_1_31() %{
 3412   predicate( n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31 );
 3413   match(ConI);
 3414 
 3415   op_cost(0);
 3416   format %{ %}
 3417   interface(CONST_INTER);
 3418 %}
 3419 
 3420 operand immI_32_63() %{
 3421   predicate( n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63 );
 3422   match(ConI);
 3423   op_cost(0);
 3424 
 3425   format %{ %}
 3426   interface(CONST_INTER);
 3427 %}
 3428 
 3429 operand immI_1() %{
 3430   predicate( n-&gt;get_int() == 1 );
 3431   match(ConI);
 3432 
 3433   op_cost(0);
 3434   format %{ %}
 3435   interface(CONST_INTER);
 3436 %}
 3437 
 3438 operand immI_2() %{
 3439   predicate( n-&gt;get_int() == 2 );
 3440   match(ConI);
 3441 
 3442   op_cost(0);
 3443   format %{ %}
 3444   interface(CONST_INTER);
 3445 %}
 3446 
 3447 operand immI_3() %{
 3448   predicate( n-&gt;get_int() == 3 );
 3449   match(ConI);
 3450 
 3451   op_cost(0);
 3452   format %{ %}
 3453   interface(CONST_INTER);
 3454 %}
 3455 
 3456 // Pointer Immediate
 3457 operand immP() %{
 3458   match(ConP);
 3459 
 3460   op_cost(10);
 3461   format %{ %}
 3462   interface(CONST_INTER);
 3463 %}
 3464 
 3465 // NULL Pointer Immediate
 3466 operand immP0() %{
 3467   predicate( n-&gt;get_ptr() == 0 );
 3468   match(ConP);
 3469   op_cost(0);
 3470 
 3471   format %{ %}
 3472   interface(CONST_INTER);
 3473 %}
 3474 
 3475 // Long Immediate
 3476 operand immL() %{
 3477   match(ConL);
 3478 
 3479   op_cost(20);
 3480   format %{ %}
 3481   interface(CONST_INTER);
 3482 %}
 3483 
 3484 // Long Immediate zero
 3485 operand immL0() %{
 3486   predicate( n-&gt;get_long() == 0L );
 3487   match(ConL);
 3488   op_cost(0);
 3489 
 3490   format %{ %}
 3491   interface(CONST_INTER);
 3492 %}
 3493 
 3494 // Long Immediate zero
 3495 operand immL_M1() %{
 3496   predicate( n-&gt;get_long() == -1L );
 3497   match(ConL);
 3498   op_cost(0);
 3499 
 3500   format %{ %}
 3501   interface(CONST_INTER);
 3502 %}
 3503 
 3504 // Long immediate from 0 to 127.
 3505 // Used for a shorter form of long mul by 10.
 3506 operand immL_127() %{
 3507   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 127));
 3508   match(ConL);
 3509   op_cost(0);
 3510 
 3511   format %{ %}
 3512   interface(CONST_INTER);
 3513 %}
 3514 
 3515 // Long Immediate: low 32-bit mask
 3516 operand immL_32bits() %{
 3517   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3518   match(ConL);
 3519   op_cost(0);
 3520 
 3521   format %{ %}
 3522   interface(CONST_INTER);
 3523 %}
 3524 
 3525 // Long Immediate: low 32-bit mask
 3526 operand immL32() %{
 3527   predicate(n-&gt;get_long() == (int)(n-&gt;get_long()));
 3528   match(ConL);
 3529   op_cost(20);
 3530 
 3531   format %{ %}
 3532   interface(CONST_INTER);
 3533 %}
 3534 
 3535 //Double Immediate zero
 3536 operand immDPR0() %{
 3537   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3538   // bug that generates code such that NaNs compare equal to 0.0
 3539   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 0.0 &amp;&amp; !g_isnan(n-&gt;getd()) );
 3540   match(ConD);
 3541 
 3542   op_cost(5);
 3543   format %{ %}
 3544   interface(CONST_INTER);
 3545 %}
 3546 
 3547 // Double Immediate one
 3548 operand immDPR1() %{
 3549   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 1.0 );
 3550   match(ConD);
 3551 
 3552   op_cost(5);
 3553   format %{ %}
 3554   interface(CONST_INTER);
 3555 %}
 3556 
 3557 // Double Immediate
 3558 operand immDPR() %{
 3559   predicate(UseSSE&lt;=1);
 3560   match(ConD);
 3561 
 3562   op_cost(5);
 3563   format %{ %}
 3564   interface(CONST_INTER);
 3565 %}
 3566 
 3567 operand immD() %{
 3568   predicate(UseSSE&gt;=2);
 3569   match(ConD);
 3570 
 3571   op_cost(5);
 3572   format %{ %}
 3573   interface(CONST_INTER);
 3574 %}
 3575 
 3576 // Double Immediate zero
 3577 operand immD0() %{
 3578   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3579   // bug that generates code such that NaNs compare equal to 0.0 AND do not
 3580   // compare equal to -0.0.
 3581   predicate( UseSSE&gt;=2 &amp;&amp; jlong_cast(n-&gt;getd()) == 0 );
 3582   match(ConD);
 3583 
 3584   format %{ %}
 3585   interface(CONST_INTER);
 3586 %}
 3587 
 3588 // Float Immediate zero
 3589 operand immFPR0() %{
 3590   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 0.0F);
 3591   match(ConF);
 3592 
 3593   op_cost(5);
 3594   format %{ %}
 3595   interface(CONST_INTER);
 3596 %}
 3597 
 3598 // Float Immediate one
 3599 operand immFPR1() %{
 3600   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 1.0F);
 3601   match(ConF);
 3602 
 3603   op_cost(5);
 3604   format %{ %}
 3605   interface(CONST_INTER);
 3606 %}
 3607 
 3608 // Float Immediate
 3609 operand immFPR() %{
 3610   predicate( UseSSE == 0 );
 3611   match(ConF);
 3612 
 3613   op_cost(5);
 3614   format %{ %}
 3615   interface(CONST_INTER);
 3616 %}
 3617 
 3618 // Float Immediate
 3619 operand immF() %{
 3620   predicate(UseSSE &gt;= 1);
 3621   match(ConF);
 3622 
 3623   op_cost(5);
 3624   format %{ %}
 3625   interface(CONST_INTER);
 3626 %}
 3627 
 3628 // Float Immediate zero.  Zero and not -0.0
 3629 operand immF0() %{
 3630   predicate( UseSSE &gt;= 1 &amp;&amp; jint_cast(n-&gt;getf()) == 0 );
 3631   match(ConF);
 3632 
 3633   op_cost(5);
 3634   format %{ %}
 3635   interface(CONST_INTER);
 3636 %}
 3637 
 3638 // Immediates for special shifts (sign extend)
 3639 
 3640 // Constants for increment
 3641 operand immI_16() %{
 3642   predicate( n-&gt;get_int() == 16 );
 3643   match(ConI);
 3644 
 3645   format %{ %}
 3646   interface(CONST_INTER);
 3647 %}
 3648 
 3649 operand immI_24() %{
 3650   predicate( n-&gt;get_int() == 24 );
 3651   match(ConI);
 3652 
 3653   format %{ %}
 3654   interface(CONST_INTER);
 3655 %}
 3656 
 3657 // Constant for byte-wide masking
 3658 operand immI_255() %{
 3659   predicate( n-&gt;get_int() == 255 );
 3660   match(ConI);
 3661 
 3662   format %{ %}
 3663   interface(CONST_INTER);
 3664 %}
 3665 
 3666 // Constant for short-wide masking
 3667 operand immI_65535() %{
 3668   predicate(n-&gt;get_int() == 65535);
 3669   match(ConI);
 3670 
 3671   format %{ %}
 3672   interface(CONST_INTER);
 3673 %}
 3674 
 3675 // Register Operands
 3676 // Integer Register
 3677 operand rRegI() %{
 3678   constraint(ALLOC_IN_RC(int_reg));
 3679   match(RegI);
 3680   match(xRegI);
 3681   match(eAXRegI);
 3682   match(eBXRegI);
 3683   match(eCXRegI);
 3684   match(eDXRegI);
 3685   match(eDIRegI);
 3686   match(eSIRegI);
 3687 
 3688   format %{ %}
 3689   interface(REG_INTER);
 3690 %}
 3691 
 3692 // Subset of Integer Register
 3693 operand xRegI(rRegI reg) %{
 3694   constraint(ALLOC_IN_RC(int_x_reg));
 3695   match(reg);
 3696   match(eAXRegI);
 3697   match(eBXRegI);
 3698   match(eCXRegI);
 3699   match(eDXRegI);
 3700 
 3701   format %{ %}
 3702   interface(REG_INTER);
 3703 %}
 3704 
 3705 // Special Registers
 3706 operand eAXRegI(xRegI reg) %{
 3707   constraint(ALLOC_IN_RC(eax_reg));
 3708   match(reg);
 3709   match(rRegI);
 3710 
 3711   format %{ &quot;EAX&quot; %}
 3712   interface(REG_INTER);
 3713 %}
 3714 
 3715 // Special Registers
 3716 operand eBXRegI(xRegI reg) %{
 3717   constraint(ALLOC_IN_RC(ebx_reg));
 3718   match(reg);
 3719   match(rRegI);
 3720 
 3721   format %{ &quot;EBX&quot; %}
 3722   interface(REG_INTER);
 3723 %}
 3724 
 3725 operand eCXRegI(xRegI reg) %{
 3726   constraint(ALLOC_IN_RC(ecx_reg));
 3727   match(reg);
 3728   match(rRegI);
 3729 
 3730   format %{ &quot;ECX&quot; %}
 3731   interface(REG_INTER);
 3732 %}
 3733 
 3734 operand eDXRegI(xRegI reg) %{
 3735   constraint(ALLOC_IN_RC(edx_reg));
 3736   match(reg);
 3737   match(rRegI);
 3738 
 3739   format %{ &quot;EDX&quot; %}
 3740   interface(REG_INTER);
 3741 %}
 3742 
 3743 operand eDIRegI(xRegI reg) %{
 3744   constraint(ALLOC_IN_RC(edi_reg));
 3745   match(reg);
 3746   match(rRegI);
 3747 
 3748   format %{ &quot;EDI&quot; %}
 3749   interface(REG_INTER);
 3750 %}
 3751 
 3752 operand naxRegI() %{
 3753   constraint(ALLOC_IN_RC(nax_reg));
 3754   match(RegI);
 3755   match(eCXRegI);
 3756   match(eDXRegI);
 3757   match(eSIRegI);
 3758   match(eDIRegI);
 3759 
 3760   format %{ %}
 3761   interface(REG_INTER);
 3762 %}
 3763 
 3764 operand nadxRegI() %{
 3765   constraint(ALLOC_IN_RC(nadx_reg));
 3766   match(RegI);
 3767   match(eBXRegI);
 3768   match(eCXRegI);
 3769   match(eSIRegI);
 3770   match(eDIRegI);
 3771 
 3772   format %{ %}
 3773   interface(REG_INTER);
 3774 %}
 3775 
 3776 operand ncxRegI() %{
 3777   constraint(ALLOC_IN_RC(ncx_reg));
 3778   match(RegI);
 3779   match(eAXRegI);
 3780   match(eDXRegI);
 3781   match(eSIRegI);
 3782   match(eDIRegI);
 3783 
 3784   format %{ %}
 3785   interface(REG_INTER);
 3786 %}
 3787 
 3788 // // This operand was used by cmpFastUnlock, but conflicted with &#39;object&#39; reg
 3789 // //
 3790 operand eSIRegI(xRegI reg) %{
 3791    constraint(ALLOC_IN_RC(esi_reg));
 3792    match(reg);
 3793    match(rRegI);
 3794 
 3795    format %{ &quot;ESI&quot; %}
 3796    interface(REG_INTER);
 3797 %}
 3798 
 3799 // Pointer Register
 3800 operand anyRegP() %{
 3801   constraint(ALLOC_IN_RC(any_reg));
 3802   match(RegP);
 3803   match(eAXRegP);
 3804   match(eBXRegP);
 3805   match(eCXRegP);
 3806   match(eDIRegP);
 3807   match(eRegP);
 3808 
 3809   format %{ %}
 3810   interface(REG_INTER);
 3811 %}
 3812 
 3813 operand eRegP() %{
 3814   constraint(ALLOC_IN_RC(int_reg));
 3815   match(RegP);
 3816   match(eAXRegP);
 3817   match(eBXRegP);
 3818   match(eCXRegP);
 3819   match(eDIRegP);
 3820 
 3821   format %{ %}
 3822   interface(REG_INTER);
 3823 %}
 3824 
 3825 // On windows95, EBP is not safe to use for implicit null tests.
 3826 operand eRegP_no_EBP() %{
 3827   constraint(ALLOC_IN_RC(int_reg_no_ebp));
 3828   match(RegP);
 3829   match(eAXRegP);
 3830   match(eBXRegP);
 3831   match(eCXRegP);
 3832   match(eDIRegP);
 3833 
 3834   op_cost(100);
 3835   format %{ %}
 3836   interface(REG_INTER);
 3837 %}
 3838 
 3839 operand naxRegP() %{
 3840   constraint(ALLOC_IN_RC(nax_reg));
 3841   match(RegP);
 3842   match(eBXRegP);
 3843   match(eDXRegP);
 3844   match(eCXRegP);
 3845   match(eSIRegP);
 3846   match(eDIRegP);
 3847 
 3848   format %{ %}
 3849   interface(REG_INTER);
 3850 %}
 3851 
 3852 operand nabxRegP() %{
 3853   constraint(ALLOC_IN_RC(nabx_reg));
 3854   match(RegP);
 3855   match(eCXRegP);
 3856   match(eDXRegP);
 3857   match(eSIRegP);
 3858   match(eDIRegP);
 3859 
 3860   format %{ %}
 3861   interface(REG_INTER);
 3862 %}
 3863 
 3864 operand pRegP() %{
 3865   constraint(ALLOC_IN_RC(p_reg));
 3866   match(RegP);
 3867   match(eBXRegP);
 3868   match(eDXRegP);
 3869   match(eSIRegP);
 3870   match(eDIRegP);
 3871 
 3872   format %{ %}
 3873   interface(REG_INTER);
 3874 %}
 3875 
 3876 // Special Registers
 3877 // Return a pointer value
 3878 operand eAXRegP(eRegP reg) %{
 3879   constraint(ALLOC_IN_RC(eax_reg));
 3880   match(reg);
 3881   format %{ &quot;EAX&quot; %}
 3882   interface(REG_INTER);
 3883 %}
 3884 
 3885 // Used in AtomicAdd
 3886 operand eBXRegP(eRegP reg) %{
 3887   constraint(ALLOC_IN_RC(ebx_reg));
 3888   match(reg);
 3889   format %{ &quot;EBX&quot; %}
 3890   interface(REG_INTER);
 3891 %}
 3892 
 3893 // Tail-call (interprocedural jump) to interpreter
 3894 operand eCXRegP(eRegP reg) %{
 3895   constraint(ALLOC_IN_RC(ecx_reg));
 3896   match(reg);
 3897   format %{ &quot;ECX&quot; %}
 3898   interface(REG_INTER);
 3899 %}
 3900 
 3901 operand eDXRegP(eRegP reg) %{
 3902   constraint(ALLOC_IN_RC(edx_reg));
 3903   match(reg);
 3904   format %{ &quot;EDX&quot; %}
 3905   interface(REG_INTER);
 3906 %}
 3907 
 3908 operand eSIRegP(eRegP reg) %{
 3909   constraint(ALLOC_IN_RC(esi_reg));
 3910   match(reg);
 3911   format %{ &quot;ESI&quot; %}
 3912   interface(REG_INTER);
 3913 %}
 3914 
 3915 // Used in rep stosw
 3916 operand eDIRegP(eRegP reg) %{
 3917   constraint(ALLOC_IN_RC(edi_reg));
 3918   match(reg);
 3919   format %{ &quot;EDI&quot; %}
 3920   interface(REG_INTER);
 3921 %}
 3922 
 3923 operand eRegL() %{
 3924   constraint(ALLOC_IN_RC(long_reg));
 3925   match(RegL);
 3926   match(eADXRegL);
 3927 
 3928   format %{ %}
 3929   interface(REG_INTER);
 3930 %}
 3931 
 3932 operand eADXRegL( eRegL reg ) %{
 3933   constraint(ALLOC_IN_RC(eadx_reg));
 3934   match(reg);
 3935 
 3936   format %{ &quot;EDX:EAX&quot; %}
 3937   interface(REG_INTER);
 3938 %}
 3939 
 3940 operand eBCXRegL( eRegL reg ) %{
 3941   constraint(ALLOC_IN_RC(ebcx_reg));
 3942   match(reg);
 3943 
 3944   format %{ &quot;EBX:ECX&quot; %}
 3945   interface(REG_INTER);
 3946 %}
 3947 
 3948 // Special case for integer high multiply
 3949 operand eADXRegL_low_only() %{
 3950   constraint(ALLOC_IN_RC(eadx_reg));
 3951   match(RegL);
 3952 
 3953   format %{ &quot;EAX&quot; %}
 3954   interface(REG_INTER);
 3955 %}
 3956 
 3957 // Flags register, used as output of compare instructions
 3958 operand eFlagsReg() %{
 3959   constraint(ALLOC_IN_RC(int_flags));
 3960   match(RegFlags);
 3961 
 3962   format %{ &quot;EFLAGS&quot; %}
 3963   interface(REG_INTER);
 3964 %}
 3965 
 3966 // Flags register, used as output of FLOATING POINT compare instructions
 3967 operand eFlagsRegU() %{
 3968   constraint(ALLOC_IN_RC(int_flags));
 3969   match(RegFlags);
 3970 
 3971   format %{ &quot;EFLAGS_U&quot; %}
 3972   interface(REG_INTER);
 3973 %}
 3974 
 3975 operand eFlagsRegUCF() %{
 3976   constraint(ALLOC_IN_RC(int_flags));
 3977   match(RegFlags);
 3978   predicate(false);
 3979 
 3980   format %{ &quot;EFLAGS_U_CF&quot; %}
 3981   interface(REG_INTER);
 3982 %}
 3983 
 3984 // Condition Code Register used by long compare
 3985 operand flagsReg_long_LTGE() %{
 3986   constraint(ALLOC_IN_RC(int_flags));
 3987   match(RegFlags);
 3988   format %{ &quot;FLAGS_LTGE&quot; %}
 3989   interface(REG_INTER);
 3990 %}
 3991 operand flagsReg_long_EQNE() %{
 3992   constraint(ALLOC_IN_RC(int_flags));
 3993   match(RegFlags);
 3994   format %{ &quot;FLAGS_EQNE&quot; %}
 3995   interface(REG_INTER);
 3996 %}
 3997 operand flagsReg_long_LEGT() %{
 3998   constraint(ALLOC_IN_RC(int_flags));
 3999   match(RegFlags);
 4000   format %{ &quot;FLAGS_LEGT&quot; %}
 4001   interface(REG_INTER);
 4002 %}
 4003 
 4004 // Condition Code Register used by unsigned long compare
 4005 operand flagsReg_ulong_LTGE() %{
 4006   constraint(ALLOC_IN_RC(int_flags));
 4007   match(RegFlags);
 4008   format %{ &quot;FLAGS_U_LTGE&quot; %}
 4009   interface(REG_INTER);
 4010 %}
 4011 operand flagsReg_ulong_EQNE() %{
 4012   constraint(ALLOC_IN_RC(int_flags));
 4013   match(RegFlags);
 4014   format %{ &quot;FLAGS_U_EQNE&quot; %}
 4015   interface(REG_INTER);
 4016 %}
 4017 operand flagsReg_ulong_LEGT() %{
 4018   constraint(ALLOC_IN_RC(int_flags));
 4019   match(RegFlags);
 4020   format %{ &quot;FLAGS_U_LEGT&quot; %}
 4021   interface(REG_INTER);
 4022 %}
 4023 
 4024 // Float register operands
 4025 operand regDPR() %{
 4026   predicate( UseSSE &lt; 2 );
 4027   constraint(ALLOC_IN_RC(fp_dbl_reg));
 4028   match(RegD);
 4029   match(regDPR1);
 4030   match(regDPR2);
 4031   format %{ %}
 4032   interface(REG_INTER);
 4033 %}
 4034 
 4035 operand regDPR1(regDPR reg) %{
 4036   predicate( UseSSE &lt; 2 );
 4037   constraint(ALLOC_IN_RC(fp_dbl_reg0));
 4038   match(reg);
 4039   format %{ &quot;FPR1&quot; %}
 4040   interface(REG_INTER);
 4041 %}
 4042 
 4043 operand regDPR2(regDPR reg) %{
 4044   predicate( UseSSE &lt; 2 );
 4045   constraint(ALLOC_IN_RC(fp_dbl_reg1));
 4046   match(reg);
 4047   format %{ &quot;FPR2&quot; %}
 4048   interface(REG_INTER);
 4049 %}
 4050 
 4051 operand regnotDPR1(regDPR reg) %{
 4052   predicate( UseSSE &lt; 2 );
 4053   constraint(ALLOC_IN_RC(fp_dbl_notreg0));
 4054   match(reg);
 4055   format %{ %}
 4056   interface(REG_INTER);
 4057 %}
 4058 
 4059 // Float register operands
 4060 operand regFPR() %{
 4061   predicate( UseSSE &lt; 2 );
 4062   constraint(ALLOC_IN_RC(fp_flt_reg));
 4063   match(RegF);
 4064   match(regFPR1);
 4065   format %{ %}
 4066   interface(REG_INTER);
 4067 %}
 4068 
 4069 // Float register operands
 4070 operand regFPR1(regFPR reg) %{
 4071   predicate( UseSSE &lt; 2 );
 4072   constraint(ALLOC_IN_RC(fp_flt_reg0));
 4073   match(reg);
 4074   format %{ &quot;FPR1&quot; %}
 4075   interface(REG_INTER);
 4076 %}
 4077 
 4078 // XMM Float register operands
 4079 operand regF() %{
 4080   predicate( UseSSE&gt;=1 );
 4081   constraint(ALLOC_IN_RC(float_reg_legacy));
 4082   match(RegF);
 4083   format %{ %}
 4084   interface(REG_INTER);
 4085 %}
 4086 
 4087 // Float register operands
 4088 operand vlRegF() %{
 4089    constraint(ALLOC_IN_RC(float_reg_vl));
 4090    match(RegF);
 4091 
 4092    format %{ %}
 4093    interface(REG_INTER);
 4094 %}
 4095 
 4096 // XMM Double register operands
 4097 operand regD() %{
 4098   predicate( UseSSE&gt;=2 );
 4099   constraint(ALLOC_IN_RC(double_reg_legacy));
 4100   match(RegD);
 4101   format %{ %}
 4102   interface(REG_INTER);
 4103 %}
 4104 
 4105 // Double register operands
 4106 operand vlRegD() %{
 4107    constraint(ALLOC_IN_RC(double_reg_vl));
 4108    match(RegD);
 4109 
 4110    format %{ %}
 4111    interface(REG_INTER);
 4112 %}
 4113 
 4114 //----------Memory Operands----------------------------------------------------
 4115 // Direct Memory Operand
 4116 operand direct(immP addr) %{
 4117   match(addr);
 4118 
 4119   format %{ &quot;[$addr]&quot; %}
 4120   interface(MEMORY_INTER) %{
 4121     base(0xFFFFFFFF);
 4122     index(0x4);
 4123     scale(0x0);
 4124     disp($addr);
 4125   %}
 4126 %}
 4127 
 4128 // Indirect Memory Operand
 4129 operand indirect(eRegP reg) %{
 4130   constraint(ALLOC_IN_RC(int_reg));
 4131   match(reg);
 4132 
 4133   format %{ &quot;[$reg]&quot; %}
 4134   interface(MEMORY_INTER) %{
 4135     base($reg);
 4136     index(0x4);
 4137     scale(0x0);
 4138     disp(0x0);
 4139   %}
 4140 %}
 4141 
 4142 // Indirect Memory Plus Short Offset Operand
 4143 operand indOffset8(eRegP reg, immI8 off) %{
 4144   match(AddP reg off);
 4145 
 4146   format %{ &quot;[$reg + $off]&quot; %}
 4147   interface(MEMORY_INTER) %{
 4148     base($reg);
 4149     index(0x4);
 4150     scale(0x0);
 4151     disp($off);
 4152   %}
 4153 %}
 4154 
 4155 // Indirect Memory Plus Long Offset Operand
 4156 operand indOffset32(eRegP reg, immI off) %{
 4157   match(AddP reg off);
 4158 
 4159   format %{ &quot;[$reg + $off]&quot; %}
 4160   interface(MEMORY_INTER) %{
 4161     base($reg);
 4162     index(0x4);
 4163     scale(0x0);
 4164     disp($off);
 4165   %}
 4166 %}
 4167 
 4168 // Indirect Memory Plus Long Offset Operand
 4169 operand indOffset32X(rRegI reg, immP off) %{
 4170   match(AddP off reg);
 4171 
 4172   format %{ &quot;[$reg + $off]&quot; %}
 4173   interface(MEMORY_INTER) %{
 4174     base($reg);
 4175     index(0x4);
 4176     scale(0x0);
 4177     disp($off);
 4178   %}
 4179 %}
 4180 
 4181 // Indirect Memory Plus Index Register Plus Offset Operand
 4182 operand indIndexOffset(eRegP reg, rRegI ireg, immI off) %{
 4183   match(AddP (AddP reg ireg) off);
 4184 
 4185   op_cost(10);
 4186   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4187   interface(MEMORY_INTER) %{
 4188     base($reg);
 4189     index($ireg);
 4190     scale(0x0);
 4191     disp($off);
 4192   %}
 4193 %}
 4194 
 4195 // Indirect Memory Plus Index Register Plus Offset Operand
 4196 operand indIndex(eRegP reg, rRegI ireg) %{
 4197   match(AddP reg ireg);
 4198 
 4199   op_cost(10);
 4200   format %{&quot;[$reg + $ireg]&quot; %}
 4201   interface(MEMORY_INTER) %{
 4202     base($reg);
 4203     index($ireg);
 4204     scale(0x0);
 4205     disp(0x0);
 4206   %}
 4207 %}
 4208 
 4209 // // -------------------------------------------------------------------------
 4210 // // 486 architecture doesn&#39;t support &quot;scale * index + offset&quot; with out a base
 4211 // // -------------------------------------------------------------------------
 4212 // // Scaled Memory Operands
 4213 // // Indirect Memory Times Scale Plus Offset Operand
 4214 // operand indScaleOffset(immP off, rRegI ireg, immI2 scale) %{
 4215 //   match(AddP off (LShiftI ireg scale));
 4216 //
 4217 //   op_cost(10);
 4218 //   format %{&quot;[$off + $ireg &lt;&lt; $scale]&quot; %}
 4219 //   interface(MEMORY_INTER) %{
 4220 //     base(0x4);
 4221 //     index($ireg);
 4222 //     scale($scale);
 4223 //     disp($off);
 4224 //   %}
 4225 // %}
 4226 
 4227 // Indirect Memory Times Scale Plus Index Register
 4228 operand indIndexScale(eRegP reg, rRegI ireg, immI2 scale) %{
 4229   match(AddP reg (LShiftI ireg scale));
 4230 
 4231   op_cost(10);
 4232   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4233   interface(MEMORY_INTER) %{
 4234     base($reg);
 4235     index($ireg);
 4236     scale($scale);
 4237     disp(0x0);
 4238   %}
 4239 %}
 4240 
 4241 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4242 operand indIndexScaleOffset(eRegP reg, immI off, rRegI ireg, immI2 scale) %{
 4243   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4244 
 4245   op_cost(10);
 4246   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4247   interface(MEMORY_INTER) %{
 4248     base($reg);
 4249     index($ireg);
 4250     scale($scale);
 4251     disp($off);
 4252   %}
 4253 %}
 4254 
 4255 //----------Load Long Memory Operands------------------------------------------
 4256 // The load-long idiom will use it&#39;s address expression again after loading
 4257 // the first word of the long.  If the load-long destination overlaps with
 4258 // registers used in the addressing expression, the 2nd half will be loaded
 4259 // from a clobbered address.  Fix this by requiring that load-long use
 4260 // address registers that do not overlap with the load-long target.
 4261 
 4262 // load-long support
 4263 operand load_long_RegP() %{
 4264   constraint(ALLOC_IN_RC(esi_reg));
 4265   match(RegP);
 4266   match(eSIRegP);
 4267   op_cost(100);
 4268   format %{  %}
 4269   interface(REG_INTER);
 4270 %}
 4271 
 4272 // Indirect Memory Operand Long
 4273 operand load_long_indirect(load_long_RegP reg) %{
 4274   constraint(ALLOC_IN_RC(esi_reg));
 4275   match(reg);
 4276 
 4277   format %{ &quot;[$reg]&quot; %}
 4278   interface(MEMORY_INTER) %{
 4279     base($reg);
 4280     index(0x4);
 4281     scale(0x0);
 4282     disp(0x0);
 4283   %}
 4284 %}
 4285 
 4286 // Indirect Memory Plus Long Offset Operand
 4287 operand load_long_indOffset32(load_long_RegP reg, immI off) %{
 4288   match(AddP reg off);
 4289 
 4290   format %{ &quot;[$reg + $off]&quot; %}
 4291   interface(MEMORY_INTER) %{
 4292     base($reg);
 4293     index(0x4);
 4294     scale(0x0);
 4295     disp($off);
 4296   %}
 4297 %}
 4298 
 4299 opclass load_long_memory(load_long_indirect, load_long_indOffset32);
 4300 
 4301 
 4302 //----------Special Memory Operands--------------------------------------------
 4303 // Stack Slot Operand - This operand is used for loading and storing temporary
 4304 //                      values on the stack where a match requires a value to
 4305 //                      flow through memory.
 4306 operand stackSlotP(sRegP reg) %{
 4307   constraint(ALLOC_IN_RC(stack_slots));
 4308   // No match rule because this operand is only generated in matching
 4309   format %{ &quot;[$reg]&quot; %}
 4310   interface(MEMORY_INTER) %{
 4311     base(0x4);   // ESP
 4312     index(0x4);  // No Index
 4313     scale(0x0);  // No Scale
 4314     disp($reg);  // Stack Offset
 4315   %}
 4316 %}
 4317 
 4318 operand stackSlotI(sRegI reg) %{
 4319   constraint(ALLOC_IN_RC(stack_slots));
 4320   // No match rule because this operand is only generated in matching
 4321   format %{ &quot;[$reg]&quot; %}
 4322   interface(MEMORY_INTER) %{
 4323     base(0x4);   // ESP
 4324     index(0x4);  // No Index
 4325     scale(0x0);  // No Scale
 4326     disp($reg);  // Stack Offset
 4327   %}
 4328 %}
 4329 
 4330 operand stackSlotF(sRegF reg) %{
 4331   constraint(ALLOC_IN_RC(stack_slots));
 4332   // No match rule because this operand is only generated in matching
 4333   format %{ &quot;[$reg]&quot; %}
 4334   interface(MEMORY_INTER) %{
 4335     base(0x4);   // ESP
 4336     index(0x4);  // No Index
 4337     scale(0x0);  // No Scale
 4338     disp($reg);  // Stack Offset
 4339   %}
 4340 %}
 4341 
 4342 operand stackSlotD(sRegD reg) %{
 4343   constraint(ALLOC_IN_RC(stack_slots));
 4344   // No match rule because this operand is only generated in matching
 4345   format %{ &quot;[$reg]&quot; %}
 4346   interface(MEMORY_INTER) %{
 4347     base(0x4);   // ESP
 4348     index(0x4);  // No Index
 4349     scale(0x0);  // No Scale
 4350     disp($reg);  // Stack Offset
 4351   %}
 4352 %}
 4353 
 4354 operand stackSlotL(sRegL reg) %{
 4355   constraint(ALLOC_IN_RC(stack_slots));
 4356   // No match rule because this operand is only generated in matching
 4357   format %{ &quot;[$reg]&quot; %}
 4358   interface(MEMORY_INTER) %{
 4359     base(0x4);   // ESP
 4360     index(0x4);  // No Index
 4361     scale(0x0);  // No Scale
 4362     disp($reg);  // Stack Offset
 4363   %}
 4364 %}
 4365 
 4366 //----------Memory Operands - Win95 Implicit Null Variants----------------
 4367 // Indirect Memory Operand
 4368 operand indirect_win95_safe(eRegP_no_EBP reg)
 4369 %{
 4370   constraint(ALLOC_IN_RC(int_reg));
 4371   match(reg);
 4372 
 4373   op_cost(100);
 4374   format %{ &quot;[$reg]&quot; %}
 4375   interface(MEMORY_INTER) %{
 4376     base($reg);
 4377     index(0x4);
 4378     scale(0x0);
 4379     disp(0x0);
 4380   %}
 4381 %}
 4382 
 4383 // Indirect Memory Plus Short Offset Operand
 4384 operand indOffset8_win95_safe(eRegP_no_EBP reg, immI8 off)
 4385 %{
 4386   match(AddP reg off);
 4387 
 4388   op_cost(100);
 4389   format %{ &quot;[$reg + $off]&quot; %}
 4390   interface(MEMORY_INTER) %{
 4391     base($reg);
 4392     index(0x4);
 4393     scale(0x0);
 4394     disp($off);
 4395   %}
 4396 %}
 4397 
 4398 // Indirect Memory Plus Long Offset Operand
 4399 operand indOffset32_win95_safe(eRegP_no_EBP reg, immI off)
 4400 %{
 4401   match(AddP reg off);
 4402 
 4403   op_cost(100);
 4404   format %{ &quot;[$reg + $off]&quot; %}
 4405   interface(MEMORY_INTER) %{
 4406     base($reg);
 4407     index(0x4);
 4408     scale(0x0);
 4409     disp($off);
 4410   %}
 4411 %}
 4412 
 4413 // Indirect Memory Plus Index Register Plus Offset Operand
 4414 operand indIndexOffset_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI off)
 4415 %{
 4416   match(AddP (AddP reg ireg) off);
 4417 
 4418   op_cost(100);
 4419   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4420   interface(MEMORY_INTER) %{
 4421     base($reg);
 4422     index($ireg);
 4423     scale(0x0);
 4424     disp($off);
 4425   %}
 4426 %}
 4427 
 4428 // Indirect Memory Times Scale Plus Index Register
 4429 operand indIndexScale_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI2 scale)
 4430 %{
 4431   match(AddP reg (LShiftI ireg scale));
 4432 
 4433   op_cost(100);
 4434   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4435   interface(MEMORY_INTER) %{
 4436     base($reg);
 4437     index($ireg);
 4438     scale($scale);
 4439     disp(0x0);
 4440   %}
 4441 %}
 4442 
 4443 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4444 operand indIndexScaleOffset_win95_safe(eRegP_no_EBP reg, immI off, rRegI ireg, immI2 scale)
 4445 %{
 4446   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4447 
 4448   op_cost(100);
 4449   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4450   interface(MEMORY_INTER) %{
 4451     base($reg);
 4452     index($ireg);
 4453     scale($scale);
 4454     disp($off);
 4455   %}
 4456 %}
 4457 
 4458 //----------Conditional Branch Operands----------------------------------------
 4459 // Comparison Op  - This is the operation of the comparison, and is limited to
 4460 //                  the following set of codes:
 4461 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4462 //
 4463 // Other attributes of the comparison, such as unsignedness, are specified
 4464 // by the comparison instruction that sets a condition code flags register.
 4465 // That result is represented by a flags operand whose subtype is appropriate
 4466 // to the unsignedness (etc.) of the comparison.
 4467 //
 4468 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4469 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4470 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4471 
 4472 // Comparision Code
 4473 operand cmpOp() %{
 4474   match(Bool);
 4475 
 4476   format %{ &quot;&quot; %}
 4477   interface(COND_INTER) %{
 4478     equal(0x4, &quot;e&quot;);
 4479     not_equal(0x5, &quot;ne&quot;);
 4480     less(0xC, &quot;l&quot;);
 4481     greater_equal(0xD, &quot;ge&quot;);
 4482     less_equal(0xE, &quot;le&quot;);
 4483     greater(0xF, &quot;g&quot;);
 4484     overflow(0x0, &quot;o&quot;);
 4485     no_overflow(0x1, &quot;no&quot;);
 4486   %}
 4487 %}
 4488 
 4489 // Comparison Code, unsigned compare.  Used by FP also, with
 4490 // C2 (unordered) turned into GT or LT already.  The other bits
 4491 // C0 and C3 are turned into Carry &amp; Zero flags.
 4492 operand cmpOpU() %{
 4493   match(Bool);
 4494 
 4495   format %{ &quot;&quot; %}
 4496   interface(COND_INTER) %{
 4497     equal(0x4, &quot;e&quot;);
 4498     not_equal(0x5, &quot;ne&quot;);
 4499     less(0x2, &quot;b&quot;);
 4500     greater_equal(0x3, &quot;nb&quot;);
 4501     less_equal(0x6, &quot;be&quot;);
 4502     greater(0x7, &quot;nbe&quot;);
 4503     overflow(0x0, &quot;o&quot;);
 4504     no_overflow(0x1, &quot;no&quot;);
 4505   %}
 4506 %}
 4507 
 4508 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4509 operand cmpOpUCF() %{
 4510   match(Bool);
 4511   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4512             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4513             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4514             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4515   format %{ &quot;&quot; %}
 4516   interface(COND_INTER) %{
 4517     equal(0x4, &quot;e&quot;);
 4518     not_equal(0x5, &quot;ne&quot;);
 4519     less(0x2, &quot;b&quot;);
 4520     greater_equal(0x3, &quot;nb&quot;);
 4521     less_equal(0x6, &quot;be&quot;);
 4522     greater(0x7, &quot;nbe&quot;);
 4523     overflow(0x0, &quot;o&quot;);
 4524     no_overflow(0x1, &quot;no&quot;);
 4525   %}
 4526 %}
 4527 
 4528 
 4529 // Floating comparisons that can be fixed up with extra conditional jumps
 4530 operand cmpOpUCF2() %{
 4531   match(Bool);
 4532   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4533             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4534   format %{ &quot;&quot; %}
 4535   interface(COND_INTER) %{
 4536     equal(0x4, &quot;e&quot;);
 4537     not_equal(0x5, &quot;ne&quot;);
 4538     less(0x2, &quot;b&quot;);
 4539     greater_equal(0x3, &quot;nb&quot;);
 4540     less_equal(0x6, &quot;be&quot;);
 4541     greater(0x7, &quot;nbe&quot;);
 4542     overflow(0x0, &quot;o&quot;);
 4543     no_overflow(0x1, &quot;no&quot;);
 4544   %}
 4545 %}
 4546 
 4547 // Comparison Code for FP conditional move
 4548 operand cmpOp_fcmov() %{
 4549   match(Bool);
 4550 
 4551   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4552             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4553   format %{ &quot;&quot; %}
 4554   interface(COND_INTER) %{
 4555     equal        (0x0C8);
 4556     not_equal    (0x1C8);
 4557     less         (0x0C0);
 4558     greater_equal(0x1C0);
 4559     less_equal   (0x0D0);
 4560     greater      (0x1D0);
 4561     overflow(0x0, &quot;o&quot;); // not really supported by the instruction
 4562     no_overflow(0x1, &quot;no&quot;); // not really supported by the instruction
 4563   %}
 4564 %}
 4565 
 4566 // Comparison Code used in long compares
 4567 operand cmpOp_commute() %{
 4568   match(Bool);
 4569 
 4570   format %{ &quot;&quot; %}
 4571   interface(COND_INTER) %{
 4572     equal(0x4, &quot;e&quot;);
 4573     not_equal(0x5, &quot;ne&quot;);
 4574     less(0xF, &quot;g&quot;);
 4575     greater_equal(0xE, &quot;le&quot;);
 4576     less_equal(0xD, &quot;ge&quot;);
 4577     greater(0xC, &quot;l&quot;);
 4578     overflow(0x0, &quot;o&quot;);
 4579     no_overflow(0x1, &quot;no&quot;);
 4580   %}
 4581 %}
 4582 
 4583 // Comparison Code used in unsigned long compares
 4584 operand cmpOpU_commute() %{
 4585   match(Bool);
 4586 
 4587   format %{ &quot;&quot; %}
 4588   interface(COND_INTER) %{
 4589     equal(0x4, &quot;e&quot;);
 4590     not_equal(0x5, &quot;ne&quot;);
 4591     less(0x7, &quot;nbe&quot;);
 4592     greater_equal(0x6, &quot;be&quot;);
 4593     less_equal(0x3, &quot;nb&quot;);
 4594     greater(0x2, &quot;b&quot;);
 4595     overflow(0x0, &quot;o&quot;);
 4596     no_overflow(0x1, &quot;no&quot;);
 4597   %}
 4598 %}
 4599 
 4600 //----------OPERAND CLASSES----------------------------------------------------
 4601 // Operand Classes are groups of operands that are used as to simplify
 4602 // instruction definitions by not requiring the AD writer to specify separate
 4603 // instructions for every form of operand when the instruction accepts
 4604 // multiple operand types with the same basic encoding and format.  The classic
 4605 // case of this is memory operands.
 4606 
 4607 opclass memory(direct, indirect, indOffset8, indOffset32, indOffset32X, indIndexOffset,
 4608                indIndex, indIndexScale, indIndexScaleOffset);
 4609 
 4610 // Long memory operations are encoded in 2 instructions and a +4 offset.
 4611 // This means some kind of offset is always required and you cannot use
 4612 // an oop as the offset (done when working on static globals).
 4613 opclass long_memory(direct, indirect, indOffset8, indOffset32, indIndexOffset,
 4614                     indIndex, indIndexScale, indIndexScaleOffset);
 4615 
 4616 
 4617 //----------PIPELINE-----------------------------------------------------------
 4618 // Rules which define the behavior of the target architectures pipeline.
 4619 pipeline %{
 4620 
 4621 //----------ATTRIBUTES---------------------------------------------------------
 4622 attributes %{
 4623   variable_size_instructions;        // Fixed size instructions
 4624   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4625   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4626   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4627   instruction_fetch_units = 1;       // of 16 bytes
 4628 
 4629   // List of nop instructions
 4630   nops( MachNop );
 4631 %}
 4632 
 4633 //----------RESOURCES----------------------------------------------------------
 4634 // Resources are the functional units available to the machine
 4635 
 4636 // Generic P2/P3 pipeline
 4637 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4638 // 3 instructions decoded per cycle.
 4639 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4640 // 2 ALU op, only ALU0 handles mul/div instructions.
 4641 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4642            MS0, MS1, MEM = MS0 | MS1,
 4643            BR, FPU,
 4644            ALU0, ALU1, ALU = ALU0 | ALU1 );
 4645 
 4646 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4647 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4648 
 4649 // Generic P2/P3 pipeline
 4650 pipe_desc(S0, S1, S2, S3, S4, S5);
 4651 
 4652 //----------PIPELINE CLASSES---------------------------------------------------
 4653 // Pipeline Classes describe the stages in which input and output are
 4654 // referenced by the hardware pipeline.
 4655 
 4656 // Naming convention: ialu or fpu
 4657 // Then: _reg
 4658 // Then: _reg if there is a 2nd register
 4659 // Then: _long if it&#39;s a pair of instructions implementing a long
 4660 // Then: _fat if it requires the big decoder
 4661 //   Or: _mem if it requires the big decoder and a memory unit.
 4662 
 4663 // Integer ALU reg operation
 4664 pipe_class ialu_reg(rRegI dst) %{
 4665     single_instruction;
 4666     dst    : S4(write);
 4667     dst    : S3(read);
 4668     DECODE : S0;        // any decoder
 4669     ALU    : S3;        // any alu
 4670 %}
 4671 
 4672 // Long ALU reg operation
 4673 pipe_class ialu_reg_long(eRegL dst) %{
 4674     instruction_count(2);
 4675     dst    : S4(write);
 4676     dst    : S3(read);
 4677     DECODE : S0(2);     // any 2 decoders
 4678     ALU    : S3(2);     // both alus
 4679 %}
 4680 
 4681 // Integer ALU reg operation using big decoder
 4682 pipe_class ialu_reg_fat(rRegI dst) %{
 4683     single_instruction;
 4684     dst    : S4(write);
 4685     dst    : S3(read);
 4686     D0     : S0;        // big decoder only
 4687     ALU    : S3;        // any alu
 4688 %}
 4689 
 4690 // Long ALU reg operation using big decoder
 4691 pipe_class ialu_reg_long_fat(eRegL dst) %{
 4692     instruction_count(2);
 4693     dst    : S4(write);
 4694     dst    : S3(read);
 4695     D0     : S0(2);     // big decoder only; twice
 4696     ALU    : S3(2);     // any 2 alus
 4697 %}
 4698 
 4699 // Integer ALU reg-reg operation
 4700 pipe_class ialu_reg_reg(rRegI dst, rRegI src) %{
 4701     single_instruction;
 4702     dst    : S4(write);
 4703     src    : S3(read);
 4704     DECODE : S0;        // any decoder
 4705     ALU    : S3;        // any alu
 4706 %}
 4707 
 4708 // Long ALU reg-reg operation
 4709 pipe_class ialu_reg_reg_long(eRegL dst, eRegL src) %{
 4710     instruction_count(2);
 4711     dst    : S4(write);
 4712     src    : S3(read);
 4713     DECODE : S0(2);     // any 2 decoders
 4714     ALU    : S3(2);     // both alus
 4715 %}
 4716 
 4717 // Integer ALU reg-reg operation
 4718 pipe_class ialu_reg_reg_fat(rRegI dst, memory src) %{
 4719     single_instruction;
 4720     dst    : S4(write);
 4721     src    : S3(read);
 4722     D0     : S0;        // big decoder only
 4723     ALU    : S3;        // any alu
 4724 %}
 4725 
 4726 // Long ALU reg-reg operation
 4727 pipe_class ialu_reg_reg_long_fat(eRegL dst, eRegL src) %{
 4728     instruction_count(2);
 4729     dst    : S4(write);
 4730     src    : S3(read);
 4731     D0     : S0(2);     // big decoder only; twice
 4732     ALU    : S3(2);     // both alus
 4733 %}
 4734 
 4735 // Integer ALU reg-mem operation
 4736 pipe_class ialu_reg_mem(rRegI dst, memory mem) %{
 4737     single_instruction;
 4738     dst    : S5(write);
 4739     mem    : S3(read);
 4740     D0     : S0;        // big decoder only
 4741     ALU    : S4;        // any alu
 4742     MEM    : S3;        // any mem
 4743 %}
 4744 
 4745 // Long ALU reg-mem operation
 4746 pipe_class ialu_reg_long_mem(eRegL dst, load_long_memory mem) %{
 4747     instruction_count(2);
 4748     dst    : S5(write);
 4749     mem    : S3(read);
 4750     D0     : S0(2);     // big decoder only; twice
 4751     ALU    : S4(2);     // any 2 alus
 4752     MEM    : S3(2);     // both mems
 4753 %}
 4754 
 4755 // Integer mem operation (prefetch)
 4756 pipe_class ialu_mem(memory mem)
 4757 %{
 4758     single_instruction;
 4759     mem    : S3(read);
 4760     D0     : S0;        // big decoder only
 4761     MEM    : S3;        // any mem
 4762 %}
 4763 
 4764 // Integer Store to Memory
 4765 pipe_class ialu_mem_reg(memory mem, rRegI src) %{
 4766     single_instruction;
 4767     mem    : S3(read);
 4768     src    : S5(read);
 4769     D0     : S0;        // big decoder only
 4770     ALU    : S4;        // any alu
 4771     MEM    : S3;
 4772 %}
 4773 
 4774 // Long Store to Memory
 4775 pipe_class ialu_mem_long_reg(memory mem, eRegL src) %{
 4776     instruction_count(2);
 4777     mem    : S3(read);
 4778     src    : S5(read);
 4779     D0     : S0(2);     // big decoder only; twice
 4780     ALU    : S4(2);     // any 2 alus
 4781     MEM    : S3(2);     // Both mems
 4782 %}
 4783 
 4784 // Integer Store to Memory
 4785 pipe_class ialu_mem_imm(memory mem) %{
 4786     single_instruction;
 4787     mem    : S3(read);
 4788     D0     : S0;        // big decoder only
 4789     ALU    : S4;        // any alu
 4790     MEM    : S3;
 4791 %}
 4792 
 4793 // Integer ALU0 reg-reg operation
 4794 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src) %{
 4795     single_instruction;
 4796     dst    : S4(write);
 4797     src    : S3(read);
 4798     D0     : S0;        // Big decoder only
 4799     ALU0   : S3;        // only alu0
 4800 %}
 4801 
 4802 // Integer ALU0 reg-mem operation
 4803 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem) %{
 4804     single_instruction;
 4805     dst    : S5(write);
 4806     mem    : S3(read);
 4807     D0     : S0;        // big decoder only
 4808     ALU0   : S4;        // ALU0 only
 4809     MEM    : S3;        // any mem
 4810 %}
 4811 
 4812 // Integer ALU reg-reg operation
 4813 pipe_class ialu_cr_reg_reg(eFlagsReg cr, rRegI src1, rRegI src2) %{
 4814     single_instruction;
 4815     cr     : S4(write);
 4816     src1   : S3(read);
 4817     src2   : S3(read);
 4818     DECODE : S0;        // any decoder
 4819     ALU    : S3;        // any alu
 4820 %}
 4821 
 4822 // Integer ALU reg-imm operation
 4823 pipe_class ialu_cr_reg_imm(eFlagsReg cr, rRegI src1) %{
 4824     single_instruction;
 4825     cr     : S4(write);
 4826     src1   : S3(read);
 4827     DECODE : S0;        // any decoder
 4828     ALU    : S3;        // any alu
 4829 %}
 4830 
 4831 // Integer ALU reg-mem operation
 4832 pipe_class ialu_cr_reg_mem(eFlagsReg cr, rRegI src1, memory src2) %{
 4833     single_instruction;
 4834     cr     : S4(write);
 4835     src1   : S3(read);
 4836     src2   : S3(read);
 4837     D0     : S0;        // big decoder only
 4838     ALU    : S4;        // any alu
 4839     MEM    : S3;
 4840 %}
 4841 
 4842 // Conditional move reg-reg
 4843 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y ) %{
 4844     instruction_count(4);
 4845     y      : S4(read);
 4846     q      : S3(read);
 4847     p      : S3(read);
 4848     DECODE : S0(4);     // any decoder
 4849 %}
 4850 
 4851 // Conditional move reg-reg
 4852 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, eFlagsReg cr ) %{
 4853     single_instruction;
 4854     dst    : S4(write);
 4855     src    : S3(read);
 4856     cr     : S3(read);
 4857     DECODE : S0;        // any decoder
 4858 %}
 4859 
 4860 // Conditional move reg-mem
 4861 pipe_class pipe_cmov_mem( eFlagsReg cr, rRegI dst, memory src) %{
 4862     single_instruction;
 4863     dst    : S4(write);
 4864     src    : S3(read);
 4865     cr     : S3(read);
 4866     DECODE : S0;        // any decoder
 4867     MEM    : S3;
 4868 %}
 4869 
 4870 // Conditional move reg-reg long
 4871 pipe_class pipe_cmov_reg_long( eFlagsReg cr, eRegL dst, eRegL src) %{
 4872     single_instruction;
 4873     dst    : S4(write);
 4874     src    : S3(read);
 4875     cr     : S3(read);
 4876     DECODE : S0(2);     // any 2 decoders
 4877 %}
 4878 
 4879 // Conditional move double reg-reg
 4880 pipe_class pipe_cmovDPR_reg( eFlagsReg cr, regDPR1 dst, regDPR src) %{
 4881     single_instruction;
 4882     dst    : S4(write);
 4883     src    : S3(read);
 4884     cr     : S3(read);
 4885     DECODE : S0;        // any decoder
 4886 %}
 4887 
 4888 // Float reg-reg operation
 4889 pipe_class fpu_reg(regDPR dst) %{
 4890     instruction_count(2);
 4891     dst    : S3(read);
 4892     DECODE : S0(2);     // any 2 decoders
 4893     FPU    : S3;
 4894 %}
 4895 
 4896 // Float reg-reg operation
 4897 pipe_class fpu_reg_reg(regDPR dst, regDPR src) %{
 4898     instruction_count(2);
 4899     dst    : S4(write);
 4900     src    : S3(read);
 4901     DECODE : S0(2);     // any 2 decoders
 4902     FPU    : S3;
 4903 %}
 4904 
 4905 // Float reg-reg operation
 4906 pipe_class fpu_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2) %{
 4907     instruction_count(3);
 4908     dst    : S4(write);
 4909     src1   : S3(read);
 4910     src2   : S3(read);
 4911     DECODE : S0(3);     // any 3 decoders
 4912     FPU    : S3(2);
 4913 %}
 4914 
 4915 // Float reg-reg operation
 4916 pipe_class fpu_reg_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2, regDPR src3) %{
 4917     instruction_count(4);
 4918     dst    : S4(write);
 4919     src1   : S3(read);
 4920     src2   : S3(read);
 4921     src3   : S3(read);
 4922     DECODE : S0(4);     // any 3 decoders
 4923     FPU    : S3(2);
 4924 %}
 4925 
 4926 // Float reg-reg operation
 4927 pipe_class fpu_reg_mem_reg_reg(regDPR dst, memory src1, regDPR src2, regDPR src3) %{
 4928     instruction_count(4);
 4929     dst    : S4(write);
 4930     src1   : S3(read);
 4931     src2   : S3(read);
 4932     src3   : S3(read);
 4933     DECODE : S1(3);     // any 3 decoders
 4934     D0     : S0;        // Big decoder only
 4935     FPU    : S3(2);
 4936     MEM    : S3;
 4937 %}
 4938 
 4939 // Float reg-mem operation
 4940 pipe_class fpu_reg_mem(regDPR dst, memory mem) %{
 4941     instruction_count(2);
 4942     dst    : S5(write);
 4943     mem    : S3(read);
 4944     D0     : S0;        // big decoder only
 4945     DECODE : S1;        // any decoder for FPU POP
 4946     FPU    : S4;
 4947     MEM    : S3;        // any mem
 4948 %}
 4949 
 4950 // Float reg-mem operation
 4951 pipe_class fpu_reg_reg_mem(regDPR dst, regDPR src1, memory mem) %{
 4952     instruction_count(3);
 4953     dst    : S5(write);
 4954     src1   : S3(read);
 4955     mem    : S3(read);
 4956     D0     : S0;        // big decoder only
 4957     DECODE : S1(2);     // any decoder for FPU POP
 4958     FPU    : S4;
 4959     MEM    : S3;        // any mem
 4960 %}
 4961 
 4962 // Float mem-reg operation
 4963 pipe_class fpu_mem_reg(memory mem, regDPR src) %{
 4964     instruction_count(2);
 4965     src    : S5(read);
 4966     mem    : S3(read);
 4967     DECODE : S0;        // any decoder for FPU PUSH
 4968     D0     : S1;        // big decoder only
 4969     FPU    : S4;
 4970     MEM    : S3;        // any mem
 4971 %}
 4972 
 4973 pipe_class fpu_mem_reg_reg(memory mem, regDPR src1, regDPR src2) %{
 4974     instruction_count(3);
 4975     src1   : S3(read);
 4976     src2   : S3(read);
 4977     mem    : S3(read);
 4978     DECODE : S0(2);     // any decoder for FPU PUSH
 4979     D0     : S1;        // big decoder only
 4980     FPU    : S4;
 4981     MEM    : S3;        // any mem
 4982 %}
 4983 
 4984 pipe_class fpu_mem_reg_mem(memory mem, regDPR src1, memory src2) %{
 4985     instruction_count(3);
 4986     src1   : S3(read);
 4987     src2   : S3(read);
 4988     mem    : S4(read);
 4989     DECODE : S0;        // any decoder for FPU PUSH
 4990     D0     : S0(2);     // big decoder only
 4991     FPU    : S4;
 4992     MEM    : S3(2);     // any mem
 4993 %}
 4994 
 4995 pipe_class fpu_mem_mem(memory dst, memory src1) %{
 4996     instruction_count(2);
 4997     src1   : S3(read);
 4998     dst    : S4(read);
 4999     D0     : S0(2);     // big decoder only
 5000     MEM    : S3(2);     // any mem
 5001 %}
 5002 
 5003 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2) %{
 5004     instruction_count(3);
 5005     src1   : S3(read);
 5006     src2   : S3(read);
 5007     dst    : S4(read);
 5008     D0     : S0(3);     // big decoder only
 5009     FPU    : S4;
 5010     MEM    : S3(3);     // any mem
 5011 %}
 5012 
 5013 pipe_class fpu_mem_reg_con(memory mem, regDPR src1) %{
 5014     instruction_count(3);
 5015     src1   : S4(read);
 5016     mem    : S4(read);
 5017     DECODE : S0;        // any decoder for FPU PUSH
 5018     D0     : S0(2);     // big decoder only
 5019     FPU    : S4;
 5020     MEM    : S3(2);     // any mem
 5021 %}
 5022 
 5023 // Float load constant
 5024 pipe_class fpu_reg_con(regDPR dst) %{
 5025     instruction_count(2);
 5026     dst    : S5(write);
 5027     D0     : S0;        // big decoder only for the load
 5028     DECODE : S1;        // any decoder for FPU POP
 5029     FPU    : S4;
 5030     MEM    : S3;        // any mem
 5031 %}
 5032 
 5033 // Float load constant
 5034 pipe_class fpu_reg_reg_con(regDPR dst, regDPR src) %{
 5035     instruction_count(3);
 5036     dst    : S5(write);
 5037     src    : S3(read);
 5038     D0     : S0;        // big decoder only for the load
 5039     DECODE : S1(2);     // any decoder for FPU POP
 5040     FPU    : S4;
 5041     MEM    : S3;        // any mem
 5042 %}
 5043 
 5044 // UnConditional branch
 5045 pipe_class pipe_jmp( label labl ) %{
 5046     single_instruction;
 5047     BR   : S3;
 5048 %}
 5049 
 5050 // Conditional branch
 5051 pipe_class pipe_jcc( cmpOp cmp, eFlagsReg cr, label labl ) %{
 5052     single_instruction;
 5053     cr    : S1(read);
 5054     BR    : S3;
 5055 %}
 5056 
 5057 // Allocation idiom
 5058 pipe_class pipe_cmpxchg( eRegP dst, eRegP heap_ptr ) %{
 5059     instruction_count(1); force_serialization;
 5060     fixed_latency(6);
 5061     heap_ptr : S3(read);
 5062     DECODE   : S0(3);
 5063     D0       : S2;
 5064     MEM      : S3;
 5065     ALU      : S3(2);
 5066     dst      : S5(write);
 5067     BR       : S5;
 5068 %}
 5069 
 5070 // Generic big/slow expanded idiom
 5071 pipe_class pipe_slow(  ) %{
 5072     instruction_count(10); multiple_bundles; force_serialization;
 5073     fixed_latency(100);
 5074     D0  : S0(2);
 5075     MEM : S3(2);
 5076 %}
 5077 
 5078 // The real do-nothing guy
 5079 pipe_class empty( ) %{
 5080     instruction_count(0);
 5081 %}
 5082 
 5083 // Define the class for the Nop node
 5084 define %{
 5085    MachNop = empty;
 5086 %}
 5087 
 5088 %}
 5089 
 5090 //----------INSTRUCTIONS-------------------------------------------------------
 5091 //
 5092 // match      -- States which machine-independent subtree may be replaced
 5093 //               by this instruction.
 5094 // ins_cost   -- The estimated cost of this instruction is used by instruction
 5095 //               selection to identify a minimum cost tree of machine
 5096 //               instructions that matches a tree of machine-independent
 5097 //               instructions.
 5098 // format     -- A string providing the disassembly for this instruction.
 5099 //               The value of an instruction&#39;s operand may be inserted
 5100 //               by referring to it with a &#39;$&#39; prefix.
 5101 // opcode     -- Three instruction opcodes may be provided.  These are referred
 5102 //               to within an encode class as $primary, $secondary, and $tertiary
 5103 //               respectively.  The primary opcode is commonly used to
 5104 //               indicate the type of machine instruction, while secondary
 5105 //               and tertiary are often used for prefix options or addressing
 5106 //               modes.
 5107 // ins_encode -- A list of encode classes with parameters. The encode class
 5108 //               name must have been defined in an &#39;enc_class&#39; specification
 5109 //               in the encode section of the architecture description.
 5110 
 5111 //----------BSWAP-Instruction--------------------------------------------------
 5112 instruct bytes_reverse_int(rRegI dst) %{
 5113   match(Set dst (ReverseBytesI dst));
 5114 
 5115   format %{ &quot;BSWAP  $dst&quot; %}
 5116   opcode(0x0F, 0xC8);
 5117   ins_encode( OpcP, OpcSReg(dst) );
 5118   ins_pipe( ialu_reg );
 5119 %}
 5120 
 5121 instruct bytes_reverse_long(eRegL dst) %{
 5122   match(Set dst (ReverseBytesL dst));
 5123 
 5124   format %{ &quot;BSWAP  $dst.lo\n\t&quot;
 5125             &quot;BSWAP  $dst.hi\n\t&quot;
 5126             &quot;XCHG   $dst.lo $dst.hi&quot; %}
 5127 
 5128   ins_cost(125);
 5129   ins_encode( bswap_long_bytes(dst) );
 5130   ins_pipe( ialu_reg_reg);
 5131 %}
 5132 
 5133 instruct bytes_reverse_unsigned_short(rRegI dst, eFlagsReg cr) %{
 5134   match(Set dst (ReverseBytesUS dst));
 5135   effect(KILL cr);
 5136 
 5137   format %{ &quot;BSWAP  $dst\n\t&quot;
 5138             &quot;SHR    $dst,16\n\t&quot; %}
 5139   ins_encode %{
 5140     __ bswapl($dst$$Register);
 5141     __ shrl($dst$$Register, 16);
 5142   %}
 5143   ins_pipe( ialu_reg );
 5144 %}
 5145 
 5146 instruct bytes_reverse_short(rRegI dst, eFlagsReg cr) %{
 5147   match(Set dst (ReverseBytesS dst));
 5148   effect(KILL cr);
 5149 
 5150   format %{ &quot;BSWAP  $dst\n\t&quot;
 5151             &quot;SAR    $dst,16\n\t&quot; %}
 5152   ins_encode %{
 5153     __ bswapl($dst$$Register);
 5154     __ sarl($dst$$Register, 16);
 5155   %}
 5156   ins_pipe( ialu_reg );
 5157 %}
 5158 
 5159 
 5160 //---------- Zeros Count Instructions ------------------------------------------
 5161 
 5162 instruct countLeadingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5163   predicate(UseCountLeadingZerosInstruction);
 5164   match(Set dst (CountLeadingZerosI src));
 5165   effect(KILL cr);
 5166 
 5167   format %{ &quot;LZCNT  $dst, $src\t# count leading zeros (int)&quot; %}
 5168   ins_encode %{
 5169     __ lzcntl($dst$$Register, $src$$Register);
 5170   %}
 5171   ins_pipe(ialu_reg);
 5172 %}
 5173 
 5174 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, eFlagsReg cr) %{
 5175   predicate(!UseCountLeadingZerosInstruction);
 5176   match(Set dst (CountLeadingZerosI src));
 5177   effect(KILL cr);
 5178 
 5179   format %{ &quot;BSR    $dst, $src\t# count leading zeros (int)\n\t&quot;
 5180             &quot;JNZ    skip\n\t&quot;
 5181             &quot;MOV    $dst, -1\n&quot;
 5182       &quot;skip:\n\t&quot;
 5183             &quot;NEG    $dst\n\t&quot;
 5184             &quot;ADD    $dst, 31&quot; %}
 5185   ins_encode %{
 5186     Register Rdst = $dst$$Register;
 5187     Register Rsrc = $src$$Register;
 5188     Label skip;
 5189     __ bsrl(Rdst, Rsrc);
 5190     __ jccb(Assembler::notZero, skip);
 5191     __ movl(Rdst, -1);
 5192     __ bind(skip);
 5193     __ negl(Rdst);
 5194     __ addl(Rdst, BitsPerInt - 1);
 5195   %}
 5196   ins_pipe(ialu_reg);
 5197 %}
 5198 
 5199 instruct countLeadingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5200   predicate(UseCountLeadingZerosInstruction);
 5201   match(Set dst (CountLeadingZerosL src));
 5202   effect(TEMP dst, KILL cr);
 5203 
 5204   format %{ &quot;LZCNT  $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5205             &quot;JNC    done\n\t&quot;
 5206             &quot;LZCNT  $dst, $src.lo\n\t&quot;
 5207             &quot;ADD    $dst, 32\n&quot;
 5208       &quot;done:&quot; %}
 5209   ins_encode %{
 5210     Register Rdst = $dst$$Register;
 5211     Register Rsrc = $src$$Register;
 5212     Label done;
 5213     __ lzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5214     __ jccb(Assembler::carryClear, done);
 5215     __ lzcntl(Rdst, Rsrc);
 5216     __ addl(Rdst, BitsPerInt);
 5217     __ bind(done);
 5218   %}
 5219   ins_pipe(ialu_reg);
 5220 %}
 5221 
 5222 instruct countLeadingZerosL_bsr(rRegI dst, eRegL src, eFlagsReg cr) %{
 5223   predicate(!UseCountLeadingZerosInstruction);
 5224   match(Set dst (CountLeadingZerosL src));
 5225   effect(TEMP dst, KILL cr);
 5226 
 5227   format %{ &quot;BSR    $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5228             &quot;JZ     msw_is_zero\n\t&quot;
 5229             &quot;ADD    $dst, 32\n\t&quot;
 5230             &quot;JMP    not_zero\n&quot;
 5231       &quot;msw_is_zero:\n\t&quot;
 5232             &quot;BSR    $dst, $src.lo\n\t&quot;
 5233             &quot;JNZ    not_zero\n\t&quot;
 5234             &quot;MOV    $dst, -1\n&quot;
 5235       &quot;not_zero:\n\t&quot;
 5236             &quot;NEG    $dst\n\t&quot;
 5237             &quot;ADD    $dst, 63\n&quot; %}
 5238  ins_encode %{
 5239     Register Rdst = $dst$$Register;
 5240     Register Rsrc = $src$$Register;
 5241     Label msw_is_zero;
 5242     Label not_zero;
 5243     __ bsrl(Rdst, HIGH_FROM_LOW(Rsrc));
 5244     __ jccb(Assembler::zero, msw_is_zero);
 5245     __ addl(Rdst, BitsPerInt);
 5246     __ jmpb(not_zero);
 5247     __ bind(msw_is_zero);
 5248     __ bsrl(Rdst, Rsrc);
 5249     __ jccb(Assembler::notZero, not_zero);
 5250     __ movl(Rdst, -1);
 5251     __ bind(not_zero);
 5252     __ negl(Rdst);
 5253     __ addl(Rdst, BitsPerLong - 1);
 5254   %}
 5255   ins_pipe(ialu_reg);
 5256 %}
 5257 
 5258 instruct countTrailingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5259   predicate(UseCountTrailingZerosInstruction);
 5260   match(Set dst (CountTrailingZerosI src));
 5261   effect(KILL cr);
 5262 
 5263   format %{ &quot;TZCNT    $dst, $src\t# count trailing zeros (int)&quot; %}
 5264   ins_encode %{
 5265     __ tzcntl($dst$$Register, $src$$Register);
 5266   %}
 5267   ins_pipe(ialu_reg);
 5268 %}
 5269 
 5270 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, eFlagsReg cr) %{
 5271   predicate(!UseCountTrailingZerosInstruction);
 5272   match(Set dst (CountTrailingZerosI src));
 5273   effect(KILL cr);
 5274 
 5275   format %{ &quot;BSF    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 5276             &quot;JNZ    done\n\t&quot;
 5277             &quot;MOV    $dst, 32\n&quot;
 5278       &quot;done:&quot; %}
 5279   ins_encode %{
 5280     Register Rdst = $dst$$Register;
 5281     Label done;
 5282     __ bsfl(Rdst, $src$$Register);
 5283     __ jccb(Assembler::notZero, done);
 5284     __ movl(Rdst, BitsPerInt);
 5285     __ bind(done);
 5286   %}
 5287   ins_pipe(ialu_reg);
 5288 %}
 5289 
 5290 instruct countTrailingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5291   predicate(UseCountTrailingZerosInstruction);
 5292   match(Set dst (CountTrailingZerosL src));
 5293   effect(TEMP dst, KILL cr);
 5294 
 5295   format %{ &quot;TZCNT  $dst, $src.lo\t# count trailing zeros (long) \n\t&quot;
 5296             &quot;JNC    done\n\t&quot;
 5297             &quot;TZCNT  $dst, $src.hi\n\t&quot;
 5298             &quot;ADD    $dst, 32\n&quot;
 5299             &quot;done:&quot; %}
 5300   ins_encode %{
 5301     Register Rdst = $dst$$Register;
 5302     Register Rsrc = $src$$Register;
 5303     Label done;
 5304     __ tzcntl(Rdst, Rsrc);
 5305     __ jccb(Assembler::carryClear, done);
 5306     __ tzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5307     __ addl(Rdst, BitsPerInt);
 5308     __ bind(done);
 5309   %}
 5310   ins_pipe(ialu_reg);
 5311 %}
 5312 
 5313 instruct countTrailingZerosL_bsf(rRegI dst, eRegL src, eFlagsReg cr) %{
 5314   predicate(!UseCountTrailingZerosInstruction);
 5315   match(Set dst (CountTrailingZerosL src));
 5316   effect(TEMP dst, KILL cr);
 5317 
 5318   format %{ &quot;BSF    $dst, $src.lo\t# count trailing zeros (long)\n\t&quot;
 5319             &quot;JNZ    done\n\t&quot;
 5320             &quot;BSF    $dst, $src.hi\n\t&quot;
 5321             &quot;JNZ    msw_not_zero\n\t&quot;
 5322             &quot;MOV    $dst, 32\n&quot;
 5323       &quot;msw_not_zero:\n\t&quot;
 5324             &quot;ADD    $dst, 32\n&quot;
 5325       &quot;done:&quot; %}
 5326   ins_encode %{
 5327     Register Rdst = $dst$$Register;
 5328     Register Rsrc = $src$$Register;
 5329     Label msw_not_zero;
 5330     Label done;
 5331     __ bsfl(Rdst, Rsrc);
 5332     __ jccb(Assembler::notZero, done);
 5333     __ bsfl(Rdst, HIGH_FROM_LOW(Rsrc));
 5334     __ jccb(Assembler::notZero, msw_not_zero);
 5335     __ movl(Rdst, BitsPerInt);
 5336     __ bind(msw_not_zero);
 5337     __ addl(Rdst, BitsPerInt);
 5338     __ bind(done);
 5339   %}
 5340   ins_pipe(ialu_reg);
 5341 %}
 5342 
 5343 
 5344 //---------- Population Count Instructions -------------------------------------
 5345 
 5346 instruct popCountI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5347   predicate(UsePopCountInstruction);
 5348   match(Set dst (PopCountI src));
 5349   effect(KILL cr);
 5350 
 5351   format %{ &quot;POPCNT $dst, $src&quot; %}
 5352   ins_encode %{
 5353     __ popcntl($dst$$Register, $src$$Register);
 5354   %}
 5355   ins_pipe(ialu_reg);
 5356 %}
 5357 
 5358 instruct popCountI_mem(rRegI dst, memory mem, eFlagsReg cr) %{
 5359   predicate(UsePopCountInstruction);
 5360   match(Set dst (PopCountI (LoadI mem)));
 5361   effect(KILL cr);
 5362 
 5363   format %{ &quot;POPCNT $dst, $mem&quot; %}
 5364   ins_encode %{
 5365     __ popcntl($dst$$Register, $mem$$Address);
 5366   %}
 5367   ins_pipe(ialu_reg);
 5368 %}
 5369 
 5370 // Note: Long.bitCount(long) returns an int.
 5371 instruct popCountL(rRegI dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 5372   predicate(UsePopCountInstruction);
 5373   match(Set dst (PopCountL src));
 5374   effect(KILL cr, TEMP tmp, TEMP dst);
 5375 
 5376   format %{ &quot;POPCNT $dst, $src.lo\n\t&quot;
 5377             &quot;POPCNT $tmp, $src.hi\n\t&quot;
 5378             &quot;ADD    $dst, $tmp&quot; %}
 5379   ins_encode %{
 5380     __ popcntl($dst$$Register, $src$$Register);
 5381     __ popcntl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 5382     __ addl($dst$$Register, $tmp$$Register);
 5383   %}
 5384   ins_pipe(ialu_reg);
 5385 %}
 5386 
 5387 // Note: Long.bitCount(long) returns an int.
 5388 instruct popCountL_mem(rRegI dst, memory mem, rRegI tmp, eFlagsReg cr) %{
 5389   predicate(UsePopCountInstruction);
 5390   match(Set dst (PopCountL (LoadL mem)));
 5391   effect(KILL cr, TEMP tmp, TEMP dst);
 5392 
 5393   format %{ &quot;POPCNT $dst, $mem\n\t&quot;
 5394             &quot;POPCNT $tmp, $mem+4\n\t&quot;
 5395             &quot;ADD    $dst, $tmp&quot; %}
 5396   ins_encode %{
 5397     //__ popcntl($dst$$Register, $mem$$Address$$first);
 5398     //__ popcntl($tmp$$Register, $mem$$Address$$second);
 5399     __ popcntl($dst$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none));
 5400     __ popcntl($tmp$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none));
 5401     __ addl($dst$$Register, $tmp$$Register);
 5402   %}
 5403   ins_pipe(ialu_reg);
 5404 %}
 5405 
 5406 
 5407 //----------Load/Store/Move Instructions---------------------------------------
 5408 //----------Load Instructions--------------------------------------------------
 5409 // Load Byte (8bit signed)
 5410 instruct loadB(xRegI dst, memory mem) %{
 5411   match(Set dst (LoadB mem));
 5412 
 5413   ins_cost(125);
 5414   format %{ &quot;MOVSX8 $dst,$mem\t# byte&quot; %}
 5415 
 5416   ins_encode %{
 5417     __ movsbl($dst$$Register, $mem$$Address);
 5418   %}
 5419 
 5420   ins_pipe(ialu_reg_mem);
 5421 %}
 5422 
 5423 // Load Byte (8bit signed) into Long Register
 5424 instruct loadB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5425   match(Set dst (ConvI2L (LoadB mem)));
 5426   effect(KILL cr);
 5427 
 5428   ins_cost(375);
 5429   format %{ &quot;MOVSX8 $dst.lo,$mem\t# byte -&gt; long\n\t&quot;
 5430             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5431             &quot;SAR    $dst.hi,7&quot; %}
 5432 
 5433   ins_encode %{
 5434     __ movsbl($dst$$Register, $mem$$Address);
 5435     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5436     __ sarl(HIGH_FROM_LOW($dst$$Register), 7); // 24+1 MSB are already signed extended.
 5437   %}
 5438 
 5439   ins_pipe(ialu_reg_mem);
 5440 %}
 5441 
 5442 // Load Unsigned Byte (8bit UNsigned)
 5443 instruct loadUB(xRegI dst, memory mem) %{
 5444   match(Set dst (LoadUB mem));
 5445 
 5446   ins_cost(125);
 5447   format %{ &quot;MOVZX8 $dst,$mem\t# ubyte -&gt; int&quot; %}
 5448 
 5449   ins_encode %{
 5450     __ movzbl($dst$$Register, $mem$$Address);
 5451   %}
 5452 
 5453   ins_pipe(ialu_reg_mem);
 5454 %}
 5455 
 5456 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 5457 instruct loadUB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5458   match(Set dst (ConvI2L (LoadUB mem)));
 5459   effect(KILL cr);
 5460 
 5461   ins_cost(250);
 5462   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte -&gt; long\n\t&quot;
 5463             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5464 
 5465   ins_encode %{
 5466     Register Rdst = $dst$$Register;
 5467     __ movzbl(Rdst, $mem$$Address);
 5468     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5469   %}
 5470 
 5471   ins_pipe(ialu_reg_mem);
 5472 %}
 5473 
 5474 // Load Unsigned Byte (8 bit UNsigned) with mask into Long Register
 5475 instruct loadUB2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5476   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5477   effect(KILL cr);
 5478 
 5479   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5480             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5481             &quot;AND    $dst.lo,right_n_bits($mask, 8)&quot; %}
 5482   ins_encode %{
 5483     Register Rdst = $dst$$Register;
 5484     __ movzbl(Rdst, $mem$$Address);
 5485     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5486     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 5487   %}
 5488   ins_pipe(ialu_reg_mem);
 5489 %}
 5490 
 5491 // Load Short (16bit signed)
 5492 instruct loadS(rRegI dst, memory mem) %{
 5493   match(Set dst (LoadS mem));
 5494 
 5495   ins_cost(125);
 5496   format %{ &quot;MOVSX  $dst,$mem\t# short&quot; %}
 5497 
 5498   ins_encode %{
 5499     __ movswl($dst$$Register, $mem$$Address);
 5500   %}
 5501 
 5502   ins_pipe(ialu_reg_mem);
 5503 %}
 5504 
 5505 // Load Short (16 bit signed) to Byte (8 bit signed)
 5506 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5507   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5508 
 5509   ins_cost(125);
 5510   format %{ &quot;MOVSX  $dst, $mem\t# short -&gt; byte&quot; %}
 5511   ins_encode %{
 5512     __ movsbl($dst$$Register, $mem$$Address);
 5513   %}
 5514   ins_pipe(ialu_reg_mem);
 5515 %}
 5516 
 5517 // Load Short (16bit signed) into Long Register
 5518 instruct loadS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5519   match(Set dst (ConvI2L (LoadS mem)));
 5520   effect(KILL cr);
 5521 
 5522   ins_cost(375);
 5523   format %{ &quot;MOVSX  $dst.lo,$mem\t# short -&gt; long\n\t&quot;
 5524             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5525             &quot;SAR    $dst.hi,15&quot; %}
 5526 
 5527   ins_encode %{
 5528     __ movswl($dst$$Register, $mem$$Address);
 5529     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5530     __ sarl(HIGH_FROM_LOW($dst$$Register), 15); // 16+1 MSB are already signed extended.
 5531   %}
 5532 
 5533   ins_pipe(ialu_reg_mem);
 5534 %}
 5535 
 5536 // Load Unsigned Short/Char (16bit unsigned)
 5537 instruct loadUS(rRegI dst, memory mem) %{
 5538   match(Set dst (LoadUS mem));
 5539 
 5540   ins_cost(125);
 5541   format %{ &quot;MOVZX  $dst,$mem\t# ushort/char -&gt; int&quot; %}
 5542 
 5543   ins_encode %{
 5544     __ movzwl($dst$$Register, $mem$$Address);
 5545   %}
 5546 
 5547   ins_pipe(ialu_reg_mem);
 5548 %}
 5549 
 5550 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5551 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5552   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5553 
 5554   ins_cost(125);
 5555   format %{ &quot;MOVSX  $dst, $mem\t# ushort -&gt; byte&quot; %}
 5556   ins_encode %{
 5557     __ movsbl($dst$$Register, $mem$$Address);
 5558   %}
 5559   ins_pipe(ialu_reg_mem);
 5560 %}
 5561 
 5562 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 5563 instruct loadUS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5564   match(Set dst (ConvI2L (LoadUS mem)));
 5565   effect(KILL cr);
 5566 
 5567   ins_cost(250);
 5568   format %{ &quot;MOVZX  $dst.lo,$mem\t# ushort/char -&gt; long\n\t&quot;
 5569             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5570 
 5571   ins_encode %{
 5572     __ movzwl($dst$$Register, $mem$$Address);
 5573     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5574   %}
 5575 
 5576   ins_pipe(ialu_reg_mem);
 5577 %}
 5578 
 5579 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 5580 instruct loadUS2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5581   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5582   effect(KILL cr);
 5583 
 5584   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ushort/char &amp; 0xFF -&gt; long\n\t&quot;
 5585             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5586   ins_encode %{
 5587     Register Rdst = $dst$$Register;
 5588     __ movzbl(Rdst, $mem$$Address);
 5589     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5590   %}
 5591   ins_pipe(ialu_reg_mem);
 5592 %}
 5593 
 5594 // Load Unsigned Short/Char (16 bit UNsigned) with a 32-bit mask into Long Register
 5595 instruct loadUS2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5596   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5597   effect(KILL cr);
 5598 
 5599   format %{ &quot;MOVZX  $dst.lo, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5600             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5601             &quot;AND    $dst.lo,right_n_bits($mask, 16)&quot; %}
 5602   ins_encode %{
 5603     Register Rdst = $dst$$Register;
 5604     __ movzwl(Rdst, $mem$$Address);
 5605     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5606     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 5607   %}
 5608   ins_pipe(ialu_reg_mem);
 5609 %}
 5610 
 5611 // Load Integer
 5612 instruct loadI(rRegI dst, memory mem) %{
 5613   match(Set dst (LoadI mem));
 5614 
 5615   ins_cost(125);
 5616   format %{ &quot;MOV    $dst,$mem\t# int&quot; %}
 5617 
 5618   ins_encode %{
 5619     __ movl($dst$$Register, $mem$$Address);
 5620   %}
 5621 
 5622   ins_pipe(ialu_reg_mem);
 5623 %}
 5624 
 5625 // Load Integer (32 bit signed) to Byte (8 bit signed)
 5626 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5627   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5628 
 5629   ins_cost(125);
 5630   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; byte&quot; %}
 5631   ins_encode %{
 5632     __ movsbl($dst$$Register, $mem$$Address);
 5633   %}
 5634   ins_pipe(ialu_reg_mem);
 5635 %}
 5636 
 5637 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 5638 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 5639   match(Set dst (AndI (LoadI mem) mask));
 5640 
 5641   ins_cost(125);
 5642   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ubyte&quot; %}
 5643   ins_encode %{
 5644     __ movzbl($dst$$Register, $mem$$Address);
 5645   %}
 5646   ins_pipe(ialu_reg_mem);
 5647 %}
 5648 
 5649 // Load Integer (32 bit signed) to Short (16 bit signed)
 5650 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5651   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5652 
 5653   ins_cost(125);
 5654   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; short&quot; %}
 5655   ins_encode %{
 5656     __ movswl($dst$$Register, $mem$$Address);
 5657   %}
 5658   ins_pipe(ialu_reg_mem);
 5659 %}
 5660 
 5661 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5662 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5663   match(Set dst (AndI (LoadI mem) mask));
 5664 
 5665   ins_cost(125);
 5666   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5667   ins_encode %{
 5668     __ movzwl($dst$$Register, $mem$$Address);
 5669   %}
 5670   ins_pipe(ialu_reg_mem);
 5671 %}
 5672 
 5673 // Load Integer into Long Register
 5674 instruct loadI2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5675   match(Set dst (ConvI2L (LoadI mem)));
 5676   effect(KILL cr);
 5677 
 5678   ins_cost(375);
 5679   format %{ &quot;MOV    $dst.lo,$mem\t# int -&gt; long\n\t&quot;
 5680             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5681             &quot;SAR    $dst.hi,31&quot; %}
 5682 
 5683   ins_encode %{
 5684     __ movl($dst$$Register, $mem$$Address);
 5685     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5686     __ sarl(HIGH_FROM_LOW($dst$$Register), 31);
 5687   %}
 5688 
 5689   ins_pipe(ialu_reg_mem);
 5690 %}
 5691 
 5692 // Load Integer with mask 0xFF into Long Register
 5693 instruct loadI2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5694   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5695   effect(KILL cr);
 5696 
 5697   format %{ &quot;MOVZX8 $dst.lo,$mem\t# int &amp; 0xFF -&gt; long\n\t&quot;
 5698             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5699   ins_encode %{
 5700     Register Rdst = $dst$$Register;
 5701     __ movzbl(Rdst, $mem$$Address);
 5702     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5703   %}
 5704   ins_pipe(ialu_reg_mem);
 5705 %}
 5706 
 5707 // Load Integer with mask 0xFFFF into Long Register
 5708 instruct loadI2L_immI_65535(eRegL dst, memory mem, immI_65535 mask, eFlagsReg cr) %{
 5709   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5710   effect(KILL cr);
 5711 
 5712   format %{ &quot;MOVZX  $dst.lo,$mem\t# int &amp; 0xFFFF -&gt; long\n\t&quot;
 5713             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5714   ins_encode %{
 5715     Register Rdst = $dst$$Register;
 5716     __ movzwl(Rdst, $mem$$Address);
 5717     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5718   %}
 5719   ins_pipe(ialu_reg_mem);
 5720 %}
 5721 
 5722 // Load Integer with 31-bit mask into Long Register
 5723 instruct loadI2L_immU31(eRegL dst, memory mem, immU31 mask, eFlagsReg cr) %{
 5724   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5725   effect(KILL cr);
 5726 
 5727   format %{ &quot;MOV    $dst.lo,$mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5728             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5729             &quot;AND    $dst.lo,$mask&quot; %}
 5730   ins_encode %{
 5731     Register Rdst = $dst$$Register;
 5732     __ movl(Rdst, $mem$$Address);
 5733     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5734     __ andl(Rdst, $mask$$constant);
 5735   %}
 5736   ins_pipe(ialu_reg_mem);
 5737 %}
 5738 
 5739 // Load Unsigned Integer into Long Register
 5740 instruct loadUI2L(eRegL dst, memory mem, immL_32bits mask, eFlagsReg cr) %{
 5741   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5742   effect(KILL cr);
 5743 
 5744   ins_cost(250);
 5745   format %{ &quot;MOV    $dst.lo,$mem\t# uint -&gt; long\n\t&quot;
 5746             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5747 
 5748   ins_encode %{
 5749     __ movl($dst$$Register, $mem$$Address);
 5750     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5751   %}
 5752 
 5753   ins_pipe(ialu_reg_mem);
 5754 %}
 5755 
 5756 // Load Long.  Cannot clobber address while loading, so restrict address
 5757 // register to ESI
 5758 instruct loadL(eRegL dst, load_long_memory mem) %{
 5759   predicate(!((LoadLNode*)n)-&gt;require_atomic_access());
 5760   match(Set dst (LoadL mem));
 5761 
 5762   ins_cost(250);
 5763   format %{ &quot;MOV    $dst.lo,$mem\t# long\n\t&quot;
 5764             &quot;MOV    $dst.hi,$mem+4&quot; %}
 5765 
 5766   ins_encode %{
 5767     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 5768     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 5769     __ movl($dst$$Register, Amemlo);
 5770     __ movl(HIGH_FROM_LOW($dst$$Register), Amemhi);
 5771   %}
 5772 
 5773   ins_pipe(ialu_reg_long_mem);
 5774 %}
 5775 
 5776 // Volatile Load Long.  Must be atomic, so do 64-bit FILD
 5777 // then store it down to the stack and reload on the int
 5778 // side.
 5779 instruct loadL_volatile(stackSlotL dst, memory mem) %{
 5780   predicate(UseSSE&lt;=1 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5781   match(Set dst (LoadL mem));
 5782 
 5783   ins_cost(200);
 5784   format %{ &quot;FILD   $mem\t# Atomic volatile long load\n\t&quot;
 5785             &quot;FISTp  $dst&quot; %}
 5786   ins_encode(enc_loadL_volatile(mem,dst));
 5787   ins_pipe( fpu_reg_mem );
 5788 %}
 5789 
 5790 instruct loadLX_volatile(stackSlotL dst, memory mem, regD tmp) %{
 5791   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5792   match(Set dst (LoadL mem));
 5793   effect(TEMP tmp);
 5794   ins_cost(180);
 5795   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5796             &quot;MOVSD  $dst,$tmp&quot; %}
 5797   ins_encode %{
 5798     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5799     __ movdbl(Address(rsp, $dst$$disp), $tmp$$XMMRegister);
 5800   %}
 5801   ins_pipe( pipe_slow );
 5802 %}
 5803 
 5804 instruct loadLX_reg_volatile(eRegL dst, memory mem, regD tmp) %{
 5805   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5806   match(Set dst (LoadL mem));
 5807   effect(TEMP tmp);
 5808   ins_cost(160);
 5809   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5810             &quot;MOVD   $dst.lo,$tmp\n\t&quot;
 5811             &quot;PSRLQ  $tmp,32\n\t&quot;
 5812             &quot;MOVD   $dst.hi,$tmp&quot; %}
 5813   ins_encode %{
 5814     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5815     __ movdl($dst$$Register, $tmp$$XMMRegister);
 5816     __ psrlq($tmp$$XMMRegister, 32);
 5817     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
 5818   %}
 5819   ins_pipe( pipe_slow );
 5820 %}
 5821 
 5822 // Load Range
 5823 instruct loadRange(rRegI dst, memory mem) %{
 5824   match(Set dst (LoadRange mem));
 5825 
 5826   ins_cost(125);
 5827   format %{ &quot;MOV    $dst,$mem&quot; %}
 5828   opcode(0x8B);
 5829   ins_encode( OpcP, RegMem(dst,mem));
 5830   ins_pipe( ialu_reg_mem );
 5831 %}
 5832 
 5833 
 5834 // Load Pointer
 5835 instruct loadP(eRegP dst, memory mem) %{
 5836   match(Set dst (LoadP mem));
 5837 
 5838   ins_cost(125);
 5839   format %{ &quot;MOV    $dst,$mem&quot; %}
 5840   opcode(0x8B);
 5841   ins_encode( OpcP, RegMem(dst,mem));
 5842   ins_pipe( ialu_reg_mem );
 5843 %}
 5844 
 5845 // Load Klass Pointer
 5846 instruct loadKlass(eRegP dst, memory mem) %{
 5847   match(Set dst (LoadKlass mem));
 5848 
 5849   ins_cost(125);
 5850   format %{ &quot;MOV    $dst,$mem&quot; %}
 5851   opcode(0x8B);
 5852   ins_encode( OpcP, RegMem(dst,mem));
 5853   ins_pipe( ialu_reg_mem );
 5854 %}
 5855 
 5856 // Load Double
 5857 instruct loadDPR(regDPR dst, memory mem) %{
 5858   predicate(UseSSE&lt;=1);
 5859   match(Set dst (LoadD mem));
 5860 
 5861   ins_cost(150);
 5862   format %{ &quot;FLD_D  ST,$mem\n\t&quot;
 5863             &quot;FSTP   $dst&quot; %}
 5864   opcode(0xDD);               /* DD /0 */
 5865   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5866               Pop_Reg_DPR(dst) );
 5867   ins_pipe( fpu_reg_mem );
 5868 %}
 5869 
 5870 // Load Double to XMM
 5871 instruct loadD(regD dst, memory mem) %{
 5872   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
 5873   match(Set dst (LoadD mem));
 5874   ins_cost(145);
 5875   format %{ &quot;MOVSD  $dst,$mem&quot; %}
 5876   ins_encode %{
 5877     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5878   %}
 5879   ins_pipe( pipe_slow );
 5880 %}
 5881 
 5882 instruct loadD_partial(regD dst, memory mem) %{
 5883   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
 5884   match(Set dst (LoadD mem));
 5885   ins_cost(145);
 5886   format %{ &quot;MOVLPD $dst,$mem&quot; %}
 5887   ins_encode %{
 5888     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5889   %}
 5890   ins_pipe( pipe_slow );
 5891 %}
 5892 
 5893 // Load to XMM register (single-precision floating point)
 5894 // MOVSS instruction
 5895 instruct loadF(regF dst, memory mem) %{
 5896   predicate(UseSSE&gt;=1);
 5897   match(Set dst (LoadF mem));
 5898   ins_cost(145);
 5899   format %{ &quot;MOVSS  $dst,$mem&quot; %}
 5900   ins_encode %{
 5901     __ movflt ($dst$$XMMRegister, $mem$$Address);
 5902   %}
 5903   ins_pipe( pipe_slow );
 5904 %}
 5905 
 5906 // Load Float
 5907 instruct loadFPR(regFPR dst, memory mem) %{
 5908   predicate(UseSSE==0);
 5909   match(Set dst (LoadF mem));
 5910 
 5911   ins_cost(150);
 5912   format %{ &quot;FLD_S  ST,$mem\n\t&quot;
 5913             &quot;FSTP   $dst&quot; %}
 5914   opcode(0xD9);               /* D9 /0 */
 5915   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5916               Pop_Reg_FPR(dst) );
 5917   ins_pipe( fpu_reg_mem );
 5918 %}
 5919 
 5920 // Load Effective Address
 5921 instruct leaP8(eRegP dst, indOffset8 mem) %{
 5922   match(Set dst mem);
 5923 
 5924   ins_cost(110);
 5925   format %{ &quot;LEA    $dst,$mem&quot; %}
 5926   opcode(0x8D);
 5927   ins_encode( OpcP, RegMem(dst,mem));
 5928   ins_pipe( ialu_reg_reg_fat );
 5929 %}
 5930 
 5931 instruct leaP32(eRegP dst, indOffset32 mem) %{
 5932   match(Set dst mem);
 5933 
 5934   ins_cost(110);
 5935   format %{ &quot;LEA    $dst,$mem&quot; %}
 5936   opcode(0x8D);
 5937   ins_encode( OpcP, RegMem(dst,mem));
 5938   ins_pipe( ialu_reg_reg_fat );
 5939 %}
 5940 
 5941 instruct leaPIdxOff(eRegP dst, indIndexOffset mem) %{
 5942   match(Set dst mem);
 5943 
 5944   ins_cost(110);
 5945   format %{ &quot;LEA    $dst,$mem&quot; %}
 5946   opcode(0x8D);
 5947   ins_encode( OpcP, RegMem(dst,mem));
 5948   ins_pipe( ialu_reg_reg_fat );
 5949 %}
 5950 
 5951 instruct leaPIdxScale(eRegP dst, indIndexScale mem) %{
 5952   match(Set dst mem);
 5953 
 5954   ins_cost(110);
 5955   format %{ &quot;LEA    $dst,$mem&quot; %}
 5956   opcode(0x8D);
 5957   ins_encode( OpcP, RegMem(dst,mem));
 5958   ins_pipe( ialu_reg_reg_fat );
 5959 %}
 5960 
 5961 instruct leaPIdxScaleOff(eRegP dst, indIndexScaleOffset mem) %{
 5962   match(Set dst mem);
 5963 
 5964   ins_cost(110);
 5965   format %{ &quot;LEA    $dst,$mem&quot; %}
 5966   opcode(0x8D);
 5967   ins_encode( OpcP, RegMem(dst,mem));
 5968   ins_pipe( ialu_reg_reg_fat );
 5969 %}
 5970 
 5971 // Load Constant
 5972 instruct loadConI(rRegI dst, immI src) %{
 5973   match(Set dst src);
 5974 
 5975   format %{ &quot;MOV    $dst,$src&quot; %}
 5976   ins_encode( LdImmI(dst, src) );
 5977   ins_pipe( ialu_reg_fat );
 5978 %}
 5979 
 5980 // Load Constant zero
 5981 instruct loadConI0(rRegI dst, immI0 src, eFlagsReg cr) %{
 5982   match(Set dst src);
 5983   effect(KILL cr);
 5984 
 5985   ins_cost(50);
 5986   format %{ &quot;XOR    $dst,$dst&quot; %}
 5987   opcode(0x33);  /* + rd */
 5988   ins_encode( OpcP, RegReg( dst, dst ) );
 5989   ins_pipe( ialu_reg );
 5990 %}
 5991 
 5992 instruct loadConP(eRegP dst, immP src) %{
 5993   match(Set dst src);
 5994 
 5995   format %{ &quot;MOV    $dst,$src&quot; %}
 5996   opcode(0xB8);  /* + rd */
 5997   ins_encode( LdImmP(dst, src) );
 5998   ins_pipe( ialu_reg_fat );
 5999 %}
 6000 
 6001 instruct loadConL(eRegL dst, immL src, eFlagsReg cr) %{
 6002   match(Set dst src);
 6003   effect(KILL cr);
 6004   ins_cost(200);
 6005   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
 6006             &quot;MOV    $dst.hi,$src.hi&quot; %}
 6007   opcode(0xB8);
 6008   ins_encode( LdImmL_Lo(dst, src), LdImmL_Hi(dst, src) );
 6009   ins_pipe( ialu_reg_long_fat );
 6010 %}
 6011 
 6012 instruct loadConL0(eRegL dst, immL0 src, eFlagsReg cr) %{
 6013   match(Set dst src);
 6014   effect(KILL cr);
 6015   ins_cost(150);
 6016   format %{ &quot;XOR    $dst.lo,$dst.lo\n\t&quot;
 6017             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 6018   opcode(0x33,0x33);
 6019   ins_encode( RegReg_Lo(dst,dst), RegReg_Hi(dst, dst) );
 6020   ins_pipe( ialu_reg_long );
 6021 %}
 6022 
 6023 // The instruction usage is guarded by predicate in operand immFPR().
 6024 instruct loadConFPR(regFPR dst, immFPR con) %{
 6025   match(Set dst con);
 6026   ins_cost(125);
 6027   format %{ &quot;FLD_S  ST,[$constantaddress]\t# load from constant table: float=$con\n\t&quot;
 6028             &quot;FSTP   $dst&quot; %}
 6029   ins_encode %{
 6030     __ fld_s($constantaddress($con));
 6031     __ fstp_d($dst$$reg);
 6032   %}
 6033   ins_pipe(fpu_reg_con);
 6034 %}
 6035 
 6036 // The instruction usage is guarded by predicate in operand immFPR0().
 6037 instruct loadConFPR0(regFPR dst, immFPR0 con) %{
 6038   match(Set dst con);
 6039   ins_cost(125);
 6040   format %{ &quot;FLDZ   ST\n\t&quot;
 6041             &quot;FSTP   $dst&quot; %}
 6042   ins_encode %{
 6043     __ fldz();
 6044     __ fstp_d($dst$$reg);
 6045   %}
 6046   ins_pipe(fpu_reg_con);
 6047 %}
 6048 
 6049 // The instruction usage is guarded by predicate in operand immFPR1().
 6050 instruct loadConFPR1(regFPR dst, immFPR1 con) %{
 6051   match(Set dst con);
 6052   ins_cost(125);
 6053   format %{ &quot;FLD1   ST\n\t&quot;
 6054             &quot;FSTP   $dst&quot; %}
 6055   ins_encode %{
 6056     __ fld1();
 6057     __ fstp_d($dst$$reg);
 6058   %}
 6059   ins_pipe(fpu_reg_con);
 6060 %}
 6061 
 6062 // The instruction usage is guarded by predicate in operand immF().
 6063 instruct loadConF(regF dst, immF con) %{
 6064   match(Set dst con);
 6065   ins_cost(125);
 6066   format %{ &quot;MOVSS  $dst,[$constantaddress]\t# load from constant table: float=$con&quot; %}
 6067   ins_encode %{
 6068     __ movflt($dst$$XMMRegister, $constantaddress($con));
 6069   %}
 6070   ins_pipe(pipe_slow);
 6071 %}
 6072 
 6073 // The instruction usage is guarded by predicate in operand immF0().
 6074 instruct loadConF0(regF dst, immF0 src) %{
 6075   match(Set dst src);
 6076   ins_cost(100);
 6077   format %{ &quot;XORPS  $dst,$dst\t# float 0.0&quot; %}
 6078   ins_encode %{
 6079     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 6080   %}
 6081   ins_pipe(pipe_slow);
 6082 %}
 6083 
 6084 // The instruction usage is guarded by predicate in operand immDPR().
 6085 instruct loadConDPR(regDPR dst, immDPR con) %{
 6086   match(Set dst con);
 6087   ins_cost(125);
 6088 
 6089   format %{ &quot;FLD_D  ST,[$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 6090             &quot;FSTP   $dst&quot; %}
 6091   ins_encode %{
 6092     __ fld_d($constantaddress($con));
 6093     __ fstp_d($dst$$reg);
 6094   %}
 6095   ins_pipe(fpu_reg_con);
 6096 %}
 6097 
 6098 // The instruction usage is guarded by predicate in operand immDPR0().
 6099 instruct loadConDPR0(regDPR dst, immDPR0 con) %{
 6100   match(Set dst con);
 6101   ins_cost(125);
 6102 
 6103   format %{ &quot;FLDZ   ST\n\t&quot;
 6104             &quot;FSTP   $dst&quot; %}
 6105   ins_encode %{
 6106     __ fldz();
 6107     __ fstp_d($dst$$reg);
 6108   %}
 6109   ins_pipe(fpu_reg_con);
 6110 %}
 6111 
 6112 // The instruction usage is guarded by predicate in operand immDPR1().
 6113 instruct loadConDPR1(regDPR dst, immDPR1 con) %{
 6114   match(Set dst con);
 6115   ins_cost(125);
 6116 
 6117   format %{ &quot;FLD1   ST\n\t&quot;
 6118             &quot;FSTP   $dst&quot; %}
 6119   ins_encode %{
 6120     __ fld1();
 6121     __ fstp_d($dst$$reg);
 6122   %}
 6123   ins_pipe(fpu_reg_con);
 6124 %}
 6125 
 6126 // The instruction usage is guarded by predicate in operand immD().
 6127 instruct loadConD(regD dst, immD con) %{
 6128   match(Set dst con);
 6129   ins_cost(125);
 6130   format %{ &quot;MOVSD  $dst,[$constantaddress]\t# load from constant table: double=$con&quot; %}
 6131   ins_encode %{
 6132     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 6133   %}
 6134   ins_pipe(pipe_slow);
 6135 %}
 6136 
 6137 // The instruction usage is guarded by predicate in operand immD0().
 6138 instruct loadConD0(regD dst, immD0 src) %{
 6139   match(Set dst src);
 6140   ins_cost(100);
 6141   format %{ &quot;XORPD  $dst,$dst\t# double 0.0&quot; %}
 6142   ins_encode %{
 6143     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 6144   %}
 6145   ins_pipe( pipe_slow );
 6146 %}
 6147 
 6148 // Load Stack Slot
 6149 instruct loadSSI(rRegI dst, stackSlotI src) %{
 6150   match(Set dst src);
 6151   ins_cost(125);
 6152 
 6153   format %{ &quot;MOV    $dst,$src&quot; %}
 6154   opcode(0x8B);
 6155   ins_encode( OpcP, RegMem(dst,src));
 6156   ins_pipe( ialu_reg_mem );
 6157 %}
 6158 
 6159 instruct loadSSL(eRegL dst, stackSlotL src) %{
 6160   match(Set dst src);
 6161 
 6162   ins_cost(200);
 6163   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6164             &quot;MOV    $dst+4,$src.hi&quot; %}
 6165   opcode(0x8B, 0x8B);
 6166   ins_encode( OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ) );
 6167   ins_pipe( ialu_mem_long_reg );
 6168 %}
 6169 
 6170 // Load Stack Slot
 6171 instruct loadSSP(eRegP dst, stackSlotP src) %{
 6172   match(Set dst src);
 6173   ins_cost(125);
 6174 
 6175   format %{ &quot;MOV    $dst,$src&quot; %}
 6176   opcode(0x8B);
 6177   ins_encode( OpcP, RegMem(dst,src));
 6178   ins_pipe( ialu_reg_mem );
 6179 %}
 6180 
 6181 // Load Stack Slot
 6182 instruct loadSSF(regFPR dst, stackSlotF src) %{
 6183   match(Set dst src);
 6184   ins_cost(125);
 6185 
 6186   format %{ &quot;FLD_S  $src\n\t&quot;
 6187             &quot;FSTP   $dst&quot; %}
 6188   opcode(0xD9);               /* D9 /0, FLD m32real */
 6189   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6190               Pop_Reg_FPR(dst) );
 6191   ins_pipe( fpu_reg_mem );
 6192 %}
 6193 
 6194 // Load Stack Slot
 6195 instruct loadSSD(regDPR dst, stackSlotD src) %{
 6196   match(Set dst src);
 6197   ins_cost(125);
 6198 
 6199   format %{ &quot;FLD_D  $src\n\t&quot;
 6200             &quot;FSTP   $dst&quot; %}
 6201   opcode(0xDD);               /* DD /0, FLD m64real */
 6202   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6203               Pop_Reg_DPR(dst) );
 6204   ins_pipe( fpu_reg_mem );
 6205 %}
 6206 
 6207 // Prefetch instructions for allocation.
 6208 // Must be safe to execute with invalid address (cannot fault).
 6209 
 6210 instruct prefetchAlloc0( memory mem ) %{
 6211   predicate(UseSSE==0 &amp;&amp; AllocatePrefetchInstr!=3);
 6212   match(PrefetchAllocation mem);
 6213   ins_cost(0);
 6214   size(0);
 6215   format %{ &quot;Prefetch allocation (non-SSE is empty encoding)&quot; %}
 6216   ins_encode();
 6217   ins_pipe(empty);
 6218 %}
 6219 
 6220 instruct prefetchAlloc( memory mem ) %{
 6221   predicate(AllocatePrefetchInstr==3);
 6222   match( PrefetchAllocation mem );
 6223   ins_cost(100);
 6224 
 6225   format %{ &quot;PREFETCHW $mem\t! Prefetch allocation into L1 cache and mark modified&quot; %}
 6226   ins_encode %{
 6227     __ prefetchw($mem$$Address);
 6228   %}
 6229   ins_pipe(ialu_mem);
 6230 %}
 6231 
 6232 instruct prefetchAllocNTA( memory mem ) %{
 6233   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==0);
 6234   match(PrefetchAllocation mem);
 6235   ins_cost(100);
 6236 
 6237   format %{ &quot;PREFETCHNTA $mem\t! Prefetch allocation into non-temporal cache for write&quot; %}
 6238   ins_encode %{
 6239     __ prefetchnta($mem$$Address);
 6240   %}
 6241   ins_pipe(ialu_mem);
 6242 %}
 6243 
 6244 instruct prefetchAllocT0( memory mem ) %{
 6245   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==1);
 6246   match(PrefetchAllocation mem);
 6247   ins_cost(100);
 6248 
 6249   format %{ &quot;PREFETCHT0 $mem\t! Prefetch allocation into L1 and L2 caches for write&quot; %}
 6250   ins_encode %{
 6251     __ prefetcht0($mem$$Address);
 6252   %}
 6253   ins_pipe(ialu_mem);
 6254 %}
 6255 
 6256 instruct prefetchAllocT2( memory mem ) %{
 6257   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==2);
 6258   match(PrefetchAllocation mem);
 6259   ins_cost(100);
 6260 
 6261   format %{ &quot;PREFETCHT2 $mem\t! Prefetch allocation into L2 cache for write&quot; %}
 6262   ins_encode %{
 6263     __ prefetcht2($mem$$Address);
 6264   %}
 6265   ins_pipe(ialu_mem);
 6266 %}
 6267 
 6268 //----------Store Instructions-------------------------------------------------
 6269 
 6270 // Store Byte
 6271 instruct storeB(memory mem, xRegI src) %{
 6272   match(Set mem (StoreB mem src));
 6273 
 6274   ins_cost(125);
 6275   format %{ &quot;MOV8   $mem,$src&quot; %}
 6276   opcode(0x88);
 6277   ins_encode( OpcP, RegMem( src, mem ) );
 6278   ins_pipe( ialu_mem_reg );
 6279 %}
 6280 
 6281 // Store Char/Short
 6282 instruct storeC(memory mem, rRegI src) %{
 6283   match(Set mem (StoreC mem src));
 6284 
 6285   ins_cost(125);
 6286   format %{ &quot;MOV16  $mem,$src&quot; %}
 6287   opcode(0x89, 0x66);
 6288   ins_encode( OpcS, OpcP, RegMem( src, mem ) );
 6289   ins_pipe( ialu_mem_reg );
 6290 %}
 6291 
 6292 // Store Integer
 6293 instruct storeI(memory mem, rRegI src) %{
 6294   match(Set mem (StoreI mem src));
 6295 
 6296   ins_cost(125);
 6297   format %{ &quot;MOV    $mem,$src&quot; %}
 6298   opcode(0x89);
 6299   ins_encode( OpcP, RegMem( src, mem ) );
 6300   ins_pipe( ialu_mem_reg );
 6301 %}
 6302 
 6303 // Store Long
 6304 instruct storeL(long_memory mem, eRegL src) %{
 6305   predicate(!((StoreLNode*)n)-&gt;require_atomic_access());
 6306   match(Set mem (StoreL mem src));
 6307 
 6308   ins_cost(200);
 6309   format %{ &quot;MOV    $mem,$src.lo\n\t&quot;
 6310             &quot;MOV    $mem+4,$src.hi&quot; %}
 6311   opcode(0x89, 0x89);
 6312   ins_encode( OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ) );
 6313   ins_pipe( ialu_mem_long_reg );
 6314 %}
 6315 
 6316 // Store Long to Integer
 6317 instruct storeL2I(memory mem, eRegL src) %{
 6318   match(Set mem (StoreI mem (ConvL2I src)));
 6319 
 6320   format %{ &quot;MOV    $mem,$src.lo\t# long -&gt; int&quot; %}
 6321   ins_encode %{
 6322     __ movl($mem$$Address, $src$$Register);
 6323   %}
 6324   ins_pipe(ialu_mem_reg);
 6325 %}
 6326 
 6327 // Volatile Store Long.  Must be atomic, so move it into
 6328 // the FP TOS and then do a 64-bit FIST.  Has to probe the
 6329 // target address before the store (for null-ptr checks)
 6330 // so the memory operand is used twice in the encoding.
 6331 instruct storeL_volatile(memory mem, stackSlotL src, eFlagsReg cr ) %{
 6332   predicate(UseSSE&lt;=1 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6333   match(Set mem (StoreL mem src));
 6334   effect( KILL cr );
 6335   ins_cost(400);
 6336   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6337             &quot;FILD   $src\n\t&quot;
 6338             &quot;FISTp  $mem\t # 64-bit atomic volatile long store&quot; %}
 6339   opcode(0x3B);
 6340   ins_encode( OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src));
 6341   ins_pipe( fpu_reg_mem );
 6342 %}
 6343 
 6344 instruct storeLX_volatile(memory mem, stackSlotL src, regD tmp, eFlagsReg cr) %{
 6345   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6346   match(Set mem (StoreL mem src));
 6347   effect( TEMP tmp, KILL cr );
 6348   ins_cost(380);
 6349   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6350             &quot;MOVSD  $tmp,$src\n\t&quot;
 6351             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6352   ins_encode %{
 6353     __ cmpl(rax, $mem$$Address);
 6354     __ movdbl($tmp$$XMMRegister, Address(rsp, $src$$disp));
 6355     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6356   %}
 6357   ins_pipe( pipe_slow );
 6358 %}
 6359 
 6360 instruct storeLX_reg_volatile(memory mem, eRegL src, regD tmp2, regD tmp, eFlagsReg cr) %{
 6361   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6362   match(Set mem (StoreL mem src));
 6363   effect( TEMP tmp2 , TEMP tmp, KILL cr );
 6364   ins_cost(360);
 6365   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6366             &quot;MOVD   $tmp,$src.lo\n\t&quot;
 6367             &quot;MOVD   $tmp2,$src.hi\n\t&quot;
 6368             &quot;PUNPCKLDQ $tmp,$tmp2\n\t&quot;
 6369             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6370   ins_encode %{
 6371     __ cmpl(rax, $mem$$Address);
 6372     __ movdl($tmp$$XMMRegister, $src$$Register);
 6373     __ movdl($tmp2$$XMMRegister, HIGH_FROM_LOW($src$$Register));
 6374     __ punpckldq($tmp$$XMMRegister, $tmp2$$XMMRegister);
 6375     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6376   %}
 6377   ins_pipe( pipe_slow );
 6378 %}
 6379 
 6380 // Store Pointer; for storing unknown oops and raw pointers
 6381 instruct storeP(memory mem, anyRegP src) %{
 6382   match(Set mem (StoreP mem src));
 6383 
 6384   ins_cost(125);
 6385   format %{ &quot;MOV    $mem,$src&quot; %}
 6386   opcode(0x89);
 6387   ins_encode( OpcP, RegMem( src, mem ) );
 6388   ins_pipe( ialu_mem_reg );
 6389 %}
 6390 
 6391 // Store Integer Immediate
 6392 instruct storeImmI(memory mem, immI src) %{
 6393   match(Set mem (StoreI mem src));
 6394 
 6395   ins_cost(150);
 6396   format %{ &quot;MOV    $mem,$src&quot; %}
 6397   opcode(0xC7);               /* C7 /0 */
 6398   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6399   ins_pipe( ialu_mem_imm );
 6400 %}
 6401 
 6402 // Store Short/Char Immediate
 6403 instruct storeImmI16(memory mem, immI16 src) %{
 6404   predicate(UseStoreImmI16);
 6405   match(Set mem (StoreC mem src));
 6406 
 6407   ins_cost(150);
 6408   format %{ &quot;MOV16  $mem,$src&quot; %}
 6409   opcode(0xC7);     /* C7 /0 Same as 32 store immediate with prefix */
 6410   ins_encode( SizePrefix, OpcP, RMopc_Mem(0x00,mem),  Con16( src ));
 6411   ins_pipe( ialu_mem_imm );
 6412 %}
 6413 
 6414 // Store Pointer Immediate; null pointers or constant oops that do not
 6415 // need card-mark barriers.
 6416 instruct storeImmP(memory mem, immP src) %{
 6417   match(Set mem (StoreP mem src));
 6418 
 6419   ins_cost(150);
 6420   format %{ &quot;MOV    $mem,$src&quot; %}
 6421   opcode(0xC7);               /* C7 /0 */
 6422   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6423   ins_pipe( ialu_mem_imm );
 6424 %}
 6425 
 6426 // Store Byte Immediate
 6427 instruct storeImmB(memory mem, immI8 src) %{
 6428   match(Set mem (StoreB mem src));
 6429 
 6430   ins_cost(150);
 6431   format %{ &quot;MOV8   $mem,$src&quot; %}
 6432   opcode(0xC6);               /* C6 /0 */
 6433   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6434   ins_pipe( ialu_mem_imm );
 6435 %}
 6436 
 6437 // Store CMS card-mark Immediate
 6438 instruct storeImmCM(memory mem, immI8 src) %{
 6439   match(Set mem (StoreCM mem src));
 6440 
 6441   ins_cost(150);
 6442   format %{ &quot;MOV8   $mem,$src\t! CMS card-mark imm0&quot; %}
 6443   opcode(0xC6);               /* C6 /0 */
 6444   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6445   ins_pipe( ialu_mem_imm );
 6446 %}
 6447 
 6448 // Store Double
 6449 instruct storeDPR( memory mem, regDPR1 src) %{
 6450   predicate(UseSSE&lt;=1);
 6451   match(Set mem (StoreD mem src));
 6452 
 6453   ins_cost(100);
 6454   format %{ &quot;FST_D  $mem,$src&quot; %}
 6455   opcode(0xDD);       /* DD /2 */
 6456   ins_encode( enc_FPR_store(mem,src) );
 6457   ins_pipe( fpu_mem_reg );
 6458 %}
 6459 
 6460 // Store double does rounding on x86
 6461 instruct storeDPR_rounded( memory mem, regDPR1 src) %{
 6462   predicate(UseSSE&lt;=1);
 6463   match(Set mem (StoreD mem (RoundDouble src)));
 6464 
 6465   ins_cost(100);
 6466   format %{ &quot;FST_D  $mem,$src\t# round&quot; %}
 6467   opcode(0xDD);       /* DD /2 */
 6468   ins_encode( enc_FPR_store(mem,src) );
 6469   ins_pipe( fpu_mem_reg );
 6470 %}
 6471 
 6472 // Store XMM register to memory (double-precision floating points)
 6473 // MOVSD instruction
 6474 instruct storeD(memory mem, regD src) %{
 6475   predicate(UseSSE&gt;=2);
 6476   match(Set mem (StoreD mem src));
 6477   ins_cost(95);
 6478   format %{ &quot;MOVSD  $mem,$src&quot; %}
 6479   ins_encode %{
 6480     __ movdbl($mem$$Address, $src$$XMMRegister);
 6481   %}
 6482   ins_pipe( pipe_slow );
 6483 %}
 6484 
 6485 // Load Double
 6486 instruct MoveD2VL(vlRegD dst, regD src) %{
 6487   match(Set dst src);
 6488   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6489   ins_encode %{
 6490     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6491   %}
 6492   ins_pipe( fpu_reg_reg );
 6493 %}
 6494 
 6495 // Load Double
 6496 instruct MoveVL2D(regD dst, vlRegD src) %{
 6497   match(Set dst src);
 6498   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6499   ins_encode %{
 6500     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6501   %}
 6502   ins_pipe( fpu_reg_reg );
 6503 %}
 6504 
 6505 // Store XMM register to memory (single-precision floating point)
 6506 // MOVSS instruction
 6507 instruct storeF(memory mem, regF src) %{
 6508   predicate(UseSSE&gt;=1);
 6509   match(Set mem (StoreF mem src));
 6510   ins_cost(95);
 6511   format %{ &quot;MOVSS  $mem,$src&quot; %}
 6512   ins_encode %{
 6513     __ movflt($mem$$Address, $src$$XMMRegister);
 6514   %}
 6515   ins_pipe( pipe_slow );
 6516 %}
 6517 
 6518 // Load Float
 6519 instruct MoveF2VL(vlRegF dst, regF src) %{
 6520   match(Set dst src);
 6521   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6522   ins_encode %{
 6523     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6524   %}
 6525   ins_pipe( fpu_reg_reg );
 6526 %}
 6527 
 6528 // Load Float
 6529 instruct MoveVL2F(regF dst, vlRegF src) %{
 6530   match(Set dst src);
 6531   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6532   ins_encode %{
 6533     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6534   %}
 6535   ins_pipe( fpu_reg_reg );
 6536 %}
 6537 
 6538 // Store Float
 6539 instruct storeFPR( memory mem, regFPR1 src) %{
 6540   predicate(UseSSE==0);
 6541   match(Set mem (StoreF mem src));
 6542 
 6543   ins_cost(100);
 6544   format %{ &quot;FST_S  $mem,$src&quot; %}
 6545   opcode(0xD9);       /* D9 /2 */
 6546   ins_encode( enc_FPR_store(mem,src) );
 6547   ins_pipe( fpu_mem_reg );
 6548 %}
 6549 
 6550 // Store Float does rounding on x86
 6551 instruct storeFPR_rounded( memory mem, regFPR1 src) %{
 6552   predicate(UseSSE==0);
 6553   match(Set mem (StoreF mem (RoundFloat src)));
 6554 
 6555   ins_cost(100);
 6556   format %{ &quot;FST_S  $mem,$src\t# round&quot; %}
 6557   opcode(0xD9);       /* D9 /2 */
 6558   ins_encode( enc_FPR_store(mem,src) );
 6559   ins_pipe( fpu_mem_reg );
 6560 %}
 6561 
 6562 // Store Float does rounding on x86
 6563 instruct storeFPR_Drounded( memory mem, regDPR1 src) %{
 6564   predicate(UseSSE&lt;=1);
 6565   match(Set mem (StoreF mem (ConvD2F src)));
 6566 
 6567   ins_cost(100);
 6568   format %{ &quot;FST_S  $mem,$src\t# D-round&quot; %}
 6569   opcode(0xD9);       /* D9 /2 */
 6570   ins_encode( enc_FPR_store(mem,src) );
 6571   ins_pipe( fpu_mem_reg );
 6572 %}
 6573 
 6574 // Store immediate Float value (it is faster than store from FPU register)
 6575 // The instruction usage is guarded by predicate in operand immFPR().
 6576 instruct storeFPR_imm( memory mem, immFPR src) %{
 6577   match(Set mem (StoreF mem src));
 6578 
 6579   ins_cost(50);
 6580   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6581   opcode(0xC7);               /* C7 /0 */
 6582   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits( src ));
 6583   ins_pipe( ialu_mem_imm );
 6584 %}
 6585 
 6586 // Store immediate Float value (it is faster than store from XMM register)
 6587 // The instruction usage is guarded by predicate in operand immF().
 6588 instruct storeF_imm( memory mem, immF src) %{
 6589   match(Set mem (StoreF mem src));
 6590 
 6591   ins_cost(50);
 6592   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6593   opcode(0xC7);               /* C7 /0 */
 6594   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits( src ));
 6595   ins_pipe( ialu_mem_imm );
 6596 %}
 6597 
 6598 // Store Integer to stack slot
 6599 instruct storeSSI(stackSlotI dst, rRegI src) %{
 6600   match(Set dst src);
 6601 
 6602   ins_cost(100);
 6603   format %{ &quot;MOV    $dst,$src&quot; %}
 6604   opcode(0x89);
 6605   ins_encode( OpcPRegSS( dst, src ) );
 6606   ins_pipe( ialu_mem_reg );
 6607 %}
 6608 
 6609 // Store Integer to stack slot
 6610 instruct storeSSP(stackSlotP dst, eRegP src) %{
 6611   match(Set dst src);
 6612 
 6613   ins_cost(100);
 6614   format %{ &quot;MOV    $dst,$src&quot; %}
 6615   opcode(0x89);
 6616   ins_encode( OpcPRegSS( dst, src ) );
 6617   ins_pipe( ialu_mem_reg );
 6618 %}
 6619 
 6620 // Store Long to stack slot
 6621 instruct storeSSL(stackSlotL dst, eRegL src) %{
 6622   match(Set dst src);
 6623 
 6624   ins_cost(200);
 6625   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6626             &quot;MOV    $dst+4,$src.hi&quot; %}
 6627   opcode(0x89, 0x89);
 6628   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
 6629   ins_pipe( ialu_mem_long_reg );
 6630 %}
 6631 
 6632 //----------MemBar Instructions-----------------------------------------------
 6633 // Memory barrier flavors
 6634 
 6635 instruct membar_acquire() %{
 6636   match(MemBarAcquire);
 6637   match(LoadFence);
 6638   ins_cost(400);
 6639 
 6640   size(0);
 6641   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6642   ins_encode();
 6643   ins_pipe(empty);
 6644 %}
 6645 
 6646 instruct membar_acquire_lock() %{
 6647   match(MemBarAcquireLock);
 6648   ins_cost(0);
 6649 
 6650   size(0);
 6651   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6652   ins_encode( );
 6653   ins_pipe(empty);
 6654 %}
 6655 
 6656 instruct membar_release() %{
 6657   match(MemBarRelease);
 6658   match(StoreFence);
 6659   ins_cost(400);
 6660 
 6661   size(0);
 6662   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6663   ins_encode( );
 6664   ins_pipe(empty);
 6665 %}
 6666 
 6667 instruct membar_release_lock() %{
 6668   match(MemBarReleaseLock);
 6669   ins_cost(0);
 6670 
 6671   size(0);
 6672   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6673   ins_encode( );
 6674   ins_pipe(empty);
 6675 %}
 6676 
 6677 instruct membar_volatile(eFlagsReg cr) %{
 6678   match(MemBarVolatile);
 6679   effect(KILL cr);
 6680   ins_cost(400);
 6681 
 6682   format %{
 6683     $$template
 6684     $$emit$$&quot;LOCK ADDL [ESP + #0], 0\t! membar_volatile&quot;
 6685   %}
 6686   ins_encode %{
 6687     __ membar(Assembler::StoreLoad);
 6688   %}
 6689   ins_pipe(pipe_slow);
 6690 %}
 6691 
 6692 instruct unnecessary_membar_volatile() %{
 6693   match(MemBarVolatile);
 6694   predicate(Matcher::post_store_load_barrier(n));
 6695   ins_cost(0);
 6696 
 6697   size(0);
 6698   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6699   ins_encode( );
 6700   ins_pipe(empty);
 6701 %}
 6702 
 6703 instruct membar_storestore() %{
 6704   match(MemBarStoreStore);
 6705   ins_cost(0);
 6706 
 6707   size(0);
 6708   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6709   ins_encode( );
 6710   ins_pipe(empty);
 6711 %}
 6712 
 6713 //----------Move Instructions--------------------------------------------------
 6714 instruct castX2P(eAXRegP dst, eAXRegI src) %{
 6715   match(Set dst (CastX2P src));
 6716   format %{ &quot;# X2P  $dst, $src&quot; %}
 6717   ins_encode( /*empty encoding*/ );
 6718   ins_cost(0);
 6719   ins_pipe(empty);
 6720 %}
 6721 
 6722 instruct castP2X(rRegI dst, eRegP src ) %{
 6723   match(Set dst (CastP2X src));
 6724   ins_cost(50);
 6725   format %{ &quot;MOV    $dst, $src\t# CastP2X&quot; %}
 6726   ins_encode( enc_Copy( dst, src) );
 6727   ins_pipe( ialu_reg_reg );
 6728 %}
 6729 
 6730 //----------Conditional Move---------------------------------------------------
 6731 // Conditional move
 6732 instruct jmovI_reg(cmpOp cop, eFlagsReg cr, rRegI dst, rRegI src) %{
 6733   predicate(!VM_Version::supports_cmov() );
 6734   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6735   ins_cost(200);
 6736   format %{ &quot;J$cop,us skip\t# signed cmove\n\t&quot;
 6737             &quot;MOV    $dst,$src\n&quot;
 6738       &quot;skip:&quot; %}
 6739   ins_encode %{
 6740     Label Lskip;
 6741     // Invert sense of branch from sense of CMOV
 6742     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6743     __ movl($dst$$Register, $src$$Register);
 6744     __ bind(Lskip);
 6745   %}
 6746   ins_pipe( pipe_cmov_reg );
 6747 %}
 6748 
 6749 instruct jmovI_regU(cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src) %{
 6750   predicate(!VM_Version::supports_cmov() );
 6751   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6752   ins_cost(200);
 6753   format %{ &quot;J$cop,us skip\t# unsigned cmove\n\t&quot;
 6754             &quot;MOV    $dst,$src\n&quot;
 6755       &quot;skip:&quot; %}
 6756   ins_encode %{
 6757     Label Lskip;
 6758     // Invert sense of branch from sense of CMOV
 6759     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6760     __ movl($dst$$Register, $src$$Register);
 6761     __ bind(Lskip);
 6762   %}
 6763   ins_pipe( pipe_cmov_reg );
 6764 %}
 6765 
 6766 instruct cmovI_reg(rRegI dst, rRegI src, eFlagsReg cr, cmpOp cop ) %{
 6767   predicate(VM_Version::supports_cmov() );
 6768   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6769   ins_cost(200);
 6770   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6771   opcode(0x0F,0x40);
 6772   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6773   ins_pipe( pipe_cmov_reg );
 6774 %}
 6775 
 6776 instruct cmovI_regU( cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src ) %{
 6777   predicate(VM_Version::supports_cmov() );
 6778   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6779   ins_cost(200);
 6780   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6781   opcode(0x0F,0x40);
 6782   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6783   ins_pipe( pipe_cmov_reg );
 6784 %}
 6785 
 6786 instruct cmovI_regUCF( cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, rRegI src ) %{
 6787   predicate(VM_Version::supports_cmov() );
 6788   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6789   ins_cost(200);
 6790   expand %{
 6791     cmovI_regU(cop, cr, dst, src);
 6792   %}
 6793 %}
 6794 
 6795 // Conditional move
 6796 instruct cmovI_mem(cmpOp cop, eFlagsReg cr, rRegI dst, memory src) %{
 6797   predicate(VM_Version::supports_cmov() );
 6798   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6799   ins_cost(250);
 6800   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6801   opcode(0x0F,0x40);
 6802   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6803   ins_pipe( pipe_cmov_mem );
 6804 %}
 6805 
 6806 // Conditional move
 6807 instruct cmovI_memU(cmpOpU cop, eFlagsRegU cr, rRegI dst, memory src) %{
 6808   predicate(VM_Version::supports_cmov() );
 6809   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6810   ins_cost(250);
 6811   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6812   opcode(0x0F,0x40);
 6813   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6814   ins_pipe( pipe_cmov_mem );
 6815 %}
 6816 
 6817 instruct cmovI_memUCF(cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, memory src) %{
 6818   predicate(VM_Version::supports_cmov() );
 6819   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6820   ins_cost(250);
 6821   expand %{
 6822     cmovI_memU(cop, cr, dst, src);
 6823   %}
 6824 %}
 6825 
 6826 // Conditional move
 6827 instruct cmovP_reg(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6828   predicate(VM_Version::supports_cmov() );
 6829   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6830   ins_cost(200);
 6831   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6832   opcode(0x0F,0x40);
 6833   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6834   ins_pipe( pipe_cmov_reg );
 6835 %}
 6836 
 6837 // Conditional move (non-P6 version)
 6838 // Note:  a CMoveP is generated for  stubs and native wrappers
 6839 //        regardless of whether we are on a P6, so we
 6840 //        emulate a cmov here
 6841 instruct cmovP_reg_nonP6(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6842   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6843   ins_cost(300);
 6844   format %{ &quot;Jn$cop   skip\n\t&quot;
 6845           &quot;MOV    $dst,$src\t# pointer\n&quot;
 6846       &quot;skip:&quot; %}
 6847   opcode(0x8b);
 6848   ins_encode( enc_cmov_branch(cop, 0x2), OpcP, RegReg(dst, src));
 6849   ins_pipe( pipe_cmov_reg );
 6850 %}
 6851 
 6852 // Conditional move
 6853 instruct cmovP_regU(cmpOpU cop, eFlagsRegU cr, eRegP dst, eRegP src ) %{
 6854   predicate(VM_Version::supports_cmov() );
 6855   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6856   ins_cost(200);
 6857   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6858   opcode(0x0F,0x40);
 6859   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6860   ins_pipe( pipe_cmov_reg );
 6861 %}
 6862 
 6863 instruct cmovP_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegP dst, eRegP src ) %{
 6864   predicate(VM_Version::supports_cmov() );
 6865   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6866   ins_cost(200);
 6867   expand %{
 6868     cmovP_regU(cop, cr, dst, src);
 6869   %}
 6870 %}
 6871 
 6872 // DISABLED: Requires the ADLC to emit a bottom_type call that
 6873 // correctly meets the two pointer arguments; one is an incoming
 6874 // register but the other is a memory operand.  ALSO appears to
 6875 // be buggy with implicit null checks.
 6876 //
 6877 //// Conditional move
 6878 //instruct cmovP_mem(cmpOp cop, eFlagsReg cr, eRegP dst, memory src) %{
 6879 //  predicate(VM_Version::supports_cmov() );
 6880 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6881 //  ins_cost(250);
 6882 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6883 //  opcode(0x0F,0x40);
 6884 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6885 //  ins_pipe( pipe_cmov_mem );
 6886 //%}
 6887 //
 6888 //// Conditional move
 6889 //instruct cmovP_memU(cmpOpU cop, eFlagsRegU cr, eRegP dst, memory src) %{
 6890 //  predicate(VM_Version::supports_cmov() );
 6891 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6892 //  ins_cost(250);
 6893 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6894 //  opcode(0x0F,0x40);
 6895 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6896 //  ins_pipe( pipe_cmov_mem );
 6897 //%}
 6898 
 6899 // Conditional move
 6900 instruct fcmovDPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regDPR1 dst, regDPR src) %{
 6901   predicate(UseSSE&lt;=1);
 6902   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6903   ins_cost(200);
 6904   format %{ &quot;FCMOV$cop $dst,$src\t# double&quot; %}
 6905   opcode(0xDA);
 6906   ins_encode( enc_cmov_dpr(cop,src) );
 6907   ins_pipe( pipe_cmovDPR_reg );
 6908 %}
 6909 
 6910 // Conditional move
 6911 instruct fcmovFPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regFPR1 dst, regFPR src) %{
 6912   predicate(UseSSE==0);
 6913   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6914   ins_cost(200);
 6915   format %{ &quot;FCMOV$cop $dst,$src\t# float&quot; %}
 6916   opcode(0xDA);
 6917   ins_encode( enc_cmov_dpr(cop,src) );
 6918   ins_pipe( pipe_cmovDPR_reg );
 6919 %}
 6920 
 6921 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6922 instruct fcmovDPR_regS(cmpOp cop, eFlagsReg cr, regDPR dst, regDPR src) %{
 6923   predicate(UseSSE&lt;=1);
 6924   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6925   ins_cost(200);
 6926   format %{ &quot;Jn$cop   skip\n\t&quot;
 6927             &quot;MOV    $dst,$src\t# double\n&quot;
 6928       &quot;skip:&quot; %}
 6929   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6930   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_DPR(src), OpcP, RegOpc(dst) );
 6931   ins_pipe( pipe_cmovDPR_reg );
 6932 %}
 6933 
 6934 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6935 instruct fcmovFPR_regS(cmpOp cop, eFlagsReg cr, regFPR dst, regFPR src) %{
 6936   predicate(UseSSE==0);
 6937   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6938   ins_cost(200);
 6939   format %{ &quot;Jn$cop    skip\n\t&quot;
 6940             &quot;MOV    $dst,$src\t# float\n&quot;
 6941       &quot;skip:&quot; %}
 6942   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6943   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_FPR(src), OpcP, RegOpc(dst) );
 6944   ins_pipe( pipe_cmovDPR_reg );
 6945 %}
 6946 
 6947 // No CMOVE with SSE/SSE2
 6948 instruct fcmovF_regS(cmpOp cop, eFlagsReg cr, regF dst, regF src) %{
 6949   predicate (UseSSE&gt;=1);
 6950   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6951   ins_cost(200);
 6952   format %{ &quot;Jn$cop   skip\n\t&quot;
 6953             &quot;MOVSS  $dst,$src\t# float\n&quot;
 6954       &quot;skip:&quot; %}
 6955   ins_encode %{
 6956     Label skip;
 6957     // Invert sense of branch from sense of CMOV
 6958     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6959     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6960     __ bind(skip);
 6961   %}
 6962   ins_pipe( pipe_slow );
 6963 %}
 6964 
 6965 // No CMOVE with SSE/SSE2
 6966 instruct fcmovD_regS(cmpOp cop, eFlagsReg cr, regD dst, regD src) %{
 6967   predicate (UseSSE&gt;=2);
 6968   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6969   ins_cost(200);
 6970   format %{ &quot;Jn$cop   skip\n\t&quot;
 6971             &quot;MOVSD  $dst,$src\t# float\n&quot;
 6972       &quot;skip:&quot; %}
 6973   ins_encode %{
 6974     Label skip;
 6975     // Invert sense of branch from sense of CMOV
 6976     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6977     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6978     __ bind(skip);
 6979   %}
 6980   ins_pipe( pipe_slow );
 6981 %}
 6982 
 6983 // unsigned version
 6984 instruct fcmovF_regU(cmpOpU cop, eFlagsRegU cr, regF dst, regF src) %{
 6985   predicate (UseSSE&gt;=1);
 6986   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6987   ins_cost(200);
 6988   format %{ &quot;Jn$cop   skip\n\t&quot;
 6989             &quot;MOVSS  $dst,$src\t# float\n&quot;
 6990       &quot;skip:&quot; %}
 6991   ins_encode %{
 6992     Label skip;
 6993     // Invert sense of branch from sense of CMOV
 6994     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6995     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6996     __ bind(skip);
 6997   %}
 6998   ins_pipe( pipe_slow );
 6999 %}
 7000 
 7001 instruct fcmovF_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regF dst, regF src) %{
 7002   predicate (UseSSE&gt;=1);
 7003   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7004   ins_cost(200);
 7005   expand %{
 7006     fcmovF_regU(cop, cr, dst, src);
 7007   %}
 7008 %}
 7009 
 7010 // unsigned version
 7011 instruct fcmovD_regU(cmpOpU cop, eFlagsRegU cr, regD dst, regD src) %{
 7012   predicate (UseSSE&gt;=2);
 7013   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7014   ins_cost(200);
 7015   format %{ &quot;Jn$cop   skip\n\t&quot;
 7016             &quot;MOVSD  $dst,$src\t# float\n&quot;
 7017       &quot;skip:&quot; %}
 7018   ins_encode %{
 7019     Label skip;
 7020     // Invert sense of branch from sense of CMOV
 7021     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 7022     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7023     __ bind(skip);
 7024   %}
 7025   ins_pipe( pipe_slow );
 7026 %}
 7027 
 7028 instruct fcmovD_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regD dst, regD src) %{
 7029   predicate (UseSSE&gt;=2);
 7030   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7031   ins_cost(200);
 7032   expand %{
 7033     fcmovD_regU(cop, cr, dst, src);
 7034   %}
 7035 %}
 7036 
 7037 instruct cmovL_reg(cmpOp cop, eFlagsReg cr, eRegL dst, eRegL src) %{
 7038   predicate(VM_Version::supports_cmov() );
 7039   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7040   ins_cost(200);
 7041   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7042             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7043   opcode(0x0F,0x40);
 7044   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7045   ins_pipe( pipe_cmov_reg_long );
 7046 %}
 7047 
 7048 instruct cmovL_regU(cmpOpU cop, eFlagsRegU cr, eRegL dst, eRegL src) %{
 7049   predicate(VM_Version::supports_cmov() );
 7050   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7051   ins_cost(200);
 7052   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7053             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7054   opcode(0x0F,0x40);
 7055   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7056   ins_pipe( pipe_cmov_reg_long );
 7057 %}
 7058 
 7059 instruct cmovL_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegL dst, eRegL src) %{
 7060   predicate(VM_Version::supports_cmov() );
 7061   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7062   ins_cost(200);
 7063   expand %{
 7064     cmovL_regU(cop, cr, dst, src);
 7065   %}
 7066 %}
 7067 
 7068 //----------Arithmetic Instructions--------------------------------------------
 7069 //----------Addition Instructions----------------------------------------------
 7070 
 7071 // Integer Addition Instructions
 7072 instruct addI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7073   match(Set dst (AddI dst src));
 7074   effect(KILL cr);
 7075 
 7076   size(2);
 7077   format %{ &quot;ADD    $dst,$src&quot; %}
 7078   opcode(0x03);
 7079   ins_encode( OpcP, RegReg( dst, src) );
 7080   ins_pipe( ialu_reg_reg );
 7081 %}
 7082 
 7083 instruct addI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7084   match(Set dst (AddI dst src));
 7085   effect(KILL cr);
 7086 
 7087   format %{ &quot;ADD    $dst,$src&quot; %}
 7088   opcode(0x81, 0x00); /* /0 id */
 7089   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7090   ins_pipe( ialu_reg );
 7091 %}
 7092 
 7093 instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
 7094   predicate(UseIncDec);
 7095   match(Set dst (AddI dst src));
 7096   effect(KILL cr);
 7097 
 7098   size(1);
 7099   format %{ &quot;INC    $dst&quot; %}
 7100   opcode(0x40); /*  */
 7101   ins_encode( Opc_plus( primary, dst ) );
 7102   ins_pipe( ialu_reg );
 7103 %}
 7104 
 7105 instruct leaI_eReg_immI(rRegI dst, rRegI src0, immI src1) %{
 7106   match(Set dst (AddI src0 src1));
 7107   ins_cost(110);
 7108 
 7109   format %{ &quot;LEA    $dst,[$src0 + $src1]&quot; %}
 7110   opcode(0x8D); /* 0x8D /r */
 7111   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7112   ins_pipe( ialu_reg_reg );
 7113 %}
 7114 
 7115 instruct leaP_eReg_immI(eRegP dst, eRegP src0, immI src1) %{
 7116   match(Set dst (AddP src0 src1));
 7117   ins_cost(110);
 7118 
 7119   format %{ &quot;LEA    $dst,[$src0 + $src1]\t# ptr&quot; %}
 7120   opcode(0x8D); /* 0x8D /r */
 7121   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7122   ins_pipe( ialu_reg_reg );
 7123 %}
 7124 
 7125 instruct decI_eReg(rRegI dst, immI_M1 src, eFlagsReg cr) %{
 7126   predicate(UseIncDec);
 7127   match(Set dst (AddI dst src));
 7128   effect(KILL cr);
 7129 
 7130   size(1);
 7131   format %{ &quot;DEC    $dst&quot; %}
 7132   opcode(0x48); /*  */
 7133   ins_encode( Opc_plus( primary, dst ) );
 7134   ins_pipe( ialu_reg );
 7135 %}
 7136 
 7137 instruct addP_eReg(eRegP dst, rRegI src, eFlagsReg cr) %{
 7138   match(Set dst (AddP dst src));
 7139   effect(KILL cr);
 7140 
 7141   size(2);
 7142   format %{ &quot;ADD    $dst,$src&quot; %}
 7143   opcode(0x03);
 7144   ins_encode( OpcP, RegReg( dst, src) );
 7145   ins_pipe( ialu_reg_reg );
 7146 %}
 7147 
 7148 instruct addP_eReg_imm(eRegP dst, immI src, eFlagsReg cr) %{
 7149   match(Set dst (AddP dst src));
 7150   effect(KILL cr);
 7151 
 7152   format %{ &quot;ADD    $dst,$src&quot; %}
 7153   opcode(0x81,0x00); /* Opcode 81 /0 id */
 7154   // ins_encode( RegImm( dst, src) );
 7155   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7156   ins_pipe( ialu_reg );
 7157 %}
 7158 
 7159 instruct addI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7160   match(Set dst (AddI dst (LoadI src)));
 7161   effect(KILL cr);
 7162 
 7163   ins_cost(125);
 7164   format %{ &quot;ADD    $dst,$src&quot; %}
 7165   opcode(0x03);
 7166   ins_encode( OpcP, RegMem( dst, src) );
 7167   ins_pipe( ialu_reg_mem );
 7168 %}
 7169 
 7170 instruct addI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7171   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7172   effect(KILL cr);
 7173 
 7174   ins_cost(150);
 7175   format %{ &quot;ADD    $dst,$src&quot; %}
 7176   opcode(0x01);  /* Opcode 01 /r */
 7177   ins_encode( OpcP, RegMem( src, dst ) );
 7178   ins_pipe( ialu_mem_reg );
 7179 %}
 7180 
 7181 // Add Memory with Immediate
 7182 instruct addI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 7183   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7184   effect(KILL cr);
 7185 
 7186   ins_cost(125);
 7187   format %{ &quot;ADD    $dst,$src&quot; %}
 7188   opcode(0x81);               /* Opcode 81 /0 id */
 7189   ins_encode( OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32( src ) );
 7190   ins_pipe( ialu_mem_imm );
 7191 %}
 7192 
 7193 instruct incI_mem(memory dst, immI1 src, eFlagsReg cr) %{
 7194   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7195   effect(KILL cr);
 7196 
 7197   ins_cost(125);
 7198   format %{ &quot;INC    $dst&quot; %}
 7199   opcode(0xFF);               /* Opcode FF /0 */
 7200   ins_encode( OpcP, RMopc_Mem(0x00,dst));
 7201   ins_pipe( ialu_mem_imm );
 7202 %}
 7203 
 7204 instruct decI_mem(memory dst, immI_M1 src, eFlagsReg cr) %{
 7205   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7206   effect(KILL cr);
 7207 
 7208   ins_cost(125);
 7209   format %{ &quot;DEC    $dst&quot; %}
 7210   opcode(0xFF);               /* Opcode FF /1 */
 7211   ins_encode( OpcP, RMopc_Mem(0x01,dst));
 7212   ins_pipe( ialu_mem_imm );
 7213 %}
 7214 
 7215 
 7216 instruct checkCastPP( eRegP dst ) %{
 7217   match(Set dst (CheckCastPP dst));
 7218 
 7219   size(0);
 7220   format %{ &quot;#checkcastPP of $dst&quot; %}
 7221   ins_encode( /*empty encoding*/ );
 7222   ins_pipe( empty );
 7223 %}
 7224 
 7225 instruct castPP( eRegP dst ) %{
 7226   match(Set dst (CastPP dst));
 7227   format %{ &quot;#castPP of $dst&quot; %}
 7228   ins_encode( /*empty encoding*/ );
 7229   ins_pipe( empty );
 7230 %}
 7231 
 7232 instruct castII( rRegI dst ) %{
 7233   match(Set dst (CastII dst));
 7234   format %{ &quot;#castII of $dst&quot; %}
 7235   ins_encode( /*empty encoding*/ );
 7236   ins_cost(0);
 7237   ins_pipe( empty );
 7238 %}
 7239 
 7240 instruct castLL( eRegL dst ) %{
 7241   match(Set dst (CastLL dst));
 7242   format %{ &quot;#castLL of $dst&quot; %}
 7243   ins_encode( /*empty encoding*/ );
 7244   ins_cost(0);
 7245   ins_pipe( empty );
 7246 %}
 7247 
 7248 
 7249 // Load-locked - same as a regular pointer load when used with compare-swap
 7250 instruct loadPLocked(eRegP dst, memory mem) %{
 7251   match(Set dst (LoadPLocked mem));
 7252 
 7253   ins_cost(125);
 7254   format %{ &quot;MOV    $dst,$mem\t# Load ptr. locked&quot; %}
 7255   opcode(0x8B);
 7256   ins_encode( OpcP, RegMem(dst,mem));
 7257   ins_pipe( ialu_reg_mem );
 7258 %}
 7259 
 7260 // Conditional-store of the updated heap-top.
 7261 // Used during allocation of the shared heap.
 7262 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7263 instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{
 7264   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7265   // EAX is killed if there is contention, but then it&#39;s also unused.
 7266   // In the common case of no contention, EAX holds the new oop address.
 7267   format %{ &quot;CMPXCHG $heap_top_ptr,$newval\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr&quot; %}
 7268   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval,heap_top_ptr) );
 7269   ins_pipe( pipe_cmpxchg );
 7270 %}
 7271 
 7272 // Conditional-store of an int value.
 7273 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG on Intel.
 7274 instruct storeIConditional( memory mem, eAXRegI oldval, rRegI newval, eFlagsReg cr ) %{
 7275   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7276   effect(KILL oldval);
 7277   format %{ &quot;CMPXCHG $mem,$newval\t# If EAX==$mem Then store $newval into $mem&quot; %}
 7278   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval, mem) );
 7279   ins_pipe( pipe_cmpxchg );
 7280 %}
 7281 
 7282 // Conditional-store of a long value.
 7283 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG8 on Intel.
 7284 instruct storeLConditional( memory mem, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7285   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7286   effect(KILL oldval);
 7287   format %{ &quot;XCHG   EBX,ECX\t# correct order for CMPXCHG8 instruction\n\t&quot;
 7288             &quot;CMPXCHG8 $mem,ECX:EBX\t# If EDX:EAX==$mem Then store ECX:EBX into $mem\n\t&quot;
 7289             &quot;XCHG   EBX,ECX&quot;
 7290   %}
 7291   ins_encode %{
 7292     // Note: we need to swap rbx, and rcx before and after the
 7293     //       cmpxchg8 instruction because the instruction uses
 7294     //       rcx as the high order word of the new value to store but
 7295     //       our register encoding uses rbx.
 7296     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7297     __ lock();
 7298     __ cmpxchg8($mem$$Address);
 7299     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7300   %}
 7301   ins_pipe( pipe_cmpxchg );
 7302 %}
 7303 
 7304 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7305 
 7306 instruct compareAndSwapL( rRegI res, eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7307   predicate(VM_Version::supports_cx8());
 7308   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7309   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7310   effect(KILL cr, KILL oldval);
 7311   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7312             &quot;MOV    $res,0\n\t&quot;
 7313             &quot;JNE,s  fail\n\t&quot;
 7314             &quot;MOV    $res,1\n&quot;
 7315           &quot;fail:&quot; %}
 7316   ins_encode( enc_cmpxchg8(mem_ptr),
 7317               enc_flags_ne_to_boolean(res) );
 7318   ins_pipe( pipe_cmpxchg );
 7319 %}
 7320 
 7321 instruct compareAndSwapP( rRegI res,  pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7322   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7323   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7324   effect(KILL cr, KILL oldval);
 7325   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7326             &quot;MOV    $res,0\n\t&quot;
 7327             &quot;JNE,s  fail\n\t&quot;
 7328             &quot;MOV    $res,1\n&quot;
 7329           &quot;fail:&quot; %}
 7330   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7331   ins_pipe( pipe_cmpxchg );
 7332 %}
 7333 
 7334 instruct compareAndSwapB( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7335   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7336   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7337   effect(KILL cr, KILL oldval);
 7338   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7339             &quot;MOV    $res,0\n\t&quot;
 7340             &quot;JNE,s  fail\n\t&quot;
 7341             &quot;MOV    $res,1\n&quot;
 7342           &quot;fail:&quot; %}
 7343   ins_encode( enc_cmpxchgb(mem_ptr),
 7344               enc_flags_ne_to_boolean(res) );
 7345   ins_pipe( pipe_cmpxchg );
 7346 %}
 7347 
 7348 instruct compareAndSwapS( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7349   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7350   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7351   effect(KILL cr, KILL oldval);
 7352   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7353             &quot;MOV    $res,0\n\t&quot;
 7354             &quot;JNE,s  fail\n\t&quot;
 7355             &quot;MOV    $res,1\n&quot;
 7356           &quot;fail:&quot; %}
 7357   ins_encode( enc_cmpxchgw(mem_ptr),
 7358               enc_flags_ne_to_boolean(res) );
 7359   ins_pipe( pipe_cmpxchg );
 7360 %}
 7361 
 7362 instruct compareAndSwapI( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7363   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7364   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7365   effect(KILL cr, KILL oldval);
 7366   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7367             &quot;MOV    $res,0\n\t&quot;
 7368             &quot;JNE,s  fail\n\t&quot;
 7369             &quot;MOV    $res,1\n&quot;
 7370           &quot;fail:&quot; %}
 7371   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7372   ins_pipe( pipe_cmpxchg );
 7373 %}
 7374 
 7375 instruct compareAndExchangeL( eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7376   predicate(VM_Version::supports_cx8());
 7377   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7378   effect(KILL cr);
 7379   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7380   ins_encode( enc_cmpxchg8(mem_ptr) );
 7381   ins_pipe( pipe_cmpxchg );
 7382 %}
 7383 
 7384 instruct compareAndExchangeP( pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7385   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7386   effect(KILL cr);
 7387   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7388   ins_encode( enc_cmpxchg(mem_ptr) );
 7389   ins_pipe( pipe_cmpxchg );
 7390 %}
 7391 
 7392 instruct compareAndExchangeB( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7393   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7394   effect(KILL cr);
 7395   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7396   ins_encode( enc_cmpxchgb(mem_ptr) );
 7397   ins_pipe( pipe_cmpxchg );
 7398 %}
 7399 
 7400 instruct compareAndExchangeS( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7401   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7402   effect(KILL cr);
 7403   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7404   ins_encode( enc_cmpxchgw(mem_ptr) );
 7405   ins_pipe( pipe_cmpxchg );
 7406 %}
 7407 
 7408 instruct compareAndExchangeI( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7409   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7410   effect(KILL cr);
 7411   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7412   ins_encode( enc_cmpxchg(mem_ptr) );
 7413   ins_pipe( pipe_cmpxchg );
 7414 %}
 7415 
 7416 instruct xaddB_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7417   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7418   match(Set dummy (GetAndAddB mem add));
 7419   effect(KILL cr);
 7420   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7421   ins_encode %{
 7422     __ lock();
 7423     __ addb($mem$$Address, $add$$constant);
 7424   %}
 7425   ins_pipe( pipe_cmpxchg );
 7426 %}
 7427 
 7428 // Important to match to xRegI: only 8-bit regs.
 7429 instruct xaddB( memory mem, xRegI newval, eFlagsReg cr) %{
 7430   match(Set newval (GetAndAddB mem newval));
 7431   effect(KILL cr);
 7432   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7433   ins_encode %{
 7434     __ lock();
 7435     __ xaddb($mem$$Address, $newval$$Register);
 7436   %}
 7437   ins_pipe( pipe_cmpxchg );
 7438 %}
 7439 
 7440 instruct xaddS_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7441   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7442   match(Set dummy (GetAndAddS mem add));
 7443   effect(KILL cr);
 7444   format %{ &quot;ADDS  [$mem],$add&quot; %}
 7445   ins_encode %{
 7446     __ lock();
 7447     __ addw($mem$$Address, $add$$constant);
 7448   %}
 7449   ins_pipe( pipe_cmpxchg );
 7450 %}
 7451 
 7452 instruct xaddS( memory mem, rRegI newval, eFlagsReg cr) %{
 7453   match(Set newval (GetAndAddS mem newval));
 7454   effect(KILL cr);
 7455   format %{ &quot;XADDS  [$mem],$newval&quot; %}
 7456   ins_encode %{
 7457     __ lock();
 7458     __ xaddw($mem$$Address, $newval$$Register);
 7459   %}
 7460   ins_pipe( pipe_cmpxchg );
 7461 %}
 7462 
 7463 instruct xaddI_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7464   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7465   match(Set dummy (GetAndAddI mem add));
 7466   effect(KILL cr);
 7467   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7468   ins_encode %{
 7469     __ lock();
 7470     __ addl($mem$$Address, $add$$constant);
 7471   %}
 7472   ins_pipe( pipe_cmpxchg );
 7473 %}
 7474 
 7475 instruct xaddI( memory mem, rRegI newval, eFlagsReg cr) %{
 7476   match(Set newval (GetAndAddI mem newval));
 7477   effect(KILL cr);
 7478   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7479   ins_encode %{
 7480     __ lock();
 7481     __ xaddl($mem$$Address, $newval$$Register);
 7482   %}
 7483   ins_pipe( pipe_cmpxchg );
 7484 %}
 7485 
 7486 // Important to match to xRegI: only 8-bit regs.
 7487 instruct xchgB( memory mem, xRegI newval) %{
 7488   match(Set newval (GetAndSetB mem newval));
 7489   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7490   ins_encode %{
 7491     __ xchgb($newval$$Register, $mem$$Address);
 7492   %}
 7493   ins_pipe( pipe_cmpxchg );
 7494 %}
 7495 
 7496 instruct xchgS( memory mem, rRegI newval) %{
 7497   match(Set newval (GetAndSetS mem newval));
 7498   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7499   ins_encode %{
 7500     __ xchgw($newval$$Register, $mem$$Address);
 7501   %}
 7502   ins_pipe( pipe_cmpxchg );
 7503 %}
 7504 
 7505 instruct xchgI( memory mem, rRegI newval) %{
 7506   match(Set newval (GetAndSetI mem newval));
 7507   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7508   ins_encode %{
 7509     __ xchgl($newval$$Register, $mem$$Address);
 7510   %}
 7511   ins_pipe( pipe_cmpxchg );
 7512 %}
 7513 
 7514 instruct xchgP( memory mem, pRegP newval) %{
 7515   match(Set newval (GetAndSetP mem newval));
 7516   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7517   ins_encode %{
 7518     __ xchgl($newval$$Register, $mem$$Address);
 7519   %}
 7520   ins_pipe( pipe_cmpxchg );
 7521 %}
 7522 
 7523 //----------Subtraction Instructions-------------------------------------------
 7524 
 7525 // Integer Subtraction Instructions
 7526 instruct subI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7527   match(Set dst (SubI dst src));
 7528   effect(KILL cr);
 7529 
 7530   size(2);
 7531   format %{ &quot;SUB    $dst,$src&quot; %}
 7532   opcode(0x2B);
 7533   ins_encode( OpcP, RegReg( dst, src) );
 7534   ins_pipe( ialu_reg_reg );
 7535 %}
 7536 
 7537 instruct subI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7538   match(Set dst (SubI dst src));
 7539   effect(KILL cr);
 7540 
 7541   format %{ &quot;SUB    $dst,$src&quot; %}
 7542   opcode(0x81,0x05);  /* Opcode 81 /5 */
 7543   // ins_encode( RegImm( dst, src) );
 7544   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7545   ins_pipe( ialu_reg );
 7546 %}
 7547 
 7548 instruct subI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7549   match(Set dst (SubI dst (LoadI src)));
 7550   effect(KILL cr);
 7551 
 7552   ins_cost(125);
 7553   format %{ &quot;SUB    $dst,$src&quot; %}
 7554   opcode(0x2B);
 7555   ins_encode( OpcP, RegMem( dst, src) );
 7556   ins_pipe( ialu_reg_mem );
 7557 %}
 7558 
 7559 instruct subI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7560   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 7561   effect(KILL cr);
 7562 
 7563   ins_cost(150);
 7564   format %{ &quot;SUB    $dst,$src&quot; %}
 7565   opcode(0x29);  /* Opcode 29 /r */
 7566   ins_encode( OpcP, RegMem( src, dst ) );
 7567   ins_pipe( ialu_mem_reg );
 7568 %}
 7569 
 7570 // Subtract from a pointer
 7571 instruct subP_eReg(eRegP dst, rRegI src, immI0 zero, eFlagsReg cr) %{
 7572   match(Set dst (AddP dst (SubI zero src)));
 7573   effect(KILL cr);
 7574 
 7575   size(2);
 7576   format %{ &quot;SUB    $dst,$src&quot; %}
 7577   opcode(0x2B);
 7578   ins_encode( OpcP, RegReg( dst, src) );
 7579   ins_pipe( ialu_reg_reg );
 7580 %}
 7581 
 7582 instruct negI_eReg(rRegI dst, immI0 zero, eFlagsReg cr) %{
 7583   match(Set dst (SubI zero dst));
 7584   effect(KILL cr);
 7585 
 7586   size(2);
 7587   format %{ &quot;NEG    $dst&quot; %}
 7588   opcode(0xF7,0x03);  // Opcode F7 /3
 7589   ins_encode( OpcP, RegOpc( dst ) );
 7590   ins_pipe( ialu_reg );
 7591 %}
 7592 
 7593 //----------Multiplication/Division Instructions-------------------------------
 7594 // Integer Multiplication Instructions
 7595 // Multiply Register
 7596 instruct mulI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7597   match(Set dst (MulI dst src));
 7598   effect(KILL cr);
 7599 
 7600   size(3);
 7601   ins_cost(300);
 7602   format %{ &quot;IMUL   $dst,$src&quot; %}
 7603   opcode(0xAF, 0x0F);
 7604   ins_encode( OpcS, OpcP, RegReg( dst, src) );
 7605   ins_pipe( ialu_reg_reg_alu0 );
 7606 %}
 7607 
 7608 // Multiply 32-bit Immediate
 7609 instruct mulI_eReg_imm(rRegI dst, rRegI src, immI imm, eFlagsReg cr) %{
 7610   match(Set dst (MulI src imm));
 7611   effect(KILL cr);
 7612 
 7613   ins_cost(300);
 7614   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7615   opcode(0x69);  /* 69 /r id */
 7616   ins_encode( OpcSE(imm), RegReg( dst, src ), Con8or32( imm ) );
 7617   ins_pipe( ialu_reg_reg_alu0 );
 7618 %}
 7619 
 7620 instruct loadConL_low_only(eADXRegL_low_only dst, immL32 src, eFlagsReg cr) %{
 7621   match(Set dst src);
 7622   effect(KILL cr);
 7623 
 7624   // Note that this is artificially increased to make it more expensive than loadConL
 7625   ins_cost(250);
 7626   format %{ &quot;MOV    EAX,$src\t// low word only&quot; %}
 7627   opcode(0xB8);
 7628   ins_encode( LdImmL_Lo(dst, src) );
 7629   ins_pipe( ialu_reg_fat );
 7630 %}
 7631 
 7632 // Multiply by 32-bit Immediate, taking the shifted high order results
 7633 //  (special case for shift by 32)
 7634 instruct mulI_imm_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32 cnt, eFlagsReg cr) %{
 7635   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7636   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7637              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7638              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7639   effect(USE src1, KILL cr);
 7640 
 7641   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7642   ins_cost(0*100 + 1*400 - 150);
 7643   format %{ &quot;IMUL   EDX:EAX,$src1&quot; %}
 7644   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7645   ins_pipe( pipe_slow );
 7646 %}
 7647 
 7648 // Multiply by 32-bit Immediate, taking the shifted high order results
 7649 instruct mulI_imm_RShift_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr) %{
 7650   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7651   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7652              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7653              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7654   effect(USE src1, KILL cr);
 7655 
 7656   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7657   ins_cost(1*100 + 1*400 - 150);
 7658   format %{ &quot;IMUL   EDX:EAX,$src1\n\t&quot;
 7659             &quot;SAR    EDX,$cnt-32&quot; %}
 7660   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7661   ins_pipe( pipe_slow );
 7662 %}
 7663 
 7664 // Multiply Memory 32-bit Immediate
 7665 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, eFlagsReg cr) %{
 7666   match(Set dst (MulI (LoadI src) imm));
 7667   effect(KILL cr);
 7668 
 7669   ins_cost(300);
 7670   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7671   opcode(0x69);  /* 69 /r id */
 7672   ins_encode( OpcSE(imm), RegMem( dst, src ), Con8or32( imm ) );
 7673   ins_pipe( ialu_reg_mem_alu0 );
 7674 %}
 7675 
 7676 // Multiply Memory
 7677 instruct mulI(rRegI dst, memory src, eFlagsReg cr) %{
 7678   match(Set dst (MulI dst (LoadI src)));
 7679   effect(KILL cr);
 7680 
 7681   ins_cost(350);
 7682   format %{ &quot;IMUL   $dst,$src&quot; %}
 7683   opcode(0xAF, 0x0F);
 7684   ins_encode( OpcS, OpcP, RegMem( dst, src) );
 7685   ins_pipe( ialu_reg_mem_alu0 );
 7686 %}
 7687 
 7688 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, eFlagsReg cr)
 7689 %{
 7690   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 7691   effect(KILL cr, KILL src2);
 7692 
 7693   expand %{ mulI_eReg(dst, src1, cr);
 7694            mulI_eReg(src2, src3, cr);
 7695            addI_eReg(dst, src2, cr); %}
 7696 %}
 7697 
 7698 // Multiply Register Int to Long
 7699 instruct mulI2L(eADXRegL dst, eAXRegI src, nadxRegI src1, eFlagsReg flags) %{
 7700   // Basic Idea: long = (long)int * (long)int
 7701   match(Set dst (MulL (ConvI2L src) (ConvI2L src1)));
 7702   effect(DEF dst, USE src, USE src1, KILL flags);
 7703 
 7704   ins_cost(300);
 7705   format %{ &quot;IMUL   $dst,$src1&quot; %}
 7706 
 7707   ins_encode( long_int_multiply( dst, src1 ) );
 7708   ins_pipe( ialu_reg_reg_alu0 );
 7709 %}
 7710 
 7711 instruct mulIS_eReg(eADXRegL dst, immL_32bits mask, eFlagsReg flags, eAXRegI src, nadxRegI src1) %{
 7712   // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 7713   match(Set dst (MulL (AndL (ConvI2L src) mask) (AndL (ConvI2L src1) mask)));
 7714   effect(KILL flags);
 7715 
 7716   ins_cost(300);
 7717   format %{ &quot;MUL    $dst,$src1&quot; %}
 7718 
 7719   ins_encode( long_uint_multiply(dst, src1) );
 7720   ins_pipe( ialu_reg_reg_alu0 );
 7721 %}
 7722 
 7723 // Multiply Register Long
 7724 instruct mulL_eReg(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7725   match(Set dst (MulL dst src));
 7726   effect(KILL cr, TEMP tmp);
 7727   ins_cost(4*100+3*400);
 7728 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7729 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 7730   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7731             &quot;IMUL   $tmp,EDX\n\t&quot;
 7732             &quot;MOV    EDX,$src.hi\n\t&quot;
 7733             &quot;IMUL   EDX,EAX\n\t&quot;
 7734             &quot;ADD    $tmp,EDX\n\t&quot;
 7735             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7736             &quot;ADD    EDX,$tmp&quot; %}
 7737   ins_encode( long_multiply( dst, src, tmp ) );
 7738   ins_pipe( pipe_slow );
 7739 %}
 7740 
 7741 // Multiply Register Long where the left operand&#39;s high 32 bits are zero
 7742 instruct mulL_eReg_lhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7743   predicate(is_operand_hi32_zero(n-&gt;in(1)));
 7744   match(Set dst (MulL dst src));
 7745   effect(KILL cr, TEMP tmp);
 7746   ins_cost(2*100+2*400);
 7747 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7748 //             hi(result) = hi(x_lo * y_lo) + lo(x_lo * y_hi) where lo(x_hi * y_lo) = 0 because x_hi = 0
 7749   format %{ &quot;MOV    $tmp,$src.hi\n\t&quot;
 7750             &quot;IMUL   $tmp,EAX\n\t&quot;
 7751             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7752             &quot;ADD    EDX,$tmp&quot; %}
 7753   ins_encode %{
 7754     __ movl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 7755     __ imull($tmp$$Register, rax);
 7756     __ mull($src$$Register);
 7757     __ addl(rdx, $tmp$$Register);
 7758   %}
 7759   ins_pipe( pipe_slow );
 7760 %}
 7761 
 7762 // Multiply Register Long where the right operand&#39;s high 32 bits are zero
 7763 instruct mulL_eReg_rhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7764   predicate(is_operand_hi32_zero(n-&gt;in(2)));
 7765   match(Set dst (MulL dst src));
 7766   effect(KILL cr, TEMP tmp);
 7767   ins_cost(2*100+2*400);
 7768 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7769 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) where lo(x_lo * y_hi) = 0 because y_hi = 0
 7770   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7771             &quot;IMUL   $tmp,EDX\n\t&quot;
 7772             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7773             &quot;ADD    EDX,$tmp&quot; %}
 7774   ins_encode %{
 7775     __ movl($tmp$$Register, $src$$Register);
 7776     __ imull($tmp$$Register, rdx);
 7777     __ mull($src$$Register);
 7778     __ addl(rdx, $tmp$$Register);
 7779   %}
 7780   ins_pipe( pipe_slow );
 7781 %}
 7782 
 7783 // Multiply Register Long where the left and the right operands&#39; high 32 bits are zero
 7784 instruct mulL_eReg_hi0(eADXRegL dst, eRegL src, eFlagsReg cr) %{
 7785   predicate(is_operand_hi32_zero(n-&gt;in(1)) &amp;&amp; is_operand_hi32_zero(n-&gt;in(2)));
 7786   match(Set dst (MulL dst src));
 7787   effect(KILL cr);
 7788   ins_cost(1*400);
 7789 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7790 //             hi(result) = hi(x_lo * y_lo) where lo(x_hi * y_lo) = 0 and lo(x_lo * y_hi) = 0 because x_hi = 0 and y_hi = 0
 7791   format %{ &quot;MUL    EDX:EAX,$src.lo\n\t&quot; %}
 7792   ins_encode %{
 7793     __ mull($src$$Register);
 7794   %}
 7795   ins_pipe( pipe_slow );
 7796 %}
 7797 
 7798 // Multiply Register Long by small constant
 7799 instruct mulL_eReg_con(eADXRegL dst, immL_127 src, rRegI tmp, eFlagsReg cr) %{
 7800   match(Set dst (MulL dst src));
 7801   effect(KILL cr, TEMP tmp);
 7802   ins_cost(2*100+2*400);
 7803   size(12);
 7804 // Basic idea: lo(result) = lo(src * EAX)
 7805 //             hi(result) = hi(src * EAX) + lo(src * EDX)
 7806   format %{ &quot;IMUL   $tmp,EDX,$src\n\t&quot;
 7807             &quot;MOV    EDX,$src\n\t&quot;
 7808             &quot;MUL    EDX\t# EDX*EAX -&gt; EDX:EAX\n\t&quot;
 7809             &quot;ADD    EDX,$tmp&quot; %}
 7810   ins_encode( long_multiply_con( dst, src, tmp ) );
 7811   ins_pipe( pipe_slow );
 7812 %}
 7813 
 7814 // Integer DIV with Register
 7815 instruct divI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7816   match(Set rax (DivI rax div));
 7817   effect(KILL rdx, KILL cr);
 7818   size(26);
 7819   ins_cost(30*100+10*100);
 7820   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7821             &quot;JNE,s  normal\n\t&quot;
 7822             &quot;XOR    EDX,EDX\n\t&quot;
 7823             &quot;CMP    ECX,-1\n\t&quot;
 7824             &quot;JE,s   done\n&quot;
 7825     &quot;normal: CDQ\n\t&quot;
 7826             &quot;IDIV   $div\n\t&quot;
 7827     &quot;done:&quot;        %}
 7828   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7829   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7830   ins_pipe( ialu_reg_reg_alu0 );
 7831 %}
 7832 
 7833 // Divide Register Long
 7834 instruct divL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7835   match(Set dst (DivL src1 src2));
 7836   effect( KILL cr, KILL cx, KILL bx );
 7837   ins_cost(10000);
 7838   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7839             &quot;PUSH   $src1.lo\n\t&quot;
 7840             &quot;PUSH   $src2.hi\n\t&quot;
 7841             &quot;PUSH   $src2.lo\n\t&quot;
 7842             &quot;CALL   SharedRuntime::ldiv\n\t&quot;
 7843             &quot;ADD    ESP,16&quot; %}
 7844   ins_encode( long_div(src1,src2) );
 7845   ins_pipe( pipe_slow );
 7846 %}
 7847 
 7848 // Integer DIVMOD with Register, both quotient and mod results
 7849 instruct divModI_eReg_divmod(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7850   match(DivModI rax div);
 7851   effect(KILL cr);
 7852   size(26);
 7853   ins_cost(30*100+10*100);
 7854   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7855             &quot;JNE,s  normal\n\t&quot;
 7856             &quot;XOR    EDX,EDX\n\t&quot;
 7857             &quot;CMP    ECX,-1\n\t&quot;
 7858             &quot;JE,s   done\n&quot;
 7859     &quot;normal: CDQ\n\t&quot;
 7860             &quot;IDIV   $div\n\t&quot;
 7861     &quot;done:&quot;        %}
 7862   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7863   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7864   ins_pipe( pipe_slow );
 7865 %}
 7866 
 7867 // Integer MOD with Register
 7868 instruct modI_eReg(eDXRegI rdx, eAXRegI rax, eCXRegI div, eFlagsReg cr) %{
 7869   match(Set rdx (ModI rax div));
 7870   effect(KILL rax, KILL cr);
 7871 
 7872   size(26);
 7873   ins_cost(300);
 7874   format %{ &quot;CDQ\n\t&quot;
 7875             &quot;IDIV   $div&quot; %}
 7876   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7877   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7878   ins_pipe( ialu_reg_reg_alu0 );
 7879 %}
 7880 
 7881 // Remainder Register Long
 7882 instruct modL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7883   match(Set dst (ModL src1 src2));
 7884   effect( KILL cr, KILL cx, KILL bx );
 7885   ins_cost(10000);
 7886   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7887             &quot;PUSH   $src1.lo\n\t&quot;
 7888             &quot;PUSH   $src2.hi\n\t&quot;
 7889             &quot;PUSH   $src2.lo\n\t&quot;
 7890             &quot;CALL   SharedRuntime::lrem\n\t&quot;
 7891             &quot;ADD    ESP,16&quot; %}
 7892   ins_encode( long_mod(src1,src2) );
 7893   ins_pipe( pipe_slow );
 7894 %}
 7895 
 7896 // Divide Register Long (no special case since divisor != -1)
 7897 instruct divL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7898   match(Set dst (DivL dst imm));
 7899   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7900   ins_cost(1000);
 7901   format %{ &quot;MOV    $tmp,abs($imm) # ldiv EDX:EAX,$imm\n\t&quot;
 7902             &quot;XOR    $tmp2,$tmp2\n\t&quot;
 7903             &quot;CMP    $tmp,EDX\n\t&quot;
 7904             &quot;JA,s   fast\n\t&quot;
 7905             &quot;MOV    $tmp2,EAX\n\t&quot;
 7906             &quot;MOV    EAX,EDX\n\t&quot;
 7907             &quot;MOV    EDX,0\n\t&quot;
 7908             &quot;JLE,s  pos\n\t&quot;
 7909             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7910             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7911             &quot;XCHG   EAX,$tmp2\n\t&quot;
 7912             &quot;DIV    $tmp\n\t&quot;
 7913             &quot;LNEG   $tmp2 : EAX\n\t&quot;
 7914             &quot;JMP,s  done\n&quot;
 7915     &quot;pos:\n\t&quot;
 7916             &quot;DIV    $tmp\n\t&quot;
 7917             &quot;XCHG   EAX,$tmp2\n&quot;
 7918     &quot;fast:\n\t&quot;
 7919             &quot;DIV    $tmp\n&quot;
 7920     &quot;done:\n\t&quot;
 7921             &quot;MOV    EDX,$tmp2\n\t&quot;
 7922             &quot;NEG    EDX:EAX # if $imm &lt; 0&quot; %}
 7923   ins_encode %{
 7924     int con = (int)$imm$$constant;
 7925     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 7926     int pcon = (con &gt; 0) ? con : -con;
 7927     Label Lfast, Lpos, Ldone;
 7928 
 7929     __ movl($tmp$$Register, pcon);
 7930     __ xorl($tmp2$$Register,$tmp2$$Register);
 7931     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 7932     __ jccb(Assembler::above, Lfast); // result fits into 32 bit
 7933 
 7934     __ movl($tmp2$$Register, $dst$$Register); // save
 7935     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 7936     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 7937     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 7938 
 7939     // Negative dividend.
 7940     // convert value to positive to use unsigned division
 7941     __ lneg($dst$$Register, $tmp2$$Register);
 7942     __ divl($tmp$$Register);
 7943     __ xchgl($dst$$Register, $tmp2$$Register);
 7944     __ divl($tmp$$Register);
 7945     // revert result back to negative
 7946     __ lneg($tmp2$$Register, $dst$$Register);
 7947     __ jmpb(Ldone);
 7948 
 7949     __ bind(Lpos);
 7950     __ divl($tmp$$Register); // Use unsigned division
 7951     __ xchgl($dst$$Register, $tmp2$$Register);
 7952     // Fallthrow for final divide, tmp2 has 32 bit hi result
 7953 
 7954     __ bind(Lfast);
 7955     // fast path: src is positive
 7956     __ divl($tmp$$Register); // Use unsigned division
 7957 
 7958     __ bind(Ldone);
 7959     __ movl(HIGH_FROM_LOW($dst$$Register),$tmp2$$Register);
 7960     if (con &lt; 0) {
 7961       __ lneg(HIGH_FROM_LOW($dst$$Register), $dst$$Register);
 7962     }
 7963   %}
 7964   ins_pipe( pipe_slow );
 7965 %}
 7966 
 7967 // Remainder Register Long (remainder fit into 32 bits)
 7968 instruct modL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7969   match(Set dst (ModL dst imm));
 7970   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7971   ins_cost(1000);
 7972   format %{ &quot;MOV    $tmp,abs($imm) # lrem EDX:EAX,$imm\n\t&quot;
 7973             &quot;CMP    $tmp,EDX\n\t&quot;
 7974             &quot;JA,s   fast\n\t&quot;
 7975             &quot;MOV    $tmp2,EAX\n\t&quot;
 7976             &quot;MOV    EAX,EDX\n\t&quot;
 7977             &quot;MOV    EDX,0\n\t&quot;
 7978             &quot;JLE,s  pos\n\t&quot;
 7979             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7980             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7981             &quot;MOV    EAX,$tmp2\n\t&quot;
 7982             &quot;DIV    $tmp\n\t&quot;
 7983             &quot;NEG    EDX\n\t&quot;
 7984             &quot;JMP,s  done\n&quot;
 7985     &quot;pos:\n\t&quot;
 7986             &quot;DIV    $tmp\n\t&quot;
 7987             &quot;MOV    EAX,$tmp2\n&quot;
 7988     &quot;fast:\n\t&quot;
 7989             &quot;DIV    $tmp\n&quot;
 7990     &quot;done:\n\t&quot;
 7991             &quot;MOV    EAX,EDX\n\t&quot;
 7992             &quot;SAR    EDX,31\n\t&quot; %}
 7993   ins_encode %{
 7994     int con = (int)$imm$$constant;
 7995     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 7996     int pcon = (con &gt; 0) ? con : -con;
 7997     Label  Lfast, Lpos, Ldone;
 7998 
 7999     __ movl($tmp$$Register, pcon);
 8000     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 8001     __ jccb(Assembler::above, Lfast); // src is positive and result fits into 32 bit
 8002 
 8003     __ movl($tmp2$$Register, $dst$$Register); // save
 8004     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8005     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 8006     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 8007 
 8008     // Negative dividend.
 8009     // convert value to positive to use unsigned division
 8010     __ lneg($dst$$Register, $tmp2$$Register);
 8011     __ divl($tmp$$Register);
 8012     __ movl($dst$$Register, $tmp2$$Register);
 8013     __ divl($tmp$$Register);
 8014     // revert remainder back to negative
 8015     __ negl(HIGH_FROM_LOW($dst$$Register));
 8016     __ jmpb(Ldone);
 8017 
 8018     __ bind(Lpos);
 8019     __ divl($tmp$$Register);
 8020     __ movl($dst$$Register, $tmp2$$Register);
 8021 
 8022     __ bind(Lfast);
 8023     // fast path: src is positive
 8024     __ divl($tmp$$Register);
 8025 
 8026     __ bind(Ldone);
 8027     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8028     __ sarl(HIGH_FROM_LOW($dst$$Register), 31); // result sign
 8029 
 8030   %}
 8031   ins_pipe( pipe_slow );
 8032 %}
 8033 
 8034 // Integer Shift Instructions
 8035 // Shift Left by one
 8036 instruct shlI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8037   match(Set dst (LShiftI dst shift));
 8038   effect(KILL cr);
 8039 
 8040   size(2);
 8041   format %{ &quot;SHL    $dst,$shift&quot; %}
 8042   opcode(0xD1, 0x4);  /* D1 /4 */
 8043   ins_encode( OpcP, RegOpc( dst ) );
 8044   ins_pipe( ialu_reg );
 8045 %}
 8046 
 8047 // Shift Left by 8-bit immediate
 8048 instruct salI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8049   match(Set dst (LShiftI dst shift));
 8050   effect(KILL cr);
 8051 
 8052   size(3);
 8053   format %{ &quot;SHL    $dst,$shift&quot; %}
 8054   opcode(0xC1, 0x4);  /* C1 /4 ib */
 8055   ins_encode( RegOpcImm( dst, shift) );
 8056   ins_pipe( ialu_reg );
 8057 %}
 8058 
 8059 // Shift Left by variable
 8060 instruct salI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8061   match(Set dst (LShiftI dst shift));
 8062   effect(KILL cr);
 8063 
 8064   size(2);
 8065   format %{ &quot;SHL    $dst,$shift&quot; %}
 8066   opcode(0xD3, 0x4);  /* D3 /4 */
 8067   ins_encode( OpcP, RegOpc( dst ) );
 8068   ins_pipe( ialu_reg_reg );
 8069 %}
 8070 
 8071 // Arithmetic shift right by one
 8072 instruct sarI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8073   match(Set dst (RShiftI dst shift));
 8074   effect(KILL cr);
 8075 
 8076   size(2);
 8077   format %{ &quot;SAR    $dst,$shift&quot; %}
 8078   opcode(0xD1, 0x7);  /* D1 /7 */
 8079   ins_encode( OpcP, RegOpc( dst ) );
 8080   ins_pipe( ialu_reg );
 8081 %}
 8082 
 8083 // Arithmetic shift right by one
 8084 instruct sarI_mem_1(memory dst, immI1 shift, eFlagsReg cr) %{
 8085   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8086   effect(KILL cr);
 8087   format %{ &quot;SAR    $dst,$shift&quot; %}
 8088   opcode(0xD1, 0x7);  /* D1 /7 */
 8089   ins_encode( OpcP, RMopc_Mem(secondary,dst) );
 8090   ins_pipe( ialu_mem_imm );
 8091 %}
 8092 
 8093 // Arithmetic Shift Right by 8-bit immediate
 8094 instruct sarI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8095   match(Set dst (RShiftI dst shift));
 8096   effect(KILL cr);
 8097 
 8098   size(3);
 8099   format %{ &quot;SAR    $dst,$shift&quot; %}
 8100   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8101   ins_encode( RegOpcImm( dst, shift ) );
 8102   ins_pipe( ialu_mem_imm );
 8103 %}
 8104 
 8105 // Arithmetic Shift Right by 8-bit immediate
 8106 instruct sarI_mem_imm(memory dst, immI8 shift, eFlagsReg cr) %{
 8107   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8108   effect(KILL cr);
 8109 
 8110   format %{ &quot;SAR    $dst,$shift&quot; %}
 8111   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8112   ins_encode( OpcP, RMopc_Mem(secondary, dst ), Con8or32( shift ) );
 8113   ins_pipe( ialu_mem_imm );
 8114 %}
 8115 
 8116 // Arithmetic Shift Right by variable
 8117 instruct sarI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8118   match(Set dst (RShiftI dst shift));
 8119   effect(KILL cr);
 8120 
 8121   size(2);
 8122   format %{ &quot;SAR    $dst,$shift&quot; %}
 8123   opcode(0xD3, 0x7);  /* D3 /7 */
 8124   ins_encode( OpcP, RegOpc( dst ) );
 8125   ins_pipe( ialu_reg_reg );
 8126 %}
 8127 
 8128 // Logical shift right by one
 8129 instruct shrI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8130   match(Set dst (URShiftI dst shift));
 8131   effect(KILL cr);
 8132 
 8133   size(2);
 8134   format %{ &quot;SHR    $dst,$shift&quot; %}
 8135   opcode(0xD1, 0x5);  /* D1 /5 */
 8136   ins_encode( OpcP, RegOpc( dst ) );
 8137   ins_pipe( ialu_reg );
 8138 %}
 8139 
 8140 // Logical Shift Right by 8-bit immediate
 8141 instruct shrI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8142   match(Set dst (URShiftI dst shift));
 8143   effect(KILL cr);
 8144 
 8145   size(3);
 8146   format %{ &quot;SHR    $dst,$shift&quot; %}
 8147   opcode(0xC1, 0x5);  /* C1 /5 ib */
 8148   ins_encode( RegOpcImm( dst, shift) );
 8149   ins_pipe( ialu_reg );
 8150 %}
 8151 
 8152 
 8153 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8154 // This idiom is used by the compiler for the i2b bytecode.
 8155 instruct i2b(rRegI dst, xRegI src, immI_24 twentyfour) %{
 8156   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8157 
 8158   size(3);
 8159   format %{ &quot;MOVSX  $dst,$src :8&quot; %}
 8160   ins_encode %{
 8161     __ movsbl($dst$$Register, $src$$Register);
 8162   %}
 8163   ins_pipe(ialu_reg_reg);
 8164 %}
 8165 
 8166 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8167 // This idiom is used by the compiler the i2s bytecode.
 8168 instruct i2s(rRegI dst, xRegI src, immI_16 sixteen) %{
 8169   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8170 
 8171   size(3);
 8172   format %{ &quot;MOVSX  $dst,$src :16&quot; %}
 8173   ins_encode %{
 8174     __ movswl($dst$$Register, $src$$Register);
 8175   %}
 8176   ins_pipe(ialu_reg_reg);
 8177 %}
 8178 
 8179 
 8180 // Logical Shift Right by variable
 8181 instruct shrI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8182   match(Set dst (URShiftI dst shift));
 8183   effect(KILL cr);
 8184 
 8185   size(2);
 8186   format %{ &quot;SHR    $dst,$shift&quot; %}
 8187   opcode(0xD3, 0x5);  /* D3 /5 */
 8188   ins_encode( OpcP, RegOpc( dst ) );
 8189   ins_pipe( ialu_reg_reg );
 8190 %}
 8191 
 8192 
 8193 //----------Logical Instructions-----------------------------------------------
 8194 //----------Integer Logical Instructions---------------------------------------
 8195 // And Instructions
 8196 // And Register with Register
 8197 instruct andI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8198   match(Set dst (AndI dst src));
 8199   effect(KILL cr);
 8200 
 8201   size(2);
 8202   format %{ &quot;AND    $dst,$src&quot; %}
 8203   opcode(0x23);
 8204   ins_encode( OpcP, RegReg( dst, src) );
 8205   ins_pipe( ialu_reg_reg );
 8206 %}
 8207 
 8208 // And Register with Immediate
 8209 instruct andI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8210   match(Set dst (AndI dst src));
 8211   effect(KILL cr);
 8212 
 8213   format %{ &quot;AND    $dst,$src&quot; %}
 8214   opcode(0x81,0x04);  /* Opcode 81 /4 */
 8215   // ins_encode( RegImm( dst, src) );
 8216   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8217   ins_pipe( ialu_reg );
 8218 %}
 8219 
 8220 // And Register with Memory
 8221 instruct andI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8222   match(Set dst (AndI dst (LoadI src)));
 8223   effect(KILL cr);
 8224 
 8225   ins_cost(125);
 8226   format %{ &quot;AND    $dst,$src&quot; %}
 8227   opcode(0x23);
 8228   ins_encode( OpcP, RegMem( dst, src) );
 8229   ins_pipe( ialu_reg_mem );
 8230 %}
 8231 
 8232 // And Memory with Register
 8233 instruct andI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8234   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8235   effect(KILL cr);
 8236 
 8237   ins_cost(150);
 8238   format %{ &quot;AND    $dst,$src&quot; %}
 8239   opcode(0x21);  /* Opcode 21 /r */
 8240   ins_encode( OpcP, RegMem( src, dst ) );
 8241   ins_pipe( ialu_mem_reg );
 8242 %}
 8243 
 8244 // And Memory with Immediate
 8245 instruct andI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8246   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8247   effect(KILL cr);
 8248 
 8249   ins_cost(125);
 8250   format %{ &quot;AND    $dst,$src&quot; %}
 8251   opcode(0x81, 0x4);  /* Opcode 81 /4 id */
 8252   // ins_encode( MemImm( dst, src) );
 8253   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8254   ins_pipe( ialu_mem_imm );
 8255 %}
 8256 
 8257 // BMI1 instructions
 8258 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, eFlagsReg cr) %{
 8259   match(Set dst (AndI (XorI src1 minus_1) src2));
 8260   predicate(UseBMI1Instructions);
 8261   effect(KILL cr);
 8262 
 8263   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8264 
 8265   ins_encode %{
 8266     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 8267   %}
 8268   ins_pipe(ialu_reg);
 8269 %}
 8270 
 8271 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, eFlagsReg cr) %{
 8272   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2) ));
 8273   predicate(UseBMI1Instructions);
 8274   effect(KILL cr);
 8275 
 8276   ins_cost(125);
 8277   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8278 
 8279   ins_encode %{
 8280     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 8281   %}
 8282   ins_pipe(ialu_reg_mem);
 8283 %}
 8284 
 8285 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, eFlagsReg cr) %{
 8286   match(Set dst (AndI (SubI imm_zero src) src));
 8287   predicate(UseBMI1Instructions);
 8288   effect(KILL cr);
 8289 
 8290   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8291 
 8292   ins_encode %{
 8293     __ blsil($dst$$Register, $src$$Register);
 8294   %}
 8295   ins_pipe(ialu_reg);
 8296 %}
 8297 
 8298 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, eFlagsReg cr) %{
 8299   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 8300   predicate(UseBMI1Instructions);
 8301   effect(KILL cr);
 8302 
 8303   ins_cost(125);
 8304   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8305 
 8306   ins_encode %{
 8307     __ blsil($dst$$Register, $src$$Address);
 8308   %}
 8309   ins_pipe(ialu_reg_mem);
 8310 %}
 8311 
 8312 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8313 %{
 8314   match(Set dst (XorI (AddI src minus_1) src));
 8315   predicate(UseBMI1Instructions);
 8316   effect(KILL cr);
 8317 
 8318   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8319 
 8320   ins_encode %{
 8321     __ blsmskl($dst$$Register, $src$$Register);
 8322   %}
 8323 
 8324   ins_pipe(ialu_reg);
 8325 %}
 8326 
 8327 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8328 %{
 8329   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ));
 8330   predicate(UseBMI1Instructions);
 8331   effect(KILL cr);
 8332 
 8333   ins_cost(125);
 8334   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8335 
 8336   ins_encode %{
 8337     __ blsmskl($dst$$Register, $src$$Address);
 8338   %}
 8339 
 8340   ins_pipe(ialu_reg_mem);
 8341 %}
 8342 
 8343 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8344 %{
 8345   match(Set dst (AndI (AddI src minus_1) src) );
 8346   predicate(UseBMI1Instructions);
 8347   effect(KILL cr);
 8348 
 8349   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8350 
 8351   ins_encode %{
 8352     __ blsrl($dst$$Register, $src$$Register);
 8353   %}
 8354 
 8355   ins_pipe(ialu_reg);
 8356 %}
 8357 
 8358 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8359 %{
 8360   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ));
 8361   predicate(UseBMI1Instructions);
 8362   effect(KILL cr);
 8363 
 8364   ins_cost(125);
 8365   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8366 
 8367   ins_encode %{
 8368     __ blsrl($dst$$Register, $src$$Address);
 8369   %}
 8370 
 8371   ins_pipe(ialu_reg_mem);
 8372 %}
 8373 
 8374 // Or Instructions
 8375 // Or Register with Register
 8376 instruct orI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8377   match(Set dst (OrI dst src));
 8378   effect(KILL cr);
 8379 
 8380   size(2);
 8381   format %{ &quot;OR     $dst,$src&quot; %}
 8382   opcode(0x0B);
 8383   ins_encode( OpcP, RegReg( dst, src) );
 8384   ins_pipe( ialu_reg_reg );
 8385 %}
 8386 
 8387 instruct orI_eReg_castP2X(rRegI dst, eRegP src, eFlagsReg cr) %{
 8388   match(Set dst (OrI dst (CastP2X src)));
 8389   effect(KILL cr);
 8390 
 8391   size(2);
 8392   format %{ &quot;OR     $dst,$src&quot; %}
 8393   opcode(0x0B);
 8394   ins_encode( OpcP, RegReg( dst, src) );
 8395   ins_pipe( ialu_reg_reg );
 8396 %}
 8397 
 8398 
 8399 // Or Register with Immediate
 8400 instruct orI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8401   match(Set dst (OrI dst src));
 8402   effect(KILL cr);
 8403 
 8404   format %{ &quot;OR     $dst,$src&quot; %}
 8405   opcode(0x81,0x01);  /* Opcode 81 /1 id */
 8406   // ins_encode( RegImm( dst, src) );
 8407   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8408   ins_pipe( ialu_reg );
 8409 %}
 8410 
 8411 // Or Register with Memory
 8412 instruct orI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8413   match(Set dst (OrI dst (LoadI src)));
 8414   effect(KILL cr);
 8415 
 8416   ins_cost(125);
 8417   format %{ &quot;OR     $dst,$src&quot; %}
 8418   opcode(0x0B);
 8419   ins_encode( OpcP, RegMem( dst, src) );
 8420   ins_pipe( ialu_reg_mem );
 8421 %}
 8422 
 8423 // Or Memory with Register
 8424 instruct orI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8425   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8426   effect(KILL cr);
 8427 
 8428   ins_cost(150);
 8429   format %{ &quot;OR     $dst,$src&quot; %}
 8430   opcode(0x09);  /* Opcode 09 /r */
 8431   ins_encode( OpcP, RegMem( src, dst ) );
 8432   ins_pipe( ialu_mem_reg );
 8433 %}
 8434 
 8435 // Or Memory with Immediate
 8436 instruct orI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8437   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8438   effect(KILL cr);
 8439 
 8440   ins_cost(125);
 8441   format %{ &quot;OR     $dst,$src&quot; %}
 8442   opcode(0x81,0x1);  /* Opcode 81 /1 id */
 8443   // ins_encode( MemImm( dst, src) );
 8444   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8445   ins_pipe( ialu_mem_imm );
 8446 %}
 8447 
 8448 // ROL/ROR
 8449 // ROL expand
 8450 instruct rolI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8451   effect(USE_DEF dst, USE shift, KILL cr);
 8452 
 8453   format %{ &quot;ROL    $dst, $shift&quot; %}
 8454   opcode(0xD1, 0x0); /* Opcode D1 /0 */
 8455   ins_encode( OpcP, RegOpc( dst ));
 8456   ins_pipe( ialu_reg );
 8457 %}
 8458 
 8459 instruct rolI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8460   effect(USE_DEF dst, USE shift, KILL cr);
 8461 
 8462   format %{ &quot;ROL    $dst, $shift&quot; %}
 8463   opcode(0xC1, 0x0); /*Opcode /C1  /0  */
 8464   ins_encode( RegOpcImm(dst, shift) );
 8465   ins_pipe(ialu_reg);
 8466 %}
 8467 
 8468 instruct rolI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8469   effect(USE_DEF dst, USE shift, KILL cr);
 8470 
 8471   format %{ &quot;ROL    $dst, $shift&quot; %}
 8472   opcode(0xD3, 0x0);    /* Opcode D3 /0 */
 8473   ins_encode(OpcP, RegOpc(dst));
 8474   ins_pipe( ialu_reg_reg );
 8475 %}
 8476 // end of ROL expand
 8477 
 8478 // ROL 32bit by one once
 8479 instruct rolI_eReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, eFlagsReg cr) %{
 8480   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8481 
 8482   expand %{
 8483     rolI_eReg_imm1(dst, lshift, cr);
 8484   %}
 8485 %}
 8486 
 8487 // ROL 32bit var by imm8 once
 8488 instruct rolI_eReg_i8(rRegI dst, immI8 lshift, immI8 rshift, eFlagsReg cr) %{
 8489   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8490   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8491 
 8492   expand %{
 8493     rolI_eReg_imm8(dst, lshift, cr);
 8494   %}
 8495 %}
 8496 
 8497 // ROL 32bit var by var once
 8498 instruct rolI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8499   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 8500 
 8501   expand %{
 8502     rolI_eReg_CL(dst, shift, cr);
 8503   %}
 8504 %}
 8505 
 8506 // ROL 32bit var by var once
 8507 instruct rolI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8508   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 8509 
 8510   expand %{
 8511     rolI_eReg_CL(dst, shift, cr);
 8512   %}
 8513 %}
 8514 
 8515 // ROR expand
 8516 instruct rorI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8517   effect(USE_DEF dst, USE shift, KILL cr);
 8518 
 8519   format %{ &quot;ROR    $dst, $shift&quot; %}
 8520   opcode(0xD1,0x1);  /* Opcode D1 /1 */
 8521   ins_encode( OpcP, RegOpc( dst ) );
 8522   ins_pipe( ialu_reg );
 8523 %}
 8524 
 8525 instruct rorI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8526   effect (USE_DEF dst, USE shift, KILL cr);
 8527 
 8528   format %{ &quot;ROR    $dst, $shift&quot; %}
 8529   opcode(0xC1, 0x1); /* Opcode /C1 /1 ib */
 8530   ins_encode( RegOpcImm(dst, shift) );
 8531   ins_pipe( ialu_reg );
 8532 %}
 8533 
 8534 instruct rorI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr)%{
 8535   effect(USE_DEF dst, USE shift, KILL cr);
 8536 
 8537   format %{ &quot;ROR    $dst, $shift&quot; %}
 8538   opcode(0xD3, 0x1);    /* Opcode D3 /1 */
 8539   ins_encode(OpcP, RegOpc(dst));
 8540   ins_pipe( ialu_reg_reg );
 8541 %}
 8542 // end of ROR expand
 8543 
 8544 // ROR right once
 8545 instruct rorI_eReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, eFlagsReg cr) %{
 8546   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8547 
 8548   expand %{
 8549     rorI_eReg_imm1(dst, rshift, cr);
 8550   %}
 8551 %}
 8552 
 8553 // ROR 32bit by immI8 once
 8554 instruct rorI_eReg_i8(rRegI dst, immI8 rshift, immI8 lshift, eFlagsReg cr) %{
 8555   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8556   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8557 
 8558   expand %{
 8559     rorI_eReg_imm8(dst, rshift, cr);
 8560   %}
 8561 %}
 8562 
 8563 // ROR 32bit var by var once
 8564 instruct rorI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8565   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 8566 
 8567   expand %{
 8568     rorI_eReg_CL(dst, shift, cr);
 8569   %}
 8570 %}
 8571 
 8572 // ROR 32bit var by var once
 8573 instruct rorI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8574   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 8575 
 8576   expand %{
 8577     rorI_eReg_CL(dst, shift, cr);
 8578   %}
 8579 %}
 8580 
 8581 // Xor Instructions
 8582 // Xor Register with Register
 8583 instruct xorI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8584   match(Set dst (XorI dst src));
 8585   effect(KILL cr);
 8586 
 8587   size(2);
 8588   format %{ &quot;XOR    $dst,$src&quot; %}
 8589   opcode(0x33);
 8590   ins_encode( OpcP, RegReg( dst, src) );
 8591   ins_pipe( ialu_reg_reg );
 8592 %}
 8593 
 8594 // Xor Register with Immediate -1
 8595 instruct xorI_eReg_im1(rRegI dst, immI_M1 imm) %{
 8596   match(Set dst (XorI dst imm));
 8597 
 8598   size(2);
 8599   format %{ &quot;NOT    $dst&quot; %}
 8600   ins_encode %{
 8601      __ notl($dst$$Register);
 8602   %}
 8603   ins_pipe( ialu_reg );
 8604 %}
 8605 
 8606 // Xor Register with Immediate
 8607 instruct xorI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8608   match(Set dst (XorI dst src));
 8609   effect(KILL cr);
 8610 
 8611   format %{ &quot;XOR    $dst,$src&quot; %}
 8612   opcode(0x81,0x06);  /* Opcode 81 /6 id */
 8613   // ins_encode( RegImm( dst, src) );
 8614   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8615   ins_pipe( ialu_reg );
 8616 %}
 8617 
 8618 // Xor Register with Memory
 8619 instruct xorI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8620   match(Set dst (XorI dst (LoadI src)));
 8621   effect(KILL cr);
 8622 
 8623   ins_cost(125);
 8624   format %{ &quot;XOR    $dst,$src&quot; %}
 8625   opcode(0x33);
 8626   ins_encode( OpcP, RegMem(dst, src) );
 8627   ins_pipe( ialu_reg_mem );
 8628 %}
 8629 
 8630 // Xor Memory with Register
 8631 instruct xorI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8632   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8633   effect(KILL cr);
 8634 
 8635   ins_cost(150);
 8636   format %{ &quot;XOR    $dst,$src&quot; %}
 8637   opcode(0x31);  /* Opcode 31 /r */
 8638   ins_encode( OpcP, RegMem( src, dst ) );
 8639   ins_pipe( ialu_mem_reg );
 8640 %}
 8641 
 8642 // Xor Memory with Immediate
 8643 instruct xorI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8644   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8645   effect(KILL cr);
 8646 
 8647   ins_cost(125);
 8648   format %{ &quot;XOR    $dst,$src&quot; %}
 8649   opcode(0x81,0x6);  /* Opcode 81 /6 id */
 8650   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8651   ins_pipe( ialu_mem_imm );
 8652 %}
 8653 
 8654 //----------Convert Int to Boolean---------------------------------------------
 8655 
 8656 instruct movI_nocopy(rRegI dst, rRegI src) %{
 8657   effect( DEF dst, USE src );
 8658   format %{ &quot;MOV    $dst,$src&quot; %}
 8659   ins_encode( enc_Copy( dst, src) );
 8660   ins_pipe( ialu_reg_reg );
 8661 %}
 8662 
 8663 instruct ci2b( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8664   effect( USE_DEF dst, USE src, KILL cr );
 8665 
 8666   size(4);
 8667   format %{ &quot;NEG    $dst\n\t&quot;
 8668             &quot;ADC    $dst,$src&quot; %}
 8669   ins_encode( neg_reg(dst),
 8670               OpcRegReg(0x13,dst,src) );
 8671   ins_pipe( ialu_reg_reg_long );
 8672 %}
 8673 
 8674 instruct convI2B( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8675   match(Set dst (Conv2B src));
 8676 
 8677   expand %{
 8678     movI_nocopy(dst,src);
 8679     ci2b(dst,src,cr);
 8680   %}
 8681 %}
 8682 
 8683 instruct movP_nocopy(rRegI dst, eRegP src) %{
 8684   effect( DEF dst, USE src );
 8685   format %{ &quot;MOV    $dst,$src&quot; %}
 8686   ins_encode( enc_Copy( dst, src) );
 8687   ins_pipe( ialu_reg_reg );
 8688 %}
 8689 
 8690 instruct cp2b( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8691   effect( USE_DEF dst, USE src, KILL cr );
 8692   format %{ &quot;NEG    $dst\n\t&quot;
 8693             &quot;ADC    $dst,$src&quot; %}
 8694   ins_encode( neg_reg(dst),
 8695               OpcRegReg(0x13,dst,src) );
 8696   ins_pipe( ialu_reg_reg_long );
 8697 %}
 8698 
 8699 instruct convP2B( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8700   match(Set dst (Conv2B src));
 8701 
 8702   expand %{
 8703     movP_nocopy(dst,src);
 8704     cp2b(dst,src,cr);
 8705   %}
 8706 %}
 8707 
 8708 instruct cmpLTMask(eCXRegI dst, ncxRegI p, ncxRegI q, eFlagsReg cr) %{
 8709   match(Set dst (CmpLTMask p q));
 8710   effect(KILL cr);
 8711   ins_cost(400);
 8712 
 8713   // SETlt can only use low byte of EAX,EBX, ECX, or EDX as destination
 8714   format %{ &quot;XOR    $dst,$dst\n\t&quot;
 8715             &quot;CMP    $p,$q\n\t&quot;
 8716             &quot;SETlt  $dst\n\t&quot;
 8717             &quot;NEG    $dst&quot; %}
 8718   ins_encode %{
 8719     Register Rp = $p$$Register;
 8720     Register Rq = $q$$Register;
 8721     Register Rd = $dst$$Register;
 8722     Label done;
 8723     __ xorl(Rd, Rd);
 8724     __ cmpl(Rp, Rq);
 8725     __ setb(Assembler::less, Rd);
 8726     __ negl(Rd);
 8727   %}
 8728 
 8729   ins_pipe(pipe_slow);
 8730 %}
 8731 
 8732 instruct cmpLTMask0(rRegI dst, immI0 zero, eFlagsReg cr) %{
 8733   match(Set dst (CmpLTMask dst zero));
 8734   effect(DEF dst, KILL cr);
 8735   ins_cost(100);
 8736 
 8737   format %{ &quot;SAR    $dst,31\t# cmpLTMask0&quot; %}
 8738   ins_encode %{
 8739   __ sarl($dst$$Register, 31);
 8740   %}
 8741   ins_pipe(ialu_reg);
 8742 %}
 8743 
 8744 /* better to save a register than avoid a branch */
 8745 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8746   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 8747   effect(KILL cr);
 8748   ins_cost(400);
 8749   format %{ &quot;SUB    $p,$q\t# cadd_cmpLTMask\n\t&quot;
 8750             &quot;JGE    done\n\t&quot;
 8751             &quot;ADD    $p,$y\n&quot;
 8752             &quot;done:  &quot; %}
 8753   ins_encode %{
 8754     Register Rp = $p$$Register;
 8755     Register Rq = $q$$Register;
 8756     Register Ry = $y$$Register;
 8757     Label done;
 8758     __ subl(Rp, Rq);
 8759     __ jccb(Assembler::greaterEqual, done);
 8760     __ addl(Rp, Ry);
 8761     __ bind(done);
 8762   %}
 8763 
 8764   ins_pipe(pipe_cmplt);
 8765 %}
 8766 
 8767 /* better to save a register than avoid a branch */
 8768 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8769   match(Set y (AndI (CmpLTMask p q) y));
 8770   effect(KILL cr);
 8771 
 8772   ins_cost(300);
 8773 
 8774   format %{ &quot;CMPL     $p, $q\t# and_cmpLTMask\n\t&quot;
 8775             &quot;JLT      done\n\t&quot;
 8776             &quot;XORL     $y, $y\n&quot;
 8777             &quot;done:  &quot; %}
 8778   ins_encode %{
 8779     Register Rp = $p$$Register;
 8780     Register Rq = $q$$Register;
 8781     Register Ry = $y$$Register;
 8782     Label done;
 8783     __ cmpl(Rp, Rq);
 8784     __ jccb(Assembler::less, done);
 8785     __ xorl(Ry, Ry);
 8786     __ bind(done);
 8787   %}
 8788 
 8789   ins_pipe(pipe_cmplt);
 8790 %}
 8791 
 8792 /* If I enable this, I encourage spilling in the inner loop of compress.
 8793 instruct cadd_cmpLTMask_mem(ncxRegI p, ncxRegI q, memory y, eCXRegI tmp, eFlagsReg cr) %{
 8794   match(Set p (AddI (AndI (CmpLTMask p q) (LoadI y)) (SubI p q)));
 8795 */
 8796 //----------Overflow Math Instructions-----------------------------------------
 8797 
 8798 instruct overflowAddI_eReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8799 %{
 8800   match(Set cr (OverflowAddI op1 op2));
 8801   effect(DEF cr, USE_KILL op1, USE op2);
 8802 
 8803   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8804 
 8805   ins_encode %{
 8806     __ addl($op1$$Register, $op2$$Register);
 8807   %}
 8808   ins_pipe(ialu_reg_reg);
 8809 %}
 8810 
 8811 instruct overflowAddI_rReg_imm(eFlagsReg cr, eAXRegI op1, immI op2)
 8812 %{
 8813   match(Set cr (OverflowAddI op1 op2));
 8814   effect(DEF cr, USE_KILL op1, USE op2);
 8815 
 8816   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8817 
 8818   ins_encode %{
 8819     __ addl($op1$$Register, $op2$$constant);
 8820   %}
 8821   ins_pipe(ialu_reg_reg);
 8822 %}
 8823 
 8824 instruct overflowSubI_rReg(eFlagsReg cr, rRegI op1, rRegI op2)
 8825 %{
 8826   match(Set cr (OverflowSubI op1 op2));
 8827 
 8828   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8829   ins_encode %{
 8830     __ cmpl($op1$$Register, $op2$$Register);
 8831   %}
 8832   ins_pipe(ialu_reg_reg);
 8833 %}
 8834 
 8835 instruct overflowSubI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2)
 8836 %{
 8837   match(Set cr (OverflowSubI op1 op2));
 8838 
 8839   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8840   ins_encode %{
 8841     __ cmpl($op1$$Register, $op2$$constant);
 8842   %}
 8843   ins_pipe(ialu_reg_reg);
 8844 %}
 8845 
 8846 instruct overflowNegI_rReg(eFlagsReg cr, immI0 zero, eAXRegI op2)
 8847 %{
 8848   match(Set cr (OverflowSubI zero op2));
 8849   effect(DEF cr, USE_KILL op2);
 8850 
 8851   format %{ &quot;NEG    $op2\t# overflow check int&quot; %}
 8852   ins_encode %{
 8853     __ negl($op2$$Register);
 8854   %}
 8855   ins_pipe(ialu_reg_reg);
 8856 %}
 8857 
 8858 instruct overflowMulI_rReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8859 %{
 8860   match(Set cr (OverflowMulI op1 op2));
 8861   effect(DEF cr, USE_KILL op1, USE op2);
 8862 
 8863   format %{ &quot;IMUL    $op1, $op2\t# overflow check int&quot; %}
 8864   ins_encode %{
 8865     __ imull($op1$$Register, $op2$$Register);
 8866   %}
 8867   ins_pipe(ialu_reg_reg_alu0);
 8868 %}
 8869 
 8870 instruct overflowMulI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
 8871 %{
 8872   match(Set cr (OverflowMulI op1 op2));
 8873   effect(DEF cr, TEMP tmp, USE op1, USE op2);
 8874 
 8875   format %{ &quot;IMUL    $tmp, $op1, $op2\t# overflow check int&quot; %}
 8876   ins_encode %{
 8877     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
 8878   %}
 8879   ins_pipe(ialu_reg_reg_alu0);
 8880 %}
 8881 
 8882 // Integer Absolute Instructions
 8883 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, eFlagsReg cr)
 8884 %{
 8885   match(Set dst (AbsI src));
 8886   effect(TEMP dst, TEMP tmp, KILL cr);
 8887   format %{ &quot;movl $tmp, $src\n\t&quot;
 8888             &quot;sarl $tmp, 31\n\t&quot;
 8889             &quot;movl $dst, $src\n\t&quot;
 8890             &quot;xorl $dst, $tmp\n\t&quot;
 8891             &quot;subl $dst, $tmp\n&quot;
 8892           %}
 8893   ins_encode %{
 8894     __ movl($tmp$$Register, $src$$Register);
 8895     __ sarl($tmp$$Register, 31);
 8896     __ movl($dst$$Register, $src$$Register);
 8897     __ xorl($dst$$Register, $tmp$$Register);
 8898     __ subl($dst$$Register, $tmp$$Register);
 8899   %}
 8900 
 8901   ins_pipe(ialu_reg_reg);
 8902 %}
 8903 
 8904 //----------Long Instructions------------------------------------------------
 8905 // Add Long Register with Register
 8906 instruct addL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8907   match(Set dst (AddL dst src));
 8908   effect(KILL cr);
 8909   ins_cost(200);
 8910   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8911             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8912   opcode(0x03, 0x13);
 8913   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8914   ins_pipe( ialu_reg_reg_long );
 8915 %}
 8916 
 8917 // Add Long Register with Immediate
 8918 instruct addL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8919   match(Set dst (AddL dst src));
 8920   effect(KILL cr);
 8921   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8922             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8923   opcode(0x81,0x00,0x02);  /* Opcode 81 /0, 81 /2 */
 8924   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8925   ins_pipe( ialu_reg_long );
 8926 %}
 8927 
 8928 // Add Long Register with Memory
 8929 instruct addL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8930   match(Set dst (AddL dst (LoadL mem)));
 8931   effect(KILL cr);
 8932   ins_cost(125);
 8933   format %{ &quot;ADD    $dst.lo,$mem\n\t&quot;
 8934             &quot;ADC    $dst.hi,$mem+4&quot; %}
 8935   opcode(0x03, 0x13);
 8936   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8937   ins_pipe( ialu_reg_long_mem );
 8938 %}
 8939 
 8940 // Subtract Long Register with Register.
 8941 instruct subL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8942   match(Set dst (SubL dst src));
 8943   effect(KILL cr);
 8944   ins_cost(200);
 8945   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8946             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8947   opcode(0x2B, 0x1B);
 8948   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8949   ins_pipe( ialu_reg_reg_long );
 8950 %}
 8951 
 8952 // Subtract Long Register with Immediate
 8953 instruct subL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8954   match(Set dst (SubL dst src));
 8955   effect(KILL cr);
 8956   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8957             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8958   opcode(0x81,0x05,0x03);  /* Opcode 81 /5, 81 /3 */
 8959   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8960   ins_pipe( ialu_reg_long );
 8961 %}
 8962 
 8963 // Subtract Long Register with Memory
 8964 instruct subL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8965   match(Set dst (SubL dst (LoadL mem)));
 8966   effect(KILL cr);
 8967   ins_cost(125);
 8968   format %{ &quot;SUB    $dst.lo,$mem\n\t&quot;
 8969             &quot;SBB    $dst.hi,$mem+4&quot; %}
 8970   opcode(0x2B, 0x1B);
 8971   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8972   ins_pipe( ialu_reg_long_mem );
 8973 %}
 8974 
 8975 instruct negL_eReg(eRegL dst, immL0 zero, eFlagsReg cr) %{
 8976   match(Set dst (SubL zero dst));
 8977   effect(KILL cr);
 8978   ins_cost(300);
 8979   format %{ &quot;NEG    $dst.hi\n\tNEG    $dst.lo\n\tSBB    $dst.hi,0&quot; %}
 8980   ins_encode( neg_long(dst) );
 8981   ins_pipe( ialu_reg_reg_long );
 8982 %}
 8983 
 8984 // And Long Register with Register
 8985 instruct andL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8986   match(Set dst (AndL dst src));
 8987   effect(KILL cr);
 8988   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 8989             &quot;AND    $dst.hi,$src.hi&quot; %}
 8990   opcode(0x23,0x23);
 8991   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 8992   ins_pipe( ialu_reg_reg_long );
 8993 %}
 8994 
 8995 // And Long Register with Immediate
 8996 instruct andL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8997   match(Set dst (AndL dst src));
 8998   effect(KILL cr);
 8999   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 9000             &quot;AND    $dst.hi,$src.hi&quot; %}
 9001   opcode(0x81,0x04,0x04);  /* Opcode 81 /4, 81 /4 */
 9002   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9003   ins_pipe( ialu_reg_long );
 9004 %}
 9005 
 9006 // And Long Register with Memory
 9007 instruct andL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9008   match(Set dst (AndL dst (LoadL mem)));
 9009   effect(KILL cr);
 9010   ins_cost(125);
 9011   format %{ &quot;AND    $dst.lo,$mem\n\t&quot;
 9012             &quot;AND    $dst.hi,$mem+4&quot; %}
 9013   opcode(0x23, 0x23);
 9014   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9015   ins_pipe( ialu_reg_long_mem );
 9016 %}
 9017 
 9018 // BMI1 instructions
 9019 instruct andnL_eReg_eReg_eReg(eRegL dst, eRegL src1, eRegL src2, immL_M1 minus_1, eFlagsReg cr) %{
 9020   match(Set dst (AndL (XorL src1 minus_1) src2));
 9021   predicate(UseBMI1Instructions);
 9022   effect(KILL cr, TEMP dst);
 9023 
 9024   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2.lo\n\t&quot;
 9025             &quot;ANDNL  $dst.hi, $src1.hi, $src2.hi&quot;
 9026          %}
 9027 
 9028   ins_encode %{
 9029     Register Rdst = $dst$$Register;
 9030     Register Rsrc1 = $src1$$Register;
 9031     Register Rsrc2 = $src2$$Register;
 9032     __ andnl(Rdst, Rsrc1, Rsrc2);
 9033     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), HIGH_FROM_LOW(Rsrc2));
 9034   %}
 9035   ins_pipe(ialu_reg_reg_long);
 9036 %}
 9037 
 9038 instruct andnL_eReg_eReg_mem(eRegL dst, eRegL src1, memory src2, immL_M1 minus_1, eFlagsReg cr) %{
 9039   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2) ));
 9040   predicate(UseBMI1Instructions);
 9041   effect(KILL cr, TEMP dst);
 9042 
 9043   ins_cost(125);
 9044   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2\n\t&quot;
 9045             &quot;ANDNL  $dst.hi, $src1.hi, $src2+4&quot;
 9046          %}
 9047 
 9048   ins_encode %{
 9049     Register Rdst = $dst$$Register;
 9050     Register Rsrc1 = $src1$$Register;
 9051     Address src2_hi = Address::make_raw($src2$$base, $src2$$index, $src2$$scale, $src2$$disp + 4, relocInfo::none);
 9052 
 9053     __ andnl(Rdst, Rsrc1, $src2$$Address);
 9054     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), src2_hi);
 9055   %}
 9056   ins_pipe(ialu_reg_mem);
 9057 %}
 9058 
 9059 instruct blsiL_eReg_eReg(eRegL dst, eRegL src, immL0 imm_zero, eFlagsReg cr) %{
 9060   match(Set dst (AndL (SubL imm_zero src) src));
 9061   predicate(UseBMI1Instructions);
 9062   effect(KILL cr, TEMP dst);
 9063 
 9064   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9065             &quot;BLSIL  $dst.lo, $src.lo\n\t&quot;
 9066             &quot;JNZ    done\n\t&quot;
 9067             &quot;BLSIL  $dst.hi, $src.hi\n&quot;
 9068             &quot;done:&quot;
 9069          %}
 9070 
 9071   ins_encode %{
 9072     Label done;
 9073     Register Rdst = $dst$$Register;
 9074     Register Rsrc = $src$$Register;
 9075     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9076     __ blsil(Rdst, Rsrc);
 9077     __ jccb(Assembler::notZero, done);
 9078     __ blsil(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9079     __ bind(done);
 9080   %}
 9081   ins_pipe(ialu_reg);
 9082 %}
 9083 
 9084 instruct blsiL_eReg_mem(eRegL dst, memory src, immL0 imm_zero, eFlagsReg cr) %{
 9085   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9086   predicate(UseBMI1Instructions);
 9087   effect(KILL cr, TEMP dst);
 9088 
 9089   ins_cost(125);
 9090   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9091             &quot;BLSIL  $dst.lo, $src\n\t&quot;
 9092             &quot;JNZ    done\n\t&quot;
 9093             &quot;BLSIL  $dst.hi, $src+4\n&quot;
 9094             &quot;done:&quot;
 9095          %}
 9096 
 9097   ins_encode %{
 9098     Label done;
 9099     Register Rdst = $dst$$Register;
 9100     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9101 
 9102     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9103     __ blsil(Rdst, $src$$Address);
 9104     __ jccb(Assembler::notZero, done);
 9105     __ blsil(HIGH_FROM_LOW(Rdst), src_hi);
 9106     __ bind(done);
 9107   %}
 9108   ins_pipe(ialu_reg_mem);
 9109 %}
 9110 
 9111 instruct blsmskL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9112 %{
 9113   match(Set dst (XorL (AddL src minus_1) src));
 9114   predicate(UseBMI1Instructions);
 9115   effect(KILL cr, TEMP dst);
 9116 
 9117   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9118             &quot;BLSMSKL $dst.lo, $src.lo\n\t&quot;
 9119             &quot;JNC     done\n\t&quot;
 9120             &quot;BLSMSKL $dst.hi, $src.hi\n&quot;
 9121             &quot;done:&quot;
 9122          %}
 9123 
 9124   ins_encode %{
 9125     Label done;
 9126     Register Rdst = $dst$$Register;
 9127     Register Rsrc = $src$$Register;
 9128     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9129     __ blsmskl(Rdst, Rsrc);
 9130     __ jccb(Assembler::carryClear, done);
 9131     __ blsmskl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9132     __ bind(done);
 9133   %}
 9134 
 9135   ins_pipe(ialu_reg);
 9136 %}
 9137 
 9138 instruct blsmskL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9139 %{
 9140   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ));
 9141   predicate(UseBMI1Instructions);
 9142   effect(KILL cr, TEMP dst);
 9143 
 9144   ins_cost(125);
 9145   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9146             &quot;BLSMSKL $dst.lo, $src\n\t&quot;
 9147             &quot;JNC     done\n\t&quot;
 9148             &quot;BLSMSKL $dst.hi, $src+4\n&quot;
 9149             &quot;done:&quot;
 9150          %}
 9151 
 9152   ins_encode %{
 9153     Label done;
 9154     Register Rdst = $dst$$Register;
 9155     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9156 
 9157     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9158     __ blsmskl(Rdst, $src$$Address);
 9159     __ jccb(Assembler::carryClear, done);
 9160     __ blsmskl(HIGH_FROM_LOW(Rdst), src_hi);
 9161     __ bind(done);
 9162   %}
 9163 
 9164   ins_pipe(ialu_reg_mem);
 9165 %}
 9166 
 9167 instruct blsrL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9168 %{
 9169   match(Set dst (AndL (AddL src minus_1) src) );
 9170   predicate(UseBMI1Instructions);
 9171   effect(KILL cr, TEMP dst);
 9172 
 9173   format %{ &quot;MOVL   $dst.hi, $src.hi\n\t&quot;
 9174             &quot;BLSRL  $dst.lo, $src.lo\n\t&quot;
 9175             &quot;JNC    done\n\t&quot;
 9176             &quot;BLSRL  $dst.hi, $src.hi\n&quot;
 9177             &quot;done:&quot;
 9178   %}
 9179 
 9180   ins_encode %{
 9181     Label done;
 9182     Register Rdst = $dst$$Register;
 9183     Register Rsrc = $src$$Register;
 9184     __ movl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9185     __ blsrl(Rdst, Rsrc);
 9186     __ jccb(Assembler::carryClear, done);
 9187     __ blsrl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9188     __ bind(done);
 9189   %}
 9190 
 9191   ins_pipe(ialu_reg);
 9192 %}
 9193 
 9194 instruct blsrL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9195 %{
 9196   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src) ));
 9197   predicate(UseBMI1Instructions);
 9198   effect(KILL cr, TEMP dst);
 9199 
 9200   ins_cost(125);
 9201   format %{ &quot;MOVL   $dst.hi, $src+4\n\t&quot;
 9202             &quot;BLSRL  $dst.lo, $src\n\t&quot;
 9203             &quot;JNC    done\n\t&quot;
 9204             &quot;BLSRL  $dst.hi, $src+4\n&quot;
 9205             &quot;done:&quot;
 9206   %}
 9207 
 9208   ins_encode %{
 9209     Label done;
 9210     Register Rdst = $dst$$Register;
 9211     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9212     __ movl(HIGH_FROM_LOW(Rdst), src_hi);
 9213     __ blsrl(Rdst, $src$$Address);
 9214     __ jccb(Assembler::carryClear, done);
 9215     __ blsrl(HIGH_FROM_LOW(Rdst), src_hi);
 9216     __ bind(done);
 9217   %}
 9218 
 9219   ins_pipe(ialu_reg_mem);
 9220 %}
 9221 
 9222 // Or Long Register with Register
 9223 instruct orl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9224   match(Set dst (OrL dst src));
 9225   effect(KILL cr);
 9226   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9227             &quot;OR     $dst.hi,$src.hi&quot; %}
 9228   opcode(0x0B,0x0B);
 9229   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9230   ins_pipe( ialu_reg_reg_long );
 9231 %}
 9232 
 9233 // Or Long Register with Immediate
 9234 instruct orl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9235   match(Set dst (OrL dst src));
 9236   effect(KILL cr);
 9237   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9238             &quot;OR     $dst.hi,$src.hi&quot; %}
 9239   opcode(0x81,0x01,0x01);  /* Opcode 81 /1, 81 /1 */
 9240   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9241   ins_pipe( ialu_reg_long );
 9242 %}
 9243 
 9244 // Or Long Register with Memory
 9245 instruct orl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9246   match(Set dst (OrL dst (LoadL mem)));
 9247   effect(KILL cr);
 9248   ins_cost(125);
 9249   format %{ &quot;OR     $dst.lo,$mem\n\t&quot;
 9250             &quot;OR     $dst.hi,$mem+4&quot; %}
 9251   opcode(0x0B,0x0B);
 9252   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9253   ins_pipe( ialu_reg_long_mem );
 9254 %}
 9255 
 9256 // Xor Long Register with Register
 9257 instruct xorl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9258   match(Set dst (XorL dst src));
 9259   effect(KILL cr);
 9260   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9261             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9262   opcode(0x33,0x33);
 9263   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9264   ins_pipe( ialu_reg_reg_long );
 9265 %}
 9266 
 9267 // Xor Long Register with Immediate -1
 9268 instruct xorl_eReg_im1(eRegL dst, immL_M1 imm) %{
 9269   match(Set dst (XorL dst imm));
 9270   format %{ &quot;NOT    $dst.lo\n\t&quot;
 9271             &quot;NOT    $dst.hi&quot; %}
 9272   ins_encode %{
 9273      __ notl($dst$$Register);
 9274      __ notl(HIGH_FROM_LOW($dst$$Register));
 9275   %}
 9276   ins_pipe( ialu_reg_long );
 9277 %}
 9278 
 9279 // Xor Long Register with Immediate
 9280 instruct xorl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9281   match(Set dst (XorL dst src));
 9282   effect(KILL cr);
 9283   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9284             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9285   opcode(0x81,0x06,0x06);  /* Opcode 81 /6, 81 /6 */
 9286   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9287   ins_pipe( ialu_reg_long );
 9288 %}
 9289 
 9290 // Xor Long Register with Memory
 9291 instruct xorl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9292   match(Set dst (XorL dst (LoadL mem)));
 9293   effect(KILL cr);
 9294   ins_cost(125);
 9295   format %{ &quot;XOR    $dst.lo,$mem\n\t&quot;
 9296             &quot;XOR    $dst.hi,$mem+4&quot; %}
 9297   opcode(0x33,0x33);
 9298   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9299   ins_pipe( ialu_reg_long_mem );
 9300 %}
 9301 
 9302 // Shift Left Long by 1
 9303 instruct shlL_eReg_1(eRegL dst, immI_1 cnt, eFlagsReg cr) %{
 9304   predicate(UseNewLongLShift);
 9305   match(Set dst (LShiftL dst cnt));
 9306   effect(KILL cr);
 9307   ins_cost(100);
 9308   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9309             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9310   ins_encode %{
 9311     __ addl($dst$$Register,$dst$$Register);
 9312     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9313   %}
 9314   ins_pipe( ialu_reg_long );
 9315 %}
 9316 
 9317 // Shift Left Long by 2
 9318 instruct shlL_eReg_2(eRegL dst, immI_2 cnt, eFlagsReg cr) %{
 9319   predicate(UseNewLongLShift);
 9320   match(Set dst (LShiftL dst cnt));
 9321   effect(KILL cr);
 9322   ins_cost(100);
 9323   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9324             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9325             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9326             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9327   ins_encode %{
 9328     __ addl($dst$$Register,$dst$$Register);
 9329     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9330     __ addl($dst$$Register,$dst$$Register);
 9331     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9332   %}
 9333   ins_pipe( ialu_reg_long );
 9334 %}
 9335 
 9336 // Shift Left Long by 3
 9337 instruct shlL_eReg_3(eRegL dst, immI_3 cnt, eFlagsReg cr) %{
 9338   predicate(UseNewLongLShift);
 9339   match(Set dst (LShiftL dst cnt));
 9340   effect(KILL cr);
 9341   ins_cost(100);
 9342   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9343             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9344             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9345             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9346             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9347             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9348   ins_encode %{
 9349     __ addl($dst$$Register,$dst$$Register);
 9350     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9351     __ addl($dst$$Register,$dst$$Register);
 9352     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9353     __ addl($dst$$Register,$dst$$Register);
 9354     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9355   %}
 9356   ins_pipe( ialu_reg_long );
 9357 %}
 9358 
 9359 // Shift Left Long by 1-31
 9360 instruct shlL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9361   match(Set dst (LShiftL dst cnt));
 9362   effect(KILL cr);
 9363   ins_cost(200);
 9364   format %{ &quot;SHLD   $dst.hi,$dst.lo,$cnt\n\t&quot;
 9365             &quot;SHL    $dst.lo,$cnt&quot; %}
 9366   opcode(0xC1, 0x4, 0xA4);  /* 0F/A4, then C1 /4 ib */
 9367   ins_encode( move_long_small_shift(dst,cnt) );
 9368   ins_pipe( ialu_reg_long );
 9369 %}
 9370 
 9371 // Shift Left Long by 32-63
 9372 instruct shlL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9373   match(Set dst (LShiftL dst cnt));
 9374   effect(KILL cr);
 9375   ins_cost(300);
 9376   format %{ &quot;MOV    $dst.hi,$dst.lo\n&quot;
 9377           &quot;\tSHL    $dst.hi,$cnt-32\n&quot;
 9378           &quot;\tXOR    $dst.lo,$dst.lo&quot; %}
 9379   opcode(0xC1, 0x4);  /* C1 /4 ib */
 9380   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9381   ins_pipe( ialu_reg_long );
 9382 %}
 9383 
 9384 // Shift Left Long by variable
 9385 instruct salL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9386   match(Set dst (LShiftL dst shift));
 9387   effect(KILL cr);
 9388   ins_cost(500+200);
 9389   size(17);
 9390   format %{ &quot;TEST   $shift,32\n\t&quot;
 9391             &quot;JEQ,s  small\n\t&quot;
 9392             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 9393             &quot;XOR    $dst.lo,$dst.lo\n&quot;
 9394     &quot;small:\tSHLD   $dst.hi,$dst.lo,$shift\n\t&quot;
 9395             &quot;SHL    $dst.lo,$shift&quot; %}
 9396   ins_encode( shift_left_long( dst, shift ) );
 9397   ins_pipe( pipe_slow );
 9398 %}
 9399 
 9400 // Shift Right Long by 1-31
 9401 instruct shrL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9402   match(Set dst (URShiftL dst cnt));
 9403   effect(KILL cr);
 9404   ins_cost(200);
 9405   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9406             &quot;SHR    $dst.hi,$cnt&quot; %}
 9407   opcode(0xC1, 0x5, 0xAC);  /* 0F/AC, then C1 /5 ib */
 9408   ins_encode( move_long_small_shift(dst,cnt) );
 9409   ins_pipe( ialu_reg_long );
 9410 %}
 9411 
 9412 // Shift Right Long by 32-63
 9413 instruct shrL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9414   match(Set dst (URShiftL dst cnt));
 9415   effect(KILL cr);
 9416   ins_cost(300);
 9417   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9418           &quot;\tSHR    $dst.lo,$cnt-32\n&quot;
 9419           &quot;\tXOR    $dst.hi,$dst.hi&quot; %}
 9420   opcode(0xC1, 0x5);  /* C1 /5 ib */
 9421   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9422   ins_pipe( ialu_reg_long );
 9423 %}
 9424 
 9425 // Shift Right Long by variable
 9426 instruct shrL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9427   match(Set dst (URShiftL dst shift));
 9428   effect(KILL cr);
 9429   ins_cost(600);
 9430   size(17);
 9431   format %{ &quot;TEST   $shift,32\n\t&quot;
 9432             &quot;JEQ,s  small\n\t&quot;
 9433             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9434             &quot;XOR    $dst.hi,$dst.hi\n&quot;
 9435     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9436             &quot;SHR    $dst.hi,$shift&quot; %}
 9437   ins_encode( shift_right_long( dst, shift ) );
 9438   ins_pipe( pipe_slow );
 9439 %}
 9440 
 9441 // Shift Right Long by 1-31
 9442 instruct sarL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9443   match(Set dst (RShiftL dst cnt));
 9444   effect(KILL cr);
 9445   ins_cost(200);
 9446   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9447             &quot;SAR    $dst.hi,$cnt&quot; %}
 9448   opcode(0xC1, 0x7, 0xAC);  /* 0F/AC, then C1 /7 ib */
 9449   ins_encode( move_long_small_shift(dst,cnt) );
 9450   ins_pipe( ialu_reg_long );
 9451 %}
 9452 
 9453 // Shift Right Long by 32-63
 9454 instruct sarL_eReg_32_63( eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9455   match(Set dst (RShiftL dst cnt));
 9456   effect(KILL cr);
 9457   ins_cost(300);
 9458   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9459           &quot;\tSAR    $dst.lo,$cnt-32\n&quot;
 9460           &quot;\tSAR    $dst.hi,31&quot; %}
 9461   opcode(0xC1, 0x7);  /* C1 /7 ib */
 9462   ins_encode( move_long_big_shift_sign(dst,cnt) );
 9463   ins_pipe( ialu_reg_long );
 9464 %}
 9465 
 9466 // Shift Right arithmetic Long by variable
 9467 instruct sarL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9468   match(Set dst (RShiftL dst shift));
 9469   effect(KILL cr);
 9470   ins_cost(600);
 9471   size(18);
 9472   format %{ &quot;TEST   $shift,32\n\t&quot;
 9473             &quot;JEQ,s  small\n\t&quot;
 9474             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9475             &quot;SAR    $dst.hi,31\n&quot;
 9476     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9477             &quot;SAR    $dst.hi,$shift&quot; %}
 9478   ins_encode( shift_right_arith_long( dst, shift ) );
 9479   ins_pipe( pipe_slow );
 9480 %}
 9481 
 9482 
 9483 //----------Double Instructions------------------------------------------------
 9484 // Double Math
 9485 
 9486 // Compare &amp; branch
 9487 
 9488 // P6 version of float compare, sets condition codes in EFLAGS
 9489 instruct cmpDPR_cc_P6(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9490   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9491   match(Set cr (CmpD src1 src2));
 9492   effect(KILL rax);
 9493   ins_cost(150);
 9494   format %{ &quot;FLD    $src1\n\t&quot;
 9495             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
 9496             &quot;JNP    exit\n\t&quot;
 9497             &quot;MOV    ah,1       // saw a NaN, set CF\n\t&quot;
 9498             &quot;SAHF\n&quot;
 9499      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
 9500   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9501   ins_encode( Push_Reg_DPR(src1),
 9502               OpcP, RegOpc(src2),
 9503               cmpF_P6_fixup );
 9504   ins_pipe( pipe_slow );
 9505 %}
 9506 
 9507 instruct cmpDPR_cc_P6CF(eFlagsRegUCF cr, regDPR src1, regDPR src2) %{
 9508   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9509   match(Set cr (CmpD src1 src2));
 9510   ins_cost(150);
 9511   format %{ &quot;FLD    $src1\n\t&quot;
 9512             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
 9513   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9514   ins_encode( Push_Reg_DPR(src1),
 9515               OpcP, RegOpc(src2));
 9516   ins_pipe( pipe_slow );
 9517 %}
 9518 
 9519 // Compare &amp; branch
 9520 instruct cmpDPR_cc(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9521   predicate(UseSSE&lt;=1);
 9522   match(Set cr (CmpD src1 src2));
 9523   effect(KILL rax);
 9524   ins_cost(200);
 9525   format %{ &quot;FLD    $src1\n\t&quot;
 9526             &quot;FCOMp  $src2\n\t&quot;
 9527             &quot;FNSTSW AX\n\t&quot;
 9528             &quot;TEST   AX,0x400\n\t&quot;
 9529             &quot;JZ,s   flags\n\t&quot;
 9530             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
 9531     &quot;flags:\tSAHF&quot; %}
 9532   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9533   ins_encode( Push_Reg_DPR(src1),
 9534               OpcP, RegOpc(src2),
 9535               fpu_flags);
 9536   ins_pipe( pipe_slow );
 9537 %}
 9538 
 9539 // Compare vs zero into -1,0,1
 9540 instruct cmpDPR_0(rRegI dst, regDPR src1, immDPR0 zero, eAXRegI rax, eFlagsReg cr) %{
 9541   predicate(UseSSE&lt;=1);
 9542   match(Set dst (CmpD3 src1 zero));
 9543   effect(KILL cr, KILL rax);
 9544   ins_cost(280);
 9545   format %{ &quot;FTSTD  $dst,$src1&quot; %}
 9546   opcode(0xE4, 0xD9);
 9547   ins_encode( Push_Reg_DPR(src1),
 9548               OpcS, OpcP, PopFPU,
 9549               CmpF_Result(dst));
 9550   ins_pipe( pipe_slow );
 9551 %}
 9552 
 9553 // Compare into -1,0,1
 9554 instruct cmpDPR_reg(rRegI dst, regDPR src1, regDPR src2, eAXRegI rax, eFlagsReg cr) %{
 9555   predicate(UseSSE&lt;=1);
 9556   match(Set dst (CmpD3 src1 src2));
 9557   effect(KILL cr, KILL rax);
 9558   ins_cost(300);
 9559   format %{ &quot;FCMPD  $dst,$src1,$src2&quot; %}
 9560   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9561   ins_encode( Push_Reg_DPR(src1),
 9562               OpcP, RegOpc(src2),
 9563               CmpF_Result(dst));
 9564   ins_pipe( pipe_slow );
 9565 %}
 9566 
 9567 // float compare and set condition codes in EFLAGS by XMM regs
 9568 instruct cmpD_cc(eFlagsRegU cr, regD src1, regD src2) %{
 9569   predicate(UseSSE&gt;=2);
 9570   match(Set cr (CmpD src1 src2));
 9571   ins_cost(145);
 9572   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9573             &quot;JNP,s   exit\n\t&quot;
 9574             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9575             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9576             &quot;POPF\n&quot;
 9577     &quot;exit:&quot; %}
 9578   ins_encode %{
 9579     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9580     emit_cmpfp_fixup(_masm);
 9581   %}
 9582   ins_pipe( pipe_slow );
 9583 %}
 9584 
 9585 instruct cmpD_ccCF(eFlagsRegUCF cr, regD src1, regD src2) %{
 9586   predicate(UseSSE&gt;=2);
 9587   match(Set cr (CmpD src1 src2));
 9588   ins_cost(100);
 9589   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9590   ins_encode %{
 9591     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9592   %}
 9593   ins_pipe( pipe_slow );
 9594 %}
 9595 
 9596 // float compare and set condition codes in EFLAGS by XMM regs
 9597 instruct cmpD_ccmem(eFlagsRegU cr, regD src1, memory src2) %{
 9598   predicate(UseSSE&gt;=2);
 9599   match(Set cr (CmpD src1 (LoadD src2)));
 9600   ins_cost(145);
 9601   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9602             &quot;JNP,s   exit\n\t&quot;
 9603             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9604             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9605             &quot;POPF\n&quot;
 9606     &quot;exit:&quot; %}
 9607   ins_encode %{
 9608     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9609     emit_cmpfp_fixup(_masm);
 9610   %}
 9611   ins_pipe( pipe_slow );
 9612 %}
 9613 
 9614 instruct cmpD_ccmemCF(eFlagsRegUCF cr, regD src1, memory src2) %{
 9615   predicate(UseSSE&gt;=2);
 9616   match(Set cr (CmpD src1 (LoadD src2)));
 9617   ins_cost(100);
 9618   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9619   ins_encode %{
 9620     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9621   %}
 9622   ins_pipe( pipe_slow );
 9623 %}
 9624 
 9625 // Compare into -1,0,1 in XMM
 9626 instruct cmpD_reg(xRegI dst, regD src1, regD src2, eFlagsReg cr) %{
 9627   predicate(UseSSE&gt;=2);
 9628   match(Set dst (CmpD3 src1 src2));
 9629   effect(KILL cr);
 9630   ins_cost(255);
 9631   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9632             &quot;MOV     $dst, #-1\n\t&quot;
 9633             &quot;JP,s    done\n\t&quot;
 9634             &quot;JB,s    done\n\t&quot;
 9635             &quot;SETNE   $dst\n\t&quot;
 9636             &quot;MOVZB   $dst, $dst\n&quot;
 9637     &quot;done:&quot; %}
 9638   ins_encode %{
 9639     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9640     emit_cmpfp3(_masm, $dst$$Register);
 9641   %}
 9642   ins_pipe( pipe_slow );
 9643 %}
 9644 
 9645 // Compare into -1,0,1 in XMM and memory
 9646 instruct cmpD_regmem(xRegI dst, regD src1, memory src2, eFlagsReg cr) %{
 9647   predicate(UseSSE&gt;=2);
 9648   match(Set dst (CmpD3 src1 (LoadD src2)));
 9649   effect(KILL cr);
 9650   ins_cost(275);
 9651   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9652             &quot;MOV     $dst, #-1\n\t&quot;
 9653             &quot;JP,s    done\n\t&quot;
 9654             &quot;JB,s    done\n\t&quot;
 9655             &quot;SETNE   $dst\n\t&quot;
 9656             &quot;MOVZB   $dst, $dst\n&quot;
 9657     &quot;done:&quot; %}
 9658   ins_encode %{
 9659     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9660     emit_cmpfp3(_masm, $dst$$Register);
 9661   %}
 9662   ins_pipe( pipe_slow );
 9663 %}
 9664 
 9665 
 9666 instruct subDPR_reg(regDPR dst, regDPR src) %{
 9667   predicate (UseSSE &lt;=1);
 9668   match(Set dst (SubD dst src));
 9669 
 9670   format %{ &quot;FLD    $src\n\t&quot;
 9671             &quot;DSUBp  $dst,ST&quot; %}
 9672   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
 9673   ins_cost(150);
 9674   ins_encode( Push_Reg_DPR(src),
 9675               OpcP, RegOpc(dst) );
 9676   ins_pipe( fpu_reg_reg );
 9677 %}
 9678 
 9679 instruct subDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9680   predicate (UseSSE &lt;=1);
 9681   match(Set dst (RoundDouble (SubD src1 src2)));
 9682   ins_cost(250);
 9683 
 9684   format %{ &quot;FLD    $src2\n\t&quot;
 9685             &quot;DSUB   ST,$src1\n\t&quot;
 9686             &quot;FSTP_D $dst\t# D-round&quot; %}
 9687   opcode(0xD8, 0x5);
 9688   ins_encode( Push_Reg_DPR(src2),
 9689               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9690   ins_pipe( fpu_mem_reg_reg );
 9691 %}
 9692 
 9693 
 9694 instruct subDPR_reg_mem(regDPR dst, memory src) %{
 9695   predicate (UseSSE &lt;=1);
 9696   match(Set dst (SubD dst (LoadD src)));
 9697   ins_cost(150);
 9698 
 9699   format %{ &quot;FLD    $src\n\t&quot;
 9700             &quot;DSUBp  $dst,ST&quot; %}
 9701   opcode(0xDE, 0x5, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9702   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9703               OpcP, RegOpc(dst) );
 9704   ins_pipe( fpu_reg_mem );
 9705 %}
 9706 
 9707 instruct absDPR_reg(regDPR1 dst, regDPR1 src) %{
 9708   predicate (UseSSE&lt;=1);
 9709   match(Set dst (AbsD src));
 9710   ins_cost(100);
 9711   format %{ &quot;FABS&quot; %}
 9712   opcode(0xE1, 0xD9);
 9713   ins_encode( OpcS, OpcP );
 9714   ins_pipe( fpu_reg_reg );
 9715 %}
 9716 
 9717 instruct negDPR_reg(regDPR1 dst, regDPR1 src) %{
 9718   predicate(UseSSE&lt;=1);
 9719   match(Set dst (NegD src));
 9720   ins_cost(100);
 9721   format %{ &quot;FCHS&quot; %}
 9722   opcode(0xE0, 0xD9);
 9723   ins_encode( OpcS, OpcP );
 9724   ins_pipe( fpu_reg_reg );
 9725 %}
 9726 
 9727 instruct addDPR_reg(regDPR dst, regDPR src) %{
 9728   predicate(UseSSE&lt;=1);
 9729   match(Set dst (AddD dst src));
 9730   format %{ &quot;FLD    $src\n\t&quot;
 9731             &quot;DADD   $dst,ST&quot; %}
 9732   size(4);
 9733   ins_cost(150);
 9734   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
 9735   ins_encode( Push_Reg_DPR(src),
 9736               OpcP, RegOpc(dst) );
 9737   ins_pipe( fpu_reg_reg );
 9738 %}
 9739 
 9740 
 9741 instruct addDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9742   predicate(UseSSE&lt;=1);
 9743   match(Set dst (RoundDouble (AddD src1 src2)));
 9744   ins_cost(250);
 9745 
 9746   format %{ &quot;FLD    $src2\n\t&quot;
 9747             &quot;DADD   ST,$src1\n\t&quot;
 9748             &quot;FSTP_D $dst\t# D-round&quot; %}
 9749   opcode(0xD8, 0x0); /* D8 C0+i or D8 /0*/
 9750   ins_encode( Push_Reg_DPR(src2),
 9751               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9752   ins_pipe( fpu_mem_reg_reg );
 9753 %}
 9754 
 9755 
 9756 instruct addDPR_reg_mem(regDPR dst, memory src) %{
 9757   predicate(UseSSE&lt;=1);
 9758   match(Set dst (AddD dst (LoadD src)));
 9759   ins_cost(150);
 9760 
 9761   format %{ &quot;FLD    $src\n\t&quot;
 9762             &quot;DADDp  $dst,ST&quot; %}
 9763   opcode(0xDE, 0x0, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9764   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9765               OpcP, RegOpc(dst) );
 9766   ins_pipe( fpu_reg_mem );
 9767 %}
 9768 
 9769 // add-to-memory
 9770 instruct addDPR_mem_reg(memory dst, regDPR src) %{
 9771   predicate(UseSSE&lt;=1);
 9772   match(Set dst (StoreD dst (RoundDouble (AddD (LoadD dst) src))));
 9773   ins_cost(150);
 9774 
 9775   format %{ &quot;FLD_D  $dst\n\t&quot;
 9776             &quot;DADD   ST,$src\n\t&quot;
 9777             &quot;FST_D  $dst&quot; %}
 9778   opcode(0xDD, 0x0);
 9779   ins_encode( Opcode(0xDD), RMopc_Mem(0x00,dst),
 9780               Opcode(0xD8), RegOpc(src),
 9781               set_instruction_start,
 9782               Opcode(0xDD), RMopc_Mem(0x03,dst) );
 9783   ins_pipe( fpu_reg_mem );
 9784 %}
 9785 
 9786 instruct addDPR_reg_imm1(regDPR dst, immDPR1 con) %{
 9787   predicate(UseSSE&lt;=1);
 9788   match(Set dst (AddD dst con));
 9789   ins_cost(125);
 9790   format %{ &quot;FLD1\n\t&quot;
 9791             &quot;DADDp  $dst,ST&quot; %}
 9792   ins_encode %{
 9793     __ fld1();
 9794     __ faddp($dst$$reg);
 9795   %}
 9796   ins_pipe(fpu_reg);
 9797 %}
 9798 
 9799 instruct addDPR_reg_imm(regDPR dst, immDPR con) %{
 9800   predicate(UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9801   match(Set dst (AddD dst con));
 9802   ins_cost(200);
 9803   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9804             &quot;DADDp  $dst,ST&quot; %}
 9805   ins_encode %{
 9806     __ fld_d($constantaddress($con));
 9807     __ faddp($dst$$reg);
 9808   %}
 9809   ins_pipe(fpu_reg_mem);
 9810 %}
 9811 
 9812 instruct addDPR_reg_imm_round(stackSlotD dst, regDPR src, immDPR con) %{
 9813   predicate(UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9814   match(Set dst (RoundDouble (AddD src con)));
 9815   ins_cost(200);
 9816   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9817             &quot;DADD   ST,$src\n\t&quot;
 9818             &quot;FSTP_D $dst\t# D-round&quot; %}
 9819   ins_encode %{
 9820     __ fld_d($constantaddress($con));
 9821     __ fadd($src$$reg);
 9822     __ fstp_d(Address(rsp, $dst$$disp));
 9823   %}
 9824   ins_pipe(fpu_mem_reg_con);
 9825 %}
 9826 
 9827 instruct mulDPR_reg(regDPR dst, regDPR src) %{
 9828   predicate(UseSSE&lt;=1);
 9829   match(Set dst (MulD dst src));
 9830   format %{ &quot;FLD    $src\n\t&quot;
 9831             &quot;DMULp  $dst,ST&quot; %}
 9832   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9833   ins_cost(150);
 9834   ins_encode( Push_Reg_DPR(src),
 9835               OpcP, RegOpc(dst) );
 9836   ins_pipe( fpu_reg_reg );
 9837 %}
 9838 
 9839 // Strict FP instruction biases argument before multiply then
 9840 // biases result to avoid double rounding of subnormals.
 9841 //
 9842 // scale arg1 by multiplying arg1 by 2^(-15360)
 9843 // load arg2
 9844 // multiply scaled arg1 by arg2
 9845 // rescale product by 2^(15360)
 9846 //
 9847 instruct strictfp_mulDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9848   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9849   match(Set dst (MulD dst src));
 9850   ins_cost(1);   // Select this instruction for all strict FP double multiplies
 9851 
 9852   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9853             &quot;DMULp  $dst,ST\n\t&quot;
 9854             &quot;FLD    $src\n\t&quot;
 9855             &quot;DMULp  $dst,ST\n\t&quot;
 9856             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9857             &quot;DMULp  $dst,ST\n\t&quot; %}
 9858   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9859   ins_encode( strictfp_bias1(dst),
 9860               Push_Reg_DPR(src),
 9861               OpcP, RegOpc(dst),
 9862               strictfp_bias2(dst) );
 9863   ins_pipe( fpu_reg_reg );
 9864 %}
 9865 
 9866 instruct mulDPR_reg_imm(regDPR dst, immDPR con) %{
 9867   predicate( UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9868   match(Set dst (MulD dst con));
 9869   ins_cost(200);
 9870   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9871             &quot;DMULp  $dst,ST&quot; %}
 9872   ins_encode %{
 9873     __ fld_d($constantaddress($con));
 9874     __ fmulp($dst$$reg);
 9875   %}
 9876   ins_pipe(fpu_reg_mem);
 9877 %}
 9878 
 9879 
 9880 instruct mulDPR_reg_mem(regDPR dst, memory src) %{
 9881   predicate( UseSSE&lt;=1 );
 9882   match(Set dst (MulD dst (LoadD src)));
 9883   ins_cost(200);
 9884   format %{ &quot;FLD_D  $src\n\t&quot;
 9885             &quot;DMULp  $dst,ST&quot; %}
 9886   opcode(0xDE, 0x1, 0xDD); /* DE C8+i or DE /1*/  /* LoadD  DD /0 */
 9887   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9888               OpcP, RegOpc(dst) );
 9889   ins_pipe( fpu_reg_mem );
 9890 %}
 9891 
 9892 //
 9893 // Cisc-alternate to reg-reg multiply
 9894 instruct mulDPR_reg_mem_cisc(regDPR dst, regDPR src, memory mem) %{
 9895   predicate( UseSSE&lt;=1 );
 9896   match(Set dst (MulD src (LoadD mem)));
 9897   ins_cost(250);
 9898   format %{ &quot;FLD_D  $mem\n\t&quot;
 9899             &quot;DMUL   ST,$src\n\t&quot;
 9900             &quot;FSTP_D $dst&quot; %}
 9901   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadD D9 /0 */
 9902   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem),
 9903               OpcReg_FPR(src),
 9904               Pop_Reg_DPR(dst) );
 9905   ins_pipe( fpu_reg_reg_mem );
 9906 %}
 9907 
 9908 
 9909 // MACRO3 -- addDPR a mulDPR
 9910 // This instruction is a &#39;2-address&#39; instruction in that the result goes
 9911 // back to src2.  This eliminates a move from the macro; possibly the
 9912 // register allocator will have to add it back (and maybe not).
 9913 instruct addDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9914   predicate( UseSSE&lt;=1 );
 9915   match(Set src2 (AddD (MulD src0 src1) src2));
 9916   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9917             &quot;DMUL   ST,$src1\n\t&quot;
 9918             &quot;DADDp  $src2,ST&quot; %}
 9919   ins_cost(250);
 9920   opcode(0xDD); /* LoadD DD /0 */
 9921   ins_encode( Push_Reg_FPR(src0),
 9922               FMul_ST_reg(src1),
 9923               FAddP_reg_ST(src2) );
 9924   ins_pipe( fpu_reg_reg_reg );
 9925 %}
 9926 
 9927 
 9928 // MACRO3 -- subDPR a mulDPR
 9929 instruct subDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9930   predicate( UseSSE&lt;=1 );
 9931   match(Set src2 (SubD (MulD src0 src1) src2));
 9932   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9933             &quot;DMUL   ST,$src1\n\t&quot;
 9934             &quot;DSUBRp $src2,ST&quot; %}
 9935   ins_cost(250);
 9936   ins_encode( Push_Reg_FPR(src0),
 9937               FMul_ST_reg(src1),
 9938               Opcode(0xDE), Opc_plus(0xE0,src2));
 9939   ins_pipe( fpu_reg_reg_reg );
 9940 %}
 9941 
 9942 
 9943 instruct divDPR_reg(regDPR dst, regDPR src) %{
 9944   predicate( UseSSE&lt;=1 );
 9945   match(Set dst (DivD dst src));
 9946 
 9947   format %{ &quot;FLD    $src\n\t&quot;
 9948             &quot;FDIVp  $dst,ST&quot; %}
 9949   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9950   ins_cost(150);
 9951   ins_encode( Push_Reg_DPR(src),
 9952               OpcP, RegOpc(dst) );
 9953   ins_pipe( fpu_reg_reg );
 9954 %}
 9955 
 9956 // Strict FP instruction biases argument before division then
 9957 // biases result, to avoid double rounding of subnormals.
 9958 //
 9959 // scale dividend by multiplying dividend by 2^(-15360)
 9960 // load divisor
 9961 // divide scaled dividend by divisor
 9962 // rescale quotient by 2^(15360)
 9963 //
 9964 instruct strictfp_divDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9965   predicate (UseSSE&lt;=1);
 9966   match(Set dst (DivD dst src));
 9967   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9968   ins_cost(01);
 9969 
 9970   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9971             &quot;DMULp  $dst,ST\n\t&quot;
 9972             &quot;FLD    $src\n\t&quot;
 9973             &quot;FDIVp  $dst,ST\n\t&quot;
 9974             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9975             &quot;DMULp  $dst,ST\n\t&quot; %}
 9976   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9977   ins_encode( strictfp_bias1(dst),
 9978               Push_Reg_DPR(src),
 9979               OpcP, RegOpc(dst),
 9980               strictfp_bias2(dst) );
 9981   ins_pipe( fpu_reg_reg );
 9982 %}
 9983 
 9984 instruct divDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9985   predicate( UseSSE&lt;=1 &amp;&amp; !(Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict()) );
 9986   match(Set dst (RoundDouble (DivD src1 src2)));
 9987 
 9988   format %{ &quot;FLD    $src1\n\t&quot;
 9989             &quot;FDIV   ST,$src2\n\t&quot;
 9990             &quot;FSTP_D $dst\t# D-round&quot; %}
 9991   opcode(0xD8, 0x6); /* D8 F0+i or D8 /6 */
 9992   ins_encode( Push_Reg_DPR(src1),
 9993               OpcP, RegOpc(src2), Pop_Mem_DPR(dst) );
 9994   ins_pipe( fpu_mem_reg_reg );
 9995 %}
 9996 
 9997 
 9998 instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{
 9999   predicate(UseSSE&lt;=1);
10000   match(Set dst (ModD dst src));
10001   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10002 
10003   format %{ &quot;DMOD   $dst,$src&quot; %}
10004   ins_cost(250);
10005   ins_encode(Push_Reg_Mod_DPR(dst, src),
10006               emitModDPR(),
10007               Push_Result_Mod_DPR(src),
10008               Pop_Reg_DPR(dst));
10009   ins_pipe( pipe_slow );
10010 %}
10011 
10012 instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{
10013   predicate(UseSSE&gt;=2);
10014   match(Set dst (ModD src0 src1));
10015   effect(KILL rax, KILL cr);
10016 
10017   format %{ &quot;SUB    ESP,8\t # DMOD\n&quot;
10018           &quot;\tMOVSD  [ESP+0],$src1\n&quot;
10019           &quot;\tFLD_D  [ESP+0]\n&quot;
10020           &quot;\tMOVSD  [ESP+0],$src0\n&quot;
10021           &quot;\tFLD_D  [ESP+0]\n&quot;
10022      &quot;loop:\tFPREM\n&quot;
10023           &quot;\tFWAIT\n&quot;
10024           &quot;\tFNSTSW AX\n&quot;
10025           &quot;\tSAHF\n&quot;
10026           &quot;\tJP     loop\n&quot;
10027           &quot;\tFSTP_D [ESP+0]\n&quot;
10028           &quot;\tMOVSD  $dst,[ESP+0]\n&quot;
10029           &quot;\tADD    ESP,8\n&quot;
10030           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10031     %}
10032   ins_cost(250);
10033   ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);
10034   ins_pipe( pipe_slow );
10035 %}
10036 
10037 instruct atanDPR_reg(regDPR dst, regDPR src) %{
10038   predicate (UseSSE&lt;=1);
10039   match(Set dst(AtanD dst src));
10040   format %{ &quot;DATA   $dst,$src&quot; %}
10041   opcode(0xD9, 0xF3);
10042   ins_encode( Push_Reg_DPR(src),
10043               OpcP, OpcS, RegOpc(dst) );
10044   ins_pipe( pipe_slow );
10045 %}
10046 
10047 instruct atanD_reg(regD dst, regD src, eFlagsReg cr) %{
10048   predicate (UseSSE&gt;=2);
10049   match(Set dst(AtanD dst src));
10050   effect(KILL cr); // Push_{Src|Result}D() uses &quot;{SUB|ADD} ESP,8&quot;
10051   format %{ &quot;DATA   $dst,$src&quot; %}
10052   opcode(0xD9, 0xF3);
10053   ins_encode( Push_SrcD(src),
10054               OpcP, OpcS, Push_ResultD(dst) );
10055   ins_pipe( pipe_slow );
10056 %}
10057 
10058 instruct sqrtDPR_reg(regDPR dst, regDPR src) %{
10059   predicate (UseSSE&lt;=1);
10060   match(Set dst (SqrtD src));
10061   format %{ &quot;DSQRT  $dst,$src&quot; %}
10062   opcode(0xFA, 0xD9);
10063   ins_encode( Push_Reg_DPR(src),
10064               OpcS, OpcP, Pop_Reg_DPR(dst) );
10065   ins_pipe( pipe_slow );
10066 %}
10067 
10068 //-------------Float Instructions-------------------------------
10069 // Float Math
10070 
10071 // Code for float compare:
10072 //     fcompp();
10073 //     fwait(); fnstsw_ax();
10074 //     sahf();
10075 //     movl(dst, unordered_result);
10076 //     jcc(Assembler::parity, exit);
10077 //     movl(dst, less_result);
10078 //     jcc(Assembler::below, exit);
10079 //     movl(dst, equal_result);
10080 //     jcc(Assembler::equal, exit);
10081 //     movl(dst, greater_result);
10082 //   exit:
10083 
10084 // P6 version of float compare, sets condition codes in EFLAGS
10085 instruct cmpFPR_cc_P6(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10086   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10087   match(Set cr (CmpF src1 src2));
10088   effect(KILL rax);
10089   ins_cost(150);
10090   format %{ &quot;FLD    $src1\n\t&quot;
10091             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
10092             &quot;JNP    exit\n\t&quot;
10093             &quot;MOV    ah,1       // saw a NaN, set CF (treat as LT)\n\t&quot;
10094             &quot;SAHF\n&quot;
10095      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
10096   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10097   ins_encode( Push_Reg_DPR(src1),
10098               OpcP, RegOpc(src2),
10099               cmpF_P6_fixup );
10100   ins_pipe( pipe_slow );
10101 %}
10102 
10103 instruct cmpFPR_cc_P6CF(eFlagsRegUCF cr, regFPR src1, regFPR src2) %{
10104   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10105   match(Set cr (CmpF src1 src2));
10106   ins_cost(100);
10107   format %{ &quot;FLD    $src1\n\t&quot;
10108             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
10109   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10110   ins_encode( Push_Reg_DPR(src1),
10111               OpcP, RegOpc(src2));
10112   ins_pipe( pipe_slow );
10113 %}
10114 
10115 
10116 // Compare &amp; branch
10117 instruct cmpFPR_cc(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10118   predicate(UseSSE == 0);
10119   match(Set cr (CmpF src1 src2));
10120   effect(KILL rax);
10121   ins_cost(200);
10122   format %{ &quot;FLD    $src1\n\t&quot;
10123             &quot;FCOMp  $src2\n\t&quot;
10124             &quot;FNSTSW AX\n\t&quot;
10125             &quot;TEST   AX,0x400\n\t&quot;
10126             &quot;JZ,s   flags\n\t&quot;
10127             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
10128     &quot;flags:\tSAHF&quot; %}
10129   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10130   ins_encode( Push_Reg_DPR(src1),
10131               OpcP, RegOpc(src2),
10132               fpu_flags);
10133   ins_pipe( pipe_slow );
10134 %}
10135 
10136 // Compare vs zero into -1,0,1
10137 instruct cmpFPR_0(rRegI dst, regFPR src1, immFPR0 zero, eAXRegI rax, eFlagsReg cr) %{
10138   predicate(UseSSE == 0);
10139   match(Set dst (CmpF3 src1 zero));
10140   effect(KILL cr, KILL rax);
10141   ins_cost(280);
10142   format %{ &quot;FTSTF  $dst,$src1&quot; %}
10143   opcode(0xE4, 0xD9);
10144   ins_encode( Push_Reg_DPR(src1),
10145               OpcS, OpcP, PopFPU,
10146               CmpF_Result(dst));
10147   ins_pipe( pipe_slow );
10148 %}
10149 
10150 // Compare into -1,0,1
10151 instruct cmpFPR_reg(rRegI dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10152   predicate(UseSSE == 0);
10153   match(Set dst (CmpF3 src1 src2));
10154   effect(KILL cr, KILL rax);
10155   ins_cost(300);
10156   format %{ &quot;FCMPF  $dst,$src1,$src2&quot; %}
10157   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10158   ins_encode( Push_Reg_DPR(src1),
10159               OpcP, RegOpc(src2),
10160               CmpF_Result(dst));
10161   ins_pipe( pipe_slow );
10162 %}
10163 
10164 // float compare and set condition codes in EFLAGS by XMM regs
10165 instruct cmpF_cc(eFlagsRegU cr, regF src1, regF src2) %{
10166   predicate(UseSSE&gt;=1);
10167   match(Set cr (CmpF src1 src2));
10168   ins_cost(145);
10169   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10170             &quot;JNP,s   exit\n\t&quot;
10171             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10172             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10173             &quot;POPF\n&quot;
10174     &quot;exit:&quot; %}
10175   ins_encode %{
10176     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10177     emit_cmpfp_fixup(_masm);
10178   %}
10179   ins_pipe( pipe_slow );
10180 %}
10181 
10182 instruct cmpF_ccCF(eFlagsRegUCF cr, regF src1, regF src2) %{
10183   predicate(UseSSE&gt;=1);
10184   match(Set cr (CmpF src1 src2));
10185   ins_cost(100);
10186   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10187   ins_encode %{
10188     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10189   %}
10190   ins_pipe( pipe_slow );
10191 %}
10192 
10193 // float compare and set condition codes in EFLAGS by XMM regs
10194 instruct cmpF_ccmem(eFlagsRegU cr, regF src1, memory src2) %{
10195   predicate(UseSSE&gt;=1);
10196   match(Set cr (CmpF src1 (LoadF src2)));
10197   ins_cost(165);
10198   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10199             &quot;JNP,s   exit\n\t&quot;
10200             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10201             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10202             &quot;POPF\n&quot;
10203     &quot;exit:&quot; %}
10204   ins_encode %{
10205     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10206     emit_cmpfp_fixup(_masm);
10207   %}
10208   ins_pipe( pipe_slow );
10209 %}
10210 
10211 instruct cmpF_ccmemCF(eFlagsRegUCF cr, regF src1, memory src2) %{
10212   predicate(UseSSE&gt;=1);
10213   match(Set cr (CmpF src1 (LoadF src2)));
10214   ins_cost(100);
10215   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10216   ins_encode %{
10217     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10218   %}
10219   ins_pipe( pipe_slow );
10220 %}
10221 
10222 // Compare into -1,0,1 in XMM
10223 instruct cmpF_reg(xRegI dst, regF src1, regF src2, eFlagsReg cr) %{
10224   predicate(UseSSE&gt;=1);
10225   match(Set dst (CmpF3 src1 src2));
10226   effect(KILL cr);
10227   ins_cost(255);
10228   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10229             &quot;MOV     $dst, #-1\n\t&quot;
10230             &quot;JP,s    done\n\t&quot;
10231             &quot;JB,s    done\n\t&quot;
10232             &quot;SETNE   $dst\n\t&quot;
10233             &quot;MOVZB   $dst, $dst\n&quot;
10234     &quot;done:&quot; %}
10235   ins_encode %{
10236     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10237     emit_cmpfp3(_masm, $dst$$Register);
10238   %}
10239   ins_pipe( pipe_slow );
10240 %}
10241 
10242 // Compare into -1,0,1 in XMM and memory
10243 instruct cmpF_regmem(xRegI dst, regF src1, memory src2, eFlagsReg cr) %{
10244   predicate(UseSSE&gt;=1);
10245   match(Set dst (CmpF3 src1 (LoadF src2)));
10246   effect(KILL cr);
10247   ins_cost(275);
10248   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10249             &quot;MOV     $dst, #-1\n\t&quot;
10250             &quot;JP,s    done\n\t&quot;
10251             &quot;JB,s    done\n\t&quot;
10252             &quot;SETNE   $dst\n\t&quot;
10253             &quot;MOVZB   $dst, $dst\n&quot;
10254     &quot;done:&quot; %}
10255   ins_encode %{
10256     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10257     emit_cmpfp3(_masm, $dst$$Register);
10258   %}
10259   ins_pipe( pipe_slow );
10260 %}
10261 
10262 // Spill to obtain 24-bit precision
10263 instruct subFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10264   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10265   match(Set dst (SubF src1 src2));
10266 
10267   format %{ &quot;FSUB   $dst,$src1 - $src2&quot; %}
10268   opcode(0xD8, 0x4); /* D8 E0+i or D8 /4 mod==0x3 ;; result in TOS */
10269   ins_encode( Push_Reg_FPR(src1),
10270               OpcReg_FPR(src2),
10271               Pop_Mem_FPR(dst) );
10272   ins_pipe( fpu_mem_reg_reg );
10273 %}
10274 //
10275 // This instruction does not round to 24-bits
10276 instruct subFPR_reg(regFPR dst, regFPR src) %{
10277   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10278   match(Set dst (SubF dst src));
10279 
10280   format %{ &quot;FSUB   $dst,$src&quot; %}
10281   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
10282   ins_encode( Push_Reg_FPR(src),
10283               OpcP, RegOpc(dst) );
10284   ins_pipe( fpu_reg_reg );
10285 %}
10286 
10287 // Spill to obtain 24-bit precision
10288 instruct addFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10289   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10290   match(Set dst (AddF src1 src2));
10291 
10292   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10293   opcode(0xD8, 0x0); /* D8 C0+i */
10294   ins_encode( Push_Reg_FPR(src2),
10295               OpcReg_FPR(src1),
10296               Pop_Mem_FPR(dst) );
10297   ins_pipe( fpu_mem_reg_reg );
10298 %}
10299 //
10300 // This instruction does not round to 24-bits
10301 instruct addFPR_reg(regFPR dst, regFPR src) %{
10302   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10303   match(Set dst (AddF dst src));
10304 
10305   format %{ &quot;FLD    $src\n\t&quot;
10306             &quot;FADDp  $dst,ST&quot; %}
10307   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
10308   ins_encode( Push_Reg_FPR(src),
10309               OpcP, RegOpc(dst) );
10310   ins_pipe( fpu_reg_reg );
10311 %}
10312 
10313 instruct absFPR_reg(regFPR1 dst, regFPR1 src) %{
10314   predicate(UseSSE==0);
10315   match(Set dst (AbsF src));
10316   ins_cost(100);
10317   format %{ &quot;FABS&quot; %}
10318   opcode(0xE1, 0xD9);
10319   ins_encode( OpcS, OpcP );
10320   ins_pipe( fpu_reg_reg );
10321 %}
10322 
10323 instruct negFPR_reg(regFPR1 dst, regFPR1 src) %{
10324   predicate(UseSSE==0);
10325   match(Set dst (NegF src));
10326   ins_cost(100);
10327   format %{ &quot;FCHS&quot; %}
10328   opcode(0xE0, 0xD9);
10329   ins_encode( OpcS, OpcP );
10330   ins_pipe( fpu_reg_reg );
10331 %}
10332 
10333 // Cisc-alternate to addFPR_reg
10334 // Spill to obtain 24-bit precision
10335 instruct addFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10336   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10337   match(Set dst (AddF src1 (LoadF src2)));
10338 
10339   format %{ &quot;FLD    $src2\n\t&quot;
10340             &quot;FADD   ST,$src1\n\t&quot;
10341             &quot;FSTP_S $dst&quot; %}
10342   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10343   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10344               OpcReg_FPR(src1),
10345               Pop_Mem_FPR(dst) );
10346   ins_pipe( fpu_mem_reg_mem );
10347 %}
10348 //
10349 // Cisc-alternate to addFPR_reg
10350 // This instruction does not round to 24-bits
10351 instruct addFPR_reg_mem(regFPR dst, memory src) %{
10352   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10353   match(Set dst (AddF dst (LoadF src)));
10354 
10355   format %{ &quot;FADD   $dst,$src&quot; %}
10356   opcode(0xDE, 0x0, 0xD9); /* DE C0+i or DE /0*/  /* LoadF  D9 /0 */
10357   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
10358               OpcP, RegOpc(dst) );
10359   ins_pipe( fpu_reg_mem );
10360 %}
10361 
10362 // // Following two instructions for _222_mpegaudio
10363 // Spill to obtain 24-bit precision
10364 instruct addFPR24_mem_reg(stackSlotF dst, regFPR src2, memory src1 ) %{
10365   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10366   match(Set dst (AddF src1 src2));
10367 
10368   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10369   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10370   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src1),
10371               OpcReg_FPR(src2),
10372               Pop_Mem_FPR(dst) );
10373   ins_pipe( fpu_mem_reg_mem );
10374 %}
10375 
10376 // Cisc-spill variant
10377 // Spill to obtain 24-bit precision
10378 instruct addFPR24_mem_cisc(stackSlotF dst, memory src1, memory src2) %{
10379   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10380   match(Set dst (AddF src1 (LoadF src2)));
10381 
10382   format %{ &quot;FADD   $dst,$src1,$src2 cisc&quot; %}
10383   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10384   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10385               set_instruction_start,
10386               OpcP, RMopc_Mem(secondary,src1),
10387               Pop_Mem_FPR(dst) );
10388   ins_pipe( fpu_mem_mem_mem );
10389 %}
10390 
10391 // Spill to obtain 24-bit precision
10392 instruct addFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10393   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10394   match(Set dst (AddF src1 src2));
10395 
10396   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10397   opcode(0xD8, 0x0, 0xD9); /* D8 /0 */  /* LoadF  D9 /0 */
10398   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10399               set_instruction_start,
10400               OpcP, RMopc_Mem(secondary,src1),
10401               Pop_Mem_FPR(dst) );
10402   ins_pipe( fpu_mem_mem_mem );
10403 %}
10404 
10405 
10406 // Spill to obtain 24-bit precision
10407 instruct addFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10408   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10409   match(Set dst (AddF src con));
10410   format %{ &quot;FLD    $src\n\t&quot;
10411             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10412             &quot;FSTP_S $dst&quot;  %}
10413   ins_encode %{
10414     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10415     __ fadd_s($constantaddress($con));
10416     __ fstp_s(Address(rsp, $dst$$disp));
10417   %}
10418   ins_pipe(fpu_mem_reg_con);
10419 %}
10420 //
10421 // This instruction does not round to 24-bits
10422 instruct addFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10423   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10424   match(Set dst (AddF src con));
10425   format %{ &quot;FLD    $src\n\t&quot;
10426             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10427             &quot;FSTP   $dst&quot;  %}
10428   ins_encode %{
10429     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10430     __ fadd_s($constantaddress($con));
10431     __ fstp_d($dst$$reg);
10432   %}
10433   ins_pipe(fpu_reg_reg_con);
10434 %}
10435 
10436 // Spill to obtain 24-bit precision
10437 instruct mulFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10438   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10439   match(Set dst (MulF src1 src2));
10440 
10441   format %{ &quot;FLD    $src1\n\t&quot;
10442             &quot;FMUL   $src2\n\t&quot;
10443             &quot;FSTP_S $dst&quot;  %}
10444   opcode(0xD8, 0x1); /* D8 C8+i or D8 /1 ;; result in TOS */
10445   ins_encode( Push_Reg_FPR(src1),
10446               OpcReg_FPR(src2),
10447               Pop_Mem_FPR(dst) );
10448   ins_pipe( fpu_mem_reg_reg );
10449 %}
10450 //
10451 // This instruction does not round to 24-bits
10452 instruct mulFPR_reg(regFPR dst, regFPR src1, regFPR src2) %{
10453   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10454   match(Set dst (MulF src1 src2));
10455 
10456   format %{ &quot;FLD    $src1\n\t&quot;
10457             &quot;FMUL   $src2\n\t&quot;
10458             &quot;FSTP_S $dst&quot;  %}
10459   opcode(0xD8, 0x1); /* D8 C8+i */
10460   ins_encode( Push_Reg_FPR(src2),
10461               OpcReg_FPR(src1),
10462               Pop_Reg_FPR(dst) );
10463   ins_pipe( fpu_reg_reg_reg );
10464 %}
10465 
10466 
10467 // Spill to obtain 24-bit precision
10468 // Cisc-alternate to reg-reg multiply
10469 instruct mulFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10470   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10471   match(Set dst (MulF src1 (LoadF src2)));
10472 
10473   format %{ &quot;FLD_S  $src2\n\t&quot;
10474             &quot;FMUL   $src1\n\t&quot;
10475             &quot;FSTP_S $dst&quot;  %}
10476   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or DE /1*/  /* LoadF D9 /0 */
10477   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10478               OpcReg_FPR(src1),
10479               Pop_Mem_FPR(dst) );
10480   ins_pipe( fpu_mem_reg_mem );
10481 %}
10482 //
10483 // This instruction does not round to 24-bits
10484 // Cisc-alternate to reg-reg multiply
10485 instruct mulFPR_reg_mem(regFPR dst, regFPR src1, memory src2) %{
10486   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10487   match(Set dst (MulF src1 (LoadF src2)));
10488 
10489   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10490   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadF D9 /0 */
10491   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10492               OpcReg_FPR(src1),
10493               Pop_Reg_FPR(dst) );
10494   ins_pipe( fpu_reg_reg_mem );
10495 %}
10496 
10497 // Spill to obtain 24-bit precision
10498 instruct mulFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10499   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10500   match(Set dst (MulF src1 src2));
10501 
10502   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10503   opcode(0xD8, 0x1, 0xD9); /* D8 /1 */  /* LoadF D9 /0 */
10504   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10505               set_instruction_start,
10506               OpcP, RMopc_Mem(secondary,src1),
10507               Pop_Mem_FPR(dst) );
10508   ins_pipe( fpu_mem_mem_mem );
10509 %}
10510 
10511 // Spill to obtain 24-bit precision
10512 instruct mulFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10513   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10514   match(Set dst (MulF src con));
10515 
10516   format %{ &quot;FLD    $src\n\t&quot;
10517             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10518             &quot;FSTP_S $dst&quot;  %}
10519   ins_encode %{
10520     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10521     __ fmul_s($constantaddress($con));
10522     __ fstp_s(Address(rsp, $dst$$disp));
10523   %}
10524   ins_pipe(fpu_mem_reg_con);
10525 %}
10526 //
10527 // This instruction does not round to 24-bits
10528 instruct mulFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10529   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10530   match(Set dst (MulF src con));
10531 
10532   format %{ &quot;FLD    $src\n\t&quot;
10533             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10534             &quot;FSTP   $dst&quot;  %}
10535   ins_encode %{
10536     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10537     __ fmul_s($constantaddress($con));
10538     __ fstp_d($dst$$reg);
10539   %}
10540   ins_pipe(fpu_reg_reg_con);
10541 %}
10542 
10543 
10544 //
10545 // MACRO1 -- subsume unshared load into mulFPR
10546 // This instruction does not round to 24-bits
10547 instruct mulFPR_reg_load1(regFPR dst, regFPR src, memory mem1 ) %{
10548   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10549   match(Set dst (MulF (LoadF mem1) src));
10550 
10551   format %{ &quot;FLD    $mem1    ===MACRO1===\n\t&quot;
10552             &quot;FMUL   ST,$src\n\t&quot;
10553             &quot;FSTP   $dst&quot; %}
10554   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or D8 /1 */  /* LoadF D9 /0 */
10555   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem1),
10556               OpcReg_FPR(src),
10557               Pop_Reg_FPR(dst) );
10558   ins_pipe( fpu_reg_reg_mem );
10559 %}
10560 //
10561 // MACRO2 -- addFPR a mulFPR which subsumed an unshared load
10562 // This instruction does not round to 24-bits
10563 instruct addFPR_mulFPR_reg_load1(regFPR dst, memory mem1, regFPR src1, regFPR src2) %{
10564   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10565   match(Set dst (AddF (MulF (LoadF mem1) src1) src2));
10566   ins_cost(95);
10567 
10568   format %{ &quot;FLD    $mem1     ===MACRO2===\n\t&quot;
10569             &quot;FMUL   ST,$src1  subsume mulFPR left load\n\t&quot;
10570             &quot;FADD   ST,$src2\n\t&quot;
10571             &quot;FSTP   $dst&quot; %}
10572   opcode(0xD9); /* LoadF D9 /0 */
10573   ins_encode( OpcP, RMopc_Mem(0x00,mem1),
10574               FMul_ST_reg(src1),
10575               FAdd_ST_reg(src2),
10576               Pop_Reg_FPR(dst) );
10577   ins_pipe( fpu_reg_mem_reg_reg );
10578 %}
10579 
10580 // MACRO3 -- addFPR a mulFPR
10581 // This instruction does not round to 24-bits.  It is a &#39;2-address&#39;
10582 // instruction in that the result goes back to src2.  This eliminates
10583 // a move from the macro; possibly the register allocator will have
10584 // to add it back (and maybe not).
10585 instruct addFPR_mulFPR_reg(regFPR src2, regFPR src1, regFPR src0) %{
10586   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10587   match(Set src2 (AddF (MulF src0 src1) src2));
10588 
10589   format %{ &quot;FLD    $src0     ===MACRO3===\n\t&quot;
10590             &quot;FMUL   ST,$src1\n\t&quot;
10591             &quot;FADDP  $src2,ST&quot; %}
10592   opcode(0xD9); /* LoadF D9 /0 */
10593   ins_encode( Push_Reg_FPR(src0),
10594               FMul_ST_reg(src1),
10595               FAddP_reg_ST(src2) );
10596   ins_pipe( fpu_reg_reg_reg );
10597 %}
10598 
10599 // MACRO4 -- divFPR subFPR
10600 // This instruction does not round to 24-bits
10601 instruct subFPR_divFPR_reg(regFPR dst, regFPR src1, regFPR src2, regFPR src3) %{
10602   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10603   match(Set dst (DivF (SubF src2 src1) src3));
10604 
10605   format %{ &quot;FLD    $src2   ===MACRO4===\n\t&quot;
10606             &quot;FSUB   ST,$src1\n\t&quot;
10607             &quot;FDIV   ST,$src3\n\t&quot;
10608             &quot;FSTP  $dst&quot; %}
10609   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10610   ins_encode( Push_Reg_FPR(src2),
10611               subFPR_divFPR_encode(src1,src3),
10612               Pop_Reg_FPR(dst) );
10613   ins_pipe( fpu_reg_reg_reg_reg );
10614 %}
10615 
10616 // Spill to obtain 24-bit precision
10617 instruct divFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10618   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10619   match(Set dst (DivF src1 src2));
10620 
10621   format %{ &quot;FDIV   $dst,$src1,$src2&quot; %}
10622   opcode(0xD8, 0x6); /* D8 F0+i or DE /6*/
10623   ins_encode( Push_Reg_FPR(src1),
10624               OpcReg_FPR(src2),
10625               Pop_Mem_FPR(dst) );
10626   ins_pipe( fpu_mem_reg_reg );
10627 %}
10628 //
10629 // This instruction does not round to 24-bits
10630 instruct divFPR_reg(regFPR dst, regFPR src) %{
10631   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10632   match(Set dst (DivF dst src));
10633 
10634   format %{ &quot;FDIV   $dst,$src&quot; %}
10635   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10636   ins_encode( Push_Reg_FPR(src),
10637               OpcP, RegOpc(dst) );
10638   ins_pipe( fpu_reg_reg );
10639 %}
10640 
10641 
10642 // Spill to obtain 24-bit precision
10643 instruct modFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10644   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10645   match(Set dst (ModF src1 src2));
10646   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10647 
10648   format %{ &quot;FMOD   $dst,$src1,$src2&quot; %}
10649   ins_encode( Push_Reg_Mod_DPR(src1, src2),
10650               emitModDPR(),
10651               Push_Result_Mod_DPR(src2),
10652               Pop_Mem_FPR(dst));
10653   ins_pipe( pipe_slow );
10654 %}
10655 //
10656 // This instruction does not round to 24-bits
10657 instruct modFPR_reg(regFPR dst, regFPR src, eAXRegI rax, eFlagsReg cr) %{
10658   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10659   match(Set dst (ModF dst src));
10660   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10661 
10662   format %{ &quot;FMOD   $dst,$src&quot; %}
10663   ins_encode(Push_Reg_Mod_DPR(dst, src),
10664               emitModDPR(),
10665               Push_Result_Mod_DPR(src),
10666               Pop_Reg_FPR(dst));
10667   ins_pipe( pipe_slow );
10668 %}
10669 
10670 instruct modF_reg(regF dst, regF src0, regF src1, eAXRegI rax, eFlagsReg cr) %{
10671   predicate(UseSSE&gt;=1);
10672   match(Set dst (ModF src0 src1));
10673   effect(KILL rax, KILL cr);
10674   format %{ &quot;SUB    ESP,4\t # FMOD\n&quot;
10675           &quot;\tMOVSS  [ESP+0],$src1\n&quot;
10676           &quot;\tFLD_S  [ESP+0]\n&quot;
10677           &quot;\tMOVSS  [ESP+0],$src0\n&quot;
10678           &quot;\tFLD_S  [ESP+0]\n&quot;
10679      &quot;loop:\tFPREM\n&quot;
10680           &quot;\tFWAIT\n&quot;
10681           &quot;\tFNSTSW AX\n&quot;
10682           &quot;\tSAHF\n&quot;
10683           &quot;\tJP     loop\n&quot;
10684           &quot;\tFSTP_S [ESP+0]\n&quot;
10685           &quot;\tMOVSS  $dst,[ESP+0]\n&quot;
10686           &quot;\tADD    ESP,4\n&quot;
10687           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10688     %}
10689   ins_cost(250);
10690   ins_encode( Push_ModF_encoding(src0, src1), emitModDPR(), Push_ResultF(dst,0x4), PopFPU);
10691   ins_pipe( pipe_slow );
10692 %}
10693 
10694 
10695 //----------Arithmetic Conversion Instructions---------------------------------
10696 // The conversions operations are all Alpha sorted.  Please keep it that way!
10697 
10698 instruct roundFloat_mem_reg(stackSlotF dst, regFPR src) %{
10699   predicate(UseSSE==0);
10700   match(Set dst (RoundFloat src));
10701   ins_cost(125);
10702   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10703   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
10704   ins_pipe( fpu_mem_reg );
10705 %}
10706 
10707 instruct roundDouble_mem_reg(stackSlotD dst, regDPR src) %{
10708   predicate(UseSSE&lt;=1);
10709   match(Set dst (RoundDouble src));
10710   ins_cost(125);
10711   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10712   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
10713   ins_pipe( fpu_mem_reg );
10714 %}
10715 
10716 // Force rounding to 24-bit precision and 6-bit exponent
10717 instruct convDPR2FPR_reg(stackSlotF dst, regDPR src) %{
10718   predicate(UseSSE==0);
10719   match(Set dst (ConvD2F src));
10720   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10721   expand %{
10722     roundFloat_mem_reg(dst,src);
10723   %}
10724 %}
10725 
10726 // Force rounding to 24-bit precision and 6-bit exponent
10727 instruct convDPR2F_reg(regF dst, regDPR src, eFlagsReg cr) %{
10728   predicate(UseSSE==1);
10729   match(Set dst (ConvD2F src));
10730   effect( KILL cr );
10731   format %{ &quot;SUB    ESP,4\n\t&quot;
10732             &quot;FST_S  [ESP],$src\t# F-round\n\t&quot;
10733             &quot;MOVSS  $dst,[ESP]\n\t&quot;
10734             &quot;ADD ESP,4&quot; %}
10735   ins_encode %{
10736     __ subptr(rsp, 4);
10737     if ($src$$reg != FPR1L_enc) {
10738       __ fld_s($src$$reg-1);
10739       __ fstp_s(Address(rsp, 0));
10740     } else {
10741       __ fst_s(Address(rsp, 0));
10742     }
10743     __ movflt($dst$$XMMRegister, Address(rsp, 0));
10744     __ addptr(rsp, 4);
10745   %}
10746   ins_pipe( pipe_slow );
10747 %}
10748 
10749 // Force rounding double precision to single precision
10750 instruct convD2F_reg(regF dst, regD src) %{
10751   predicate(UseSSE&gt;=2);
10752   match(Set dst (ConvD2F src));
10753   format %{ &quot;CVTSD2SS $dst,$src\t# F-round&quot; %}
10754   ins_encode %{
10755     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10756   %}
10757   ins_pipe( pipe_slow );
10758 %}
10759 
10760 instruct convFPR2DPR_reg_reg(regDPR dst, regFPR src) %{
10761   predicate(UseSSE==0);
10762   match(Set dst (ConvF2D src));
10763   format %{ &quot;FST_S  $dst,$src\t# D-round&quot; %}
10764   ins_encode( Pop_Reg_Reg_DPR(dst, src));
10765   ins_pipe( fpu_reg_reg );
10766 %}
10767 
10768 instruct convFPR2D_reg(stackSlotD dst, regFPR src) %{
10769   predicate(UseSSE==1);
10770   match(Set dst (ConvF2D src));
10771   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10772   expand %{
10773     roundDouble_mem_reg(dst,src);
10774   %}
10775 %}
10776 
10777 instruct convF2DPR_reg(regDPR dst, regF src, eFlagsReg cr) %{
10778   predicate(UseSSE==1);
10779   match(Set dst (ConvF2D src));
10780   effect( KILL cr );
10781   format %{ &quot;SUB    ESP,4\n\t&quot;
10782             &quot;MOVSS  [ESP] $src\n\t&quot;
10783             &quot;FLD_S  [ESP]\n\t&quot;
10784             &quot;ADD    ESP,4\n\t&quot;
10785             &quot;FSTP   $dst\t# D-round&quot; %}
10786   ins_encode %{
10787     __ subptr(rsp, 4);
10788     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10789     __ fld_s(Address(rsp, 0));
10790     __ addptr(rsp, 4);
10791     __ fstp_d($dst$$reg);
10792   %}
10793   ins_pipe( pipe_slow );
10794 %}
10795 
10796 instruct convF2D_reg(regD dst, regF src) %{
10797   predicate(UseSSE&gt;=2);
10798   match(Set dst (ConvF2D src));
10799   format %{ &quot;CVTSS2SD $dst,$src\t# D-round&quot; %}
10800   ins_encode %{
10801     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10802   %}
10803   ins_pipe( pipe_slow );
10804 %}
10805 
10806 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10807 instruct convDPR2I_reg_reg( eAXRegI dst, eDXRegI tmp, regDPR src, eFlagsReg cr ) %{
10808   predicate(UseSSE&lt;=1);
10809   match(Set dst (ConvD2I src));
10810   effect( KILL tmp, KILL cr );
10811   format %{ &quot;FLD    $src\t# Convert double to int \n\t&quot;
10812             &quot;FLDCW  trunc mode\n\t&quot;
10813             &quot;SUB    ESP,4\n\t&quot;
10814             &quot;FISTp  [ESP + #0]\n\t&quot;
10815             &quot;FLDCW  std/24-bit mode\n\t&quot;
10816             &quot;POP    EAX\n\t&quot;
10817             &quot;CMP    EAX,0x80000000\n\t&quot;
10818             &quot;JNE,s  fast\n\t&quot;
10819             &quot;FLD_D  $src\n\t&quot;
10820             &quot;CALL   d2i_wrapper\n&quot;
10821       &quot;fast:&quot; %}
10822   ins_encode( Push_Reg_DPR(src), DPR2I_encoding(src) );
10823   ins_pipe( pipe_slow );
10824 %}
10825 
10826 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10827 instruct convD2I_reg_reg( eAXRegI dst, eDXRegI tmp, regD src, eFlagsReg cr ) %{
10828   predicate(UseSSE&gt;=2);
10829   match(Set dst (ConvD2I src));
10830   effect( KILL tmp, KILL cr );
10831   format %{ &quot;CVTTSD2SI $dst, $src\n\t&quot;
10832             &quot;CMP    $dst,0x80000000\n\t&quot;
10833             &quot;JNE,s  fast\n\t&quot;
10834             &quot;SUB    ESP, 8\n\t&quot;
10835             &quot;MOVSD  [ESP], $src\n\t&quot;
10836             &quot;FLD_D  [ESP]\n\t&quot;
10837             &quot;ADD    ESP, 8\n\t&quot;
10838             &quot;CALL   d2i_wrapper\n&quot;
10839       &quot;fast:&quot; %}
10840   ins_encode %{
10841     Label fast;
10842     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10843     __ cmpl($dst$$Register, 0x80000000);
10844     __ jccb(Assembler::notEqual, fast);
10845     __ subptr(rsp, 8);
10846     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10847     __ fld_d(Address(rsp, 0));
10848     __ addptr(rsp, 8);
10849     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10850     __ bind(fast);
10851   %}
10852   ins_pipe( pipe_slow );
10853 %}
10854 
10855 instruct convDPR2L_reg_reg( eADXRegL dst, regDPR src, eFlagsReg cr ) %{
10856   predicate(UseSSE&lt;=1);
10857   match(Set dst (ConvD2L src));
10858   effect( KILL cr );
10859   format %{ &quot;FLD    $src\t# Convert double to long\n\t&quot;
10860             &quot;FLDCW  trunc mode\n\t&quot;
10861             &quot;SUB    ESP,8\n\t&quot;
10862             &quot;FISTp  [ESP + #0]\n\t&quot;
10863             &quot;FLDCW  std/24-bit mode\n\t&quot;
10864             &quot;POP    EAX\n\t&quot;
10865             &quot;POP    EDX\n\t&quot;
10866             &quot;CMP    EDX,0x80000000\n\t&quot;
10867             &quot;JNE,s  fast\n\t&quot;
10868             &quot;TEST   EAX,EAX\n\t&quot;
10869             &quot;JNE,s  fast\n\t&quot;
10870             &quot;FLD    $src\n\t&quot;
10871             &quot;CALL   d2l_wrapper\n&quot;
10872       &quot;fast:&quot; %}
10873   ins_encode( Push_Reg_DPR(src),  DPR2L_encoding(src) );
10874   ins_pipe( pipe_slow );
10875 %}
10876 
10877 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
10878 instruct convD2L_reg_reg( eADXRegL dst, regD src, eFlagsReg cr ) %{
10879   predicate (UseSSE&gt;=2);
10880   match(Set dst (ConvD2L src));
10881   effect( KILL cr );
10882   format %{ &quot;SUB    ESP,8\t# Convert double to long\n\t&quot;
10883             &quot;MOVSD  [ESP],$src\n\t&quot;
10884             &quot;FLD_D  [ESP]\n\t&quot;
10885             &quot;FLDCW  trunc mode\n\t&quot;
10886             &quot;FISTp  [ESP + #0]\n\t&quot;
10887             &quot;FLDCW  std/24-bit mode\n\t&quot;
10888             &quot;POP    EAX\n\t&quot;
10889             &quot;POP    EDX\n\t&quot;
10890             &quot;CMP    EDX,0x80000000\n\t&quot;
10891             &quot;JNE,s  fast\n\t&quot;
10892             &quot;TEST   EAX,EAX\n\t&quot;
10893             &quot;JNE,s  fast\n\t&quot;
10894             &quot;SUB    ESP,8\n\t&quot;
10895             &quot;MOVSD  [ESP],$src\n\t&quot;
10896             &quot;FLD_D  [ESP]\n\t&quot;
10897             &quot;ADD    ESP,8\n\t&quot;
10898             &quot;CALL   d2l_wrapper\n&quot;
10899       &quot;fast:&quot; %}
10900   ins_encode %{
10901     Label fast;
10902     __ subptr(rsp, 8);
10903     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10904     __ fld_d(Address(rsp, 0));
10905     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
10906     __ fistp_d(Address(rsp, 0));
10907     // Restore the rounding mode, mask the exception
10908     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
10909       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
10910     } else {
10911       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
10912     }
10913     // Load the converted long, adjust CPU stack
10914     __ pop(rax);
10915     __ pop(rdx);
10916     __ cmpl(rdx, 0x80000000);
10917     __ jccb(Assembler::notEqual, fast);
10918     __ testl(rax, rax);
10919     __ jccb(Assembler::notEqual, fast);
10920     __ subptr(rsp, 8);
10921     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10922     __ fld_d(Address(rsp, 0));
10923     __ addptr(rsp, 8);
10924     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
10925     __ bind(fast);
10926   %}
10927   ins_pipe( pipe_slow );
10928 %}
10929 
10930 // Convert a double to an int.  Java semantics require we do complex
10931 // manglations in the corner cases.  So we set the rounding mode to
10932 // &#39;zero&#39;, store the darned double down as an int, and reset the
10933 // rounding mode to &#39;nearest&#39;.  The hardware stores a flag value down
10934 // if we would overflow or converted a NAN; we check for this and
10935 // and go the slow path if needed.
10936 instruct convFPR2I_reg_reg(eAXRegI dst, eDXRegI tmp, regFPR src, eFlagsReg cr ) %{
10937   predicate(UseSSE==0);
10938   match(Set dst (ConvF2I src));
10939   effect( KILL tmp, KILL cr );
10940   format %{ &quot;FLD    $src\t# Convert float to int \n\t&quot;
10941             &quot;FLDCW  trunc mode\n\t&quot;
10942             &quot;SUB    ESP,4\n\t&quot;
10943             &quot;FISTp  [ESP + #0]\n\t&quot;
10944             &quot;FLDCW  std/24-bit mode\n\t&quot;
10945             &quot;POP    EAX\n\t&quot;
10946             &quot;CMP    EAX,0x80000000\n\t&quot;
10947             &quot;JNE,s  fast\n\t&quot;
10948             &quot;FLD    $src\n\t&quot;
10949             &quot;CALL   d2i_wrapper\n&quot;
10950       &quot;fast:&quot; %}
10951   // DPR2I_encoding works for FPR2I
10952   ins_encode( Push_Reg_FPR(src), DPR2I_encoding(src) );
10953   ins_pipe( pipe_slow );
10954 %}
10955 
10956 // Convert a float in xmm to an int reg.
10957 instruct convF2I_reg(eAXRegI dst, eDXRegI tmp, regF src, eFlagsReg cr ) %{
10958   predicate(UseSSE&gt;=1);
10959   match(Set dst (ConvF2I src));
10960   effect( KILL tmp, KILL cr );
10961   format %{ &quot;CVTTSS2SI $dst, $src\n\t&quot;
10962             &quot;CMP    $dst,0x80000000\n\t&quot;
10963             &quot;JNE,s  fast\n\t&quot;
10964             &quot;SUB    ESP, 4\n\t&quot;
10965             &quot;MOVSS  [ESP], $src\n\t&quot;
10966             &quot;FLD    [ESP]\n\t&quot;
10967             &quot;ADD    ESP, 4\n\t&quot;
10968             &quot;CALL   d2i_wrapper\n&quot;
10969       &quot;fast:&quot; %}
10970   ins_encode %{
10971     Label fast;
10972     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
10973     __ cmpl($dst$$Register, 0x80000000);
10974     __ jccb(Assembler::notEqual, fast);
10975     __ subptr(rsp, 4);
10976     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10977     __ fld_s(Address(rsp, 0));
10978     __ addptr(rsp, 4);
10979     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10980     __ bind(fast);
10981   %}
10982   ins_pipe( pipe_slow );
10983 %}
10984 
10985 instruct convFPR2L_reg_reg( eADXRegL dst, regFPR src, eFlagsReg cr ) %{
10986   predicate(UseSSE==0);
10987   match(Set dst (ConvF2L src));
10988   effect( KILL cr );
10989   format %{ &quot;FLD    $src\t# Convert float to long\n\t&quot;
10990             &quot;FLDCW  trunc mode\n\t&quot;
10991             &quot;SUB    ESP,8\n\t&quot;
10992             &quot;FISTp  [ESP + #0]\n\t&quot;
10993             &quot;FLDCW  std/24-bit mode\n\t&quot;
10994             &quot;POP    EAX\n\t&quot;
10995             &quot;POP    EDX\n\t&quot;
10996             &quot;CMP    EDX,0x80000000\n\t&quot;
10997             &quot;JNE,s  fast\n\t&quot;
10998             &quot;TEST   EAX,EAX\n\t&quot;
10999             &quot;JNE,s  fast\n\t&quot;
11000             &quot;FLD    $src\n\t&quot;
11001             &quot;CALL   d2l_wrapper\n&quot;
11002       &quot;fast:&quot; %}
11003   // DPR2L_encoding works for FPR2L
11004   ins_encode( Push_Reg_FPR(src), DPR2L_encoding(src) );
11005   ins_pipe( pipe_slow );
11006 %}
11007 
11008 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
11009 instruct convF2L_reg_reg( eADXRegL dst, regF src, eFlagsReg cr ) %{
11010   predicate (UseSSE&gt;=1);
11011   match(Set dst (ConvF2L src));
11012   effect( KILL cr );
11013   format %{ &quot;SUB    ESP,8\t# Convert float to long\n\t&quot;
11014             &quot;MOVSS  [ESP],$src\n\t&quot;
11015             &quot;FLD_S  [ESP]\n\t&quot;
11016             &quot;FLDCW  trunc mode\n\t&quot;
11017             &quot;FISTp  [ESP + #0]\n\t&quot;
11018             &quot;FLDCW  std/24-bit mode\n\t&quot;
11019             &quot;POP    EAX\n\t&quot;
11020             &quot;POP    EDX\n\t&quot;
11021             &quot;CMP    EDX,0x80000000\n\t&quot;
11022             &quot;JNE,s  fast\n\t&quot;
11023             &quot;TEST   EAX,EAX\n\t&quot;
11024             &quot;JNE,s  fast\n\t&quot;
11025             &quot;SUB    ESP,4\t# Convert float to long\n\t&quot;
11026             &quot;MOVSS  [ESP],$src\n\t&quot;
11027             &quot;FLD_S  [ESP]\n\t&quot;
11028             &quot;ADD    ESP,4\n\t&quot;
11029             &quot;CALL   d2l_wrapper\n&quot;
11030       &quot;fast:&quot; %}
11031   ins_encode %{
11032     Label fast;
11033     __ subptr(rsp, 8);
11034     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11035     __ fld_s(Address(rsp, 0));
11036     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
11037     __ fistp_d(Address(rsp, 0));
11038     // Restore the rounding mode, mask the exception
11039     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
11040       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
11041     } else {
11042       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
11043     }
11044     // Load the converted long, adjust CPU stack
11045     __ pop(rax);
11046     __ pop(rdx);
11047     __ cmpl(rdx, 0x80000000);
11048     __ jccb(Assembler::notEqual, fast);
11049     __ testl(rax, rax);
11050     __ jccb(Assembler::notEqual, fast);
11051     __ subptr(rsp, 4);
11052     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11053     __ fld_s(Address(rsp, 0));
11054     __ addptr(rsp, 4);
11055     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
11056     __ bind(fast);
11057   %}
11058   ins_pipe( pipe_slow );
11059 %}
11060 
11061 instruct convI2DPR_reg(regDPR dst, stackSlotI src) %{
11062   predicate( UseSSE&lt;=1 );
11063   match(Set dst (ConvI2D src));
11064   format %{ &quot;FILD   $src\n\t&quot;
11065             &quot;FSTP   $dst&quot; %}
11066   opcode(0xDB, 0x0);  /* DB /0 */
11067   ins_encode(Push_Mem_I(src), Pop_Reg_DPR(dst));
11068   ins_pipe( fpu_reg_mem );
11069 %}
11070 
11071 instruct convI2D_reg(regD dst, rRegI src) %{
11072   predicate( UseSSE&gt;=2 &amp;&amp; !UseXmmI2D );
11073   match(Set dst (ConvI2D src));
11074   format %{ &quot;CVTSI2SD $dst,$src&quot; %}
11075   ins_encode %{
11076     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
11077   %}
11078   ins_pipe( pipe_slow );
11079 %}
11080 
11081 instruct convI2D_mem(regD dst, memory mem) %{
11082   predicate( UseSSE&gt;=2 );
11083   match(Set dst (ConvI2D (LoadI mem)));
11084   format %{ &quot;CVTSI2SD $dst,$mem&quot; %}
11085   ins_encode %{
11086     __ cvtsi2sdl ($dst$$XMMRegister, $mem$$Address);
11087   %}
11088   ins_pipe( pipe_slow );
11089 %}
11090 
11091 instruct convXI2D_reg(regD dst, rRegI src)
11092 %{
11093   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2D );
11094   match(Set dst (ConvI2D src));
11095 
11096   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11097             &quot;CVTDQ2PD $dst,$dst\t# i2d&quot; %}
11098   ins_encode %{
11099     __ movdl($dst$$XMMRegister, $src$$Register);
11100     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
11101   %}
11102   ins_pipe(pipe_slow); // XXX
11103 %}
11104 
11105 instruct convI2DPR_mem(regDPR dst, memory mem) %{
11106   predicate( UseSSE&lt;=1 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11107   match(Set dst (ConvI2D (LoadI mem)));
11108   format %{ &quot;FILD   $mem\n\t&quot;
11109             &quot;FSTP   $dst&quot; %}
11110   opcode(0xDB);      /* DB /0 */
11111   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11112               Pop_Reg_DPR(dst));
11113   ins_pipe( fpu_reg_mem );
11114 %}
11115 
11116 // Convert a byte to a float; no rounding step needed.
11117 instruct conv24I2FPR_reg(regFPR dst, stackSlotI src) %{
11118   predicate( UseSSE==0 &amp;&amp; n-&gt;in(1)-&gt;Opcode() == Op_AndI &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;get_int() == 255 );
11119   match(Set dst (ConvI2F src));
11120   format %{ &quot;FILD   $src\n\t&quot;
11121             &quot;FSTP   $dst&quot; %}
11122 
11123   opcode(0xDB, 0x0);  /* DB /0 */
11124   ins_encode(Push_Mem_I(src), Pop_Reg_FPR(dst));
11125   ins_pipe( fpu_reg_mem );
11126 %}
11127 
11128 // In 24-bit mode, force exponent rounding by storing back out
11129 instruct convI2FPR_SSF(stackSlotF dst, stackSlotI src) %{
11130   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11131   match(Set dst (ConvI2F src));
11132   ins_cost(200);
11133   format %{ &quot;FILD   $src\n\t&quot;
11134             &quot;FSTP_S $dst&quot; %}
11135   opcode(0xDB, 0x0);  /* DB /0 */
11136   ins_encode( Push_Mem_I(src),
11137               Pop_Mem_FPR(dst));
11138   ins_pipe( fpu_mem_mem );
11139 %}
11140 
11141 // In 24-bit mode, force exponent rounding by storing back out
11142 instruct convI2FPR_SSF_mem(stackSlotF dst, memory mem) %{
11143   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11144   match(Set dst (ConvI2F (LoadI mem)));
11145   ins_cost(200);
11146   format %{ &quot;FILD   $mem\n\t&quot;
11147             &quot;FSTP_S $dst&quot; %}
11148   opcode(0xDB);  /* DB /0 */
11149   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11150               Pop_Mem_FPR(dst));
11151   ins_pipe( fpu_mem_mem );
11152 %}
11153 
11154 // This instruction does not round to 24-bits
11155 instruct convI2FPR_reg(regFPR dst, stackSlotI src) %{
11156   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11157   match(Set dst (ConvI2F src));
11158   format %{ &quot;FILD   $src\n\t&quot;
11159             &quot;FSTP   $dst&quot; %}
11160   opcode(0xDB, 0x0);  /* DB /0 */
11161   ins_encode( Push_Mem_I(src),
11162               Pop_Reg_FPR(dst));
11163   ins_pipe( fpu_reg_mem );
11164 %}
11165 
11166 // This instruction does not round to 24-bits
11167 instruct convI2FPR_mem(regFPR dst, memory mem) %{
11168   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11169   match(Set dst (ConvI2F (LoadI mem)));
11170   format %{ &quot;FILD   $mem\n\t&quot;
11171             &quot;FSTP   $dst&quot; %}
11172   opcode(0xDB);      /* DB /0 */
11173   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11174               Pop_Reg_FPR(dst));
11175   ins_pipe( fpu_reg_mem );
11176 %}
11177 
11178 // Convert an int to a float in xmm; no rounding step needed.
11179 instruct convI2F_reg(regF dst, rRegI src) %{
11180   predicate( UseSSE==1 || UseSSE&gt;=2 &amp;&amp; !UseXmmI2F );
11181   match(Set dst (ConvI2F src));
11182   format %{ &quot;CVTSI2SS $dst, $src&quot; %}
11183   ins_encode %{
11184     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
11185   %}
11186   ins_pipe( pipe_slow );
11187 %}
11188 
11189  instruct convXI2F_reg(regF dst, rRegI src)
11190 %{
11191   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2F );
11192   match(Set dst (ConvI2F src));
11193 
11194   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11195             &quot;CVTDQ2PS $dst,$dst\t# i2f&quot; %}
11196   ins_encode %{
11197     __ movdl($dst$$XMMRegister, $src$$Register);
11198     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
11199   %}
11200   ins_pipe(pipe_slow); // XXX
11201 %}
11202 
11203 instruct convI2L_reg( eRegL dst, rRegI src, eFlagsReg cr) %{
11204   match(Set dst (ConvI2L src));
11205   effect(KILL cr);
11206   ins_cost(375);
11207   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11208             &quot;MOV    $dst.hi,$src\n\t&quot;
11209             &quot;SAR    $dst.hi,31&quot; %}
11210   ins_encode(convert_int_long(dst,src));
11211   ins_pipe( ialu_reg_reg_long );
11212 %}
11213 
11214 // Zero-extend convert int to long
11215 instruct convI2L_reg_zex(eRegL dst, rRegI src, immL_32bits mask, eFlagsReg flags ) %{
11216   match(Set dst (AndL (ConvI2L src) mask) );
11217   effect( KILL flags );
11218   ins_cost(250);
11219   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11220             &quot;XOR    $dst.hi,$dst.hi&quot; %}
11221   opcode(0x33); // XOR
11222   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11223   ins_pipe( ialu_reg_reg_long );
11224 %}
11225 
11226 // Zero-extend long
11227 instruct zerox_long(eRegL dst, eRegL src, immL_32bits mask, eFlagsReg flags ) %{
11228   match(Set dst (AndL src mask) );
11229   effect( KILL flags );
11230   ins_cost(250);
11231   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
11232             &quot;XOR    $dst.hi,$dst.hi\n\t&quot; %}
11233   opcode(0x33); // XOR
11234   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11235   ins_pipe( ialu_reg_reg_long );
11236 %}
11237 
11238 instruct convL2DPR_reg( stackSlotD dst, eRegL src, eFlagsReg cr) %{
11239   predicate (UseSSE&lt;=1);
11240   match(Set dst (ConvL2D src));
11241   effect( KILL cr );
11242   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11243             &quot;PUSH   $src.lo\n\t&quot;
11244             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11245             &quot;ADD    ESP,8\n\t&quot;
11246             &quot;FSTP_D $dst\t# D-round&quot; %}
11247   opcode(0xDF, 0x5);  /* DF /5 */
11248   ins_encode(convert_long_double(src), Pop_Mem_DPR(dst));
11249   ins_pipe( pipe_slow );
11250 %}
11251 
11252 instruct convL2D_reg( regD dst, eRegL src, eFlagsReg cr) %{
11253   predicate (UseSSE&gt;=2);
11254   match(Set dst (ConvL2D src));
11255   effect( KILL cr );
11256   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11257             &quot;PUSH   $src.lo\n\t&quot;
11258             &quot;FILD_D [ESP]\n\t&quot;
11259             &quot;FSTP_D [ESP]\n\t&quot;
11260             &quot;MOVSD  $dst,[ESP]\n\t&quot;
11261             &quot;ADD    ESP,8&quot; %}
11262   opcode(0xDF, 0x5);  /* DF /5 */
11263   ins_encode(convert_long_double2(src), Push_ResultD(dst));
11264   ins_pipe( pipe_slow );
11265 %}
11266 
11267 instruct convL2F_reg( regF dst, eRegL src, eFlagsReg cr) %{
11268   predicate (UseSSE&gt;=1);
11269   match(Set dst (ConvL2F src));
11270   effect( KILL cr );
11271   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11272             &quot;PUSH   $src.lo\n\t&quot;
11273             &quot;FILD_D [ESP]\n\t&quot;
11274             &quot;FSTP_S [ESP]\n\t&quot;
11275             &quot;MOVSS  $dst,[ESP]\n\t&quot;
11276             &quot;ADD    ESP,8&quot; %}
11277   opcode(0xDF, 0x5);  /* DF /5 */
11278   ins_encode(convert_long_double2(src), Push_ResultF(dst,0x8));
11279   ins_pipe( pipe_slow );
11280 %}
11281 
11282 instruct convL2FPR_reg( stackSlotF dst, eRegL src, eFlagsReg cr) %{
11283   match(Set dst (ConvL2F src));
11284   effect( KILL cr );
11285   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11286             &quot;PUSH   $src.lo\n\t&quot;
11287             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11288             &quot;ADD    ESP,8\n\t&quot;
11289             &quot;FSTP_S $dst\t# F-round&quot; %}
11290   opcode(0xDF, 0x5);  /* DF /5 */
11291   ins_encode(convert_long_double(src), Pop_Mem_FPR(dst));
11292   ins_pipe( pipe_slow );
11293 %}
11294 
11295 instruct convL2I_reg( rRegI dst, eRegL src ) %{
11296   match(Set dst (ConvL2I src));
11297   effect( DEF dst, USE src );
11298   format %{ &quot;MOV    $dst,$src.lo&quot; %}
11299   ins_encode(enc_CopyL_Lo(dst,src));
11300   ins_pipe( ialu_reg_reg );
11301 %}
11302 
11303 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
11304   match(Set dst (MoveF2I src));
11305   effect( DEF dst, USE src );
11306   ins_cost(100);
11307   format %{ &quot;MOV    $dst,$src\t# MoveF2I_stack_reg&quot; %}
11308   ins_encode %{
11309     __ movl($dst$$Register, Address(rsp, $src$$disp));
11310   %}
11311   ins_pipe( ialu_reg_mem );
11312 %}
11313 
11314 instruct MoveFPR2I_reg_stack(stackSlotI dst, regFPR src) %{
11315   predicate(UseSSE==0);
11316   match(Set dst (MoveF2I src));
11317   effect( DEF dst, USE src );
11318 
11319   ins_cost(125);
11320   format %{ &quot;FST_S  $dst,$src\t# MoveF2I_reg_stack&quot; %}
11321   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
11322   ins_pipe( fpu_mem_reg );
11323 %}
11324 
11325 instruct MoveF2I_reg_stack_sse(stackSlotI dst, regF src) %{
11326   predicate(UseSSE&gt;=1);
11327   match(Set dst (MoveF2I src));
11328   effect( DEF dst, USE src );
11329 
11330   ins_cost(95);
11331   format %{ &quot;MOVSS  $dst,$src\t# MoveF2I_reg_stack_sse&quot; %}
11332   ins_encode %{
11333     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
11334   %}
11335   ins_pipe( pipe_slow );
11336 %}
11337 
11338 instruct MoveF2I_reg_reg_sse(rRegI dst, regF src) %{
11339   predicate(UseSSE&gt;=2);
11340   match(Set dst (MoveF2I src));
11341   effect( DEF dst, USE src );
11342   ins_cost(85);
11343   format %{ &quot;MOVD   $dst,$src\t# MoveF2I_reg_reg_sse&quot; %}
11344   ins_encode %{
11345     __ movdl($dst$$Register, $src$$XMMRegister);
11346   %}
11347   ins_pipe( pipe_slow );
11348 %}
11349 
11350 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
11351   match(Set dst (MoveI2F src));
11352   effect( DEF dst, USE src );
11353 
11354   ins_cost(100);
11355   format %{ &quot;MOV    $dst,$src\t# MoveI2F_reg_stack&quot; %}
11356   ins_encode %{
11357     __ movl(Address(rsp, $dst$$disp), $src$$Register);
11358   %}
11359   ins_pipe( ialu_mem_reg );
11360 %}
11361 
11362 
11363 instruct MoveI2FPR_stack_reg(regFPR dst, stackSlotI src) %{
11364   predicate(UseSSE==0);
11365   match(Set dst (MoveI2F src));
11366   effect(DEF dst, USE src);
11367 
11368   ins_cost(125);
11369   format %{ &quot;FLD_S  $src\n\t&quot;
11370             &quot;FSTP   $dst\t# MoveI2F_stack_reg&quot; %}
11371   opcode(0xD9);               /* D9 /0, FLD m32real */
11372   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11373               Pop_Reg_FPR(dst) );
11374   ins_pipe( fpu_reg_mem );
11375 %}
11376 
11377 instruct MoveI2F_stack_reg_sse(regF dst, stackSlotI src) %{
11378   predicate(UseSSE&gt;=1);
11379   match(Set dst (MoveI2F src));
11380   effect( DEF dst, USE src );
11381 
11382   ins_cost(95);
11383   format %{ &quot;MOVSS  $dst,$src\t# MoveI2F_stack_reg_sse&quot; %}
11384   ins_encode %{
11385     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
11386   %}
11387   ins_pipe( pipe_slow );
11388 %}
11389 
11390 instruct MoveI2F_reg_reg_sse(regF dst, rRegI src) %{
11391   predicate(UseSSE&gt;=2);
11392   match(Set dst (MoveI2F src));
11393   effect( DEF dst, USE src );
11394 
11395   ins_cost(85);
11396   format %{ &quot;MOVD   $dst,$src\t# MoveI2F_reg_reg_sse&quot; %}
11397   ins_encode %{
11398     __ movdl($dst$$XMMRegister, $src$$Register);
11399   %}
11400   ins_pipe( pipe_slow );
11401 %}
11402 
11403 instruct MoveD2L_stack_reg(eRegL dst, stackSlotD src) %{
11404   match(Set dst (MoveD2L src));
11405   effect(DEF dst, USE src);
11406 
11407   ins_cost(250);
11408   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11409             &quot;MOV    $dst.hi,$src+4\t# MoveD2L_stack_reg&quot; %}
11410   opcode(0x8B, 0x8B);
11411   ins_encode( OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src));
11412   ins_pipe( ialu_mem_long_reg );
11413 %}
11414 
11415 instruct MoveDPR2L_reg_stack(stackSlotL dst, regDPR src) %{
11416   predicate(UseSSE&lt;=1);
11417   match(Set dst (MoveD2L src));
11418   effect(DEF dst, USE src);
11419 
11420   ins_cost(125);
11421   format %{ &quot;FST_D  $dst,$src\t# MoveD2L_reg_stack&quot; %}
11422   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
11423   ins_pipe( fpu_mem_reg );
11424 %}
11425 
11426 instruct MoveD2L_reg_stack_sse(stackSlotL dst, regD src) %{
11427   predicate(UseSSE&gt;=2);
11428   match(Set dst (MoveD2L src));
11429   effect(DEF dst, USE src);
11430   ins_cost(95);
11431   format %{ &quot;MOVSD  $dst,$src\t# MoveD2L_reg_stack_sse&quot; %}
11432   ins_encode %{
11433     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
11434   %}
11435   ins_pipe( pipe_slow );
11436 %}
11437 
11438 instruct MoveD2L_reg_reg_sse(eRegL dst, regD src, regD tmp) %{
11439   predicate(UseSSE&gt;=2);
11440   match(Set dst (MoveD2L src));
11441   effect(DEF dst, USE src, TEMP tmp);
11442   ins_cost(85);
11443   format %{ &quot;MOVD   $dst.lo,$src\n\t&quot;
11444             &quot;PSHUFLW $tmp,$src,0x4E\n\t&quot;
11445             &quot;MOVD   $dst.hi,$tmp\t# MoveD2L_reg_reg_sse&quot; %}
11446   ins_encode %{
11447     __ movdl($dst$$Register, $src$$XMMRegister);
11448     __ pshuflw($tmp$$XMMRegister, $src$$XMMRegister, 0x4e);
11449     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
11450   %}
11451   ins_pipe( pipe_slow );
11452 %}
11453 
11454 instruct MoveL2D_reg_stack(stackSlotD dst, eRegL src) %{
11455   match(Set dst (MoveL2D src));
11456   effect(DEF dst, USE src);
11457 
11458   ins_cost(200);
11459   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
11460             &quot;MOV    $dst+4,$src.hi\t# MoveL2D_reg_stack&quot; %}
11461   opcode(0x89, 0x89);
11462   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
11463   ins_pipe( ialu_mem_long_reg );
11464 %}
11465 
11466 
11467 instruct MoveL2DPR_stack_reg(regDPR dst, stackSlotL src) %{
11468   predicate(UseSSE&lt;=1);
11469   match(Set dst (MoveL2D src));
11470   effect(DEF dst, USE src);
11471   ins_cost(125);
11472 
11473   format %{ &quot;FLD_D  $src\n\t&quot;
11474             &quot;FSTP   $dst\t# MoveL2D_stack_reg&quot; %}
11475   opcode(0xDD);               /* DD /0, FLD m64real */
11476   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11477               Pop_Reg_DPR(dst) );
11478   ins_pipe( fpu_reg_mem );
11479 %}
11480 
11481 
11482 instruct MoveL2D_stack_reg_sse(regD dst, stackSlotL src) %{
11483   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
11484   match(Set dst (MoveL2D src));
11485   effect(DEF dst, USE src);
11486 
11487   ins_cost(95);
11488   format %{ &quot;MOVSD  $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11489   ins_encode %{
11490     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11491   %}
11492   ins_pipe( pipe_slow );
11493 %}
11494 
11495 instruct MoveL2D_stack_reg_sse_partial(regD dst, stackSlotL src) %{
11496   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
11497   match(Set dst (MoveL2D src));
11498   effect(DEF dst, USE src);
11499 
11500   ins_cost(95);
11501   format %{ &quot;MOVLPD $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11502   ins_encode %{
11503     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11504   %}
11505   ins_pipe( pipe_slow );
11506 %}
11507 
11508 instruct MoveL2D_reg_reg_sse(regD dst, eRegL src, regD tmp) %{
11509   predicate(UseSSE&gt;=2);
11510   match(Set dst (MoveL2D src));
11511   effect(TEMP dst, USE src, TEMP tmp);
11512   ins_cost(85);
11513   format %{ &quot;MOVD   $dst,$src.lo\n\t&quot;
11514             &quot;MOVD   $tmp,$src.hi\n\t&quot;
11515             &quot;PUNPCKLDQ $dst,$tmp\t# MoveL2D_reg_reg_sse&quot; %}
11516   ins_encode %{
11517     __ movdl($dst$$XMMRegister, $src$$Register);
11518     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));
11519     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);
11520   %}
11521   ins_pipe( pipe_slow );
11522 %}
11523 
11524 
11525 // =======================================================================
11526 // fast clearing of an array
11527 instruct rep_stos(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11528   predicate(!((ClearArrayNode*)n)-&gt;is_large());
11529   match(Set dummy (ClearArray cnt base));
11530   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11531 
11532   format %{ $$template
11533     $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11534     $$emit$$&quot;CMP    InitArrayShortSize,rcx\n\t&quot;
11535     $$emit$$&quot;JG     LARGE\n\t&quot;
11536     $$emit$$&quot;SHL    ECX, 1\n\t&quot;
11537     $$emit$$&quot;DEC    ECX\n\t&quot;
11538     $$emit$$&quot;JS     DONE\t# Zero length\n\t&quot;
11539     $$emit$$&quot;MOV    EAX,(EDI,ECX,4)\t# LOOP\n\t&quot;
11540     $$emit$$&quot;DEC    ECX\n\t&quot;
11541     $$emit$$&quot;JGE    LOOP\n\t&quot;
11542     $$emit$$&quot;JMP    DONE\n\t&quot;
11543     $$emit$$&quot;# LARGE:\n\t&quot;
11544     if (UseFastStosb) {
11545        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11546        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11547     } else if (UseXMMForObjInit) {
11548        $$emit$$&quot;MOV     RDI,RAX\n\t&quot;
11549        $$emit$$&quot;VPXOR    YMM0,YMM0,YMM0\n\t&quot;
11550        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11551        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11552        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11553        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11554        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11555        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11556        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11557        $$emit$$&quot;JGE     L_loop\n\t&quot;
11558        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11559        $$emit$$&quot;JL      L_tail\n\t&quot;
11560        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11561        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11562        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11563        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11564        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11565        $$emit$$&quot;JLE     L_end\n\t&quot;
11566        $$emit$$&quot;DEC     RCX\n\t&quot;
11567        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11568        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11569        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11570        $$emit$$&quot;DEC     RCX\n\t&quot;
11571        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11572        $$emit$$&quot;# L_end:\n\t&quot;
11573     } else {
11574        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11575        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11576     }
11577     $$emit$$&quot;# DONE&quot;
11578   %}
11579   ins_encode %{
11580     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11581                  $tmp$$XMMRegister, false);
11582   %}
11583   ins_pipe( pipe_slow );
11584 %}
11585 
11586 instruct rep_stos_large(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11587   predicate(((ClearArrayNode*)n)-&gt;is_large());
11588   match(Set dummy (ClearArray cnt base));
11589   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11590   format %{ $$template
11591     if (UseFastStosb) {
11592        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11593        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11594        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11595     } else if (UseXMMForObjInit) {
11596        $$emit$$&quot;MOV     RDI,RAX\t# ClearArray:\n\t&quot;
11597        $$emit$$&quot;VPXOR   YMM0,YMM0,YMM0\n\t&quot;
11598        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11599        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11600        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11601        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11602        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11603        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11604        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11605        $$emit$$&quot;JGE     L_loop\n\t&quot;
11606        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11607        $$emit$$&quot;JL      L_tail\n\t&quot;
11608        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11609        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11610        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11611        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11612        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11613        $$emit$$&quot;JLE     L_end\n\t&quot;
11614        $$emit$$&quot;DEC     RCX\n\t&quot;
11615        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11616        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11617        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11618        $$emit$$&quot;DEC     RCX\n\t&quot;
11619        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11620        $$emit$$&quot;# L_end:\n\t&quot;
11621     } else {
11622        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11623        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11624        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11625     }
11626     $$emit$$&quot;# DONE&quot;
11627   %}
11628   ins_encode %{
11629     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11630                  $tmp$$XMMRegister, true);
11631   %}
11632   ins_pipe( pipe_slow );
11633 %}
11634 
11635 instruct string_compareL(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11636                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11637   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11638   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11639   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11640 
11641   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11642   ins_encode %{
11643     __ string_compare($str1$$Register, $str2$$Register,
11644                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11645                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11646   %}
11647   ins_pipe( pipe_slow );
11648 %}
11649 
11650 instruct string_compareU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11651                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11652   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11653   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11654   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11655 
11656   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11657   ins_encode %{
11658     __ string_compare($str1$$Register, $str2$$Register,
11659                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11660                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11661   %}
11662   ins_pipe( pipe_slow );
11663 %}
11664 
11665 instruct string_compareLU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11666                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11667   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11668   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11669   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11670 
11671   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11672   ins_encode %{
11673     __ string_compare($str1$$Register, $str2$$Register,
11674                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11675                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11676   %}
11677   ins_pipe( pipe_slow );
11678 %}
11679 
11680 instruct string_compareUL(eSIRegP str1, eDXRegI cnt1, eDIRegP str2, eCXRegI cnt2,
11681                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11682   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11683   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11684   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11685 
11686   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11687   ins_encode %{
11688     __ string_compare($str2$$Register, $str1$$Register,
11689                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11690                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11691   %}
11692   ins_pipe( pipe_slow );
11693 %}
11694 
11695 // fast string equals
11696 instruct string_equals(eDIRegP str1, eSIRegP str2, eCXRegI cnt, eAXRegI result,
11697                        regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr) %{
11698   match(Set result (StrEquals (Binary str1 str2) cnt));
11699   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11700 
11701   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11702   ins_encode %{
11703     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11704                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11705                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11706   %}
11707 
11708   ins_pipe( pipe_slow );
11709 %}
11710 
11711 // fast search of substring with known size.
11712 instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11713                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11714   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11715   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11716   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11717 
11718   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11719   ins_encode %{
11720     int icnt2 = (int)$int_cnt2$$constant;
11721     if (icnt2 &gt;= 16) {
11722       // IndexOf for constant substrings with size &gt;= 16 elements
11723       // which don&#39;t need to be loaded through stack.
11724       __ string_indexofC8($str1$$Register, $str2$$Register,
11725                           $cnt1$$Register, $cnt2$$Register,
11726                           icnt2, $result$$Register,
11727                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11728     } else {
11729       // Small strings are loaded through stack if they cross page boundary.
11730       __ string_indexof($str1$$Register, $str2$$Register,
11731                         $cnt1$$Register, $cnt2$$Register,
11732                         icnt2, $result$$Register,
11733                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11734     }
11735   %}
11736   ins_pipe( pipe_slow );
11737 %}
11738 
11739 // fast search of substring with known size.
11740 instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11741                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11742   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11743   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11744   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11745 
11746   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11747   ins_encode %{
11748     int icnt2 = (int)$int_cnt2$$constant;
11749     if (icnt2 &gt;= 8) {
11750       // IndexOf for constant substrings with size &gt;= 8 elements
11751       // which don&#39;t need to be loaded through stack.
11752       __ string_indexofC8($str1$$Register, $str2$$Register,
11753                           $cnt1$$Register, $cnt2$$Register,
11754                           icnt2, $result$$Register,
11755                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11756     } else {
11757       // Small strings are loaded through stack if they cross page boundary.
11758       __ string_indexof($str1$$Register, $str2$$Register,
11759                         $cnt1$$Register, $cnt2$$Register,
11760                         icnt2, $result$$Register,
11761                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11762     }
11763   %}
11764   ins_pipe( pipe_slow );
11765 %}
11766 
11767 // fast search of substring with known size.
11768 instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11769                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11770   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11771   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11772   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11773 
11774   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11775   ins_encode %{
11776     int icnt2 = (int)$int_cnt2$$constant;
11777     if (icnt2 &gt;= 8) {
11778       // IndexOf for constant substrings with size &gt;= 8 elements
11779       // which don&#39;t need to be loaded through stack.
11780       __ string_indexofC8($str1$$Register, $str2$$Register,
11781                           $cnt1$$Register, $cnt2$$Register,
11782                           icnt2, $result$$Register,
11783                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11784     } else {
11785       // Small strings are loaded through stack if they cross page boundary.
11786       __ string_indexof($str1$$Register, $str2$$Register,
11787                         $cnt1$$Register, $cnt2$$Register,
11788                         icnt2, $result$$Register,
11789                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11790     }
11791   %}
11792   ins_pipe( pipe_slow );
11793 %}
11794 
11795 instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11796                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11797   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11798   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11799   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11800 
11801   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11802   ins_encode %{
11803     __ string_indexof($str1$$Register, $str2$$Register,
11804                       $cnt1$$Register, $cnt2$$Register,
11805                       (-1), $result$$Register,
11806                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11807   %}
11808   ins_pipe( pipe_slow );
11809 %}
11810 
11811 instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11812                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11813   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11814   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11815   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11816 
11817   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11818   ins_encode %{
11819     __ string_indexof($str1$$Register, $str2$$Register,
11820                       $cnt1$$Register, $cnt2$$Register,
11821                       (-1), $result$$Register,
11822                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11823   %}
11824   ins_pipe( pipe_slow );
11825 %}
11826 
11827 instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11828                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11829   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11830   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11831   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11832 
11833   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11834   ins_encode %{
11835     __ string_indexof($str1$$Register, $str2$$Register,
11836                       $cnt1$$Register, $cnt2$$Register,
11837                       (-1), $result$$Register,
11838                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11839   %}
11840   ins_pipe( pipe_slow );
11841 %}
11842 
11843 instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
11844                               eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{
11845   predicate(UseSSE42Intrinsics);
11846   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11847   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11848   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11849   ins_encode %{
11850     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11851                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);
11852   %}
11853   ins_pipe( pipe_slow );
11854 %}
11855 
11856 // fast array equals
11857 instruct array_equalsB(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11858                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11859 %{
11860   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11861   match(Set result (AryEq ary1 ary2));
11862   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11863   //ins_cost(300);
11864 
11865   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11866   ins_encode %{
11867     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11868                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11869                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11870   %}
11871   ins_pipe( pipe_slow );
11872 %}
11873 
11874 instruct array_equalsC(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11875                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11876 %{
11877   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11878   match(Set result (AryEq ary1 ary2));
11879   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11880   //ins_cost(300);
11881 
11882   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11883   ins_encode %{
11884     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11885                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11886                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11887   %}
11888   ins_pipe( pipe_slow );
11889 %}
11890 
11891 instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,
11892                       regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)
11893 %{
11894   match(Set result (HasNegatives ary1 len));
11895   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11896 
11897   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11898   ins_encode %{
11899     __ has_negatives($ary1$$Register, $len$$Register,
11900                      $result$$Register, $tmp3$$Register,
11901                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11902   %}
11903   ins_pipe( pipe_slow );
11904 %}
11905 
11906 // fast char[] to byte[] compression
11907 instruct string_compress(eSIRegP src, eDIRegP dst, eDXRegI len, regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11908                          eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11909   match(Set result (StrCompressedCopy src (Binary dst len)));
11910   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11911 
11912   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11913   ins_encode %{
11914     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11915                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11916                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11917   %}
11918   ins_pipe( pipe_slow );
11919 %}
11920 
11921 // fast byte[] to char[] inflation
11922 instruct string_inflate(Universe dummy, eSIRegP src, eDIRegP dst, eDXRegI len,
11923                         regD tmp1, eCXRegI tmp2, eFlagsReg cr) %{
11924   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11925   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11926 
11927   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11928   ins_encode %{
11929     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11930                           $tmp1$$XMMRegister, $tmp2$$Register);
11931   %}
11932   ins_pipe( pipe_slow );
11933 %}
11934 
11935 // encode char[] to byte[] in ISO_8859_1
11936 instruct encode_iso_array(eSIRegP src, eDIRegP dst, eDXRegI len,
11937                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11938                           eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11939   match(Set result (EncodeISOArray src (Binary dst len)));
11940   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11941 
11942   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL ECX, EDX, $tmp1, $tmp2, $tmp3, $tmp4, ESI, EDI &quot; %}
11943   ins_encode %{
11944     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11945                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11946                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11947   %}
11948   ins_pipe( pipe_slow );
11949 %}
11950 
11951 
11952 //----------Control Flow Instructions------------------------------------------
11953 // Signed compare Instructions
11954 instruct compI_eReg(eFlagsReg cr, rRegI op1, rRegI op2) %{
11955   match(Set cr (CmpI op1 op2));
11956   effect( DEF cr, USE op1, USE op2 );
11957   format %{ &quot;CMP    $op1,$op2&quot; %}
11958   opcode(0x3B);  /* Opcode 3B /r */
11959   ins_encode( OpcP, RegReg( op1, op2) );
11960   ins_pipe( ialu_cr_reg_reg );
11961 %}
11962 
11963 instruct compI_eReg_imm(eFlagsReg cr, rRegI op1, immI op2) %{
11964   match(Set cr (CmpI op1 op2));
11965   effect( DEF cr, USE op1 );
11966   format %{ &quot;CMP    $op1,$op2&quot; %}
11967   opcode(0x81,0x07);  /* Opcode 81 /7 */
11968   // ins_encode( RegImm( op1, op2) );  /* Was CmpImm */
11969   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
11970   ins_pipe( ialu_cr_reg_imm );
11971 %}
11972 
11973 // Cisc-spilled version of cmpI_eReg
11974 instruct compI_eReg_mem(eFlagsReg cr, rRegI op1, memory op2) %{
11975   match(Set cr (CmpI op1 (LoadI op2)));
11976 
11977   format %{ &quot;CMP    $op1,$op2&quot; %}
11978   ins_cost(500);
11979   opcode(0x3B);  /* Opcode 3B /r */
11980   ins_encode( OpcP, RegMem( op1, op2) );
11981   ins_pipe( ialu_cr_reg_mem );
11982 %}
11983 
11984 instruct testI_reg( eFlagsReg cr, rRegI src, immI0 zero ) %{
11985   match(Set cr (CmpI src zero));
11986   effect( DEF cr, USE src );
11987 
11988   format %{ &quot;TEST   $src,$src&quot; %}
11989   opcode(0x85);
11990   ins_encode( OpcP, RegReg( src, src ) );
11991   ins_pipe( ialu_cr_reg_imm );
11992 %}
11993 
11994 instruct testI_reg_imm( eFlagsReg cr, rRegI src, immI con, immI0 zero ) %{
11995   match(Set cr (CmpI (AndI src con) zero));
11996 
11997   format %{ &quot;TEST   $src,$con&quot; %}
11998   opcode(0xF7,0x00);
11999   ins_encode( OpcP, RegOpc(src), Con32(con) );
12000   ins_pipe( ialu_cr_reg_imm );
12001 %}
12002 
12003 instruct testI_reg_mem( eFlagsReg cr, rRegI src, memory mem, immI0 zero ) %{
12004   match(Set cr (CmpI (AndI src mem) zero));
12005 
12006   format %{ &quot;TEST   $src,$mem&quot; %}
12007   opcode(0x85);
12008   ins_encode( OpcP, RegMem( src, mem ) );
12009   ins_pipe( ialu_cr_reg_mem );
12010 %}
12011 
12012 // Unsigned compare Instructions; really, same as signed except they
12013 // produce an eFlagsRegU instead of eFlagsReg.
12014 instruct compU_eReg(eFlagsRegU cr, rRegI op1, rRegI op2) %{
12015   match(Set cr (CmpU op1 op2));
12016 
12017   format %{ &quot;CMPu   $op1,$op2&quot; %}
12018   opcode(0x3B);  /* Opcode 3B /r */
12019   ins_encode( OpcP, RegReg( op1, op2) );
12020   ins_pipe( ialu_cr_reg_reg );
12021 %}
12022 
12023 instruct compU_eReg_imm(eFlagsRegU cr, rRegI op1, immI op2) %{
12024   match(Set cr (CmpU op1 op2));
12025 
12026   format %{ &quot;CMPu   $op1,$op2&quot; %}
12027   opcode(0x81,0x07);  /* Opcode 81 /7 */
12028   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12029   ins_pipe( ialu_cr_reg_imm );
12030 %}
12031 
12032 // // Cisc-spilled version of cmpU_eReg
12033 instruct compU_eReg_mem(eFlagsRegU cr, rRegI op1, memory op2) %{
12034   match(Set cr (CmpU op1 (LoadI op2)));
12035 
12036   format %{ &quot;CMPu   $op1,$op2&quot; %}
12037   ins_cost(500);
12038   opcode(0x3B);  /* Opcode 3B /r */
12039   ins_encode( OpcP, RegMem( op1, op2) );
12040   ins_pipe( ialu_cr_reg_mem );
12041 %}
12042 
12043 // // Cisc-spilled version of cmpU_eReg
12044 //instruct compU_mem_eReg(eFlagsRegU cr, memory op1, rRegI op2) %{
12045 //  match(Set cr (CmpU (LoadI op1) op2));
12046 //
12047 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12048 //  ins_cost(500);
12049 //  opcode(0x39);  /* Opcode 39 /r */
12050 //  ins_encode( OpcP, RegMem( op1, op2) );
12051 //%}
12052 
12053 instruct testU_reg( eFlagsRegU cr, rRegI src, immI0 zero ) %{
12054   match(Set cr (CmpU src zero));
12055 
12056   format %{ &quot;TESTu  $src,$src&quot; %}
12057   opcode(0x85);
12058   ins_encode( OpcP, RegReg( src, src ) );
12059   ins_pipe( ialu_cr_reg_imm );
12060 %}
12061 
12062 // Unsigned pointer compare Instructions
12063 instruct compP_eReg(eFlagsRegU cr, eRegP op1, eRegP op2) %{
12064   match(Set cr (CmpP op1 op2));
12065 
12066   format %{ &quot;CMPu   $op1,$op2&quot; %}
12067   opcode(0x3B);  /* Opcode 3B /r */
12068   ins_encode( OpcP, RegReg( op1, op2) );
12069   ins_pipe( ialu_cr_reg_reg );
12070 %}
12071 
12072 instruct compP_eReg_imm(eFlagsRegU cr, eRegP op1, immP op2) %{
12073   match(Set cr (CmpP op1 op2));
12074 
12075   format %{ &quot;CMPu   $op1,$op2&quot; %}
12076   opcode(0x81,0x07);  /* Opcode 81 /7 */
12077   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12078   ins_pipe( ialu_cr_reg_imm );
12079 %}
12080 
12081 // // Cisc-spilled version of cmpP_eReg
12082 instruct compP_eReg_mem(eFlagsRegU cr, eRegP op1, memory op2) %{
12083   match(Set cr (CmpP op1 (LoadP op2)));
12084 
12085   format %{ &quot;CMPu   $op1,$op2&quot; %}
12086   ins_cost(500);
12087   opcode(0x3B);  /* Opcode 3B /r */
12088   ins_encode( OpcP, RegMem( op1, op2) );
12089   ins_pipe( ialu_cr_reg_mem );
12090 %}
12091 
12092 // // Cisc-spilled version of cmpP_eReg
12093 //instruct compP_mem_eReg(eFlagsRegU cr, memory op1, eRegP op2) %{
12094 //  match(Set cr (CmpP (LoadP op1) op2));
12095 //
12096 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12097 //  ins_cost(500);
12098 //  opcode(0x39);  /* Opcode 39 /r */
12099 //  ins_encode( OpcP, RegMem( op1, op2) );
12100 //%}
12101 
12102 // Compare raw pointer (used in out-of-heap check).
12103 // Only works because non-oop pointers must be raw pointers
12104 // and raw pointers have no anti-dependencies.
12105 instruct compP_mem_eReg( eFlagsRegU cr, eRegP op1, memory op2 ) %{
12106   predicate( n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none );
12107   match(Set cr (CmpP op1 (LoadP op2)));
12108 
12109   format %{ &quot;CMPu   $op1,$op2&quot; %}
12110   opcode(0x3B);  /* Opcode 3B /r */
12111   ins_encode( OpcP, RegMem( op1, op2) );
12112   ins_pipe( ialu_cr_reg_mem );
12113 %}
12114 
12115 //
12116 // This will generate a signed flags result. This should be ok
12117 // since any compare to a zero should be eq/neq.
12118 instruct testP_reg( eFlagsReg cr, eRegP src, immP0 zero ) %{
12119   match(Set cr (CmpP src zero));
12120 
12121   format %{ &quot;TEST   $src,$src&quot; %}
12122   opcode(0x85);
12123   ins_encode( OpcP, RegReg( src, src ) );
12124   ins_pipe( ialu_cr_reg_imm );
12125 %}
12126 
12127 // Cisc-spilled version of testP_reg
12128 // This will generate a signed flags result. This should be ok
12129 // since any compare to a zero should be eq/neq.
12130 instruct testP_Reg_mem( eFlagsReg cr, memory op, immI0 zero ) %{
12131   match(Set cr (CmpP (LoadP op) zero));
12132 
12133   format %{ &quot;TEST   $op,0xFFFFFFFF&quot; %}
12134   ins_cost(500);
12135   opcode(0xF7);               /* Opcode F7 /0 */
12136   ins_encode( OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF) );
12137   ins_pipe( ialu_cr_reg_imm );
12138 %}
12139 
12140 // Yanked all unsigned pointer compare operations.
12141 // Pointer compares are done with CmpP which is already unsigned.
12142 
12143 //----------Max and Min--------------------------------------------------------
12144 // Min Instructions
12145 ////
12146 //   *** Min and Max using the conditional move are slower than the
12147 //   *** branch version on a Pentium III.
12148 // // Conditional move for min
12149 //instruct cmovI_reg_lt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12150 //  effect( USE_DEF op2, USE op1, USE cr );
12151 //  format %{ &quot;CMOVlt $op2,$op1\t! min&quot; %}
12152 //  opcode(0x4C,0x0F);
12153 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12154 //  ins_pipe( pipe_cmov_reg );
12155 //%}
12156 //
12157 //// Min Register with Register (P6 version)
12158 //instruct minI_eReg_p6( rRegI op1, rRegI op2 ) %{
12159 //  predicate(VM_Version::supports_cmov() );
12160 //  match(Set op2 (MinI op1 op2));
12161 //  ins_cost(200);
12162 //  expand %{
12163 //    eFlagsReg cr;
12164 //    compI_eReg(cr,op1,op2);
12165 //    cmovI_reg_lt(op2,op1,cr);
12166 //  %}
12167 //%}
12168 
12169 // Min Register with Register (generic version)
12170 instruct minI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12171   match(Set dst (MinI dst src));
12172   effect(KILL flags);
12173   ins_cost(300);
12174 
12175   format %{ &quot;MIN    $dst,$src&quot; %}
12176   opcode(0xCC);
12177   ins_encode( min_enc(dst,src) );
12178   ins_pipe( pipe_slow );
12179 %}
12180 
12181 // Max Register with Register
12182 //   *** Min and Max using the conditional move are slower than the
12183 //   *** branch version on a Pentium III.
12184 // // Conditional move for max
12185 //instruct cmovI_reg_gt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12186 //  effect( USE_DEF op2, USE op1, USE cr );
12187 //  format %{ &quot;CMOVgt $op2,$op1\t! max&quot; %}
12188 //  opcode(0x4F,0x0F);
12189 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12190 //  ins_pipe( pipe_cmov_reg );
12191 //%}
12192 //
12193 // // Max Register with Register (P6 version)
12194 //instruct maxI_eReg_p6( rRegI op1, rRegI op2 ) %{
12195 //  predicate(VM_Version::supports_cmov() );
12196 //  match(Set op2 (MaxI op1 op2));
12197 //  ins_cost(200);
12198 //  expand %{
12199 //    eFlagsReg cr;
12200 //    compI_eReg(cr,op1,op2);
12201 //    cmovI_reg_gt(op2,op1,cr);
12202 //  %}
12203 //%}
12204 
12205 // Max Register with Register (generic version)
12206 instruct maxI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12207   match(Set dst (MaxI dst src));
12208   effect(KILL flags);
12209   ins_cost(300);
12210 
12211   format %{ &quot;MAX    $dst,$src&quot; %}
12212   opcode(0xCC);
12213   ins_encode( max_enc(dst,src) );
12214   ins_pipe( pipe_slow );
12215 %}
12216 
12217 // ============================================================================
12218 // Counted Loop limit node which represents exact final iterator value.
12219 // Note: the resulting value should fit into integer range since
12220 // counted loops have limit check on overflow.
12221 instruct loopLimit_eReg(eAXRegI limit, nadxRegI init, immI stride, eDXRegI limit_hi, nadxRegI tmp, eFlagsReg flags) %{
12222   match(Set limit (LoopLimit (Binary init limit) stride));
12223   effect(TEMP limit_hi, TEMP tmp, KILL flags);
12224   ins_cost(300);
12225 
12226   format %{ &quot;loopLimit $init,$limit,$stride  # $limit = $init + $stride *( $limit - $init + $stride -1)/ $stride, kills $limit_hi&quot; %}
12227   ins_encode %{
12228     int strd = (int)$stride$$constant;
12229     assert(strd != 1 &amp;&amp; strd != -1, &quot;sanity&quot;);
12230     int m1 = (strd &gt; 0) ? 1 : -1;
12231     // Convert limit to long (EAX:EDX)
12232     __ cdql();
12233     // Convert init to long (init:tmp)
12234     __ movl($tmp$$Register, $init$$Register);
12235     __ sarl($tmp$$Register, 31);
12236     // $limit - $init
12237     __ subl($limit$$Register, $init$$Register);
12238     __ sbbl($limit_hi$$Register, $tmp$$Register);
12239     // + ($stride - 1)
12240     if (strd &gt; 0) {
12241       __ addl($limit$$Register, (strd - 1));
12242       __ adcl($limit_hi$$Register, 0);
12243       __ movl($tmp$$Register, strd);
12244     } else {
12245       __ addl($limit$$Register, (strd + 1));
12246       __ adcl($limit_hi$$Register, -1);
12247       __ lneg($limit_hi$$Register, $limit$$Register);
12248       __ movl($tmp$$Register, -strd);
12249     }
12250     // signed devision: (EAX:EDX) / pos_stride
12251     __ idivl($tmp$$Register);
12252     if (strd &lt; 0) {
12253       // restore sign
12254       __ negl($tmp$$Register);
12255     }
12256     // (EAX) * stride
12257     __ mull($tmp$$Register);
12258     // + init (ignore upper bits)
12259     __ addl($limit$$Register, $init$$Register);
12260   %}
12261   ins_pipe( pipe_slow );
12262 %}
12263 
12264 // ============================================================================
12265 // Branch Instructions
12266 // Jump Table
12267 instruct jumpXtnd(rRegI switch_val) %{
12268   match(Jump switch_val);
12269   ins_cost(350);
12270   format %{  &quot;JMP    [$constantaddress](,$switch_val,1)\n\t&quot; %}
12271   ins_encode %{
12272     // Jump to Address(table_base + switch_reg)
12273     Address index(noreg, $switch_val$$Register, Address::times_1);
12274     __ jump(ArrayAddress($constantaddress, index));
12275   %}
12276   ins_pipe(pipe_jmp);
12277 %}
12278 
12279 // Jump Direct - Label defines a relative address from JMP+1
12280 instruct jmpDir(label labl) %{
12281   match(Goto);
12282   effect(USE labl);
12283 
12284   ins_cost(300);
12285   format %{ &quot;JMP    $labl&quot; %}
12286   size(5);
12287   ins_encode %{
12288     Label* L = $labl$$label;
12289     __ jmp(*L, false); // Always long jump
12290   %}
12291   ins_pipe( pipe_jmp );
12292 %}
12293 
12294 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12295 instruct jmpCon(cmpOp cop, eFlagsReg cr, label labl) %{
12296   match(If cop cr);
12297   effect(USE labl);
12298 
12299   ins_cost(300);
12300   format %{ &quot;J$cop    $labl&quot; %}
12301   size(6);
12302   ins_encode %{
12303     Label* L = $labl$$label;
12304     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12305   %}
12306   ins_pipe( pipe_jcc );
12307 %}
12308 
12309 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12310 instruct jmpLoopEnd(cmpOp cop, eFlagsReg cr, label labl) %{
12311   predicate(!n-&gt;has_vector_mask_set());
12312   match(CountedLoopEnd cop cr);
12313   effect(USE labl);
12314 
12315   ins_cost(300);
12316   format %{ &quot;J$cop    $labl\t# Loop end&quot; %}
12317   size(6);
12318   ins_encode %{
12319     Label* L = $labl$$label;
12320     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12321   %}
12322   ins_pipe( pipe_jcc );
12323 %}
12324 
12325 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12326 instruct jmpLoopEndU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12327   predicate(!n-&gt;has_vector_mask_set());
12328   match(CountedLoopEnd cop cmp);
12329   effect(USE labl);
12330 
12331   ins_cost(300);
12332   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12333   size(6);
12334   ins_encode %{
12335     Label* L = $labl$$label;
12336     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12337   %}
12338   ins_pipe( pipe_jcc );
12339 %}
12340 
12341 instruct jmpLoopEndUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12342   predicate(!n-&gt;has_vector_mask_set());
12343   match(CountedLoopEnd cop cmp);
12344   effect(USE labl);
12345 
12346   ins_cost(200);
12347   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12348   size(6);
12349   ins_encode %{
12350     Label* L = $labl$$label;
12351     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12352   %}
12353   ins_pipe( pipe_jcc );
12354 %}
12355 
12356 // mask version
12357 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12358 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, eFlagsReg cr, label labl) %{
12359   predicate(n-&gt;has_vector_mask_set());
12360   match(CountedLoopEnd cop cr);
12361   effect(USE labl);
12362 
12363   ins_cost(400);
12364   format %{ &quot;J$cop    $labl\t# Loop end\n\t&quot;
12365             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12366   size(10);
12367   ins_encode %{
12368     Label* L = $labl$$label;
12369     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12370     __ restorevectmask();
12371   %}
12372   ins_pipe( pipe_jcc );
12373 %}
12374 
12375 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12376 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12377   predicate(n-&gt;has_vector_mask_set());
12378   match(CountedLoopEnd cop cmp);
12379   effect(USE labl);
12380 
12381   ins_cost(400);
12382   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12383             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12384   size(10);
12385   ins_encode %{
12386     Label* L = $labl$$label;
12387     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12388     __ restorevectmask();
12389   %}
12390   ins_pipe( pipe_jcc );
12391 %}
12392 
12393 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12394   predicate(n-&gt;has_vector_mask_set());
12395   match(CountedLoopEnd cop cmp);
12396   effect(USE labl);
12397 
12398   ins_cost(300);
12399   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12400             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12401   size(10);
12402   ins_encode %{
12403     Label* L = $labl$$label;
12404     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12405     __ restorevectmask();
12406   %}
12407   ins_pipe( pipe_jcc );
12408 %}
12409 
12410 // Jump Direct Conditional - using unsigned comparison
12411 instruct jmpConU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12412   match(If cop cmp);
12413   effect(USE labl);
12414 
12415   ins_cost(300);
12416   format %{ &quot;J$cop,u  $labl&quot; %}
12417   size(6);
12418   ins_encode %{
12419     Label* L = $labl$$label;
12420     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12421   %}
12422   ins_pipe(pipe_jcc);
12423 %}
12424 
12425 instruct jmpConUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12426   match(If cop cmp);
12427   effect(USE labl);
12428 
12429   ins_cost(200);
12430   format %{ &quot;J$cop,u  $labl&quot; %}
12431   size(6);
12432   ins_encode %{
12433     Label* L = $labl$$label;
12434     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12435   %}
12436   ins_pipe(pipe_jcc);
12437 %}
12438 
12439 instruct jmpConUCF2(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12440   match(If cop cmp);
12441   effect(USE labl);
12442 
12443   ins_cost(200);
12444   format %{ $$template
12445     if ($cop$$cmpcode == Assembler::notEqual) {
12446       $$emit$$&quot;JP,u   $labl\n\t&quot;
12447       $$emit$$&quot;J$cop,u   $labl&quot;
12448     } else {
12449       $$emit$$&quot;JP,u   done\n\t&quot;
12450       $$emit$$&quot;J$cop,u   $labl\n\t&quot;
12451       $$emit$$&quot;done:&quot;
12452     }
12453   %}
12454   ins_encode %{
12455     Label* l = $labl$$label;
12456     if ($cop$$cmpcode == Assembler::notEqual) {
12457       __ jcc(Assembler::parity, *l, false);
12458       __ jcc(Assembler::notEqual, *l, false);
12459     } else if ($cop$$cmpcode == Assembler::equal) {
12460       Label done;
12461       __ jccb(Assembler::parity, done);
12462       __ jcc(Assembler::equal, *l, false);
12463       __ bind(done);
12464     } else {
12465        ShouldNotReachHere();
12466     }
12467   %}
12468   ins_pipe(pipe_jcc);
12469 %}
12470 
12471 // ============================================================================
12472 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
12473 // array for an instance of the superklass.  Set a hidden internal cache on a
12474 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
12475 // NZ for a miss or zero for a hit.  The encoding ALSO sets flags.
12476 instruct partialSubtypeCheck( eDIRegP result, eSIRegP sub, eAXRegP super, eCXRegI rcx, eFlagsReg cr ) %{
12477   match(Set result (PartialSubtypeCheck sub super));
12478   effect( KILL rcx, KILL cr );
12479 
12480   ins_cost(1100);  // slightly larger than the next version
12481   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12482             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12483             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12484             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12485             &quot;JNE,s  miss\t\t# Missed: EDI not-zero\n\t&quot;
12486             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache\n\t&quot;
12487             &quot;XOR    $result,$result\t\t Hit: EDI zero\n\t&quot;
12488      &quot;miss:\t&quot; %}
12489 
12490   opcode(0x1); // Force a XOR of EDI
12491   ins_encode( enc_PartialSubtypeCheck() );
12492   ins_pipe( pipe_slow );
12493 %}
12494 
12495 instruct partialSubtypeCheck_vs_Zero( eFlagsReg cr, eSIRegP sub, eAXRegP super, eCXRegI rcx, eDIRegP result, immP0 zero ) %{
12496   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12497   effect( KILL rcx, KILL result );
12498 
12499   ins_cost(1000);
12500   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12501             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12502             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12503             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12504             &quot;JNE,s  miss\t\t# Missed: flags NZ\n\t&quot;
12505             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache, flags Z\n\t&quot;
12506      &quot;miss:\t&quot; %}
12507 
12508   opcode(0x0);  // No need to XOR EDI
12509   ins_encode( enc_PartialSubtypeCheck() );
12510   ins_pipe( pipe_slow );
12511 %}
12512 
12513 // ============================================================================
12514 // Branch Instructions -- short offset versions
12515 //
12516 // These instructions are used to replace jumps of a long offset (the default
12517 // match) with jumps of a shorter offset.  These instructions are all tagged
12518 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12519 // match rules in general matching.  Instead, the ADLC generates a conversion
12520 // method in the MachNode which can be used to do in-place replacement of the
12521 // long variant with the shorter variant.  The compiler will determine if a
12522 // branch can be taken by the is_short_branch_offset() predicate in the machine
12523 // specific code section of the file.
12524 
12525 // Jump Direct - Label defines a relative address from JMP+1
12526 instruct jmpDir_short(label labl) %{
12527   match(Goto);
12528   effect(USE labl);
12529 
12530   ins_cost(300);
12531   format %{ &quot;JMP,s  $labl&quot; %}
12532   size(2);
12533   ins_encode %{
12534     Label* L = $labl$$label;
12535     __ jmpb(*L);
12536   %}
12537   ins_pipe( pipe_jmp );
12538   ins_short_branch(1);
12539 %}
12540 
12541 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12542 instruct jmpCon_short(cmpOp cop, eFlagsReg cr, label labl) %{
12543   match(If cop cr);
12544   effect(USE labl);
12545 
12546   ins_cost(300);
12547   format %{ &quot;J$cop,s  $labl&quot; %}
12548   size(2);
12549   ins_encode %{
12550     Label* L = $labl$$label;
12551     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12552   %}
12553   ins_pipe( pipe_jcc );
12554   ins_short_branch(1);
12555 %}
12556 
12557 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12558 instruct jmpLoopEnd_short(cmpOp cop, eFlagsReg cr, label labl) %{
12559   match(CountedLoopEnd cop cr);
12560   effect(USE labl);
12561 
12562   ins_cost(300);
12563   format %{ &quot;J$cop,s  $labl\t# Loop end&quot; %}
12564   size(2);
12565   ins_encode %{
12566     Label* L = $labl$$label;
12567     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12568   %}
12569   ins_pipe( pipe_jcc );
12570   ins_short_branch(1);
12571 %}
12572 
12573 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12574 instruct jmpLoopEndU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12575   match(CountedLoopEnd cop cmp);
12576   effect(USE labl);
12577 
12578   ins_cost(300);
12579   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12580   size(2);
12581   ins_encode %{
12582     Label* L = $labl$$label;
12583     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12584   %}
12585   ins_pipe( pipe_jcc );
12586   ins_short_branch(1);
12587 %}
12588 
12589 instruct jmpLoopEndUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12590   match(CountedLoopEnd cop cmp);
12591   effect(USE labl);
12592 
12593   ins_cost(300);
12594   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12595   size(2);
12596   ins_encode %{
12597     Label* L = $labl$$label;
12598     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12599   %}
12600   ins_pipe( pipe_jcc );
12601   ins_short_branch(1);
12602 %}
12603 
12604 // Jump Direct Conditional - using unsigned comparison
12605 instruct jmpConU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12606   match(If cop cmp);
12607   effect(USE labl);
12608 
12609   ins_cost(300);
12610   format %{ &quot;J$cop,us $labl&quot; %}
12611   size(2);
12612   ins_encode %{
12613     Label* L = $labl$$label;
12614     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12615   %}
12616   ins_pipe( pipe_jcc );
12617   ins_short_branch(1);
12618 %}
12619 
12620 instruct jmpConUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12621   match(If cop cmp);
12622   effect(USE labl);
12623 
12624   ins_cost(300);
12625   format %{ &quot;J$cop,us $labl&quot; %}
12626   size(2);
12627   ins_encode %{
12628     Label* L = $labl$$label;
12629     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12630   %}
12631   ins_pipe( pipe_jcc );
12632   ins_short_branch(1);
12633 %}
12634 
12635 instruct jmpConUCF2_short(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12636   match(If cop cmp);
12637   effect(USE labl);
12638 
12639   ins_cost(300);
12640   format %{ $$template
12641     if ($cop$$cmpcode == Assembler::notEqual) {
12642       $$emit$$&quot;JP,u,s   $labl\n\t&quot;
12643       $$emit$$&quot;J$cop,u,s   $labl&quot;
12644     } else {
12645       $$emit$$&quot;JP,u,s   done\n\t&quot;
12646       $$emit$$&quot;J$cop,u,s  $labl\n\t&quot;
12647       $$emit$$&quot;done:&quot;
12648     }
12649   %}
12650   size(4);
12651   ins_encode %{
12652     Label* l = $labl$$label;
12653     if ($cop$$cmpcode == Assembler::notEqual) {
12654       __ jccb(Assembler::parity, *l);
12655       __ jccb(Assembler::notEqual, *l);
12656     } else if ($cop$$cmpcode == Assembler::equal) {
12657       Label done;
12658       __ jccb(Assembler::parity, done);
12659       __ jccb(Assembler::equal, *l);
12660       __ bind(done);
12661     } else {
12662        ShouldNotReachHere();
12663     }
12664   %}
12665   ins_pipe(pipe_jcc);
12666   ins_short_branch(1);
12667 %}
12668 
12669 // ============================================================================
12670 // Long Compare
12671 //
12672 // Currently we hold longs in 2 registers.  Comparing such values efficiently
12673 // is tricky.  The flavor of compare used depends on whether we are testing
12674 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
12675 // The GE test is the negated LT test.  The LE test can be had by commuting
12676 // the operands (yielding a GE test) and then negating; negate again for the
12677 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
12678 // NE test is negated from that.
12679 
12680 // Due to a shortcoming in the ADLC, it mixes up expressions like:
12681 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
12682 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
12683 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
12684 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
12685 // foo match ends up with the wrong leaf.  One fix is to not match both
12686 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
12687 // both forms beat the trinary form of long-compare and both are very useful
12688 // on Intel which has so few registers.
12689 
12690 // Manifest a CmpL result in an integer register.  Very painful.
12691 // This is the test to avoid.
12692 instruct cmpL3_reg_reg(eSIRegI dst, eRegL src1, eRegL src2, eFlagsReg flags ) %{
12693   match(Set dst (CmpL3 src1 src2));
12694   effect( KILL flags );
12695   ins_cost(1000);
12696   format %{ &quot;XOR    $dst,$dst\n\t&quot;
12697             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12698             &quot;JLT,s  m_one\n\t&quot;
12699             &quot;JGT,s  p_one\n\t&quot;
12700             &quot;CMP    $src1.lo,$src2.lo\n\t&quot;
12701             &quot;JB,s   m_one\n\t&quot;
12702             &quot;JEQ,s  done\n&quot;
12703     &quot;p_one:\tINC    $dst\n\t&quot;
12704             &quot;JMP,s  done\n&quot;
12705     &quot;m_one:\tDEC    $dst\n&quot;
12706      &quot;done:&quot; %}
12707   ins_encode %{
12708     Label p_one, m_one, done;
12709     __ xorptr($dst$$Register, $dst$$Register);
12710     __ cmpl(HIGH_FROM_LOW($src1$$Register), HIGH_FROM_LOW($src2$$Register));
12711     __ jccb(Assembler::less,    m_one);
12712     __ jccb(Assembler::greater, p_one);
12713     __ cmpl($src1$$Register, $src2$$Register);
12714     __ jccb(Assembler::below,   m_one);
12715     __ jccb(Assembler::equal,   done);
12716     __ bind(p_one);
12717     __ incrementl($dst$$Register);
12718     __ jmpb(done);
12719     __ bind(m_one);
12720     __ decrementl($dst$$Register);
12721     __ bind(done);
12722   %}
12723   ins_pipe( pipe_slow );
12724 %}
12725 
12726 //======
12727 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12728 // compares.  Can be used for LE or GT compares by reversing arguments.
12729 // NOT GOOD FOR EQ/NE tests.
12730 instruct cmpL_zero_flags_LTGE( flagsReg_long_LTGE flags, eRegL src, immL0 zero ) %{
12731   match( Set flags (CmpL src zero ));
12732   ins_cost(100);
12733   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12734   opcode(0x85);
12735   ins_encode( OpcP, RegReg_Hi2( src, src ) );
12736   ins_pipe( ialu_cr_reg_reg );
12737 %}
12738 
12739 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12740 // compares.  Can be used for LE or GT compares by reversing arguments.
12741 // NOT GOOD FOR EQ/NE tests.
12742 instruct cmpL_reg_flags_LTGE( flagsReg_long_LTGE flags, eRegL src1, eRegL src2, rRegI tmp ) %{
12743   match( Set flags (CmpL src1 src2 ));
12744   effect( TEMP tmp );
12745   ins_cost(300);
12746   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12747             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12748             &quot;SBB    $tmp,$src2.hi\t! Compute flags for long compare&quot; %}
12749   ins_encode( long_cmp_flags2( src1, src2, tmp ) );
12750   ins_pipe( ialu_cr_reg_reg );
12751 %}
12752 
12753 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
12754 // Just a wrapper for a normal branch, plus the predicate test.
12755 instruct cmpL_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, label labl) %{
12756   match(If cmp flags);
12757   effect(USE labl);
12758   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12759   expand %{
12760     jmpCon(cmp,flags,labl);    // JLT or JGE...
12761   %}
12762 %}
12763 
12764 //======
12765 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12766 // compares.  Can be used for LE or GT compares by reversing arguments.
12767 // NOT GOOD FOR EQ/NE tests.
12768 instruct cmpUL_zero_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src, immL0 zero) %{
12769   match(Set flags (CmpUL src zero));
12770   ins_cost(100);
12771   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12772   opcode(0x85);
12773   ins_encode(OpcP, RegReg_Hi2(src, src));
12774   ins_pipe(ialu_cr_reg_reg);
12775 %}
12776 
12777 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12778 // compares.  Can be used for LE or GT compares by reversing arguments.
12779 // NOT GOOD FOR EQ/NE tests.
12780 instruct cmpUL_reg_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src1, eRegL src2, rRegI tmp) %{
12781   match(Set flags (CmpUL src1 src2));
12782   effect(TEMP tmp);
12783   ins_cost(300);
12784   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12785             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12786             &quot;SBB    $tmp,$src2.hi\t! Compute flags for unsigned long compare&quot; %}
12787   ins_encode(long_cmp_flags2(src1, src2, tmp));
12788   ins_pipe(ialu_cr_reg_reg);
12789 %}
12790 
12791 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
12792 // Just a wrapper for a normal branch, plus the predicate test.
12793 instruct cmpUL_LTGE(cmpOpU cmp, flagsReg_ulong_LTGE flags, label labl) %{
12794   match(If cmp flags);
12795   effect(USE labl);
12796   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
12797   expand %{
12798     jmpCon(cmp, flags, labl);    // JLT or JGE...
12799   %}
12800 %}
12801 
12802 // Compare 2 longs and CMOVE longs.
12803 instruct cmovLL_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, eRegL src) %{
12804   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12805   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12806   ins_cost(400);
12807   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12808             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12809   opcode(0x0F,0x40);
12810   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12811   ins_pipe( pipe_cmov_reg_long );
12812 %}
12813 
12814 instruct cmovLL_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, load_long_memory src) %{
12815   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12816   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12817   ins_cost(500);
12818   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12819             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12820   opcode(0x0F,0x40);
12821   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
12822   ins_pipe( pipe_cmov_reg_long );
12823 %}
12824 
12825 // Compare 2 longs and CMOVE ints.
12826 instruct cmovII_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, rRegI src) %{
12827   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12828   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
12829   ins_cost(200);
12830   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12831   opcode(0x0F,0x40);
12832   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12833   ins_pipe( pipe_cmov_reg );
12834 %}
12835 
12836 instruct cmovII_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, memory src) %{
12837   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12838   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
12839   ins_cost(250);
12840   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12841   opcode(0x0F,0x40);
12842   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
12843   ins_pipe( pipe_cmov_mem );
12844 %}
12845 
12846 // Compare 2 longs and CMOVE ints.
12847 instruct cmovPP_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegP dst, eRegP src) %{
12848   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12849   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
12850   ins_cost(200);
12851   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12852   opcode(0x0F,0x40);
12853   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12854   ins_pipe( pipe_cmov_reg );
12855 %}
12856 
12857 // Compare 2 longs and CMOVE doubles
12858 instruct cmovDDPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regDPR dst, regDPR src) %{
12859   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12860   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12861   ins_cost(200);
12862   expand %{
12863     fcmovDPR_regS(cmp,flags,dst,src);
12864   %}
12865 %}
12866 
12867 // Compare 2 longs and CMOVE doubles
12868 instruct cmovDD_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regD dst, regD src) %{
12869   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12870   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12871   ins_cost(200);
12872   expand %{
12873     fcmovD_regS(cmp,flags,dst,src);
12874   %}
12875 %}
12876 
12877 instruct cmovFFPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regFPR dst, regFPR src) %{
12878   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12879   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12880   ins_cost(200);
12881   expand %{
12882     fcmovFPR_regS(cmp,flags,dst,src);
12883   %}
12884 %}
12885 
12886 instruct cmovFF_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regF dst, regF src) %{
12887   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12888   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12889   ins_cost(200);
12890   expand %{
12891     fcmovF_regS(cmp,flags,dst,src);
12892   %}
12893 %}
12894 
12895 //======
12896 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12897 instruct cmpL_zero_flags_EQNE( flagsReg_long_EQNE flags, eRegL src, immL0 zero, rRegI tmp ) %{
12898   match( Set flags (CmpL src zero ));
12899   effect(TEMP tmp);
12900   ins_cost(200);
12901   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12902             &quot;OR     $tmp,$src.hi\t! Long is EQ/NE 0?&quot; %}
12903   ins_encode( long_cmp_flags0( src, tmp ) );
12904   ins_pipe( ialu_reg_reg_long );
12905 %}
12906 
12907 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12908 instruct cmpL_reg_flags_EQNE( flagsReg_long_EQNE flags, eRegL src1, eRegL src2 ) %{
12909   match( Set flags (CmpL src1 src2 ));
12910   ins_cost(200+300);
12911   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12912             &quot;JNE,s  skip\n\t&quot;
12913             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12914      &quot;skip:\t&quot; %}
12915   ins_encode( long_cmp_flags1( src1, src2 ) );
12916   ins_pipe( ialu_cr_reg_reg );
12917 %}
12918 
12919 // Long compare reg == zero/reg OR reg != zero/reg
12920 // Just a wrapper for a normal branch, plus the predicate test.
12921 instruct cmpL_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, label labl) %{
12922   match(If cmp flags);
12923   effect(USE labl);
12924   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
12925   expand %{
12926     jmpCon(cmp,flags,labl);    // JEQ or JNE...
12927   %}
12928 %}
12929 
12930 //======
12931 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12932 instruct cmpUL_zero_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src, immL0 zero, rRegI tmp) %{
12933   match(Set flags (CmpUL src zero));
12934   effect(TEMP tmp);
12935   ins_cost(200);
12936   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12937             &quot;OR     $tmp,$src.hi\t! Unsigned long is EQ/NE 0?&quot; %}
12938   ins_encode(long_cmp_flags0(src, tmp));
12939   ins_pipe(ialu_reg_reg_long);
12940 %}
12941 
12942 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12943 instruct cmpUL_reg_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src1, eRegL src2) %{
12944   match(Set flags (CmpUL src1 src2));
12945   ins_cost(200+300);
12946   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12947             &quot;JNE,s  skip\n\t&quot;
12948             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12949      &quot;skip:\t&quot; %}
12950   ins_encode(long_cmp_flags1(src1, src2));
12951   ins_pipe(ialu_cr_reg_reg);
12952 %}
12953 
12954 // Unsigned long compare reg == zero/reg OR reg != zero/reg
12955 // Just a wrapper for a normal branch, plus the predicate test.
12956 instruct cmpUL_EQNE(cmpOpU cmp, flagsReg_ulong_EQNE flags, label labl) %{
12957   match(If cmp flags);
12958   effect(USE labl);
12959   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne);
12960   expand %{
12961     jmpCon(cmp, flags, labl);    // JEQ or JNE...
12962   %}
12963 %}
12964 
12965 // Compare 2 longs and CMOVE longs.
12966 instruct cmovLL_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, eRegL src) %{
12967   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12968   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12969   ins_cost(400);
12970   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12971             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12972   opcode(0x0F,0x40);
12973   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12974   ins_pipe( pipe_cmov_reg_long );
12975 %}
12976 
12977 instruct cmovLL_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, load_long_memory src) %{
12978   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12979   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12980   ins_cost(500);
12981   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12982             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12983   opcode(0x0F,0x40);
12984   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
12985   ins_pipe( pipe_cmov_reg_long );
12986 %}
12987 
12988 // Compare 2 longs and CMOVE ints.
12989 instruct cmovII_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, rRegI src) %{
12990   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12991   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
12992   ins_cost(200);
12993   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12994   opcode(0x0F,0x40);
12995   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12996   ins_pipe( pipe_cmov_reg );
12997 %}
12998 
12999 instruct cmovII_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, memory src) %{
13000   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13001   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13002   ins_cost(250);
13003   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13004   opcode(0x0F,0x40);
13005   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13006   ins_pipe( pipe_cmov_mem );
13007 %}
13008 
13009 // Compare 2 longs and CMOVE ints.
13010 instruct cmovPP_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegP dst, eRegP src) %{
13011   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13012   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13013   ins_cost(200);
13014   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13015   opcode(0x0F,0x40);
13016   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13017   ins_pipe( pipe_cmov_reg );
13018 %}
13019 
13020 // Compare 2 longs and CMOVE doubles
13021 instruct cmovDDPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regDPR dst, regDPR src) %{
13022   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13023   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13024   ins_cost(200);
13025   expand %{
13026     fcmovDPR_regS(cmp,flags,dst,src);
13027   %}
13028 %}
13029 
13030 // Compare 2 longs and CMOVE doubles
13031 instruct cmovDD_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regD dst, regD src) %{
13032   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13033   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13034   ins_cost(200);
13035   expand %{
13036     fcmovD_regS(cmp,flags,dst,src);
13037   %}
13038 %}
13039 
13040 instruct cmovFFPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regFPR dst, regFPR src) %{
13041   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13042   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13043   ins_cost(200);
13044   expand %{
13045     fcmovFPR_regS(cmp,flags,dst,src);
13046   %}
13047 %}
13048 
13049 instruct cmovFF_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regF dst, regF src) %{
13050   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13051   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13052   ins_cost(200);
13053   expand %{
13054     fcmovF_regS(cmp,flags,dst,src);
13055   %}
13056 %}
13057 
13058 //======
13059 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13060 // Same as cmpL_reg_flags_LEGT except must negate src
13061 instruct cmpL_zero_flags_LEGT( flagsReg_long_LEGT flags, eRegL src, immL0 zero, rRegI tmp ) %{
13062   match( Set flags (CmpL src zero ));
13063   effect( TEMP tmp );
13064   ins_cost(300);
13065   format %{ &quot;XOR    $tmp,$tmp\t# Long compare for -$src &lt; 0, use commuted test\n\t&quot;
13066             &quot;CMP    $tmp,$src.lo\n\t&quot;
13067             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13068   ins_encode( long_cmp_flags3(src, tmp) );
13069   ins_pipe( ialu_reg_reg_long );
13070 %}
13071 
13072 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13073 // Same as cmpL_reg_flags_LTGE except operands swapped.  Swapping operands
13074 // requires a commuted test to get the same result.
13075 instruct cmpL_reg_flags_LEGT( flagsReg_long_LEGT flags, eRegL src1, eRegL src2, rRegI tmp ) %{
13076   match( Set flags (CmpL src1 src2 ));
13077   effect( TEMP tmp );
13078   ins_cost(300);
13079   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Long compare, swapped operands, use with commuted test\n\t&quot;
13080             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13081             &quot;SBB    $tmp,$src1.hi\t! Compute flags for long compare&quot; %}
13082   ins_encode( long_cmp_flags2( src2, src1, tmp ) );
13083   ins_pipe( ialu_cr_reg_reg );
13084 %}
13085 
13086 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
13087 // Just a wrapper for a normal branch, plus the predicate test
13088 instruct cmpL_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, label labl) %{
13089   match(If cmp flags);
13090   effect(USE labl);
13091   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le );
13092   ins_cost(300);
13093   expand %{
13094     jmpCon(cmp,flags,labl);    // JGT or JLE...
13095   %}
13096 %}
13097 
13098 //======
13099 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13100 // Same as cmpUL_reg_flags_LEGT except must negate src
13101 instruct cmpUL_zero_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src, immL0 zero, rRegI tmp) %{
13102   match(Set flags (CmpUL src zero));
13103   effect(TEMP tmp);
13104   ins_cost(300);
13105   format %{ &quot;XOR    $tmp,$tmp\t# Unsigned long compare for -$src &lt; 0, use commuted test\n\t&quot;
13106             &quot;CMP    $tmp,$src.lo\n\t&quot;
13107             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13108   ins_encode(long_cmp_flags3(src, tmp));
13109   ins_pipe(ialu_reg_reg_long);
13110 %}
13111 
13112 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13113 // Same as cmpUL_reg_flags_LTGE except operands swapped.  Swapping operands
13114 // requires a commuted test to get the same result.
13115 instruct cmpUL_reg_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src1, eRegL src2, rRegI tmp) %{
13116   match(Set flags (CmpUL src1 src2));
13117   effect(TEMP tmp);
13118   ins_cost(300);
13119   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Unsigned long compare, swapped operands, use with commuted test\n\t&quot;
13120             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13121             &quot;SBB    $tmp,$src1.hi\t! Compute flags for unsigned long compare&quot; %}
13122   ins_encode(long_cmp_flags2( src2, src1, tmp));
13123   ins_pipe(ialu_cr_reg_reg);
13124 %}
13125 
13126 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
13127 // Just a wrapper for a normal branch, plus the predicate test
13128 instruct cmpUL_LEGT(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, label labl) %{
13129   match(If cmp flags);
13130   effect(USE labl);
13131   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le);
13132   ins_cost(300);
13133   expand %{
13134     jmpCon(cmp, flags, labl);    // JGT or JLE...
13135   %}
13136 %}
13137 
13138 // Compare 2 longs and CMOVE longs.
13139 instruct cmovLL_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, eRegL src) %{
13140   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
13141   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13142   ins_cost(400);
13143   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13144             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
13145   opcode(0x0F,0x40);
13146   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
13147   ins_pipe( pipe_cmov_reg_long );
13148 %}
13149 
13150 instruct cmovLL_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, load_long_memory src) %{
13151   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
13152   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13153   ins_cost(500);
13154   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13155             &quot;CMOV$cmp $dst.hi,$src.hi+4&quot; %}
13156   opcode(0x0F,0x40);
13157   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
13158   ins_pipe( pipe_cmov_reg_long );
13159 %}
13160 
13161 // Compare 2 longs and CMOVE ints.
13162 instruct cmovII_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, rRegI src) %{
13163   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13164   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
13165   ins_cost(200);
13166   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13167   opcode(0x0F,0x40);
13168   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13169   ins_pipe( pipe_cmov_reg );
13170 %}
13171 
13172 instruct cmovII_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, memory src) %{
13173   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13174   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13175   ins_cost(250);
13176   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13177   opcode(0x0F,0x40);
13178   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13179   ins_pipe( pipe_cmov_mem );
13180 %}
13181 
13182 // Compare 2 longs and CMOVE ptrs.
13183 instruct cmovPP_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegP dst, eRegP src) %{
13184   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13185   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13186   ins_cost(200);
13187   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13188   opcode(0x0F,0x40);
13189   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13190   ins_pipe( pipe_cmov_reg );
13191 %}
13192 
13193 // Compare 2 longs and CMOVE doubles
13194 instruct cmovDDPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regDPR dst, regDPR src) %{
13195   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13196   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13197   ins_cost(200);
13198   expand %{
13199     fcmovDPR_regS(cmp,flags,dst,src);
13200   %}
13201 %}
13202 
13203 // Compare 2 longs and CMOVE doubles
13204 instruct cmovDD_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regD dst, regD src) %{
13205   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13206   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13207   ins_cost(200);
13208   expand %{
13209     fcmovD_regS(cmp,flags,dst,src);
13210   %}
13211 %}
13212 
13213 instruct cmovFFPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regFPR dst, regFPR src) %{
13214   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13215   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13216   ins_cost(200);
13217   expand %{
13218     fcmovFPR_regS(cmp,flags,dst,src);
13219   %}
13220 %}
13221 
13222 
13223 instruct cmovFF_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regF dst, regF src) %{
13224   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13225   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13226   ins_cost(200);
13227   expand %{
13228     fcmovF_regS(cmp,flags,dst,src);
13229   %}
13230 %}
13231 
13232 
13233 // ============================================================================
13234 // Procedure Call/Return Instructions
13235 // Call Java Static Instruction
13236 // Note: If this code changes, the corresponding ret_addr_offset() and
13237 //       compute_padding() functions will have to be adjusted.
13238 instruct CallStaticJavaDirect(method meth) %{
13239   match(CallStaticJava);
13240   effect(USE meth);
13241 
13242   ins_cost(300);
13243   format %{ &quot;CALL,static &quot; %}
13244   opcode(0xE8); /* E8 cd */
13245   ins_encode( pre_call_resets,
13246               Java_Static_Call( meth ),
13247               call_epilog,
13248               post_call_FPU );
13249   ins_pipe( pipe_slow );
13250   ins_alignment(4);
13251 %}
13252 
13253 // Call Java Dynamic Instruction
13254 // Note: If this code changes, the corresponding ret_addr_offset() and
13255 //       compute_padding() functions will have to be adjusted.
13256 instruct CallDynamicJavaDirect(method meth) %{
13257   match(CallDynamicJava);
13258   effect(USE meth);
13259 
13260   ins_cost(300);
13261   format %{ &quot;MOV    EAX,(oop)-1\n\t&quot;
13262             &quot;CALL,dynamic&quot; %}
13263   opcode(0xE8); /* E8 cd */
13264   ins_encode( pre_call_resets,
13265               Java_Dynamic_Call( meth ),
13266               call_epilog,
13267               post_call_FPU );
13268   ins_pipe( pipe_slow );
13269   ins_alignment(4);
13270 %}
13271 
13272 // Call Runtime Instruction
13273 instruct CallRuntimeDirect(method meth) %{
13274   match(CallRuntime );
13275   effect(USE meth);
13276 
13277   ins_cost(300);
13278   format %{ &quot;CALL,runtime &quot; %}
13279   opcode(0xE8); /* E8 cd */
13280   // Use FFREEs to clear entries in float stack
13281   ins_encode( pre_call_resets,
13282               FFree_Float_Stack_All,
13283               Java_To_Runtime( meth ),
13284               post_call_FPU );
13285   ins_pipe( pipe_slow );
13286 %}
13287 
13288 // Call runtime without safepoint
13289 instruct CallLeafDirect(method meth) %{
13290   match(CallLeaf);
13291   effect(USE meth);
13292 
13293   ins_cost(300);
13294   format %{ &quot;CALL_LEAF,runtime &quot; %}
13295   opcode(0xE8); /* E8 cd */
13296   ins_encode( pre_call_resets,
13297               FFree_Float_Stack_All,
13298               Java_To_Runtime( meth ),
13299               Verify_FPU_For_Leaf, post_call_FPU );
13300   ins_pipe( pipe_slow );
13301 %}
13302 
13303 instruct CallLeafNoFPDirect(method meth) %{
13304   match(CallLeafNoFP);
13305   effect(USE meth);
13306 
13307   ins_cost(300);
13308   format %{ &quot;CALL_LEAF_NOFP,runtime &quot; %}
13309   opcode(0xE8); /* E8 cd */
13310   ins_encode(pre_call_resets, Java_To_Runtime(meth));
13311   ins_pipe( pipe_slow );
13312 %}
13313 
13314 
13315 // Return Instruction
13316 // Remove the return address &amp; jump to it.
13317 instruct Ret() %{
13318   match(Return);
13319   format %{ &quot;RET&quot; %}
13320   opcode(0xC3);
13321   ins_encode(OpcP);
13322   ins_pipe( pipe_jmp );
13323 %}
13324 
13325 // Tail Call; Jump from runtime stub to Java code.
13326 // Also known as an &#39;interprocedural jump&#39;.
13327 // Target of jump will eventually return to caller.
13328 // TailJump below removes the return address.
13329 instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_oop) %{
13330   match(TailCall jump_target method_oop );
13331   ins_cost(300);
13332   format %{ &quot;JMP    $jump_target \t# EBX holds method oop&quot; %}
13333   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13334   ins_encode( OpcP, RegOpc(jump_target) );
13335   ins_pipe( pipe_jmp );
13336 %}
13337 
13338 
13339 // Tail Jump; remove the return address; jump to target.
13340 // TailCall above leaves the return address around.
13341 instruct tailjmpInd(eRegP_no_EBP jump_target, eAXRegP ex_oop) %{
13342   match( TailJump jump_target ex_oop );
13343   ins_cost(300);
13344   format %{ &quot;POP    EDX\t# pop return address into dummy\n\t&quot;
13345             &quot;JMP    $jump_target &quot; %}
13346   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13347   ins_encode( enc_pop_rdx,
13348               OpcP, RegOpc(jump_target) );
13349   ins_pipe( pipe_jmp );
13350 %}
13351 
13352 // Create exception oop: created by stack-crawling runtime code.
13353 // Created exception is now available to this handler, and is setup
13354 // just prior to jumping to this handler.  No code emitted.
13355 instruct CreateException( eAXRegP ex_oop )
13356 %{
13357   match(Set ex_oop (CreateEx));
13358 
13359   size(0);
13360   // use the following format syntax
13361   format %{ &quot;# exception oop is in EAX; no code emitted&quot; %}
13362   ins_encode();
13363   ins_pipe( empty );
13364 %}
13365 
13366 
13367 // Rethrow exception:
13368 // The exception oop will come in the first argument position.
13369 // Then JUMP (not call) to the rethrow stub code.
13370 instruct RethrowException()
13371 %{
13372   match(Rethrow);
13373 
13374   // use the following format syntax
13375   format %{ &quot;JMP    rethrow_stub&quot; %}
13376   ins_encode(enc_rethrow);
13377   ins_pipe( pipe_jmp );
13378 %}
13379 
13380 // inlined locking and unlocking
13381 
13382 instruct cmpFastLockRTM(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eDXRegI scr, rRegI cx1, rRegI cx2) %{
13383   predicate(Compile::current()-&gt;use_rtm());
13384   match(Set cr (FastLock object box));
13385   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
13386   ins_cost(300);
13387   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
13388   ins_encode %{
13389     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13390                  $scr$$Register, $cx1$$Register, $cx2$$Register,
13391                  _counters, _rtm_counters, _stack_rtm_counters,
13392                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
13393                  true, ra_-&gt;C-&gt;profile_rtm());
13394   %}
13395   ins_pipe(pipe_slow);
13396 %}
13397 
13398 instruct cmpFastLock(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eRegP scr) %{
13399   predicate(!Compile::current()-&gt;use_rtm());
13400   match(Set cr (FastLock object box));
13401   effect(TEMP tmp, TEMP scr, USE_KILL box);
13402   ins_cost(300);
13403   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr&quot; %}
13404   ins_encode %{
13405     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13406                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13407   %}
13408   ins_pipe(pipe_slow);
13409 %}
13410 
13411 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13412   match(Set cr (FastUnlock object box));
13413   effect(TEMP tmp, USE_KILL box);
13414   ins_cost(300);
13415   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13416   ins_encode %{
13417     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13418   %}
13419   ins_pipe(pipe_slow);
13420 %}
13421 
13422 
13423 
13424 // ============================================================================
13425 // Safepoint Instruction
13426 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{
13427   match(SafePoint poll);
13428   effect(KILL cr, USE poll);
13429 
13430   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13431   ins_cost(125);
13432   // EBP would need size(3)
13433   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13434   ins_encode %{
13435     __ relocate(relocInfo::poll_type);
13436     address pre_pc = __ pc();
13437     __ testl(rax, Address($poll$$Register, 0));
13438     address post_pc = __ pc();
13439     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13440   %}
13441   ins_pipe(ialu_reg_mem);
13442 %}
13443 
13444 
13445 // ============================================================================
13446 // This name is KNOWN by the ADLC and cannot be changed.
13447 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
13448 // for this guy.
13449 instruct tlsLoadP(eRegP dst, eFlagsReg cr) %{
13450   match(Set dst (ThreadLocal));
13451   effect(DEF dst, KILL cr);
13452 
13453   format %{ &quot;MOV    $dst, Thread::current()&quot; %}
13454   ins_encode %{
13455     Register dstReg = as_Register($dst$$reg);
13456     __ get_thread(dstReg);
13457   %}
13458   ins_pipe( ialu_reg_fat );
13459 %}
13460 
13461 
13462 
13463 //----------PEEPHOLE RULES-----------------------------------------------------
13464 // These must follow all instruction definitions as they use the names
13465 // defined in the instructions definitions.
13466 //
13467 // peepmatch ( root_instr_name [preceding_instruction]* );
13468 //
13469 // peepconstraint %{
13470 // (instruction_number.operand_name relational_op instruction_number.operand_name
13471 //  [, ...] );
13472 // // instruction numbers are zero-based using left to right order in peepmatch
13473 //
13474 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
13475 // // provide an instruction_number.operand_name for each operand that appears
13476 // // in the replacement instruction&#39;s match rule
13477 //
13478 // ---------VM FLAGS---------------------------------------------------------
13479 //
13480 // All peephole optimizations can be turned off using -XX:-OptoPeephole
13481 //
13482 // Each peephole rule is given an identifying number starting with zero and
13483 // increasing by one in the order seen by the parser.  An individual peephole
13484 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
13485 // on the command-line.
13486 //
13487 // ---------CURRENT LIMITATIONS----------------------------------------------
13488 //
13489 // Only match adjacent instructions in same basic block
13490 // Only equality constraints
13491 // Only constraints between operands, not (0.dest_reg == EAX_enc)
13492 // Only one replacement instruction
13493 //
13494 // ---------EXAMPLE----------------------------------------------------------
13495 //
13496 // // pertinent parts of existing instructions in architecture description
13497 // instruct movI(rRegI dst, rRegI src) %{
13498 //   match(Set dst (CopyI src));
13499 // %}
13500 //
13501 // instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
13502 //   match(Set dst (AddI dst src));
13503 //   effect(KILL cr);
13504 // %}
13505 //
13506 // // Change (inc mov) to lea
13507 // peephole %{
13508 //   // increment preceeded by register-register move
13509 //   peepmatch ( incI_eReg movI );
13510 //   // require that the destination register of the increment
13511 //   // match the destination register of the move
13512 //   peepconstraint ( 0.dst == 1.dst );
13513 //   // construct a replacement instruction that sets
13514 //   // the destination to ( move&#39;s source register + one )
13515 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13516 // %}
13517 //
13518 // Implementation no longer uses movX instructions since
13519 // machine-independent system no longer uses CopyX nodes.
13520 //
13521 // peephole %{
13522 //   peepmatch ( incI_eReg movI );
13523 //   peepconstraint ( 0.dst == 1.dst );
13524 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13525 // %}
13526 //
13527 // peephole %{
13528 //   peepmatch ( decI_eReg movI );
13529 //   peepconstraint ( 0.dst == 1.dst );
13530 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13531 // %}
13532 //
13533 // peephole %{
13534 //   peepmatch ( addI_eReg_imm movI );
13535 //   peepconstraint ( 0.dst == 1.dst );
13536 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13537 // %}
13538 //
13539 // peephole %{
13540 //   peepmatch ( addP_eReg_imm movP );
13541 //   peepconstraint ( 0.dst == 1.dst );
13542 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
13543 // %}
13544 
13545 // // Change load of spilled value to only a spill
13546 // instruct storeI(memory mem, rRegI src) %{
13547 //   match(Set mem (StoreI mem src));
13548 // %}
13549 //
13550 // instruct loadI(rRegI dst, memory mem) %{
13551 //   match(Set dst (LoadI mem));
13552 // %}
13553 //
13554 peephole %{
13555   peepmatch ( loadI storeI );
13556   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13557   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
13558 %}
13559 
13560 //----------SMARTSPILL RULES---------------------------------------------------
13561 // These must follow all instruction definitions as they use the names
13562 // defined in the instructions definitions.
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
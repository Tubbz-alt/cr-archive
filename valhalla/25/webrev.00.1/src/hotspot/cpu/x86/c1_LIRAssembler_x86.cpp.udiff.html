<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../sparc/interp_masm_sparc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,12 +30,14 @@</span>
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
<span class="udiff-line-added">+ #include &quot;ci/ciValueKlass.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;nativeInst_x86.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/oop.inline.hpp&quot;</span>
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/powerOfTwo.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -189,11 +191,11 @@</span>
      __ push_reg(opr-&gt;as_register_lo());
    } else if (opr-&gt;is_stack()) {
      __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
    } else if (opr-&gt;is_constant()) {
      LIR_Const* const_opr = opr-&gt;as_constant_ptr();
<span class="udiff-line-modified-removed">-     if (const_opr-&gt;type() == T_OBJECT) {</span>
<span class="udiff-line-modified-added">+     if (const_opr-&gt;type() == T_OBJECT || const_opr-&gt;type() == T_VALUETYPE) {</span>
        __ push_oop(const_opr-&gt;as_jobject());
      } else if (const_opr-&gt;type() == T_INT) {
        __ push_jint(const_opr-&gt;as_jint());
      } else {
        ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -476,11 +478,12 @@</span>
    if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
      __ mov(rax, rbx);  // Restore the exception
    }
  
    // remove the activation and dispatch to the unwind handler
<span class="udiff-line-modified-removed">-   __ remove_frame(initial_frame_size_in_bytes());</span>
<span class="udiff-line-modified-added">+   int initial_framesize = initial_frame_size_in_bytes();</span>
<span class="udiff-line-added">+   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);</span>
    __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
  
    // Emit the slow path assembly
    if (stub != NULL) {
      stub-&gt;emit_code(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -522,12 +525,32 @@</span>
    assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
    if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
      assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
    }
  
<span class="udiff-line-added">+   ciMethod* method = compilation()-&gt;method();</span>
<span class="udiff-line-added">+   if (ValueTypeReturnedAsFields &amp;&amp; method-&gt;signature()-&gt;returns_never_null()) {</span>
<span class="udiff-line-added">+     ciType* return_type = method-&gt;return_type();</span>
<span class="udiff-line-added">+     if (return_type-&gt;is_valuetype()) {</span>
<span class="udiff-line-added">+       ciValueKlass* vk = return_type-&gt;as_value_klass();</span>
<span class="udiff-line-added">+       if (vk-&gt;can_be_returned_as_fields()) {</span>
<span class="udiff-line-added">+ #ifndef _LP64</span>
<span class="udiff-line-added">+         Unimplemented();</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+         address unpack_handler = vk-&gt;unpack_handler();</span>
<span class="udiff-line-added">+         assert(unpack_handler != NULL, &quot;must be&quot;);</span>
<span class="udiff-line-added">+         __ call(RuntimeAddress(unpack_handler));</span>
<span class="udiff-line-added">+         // At this point, rax points to the value object (for interpreter or C1 caller).</span>
<span class="udiff-line-added">+         // The fields of the object are copied into registers (for C2 caller).</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Pop the stack before the safepoint code
<span class="udiff-line-modified-removed">-   __ remove_frame(initial_frame_size_in_bytes());</span>
<span class="udiff-line-modified-added">+   int initial_framesize = initial_frame_size_in_bytes();</span>
<span class="udiff-line-added">+   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);</span>
  
    if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check();
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -549,10 +572,14 @@</span>
    __ testl(rax, Address(poll_addr, 0));
    __ ret(0);
  }
  
  
<span class="udiff-line-added">+ int LIR_Assembler::store_value_type_fields_to_buf(ciValueKlass* vk) {</span>
<span class="udiff-line-added">+   return (__ store_value_type_fields_to_buf(vk, false));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
    guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
    int offset = __ offset();
  #ifdef _LP64
    const Register poll_addr = rscratch1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -609,10 +636,11 @@</span>
        __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
  #endif // _LP64
        break;
      }
  
<span class="udiff-line-added">+     case T_VALUETYPE: // Fall through</span>
      case T_OBJECT: {
        if (patch_code != lir_patch_none) {
          jobject2reg_with_patching(dest-&gt;as_register(), info);
        } else {
          __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -699,10 +727,11 @@</span>
  
      case T_ADDRESS:
        __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
        break;
  
<span class="udiff-line-added">+     case T_VALUETYPE: // Fall through</span>
      case T_OBJECT:
        __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
        break;
  
      case T_LONG:  // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -738,10 +767,11 @@</span>
  
      case T_ADDRESS:
        __ movptr(as_Address(addr), c-&gt;as_jint_bits());
        break;
  
<span class="udiff-line-added">+     case T_VALUETYPE: // fall through</span>
      case T_OBJECT:  // fall through
      case T_ARRAY:
        if (c-&gt;as_jobject() == NULL) {
          if (UseCompressedOops &amp;&amp; !wide) {
            __ movl(as_Address(addr), (int32_t)NULL_WORD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -826,11 +856,11 @@</span>
        move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
        return;
      }
  #endif
      assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
<span class="udiff-line-modified-removed">-     if (src-&gt;type() == T_OBJECT) {</span>
<span class="udiff-line-modified-added">+     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_VALUETYPE) {</span>
        __ verify_oop(src-&gt;as_register());
      }
      move_regs(src-&gt;as_register(), dest-&gt;as_register());
  
    } else if (dest-&gt;is_double_cpu()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1012,10 +1042,11 @@</span>
        }
  #endif // _LP64
        break;
      }
  
<span class="udiff-line-added">+     case T_VALUETYPE: // fall through</span>
      case T_ARRAY:   // fall through
      case T_OBJECT:  // fall through
        if (UseCompressedOops &amp;&amp; !wide) {
          __ movl(as_Address(to_addr), compressed_src);
        } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1184,11 +1215,11 @@</span>
    assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
  
    LIR_Address* addr = src-&gt;as_address_ptr();
    Address from_addr = as_Address(addr);
  
<span class="udiff-line-modified-removed">-   if (addr-&gt;base()-&gt;type() == T_OBJECT) {</span>
<span class="udiff-line-modified-added">+   if (addr-&gt;base()-&gt;type() == T_OBJECT || addr-&gt;base()-&gt;type() == T_VALUETYPE) {</span>
      __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
    }
  
    switch (type) {
      case T_BOOLEAN: // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1245,10 +1276,11 @@</span>
  #endif // !LP64
        }
        break;
      }
  
<span class="udiff-line-added">+     case T_VALUETYPE: // fall through</span>
      case T_OBJECT:  // fall through
      case T_ARRAY:   // fall through
        if (UseCompressedOops &amp;&amp; !wide) {
          __ movl(dest-&gt;as_register(), from_addr);
        } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1368,12 +1400,18 @@</span>
        __ verify_oop(dest-&gt;as_register());
      }
    } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
  #ifdef _LP64
      if (UseCompressedClassPointers) {
<span class="udiff-line-added">+       __ andl(dest-&gt;as_register(), oopDesc::compressed_klass_mask());</span>
        __ decode_klass_not_null(dest-&gt;as_register());
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       __ shlq(dest-&gt;as_register(), oopDesc::storage_props_nof_bits);</span>
<span class="udiff-line-added">+       __ shrq(dest-&gt;as_register(), oopDesc::storage_props_nof_bits);</span>
      }
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     __ andl(dest-&gt;as_register(), oopDesc::wide_klass_mask());</span>
  #endif
    }
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1631,11 +1669,11 @@</span>
  
  void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
    Register len =  op-&gt;len()-&gt;as_register();
    LP64_ONLY( __ movslq(len, len); )
  
<span class="udiff-line-modified-removed">-   if (UseSlowPath ||</span>
<span class="udiff-line-modified-added">+   if (UseSlowPath || op-&gt;type() == T_VALUETYPE ||</span>
        (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
        (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
      __ jmp(*op-&gt;stub()-&gt;entry());
    } else {
      Register tmp1 = op-&gt;tmp1()-&gt;as_register();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1729,24 +1767,26 @@</span>
      select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
    }
  
    assert_different_registers(obj, k_RInfo, klass_RInfo);
  
<span class="udiff-line-modified-removed">-   __ cmpptr(obj, (int32_t)NULL_WORD);</span>
<span class="udiff-line-modified-removed">-   if (op-&gt;should_profile()) {</span>
<span class="udiff-line-modified-removed">-     Label not_null;</span>
<span class="udiff-line-modified-removed">-     __ jccb(Assembler::notEqual, not_null);</span>
<span class="udiff-line-modified-removed">-     // Object is null; update MDO and exit</span>
<span class="udiff-line-modified-removed">-     Register mdo  = klass_RInfo;</span>
<span class="udiff-line-modified-removed">-     __ mov_metadata(mdo, md-&gt;constant_encoding());</span>
<span class="udiff-line-modified-removed">-     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));</span>
<span class="udiff-line-modified-removed">-     int header_bits = BitData::null_seen_byte_constant();</span>
<span class="udiff-line-modified-removed">-     __ orb(data_addr, header_bits);</span>
<span class="udiff-line-modified-removed">-     __ jmp(*obj_is_null);</span>
<span class="udiff-line-modified-removed">-     __ bind(not_null);</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::equal, *obj_is_null);</span>
<span class="udiff-line-modified-added">+   if (op-&gt;need_null_check()) {</span>
<span class="udiff-line-modified-added">+     __ cmpptr(obj, (int32_t)NULL_WORD);</span>
<span class="udiff-line-modified-added">+     if (op-&gt;should_profile()) {</span>
<span class="udiff-line-modified-added">+       Label not_null;</span>
<span class="udiff-line-modified-added">+       __ jccb(Assembler::notEqual, not_null);</span>
<span class="udiff-line-modified-added">+       // Object is null; update MDO and exit</span>
<span class="udiff-line-modified-added">+       Register mdo  = klass_RInfo;</span>
<span class="udiff-line-modified-added">+       __ mov_metadata(mdo, md-&gt;constant_encoding());</span>
<span class="udiff-line-modified-added">+       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));</span>
<span class="udiff-line-modified-added">+       int header_bits = BitData::null_seen_byte_constant();</span>
<span class="udiff-line-modified-added">+       __ orb(data_addr, header_bits);</span>
<span class="udiff-line-modified-added">+       __ jmp(*obj_is_null);</span>
<span class="udiff-line-modified-added">+       __ bind(not_null);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-added">+       __ jcc(Assembler::equal, *obj_is_null);</span>
<span class="udiff-line-added">+     }</span>
    }
  
    if (!k-&gt;is_loaded()) {
      klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1953,10 +1993,117 @@</span>
          ShouldNotReachHere();
        }
  
  }
  
<span class="udiff-line-added">+ void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {</span>
<span class="udiff-line-added">+   // We are loading/storing an array that *may* be a flattened array (the declared type</span>
<span class="udiff-line-added">+   // Object[], interface[], or VT?[]). If this array is flattened, take slow path.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());</span>
<span class="udiff-line-added">+   __ testb(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::flattened_value);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::notZero, *op-&gt;stub()-&gt;entry());</span>
<span class="udiff-line-added">+   if (!op-&gt;value()-&gt;is_illegal()) {</span>
<span class="udiff-line-added">+     // We are storing into the array.</span>
<span class="udiff-line-added">+     Label skip;</span>
<span class="udiff-line-added">+     __ testb(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::null_free_value);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::zero, skip);</span>
<span class="udiff-line-added">+     // The array is not flattened, but it is null_free. If we are storing</span>
<span class="udiff-line-added">+     // a null, take the slow path (which will throw NPE).</span>
<span class="udiff-line-added">+     __ cmpptr(op-&gt;value()-&gt;as_register(), (int32_t)NULL_WORD);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::zero, *op-&gt;stub()-&gt;entry());</span>
<span class="udiff-line-added">+     __ bind(skip);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {</span>
<span class="udiff-line-added">+   // This is called when we use aastore into a an array declared as &quot;[LVT;&quot;,</span>
<span class="udiff-line-added">+   // where we know VT is not flattenable (due to ValueArrayElemMaxFlatOops, etc).</span>
<span class="udiff-line-added">+   // However, we need to do a NULL check if the actual array is a &quot;[QVT;&quot;.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());</span>
<span class="udiff-line-added">+   __ testb(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::null_free_value);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {</span>
<span class="udiff-line-added">+   Label L_oops_equal;</span>
<span class="udiff-line-added">+   Label L_oops_not_equal;</span>
<span class="udiff-line-added">+   Label L_end;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Register left  = op-&gt;left()-&gt;as_register();</span>
<span class="udiff-line-added">+   Register right = op-&gt;right()-&gt;as_register();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ cmpptr(left, right);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::equal, L_oops_equal);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // (1) Null check -- if one of the operands is null, the other must not be null (because</span>
<span class="udiff-line-added">+   //     the two references are not equal), so they are not substitutable,</span>
<span class="udiff-line-added">+   //     FIXME: do null check only if the operand is nullable</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     __ cmpptr(left, (int32_t)NULL_WORD);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::equal, L_oops_not_equal);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ cmpptr(right, (int32_t)NULL_WORD);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::equal, L_oops_not_equal);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ciKlass* left_klass = op-&gt;left_klass();</span>
<span class="udiff-line-added">+   ciKlass* right_klass = op-&gt;right_klass();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // (2) Value object check -- if either of the operands is not a value object,</span>
<span class="udiff-line-added">+   //     they are not substitutable. We do this only if we are not sure that the</span>
<span class="udiff-line-added">+   //     operands are value objects</span>
<span class="udiff-line-added">+   if ((left_klass == NULL || right_klass == NULL) ||// The klass is still unloaded, or came from a Phi node.</span>
<span class="udiff-line-added">+       !left_klass-&gt;is_valuetype() || !right_klass-&gt;is_valuetype()) {</span>
<span class="udiff-line-added">+     Register tmp1  = op-&gt;tmp1()-&gt;as_register();</span>
<span class="udiff-line-added">+     __ movptr(tmp1, (intptr_t)markWord::always_locked_pattern);</span>
<span class="udiff-line-added">+     __ andl(tmp1, Address(left, oopDesc::mark_offset_in_bytes()));</span>
<span class="udiff-line-added">+     __ andl(tmp1, Address(right, oopDesc::mark_offset_in_bytes()));</span>
<span class="udiff-line-added">+     __ cmpptr(tmp1, (intptr_t)markWord::always_locked_pattern);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::notEqual, L_oops_not_equal);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // (3) Same klass check: if the operands are of different klasses, they are not substitutable.</span>
<span class="udiff-line-added">+   if (left_klass != NULL &amp;&amp; left_klass-&gt;is_valuetype() &amp;&amp; left_klass == right_klass) {</span>
<span class="udiff-line-added">+     // No need to load klass -- the operands are statically known to be the same value klass.</span>
<span class="udiff-line-added">+     __ jmp(*op-&gt;stub()-&gt;entry());</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     Register left_klass_op = op-&gt;left_klass_op()-&gt;as_register();</span>
<span class="udiff-line-added">+     Register right_klass_op = op-&gt;right_klass_op()-&gt;as_register();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (UseCompressedOops) {</span>
<span class="udiff-line-added">+       __ movl(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));</span>
<span class="udiff-line-added">+       __ movl(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));</span>
<span class="udiff-line-added">+       __ cmpl(left_klass_op, right_klass_op);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       __ movptr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));</span>
<span class="udiff-line-added">+       __ movptr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));</span>
<span class="udiff-line-added">+       __ cmpptr(left_klass_op, right_klass_op);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry()); // same klass -&gt; do slow check</span>
<span class="udiff-line-added">+     // fall through to L_oops_not_equal</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ bind(L_oops_not_equal);</span>
<span class="udiff-line-added">+   move(op-&gt;not_equal_result(), op-&gt;result_opr());</span>
<span class="udiff-line-added">+   __ jmp(L_end);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ bind(L_oops_equal);</span>
<span class="udiff-line-added">+   move(op-&gt;equal_result(), op-&gt;result_opr());</span>
<span class="udiff-line-added">+   __ jmp(L_end);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // We&#39;ve returned from the stub. RAX contains 0x0 IFF the two</span>
<span class="udiff-line-added">+   // operands are not substitutable. (Don&#39;t compare against 0x1 in case the</span>
<span class="udiff-line-added">+   // C compiler is naughty)</span>
<span class="udiff-line-added">+   __ bind(*op-&gt;stub()-&gt;continuation());</span>
<span class="udiff-line-added">+   __ cmpl(rax, 0);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::equal, L_oops_not_equal); // (call_stub() == 0x0) -&gt; not_equal</span>
<span class="udiff-line-added">+   move(op-&gt;equal_result(), op-&gt;result_opr()); // (call_stub() != 0x0) -&gt; equal</span>
<span class="udiff-line-added">+   // fall-through</span>
<span class="udiff-line-added">+   __ bind(L_end);</span>
<span class="udiff-line-added">+ }</span>
  
  void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
    if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
      assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
      assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2013,10 +2160,25 @@</span>
    } else {
      Unimplemented();
    }
  }
  
<span class="udiff-line-added">+ void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {</span>
<span class="udiff-line-added">+   assert(dst-&gt;is_cpu_register(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+   assert(dst-&gt;type() == src-&gt;type(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (src-&gt;is_cpu_register()) {</span>
<span class="udiff-line-added">+     reg2reg(src, dst);</span>
<span class="udiff-line-added">+   } else if (src-&gt;is_stack()) {</span>
<span class="udiff-line-added">+     stack2reg(src, dst, dst-&gt;type());</span>
<span class="udiff-line-added">+   } else if (src-&gt;is_constant()) {</span>
<span class="udiff-line-added">+     const2reg(src, dst, lir_patch_none, NULL);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     ShouldNotReachHere();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
    Assembler::Condition acond, ncond;
    switch (condition) {
      case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
      case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2892,17 +3054,17 @@</span>
  
  void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
    assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
           &quot;must be aligned&quot;);
    __ call(AddressLiteral(op-&gt;addr(), rtype));
<span class="udiff-line-modified-removed">-   add_call_info(code_offset(), op-&gt;info());</span>
<span class="udiff-line-modified-added">+   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());</span>
  }
  
  
  void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
    __ ic_call(op-&gt;addr());
<span class="udiff-line-modified-removed">-   add_call_info(code_offset(), op-&gt;info());</span>
<span class="udiff-line-modified-added">+   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());</span>
    assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
           &quot;must be aligned&quot;);
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3094,10 +3256,27 @@</span>
    assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
    __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
  }
  
  
<span class="udiff-line-added">+ void LIR_Assembler::arraycopy_valuetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest, bool null_check) {</span>
<span class="udiff-line-added">+   if (null_check) {</span>
<span class="udiff-line-added">+     __ testptr(obj, obj);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::zero, *slow_path-&gt;entry());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   __ load_storage_props(tmp, obj);</span>
<span class="udiff-line-added">+   if (is_dest) {</span>
<span class="udiff-line-added">+     // We also take slow path if it&#39;s a null_free destination array, just in case the source array</span>
<span class="udiff-line-added">+     // contains NULLs.</span>
<span class="udiff-line-added">+     __ testb(tmp, ArrayStorageProperties::flattened_value | ArrayStorageProperties::null_free_value);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     __ testb(tmp, ArrayStorageProperties::flattened_value);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   __ jcc(Assembler::notEqual, *slow_path-&gt;entry());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  // This code replaces a call to arraycopy; no exception may
  // be thrown in this code, they must be thrown in the System.arraycopy
  // activation frame; we could save some checks if this would not be the case
  void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
    ciArrayKlass* default_type = op-&gt;expected_type();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3114,10 +3293,24 @@</span>
    CodeStub* stub = op-&gt;stub();
    int flags = op-&gt;flags();
    BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
    if (is_reference_type(basic_type)) basic_type = T_OBJECT;
  
<span class="udiff-line-added">+   if (flags &amp; LIR_OpArrayCopy::always_slow_path) {</span>
<span class="udiff-line-added">+     __ jmp(*stub-&gt;entry());</span>
<span class="udiff-line-added">+     __ bind(*stub-&gt;continuation());</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (flags &amp; LIR_OpArrayCopy::src_valuetype_check) {</span>
<span class="udiff-line-added">+     arraycopy_valuetype_check(src, tmp, stub, false, (flags &amp; LIR_OpArrayCopy::src_null_check));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (flags &amp; LIR_OpArrayCopy::dst_valuetype_check) {</span>
<span class="udiff-line-added">+     arraycopy_valuetype_check(dst, tmp, stub, true, (flags &amp; LIR_OpArrayCopy::dst_null_check));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // if we don&#39;t know anything, just go through the generic arraycopy
    if (default_type == NULL) {
      // save outgoing arguments on stack in case call to System.arraycopy is needed
      // HACK ALERT. This code used to push the parameters in a hardwired fashion
      // for interpreter calling conventions. Now we have to do it in new style conventions.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4049,10 +4242,13 @@</span>
  #else
    __ get_thread(result_reg-&gt;as_register());
  #endif // _LP64
  }
  
<span class="udiff-line-added">+ void LIR_Assembler::check_orig_pc() {</span>
<span class="udiff-line-added">+   __ cmpptr(frame_map()-&gt;address_for_orig_pc_addr(), (int32_t)NULL_WORD);</span>
<span class="udiff-line-added">+ }</span>
  
  void LIR_Assembler::peephole(LIR_List*) {
    // do nothing for now
  }
  
</pre>
<center><a href="../sparc/interp_masm_sparc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/formssel.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
<span class="line-removed">  870   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-removed">  871   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-removed">  872 </span>
  873   if (C-&gt;clinit_barrier_on_entry()) {
  874     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  875     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  876 
  877     Label L_skip_barrier;
  878     Register klass = rscratch1;
  879 
  880     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  881     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  882 
  883     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  884 
  885     __ bind(L_skip_barrier);
  886   }
  887 
<span class="line-modified">  888   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);</span>






  889 
  890   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  891 
  892   if (C-&gt;has_mach_constant_base_node()) {
  893     // NOTE: We set the table base offset here because users might be
  894     // emitted before MachConstantBaseNode.
  895     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  896     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  897   }
  898 }
  899 
<span class="line-removed">  900 uint MachPrologNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  901 {</span>
<span class="line-removed">  902   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  903                               // the hard way</span>
<span class="line-removed">  904 }</span>
<span class="line-removed">  905 </span>
  906 int MachPrologNode::reloc() const
  907 {
  908   return 0; // a large enough number
  909 }
  910 
  911 //=============================================================================
  912 #ifndef PRODUCT
  913 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  914 {
  915   Compile* C = ra_-&gt;C;
  916   if (generate_vzeroupper(C)) {
  917     st-&gt;print(&quot;vzeroupper&quot;);
  918     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  919   }
  920 
  921   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  922   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  923   // Remove word for return adr already pushed
  924   // and RBP
  925   framesize -= 2*wordSize;
</pre>
<hr />
<pre>
  933   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  934     st-&gt;print(&quot;\t&quot;);
  935     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  936                  &quot;testl   rax, [rscratch1]\t&quot;
  937                  &quot;# Safepoint: poll for GC&quot;);
  938   }
  939 }
  940 #endif
  941 
  942 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  943 {
  944   Compile* C = ra_-&gt;C;
  945   MacroAssembler _masm(&amp;cbuf);
  946 
  947   if (generate_vzeroupper(C)) {
  948     // Clear upper bits of YMM registers when current compiled code uses
  949     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  950     __ vzeroupper();
  951   }
  952 
<span class="line-modified">  953   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  954   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);</span>
<span class="line-modified">  955   // Remove word for return adr already pushed</span>
<span class="line-removed">  956   // and RBP</span>
<span class="line-removed">  957   framesize -= 2*wordSize;</span>
<span class="line-removed">  958 </span>
<span class="line-removed">  959   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here</span>
<span class="line-removed">  960 </span>
<span class="line-removed">  961   if (framesize) {</span>
<span class="line-removed">  962     emit_opcode(cbuf, Assembler::REX_W);</span>
<span class="line-removed">  963     if (framesize &lt; 0x80) {</span>
<span class="line-removed">  964       emit_opcode(cbuf, 0x83); // addq rsp, #framesize</span>
<span class="line-removed">  965       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  966       emit_d8(cbuf, framesize);</span>
<span class="line-removed">  967     } else {</span>
<span class="line-removed">  968       emit_opcode(cbuf, 0x81); // addq rsp, #framesize</span>
<span class="line-removed">  969       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  970       emit_d32(cbuf, framesize);</span>
<span class="line-removed">  971     }</span>
<span class="line-removed">  972   }</span>
<span class="line-removed">  973 </span>
<span class="line-removed">  974   // popq rbp</span>
<span class="line-removed">  975   emit_opcode(cbuf, 0x58 | RBP_enc);</span>
  976 
  977   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  978     __ reserved_stack_check();
  979   }
  980 
  981   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  982     MacroAssembler _masm(&amp;cbuf);
  983     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  984     __ relocate(relocInfo::poll_return_type);
  985     __ testl(rax, Address(rscratch1, 0));
  986   }
  987 }
  988 
<span class="line-removed">  989 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  990 {</span>
<span class="line-removed">  991   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  992                               // the hard way</span>
<span class="line-removed">  993 }</span>
<span class="line-removed">  994 </span>
  995 int MachEpilogNode::reloc() const
  996 {
  997   return 2; // a large enough number
  998 }
  999 
 1000 const Pipeline* MachEpilogNode::pipeline() const
 1001 {
 1002   return MachNode::pipeline_class();
 1003 }
 1004 
 1005 //=============================================================================
 1006 
 1007 enum RC {
 1008   rc_bad,
 1009   rc_int,
 1010   rc_float,
 1011   rc_stack
 1012 };
 1013 
 1014 static enum RC rc_class(OptoReg::Name reg)
</pre>
<hr />
<pre>
 1510     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1511     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1512     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1513     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1514     emit_d32(cbuf, offset);
 1515   } else {
 1516     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1517     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1518     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1519     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1520     emit_d8(cbuf, offset);
 1521   }
 1522 }
 1523 
 1524 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1525 {
 1526   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1527   return (offset &lt; 0x80) ? 5 : 8; // REX
 1528 }
 1529 




























 1530 //=============================================================================
 1531 #ifndef PRODUCT
 1532 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1533 {
 1534   if (UseCompressedClassPointers) {
 1535     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1536     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1537     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1538   } else {
 1539     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1540                  &quot;# Inline cache check&quot;);
 1541   }
 1542   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1543   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1544 }
 1545 #endif
 1546 
 1547 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1548 {
 1549   MacroAssembler masm(&amp;cbuf);
</pre>
<hr />
<pre>
 1552     masm.load_klass(rscratch1, j_rarg0);
 1553     masm.cmpptr(rax, rscratch1);
 1554   } else {
 1555     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1556   }
 1557 
 1558   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1559 
 1560   /* WARNING these NOPs are critical so that verified entry point is properly
 1561      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1562   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1563   if (OptoBreakpoint) {
 1564     // Leave space for int3
 1565     nops_cnt -= 1;
 1566   }
 1567   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1568   if (nops_cnt &gt; 0)
 1569     masm.nop(nops_cnt);
 1570 }
 1571 
<span class="line-removed"> 1572 uint MachUEPNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed"> 1573 {</span>
<span class="line-removed"> 1574   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed"> 1575                               // the hard way</span>
<span class="line-removed"> 1576 }</span>
<span class="line-removed"> 1577 </span>
<span class="line-removed"> 1578 </span>
 1579 //=============================================================================
 1580 
 1581 int Matcher::regnum_to_fpu_offset(int regnum)
 1582 {
 1583   return regnum - 32; // The FP registers are in the second chunk
 1584 }
 1585 
 1586 // This is UltraSparc specific, true just means we have fast l2f conversion
 1587 const bool Matcher::convL2FSupported(void) {
 1588   return true;
 1589 }
 1590 
 1591 // Is this branch offset short enough that a short branch can be used?
 1592 //
 1593 // NOTE: If the platform does not provide any short branch variants, then
 1594 //       this method should return false for offset 0.
 1595 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1596   // The passed offset is relative to address of the branch.
 1597   // On 86 a branch displacement is calculated relative to address
 1598   // of a next instruction.
</pre>
<hr />
<pre>
 3844   %}
 3845 %}
 3846 
 3847 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3848 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3849 %{
 3850   constraint(ALLOC_IN_RC(ptr_reg));
 3851   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3852   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3853 
 3854   op_cost(10);
 3855   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3856   interface(MEMORY_INTER) %{
 3857     base($reg);
 3858     index($idx);
 3859     scale($scale);
 3860     disp($off);
 3861   %}
 3862 %}
 3863 
















 3864 // Indirect Narrow Oop Plus Offset Operand
 3865 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3866 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3867 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3868   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3869   constraint(ALLOC_IN_RC(ptr_reg));
 3870   match(AddP (DecodeN reg) off);
 3871 
 3872   op_cost(10);
 3873   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3874   interface(MEMORY_INTER) %{
 3875     base(0xc); // R12
 3876     index($reg);
 3877     scale(0x3);
 3878     disp($off);
 3879   %}
 3880 %}
 3881 
 3882 // Indirect Memory Operand
 3883 operand indirectNarrow(rRegN reg)
</pre>
<hr />
<pre>
 4186     equal(0x4, &quot;e&quot;);
 4187     not_equal(0x5, &quot;ne&quot;);
 4188     less(0x2, &quot;b&quot;);
 4189     greater_equal(0x3, &quot;nb&quot;);
 4190     less_equal(0x6, &quot;be&quot;);
 4191     greater(0x7, &quot;nbe&quot;);
 4192     overflow(0x0, &quot;o&quot;);
 4193     no_overflow(0x1, &quot;no&quot;);
 4194   %}
 4195 %}
 4196 
 4197 //----------OPERAND CLASSES----------------------------------------------------
 4198 // Operand Classes are groups of operands that are used as to simplify
 4199 // instruction definitions by not requiring the AD writer to specify separate
 4200 // instructions for every form of operand when the instruction accepts
 4201 // multiple operand types with the same basic encoding and format.  The classic
 4202 // case of this is memory operands.
 4203 
 4204 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4205                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
<span class="line-modified"> 4206                indCompressedOopOffset,</span>
 4207                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4208                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4209                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4210 
 4211 //----------PIPELINE-----------------------------------------------------------
 4212 // Rules which define the behavior of the target architectures pipeline.
 4213 pipeline %{
 4214 
 4215 //----------ATTRIBUTES---------------------------------------------------------
 4216 attributes %{
 4217   variable_size_instructions;        // Fixed size instructions
 4218   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4219   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4220   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4221   instruction_fetch_units = 1;       // of 16 bytes
 4222 
 4223   // List of nop instructions
 4224   nops( MachNop );
 4225 %}
 4226 
</pre>
<hr />
<pre>
 6670   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6671   ins_encode( );
 6672   ins_pipe(empty);
 6673 %}
 6674 
 6675 //----------Move Instructions--------------------------------------------------
 6676 
 6677 instruct castX2P(rRegP dst, rRegL src)
 6678 %{
 6679   match(Set dst (CastX2P src));
 6680 
 6681   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6682   ins_encode %{
 6683     if ($dst$$reg != $src$$reg) {
 6684       __ movptr($dst$$Register, $src$$Register);
 6685     }
 6686   %}
 6687   ins_pipe(ialu_reg_reg); // XXX
 6688 %}
 6689 













 6690 instruct castP2X(rRegL dst, rRegP src)
 6691 %{
 6692   match(Set dst (CastP2X src));
 6693 
 6694   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6695   ins_encode %{
 6696     if ($dst$$reg != $src$$reg) {
 6697       __ movptr($dst$$Register, $src$$Register);
 6698     }
 6699   %}
 6700   ins_pipe(ialu_reg_reg); // XXX
 6701 %}
 6702 



























 6703 // Convert oop into int for vectors alignment masking
 6704 instruct convP2I(rRegI dst, rRegP src)
 6705 %{
 6706   match(Set dst (ConvL2I (CastP2X src)));
 6707 
 6708   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6709   ins_encode %{
 6710     __ movl($dst$$Register, $src$$Register);
 6711   %}
 6712   ins_pipe(ialu_reg_reg); // XXX
 6713 %}
 6714 
 6715 // Convert compressed oop into int for vectors alignment masking
 6716 // in case of 32bit oops (heap &lt; 4Gb).
 6717 instruct convN2I(rRegI dst, rRegN src)
 6718 %{
 6719   predicate(CompressedOops::shift() == 0);
 6720   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6721 
 6722   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
</pre>
<hr />
<pre>
10914   ins_encode %{
10915     __ movdl($dst$$XMMRegister, $src$$Register);
10916   %}
10917   ins_pipe( pipe_slow );
10918 %}
10919 
10920 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10921   match(Set dst (MoveL2D src));
10922   effect(DEF dst, USE src);
10923   ins_cost(100);
10924   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10925   ins_encode %{
10926      __ movdq($dst$$XMMRegister, $src$$Register);
10927   %}
10928   ins_pipe( pipe_slow );
10929 %}
10930 
10931 
10932 // =======================================================================
10933 // fast clearing of an array
<span class="line-modified">10934 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
10935                   Universe dummy, rFlagsReg cr)
10936 %{
<span class="line-modified">10937   predicate(!((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10938   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10939   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10940 
10941   format %{ $$template
<span class="line-removed">10942     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
10943     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10944     $$emit$$&quot;jg      LARGE\n\t&quot;
10945     $$emit$$&quot;dec     rcx\n\t&quot;
10946     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10947     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10948     $$emit$$&quot;dec     rcx\n\t&quot;
10949     $$emit$$&quot;jge     LOOP\n\t&quot;
10950     $$emit$$&quot;jmp     DONE\n\t&quot;
10951     $$emit$$&quot;# LARGE:\n\t&quot;
10952     if (UseFastStosb) {
10953        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10954        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10955     } else if (UseXMMForObjInit) {
<span class="line-modified">10956        $$emit$$&quot;mov     rdi,rax\n\t&quot;</span>
<span class="line-modified">10957        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>

10958        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10959        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10960        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">10961        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
10962        $$emit$$&quot;add     0x40,rax\n\t&quot;
10963        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10964        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10965        $$emit$$&quot;jge     L_loop\n\t&quot;
10966        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10967        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">10968        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
10969        $$emit$$&quot;add     0x20,rax\n\t&quot;
10970        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10971        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10972        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10973        $$emit$$&quot;jle     L_end\n\t&quot;
10974        $$emit$$&quot;dec     rcx\n\t&quot;
10975        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
10976        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
10977        $$emit$$&quot;add     0x8,rax\n\t&quot;
10978        $$emit$$&quot;dec     rcx\n\t&quot;
10979        $$emit$$&quot;jge     L_sloop\n\t&quot;
10980        $$emit$$&quot;# L_end:\n\t&quot;
10981     } else {
10982        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
10983     }
10984     $$emit$$&quot;# DONE&quot;
10985   %}
10986   ins_encode %{
<span class="line-modified">10987     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">10988                  $tmp$$XMMRegister, false);</span>
10989   %}
10990   ins_pipe(pipe_slow);
10991 %}
10992 
<span class="line-modified">10993 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
























































10994                         Universe dummy, rFlagsReg cr)
10995 %{
<span class="line-modified">10996   predicate(((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10997   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10998   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10999 
11000   format %{ $$template
11001     if (UseFastStosb) {
<span class="line-removed">11002        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
11003        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11004        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11005     } else if (UseXMMForObjInit) {
<span class="line-modified">11006        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;</span>
<span class="line-modified">11007        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>















































11008        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11009        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">11010        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">11011        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
11012        $$emit$$&quot;add     0x40,rax\n\t&quot;
11013        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11014        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11015        $$emit$$&quot;jge     L_loop\n\t&quot;
11016        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11017        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">11018        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
11019        $$emit$$&quot;add     0x20,rax\n\t&quot;
11020        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11021        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11022        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11023        $$emit$$&quot;jle     L_end\n\t&quot;
11024        $$emit$$&quot;dec     rcx\n\t&quot;
11025        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11026        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11027        $$emit$$&quot;add     0x8,rax\n\t&quot;
11028        $$emit$$&quot;dec     rcx\n\t&quot;
11029        $$emit$$&quot;jge     L_sloop\n\t&quot;
11030        $$emit$$&quot;# L_end:\n\t&quot;
11031     } else {
<span class="line-removed">11032        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
11033        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11034     }
11035   %}
11036   ins_encode %{
<span class="line-modified">11037     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">11038                  $tmp$$XMMRegister, true);</span>
11039   %}
11040   ins_pipe(pipe_slow);
11041 %}
11042 
11043 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11044                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11045 %{
11046   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11047   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11048   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11049 
11050   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11051   ins_encode %{
11052     __ string_compare($str1$$Register, $str2$$Register,
11053                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11054                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11055   %}
11056   ins_pipe( pipe_slow );
11057 %}
11058 
</pre>
<hr />
<pre>
11583 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11584 %{
11585   match(Set cr (CmpI (AndI src con) zero));
11586 
11587   format %{ &quot;testl   $src, $con&quot; %}
11588   opcode(0xF7, 0x00);
11589   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11590   ins_pipe(ialu_cr_reg_imm);
11591 %}
11592 
11593 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11594 %{
11595   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11596 
11597   format %{ &quot;testl   $src, $mem&quot; %}
11598   opcode(0x85);
11599   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11600   ins_pipe(ialu_cr_reg_mem);
11601 %}
11602 


























11603 // Unsigned compare Instructions; really, same as signed except they
11604 // produce an rFlagsRegU instead of rFlagsReg.
11605 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11606 %{
11607   match(Set cr (CmpU op1 op2));
11608 
11609   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11610   opcode(0x3B); /* Opcode 3B /r */
11611   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11612   ins_pipe(ialu_cr_reg_reg);
11613 %}
11614 
11615 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11616 %{
11617   match(Set cr (CmpU op1 op2));
11618 
11619   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11620   opcode(0x81,0x07); /* Opcode 81 /7 */
11621   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11622   ins_pipe(ialu_cr_reg_imm);
</pre>
<hr />
<pre>
11896 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11897 %{
11898   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11899 
11900   format %{ &quot;testq   $src, $mem&quot; %}
11901   opcode(0x85);
11902   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11903   ins_pipe(ialu_cr_reg_mem);
11904 %}
11905 
11906 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11907 %{
11908   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11909 
11910   format %{ &quot;testq   $src, $mem&quot; %}
11911   opcode(0x85);
11912   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11913   ins_pipe(ialu_cr_reg_mem);
11914 %}
11915 











11916 // Manifest a CmpL result in an integer register.  Very painful.
11917 // This is the test to avoid.
11918 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11919 %{
11920   match(Set dst (CmpL3 src1 src2));
11921   effect(KILL flags);
11922 
11923   ins_cost(275); // XXX
11924   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11925             &quot;movl    $dst, -1\n\t&quot;
11926             &quot;jl,s    done\n\t&quot;
11927             &quot;setne   $dst\n\t&quot;
11928             &quot;movzbl  $dst, $dst\n\t&quot;
11929     &quot;done:&quot; %}
11930   ins_encode(cmpl3_flag(src1, src2, dst));
11931   ins_pipe(pipe_slow);
11932 %}
11933 
11934 // Unsigned long compare Instructions; really, same as signed long except they
11935 // produce an rFlagsRegU instead of rFlagsReg.
</pre>
<hr />
<pre>
12563 
12564   ins_cost(300);
12565   format %{ &quot;call,runtime &quot; %}
12566   ins_encode(clear_avx, Java_To_Runtime(meth));
12567   ins_pipe(pipe_slow);
12568 %}
12569 
12570 // Call runtime without safepoint
12571 instruct CallLeafDirect(method meth)
12572 %{
12573   match(CallLeaf);
12574   effect(USE meth);
12575 
12576   ins_cost(300);
12577   format %{ &quot;call_leaf,runtime &quot; %}
12578   ins_encode(clear_avx, Java_To_Runtime(meth));
12579   ins_pipe(pipe_slow);
12580 %}
12581 
12582 // Call runtime without safepoint















12583 instruct CallLeafNoFPDirect(method meth)
12584 %{

12585   match(CallLeafNoFP);
12586   effect(USE meth);
12587 
12588   ins_cost(300);
12589   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12590   ins_encode(clear_avx, Java_To_Runtime(meth));
12591   ins_pipe(pipe_slow);
12592 %}
12593 
12594 // Return Instruction
12595 // Remove the return address &amp; jump to it.
12596 // Notice: We always emit a nop after a ret to make sure there is room
12597 // for safepoint patching
12598 instruct Ret()
12599 %{
12600   match(Return);
12601 
12602   format %{ &quot;ret&quot; %}
12603   opcode(0xC3);
12604   ins_encode(OpcP);
</pre>
</td>
<td>
<hr />
<pre>
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 



  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  872     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  873 
  874     Label L_skip_barrier;
  875     Register klass = rscratch1;
  876 
  877     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  879 
  880     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  881 
  882     __ bind(L_skip_barrier);
  883   }
  884 
<span class="line-modified">  885   __ verified_entry(C);</span>
<span class="line-added">  886   __ bind(*_verified_entry);</span>
<span class="line-added">  887 </span>
<span class="line-added">  888   if (C-&gt;stub_function() == NULL) {</span>
<span class="line-added">  889     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added">  890     bs-&gt;nmethod_entry_barrier(&amp;_masm);</span>
<span class="line-added">  891   }</span>
  892 
  893   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  894 
  895   if (C-&gt;has_mach_constant_base_node()) {
  896     // NOTE: We set the table base offset here because users might be
  897     // emitted before MachConstantBaseNode.
  898     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  899     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  900   }
  901 }
  902 






  903 int MachPrologNode::reloc() const
  904 {
  905   return 0; // a large enough number
  906 }
  907 
  908 //=============================================================================
  909 #ifndef PRODUCT
  910 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  911 {
  912   Compile* C = ra_-&gt;C;
  913   if (generate_vzeroupper(C)) {
  914     st-&gt;print(&quot;vzeroupper&quot;);
  915     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  916   }
  917 
  918   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  919   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  920   // Remove word for return adr already pushed
  921   // and RBP
  922   framesize -= 2*wordSize;
</pre>
<hr />
<pre>
  930   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  931     st-&gt;print(&quot;\t&quot;);
  932     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  933                  &quot;testl   rax, [rscratch1]\t&quot;
  934                  &quot;# Safepoint: poll for GC&quot;);
  935   }
  936 }
  937 #endif
  938 
  939 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  940 {
  941   Compile* C = ra_-&gt;C;
  942   MacroAssembler _masm(&amp;cbuf);
  943 
  944   if (generate_vzeroupper(C)) {
  945     // Clear upper bits of YMM registers when current compiled code uses
  946     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  947     __ vzeroupper();
  948   }
  949 
<span class="line-modified">  950   // Subtract two words to account for return address and rbp</span>
<span class="line-modified">  951   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;</span>
<span class="line-modified">  952   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());</span>




















  953 
  954   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  955     __ reserved_stack_check();
  956   }
  957 
  958   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  959     MacroAssembler _masm(&amp;cbuf);
  960     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  961     __ relocate(relocInfo::poll_return_type);
  962     __ testl(rax, Address(rscratch1, 0));
  963   }
  964 }
  965 






  966 int MachEpilogNode::reloc() const
  967 {
  968   return 2; // a large enough number
  969 }
  970 
  971 const Pipeline* MachEpilogNode::pipeline() const
  972 {
  973   return MachNode::pipeline_class();
  974 }
  975 
  976 //=============================================================================
  977 
  978 enum RC {
  979   rc_bad,
  980   rc_int,
  981   rc_float,
  982   rc_stack
  983 };
  984 
  985 static enum RC rc_class(OptoReg::Name reg)
</pre>
<hr />
<pre>
 1481     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1482     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1483     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1484     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1485     emit_d32(cbuf, offset);
 1486   } else {
 1487     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1488     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1489     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1490     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1491     emit_d8(cbuf, offset);
 1492   }
 1493 }
 1494 
 1495 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1496 {
 1497   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1498   return (offset &lt; 0x80) ? 5 : 8; // REX
 1499 }
 1500 
<span class="line-added"> 1501 //=============================================================================</span>
<span class="line-added"> 1502 #ifndef PRODUCT</span>
<span class="line-added"> 1503 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const</span>
<span class="line-added"> 1504 {</span>
<span class="line-added"> 1505   st-&gt;print_cr(&quot;MachVEPNode&quot;);</span>
<span class="line-added"> 1506 }</span>
<span class="line-added"> 1507 #endif</span>
<span class="line-added"> 1508 </span>
<span class="line-added"> 1509 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const</span>
<span class="line-added"> 1510 {</span>
<span class="line-added"> 1511   MacroAssembler masm(&amp;cbuf);</span>
<span class="line-added"> 1512   if (!_verified) {  </span>
<span class="line-added"> 1513     uint insts_size = cbuf.insts_size();</span>
<span class="line-added"> 1514     if (UseCompressedClassPointers) {</span>
<span class="line-added"> 1515       masm.load_klass(rscratch1, j_rarg0);</span>
<span class="line-added"> 1516       masm.cmpptr(rax, rscratch1);</span>
<span class="line-added"> 1517     } else {</span>
<span class="line-added"> 1518       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));</span>
<span class="line-added"> 1519     }</span>
<span class="line-added"> 1520     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));</span>
<span class="line-added"> 1521   } else {</span>
<span class="line-added"> 1522     // Unpack value type args passed as oop and then jump to</span>
<span class="line-added"> 1523     // the verified entry point (skipping the unverified entry).</span>
<span class="line-added"> 1524     masm.unpack_value_args(ra_-&gt;C, _receiver_only);</span>
<span class="line-added"> 1525     masm.jmp(*_verified_entry);</span>
<span class="line-added"> 1526   }</span>
<span class="line-added"> 1527 }</span>
<span class="line-added"> 1528 </span>
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1532 {
 1533   if (UseCompressedClassPointers) {
 1534     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1535     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1536     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1537   } else {
 1538     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1539                  &quot;# Inline cache check&quot;);
 1540   }
 1541   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1542   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1543 }
 1544 #endif
 1545 
 1546 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1547 {
 1548   MacroAssembler masm(&amp;cbuf);
</pre>
<hr />
<pre>
 1551     masm.load_klass(rscratch1, j_rarg0);
 1552     masm.cmpptr(rax, rscratch1);
 1553   } else {
 1554     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1555   }
 1556 
 1557   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1558 
 1559   /* WARNING these NOPs are critical so that verified entry point is properly
 1560      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1561   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1562   if (OptoBreakpoint) {
 1563     // Leave space for int3
 1564     nops_cnt -= 1;
 1565   }
 1566   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1567   if (nops_cnt &gt; 0)
 1568     masm.nop(nops_cnt);
 1569 }
 1570 







 1571 //=============================================================================
 1572 
 1573 int Matcher::regnum_to_fpu_offset(int regnum)
 1574 {
 1575   return regnum - 32; // The FP registers are in the second chunk
 1576 }
 1577 
 1578 // This is UltraSparc specific, true just means we have fast l2f conversion
 1579 const bool Matcher::convL2FSupported(void) {
 1580   return true;
 1581 }
 1582 
 1583 // Is this branch offset short enough that a short branch can be used?
 1584 //
 1585 // NOTE: If the platform does not provide any short branch variants, then
 1586 //       this method should return false for offset 0.
 1587 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1588   // The passed offset is relative to address of the branch.
 1589   // On 86 a branch displacement is calculated relative to address
 1590   // of a next instruction.
</pre>
<hr />
<pre>
 3836   %}
 3837 %}
 3838 
 3839 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3840 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3841 %{
 3842   constraint(ALLOC_IN_RC(ptr_reg));
 3843   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3844   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3845 
 3846   op_cost(10);
 3847   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3848   interface(MEMORY_INTER) %{
 3849     base($reg);
 3850     index($idx);
 3851     scale($scale);
 3852     disp($off);
 3853   %}
 3854 %}
 3855 
<span class="line-added"> 3856 // Indirect Narrow Oop Operand</span>
<span class="line-added"> 3857 operand indCompressedOop(rRegN reg) %{</span>
<span class="line-added"> 3858   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));</span>
<span class="line-added"> 3859   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="line-added"> 3860   match(DecodeN reg);</span>
<span class="line-added"> 3861 </span>
<span class="line-added"> 3862   op_cost(10);</span>
<span class="line-added"> 3863   format %{&quot;[R12 + $reg &lt;&lt; 3] (compressed oop addressing)&quot; %}</span>
<span class="line-added"> 3864   interface(MEMORY_INTER) %{</span>
<span class="line-added"> 3865     base(0xc); // R12</span>
<span class="line-added"> 3866     index($reg);</span>
<span class="line-added"> 3867     scale(0x3);</span>
<span class="line-added"> 3868     disp(0x0);</span>
<span class="line-added"> 3869   %}</span>
<span class="line-added"> 3870 %}</span>
<span class="line-added"> 3871 </span>
 3872 // Indirect Narrow Oop Plus Offset Operand
 3873 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3874 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3875 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3876   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3877   constraint(ALLOC_IN_RC(ptr_reg));
 3878   match(AddP (DecodeN reg) off);
 3879 
 3880   op_cost(10);
 3881   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3882   interface(MEMORY_INTER) %{
 3883     base(0xc); // R12
 3884     index($reg);
 3885     scale(0x3);
 3886     disp($off);
 3887   %}
 3888 %}
 3889 
 3890 // Indirect Memory Operand
 3891 operand indirectNarrow(rRegN reg)
</pre>
<hr />
<pre>
 4194     equal(0x4, &quot;e&quot;);
 4195     not_equal(0x5, &quot;ne&quot;);
 4196     less(0x2, &quot;b&quot;);
 4197     greater_equal(0x3, &quot;nb&quot;);
 4198     less_equal(0x6, &quot;be&quot;);
 4199     greater(0x7, &quot;nbe&quot;);
 4200     overflow(0x0, &quot;o&quot;);
 4201     no_overflow(0x1, &quot;no&quot;);
 4202   %}
 4203 %}
 4204 
 4205 //----------OPERAND CLASSES----------------------------------------------------
 4206 // Operand Classes are groups of operands that are used as to simplify
 4207 // instruction definitions by not requiring the AD writer to specify separate
 4208 // instructions for every form of operand when the instruction accepts
 4209 // multiple operand types with the same basic encoding and format.  The classic
 4210 // case of this is memory operands.
 4211 
 4212 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4213                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
<span class="line-modified"> 4214                indCompressedOop, indCompressedOopOffset,</span>
 4215                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4216                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4217                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4218 
 4219 //----------PIPELINE-----------------------------------------------------------
 4220 // Rules which define the behavior of the target architectures pipeline.
 4221 pipeline %{
 4222 
 4223 //----------ATTRIBUTES---------------------------------------------------------
 4224 attributes %{
 4225   variable_size_instructions;        // Fixed size instructions
 4226   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4227   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4228   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4229   instruction_fetch_units = 1;       // of 16 bytes
 4230 
 4231   // List of nop instructions
 4232   nops( MachNop );
 4233 %}
 4234 
</pre>
<hr />
<pre>
 6678   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6679   ins_encode( );
 6680   ins_pipe(empty);
 6681 %}
 6682 
 6683 //----------Move Instructions--------------------------------------------------
 6684 
 6685 instruct castX2P(rRegP dst, rRegL src)
 6686 %{
 6687   match(Set dst (CastX2P src));
 6688 
 6689   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6690   ins_encode %{
 6691     if ($dst$$reg != $src$$reg) {
 6692       __ movptr($dst$$Register, $src$$Register);
 6693     }
 6694   %}
 6695   ins_pipe(ialu_reg_reg); // XXX
 6696 %}
 6697 
<span class="line-added"> 6698 instruct castN2X(rRegL dst, rRegN src)</span>
<span class="line-added"> 6699 %{</span>
<span class="line-added"> 6700   match(Set dst (CastP2X src));</span>
<span class="line-added"> 6701 </span>
<span class="line-added"> 6702   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}</span>
<span class="line-added"> 6703   ins_encode %{</span>
<span class="line-added"> 6704     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6705       __ movptr($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6706     }</span>
<span class="line-added"> 6707   %}</span>
<span class="line-added"> 6708   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6709 %}</span>
<span class="line-added"> 6710 </span>
 6711 instruct castP2X(rRegL dst, rRegP src)
 6712 %{
 6713   match(Set dst (CastP2X src));
 6714 
 6715   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6716   ins_encode %{
 6717     if ($dst$$reg != $src$$reg) {
 6718       __ movptr($dst$$Register, $src$$Register);
 6719     }
 6720   %}
 6721   ins_pipe(ialu_reg_reg); // XXX
 6722 %}
 6723 
<span class="line-added"> 6724 instruct castN2I(rRegI dst, rRegN src)</span>
<span class="line-added"> 6725 %{</span>
<span class="line-added"> 6726   match(Set dst (CastN2I src));</span>
<span class="line-added"> 6727 </span>
<span class="line-added"> 6728   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}</span>
<span class="line-added"> 6729   ins_encode %{</span>
<span class="line-added"> 6730     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6731       __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6732     }</span>
<span class="line-added"> 6733   %}</span>
<span class="line-added"> 6734   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6735 %}</span>
<span class="line-added"> 6736 </span>
<span class="line-added"> 6737 instruct castI2N(rRegN dst, rRegI src)</span>
<span class="line-added"> 6738 %{</span>
<span class="line-added"> 6739   match(Set dst (CastI2N src));</span>
<span class="line-added"> 6740 </span>
<span class="line-added"> 6741   format %{ &quot;movl    $dst, $src\t# int -&gt; compressed ptr&quot; %}</span>
<span class="line-added"> 6742   ins_encode %{</span>
<span class="line-added"> 6743     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6744       __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6745     }</span>
<span class="line-added"> 6746   %}</span>
<span class="line-added"> 6747   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6748 %}</span>
<span class="line-added"> 6749 </span>
<span class="line-added"> 6750 </span>
 6751 // Convert oop into int for vectors alignment masking
 6752 instruct convP2I(rRegI dst, rRegP src)
 6753 %{
 6754   match(Set dst (ConvL2I (CastP2X src)));
 6755 
 6756   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6757   ins_encode %{
 6758     __ movl($dst$$Register, $src$$Register);
 6759   %}
 6760   ins_pipe(ialu_reg_reg); // XXX
 6761 %}
 6762 
 6763 // Convert compressed oop into int for vectors alignment masking
 6764 // in case of 32bit oops (heap &lt; 4Gb).
 6765 instruct convN2I(rRegI dst, rRegN src)
 6766 %{
 6767   predicate(CompressedOops::shift() == 0);
 6768   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6769 
 6770   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
</pre>
<hr />
<pre>
10962   ins_encode %{
10963     __ movdl($dst$$XMMRegister, $src$$Register);
10964   %}
10965   ins_pipe( pipe_slow );
10966 %}
10967 
10968 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10969   match(Set dst (MoveL2D src));
10970   effect(DEF dst, USE src);
10971   ins_cost(100);
10972   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10973   ins_encode %{
10974      __ movdq($dst$$XMMRegister, $src$$Register);
10975   %}
10976   ins_pipe( pipe_slow );
10977 %}
10978 
10979 
10980 // =======================================================================
10981 // fast clearing of an array
<span class="line-modified">10982 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
10983                   Universe dummy, rFlagsReg cr)
10984 %{
<span class="line-modified">10985   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-modified">10986   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-modified">10987   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
10988 
10989   format %{ $$template

10990     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10991     $$emit$$&quot;jg      LARGE\n\t&quot;
10992     $$emit$$&quot;dec     rcx\n\t&quot;
10993     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10994     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10995     $$emit$$&quot;dec     rcx\n\t&quot;
10996     $$emit$$&quot;jge     LOOP\n\t&quot;
10997     $$emit$$&quot;jmp     DONE\n\t&quot;
10998     $$emit$$&quot;# LARGE:\n\t&quot;
10999     if (UseFastStosb) {
11000        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11001        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
11002     } else if (UseXMMForObjInit) {
<span class="line-modified">11003        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-modified">11004        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11005        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
11006        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11007        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">11008        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-modified">11009        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
11010        $$emit$$&quot;add     0x40,rax\n\t&quot;
11011        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11012        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11013        $$emit$$&quot;jge     L_loop\n\t&quot;
11014        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11015        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">11016        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
11017        $$emit$$&quot;add     0x20,rax\n\t&quot;
11018        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11019        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11020        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11021        $$emit$$&quot;jle     L_end\n\t&quot;
11022        $$emit$$&quot;dec     rcx\n\t&quot;
11023        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11024        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11025        $$emit$$&quot;add     0x8,rax\n\t&quot;
11026        $$emit$$&quot;dec     rcx\n\t&quot;
11027        $$emit$$&quot;jge     L_sloop\n\t&quot;
11028        $$emit$$&quot;# L_end:\n\t&quot;
11029     } else {
11030        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11031     }
11032     $$emit$$&quot;# DONE&quot;
11033   %}
11034   ins_encode %{
<span class="line-modified">11035     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-modified">11036                  $tmp$$XMMRegister, false, false);</span>
11037   %}
11038   ins_pipe(pipe_slow);
11039 %}
11040 
<span class="line-modified">11041 instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
<span class="line-added">11042                   Universe dummy, rFlagsReg cr)</span>
<span class="line-added">11043 %{</span>
<span class="line-added">11044   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-added">11045   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-added">11046   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
<span class="line-added">11047 </span>
<span class="line-added">11048   format %{ $$template</span>
<span class="line-added">11049     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;</span>
<span class="line-added">11050     $$emit$$&quot;jg      LARGE\n\t&quot;</span>
<span class="line-added">11051     $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11052     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;</span>
<span class="line-added">11053     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;</span>
<span class="line-added">11054     $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11055     $$emit$$&quot;jge     LOOP\n\t&quot;</span>
<span class="line-added">11056     $$emit$$&quot;jmp     DONE\n\t&quot;</span>
<span class="line-added">11057     $$emit$$&quot;# LARGE:\n\t&quot;</span>
<span class="line-added">11058     if (UseXMMForObjInit) {</span>
<span class="line-added">11059        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-added">11060        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11061        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11062        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;</span>
<span class="line-added">11063        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;</span>
<span class="line-added">11064        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11065        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
<span class="line-added">11066        $$emit$$&quot;add     0x40,rax\n\t&quot;</span>
<span class="line-added">11067        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;</span>
<span class="line-added">11068        $$emit$$&quot;sub     0x8,rcx\n\t&quot;</span>
<span class="line-added">11069        $$emit$$&quot;jge     L_loop\n\t&quot;</span>
<span class="line-added">11070        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11071        $$emit$$&quot;jl      L_tail\n\t&quot;</span>
<span class="line-added">11072        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11073        $$emit$$&quot;add     0x20,rax\n\t&quot;</span>
<span class="line-added">11074        $$emit$$&quot;sub     0x4,rcx\n\t&quot;</span>
<span class="line-added">11075        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;</span>
<span class="line-added">11076        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11077        $$emit$$&quot;jle     L_end\n\t&quot;</span>
<span class="line-added">11078        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11079        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;</span>
<span class="line-added">11080        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;</span>
<span class="line-added">11081        $$emit$$&quot;add     0x8,rax\n\t&quot;</span>
<span class="line-added">11082        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11083        $$emit$$&quot;jge     L_sloop\n\t&quot;</span>
<span class="line-added">11084        $$emit$$&quot;# L_end:\n\t&quot;</span>
<span class="line-added">11085     } else {</span>
<span class="line-added">11086        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;</span>
<span class="line-added">11087     }</span>
<span class="line-added">11088     $$emit$$&quot;# DONE&quot;</span>
<span class="line-added">11089   %}</span>
<span class="line-added">11090   ins_encode %{</span>
<span class="line-added">11091     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-added">11092                  $tmp$$XMMRegister, false, true);</span>
<span class="line-added">11093   %}</span>
<span class="line-added">11094   ins_pipe(pipe_slow);</span>
<span class="line-added">11095 %}</span>
<span class="line-added">11096 </span>
<span class="line-added">11097 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
11098                         Universe dummy, rFlagsReg cr)
11099 %{
<span class="line-modified">11100   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-modified">11101   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-modified">11102   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
11103 
11104   format %{ $$template
11105     if (UseFastStosb) {

11106        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11107        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11108     } else if (UseXMMForObjInit) {
<span class="line-modified">11109        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-modified">11110        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11111        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11112        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;</span>
<span class="line-added">11113        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;</span>
<span class="line-added">11114        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11115        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
<span class="line-added">11116        $$emit$$&quot;add     0x40,rax\n\t&quot;</span>
<span class="line-added">11117        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;</span>
<span class="line-added">11118        $$emit$$&quot;sub     0x8,rcx\n\t&quot;</span>
<span class="line-added">11119        $$emit$$&quot;jge     L_loop\n\t&quot;</span>
<span class="line-added">11120        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11121        $$emit$$&quot;jl      L_tail\n\t&quot;</span>
<span class="line-added">11122        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11123        $$emit$$&quot;add     0x20,rax\n\t&quot;</span>
<span class="line-added">11124        $$emit$$&quot;sub     0x4,rcx\n\t&quot;</span>
<span class="line-added">11125        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;</span>
<span class="line-added">11126        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11127        $$emit$$&quot;jle     L_end\n\t&quot;</span>
<span class="line-added">11128        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11129        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;</span>
<span class="line-added">11130        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;</span>
<span class="line-added">11131        $$emit$$&quot;add     0x8,rax\n\t&quot;</span>
<span class="line-added">11132        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11133        $$emit$$&quot;jge     L_sloop\n\t&quot;</span>
<span class="line-added">11134        $$emit$$&quot;# L_end:\n\t&quot;</span>
<span class="line-added">11135     } else {</span>
<span class="line-added">11136        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;</span>
<span class="line-added">11137     }</span>
<span class="line-added">11138   %}</span>
<span class="line-added">11139   ins_encode %{</span>
<span class="line-added">11140     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-added">11141                  $tmp$$XMMRegister, true, false);</span>
<span class="line-added">11142   %}</span>
<span class="line-added">11143   ins_pipe(pipe_slow);</span>
<span class="line-added">11144 %}</span>
<span class="line-added">11145 </span>
<span class="line-added">11146 instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val, </span>
<span class="line-added">11147                         Universe dummy, rFlagsReg cr)</span>
<span class="line-added">11148 %{</span>
<span class="line-added">11149   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-added">11150   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-added">11151   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
<span class="line-added">11152 </span>
<span class="line-added">11153   format %{ $$template</span>
<span class="line-added">11154     if (UseXMMForObjInit) {</span>
<span class="line-added">11155        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-added">11156        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11157        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
11158        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11159        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">11160        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-modified">11161        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
11162        $$emit$$&quot;add     0x40,rax\n\t&quot;
11163        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11164        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11165        $$emit$$&quot;jge     L_loop\n\t&quot;
11166        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11167        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">11168        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
11169        $$emit$$&quot;add     0x20,rax\n\t&quot;
11170        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11171        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11172        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11173        $$emit$$&quot;jle     L_end\n\t&quot;
11174        $$emit$$&quot;dec     rcx\n\t&quot;
11175        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11176        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11177        $$emit$$&quot;add     0x8,rax\n\t&quot;
11178        $$emit$$&quot;dec     rcx\n\t&quot;
11179        $$emit$$&quot;jge     L_sloop\n\t&quot;
11180        $$emit$$&quot;# L_end:\n\t&quot;
11181     } else {

11182        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11183     }
11184   %}
11185   ins_encode %{
<span class="line-modified">11186     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register, </span>
<span class="line-modified">11187                  $tmp$$XMMRegister, true, true);</span>
11188   %}
11189   ins_pipe(pipe_slow);
11190 %}
11191 
11192 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11193                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11194 %{
11195   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11196   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11197   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11198 
11199   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11200   ins_encode %{
11201     __ string_compare($str1$$Register, $str2$$Register,
11202                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11203                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11204   %}
11205   ins_pipe( pipe_slow );
11206 %}
11207 
</pre>
<hr />
<pre>
11732 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11733 %{
11734   match(Set cr (CmpI (AndI src con) zero));
11735 
11736   format %{ &quot;testl   $src, $con&quot; %}
11737   opcode(0xF7, 0x00);
11738   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11739   ins_pipe(ialu_cr_reg_imm);
11740 %}
11741 
11742 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11743 %{
11744   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11745 
11746   format %{ &quot;testl   $src, $mem&quot; %}
11747   opcode(0x85);
11748   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11749   ins_pipe(ialu_cr_reg_mem);
11750 %}
11751 
<span class="line-added">11752 // Fold array properties check</span>
<span class="line-added">11753 instruct testI_mem_imm(rFlagsReg cr, memory mem, immI con, immI0 zero)</span>
<span class="line-added">11754 %{</span>
<span class="line-added">11755   match(Set cr (CmpI (AndI (CastN2I (LoadNKlass mem)) con) zero));</span>
<span class="line-added">11756 </span>
<span class="line-added">11757   format %{ &quot;testl   $mem, $con&quot; %}</span>
<span class="line-added">11758   opcode(0xF7, 0x00);</span>
<span class="line-added">11759   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));</span>
<span class="line-added">11760   ins_pipe(ialu_mem_imm);</span>
<span class="line-added">11761 %}</span>
<span class="line-added">11762 </span>
<span class="line-added">11763 // Clear array property bits</span>
<span class="line-added">11764 instruct clear_property_bits(rRegN dst, memory mem, immU31 mask, rFlagsReg cr)</span>
<span class="line-added">11765 %{</span>
<span class="line-added">11766   match(Set dst (CastI2N (AndI (CastN2I (LoadNKlass mem)) mask)));</span>
<span class="line-added">11767   effect(KILL cr);</span>
<span class="line-added">11768 </span>
<span class="line-added">11769   format %{ &quot;movl    $dst, $mem\t# clear property bits\n\t&quot;</span>
<span class="line-added">11770             &quot;andl    $dst, $mask&quot; %}</span>
<span class="line-added">11771   ins_encode %{</span>
<span class="line-added">11772     __ movl($dst$$Register, $mem$$Address);</span>
<span class="line-added">11773     __ andl($dst$$Register, $mask$$constant);</span>
<span class="line-added">11774   %}</span>
<span class="line-added">11775   ins_pipe(ialu_reg_mem);</span>
<span class="line-added">11776 %}</span>
<span class="line-added">11777 </span>
11778 // Unsigned compare Instructions; really, same as signed except they
11779 // produce an rFlagsRegU instead of rFlagsReg.
11780 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11781 %{
11782   match(Set cr (CmpU op1 op2));
11783 
11784   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11785   opcode(0x3B); /* Opcode 3B /r */
11786   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11787   ins_pipe(ialu_cr_reg_reg);
11788 %}
11789 
11790 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11791 %{
11792   match(Set cr (CmpU op1 op2));
11793 
11794   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11795   opcode(0x81,0x07); /* Opcode 81 /7 */
11796   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11797   ins_pipe(ialu_cr_reg_imm);
</pre>
<hr />
<pre>
12071 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12072 %{
12073   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12074 
12075   format %{ &quot;testq   $src, $mem&quot; %}
12076   opcode(0x85);
12077   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12078   ins_pipe(ialu_cr_reg_mem);
12079 %}
12080 
12081 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12082 %{
12083   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12084 
12085   format %{ &quot;testq   $src, $mem&quot; %}
12086   opcode(0x85);
12087   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12088   ins_pipe(ialu_cr_reg_mem);
12089 %}
12090 
<span class="line-added">12091 // Fold array properties check</span>
<span class="line-added">12092 instruct testL_reg_mem3(rFlagsReg cr, memory mem, rRegL src, immL0 zero)</span>
<span class="line-added">12093 %{</span>
<span class="line-added">12094   match(Set cr (CmpL (AndL (CastP2X (LoadKlass mem)) src) zero));</span>
<span class="line-added">12095 </span>
<span class="line-added">12096   format %{ &quot;testq   $src, $mem\t# test array properties&quot; %}</span>
<span class="line-added">12097   opcode(0x85);</span>
<span class="line-added">12098   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));</span>
<span class="line-added">12099   ins_pipe(ialu_cr_reg_mem);</span>
<span class="line-added">12100 %}</span>
<span class="line-added">12101 </span>
12102 // Manifest a CmpL result in an integer register.  Very painful.
12103 // This is the test to avoid.
12104 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12105 %{
12106   match(Set dst (CmpL3 src1 src2));
12107   effect(KILL flags);
12108 
12109   ins_cost(275); // XXX
12110   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12111             &quot;movl    $dst, -1\n\t&quot;
12112             &quot;jl,s    done\n\t&quot;
12113             &quot;setne   $dst\n\t&quot;
12114             &quot;movzbl  $dst, $dst\n\t&quot;
12115     &quot;done:&quot; %}
12116   ins_encode(cmpl3_flag(src1, src2, dst));
12117   ins_pipe(pipe_slow);
12118 %}
12119 
12120 // Unsigned long compare Instructions; really, same as signed long except they
12121 // produce an rFlagsRegU instead of rFlagsReg.
</pre>
<hr />
<pre>
12749 
12750   ins_cost(300);
12751   format %{ &quot;call,runtime &quot; %}
12752   ins_encode(clear_avx, Java_To_Runtime(meth));
12753   ins_pipe(pipe_slow);
12754 %}
12755 
12756 // Call runtime without safepoint
12757 instruct CallLeafDirect(method meth)
12758 %{
12759   match(CallLeaf);
12760   effect(USE meth);
12761 
12762   ins_cost(300);
12763   format %{ &quot;call_leaf,runtime &quot; %}
12764   ins_encode(clear_avx, Java_To_Runtime(meth));
12765   ins_pipe(pipe_slow);
12766 %}
12767 
12768 // Call runtime without safepoint
<span class="line-added">12769 // entry point is null, target holds the address to call</span>
<span class="line-added">12770 instruct CallLeafNoFPInDirect(rRegP target)</span>
<span class="line-added">12771 %{</span>
<span class="line-added">12772   predicate(n-&gt;as_Call()-&gt;entry_point() == NULL);</span>
<span class="line-added">12773   match(CallLeafNoFP target);</span>
<span class="line-added">12774 </span>
<span class="line-added">12775   ins_cost(300);</span>
<span class="line-added">12776   format %{ &quot;call_leaf_nofp,runtime indirect &quot; %}</span>
<span class="line-added">12777   ins_encode %{</span>
<span class="line-added">12778      __ call($target$$Register);</span>
<span class="line-added">12779   %}</span>
<span class="line-added">12780 </span>
<span class="line-added">12781   ins_pipe(pipe_slow);</span>
<span class="line-added">12782 %}</span>
<span class="line-added">12783 </span>
12784 instruct CallLeafNoFPDirect(method meth)
12785 %{
<span class="line-added">12786   predicate(n-&gt;as_Call()-&gt;entry_point() != NULL);</span>
12787   match(CallLeafNoFP);
12788   effect(USE meth);
12789 
12790   ins_cost(300);
12791   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12792   ins_encode(clear_avx, Java_To_Runtime(meth));
12793   ins_pipe(pipe_slow);
12794 %}
12795 
12796 // Return Instruction
12797 // Remove the return address &amp; jump to it.
12798 // Notice: We always emit a nop after a ret to make sure there is room
12799 // for safepoint patching
12800 instruct Ret()
12801 %{
12802   match(Return);
12803 
12804   format %{ &quot;ret&quot; %}
12805   opcode(0xC3);
12806   ins_encode(OpcP);
</pre>
</td>
</tr>
</table>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/formssel.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
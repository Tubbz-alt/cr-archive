<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/frame_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/frame_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
118       // which can be different from the sender unextended sp (the sp seen
119       // by the sender) because of current frame local variables
120       sender_sp = (intptr_t*) addr_at(sender_sp_offset);
121       sender_unextended_sp = (intptr_t*) this-&gt;fp()[interpreter_frame_sender_sp_offset];
122       saved_fp = (intptr_t*) this-&gt;fp()[link_offset];
123 
124     } else {
125       // must be some sort of compiled/runtime frame
126       // fp does not have to be safe (although it could be check for c1?)
127 
128       // check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc
129       if (_cb-&gt;frame_size() &lt;= 0) {
130         return false;
131       }
132 
133       sender_sp = _unextended_sp + _cb-&gt;frame_size();
134       // Is sender_sp safe?
135       if (!thread-&gt;is_in_full_stack_checked((address)sender_sp)) {
136         return false;
137       }
<span class="line-removed">138       sender_unextended_sp = sender_sp;</span>
139       // On Intel the return_address is always the word on the stack
140       sender_pc = (address) *(sender_sp-1);
141       // Note: frame::sender_sp_offset is only valid for compiled frame
<span class="line-modified">142       saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);</span>
<span class="line-modified">143     }</span>
144 




145 
146     // If the potential sender is the interpreter then we can do some more checking
147     if (Interpreter::contains(sender_pc)) {
148 
149       // ebp is always saved in a recognizable place in any code we generate. However
150       // only if the sender is interpreted/call_stub (c1 too?) are we certain that the saved ebp
151       // is really a frame pointer.
152 
153       if (!thread-&gt;is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {
154         return false;
155       }
156 
157       // construct the potential sender
158 
159       frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);
160 
161       return sender.is_interpreted_frame_valid(thread);
162 
163     }
164 
</pre>
<hr />
<pre>
422   intptr_t* unextended_sp = interpreter_frame_sender_sp();
423 
424 #if COMPILER2_OR_JVMCI
425   if (map-&gt;update_map()) {
426     update_map_with_saved_link(map, (intptr_t**) addr_at(link_offset));
427   }
428 #endif // COMPILER2_OR_JVMCI
429 
430   return frame(sender_sp, unextended_sp, link(), sender_pc());
431 }
432 
433 
434 //------------------------------------------------------------------------------
435 // frame::sender_for_compiled_frame
436 frame frame::sender_for_compiled_frame(RegisterMap* map) const {
437   assert(map != NULL, &quot;map must be set&quot;);
438 
439   // frame owned by optimizing compiler
440   assert(_cb-&gt;frame_size() &gt;= 0, &quot;must have non-zero frame size&quot;);
441   intptr_t* sender_sp = unextended_sp() + _cb-&gt;frame_size();
<span class="line-modified">442   intptr_t* unextended_sp = sender_sp;</span>
<span class="line-modified">443 </span>
<span class="line-modified">444   // On Intel the return_address is always the word on the stack</span>
445   address sender_pc = (address) *(sender_sp-1);
446 
447   // This is the saved value of EBP which may or may not really be an FP.
448   // It is only an FP if the sender is an interpreter frame (or C1?).
449   intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);
450 
















451   if (map-&gt;update_map()) {
452     // Tell GC to use argument oopmaps for some runtime stubs that need it.
453     // For C1, the runtime stub might not have oop maps, so set this flag
454     // outside of update_register_map.
<span class="line-modified">455     map-&gt;set_include_argument_oops(_cb-&gt;caller_must_gc_arguments(map-&gt;thread()));</span>



















456     if (_cb-&gt;oop_maps() != NULL) {
457       OopMapSet::update_register_map(this, map);
458     }
459 
460     // Since the prolog does the save and restore of EBP there is no oopmap
461     // for it so we must fill in its location as if there was an oopmap entry
462     // since if our caller was compiled code there could be live jvm state in it.
463     update_map_with_saved_link(map, saved_fp_addr);
464   }
465 
466   assert(sender_sp != sp(), &quot;must have changed&quot;);
<span class="line-modified">467   return frame(sender_sp, unextended_sp, *saved_fp_addr, sender_pc);</span>
468 }
469 
470 
471 //------------------------------------------------------------------------------
472 // frame::sender
473 frame frame::sender(RegisterMap* map) const {
<span class="line-modified">474   // Default is we done have to follow them. The sender_for_xxx will</span>
475   // update it accordingly
476   map-&gt;set_include_argument_oops(false);
477 
478   if (is_entry_frame())       return sender_for_entry_frame(map);
479   if (is_interpreted_frame()) return sender_for_interpreter_frame(map);
480   assert(_cb == CodeCache::find_blob(pc()),&quot;Must be the same&quot;);
481 
482   if (_cb != NULL) {
483     return sender_for_compiled_frame(map);
484   }
485   // Must be native-compiled frame, i.e. the marshaling code for native
486   // methods that exists in the core system.
487   return frame(sender_sp(), link(), sender_pc());
488 }
489 
490 bool frame::is_interpreted_frame_valid(JavaThread* thread) const {
491   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
492   // These are reasonable sanity checks
493   if (fp() == 0 || (intptr_t(fp()) &amp; (wordSize-1)) != 0) {
494     return false;
</pre>
<hr />
<pre>
549     // Prior to calling into the runtime to report the method_exit the possible
550     // return value is pushed to the native stack. If the result is a jfloat/jdouble
551     // then ST0 is saved before EAX/EDX. See the note in generate_native_result
552     tos_addr = (intptr_t*)sp();
553     if (type == T_FLOAT || type == T_DOUBLE) {
554     // QQQ seems like this code is equivalent on the two platforms
555 #ifdef AMD64
556       // This is times two because we do a push(ltos) after pushing XMM0
557       // and that takes two interpreter stack slots.
558       tos_addr += 2 * Interpreter::stackElementWords;
559 #else
560       tos_addr += 2;
561 #endif // AMD64
562     }
563   } else {
564     tos_addr = (intptr_t*)interpreter_frame_tos_address();
565   }
566 
567   switch (type) {
568     case T_OBJECT  :

569     case T_ARRAY   : {
570       oop obj;
571       if (method-&gt;is_native()) {
572         obj = cast_to_oop(at(interpreter_frame_oop_temp_offset));
573       } else {
574         oop* obj_p = (oop*)tos_addr;
575         obj = (obj_p == NULL) ? (oop)NULL : *obj_p;
576       }
577       assert(obj == NULL || Universe::heap()-&gt;is_in(obj), &quot;sanity check&quot;);
578       *oop_result = obj;
579       break;
580     }
581     case T_BOOLEAN : value_result-&gt;z = *(jboolean*)tos_addr; break;
582     case T_BYTE    : value_result-&gt;b = *(jbyte*)tos_addr; break;
583     case T_CHAR    : value_result-&gt;c = *(jchar*)tos_addr; break;
584     case T_SHORT   : value_result-&gt;s = *(jshort*)tos_addr; break;
585     case T_INT     : value_result-&gt;i = *(jint*)tos_addr; break;
586     case T_LONG    : value_result-&gt;j = *(jlong*)tos_addr; break;
587     case T_FLOAT   : {
588 #ifdef AMD64
</pre>
<hr />
<pre>
650     // use the frame size if valid
651     int size = _cb-&gt;frame_size();
652     if (size &gt; 0) {
653       return unextended_sp() + size;
654     }
655   }
656   // else rely on fp()
657   assert(! is_compiled_frame(), &quot;unknown compiled frame size&quot;);
658   return fp();
659 }
660 
661 #ifndef PRODUCT
662 // This is a generic constructor which is only used by pns() in debug.cpp.
663 frame::frame(void* sp, void* fp, void* pc) {
664   init((intptr_t*)sp, (intptr_t*)fp, (address)pc);
665 }
666 
667 void frame::pd_ps() {}
668 #endif
669 















670 void JavaFrameAnchor::make_walkable(JavaThread* thread) {
671   // last frame set?
672   if (last_Java_sp() == NULL) return;
673   // already walkable?
674   if (walkable()) return;
675   vmassert(Thread::current() == (Thread*)thread, &quot;not current thread&quot;);
676   vmassert(last_Java_sp() != NULL, &quot;not called from Java code?&quot;);
677   vmassert(last_Java_pc() == NULL, &quot;already walkable&quot;);
678   capture_last_Java_pc();
679   vmassert(walkable(), &quot;something went wrong&quot;);
680 }
681 
682 void JavaFrameAnchor::capture_last_Java_pc() {
683   vmassert(_last_Java_sp != NULL, &quot;no last frame set&quot;);
684   vmassert(_last_Java_pc == NULL, &quot;already walkable&quot;);
685   _last_Java_pc = (address)_last_Java_sp[-1];
686 }
</pre>
</td>
<td>
<hr />
<pre>
118       // which can be different from the sender unextended sp (the sp seen
119       // by the sender) because of current frame local variables
120       sender_sp = (intptr_t*) addr_at(sender_sp_offset);
121       sender_unextended_sp = (intptr_t*) this-&gt;fp()[interpreter_frame_sender_sp_offset];
122       saved_fp = (intptr_t*) this-&gt;fp()[link_offset];
123 
124     } else {
125       // must be some sort of compiled/runtime frame
126       // fp does not have to be safe (although it could be check for c1?)
127 
128       // check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc
129       if (_cb-&gt;frame_size() &lt;= 0) {
130         return false;
131       }
132 
133       sender_sp = _unextended_sp + _cb-&gt;frame_size();
134       // Is sender_sp safe?
135       if (!thread-&gt;is_in_full_stack_checked((address)sender_sp)) {
136         return false;
137       }

138       // On Intel the return_address is always the word on the stack
139       sender_pc = (address) *(sender_sp-1);
140       // Note: frame::sender_sp_offset is only valid for compiled frame
<span class="line-modified">141       intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);</span>
<span class="line-modified">142       saved_fp = *saved_fp_addr;</span>
143 
<span class="line-added">144       // Repair the sender sp if this is a method with scalarized value type args</span>
<span class="line-added">145       sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);</span>
<span class="line-added">146       sender_unextended_sp = sender_sp;</span>
<span class="line-added">147     }</span>
148 
149     // If the potential sender is the interpreter then we can do some more checking
150     if (Interpreter::contains(sender_pc)) {
151 
152       // ebp is always saved in a recognizable place in any code we generate. However
153       // only if the sender is interpreted/call_stub (c1 too?) are we certain that the saved ebp
154       // is really a frame pointer.
155 
156       if (!thread-&gt;is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {
157         return false;
158       }
159 
160       // construct the potential sender
161 
162       frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);
163 
164       return sender.is_interpreted_frame_valid(thread);
165 
166     }
167 
</pre>
<hr />
<pre>
425   intptr_t* unextended_sp = interpreter_frame_sender_sp();
426 
427 #if COMPILER2_OR_JVMCI
428   if (map-&gt;update_map()) {
429     update_map_with_saved_link(map, (intptr_t**) addr_at(link_offset));
430   }
431 #endif // COMPILER2_OR_JVMCI
432 
433   return frame(sender_sp, unextended_sp, link(), sender_pc());
434 }
435 
436 
437 //------------------------------------------------------------------------------
438 // frame::sender_for_compiled_frame
439 frame frame::sender_for_compiled_frame(RegisterMap* map) const {
440   assert(map != NULL, &quot;map must be set&quot;);
441 
442   // frame owned by optimizing compiler
443   assert(_cb-&gt;frame_size() &gt;= 0, &quot;must have non-zero frame size&quot;);
444   intptr_t* sender_sp = unextended_sp() + _cb-&gt;frame_size();
<span class="line-modified">445 </span>
<span class="line-modified">446 #ifdef ASSERT</span>
<span class="line-modified">447   address sender_pc_copy = (address) *(sender_sp-1);</span>
448 #endif
449 
450   // This is the saved value of EBP which may or may not really be an FP.
451   // It is only an FP if the sender is an interpreter frame (or C1?).
452   intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);
453 
<span class="line-added">454   // Repair the sender sp if the frame has been extended</span>
<span class="line-added">455   sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);</span>
<span class="line-added">456 </span>
<span class="line-added">457   // On Intel the return_address is always the word on the stack</span>
<span class="line-added">458   address sender_pc = (address) *(sender_sp-1);</span>
<span class="line-added">459 </span>
<span class="line-added">460 #ifdef ASSERT</span>
<span class="line-added">461   if (sender_pc != sender_pc_copy) {</span>
<span class="line-added">462     // When extending the stack in the callee method entry to make room for unpacking of value</span>
<span class="line-added">463     // type args, we keep a copy of the sender pc at the expected location in the callee frame.</span>
<span class="line-added">464     // If the sender pc is patched due to deoptimization, the copy is not consistent anymore.</span>
<span class="line-added">465     nmethod* nm = CodeCache::find_blob(sender_pc)-&gt;as_nmethod();</span>
<span class="line-added">466     assert(sender_pc == nm-&gt;deopt_mh_handler_begin() || sender_pc == nm-&gt;deopt_handler_begin(), &quot;unexpected sender pc&quot;);</span>
<span class="line-added">467   }</span>
<span class="line-added">468 #endif</span>
<span class="line-added">469 </span>
470   if (map-&gt;update_map()) {
471     // Tell GC to use argument oopmaps for some runtime stubs that need it.
472     // For C1, the runtime stub might not have oop maps, so set this flag
473     // outside of update_register_map.
<span class="line-modified">474     bool caller_args = _cb-&gt;caller_must_gc_arguments(map-&gt;thread());</span>
<span class="line-added">475 #ifdef COMPILER1</span>
<span class="line-added">476     if (!caller_args) {</span>
<span class="line-added">477       nmethod* nm = _cb-&gt;as_nmethod_or_null();</span>
<span class="line-added">478       if (nm != NULL &amp;&amp; nm-&gt;is_compiled_by_c1() &amp;&amp; nm-&gt;method()-&gt;has_scalarized_args() &amp;&amp;</span>
<span class="line-added">479           pc() &lt; nm-&gt;verified_value_entry_point()) {</span>
<span class="line-added">480         // The VEP and VVEP(RO) of C1-compiled methods call buffer_value_args_xxx</span>
<span class="line-added">481         // before doing any argument shuffling, so we need to scan the oops</span>
<span class="line-added">482         // as the caller passes them.</span>
<span class="line-added">483         caller_args = true;</span>
<span class="line-added">484 #ifdef ASSERT</span>
<span class="line-added">485         NativeCall* call = nativeCall_before(pc());</span>
<span class="line-added">486         address dest = call-&gt;destination();</span>
<span class="line-added">487         assert(dest == Runtime1::entry_for(Runtime1::buffer_value_args_no_receiver_id) ||</span>
<span class="line-added">488                dest == Runtime1::entry_for(Runtime1::buffer_value_args_id), &quot;unexpected safepoint in entry point&quot;);</span>
<span class="line-added">489 #endif</span>
<span class="line-added">490       }</span>
<span class="line-added">491     }</span>
<span class="line-added">492 #endif</span>
<span class="line-added">493     map-&gt;set_include_argument_oops(caller_args);</span>
494     if (_cb-&gt;oop_maps() != NULL) {
495       OopMapSet::update_register_map(this, map);
496     }
497 
498     // Since the prolog does the save and restore of EBP there is no oopmap
499     // for it so we must fill in its location as if there was an oopmap entry
500     // since if our caller was compiled code there could be live jvm state in it.
501     update_map_with_saved_link(map, saved_fp_addr);
502   }
503 
504   assert(sender_sp != sp(), &quot;must have changed&quot;);
<span class="line-modified">505   return frame(sender_sp, sender_sp, *saved_fp_addr, sender_pc);</span>
506 }
507 
508 
509 //------------------------------------------------------------------------------
510 // frame::sender
511 frame frame::sender(RegisterMap* map) const {
<span class="line-modified">512   // Default is we don&#39;t have to follow them. The sender_for_xxx will</span>
513   // update it accordingly
514   map-&gt;set_include_argument_oops(false);
515 
516   if (is_entry_frame())       return sender_for_entry_frame(map);
517   if (is_interpreted_frame()) return sender_for_interpreter_frame(map);
518   assert(_cb == CodeCache::find_blob(pc()),&quot;Must be the same&quot;);
519 
520   if (_cb != NULL) {
521     return sender_for_compiled_frame(map);
522   }
523   // Must be native-compiled frame, i.e. the marshaling code for native
524   // methods that exists in the core system.
525   return frame(sender_sp(), link(), sender_pc());
526 }
527 
528 bool frame::is_interpreted_frame_valid(JavaThread* thread) const {
529   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
530   // These are reasonable sanity checks
531   if (fp() == 0 || (intptr_t(fp()) &amp; (wordSize-1)) != 0) {
532     return false;
</pre>
<hr />
<pre>
587     // Prior to calling into the runtime to report the method_exit the possible
588     // return value is pushed to the native stack. If the result is a jfloat/jdouble
589     // then ST0 is saved before EAX/EDX. See the note in generate_native_result
590     tos_addr = (intptr_t*)sp();
591     if (type == T_FLOAT || type == T_DOUBLE) {
592     // QQQ seems like this code is equivalent on the two platforms
593 #ifdef AMD64
594       // This is times two because we do a push(ltos) after pushing XMM0
595       // and that takes two interpreter stack slots.
596       tos_addr += 2 * Interpreter::stackElementWords;
597 #else
598       tos_addr += 2;
599 #endif // AMD64
600     }
601   } else {
602     tos_addr = (intptr_t*)interpreter_frame_tos_address();
603   }
604 
605   switch (type) {
606     case T_OBJECT  :
<span class="line-added">607     case T_VALUETYPE:</span>
608     case T_ARRAY   : {
609       oop obj;
610       if (method-&gt;is_native()) {
611         obj = cast_to_oop(at(interpreter_frame_oop_temp_offset));
612       } else {
613         oop* obj_p = (oop*)tos_addr;
614         obj = (obj_p == NULL) ? (oop)NULL : *obj_p;
615       }
616       assert(obj == NULL || Universe::heap()-&gt;is_in(obj), &quot;sanity check&quot;);
617       *oop_result = obj;
618       break;
619     }
620     case T_BOOLEAN : value_result-&gt;z = *(jboolean*)tos_addr; break;
621     case T_BYTE    : value_result-&gt;b = *(jbyte*)tos_addr; break;
622     case T_CHAR    : value_result-&gt;c = *(jchar*)tos_addr; break;
623     case T_SHORT   : value_result-&gt;s = *(jshort*)tos_addr; break;
624     case T_INT     : value_result-&gt;i = *(jint*)tos_addr; break;
625     case T_LONG    : value_result-&gt;j = *(jlong*)tos_addr; break;
626     case T_FLOAT   : {
627 #ifdef AMD64
</pre>
<hr />
<pre>
689     // use the frame size if valid
690     int size = _cb-&gt;frame_size();
691     if (size &gt; 0) {
692       return unextended_sp() + size;
693     }
694   }
695   // else rely on fp()
696   assert(! is_compiled_frame(), &quot;unknown compiled frame size&quot;);
697   return fp();
698 }
699 
700 #ifndef PRODUCT
701 // This is a generic constructor which is only used by pns() in debug.cpp.
702 frame::frame(void* sp, void* fp, void* pc) {
703   init((intptr_t*)sp, (intptr_t*)fp, (address)pc);
704 }
705 
706 void frame::pd_ps() {}
707 #endif
708 
<span class="line-added">709 // Check for a method with scalarized value type arguments that needs</span>
<span class="line-added">710 // a stack repair and return the repaired sender stack pointer.</span>
<span class="line-added">711 intptr_t* frame::repair_sender_sp(intptr_t* sender_sp, intptr_t** saved_fp_addr) const {</span>
<span class="line-added">712   CompiledMethod* cm = _cb-&gt;as_compiled_method_or_null();</span>
<span class="line-added">713   if (cm != NULL &amp;&amp; cm-&gt;needs_stack_repair()) {</span>
<span class="line-added">714     // The stack increment resides just below the saved rbp on the stack</span>
<span class="line-added">715     // and does not account for the return address.</span>
<span class="line-added">716     intptr_t* real_frame_size_addr = (intptr_t*) (saved_fp_addr - 1);</span>
<span class="line-added">717     int real_frame_size = ((*real_frame_size_addr) + wordSize) / wordSize;</span>
<span class="line-added">718     assert(real_frame_size &gt;= _cb-&gt;frame_size(), &quot;invalid frame size&quot;);</span>
<span class="line-added">719     sender_sp = unextended_sp() + real_frame_size;</span>
<span class="line-added">720   }</span>
<span class="line-added">721   return sender_sp;</span>
<span class="line-added">722 }</span>
<span class="line-added">723 </span>
724 void JavaFrameAnchor::make_walkable(JavaThread* thread) {
725   // last frame set?
726   if (last_Java_sp() == NULL) return;
727   // already walkable?
728   if (walkable()) return;
729   vmassert(Thread::current() == (Thread*)thread, &quot;not current thread&quot;);
730   vmassert(last_Java_sp() != NULL, &quot;not called from Java code?&quot;);
731   vmassert(last_Java_pc() == NULL, &quot;already walkable&quot;);
732   capture_last_Java_pc();
733   vmassert(walkable(), &quot;something went wrong&quot;);
734 }
735 
736 void JavaFrameAnchor::capture_last_Java_pc() {
737   vmassert(_last_Java_sp != NULL, &quot;no last frame set&quot;);
738   vmassert(_last_Java_pc == NULL, &quot;already walkable&quot;);
739   _last_Java_pc = (address)_last_Java_sp[-1];
740 }
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
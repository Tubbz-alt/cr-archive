<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_FrameMap.hpp&quot;
  28 #include &quot;c1/c1_Instruction.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArray.hpp&quot;
  34 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  35 #include &quot;ci/ciTypeArrayKlass.hpp&quot;

  36 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  37 #include &quot;runtime/sharedRuntime.hpp&quot;
  38 #include &quot;runtime/stubRoutines.hpp&quot;
  39 #include &quot;utilities/powerOfTwo.hpp&quot;
  40 #include &quot;vmreg_x86.inline.hpp&quot;
  41 
  42 #ifdef ASSERT
  43 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  44 #else
  45 #define __ gen()-&gt;lir()-&gt;
  46 #endif
  47 
  48 // Item will be loaded into a byte register; Intel only
  49 void LIRItem::load_byte_item() {
  50   load_item();
  51   LIR_Opr res = result();
  52 
  53   if (!res-&gt;is_virtual() || !_gen-&gt;is_vreg_flag_set(res, LIRGenerator::byte_reg)) {
  54     // make sure that it is a byte register
  55     assert(!value()-&gt;type()-&gt;is_float() &amp;&amp; !value()-&gt;type()-&gt;is_double(),
</pre>
<hr />
<pre>
  99 #else
 100     case floatTag:   opr = UseSSE &gt;= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;
 101     case doubleTag:  opr = UseSSE &gt;= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;
 102 #endif // _LP64
 103     case addressTag:
 104     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
 105   }
 106 
 107   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
 108   return opr;
 109 }
 110 
 111 
 112 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 113   LIR_Opr reg = new_register(T_INT);
 114   set_vreg_flag(reg, LIRGenerator::byte_reg);
 115   return reg;
 116 }
 117 
 118 













 119 //--------- loading items into registers --------------------------------
 120 
 121 
 122 // i486 instructions can inline constants
 123 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 124   if (type == T_SHORT || type == T_CHAR) {
 125     // there is no immediate move of word values in asembler_i486.?pp
 126     return false;
 127   }
 128   Constant* c = v-&gt;as_Constant();
 129   if (c &amp;&amp; c-&gt;state_before() == NULL) {
 130     // constants of any type can be stored directly, except for
 131     // unloaded object constants.
 132     return true;
 133   }
 134   return false;
 135 }
 136 
 137 
 138 bool LIRGenerator::can_inline_as_constant(Value v) const {
</pre>
<hr />
<pre>
 273   LIR_Opr tmp2 = new_register(objectType);
 274   LIR_Opr tmp3 = new_register(objectType);
 275   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 276 }
 277 
 278 //----------------------------------------------------------------------
 279 //             visitor functions
 280 //----------------------------------------------------------------------
 281 
 282 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 283   assert(x-&gt;is_pinned(),&quot;&quot;);
 284   LIRItem obj(x-&gt;obj(), this);
 285   obj.load_item();
 286 
 287   set_no_result(x);
 288 
 289   // &quot;lock&quot; stores the address of the monitor stack slot, so this is not an oop
 290   LIR_Opr lock = new_register(T_INT);
 291   // Need a scratch register for biased locking on x86
 292   LIR_Opr scratch = LIR_OprFact::illegalOpr;
<span class="line-modified"> 293   if (UseBiasedLocking) {</span>
 294     scratch = new_register(T_INT);
 295   }
 296 
 297   CodeEmitInfo* info_for_exception = NULL;
 298   if (x-&gt;needs_null_check()) {
 299     info_for_exception = state_for(x);
 300   }






 301   // this CodeEmitInfo must not have the xhandlers because here the
 302   // object is already locked (xhandlers expect object to be unlocked)
 303   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 304   monitor_enter(obj.result(), lock, syncTempOpr(), scratch,
<span class="line-modified"> 305                         x-&gt;monitor_no(), info_for_exception, info);</span>
 306 }
 307 
 308 
 309 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 310   assert(x-&gt;is_pinned(),&quot;&quot;);
 311 
 312   LIRItem obj(x-&gt;obj(), this);
 313   obj.dont_load_item();
 314 
 315   LIR_Opr lock = new_register(T_INT);
 316   LIR_Opr obj_temp = new_register(T_INT);
 317   set_no_result(x);
 318   monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 319 }
 320 
 321 
 322 // _ineg, _lneg, _fneg, _dneg
 323 void LIRGenerator::do_NegateOp(NegateOp* x) {
 324   LIRItem value(x-&gt;x(), this);
 325   value.set_destroys_register();
</pre>
<hr />
<pre>
1260   set_result(x, result);
1261 #endif // _LP64
1262 }
1263 
1264 
1265 void LIRGenerator::do_NewInstance(NewInstance* x) {
1266   print_if_not_loaded(x);
1267 
1268   CodeEmitInfo* info = state_for(x, x-&gt;state());
1269   LIR_Opr reg = result_register_for(x-&gt;type());
1270   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1271                        FrameMap::rcx_oop_opr,
1272                        FrameMap::rdi_oop_opr,
1273                        FrameMap::rsi_oop_opr,
1274                        LIR_OprFact::illegalOpr,
1275                        FrameMap::rdx_metadata_opr, info);
1276   LIR_Opr result = rlock_result(x);
1277   __ move(reg, result);
1278 }
1279 















1280 
1281 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
1282   CodeEmitInfo* info = state_for(x, x-&gt;state());
1283 
1284   LIRItem length(x-&gt;length(), this);
1285   length.load_item_force(FrameMap::rbx_opr);
1286 
1287   LIR_Opr reg = result_register_for(x-&gt;type());
1288   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1289   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1290   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1291   LIR_Opr tmp4 = reg;
1292   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1293   LIR_Opr len = length.result();
1294   BasicType elem_type = x-&gt;elt_type();
1295 
1296   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
1297 
1298   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
1299   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
</pre>
<hr />
<pre>
1307   LIRItem length(x-&gt;length(), this);
1308   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1309   // and therefore provide the state before the parameters have been consumed
1310   CodeEmitInfo* patching_info = NULL;
1311   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1312     patching_info =  state_for(x, x-&gt;state_before());
1313   }
1314 
1315   CodeEmitInfo* info = state_for(x, x-&gt;state());
1316 
1317   const LIR_Opr reg = result_register_for(x-&gt;type());
1318   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1319   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1320   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1321   LIR_Opr tmp4 = reg;
1322   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1323 
1324   length.load_item_force(FrameMap::rbx_opr);
1325   LIR_Opr len = length.result();
1326 
<span class="line-modified">1327   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);</span>
<span class="line-modified">1328   ciKlass* obj = (ciKlass*) ciObjArrayKlass::make(x-&gt;klass());</span>
1329   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1330     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1331   }
1332   klass2reg_with_patching(klass_reg, obj, patching_info);
<span class="line-modified">1333   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);</span>




1334 
1335   LIR_Opr result = rlock_result(x);
1336   __ move(reg, result);
1337 }
1338 
1339 
1340 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1341   Values* dims = x-&gt;dims();
1342   int i = dims-&gt;length();
1343   LIRItemList* items = new LIRItemList(i, i, NULL);
1344   while (i-- &gt; 0) {
1345     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1346     items-&gt;at_put(i, size);
1347   }
1348 
1349   // Evaluate state_for early since it may emit code.
1350   CodeEmitInfo* patching_info = NULL;
1351   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1352     patching_info = state_for(x, x-&gt;state_before());
1353 
</pre>
<hr />
<pre>
1392   // nothing to do for now
1393 }
1394 
1395 
1396 void LIRGenerator::do_CheckCast(CheckCast* x) {
1397   LIRItem obj(x-&gt;obj(), this);
1398 
1399   CodeEmitInfo* patching_info = NULL;
1400   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1401     // must do this before locking the destination register as an oop register,
1402     // and before the obj is loaded (the latter is for deoptimization)
1403     patching_info = state_for(x, x-&gt;state_before());
1404   }
1405   obj.load_item();
1406 
1407   // info for exceptions
1408   CodeEmitInfo* info_for_exception =
1409       (x-&gt;needs_exception_state() ? state_for(x) :
1410                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
1411 




1412   CodeStub* stub;
1413   if (x-&gt;is_incompatible_class_change_check()) {
1414     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1415     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1416   } else if (x-&gt;is_invokespecial_receiver_check()) {
1417     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1418     stub = new DeoptimizeStub(info_for_exception, Deoptimization::Reason_class_check, Deoptimization::Action_none);
1419   } else {
1420     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1421   }
1422   LIR_Opr reg = rlock_result(x);
1423   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1424   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1425     tmp3 = new_register(objectType);
1426   }
1427   __ checkcast(reg, obj.result(), x-&gt;klass(),
1428                new_register(objectType), new_register(objectType), tmp3,
1429                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
<span class="line-modified">1430                x-&gt;profiled_method(), x-&gt;profiled_bci());</span>
1431 }
1432 
1433 
1434 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1435   LIRItem obj(x-&gt;obj(), this);
1436 
1437   // result and test object may not be in same register
1438   LIR_Opr reg = rlock_result(x);
1439   CodeEmitInfo* patching_info = NULL;
1440   if ((!x-&gt;klass()-&gt;is_loaded() || PatchALot)) {
1441     // must do this before locking the destination register as an oop register
1442     patching_info = state_for(x, x-&gt;state_before());
1443   }
1444   obj.load_item();
1445   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1446   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1447     tmp3 = new_register(objectType);
1448   }
1449   __ instanceof(reg, obj.result(), x-&gt;klass(),
1450                 new_register(objectType), new_register(objectType), tmp3,
</pre>
<hr />
<pre>
1461 
1462   LIRItem xitem(x-&gt;x(), this);
1463   LIRItem yitem(x-&gt;y(), this);
1464   LIRItem* xin = &amp;xitem;
1465   LIRItem* yin = &amp;yitem;
1466 
1467   if (tag == longTag) {
1468     // for longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
1469     // mirror for other conditions
1470     if (cond == If::gtr || cond == If::leq) {
1471       cond = Instruction::mirror(cond);
1472       xin = &amp;yitem;
1473       yin = &amp;xitem;
1474     }
1475     xin-&gt;set_destroys_register();
1476   }
1477   xin-&gt;load_item();
1478   if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp; (cond == If::eql || cond == If::neq)) {
1479     // inline long zero
1480     yin-&gt;dont_load_item();
<span class="line-modified">1481   } else if (tag == longTag || tag == floatTag || tag == doubleTag) {</span>
1482     // longs cannot handle constants at right side
1483     yin-&gt;load_item();
1484   } else {
1485     yin-&gt;dont_load_item();
1486   }
1487 
1488   LIR_Opr left = xin-&gt;result();
1489   LIR_Opr right = yin-&gt;result();
1490 
1491   set_no_result(x);
1492 
1493   // add safepoint before generating condition code so it can be recomputed
1494   if (x-&gt;is_safepoint()) {
1495     // increment backedge counter if needed
1496     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1497         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1498     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1499   }
1500 
<span class="line-modified">1501   __ cmp(lir_cond(cond), left, right);</span>




1502   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1503   profile_branch(x, cond);
1504   move_to_phi(x-&gt;state());
1505   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1506     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
1507   } else {
1508     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
1509   }
1510   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1511   __ jump(x-&gt;default_sux());
1512 }
1513 
1514 
1515 LIR_Opr LIRGenerator::getThreadPointer() {
1516 #ifdef _LP64
1517   return FrameMap::as_pointer_opr(r15_thread);
1518 #else
1519   LIR_Opr result = new_register(T_INT);
1520   __ get_thread(result);
1521   return result;
</pre>
</td>
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_FrameMap.hpp&quot;
  28 #include &quot;c1/c1_Instruction.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArray.hpp&quot;
  34 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  35 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
<span class="line-added">  36 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  37 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/stubRoutines.hpp&quot;
  40 #include &quot;utilities/powerOfTwo.hpp&quot;
  41 #include &quot;vmreg_x86.inline.hpp&quot;
  42 
  43 #ifdef ASSERT
  44 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  45 #else
  46 #define __ gen()-&gt;lir()-&gt;
  47 #endif
  48 
  49 // Item will be loaded into a byte register; Intel only
  50 void LIRItem::load_byte_item() {
  51   load_item();
  52   LIR_Opr res = result();
  53 
  54   if (!res-&gt;is_virtual() || !_gen-&gt;is_vreg_flag_set(res, LIRGenerator::byte_reg)) {
  55     // make sure that it is a byte register
  56     assert(!value()-&gt;type()-&gt;is_float() &amp;&amp; !value()-&gt;type()-&gt;is_double(),
</pre>
<hr />
<pre>
 100 #else
 101     case floatTag:   opr = UseSSE &gt;= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;
 102     case doubleTag:  opr = UseSSE &gt;= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;
 103 #endif // _LP64
 104     case addressTag:
 105     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
 106   }
 107 
 108   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
 109   return opr;
 110 }
 111 
 112 
 113 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 114   LIR_Opr reg = new_register(T_INT);
 115   set_vreg_flag(reg, LIRGenerator::byte_reg);
 116   return reg;
 117 }
 118 
 119 
<span class="line-added"> 120 void LIRGenerator::init_temps_for_substitutability_check(LIR_Opr&amp; tmp1, LIR_Opr&amp; tmp2) {</span>
<span class="line-added"> 121   // We just need one 32-bit temp register for x86/x64, to check whether both</span>
<span class="line-added"> 122   // oops have markWord::always_locked_pattern. See LIR_Assembler::emit_opSubstitutabilityCheck().</span>
<span class="line-added"> 123   // @temp = %r10d</span>
<span class="line-added"> 124   // mov $0x405, %r10d</span>
<span class="line-added"> 125   // and (%left), %r10d   /* if need to check left */</span>
<span class="line-added"> 126   // and (%right), %r10d  /* if need to check right */</span>
<span class="line-added"> 127   // cmp $0x405, $r10d</span>
<span class="line-added"> 128   // jne L_oops_not_equal</span>
<span class="line-added"> 129   tmp1 = new_register(T_INT);</span>
<span class="line-added"> 130   tmp2 = LIR_OprFact::illegalOpr;</span>
<span class="line-added"> 131 }</span>
<span class="line-added"> 132 </span>
 133 //--------- loading items into registers --------------------------------
 134 
 135 
 136 // i486 instructions can inline constants
 137 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 138   if (type == T_SHORT || type == T_CHAR) {
 139     // there is no immediate move of word values in asembler_i486.?pp
 140     return false;
 141   }
 142   Constant* c = v-&gt;as_Constant();
 143   if (c &amp;&amp; c-&gt;state_before() == NULL) {
 144     // constants of any type can be stored directly, except for
 145     // unloaded object constants.
 146     return true;
 147   }
 148   return false;
 149 }
 150 
 151 
 152 bool LIRGenerator::can_inline_as_constant(Value v) const {
</pre>
<hr />
<pre>
 287   LIR_Opr tmp2 = new_register(objectType);
 288   LIR_Opr tmp3 = new_register(objectType);
 289   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 290 }
 291 
 292 //----------------------------------------------------------------------
 293 //             visitor functions
 294 //----------------------------------------------------------------------
 295 
 296 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 297   assert(x-&gt;is_pinned(),&quot;&quot;);
 298   LIRItem obj(x-&gt;obj(), this);
 299   obj.load_item();
 300 
 301   set_no_result(x);
 302 
 303   // &quot;lock&quot; stores the address of the monitor stack slot, so this is not an oop
 304   LIR_Opr lock = new_register(T_INT);
 305   // Need a scratch register for biased locking on x86
 306   LIR_Opr scratch = LIR_OprFact::illegalOpr;
<span class="line-modified"> 307   if (UseBiasedLocking || x-&gt;maybe_valuetype()) {</span>
 308     scratch = new_register(T_INT);
 309   }
 310 
 311   CodeEmitInfo* info_for_exception = NULL;
 312   if (x-&gt;needs_null_check()) {
 313     info_for_exception = state_for(x);
 314   }
<span class="line-added"> 315 </span>
<span class="line-added"> 316   CodeStub* throw_imse_stub = x-&gt;maybe_valuetype() ?</span>
<span class="line-added"> 317       new SimpleExceptionStub(Runtime1::throw_illegal_monitor_state_exception_id,</span>
<span class="line-added"> 318                               LIR_OprFact::illegalOpr, state_for(x))</span>
<span class="line-added"> 319     : NULL;</span>
<span class="line-added"> 320 </span>
 321   // this CodeEmitInfo must not have the xhandlers because here the
 322   // object is already locked (xhandlers expect object to be unlocked)
 323   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 324   monitor_enter(obj.result(), lock, syncTempOpr(), scratch,
<span class="line-modified"> 325                 x-&gt;monitor_no(), info_for_exception, info, throw_imse_stub);</span>
 326 }
 327 
 328 
 329 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 330   assert(x-&gt;is_pinned(),&quot;&quot;);
 331 
 332   LIRItem obj(x-&gt;obj(), this);
 333   obj.dont_load_item();
 334 
 335   LIR_Opr lock = new_register(T_INT);
 336   LIR_Opr obj_temp = new_register(T_INT);
 337   set_no_result(x);
 338   monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 339 }
 340 
 341 
 342 // _ineg, _lneg, _fneg, _dneg
 343 void LIRGenerator::do_NegateOp(NegateOp* x) {
 344   LIRItem value(x-&gt;x(), this);
 345   value.set_destroys_register();
</pre>
<hr />
<pre>
1280   set_result(x, result);
1281 #endif // _LP64
1282 }
1283 
1284 
1285 void LIRGenerator::do_NewInstance(NewInstance* x) {
1286   print_if_not_loaded(x);
1287 
1288   CodeEmitInfo* info = state_for(x, x-&gt;state());
1289   LIR_Opr reg = result_register_for(x-&gt;type());
1290   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1291                        FrameMap::rcx_oop_opr,
1292                        FrameMap::rdi_oop_opr,
1293                        FrameMap::rsi_oop_opr,
1294                        LIR_OprFact::illegalOpr,
1295                        FrameMap::rdx_metadata_opr, info);
1296   LIR_Opr result = rlock_result(x);
1297   __ move(reg, result);
1298 }
1299 
<span class="line-added">1300 void LIRGenerator::do_NewValueTypeInstance(NewValueTypeInstance* x) {</span>
<span class="line-added">1301   // Mapping to do_NewInstance (same code) but use state_before for reexecution.</span>
<span class="line-added">1302   CodeEmitInfo* info = state_for(x, x-&gt;state_before());</span>
<span class="line-added">1303   x-&gt;set_to_object_type();</span>
<span class="line-added">1304   LIR_Opr reg = result_register_for(x-&gt;type());</span>
<span class="line-added">1305   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),</span>
<span class="line-added">1306              FrameMap::rcx_oop_opr,</span>
<span class="line-added">1307              FrameMap::rdi_oop_opr,</span>
<span class="line-added">1308              FrameMap::rsi_oop_opr,</span>
<span class="line-added">1309              LIR_OprFact::illegalOpr,</span>
<span class="line-added">1310              FrameMap::rdx_metadata_opr, info);</span>
<span class="line-added">1311   LIR_Opr result = rlock_result(x);</span>
<span class="line-added">1312   __ move(reg, result);</span>
<span class="line-added">1313 </span>
<span class="line-added">1314 }</span>
1315 
1316 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
1317   CodeEmitInfo* info = state_for(x, x-&gt;state());
1318 
1319   LIRItem length(x-&gt;length(), this);
1320   length.load_item_force(FrameMap::rbx_opr);
1321 
1322   LIR_Opr reg = result_register_for(x-&gt;type());
1323   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1324   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1325   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1326   LIR_Opr tmp4 = reg;
1327   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1328   LIR_Opr len = length.result();
1329   BasicType elem_type = x-&gt;elt_type();
1330 
1331   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
1332 
1333   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
1334   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
</pre>
<hr />
<pre>
1342   LIRItem length(x-&gt;length(), this);
1343   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1344   // and therefore provide the state before the parameters have been consumed
1345   CodeEmitInfo* patching_info = NULL;
1346   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1347     patching_info =  state_for(x, x-&gt;state_before());
1348   }
1349 
1350   CodeEmitInfo* info = state_for(x, x-&gt;state());
1351 
1352   const LIR_Opr reg = result_register_for(x-&gt;type());
1353   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1354   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1355   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1356   LIR_Opr tmp4 = reg;
1357   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1358 
1359   length.load_item_force(FrameMap::rbx_opr);
1360   LIR_Opr len = length.result();
1361 
<span class="line-modified">1362   ciKlass* obj = (ciKlass*) x-&gt;exact_type();</span>
<span class="line-modified">1363   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x-&gt;is_never_null());</span>
1364   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1365     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1366   }
1367   klass2reg_with_patching(klass_reg, obj, patching_info);
<span class="line-modified">1368   if (x-&gt;is_never_null()) {</span>
<span class="line-added">1369     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_VALUETYPE, klass_reg, slow_path);</span>
<span class="line-added">1370   } else {</span>
<span class="line-added">1371     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);</span>
<span class="line-added">1372   }</span>
1373 
1374   LIR_Opr result = rlock_result(x);
1375   __ move(reg, result);
1376 }
1377 
1378 
1379 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1380   Values* dims = x-&gt;dims();
1381   int i = dims-&gt;length();
1382   LIRItemList* items = new LIRItemList(i, i, NULL);
1383   while (i-- &gt; 0) {
1384     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1385     items-&gt;at_put(i, size);
1386   }
1387 
1388   // Evaluate state_for early since it may emit code.
1389   CodeEmitInfo* patching_info = NULL;
1390   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1391     patching_info = state_for(x, x-&gt;state_before());
1392 
</pre>
<hr />
<pre>
1431   // nothing to do for now
1432 }
1433 
1434 
1435 void LIRGenerator::do_CheckCast(CheckCast* x) {
1436   LIRItem obj(x-&gt;obj(), this);
1437 
1438   CodeEmitInfo* patching_info = NULL;
1439   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1440     // must do this before locking the destination register as an oop register,
1441     // and before the obj is loaded (the latter is for deoptimization)
1442     patching_info = state_for(x, x-&gt;state_before());
1443   }
1444   obj.load_item();
1445 
1446   // info for exceptions
1447   CodeEmitInfo* info_for_exception =
1448       (x-&gt;needs_exception_state() ? state_for(x) :
1449                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
1450 
<span class="line-added">1451   if (x-&gt;is_never_null()) {</span>
<span class="line-added">1452     __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));</span>
<span class="line-added">1453   }</span>
<span class="line-added">1454 </span>
1455   CodeStub* stub;
1456   if (x-&gt;is_incompatible_class_change_check()) {
1457     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1458     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1459   } else if (x-&gt;is_invokespecial_receiver_check()) {
1460     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1461     stub = new DeoptimizeStub(info_for_exception, Deoptimization::Reason_class_check, Deoptimization::Action_none);
1462   } else {
1463     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1464   }
1465   LIR_Opr reg = rlock_result(x);
1466   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1467   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1468     tmp3 = new_register(objectType);
1469   }
1470   __ checkcast(reg, obj.result(), x-&gt;klass(),
1471                new_register(objectType), new_register(objectType), tmp3,
1472                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
<span class="line-modified">1473                x-&gt;profiled_method(), x-&gt;profiled_bci(), x-&gt;is_never_null());</span>
1474 }
1475 
1476 
1477 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1478   LIRItem obj(x-&gt;obj(), this);
1479 
1480   // result and test object may not be in same register
1481   LIR_Opr reg = rlock_result(x);
1482   CodeEmitInfo* patching_info = NULL;
1483   if ((!x-&gt;klass()-&gt;is_loaded() || PatchALot)) {
1484     // must do this before locking the destination register as an oop register
1485     patching_info = state_for(x, x-&gt;state_before());
1486   }
1487   obj.load_item();
1488   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1489   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1490     tmp3 = new_register(objectType);
1491   }
1492   __ instanceof(reg, obj.result(), x-&gt;klass(),
1493                 new_register(objectType), new_register(objectType), tmp3,
</pre>
<hr />
<pre>
1504 
1505   LIRItem xitem(x-&gt;x(), this);
1506   LIRItem yitem(x-&gt;y(), this);
1507   LIRItem* xin = &amp;xitem;
1508   LIRItem* yin = &amp;yitem;
1509 
1510   if (tag == longTag) {
1511     // for longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
1512     // mirror for other conditions
1513     if (cond == If::gtr || cond == If::leq) {
1514       cond = Instruction::mirror(cond);
1515       xin = &amp;yitem;
1516       yin = &amp;xitem;
1517     }
1518     xin-&gt;set_destroys_register();
1519   }
1520   xin-&gt;load_item();
1521   if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp; (cond == If::eql || cond == If::neq)) {
1522     // inline long zero
1523     yin-&gt;dont_load_item();
<span class="line-modified">1524   } else if (tag == longTag || tag == floatTag || tag == doubleTag || x-&gt;substitutability_check()) {</span>
1525     // longs cannot handle constants at right side
1526     yin-&gt;load_item();
1527   } else {
1528     yin-&gt;dont_load_item();
1529   }
1530 
1531   LIR_Opr left = xin-&gt;result();
1532   LIR_Opr right = yin-&gt;result();
1533 
1534   set_no_result(x);
1535 
1536   // add safepoint before generating condition code so it can be recomputed
1537   if (x-&gt;is_safepoint()) {
1538     // increment backedge counter if needed
1539     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1540         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1541     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1542   }
1543 
<span class="line-modified">1544   if (x-&gt;substitutability_check()) {</span>
<span class="line-added">1545     substitutability_check(x, *xin, *yin);</span>
<span class="line-added">1546   } else {</span>
<span class="line-added">1547     __ cmp(lir_cond(cond), left, right);</span>
<span class="line-added">1548   }</span>
1549   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1550   profile_branch(x, cond);
1551   move_to_phi(x-&gt;state());
1552   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1553     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
1554   } else {
1555     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
1556   }
1557   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1558   __ jump(x-&gt;default_sux());
1559 }
1560 
1561 
1562 LIR_Opr LIRGenerator::getThreadPointer() {
1563 #ifdef _LP64
1564   return FrameMap::as_pointer_opr(r15_thread);
1565 #else
1566   LIR_Opr result = new_register(T_INT);
1567   __ get_thread(result);
1568   return result;
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
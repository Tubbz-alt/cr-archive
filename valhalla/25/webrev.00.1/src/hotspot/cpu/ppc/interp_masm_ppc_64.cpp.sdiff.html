<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/interp_masm_ppc_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aarch64/sharedRuntime_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../s390/interp_masm_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/interp_masm_ppc_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1861 
1862         profile_obj_type(tmp1, R28_mdx, in_bytes(TypeEntriesAtCall::argument_type_offset(i))-off_to_args, tmp2, tmp1);
1863 
1864         int to_add = in_bytes(TypeStackSlotEntries::per_arg_size());
1865         addi(R28_mdx, R28_mdx, to_add);
1866         off_to_args += to_add;
1867       }
1868 
1869       if (MethodData::profile_return()) {
1870         ld(tmp1, in_bytes(TypeEntriesAtCall::cell_count_offset())-off_to_args, R28_mdx);
1871         addi(tmp1, tmp1, -TypeProfileArgsLimit*TypeStackSlotEntries::per_arg_count());
1872       }
1873 
1874       bind(done);
1875 
1876       if (MethodData::profile_return()) {
1877         // We&#39;re right after the type profile for the last
1878         // argument. tmp1 is the number of cells left in the
1879         // CallTypeData/VirtualCallTypeData to reach its end. Non null
1880         // if there&#39;s a return to profile.
<span class="line-modified">1881         assert(ReturnTypeEntry::static_cell_count() &lt; TypeStackSlotEntries::per_arg_count(),</span>
1882                &quot;can&#39;t move past ret type&quot;);
1883         sldi(tmp1, tmp1, exact_log2(DataLayout::cell_size));
1884         add(R28_mdx, tmp1, R28_mdx);
1885       }
1886     } else {
1887       assert(MethodData::profile_return(), &quot;either profile call args or call ret&quot;);
1888       update_mdp_by_constant(in_bytes(TypeEntriesAtCall::return_only_size()));
1889     }
1890 
1891     // Mdp points right after the end of the
1892     // CallTypeData/VirtualCallTypeData, right after the cells for the
1893     // return value type if there&#39;s one.
1894     align(32, 12);
1895     bind(profile_continue);
1896   }
1897 }
1898 
1899 void InterpreterMacroAssembler::profile_return_type(Register ret, Register tmp1, Register tmp2) {
1900   assert_different_registers(ret, tmp1, tmp2);
1901   if (ProfileInterpreter &amp;&amp; MethodData::profile_return()) {
1902     Label profile_continue;
1903 
1904     test_method_data_pointer(profile_continue);
1905 
1906     if (MethodData::profile_return_jsr292_only()) {
1907       // If we don&#39;t profile all invoke bytecodes we must make sure
1908       // it&#39;s a bytecode we indeed profile. We can&#39;t go back to the
1909       // begining of the ProfileData we intend to update to check its
1910       // type because we&#39;re right after it and we don&#39;t known its
1911       // length.
1912       lbz(tmp1, 0, R14_bcp);
1913       lbz(tmp2, Method::intrinsic_id_offset_in_bytes(), R19_method);
1914       cmpwi(CCR0, tmp1, Bytecodes::_invokedynamic);
1915       cmpwi(CCR1, tmp1, Bytecodes::_invokehandle);
1916       cror(CCR0, Assembler::equal, CCR1, Assembler::equal);
1917       cmpwi(CCR1, tmp2, vmIntrinsics::_compiledLambdaForm);
1918       cror(CCR0, Assembler::equal, CCR1, Assembler::equal);
1919       bne(CCR0, profile_continue);
1920     }
1921 
<span class="line-modified">1922     profile_obj_type(ret, R28_mdx, -in_bytes(ReturnTypeEntry::size()), tmp1, tmp2);</span>
1923 
1924     align(32, 12);
1925     bind(profile_continue);
1926   }
1927 }
1928 
1929 void InterpreterMacroAssembler::profile_parameters_type(Register tmp1, Register tmp2,
1930                                                         Register tmp3, Register tmp4) {
1931   if (ProfileInterpreter &amp;&amp; MethodData::profile_parameters()) {
1932     Label profile_continue, done;
1933 
1934     test_method_data_pointer(profile_continue);
1935 
1936     // Load the offset of the area within the MDO used for
1937     // parameters. If it&#39;s negative we&#39;re not profiling any parameters.
1938     lwz(tmp1, in_bytes(MethodData::parameters_type_data_di_offset()) - in_bytes(MethodData::data_offset()), R28_mdx);
1939     cmpwi(CCR0, tmp1, 0);
1940     blt(CCR0, profile_continue);
1941 
1942     // Compute a pointer to the area for parameters from the offset
</pre>
</td>
<td>
<hr />
<pre>
1861 
1862         profile_obj_type(tmp1, R28_mdx, in_bytes(TypeEntriesAtCall::argument_type_offset(i))-off_to_args, tmp2, tmp1);
1863 
1864         int to_add = in_bytes(TypeStackSlotEntries::per_arg_size());
1865         addi(R28_mdx, R28_mdx, to_add);
1866         off_to_args += to_add;
1867       }
1868 
1869       if (MethodData::profile_return()) {
1870         ld(tmp1, in_bytes(TypeEntriesAtCall::cell_count_offset())-off_to_args, R28_mdx);
1871         addi(tmp1, tmp1, -TypeProfileArgsLimit*TypeStackSlotEntries::per_arg_count());
1872       }
1873 
1874       bind(done);
1875 
1876       if (MethodData::profile_return()) {
1877         // We&#39;re right after the type profile for the last
1878         // argument. tmp1 is the number of cells left in the
1879         // CallTypeData/VirtualCallTypeData to reach its end. Non null
1880         // if there&#39;s a return to profile.
<span class="line-modified">1881         assert(SingleTypeEntry::static_cell_count() &lt; TypeStackSlotEntries::per_arg_count(),</span>
1882                &quot;can&#39;t move past ret type&quot;);
1883         sldi(tmp1, tmp1, exact_log2(DataLayout::cell_size));
1884         add(R28_mdx, tmp1, R28_mdx);
1885       }
1886     } else {
1887       assert(MethodData::profile_return(), &quot;either profile call args or call ret&quot;);
1888       update_mdp_by_constant(in_bytes(TypeEntriesAtCall::return_only_size()));
1889     }
1890 
1891     // Mdp points right after the end of the
1892     // CallTypeData/VirtualCallTypeData, right after the cells for the
1893     // return value type if there&#39;s one.
1894     align(32, 12);
1895     bind(profile_continue);
1896   }
1897 }
1898 
1899 void InterpreterMacroAssembler::profile_return_type(Register ret, Register tmp1, Register tmp2) {
1900   assert_different_registers(ret, tmp1, tmp2);
1901   if (ProfileInterpreter &amp;&amp; MethodData::profile_return()) {
1902     Label profile_continue;
1903 
1904     test_method_data_pointer(profile_continue);
1905 
1906     if (MethodData::profile_return_jsr292_only()) {
1907       // If we don&#39;t profile all invoke bytecodes we must make sure
1908       // it&#39;s a bytecode we indeed profile. We can&#39;t go back to the
1909       // begining of the ProfileData we intend to update to check its
1910       // type because we&#39;re right after it and we don&#39;t known its
1911       // length.
1912       lbz(tmp1, 0, R14_bcp);
1913       lbz(tmp2, Method::intrinsic_id_offset_in_bytes(), R19_method);
1914       cmpwi(CCR0, tmp1, Bytecodes::_invokedynamic);
1915       cmpwi(CCR1, tmp1, Bytecodes::_invokehandle);
1916       cror(CCR0, Assembler::equal, CCR1, Assembler::equal);
1917       cmpwi(CCR1, tmp2, vmIntrinsics::_compiledLambdaForm);
1918       cror(CCR0, Assembler::equal, CCR1, Assembler::equal);
1919       bne(CCR0, profile_continue);
1920     }
1921 
<span class="line-modified">1922     profile_obj_type(ret, R28_mdx, -in_bytes(SingleTypeEntry::size()), tmp1, tmp2);</span>
1923 
1924     align(32, 12);
1925     bind(profile_continue);
1926   }
1927 }
1928 
1929 void InterpreterMacroAssembler::profile_parameters_type(Register tmp1, Register tmp2,
1930                                                         Register tmp3, Register tmp4) {
1931   if (ProfileInterpreter &amp;&amp; MethodData::profile_parameters()) {
1932     Label profile_continue, done;
1933 
1934     test_method_data_pointer(profile_continue);
1935 
1936     // Load the offset of the area within the MDO used for
1937     // parameters. If it&#39;s negative we&#39;re not profiling any parameters.
1938     lwz(tmp1, in_bytes(MethodData::parameters_type_data_di_offset()) - in_bytes(MethodData::data_offset()), R28_mdx);
1939     cmpwi(CCR0, tmp1, 0);
1940     blt(CCR0, profile_continue);
1941 
1942     // Compute a pointer to the area for parameters from the offset
</pre>
</td>
</tr>
</table>
<center><a href="../aarch64/sharedRuntime_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../s390/interp_masm_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
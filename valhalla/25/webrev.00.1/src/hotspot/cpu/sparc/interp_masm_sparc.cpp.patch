diff a/src/hotspot/cpu/sparc/interp_masm_sparc.cpp b/src/hotspot/cpu/sparc/interp_masm_sparc.cpp
--- a/src/hotspot/cpu/sparc/interp_masm_sparc.cpp
+++ b/src/hotspot/cpu/sparc/interp_masm_sparc.cpp
@@ -2019,11 +2019,11 @@
       if (MethodData::profile_return()) {
         // We're right after the type profile for the last
         // argument. tmp1 is the number of cells left in the
         // CallTypeData/VirtualCallTypeData to reach its end. Non null
         // if there's a return to profile.
-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), "can't move past ret type");
+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(), "can't move past ret type");
         sll(tmp1, exact_log2(DataLayout::cell_size), tmp1);
         add(ImethodDataPtr, tmp1, ImethodDataPtr);
       }
     } else {
       assert(MethodData::profile_return(), "either profile call args or call ret");
@@ -2062,11 +2062,11 @@
       cmp_and_br_short(tmp1, vmIntrinsics::_compiledLambdaForm, notEqual, pt, profile_continue);
 
       bind(do_profile);
     }
 
-    Address mdo_ret_addr(ImethodDataPtr, -in_bytes(ReturnTypeEntry::size()));
+    Address mdo_ret_addr(ImethodDataPtr, -in_bytes(SingleTypeEntry::size()));
     mov(ret, tmp1);
     profile_obj_type(tmp1, mdo_ret_addr, tmp2);
 
     bind(profile_continue);
   }

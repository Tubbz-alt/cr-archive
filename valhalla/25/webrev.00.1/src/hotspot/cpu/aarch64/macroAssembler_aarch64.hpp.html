<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  27 #define CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  28 
  29 #include &quot;asm/assembler.hpp&quot;
  30 #include &quot;oops/compressedOops.hpp&quot;
  31 #include &quot;utilities/macros.hpp&quot;
  32 #include &quot;utilities/powerOfTwo.hpp&quot;
  33 #include &quot;runtime/signature.hpp&quot;
  34 
  35 
  36 class ciValueKlass;
  37 
  38 // MacroAssembler extends Assembler by frequently used macros.
  39 //
  40 // Instructions for which a &#39;better&#39; code sequence exists depending
  41 // on arguments should also go in here.
  42 
  43 class MacroAssembler: public Assembler {
  44   friend class LIR_Assembler;
  45 
  46  public:
  47   using Assembler::mov;
  48   using Assembler::movi;
  49 
  50  protected:
  51 
  52   // Support for VM calls
  53   //
  54   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  55   // may customize this version by overriding it for its purposes (e.g., to save/restore
  56   // additional registers when doing a VM call).
  57   virtual void call_VM_leaf_base(
  58     address entry_point,               // the entry point
  59     int     number_of_arguments,        // the number of arguments to pop after the call
  60     Label *retaddr = NULL
  61   );
  62 
  63   virtual void call_VM_leaf_base(
  64     address entry_point,               // the entry point
  65     int     number_of_arguments,        // the number of arguments to pop after the call
  66     Label &amp;retaddr) {
  67     call_VM_leaf_base(entry_point, number_of_arguments, &amp;retaddr);
  68   }
  69 
  70   // This is the base routine called by the different versions of call_VM. The interpreter
  71   // may customize this version by overriding it for its purposes (e.g., to save/restore
  72   // additional registers when doing a VM call).
  73   //
  74   // If no java_thread register is specified (noreg) than rthread will be used instead. call_VM_base
  75   // returns the register which contains the thread upon return. If a thread register has been
  76   // specified, the return value will correspond to that register. If no last_java_sp is specified
  77   // (noreg) than rsp will be used instead.
  78   virtual void call_VM_base(           // returns the register containing the thread upon return
  79     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  80     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  81     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  82     address  entry_point,              // the entry point
  83     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  84     bool     check_exceptions          // whether to check for pending exceptions after return
  85   );
  86 
  87   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  88 
  89   enum KlassDecodeMode {
  90     KlassDecodeNone,
  91     KlassDecodeZero,
  92     KlassDecodeXor,
  93     KlassDecodeMovk
  94   };
  95 
  96   KlassDecodeMode klass_decode_mode();
  97 
  98  private:
  99   static KlassDecodeMode _klass_decode_mode;
 100 
 101  public:
 102   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
 103 
 104  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
 105  // The implementation is only non-empty for the InterpreterMacroAssembler,
 106  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
 107  virtual void check_and_handle_popframe(Register java_thread);
 108  virtual void check_and_handle_earlyret(Register java_thread);
 109 
 110   void safepoint_poll(Label&amp; slow_path);
 111   void safepoint_poll_acquire(Label&amp; slow_path);
 112 
 113   // Biased locking support
 114   // lock_reg and obj_reg must be loaded up with the appropriate values.
 115   // swap_reg is killed.
 116   // tmp_reg must be supplied and must not be rscratch1 or rscratch2
 117   // Optional slow case is for implementations (interpreter and C1) which branch to
 118   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 119   // Returns offset of first potentially-faulting instruction for null
 120   // check info (currently consumed only by C1). If
 121   // swap_reg_contains_mark is true then returns -1 as it is assumed
 122   // the calling code has already passed any potential faults.
 123   int biased_locking_enter(Register lock_reg, Register obj_reg,
 124                            Register swap_reg, Register tmp_reg,
 125                            bool swap_reg_contains_mark,
 126                            Label&amp; done, Label* slow_case = NULL,
 127                            BiasedLockingCounters* counters = NULL);
 128   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 129 
 130 
 131   // Helper functions for statistics gathering.
 132   // Unconditional atomic increment.
 133   void atomic_incw(Register counter_addr, Register tmp, Register tmp2);
 134   void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {
 135     lea(tmp1, counter_addr);
 136     atomic_incw(tmp1, tmp2, tmp3);
 137   }
 138   // Load Effective Address
 139   void lea(Register r, const Address &amp;a) {
 140     InstructionMark im(this);
 141     code_section()-&gt;relocate(inst_mark(), a.rspec());
 142     a.lea(this, r);
 143   }
 144 
 145   /* Sometimes we get misaligned loads and stores, usually from Unsafe
 146      accesses, and these can exceed the offset range. */
 147   Address legitimize_address(const Address &amp;a, int size, Register scratch) {
 148     if (a.getMode() == Address::base_plus_offset) {
 149       if (! Address::offset_ok_for_immed(a.offset(), exact_log2(size))) {
 150         block_comment(&quot;legitimize_address {&quot;);
 151         lea(scratch, a);
 152         block_comment(&quot;} legitimize_address&quot;);
 153         return Address(scratch);
 154       }
 155     }
 156     return a;
 157   }
 158 
 159   void addmw(Address a, Register incr, Register scratch) {
 160     ldrw(scratch, a);
 161     addw(scratch, scratch, incr);
 162     strw(scratch, a);
 163   }
 164 
 165   // Add constant to memory word
 166   void addmw(Address a, int imm, Register scratch) {
 167     ldrw(scratch, a);
 168     if (imm &gt; 0)
 169       addw(scratch, scratch, (unsigned)imm);
 170     else
 171       subw(scratch, scratch, (unsigned)-imm);
 172     strw(scratch, a);
 173   }
 174 
 175   void bind(Label&amp; L) {
 176     Assembler::bind(L);
 177     code()-&gt;clear_last_insn();
 178   }
 179 
 180   void membar(Membar_mask_bits order_constraint);
 181 
 182   using Assembler::ldr;
 183   using Assembler::str;
 184 
 185   void ldr(Register Rx, const Address &amp;adr);
 186   void ldrw(Register Rw, const Address &amp;adr);
 187   void str(Register Rx, const Address &amp;adr);
 188   void strw(Register Rx, const Address &amp;adr);
 189 
 190   // Frame creation and destruction shared between JITs.
 191   void build_frame(int framesize);
 192   void remove_frame(int framesize);
 193 
 194   virtual void _call_Unimplemented(address call_site) {
 195     mov(rscratch2, call_site);
 196   }
 197 
 198 #define call_Unimplemented() _call_Unimplemented((address)__PRETTY_FUNCTION__)
 199 
 200   // aliases defined in AARCH64 spec
 201 
 202   template&lt;class T&gt;
 203   inline void cmpw(Register Rd, T imm)  { subsw(zr, Rd, imm); }
 204 
 205   inline void cmp(Register Rd, unsigned char imm8)  { subs(zr, Rd, imm8); }
 206   inline void cmp(Register Rd, unsigned imm) __attribute__ ((deprecated));
 207 
 208   inline void cmnw(Register Rd, unsigned imm) { addsw(zr, Rd, imm); }
 209   inline void cmn(Register Rd, unsigned imm) { adds(zr, Rd, imm); }
 210 
 211   void cset(Register Rd, Assembler::Condition cond) {
 212     csinc(Rd, zr, zr, ~cond);
 213   }
 214   void csetw(Register Rd, Assembler::Condition cond) {
 215     csincw(Rd, zr, zr, ~cond);
 216   }
 217 
 218   void cneg(Register Rd, Register Rn, Assembler::Condition cond) {
 219     csneg(Rd, Rn, Rn, ~cond);
 220   }
 221   void cnegw(Register Rd, Register Rn, Assembler::Condition cond) {
 222     csnegw(Rd, Rn, Rn, ~cond);
 223   }
 224 
 225   inline void movw(Register Rd, Register Rn) {
 226     if (Rd == sp || Rn == sp) {
 227       addw(Rd, Rn, 0U);
 228     } else {
 229       orrw(Rd, zr, Rn);
 230     }
 231   }
 232   inline void mov(Register Rd, Register Rn) {
 233     assert(Rd != r31_sp &amp;&amp; Rn != r31_sp, &quot;should be&quot;);
 234     if (Rd == Rn) {
 235     } else if (Rd == sp || Rn == sp) {
 236       add(Rd, Rn, 0U);
 237     } else {
 238       orr(Rd, zr, Rn);
 239     }
 240   }
 241 
 242   inline void moviw(Register Rd, unsigned imm) { orrw(Rd, zr, imm); }
 243   inline void movi(Register Rd, unsigned imm) { orr(Rd, zr, imm); }
 244 
 245   inline void tstw(Register Rd, Register Rn) { andsw(zr, Rd, Rn); }
 246   inline void tst(Register Rd, Register Rn) { ands(zr, Rd, Rn); }
 247 
 248   inline void tstw(Register Rd, uint64_t imm) { andsw(zr, Rd, imm); }
 249   inline void tst(Register Rd, uint64_t imm) { ands(zr, Rd, imm); }
 250 
 251   inline void bfiw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 252     bfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 253   }
 254   inline void bfi(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 255     bfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 256   }
 257 
 258   inline void bfxilw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 259     bfmw(Rd, Rn, lsb, (lsb + width - 1));
 260   }
 261   inline void bfxil(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 262     bfm(Rd, Rn, lsb , (lsb + width - 1));
 263   }
 264 
 265   inline void sbfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 266     sbfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 267   }
 268   inline void sbfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 269     sbfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 270   }
 271 
 272   inline void sbfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 273     sbfmw(Rd, Rn, lsb, (lsb + width - 1));
 274   }
 275   inline void sbfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 276     sbfm(Rd, Rn, lsb , (lsb + width - 1));
 277   }
 278 
 279   inline void ubfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 280     ubfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 281   }
 282   inline void ubfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 283     ubfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 284   }
 285 
 286   inline void ubfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 287     ubfmw(Rd, Rn, lsb, (lsb + width - 1));
 288   }
 289   inline void ubfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 290     ubfm(Rd, Rn, lsb , (lsb + width - 1));
 291   }
 292 
 293   inline void asrw(Register Rd, Register Rn, unsigned imm) {
 294     sbfmw(Rd, Rn, imm, 31);
 295   }
 296 
 297   inline void asr(Register Rd, Register Rn, unsigned imm) {
 298     sbfm(Rd, Rn, imm, 63);
 299   }
 300 
 301   inline void lslw(Register Rd, Register Rn, unsigned imm) {
 302     ubfmw(Rd, Rn, ((32 - imm) &amp; 31), (31 - imm));
 303   }
 304 
 305   inline void lsl(Register Rd, Register Rn, unsigned imm) {
 306     ubfm(Rd, Rn, ((64 - imm) &amp; 63), (63 - imm));
 307   }
 308 
 309   inline void lsrw(Register Rd, Register Rn, unsigned imm) {
 310     ubfmw(Rd, Rn, imm, 31);
 311   }
 312 
 313   inline void lsr(Register Rd, Register Rn, unsigned imm) {
 314     ubfm(Rd, Rn, imm, 63);
 315   }
 316 
 317   inline void rorw(Register Rd, Register Rn, unsigned imm) {
 318     extrw(Rd, Rn, Rn, imm);
 319   }
 320 
 321   inline void ror(Register Rd, Register Rn, unsigned imm) {
 322     extr(Rd, Rn, Rn, imm);
 323   }
 324 
 325   inline void sxtbw(Register Rd, Register Rn) {
 326     sbfmw(Rd, Rn, 0, 7);
 327   }
 328   inline void sxthw(Register Rd, Register Rn) {
 329     sbfmw(Rd, Rn, 0, 15);
 330   }
 331   inline void sxtb(Register Rd, Register Rn) {
 332     sbfm(Rd, Rn, 0, 7);
 333   }
 334   inline void sxth(Register Rd, Register Rn) {
 335     sbfm(Rd, Rn, 0, 15);
 336   }
 337   inline void sxtw(Register Rd, Register Rn) {
 338     sbfm(Rd, Rn, 0, 31);
 339   }
 340 
 341   inline void uxtbw(Register Rd, Register Rn) {
 342     ubfmw(Rd, Rn, 0, 7);
 343   }
 344   inline void uxthw(Register Rd, Register Rn) {
 345     ubfmw(Rd, Rn, 0, 15);
 346   }
 347   inline void uxtb(Register Rd, Register Rn) {
 348     ubfm(Rd, Rn, 0, 7);
 349   }
 350   inline void uxth(Register Rd, Register Rn) {
 351     ubfm(Rd, Rn, 0, 15);
 352   }
 353   inline void uxtw(Register Rd, Register Rn) {
 354     ubfm(Rd, Rn, 0, 31);
 355   }
 356 
 357   inline void cmnw(Register Rn, Register Rm) {
 358     addsw(zr, Rn, Rm);
 359   }
 360   inline void cmn(Register Rn, Register Rm) {
 361     adds(zr, Rn, Rm);
 362   }
 363 
 364   inline void cmpw(Register Rn, Register Rm) {
 365     subsw(zr, Rn, Rm);
 366   }
 367   inline void cmp(Register Rn, Register Rm) {
 368     subs(zr, Rn, Rm);
 369   }
 370 
 371   inline void negw(Register Rd, Register Rn) {
 372     subw(Rd, zr, Rn);
 373   }
 374 
 375   inline void neg(Register Rd, Register Rn) {
 376     sub(Rd, zr, Rn);
 377   }
 378 
 379   inline void negsw(Register Rd, Register Rn) {
 380     subsw(Rd, zr, Rn);
 381   }
 382 
 383   inline void negs(Register Rd, Register Rn) {
 384     subs(Rd, zr, Rn);
 385   }
 386 
 387   inline void cmnw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 388     addsw(zr, Rn, Rm, kind, shift);
 389   }
 390   inline void cmn(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 391     adds(zr, Rn, Rm, kind, shift);
 392   }
 393 
 394   inline void cmpw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 395     subsw(zr, Rn, Rm, kind, shift);
 396   }
 397   inline void cmp(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 398     subs(zr, Rn, Rm, kind, shift);
 399   }
 400 
 401   inline void negw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 402     subw(Rd, zr, Rn, kind, shift);
 403   }
 404 
 405   inline void neg(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 406     sub(Rd, zr, Rn, kind, shift);
 407   }
 408 
 409   inline void negsw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 410     subsw(Rd, zr, Rn, kind, shift);
 411   }
 412 
 413   inline void negs(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 414     subs(Rd, zr, Rn, kind, shift);
 415   }
 416 
 417   inline void mnegw(Register Rd, Register Rn, Register Rm) {
 418     msubw(Rd, Rn, Rm, zr);
 419   }
 420   inline void mneg(Register Rd, Register Rn, Register Rm) {
 421     msub(Rd, Rn, Rm, zr);
 422   }
 423 
 424   inline void mulw(Register Rd, Register Rn, Register Rm) {
 425     maddw(Rd, Rn, Rm, zr);
 426   }
 427   inline void mul(Register Rd, Register Rn, Register Rm) {
 428     madd(Rd, Rn, Rm, zr);
 429   }
 430 
 431   inline void smnegl(Register Rd, Register Rn, Register Rm) {
 432     smsubl(Rd, Rn, Rm, zr);
 433   }
 434   inline void smull(Register Rd, Register Rn, Register Rm) {
 435     smaddl(Rd, Rn, Rm, zr);
 436   }
 437 
 438   inline void umnegl(Register Rd, Register Rn, Register Rm) {
 439     umsubl(Rd, Rn, Rm, zr);
 440   }
 441   inline void umull(Register Rd, Register Rn, Register Rm) {
 442     umaddl(Rd, Rn, Rm, zr);
 443   }
 444 
 445 #define WRAP(INSN)                                                            \
 446   void INSN(Register Rd, Register Rn, Register Rm, Register Ra) {             \
 447     if ((VM_Version::features() &amp; VM_Version::CPU_A53MAC) &amp;&amp; Ra != zr)        \
 448       nop();                                                                  \
 449     Assembler::INSN(Rd, Rn, Rm, Ra);                                          \
 450   }
 451 
 452   WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)
 453   WRAP(smaddl) WRAP(smsubl) WRAP(umaddl) WRAP(umsubl)
 454 #undef WRAP
 455 
 456 
 457   // macro assembly operations needed for aarch64
 458 
 459   // first two private routines for loading 32 bit or 64 bit constants
 460 private:
 461 
 462   void mov_immediate64(Register dst, u_int64_t imm64);
 463   void mov_immediate32(Register dst, u_int32_t imm32);
 464 
 465   int push(unsigned int bitset, Register stack);
 466   int pop(unsigned int bitset, Register stack);
 467 
 468   int push_fp(unsigned int bitset, Register stack);
 469   int pop_fp(unsigned int bitset, Register stack);
 470 
 471   void mov(Register dst, Address a);
 472 
 473 public:
 474   void push(RegSet regs, Register stack) { if (regs.bits()) push(regs.bits(), stack); }
 475   void pop(RegSet regs, Register stack) { if (regs.bits()) pop(regs.bits(), stack); }
 476 
 477   void push_fp(RegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }
 478   void pop_fp(RegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }
 479 
 480   // Push and pop everything that might be clobbered by a native
 481   // runtime call except rscratch1 and rscratch2.  (They are always
 482   // scratch, so we don&#39;t have to protect them.)  Only save the lower
 483   // 64 bits of each vector register.
 484   void push_call_clobbered_registers();
 485   void pop_call_clobbered_registers();
 486 
 487   // now mov instructions for loading absolute addresses and 32 or
 488   // 64 bit integers
 489 
 490   inline void mov(Register dst, address addr)
 491   {
 492     mov_immediate64(dst, (u_int64_t)addr);
 493   }
 494 
 495   inline void mov(Register dst, u_int64_t imm64)
 496   {
 497     mov_immediate64(dst, imm64);
 498   }
 499 
 500   inline void movw(Register dst, u_int32_t imm32)
 501   {
 502     mov_immediate32(dst, imm32);
 503   }
 504 
 505   inline void mov(Register dst, long l)
 506   {
 507     mov(dst, (u_int64_t)l);
 508   }
 509 
 510   inline void mov(Register dst, int i)
 511   {
 512     mov(dst, (long)i);
 513   }
 514 
 515   void mov(Register dst, RegisterOrConstant src) {
 516     if (src.is_register())
 517       mov(dst, src.as_register());
 518     else
 519       mov(dst, src.as_constant());
 520   }
 521 
 522   void movptr(Register r, uintptr_t imm64);
 523 
 524   void mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32);
 525 
 526   void mov(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {
 527     orr(Vd, T, Vn, Vn);
 528   }
 529 
 530 public:
 531 
 532   // Generalized Test Bit And Branch, including a &quot;far&quot; variety which
 533   // spans more than 32KiB.
 534   void tbr(Condition cond, Register Rt, int bitpos, Label &amp;dest, bool far = false) {
 535     assert(cond == EQ || cond == NE, &quot;must be&quot;);
 536 
 537     if (far)
 538       cond = ~cond;
 539 
 540     void (Assembler::* branch)(Register Rt, int bitpos, Label &amp;L);
 541     if (cond == Assembler::EQ)
 542       branch = &amp;Assembler::tbz;
 543     else
 544       branch = &amp;Assembler::tbnz;
 545 
 546     if (far) {
 547       Label L;
 548       (this-&gt;*branch)(Rt, bitpos, L);
 549       b(dest);
 550       bind(L);
 551     } else {
 552       (this-&gt;*branch)(Rt, bitpos, dest);
 553     }
 554   }
 555 
 556   // macro instructions for accessing and updating floating point
 557   // status register
 558   //
 559   // FPSR : op1 == 011
 560   //        CRn == 0100
 561   //        CRm == 0100
 562   //        op2 == 001
 563 
 564   inline void get_fpsr(Register reg)
 565   {
 566     mrs(0b11, 0b0100, 0b0100, 0b001, reg);
 567   }
 568 
 569   inline void set_fpsr(Register reg)
 570   {
 571     msr(0b011, 0b0100, 0b0100, 0b001, reg);
 572   }
 573 
 574   inline void clear_fpsr()
 575   {
 576     msr(0b011, 0b0100, 0b0100, 0b001, zr);
 577   }
 578 
 579   // DCZID_EL0: op1 == 011
 580   //            CRn == 0000
 581   //            CRm == 0000
 582   //            op2 == 111
 583   inline void get_dczid_el0(Register reg)
 584   {
 585     mrs(0b011, 0b0000, 0b0000, 0b111, reg);
 586   }
 587 
 588   // CTR_EL0:   op1 == 011
 589   //            CRn == 0000
 590   //            CRm == 0000
 591   //            op2 == 001
 592   inline void get_ctr_el0(Register reg)
 593   {
 594     mrs(0b011, 0b0000, 0b0000, 0b001, reg);
 595   }
 596 
 597   // idiv variant which deals with MINLONG as dividend and -1 as divisor
 598   int corrected_idivl(Register result, Register ra, Register rb,
 599                       bool want_remainder, Register tmp = rscratch1);
 600   int corrected_idivq(Register result, Register ra, Register rb,
 601                       bool want_remainder, Register tmp = rscratch1);
 602 
 603   // Support for NULL-checks
 604   //
 605   // Generates code that causes a NULL OS exception if the content of reg is NULL.
 606   // If the accessed location is M[reg + offset] and the offset is known, provide the
 607   // offset. No explicit code generation is needed if the offset is within a certain
 608   // range (0 &lt;= offset &lt;= page_size).
 609 
 610   virtual void null_check(Register reg, int offset = -1);
 611   static bool needs_explicit_null_check(intptr_t offset);
 612   static bool uses_implicit_null_check(void* address);
 613 
 614   void test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value);
 615 
 616   void test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable);
 617   void test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; notFlattenable);
 618   void test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened);
 619 
 620   // Check klass/oops is flat value type array (oop-&gt;_klass-&gt;_layout_helper &amp; vt_bit)
 621   void test_flattened_array_oop(Register klass, Register temp_reg, Label&amp; is_flattened_array);
 622   void test_null_free_array_oop(Register oop, Register temp_reg, Label&amp; is_null_free_array);
 623 
 624   static address target_addr_for_insn(address insn_addr, unsigned insn);
 625   static address target_addr_for_insn(address insn_addr) {
 626     unsigned insn = *(unsigned*)insn_addr;
 627     return target_addr_for_insn(insn_addr, insn);
 628   }
 629 
 630   // Required platform-specific helpers for Label::patch_instructions.
 631   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 632   static int pd_patch_instruction_size(address branch, address target);
 633   static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {
 634     pd_patch_instruction_size(branch, target);
 635   }
 636   static address pd_call_destination(address branch) {
 637     return target_addr_for_insn(branch);
 638   }
 639 #ifndef PRODUCT
 640   static void pd_print_patched_instruction(address branch);
 641 #endif
 642 
 643   static int patch_oop(address insn_addr, address o);
 644   static int patch_narrow_klass(address insn_addr, narrowKlass n);
 645 
 646   address emit_trampoline_stub(int insts_call_instruction_offset, address target);
 647   void emit_static_call_stub();
 648 
 649   // The following 4 methods return the offset of the appropriate move instruction
 650 
 651   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 652   int load_unsigned_byte(Register dst, Address src);
 653   int load_unsigned_short(Register dst, Address src);
 654 
 655   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 656   int load_signed_byte(Register dst, Address src);
 657   int load_signed_short(Register dst, Address src);
 658 
 659   int load_signed_byte32(Register dst, Address src);
 660   int load_signed_short32(Register dst, Address src);
 661 
 662   // Support for sign-extension (hi:lo = extend_sign(lo))
 663   void extend_sign(Register hi, Register lo);
 664 
 665   // Load and store values by size and signed-ness
 666   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 667   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 668 
 669   // Support for inc/dec with optimal instruction selection depending on value
 670 
 671   // x86_64 aliases an unqualified register/address increment and
 672   // decrement to call incrementq and decrementq but also supports
 673   // explicitly sized calls to incrementq/decrementq or
 674   // incrementl/decrementl
 675 
 676   // for aarch64 the proper convention would be to use
 677   // increment/decrement for 64 bit operatons and
 678   // incrementw/decrementw for 32 bit operations. so when porting
 679   // x86_64 code we can leave calls to increment/decrement as is,
 680   // replace incrementq/decrementq with increment/decrement and
 681   // replace incrementl/decrementl with incrementw/decrementw.
 682 
 683   // n.b. increment/decrement calls with an Address destination will
 684   // need to use a scratch register to load the value to be
 685   // incremented. increment/decrement calls which add or subtract a
 686   // constant value greater than 2^12 will need to use a 2nd scratch
 687   // register to hold the constant. so, a register increment/decrement
 688   // may trash rscratch2 and an address increment/decrement trash
 689   // rscratch and rscratch2
 690 
 691   void decrementw(Address dst, int value = 1);
 692   void decrementw(Register reg, int value = 1);
 693 
 694   void decrement(Register reg, int value = 1);
 695   void decrement(Address dst, int value = 1);
 696 
 697   void incrementw(Address dst, int value = 1);
 698   void incrementw(Register reg, int value = 1);
 699 
 700   void increment(Register reg, int value = 1);
 701   void increment(Address dst, int value = 1);
 702 
 703 
 704   // Alignment
 705   void align(int modulus);
 706 
 707   // Stack frame creation/removal
 708   void enter()
 709   {
 710     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
 711     mov(rfp, sp);
 712   }
 713   void leave()
 714   {
 715     mov(sp, rfp);
 716     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
 717   }
 718 
 719   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 720   // The pointer will be loaded into the thread register.
 721   void get_thread(Register thread);
 722 
 723 
 724   // Support for VM calls
 725   //
 726   // It is imperative that all calls into the VM are handled via the call_VM macros.
 727   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 728   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 729 
 730 
 731   void call_VM(Register oop_result,
 732                address entry_point,
 733                bool check_exceptions = true);
 734   void call_VM(Register oop_result,
 735                address entry_point,
 736                Register arg_1,
 737                bool check_exceptions = true);
 738   void call_VM(Register oop_result,
 739                address entry_point,
 740                Register arg_1, Register arg_2,
 741                bool check_exceptions = true);
 742   void call_VM(Register oop_result,
 743                address entry_point,
 744                Register arg_1, Register arg_2, Register arg_3,
 745                bool check_exceptions = true);
 746 
 747   // Overloadings with last_Java_sp
 748   void call_VM(Register oop_result,
 749                Register last_java_sp,
 750                address entry_point,
 751                int number_of_arguments = 0,
 752                bool check_exceptions = true);
 753   void call_VM(Register oop_result,
 754                Register last_java_sp,
 755                address entry_point,
 756                Register arg_1, bool
 757                check_exceptions = true);
 758   void call_VM(Register oop_result,
 759                Register last_java_sp,
 760                address entry_point,
 761                Register arg_1, Register arg_2,
 762                bool check_exceptions = true);
 763   void call_VM(Register oop_result,
 764                Register last_java_sp,
 765                address entry_point,
 766                Register arg_1, Register arg_2, Register arg_3,
 767                bool check_exceptions = true);
 768 
 769   void get_vm_result  (Register oop_result, Register thread);
 770   void get_vm_result_2(Register metadata_result, Register thread);
 771 
 772   // These always tightly bind to MacroAssembler::call_VM_base
 773   // bypassing the virtual implementation
 774   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 775   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 776   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 777   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 778   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 779 
 780   void call_VM_leaf(address entry_point,
 781                     int number_of_arguments = 0);
 782   void call_VM_leaf(address entry_point,
 783                     Register arg_1);
 784   void call_VM_leaf(address entry_point,
 785                     Register arg_1, Register arg_2);
 786   void call_VM_leaf(address entry_point,
 787                     Register arg_1, Register arg_2, Register arg_3);
 788 
 789   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 790   // bypassing the virtual implementation
 791   void super_call_VM_leaf(address entry_point);
 792   void super_call_VM_leaf(address entry_point, Register arg_1);
 793   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 794   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 795   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 796 
 797   // last Java Frame (fills frame anchor)
 798   void set_last_Java_frame(Register last_java_sp,
 799                            Register last_java_fp,
 800                            address last_java_pc,
 801                            Register scratch);
 802 
 803   void set_last_Java_frame(Register last_java_sp,
 804                            Register last_java_fp,
 805                            Label &amp;last_java_pc,
 806                            Register scratch);
 807 
 808   void set_last_Java_frame(Register last_java_sp,
 809                            Register last_java_fp,
 810                            Register last_java_pc,
 811                            Register scratch);
 812 
 813   void reset_last_Java_frame(Register thread);
 814 
 815   // thread in the default location (rthread)
 816   void reset_last_Java_frame(bool clear_fp);
 817 
 818   // Stores
 819   void store_check(Register obj);                // store check for obj - register is destroyed afterwards
 820   void store_check(Register obj, Address dst);   // same as above, dst is exact store location (reg. is destroyed)
 821 
 822   void resolve_jobject(Register value, Register thread, Register tmp);
 823 
 824   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 825   void c2bool(Register x);
 826 
 827   void load_method_holder(Register holder, Register method);
 828 
 829   // oop manipulations
 830   void load_metadata(Register dst, Register src);
 831   void load_storage_props(Register dst, Register src);
 832 
 833   void load_klass(Register dst, Register src);
 834   void store_klass(Register dst, Register src);
 835   void cmp_klass(Register oop, Register trial_klass, Register tmp);
 836 
 837   void resolve_oop_handle(Register result, Register tmp = r5);
 838   void load_mirror(Register dst, Register method, Register tmp = r5);
 839 
 840   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 841                       Register tmp1, Register tmp_thread);
 842 
 843   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 844                        Register tmp1, Register tmp_thread, Register tmp3 = noreg);
 845 
 846   // Resolves obj for access. Result is placed in the same register.
 847   // All other registers are preserved.
 848   void resolve(DecoratorSet decorators, Register obj);
 849 
 850   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 851                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 852 
 853   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 854                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 855   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 856                       Register tmp_thread = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);
 857 
 858   // currently unimplemented
 859   // Used for storing NULL. All other oop constants should be
 860   // stored using routines that take a jobject.
 861   void store_heap_oop_null(Address dst);
 862 
 863   void load_prototype_header(Register dst, Register src);
 864 
 865   void store_klass_gap(Register dst, Register src);
 866 
 867   // This dummy is to prevent a call to store_heap_oop from
 868   // converting a zero (like NULL) into a Register by giving
 869   // the compiler two choices it can&#39;t resolve
 870 
 871   void store_heap_oop(Address dst, void* dummy);
 872 
 873   void encode_heap_oop(Register d, Register s);
 874   void encode_heap_oop(Register r) { encode_heap_oop(r, r); }
 875   void decode_heap_oop(Register d, Register s);
 876   void decode_heap_oop(Register r) { decode_heap_oop(r, r); }
 877   void encode_heap_oop_not_null(Register r);
 878   void decode_heap_oop_not_null(Register r);
 879   void encode_heap_oop_not_null(Register dst, Register src);
 880   void decode_heap_oop_not_null(Register dst, Register src);
 881 
 882   void set_narrow_oop(Register dst, jobject obj);
 883 
 884   void encode_klass_not_null(Register r);
 885   void decode_klass_not_null(Register r);
 886   void encode_klass_not_null(Register dst, Register src);
 887   void decode_klass_not_null(Register dst, Register src);
 888 
 889   void set_narrow_klass(Register dst, Klass* k);
 890 
 891   // if heap base register is used - reinit it with the correct value
 892   void reinit_heapbase();
 893 
 894   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 895 
 896   void push_CPU_state(bool save_vectors = false);
 897   void pop_CPU_state(bool restore_vectors = false) ;
 898 
 899   // Round up to a power of two
 900   void round_to(Register reg, int modulus);
 901 
 902   // allocation
 903   void eden_allocate(
 904     Register obj,                      // result: pointer to object after successful allocation
 905     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 906     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 907     Register t1,                       // temp register
 908     Label&amp;   slow_case                 // continuation point if fast allocation fails
 909   );
 910   void tlab_allocate(
 911     Register obj,                      // result: pointer to object after successful allocation
 912     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 913     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 914     Register t1,                       // temp register
 915     Register t2,                       // temp register
 916     Label&amp;   slow_case                 // continuation point if fast allocation fails
 917   );
 918   void zero_memory(Register addr, Register len, Register t1);
 919   void verify_tlab();
 920 
 921   // interface method calling
 922   void lookup_interface_method(Register recv_klass,
 923                                Register intf_klass,
 924                                RegisterOrConstant itable_index,
 925                                Register method_result,
 926                                Register scan_temp,
 927                                Label&amp; no_such_interface,
 928                    bool return_method = true);
 929 
 930   // virtual method calling
 931   // n.b. x86 allows RegisterOrConstant for vtable_index
 932   void lookup_virtual_method(Register recv_klass,
 933                              RegisterOrConstant vtable_index,
 934                              Register method_result);
 935 
 936   // Test sub_klass against super_klass, with fast and slow paths.
 937 
 938   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 939   // One of the three labels can be NULL, meaning take the fall-through.
 940   // If super_check_offset is -1, the value is loaded up from super_klass.
 941   // No registers are killed, except temp_reg.
 942   void check_klass_subtype_fast_path(Register sub_klass,
 943                                      Register super_klass,
 944                                      Register temp_reg,
 945                                      Label* L_success,
 946                                      Label* L_failure,
 947                                      Label* L_slow_path,
 948                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 949 
 950   // The rest of the type check; must be wired to a corresponding fast path.
 951   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 952   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 953   // Updates the sub&#39;s secondary super cache as necessary.
 954   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 955   void check_klass_subtype_slow_path(Register sub_klass,
 956                                      Register super_klass,
 957                                      Register temp_reg,
 958                                      Register temp2_reg,
 959                                      Label* L_success,
 960                                      Label* L_failure,
 961                                      bool set_cond_codes = false);
 962 
 963   // Simplified, combined version, good for typical uses.
 964   // Falls through on failure.
 965   void check_klass_subtype(Register sub_klass,
 966                            Register super_klass,
 967                            Register temp_reg,
 968                            Label&amp; L_success);
 969 
 970   void clinit_barrier(Register klass,
 971                       Register thread,
 972                       Label* L_fast_path = NULL,
 973                       Label* L_slow_path = NULL);
 974 
 975   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 976 
 977 
 978   // Debugging
 979 
 980   // only if +VerifyOops
 981   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 982   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 983 
 984 // TODO: verify method and klass metadata (compare against vptr?)
 985   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 986   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 987 
 988 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 989 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 990 
 991   // only if +VerifyFPU
 992   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 993 
 994   // prints msg, dumps registers and stops execution
 995   void stop(const char* msg);
 996 
 997   // prints msg and continues
 998   void warn(const char* msg);
 999 
1000   static void debug64(char* msg, int64_t pc, int64_t regs[]);
1001 
1002   void untested()                                { stop(&quot;untested&quot;); }
1003 
1004   void unimplemented(const char* what = &quot;&quot;);
1005 
1006   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
1007 
1008   // Stack overflow checking
1009   void bang_stack_with_offset(int offset) {
1010     // stack grows down, caller passes positive offset
1011     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
1012     sub(rscratch2, sp, offset);
1013     str(zr, Address(rscratch2));
1014   }
1015 
1016   // Writes to stack successive pages until offset reached to check for
1017   // stack overflow + shadow pages.  Also, clobbers tmp
1018   void bang_stack_size(Register size, Register tmp);
1019 
1020   // Check for reserved stack access in method being exited (for JIT)
1021   void reserved_stack_check();
1022 
1023   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
1024                                                 Register tmp,
1025                                                 int offset);
1026 
1027   // Arithmetics
1028 
1029   void addptr(const Address &amp;dst, int32_t src);
1030   void cmpptr(Register src1, Address src2);
1031 
1032   void cmpoop(Register obj1, Register obj2);
1033 
1034   // Various forms of CAS
1035 
1036   void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
1037                           Label &amp;suceed, Label *fail);
1038   void cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
1039                   Label &amp;suceed, Label *fail);
1040 
1041   void cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
1042                   Label &amp;suceed, Label *fail);
1043 
1044   void atomic_add(Register prev, RegisterOrConstant incr, Register addr);
1045   void atomic_addw(Register prev, RegisterOrConstant incr, Register addr);
1046   void atomic_addal(Register prev, RegisterOrConstant incr, Register addr);
1047   void atomic_addalw(Register prev, RegisterOrConstant incr, Register addr);
1048 
1049   void atomic_xchg(Register prev, Register newv, Register addr);
1050   void atomic_xchgw(Register prev, Register newv, Register addr);
1051   void atomic_xchgal(Register prev, Register newv, Register addr);
1052   void atomic_xchgalw(Register prev, Register newv, Register addr);
1053 
1054   void orptr(Address adr, RegisterOrConstant src) {
1055     ldr(rscratch1, adr);
1056     if (src.is_register())
1057       orr(rscratch1, rscratch1, src.as_register());
1058     else
1059       orr(rscratch1, rscratch1, src.as_constant());
1060     str(rscratch1, adr);
1061   }
1062 
1063   // A generic CAS; success or failure is in the EQ flag.
1064   // Clobbers rscratch1
1065   void cmpxchg(Register addr, Register expected, Register new_val,
1066                enum operand_size size,
1067                bool acquire, bool release, bool weak,
1068                Register result);
1069 private:
1070   void compare_eq(Register rn, Register rm, enum operand_size size);
1071 
1072 public:
1073   // Calls
1074 
1075   address trampoline_call(Address entry, CodeBuffer *cbuf = NULL);
1076 
1077   static bool far_branches() {
1078     return ReservedCodeCacheSize &gt; branch_range || UseAOT;
1079   }
1080 
1081   // Jumps that can reach anywhere in the code cache.
1082   // Trashes tmp.
1083   void far_call(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1084   void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1085 
1086   static int far_branch_size() {
1087     if (far_branches()) {
1088       return 3 * 4;  // adrp, add, br
1089     } else {
1090       return 4;
1091     }
1092   }
1093 
1094   // Emit the CompiledIC call idiom
1095   address ic_call(address entry, jint method_index = 0);
1096 
1097 public:
1098 
1099   // Data
1100 
1101   void mov_metadata(Register dst, Metadata* obj);
1102   Address allocate_metadata_address(Metadata* obj);
1103   Address constant_oop_address(jobject obj);
1104 
1105   void movoop(Register dst, jobject obj, bool immediate = false);
1106 
1107   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1108   void kernel_crc32(Register crc, Register buf, Register len,
1109         Register table0, Register table1, Register table2, Register table3,
1110         Register tmp, Register tmp2, Register tmp3);
1111   // CRC32 code for java.util.zip.CRC32C::updateBytes() instrinsic.
1112   void kernel_crc32c(Register crc, Register buf, Register len,
1113         Register table0, Register table1, Register table2, Register table3,
1114         Register tmp, Register tmp2, Register tmp3);
1115 
1116   // Stack push and pop individual 64 bit registers
1117   void push(Register src);
1118   void pop(Register dst);
1119 
1120   // push all registers onto the stack
1121   void pusha();
1122   void popa();
1123 
1124   void repne_scan(Register addr, Register value, Register count,
1125                   Register scratch);
1126   void repne_scanw(Register addr, Register value, Register count,
1127                    Register scratch);
1128 
1129   typedef void (MacroAssembler::* add_sub_imm_insn)(Register Rd, Register Rn, unsigned imm);
1130   typedef void (MacroAssembler::* add_sub_reg_insn)(Register Rd, Register Rn, Register Rm, enum shift_kind kind, unsigned shift);
1131 
1132   // If a constant does not fit in an immediate field, generate some
1133   // number of MOV instructions and then perform the operation
1134   void wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
1135                              add_sub_imm_insn insn1,
1136                              add_sub_reg_insn insn2);
1137   // Seperate vsn which sets the flags
1138   void wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
1139                              add_sub_imm_insn insn1,
1140                              add_sub_reg_insn insn2);
1141 
1142 #define WRAP(INSN)                                                      \
1143   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1144     wrap_add_sub_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1145   }                                                                     \
1146                                                                         \
1147   void INSN(Register Rd, Register Rn, Register Rm,                      \
1148              enum shift_kind kind, unsigned shift = 0) {                \
1149     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1150   }                                                                     \
1151                                                                         \
1152   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1153     Assembler::INSN(Rd, Rn, Rm);                                        \
1154   }                                                                     \
1155                                                                         \
1156   void INSN(Register Rd, Register Rn, Register Rm,                      \
1157            ext::operation option, int amount = 0) {                     \
1158     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1159   }
1160 
1161   WRAP(add) WRAP(addw) WRAP(sub) WRAP(subw)
1162 
1163 #undef WRAP
1164 #define WRAP(INSN)                                                      \
1165   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1166     wrap_adds_subs_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1167   }                                                                     \
1168                                                                         \
1169   void INSN(Register Rd, Register Rn, Register Rm,                      \
1170              enum shift_kind kind, unsigned shift = 0) {                \
1171     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1172   }                                                                     \
1173                                                                         \
1174   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1175     Assembler::INSN(Rd, Rn, Rm);                                        \
1176   }                                                                     \
1177                                                                         \
1178   void INSN(Register Rd, Register Rn, Register Rm,                      \
1179            ext::operation option, int amount = 0) {                     \
1180     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1181   }
1182 
1183   WRAP(adds) WRAP(addsw) WRAP(subs) WRAP(subsw)
1184 
1185   void add(Register Rd, Register Rn, RegisterOrConstant increment);
1186   void addw(Register Rd, Register Rn, RegisterOrConstant increment);
1187   void sub(Register Rd, Register Rn, RegisterOrConstant decrement);
1188   void subw(Register Rd, Register Rn, RegisterOrConstant decrement);
1189 
1190   void adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset);
1191 
1192 
1193   enum RegState {
1194      reg_readonly,
1195      reg_writable,
1196      reg_written
1197   };
1198 
1199   void verified_entry(Compile* C, int sp_inc);
1200 
1201   int store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter = true);
1202 
1203 // Unpack all value type arguments passed as oops
1204   void unpack_value_args(Compile* C, bool receiver_only);
1205   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1206   bool unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
1207                            RegState reg_state[], int ret_off, int extra_stack_offset);
1208   bool pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
1209                          VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
1210                          int ret_off, int extra_stack_offset);
1211   void restore_stack(Compile* C);
1212 
1213   int shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,
1214                          BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
1215                          int args_passed, int args_on_stack, VMRegPair* regs,
1216                          int args_passed_to, int args_on_stack_to, VMRegPair* regs_to);
1217   bool shuffle_value_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
1218                                 VMRegPair* regs_from, int from_index, int regs_from_count,
1219                                 RegState* reg_state, int sp_inc, int extra_stack_offset);
1220   VMReg spill_reg_for(VMReg reg);
1221 
1222 
1223   void tableswitch(Register index, jint lowbound, jint highbound,
1224                    Label &amp;jumptable, Label &amp;jumptable_end, int stride = 1) {
1225     adr(rscratch1, jumptable);
1226     subsw(rscratch2, index, lowbound);
1227     subsw(zr, rscratch2, highbound - lowbound);
1228     br(Assembler::HS, jumptable_end);
1229     add(rscratch1, rscratch1, rscratch2,
1230         ext::sxtw, exact_log2(stride * Assembler::instruction_size));
1231     br(rscratch1);
1232   }
1233 
1234   // Form an address from base + offset in Rd.  Rd may or may not
1235   // actually be used: you must use the Address that is returned.  It
1236   // is up to you to ensure that the shift provided matches the size
1237   // of your data.
1238   Address form_address(Register Rd, Register base, long byte_offset, int shift);
1239 
1240   // Return true iff an address is within the 48-bit AArch64 address
1241   // space.
1242   bool is_valid_AArch64_address(address a) {
1243     return ((uint64_t)a &gt;&gt; 48) == 0;
1244   }
1245 
1246   // Load the base of the cardtable byte map into reg.
1247   void load_byte_map_base(Register reg);
1248 
1249   // Prolog generator routines to support switch between x86 code and
1250   // generated ARM code
1251 
1252   // routine to generate an x86 prolog for a stub function which
1253   // bootstraps into the generated ARM code which directly follows the
1254   // stub
1255   //
1256 
1257   public:
1258 
1259   void ldr_constant(Register dest, const Address &amp;const_addr) {
1260     if (NearCpool) {
1261       ldr(dest, const_addr);
1262     } else {
1263       unsigned long offset;
1264       adrp(dest, InternalAddress(const_addr.target()), offset);
1265       ldr(dest, Address(dest, offset));
1266     }
1267   }
1268 
1269   address read_polling_page(Register r, relocInfo::relocType rtype);
1270   void get_polling_page(Register dest, relocInfo::relocType rtype);
1271   address fetch_and_read_polling_page(Register r, relocInfo::relocType rtype);
1272 
1273   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1274   void update_byte_crc32(Register crc, Register val, Register table);
1275   void update_word_crc32(Register crc, Register v, Register tmp,
1276         Register table0, Register table1, Register table2, Register table3,
1277         bool upper = false);
1278 
1279   void has_negatives(Register ary1, Register len, Register result);
1280 
1281   void arrays_equals(Register a1, Register a2, Register result, Register cnt1,
1282                      Register tmp1, Register tmp2, Register tmp3, int elem_size);
1283 
1284   void string_equals(Register a1, Register a2, Register result, Register cnt1,
1285                      int elem_size);
1286 
1287   void fill_words(Register base, Register cnt, Register value);
1288   void fill_words(Register base, u_int64_t cnt, Register value);
1289 
1290   void zero_words(Register base, u_int64_t cnt);
1291   void zero_words(Register ptr, Register cnt);
1292   void zero_dcache_blocks(Register base, Register cnt);
1293 
1294   static const int zero_words_block_size;
1295 
1296   void byte_array_inflate(Register src, Register dst, Register len,
1297                           FloatRegister vtmp1, FloatRegister vtmp2,
1298                           FloatRegister vtmp3, Register tmp4);
1299 
1300   void char_array_compress(Register src, Register dst, Register len,
1301                            FloatRegister tmp1Reg, FloatRegister tmp2Reg,
1302                            FloatRegister tmp3Reg, FloatRegister tmp4Reg,
1303                            Register result);
1304 
1305   void encode_iso_array(Register src, Register dst,
1306                         Register len, Register result,
1307                         FloatRegister Vtmp1, FloatRegister Vtmp2,
1308                         FloatRegister Vtmp3, FloatRegister Vtmp4);
1309   void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,
1310                 FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,
1311                 FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,
1312                 FloatRegister tmpC4, Register tmp1, Register tmp2,
1313                 Register tmp3, Register tmp4, Register tmp5);
1314   void generate_dsin_dcos(bool isCos, address npio2_hw, address two_over_pi,
1315       address pio2, address dsin_coef, address dcos_coef);
1316  private:
1317   // begin trigonometric functions support block
1318   void generate__ieee754_rem_pio2(address npio2_hw, address two_over_pi, address pio2);
1319   void generate__kernel_rem_pio2(address two_over_pi, address pio2);
1320   void generate_kernel_sin(FloatRegister x, bool iyIsOne, address dsin_coef);
1321   void generate_kernel_cos(FloatRegister x, address dcos_coef);
1322   // end trigonometric functions support block
1323   void add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
1324                        Register src1, Register src2);
1325   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
1326     add2_with_carry(dest_hi, dest_hi, dest_lo, src1, src2);
1327   }
1328   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1329                              Register y, Register y_idx, Register z,
1330                              Register carry, Register product,
1331                              Register idx, Register kdx);
1332   void multiply_128_x_128_loop(Register y, Register z,
1333                                Register carry, Register carry2,
1334                                Register idx, Register jdx,
1335                                Register yz_idx1, Register yz_idx2,
1336                                Register tmp, Register tmp3, Register tmp4,
1337                                Register tmp7, Register product_hi);
1338   void kernel_crc32_using_crc32(Register crc, Register buf,
1339         Register len, Register tmp0, Register tmp1, Register tmp2,
1340         Register tmp3);
1341   void kernel_crc32c_using_crc32c(Register crc, Register buf,
1342         Register len, Register tmp0, Register tmp1, Register tmp2,
1343         Register tmp3);
1344 public:
1345   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z,
1346                        Register zlen, Register tmp1, Register tmp2, Register tmp3,
1347                        Register tmp4, Register tmp5, Register tmp6, Register tmp7);
1348   void mul_add(Register out, Register in, Register offs, Register len, Register k);
1349   // ISB may be needed because of a safepoint
1350   void maybe_isb() { isb(); }
1351 
1352 private:
1353   // Return the effective address r + (r1 &lt;&lt; ext) + offset.
1354   // Uses rscratch2.
1355   Address offsetted_address(Register r, Register r1, Address::extend ext,
1356                             int offset, int size);
1357 
1358 private:
1359   // Returns an address on the stack which is reachable with a ldr/str of size
1360   // Uses rscratch2 if the address is not directly reachable
1361   Address spill_address(int size, int offset, Register tmp=rscratch2);
1362 
1363   bool merge_alignment_check(Register base, size_t size, long cur_offset, long prev_offset) const;
1364 
1365   // Check whether two loads/stores can be merged into ldp/stp.
1366   bool ldst_can_merge(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store) const;
1367 
1368   // Merge current load/store with previous load/store into ldp/stp.
1369   void merge_ldst(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1370 
1371   // Try to merge two loads/stores into ldp/stp. If success, returns true else false.
1372   bool try_merge_ldst(Register rt, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1373 
1374 public:
1375   void spill(Register Rx, bool is64, int offset) {
1376     if (is64) {
1377       str(Rx, spill_address(8, offset));
1378     } else {
1379       strw(Rx, spill_address(4, offset));
1380     }
1381   }
1382   void spill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1383     str(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1384   }
1385   void unspill(Register Rx, bool is64, int offset) {
1386     if (is64) {
1387       ldr(Rx, spill_address(8, offset));
1388     } else {
1389       ldrw(Rx, spill_address(4, offset));
1390     }
1391   }
1392   void unspill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1393     ldr(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1394   }
1395   void spill_copy128(int src_offset, int dst_offset,
1396                      Register tmp1=rscratch1, Register tmp2=rscratch2) {
1397     if (src_offset &lt; 512 &amp;&amp; (src_offset &amp; 7) == 0 &amp;&amp;
1398         dst_offset &lt; 512 &amp;&amp; (dst_offset &amp; 7) == 0) {
1399       ldp(tmp1, tmp2, Address(sp, src_offset));
1400       stp(tmp1, tmp2, Address(sp, dst_offset));
1401     } else {
1402       unspill(tmp1, true, src_offset);
1403       spill(tmp1, true, dst_offset);
1404       unspill(tmp1, true, src_offset+8);
1405       spill(tmp1, true, dst_offset+8);
1406     }
1407   }
1408 
1409   void cache_wb(Address line);
1410   void cache_wbsync(bool is_pre);
1411 
1412   #include &quot;asm/macroAssembler_common.hpp&quot;
1413 
1414 };
1415 
1416 #ifdef ASSERT
1417 inline bool AbstractAssembler::pd_check_instruction_mark() { return false; }
1418 #endif
1419 
1420 /**
1421  * class SkipIfEqual:
1422  *
1423  * Instantiating this class will result in assembly code being output that will
1424  * jump around any code emitted between the creation of the instance and it&#39;s
1425  * automatic destruction at the end of a scope block, depending on the value of
1426  * the flag passed to the constructor, which will be checked at run-time.
1427  */
1428 class SkipIfEqual {
1429  private:
1430   MacroAssembler* _masm;
1431   Label _label;
1432 
1433  public:
1434    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1435    ~SkipIfEqual();
1436 };
1437 
1438 struct tableswitch {
1439   Register _reg;
1440   int _insn_index; jint _first_key; jint _last_key;
1441   Label _after;
1442   Label _branches;
1443 };
1444 
1445 #endif // CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
    </pre>
  </body>
</html>
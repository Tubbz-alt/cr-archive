<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/aarch64/gc/g1/g1BarrierSetAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
 28 #include &quot;gc/g1/g1BarrierSetAssembler.hpp&quot;
 29 #include &quot;gc/g1/g1BarrierSetRuntime.hpp&quot;
 30 #include &quot;gc/g1/g1CardTable.hpp&quot;
 31 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
 32 #include &quot;gc/g1/heapRegion.hpp&quot;
 33 #include &quot;gc/shared/collectedHeap.hpp&quot;
 34 #include &quot;runtime/sharedRuntime.hpp&quot;
 35 #include &quot;runtime/thread.hpp&quot;
 36 #include &quot;interpreter/interp_masm.hpp&quot;
 37 #include &quot;runtime/sharedRuntime.hpp&quot;
 38 #ifdef COMPILER1
 39 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 40 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 41 #include &quot;gc/g1/c1/g1BarrierSetC1.hpp&quot;
 42 #endif
 43 
 44 #define __ masm-&gt;
 45 
 46 void G1BarrierSetAssembler::gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,
 47                                                             Register addr, Register count, RegSet saved_regs) {
 48   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
 49   if (!dest_uninitialized) {
 50     Label done;
 51     Address in_progress(rthread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));
 52 
 53     // Is marking active?
 54     if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {
 55       __ ldrw(rscratch1, in_progress);
 56     } else {
 57       assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);
 58       __ ldrb(rscratch1, in_progress);
 59     }
 60     __ cbzw(rscratch1, done);
 61 
 62     __ push(saved_regs, sp);
 63     if (count == c_rarg0) {
 64       if (addr == c_rarg1) {
 65         // exactly backwards!!
 66         __ mov(rscratch1, c_rarg0);
 67         __ mov(c_rarg0, c_rarg1);
 68         __ mov(c_rarg1, rscratch1);
 69       } else {
 70         __ mov(c_rarg1, count);
 71         __ mov(c_rarg0, addr);
 72       }
 73     } else {
 74       __ mov(c_rarg0, addr);
 75       __ mov(c_rarg1, count);
 76     }
 77     if (UseCompressedOops) {
 78       __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_array_pre_narrow_oop_entry), 2);
 79     } else {
 80       __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_array_pre_oop_entry), 2);
 81     }
 82     __ pop(saved_regs, sp);
 83 
 84     __ bind(done);
 85   }
 86 }
 87 
 88 void G1BarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,
 89                                                              Register start, Register count, Register scratch, RegSet saved_regs) {
 90   __ push(saved_regs, sp);
 91   assert_different_registers(start, count, scratch);
 92   assert_different_registers(c_rarg0, count);
 93   __ mov(c_rarg0, start);
 94   __ mov(c_rarg1, count);
 95   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_array_post_entry), 2);
 96   __ pop(saved_regs, sp);
 97 }
 98 
 99 void G1BarrierSetAssembler::g1_write_barrier_pre(MacroAssembler* masm,
100                                                  Register obj,
101                                                  Register pre_val,
102                                                  Register thread,
103                                                  Register tmp,
104                                                  bool tosca_live,
105                                                  bool expand_call) {
106   // If expand_call is true then we expand the call_VM_leaf macro
107   // directly to skip generating the check by
108   // InterpreterMacroAssembler::call_VM_leaf_base that checks _last_sp.
109 
110   assert(thread == rthread, &quot;must be&quot;);
111 
112   Label done;
113   Label runtime;
114 
115   assert_different_registers(obj, pre_val, tmp, rscratch1);
116   assert(pre_val != noreg &amp;&amp;  tmp != noreg, &quot;expecting a register&quot;);
117 
118   Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));
119   Address index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));
120   Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));
121 
122   // Is marking active?
123   if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {
124     __ ldrw(tmp, in_progress);
125   } else {
126     assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);
127     __ ldrb(tmp, in_progress);
128   }
129   __ cbzw(tmp, done);
130 
131   // Do we need to load the previous value?
132   if (obj != noreg) {
133     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
134   }
135 
136   // Is the previous value null?
137   __ cbz(pre_val, done);
138 
139   // Can we store original value in the thread&#39;s buffer?
140   // Is index == 0?
141   // (The index field is typed as size_t.)
142 
143   __ ldr(tmp, index);                      // tmp := *index_adr
144   __ cbz(tmp, runtime);                    // tmp == 0?
145                                         // If yes, goto runtime
146 
147   __ sub(tmp, tmp, wordSize);              // tmp := tmp - wordSize
148   __ str(tmp, index);                      // *index_adr := tmp
149   __ ldr(rscratch1, buffer);
150   __ add(tmp, tmp, rscratch1);             // tmp := tmp + *buffer_adr
151 
152   // Record the previous value
153   __ str(pre_val, Address(tmp, 0));
154   __ b(done);
155 
156   __ bind(runtime);
157   // save the live input values
158   RegSet saved = RegSet::of(pre_val);
159   if (tosca_live) saved += RegSet::of(r0);
160   if (obj != noreg) saved += RegSet::of(obj);
161 
162   __ push(saved, sp);
163 
164   // Calling the runtime using the regular call_VM_leaf mechanism generates
165   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
166   // that checks that the *(rfp+frame::interpreter_frame_last_sp) == NULL.
167   //
168   // If we care generating the pre-barrier without a frame (e.g. in the
169   // intrinsified Reference.get() routine) then ebp might be pointing to
170   // the caller frame and so this check will most likely fail at runtime.
171   //
172   // Expanding the call directly bypasses the generation of the check.
173   // So when we do not have have a full interpreter frame on the stack
174   // expand_call should be passed true.
175 
176   if (expand_call) {
177     assert(pre_val != c_rarg1, &quot;smashed arg&quot;);
178     __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
179   } else {
180     __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
181   }
182 
183   __ pop(saved, sp);
184 
185   __ bind(done);
186 
187 }
188 
189 void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,
190                                                   Register store_addr,
191                                                   Register new_val,
192                                                   Register thread,
193                                                   Register tmp,
194                                                   Register tmp2) {
195   assert(thread == rthread, &quot;must be&quot;);
196   assert_different_registers(store_addr, new_val, thread, tmp, tmp2,
197                              rscratch1);
198   assert(store_addr != noreg &amp;&amp; new_val != noreg &amp;&amp; tmp != noreg
199          &amp;&amp; tmp2 != noreg, &quot;expecting a register&quot;);
200 
201   Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));
202   Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));
203 
204   BarrierSet* bs = BarrierSet::barrier_set();
205   CardTableBarrierSet* ctbs = barrier_set_cast&lt;CardTableBarrierSet&gt;(bs);
206   CardTable* ct = ctbs-&gt;card_table();
207 
208   Label done;
209   Label runtime;
210 
211   // Does store cross heap regions?
212 
213   __ eor(tmp, store_addr, new_val);
214   __ lsr(tmp, tmp, HeapRegion::LogOfHRGrainBytes);
215   __ cbz(tmp, done);
216 
217   // crosses regions, storing NULL?
218 
219   __ cbz(new_val, done);
220 
221   // storing region crossing non-NULL, is card already dirty?
222 
223   ExternalAddress cardtable((address) ct-&gt;byte_map_base());
224   const Register card_addr = tmp;
225 
226   __ lsr(card_addr, store_addr, CardTable::card_shift);
227 
228   // get the address of the card
229   __ load_byte_map_base(tmp2);
230   __ add(card_addr, card_addr, tmp2);
231   __ ldrb(tmp2, Address(card_addr));
232   __ cmpw(tmp2, (int)G1CardTable::g1_young_card_val());
233   __ br(Assembler::EQ, done);
234 
235   assert((int)CardTable::dirty_card_val() == 0, &quot;must be 0&quot;);
236 
237   __ membar(Assembler::StoreLoad);
238 
239   __ ldrb(tmp2, Address(card_addr));
240   __ cbzw(tmp2, done);
241 
242   // storing a region crossing, non-NULL oop, card is clean.
243   // dirty card and log.
244 
245   __ strb(zr, Address(card_addr));
246 
247   __ ldr(rscratch1, queue_index);
248   __ cbz(rscratch1, runtime);
249   __ sub(rscratch1, rscratch1, wordSize);
250   __ str(rscratch1, queue_index);
251 
252   __ ldr(tmp2, buffer);
253   __ str(card_addr, Address(tmp2, rscratch1));
254   __ b(done);
255 
256   __ bind(runtime);
257   // save the live input values
258   RegSet saved = RegSet::of(store_addr, new_val);
259   __ push(saved, sp);
260   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);
261   __ pop(saved, sp);
262 
263   __ bind(done);
264 }
265 
266 void G1BarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
267                                     Register dst, Address src, Register tmp1, Register tmp_thread) {
268   bool on_oop = is_reference_type(type);
269   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;
270   bool on_phantom = (decorators &amp; ON_PHANTOM_OOP_REF) != 0;
271   bool on_reference = on_weak || on_phantom;
272   ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);
273   if (on_oop &amp;&amp; on_reference) {
274     // LR is live.  It must be saved around calls.
275     __ enter(); // barrier may call runtime
276     // Generate the G1 pre-barrier code to log the value of
277     // the referent field in an SATB buffer.
278     g1_write_barrier_pre(masm /* masm */,
279                          noreg /* obj */,
280                          dst /* pre_val */,
281                          rthread /* thread */,
282                          tmp1 /* tmp */,
283                          true /* tosca_live */,
284                          true /* expand_call */);
285     __ leave();
286   }
287 }
288 
289 void G1BarrierSetAssembler::oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
290                                          Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {
291 
292   bool in_heap = (decorators &amp; IN_HEAP) != 0;
293   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
294   assert((decorators &amp; IS_DEST_UNINITIALIZED) == 0, &quot;unsupported&quot;);
295 
296   bool needs_pre_barrier = as_normal;
297   bool needs_post_barrier = (val != noreg &amp;&amp; in_heap);
298 
299 
300    if (tmp3 == noreg) {
301      tmp3 = rscratch2;
302    }
303    // assert_different_registers(val, tmp1, tmp2, tmp3, rscratch1, rscratch2);
304    assert_different_registers(val, tmp1, tmp2, tmp3);
305 
306   // flatten object address if needed
307   if (dst.index() == noreg &amp;&amp; dst.offset() == 0) {
308     if (dst.base() != tmp1) {
309       __ mov(tmp1, dst.base());
310     }
311   } else {
312     __ lea(tmp1, dst);
313   }
314 
315 
316   if (needs_pre_barrier) {
317       g1_write_barrier_pre(masm,
318                        tmp1 /* obj */,
319                        tmp2 /* pre_val */,
320                        rthread /* thread */,
321                        tmp3  /* tmp */,
322                        val != noreg /* tosca_live */,
323                        false /* expand_call */);
324   }
325 
326   if (val == noreg) {
327     BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), noreg, noreg, noreg, noreg);
328   } else {
329     // G1 barrier needs uncompressed oop for region cross check.
330     Register new_val = val;
331     if (needs_post_barrier) {
332       if (UseCompressedOops) {
333         // FIXME: Refactor the code to avoid usage of r19 and stay within tmpX
334         new_val = r19;
335         __ mov(new_val, val);
336       }
337    }
338 
339    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg, noreg);
340 
341     if (needs_post_barrier) {
342        g1_write_barrier_post(masm,
343                           tmp1 /* store_adr */,
344                           new_val /* new_val */,
345                           rthread /* thread */,
346                           tmp2 /* tmp */,
347                           tmp3 /* tmp2 */);
348    }
349  }
350 
351 }
352 
353 #ifdef COMPILER1
354 
355 #undef __
356 #define __ ce-&gt;masm()-&gt;
357 
358 void G1BarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, G1PreBarrierStub* stub) {
359   G1BarrierSetC1* bs = (G1BarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
360   // At this point we know that marking is in progress.
361   // If do_load() is true then we have to emit the
362   // load of the previous value; otherwise it has already
363   // been loaded into _pre_val.
364 
365   __ bind(*stub-&gt;entry());
366 
367   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
368 
369   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
370 
371   if (stub-&gt;do_load()) {
372     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
373   }
374   __ cbz(pre_val_reg, *stub-&gt;continuation());
375   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
376   __ far_call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
377   __ b(*stub-&gt;continuation());
378 }
379 
380 void G1BarrierSetAssembler::gen_post_barrier_stub(LIR_Assembler* ce, G1PostBarrierStub* stub) {
381   G1BarrierSetC1* bs = (G1BarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
382   __ bind(*stub-&gt;entry());
383   assert(stub-&gt;addr()-&gt;is_register(), &quot;Precondition.&quot;);
384   assert(stub-&gt;new_val()-&gt;is_register(), &quot;Precondition.&quot;);
385   Register new_val_reg = stub-&gt;new_val()-&gt;as_register();
386   __ cbz(new_val_reg, *stub-&gt;continuation());
387   ce-&gt;store_parameter(stub-&gt;addr()-&gt;as_pointer_register(), 0);
388   __ far_call(RuntimeAddress(bs-&gt;post_barrier_c1_runtime_code_blob()-&gt;code_begin()));
389   __ b(*stub-&gt;continuation());
390 }
391 
392 #undef __
393 
394 #define __ sasm-&gt;
395 
396 void G1BarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
397   __ prologue(&quot;g1_pre_barrier&quot;, false);
398 
399   // arg0 : previous value of memory
400 
401   BarrierSet* bs = BarrierSet::barrier_set();
402 
403   const Register pre_val = r0;
404   const Register thread = rthread;
405   const Register tmp = rscratch1;
406 
407   Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));
408   Address queue_index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));
409   Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));
410 
411   Label done;
412   Label runtime;
413 
414   // Is marking still active?
415   if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {
416     __ ldrw(tmp, in_progress);
417   } else {
418     assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);
419     __ ldrb(tmp, in_progress);
420   }
421   __ cbzw(tmp, done);
422 
423   // Can we store original value in the thread&#39;s buffer?
424   __ ldr(tmp, queue_index);
425   __ cbz(tmp, runtime);
426 
427   __ sub(tmp, tmp, wordSize);
428   __ str(tmp, queue_index);
429   __ ldr(rscratch2, buffer);
430   __ add(tmp, tmp, rscratch2);
431   __ load_parameter(0, rscratch2);
432   __ str(rscratch2, Address(tmp, 0));
433   __ b(done);
434 
435   __ bind(runtime);
436   __ push_call_clobbered_registers();
437   __ load_parameter(0, pre_val);
438   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
439   __ pop_call_clobbered_registers();
440   __ bind(done);
441 
442   __ epilogue();
443 }
444 
445 void G1BarrierSetAssembler::generate_c1_post_barrier_runtime_stub(StubAssembler* sasm) {
446   __ prologue(&quot;g1_post_barrier&quot;, false);
447 
448   // arg0: store_address
449   Address store_addr(rfp, 2*BytesPerWord);
450 
451   BarrierSet* bs = BarrierSet::barrier_set();
452   CardTableBarrierSet* ctbs = barrier_set_cast&lt;CardTableBarrierSet&gt;(bs);
453   CardTable* ct = ctbs-&gt;card_table();
454 
455   Label done;
456   Label runtime;
457 
458   // At this point we know new_value is non-NULL and the new_value crosses regions.
459   // Must check to see if card is already dirty
460 
461   const Register thread = rthread;
462 
463   Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));
464   Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));
465 
466   const Register card_offset = rscratch2;
467   // LR is free here, so we can use it to hold the byte_map_base.
468   const Register byte_map_base = lr;
469 
470   assert_different_registers(card_offset, byte_map_base, rscratch1);
471 
472   __ load_parameter(0, card_offset);
473   __ lsr(card_offset, card_offset, CardTable::card_shift);
474   __ load_byte_map_base(byte_map_base);
475   __ ldrb(rscratch1, Address(byte_map_base, card_offset));
476   __ cmpw(rscratch1, (int)G1CardTable::g1_young_card_val());
477   __ br(Assembler::EQ, done);
478 
479   assert((int)CardTable::dirty_card_val() == 0, &quot;must be 0&quot;);
480 
481   __ membar(Assembler::StoreLoad);
482   __ ldrb(rscratch1, Address(byte_map_base, card_offset));
483   __ cbzw(rscratch1, done);
484 
485   // storing region crossing non-NULL, card is clean.
486   // dirty card and log.
487   __ strb(zr, Address(byte_map_base, card_offset));
488 
489   // Convert card offset into an address in card_addr
490   Register card_addr = card_offset;
491   __ add(card_addr, byte_map_base, card_addr);
492 
493   __ ldr(rscratch1, queue_index);
494   __ cbz(rscratch1, runtime);
495   __ sub(rscratch1, rscratch1, wordSize);
496   __ str(rscratch1, queue_index);
497 
498   // Reuse LR to hold buffer_addr
499   const Register buffer_addr = lr;
500 
501   __ ldr(buffer_addr, buffer);
502   __ str(card_addr, Address(buffer_addr, rscratch1));
503   __ b(done);
504 
505   __ bind(runtime);
506   __ push_call_clobbered_registers();
507   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);
508   __ pop_call_clobbered_registers();
509   __ bind(done);
510   __ epilogue();
511 }
512 
513 #undef __
514 
515 #endif // COMPILER1
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ppc/interp_masm_ppc_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;

  29 #include &quot;code/debugInfoRec.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/interp_masm.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;nativeInst_aarch64.hpp&quot;
  37 #include &quot;oops/compiledICHolder.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/vframeArray.hpp&quot;
  42 #include &quot;utilities/align.hpp&quot;
  43 #include &quot;vmreg_aarch64.inline.hpp&quot;
  44 #ifdef COMPILER1
  45 #include &quot;c1/c1_Runtime1.hpp&quot;
  46 #endif
  47 #ifdef COMPILER2
  48 #include &quot;adfiles/ad_aarch64.hpp&quot;
</pre>
<hr />
<pre>
 272     case T_SHORT:
 273     case T_INT:
 274       if (int_args &lt; Argument::n_int_register_parameters_j) {
 275         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 276       } else {
 277         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 278         stk_args += 2;
 279       }
 280       break;
 281     case T_VOID:
 282       // halves of T_LONG or T_DOUBLE
 283       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 284       regs[i].set_bad();
 285       break;
 286     case T_LONG:
 287       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 288       // fall through
 289     case T_OBJECT:
 290     case T_ARRAY:
 291     case T_ADDRESS:

 292       if (int_args &lt; Argument::n_int_register_parameters_j) {
 293         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 294       } else {
 295         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 296         stk_args += 2;
 297       }
 298       break;
 299     case T_FLOAT:
 300       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 301         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 302       } else {
 303         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 304         stk_args += 2;
 305       }
 306       break;
 307     case T_DOUBLE:
 308       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 309       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 310         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 311       } else {
 312         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 313         stk_args += 2;
 314       }
 315       break;
 316     default:
 317       ShouldNotReachHere();
 318       break;
 319     }
 320   }
 321 
 322   return align_up(stk_args, 2);
 323 }
 324 




















































































 325 // Patch the callers callsite with entry to compiled code if it exists.
 326 static void patch_callers_callsite(MacroAssembler *masm) {
 327   Label L;
 328   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 329   __ cbz(rscratch1, L);
 330 
 331   __ enter();
 332   __ push_CPU_state();
 333 
 334   // VM needs caller&#39;s callsite
 335   // VM needs target method
 336   // This needs to be a long call since we will relocate this adapter to
 337   // the codeBuffer and it may not reach
 338 
 339 #ifndef PRODUCT
 340   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 341 #endif
 342 
 343   __ mov(c_rarg0, rmethod);
 344   __ mov(c_rarg1, lr);
 345   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 346   __ blr(rscratch1);
 347   __ maybe_isb();
 348 
 349   __ pop_CPU_state();
 350   // restore sp
 351   __ leave();
 352   __ bind(L);
 353 }
 354 
<span class="line-modified"> 355 static void gen_c2i_adapter(MacroAssembler *masm,</span>
<span class="line-modified"> 356                             int total_args_passed,</span>
<span class="line-modified"> 357                             int comp_args_on_stack,</span>
<span class="line-modified"> 358                             const BasicType *sig_bt,</span>
<span class="line-modified"> 359                             const VMRegPair *regs,</span>
<span class="line-modified"> 360                             Label&amp; skip_fixup) {</span>
<span class="line-modified"> 361   // Before we get into the guts of the C2I adapter, see if we should be here</span>
<span class="line-modified"> 362   // at all.  We&#39;ve come from compiled code and are attempting to jump to the</span>
<span class="line-modified"> 363   // interpreter, which means the caller made a static call to get here</span>
<span class="line-modified"> 364   // (vcalls always get a compiled target if there is one).  Check for a</span>
<span class="line-modified"> 365   // compiled target.  If there is one, we need to patch the caller&#39;s call.</span>
<span class="line-modified"> 366   patch_callers_callsite(masm);</span>
<span class="line-modified"> 367 </span>
<span class="line-modified"> 368   __ bind(skip_fixup);</span>
<span class="line-modified"> 369 </span>
<span class="line-modified"> 370   int words_pushed = 0;</span>
<span class="line-modified"> 371 </span>
<span class="line-modified"> 372   // Since all args are passed on the stack, total_args_passed *</span>
<span class="line-modified"> 373   // Interpreter::stackElementSize is the space we need.</span>























 374 
<span class="line-modified"> 375   int extraspace = total_args_passed * Interpreter::stackElementSize;</span>

 376 
<span class="line-modified"> 377   __ mov(r13, sp);</span>
<span class="line-removed"> 378 </span>
<span class="line-removed"> 379   // stack is aligned, keep it that way</span>
 380   extraspace = align_up(extraspace, 2*wordSize);
 381 
<span class="line-modified"> 382   if (extraspace)</span>
<span class="line-removed"> 383     __ sub(sp, sp, extraspace);</span>
<span class="line-removed"> 384 </span>
<span class="line-removed"> 385   // Now write the args into the outgoing interpreter space</span>
<span class="line-removed"> 386   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="line-removed"> 387     if (sig_bt[i] == T_VOID) {</span>
<span class="line-removed"> 388       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);</span>
<span class="line-removed"> 389       continue;</span>
<span class="line-removed"> 390     }</span>
<span class="line-removed"> 391 </span>
<span class="line-removed"> 392     // offset to start parameters</span>
<span class="line-removed"> 393     int st_off   = (total_args_passed - i - 1) * Interpreter::stackElementSize;</span>
<span class="line-removed"> 394     int next_off = st_off - Interpreter::stackElementSize;</span>
 395 
 396     // Say 4 args:
 397     // i   st_off
 398     // 0   32 T_LONG
 399     // 1   24 T_VOID
 400     // 2   16 T_OBJECT
 401     // 3    8 T_BOOL
 402     // -    0 return address
 403     //
 404     // However to make thing extra confusing. Because we can fit a long/double in
 405     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 406     // leaves one slot empty and only stores to a single slot. In this case the
 407     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 408 
<span class="line-modified"> 409     VMReg r_1 = regs[i].first();</span>
<span class="line-modified"> 410     VMReg r_2 = regs[i].second();</span>



 411     if (!r_1-&gt;is_valid()) {
 412       assert(!r_2-&gt;is_valid(), &quot;&quot;);
<span class="line-modified"> 413       continue;</span>
 414     }

 415     if (r_1-&gt;is_stack()) {
 416       // memory to memory use rscratch1
<span class="line-modified"> 417       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size</span>
<span class="line-modified"> 418                     + extraspace</span>
<span class="line-removed"> 419                     + words_pushed * wordSize);</span>
 420       if (!r_2-&gt;is_valid()) {
 421         // sign extend??
 422         __ ldrw(rscratch1, Address(sp, ld_off));
<span class="line-modified"> 423         __ str(rscratch1, Address(sp, st_off));</span>
 424 
 425       } else {
<span class="line-modified"> 426 </span>
<span class="line-removed"> 427         __ ldr(rscratch1, Address(sp, ld_off));</span>
<span class="line-removed"> 428 </span>
<span class="line-removed"> 429         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG</span>
<span class="line-removed"> 430         // T_DOUBLE and T_LONG use two slots in the interpreter</span>
<span class="line-removed"> 431         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {</span>
<span class="line-removed"> 432           // ld_off == LSW, ld_off+wordSize == MSW</span>
<span class="line-removed"> 433           // st_off == MSW, next_off == LSW</span>
<span class="line-removed"> 434           __ str(rscratch1, Address(sp, next_off));</span>
<span class="line-removed"> 435 #ifdef ASSERT</span>
<span class="line-removed"> 436           // Overwrite the unused slot with known junk</span>
<span class="line-removed"> 437           __ mov(rscratch1, 0xdeadffffdeadaaaaul);</span>
<span class="line-removed"> 438           __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-removed"> 439 #endif /* ASSERT */</span>
<span class="line-removed"> 440         } else {</span>
<span class="line-removed"> 441           __ str(rscratch1, Address(sp, st_off));</span>
 442         }
 443       }
 444     } else if (r_1-&gt;is_Register()) {
 445       Register r = r_1-&gt;as_Register();
<span class="line-modified"> 446       if (!r_2-&gt;is_valid()) {</span>
<span class="line-removed"> 447         // must be only an int (or less ) so move only 32bits to slot</span>
<span class="line-removed"> 448         // why not sign extend??</span>
<span class="line-removed"> 449         __ str(r, Address(sp, st_off));</span>
<span class="line-removed"> 450       } else {</span>
<span class="line-removed"> 451         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG</span>
<span class="line-removed"> 452         // T_DOUBLE and T_LONG use two slots in the interpreter</span>
<span class="line-removed"> 453         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {</span>
<span class="line-removed"> 454           // long/double in gpr</span>
<span class="line-removed"> 455 #ifdef ASSERT</span>
<span class="line-removed"> 456           // Overwrite the unused slot with known junk</span>
<span class="line-removed"> 457           __ mov(rscratch1, 0xdeadffffdeadaaabul);</span>
<span class="line-removed"> 458           __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-removed"> 459 #endif /* ASSERT */</span>
<span class="line-removed"> 460           __ str(r, Address(sp, next_off));</span>
<span class="line-removed"> 461         } else {</span>
<span class="line-removed"> 462           __ str(r, Address(sp, st_off));</span>
<span class="line-removed"> 463         }</span>
<span class="line-removed"> 464       }</span>
 465     } else {
 466       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 467       if (!r_2-&gt;is_valid()) {
 468         // only a float use just part of the slot
<span class="line-modified"> 469         __ strs(r_1-&gt;as_FloatRegister(), Address(sp, st_off));</span>
 470       } else {
<span class="line-modified"> 471 #ifdef ASSERT</span>
<span class="line-removed"> 472         // Overwrite the unused slot with known junk</span>
<span class="line-removed"> 473         __ mov(rscratch1, 0xdeadffffdeadaaacul);</span>
<span class="line-removed"> 474         __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-removed"> 475 #endif /* ASSERT */</span>
<span class="line-removed"> 476         __ strd(r_1-&gt;as_FloatRegister(), Address(sp, next_off));</span>
 477       }





































































































































































 478     }


 479   }
 480 
 481   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 482 
 483   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 484   __ br(rscratch1);
 485 }
 486 

 487 
<span class="line-removed"> 488 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,</span>
<span class="line-removed"> 489                                     int total_args_passed,</span>
<span class="line-removed"> 490                                     int comp_args_on_stack,</span>
<span class="line-removed"> 491                                     const BasicType *sig_bt,</span>
<span class="line-removed"> 492                                     const VMRegPair *regs) {</span>
 493 
 494   // Note: r13 contains the senderSP on entry. We must preserve it since
 495   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 496   // code goes non-entrant while we get args ready.
 497 
 498   // In addition we use r13 to locate all the interpreter args because
 499   // we must align the stack to 16 bytes.
 500 
 501   // Adapters are frameless.
 502 
 503   // An i2c adapter is frameless because the *caller* frame, which is
 504   // interpreted, routinely repairs its own esp (from
 505   // interpreter_frame_last_sp), even if a callee has modified the
 506   // stack pointer.  It also recalculates and aligns sp.
 507 
 508   // A c2i adapter is frameless because the *callee* frame, which is
 509   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 510   // which is set up via the senderSP register).
 511 
 512   // In other words, if *either* the caller or callee is interpreted, we can
</pre>
<hr />
<pre>
 532       range_check(masm, rax, r11,
 533                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 534                   L_ok);
 535     if (StubRoutines::code1() != NULL)
 536       range_check(masm, rax, r11,
 537                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 538                   L_ok);
 539     if (StubRoutines::code2() != NULL)
 540       range_check(masm, rax, r11,
 541                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 542                   L_ok);
 543     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 544     __ block_comment(msg);
 545     __ stop(msg);
 546     __ bind(L_ok);
 547     __ block_comment(&quot;} verify_i2ce &quot;);
 548 #endif
 549   }
 550 
 551   // Cut-out for having no stack args.
<span class="line-modified"> 552   int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;</span>
 553   if (comp_args_on_stack) {
<span class="line-modified"> 554     __ sub(rscratch1, sp, comp_words_on_stack * wordSize);</span>
<span class="line-modified"> 555     __ andr(sp, rscratch1, -16);</span>

 556   }
 557 
 558   // Will jump to the compiled code just as if compiled code was doing it.
 559   // Pre-load the register-jump target early, to schedule it better.
 560   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 561 
 562 #if INCLUDE_JVMCI
 563   if (EnableJVMCI || UseAOT) {
 564     // check if this call should be routed towards a specific entry point
 565     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 566     Label no_alternative_target;
 567     __ cbz(rscratch2, no_alternative_target);
 568     __ mov(rscratch1, rscratch2);
 569     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 570     __ bind(no_alternative_target);
 571   }
 572 #endif // INCLUDE_JVMCI
 573 


 574   // Now generate the shuffle code.
 575   for (int i = 0; i &lt; total_args_passed; i++) {
<span class="line-modified"> 576     if (sig_bt[i] == T_VOID) {</span>
<span class="line-modified"> 577       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);</span>



 578       continue;
 579     }
 580 
 581     // Pick up 0, 1 or 2 words from SP+offset.

 582 
<span class="line-modified"> 583     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),</span>
<span class="line-removed"> 584             &quot;scrambled load targets?&quot;);</span>
<span class="line-removed"> 585     // Load in argument order going down.</span>
 586     int ld_off = (total_args_passed - i - 1)*Interpreter::stackElementSize;
 587     // Point to interpreter value (vs. tag)
 588     int next_off = ld_off - Interpreter::stackElementSize;
 589     //
 590     //
 591     //
 592     VMReg r_1 = regs[i].first();
 593     VMReg r_2 = regs[i].second();
 594     if (!r_1-&gt;is_valid()) {
 595       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 596       continue;
 597     }
 598     if (r_1-&gt;is_stack()) {
 599       // Convert stack slot to an SP offset (+ wordSize to account for return address )
<span class="line-modified"> 600       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size;</span>
 601       if (!r_2-&gt;is_valid()) {
 602         // sign extend???
 603         __ ldrsw(rscratch2, Address(esp, ld_off));
 604         __ str(rscratch2, Address(sp, st_off));
 605       } else {
 606         //
 607         // We are using two optoregs. This can be either T_OBJECT,
 608         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 609         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 610         // So we must adjust where to pick up the data to match the
 611         // interpreter.
 612         //
 613         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 614         // are accessed as negative so LSW is at LOW address
 615 
 616         // ld_off is MSW so get LSW
<span class="line-modified"> 617         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?</span>
<span class="line-removed"> 618                            next_off : ld_off;</span>
 619         __ ldr(rscratch2, Address(esp, offset));
 620         // st_off is LSW (i.e. reg.first())
<span class="line-modified"> 621         __ str(rscratch2, Address(sp, st_off));</span>
<span class="line-modified"> 622       }</span>
<span class="line-modified"> 623     } else if (r_1-&gt;is_Register()) {  // Register argument</span>
<span class="line-modified"> 624       Register r = r_1-&gt;as_Register();</span>
<span class="line-modified"> 625       if (r_2-&gt;is_valid()) {</span>
<span class="line-modified"> 626         //</span>
<span class="line-modified"> 627         // We are using two VMRegs. This can be either T_OBJECT,</span>
<span class="line-modified"> 628         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates</span>
<span class="line-modified"> 629         // two slots but only uses one for thr T_LONG or T_DOUBLE case</span>
<span class="line-modified"> 630         // So we must adjust where to pick up the data to match the</span>
<span class="line-modified"> 631         // interpreter.</span>

















 632 
<span class="line-removed"> 633         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?</span>
<span class="line-removed"> 634                            next_off : ld_off;</span>
<span class="line-removed"> 635 </span>
<span class="line-removed"> 636         // this can be a misaligned move</span>
<span class="line-removed"> 637         __ ldr(r, Address(esp, offset));</span>
<span class="line-removed"> 638       } else {</span>
<span class="line-removed"> 639         // sign extend and use a full word?</span>
<span class="line-removed"> 640         __ ldrw(r, Address(esp, ld_off));</span>
<span class="line-removed"> 641       }</span>
<span class="line-removed"> 642     } else {</span>
<span class="line-removed"> 643       if (!r_2-&gt;is_valid()) {</span>
<span class="line-removed"> 644         __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));</span>
<span class="line-removed"> 645       } else {</span>
<span class="line-removed"> 646         __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));</span>
<span class="line-removed"> 647       }</span>
<span class="line-removed"> 648     }</span>
<span class="line-removed"> 649   }</span>
 650 
 651   // 6243940 We might end up in handle_wrong_method if
 652   // the callee is deoptimized as we race thru here. If that
 653   // happens we don&#39;t want to take a safepoint because the
 654   // caller frame will look interpreted and arguments are now
 655   // &quot;compiled&quot; so it is much better to make this transition
 656   // invisible to the stack walking code. Unfortunately if
 657   // we try and find the callee by normal means a safepoint
 658   // is possible. So we stash the desired callee in the thread
 659   // and the vm will find there should this case occur.
 660 
 661   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
<span class="line-removed"> 662 </span>
 663   __ br(rscratch1);
 664 }
 665 
<span class="line-modified"> 666 // ---------------------------------------------------------------</span>
<span class="line-removed"> 667 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="line-removed"> 668                                                             int total_args_passed,</span>
<span class="line-removed"> 669                                                             int comp_args_on_stack,</span>
<span class="line-removed"> 670                                                             const BasicType *sig_bt,</span>
<span class="line-removed"> 671                                                             const VMRegPair *regs,</span>
<span class="line-removed"> 672                                                             AdapterFingerPrint* fingerprint) {</span>
<span class="line-removed"> 673   address i2c_entry = __ pc();</span>
<span class="line-removed"> 674 </span>
<span class="line-removed"> 675   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);</span>
<span class="line-removed"> 676 </span>
<span class="line-removed"> 677   address c2i_unverified_entry = __ pc();</span>
<span class="line-removed"> 678   Label skip_fixup;</span>
 679 
 680   Label ok;
 681 
 682   Register holder = rscratch2;
 683   Register receiver = j_rarg0;
 684   Register tmp = r10;  // A call-clobbered register not used for arg passing
 685 
 686   // -------------------------------------------------------------------------
 687   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 688   // to the interpreter.  The args start out packed in the compiled layout.  They
 689   // need to be unpacked into the interpreter layout.  This will almost always
 690   // require some stack space.  We grow the current (compiled) stack, then repack
 691   // the args.  We  finally end in a jump to the generic interpreter entry point.
 692   // On exit from the interpreter, the interpreter will restore our SP (lest the
 693   // compiled code, which relys solely on SP and not FP, get sick).
 694 
 695   {
 696     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 697     __ load_klass(rscratch1, receiver);
 698     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 699     __ cmp(rscratch1, tmp);
 700     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 701     __ br(Assembler::EQ, ok);
 702     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 703 
 704     __ bind(ok);
 705     // Method might have been compiled since the call site was patched to
 706     // interpreted; if that is the case treat it as a miss so we can get
 707     // the call site corrected.
 708     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 709     __ cbz(rscratch1, skip_fixup);
 710     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 711     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 712   }


































 713 

 714   address c2i_entry = __ pc();
 715 
 716   // Class initialization barrier for static methods
 717   address c2i_no_clinit_check_entry = NULL;

 718   if (VM_Version::supports_fast_class_init_checks()) {
 719     Label L_skip_barrier;
<span class="line-modified"> 720 </span>
<span class="line-modified"> 721     { // Bypass the barrier for non-static methods</span>
<span class="line-modified"> 722       __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));</span>
<span class="line-modified"> 723       __ andsw(zr, rscratch1, JVM_ACC_STATIC);</span>
 724       __ br(Assembler::EQ, L_skip_barrier); // non-static
 725     }
 726 
<span class="line-modified"> 727     __ load_method_holder(rscratch2, rmethod);</span>
<span class="line-modified"> 728     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-modified"> 729     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>



 730 
 731     __ bind(L_skip_barrier);
 732     c2i_no_clinit_check_entry = __ pc();
 733   }
 734 
<span class="line-modified"> 735   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);</span>


















 736 
 737   __ flush();
<span class="line-modified"> 738   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>







 739 }
 740 
 741 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 742                                          VMRegPair *regs,
 743                                          VMRegPair *regs2,
 744                                          int total_args_passed) {
 745   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
 746 
 747 // We return the amount of VMRegImpl stack slots we need to reserve for all
 748 // the arguments NOT counting out_preserve_stack_slots.
 749 
 750     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 751       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
 752     };
 753     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
 754       c_farg0, c_farg1, c_farg2, c_farg3,
 755       c_farg4, c_farg5, c_farg6, c_farg7
 756     };
 757 
 758     uint int_args = 0;
</pre>
<hr />
<pre>
 761 
 762     for (int i = 0; i &lt; total_args_passed; i++) {
 763       switch (sig_bt[i]) {
 764       case T_BOOLEAN:
 765       case T_CHAR:
 766       case T_BYTE:
 767       case T_SHORT:
 768       case T_INT:
 769         if (int_args &lt; Argument::n_int_register_parameters_c) {
 770           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 771         } else {
 772           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 773           stk_args += 2;
 774         }
 775         break;
 776       case T_LONG:
 777         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 778         // fall through
 779       case T_OBJECT:
 780       case T_ARRAY:

 781       case T_ADDRESS:
 782       case T_METADATA:
 783         if (int_args &lt; Argument::n_int_register_parameters_c) {
 784           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 785         } else {
 786           regs[i].set2(VMRegImpl::stack2reg(stk_args));
 787           stk_args += 2;
 788         }
 789         break;
 790       case T_FLOAT:
 791         if (fp_args &lt; Argument::n_float_register_parameters_c) {
 792           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 793         } else {
 794           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 795           stk_args += 2;
 796         }
 797         break;
 798       case T_DOUBLE:
 799         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 800         if (fp_args &lt; Argument::n_float_register_parameters_c) {
</pre>
<hr />
<pre>
1611       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1612     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1613       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1614     }
1615 #endif /* ASSERT */
1616     switch (in_sig_bt[i]) {
1617       case T_ARRAY:
1618         if (is_critical_native) {
1619           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1620           c_arg++;
1621 #ifdef ASSERT
1622           if (out_regs[c_arg].first()-&gt;is_Register()) {
1623             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1624           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1625             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1626           }
1627 #endif
1628           int_args++;
1629           break;
1630         }

1631       case T_OBJECT:
1632         assert(!is_critical_native, &quot;no oop arguments&quot;);
1633         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1634                     ((i == 0) &amp;&amp; (!is_static)),
1635                     &amp;receiver_offset);
1636         int_args++;
1637         break;
1638       case T_VOID:
1639         break;
1640 
1641       case T_FLOAT:
1642         float_move(masm, in_regs[i], out_regs[c_arg]);
1643         float_args++;
1644         break;
1645 
1646       case T_DOUBLE:
1647         assert( i + 1 &lt; total_in_args &amp;&amp;
1648                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1649                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1650         double_move(masm, in_regs[i], out_regs[c_arg]);
</pre>
<hr />
<pre>
1792   }
1793 
1794   // Now set thread in native
1795   __ mov(rscratch1, _thread_in_native);
1796   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1797   __ stlrw(rscratch1, rscratch2);
1798 
1799   {
1800     int return_type = 0;
1801     switch (ret_type) {
1802     case T_VOID: break;
1803       return_type = 0; break;
1804     case T_CHAR:
1805     case T_BYTE:
1806     case T_SHORT:
1807     case T_INT:
1808     case T_BOOLEAN:
1809     case T_LONG:
1810       return_type = 1; break;
1811     case T_ARRAY:

1812     case T_OBJECT:
1813       return_type = 1; break;
1814     case T_FLOAT:
1815       return_type = 2; break;
1816     case T_DOUBLE:
1817       return_type = 3; break;
1818     default:
1819       ShouldNotReachHere();
1820     }
1821     rt_call(masm, native_func,
1822             int_args + 2, // AArch64 passes up to 8 args in int registers
1823             float_args,   // and up to 8 float args
1824             return_type);
1825   }
1826 
1827   __ bind(native_return);
1828 
1829   intptr_t return_pc = (intptr_t) __ pc();
1830   oop_maps-&gt;add_gc_map(return_pc - start, map);
1831 
1832   // Unpack native results.
1833   switch (ret_type) {
1834   case T_BOOLEAN: __ c2bool(r0);                     break;
1835   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
1836   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
1837   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
1838   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
1839   case T_DOUBLE :
1840   case T_FLOAT  :
1841     // Result is in v0 we&#39;ll save as needed
1842     break;
1843   case T_ARRAY:                 // Really a handle

1844   case T_OBJECT:                // Really a handle
1845       break; // can&#39;t de-handlize until after safepoint check
1846   case T_VOID: break;
1847   case T_LONG: break;
1848   default       : ShouldNotReachHere();
1849   }
1850 
1851   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
1852   // This additional state is necessary because reading and testing the synchronization
1853   // state is not atomic w.r.t. GC, as this scenario demonstrates:
1854   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
1855   //     VM thread changes sync state to synchronizing and suspends threads for GC.
1856   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
1857   //     didn&#39;t see any synchronization is progress, and escapes.
1858   __ mov(rscratch1, _thread_in_native_trans);
1859 
1860   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
1861 
1862   // Force this write out before the read below
1863   __ dmb(Assembler::ISH);
</pre>
<hr />
<pre>
3049 #ifdef ASSERT
3050   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3051   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3052 #endif
3053   // Clear the exception oop so GC no longer processes it as a root.
3054   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3055 
3056   // r0: exception oop
3057   // r8:  exception handler
3058   // r4: exception pc
3059   // Jump to handler
3060 
3061   __ br(r8);
3062 
3063   // Make sure all code is generated
3064   masm-&gt;flush();
3065 
3066   // Set exception blob
3067   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3068 }









































































































3069 #endif // COMPILER2
</pre>
</td>
<td>
<hr />
<pre>
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
<span class="line-added">  29 #include &quot;classfile/symbolTable.hpp&quot;</span>
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;code/icBuffer.hpp&quot;
  32 #include &quot;code/vtableStubs.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;interpreter/interp_masm.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;nativeInst_aarch64.hpp&quot;
  38 #include &quot;oops/compiledICHolder.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/vframeArray.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
  44 #include &quot;vmreg_aarch64.inline.hpp&quot;
  45 #ifdef COMPILER1
  46 #include &quot;c1/c1_Runtime1.hpp&quot;
  47 #endif
  48 #ifdef COMPILER2
  49 #include &quot;adfiles/ad_aarch64.hpp&quot;
</pre>
<hr />
<pre>
 273     case T_SHORT:
 274     case T_INT:
 275       if (int_args &lt; Argument::n_int_register_parameters_j) {
 276         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 277       } else {
 278         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 279         stk_args += 2;
 280       }
 281       break;
 282     case T_VOID:
 283       // halves of T_LONG or T_DOUBLE
 284       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 285       regs[i].set_bad();
 286       break;
 287     case T_LONG:
 288       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 289       // fall through
 290     case T_OBJECT:
 291     case T_ARRAY:
 292     case T_ADDRESS:
<span class="line-added"> 293     case T_VALUETYPE:</span>
 294       if (int_args &lt; Argument::n_int_register_parameters_j) {
 295         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 296       } else {
 297         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 298         stk_args += 2;
 299       }
 300       break;
 301     case T_FLOAT:
 302       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 303         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 304       } else {
 305         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 306         stk_args += 2;
 307       }
 308       break;
 309     case T_DOUBLE:
 310       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 311       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 312         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 313       } else {
 314         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 315         stk_args += 2;
 316       }
 317       break;
 318     default:
 319       ShouldNotReachHere();
 320       break;
 321     }
 322   }
 323 
 324   return align_up(stk_args, 2);
 325 }
 326 
<span class="line-added"> 327 </span>
<span class="line-added"> 328 // const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j+1;</span>
<span class="line-added"> 329 const uint SharedRuntime::java_return_convention_max_int = 6;</span>
<span class="line-added"> 330 const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;</span>
<span class="line-added"> 331 </span>
<span class="line-added"> 332 int SharedRuntime::java_return_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed) {</span>
<span class="line-added"> 333 </span>
<span class="line-added"> 334   // Create the mapping between argument positions and</span>
<span class="line-added"> 335   // registers.</span>
<span class="line-added"> 336   // r1, r2 used to address klasses and states, exclude it from return convention to avoid colision</span>
<span class="line-added"> 337 </span>
<span class="line-added"> 338   static const Register INT_ArgReg[java_return_convention_max_int] = {</span>
<span class="line-added"> 339      r0 /* j_rarg7 */, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2</span>
<span class="line-added"> 340   };</span>
<span class="line-added"> 341 </span>
<span class="line-added"> 342   static const FloatRegister FP_ArgReg[java_return_convention_max_float] = {</span>
<span class="line-added"> 343     j_farg0, j_farg1, j_farg2, j_farg3, j_farg4, j_farg5, j_farg6, j_farg7</span>
<span class="line-added"> 344   };</span>
<span class="line-added"> 345 </span>
<span class="line-added"> 346   uint int_args = 0;</span>
<span class="line-added"> 347   uint fp_args = 0;</span>
<span class="line-added"> 348 </span>
<span class="line-added"> 349   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="line-added"> 350     switch (sig_bt[i]) {</span>
<span class="line-added"> 351     case T_BOOLEAN:</span>
<span class="line-added"> 352     case T_CHAR:</span>
<span class="line-added"> 353     case T_BYTE:</span>
<span class="line-added"> 354     case T_SHORT:</span>
<span class="line-added"> 355     case T_INT:</span>
<span class="line-added"> 356       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {</span>
<span class="line-added"> 357         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());</span>
<span class="line-added"> 358         int_args ++;</span>
<span class="line-added"> 359       } else {</span>
<span class="line-added"> 360         // Should we have gurantee here?</span>
<span class="line-added"> 361         return -1;</span>
<span class="line-added"> 362       }</span>
<span class="line-added"> 363       break;</span>
<span class="line-added"> 364     case T_VOID:</span>
<span class="line-added"> 365       // halves of T_LONG or T_DOUBLE</span>
<span class="line-added"> 366       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);</span>
<span class="line-added"> 367       regs[i].set_bad();</span>
<span class="line-added"> 368       break;</span>
<span class="line-added"> 369     case T_LONG:</span>
<span class="line-added"> 370       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);</span>
<span class="line-added"> 371       // fall through</span>
<span class="line-added"> 372     case T_OBJECT:</span>
<span class="line-added"> 373     case T_ARRAY:</span>
<span class="line-added"> 374     case T_ADDRESS:</span>
<span class="line-added"> 375       // Should T_METADATA be added to java_calling_convention as well ?</span>
<span class="line-added"> 376     case T_METADATA:</span>
<span class="line-added"> 377     case T_VALUETYPE:</span>
<span class="line-added"> 378       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {</span>
<span class="line-added"> 379         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());</span>
<span class="line-added"> 380         int_args ++;</span>
<span class="line-added"> 381       } else {</span>
<span class="line-added"> 382         return -1;</span>
<span class="line-added"> 383       }</span>
<span class="line-added"> 384       break;</span>
<span class="line-added"> 385     case T_FLOAT:</span>
<span class="line-added"> 386       if (fp_args &lt; SharedRuntime::java_return_convention_max_float) {</span>
<span class="line-added"> 387         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());</span>
<span class="line-added"> 388         fp_args ++;</span>
<span class="line-added"> 389       } else {</span>
<span class="line-added"> 390         return -1;</span>
<span class="line-added"> 391       }</span>
<span class="line-added"> 392       break;</span>
<span class="line-added"> 393     case T_DOUBLE:</span>
<span class="line-added"> 394       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);</span>
<span class="line-added"> 395       if (fp_args &lt; Argument::n_float_register_parameters_j) {</span>
<span class="line-added"> 396         regs[i].set2(FP_ArgReg[fp_args]-&gt;as_VMReg());</span>
<span class="line-added"> 397         fp_args ++;</span>
<span class="line-added"> 398       } else {</span>
<span class="line-added"> 399         return -1;</span>
<span class="line-added"> 400       }</span>
<span class="line-added"> 401       break;</span>
<span class="line-added"> 402     default:</span>
<span class="line-added"> 403       ShouldNotReachHere();</span>
<span class="line-added"> 404       break;</span>
<span class="line-added"> 405     }</span>
<span class="line-added"> 406   }</span>
<span class="line-added"> 407 </span>
<span class="line-added"> 408   return int_args + fp_args;</span>
<span class="line-added"> 409 }</span>
<span class="line-added"> 410 </span>
 411 // Patch the callers callsite with entry to compiled code if it exists.
 412 static void patch_callers_callsite(MacroAssembler *masm) {
 413   Label L;
 414   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 415   __ cbz(rscratch1, L);
 416 
 417   __ enter();
 418   __ push_CPU_state();
 419 
 420   // VM needs caller&#39;s callsite
 421   // VM needs target method
 422   // This needs to be a long call since we will relocate this adapter to
 423   // the codeBuffer and it may not reach
 424 
 425 #ifndef PRODUCT
 426   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 427 #endif
 428 
 429   __ mov(c_rarg0, rmethod);
 430   __ mov(c_rarg1, lr);
 431   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 432   __ blr(rscratch1);
 433   __ maybe_isb();
 434 
 435   __ pop_CPU_state();
 436   // restore sp
 437   __ leave();
 438   __ bind(L);
 439 }
 440 
<span class="line-modified"> 441 // For each value type argument, sig includes the list of fields of</span>
<span class="line-modified"> 442 // the value type. This utility function computes the number of</span>
<span class="line-modified"> 443 // arguments for the call if value types are passed by reference (the</span>
<span class="line-modified"> 444 // calling convention the interpreter expects).</span>
<span class="line-modified"> 445 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {</span>
<span class="line-modified"> 446   int total_args_passed = 0;</span>
<span class="line-modified"> 447   if (ValueTypePassFieldsAsArgs) {</span>
<span class="line-modified"> 448      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {</span>
<span class="line-modified"> 449        BasicType bt = sig_extended-&gt;at(i)._bt;</span>
<span class="line-modified"> 450        if (SigEntry::is_reserved_entry(sig_extended, i)) {</span>
<span class="line-modified"> 451          // Ignore reserved entry</span>
<span class="line-modified"> 452        } else if (bt == T_VALUETYPE) {</span>
<span class="line-modified"> 453          // In sig_extended, a value type argument starts with:</span>
<span class="line-modified"> 454          // T_VALUETYPE, followed by the types of the fields of the</span>
<span class="line-modified"> 455          // value type and T_VOID to mark the end of the value</span>
<span class="line-modified"> 456          // type. Value types are flattened so, for instance, in the</span>
<span class="line-modified"> 457          // case of a value type with an int field and a value type</span>
<span class="line-modified"> 458          // field that itself has 2 fields, an int and a long:</span>
<span class="line-modified"> 459          // T_VALUETYPE T_INT T_VALUETYPE T_INT T_LONG T_VOID (second</span>
<span class="line-added"> 460          // slot for the T_LONG) T_VOID (inner T_VALUETYPE) T_VOID</span>
<span class="line-added"> 461          // (outer T_VALUETYPE)</span>
<span class="line-added"> 462          total_args_passed++;</span>
<span class="line-added"> 463          int vt = 1;</span>
<span class="line-added"> 464          do {</span>
<span class="line-added"> 465            i++;</span>
<span class="line-added"> 466            BasicType bt = sig_extended-&gt;at(i)._bt;</span>
<span class="line-added"> 467            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;</span>
<span class="line-added"> 468            if (bt == T_VALUETYPE) {</span>
<span class="line-added"> 469              vt++;</span>
<span class="line-added"> 470            } else if (bt == T_VOID &amp;&amp;</span>
<span class="line-added"> 471                       prev_bt != T_LONG &amp;&amp;</span>
<span class="line-added"> 472                       prev_bt != T_DOUBLE) {</span>
<span class="line-added"> 473              vt--;</span>
<span class="line-added"> 474            }</span>
<span class="line-added"> 475          } while (vt != 0);</span>
<span class="line-added"> 476        } else {</span>
<span class="line-added"> 477          total_args_passed++;</span>
<span class="line-added"> 478        }</span>
<span class="line-added"> 479      }</span>
<span class="line-added"> 480   } else {</span>
<span class="line-added"> 481     total_args_passed = sig_extended-&gt;length();</span>
<span class="line-added"> 482   }</span>
 483 
<span class="line-modified"> 484   return total_args_passed;</span>
<span class="line-added"> 485 }</span>
 486 
<span class="line-modified"> 487 </span>


 488 static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair&amp; reg_pair, int extraspace, const Address&amp; to) {
 489 
<span class="line-modified"> 490     assert(bt != T_VALUETYPE || !ValueTypePassFieldsAsArgs, &quot;no value type here&quot;);</span>












 491 
 492     // Say 4 args:
 493     // i   st_off
 494     // 0   32 T_LONG
 495     // 1   24 T_VOID
 496     // 2   16 T_OBJECT
 497     // 3    8 T_BOOL
 498     // -    0 return address
 499     //
 500     // However to make thing extra confusing. Because we can fit a long/double in
 501     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 502     // leaves one slot empty and only stores to a single slot. In this case the
 503     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 504 
<span class="line-modified"> 505     // int next_off = st_off - Interpreter::stackElementSize;</span>
<span class="line-modified"> 506 </span>
<span class="line-added"> 507     VMReg r_1 = reg_pair.first();</span>
<span class="line-added"> 508     VMReg r_2 = reg_pair.second();</span>
<span class="line-added"> 509 </span>
 510     if (!r_1-&gt;is_valid()) {
 511       assert(!r_2-&gt;is_valid(), &quot;&quot;);
<span class="line-modified"> 512       return;</span>
 513     }
<span class="line-added"> 514 </span>
 515     if (r_1-&gt;is_stack()) {
 516       // memory to memory use rscratch1
<span class="line-modified"> 517       // words_pushed is always 0 so we don&#39;t use it.</span>
<span class="line-modified"> 518       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace /* + word_pushed * wordSize */);</span>

 519       if (!r_2-&gt;is_valid()) {
 520         // sign extend??
 521         __ ldrw(rscratch1, Address(sp, ld_off));
<span class="line-modified"> 522         __ str(rscratch1, to);</span>
 523 
 524       } else {
<span class="line-modified"> 525         __ ldr(rscratch1, Address(sp, ld_off));</span>















 526         __ str(rscratch1, to);
 527       }
 528     } else if (r_1-&gt;is_Register()) {
 529       Register r = r_1-&gt;as_Register();
<span class="line-modified"> 530       __ str(r, to);</span>


















 531     } else {
 532       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 533       if (!r_2-&gt;is_valid()) {
 534         // only a float use just part of the slot
<span class="line-modified"> 535         __ strs(r_1-&gt;as_FloatRegister(), to);</span>
 536       } else {
<span class="line-modified"> 537         __ strd(r_1-&gt;as_FloatRegister(), to);</span>





 538       }
<span class="line-added"> 539    }</span>
<span class="line-added"> 540 }</span>
<span class="line-added"> 541 </span>
<span class="line-added"> 542 static void gen_c2i_adapter(MacroAssembler *masm,</span>
<span class="line-added"> 543                             const GrowableArray&lt;SigEntry&gt;* sig_extended,</span>
<span class="line-added"> 544                             const VMRegPair *regs,</span>
<span class="line-added"> 545                             Label&amp; skip_fixup,</span>
<span class="line-added"> 546                             address start,</span>
<span class="line-added"> 547                             OopMapSet* oop_maps,</span>
<span class="line-added"> 548                             int&amp; frame_complete,</span>
<span class="line-added"> 549                             int&amp; frame_size_in_words,</span>
<span class="line-added"> 550                             bool alloc_value_receiver) {</span>
<span class="line-added"> 551 </span>
<span class="line-added"> 552   // Before we get into the guts of the C2I adapter, see if we should be here</span>
<span class="line-added"> 553   // at all.  We&#39;ve come from compiled code and are attempting to jump to the</span>
<span class="line-added"> 554   // interpreter, which means the caller made a static call to get here</span>
<span class="line-added"> 555   // (vcalls always get a compiled target if there is one).  Check for a</span>
<span class="line-added"> 556   // compiled target.  If there is one, we need to patch the caller&#39;s call.</span>
<span class="line-added"> 557   patch_callers_callsite(masm);</span>
<span class="line-added"> 558 </span>
<span class="line-added"> 559   __ bind(skip_fixup);</span>
<span class="line-added"> 560 </span>
<span class="line-added"> 561   bool has_value_argument = false;</span>
<span class="line-added"> 562 </span>
<span class="line-added"> 563   if (ValueTypePassFieldsAsArgs) {</span>
<span class="line-added"> 564       // Is there a value type argument?</span>
<span class="line-added"> 565      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {</span>
<span class="line-added"> 566        has_value_argument = (sig_extended-&gt;at(i)._bt == T_VALUETYPE);</span>
<span class="line-added"> 567      }</span>
<span class="line-added"> 568      if (has_value_argument) {</span>
<span class="line-added"> 569       // There is at least a value type argument: we&#39;re coming from</span>
<span class="line-added"> 570       // compiled code so we have no buffers to back the value</span>
<span class="line-added"> 571       // types. Allocate the buffers here with a runtime call.</span>
<span class="line-added"> 572       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);</span>
<span class="line-added"> 573 </span>
<span class="line-added"> 574       frame_complete = __ offset();</span>
<span class="line-added"> 575       address the_pc = __ pc();</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);</span>
<span class="line-added"> 578 </span>
<span class="line-added"> 579       __ mov(c_rarg0, rthread);</span>
<span class="line-added"> 580       __ mov(c_rarg1, r1);</span>
<span class="line-added"> 581       __ mov(c_rarg2, (int64_t)alloc_value_receiver);</span>
<span class="line-added"> 582 </span>
<span class="line-added"> 583       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_value_types)));</span>
<span class="line-added"> 584       __ blr(rscratch1);</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);</span>
<span class="line-added"> 587       __ reset_last_Java_frame(false);</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589       RegisterSaver::restore_live_registers(masm);</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591       Label no_exception;</span>
<span class="line-added"> 592       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));</span>
<span class="line-added"> 593       __ cbz(r0, no_exception);</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595       __ str(zr, Address(rthread, JavaThread::vm_result_offset()));</span>
<span class="line-added"> 596       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));</span>
<span class="line-added"> 597       __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));</span>
<span class="line-added"> 598 </span>
<span class="line-added"> 599       __ bind(no_exception);</span>
<span class="line-added"> 600 </span>
<span class="line-added"> 601       // We get an array of objects from the runtime call</span>
<span class="line-added"> 602       __ get_vm_result(r10, rthread);</span>
<span class="line-added"> 603       __ get_vm_result_2(r1, rthread); // TODO: required to keep the callee Method live?</span>
<span class="line-added"> 604     }</span>
<span class="line-added"> 605   }</span>
<span class="line-added"> 606 </span>
<span class="line-added"> 607   int words_pushed = 0;</span>
<span class="line-added"> 608 </span>
<span class="line-added"> 609   // Since all args are passed on the stack, total_args_passed *</span>
<span class="line-added"> 610   // Interpreter::stackElementSize is the space we need.</span>
<span class="line-added"> 611 </span>
<span class="line-added"> 612   int total_args_passed = compute_total_args_passed_int(sig_extended);</span>
<span class="line-added"> 613   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;</span>
<span class="line-added"> 614 </span>
<span class="line-added"> 615   // stack is aligned, keep it that way</span>
<span class="line-added"> 616   extraspace = align_up(extraspace, 2 * wordSize);</span>
<span class="line-added"> 617 </span>
<span class="line-added"> 618   __ mov(r13, sp);</span>
<span class="line-added"> 619 </span>
<span class="line-added"> 620   if (extraspace)</span>
<span class="line-added"> 621     __ sub(sp, sp, extraspace);</span>
<span class="line-added"> 622 </span>
<span class="line-added"> 623   // Now write the args into the outgoing interpreter space</span>
<span class="line-added"> 624 </span>
<span class="line-added"> 625   int ignored = 0, next_vt_arg = 0, next_arg_int = 0;</span>
<span class="line-added"> 626   bool has_oop_field = false;</span>
<span class="line-added"> 627 </span>
<span class="line-added"> 628   for (int next_arg_comp = 0; next_arg_comp &lt; total_args_passed; next_arg_comp++) {</span>
<span class="line-added"> 629     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;</span>
<span class="line-added"> 630     // offset to start parameters</span>
<span class="line-added"> 631     int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;</span>
<span class="line-added"> 632 </span>
<span class="line-added"> 633     if (!ValueTypePassFieldsAsArgs || bt != T_VALUETYPE) {</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635             if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {</span>
<span class="line-added"> 636                continue; // Ignore reserved entry</span>
<span class="line-added"> 637             }</span>
<span class="line-added"> 638 </span>
<span class="line-added"> 639             if (bt == T_VOID) {</span>
<span class="line-added"> 640                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);</span>
<span class="line-added"> 641                next_arg_int ++;</span>
<span class="line-added"> 642                continue;</span>
<span class="line-added"> 643              }</span>
<span class="line-added"> 644 </span>
<span class="line-added"> 645              int next_off = st_off - Interpreter::stackElementSize;</span>
<span class="line-added"> 646              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;</span>
<span class="line-added"> 647 </span>
<span class="line-added"> 648              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));</span>
<span class="line-added"> 649              next_arg_int ++;</span>
<span class="line-added"> 650    } else {</span>
<span class="line-added"> 651        ignored++;</span>
<span class="line-added"> 652       // get the buffer from the just allocated pool of buffers</span>
<span class="line-added"> 653       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_VALUETYPE);</span>
<span class="line-added"> 654       __ load_heap_oop(rscratch1, Address(r10, index));</span>
<span class="line-added"> 655       next_vt_arg++;</span>
<span class="line-added"> 656       next_arg_int++;</span>
<span class="line-added"> 657       int vt = 1;</span>
<span class="line-added"> 658       // write fields we get from compiled code in registers/stack</span>
<span class="line-added"> 659       // slots to the buffer: we know we are done with that value type</span>
<span class="line-added"> 660       // argument when we hit the T_VOID that acts as an end of value</span>
<span class="line-added"> 661       // type delimiter for this value type. Value types are flattened</span>
<span class="line-added"> 662       // so we might encounter embedded value types. Each entry in</span>
<span class="line-added"> 663       // sig_extended contains a field offset in the buffer.</span>
<span class="line-added"> 664       do {</span>
<span class="line-added"> 665         next_arg_comp++;</span>
<span class="line-added"> 666         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;</span>
<span class="line-added"> 667         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;</span>
<span class="line-added"> 668         if (bt == T_VALUETYPE) {</span>
<span class="line-added"> 669           vt++;</span>
<span class="line-added"> 670           ignored++;</span>
<span class="line-added"> 671         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {</span>
<span class="line-added"> 672           vt--;</span>
<span class="line-added"> 673           ignored++;</span>
<span class="line-added"> 674         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {</span>
<span class="line-added"> 675           // Ignore reserved entry</span>
<span class="line-added"> 676         } else {</span>
<span class="line-added"> 677           int off = sig_extended-&gt;at(next_arg_comp)._offset;</span>
<span class="line-added"> 678           assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="line-added"> 679 </span>
<span class="line-added"> 680           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="line-added"> 681           has_oop_field = has_oop_field || is_oop;</span>
<span class="line-added"> 682 </span>
<span class="line-added"> 683           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));</span>
<span class="line-added"> 684         }</span>
<span class="line-added"> 685       } while (vt != 0);</span>
<span class="line-added"> 686       // pass the buffer to the interpreter</span>
<span class="line-added"> 687       __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-added"> 688    }</span>
<span class="line-added"> 689 </span>
<span class="line-added"> 690   }</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692 // If a value type was allocated and initialized, apply post barrier to all oop fields</span>
<span class="line-added"> 693   if (has_value_argument &amp;&amp; has_oop_field) {</span>
<span class="line-added"> 694     __ push(r13); // save senderSP</span>
<span class="line-added"> 695     __ push(r1); // save callee</span>
<span class="line-added"> 696     // Allocate argument register save area</span>
<span class="line-added"> 697     if (frame::arg_reg_save_area_bytes != 0) {</span>
<span class="line-added"> 698       __ sub(sp, sp, frame::arg_reg_save_area_bytes);</span>
<span class="line-added"> 699     }</span>
<span class="line-added"> 700     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::apply_post_barriers), rthread, r10);</span>
<span class="line-added"> 701     // De-allocate argument register save area</span>
<span class="line-added"> 702     if (frame::arg_reg_save_area_bytes != 0) {</span>
<span class="line-added"> 703       __ add(sp, sp, frame::arg_reg_save_area_bytes);</span>
 704     }
<span class="line-added"> 705     __ pop(r1); // restore callee</span>
<span class="line-added"> 706     __ pop(r13); // restore sender SP</span>
 707   }
 708 
 709   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 710 
 711   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 712   __ br(rscratch1);
 713 }
 714 
<span class="line-added"> 715 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm, int comp_args_on_stack, const GrowableArray&lt;SigEntry&gt;* sig, const VMRegPair *regs) {</span>
 716 





 717 
 718   // Note: r13 contains the senderSP on entry. We must preserve it since
 719   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 720   // code goes non-entrant while we get args ready.
 721 
 722   // In addition we use r13 to locate all the interpreter args because
 723   // we must align the stack to 16 bytes.
 724 
 725   // Adapters are frameless.
 726 
 727   // An i2c adapter is frameless because the *caller* frame, which is
 728   // interpreted, routinely repairs its own esp (from
 729   // interpreter_frame_last_sp), even if a callee has modified the
 730   // stack pointer.  It also recalculates and aligns sp.
 731 
 732   // A c2i adapter is frameless because the *callee* frame, which is
 733   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 734   // which is set up via the senderSP register).
 735 
 736   // In other words, if *either* the caller or callee is interpreted, we can
</pre>
<hr />
<pre>
 756       range_check(masm, rax, r11,
 757                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 758                   L_ok);
 759     if (StubRoutines::code1() != NULL)
 760       range_check(masm, rax, r11,
 761                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 762                   L_ok);
 763     if (StubRoutines::code2() != NULL)
 764       range_check(masm, rax, r11,
 765                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 766                   L_ok);
 767     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 768     __ block_comment(msg);
 769     __ stop(msg);
 770     __ bind(L_ok);
 771     __ block_comment(&quot;} verify_i2ce &quot;);
 772 #endif
 773   }
 774 
 775   // Cut-out for having no stack args.
<span class="line-modified"> 776   int comp_words_on_stack = 0;</span>
 777   if (comp_args_on_stack) {
<span class="line-modified"> 778      comp_words_on_stack = align_up(comp_args_on_stack * VMRegImpl::stack_slot_size, wordSize) &gt;&gt; LogBytesPerWord;</span>
<span class="line-modified"> 779      __ sub(rscratch1, sp, comp_words_on_stack * wordSize);</span>
<span class="line-added"> 780      __ andr(sp, rscratch1, -16);</span>
 781   }
 782 
 783   // Will jump to the compiled code just as if compiled code was doing it.
 784   // Pre-load the register-jump target early, to schedule it better.
 785   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 786 
 787 #if INCLUDE_JVMCI
 788   if (EnableJVMCI || UseAOT) {
 789     // check if this call should be routed towards a specific entry point
 790     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 791     Label no_alternative_target;
 792     __ cbz(rscratch2, no_alternative_target);
 793     __ mov(rscratch1, rscratch2);
 794     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 795     __ bind(no_alternative_target);
 796   }
 797 #endif // INCLUDE_JVMCI
 798 
<span class="line-added"> 799   int total_args_passed = sig-&gt;length();</span>
<span class="line-added"> 800 </span>
 801   // Now generate the shuffle code.
 802   for (int i = 0; i &lt; total_args_passed; i++) {
<span class="line-modified"> 803     BasicType bt = sig-&gt;at(i)._bt;</span>
<span class="line-modified"> 804 </span>
<span class="line-added"> 805     assert(bt != T_VALUETYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
<span class="line-added"> 806     if (bt == T_VOID) {</span>
<span class="line-added"> 807       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);</span>
 808       continue;
 809     }
 810 
 811     // Pick up 0, 1 or 2 words from SP+offset.
<span class="line-added"> 812     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);</span>
 813 
<span class="line-modified"> 814     // Load in argument order going down.</span>


 815     int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 816     // Point to interpreter value (vs. tag)
 817     int next_off = ld_off - Interpreter::stackElementSize;
 818     //
 819     //
 820     //
 821     VMReg r_1 = regs[i].first();
 822     VMReg r_2 = regs[i].second();
 823     if (!r_1-&gt;is_valid()) {
 824       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 825       continue;
 826     }
 827     if (r_1-&gt;is_stack()) {
 828       // Convert stack slot to an SP offset (+ wordSize to account for return address )
<span class="line-modified"> 829       int st_off = regs[i].first()-&gt;reg2stack() * VMRegImpl::stack_slot_size;</span>
 830       if (!r_2-&gt;is_valid()) {
 831         // sign extend???
 832         __ ldrsw(rscratch2, Address(esp, ld_off));
 833         __ str(rscratch2, Address(sp, st_off));
 834       } else {
 835         //
 836         // We are using two optoregs. This can be either T_OBJECT,
 837         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 838         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 839         // So we must adjust where to pick up the data to match the
 840         // interpreter.
 841         //
 842         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 843         // are accessed as negative so LSW is at LOW address
 844 
 845         // ld_off is MSW so get LSW
<span class="line-modified"> 846         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;</span>

 847         __ ldr(rscratch2, Address(esp, offset));
 848         // st_off is LSW (i.e. reg.first())
<span class="line-modified"> 849          __ str(rscratch2, Address(sp, st_off));</span>
<span class="line-modified"> 850        }</span>
<span class="line-modified"> 851      } else if (r_1-&gt;is_Register()) {  // Register argument</span>
<span class="line-modified"> 852        Register r = r_1-&gt;as_Register();</span>
<span class="line-modified"> 853        if (r_2-&gt;is_valid()) {</span>
<span class="line-modified"> 854          //</span>
<span class="line-modified"> 855          // We are using two VMRegs. This can be either T_OBJECT,</span>
<span class="line-modified"> 856          // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates</span>
<span class="line-modified"> 857          // two slots but only uses one for thr T_LONG or T_DOUBLE case</span>
<span class="line-modified"> 858          // So we must adjust where to pick up the data to match the</span>
<span class="line-modified"> 859          // interpreter.</span>
<span class="line-added"> 860 </span>
<span class="line-added"> 861         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;</span>
<span class="line-added"> 862 </span>
<span class="line-added"> 863          // this can be a misaligned move</span>
<span class="line-added"> 864          __ ldr(r, Address(esp, offset));</span>
<span class="line-added"> 865        } else {</span>
<span class="line-added"> 866          // sign extend and use a full word?</span>
<span class="line-added"> 867          __ ldrw(r, Address(esp, ld_off));</span>
<span class="line-added"> 868        }</span>
<span class="line-added"> 869      } else {</span>
<span class="line-added"> 870        if (!r_2-&gt;is_valid()) {</span>
<span class="line-added"> 871          __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));</span>
<span class="line-added"> 872        } else {</span>
<span class="line-added"> 873          __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));</span>
<span class="line-added"> 874        }</span>
<span class="line-added"> 875      }</span>
<span class="line-added"> 876    }</span>
 877 

















 878 
 879   // 6243940 We might end up in handle_wrong_method if
 880   // the callee is deoptimized as we race thru here. If that
 881   // happens we don&#39;t want to take a safepoint because the
 882   // caller frame will look interpreted and arguments are now
 883   // &quot;compiled&quot; so it is much better to make this transition
 884   // invisible to the stack walking code. Unfortunately if
 885   // we try and find the callee by normal means a safepoint
 886   // is possible. So we stash the desired callee in the thread
 887   // and the vm will find there should this case occur.
 888 
 889   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));

 890   __ br(rscratch1);
 891 }
 892 
<span class="line-modified"> 893 static void gen_inline_cache_check(MacroAssembler *masm, Label&amp; skip_fixup) {</span>












 894 
 895   Label ok;
 896 
 897   Register holder = rscratch2;
 898   Register receiver = j_rarg0;
 899   Register tmp = r10;  // A call-clobbered register not used for arg passing
 900 
 901   // -------------------------------------------------------------------------
 902   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 903   // to the interpreter.  The args start out packed in the compiled layout.  They
 904   // need to be unpacked into the interpreter layout.  This will almost always
 905   // require some stack space.  We grow the current (compiled) stack, then repack
 906   // the args.  We  finally end in a jump to the generic interpreter entry point.
 907   // On exit from the interpreter, the interpreter will restore our SP (lest the
 908   // compiled code, which relys solely on SP and not FP, get sick).
 909 
 910   {
 911     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 912     __ load_klass(rscratch1, receiver);
 913     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 914     __ cmp(rscratch1, tmp);
 915     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 916     __ br(Assembler::EQ, ok);
 917     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 918 
 919     __ bind(ok);
 920     // Method might have been compiled since the call site was patched to
 921     // interpreted; if that is the case treat it as a miss so we can get
 922     // the call site corrected.
 923     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 924     __ cbz(rscratch1, skip_fixup);
 925     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 926     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 927   }
<span class="line-added"> 928 }</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930 </span>
<span class="line-added"> 931 // ---------------------------------------------------------------</span>
<span class="line-added"> 932 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="line-added"> 933                                                             int comp_args_on_stack,</span>
<span class="line-added"> 934                                                             const GrowableArray&lt;SigEntry&gt;* sig,</span>
<span class="line-added"> 935                                                             const VMRegPair* regs,</span>
<span class="line-added"> 936                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-added"> 937                                                             const VMRegPair* regs_cc,</span>
<span class="line-added"> 938                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,</span>
<span class="line-added"> 939                                                             const VMRegPair* regs_cc_ro,</span>
<span class="line-added"> 940                                                             AdapterFingerPrint* fingerprint,</span>
<span class="line-added"> 941                                                             AdapterBlob*&amp; new_adapter) {</span>
<span class="line-added"> 942 </span>
<span class="line-added"> 943   address i2c_entry = __ pc();</span>
<span class="line-added"> 944   gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);</span>
<span class="line-added"> 945 </span>
<span class="line-added"> 946   address c2i_unverified_entry = __ pc();</span>
<span class="line-added"> 947   Label skip_fixup;</span>
<span class="line-added"> 948 </span>
<span class="line-added"> 949   gen_inline_cache_check(masm, skip_fixup);</span>
<span class="line-added"> 950 </span>
<span class="line-added"> 951   OopMapSet* oop_maps = new OopMapSet();</span>
<span class="line-added"> 952   int frame_complete = CodeOffsets::frame_never_safe;</span>
<span class="line-added"> 953   int frame_size_in_words = 0;</span>
<span class="line-added"> 954 </span>
<span class="line-added"> 955   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)</span>
<span class="line-added"> 956   address c2i_value_ro_entry = __ pc();</span>
<span class="line-added"> 957   if (regs_cc != regs_cc_ro) {</span>
<span class="line-added"> 958     Label unused;</span>
<span class="line-added"> 959     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
<span class="line-added"> 960     skip_fixup = unused;</span>
<span class="line-added"> 961   }</span>
 962 
<span class="line-added"> 963   // Scalarized c2i adapter</span>
 964   address c2i_entry = __ pc();
 965 
 966   // Class initialization barrier for static methods
 967   address c2i_no_clinit_check_entry = NULL;
<span class="line-added"> 968 </span>
 969   if (VM_Version::supports_fast_class_init_checks()) {
 970     Label L_skip_barrier;
<span class="line-modified"> 971     { // Bypass the barrier for non-static methods</span>
<span class="line-modified"> 972         Register flags  = rscratch1;</span>
<span class="line-modified"> 973       __ ldrw(flags, Address(rmethod, Method::access_flags_offset()));</span>
<span class="line-modified"> 974       __ tst(flags, JVM_ACC_STATIC);</span>
 975       __ br(Assembler::NE, L_skip_barrier); // non-static
 976     }
 977 
<span class="line-modified"> 978     Register klass = rscratch1;</span>
<span class="line-modified"> 979     __ load_method_holder(klass, rmethod);</span>
<span class="line-modified"> 980     // We pass rthread to this function on x86</span>
<span class="line-added"> 981     __ clinit_barrier(klass, rscratch2, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added"> 982 </span>
<span class="line-added"> 983     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path</span>
 984 
 985     __ bind(L_skip_barrier);
 986     c2i_no_clinit_check_entry = __ pc();
 987   }
 988 
<span class="line-modified"> 989 //  FIXME: Not Implemented</span>
<span class="line-added"> 990 //  BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added"> 991 //  bs-&gt;c2i_entry_barrier(masm);</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993   gen_c2i_adapter(masm, sig_cc, regs_cc, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, true);</span>
<span class="line-added"> 994 </span>
<span class="line-added"> 995   address c2i_unverified_value_entry = c2i_unverified_entry;</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997  // Non-scalarized c2i adapter</span>
<span class="line-added"> 998   address c2i_value_entry = c2i_entry;</span>
<span class="line-added"> 999   if (regs != regs_cc) {</span>
<span class="line-added">1000     Label value_entry_skip_fixup;</span>
<span class="line-added">1001     c2i_unverified_value_entry = __ pc();</span>
<span class="line-added">1002     gen_inline_cache_check(masm, value_entry_skip_fixup);</span>
<span class="line-added">1003 </span>
<span class="line-added">1004     c2i_value_entry = __ pc();</span>
<span class="line-added">1005     Label unused;</span>
<span class="line-added">1006     gen_c2i_adapter(masm, sig, regs, value_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
<span class="line-added">1007   }</span>
1008 
1009   __ flush();
<span class="line-modified">1010 </span>
<span class="line-added">1011   // The c2i adapter might safepoint and trigger a GC. The caller must make sure that</span>
<span class="line-added">1012   // the GC knows about the location of oop argument locations passed to the c2i adapter.</span>
<span class="line-added">1013 </span>
<span class="line-added">1014   bool caller_must_gc_arguments = (regs != regs_cc);</span>
<span class="line-added">1015   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words + 10, oop_maps, caller_must_gc_arguments);</span>
<span class="line-added">1016 </span>
<span class="line-added">1017   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry, c2i_unverified_entry, c2i_unverified_value_entry, c2i_no_clinit_check_entry);</span>
1018 }
1019 
1020 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1021                                          VMRegPair *regs,
1022                                          VMRegPair *regs2,
1023                                          int total_args_passed) {
1024   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
1025 
1026 // We return the amount of VMRegImpl stack slots we need to reserve for all
1027 // the arguments NOT counting out_preserve_stack_slots.
1028 
1029     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1030       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
1031     };
1032     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1033       c_farg0, c_farg1, c_farg2, c_farg3,
1034       c_farg4, c_farg5, c_farg6, c_farg7
1035     };
1036 
1037     uint int_args = 0;
</pre>
<hr />
<pre>
1040 
1041     for (int i = 0; i &lt; total_args_passed; i++) {
1042       switch (sig_bt[i]) {
1043       case T_BOOLEAN:
1044       case T_CHAR:
1045       case T_BYTE:
1046       case T_SHORT:
1047       case T_INT:
1048         if (int_args &lt; Argument::n_int_register_parameters_c) {
1049           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1050         } else {
1051           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1052           stk_args += 2;
1053         }
1054         break;
1055       case T_LONG:
1056         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1057         // fall through
1058       case T_OBJECT:
1059       case T_ARRAY:
<span class="line-added">1060       case T_VALUETYPE:</span>
1061       case T_ADDRESS:
1062       case T_METADATA:
1063         if (int_args &lt; Argument::n_int_register_parameters_c) {
1064           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1065         } else {
1066           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1067           stk_args += 2;
1068         }
1069         break;
1070       case T_FLOAT:
1071         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1072           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1073         } else {
1074           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1075           stk_args += 2;
1076         }
1077         break;
1078       case T_DOUBLE:
1079         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1080         if (fp_args &lt; Argument::n_float_register_parameters_c) {
</pre>
<hr />
<pre>
1891       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1892     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1893       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1894     }
1895 #endif /* ASSERT */
1896     switch (in_sig_bt[i]) {
1897       case T_ARRAY:
1898         if (is_critical_native) {
1899           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1900           c_arg++;
1901 #ifdef ASSERT
1902           if (out_regs[c_arg].first()-&gt;is_Register()) {
1903             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1904           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1905             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1906           }
1907 #endif
1908           int_args++;
1909           break;
1910         }
<span class="line-added">1911       case T_VALUETYPE:</span>
1912       case T_OBJECT:
1913         assert(!is_critical_native, &quot;no oop arguments&quot;);
1914         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1915                     ((i == 0) &amp;&amp; (!is_static)),
1916                     &amp;receiver_offset);
1917         int_args++;
1918         break;
1919       case T_VOID:
1920         break;
1921 
1922       case T_FLOAT:
1923         float_move(masm, in_regs[i], out_regs[c_arg]);
1924         float_args++;
1925         break;
1926 
1927       case T_DOUBLE:
1928         assert( i + 1 &lt; total_in_args &amp;&amp;
1929                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1930                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1931         double_move(masm, in_regs[i], out_regs[c_arg]);
</pre>
<hr />
<pre>
2073   }
2074 
2075   // Now set thread in native
2076   __ mov(rscratch1, _thread_in_native);
2077   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
2078   __ stlrw(rscratch1, rscratch2);
2079 
2080   {
2081     int return_type = 0;
2082     switch (ret_type) {
2083     case T_VOID: break;
2084       return_type = 0; break;
2085     case T_CHAR:
2086     case T_BYTE:
2087     case T_SHORT:
2088     case T_INT:
2089     case T_BOOLEAN:
2090     case T_LONG:
2091       return_type = 1; break;
2092     case T_ARRAY:
<span class="line-added">2093     case T_VALUETYPE:</span>
2094     case T_OBJECT:
2095       return_type = 1; break;
2096     case T_FLOAT:
2097       return_type = 2; break;
2098     case T_DOUBLE:
2099       return_type = 3; break;
2100     default:
2101       ShouldNotReachHere();
2102     }
2103     rt_call(masm, native_func,
2104             int_args + 2, // AArch64 passes up to 8 args in int registers
2105             float_args,   // and up to 8 float args
2106             return_type);
2107   }
2108 
2109   __ bind(native_return);
2110 
2111   intptr_t return_pc = (intptr_t) __ pc();
2112   oop_maps-&gt;add_gc_map(return_pc - start, map);
2113 
2114   // Unpack native results.
2115   switch (ret_type) {
2116   case T_BOOLEAN: __ c2bool(r0);                     break;
2117   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
2118   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
2119   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
2120   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
2121   case T_DOUBLE :
2122   case T_FLOAT  :
2123     // Result is in v0 we&#39;ll save as needed
2124     break;
2125   case T_ARRAY:                 // Really a handle
<span class="line-added">2126   case T_VALUETYPE:</span>
2127   case T_OBJECT:                // Really a handle
2128       break; // can&#39;t de-handlize until after safepoint check
2129   case T_VOID: break;
2130   case T_LONG: break;
2131   default       : ShouldNotReachHere();
2132   }
2133 
2134   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2135   // This additional state is necessary because reading and testing the synchronization
2136   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2137   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2138   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2139   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2140   //     didn&#39;t see any synchronization is progress, and escapes.
2141   __ mov(rscratch1, _thread_in_native_trans);
2142 
2143   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
2144 
2145   // Force this write out before the read below
2146   __ dmb(Assembler::ISH);
</pre>
<hr />
<pre>
3332 #ifdef ASSERT
3333   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3334   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3335 #endif
3336   // Clear the exception oop so GC no longer processes it as a root.
3337   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3338 
3339   // r0: exception oop
3340   // r8:  exception handler
3341   // r4: exception pc
3342   // Jump to handler
3343 
3344   __ br(r8);
3345 
3346   // Make sure all code is generated
3347   masm-&gt;flush();
3348 
3349   // Set exception blob
3350   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3351 }
<span class="line-added">3352 </span>
<span class="line-added">3353 BufferedValueTypeBlob* SharedRuntime::generate_buffered_value_type_adapter(const ValueKlass* vk) {</span>
<span class="line-added">3354   BufferBlob* buf = BufferBlob::create(&quot;value types pack/unpack&quot;, 16 * K);</span>
<span class="line-added">3355   CodeBuffer buffer(buf);</span>
<span class="line-added">3356   short buffer_locs[20];</span>
<span class="line-added">3357   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,</span>
<span class="line-added">3358                                          sizeof(buffer_locs)/sizeof(relocInfo));</span>
<span class="line-added">3359 </span>
<span class="line-added">3360   MacroAssembler _masm(&amp;buffer);</span>
<span class="line-added">3361   MacroAssembler* masm = &amp;_masm;</span>
<span class="line-added">3362 </span>
<span class="line-added">3363   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();</span>
<span class="line-added">3364   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();</span>
<span class="line-added">3365 </span>
<span class="line-added">3366   int pack_fields_off = __ offset();</span>
<span class="line-added">3367 </span>
<span class="line-added">3368   int j = 1;</span>
<span class="line-added">3369   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="line-added">3370     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="line-added">3371     if (bt == T_VALUETYPE) {</span>
<span class="line-added">3372       continue;</span>
<span class="line-added">3373     }</span>
<span class="line-added">3374     if (bt == T_VOID) {</span>
<span class="line-added">3375       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="line-added">3376           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="line-added">3377         j++;</span>
<span class="line-added">3378       }</span>
<span class="line-added">3379       continue;</span>
<span class="line-added">3380     }</span>
<span class="line-added">3381     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="line-added">3382     VMRegPair pair = regs-&gt;at(j);</span>
<span class="line-added">3383     VMReg r_1 = pair.first();</span>
<span class="line-added">3384     VMReg r_2 = pair.second();</span>
<span class="line-added">3385     Address to(r0, off);</span>
<span class="line-added">3386     if (bt == T_FLOAT) {</span>
<span class="line-added">3387       __ strs(r_1-&gt;as_FloatRegister(), to);</span>
<span class="line-added">3388     } else if (bt == T_DOUBLE) {</span>
<span class="line-added">3389       __ strd(r_1-&gt;as_FloatRegister(), to);</span>
<span class="line-added">3390     } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
<span class="line-added">3391       Register val = r_1-&gt;as_Register();</span>
<span class="line-added">3392       assert_different_registers(r0, val);</span>
<span class="line-added">3393       // We don&#39;t need barriers because the destination is a newly allocated object.</span>
<span class="line-added">3394       // Also, we cannot use store_heap_oop(to, val) because it uses r8 as tmp.</span>
<span class="line-added">3395       if (UseCompressedOops) {</span>
<span class="line-added">3396         __ encode_heap_oop(val);</span>
<span class="line-added">3397         __ str(val, to);</span>
<span class="line-added">3398       } else {</span>
<span class="line-added">3399         __ str(val, to);</span>
<span class="line-added">3400       }</span>
<span class="line-added">3401     } else {</span>
<span class="line-added">3402       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);</span>
<span class="line-added">3403       assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="line-added">3404       size_t size_in_bytes = type2aelembytes(bt);</span>
<span class="line-added">3405       __ store_sized_value(to, r_1-&gt;as_Register(), size_in_bytes);</span>
<span class="line-added">3406     }</span>
<span class="line-added">3407     j++;</span>
<span class="line-added">3408   }</span>
<span class="line-added">3409   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="line-added">3410 </span>
<span class="line-added">3411   __ ret(lr);</span>
<span class="line-added">3412 </span>
<span class="line-added">3413   int unpack_fields_off = __ offset();</span>
<span class="line-added">3414 </span>
<span class="line-added">3415   j = 1;</span>
<span class="line-added">3416   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="line-added">3417     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="line-added">3418     if (bt == T_VALUETYPE) {</span>
<span class="line-added">3419       continue;</span>
<span class="line-added">3420     }</span>
<span class="line-added">3421     if (bt == T_VOID) {</span>
<span class="line-added">3422       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="line-added">3423           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="line-added">3424         j++;</span>
<span class="line-added">3425       }</span>
<span class="line-added">3426       continue;</span>
<span class="line-added">3427     }</span>
<span class="line-added">3428     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="line-added">3429     VMRegPair pair = regs-&gt;at(j);</span>
<span class="line-added">3430     VMReg r_1 = pair.first();</span>
<span class="line-added">3431     VMReg r_2 = pair.second();</span>
<span class="line-added">3432     Address from(r0, off);</span>
<span class="line-added">3433     if (bt == T_FLOAT) {</span>
<span class="line-added">3434       __ ldrs(r_1-&gt;as_FloatRegister(), from);</span>
<span class="line-added">3435     } else if (bt == T_DOUBLE) {</span>
<span class="line-added">3436       __ ldrd(r_1-&gt;as_FloatRegister(), from);</span>
<span class="line-added">3437     } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
<span class="line-added">3438        assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="line-added">3439        __ load_heap_oop(r_1-&gt;as_Register(), from);</span>
<span class="line-added">3440     } else {</span>
<span class="line-added">3441       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);</span>
<span class="line-added">3442       assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="line-added">3443 </span>
<span class="line-added">3444       size_t size_in_bytes = type2aelembytes(bt);</span>
<span class="line-added">3445       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);</span>
<span class="line-added">3446     }</span>
<span class="line-added">3447     j++;</span>
<span class="line-added">3448   }</span>
<span class="line-added">3449   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="line-added">3450 </span>
<span class="line-added">3451   __ ret(lr);</span>
<span class="line-added">3452 </span>
<span class="line-added">3453   __ flush();</span>
<span class="line-added">3454 </span>
<span class="line-added">3455   return BufferedValueTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);</span>
<span class="line-added">3456 }</span>
3457 #endif // COMPILER2
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ppc/interp_masm_ppc_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
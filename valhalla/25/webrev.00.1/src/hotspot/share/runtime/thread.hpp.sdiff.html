<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 428  public:
 429   void set_visited_for_critical_count(uint64_t safepoint_id) {
 430     assert(_visited_for_critical_count == 0, &quot;Must be reset before set&quot;);
 431     assert((safepoint_id &amp; 0x1) == 1, &quot;Must be odd&quot;);
 432     _visited_for_critical_count = safepoint_id;
 433   }
 434   void reset_visited_for_critical_count(uint64_t safepoint_id) {
 435     assert(_visited_for_critical_count == safepoint_id, &quot;Was not visited&quot;);
 436     _visited_for_critical_count = 0;
 437   }
 438   bool was_visited_for_critical_count(uint64_t safepoint_id) const {
 439     return _visited_for_critical_count == safepoint_id;
 440   }
 441 #endif
 442 
 443  public:
 444   enum {
 445     is_definitely_current_thread = true
 446   };
 447 

 448   // Constructor
 449   Thread();
 450   virtual ~Thread() = 0;        // Thread is abstract.
 451 
 452   // Manage Thread::current()
 453   void initialize_thread_current();
 454   static void clear_thread_current(); // TLS cleanup needed before threads terminate
 455 
 456  protected:
 457   // To be implemented by children.
 458   virtual void run() = 0;
 459   virtual void pre_run() = 0;
 460   virtual void post_run() = 0;  // Note: Thread must not be deleted prior to calling this!
 461 
 462 #ifdef ASSERT
 463   enum RunState {
 464     PRE_CALL_RUN,
 465     CALL_RUN,
 466     PRE_RUN,
 467     RUN,
</pre>
<hr />
<pre>
1000 
1001   // Create and start the single instance of WatcherThread, or stop it on shutdown
1002   static void start();
1003   static void stop();
1004   // Only allow start once the VM is sufficiently initialized
1005   // Otherwise the first task to enroll will trigger the start
1006   static void make_startable();
1007  private:
1008   int sleep() const;
1009 };
1010 
1011 
1012 class CompilerThread;
1013 
1014 typedef void (*ThreadFunction)(JavaThread*, TRAPS);
1015 
1016 class JavaThread: public Thread {
1017   friend class VMStructs;
1018   friend class JVMCIVMStructs;
1019   friend class WhiteBox;

1020  private:
1021   bool           _on_thread_list;                // Is set when this JavaThread is added to the Threads list
1022   oop            _threadObj;                     // The Java level thread object
1023 
1024 #ifdef ASSERT
1025  private:
1026   int _java_call_counter;
1027 
1028  public:
1029   int  java_call_counter()                       { return _java_call_counter; }
1030   void inc_java_call_counter()                   { _java_call_counter++; }
1031   void dec_java_call_counter() {
1032     assert(_java_call_counter &gt; 0, &quot;Invalid nesting of JavaCallWrapper&quot;);
1033     _java_call_counter--;
1034   }
1035  private:  // restore original namespace restriction
1036 #endif  // ifdef ASSERT
1037 
1038 #ifndef PRODUCT
1039  public:
</pre>
<hr />
<pre>
1057   vframeArray*  _vframe_array_last;              // Holds last vFrameArray we popped
1058   // Because deoptimization is lazy we must save jvmti requests to set locals
1059   // in compiled frames until we deoptimize and we have an interpreter frame.
1060   // This holds the pointer to array (yeah like there might be more than one) of
1061   // description of compiled vframes that have locals that need to be updated.
1062   GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt;* _deferred_locals_updates;
1063 
1064   // Handshake value for fixing 6243940. We need a place for the i2c
1065   // adapter to store the callee Method*. This value is NEVER live
1066   // across a gc point so it does NOT have to be gc&#39;d
1067   // The handshake is open ended since we can&#39;t be certain that it will
1068   // be NULLed. This is because we rarely ever see the race and end up
1069   // in handle_wrong_method which is the backend of the handshake. See
1070   // code in i2c adapters and handle_wrong_method.
1071 
1072   Method*       _callee_target;
1073 
1074   // Used to pass back results to the interpreter or generated code running Java code.
1075   oop           _vm_result;    // oop result is GC-preserved
1076   Metadata*     _vm_result_2;  // non-oop result

1077 
1078   // See ReduceInitialCardMarks: this holds the precise space interval of
1079   // the most recent slow path allocation for which compiled code has
1080   // elided card-marks for performance along the fast-path.
1081   MemRegion     _deferred_card_mark;
1082 
1083   MonitorChunk* _monitor_chunks;                 // Contains the off stack monitors
1084                                                  // allocated during deoptimization
1085                                                  // and by JNI_MonitorEnter/Exit
1086 
1087   // Async. requests support
1088   enum AsyncRequests {
1089     _no_async_condition = 0,
1090     _async_exception,
1091     _async_unsafe_access_error
1092   };
1093   AsyncRequests _special_runtime_exit_condition; // Enum indicating pending async. request
1094   oop           _pending_async_exception;
1095 
1096   // Safepoint support
</pre>
<hr />
<pre>
1537   vframeArray* vframe_array_last() const         { return _vframe_array_last;  }
1538 
1539   // The special resourceMark used during deoptimization
1540 
1541   void set_deopt_mark(DeoptResourceMark* value)  { _deopt_mark = value; }
1542   DeoptResourceMark* deopt_mark(void)            { return _deopt_mark; }
1543 
1544   void set_deopt_compiled_method(CompiledMethod* nm)  { _deopt_nmethod = nm; }
1545   CompiledMethod* deopt_compiled_method()        { return _deopt_nmethod; }
1546 
1547   Method*    callee_target() const               { return _callee_target; }
1548   void set_callee_target  (Method* x)          { _callee_target   = x; }
1549 
1550   // Oop results of vm runtime calls
1551   oop  vm_result() const                         { return _vm_result; }
1552   void set_vm_result  (oop x)                    { _vm_result   = x; }
1553 
1554   Metadata*    vm_result_2() const               { return _vm_result_2; }
1555   void set_vm_result_2  (Metadata* x)          { _vm_result_2   = x; }
1556 



1557   MemRegion deferred_card_mark() const           { return _deferred_card_mark; }
1558   void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }
1559 
1560 #if INCLUDE_JVMCI
1561   int  pending_deoptimization() const             { return _pending_deoptimization; }
1562   jlong pending_failed_speculation() const        { return _pending_failed_speculation; }
1563   bool has_pending_monitorenter() const           { return _pending_monitorenter; }
1564   void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }
1565   void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }
1566   void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }
1567   void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }
1568   void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, &quot;must be&quot;); _jvmci._alternate_call_target = a; }
1569   void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;); _jvmci._implicit_exception_pc = a; }
1570 
1571   virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }
1572   void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }
1573 #endif // INCLUDE_JVMCI
1574 
1575   // Exception handling for compiled methods
1576   oop      exception_oop() const                 { return _exception_oop; }
</pre>
<hr />
<pre>
1776   bool do_not_unlock(void)                       { return _do_not_unlock_if_synchronized; }
1777 
1778   // For assembly stub generation
1779   static ByteSize threadObj_offset()             { return byte_offset_of(JavaThread, _threadObj); }
1780   static ByteSize jni_environment_offset()       { return byte_offset_of(JavaThread, _jni_environment); }
1781   static ByteSize pending_jni_exception_check_fn_offset() {
1782     return byte_offset_of(JavaThread, _pending_jni_exception_check_fn);
1783   }
1784   static ByteSize last_Java_sp_offset() {
1785     return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_sp_offset();
1786   }
1787   static ByteSize last_Java_pc_offset() {
1788     return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_pc_offset();
1789   }
1790   static ByteSize frame_anchor_offset() {
1791     return byte_offset_of(JavaThread, _anchor);
1792   }
1793   static ByteSize callee_target_offset()         { return byte_offset_of(JavaThread, _callee_target); }
1794   static ByteSize vm_result_offset()             { return byte_offset_of(JavaThread, _vm_result); }
1795   static ByteSize vm_result_2_offset()           { return byte_offset_of(JavaThread, _vm_result_2); }

1796   static ByteSize thread_state_offset()          { return byte_offset_of(JavaThread, _thread_state); }
1797   static ByteSize saved_exception_pc_offset()    { return byte_offset_of(JavaThread, _saved_exception_pc); }
1798   static ByteSize osthread_offset()              { return byte_offset_of(JavaThread, _osthread); }
1799 #if INCLUDE_JVMCI
1800   static ByteSize pending_deoptimization_offset() { return byte_offset_of(JavaThread, _pending_deoptimization); }
1801   static ByteSize pending_monitorenter_offset()  { return byte_offset_of(JavaThread, _pending_monitorenter); }
1802   static ByteSize pending_failed_speculation_offset() { return byte_offset_of(JavaThread, _pending_failed_speculation); }
1803   static ByteSize jvmci_alternate_call_target_offset() { return byte_offset_of(JavaThread, _jvmci._alternate_call_target); }
1804   static ByteSize jvmci_implicit_exception_pc_offset() { return byte_offset_of(JavaThread, _jvmci._implicit_exception_pc); }
1805   static ByteSize jvmci_counters_offset()        { return byte_offset_of(JavaThread, _jvmci_counters); }
1806 #endif // INCLUDE_JVMCI
1807   static ByteSize exception_oop_offset()         { return byte_offset_of(JavaThread, _exception_oop); }
1808   static ByteSize exception_pc_offset()          { return byte_offset_of(JavaThread, _exception_pc); }
1809   static ByteSize exception_handler_pc_offset()  { return byte_offset_of(JavaThread, _exception_handler_pc); }
1810   static ByteSize stack_overflow_limit_offset()  { return byte_offset_of(JavaThread, _stack_overflow_limit); }
1811   static ByteSize is_method_handle_return_offset() { return byte_offset_of(JavaThread, _is_method_handle_return); }
1812   static ByteSize stack_guard_state_offset()     { return byte_offset_of(JavaThread, _stack_guard_state); }
1813   static ByteSize reserved_stack_activation_offset() { return byte_offset_of(JavaThread, _reserved_stack_activation); }
1814   static ByteSize suspend_flags_offset()         { return byte_offset_of(JavaThread, _suspend_flags); }
1815 
</pre>
</td>
<td>
<hr />
<pre>
 428  public:
 429   void set_visited_for_critical_count(uint64_t safepoint_id) {
 430     assert(_visited_for_critical_count == 0, &quot;Must be reset before set&quot;);
 431     assert((safepoint_id &amp; 0x1) == 1, &quot;Must be odd&quot;);
 432     _visited_for_critical_count = safepoint_id;
 433   }
 434   void reset_visited_for_critical_count(uint64_t safepoint_id) {
 435     assert(_visited_for_critical_count == safepoint_id, &quot;Was not visited&quot;);
 436     _visited_for_critical_count = 0;
 437   }
 438   bool was_visited_for_critical_count(uint64_t safepoint_id) const {
 439     return _visited_for_critical_count == safepoint_id;
 440   }
 441 #endif
 442 
 443  public:
 444   enum {
 445     is_definitely_current_thread = true
 446   };
 447 
<span class="line-added"> 448  public:</span>
 449   // Constructor
 450   Thread();
 451   virtual ~Thread() = 0;        // Thread is abstract.
 452 
 453   // Manage Thread::current()
 454   void initialize_thread_current();
 455   static void clear_thread_current(); // TLS cleanup needed before threads terminate
 456 
 457  protected:
 458   // To be implemented by children.
 459   virtual void run() = 0;
 460   virtual void pre_run() = 0;
 461   virtual void post_run() = 0;  // Note: Thread must not be deleted prior to calling this!
 462 
 463 #ifdef ASSERT
 464   enum RunState {
 465     PRE_CALL_RUN,
 466     CALL_RUN,
 467     PRE_RUN,
 468     RUN,
</pre>
<hr />
<pre>
1001 
1002   // Create and start the single instance of WatcherThread, or stop it on shutdown
1003   static void start();
1004   static void stop();
1005   // Only allow start once the VM is sufficiently initialized
1006   // Otherwise the first task to enroll will trigger the start
1007   static void make_startable();
1008  private:
1009   int sleep() const;
1010 };
1011 
1012 
1013 class CompilerThread;
1014 
1015 typedef void (*ThreadFunction)(JavaThread*, TRAPS);
1016 
1017 class JavaThread: public Thread {
1018   friend class VMStructs;
1019   friend class JVMCIVMStructs;
1020   friend class WhiteBox;
<span class="line-added">1021   friend class VTBuffer;</span>
1022  private:
1023   bool           _on_thread_list;                // Is set when this JavaThread is added to the Threads list
1024   oop            _threadObj;                     // The Java level thread object
1025 
1026 #ifdef ASSERT
1027  private:
1028   int _java_call_counter;
1029 
1030  public:
1031   int  java_call_counter()                       { return _java_call_counter; }
1032   void inc_java_call_counter()                   { _java_call_counter++; }
1033   void dec_java_call_counter() {
1034     assert(_java_call_counter &gt; 0, &quot;Invalid nesting of JavaCallWrapper&quot;);
1035     _java_call_counter--;
1036   }
1037  private:  // restore original namespace restriction
1038 #endif  // ifdef ASSERT
1039 
1040 #ifndef PRODUCT
1041  public:
</pre>
<hr />
<pre>
1059   vframeArray*  _vframe_array_last;              // Holds last vFrameArray we popped
1060   // Because deoptimization is lazy we must save jvmti requests to set locals
1061   // in compiled frames until we deoptimize and we have an interpreter frame.
1062   // This holds the pointer to array (yeah like there might be more than one) of
1063   // description of compiled vframes that have locals that need to be updated.
1064   GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt;* _deferred_locals_updates;
1065 
1066   // Handshake value for fixing 6243940. We need a place for the i2c
1067   // adapter to store the callee Method*. This value is NEVER live
1068   // across a gc point so it does NOT have to be gc&#39;d
1069   // The handshake is open ended since we can&#39;t be certain that it will
1070   // be NULLed. This is because we rarely ever see the race and end up
1071   // in handle_wrong_method which is the backend of the handshake. See
1072   // code in i2c adapters and handle_wrong_method.
1073 
1074   Method*       _callee_target;
1075 
1076   // Used to pass back results to the interpreter or generated code running Java code.
1077   oop           _vm_result;    // oop result is GC-preserved
1078   Metadata*     _vm_result_2;  // non-oop result
<span class="line-added">1079   oop           _return_buffered_value; // buffered value being returned</span>
1080 
1081   // See ReduceInitialCardMarks: this holds the precise space interval of
1082   // the most recent slow path allocation for which compiled code has
1083   // elided card-marks for performance along the fast-path.
1084   MemRegion     _deferred_card_mark;
1085 
1086   MonitorChunk* _monitor_chunks;                 // Contains the off stack monitors
1087                                                  // allocated during deoptimization
1088                                                  // and by JNI_MonitorEnter/Exit
1089 
1090   // Async. requests support
1091   enum AsyncRequests {
1092     _no_async_condition = 0,
1093     _async_exception,
1094     _async_unsafe_access_error
1095   };
1096   AsyncRequests _special_runtime_exit_condition; // Enum indicating pending async. request
1097   oop           _pending_async_exception;
1098 
1099   // Safepoint support
</pre>
<hr />
<pre>
1540   vframeArray* vframe_array_last() const         { return _vframe_array_last;  }
1541 
1542   // The special resourceMark used during deoptimization
1543 
1544   void set_deopt_mark(DeoptResourceMark* value)  { _deopt_mark = value; }
1545   DeoptResourceMark* deopt_mark(void)            { return _deopt_mark; }
1546 
1547   void set_deopt_compiled_method(CompiledMethod* nm)  { _deopt_nmethod = nm; }
1548   CompiledMethod* deopt_compiled_method()        { return _deopt_nmethod; }
1549 
1550   Method*    callee_target() const               { return _callee_target; }
1551   void set_callee_target  (Method* x)          { _callee_target   = x; }
1552 
1553   // Oop results of vm runtime calls
1554   oop  vm_result() const                         { return _vm_result; }
1555   void set_vm_result  (oop x)                    { _vm_result   = x; }
1556 
1557   Metadata*    vm_result_2() const               { return _vm_result_2; }
1558   void set_vm_result_2  (Metadata* x)          { _vm_result_2   = x; }
1559 
<span class="line-added">1560   oop return_buffered_value() const              { return _return_buffered_value; }</span>
<span class="line-added">1561   void set_return_buffered_value(oop val)        { _return_buffered_value = val; }</span>
<span class="line-added">1562 </span>
1563   MemRegion deferred_card_mark() const           { return _deferred_card_mark; }
1564   void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }
1565 
1566 #if INCLUDE_JVMCI
1567   int  pending_deoptimization() const             { return _pending_deoptimization; }
1568   jlong pending_failed_speculation() const        { return _pending_failed_speculation; }
1569   bool has_pending_monitorenter() const           { return _pending_monitorenter; }
1570   void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }
1571   void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }
1572   void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }
1573   void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }
1574   void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, &quot;must be&quot;); _jvmci._alternate_call_target = a; }
1575   void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;); _jvmci._implicit_exception_pc = a; }
1576 
1577   virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }
1578   void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }
1579 #endif // INCLUDE_JVMCI
1580 
1581   // Exception handling for compiled methods
1582   oop      exception_oop() const                 { return _exception_oop; }
</pre>
<hr />
<pre>
1782   bool do_not_unlock(void)                       { return _do_not_unlock_if_synchronized; }
1783 
1784   // For assembly stub generation
1785   static ByteSize threadObj_offset()             { return byte_offset_of(JavaThread, _threadObj); }
1786   static ByteSize jni_environment_offset()       { return byte_offset_of(JavaThread, _jni_environment); }
1787   static ByteSize pending_jni_exception_check_fn_offset() {
1788     return byte_offset_of(JavaThread, _pending_jni_exception_check_fn);
1789   }
1790   static ByteSize last_Java_sp_offset() {
1791     return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_sp_offset();
1792   }
1793   static ByteSize last_Java_pc_offset() {
1794     return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_pc_offset();
1795   }
1796   static ByteSize frame_anchor_offset() {
1797     return byte_offset_of(JavaThread, _anchor);
1798   }
1799   static ByteSize callee_target_offset()         { return byte_offset_of(JavaThread, _callee_target); }
1800   static ByteSize vm_result_offset()             { return byte_offset_of(JavaThread, _vm_result); }
1801   static ByteSize vm_result_2_offset()           { return byte_offset_of(JavaThread, _vm_result_2); }
<span class="line-added">1802   static ByteSize return_buffered_value_offset() { return byte_offset_of(JavaThread, _return_buffered_value); }</span>
1803   static ByteSize thread_state_offset()          { return byte_offset_of(JavaThread, _thread_state); }
1804   static ByteSize saved_exception_pc_offset()    { return byte_offset_of(JavaThread, _saved_exception_pc); }
1805   static ByteSize osthread_offset()              { return byte_offset_of(JavaThread, _osthread); }
1806 #if INCLUDE_JVMCI
1807   static ByteSize pending_deoptimization_offset() { return byte_offset_of(JavaThread, _pending_deoptimization); }
1808   static ByteSize pending_monitorenter_offset()  { return byte_offset_of(JavaThread, _pending_monitorenter); }
1809   static ByteSize pending_failed_speculation_offset() { return byte_offset_of(JavaThread, _pending_failed_speculation); }
1810   static ByteSize jvmci_alternate_call_target_offset() { return byte_offset_of(JavaThread, _jvmci._alternate_call_target); }
1811   static ByteSize jvmci_implicit_exception_pc_offset() { return byte_offset_of(JavaThread, _jvmci._implicit_exception_pc); }
1812   static ByteSize jvmci_counters_offset()        { return byte_offset_of(JavaThread, _jvmci_counters); }
1813 #endif // INCLUDE_JVMCI
1814   static ByteSize exception_oop_offset()         { return byte_offset_of(JavaThread, _exception_oop); }
1815   static ByteSize exception_pc_offset()          { return byte_offset_of(JavaThread, _exception_pc); }
1816   static ByteSize exception_handler_pc_offset()  { return byte_offset_of(JavaThread, _exception_handler_pc); }
1817   static ByteSize stack_overflow_limit_offset()  { return byte_offset_of(JavaThread, _stack_overflow_limit); }
1818   static ByteSize is_method_handle_return_offset() { return byte_offset_of(JavaThread, _is_method_handle_return); }
1819   static ByteSize stack_guard_state_offset()     { return byte_offset_of(JavaThread, _stack_guard_state); }
1820   static ByteSize reserved_stack_activation_offset() { return byte_offset_of(JavaThread, _reserved_stack_activation); }
1821   static ByteSize suspend_flags_offset()         { return byte_offset_of(JavaThread, _suspend_flags); }
1822 
</pre>
</td>
</tr>
</table>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
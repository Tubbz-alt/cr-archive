<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 128   // ObjectMonitors are prepended here.
 129   ObjectMonitor* _free_list;
 130   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
 131 
 132   // Global ObjectMonitor in-use list. When a JavaThread is exiting,
 133   // ObjectMonitors on its per-thread in-use list are prepended here.
 134   ObjectMonitor* _in_use_list;
 135   DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
 136 
 137   int _free_count;    // # on free_list
 138   DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(int));
 139 
 140   int _in_use_count;  // # on in_use_list
 141   DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));
 142 
 143   int _population;    // # Extant -- in circulation
 144   DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));
 145 };
 146 static ObjectMonitorListGlobals om_list_globals;
 147 













 148 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 149 
 150 
 151 // =====================&gt; Spin-lock functions
 152 
 153 // ObjectMonitors are not lockable outside of this file. We use spin-locks
 154 // implemented using a bit in the _next_om field instead of the heavier
 155 // weight locking mechanisms for faster list management.
 156 
 157 #define OM_LOCK_BIT 0x1
 158 
 159 // Return true if the ObjectMonitor is locked.
 160 // Otherwise returns false.
 161 static bool is_locked(ObjectMonitor* om) {
 162   return ((intptr_t)om-&gt;next_om() &amp; OM_LOCK_BIT) == OM_LOCK_BIT;
 163 }
 164 
 165 // Mark an ObjectMonitor* with OM_LOCK_BIT and return it.
 166 static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {
 167   return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);
</pre>
<hr />
<pre>
 396 // returns true  -- to indicate the call was satisfied.
 397 // returns false -- to indicate the call needs the services of the slow-path.
 398 // A no-loitering ordinance is in effect for code in the quick_* family
 399 // operators: safepoints or indefinite blocking (blocking that might span a
 400 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 401 // entry.
 402 //
 403 // Consider: An interesting optimization is to have the JIT recognize the
 404 // following common idiom:
 405 //   synchronized (someobj) { .... ; notify(); }
 406 // That is, we find a notify() or notifyAll() call that immediately precedes
 407 // the monitorexit operation.  In that case the JIT could fuse the operations
 408 // into a single notifyAndExit() runtime primitive.
 409 
 410 bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {
 411   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 412   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 413   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 414   NoSafepointVerifier nsv;
 415   if (obj == NULL) return false;  // slow-path for invalid obj

 416   const markWord mark = obj-&gt;mark();
 417 
 418   if (mark.has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark.locker())) {
 419     // Degenerate notify
 420     // stack-locked by caller so by definition the implied waitset is empty.
 421     return true;
 422   }
 423 
 424   if (mark.has_monitor()) {
 425     ObjectMonitor* const mon = mark.monitor();
 426     assert(mon-&gt;object() == obj, &quot;invariant&quot;);
 427     if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
 428 
 429     if (mon-&gt;first_waiter() != NULL) {
 430       // We have one or more waiters. Since this is an inflated monitor
 431       // that we own, we can transfer one or more threads from the waitset
 432       // to the entrylist here and now, avoiding the slow-path.
 433       if (all) {
 434         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
 435       } else {
</pre>
<hr />
<pre>
 446   }
 447 
 448   // biased locking and any other IMS exception states take the slow-path
 449   return false;
 450 }
 451 
 452 
 453 // The LockNode emitted directly at the synchronization site would have
 454 // been too big if it were to have included support for the cases of inflated
 455 // recursive enter and exit, so they go here instead.
 456 // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
 457 // quick_enter() as our thread state remains _in_Java.
 458 
 459 bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,
 460                                      BasicLock * lock) {
 461   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 462   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 463   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 464   NoSafepointVerifier nsv;
 465   if (obj == NULL) return false;       // Need to throw NPE

 466   const markWord mark = obj-&gt;mark();
 467 
 468   if (mark.has_monitor()) {
 469     ObjectMonitor* const m = mark.monitor();
 470     assert(m-&gt;object() == obj, &quot;invariant&quot;);
 471     Thread* const owner = (Thread *) m-&gt;_owner;
 472 
 473     // Lock contention and Transactional Lock Elision (TLE) diagnostics
 474     // and observability
 475     // Case: light contention possibly amenable to TLE
 476     // Case: TLE inimical operations such as nested/recursive synchronization
 477 
 478     if (owner == self) {
 479       m-&gt;_recursions++;
 480       return true;
 481     }
 482 
 483     // This Java Monitor is inflated so obj&#39;s header will never be
 484     // displaced to this thread&#39;s BasicLock. Make the displaced header
 485     // non-NULL so this BasicLock is not seen as recursive nor as
</pre>
<hr />
<pre>
 498     }
 499   }
 500 
 501   // Note that we could inflate in quick_enter.
 502   // This is likely a useful optimization
 503   // Critically, in quick_enter() we must not:
 504   // -- perform bias revocation, or
 505   // -- block indefinitely, or
 506   // -- reach a safepoint
 507 
 508   return false;        // revert to slow-path
 509 }
 510 
 511 // -----------------------------------------------------------------------------
 512 // Monitor Enter/Exit
 513 // The interpreter and compiler assembly code tries to lock using the fast path
 514 // of this algorithm. Make sure to update that code if the following function is
 515 // changed. The implementation is extremely sensitive to race condition. Be careful.
 516 
 517 void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {

 518   if (UseBiasedLocking) {
 519     if (!SafepointSynchronize::is_at_safepoint()) {
 520       BiasedLocking::revoke(obj, THREAD);
 521     } else {
 522       BiasedLocking::revoke_at_safepoint(obj);
 523     }
 524   }
 525 
 526   markWord mark = obj-&gt;mark();
 527   assert(!mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 528 
 529   if (mark.is_neutral()) {
 530     // Anticipate successful CAS -- the ST of the displaced mark must
 531     // be visible &lt;= the ST performed by the CAS.
 532     lock-&gt;set_displaced_header(mark);
 533     if (mark == obj()-&gt;cas_set_mark(markWord::from_pointer(lock), mark)) {
 534       return;
 535     }
 536     // Fall through to inflate() ...
 537   } else if (mark.has_locker() &amp;&amp;
 538              THREAD-&gt;is_lock_owned((address)mark.locker())) {
 539     assert(lock != mark.locker(), &quot;must not re-lock the same lock&quot;);
 540     assert(lock != (BasicLock*)obj-&gt;mark().value(), &quot;don&#39;t relock with same BasicLock&quot;);
 541     lock-&gt;set_displaced_header(markWord::from_pointer(NULL));
 542     return;
 543   }
 544 
 545   // The object header will never be displaced to this lock,
 546   // so it does not matter what the value is, except that it
 547   // must be non-zero to avoid looking like a re-entrant lock,
 548   // and must not look locked either.
 549   lock-&gt;set_displaced_header(markWord::unused_mark());
 550   inflate(THREAD, obj(), inflate_cause_monitor_enter)-&gt;enter(THREAD);
 551 }
 552 
 553 void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {
 554   markWord mark = object-&gt;mark();




 555   // We cannot check for Biased Locking if we are racing an inflation.
 556   assert(mark == markWord::INFLATING() ||
 557          !mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 558 
 559   markWord dhw = lock-&gt;displaced_header();
 560   if (dhw.value() == 0) {
 561     // If the displaced header is NULL, then this exit matches up with
 562     // a recursive enter. No real work to do here except for diagnostics.
 563 #ifndef PRODUCT
 564     if (mark != markWord::INFLATING()) {
 565       // Only do diagnostics if we are not racing an inflation. Simply
 566       // exiting a recursive enter of a Java Monitor that is being
 567       // inflated is safe; see the has_monitor() comment below.
 568       assert(!mark.is_neutral(), &quot;invariant&quot;);
 569       assert(!mark.has_locker() ||
 570              THREAD-&gt;is_lock_owned((address)mark.locker()), &quot;invariant&quot;);
 571       if (mark.has_monitor()) {
 572         // The BasicLock&#39;s displaced_header is marked as a recursive
 573         // enter and we have an inflated Java Monitor (ObjectMonitor).
 574         // This is a special case where the Java Monitor was inflated
</pre>
<hr />
<pre>
 595     }
 596   }
 597 
 598   // We have to take the slow-path of possible inflation and then exit.
 599   inflate(THREAD, object, inflate_cause_vm_internal)-&gt;exit(true, THREAD);
 600 }
 601 
 602 // -----------------------------------------------------------------------------
 603 // Class Loader  support to workaround deadlocks on the class loader lock objects
 604 // Also used by GC
 605 // complete_exit()/reenter() are used to wait on a nested lock
 606 // i.e. to give up an outer lock completely and then re-enter
 607 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 608 //  1) complete_exit lock1 - saving recursion count
 609 //  2) wait on lock2
 610 //  3) when notified on lock2, unlock lock2
 611 //  4) reenter lock1 with original recursion count
 612 //  5) lock lock2
 613 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 614 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {

 615   if (UseBiasedLocking) {
 616     BiasedLocking::revoke(obj, THREAD);
 617     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 618   }
 619 
 620   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 621 
 622   return monitor-&gt;complete_exit(THREAD);
 623 }
 624 
 625 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 626 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {

 627   if (UseBiasedLocking) {
 628     BiasedLocking::revoke(obj, THREAD);
 629     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 630   }
 631 
 632   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 633 
 634   monitor-&gt;reenter(recursions, THREAD);
 635 }
 636 // -----------------------------------------------------------------------------
 637 // JNI locks on java objects
 638 // NOTE: must use heavy weight monitor to handle jni monitor enter
 639 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 640   // the current locking is from JNI instead of Java code

 641   if (UseBiasedLocking) {
 642     BiasedLocking::revoke(obj, THREAD);
 643     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 644   }
 645   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 646   inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
 647   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
 648 }
 649 
 650 // NOTE: must use heavy weight monitor to handle jni monitor exit
 651 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {

 652   if (UseBiasedLocking) {
 653     Handle h_obj(THREAD, obj);
 654     BiasedLocking::revoke(h_obj, THREAD);
 655     obj = h_obj();
 656   }
 657   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 658 
 659   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
 660   // If this thread has locked the object, exit the monitor. We
 661   // intentionally do not use CHECK here because we must exit the
 662   // monitor even if an exception is pending.
 663   if (monitor-&gt;check_owner(THREAD)) {
 664     monitor-&gt;exit(true, THREAD);
 665   }
 666 }
 667 
 668 // -----------------------------------------------------------------------------
 669 // Internal VM locks on java objects
 670 // standard constructor, allows locking failures
 671 ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool do_lock) {
</pre>
<hr />
<pre>
 673   _thread = thread;
 674   _thread-&gt;check_for_valid_safepoint_state();
 675   _obj = obj;
 676 
 677   if (_dolock) {
 678     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);
 679   }
 680 }
 681 
 682 ObjectLocker::~ObjectLocker() {
 683   if (_dolock) {
 684     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);
 685   }
 686 }
 687 
 688 
 689 // -----------------------------------------------------------------------------
 690 //  Wait/Notify/NotifyAll
 691 // NOTE: must use heavy weight monitor to handle wait()
 692 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {

 693   if (UseBiasedLocking) {
 694     BiasedLocking::revoke(obj, THREAD);
 695     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 696   }
 697   if (millis &lt; 0) {
 698     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 699   }
 700   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 701 
 702   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
 703   monitor-&gt;wait(millis, true, THREAD);
 704 
 705   // This dummy call is in place to get around dtrace bug 6254741.  Once
 706   // that&#39;s fixed we can uncomment the following line, remove the call
 707   // and change this function back into a &quot;void&quot; func.
 708   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 709   return dtrace_waited_probe(monitor, obj, THREAD);
 710 }
 711 
 712 void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {

 713   if (UseBiasedLocking) {
 714     BiasedLocking::revoke(obj, THREAD);
 715     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 716   }
 717   if (millis &lt; 0) {
 718     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 719   }
 720   inflate(THREAD, obj(), inflate_cause_wait)-&gt;wait(millis, false, THREAD);
 721 }
 722 
 723 void ObjectSynchronizer::notify(Handle obj, TRAPS) {

 724   if (UseBiasedLocking) {
 725     BiasedLocking::revoke(obj, THREAD);
 726     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 727   }
 728 
 729   markWord mark = obj-&gt;mark();
 730   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 731     return;
 732   }
 733   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notify(THREAD);
 734 }
 735 
 736 // NOTE: see comment of notify()
 737 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {

 738   if (UseBiasedLocking) {
 739     BiasedLocking::revoke(obj, THREAD);
 740     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 741   }
 742 
 743   markWord mark = obj-&gt;mark();
 744   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 745     return;
 746   }
 747   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notifyAll(THREAD);
 748 }
 749 
 750 // -----------------------------------------------------------------------------
 751 // Hash Code handling
 752 //
 753 // Performance concern:
 754 // OrderAccess::storestore() calls release() which at one time stored 0
 755 // into the global volatile OrderAccess::dummy variable. This store was
 756 // unnecessary for correctness. Many threads storing into a common location
 757 // causes considerable cache migration or &quot;sloshing&quot; on large SMP systems.
</pre>
<hr />
<pre>
 890     // This is probably the best overall implementation -- we&#39;ll
 891     // likely make this the default in future releases.
 892     unsigned t = self-&gt;_hashStateX;
 893     t ^= (t &lt;&lt; 11);
 894     self-&gt;_hashStateX = self-&gt;_hashStateY;
 895     self-&gt;_hashStateY = self-&gt;_hashStateZ;
 896     self-&gt;_hashStateZ = self-&gt;_hashStateW;
 897     unsigned v = self-&gt;_hashStateW;
 898     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
 899     self-&gt;_hashStateW = v;
 900     value = v;
 901   }
 902 
 903   value &amp;= markWord::hash_mask;
 904   if (value == 0) value = 0xBAD;
 905   assert(value != markWord::no_hash, &quot;invariant&quot;);
 906   return value;
 907 }
 908 
 909 intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {








 910   if (UseBiasedLocking) {
 911     // NOTE: many places throughout the JVM do not expect a safepoint
 912     // to be taken here, in particular most operations on perm gen
 913     // objects. However, we only ever bias Java instances and all of
 914     // the call sites of identity_hash that might revoke biases have
 915     // been checked to make sure they can handle a safepoint. The
 916     // added check of the bias pattern is to avoid useless calls to
 917     // thread-local storage.
 918     if (obj-&gt;mark().has_bias_pattern()) {
 919       // Handle for oop obj in case of STW safepoint
 920       Handle hobj(self, obj);
 921       // Relaxing assertion for bug 6320749.
 922       assert(Universe::verify_in_progress() ||
 923              !SafepointSynchronize::is_at_safepoint(),
 924              &quot;biases should not be seen by VM thread here&quot;);
 925       BiasedLocking::revoke(hobj, JavaThread::current());
 926       obj = hobj();
 927       assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 928     }
 929   }
</pre>
<hr />
<pre>
1000     hash = get_next_hash(self, obj);  // get a new hash
1001     temp = mark.copy_set_hash(hash);  // merge the hash into header
1002     assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());
1003     uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor-&gt;header_addr(), mark.value(), temp.value());
1004     test = markWord(v);
1005     if (test != mark) {
1006       // The attempt to update the ObjectMonitor&#39;s header/dmw field
1007       // did not work. This can happen if another thread managed to
1008       // merge in the hash just before our cmpxchg().
1009       // If we add any new usages of the header/dmw field, this code
1010       // will need to be updated.
1011       hash = test.hash();
1012       assert(test.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, test.value());
1013       assert(hash != 0, &quot;should only have lost the race to a thread that set a non-zero hash&quot;);
1014     }
1015   }
1016   // We finally get the hash.
1017   return hash;
1018 }
1019 
<span class="line-removed">1020 // Deprecated -- use FastHashCode() instead.</span>
<span class="line-removed">1021 </span>
<span class="line-removed">1022 intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) {</span>
<span class="line-removed">1023   return FastHashCode(Thread::current(), obj());</span>
<span class="line-removed">1024 }</span>
<span class="line-removed">1025 </span>
1026 
1027 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
1028                                                    Handle h_obj) {



1029   if (UseBiasedLocking) {
1030     BiasedLocking::revoke(h_obj, thread);
1031     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1032   }
1033 
1034   assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
1035   oop obj = h_obj();
1036 
1037   markWord mark = read_stable_mark(obj);
1038 
1039   // Uncontended case, header points to stack
1040   if (mark.has_locker()) {
1041     return thread-&gt;is_lock_owned((address)mark.locker());
1042   }
1043   // Contended case, header points to ObjectMonitor (tagged pointer)
1044   if (mark.has_monitor()) {
1045     ObjectMonitor* monitor = mark.monitor();
1046     return monitor-&gt;is_entered(thread) != 0;
1047   }
1048   // Unlocked case, header in place
</pre>
<hr />
<pre>
1604 }
1605 
1606 // Fast path code shared by multiple functions
1607 void ObjectSynchronizer::inflate_helper(oop obj) {
1608   markWord mark = obj-&gt;mark();
1609   if (mark.has_monitor()) {
1610     assert(ObjectSynchronizer::verify_objmon_isinpool(mark.monitor()), &quot;monitor is invalid&quot;);
1611     assert(mark.monitor()-&gt;header().is_neutral(), &quot;monitor must record a good object header&quot;);
1612     return;
1613   }
1614   inflate(Thread::current(), obj, inflate_cause_vm_internal);
1615 }
1616 
1617 ObjectMonitor* ObjectSynchronizer::inflate(Thread* self,
1618                                            oop object, const InflateCause cause) {
1619   // Inflate mutates the heap ...
1620   // Relaxing assertion for bug 6320749.
1621   assert(Universe::verify_in_progress() ||
1622          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1623 




1624   EventJavaMonitorInflate event;
1625 
1626   for (;;) {
1627     const markWord mark = object-&gt;mark();
1628     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);
1629 
1630     // The mark can be in one of the following states:
1631     // *  Inflated     - just return
1632     // *  Stack-locked - coerce it to inflated
1633     // *  INFLATING    - busy wait for conversion to complete
1634     // *  Neutral      - aggressively inflate the object.
1635     // *  BIASED       - Illegal.  We should never see this
1636 
1637     // CASE: inflated
1638     if (mark.has_monitor()) {
1639       ObjectMonitor* inf = mark.monitor();
1640       markWord dmw = inf-&gt;header();
1641       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1642       assert(inf-&gt;object() == object, &quot;invariant&quot;);
1643       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 128   // ObjectMonitors are prepended here.
 129   ObjectMonitor* _free_list;
 130   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
 131 
 132   // Global ObjectMonitor in-use list. When a JavaThread is exiting,
 133   // ObjectMonitors on its per-thread in-use list are prepended here.
 134   ObjectMonitor* _in_use_list;
 135   DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
 136 
 137   int _free_count;    // # on free_list
 138   DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(int));
 139 
 140   int _in_use_count;  // # on in_use_list
 141   DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));
 142 
 143   int _population;    // # Extant -- in circulation
 144   DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));
 145 };
 146 static ObjectMonitorListGlobals om_list_globals;
 147 
<span class="line-added"> 148 #define CHECK_THROW_NOSYNC_IMSE(obj)  \</span>
<span class="line-added"> 149   if ((obj)-&gt;mark().is_always_locked()) {  \</span>
<span class="line-added"> 150     ResourceMark rm(THREAD);                \</span>
<span class="line-added"> 151     THROW_MSG(vmSymbols::java_lang_IllegalMonitorStateException(), obj-&gt;klass()-&gt;external_name()); \</span>
<span class="line-added"> 152   }</span>
<span class="line-added"> 153 </span>
<span class="line-added"> 154 #define CHECK_THROW_NOSYNC_IMSE_0(obj)  \</span>
<span class="line-added"> 155     if ((obj)-&gt;mark().is_always_locked()) {  \</span>
<span class="line-added"> 156     ResourceMark rm(THREAD);                  \</span>
<span class="line-added"> 157     THROW_MSG_0(vmSymbols::java_lang_IllegalMonitorStateException(), obj-&gt;klass()-&gt;external_name()); \</span>
<span class="line-added"> 158   }</span>
<span class="line-added"> 159 </span>
<span class="line-added"> 160 </span>
 161 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 162 
 163 
 164 // =====================&gt; Spin-lock functions
 165 
 166 // ObjectMonitors are not lockable outside of this file. We use spin-locks
 167 // implemented using a bit in the _next_om field instead of the heavier
 168 // weight locking mechanisms for faster list management.
 169 
 170 #define OM_LOCK_BIT 0x1
 171 
 172 // Return true if the ObjectMonitor is locked.
 173 // Otherwise returns false.
 174 static bool is_locked(ObjectMonitor* om) {
 175   return ((intptr_t)om-&gt;next_om() &amp; OM_LOCK_BIT) == OM_LOCK_BIT;
 176 }
 177 
 178 // Mark an ObjectMonitor* with OM_LOCK_BIT and return it.
 179 static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {
 180   return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);
</pre>
<hr />
<pre>
 409 // returns true  -- to indicate the call was satisfied.
 410 // returns false -- to indicate the call needs the services of the slow-path.
 411 // A no-loitering ordinance is in effect for code in the quick_* family
 412 // operators: safepoints or indefinite blocking (blocking that might span a
 413 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 414 // entry.
 415 //
 416 // Consider: An interesting optimization is to have the JIT recognize the
 417 // following common idiom:
 418 //   synchronized (someobj) { .... ; notify(); }
 419 // That is, we find a notify() or notifyAll() call that immediately precedes
 420 // the monitorexit operation.  In that case the JIT could fuse the operations
 421 // into a single notifyAndExit() runtime primitive.
 422 
 423 bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {
 424   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 425   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 426   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 427   NoSafepointVerifier nsv;
 428   if (obj == NULL) return false;  // slow-path for invalid obj
<span class="line-added"> 429   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 430   const markWord mark = obj-&gt;mark();
 431 
 432   if (mark.has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark.locker())) {
 433     // Degenerate notify
 434     // stack-locked by caller so by definition the implied waitset is empty.
 435     return true;
 436   }
 437 
 438   if (mark.has_monitor()) {
 439     ObjectMonitor* const mon = mark.monitor();
 440     assert(mon-&gt;object() == obj, &quot;invariant&quot;);
 441     if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
 442 
 443     if (mon-&gt;first_waiter() != NULL) {
 444       // We have one or more waiters. Since this is an inflated monitor
 445       // that we own, we can transfer one or more threads from the waitset
 446       // to the entrylist here and now, avoiding the slow-path.
 447       if (all) {
 448         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
 449       } else {
</pre>
<hr />
<pre>
 460   }
 461 
 462   // biased locking and any other IMS exception states take the slow-path
 463   return false;
 464 }
 465 
 466 
 467 // The LockNode emitted directly at the synchronization site would have
 468 // been too big if it were to have included support for the cases of inflated
 469 // recursive enter and exit, so they go here instead.
 470 // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
 471 // quick_enter() as our thread state remains _in_Java.
 472 
 473 bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,
 474                                      BasicLock * lock) {
 475   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 476   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 477   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 478   NoSafepointVerifier nsv;
 479   if (obj == NULL) return false;       // Need to throw NPE
<span class="line-added"> 480   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 481   const markWord mark = obj-&gt;mark();
 482 
 483   if (mark.has_monitor()) {
 484     ObjectMonitor* const m = mark.monitor();
 485     assert(m-&gt;object() == obj, &quot;invariant&quot;);
 486     Thread* const owner = (Thread *) m-&gt;_owner;
 487 
 488     // Lock contention and Transactional Lock Elision (TLE) diagnostics
 489     // and observability
 490     // Case: light contention possibly amenable to TLE
 491     // Case: TLE inimical operations such as nested/recursive synchronization
 492 
 493     if (owner == self) {
 494       m-&gt;_recursions++;
 495       return true;
 496     }
 497 
 498     // This Java Monitor is inflated so obj&#39;s header will never be
 499     // displaced to this thread&#39;s BasicLock. Make the displaced header
 500     // non-NULL so this BasicLock is not seen as recursive nor as
</pre>
<hr />
<pre>
 513     }
 514   }
 515 
 516   // Note that we could inflate in quick_enter.
 517   // This is likely a useful optimization
 518   // Critically, in quick_enter() we must not:
 519   // -- perform bias revocation, or
 520   // -- block indefinitely, or
 521   // -- reach a safepoint
 522 
 523   return false;        // revert to slow-path
 524 }
 525 
 526 // -----------------------------------------------------------------------------
 527 // Monitor Enter/Exit
 528 // The interpreter and compiler assembly code tries to lock using the fast path
 529 // of this algorithm. Make sure to update that code if the following function is
 530 // changed. The implementation is extremely sensitive to race condition. Be careful.
 531 
 532 void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {
<span class="line-added"> 533   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 534   if (UseBiasedLocking) {
 535     if (!SafepointSynchronize::is_at_safepoint()) {
 536       BiasedLocking::revoke(obj, THREAD);
 537     } else {
 538       BiasedLocking::revoke_at_safepoint(obj);
 539     }
 540   }
 541 
 542   markWord mark = obj-&gt;mark();
 543   assert(!mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 544 
 545   if (mark.is_neutral()) {
 546     // Anticipate successful CAS -- the ST of the displaced mark must
 547     // be visible &lt;= the ST performed by the CAS.
 548     lock-&gt;set_displaced_header(mark);
 549     if (mark == obj()-&gt;cas_set_mark(markWord::from_pointer(lock), mark)) {
 550       return;
 551     }
 552     // Fall through to inflate() ...
 553   } else if (mark.has_locker() &amp;&amp;
 554              THREAD-&gt;is_lock_owned((address)mark.locker())) {
 555     assert(lock != mark.locker(), &quot;must not re-lock the same lock&quot;);
 556     assert(lock != (BasicLock*)obj-&gt;mark().value(), &quot;don&#39;t relock with same BasicLock&quot;);
 557     lock-&gt;set_displaced_header(markWord::from_pointer(NULL));
 558     return;
 559   }
 560 
 561   // The object header will never be displaced to this lock,
 562   // so it does not matter what the value is, except that it
 563   // must be non-zero to avoid looking like a re-entrant lock,
 564   // and must not look locked either.
 565   lock-&gt;set_displaced_header(markWord::unused_mark());
 566   inflate(THREAD, obj(), inflate_cause_monitor_enter)-&gt;enter(THREAD);
 567 }
 568 
 569 void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {
 570   markWord mark = object-&gt;mark();
<span class="line-added"> 571   if (EnableValhalla &amp;&amp; mark.is_always_locked()) {</span>
<span class="line-added"> 572     return;</span>
<span class="line-added"> 573   }</span>
<span class="line-added"> 574   assert(!EnableValhalla || !object-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 575   // We cannot check for Biased Locking if we are racing an inflation.
 576   assert(mark == markWord::INFLATING() ||
 577          !mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 578 
 579   markWord dhw = lock-&gt;displaced_header();
 580   if (dhw.value() == 0) {
 581     // If the displaced header is NULL, then this exit matches up with
 582     // a recursive enter. No real work to do here except for diagnostics.
 583 #ifndef PRODUCT
 584     if (mark != markWord::INFLATING()) {
 585       // Only do diagnostics if we are not racing an inflation. Simply
 586       // exiting a recursive enter of a Java Monitor that is being
 587       // inflated is safe; see the has_monitor() comment below.
 588       assert(!mark.is_neutral(), &quot;invariant&quot;);
 589       assert(!mark.has_locker() ||
 590              THREAD-&gt;is_lock_owned((address)mark.locker()), &quot;invariant&quot;);
 591       if (mark.has_monitor()) {
 592         // The BasicLock&#39;s displaced_header is marked as a recursive
 593         // enter and we have an inflated Java Monitor (ObjectMonitor).
 594         // This is a special case where the Java Monitor was inflated
</pre>
<hr />
<pre>
 615     }
 616   }
 617 
 618   // We have to take the slow-path of possible inflation and then exit.
 619   inflate(THREAD, object, inflate_cause_vm_internal)-&gt;exit(true, THREAD);
 620 }
 621 
 622 // -----------------------------------------------------------------------------
 623 // Class Loader  support to workaround deadlocks on the class loader lock objects
 624 // Also used by GC
 625 // complete_exit()/reenter() are used to wait on a nested lock
 626 // i.e. to give up an outer lock completely and then re-enter
 627 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 628 //  1) complete_exit lock1 - saving recursion count
 629 //  2) wait on lock2
 630 //  3) when notified on lock2, unlock lock2
 631 //  4) reenter lock1 with original recursion count
 632 //  5) lock lock2
 633 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 634 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {
<span class="line-added"> 635   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 636   if (UseBiasedLocking) {
 637     BiasedLocking::revoke(obj, THREAD);
 638     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 639   }
 640 
 641   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 642 
 643   return monitor-&gt;complete_exit(THREAD);
 644 }
 645 
 646 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 647 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {
<span class="line-added"> 648   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_value(), &quot;monitor op on value type&quot;);</span>
 649   if (UseBiasedLocking) {
 650     BiasedLocking::revoke(obj, THREAD);
 651     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 652   }
 653 
 654   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 655 
 656   monitor-&gt;reenter(recursions, THREAD);
 657 }
 658 // -----------------------------------------------------------------------------
 659 // JNI locks on java objects
 660 // NOTE: must use heavy weight monitor to handle jni monitor enter
 661 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 662   // the current locking is from JNI instead of Java code
<span class="line-added"> 663   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 664   if (UseBiasedLocking) {
 665     BiasedLocking::revoke(obj, THREAD);
 666     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 667   }
 668   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 669   inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
 670   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
 671 }
 672 
 673 // NOTE: must use heavy weight monitor to handle jni monitor exit
 674 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
<span class="line-added"> 675   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 676   if (UseBiasedLocking) {
 677     Handle h_obj(THREAD, obj);
 678     BiasedLocking::revoke(h_obj, THREAD);
 679     obj = h_obj();
 680   }
 681   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 682 
 683   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
 684   // If this thread has locked the object, exit the monitor. We
 685   // intentionally do not use CHECK here because we must exit the
 686   // monitor even if an exception is pending.
 687   if (monitor-&gt;check_owner(THREAD)) {
 688     monitor-&gt;exit(true, THREAD);
 689   }
 690 }
 691 
 692 // -----------------------------------------------------------------------------
 693 // Internal VM locks on java objects
 694 // standard constructor, allows locking failures
 695 ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool do_lock) {
</pre>
<hr />
<pre>
 697   _thread = thread;
 698   _thread-&gt;check_for_valid_safepoint_state();
 699   _obj = obj;
 700 
 701   if (_dolock) {
 702     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);
 703   }
 704 }
 705 
 706 ObjectLocker::~ObjectLocker() {
 707   if (_dolock) {
 708     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);
 709   }
 710 }
 711 
 712 
 713 // -----------------------------------------------------------------------------
 714 //  Wait/Notify/NotifyAll
 715 // NOTE: must use heavy weight monitor to handle wait()
 716 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
<span class="line-added"> 717   CHECK_THROW_NOSYNC_IMSE_0(obj);</span>
 718   if (UseBiasedLocking) {
 719     BiasedLocking::revoke(obj, THREAD);
 720     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 721   }
 722   if (millis &lt; 0) {
 723     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 724   }
 725   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 726 
 727   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
 728   monitor-&gt;wait(millis, true, THREAD);
 729 
 730   // This dummy call is in place to get around dtrace bug 6254741.  Once
 731   // that&#39;s fixed we can uncomment the following line, remove the call
 732   // and change this function back into a &quot;void&quot; func.
 733   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 734   return dtrace_waited_probe(monitor, obj, THREAD);
 735 }
 736 
 737 void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {
<span class="line-added"> 738   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 739   if (UseBiasedLocking) {
 740     BiasedLocking::revoke(obj, THREAD);
 741     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 742   }
 743   if (millis &lt; 0) {
 744     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 745   }
 746   inflate(THREAD, obj(), inflate_cause_wait)-&gt;wait(millis, false, THREAD);
 747 }
 748 
 749 void ObjectSynchronizer::notify(Handle obj, TRAPS) {
<span class="line-added"> 750   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 751   if (UseBiasedLocking) {
 752     BiasedLocking::revoke(obj, THREAD);
 753     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 754   }
 755 
 756   markWord mark = obj-&gt;mark();
 757   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 758     return;
 759   }
 760   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notify(THREAD);
 761 }
 762 
 763 // NOTE: see comment of notify()
 764 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
<span class="line-added"> 765   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 766   if (UseBiasedLocking) {
 767     BiasedLocking::revoke(obj, THREAD);
 768     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 769   }
 770 
 771   markWord mark = obj-&gt;mark();
 772   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 773     return;
 774   }
 775   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notifyAll(THREAD);
 776 }
 777 
 778 // -----------------------------------------------------------------------------
 779 // Hash Code handling
 780 //
 781 // Performance concern:
 782 // OrderAccess::storestore() calls release() which at one time stored 0
 783 // into the global volatile OrderAccess::dummy variable. This store was
 784 // unnecessary for correctness. Many threads storing into a common location
 785 // causes considerable cache migration or &quot;sloshing&quot; on large SMP systems.
</pre>
<hr />
<pre>
 918     // This is probably the best overall implementation -- we&#39;ll
 919     // likely make this the default in future releases.
 920     unsigned t = self-&gt;_hashStateX;
 921     t ^= (t &lt;&lt; 11);
 922     self-&gt;_hashStateX = self-&gt;_hashStateY;
 923     self-&gt;_hashStateY = self-&gt;_hashStateZ;
 924     self-&gt;_hashStateZ = self-&gt;_hashStateW;
 925     unsigned v = self-&gt;_hashStateW;
 926     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
 927     self-&gt;_hashStateW = v;
 928     value = v;
 929   }
 930 
 931   value &amp;= markWord::hash_mask;
 932   if (value == 0) value = 0xBAD;
 933   assert(value != markWord::no_hash, &quot;invariant&quot;);
 934   return value;
 935 }
 936 
 937 intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {
<span class="line-added"> 938   if (EnableValhalla &amp;&amp; obj-&gt;klass()-&gt;is_value()) {</span>
<span class="line-added"> 939     // Expected tooling to override hashCode for value type, just don&#39;t crash</span>
<span class="line-added"> 940     if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="line-added"> 941       ResourceMark rm;</span>
<span class="line-added"> 942       log_debug(monitorinflation)(&quot;FastHashCode for value type: %s&quot;, obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added"> 943     }</span>
<span class="line-added"> 944     return obj-&gt;klass()-&gt;java_mirror()-&gt;identity_hash();</span>
<span class="line-added"> 945   }</span>
 946   if (UseBiasedLocking) {
 947     // NOTE: many places throughout the JVM do not expect a safepoint
 948     // to be taken here, in particular most operations on perm gen
 949     // objects. However, we only ever bias Java instances and all of
 950     // the call sites of identity_hash that might revoke biases have
 951     // been checked to make sure they can handle a safepoint. The
 952     // added check of the bias pattern is to avoid useless calls to
 953     // thread-local storage.
 954     if (obj-&gt;mark().has_bias_pattern()) {
 955       // Handle for oop obj in case of STW safepoint
 956       Handle hobj(self, obj);
 957       // Relaxing assertion for bug 6320749.
 958       assert(Universe::verify_in_progress() ||
 959              !SafepointSynchronize::is_at_safepoint(),
 960              &quot;biases should not be seen by VM thread here&quot;);
 961       BiasedLocking::revoke(hobj, JavaThread::current());
 962       obj = hobj();
 963       assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 964     }
 965   }
</pre>
<hr />
<pre>
1036     hash = get_next_hash(self, obj);  // get a new hash
1037     temp = mark.copy_set_hash(hash);  // merge the hash into header
1038     assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());
1039     uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor-&gt;header_addr(), mark.value(), temp.value());
1040     test = markWord(v);
1041     if (test != mark) {
1042       // The attempt to update the ObjectMonitor&#39;s header/dmw field
1043       // did not work. This can happen if another thread managed to
1044       // merge in the hash just before our cmpxchg().
1045       // If we add any new usages of the header/dmw field, this code
1046       // will need to be updated.
1047       hash = test.hash();
1048       assert(test.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, test.value());
1049       assert(hash != 0, &quot;should only have lost the race to a thread that set a non-zero hash&quot;);
1050     }
1051   }
1052   // We finally get the hash.
1053   return hash;
1054 }
1055 






1056 
1057 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
1058                                                    Handle h_obj) {
<span class="line-added">1059   if (EnableValhalla &amp;&amp; h_obj-&gt;mark().is_always_locked()) {</span>
<span class="line-added">1060     return false;</span>
<span class="line-added">1061   }</span>
1062   if (UseBiasedLocking) {
1063     BiasedLocking::revoke(h_obj, thread);
1064     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1065   }
1066 
1067   assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
1068   oop obj = h_obj();
1069 
1070   markWord mark = read_stable_mark(obj);
1071 
1072   // Uncontended case, header points to stack
1073   if (mark.has_locker()) {
1074     return thread-&gt;is_lock_owned((address)mark.locker());
1075   }
1076   // Contended case, header points to ObjectMonitor (tagged pointer)
1077   if (mark.has_monitor()) {
1078     ObjectMonitor* monitor = mark.monitor();
1079     return monitor-&gt;is_entered(thread) != 0;
1080   }
1081   // Unlocked case, header in place
</pre>
<hr />
<pre>
1637 }
1638 
1639 // Fast path code shared by multiple functions
1640 void ObjectSynchronizer::inflate_helper(oop obj) {
1641   markWord mark = obj-&gt;mark();
1642   if (mark.has_monitor()) {
1643     assert(ObjectSynchronizer::verify_objmon_isinpool(mark.monitor()), &quot;monitor is invalid&quot;);
1644     assert(mark.monitor()-&gt;header().is_neutral(), &quot;monitor must record a good object header&quot;);
1645     return;
1646   }
1647   inflate(Thread::current(), obj, inflate_cause_vm_internal);
1648 }
1649 
1650 ObjectMonitor* ObjectSynchronizer::inflate(Thread* self,
1651                                            oop object, const InflateCause cause) {
1652   // Inflate mutates the heap ...
1653   // Relaxing assertion for bug 6320749.
1654   assert(Universe::verify_in_progress() ||
1655          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1656 
<span class="line-added">1657   if (EnableValhalla) {</span>
<span class="line-added">1658     guarantee(!object-&gt;klass()-&gt;is_value(), &quot;Attempt to inflate value type&quot;);</span>
<span class="line-added">1659   }</span>
<span class="line-added">1660 </span>
1661   EventJavaMonitorInflate event;
1662 
1663   for (;;) {
1664     const markWord mark = object-&gt;mark();
1665     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);
1666 
1667     // The mark can be in one of the following states:
1668     // *  Inflated     - just return
1669     // *  Stack-locked - coerce it to inflated
1670     // *  INFLATING    - busy wait for conversion to complete
1671     // *  Neutral      - aggressively inflate the object.
1672     // *  BIASED       - Illegal.  We should never see this
1673 
1674     // CASE: inflated
1675     if (mark.has_monitor()) {
1676       ObjectMonitor* inf = mark.monitor();
1677       markWord dmw = inf-&gt;header();
1678       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1679       assert(inf-&gt;object() == object, &quot;invariant&quot;);
1680       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/classLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;jimage.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/javaClasses.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  40 #include &quot;classfile/vmSymbols.hpp&quot;
  41 #include &quot;compiler/compileBroker.hpp&quot;
  42 #include &quot;interpreter/bytecodeStream.hpp&quot;
  43 #include &quot;interpreter/oopMapCache.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;logging/logStream.hpp&quot;
  46 #include &quot;logging/logTag.hpp&quot;
  47 #include &quot;memory/allocation.inline.hpp&quot;
  48 #include &quot;memory/filemap.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;memory/universe.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceRefKlass.hpp&quot;
  54 #include &quot;oops/method.inline.hpp&quot;
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
  57 #include &quot;oops/symbol.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;runtime/arguments.hpp&quot;
  60 #include &quot;runtime/handles.inline.hpp&quot;
  61 #include &quot;runtime/init.hpp&quot;
  62 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  63 #include &quot;runtime/java.hpp&quot;
  64 #include &quot;runtime/javaCalls.hpp&quot;
  65 #include &quot;runtime/os.inline.hpp&quot;
  66 #include &quot;runtime/threadCritical.hpp&quot;
  67 #include &quot;runtime/timer.hpp&quot;
  68 #include &quot;runtime/vm_version.hpp&quot;
  69 #include &quot;services/management.hpp&quot;
  70 #include &quot;services/threadService.hpp&quot;
  71 #include &quot;utilities/classpathStream.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;
  75 #include &quot;utilities/utf8.hpp&quot;
  76 
  77 // Entry point in java.dll for path canonicalization
  78 
  79 typedef int (*canonicalize_fn_t)(const char *orig, char *out, int len);
  80 
  81 static canonicalize_fn_t CanonicalizeEntry  = NULL;
  82 
  83 // Entry points in zip.dll for loading zip/jar file entries
  84 
  85 typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
  86 typedef void     (*ZipClose_t)(jzfile *zip);
  87 typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  88 typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  89 typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);
  90 typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  91 
  92 static ZipOpen_t         ZipOpen            = NULL;
  93 static ZipClose_t        ZipClose           = NULL;
  94 static FindEntry_t       FindEntry          = NULL;
  95 static ReadEntry_t       ReadEntry          = NULL;
  96 static GetNextEntry_t    GetNextEntry       = NULL;
  97 static Crc32_t           Crc32              = NULL;
  98 
  99 // Entry points for jimage.dll for loading jimage file entries
 100 
 101 static JImageOpen_t                    JImageOpen             = NULL;
 102 static JImageClose_t                   JImageClose            = NULL;
 103 static JImagePackageToModule_t         JImagePackageToModule  = NULL;
 104 static JImageFindResource_t            JImageFindResource     = NULL;
 105 static JImageGetResource_t             JImageGetResource      = NULL;
 106 static JImageResourceIterator_t        JImageResourceIterator = NULL;
 107 
 108 // Globals
 109 
 110 PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;
 111 PerfCounter*    ClassLoader::_perf_classes_inited = NULL;
 112 PerfCounter*    ClassLoader::_perf_class_init_time = NULL;
 113 PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;
 114 PerfCounter*    ClassLoader::_perf_classes_verified = NULL;
 115 PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;
 116 PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;
 117 PerfCounter*    ClassLoader::_perf_classes_linked = NULL;
 118 PerfCounter*    ClassLoader::_perf_class_link_time = NULL;
 119 PerfCounter*    ClassLoader::_perf_class_link_selftime = NULL;
 120 PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = NULL;
 121 PerfCounter*    ClassLoader::_perf_shared_classload_time = NULL;
 122 PerfCounter*    ClassLoader::_perf_sys_classload_time = NULL;
 123 PerfCounter*    ClassLoader::_perf_app_classload_time = NULL;
 124 PerfCounter*    ClassLoader::_perf_app_classload_selftime = NULL;
 125 PerfCounter*    ClassLoader::_perf_app_classload_count = NULL;
 126 PerfCounter*    ClassLoader::_perf_define_appclasses = NULL;
 127 PerfCounter*    ClassLoader::_perf_define_appclass_time = NULL;
 128 PerfCounter*    ClassLoader::_perf_define_appclass_selftime = NULL;
 129 PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = NULL;
 130 PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = NULL;
 131 PerfCounter*    ClassLoader::_sync_systemLoaderLockContentionRate = NULL;
 132 PerfCounter*    ClassLoader::_sync_nonSystemLoaderLockContentionRate = NULL;
 133 PerfCounter*    ClassLoader::_sync_JVMFindLoadedClassLockFreeCounter = NULL;
 134 PerfCounter*    ClassLoader::_sync_JVMDefineClassLockFreeCounter = NULL;
 135 PerfCounter*    ClassLoader::_sync_JNIDefineClassLockFreeCounter = NULL;
 136 PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = NULL;
 137 
 138 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_patch_mod_entries = NULL;
 139 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_exploded_entries = NULL;
 140 ClassPathEntry* ClassLoader::_jrt_entry = NULL;
 141 ClassPathEntry* ClassLoader::_first_append_entry = NULL;
 142 ClassPathEntry* ClassLoader::_last_append_entry  = NULL;
 143 #if INCLUDE_CDS
 144 ClassPathEntry* ClassLoader::_app_classpath_entries = NULL;
 145 ClassPathEntry* ClassLoader::_last_app_classpath_entry = NULL;
 146 ClassPathEntry* ClassLoader::_module_path_entries = NULL;
 147 ClassPathEntry* ClassLoader::_last_module_path_entry = NULL;
 148 #endif
 149 
 150 // helper routines
 151 bool string_starts_with(const char* str, const char* str_to_find) {
 152   size_t str_len = strlen(str);
 153   size_t str_to_find_len = strlen(str_to_find);
 154   if (str_to_find_len &gt; str_len) {
 155     return false;
 156   }
 157   return (strncmp(str, str_to_find, str_to_find_len) == 0);
 158 }
 159 
 160 static const char* get_jimage_version_string() {
 161   static char version_string[10] = &quot;&quot;;
 162   if (version_string[0] == &#39;\0&#39;) {
 163     jio_snprintf(version_string, sizeof(version_string), &quot;%d.%d&quot;,
 164                  VM_Version::vm_major_version(), VM_Version::vm_minor_version());
 165   }
 166   return (const char*)version_string;
 167 }
 168 
 169 bool ClassLoader::string_ends_with(const char* str, const char* str_to_find) {
 170   size_t str_len = strlen(str);
 171   size_t str_to_find_len = strlen(str_to_find);
 172   if (str_to_find_len &gt; str_len) {
 173     return false;
 174   }
 175   return (strncmp(str + (str_len - str_to_find_len), str_to_find, str_to_find_len) == 0);
 176 }
 177 
 178 // Used to obtain the package name from a fully qualified class name.
 179 Symbol* ClassLoader::package_from_class_name(const Symbol* name, bool* bad_class_name) {
 180   if (name == NULL) {
 181     if (bad_class_name != NULL) {
 182       *bad_class_name = true;
 183     }
 184     return NULL;
 185   }
 186 
 187   int utf_len = name-&gt;utf8_length();
 188   const jbyte* base = (const jbyte*)name-&gt;base();
 189   const jbyte* start = base;
 190   const jbyte* end = UTF8::strrchr(start, utf_len, JVM_SIGNATURE_SLASH);
 191   if (end == NULL) {
 192     return NULL;
 193   }
 194   // Skip over &#39;[&#39;s
 195   if (*start == JVM_SIGNATURE_ARRAY) {
 196     do {
 197       start++;
 198     } while (start &lt; end &amp;&amp; *start == JVM_SIGNATURE_ARRAY);
 199 
 200     // Fully qualified class names should not contain a &#39;L&#39;.
 201     // Set bad_class_name to true to indicate that the package name
 202     // could not be obtained due to an error condition.
 203     // In this situation, is_same_class_package returns false.
 204     if (*start == JVM_SIGNATURE_CLASS || *start == JVM_SIGNATURE_VALUETYPE) {
 205       if (bad_class_name != NULL) {
 206         *bad_class_name = true;
 207       }
 208       return NULL;
 209     }
 210   }
 211   // A class name could have just the slash character in the name,
 212   // in which case start &gt; end
 213   if (start &gt;= end) {
 214     // No package name
 215     if (bad_class_name != NULL) {
 216       *bad_class_name = true;
 217     }
 218     return NULL;
 219   }
 220   return SymbolTable::new_symbol(name, start - base, end - base);
 221 }
 222 
 223 // Given a fully qualified package name, find its defining package in the class loader&#39;s
 224 // package entry table.
 225 PackageEntry* ClassLoader::get_package_entry(Symbol* pkg_name, ClassLoaderData* loader_data) {
 226   if (pkg_name == NULL) {
 227     return NULL;
 228   }
 229   PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
 230   return pkgEntryTable-&gt;lookup_only(pkg_name);
 231 }
 232 
 233 const char* ClassPathEntry::copy_path(const char* path) {
 234   char* copy = NEW_C_HEAP_ARRAY(char, strlen(path)+1, mtClass);
 235   strcpy(copy, path);
 236   return copy;
 237 }
 238 
 239 ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {
 240   // construct full path name
 241   assert((_dir != NULL) &amp;&amp; (name != NULL), &quot;sanity&quot;);
 242   size_t path_len = strlen(_dir) + strlen(name) + strlen(os::file_separator()) + 1;
 243   char* path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, path_len);
 244   int len = jio_snprintf(path, path_len, &quot;%s%s%s&quot;, _dir, os::file_separator(), name);
 245   assert(len == (int)(path_len - 1), &quot;sanity&quot;);
 246   // check if file exists
 247   struct stat st;
 248   if (os::stat(path, &amp;st) == 0) {
 249     // found file, open it
 250     int file_handle = os::open(path, 0, 0);
 251     if (file_handle != -1) {
 252       // read contents into resource array
 253       u1* buffer = NEW_RESOURCE_ARRAY(u1, st.st_size);
 254       size_t num_read = os::read(file_handle, (char*) buffer, st.st_size);
 255       // close file
 256       os::close(file_handle);
 257       // construct ClassFileStream
 258       if (num_read == (size_t)st.st_size) {
 259         if (UsePerfData) {
 260           ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(num_read);
 261         }
 262         FREE_RESOURCE_ARRAY(char, path, path_len);
 263         // Resource allocated
 264         return new ClassFileStream(buffer,
 265                                    st.st_size,
 266                                    _dir,
 267                                    ClassFileStream::verify);
 268       }
 269     }
 270   }
 271   FREE_RESOURCE_ARRAY(char, path, path_len);
 272   return NULL;
 273 }
 274 
 275 ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name,
 276                                      bool is_boot_append, bool from_class_path_attr) : ClassPathEntry() {
 277   _zip = zip;
 278   _zip_name = copy_path(zip_name);
 279   _from_class_path_attr = from_class_path_attr;
 280 }
 281 
 282 ClassPathZipEntry::~ClassPathZipEntry() {
 283   (*ZipClose)(_zip);
 284   FREE_C_HEAP_ARRAY(char, _zip_name);
 285 }
 286 
 287 u1* ClassPathZipEntry::open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS) {
 288     // enable call to C land
 289   JavaThread* thread = JavaThread::current();
 290   ThreadToNativeFromVM ttn(thread);
 291   // check whether zip archive contains name
 292   jint name_len;
 293   jzentry* entry = (*FindEntry)(_zip, name, filesize, &amp;name_len);
 294   if (entry == NULL) return NULL;
 295   u1* buffer;
 296   char name_buf[128];
 297   char* filename;
 298   if (name_len &lt; 128) {
 299     filename = name_buf;
 300   } else {
 301     filename = NEW_RESOURCE_ARRAY(char, name_len + 1);
 302   }
 303 
 304   // read contents into resource array
 305   int size = (*filesize) + ((nul_terminate) ? 1 : 0);
 306   buffer = NEW_RESOURCE_ARRAY(u1, size);
 307   if (!(*ReadEntry)(_zip, entry, buffer, filename)) return NULL;
 308 
 309   // return result
 310   if (nul_terminate) {
 311     buffer[*filesize] = 0;
 312   }
 313   return buffer;
 314 }
 315 
 316 ClassFileStream* ClassPathZipEntry::open_stream(const char* name, TRAPS) {
 317   jint filesize;
 318   u1* buffer = open_entry(name, &amp;filesize, false, CHECK_NULL);
 319   if (buffer == NULL) {
 320     return NULL;
 321   }
 322   if (UsePerfData) {
 323     ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(filesize);
 324   }
 325   // Resource allocated
 326   return new ClassFileStream(buffer,
 327                              filesize,
 328                              _zip_name,
 329                              ClassFileStream::verify);
 330 }
 331 
 332 // invoke function for each entry in the zip file
 333 void ClassPathZipEntry::contents_do(void f(const char* name, void* context), void* context) {
 334   JavaThread* thread = JavaThread::current();
 335   HandleMark  handle_mark(thread);
 336   ThreadToNativeFromVM ttn(thread);
 337   for (int n = 0; ; n++) {
 338     jzentry * ze = ((*GetNextEntry)(_zip, n));
 339     if (ze == NULL) break;
 340     (*f)(ze-&gt;name, context);
 341   }
 342 }
 343 
 344 DEBUG_ONLY(ClassPathImageEntry* ClassPathImageEntry::_singleton = NULL;)
 345 
 346 void ClassPathImageEntry::close_jimage() {
 347   if (_jimage != NULL) {
 348     (*JImageClose)(_jimage);
 349     _jimage = NULL;
 350   }
 351 }
 352 
 353 ClassPathImageEntry::ClassPathImageEntry(JImageFile* jimage, const char* name) :
 354   ClassPathEntry(),
 355   _jimage(jimage) {
 356   guarantee(jimage != NULL, &quot;jimage file is null&quot;);
 357   guarantee(name != NULL, &quot;jimage file name is null&quot;);
 358   assert(_singleton == NULL, &quot;VM supports only one jimage&quot;);
 359   DEBUG_ONLY(_singleton = this);
 360   size_t len = strlen(name) + 1;
 361   _name = copy_path(name);
 362 }
 363 
 364 ClassPathImageEntry::~ClassPathImageEntry() {
 365   assert(_singleton == this, &quot;must be&quot;);
 366   DEBUG_ONLY(_singleton = NULL);
 367 
 368   FREE_C_HEAP_ARRAY(const char, _name);
 369 
 370   if (_jimage != NULL) {
 371     (*JImageClose)(_jimage);
 372     _jimage = NULL;
 373   }
 374 }
 375 
 376 ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {
 377   return open_stream_for_loader(name, ClassLoaderData::the_null_class_loader_data(), THREAD);
 378 }
 379 
 380 // For a class in a named module, look it up in the jimage file using this syntax:
 381 //    /&lt;module-name&gt;/&lt;package-name&gt;/&lt;base-class&gt;
 382 //
 383 // Assumptions:
 384 //     1. There are no unnamed modules in the jimage file.
 385 //     2. A package is in at most one module in the jimage file.
 386 //
 387 ClassFileStream* ClassPathImageEntry::open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {
 388   jlong size;
 389   JImageLocationRef location = (*JImageFindResource)(_jimage, &quot;&quot;, get_jimage_version_string(), name, &amp;size);
 390 
 391   if (location == 0) {
 392     TempNewSymbol class_name = SymbolTable::new_symbol(name);
 393     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
 394 
 395     if (pkg_name != NULL) {
 396       if (!Universe::is_module_initialized()) {
 397         location = (*JImageFindResource)(_jimage, JAVA_BASE_NAME, get_jimage_version_string(), name, &amp;size);
 398       } else {
 399         PackageEntry* package_entry = ClassLoader::get_package_entry(pkg_name, loader_data);
 400         if (package_entry != NULL) {
 401           ResourceMark rm(THREAD);
 402           // Get the module name
 403           ModuleEntry* module = package_entry-&gt;module();
 404           assert(module != NULL, &quot;Boot classLoader package missing module&quot;);
 405           assert(module-&gt;is_named(), &quot;Boot classLoader package is in unnamed module&quot;);
 406           const char* module_name = module-&gt;name()-&gt;as_C_string();
 407           if (module_name != NULL) {
 408             location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &amp;size);
 409           }
 410         }
 411       }
 412     }
 413   }
 414   if (location != 0) {
 415     if (UsePerfData) {
 416       ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(size);
 417     }
 418     char* data = NEW_RESOURCE_ARRAY(char, size);
 419     (*JImageGetResource)(_jimage, location, data, size);
 420     // Resource allocated
 421     assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be&quot;);
 422     return new ClassFileStream((u1*)data,
 423                                (int)size,
 424                                _name,
 425                                ClassFileStream::verify,
 426                                true); // from_boot_loader_modules_image
 427   }
 428 
 429   return NULL;
 430 }
 431 
 432 JImageLocationRef ClassLoader::jimage_find_resource(JImageFile* jf,
 433                                                     const char* module_name,
 434                                                     const char* file_name,
 435                                                     jlong &amp;size) {
 436   return ((*JImageFindResource)(jf, module_name, get_jimage_version_string(), file_name, &amp;size));
 437 }
 438 
 439 bool ClassPathImageEntry::is_modules_image() const {
 440   assert(this == _singleton, &quot;VM supports a single jimage&quot;);
 441   assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be used for jrt entry&quot;);
 442   return true;
 443 }
 444 
 445 #if INCLUDE_CDS
 446 void ClassLoader::exit_with_path_failure(const char* error, const char* message) {
 447   Arguments::assert_is_dumping_archive();
 448   tty-&gt;print_cr(&quot;Hint: enable -Xlog:class+path=info to diagnose the failure&quot;);
 449   vm_exit_during_initialization(error, message);
 450 }
 451 #endif
 452 
 453 ModuleClassPathList::ModuleClassPathList(Symbol* module_name) {
 454   _module_name = module_name;
 455   _module_first_entry = NULL;
 456   _module_last_entry = NULL;
 457 }
 458 
 459 ModuleClassPathList::~ModuleClassPathList() {
 460   // Clean out each ClassPathEntry on list
 461   ClassPathEntry* e = _module_first_entry;
 462   while (e != NULL) {
 463     ClassPathEntry* next_entry = e-&gt;next();
 464     delete e;
 465     e = next_entry;
 466   }
 467 }
 468 
 469 void ModuleClassPathList::add_to_list(ClassPathEntry* new_entry) {
 470   if (new_entry != NULL) {
 471     if (_module_last_entry == NULL) {
 472       _module_first_entry = _module_last_entry = new_entry;
 473     } else {
 474       _module_last_entry-&gt;set_next(new_entry);
 475       _module_last_entry = new_entry;
 476     }
 477   }
 478 }
 479 
 480 void ClassLoader::trace_class_path(const char* msg, const char* name) {
 481   LogTarget(Info, class, path) lt;
 482   if (lt.is_enabled()) {
 483     LogStream ls(lt);
 484     if (msg) {
 485       ls.print(&quot;%s&quot;, msg);
 486     }
 487     if (name) {
 488       if (strlen(name) &lt; 256) {
 489         ls.print(&quot;%s&quot;, name);
 490       } else {
 491         // For very long paths, we need to print each character separately,
 492         // as print_cr() has a length limit
 493         while (name[0] != &#39;\0&#39;) {
 494           ls.print(&quot;%c&quot;, name[0]);
 495           name++;
 496         }
 497       }
 498     }
 499     ls.cr();
 500   }
 501 }
 502 
 503 void ClassLoader::setup_bootstrap_search_path() {
 504   const char* sys_class_path = Arguments::get_sysclasspath();
 505   assert(sys_class_path != NULL, &quot;System boot class path must not be NULL&quot;);
 506   if (PrintSharedArchiveAndExit) {
 507     // Don&#39;t print sys_class_path - this is the bootcp of this current VM process, not necessarily
 508     // the same as the bootcp of the shared archive.
 509   } else {
 510     trace_class_path(&quot;bootstrap loader class path=&quot;, sys_class_path);
 511   }
 512   setup_boot_search_path(sys_class_path);
 513 }
 514 
 515 #if INCLUDE_CDS
 516 void ClassLoader::setup_app_search_path(const char *class_path) {
 517   Arguments::assert_is_dumping_archive();
 518 
 519   ResourceMark rm;
 520   ClasspathStream cp_stream(class_path);
 521 
 522   while (cp_stream.has_next()) {
 523     const char* path = cp_stream.get_next();
 524     update_class_path_entry_list(path, false, false, false);
 525   }
 526 }
 527 
 528 void ClassLoader::add_to_module_path_entries(const char* path,
 529                                              ClassPathEntry* entry) {
 530   assert(entry != NULL, &quot;ClassPathEntry should not be NULL&quot;);
 531   Arguments::assert_is_dumping_archive();
 532 
 533   // The entry does not exist, add to the list
 534   if (_module_path_entries == NULL) {
 535     assert(_last_module_path_entry == NULL, &quot;Sanity&quot;);
 536     _module_path_entries = _last_module_path_entry = entry;
 537   } else {
 538     _last_module_path_entry-&gt;set_next(entry);
 539     _last_module_path_entry = entry;
 540   }
 541 }
 542 
 543 // Add a module path to the _module_path_entries list.
 544 void ClassLoader::update_module_path_entry_list(const char *path, TRAPS) {
 545   Arguments::assert_is_dumping_archive();
 546   struct stat st;
 547   if (os::stat(path, &amp;st) != 0) {
 548     tty-&gt;print_cr(&quot;os::stat error %d (%s). CDS dump aborted (path was \&quot;%s\&quot;).&quot;,
 549       errno, os::errno_name(errno), path);
 550     vm_exit_during_initialization();
 551   }
 552   // File or directory found
 553   ClassPathEntry* new_entry = NULL;
 554   new_entry = create_class_path_entry(path, &amp;st, true /* throw_exception */,
 555                                       false /*is_boot_append */, false /* from_class_path_attr */, CHECK);
 556   if (new_entry == NULL) {
 557     return;
 558   }
 559 
 560   add_to_module_path_entries(path, new_entry);
 561   return;
 562 }
 563 
 564 void ClassLoader::setup_module_search_path(const char* path, TRAPS) {
 565   update_module_path_entry_list(path, THREAD);
 566 }
 567 
 568 #endif // INCLUDE_CDS
 569 
 570 void ClassLoader::close_jrt_image() {
 571   // Not applicable for exploded builds
 572   if (!ClassLoader::has_jrt_entry()) return;
 573   _jrt_entry-&gt;close_jimage();
 574 }
 575 
 576 // Construct the array of module/path pairs as specified to --patch-module
 577 // for the boot loader to search ahead of the jimage, if the class being
 578 // loaded is defined to a module that has been specified to --patch-module.
 579 void ClassLoader::setup_patch_mod_entries() {
 580   Thread* THREAD = Thread::current();
 581   GrowableArray&lt;ModulePatchPath*&gt;* patch_mod_args = Arguments::get_patch_mod_prefix();
 582   int num_of_entries = patch_mod_args-&gt;length();
 583 
 584   // Set up the boot loader&#39;s _patch_mod_entries list
 585   _patch_mod_entries = new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;ModuleClassPathList*&gt;(num_of_entries, true);
 586 
 587   for (int i = 0; i &lt; num_of_entries; i++) {
 588     const char* module_name = (patch_mod_args-&gt;at(i))-&gt;module_name();
 589     Symbol* const module_sym = SymbolTable::new_symbol(module_name);
 590     assert(module_sym != NULL, &quot;Failed to obtain Symbol for module name&quot;);
 591     ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 592 
 593     char* class_path = (patch_mod_args-&gt;at(i))-&gt;path_string();
 594     ResourceMark rm(THREAD);
 595     ClasspathStream cp_stream(class_path);
 596 
 597     while (cp_stream.has_next()) {
 598       const char* path = cp_stream.get_next();
 599       struct stat st;
 600       if (os::stat(path, &amp;st) == 0) {
 601         // File or directory found
 602         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);
 603         // If the path specification is valid, enter it into this module&#39;s list
 604         if (new_entry != NULL) {
 605           module_cpl-&gt;add_to_list(new_entry);
 606         }
 607       }
 608     }
 609 
 610     // Record the module into the list of --patch-module entries only if
 611     // valid ClassPathEntrys have been created
 612     if (module_cpl-&gt;module_first_entry() != NULL) {
 613       _patch_mod_entries-&gt;push(module_cpl);
 614     }
 615   }
 616 }
 617 
 618 // Determine whether the module has been patched via the command-line
 619 // option --patch-module
 620 bool ClassLoader::is_in_patch_mod_entries(Symbol* module_name) {
 621   if (_patch_mod_entries != NULL &amp;&amp; _patch_mod_entries-&gt;is_nonempty()) {
 622     int table_len = _patch_mod_entries-&gt;length();
 623     for (int i = 0; i &lt; table_len; i++) {
 624       ModuleClassPathList* patch_mod = _patch_mod_entries-&gt;at(i);
 625       if (module_name-&gt;fast_compare(patch_mod-&gt;module_name()) == 0) {
 626         return true;
 627       }
 628     }
 629   }
 630   return false;
 631 }
 632 
 633 // Set up the _jrt_entry if present and boot append path
 634 void ClassLoader::setup_boot_search_path(const char *class_path) {
 635   EXCEPTION_MARK;
 636   ResourceMark rm(THREAD);
 637   ClasspathStream cp_stream(class_path);
 638   bool set_base_piece = true;
 639 
 640 #if INCLUDE_CDS
 641   if (Arguments::is_dumping_archive()) {
 642     if (!Arguments::has_jimage()) {
 643       vm_exit_during_initialization(&quot;CDS is not supported in exploded JDK build&quot;, NULL);
 644     }
 645   }
 646 #endif
 647 
 648   while (cp_stream.has_next()) {
 649     const char* path = cp_stream.get_next();
 650 
 651     if (set_base_piece) {
 652       // The first time through the bootstrap_search setup, it must be determined
 653       // what the base or core piece of the boot loader search is.  Either a java runtime
 654       // image is present or this is an exploded module build situation.
 655       assert(string_ends_with(path, MODULES_IMAGE_NAME) || string_ends_with(path, JAVA_BASE_NAME),
 656              &quot;Incorrect boot loader search path, no java runtime image or &quot; JAVA_BASE_NAME &quot; exploded build&quot;);
 657       struct stat st;
 658       if (os::stat(path, &amp;st) == 0) {
 659         // Directory found
 660         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);
 661 
 662         // Check for a jimage
 663         if (Arguments::has_jimage()) {
 664           assert(_jrt_entry == NULL, &quot;should not setup bootstrap class search path twice&quot;);
 665           _jrt_entry = new_entry;
 666           assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_modules_image(), &quot;No java runtime image present&quot;);
 667           assert(_jrt_entry-&gt;jimage() != NULL, &quot;No java runtime image&quot;);
 668         }
 669       } else {
 670         // If path does not exist, exit
 671         vm_exit_during_initialization(&quot;Unable to establish the boot loader search path&quot;, path);
 672       }
 673       set_base_piece = false;
 674     } else {
 675       // Every entry on the system boot class path after the initial base piece,
 676       // which is set by os::set_boot_path(), is considered an appended entry.
 677       update_class_path_entry_list(path, false, true, false);
 678     }
 679   }
 680 }
 681 
 682 // During an exploded modules build, each module defined to the boot loader
 683 // will be added to the ClassLoader::_exploded_entries array.
 684 void ClassLoader::add_to_exploded_build_list(Symbol* module_sym, TRAPS) {
 685   assert(!ClassLoader::has_jrt_entry(), &quot;Exploded build not applicable&quot;);
 686   assert(_exploded_entries != NULL, &quot;_exploded_entries was not initialized&quot;);
 687 
 688   // Find the module&#39;s symbol
 689   ResourceMark rm(THREAD);
 690   const char *module_name = module_sym-&gt;as_C_string();
 691   const char *home = Arguments::get_java_home();
 692   const char file_sep = os::file_separator()[0];
 693   // 10 represents the length of &quot;modules&quot; + 2 file separators + \0
 694   size_t len = strlen(home) + strlen(module_name) + 10;
 695   char *path = NEW_RESOURCE_ARRAY(char, len);
 696   jio_snprintf(path, len, &quot;%s%cmodules%c%s&quot;, home, file_sep, file_sep, module_name);
 697 
 698   struct stat st;
 699   if (os::stat(path, &amp;st) == 0) {
 700     // Directory found
 701     ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);
 702 
 703     // If the path specification is valid, enter it into this module&#39;s list.
 704     // There is no need to check for duplicate modules in the exploded entry list,
 705     // since no two modules with the same name can be defined to the boot loader.
 706     // This is checked at module definition time in Modules::define_module.
 707     if (new_entry != NULL) {
 708       ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 709       module_cpl-&gt;add_to_list(new_entry);
 710       {
 711         MutexLocker ml(THREAD, Module_lock);
 712         _exploded_entries-&gt;push(module_cpl);
 713       }
 714       log_info(class, load)(&quot;path: %s&quot;, path);
 715     }
 716   }
 717 }
 718 
 719 ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const struct stat* st,
 720                                                      bool throw_exception,
 721                                                      bool is_boot_append,
 722                                                      bool from_class_path_attr,
 723                                                      TRAPS) {
 724   JavaThread* thread = JavaThread::current();
 725   ClassPathEntry* new_entry = NULL;
 726   if ((st-&gt;st_mode &amp; S_IFMT) == S_IFREG) {
 727     ResourceMark rm(thread);
 728     // Regular file, should be a zip or jimage file
 729     // Canonicalized filename
 730     char* canonical_path = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, JVM_MAXPATHLEN);
 731     if (!get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 732       // This matches the classic VM
 733       if (throw_exception) {
 734         THROW_MSG_(vmSymbols::java_io_IOException(), &quot;Bad pathname&quot;, NULL);
 735       } else {
 736         return NULL;
 737       }
 738     }
 739     jint error;
 740     JImageFile* jimage =(*JImageOpen)(canonical_path, &amp;error);
 741     if (jimage != NULL) {
 742       new_entry = new ClassPathImageEntry(jimage, canonical_path);
 743     } else {
 744       char* error_msg = NULL;
 745       jzfile* zip;
 746       {
 747         // enable call to C land
 748         ThreadToNativeFromVM ttn(thread);
 749         HandleMark hm(thread);
 750         zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 751       }
 752       if (zip != NULL &amp;&amp; error_msg == NULL) {
 753         new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr);
 754       } else {
 755         char *msg;
 756         if (error_msg == NULL) {
 757           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;
 758           jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
 759         } else {
 760           int len = (int)(strlen(path) + strlen(error_msg) + 128);
 761           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, len); ;
 762           jio_snprintf(msg, len - 1, &quot;error in opening JAR file &lt;%s&gt; %s&quot;, error_msg, path);
 763         }
 764         // Don&#39;t complain about bad jar files added via -Xbootclasspath/a:.
 765         if (throw_exception &amp;&amp; is_init_completed()) {
 766           THROW_MSG_(vmSymbols::java_lang_ClassNotFoundException(), msg, NULL);
 767         } else {
 768           return NULL;
 769         }
 770       }
 771     }
 772     log_info(class, path)(&quot;opened: %s&quot;, path);
 773     log_info(class, load)(&quot;opened: %s&quot;, path);
 774   } else {
 775     // Directory
 776     new_entry = new ClassPathDirEntry(path);
 777     log_info(class, load)(&quot;path: %s&quot;, path);
 778   }
 779   return new_entry;
 780 }
 781 
 782 
 783 // Create a class path zip entry for a given path (return NULL if not found
 784 // or zip/JAR file cannot be opened)
 785 ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bool is_boot_append) {
 786   // check for a regular file
 787   struct stat st;
 788   if (os::stat(path, &amp;st) == 0) {
 789     if ((st.st_mode &amp; S_IFMT) == S_IFREG) {
 790       char canonical_path[JVM_MAXPATHLEN];
 791       if (get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 792         char* error_msg = NULL;
 793         jzfile* zip;
 794         {
 795           // enable call to C land
 796           JavaThread* thread = JavaThread::current();
 797           ThreadToNativeFromVM ttn(thread);
 798           HandleMark hm(thread);
 799           zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 800         }
 801         if (zip != NULL &amp;&amp; error_msg == NULL) {
 802           // create using canonical path
 803           return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false);
 804         }
 805       }
 806     }
 807   }
 808   return NULL;
 809 }
 810 
 811 // returns true if entry already on class path
 812 bool ClassLoader::contains_append_entry(const char* name) {
 813   ClassPathEntry* e = _first_append_entry;
 814   while (e != NULL) {
 815     // assume zip entries have been canonicalized
 816     if (strcmp(name, e-&gt;name()) == 0) {
 817       return true;
 818     }
 819     e = e-&gt;next();
 820   }
 821   return false;
 822 }
 823 
 824 void ClassLoader::add_to_boot_append_entries(ClassPathEntry *new_entry) {
 825   if (new_entry != NULL) {
 826     if (_last_append_entry == NULL) {
 827       assert(_first_append_entry == NULL, &quot;boot loader&#39;s append class path entry list not empty&quot;);
 828       _first_append_entry = _last_append_entry = new_entry;
 829     } else {
 830       _last_append_entry-&gt;set_next(new_entry);
 831       _last_append_entry = new_entry;
 832     }
 833   }
 834 }
 835 
 836 // Record the path entries specified in -cp during dump time. The recorded
 837 // information will be used at runtime for loading the archived app classes.
 838 //
 839 // Note that at dump time, ClassLoader::_app_classpath_entries are NOT used for
 840 // loading app classes. Instead, the app class are loaded by the
 841 // jdk/internal/loader/ClassLoaders$AppClassLoader instance.
 842 void ClassLoader::add_to_app_classpath_entries(const char* path,
 843                                                ClassPathEntry* entry,
 844                                                bool check_for_duplicates) {
 845 #if INCLUDE_CDS
 846   assert(entry != NULL, &quot;ClassPathEntry should not be NULL&quot;);
 847   ClassPathEntry* e = _app_classpath_entries;
 848   if (check_for_duplicates) {
 849     while (e != NULL) {
 850       if (strcmp(e-&gt;name(), entry-&gt;name()) == 0) {
 851         // entry already exists
 852         return;
 853       }
 854       e = e-&gt;next();
 855     }
 856   }
 857 
 858   // The entry does not exist, add to the list
 859   if (_app_classpath_entries == NULL) {
 860     assert(_last_app_classpath_entry == NULL, &quot;Sanity&quot;);
 861     _app_classpath_entries = _last_app_classpath_entry = entry;
 862   } else {
 863     _last_app_classpath_entry-&gt;set_next(entry);
 864     _last_app_classpath_entry = entry;
 865   }
 866 
 867   if (entry-&gt;is_jar_file()) {
 868     ClassLoaderExt::process_jar_manifest(entry, check_for_duplicates);
 869   }
 870 #endif
 871 }
 872 
 873 // Returns true IFF the file/dir exists and the entry was successfully created.
 874 bool ClassLoader::update_class_path_entry_list(const char *path,
 875                                                bool check_for_duplicates,
 876                                                bool is_boot_append,
 877                                                bool from_class_path_attr,
 878                                                bool throw_exception) {
 879   struct stat st;
 880   if (os::stat(path, &amp;st) == 0) {
 881     // File or directory found
 882     ClassPathEntry* new_entry = NULL;
 883     Thread* THREAD = Thread::current();
 884     new_entry = create_class_path_entry(path, &amp;st, throw_exception, is_boot_append, from_class_path_attr, CHECK_(false));
 885     if (new_entry == NULL) {
 886       return false;
 887     }
 888 
 889     // Do not reorder the bootclasspath which would break get_system_package().
 890     // Add new entry to linked list
 891     if (is_boot_append) {
 892       add_to_boot_append_entries(new_entry);
 893     } else {
 894       add_to_app_classpath_entries(path, new_entry, check_for_duplicates);
 895     }
 896     return true;
 897   } else {
 898     return false;
 899   }
 900 }
 901 
 902 static void print_module_entry_table(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list) {
 903   ResourceMark rm;
 904   int num_of_entries = module_list-&gt;length();
 905   for (int i = 0; i &lt; num_of_entries; i++) {
 906     ClassPathEntry* e;
 907     ModuleClassPathList* mpl = module_list-&gt;at(i);
 908     tty-&gt;print(&quot;%s=&quot;, mpl-&gt;module_name()-&gt;as_C_string());
 909     e = mpl-&gt;module_first_entry();
 910     while (e != NULL) {
 911       tty-&gt;print(&quot;%s&quot;, e-&gt;name());
 912       e = e-&gt;next();
 913       if (e != NULL) {
 914         tty-&gt;print(&quot;%s&quot;, os::path_separator());
 915       }
 916     }
 917     tty-&gt;print(&quot; ;&quot;);
 918   }
 919 }
 920 
 921 void ClassLoader::print_bootclasspath() {
 922   ClassPathEntry* e;
 923   tty-&gt;print(&quot;[bootclasspath= &quot;);
 924 
 925   // Print --patch-module module/path specifications first
 926   if (_patch_mod_entries != NULL) {
 927     print_module_entry_table(_patch_mod_entries);
 928   }
 929 
 930   // [jimage | exploded modules build]
 931   if (has_jrt_entry()) {
 932     // Print the location of the java runtime image
 933     tty-&gt;print(&quot;%s ;&quot;, _jrt_entry-&gt;name());
 934   } else {
 935     // Print exploded module build path specifications
 936     if (_exploded_entries != NULL) {
 937       print_module_entry_table(_exploded_entries);
 938     }
 939   }
 940 
 941   // appended entries
 942   e = _first_append_entry;
 943   while (e != NULL) {
 944     tty-&gt;print(&quot;%s ;&quot;, e-&gt;name());
 945     e = e-&gt;next();
 946   }
 947   tty-&gt;print_cr(&quot;]&quot;);
 948 }
 949 
 950 void* ClassLoader::dll_lookup(void* lib, const char* name, const char* path) {
 951   void* func = os::dll_lookup(lib, name);
 952   if (func == NULL) {
 953     char msg[256] = &quot;&quot;;
 954     jio_snprintf(msg, sizeof(msg), &quot;Could not resolve \&quot;%s\&quot;&quot;, name);
 955     vm_exit_during_initialization(msg, path);
 956   }
 957   return func;
 958 }
 959 
 960 void ClassLoader::load_java_library() {
 961   assert(CanonicalizeEntry == NULL, &quot;should not load java library twice&quot;);
 962   void *javalib_handle = os::native_java_library();
 963   if (javalib_handle == NULL) {
 964     vm_exit_during_initialization(&quot;Unable to load java library&quot;, NULL);
 965   }
 966 
 967   CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, &quot;JDK_Canonicalize&quot;, NULL));
 968 }
 969 
 970 void ClassLoader::load_zip_library() {
 971   assert(ZipOpen == NULL, &quot;should not load zip library twice&quot;);
 972   char path[JVM_MAXPATHLEN];
 973   char ebuf[1024];
 974   void* handle = NULL;
 975   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;zip&quot;)) {
 976     handle = os::dll_load(path, ebuf, sizeof ebuf);
 977   }
 978   if (handle == NULL) {
 979     vm_exit_during_initialization(&quot;Unable to load zip library&quot;, path);
 980   }
 981 
 982   ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(handle, &quot;ZIP_Open&quot;, path));
 983   ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(handle, &quot;ZIP_Close&quot;, path));
 984   FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(handle, &quot;ZIP_FindEntry&quot;, path));
 985   ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(handle, &quot;ZIP_ReadEntry&quot;, path));
 986   GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(handle, &quot;ZIP_GetNextEntry&quot;, path));
 987   Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(handle, &quot;ZIP_CRC32&quot;, path));
 988 }
 989 
 990 void ClassLoader::load_jimage_library() {
 991   assert(JImageOpen == NULL, &quot;should not load jimage library twice&quot;);
 992   char path[JVM_MAXPATHLEN];
 993   char ebuf[1024];
 994   void* handle = NULL;
 995   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
 996     handle = os::dll_load(path, ebuf, sizeof ebuf);
 997   }
 998   if (handle == NULL) {
 999     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1000   }
1001 
1002   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));
1003   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));
1004   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));
1005   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));
1006   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));
1007   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));
1008 }
1009 
1010 int ClassLoader::crc32(int crc, const char* buf, int len) {
1011   return (*Crc32)(crc, (const jbyte*)buf, len);
1012 }
1013 
1014 // Function add_package checks if the package of the InstanceKlass is in the
1015 // boot loader&#39;s package entry table.  If so, then it sets the classpath_index
1016 // in the package entry record.
1017 //
1018 // The classpath_index field is used to find the entry on the boot loader class
1019 // path for packages with classes loaded by the boot loader from -Xbootclasspath/a
1020 // in an unnamed module.  It is also used to indicate (for all packages whose
1021 // classes are loaded by the boot loader) that at least one of the package&#39;s
1022 // classes has been loaded.
1023 bool ClassLoader::add_package(const InstanceKlass* ik, s2 classpath_index, TRAPS) {
1024   assert(ik != NULL, &quot;just checking&quot;);
1025 
1026   PackageEntry* ik_pkg = ik-&gt;package();
1027   if (ik_pkg != NULL) {
1028     PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();
1029     PackageEntry* pkg_entry = pkg_entry_tbl-&gt;lookup_only(ik_pkg-&gt;name());
1030     if (pkg_entry != NULL) {
1031       assert(classpath_index != -1, &quot;Unexpected classpath_index&quot;);
1032       pkg_entry-&gt;set_classpath_index(classpath_index);
1033     } else {
1034       return false;
1035     }
1036   }
1037   return true;
1038 }
1039 
1040 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1041   // Look up the name in the boot loader&#39;s package entry table.
1042   if (name != NULL) {
1043     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
1044     // Look for the package entry in the boot loader&#39;s package entry table.
1045     PackageEntry* package =
1046       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1047 
1048     // Return NULL if package does not exist or if no classes in that package
1049     // have been loaded.
1050     if (package != NULL &amp;&amp; package-&gt;has_loaded_class()) {
1051       ModuleEntry* module = package-&gt;module();
1052       if (module-&gt;location() != NULL) {
1053         ResourceMark rm(THREAD);
1054         Handle ml = java_lang_String::create_from_str(
1055           module-&gt;location()-&gt;as_C_string(), THREAD);
1056         return ml();
1057       }
1058       // Return entry on boot loader class path.
1059       Handle cph = java_lang_String::create_from_str(
1060         ClassLoader::classpath_entry(package-&gt;classpath_index())-&gt;name(), THREAD);
1061       return cph();
1062     }
1063   }
1064   return NULL;
1065 }
1066 
1067 objArrayOop ClassLoader::get_system_packages(TRAPS) {
1068   ResourceMark rm(THREAD);
1069   // List of pointers to PackageEntrys that have loaded classes.
1070   GrowableArray&lt;PackageEntry*&gt;* loaded_class_pkgs = new GrowableArray&lt;PackageEntry*&gt;(50);
1071   {
1072     MutexLocker ml(THREAD, Module_lock);
1073 
1074     PackageEntryTable* pe_table =
1075       ClassLoaderData::the_null_class_loader_data()-&gt;packages();
1076 
1077     // Collect the packages that have at least one loaded class.
1078     for (int x = 0; x &lt; pe_table-&gt;table_size(); x++) {
1079       for (PackageEntry* package_entry = pe_table-&gt;bucket(x);
1080            package_entry != NULL;
1081            package_entry = package_entry-&gt;next()) {
1082         if (package_entry-&gt;has_loaded_class()) {
1083           loaded_class_pkgs-&gt;append(package_entry);
1084         }
1085       }
1086     }
1087   }
1088 
1089 
1090   // Allocate objArray and fill with java.lang.String
1091   objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
1092                                            loaded_class_pkgs-&gt;length(), CHECK_NULL);
1093   objArrayHandle result(THREAD, r);
1094   for (int x = 0; x &lt; loaded_class_pkgs-&gt;length(); x++) {
1095     PackageEntry* package_entry = loaded_class_pkgs-&gt;at(x);
1096     Handle str = java_lang_String::create_from_symbol(package_entry-&gt;name(), CHECK_NULL);
1097     result-&gt;obj_at_put(x, str());
1098   }
1099   return result();
1100 }
1101 
1102 // caller needs ResourceMark
1103 const char* ClassLoader::file_name_for_class_name(const char* class_name,
1104                                                   int class_name_len) {
1105   assert(class_name != NULL, &quot;invariant&quot;);
1106   assert((int)strlen(class_name) == class_name_len, &quot;invariant&quot;);
1107 
1108   static const char class_suffix[] = &quot;.class&quot;;
1109   size_t class_suffix_len = sizeof(class_suffix);
1110 
1111   char* const file_name = NEW_RESOURCE_ARRAY(char,
1112                                              class_name_len +
1113                                              class_suffix_len); // includes term NULL
1114 
1115   strncpy(file_name, class_name, class_name_len);
1116   strncpy(&amp;file_name[class_name_len], class_suffix, class_suffix_len);
1117 
1118   return file_name;
1119 }
1120 
1121 ClassPathEntry* find_first_module_cpe(ModuleEntry* mod_entry,
1122                                       const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list) {
1123   int num_of_entries = module_list-&gt;length();
1124   const Symbol* class_module_name = mod_entry-&gt;name();
1125 
1126   // Loop through all the modules in either the patch-module or exploded entries looking for module
1127   for (int i = 0; i &lt; num_of_entries; i++) {
1128     ModuleClassPathList* module_cpl = module_list-&gt;at(i);
1129     Symbol* module_cpl_name = module_cpl-&gt;module_name();
1130 
1131     if (module_cpl_name-&gt;fast_compare(class_module_name) == 0) {
1132       // Class&#39; module has been located.
1133       return module_cpl-&gt;module_first_entry();
1134     }
1135   }
1136   return NULL;
1137 }
1138 
1139 
1140 // Search either the patch-module or exploded build entries for class.
1141 ClassFileStream* ClassLoader::search_module_entries(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list,
1142                                                     const char* const class_name,
1143                                                     const char* const file_name,
1144                                                     TRAPS) {
1145   ClassFileStream* stream = NULL;
1146 
1147   // Find the class&#39; defining module in the boot loader&#39;s module entry table
1148   TempNewSymbol class_name_symbol = SymbolTable::new_symbol(class_name);
1149   TempNewSymbol pkg_name = package_from_class_name(class_name_symbol);
1150   PackageEntry* pkg_entry = get_package_entry(pkg_name, ClassLoaderData::the_null_class_loader_data());
1151   ModuleEntry* mod_entry = (pkg_entry != NULL) ? pkg_entry-&gt;module() : NULL;
1152 
1153   // If the module system has not defined java.base yet, then
1154   // classes loaded are assumed to be defined to java.base.
1155   // When java.base is eventually defined by the module system,
1156   // all packages of classes that have been previously loaded
1157   // are verified in ModuleEntryTable::verify_javabase_packages().
1158   if (!Universe::is_module_initialized() &amp;&amp;
1159       !ModuleEntryTable::javabase_defined() &amp;&amp;
1160       mod_entry == NULL) {
1161     mod_entry = ModuleEntryTable::javabase_moduleEntry();
1162   }
1163 
1164   // The module must be a named module
1165   ClassPathEntry* e = NULL;
1166   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_named()) {
1167     if (module_list == _exploded_entries) {
1168       // The exploded build entries can be added to at any time so a lock is
1169       // needed when searching them.
1170       assert(!ClassLoader::has_jrt_entry(), &quot;Must be exploded build&quot;);
1171       MutexLocker ml(THREAD, Module_lock);
1172       e = find_first_module_cpe(mod_entry, module_list);
1173     } else {
1174       e = find_first_module_cpe(mod_entry, module_list);
1175     }
1176   }
1177 
1178   // Try to load the class from the module&#39;s ClassPathEntry list.
1179   while (e != NULL) {
1180     stream = e-&gt;open_stream(file_name, CHECK_NULL);
1181     // No context.check is required since CDS is not supported
1182     // for an exploded modules build or if --patch-module is specified.
1183     if (NULL != stream) {
1184       return stream;
1185     }
1186     e = e-&gt;next();
1187   }
1188   // If the module was located, break out even if the class was not
1189   // located successfully from that module&#39;s ClassPathEntry list.
1190   // There will not be another valid entry for that module.
1191   return NULL;
1192 }
1193 
1194 // Called by the boot classloader to load classes
1195 InstanceKlass* ClassLoader::load_class(Symbol* name, bool search_append_only, TRAPS) {
1196   assert(name != NULL, &quot;invariant&quot;);
1197   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1198 
1199   ResourceMark rm(THREAD);
1200   HandleMark hm(THREAD);
1201 
1202   const char* const class_name = name-&gt;as_C_string();
1203 
1204   EventMark m(&quot;loading class %s&quot;, class_name);
1205 
1206   const char* const file_name = file_name_for_class_name(class_name,
1207                                                          name-&gt;utf8_length());
1208   assert(file_name != NULL, &quot;invariant&quot;);
1209 
1210   // Lookup stream for parsing .class file
1211   ClassFileStream* stream = NULL;
1212   s2 classpath_index = 0;
1213   ClassPathEntry* e = NULL;
1214 
1215   // If search_append_only is true, boot loader visibility boundaries are
1216   // set to be _first_append_entry to the end. This includes:
1217   //   [-Xbootclasspath/a]; [jvmti appended entries]
1218   //
1219   // If search_append_only is false, boot loader visibility boundaries are
1220   // set to be the --patch-module entries plus the base piece. This includes:
1221   //   [--patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*]; [jimage | exploded module build]
1222   //
1223 
1224   // Load Attempt #1: --patch-module
1225   // Determine the class&#39; defining module.  If it appears in the _patch_mod_entries,
1226   // attempt to load the class from those locations specific to the module.
1227   // Specifications to --patch-module can contain a partial number of classes
1228   // that are part of the overall module definition.  So if a particular class is not
1229   // found within its module specification, the search should continue to Load Attempt #2.
1230   // Note: The --patch-module entries are never searched if the boot loader&#39;s
1231   //       visibility boundary is limited to only searching the append entries.
1232   if (_patch_mod_entries != NULL &amp;&amp; !search_append_only) {
1233     // At CDS dump time, the --patch-module entries are ignored. That means a
1234     // class is still loaded from the runtime image even if it might
1235     // appear in the _patch_mod_entries. The runtime shared class visibility
1236     // check will determine if a shared class is visible based on the runtime
1237     // environemnt, including the runtime --patch-module setting.
1238     //
1239     // DynamicDumpSharedSpaces requires UseSharedSpaces to be enabled. Since --patch-module
1240     // is not supported with UseSharedSpaces, it is not supported with DynamicDumpSharedSpaces.
1241     assert(!DynamicDumpSharedSpaces, &quot;sanity&quot;);
1242     if (!DumpSharedSpaces) {
1243       stream = search_module_entries(_patch_mod_entries, class_name, file_name, CHECK_NULL);
1244     }
1245   }
1246 
1247   // Load Attempt #2: [jimage | exploded build]
1248   if (!search_append_only &amp;&amp; (NULL == stream)) {
1249     if (has_jrt_entry()) {
1250       e = _jrt_entry;
1251       stream = _jrt_entry-&gt;open_stream(file_name, CHECK_NULL);
1252     } else {
1253       // Exploded build - attempt to locate class in its defining module&#39;s location.
1254       assert(_exploded_entries != NULL, &quot;No exploded build entries present&quot;);
1255       stream = search_module_entries(_exploded_entries, class_name, file_name, CHECK_NULL);
1256     }
1257   }
1258 
1259   // Load Attempt #3: [-Xbootclasspath/a]; [jvmti appended entries]
1260   if (search_append_only &amp;&amp; (NULL == stream)) {
1261     // For the boot loader append path search, the starting classpath_index
1262     // for the appended piece is always 1 to account for either the
1263     // _jrt_entry or the _exploded_entries.
1264     assert(classpath_index == 0, &quot;The classpath_index has been incremented incorrectly&quot;);
1265     classpath_index = 1;
1266 
1267     e = _first_append_entry;
1268     while (e != NULL) {
1269       stream = e-&gt;open_stream(file_name, CHECK_NULL);
1270       if (NULL != stream) {
1271         break;
1272       }
1273       e = e-&gt;next();
1274       ++classpath_index;
1275     }
1276   }
1277 
1278   if (NULL == stream) {
1279     return NULL;
1280   }
1281 
1282   stream-&gt;set_verify(ClassLoaderExt::should_verify(classpath_index));
1283 
1284   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
1285   Handle protection_domain;
1286 
1287   InstanceKlass* result = KlassFactory::create_from_stream(stream,
1288                                                            name,
1289                                                            loader_data,
1290                                                            protection_domain,
1291                                                            NULL, // unsafe_anonymous_host
1292                                                            NULL, // cp_patches
1293                                                            THREAD);
1294   if (HAS_PENDING_EXCEPTION) {
1295     if (DumpSharedSpaces) {
1296       log_error(cds)(&quot;Preload Error: Failed to load %s&quot;, class_name);
1297     }
1298     return NULL;
1299   }
1300 
1301   if (!add_package(result, classpath_index, THREAD)) {
1302     return NULL;
1303   }
1304 
1305   return result;
1306 }
1307 
1308 #if INCLUDE_CDS
1309 char* ClassLoader::skip_uri_protocol(char* source) {
1310   if (strncmp(source, &quot;file:&quot;, 5) == 0) {
1311     // file: protocol path could start with file:/ or file:///
1312     // locate the char after all the forward slashes
1313     int offset = 5;
1314     while (*(source + offset) == &#39;/&#39;) {
1315         offset++;
1316     }
1317     source += offset;
1318   // for non-windows platforms, move back one char as the path begins with a &#39;/&#39;
1319 #ifndef _WINDOWS
1320     source -= 1;
1321 #endif
1322   } else if (strncmp(source, &quot;jrt:/&quot;, 5) == 0) {
1323     source += 5;
1324   }
1325   return source;
1326 }
1327 
1328 // Record the shared classpath index and loader type for classes loaded
1329 // by the builtin loaders at dump time.
1330 void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {
1331   Arguments::assert_is_dumping_archive();
1332   assert(stream != NULL, &quot;sanity&quot;);
1333 
1334   if (ik-&gt;is_unsafe_anonymous()) {
1335     // We do not archive unsafe anonymous classes.
1336     return;
1337   }
1338 
1339   oop loader = ik-&gt;class_loader();
1340   char* src = (char*)stream-&gt;source();
1341   if (src == NULL) {
1342     if (loader == NULL) {
1343       // JFR classes
1344       ik-&gt;set_shared_classpath_index(0);
1345       ik-&gt;set_shared_class_loader_type(ClassLoader::BOOT_LOADER);
1346     }
1347     return;
1348   }
1349 
1350   assert(has_jrt_entry(), &quot;CDS dumping does not support exploded JDK build&quot;);
1351 
1352   ResourceMark rm(THREAD);
1353   int classpath_index = -1;
1354   PackageEntry* pkg_entry = ik-&gt;package();
1355 
1356   if (FileMapInfo::get_number_of_shared_paths() &gt; 0) {
1357     char* canonical_path_table_entry = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, JVM_MAXPATHLEN);
1358 
1359     // save the path from the file: protocol or the module name from the jrt: protocol
1360     // if no protocol prefix is found, path is the same as stream-&gt;source()
1361     char* path = skip_uri_protocol(src);
1362     char* canonical_class_src_path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, JVM_MAXPATHLEN);
1363     bool success = get_canonical_path(path, canonical_class_src_path, JVM_MAXPATHLEN);
1364     // The path is from the ClassFileStream. Since a ClassFileStream has been created successfully in functions
1365     // such as ClassLoader::load_class(), its source path must be valid.
1366     assert(success, &quot;must be valid path&quot;);
1367     for (int i = 0; i &lt; FileMapInfo::get_number_of_shared_paths(); i++) {
1368       SharedClassPathEntry* ent = FileMapInfo::shared_path(i);
1369       success = get_canonical_path(ent-&gt;name(), canonical_path_table_entry, JVM_MAXPATHLEN);
1370       // A shared path has been validated during its creation in ClassLoader::create_class_path_entry(),
1371       // it must be valid here.
1372       assert(success, &quot;must be valid path&quot;);
1373       // If the path (from the class stream source) is the same as the shared
1374       // class or module path, then we have a match.
1375       if (strcmp(canonical_path_table_entry, canonical_class_src_path) == 0) {
1376         // NULL pkg_entry and pkg_entry in an unnamed module implies the class
1377         // is from the -cp or boot loader append path which consists of -Xbootclasspath/a
1378         // and jvmti appended entries.
1379         if ((pkg_entry == NULL) || (pkg_entry-&gt;in_unnamed_module())) {
1380           // Ensure the index is within the -cp range before assigning
1381           // to the classpath_index.
1382           if (SystemDictionary::is_system_class_loader(loader) &amp;&amp;
1383               (i &gt;= ClassLoaderExt::app_class_paths_start_index()) &amp;&amp;
1384               (i &lt; ClassLoaderExt::app_module_paths_start_index())) {
1385             classpath_index = i;
1386             break;
1387           } else {
1388             if ((i &gt;= 1) &amp;&amp;
1389                 (i &lt; ClassLoaderExt::app_class_paths_start_index())) {
1390               // The class must be from boot loader append path which consists of
1391               // -Xbootclasspath/a and jvmti appended entries.
1392               assert(loader == NULL, &quot;sanity&quot;);
1393               classpath_index = i;
1394               break;
1395             }
1396           }
1397         } else {
1398           // A class from a named module from the --module-path. Ensure the index is
1399           // within the --module-path range before assigning to the classpath_index.
1400           if ((pkg_entry != NULL) &amp;&amp; !(pkg_entry-&gt;in_unnamed_module()) &amp;&amp; (i &gt; 0)) {
1401             if (i &gt;= ClassLoaderExt::app_module_paths_start_index() &amp;&amp;
1402                 i &lt; FileMapInfo::get_number_of_shared_paths()) {
1403               classpath_index = i;
1404               break;
1405             }
1406           }
1407         }
1408       }
1409       // for index 0 and the stream-&gt;source() is the modules image or has the jrt: protocol.
1410       // The class must be from the runtime modules image.
1411       if (i == 0 &amp;&amp; (stream-&gt;from_boot_loader_modules_image() || string_starts_with(src, &quot;jrt:&quot;))) {
1412         classpath_index = i;
1413         break;
1414       }
1415     }
1416 
1417     // No path entry found for this class. Must be a shared class loaded by the
1418     // user defined classloader.
1419     if (classpath_index &lt; 0) {
1420       assert(ik-&gt;shared_classpath_index() &lt; 0, &quot;Sanity&quot;);
1421       ik-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);
1422       SystemDictionaryShared::set_shared_class_misc_info(ik, (ClassFileStream*)stream);
1423       return;
1424     }
1425   } else {
1426     // The shared path table is set up after module system initialization.
1427     // The path table contains no entry before that. Any classes loaded prior
1428     // to the setup of the shared path table must be from the modules image.
1429     assert(stream-&gt;from_boot_loader_modules_image(), &quot;stream must be loaded by boot loader from modules image&quot;);
1430     assert(FileMapInfo::get_number_of_shared_paths() == 0, &quot;shared path table must not have been setup&quot;);
1431     classpath_index = 0;
1432   }
1433 
1434   const char* const class_name = ik-&gt;name()-&gt;as_C_string();
1435   const char* const file_name = file_name_for_class_name(class_name,
1436                                                          ik-&gt;name()-&gt;utf8_length());
1437   assert(file_name != NULL, &quot;invariant&quot;);
1438 
1439   ClassLoaderExt::record_result(classpath_index, ik, THREAD);
1440 }
1441 #endif // INCLUDE_CDS
1442 
1443 // Initialize the class loader&#39;s access to methods in libzip.  Parse and
1444 // process the boot classpath into a list ClassPathEntry objects.  Once
1445 // this list has been created, it must not change order (see class PackageInfo)
1446 // it can be appended to and is by jvmti and the kernel vm.
1447 
1448 void ClassLoader::initialize() {
1449   EXCEPTION_MARK;
1450 
1451   if (UsePerfData) {
1452     // jvmstat performance counters
1453     NEWPERFTICKCOUNTER(_perf_accumulated_time, SUN_CLS, &quot;time&quot;);
1454     NEWPERFTICKCOUNTER(_perf_class_init_time, SUN_CLS, &quot;classInitTime&quot;);
1455     NEWPERFTICKCOUNTER(_perf_class_init_selftime, SUN_CLS, &quot;classInitTime.self&quot;);
1456     NEWPERFTICKCOUNTER(_perf_class_verify_time, SUN_CLS, &quot;classVerifyTime&quot;);
1457     NEWPERFTICKCOUNTER(_perf_class_verify_selftime, SUN_CLS, &quot;classVerifyTime.self&quot;);
1458     NEWPERFTICKCOUNTER(_perf_class_link_time, SUN_CLS, &quot;classLinkedTime&quot;);
1459     NEWPERFTICKCOUNTER(_perf_class_link_selftime, SUN_CLS, &quot;classLinkedTime.self&quot;);
1460     NEWPERFEVENTCOUNTER(_perf_classes_inited, SUN_CLS, &quot;initializedClasses&quot;);
1461     NEWPERFEVENTCOUNTER(_perf_classes_linked, SUN_CLS, &quot;linkedClasses&quot;);
1462     NEWPERFEVENTCOUNTER(_perf_classes_verified, SUN_CLS, &quot;verifiedClasses&quot;);
1463 
1464     NEWPERFTICKCOUNTER(_perf_sys_class_lookup_time, SUN_CLS, &quot;lookupSysClassTime&quot;);
1465     NEWPERFTICKCOUNTER(_perf_shared_classload_time, SUN_CLS, &quot;sharedClassLoadTime&quot;);
1466     NEWPERFTICKCOUNTER(_perf_sys_classload_time, SUN_CLS, &quot;sysClassLoadTime&quot;);
1467     NEWPERFTICKCOUNTER(_perf_app_classload_time, SUN_CLS, &quot;appClassLoadTime&quot;);
1468     NEWPERFTICKCOUNTER(_perf_app_classload_selftime, SUN_CLS, &quot;appClassLoadTime.self&quot;);
1469     NEWPERFEVENTCOUNTER(_perf_app_classload_count, SUN_CLS, &quot;appClassLoadCount&quot;);
1470     NEWPERFTICKCOUNTER(_perf_define_appclasses, SUN_CLS, &quot;defineAppClasses&quot;);
1471     NEWPERFTICKCOUNTER(_perf_define_appclass_time, SUN_CLS, &quot;defineAppClassTime&quot;);
1472     NEWPERFTICKCOUNTER(_perf_define_appclass_selftime, SUN_CLS, &quot;defineAppClassTime.self&quot;);
1473     NEWPERFBYTECOUNTER(_perf_app_classfile_bytes_read, SUN_CLS, &quot;appClassBytes&quot;);
1474     NEWPERFBYTECOUNTER(_perf_sys_classfile_bytes_read, SUN_CLS, &quot;sysClassBytes&quot;);
1475 
1476 
1477     // The following performance counters are added for measuring the impact
1478     // of the bug fix of 6365597. They are mainly focused on finding out
1479     // the behavior of system &amp; user-defined classloader lock, whether
1480     // ClassLoader.loadClass/findClass is being called synchronized or not.
1481     NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,
1482                         &quot;systemLoaderLockContentionRate&quot;);
1483     NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,
1484                         &quot;nonSystemLoaderLockContentionRate&quot;);
1485     NEWPERFEVENTCOUNTER(_sync_JVMFindLoadedClassLockFreeCounter, SUN_CLS,
1486                         &quot;jvmFindLoadedClassNoLockCalls&quot;);
1487     NEWPERFEVENTCOUNTER(_sync_JVMDefineClassLockFreeCounter, SUN_CLS,
1488                         &quot;jvmDefineClassNoLockCalls&quot;);
1489 
1490     NEWPERFEVENTCOUNTER(_sync_JNIDefineClassLockFreeCounter, SUN_CLS,
1491                         &quot;jniDefineClassNoLockCalls&quot;);
1492 
1493     NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,
1494                         &quot;unsafeDefineClassCalls&quot;);
1495   }
1496 
1497   // lookup java library entry points
1498   load_java_library();
1499   // lookup zip library entry points
1500   load_zip_library();
1501   // jimage library entry points are loaded below, in lookup_vm_options
1502   setup_bootstrap_search_path();
1503 }
1504 
1505 char* lookup_vm_resource(JImageFile *jimage, const char *jimage_version, const char *path) {
1506   jlong size;
1507   JImageLocationRef location = (*JImageFindResource)(jimage, &quot;java.base&quot;, jimage_version, path, &amp;size);
1508   if (location == 0)
1509     return NULL;
1510   char *val = NEW_C_HEAP_ARRAY(char, size+1, mtClass);
1511   (*JImageGetResource)(jimage, location, val, size);
1512   val[size] = &#39;\0&#39;;
1513   return val;
1514 }
1515 
1516 // Lookup VM options embedded in the modules jimage file
1517 char* ClassLoader::lookup_vm_options() {
1518   jint error;
1519   char modules_path[JVM_MAXPATHLEN];
1520   const char* fileSep = os::file_separator();
1521 
1522   // Initialize jimage library entry points
1523   load_jimage_library();
1524 
1525   jio_snprintf(modules_path, JVM_MAXPATHLEN, &quot;%s%slib%smodules&quot;, Arguments::get_java_home(), fileSep, fileSep);
1526   JImageFile* jimage =(*JImageOpen)(modules_path, &amp;error);
1527   if (jimage == NULL) {
1528     return NULL;
1529   }
1530 
1531   const char *jimage_version = get_jimage_version_string();
1532   char *options = lookup_vm_resource(jimage, jimage_version, &quot;jdk/internal/vm/options&quot;);
1533 
1534   (*JImageClose)(jimage);
1535   return options;
1536 }
1537 
1538 #if INCLUDE_CDS
1539 void ClassLoader::initialize_shared_path() {
1540   if (Arguments::is_dumping_archive()) {
1541     ClassLoaderExt::setup_search_paths();
1542   }
1543 }
1544 
1545 void ClassLoader::initialize_module_path(TRAPS) {
1546   if (Arguments::is_dumping_archive()) {
1547     ClassLoaderExt::setup_module_paths(THREAD);
1548     FileMapInfo::allocate_shared_path_table();
1549   }
1550 }
1551 #endif
1552 
1553 jlong ClassLoader::classloader_time_ms() {
1554   return UsePerfData ?
1555     Management::ticks_to_ms(_perf_accumulated_time-&gt;get_value()) : -1;
1556 }
1557 
1558 jlong ClassLoader::class_init_count() {
1559   return UsePerfData ? _perf_classes_inited-&gt;get_value() : -1;
1560 }
1561 
1562 jlong ClassLoader::class_init_time_ms() {
1563   return UsePerfData ?
1564     Management::ticks_to_ms(_perf_class_init_time-&gt;get_value()) : -1;
1565 }
1566 
1567 jlong ClassLoader::class_verify_time_ms() {
1568   return UsePerfData ?
1569     Management::ticks_to_ms(_perf_class_verify_time-&gt;get_value()) : -1;
1570 }
1571 
1572 jlong ClassLoader::class_link_count() {
1573   return UsePerfData ? _perf_classes_linked-&gt;get_value() : -1;
1574 }
1575 
1576 jlong ClassLoader::class_link_time_ms() {
1577   return UsePerfData ?
1578     Management::ticks_to_ms(_perf_class_link_time-&gt;get_value()) : -1;
1579 }
1580 
1581 int ClassLoader::compute_Object_vtable() {
1582   // hardwired for JDK1.2 -- would need to duplicate class file parsing
1583   // code to determine actual value from file
1584   // Would be value &#39;11&#39; if finals were in vtable
1585   int JDK_1_2_Object_vtable_size = 5;
1586   return JDK_1_2_Object_vtable_size * vtableEntry::size();
1587 }
1588 
1589 
1590 void classLoader_init1() {
1591   ClassLoader::initialize();
1592 }
1593 
1594 // Complete the ClassPathEntry setup for the boot loader
1595 void ClassLoader::classLoader_init2(TRAPS) {
1596   // Setup the list of module/path pairs for --patch-module processing
1597   // This must be done after the SymbolTable is created in order
1598   // to use fast_compare on module names instead of a string compare.
1599   if (Arguments::get_patch_mod_prefix() != NULL) {
1600     setup_patch_mod_entries();
1601   }
1602 
1603   // Create the ModuleEntry for java.base (must occur after setup_patch_mod_entries
1604   // to successfully determine if java.base has been patched)
1605   create_javabase();
1606 
1607   // Setup the initial java.base/path pair for the exploded build entries.
1608   // As more modules are defined during module system initialization, more
1609   // entries will be added to the exploded build array.
1610   if (!has_jrt_entry()) {
1611     assert(!DumpSharedSpaces, &quot;DumpSharedSpaces not supported with exploded module builds&quot;);
1612     assert(!DynamicDumpSharedSpaces, &quot;DynamicDumpSharedSpaces not supported with exploded module builds&quot;);
1613     assert(!UseSharedSpaces, &quot;UsedSharedSpaces not supported with exploded module builds&quot;);
1614     // Set up the boot loader&#39;s _exploded_entries list.  Note that this gets
1615     // done before loading any classes, by the same thread that will
1616     // subsequently do the first class load. So, no lock is needed for this.
1617     assert(_exploded_entries == NULL, &quot;Should only get initialized once&quot;);
1618     _exploded_entries = new (ResourceObj::C_HEAP, mtModule)
1619       GrowableArray&lt;ModuleClassPathList*&gt;(EXPLODED_ENTRY_SIZE, true);
1620     add_to_exploded_build_list(vmSymbols::java_base(), CHECK);
1621   }
1622 }
1623 
1624 bool ClassLoader::get_canonical_path(const char* orig, char* out, int len) {
1625   assert(orig != NULL &amp;&amp; out != NULL &amp;&amp; len &gt; 0, &quot;bad arguments&quot;);
1626   JavaThread* THREAD = JavaThread::current();
1627   ResourceMark rm(THREAD);
1628 
1629   // os::native_path writes into orig_copy
1630   char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(orig)+1);
1631   strcpy(orig_copy, orig);
1632   if ((CanonicalizeEntry)(os::native_path(orig_copy), out, len) &lt; 0) {
1633     return false;
1634   }
1635   return true;
1636 }
1637 
1638 void ClassLoader::create_javabase() {
1639   Thread* THREAD = Thread::current();
1640 
1641   // Create java.base&#39;s module entry for the boot
1642   // class loader prior to loading j.l.Ojbect.
1643   ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
1644 
1645   // Get module entry table
1646   ModuleEntryTable* null_cld_modules = null_cld-&gt;modules();
1647   if (null_cld_modules == NULL) {
1648     vm_exit_during_initialization(&quot;No ModuleEntryTable for the boot class loader&quot;);
1649   }
1650 
1651   {
1652     MutexLocker ml(THREAD, Module_lock);
1653     ModuleEntry* jb_module = null_cld_modules-&gt;locked_create_entry(Handle(),
1654                                false, vmSymbols::java_base(), NULL, NULL, null_cld);
1655     if (jb_module == NULL) {
1656       vm_exit_during_initialization(&quot;Unable to create ModuleEntry for &quot; JAVA_BASE_NAME);
1657     }
1658     ModuleEntryTable::set_javabase_moduleEntry(jb_module);
1659   }
1660 }
1661 
1662 // Please keep following two functions at end of this file. With them placed at top or in middle of the file,
1663 // they could get inlined by agressive compiler, an unknown trick, see bug 6966589.
1664 void PerfClassTraceTime::initialize() {
1665   if (!UsePerfData) return;
1666 
1667   if (_eventp != NULL) {
1668     // increment the event counter
1669     _eventp-&gt;inc();
1670   }
1671 
1672   // stop the current active thread-local timer to measure inclusive time
1673   _prev_active_event = -1;
1674   for (int i=0; i &lt; EVENT_TYPE_COUNT; i++) {
1675      if (_timers[i].is_active()) {
1676        assert(_prev_active_event == -1, &quot;should have only one active timer&quot;);
1677        _prev_active_event = i;
1678        _timers[i].stop();
1679      }
1680   }
1681 
1682   if (_recursion_counters == NULL || (_recursion_counters[_event_type])++ == 0) {
1683     // start the inclusive timer if not recursively called
1684     _t.start();
1685   }
1686 
1687   // start thread-local timer of the given event type
1688    if (!_timers[_event_type].is_active()) {
1689     _timers[_event_type].start();
1690   }
1691 }
1692 
1693 PerfClassTraceTime::~PerfClassTraceTime() {
1694   if (!UsePerfData) return;
1695 
1696   // stop the thread-local timer as the event completes
1697   // and resume the thread-local timer of the event next on the stack
1698   _timers[_event_type].stop();
1699   jlong selftime = _timers[_event_type].ticks();
1700 
1701   if (_prev_active_event &gt;= 0) {
1702     _timers[_prev_active_event].start();
1703   }
1704 
1705   if (_recursion_counters != NULL &amp;&amp; --(_recursion_counters[_event_type]) &gt; 0) return;
1706 
1707   // increment the counters only on the leaf call
1708   _t.stop();
1709   _timep-&gt;inc(_t.ticks());
1710   if (_selftimep != NULL) {
1711     _selftimep-&gt;inc(selftime);
1712   }
1713   // add all class loading related event selftime to the accumulated time counter
1714   ClassLoader::perf_accumulated_time()-&gt;inc(selftime);
1715 
1716   // reset the timer
1717   _timers[_event_type].reset();
1718 }
    </pre>
  </body>
</html>
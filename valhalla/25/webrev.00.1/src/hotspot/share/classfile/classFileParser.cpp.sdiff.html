<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../c1/c1_LIRAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */

  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/packageEntry.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/verificationType.hpp&quot;
  40 #include &quot;classfile/verifier.hpp&quot;
  41 #include &quot;classfile/vmSymbols.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/annotations.hpp&quot;
  50 #include &quot;oops/constantPool.inline.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  54 #include &quot;oops/klass.inline.hpp&quot;
  55 #include &quot;oops/klassVtable.hpp&quot;
  56 #include &quot;oops/metadata.hpp&quot;
  57 #include &quot;oops/method.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/recordComponent.hpp&quot;
  60 #include &quot;oops/symbol.hpp&quot;

  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/os.hpp&quot;
  68 #include &quot;runtime/perfData.hpp&quot;
  69 #include &quot;runtime/reflection.hpp&quot;
  70 #include &quot;runtime/safepointVerifiers.hpp&quot;
  71 #include &quot;runtime/signature.hpp&quot;
  72 #include &quot;runtime/timer.hpp&quot;
  73 #include &quot;services/classLoadingService.hpp&quot;
  74 #include &quot;services/threadService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/bitMap.inline.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/exceptions.hpp&quot;
  79 #include &quot;utilities/globalDefinitions.hpp&quot;
  80 #include &quot;utilities/growableArray.hpp&quot;
  81 #include &quot;utilities/macros.hpp&quot;
  82 #include &quot;utilities/ostream.hpp&quot;
  83 #include &quot;utilities/resourceHash.hpp&quot;

  84 #include &quot;utilities/utf8.hpp&quot;
  85 
  86 #if INCLUDE_CDS
  87 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  88 #endif
  89 #if INCLUDE_JFR
  90 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  91 #endif
  92 
  93 // We generally try to create the oops directly when parsing, rather than
  94 // allocating temporary data structures and copying the bytes twice. A
  95 // temporary area is only needed when parsing utf8 entries in the constant
  96 // pool and when parsing line number tables.
  97 
  98 // We add assert in debug mode when class format is not checked.
  99 
 100 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 101 #define JAVA_MIN_SUPPORTED_VERSION        45
 102 #define JAVA_PREVIEW_MINOR_VERSION        65535
 103 
</pre>
<hr />
<pre>
 115 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 116 #define JAVA_7_VERSION                    51
 117 
 118 // Extension method support.
 119 #define JAVA_8_VERSION                    52
 120 
 121 #define JAVA_9_VERSION                    53
 122 
 123 #define JAVA_10_VERSION                   54
 124 
 125 #define JAVA_11_VERSION                   55
 126 
 127 #define JAVA_12_VERSION                   56
 128 
 129 #define JAVA_13_VERSION                   57
 130 
 131 #define JAVA_14_VERSION                   58
 132 
 133 #define JAVA_15_VERSION                   59
 134 


 135 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 136   assert((bad_constant == JVM_CONSTANT_Module ||
 137           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 138          &quot;Unexpected bad constant pool entry&quot;);
 139   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 140 }
 141 
 142 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 143                                                   ConstantPool* cp,
 144                                                   const int length,
 145                                                   TRAPS) {
 146   assert(stream != NULL, &quot;invariant&quot;);
 147   assert(cp != NULL, &quot;invariant&quot;);
 148 
 149   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 150   // this function (_current can be allocated in a register, with scalar
 151   // replacement of aggregates). The _current pointer is copied back to
 152   // stream() when this function returns. DON&#39;T call another method within
 153   // this method that uses stream().
 154   const ClassFileStream cfs1 = *stream;
 155   const ClassFileStream* const cfs = &amp;cfs1;
 156 
 157   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 158   debug_only(const u1* const old_current = stream-&gt;current();)
 159 
 160   // Used for batching symbol allocations.
 161   const char* names[SymbolTable::symbol_alloc_batch_size];
 162   int lengths[SymbolTable::symbol_alloc_batch_size];
 163   int indices[SymbolTable::symbol_alloc_batch_size];
 164   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 165   int names_count = 0;
 166 
 167   // parsing  Index 0 is unused
 168   for (int index = 1; index &lt; length; index++) {
 169     // Each of the following case guarantees one more byte in the stream
 170     // for the following tag or the access_flags following constant pool,
 171     // so we don&#39;t need bounds-check for reading tag.
 172     const u1 tag = cfs-&gt;get_u1_fast();
 173     switch (tag) {
<span class="line-modified"> 174       case JVM_CONSTANT_Class : {</span>
 175         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 176         const u2 name_index = cfs-&gt;get_u2_fast();
 177         cp-&gt;klass_index_at_put(index, name_index);
 178         break;
 179       }
 180       case JVM_CONSTANT_Fieldref: {
 181         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 182         const u2 class_index = cfs-&gt;get_u2_fast();
 183         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 184         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 185         break;
 186       }
 187       case JVM_CONSTANT_Methodref: {
 188         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 189         const u2 class_index = cfs-&gt;get_u2_fast();
 190         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 191         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 192         break;
 193       }
 194       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 484         check_property(valid_symbol_at(name_ref_index),
 485           &quot;Invalid constant pool index %u in class file %s&quot;,
 486           name_ref_index, CHECK);
 487         check_property(valid_symbol_at(signature_ref_index),
 488           &quot;Invalid constant pool index %u in class file %s&quot;,
 489           signature_ref_index, CHECK);
 490         break;
 491       }
 492       case JVM_CONSTANT_Utf8:
 493         break;
 494       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 495       case JVM_CONSTANT_UnresolvedClassInError: {
 496         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 497         break;
 498       }
 499       case JVM_CONSTANT_ClassIndex: {
 500         const int class_index = cp-&gt;klass_index_at(index);
 501         check_property(valid_symbol_at(class_index),
 502           &quot;Invalid constant pool index %u in class file %s&quot;,
 503           class_index, CHECK);
<span class="line-modified"> 504         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>







 505         break;
 506       }
 507       case JVM_CONSTANT_StringIndex: {
 508         const int string_index = cp-&gt;string_index_at(index);
 509         check_property(valid_symbol_at(string_index),
 510           &quot;Invalid constant pool index %u in class file %s&quot;,
 511           string_index, CHECK);
 512         Symbol* const sym = cp-&gt;symbol_at(string_index);
 513         cp-&gt;unresolved_string_at_put(index, sym);
 514         break;
 515       }
 516       case JVM_CONSTANT_MethodHandle: {
 517         const int ref_index = cp-&gt;method_handle_index_at(index);
 518         check_property(valid_cp_range(ref_index, length),
 519           &quot;Invalid constant pool index %u in class file %s&quot;,
 520           ref_index, CHECK);
 521         const constantTag tag = cp-&gt;tag_at(ref_index);
 522         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 523 
 524         switch (ref_kind) {
</pre>
<hr />
<pre>
 738             classfile_parse_error(
 739               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 740               name_ref_index, CHECK);
 741           }
 742         }
 743         break;
 744       }
 745       case JVM_CONSTANT_MethodHandle: {
 746         const int ref_index = cp-&gt;method_handle_index_at(index);
 747         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 748         switch (ref_kind) {
 749           case JVM_REF_invokeVirtual:
 750           case JVM_REF_invokeStatic:
 751           case JVM_REF_invokeSpecial:
 752           case JVM_REF_newInvokeSpecial: {
 753             const int name_and_type_ref_index =
 754               cp-&gt;name_and_type_ref_index_at(ref_index);
 755             const int name_ref_index =
 756               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 757             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 758             if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-modified"> 759               if (name != vmSymbols::object_initializer_name()) {</span>
 760                 classfile_parse_error(
 761                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 762                     name_ref_index, CHECK);
 763               }
 764             } else {
<span class="line-modified"> 765               if (name == vmSymbols::object_initializer_name()) {</span>











 766                 classfile_parse_error(
 767                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 768                   name_ref_index, CHECK);
 769               }
 770             }
 771             break;
 772           }
 773           // Other ref_kinds are already fully checked in previous pass.
 774         } // switch(ref_kind)
 775         break;
 776       }
 777       case JVM_CONSTANT_MethodType: {
 778         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 779         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 780         verify_legal_method_signature(no_name, signature, CHECK);
 781         break;
 782       }
 783       case JVM_CONSTANT_Utf8: {
 784         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 785       }
</pre>
<hr />
<pre>
 904   while (entry != NULL) {
 905     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 906       return false;
 907     }
 908     entry = entry-&gt;_next;
 909   }
 910 
 911   // No duplicate is found, allocate a new entry and fill it.
 912   entry = new NameSigHash();
 913   entry-&gt;_name = name;
 914   entry-&gt;_sig = sig;
 915 
 916   // Insert into hash table
 917   entry-&gt;_next = table[index];
 918   table[index] = entry;
 919 
 920   return true;
 921 }
 922 
 923 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 924 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified"> 925                                        const int itfs_len,</span>
<span class="line-modified"> 926                                        ConstantPool* const cp,</span>
 927                                        bool* const has_nonstatic_concrete_methods,







 928                                        TRAPS) {
 929   assert(stream != NULL, &quot;invariant&quot;);
 930   assert(cp != NULL, &quot;invariant&quot;);
 931   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 932 
 933   if (itfs_len == 0) {
 934     _local_interfaces = Universe::the_empty_instance_klass_array();
 935   } else {
 936     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 937     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
 938 
 939     int index;
 940     for (index = 0; index &lt; itfs_len; index++) {
 941       const u2 interface_index = stream-&gt;get_u2(CHECK);
 942       Klass* interf;
 943       check_property(
 944         valid_klass_reference_at(interface_index),
 945         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 946         interface_index, CHECK);
 947       if (cp-&gt;tag_at(interface_index).is_klass()) {
</pre>
<hr />
<pre>
 955                            &quot;Bad interface name in class file %s&quot;, CHECK);
 956 
 957         // Call resolve_super so classcircularity is checked
 958         interf = SystemDictionary::resolve_super_or_fail(
 959                                                   _class_name,
 960                                                   unresolved_klass,
 961                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 962                                                   _protection_domain,
 963                                                   false,
 964                                                   CHECK);
 965       }
 966 
 967       if (!interf-&gt;is_interface()) {
 968         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 969                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 970                           _class_name-&gt;as_klass_external_name(),
 971                           interf-&gt;external_name(),
 972                           interf-&gt;class_in_module_of_loader()));
 973       }
 974 
<span class="line-modified"> 975       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>

 976         *has_nonstatic_concrete_methods = true;
 977       }
<span class="line-modified"> 978       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>



 979     }
 980 
 981     if (!_need_verify || itfs_len &lt;= 1) {
 982       return;
 983     }
 984 
 985     // Check if there&#39;s any duplicates in interfaces
 986     ResourceMark rm(THREAD);
 987     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 988                                                                  NameSigHash*,
 989                                                                  HASH_ROW_SIZE);
 990     initialize_hashtable(interface_names);
 991     bool dup = false;
 992     const Symbol* name = NULL;
 993     {
 994       debug_only(NoSafepointVerifier nsv;)
 995       for (index = 0; index &lt; itfs_len; index++) {
 996         const InstanceKlass* const k = _local_interfaces-&gt;at(index);
 997         name = k-&gt;name();
 998         // If no duplicates, add (name, NULL) in hashtable interface_names.
</pre>
<hr />
<pre>
1450                                             CHECK);
1451   parsed_annotations-&gt;set_field_annotations(a);
1452   a = assemble_annotations(runtime_visible_type_annotations,
1453                            runtime_visible_type_annotations_length,
1454                            runtime_invisible_type_annotations,
1455                            runtime_invisible_type_annotations_length,
1456                            CHECK);
1457   parsed_annotations-&gt;set_field_type_annotations(a);
1458   return;
1459 }
1460 
1461 
1462 // Field allocation types. Used for computing field offsets.
1463 
1464 enum FieldAllocationType {
1465   STATIC_OOP,           // Oops
1466   STATIC_BYTE,          // Boolean, Byte, char
1467   STATIC_SHORT,         // shorts
1468   STATIC_WORD,          // ints
1469   STATIC_DOUBLE,        // aligned long or double

1470   NONSTATIC_OOP,
1471   NONSTATIC_BYTE,
1472   NONSTATIC_SHORT,
1473   NONSTATIC_WORD,
1474   NONSTATIC_DOUBLE,

1475   MAX_FIELD_ALLOCATION_TYPE,
1476   BAD_ALLOCATION_TYPE = -1
1477 };
1478 
1479 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1480   BAD_ALLOCATION_TYPE, // 0
1481   BAD_ALLOCATION_TYPE, // 1
1482   BAD_ALLOCATION_TYPE, // 2
1483   BAD_ALLOCATION_TYPE, // 3
1484   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1485   NONSTATIC_SHORT,     // T_CHAR        =  5,
1486   NONSTATIC_WORD,      // T_FLOAT       =  6,
1487   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1488   NONSTATIC_BYTE,      // T_BYTE        =  8,
1489   NONSTATIC_SHORT,     // T_SHORT       =  9,
1490   NONSTATIC_WORD,      // T_INT         = 10,
1491   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1492   NONSTATIC_OOP,       // T_OBJECT      = 12,
1493   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1494   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1495   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1496   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1497   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1498   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1499   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1500   BAD_ALLOCATION_TYPE, // 0
1501   BAD_ALLOCATION_TYPE, // 1
1502   BAD_ALLOCATION_TYPE, // 2
1503   BAD_ALLOCATION_TYPE, // 3
1504   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1505   STATIC_SHORT,        // T_CHAR        =  5,
1506   STATIC_WORD,         // T_FLOAT       =  6,
1507   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1508   STATIC_BYTE,         // T_BYTE        =  8,
1509   STATIC_SHORT,        // T_SHORT       =  9,
1510   STATIC_WORD,         // T_INT         = 10,
1511   STATIC_DOUBLE,       // T_LONG        = 11,
1512   STATIC_OOP,          // T_OBJECT      = 12,
1513   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1514   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1515   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1516   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1517   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1518   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1519   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1520 };
1521 
<span class="line-modified">1522 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {</span>
1523   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1524   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1525   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);



1526   return result;
1527 }
1528 
1529 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1530  public:
1531   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1532 
1533   FieldAllocationCount() {
1534     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1535       count[i] = 0;
1536     }
1537   }
1538 
<span class="line-modified">1539   FieldAllocationType update(bool is_static, BasicType type) {</span>
<span class="line-modified">1540     FieldAllocationType atype = basic_type_to_atype(is_static, type);</span>
1541     if (atype != BAD_ALLOCATION_TYPE) {
1542       // Make sure there is no overflow with injected fields.
1543       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1544       count[atype]++;
1545     }
1546     return atype;
1547   }
1548 };
1549 
1550 // Side-effects: populates the _fields, _fields_annotations,
1551 // _fields_type_annotations fields
1552 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1553                                    bool is_interface,

1554                                    FieldAllocationCount* const fac,
1555                                    ConstantPool* cp,
1556                                    const int cp_size,
1557                                    u2* const java_fields_count_ptr,
1558                                    TRAPS) {
1559 
1560   assert(cfs != NULL, &quot;invariant&quot;);
1561   assert(fac != NULL, &quot;invariant&quot;);
1562   assert(cp != NULL, &quot;invariant&quot;);
1563   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1564 
1565   assert(NULL == _fields, &quot;invariant&quot;);
1566   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1567   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1568 
1569   cfs-&gt;guarantee_more(2, CHECK);  // length
1570   const u2 length = cfs-&gt;get_u2_fast();
1571   *java_fields_count_ptr = length;
1572 
1573   int num_injected = 0;
1574   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1575                                                                   &amp;num_injected);
<span class="line-modified">1576   const int total_fields = length + num_injected;</span>




1577 
1578   // The field array starts with tuples of shorts
1579   // [access, name index, sig index, initial value index, byte offset].
1580   // A generic signature slot only exists for field with generic
1581   // signature attribute. And the access flag is set with
1582   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1583   // signature slots are at the end of the field array and after all
1584   // other fields data.
1585   //
1586   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1587   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1588   //       ...
1589   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1590   //       [generic signature index]
1591   //       [generic signature index]
1592   //       ...
1593   //
1594   // Allocate a temporary resource array for field data. For each field,
1595   // a slot is reserved in the temporary array for the generic signature
1596   // index. After parsing all fields, the data are copied to a permanent
1597   // array and any unused slots will be discarded.
1598   ResourceMark rm(THREAD);
1599   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1600                                               u2,
1601                                               total_fields * (FieldInfo::field_slots + 1));
1602 
1603   // The generic signature slots start after all other fields&#39; data.
1604   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1605   int num_generic_signature = 0;

1606   for (int n = 0; n &lt; length; n++) {
1607     // access_flags, name_index, descriptor_index, attributes_count
1608     cfs-&gt;guarantee_more(8, CHECK);
1609 




1610     AccessFlags access_flags;
<span class="line-removed">1611     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-removed">1612     verify_legal_field_modifiers(flags, is_interface, CHECK);</span>
1613     access_flags.set_flags(flags);
1614 
1615     const u2 name_index = cfs-&gt;get_u2_fast();
1616     check_property(valid_symbol_at(name_index),
1617       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1618       name_index, CHECK);
1619     const Symbol* const name = cp-&gt;symbol_at(name_index);
1620     verify_legal_field_name(name, CHECK);
1621 
1622     const u2 signature_index = cfs-&gt;get_u2_fast();
1623     check_property(valid_symbol_at(signature_index),
1624       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1625       signature_index, CHECK);
1626     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1627     verify_legal_field_signature(name, sig, CHECK);

















1628 
1629     u2 constantvalue_index = 0;
1630     bool is_synthetic = false;
1631     u2 generic_signature_index = 0;
1632     const bool is_static = access_flags.is_static();
1633     FieldAnnotationCollector parsed_annotations(_loader_data);
1634 
1635     const u2 attributes_count = cfs-&gt;get_u2_fast();
1636     if (attributes_count &gt; 0) {
1637       parse_field_attributes(cfs,
1638                              attributes_count,
1639                              is_static,
1640                              signature_index,
1641                              &amp;constantvalue_index,
1642                              &amp;is_synthetic,
1643                              &amp;generic_signature_index,
1644                              &amp;parsed_annotations,
1645                              CHECK);
1646 
1647       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1667 
1668       if (is_synthetic) {
1669         access_flags.set_is_synthetic();
1670       }
1671       if (generic_signature_index != 0) {
1672         access_flags.set_field_has_generic_signature();
1673         fa[generic_signature_slot] = generic_signature_index;
1674         generic_signature_slot ++;
1675         num_generic_signature ++;
1676       }
1677     }
1678 
1679     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1680     field-&gt;initialize(access_flags.as_short(),
1681                       name_index,
1682                       signature_index,
1683                       constantvalue_index);
1684     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1685 
1686     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1687     const FieldAllocationType atype = fac-&gt;update(is_static, type);</span>
1688     field-&gt;set_allocation_type(atype);
1689 
1690     // After field is initialized with type, we can augment it with aux info
1691     if (parsed_annotations.has_any_annotations()) {
1692       parsed_annotations.apply_to(field);
1693       if (field-&gt;is_contended()) {
1694         _has_contended_fields = true;
1695       }
1696     }
1697   }
1698 
1699   int index = length;
1700   if (num_injected != 0) {
1701     for (int n = 0; n &lt; num_injected; n++) {
1702       // Check for duplicates
1703       if (injected[n].may_be_java) {
1704         const Symbol* const name      = injected[n].name();
1705         const Symbol* const signature = injected[n].signature();
1706         bool duplicate = false;
1707         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1712             duplicate = true;
1713             break;
1714           }
1715         }
1716         if (duplicate) {
1717           // These will be removed from the field array at the end
1718           continue;
1719         }
1720       }
1721 
1722       // Injected field
1723       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1724       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1725                         injected[n].name_index,
1726                         injected[n].signature_index,
1727                         0);
1728 
1729       const BasicType type = Signature::basic_type(injected[n].signature());
1730 
1731       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1732       const FieldAllocationType atype = fac-&gt;update(false, type);</span>
1733       field-&gt;set_allocation_type(atype);
1734       index++;
1735     }
1736   }
1737 

























1738   assert(NULL == _fields, &quot;invariant&quot;);
1739 
1740   _fields =
1741     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1742                                    index * FieldInfo::field_slots + num_generic_signature,
1743                                    CHECK);
1744   // Sometimes injected fields already exist in the Java source so
1745   // the fields array could be too long.  In that case the
1746   // fields array is trimed. Also unused slots that were reserved
1747   // for generic signature indexes are discarded.
1748   {
1749     int i = 0;
1750     for (; i &lt; index * FieldInfo::field_slots; i++) {
1751       _fields-&gt;at_put(i, fa[i]);
1752     }
1753     for (int j = total_fields * FieldInfo::field_slots;
1754          j &lt; generic_signature_slot; j++) {
1755       _fields-&gt;at_put(i++, fa[j]);
1756     }
1757     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2033         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2034         checked_exception, CHECK_NULL);
2035     }
2036   }
2037   // check exceptions attribute length
2038   if (_need_verify) {
2039     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2040                                                    sizeof(u2) * size),
2041                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2042   }
2043   return checked_exceptions_start;
2044 }
2045 
2046 void ClassFileParser::throwIllegalSignature(const char* type,
2047                                             const Symbol* name,
2048                                             const Symbol* sig,
2049                                             TRAPS) const {
2050   assert(name != NULL, &quot;invariant&quot;);
2051   assert(sig != NULL, &quot;invariant&quot;);
2052 





2053   ResourceMark rm(THREAD);
2054   Exceptions::fthrow(THREAD_AND_LOCATION,
2055       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2056       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2057       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());</span>
2058 }
2059 
2060 AnnotationCollector::ID
2061 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2062                                       const Symbol* name) {
2063   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2064   // Privileged code can use all annotations.  Other code silently drops some.
2065   const bool privileged = loader_data-&gt;is_the_null_class_loader_data() ||
2066                           loader_data-&gt;is_platform_class_loader_data() ||
2067                           loader_data-&gt;is_unsafe_anonymous();
2068   switch (sid) {
2069     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2070       if (_location != _in_method)  break;  // only allow for methods
2071       if (!privileged)              break;  // only allow in privileged code
2072       return _method_CallerSensitive;
2073     }
2074     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2075       if (_location != _in_method)  break;  // only allow for methods
2076       if (!privileged)              break;  // only allow in privileged code
2077       return _method_ForceInline;
</pre>
<hr />
<pre>
2301                              runtime_visible_type_annotations_length,
2302                              runtime_invisible_type_annotations,
2303                              runtime_invisible_type_annotations_length,
2304                              CHECK);
2305     cm-&gt;set_type_annotations(a);
2306   }
2307 }
2308 
2309 
2310 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2311 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2312 // Method* to save footprint, so we only know the size of the resulting Method* when the
2313 // entire method attribute is parsed.
2314 //
2315 // The promoted_flags parameter is used to pass relevant access_flags
2316 // from the method back up to the containing klass. These flag values
2317 // are added to klass&#39;s access_flags.
2318 
2319 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2320                                       bool is_interface,

2321                                       const ConstantPool* cp,
2322                                       AccessFlags* const promoted_flags,
2323                                       TRAPS) {
2324   assert(cfs != NULL, &quot;invariant&quot;);
2325   assert(cp != NULL, &quot;invariant&quot;);
2326   assert(promoted_flags != NULL, &quot;invariant&quot;);
2327 
2328   ResourceMark rm(THREAD);
2329   // Parse fixed parts:
2330   // access_flags, name_index, descriptor_index, attributes_count
2331   cfs-&gt;guarantee_more(8, CHECK_NULL);
2332 
2333   int flags = cfs-&gt;get_u2_fast();
2334   const u2 name_index = cfs-&gt;get_u2_fast();
2335   const int cp_size = cp-&gt;length();
2336   check_property(
2337     valid_symbol_at(name_index),
2338     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2339     name_index, CHECK_NULL);
2340   const Symbol* const name = cp-&gt;symbol_at(name_index);
2341   verify_legal_method_name(name, CHECK_NULL);
2342 
2343   const u2 signature_index = cfs-&gt;get_u2_fast();
2344   guarantee_property(
2345     valid_symbol_at(signature_index),
2346     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2347     signature_index, CHECK_NULL);
2348   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2349 
2350   if (name == vmSymbols::class_initializer_name()) {
2351     // We ignore the other access flags for a valid class initializer.
2352     // (JVM Spec 2nd ed., chapter 4.6)
2353     if (_major_version &lt; 51) { // backward compatibility
2354       flags = JVM_ACC_STATIC;
2355     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2356       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2357     } else {
2358       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2359     }
2360   } else {
<span class="line-modified">2361     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);</span>
<span class="line-modified">2362   }</span>
<span class="line-modified">2363 </span>
<span class="line-modified">2364   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {</span>
<span class="line-modified">2365     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>










































2366   }
2367 
2368   int args_size = -1;  // only used when _need_verify is true
2369   if (_need_verify) {
2370     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2371                  verify_legal_method_signature(name, signature, CHECK_NULL);
2372     if (args_size &gt; MAX_ARGS_SIZE) {
2373       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2374     }
2375   }
2376 
2377   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2378 
2379   // Default values for code and exceptions attribute elements
2380   u2 max_stack = 0;
2381   u2 max_locals = 0;
2382   u4 code_length = 0;
2383   const u1* code_start = 0;
2384   u2 exception_table_length = 0;
2385   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
2891       _has_finalizer = true;
2892     }
2893   }
2894   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2895       signature == vmSymbols::void_method_signature() &amp;&amp;
2896       m-&gt;is_vanilla_constructor()) {
2897     _has_vanilla_constructor = true;
2898   }
2899 
2900   NOT_PRODUCT(m-&gt;verify());
2901   return m;
2902 }
2903 
2904 
2905 // The promoted_flags parameter is used to pass relevant access_flags
2906 // from the methods back up to the containing klass. These flag values
2907 // are added to klass&#39;s access_flags.
2908 // Side-effects: populates the _methods field in the parser
2909 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2910                                     bool is_interface,

2911                                     AccessFlags* promoted_flags,
2912                                     bool* has_final_method,
2913                                     bool* declares_nonstatic_concrete_methods,
2914                                     TRAPS) {
2915   assert(cfs != NULL, &quot;invariant&quot;);
2916   assert(promoted_flags != NULL, &quot;invariant&quot;);
2917   assert(has_final_method != NULL, &quot;invariant&quot;);
2918   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2919 
2920   assert(NULL == _methods, &quot;invariant&quot;);
2921 
2922   cfs-&gt;guarantee_more(2, CHECK);  // length
2923   const u2 length = cfs-&gt;get_u2_fast();
2924   if (length == 0) {
2925     _methods = Universe::the_empty_method_array();
2926   } else {
2927     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2928                                                    length,
2929                                                    NULL,
2930                                                    CHECK);
2931 
2932     for (int index = 0; index &lt; length; index++) {
2933       Method* method = parse_method(cfs,
2934                                     is_interface,

2935                                     _cp,
2936                                     promoted_flags,
2937                                     CHECK);
2938 
2939       if (method-&gt;is_final()) {
2940         *has_final_method = true;
2941       }
2942       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2943       // used for interface initialization, and default method inheritance analysis
2944       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2945         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2946         *declares_nonstatic_concrete_methods = true;
2947       }
2948       _methods-&gt;at_put(index, method);
2949     }
2950 
2951     if (_need_verify &amp;&amp; length &gt; 1) {
2952       // Check duplicated methods
2953       ResourceMark rm(THREAD);
2954       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3107       valid_klass_reference_at(inner_class_info_index),
3108       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3109       inner_class_info_index, CHECK_0);
3110     // Outer class index
3111     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3112     check_property(
3113       outer_class_info_index == 0 ||
3114         valid_klass_reference_at(outer_class_info_index),
3115       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3116       outer_class_info_index, CHECK_0);
3117     // Inner class name
3118     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3119     check_property(
3120       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3121       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3122       inner_name_index, CHECK_0);
3123     if (_need_verify) {
3124       guarantee_property(inner_class_info_index != outer_class_info_index,
3125                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3126     }
<span class="line-modified">3127     // Access flags</span>
<span class="line-modified">3128     jint flags;</span>
3129     // JVM_ACC_MODULE is defined in JDK-9 and later.
3130     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3131       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">3132     } else {</span>
<span class="line-modified">3133       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;</span>


3134     }




3135     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3136       // Set abstract bit for old class files for backward compatibility
3137       flags |= JVM_ACC_ABSTRACT;
3138     }
3139     verify_legal_class_modifiers(flags, CHECK_0);
3140     AccessFlags inner_access_flags(flags);
3141 
3142     inner_classes-&gt;at_put(index++, inner_class_info_index);
3143     inner_classes-&gt;at_put(index++, outer_class_info_index);
3144     inner_classes-&gt;at_put(index++, inner_name_index);
3145     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3146   }
3147 
3148   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3149   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3150     for(int i = 0; i &lt; length * 4; i += 4) {
3151       for(int j = i + 4; j &lt; length * 4; j += 4) {
3152         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3153                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3154                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
3491   bool parsed_sourcefile_attribute = false;
3492   bool parsed_innerclasses_attribute = false;
3493   bool parsed_nest_members_attribute = false;
3494   bool parsed_nest_host_attribute = false;
3495   bool parsed_record_attribute = false;
3496   bool parsed_enclosingmethod_attribute = false;
3497   bool parsed_bootstrap_methods_attribute = false;
3498   const u1* runtime_visible_annotations = NULL;
3499   int runtime_visible_annotations_length = 0;
3500   const u1* runtime_invisible_annotations = NULL;
3501   int runtime_invisible_annotations_length = 0;
3502   const u1* runtime_visible_type_annotations = NULL;
3503   int runtime_visible_type_annotations_length = 0;
3504   const u1* runtime_invisible_type_annotations = NULL;
3505   int runtime_invisible_type_annotations_length = 0;
3506   bool runtime_invisible_type_annotations_exists = false;
3507   bool runtime_invisible_annotations_exists = false;
3508   bool parsed_source_debug_ext_annotations_exist = false;
3509   const u1* inner_classes_attribute_start = NULL;
3510   u4  inner_classes_attribute_length = 0;


3511   u2  enclosing_method_class_index = 0;
3512   u2  enclosing_method_method_index = 0;
3513   const u1* nest_members_attribute_start = NULL;
3514   u4  nest_members_attribute_length = 0;
3515   const u1* record_attribute_start = NULL;
3516   u4  record_attribute_length = 0;
3517 
3518   // Iterate over attributes
3519   while (attributes_count--) {
3520     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3521     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3522     const u4 attribute_length = cfs-&gt;get_u4_fast();
3523     check_property(
3524       valid_symbol_at(attribute_name_index),
3525       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3526       attribute_name_index, CHECK);
3527     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3528     if (tag == vmSymbols::tag_source_file()) {
3529       // Check for SourceFile tag
3530       if (_need_verify) {
</pre>
<hr />
<pre>
3894       }
3895     }
3896     if (runtime_invisible_annotations != NULL) {
3897       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3898         int append = runtime_visible_annotations_length+i;
3899         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3900       }
3901     }
3902   }
3903   return annotations;
3904 }
3905 
3906 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3907                                                         const int super_class_index,
3908                                                         const bool need_verify,
3909                                                         TRAPS) {
3910   assert(cp != NULL, &quot;invariant&quot;);
3911   const InstanceKlass* super_klass = NULL;
3912 
3913   if (super_class_index == 0) {
<span class="line-modified">3914     check_property(_class_name == vmSymbols::java_lang_Object(),</span>

3915                    &quot;Invalid superclass index %u in class file %s&quot;,
3916                    super_class_index,
3917                    CHECK_NULL);
3918   } else {
3919     check_property(valid_klass_reference_at(super_class_index),
3920                    &quot;Invalid superclass index %u in class file %s&quot;,
3921                    super_class_index,
3922                    CHECK_NULL);
3923     // The class name should be legal because it is checked when parsing constant pool.
3924     // However, make sure it is not an array type.
3925     bool is_array = false;
3926     if (cp-&gt;tag_at(super_class_index).is_klass()) {
3927       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
3928       if (need_verify)
3929         is_array = super_klass-&gt;is_array_klass();
3930     } else if (need_verify) {
3931       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
3932     }
3933     if (need_verify) {
3934       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4074 }
4075 
4076 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4077   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4078   if (_nonstatic_oop_map_count &gt; 0) {
4079     OopMapBlock* map = _nonstatic_oop_maps;
4080     OopMapBlock* last_map = last_oop_map();
4081     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4082     while (map &lt;= last_map) {
4083       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4084                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4085       map++;
4086     }
4087   }
4088 }
4089 
4090 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4091   print_on(st);
4092 }
4093 



















4094 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4095 void ClassFileParser::layout_fields(ConstantPool* cp,
4096                                     const FieldAllocationCount* fac,
4097                                     const ClassAnnotationCollector* parsed_annotations,
4098                                     FieldLayoutInfo* info,
4099                                     TRAPS) {
4100 
4101   assert(cp != NULL, &quot;invariant&quot;);
4102 
4103   // Field size and offset computation
4104   int nonstatic_field_size = _super_klass == NULL ? 0 :
4105                                _super_klass-&gt;nonstatic_field_size();






4106 
4107   // Count the contended fields by type.
4108   //
4109   // We ignore static fields, because @Contended is not supported for them.
4110   // The layout code below will also ignore the static fields.
4111   int nonstatic_contended_count = 0;
4112   FieldAllocationCount fac_contended;
4113   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4114     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4115     if (fs.is_contended()) {
4116       fac_contended.count[atype]++;
4117       if (!fs.access_flags().is_static()) {
4118         nonstatic_contended_count++;
4119       }
4120     }
4121   }
4122 
4123 
4124   // Calculate the starting byte offsets
4125   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();

4126   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4127                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);</span>
4128   if (fac-&gt;count[STATIC_DOUBLE]) {
4129     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4130   }
4131 
4132   int next_static_word_offset   = next_static_double_offset +
4133                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4134   int next_static_short_offset  = next_static_word_offset +
4135                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4136   int next_static_byte_offset   = next_static_short_offset +
4137                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4138 
4139   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4140                                 nonstatic_field_size * heapOopSize;
4141 










4142   int next_nonstatic_field_offset = nonstatic_fields_start;
4143 
4144   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4145 
4146   // Class is contended, pad before all the fields
4147   if (is_contended_class) {
4148     next_nonstatic_field_offset += ContendedPaddingWidth;
4149   }
4150 








4151   // Compute the non-contended fields count.
4152   // The packing code below relies on these counts to determine if some field
4153   // can be squeezed into the alignment gap. Contended fields are obviously
4154   // exempt from that.
4155   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4156   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4157   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4158   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4159   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4160 









































































4161   // Total non-static fields count, including every contended field
4162   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4163                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4164                                         fac-&gt;count[NONSTATIC_OOP];</span>
4165 
4166   const bool super_has_nonstatic_fields =
4167           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4168   const bool has_nonstatic_fields =
4169     super_has_nonstatic_fields || (nonstatic_fields_count != 0);

4170 





4171 
4172   // Prepare list of oops for oop map generation.
4173   //
4174   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4175   // regions. offset[i] is the start of the i-th region, which then has
4176   // count[i] oops following. Before we know how many regions are required,
4177   // we pessimistically allocate the maps to fit all the oops into the
4178   // distinct regions.
<span class="line-modified">4179 </span>
4180   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4181   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];</span>




4182 
4183   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4184   if (super_oop_map_count &gt; 0) {
4185     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4186                                                     _super_klass-&gt;nonstatic_oop_map_count());
4187   }
4188 
4189   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4190 
4191   bool compact_fields  = true;
4192   bool allocate_oops_first = false;
4193 
4194   // The next classes have predefined hard-coded fields offsets
4195   // (see in JavaClasses::compute_hard_coded_offsets()).
4196   // Use default fields allocation order for them.
4197   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4198       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4199        _class_name == vmSymbols::java_lang_Boolean() ||
4200        _class_name == vmSymbols::java_lang_Character() ||
4201        _class_name == vmSymbols::java_lang_Float() ||
</pre>
<hr />
<pre>
4273   }
4274 
4275   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4276                                      (nonstatic_double_count * BytesPerLong);
4277   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4278                                       (nonstatic_word_count * BytesPerInt);
4279   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4280                                      (nonstatic_short_count * BytesPerShort);
4281   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4282                                        nonstatic_byte_count;
4283 
4284   // let oops jump before padding with this allocation style
4285   if (!allocate_oops_first) {
4286     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4287     if( nonstatic_oop_count &gt; 0 ) {
4288       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4289     }
4290     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4291   }
4292 










4293   // Iterate over fields again and compute correct offsets.
4294   // The field allocation type was temporarily stored in the offset slot.
4295   // oop fields are located before non-oop fields (static and non-static).
4296   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4297 
4298     // skip already laid out fields
4299     if (fs.is_offset_set()) continue;
4300 
4301     // contended instance fields are handled below
4302     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4303 
4304     int real_offset = 0;
4305     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4306 
4307     // pack the rest of the fields
4308     switch (atype) {


4309       case STATIC_OOP:
4310         real_offset = next_static_oop_offset;
4311         next_static_oop_offset += heapOopSize;
4312         break;
4313       case STATIC_BYTE:
4314         real_offset = next_static_byte_offset;
4315         next_static_byte_offset += 1;
4316         break;
4317       case STATIC_SHORT:
4318         real_offset = next_static_short_offset;
4319         next_static_short_offset += BytesPerShort;
4320         break;
4321       case STATIC_WORD:
4322         real_offset = next_static_word_offset;
4323         next_static_word_offset += BytesPerInt;
4324         break;
4325       case STATIC_DOUBLE:
4326         real_offset = next_static_double_offset;
4327         next_static_double_offset += BytesPerLong;
4328         break;

























4329       case NONSTATIC_OOP:
4330         if( nonstatic_oop_space_count &gt; 0 ) {
4331           real_offset = nonstatic_oop_space_offset;
4332           nonstatic_oop_space_offset += heapOopSize;
4333           nonstatic_oop_space_count  -= 1;
4334         } else {
4335           real_offset = next_nonstatic_oop_offset;
4336           next_nonstatic_oop_offset += heapOopSize;
4337         }
4338         nonstatic_oop_maps-&gt;add(real_offset, 1);
4339         break;
4340       case NONSTATIC_BYTE:
4341         if( nonstatic_byte_space_count &gt; 0 ) {
4342           real_offset = nonstatic_byte_space_offset;
4343           nonstatic_byte_space_offset += 1;
4344           nonstatic_byte_space_count  -= 1;
4345         } else {
4346           real_offset = next_nonstatic_byte_offset;
4347           next_nonstatic_byte_offset += 1;
4348         }
</pre>
<hr />
<pre>
4427             break;
4428 
4429           case NONSTATIC_SHORT:
4430             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4431             real_offset = next_nonstatic_padded_offset;
4432             next_nonstatic_padded_offset += BytesPerShort;
4433             break;
4434 
4435           case NONSTATIC_WORD:
4436             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4437             real_offset = next_nonstatic_padded_offset;
4438             next_nonstatic_padded_offset += BytesPerInt;
4439             break;
4440 
4441           case NONSTATIC_DOUBLE:
4442             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4443             real_offset = next_nonstatic_padded_offset;
4444             next_nonstatic_padded_offset += BytesPerLong;
4445             break;
4446 






4447           case NONSTATIC_OOP:
4448             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4449             real_offset = next_nonstatic_padded_offset;
4450             next_nonstatic_padded_offset += heapOopSize;
4451             nonstatic_oop_maps-&gt;add(real_offset, 1);
4452             break;
4453 
4454           default:
4455             ShouldNotReachHere();
4456         }
4457 
4458         if (fs.contended_group() == 0) {
4459           // Contended group defines the equivalence class over the fields:
4460           // the fields within the same contended group are not inter-padded.
4461           // The only exception is default group, which does not incur the
4462           // equivalence, and so requires intra-padding.
4463           next_nonstatic_padded_offset += ContendedPaddingWidth;
4464         }
4465 
4466         fs.set_offset(real_offset);
4467       } // for
4468 
4469       // Start laying out the next group.
4470       // Note that this will effectively pad the last group in the back;
4471       // this is expected to alleviate memory contention effects for
4472       // subclass fields and/or adjacent object.
4473       // If this was the default group, the padding is already in place.
4474       if (current_group != 0) {
4475         next_nonstatic_padded_offset += ContendedPaddingWidth;
4476       }
4477     }
4478 
4479     // handle static fields
4480   }
4481 
4482   // Entire class is contended, pad in the back.
4483   // This helps to alleviate memory contention effects for subclass fields
4484   // and/or adjacent object.
4485   if (is_contended_class) {

4486     next_nonstatic_padded_offset += ContendedPaddingWidth;
4487   }
4488 
<span class="line-modified">4489   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>





4490 
<span class="line-modified">4491   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);</span>






4492   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4493   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4494 
4495   int static_field_size         = (static_fields_end -
4496                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4497   nonstatic_field_size          = nonstatic_field_size +
4498                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4499 
4500   int instance_size             = align_object_size(instance_end / wordSize);
4501 
4502   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4503          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),</span>
<span class="line-modified">4504           wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>

4505 
4506   // Invariant: nonstatic_field end/start should only change if there are
4507   // nonstatic fields in the class, or if the class is contended. We compare
4508   // against the non-aligned value, so that end alignment will not fail the
4509   // assert without actually having the fields.
4510   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4511          is_contended_class ||
4512          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4513 
4514   // Number of non-static oop map blocks allocated at end of klass.
4515   nonstatic_oop_maps-&gt;compact();
4516 
4517 #ifndef PRODUCT
<span class="line-modified">4518   if (PrintFieldLayout) {</span>

4519     print_field_layout(_class_name,
4520           _fields,
4521           cp,
4522           instance_size,
4523           nonstatic_fields_start,
4524           nonstatic_fields_end,
4525           static_fields_end);







4526   }
4527 
4528 #endif
4529   // Pass back information needed for InstanceKlass creation
4530   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4531   info-&gt;_instance_size = instance_size;
4532   info-&gt;_static_field_size = static_field_size;
4533   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4534   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;













4535 }
4536 
4537 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4538   assert(ik != NULL, &quot;invariant&quot;);
4539 
4540   const Klass* const super = ik-&gt;super();
4541 
4542   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4543   // in which case we don&#39;t have to register objects as finalizable
4544   if (!_has_empty_finalizer) {
4545     if (_has_finalizer ||
4546         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4547       ik-&gt;set_has_finalizer();
4548     }
4549   }
4550 
4551 #ifdef ASSERT
4552   bool f = false;
4553   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4554                                            vmSymbols::void_method_signature());
4555   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4556       f = true;
4557   }
4558 
4559   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4560   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4561   // will not work as expected we shouldn&#39;t abort vm in this case
4562   if (!ik-&gt;has_redefined_this_or_super()) {
4563     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4564   }
4565 #endif
4566 
4567   // Check if this klass supports the java.lang.Cloneable interface
4568   if (SystemDictionary::Cloneable_klass_loaded()) {
4569     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {





4570       ik-&gt;set_is_cloneable();
4571     }
4572   }
4573 
4574   // Check if this klass has a vanilla default constructor
4575   if (super == NULL) {
4576     // java.lang.Object has empty default constructor
4577     ik-&gt;set_has_vanilla_constructor();
4578   } else {
4579     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4580         _has_vanilla_constructor) {
4581       ik-&gt;set_has_vanilla_constructor();
4582     }
4583 #ifdef ASSERT
4584     bool v = false;
4585     if (super-&gt;has_vanilla_constructor()) {
4586       const Method* const constructor =
4587         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4588                        vmSymbols::void_method_signature());
4589       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4590         v = true;
4591       }
4592     }
4593     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4594 #endif
4595   }
4596 
4597   // If it cannot be fast-path allocated, set a bit in the layout helper.
4598   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4599   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4600   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4601       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4602       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4603       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4604     // Forbid fast-path allocation.
4605     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4606     ik-&gt;set_layout_helper(lh);
4607   }
4608 }
4609 





4610 // utility methods for appending an array with check for duplicates
4611 
4612 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4613                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4614   // iterate over new interfaces
4615   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4616     InstanceKlass* const e = ifs-&gt;at(i);
4617     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4618     // add new interface
4619     result-&gt;append_if_missing(e);
4620   }
4621 }
4622 
4623 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4624                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4625                                                             ClassLoaderData* loader_data,
4626                                                             TRAPS) {
4627   assert(local_ifs != NULL, &quot;invariant&quot;);
4628   assert(loader_data != NULL, &quot;invariant&quot;);
4629 
</pre>
<hr />
<pre>
4853     const Method* const m = methods-&gt;at(index);
4854     // if m is static and not the init method, throw a verify error
4855     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4856       ResourceMark rm(THREAD);
4857       Exceptions::fthrow(
4858         THREAD_AND_LOCATION,
4859         vmSymbols::java_lang_VerifyError(),
4860         &quot;Illegal static method %s in interface %s&quot;,
4861         m-&gt;name()-&gt;as_C_string(),
4862         this_klass-&gt;external_name()
4863       );
4864       return;
4865     }
4866   }
4867 }
4868 
4869 // utility methods for format checking
4870 
4871 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4872   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;

4873   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);

4874   if (is_module) {
4875     ResourceMark rm(THREAD);
4876     Exceptions::fthrow(
4877       THREAD_AND_LOCATION,
4878       vmSymbols::java_lang_NoClassDefFoundError(),
4879       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4880       _class_name-&gt;as_C_string());
4881     return;
4882   }
4883 










4884   if (!_need_verify) { return; }
4885 
4886   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4887   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4888   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4889   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4890   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4891   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4892   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4893   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
4894 
4895   if ((is_abstract &amp;&amp; is_final) ||
4896       (is_interface &amp;&amp; !is_abstract) ||
4897       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">4898       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>

4899     ResourceMark rm(THREAD);


4900     Exceptions::fthrow(
4901       THREAD_AND_LOCATION,
4902       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">4903       &quot;Illegal class modifiers in class %s: 0x%X&quot;,</span>
<span class="line-modified">4904       _class_name-&gt;as_C_string(), flags</span>
4905     );
4906     return;
4907   }
4908 }
4909 
4910 static bool has_illegal_visibility(jint flags) {
4911   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4912   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4913   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4914 
4915   return ((is_public &amp;&amp; is_protected) ||
4916           (is_public &amp;&amp; is_private) ||
4917           (is_protected &amp;&amp; is_private));
4918 }
4919 
4920 // A legal major_version.minor_version must be one of the following:
4921 //
4922 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
4923 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
4924 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
4963     if (!Arguments::enable_preview()) {
4964       Exceptions::fthrow(
4965         THREAD_AND_LOCATION,
4966         vmSymbols::java_lang_UnsupportedClassVersionError(),
4967         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
4968         class_name-&gt;as_C_string(), major, minor);
4969       return;
4970     }
4971 
4972   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
4973     Exceptions::fthrow(
4974         THREAD_AND_LOCATION,
4975         vmSymbols::java_lang_UnsupportedClassVersionError(),
4976         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
4977         class_name-&gt;as_C_string(), major, minor);
4978   }
4979 }
4980 
4981 void ClassFileParser::verify_legal_field_modifiers(jint flags,
4982                                                    bool is_interface,

4983                                                    TRAPS) const {
4984   if (!_need_verify) { return; }
4985 
4986   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4987   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4988   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4989   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
4990   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
4991   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
4992   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
4993   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
4994   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4995 
4996   bool is_illegal = false;
4997 
4998   if (is_interface) {
4999     if (!is_public || !is_static || !is_final || is_private ||
5000         is_protected || is_volatile || is_transient ||
5001         (major_gte_1_5 &amp;&amp; is_enum)) {
5002       is_illegal = true;
5003     }
5004   } else { // not interface
5005     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5006       is_illegal = true;




5007     }
5008   }
5009 
5010   if (is_illegal) {
5011     ResourceMark rm(THREAD);
5012     Exceptions::fthrow(
5013       THREAD_AND_LOCATION,
5014       vmSymbols::java_lang_ClassFormatError(),
5015       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5016       _class_name-&gt;as_C_string(), flags);
5017     return;
5018   }
5019 }
5020 
5021 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5022                                                     bool is_interface,

5023                                                     const Symbol* name,
5024                                                     TRAPS) const {
5025   if (!_need_verify) { return; }
5026 
5027   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5028   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5029   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5030   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5031   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5032   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5033   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5034   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5035   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5036   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5037   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5038   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5039   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5040 
5041   bool is_illegal = false;
5042 


5043   if (is_interface) {
5044     if (major_gte_8) {
5045       // Class file version is JAVA_8_VERSION or later Methods of
5046       // interfaces may set any of the flags except ACC_PROTECTED,
5047       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5048       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5049       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5050           (is_native || is_protected || is_final || is_synchronized) ||
5051           // If a specific method of a class or interface has its
5052           // ACC_ABSTRACT flag set, it must not have any of its
5053           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5054           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5055           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5056           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5057           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5058         is_illegal = true;
5059       }
5060     } else if (major_gte_1_5) {
5061       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5062       if (!is_public || is_private || is_protected || is_static || is_final ||
5063           is_synchronized || is_native || !is_abstract || is_strict) {
5064         is_illegal = true;
5065       }
5066     } else {
5067       // Class file version is pre-JAVA_1_5_VERSION
5068       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5069         is_illegal = true;
5070       }
5071     }
5072   } else { // not interface
5073     if (has_illegal_visibility(flags)) {
5074       is_illegal = true;
5075     } else {
5076       if (is_initializer) {
<span class="line-modified">5077         if (is_static || is_final || is_synchronized || is_native ||</span>
5078             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5079           is_illegal = true;
5080         }









5081       } else { // not initializer
<span class="line-modified">5082         if (is_abstract) {</span>
<span class="line-modified">5083           if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-modified">5084               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-modified">5085             is_illegal = true;</span>





5086           }
5087         }
5088       }
5089     }
5090   }
5091 
5092   if (is_illegal) {
5093     ResourceMark rm(THREAD);
5094     Exceptions::fthrow(
5095       THREAD_AND_LOCATION,
5096       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5097       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5098       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);</span>
5099     return;
5100   }
5101 }
5102 
5103 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5104                                         int length,
5105                                         TRAPS) const {
5106   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5107   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5108     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5109   }
5110 }
5111 
5112 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5113 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5114 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5115 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5116 // method.  Because these names have been checked as special cases before
5117 // calling this method in verify_legal_method_name.
5118 //
</pre>
<hr />
<pre>
5236 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5237 // Return a pointer to just past the signature.
5238 // Return NULL if no legal signature is found.
5239 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5240                                                        bool void_ok,
5241                                                        unsigned int length,
5242                                                        TRAPS) const {
5243   unsigned int array_dim = 0;
5244   while (length &gt; 0) {
5245     switch (signature[0]) {
5246     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5247     case JVM_SIGNATURE_BOOLEAN:
5248     case JVM_SIGNATURE_BYTE:
5249     case JVM_SIGNATURE_CHAR:
5250     case JVM_SIGNATURE_SHORT:
5251     case JVM_SIGNATURE_INT:
5252     case JVM_SIGNATURE_FLOAT:
5253     case JVM_SIGNATURE_LONG:
5254     case JVM_SIGNATURE_DOUBLE:
5255       return signature + 1;
<span class="line-modified">5256     case JVM_SIGNATURE_CLASS: {</span>









5257       if (_major_version &lt; JAVA_1_5_VERSION) {
5258         // Skip over the class name if one is there
5259         const char* const p = skip_over_field_name(signature + 1, true, --length);
5260 
5261         // The next character better be a semicolon
5262         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5263           return p + 1;
5264         }
5265       }
5266       else {
<span class="line-modified">5267         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;</span>
5268         signature++;
5269         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5270         // Format check signature
5271         if (c != NULL) {
5272           int newlen = c - (char*) signature;
5273           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5274           if (!legal) {
5275             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5276                                   &quot;in descriptor in class file %s&quot;,
5277                                   CHECK_NULL);
5278             return NULL;
5279           }
5280           return signature + newlen + 1;
5281         }
5282       }
5283       return NULL;
5284     }
5285     case JVM_SIGNATURE_ARRAY:
5286       array_dim++;
5287       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5302 
5303 // Checks if name is a legal class name.
5304 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5305   if (!_need_verify || _relax_verify) { return; }
5306 
5307   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5308   char* bytes = (char*)name-&gt;bytes();
5309   unsigned int length = name-&gt;utf8_length();
5310   bool legal = false;
5311 
5312   if (length &gt; 0) {
5313     const char* p;
5314     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5315       p = skip_over_field_signature(bytes, false, length, CHECK);
5316       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5317     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5318       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5319         p = skip_over_field_name(bytes, true, length);
5320         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5321       }



5322     } else {
5323       // 4900761: relax the constraints based on JSR202 spec
5324       // Class names may be drawn from the entire Unicode character set.
5325       // Identifiers between &#39;/&#39; must be unqualified names.
5326       // The utf8 string has been verified when parsing cpool entries.
5327       legal = verify_unqualified_name(bytes, length, LegalClass);
5328     }
5329   }
5330   if (!legal) {
5331     ResourceMark rm(THREAD);
5332     assert(_class_name != NULL, &quot;invariant&quot;);
5333     Exceptions::fthrow(
5334       THREAD_AND_LOCATION,
5335       vmSymbols::java_lang_ClassFormatError(),
5336       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5337       _class_name-&gt;as_C_string()
5338     );
5339     return;
5340   }
5341 }
</pre>
<hr />
<pre>
5451   const char* nextp;
5452 
5453   // The first character must be a &#39;(&#39;
5454   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5455     length--;
5456     // Skip over legal field signatures
5457     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5458     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5459       args_size++;
5460       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5461         args_size++;
5462       }
5463       length -= nextp - p;
5464       p = nextp;
5465       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5466     }
5467     // The first non-signature thing better be a &#39;)&#39;
5468     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5469       length--;
5470       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5471         // All internal methods must return void</span>
5472         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5473           return args_size;
5474         }
















5475       } else {
5476         // Now we better just have a return value
5477         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5478         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5479           return args_size;
5480         }
5481       }
5482     }
5483   }
5484   // Report error
5485   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5486   return 0;
5487 }
5488 
5489 int ClassFileParser::static_field_size() const {
5490   assert(_field_info != NULL, &quot;invariant&quot;);
5491   return _field_info-&gt;_static_field_size;
5492 }
5493 
5494 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
5575 
5576           if (!match) {
5577             char buf[1000];
5578             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5579                        &quot;but the method is not available in class [%s].%s&quot;,
5580                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
5581                                                              buf, sizeof(buf)),
5582                         ik-&gt;name()-&gt;as_C_string(),
5583                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5584             );
5585             tty-&gt;cr();
5586             DEBUG_ONLY(vm_exit(1));
5587           }
5588         }
5589       } // end for
5590     } // CheckIntrinsics
5591 #endif // ASSERT
5592   }
5593 }
5594 

5595 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {
5596   if (_klass != NULL) {
5597     return _klass;
5598   }
5599 
5600   InstanceKlass* const ik =
5601     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
5602 
5603   fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);
5604 
5605   assert(_klass == ik, &quot;invariant&quot;);
5606 
5607 
5608   if (ik-&gt;should_store_fingerprint()) {
5609     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5610   }
5611 
5612   ik-&gt;set_has_passed_fingerprint_check(false);
5613   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5614     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5615     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5616     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5617       // This class matches with a class saved in an AOT library
5618       ik-&gt;set_has_passed_fingerprint_check(true);
5619     } else {
5620       ResourceMark rm;
5621       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5622                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5623     }
5624   }
5625 






5626   return ik;
5627 }
5628 
5629 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
5630   assert(ik != NULL, &quot;invariant&quot;);
5631 
5632   // Set name and CLD before adding to CLD
5633   ik-&gt;set_class_loader_data(_loader_data);
5634   ik-&gt;set_name(_class_name);
5635 
5636   // Add all classes to our internal class loader list here,
5637   // including classes in the bootstrap (NULL) class loader.
5638   const bool publicize = !is_internal();
5639 
5640   _loader_data-&gt;add_class(ik, publicize);
5641 
5642   set_klass_to_deallocate(ik);
5643 
5644   assert(_field_info != NULL, &quot;invariant&quot;);
5645   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
5646   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
5647          &quot;sanity&quot;);
5648 
5649   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5650   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
5651 
5652   // Fill in information already parsed
5653   ik-&gt;set_should_verify_class(_need_verify);
5654 
5655   // Not yet: supers are done below to support the new subtype-checking fields
5656   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
5657   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);






5658   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">5659   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);</span>
5660 
5661   // this transfers ownership of a lot of arrays from
5662   // the parser onto the InstanceKlass*
5663   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5664 
5665   // note that is not safe to use the fields in the parser from this point on
5666   assert(NULL == _cp, &quot;invariant&quot;);
5667   assert(NULL == _fields, &quot;invariant&quot;);
5668   assert(NULL == _methods, &quot;invariant&quot;);
5669   assert(NULL == _inner_classes, &quot;invariant&quot;);
5670   assert(NULL == _nest_members, &quot;invariant&quot;);
5671   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5672   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5673   assert(NULL == _record_components, &quot;invariant&quot;);
5674 
5675   if (_has_final_method) {
5676     ik-&gt;set_has_final_method();
5677   }
5678 
5679   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
</pre>
<hr />
<pre>
5684   // has to be changed accordingly.
5685   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5686 
5687   ik-&gt;set_this_class_index(_this_class_index);
5688 
5689   if (is_unsafe_anonymous()) {
5690     // _this_class_index is a CONSTANT_Class entry that refers to this
5691     // anonymous class itself. If this class needs to refer to its own methods or
5692     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
5693     // _this_class_index. However, because this class is anonymous (it&#39;s
5694     // not stored in SystemDictionary), _this_class_index cannot be resolved
5695     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5696     // Therefore, we must eagerly resolve _this_class_index now.
5697     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5698   }
5699 
5700   ik-&gt;set_minor_version(_minor_version);
5701   ik-&gt;set_major_version(_major_version);
5702   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5703   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);



5704 
5705   if (_unsafe_anonymous_host != NULL) {
5706     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5707     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5708   }
5709 
5710   // Set PackageEntry for this_klass
5711   oop cl = ik-&gt;class_loader();
5712   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5713   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5714   ik-&gt;set_package(cld, NULL, CHECK);
5715 
5716   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5717   assert(methods != NULL, &quot;invariant&quot;);
5718   const int methods_len = methods-&gt;length();
5719 
5720   check_methods_for_intrinsics(ik, methods);
5721 
5722   // Fill in field values obtained by parse_classfile_attributes
5723   if (_parsed_annotations-&gt;has_any_annotations()) {
</pre>
<hr />
<pre>
5789 
5790   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5791 
5792   // Generate any default methods - default methods are public interface methods
5793   // that have a default implementation.  This is new with Java 8.
5794   if (_has_nonstatic_concrete_methods) {
5795     DefaultMethods::generate_default_methods(ik,
5796                                              _all_mirandas,
5797                                              CHECK);
5798   }
5799 
5800   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5801   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5802       !module_entry-&gt;has_default_read_edges()) {
5803     if (!module_entry-&gt;set_has_default_read_edges()) {
5804       // We won a potential race
5805       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5806     }
5807   }
5808 


































5809   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5810 
5811   if (!is_internal()) {
5812     if (log_is_enabled(Info, class, load)) {
5813       ResourceMark rm;
5814       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5815       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5816     }
5817 
5818     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5819         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5820         log_is_enabled(Info, class, preview)) {
5821       ResourceMark rm;
5822       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5823                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5824     }
5825 
5826     if (log_is_enabled(Debug, class, resolve))  {
5827       ResourceMark rm;
5828       // print out the superclass.
</pre>
<hr />
<pre>
5980   _access_flags(),
5981   _pub_level(pub_level),
5982   _bad_constant_seen(0),
5983   _synthetic_flag(false),
5984   _sde_length(false),
5985   _sde_buffer(NULL),
5986   _sourcefile_index(0),
5987   _generic_signature_index(0),
5988   _major_version(0),
5989   _minor_version(0),
5990   _this_class_index(0),
5991   _super_class_index(0),
5992   _itfs_len(0),
5993   _java_fields_count(0),
5994   _need_verify(false),
5995   _relax_verify(false),
5996   _has_nonstatic_concrete_methods(false),
5997   _declares_nonstatic_concrete_methods(false),
5998   _has_final_method(false),
5999   _has_contended_fields(false),




6000   _has_finalizer(false),
6001   _has_empty_finalizer(false),
6002   _has_vanilla_constructor(false),
6003   _max_bootstrap_specifier_index(-1) {
6004 
6005   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6006   _class_name-&gt;increment_refcount();
6007 
6008   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6009   assert(_loader_data != NULL, &quot;invariant&quot;);
6010   assert(stream != NULL, &quot;invariant&quot;);
6011   assert(_stream != NULL, &quot;invariant&quot;);
6012   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6013   assert(_class_name != NULL, &quot;invariant&quot;);
6014   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6015 
6016   // Figure out whether we can skip format checking (matching classic VM behavior)
6017   if (DumpSharedSpaces) {
6018     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6019     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6180 
6181   _orig_cp_size = cp_size;
6182   if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6183     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6184   }
6185   cp_size += _max_num_patched_klasses;
6186 
6187   _cp = ConstantPool::allocate(_loader_data,
6188                                cp_size,
6189                                CHECK);
6190 
6191   ConstantPool* const cp = _cp;
6192 
6193   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6194 
6195   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6196 
6197   // ACCESS FLAGS
6198   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6199 
<span class="line-modified">6200   // Access flags</span>
<span class="line-removed">6201   jint flags;</span>
6202   // JVM_ACC_MODULE is defined in JDK-9 and later.
6203   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6204     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">6205   } else {</span>
<span class="line-modified">6206     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;</span>


6207   }
6208 



6209   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6210     // Set abstract bit for old class files for backward compatibility
6211     flags |= JVM_ACC_ABSTRACT;
6212   }
6213 
6214   verify_legal_class_modifiers(flags, CHECK);
6215 
6216   short bad_constant = class_bad_constant_seen();
6217   if (bad_constant != 0) {
6218     // Do not throw CFE until after the access_flags are checked because if
6219     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6220     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6221   }
6222 
6223   _access_flags.set_flags(flags);
6224 
6225   // This class and superclass
6226   _this_class_index = stream-&gt;get_u2_fast();
6227   check_property(
6228     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6315           classlist_file-&gt;flush();
6316         }
6317       }
6318     }
6319 #endif
6320   }
6321 
6322   // SUPERKLASS
6323   _super_class_index = stream-&gt;get_u2_fast();
6324   _super_klass = parse_super_class(cp,
6325                                    _super_class_index,
6326                                    _need_verify,
6327                                    CHECK);
6328 
6329   // Interfaces
6330   _itfs_len = stream-&gt;get_u2_fast();
6331   parse_interfaces(stream,
6332                    _itfs_len,
6333                    cp,
6334                    &amp;_has_nonstatic_concrete_methods,

6335                    CHECK);
6336 
6337   assert(_local_interfaces != NULL, &quot;invariant&quot;);
6338 
6339   // Fields (offsets are filled in later)
6340   _fac = new FieldAllocationCount();
6341   parse_fields(stream,
<span class="line-modified">6342                _access_flags.is_interface(),</span>

6343                _fac,
6344                cp,
6345                cp_size,
6346                &amp;_java_fields_count,
6347                CHECK);
6348 
6349   assert(_fields != NULL, &quot;invariant&quot;);
6350 
6351   // Methods
6352   AccessFlags promoted_flags;
6353   parse_methods(stream,
<span class="line-modified">6354                 _access_flags.is_interface(),</span>

6355                 &amp;promoted_flags,
6356                 &amp;_has_final_method,
6357                 &amp;_declares_nonstatic_concrete_methods,
6358                 CHECK);
6359 
6360   assert(_methods != NULL, &quot;invariant&quot;);
6361 
6362   // promote flags from parse_methods() to the klass&#39; flags
6363   _access_flags.add_promoted_flags(promoted_flags.as_int());
6364 
6365   if (_declares_nonstatic_concrete_methods) {
6366     _has_nonstatic_concrete_methods = true;
6367   }
6368 
6369   // Additional attributes/annotations
6370   _parsed_annotations = new ClassAnnotationCollector();
6371   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6372 
6373   assert(_inner_classes != NULL, &quot;invariant&quot;);
6374 
</pre>
<hr />
<pre>
6383 
6384   // all bytes in stream read and parsed
6385 }
6386 
6387 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6388                                                  ConstantPool* cp,
6389                                                  TRAPS) {
6390   assert(stream != NULL, &quot;invariant&quot;);
6391   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6392   assert(cp != NULL, &quot;invariant&quot;);
6393   assert(_loader_data != NULL, &quot;invariant&quot;);
6394 
6395   if (_class_name == vmSymbols::java_lang_Object()) {
6396     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6397                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6398                    CHECK);
6399   }
6400   // We check super class after class file is parsed and format is checked
6401   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6402     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6403     if (_access_flags.is_interface()) {</span>
6404       // Before attempting to resolve the superclass, check for class format
6405       // errors not checked yet.
6406       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6407         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6408         CHECK);
6409     }
6410     Handle loader(THREAD, _loader_data-&gt;class_loader());
6411     _super_klass = (const InstanceKlass*)
6412                        SystemDictionary::resolve_super_or_fail(_class_name,
6413                                                                super_class_name,
6414                                                                loader,
6415                                                                _protection_domain,
6416                                                                true,
6417                                                                CHECK);
6418   }
6419 
6420   if (_super_klass != NULL) {
6421     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6422       _has_nonstatic_concrete_methods = true;
6423     }



6424 
6425     if (_super_klass-&gt;is_interface()) {
6426       ResourceMark rm(THREAD);
6427       Exceptions::fthrow(
6428         THREAD_AND_LOCATION,
6429         vmSymbols::java_lang_IncompatibleClassChangeError(),
6430         &quot;class %s has interface %s as super class&quot;,
6431         _class_name-&gt;as_klass_external_name(),
6432         _super_klass-&gt;external_name()
6433       );
6434       return;
6435     }











6436     // Make sure super class is not final
6437     if (_super_klass-&gt;is_final()) {
6438       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6439     }
6440   }
6441 












6442   // Compute the transitive list of all unique interfaces implemented by this class
6443   _transitive_interfaces =
6444     compute_transitive_interfaces(_super_klass,
6445                                   _local_interfaces,
6446                                   _loader_data,
6447                                   CHECK);
6448 
6449   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6450 
6451   // sort methods
6452   _method_ordering = sort_methods(_methods);
6453 
6454   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6455 
6456   Handle loader(THREAD, _loader_data-&gt;class_loader());
6457   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6458                                                     &amp;_num_miranda_methods,
6459                                                     _all_mirandas,
6460                                                     _super_klass,
6461                                                     _methods,
6462                                                     _access_flags,
6463                                                     _major_version,
6464                                                     loader,
6465                                                     _class_name,
6466                                                     _local_interfaces,
6467                                                     CHECK);
6468 
6469   // Size of Java itable (in words)
<span class="line-modified">6470   _itable_size = _access_flags.is_interface() ? 0 :</span>
6471     klassItable::compute_itable_size(_transitive_interfaces);
6472 
6473   assert(_fac != NULL, &quot;invariant&quot;);
6474   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6475 













6476   _field_info = new FieldLayoutInfo();
6477   if (UseNewFieldLayout) {
6478     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">6479                           _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-modified">6480     lb.build_layout();</span>






6481   } else {
6482     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6483   }
6484 
<span class="line-modified">6485   // Compute reference typ</span>
6486   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
6487 
6488 }
6489 
6490 void ClassFileParser::set_klass(InstanceKlass* klass) {
6491 
6492 #ifdef ASSERT
6493   if (klass != NULL) {
6494     assert(NULL == _klass, &quot;leaking?&quot;);
6495   }
6496 #endif
6497 
6498   _klass = klass;
6499 }
6500 
6501 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6502 
6503 #ifdef ASSERT
6504   if (klass != NULL) {
6505     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6506   }
6507 #endif
6508 
6509   _klass_to_deallocate = klass;
6510 }
6511 
6512 // Caller responsible for ResourceMark
6513 // clone stream with rewound position
6514 const ClassFileStream* ClassFileParser::clone_stream() const {
6515   assert(_stream != NULL, &quot;invariant&quot;);
6516 
6517   return _stream-&gt;clone();
6518 }

6519 // ----------------------------------------------------------------------------
6520 // debugging
6521 
6522 #ifdef ASSERT
6523 
6524 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6525 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6526   if (class_name != NULL) {
6527     ResourceMark rm;
6528     char* name = class_name-&gt;as_C_string();
6529     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6530   } else {
6531     return true;
6532   }
6533 }
6534 
6535 #endif
</pre>
</td>
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
<span class="line-added">  24 </span>
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/defaultMethods.hpp&quot;
  33 #include &quot;classfile/dictionary.hpp&quot;
  34 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/moduleEntry.hpp&quot;
  37 #include &quot;classfile/packageEntry.hpp&quot;
  38 #include &quot;classfile/symbolTable.hpp&quot;
  39 #include &quot;classfile/systemDictionary.hpp&quot;
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
  52 #include &quot;oops/fieldStreams.inline.hpp&quot;
  53 #include &quot;oops/instanceKlass.hpp&quot;
  54 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  55 #include &quot;oops/klass.inline.hpp&quot;
  56 #include &quot;oops/klassVtable.hpp&quot;
  57 #include &quot;oops/metadata.hpp&quot;
  58 #include &quot;oops/method.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/recordComponent.hpp&quot;
  61 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">  86 #include &quot;utilities/stringUtils.hpp&quot;</span>
  87 #include &quot;utilities/utf8.hpp&quot;
  88 
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
</pre>
<hr />
<pre>
 118 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 119 #define JAVA_7_VERSION                    51
 120 
 121 // Extension method support.
 122 #define JAVA_8_VERSION                    52
 123 
 124 #define JAVA_9_VERSION                    53
 125 
 126 #define JAVA_10_VERSION                   54
 127 
 128 #define JAVA_11_VERSION                   55
 129 
 130 #define JAVA_12_VERSION                   56
 131 
 132 #define JAVA_13_VERSION                   57
 133 
 134 #define JAVA_14_VERSION                   58
 135 
 136 #define JAVA_15_VERSION                   59
 137 
<span class="line-added"> 138 #define CONSTANT_CLASS_DESCRIPTORS        59</span>
<span class="line-added"> 139 </span>
 140 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 141   assert((bad_constant == JVM_CONSTANT_Module ||
 142           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 143          &quot;Unexpected bad constant pool entry&quot;);
 144   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 145 }
 146 
 147 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 148                                                   ConstantPool* cp,
 149                                                   const int length,
 150                                                   TRAPS) {
 151   assert(stream != NULL, &quot;invariant&quot;);
 152   assert(cp != NULL, &quot;invariant&quot;);
 153 
 154   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 155   // this function (_current can be allocated in a register, with scalar
 156   // replacement of aggregates). The _current pointer is copied back to
 157   // stream() when this function returns. DON&#39;T call another method within
 158   // this method that uses stream().
 159   const ClassFileStream cfs1 = *stream;
 160   const ClassFileStream* const cfs = &amp;cfs1;
 161 
 162   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 163   debug_only(const u1* const old_current = stream-&gt;current();)
 164 
 165   // Used for batching symbol allocations.
 166   const char* names[SymbolTable::symbol_alloc_batch_size];
 167   int lengths[SymbolTable::symbol_alloc_batch_size];
 168   int indices[SymbolTable::symbol_alloc_batch_size];
 169   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 170   int names_count = 0;
 171 
 172   // parsing  Index 0 is unused
 173   for (int index = 1; index &lt; length; index++) {
 174     // Each of the following case guarantees one more byte in the stream
 175     // for the following tag or the access_flags following constant pool,
 176     // so we don&#39;t need bounds-check for reading tag.
 177     const u1 tag = cfs-&gt;get_u1_fast();
 178     switch (tag) {
<span class="line-modified"> 179       case JVM_CONSTANT_Class: {</span>
 180         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 181         const u2 name_index = cfs-&gt;get_u2_fast();
 182         cp-&gt;klass_index_at_put(index, name_index);
 183         break;
 184       }
 185       case JVM_CONSTANT_Fieldref: {
 186         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 187         const u2 class_index = cfs-&gt;get_u2_fast();
 188         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 189         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 190         break;
 191       }
 192       case JVM_CONSTANT_Methodref: {
 193         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 194         const u2 class_index = cfs-&gt;get_u2_fast();
 195         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 196         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 197         break;
 198       }
 199       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 489         check_property(valid_symbol_at(name_ref_index),
 490           &quot;Invalid constant pool index %u in class file %s&quot;,
 491           name_ref_index, CHECK);
 492         check_property(valid_symbol_at(signature_ref_index),
 493           &quot;Invalid constant pool index %u in class file %s&quot;,
 494           signature_ref_index, CHECK);
 495         break;
 496       }
 497       case JVM_CONSTANT_Utf8:
 498         break;
 499       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 500       case JVM_CONSTANT_UnresolvedClassInError: {
 501         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 502         break;
 503       }
 504       case JVM_CONSTANT_ClassIndex: {
 505         const int class_index = cp-&gt;klass_index_at(index);
 506         check_property(valid_symbol_at(class_index),
 507           &quot;Invalid constant pool index %u in class file %s&quot;,
 508           class_index, CHECK);
<span class="line-modified"> 509 </span>
<span class="line-added"> 510         Symbol* const name = cp-&gt;symbol_at(class_index);</span>
<span class="line-added"> 511         const unsigned int name_len = name-&gt;utf8_length();</span>
<span class="line-added"> 512         if (name-&gt;is_Q_signature()) {</span>
<span class="line-added"> 513           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 514         } else {</span>
<span class="line-added"> 515           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 516         }</span>
 517         break;
 518       }
 519       case JVM_CONSTANT_StringIndex: {
 520         const int string_index = cp-&gt;string_index_at(index);
 521         check_property(valid_symbol_at(string_index),
 522           &quot;Invalid constant pool index %u in class file %s&quot;,
 523           string_index, CHECK);
 524         Symbol* const sym = cp-&gt;symbol_at(string_index);
 525         cp-&gt;unresolved_string_at_put(index, sym);
 526         break;
 527       }
 528       case JVM_CONSTANT_MethodHandle: {
 529         const int ref_index = cp-&gt;method_handle_index_at(index);
 530         check_property(valid_cp_range(ref_index, length),
 531           &quot;Invalid constant pool index %u in class file %s&quot;,
 532           ref_index, CHECK);
 533         const constantTag tag = cp-&gt;tag_at(ref_index);
 534         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 535 
 536         switch (ref_kind) {
</pre>
<hr />
<pre>
 750             classfile_parse_error(
 751               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 752               name_ref_index, CHECK);
 753           }
 754         }
 755         break;
 756       }
 757       case JVM_CONSTANT_MethodHandle: {
 758         const int ref_index = cp-&gt;method_handle_index_at(index);
 759         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 760         switch (ref_kind) {
 761           case JVM_REF_invokeVirtual:
 762           case JVM_REF_invokeStatic:
 763           case JVM_REF_invokeSpecial:
 764           case JVM_REF_newInvokeSpecial: {
 765             const int name_and_type_ref_index =
 766               cp-&gt;name_and_type_ref_index_at(ref_index);
 767             const int name_ref_index =
 768               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 769             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 770             if (name != vmSymbols::object_initializer_name()) {</span>
<span class="line-modified"> 771               if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
 772                 classfile_parse_error(
 773                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 774                     name_ref_index, CHECK);
 775               }
 776             } else {
<span class="line-modified"> 777               // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="line-added"> 778               // This test corresponds to verify_invoke_instructions in the verifier.</span>
<span class="line-added"> 779               const int signature_ref_index =</span>
<span class="line-added"> 780                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);</span>
<span class="line-added"> 781               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);</span>
<span class="line-added"> 782               if (signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 783                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-added"> 784                 // OK, could be a constructor call</span>
<span class="line-added"> 785               } else if (!signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 786                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {</span>
<span class="line-added"> 787                 // also OK, could be a static factory call</span>
<span class="line-added"> 788               } else {</span>
 789                 classfile_parse_error(
 790                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 791                   name_ref_index, CHECK);
 792               }
 793             }
 794             break;
 795           }
 796           // Other ref_kinds are already fully checked in previous pass.
 797         } // switch(ref_kind)
 798         break;
 799       }
 800       case JVM_CONSTANT_MethodType: {
 801         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 802         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 803         verify_legal_method_signature(no_name, signature, CHECK);
 804         break;
 805       }
 806       case JVM_CONSTANT_Utf8: {
 807         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 808       }
</pre>
<hr />
<pre>
 927   while (entry != NULL) {
 928     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 929       return false;
 930     }
 931     entry = entry-&gt;_next;
 932   }
 933 
 934   // No duplicate is found, allocate a new entry and fill it.
 935   entry = new NameSigHash();
 936   entry-&gt;_name = name;
 937   entry-&gt;_sig = sig;
 938 
 939   // Insert into hash table
 940   entry-&gt;_next = table[index];
 941   table[index] = entry;
 942 
 943   return true;
 944 }
 945 
 946 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,</span>
<span class="line-modified"> 948                                        int itfs_len,</span>
<span class="line-modified"> 949                                        ConstantPool* cp,</span>
 950                                        bool* const has_nonstatic_concrete_methods,
<span class="line-added"> 951                                        // FIXME: lots of these functions</span>
<span class="line-added"> 952                                        // declare their parameters as const,</span>
<span class="line-added"> 953                                        // which adds only noise to the code.</span>
<span class="line-added"> 954                                        // Remove the spurious const modifiers.</span>
<span class="line-added"> 955                                        // Many are of the form &quot;const int x&quot;</span>
<span class="line-added"> 956                                        // or &quot;T* const x&quot;.</span>
<span class="line-added"> 957                                        bool* const is_declared_atomic,</span>
 958                                        TRAPS) {
 959   assert(stream != NULL, &quot;invariant&quot;);
 960   assert(cp != NULL, &quot;invariant&quot;);
 961   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 962 
 963   if (itfs_len == 0) {
 964     _local_interfaces = Universe::the_empty_instance_klass_array();
 965   } else {
 966     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 967     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
 968 
 969     int index;
 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
</pre>
<hr />
<pre>
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
 987         // Call resolve_super so classcircularity is checked
 988         interf = SystemDictionary::resolve_super_or_fail(
 989                                                   _class_name,
 990                                                   unresolved_klass,
 991                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 992                                                   _protection_domain,
 993                                                   false,
 994                                                   CHECK);
 995       }
 996 
 997       if (!interf-&gt;is_interface()) {
 998         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 999                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1000                           _class_name-&gt;as_klass_external_name(),
1001                           interf-&gt;external_name(),
1002                           interf-&gt;class_in_module_of_loader()));
1003       }
1004 
<span class="line-modified">1005       InstanceKlass* ik = InstanceKlass::cast(interf);</span>
<span class="line-added">1006       if (ik-&gt;has_nonstatic_concrete_methods()) {</span>
1007         *has_nonstatic_concrete_methods = true;
1008       }
<span class="line-modified">1009       if (ik-&gt;is_declared_atomic()) {</span>
<span class="line-added">1010         *is_declared_atomic = true;</span>
<span class="line-added">1011       }</span>
<span class="line-added">1012       _local_interfaces-&gt;at_put(index, ik);</span>
1013     }
1014 
1015     if (!_need_verify || itfs_len &lt;= 1) {
1016       return;
1017     }
1018 
1019     // Check if there&#39;s any duplicates in interfaces
1020     ResourceMark rm(THREAD);
1021     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1022                                                                  NameSigHash*,
1023                                                                  HASH_ROW_SIZE);
1024     initialize_hashtable(interface_names);
1025     bool dup = false;
1026     const Symbol* name = NULL;
1027     {
1028       debug_only(NoSafepointVerifier nsv;)
1029       for (index = 0; index &lt; itfs_len; index++) {
1030         const InstanceKlass* const k = _local_interfaces-&gt;at(index);
1031         name = k-&gt;name();
1032         // If no duplicates, add (name, NULL) in hashtable interface_names.
</pre>
<hr />
<pre>
1484                                             CHECK);
1485   parsed_annotations-&gt;set_field_annotations(a);
1486   a = assemble_annotations(runtime_visible_type_annotations,
1487                            runtime_visible_type_annotations_length,
1488                            runtime_invisible_type_annotations,
1489                            runtime_invisible_type_annotations_length,
1490                            CHECK);
1491   parsed_annotations-&gt;set_field_type_annotations(a);
1492   return;
1493 }
1494 
1495 
1496 // Field allocation types. Used for computing field offsets.
1497 
1498 enum FieldAllocationType {
1499   STATIC_OOP,           // Oops
1500   STATIC_BYTE,          // Boolean, Byte, char
1501   STATIC_SHORT,         // shorts
1502   STATIC_WORD,          // ints
1503   STATIC_DOUBLE,        // aligned long or double
<span class="line-added">1504   STATIC_FLATTENABLE,   // flattenable field</span>
1505   NONSTATIC_OOP,
1506   NONSTATIC_BYTE,
1507   NONSTATIC_SHORT,
1508   NONSTATIC_WORD,
1509   NONSTATIC_DOUBLE,
<span class="line-added">1510   NONSTATIC_FLATTENABLE,</span>
1511   MAX_FIELD_ALLOCATION_TYPE,
1512   BAD_ALLOCATION_TYPE = -1
1513 };
1514 
1515 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1516   BAD_ALLOCATION_TYPE, // 0
1517   BAD_ALLOCATION_TYPE, // 1
1518   BAD_ALLOCATION_TYPE, // 2
1519   BAD_ALLOCATION_TYPE, // 3
1520   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1521   NONSTATIC_SHORT,     // T_CHAR        =  5,
1522   NONSTATIC_WORD,      // T_FLOAT       =  6,
1523   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1524   NONSTATIC_BYTE,      // T_BYTE        =  8,
1525   NONSTATIC_SHORT,     // T_SHORT       =  9,
1526   NONSTATIC_WORD,      // T_INT         = 10,
1527   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1528   NONSTATIC_OOP,       // T_OBJECT      = 12,
1529   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1530   NONSTATIC_OOP,       // T_VALUETYPE   = 14,</span>
<span class="line-modified">1531   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1532   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1533   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1534   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1535   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1536   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,</span>
1537   BAD_ALLOCATION_TYPE, // 0
1538   BAD_ALLOCATION_TYPE, // 1
1539   BAD_ALLOCATION_TYPE, // 2
1540   BAD_ALLOCATION_TYPE, // 3
1541   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1542   STATIC_SHORT,        // T_CHAR        =  5,
1543   STATIC_WORD,         // T_FLOAT       =  6,
1544   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1545   STATIC_BYTE,         // T_BYTE        =  8,
1546   STATIC_SHORT,        // T_SHORT       =  9,
1547   STATIC_WORD,         // T_INT         = 10,
1548   STATIC_DOUBLE,       // T_LONG        = 11,
1549   STATIC_OOP,          // T_OBJECT      = 12,
1550   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1551   STATIC_OOP,          // T_VALUETYPE   = 14,</span>
<span class="line-modified">1552   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1553   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1554   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1555   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1556   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1557   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20</span>
1558 };
1559 
<span class="line-modified">1560 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_flattenable) {</span>
1561   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1562   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1563   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<span class="line-added">1564   if (is_flattenable) {</span>
<span class="line-added">1565     result = is_static ? STATIC_FLATTENABLE : NONSTATIC_FLATTENABLE;</span>
<span class="line-added">1566   }</span>
1567   return result;
1568 }
1569 
1570 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1571  public:
1572   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1573 
1574   FieldAllocationCount() {
1575     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1576       count[i] = 0;
1577     }
1578   }
1579 
<span class="line-modified">1580   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {</span>
<span class="line-modified">1581     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);</span>
1582     if (atype != BAD_ALLOCATION_TYPE) {
1583       // Make sure there is no overflow with injected fields.
1584       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1585       count[atype]++;
1586     }
1587     return atype;
1588   }
1589 };
1590 
1591 // Side-effects: populates the _fields, _fields_annotations,
1592 // _fields_type_annotations fields
1593 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1594                                    bool is_interface,
<span class="line-added">1595                                    bool is_value_type,</span>
1596                                    FieldAllocationCount* const fac,
1597                                    ConstantPool* cp,
1598                                    const int cp_size,
1599                                    u2* const java_fields_count_ptr,
1600                                    TRAPS) {
1601 
1602   assert(cfs != NULL, &quot;invariant&quot;);
1603   assert(fac != NULL, &quot;invariant&quot;);
1604   assert(cp != NULL, &quot;invariant&quot;);
1605   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1606 
1607   assert(NULL == _fields, &quot;invariant&quot;);
1608   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1609   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1610 
1611   cfs-&gt;guarantee_more(2, CHECK);  // length
1612   const u2 length = cfs-&gt;get_u2_fast();
1613   *java_fields_count_ptr = length;
1614 
1615   int num_injected = 0;
1616   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1617                                                                   &amp;num_injected);
<span class="line-modified">1618 </span>
<span class="line-added">1619   // two more slots are required for inline classes:</span>
<span class="line-added">1620   // one for the static field with a reference to the pre-allocated default value</span>
<span class="line-added">1621   // one for the field the JVM injects when detecting an empty inline class</span>
<span class="line-added">1622   const int total_fields = length + num_injected + (is_value_type ? 2 : 0);</span>
1623 
1624   // The field array starts with tuples of shorts
1625   // [access, name index, sig index, initial value index, byte offset].
1626   // A generic signature slot only exists for field with generic
1627   // signature attribute. And the access flag is set with
1628   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1629   // signature slots are at the end of the field array and after all
1630   // other fields data.
1631   //
1632   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1633   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1634   //       ...
1635   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1636   //       [generic signature index]
1637   //       [generic signature index]
1638   //       ...
1639   //
1640   // Allocate a temporary resource array for field data. For each field,
1641   // a slot is reserved in the temporary array for the generic signature
1642   // index. After parsing all fields, the data are copied to a permanent
1643   // array and any unused slots will be discarded.
1644   ResourceMark rm(THREAD);
1645   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1646                                               u2,
1647                                               total_fields * (FieldInfo::field_slots + 1));
1648 
1649   // The generic signature slots start after all other fields&#39; data.
1650   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1651   int num_generic_signature = 0;
<span class="line-added">1652   int instance_fields_count = 0;</span>
1653   for (int n = 0; n &lt; length; n++) {
1654     // access_flags, name_index, descriptor_index, attributes_count
1655     cfs-&gt;guarantee_more(8, CHECK);
1656 
<span class="line-added">1657     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-added">1658 </span>
<span class="line-added">1659     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">1660     verify_legal_field_modifiers(flags, is_interface, is_value_type, CHECK);</span>
1661     AccessFlags access_flags;


1662     access_flags.set_flags(flags);
1663 
1664     const u2 name_index = cfs-&gt;get_u2_fast();
1665     check_property(valid_symbol_at(name_index),
1666       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1667       name_index, CHECK);
1668     const Symbol* const name = cp-&gt;symbol_at(name_index);
1669     verify_legal_field_name(name, CHECK);
1670 
1671     const u2 signature_index = cfs-&gt;get_u2_fast();
1672     check_property(valid_symbol_at(signature_index),
1673       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1674       signature_index, CHECK);
1675     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1676     verify_legal_field_signature(name, sig, CHECK);
<span class="line-added">1677     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);</span>
<span class="line-added">1678     if (sig-&gt;is_Q_signature()) {</span>
<span class="line-added">1679       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);</span>
<span class="line-added">1680       access_flags.set_is_flattenable();</span>
<span class="line-added">1681     }</span>
<span class="line-added">1682     if (access_flags.is_flattenable()) {</span>
<span class="line-added">1683       // Array flattenability cannot be specified.  Arrays of value classes are</span>
<span class="line-added">1684       // are always flattenable.  Arrays of other classes are not flattenable.</span>
<span class="line-added">1685       if (sig-&gt;utf8_length() &gt; 1 &amp;&amp; sig-&gt;char_at(0) == &#39;[&#39;) {</span>
<span class="line-added">1686         classfile_parse_error(</span>
<span class="line-added">1687             &quot;Field \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s is invalid.&quot;</span>
<span class="line-added">1688             &quot; ACC_FLATTENABLE cannot be specified for an array&quot;,</span>
<span class="line-added">1689             name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);</span>
<span class="line-added">1690       }</span>
<span class="line-added">1691       _has_flattenable_fields = true;</span>
<span class="line-added">1692     }</span>
<span class="line-added">1693     if (!access_flags.is_static()) instance_fields_count++;</span>
1694 
1695     u2 constantvalue_index = 0;
1696     bool is_synthetic = false;
1697     u2 generic_signature_index = 0;
1698     const bool is_static = access_flags.is_static();
1699     FieldAnnotationCollector parsed_annotations(_loader_data);
1700 
1701     const u2 attributes_count = cfs-&gt;get_u2_fast();
1702     if (attributes_count &gt; 0) {
1703       parse_field_attributes(cfs,
1704                              attributes_count,
1705                              is_static,
1706                              signature_index,
1707                              &amp;constantvalue_index,
1708                              &amp;is_synthetic,
1709                              &amp;generic_signature_index,
1710                              &amp;parsed_annotations,
1711                              CHECK);
1712 
1713       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1733 
1734       if (is_synthetic) {
1735         access_flags.set_is_synthetic();
1736       }
1737       if (generic_signature_index != 0) {
1738         access_flags.set_field_has_generic_signature();
1739         fa[generic_signature_slot] = generic_signature_index;
1740         generic_signature_slot ++;
1741         num_generic_signature ++;
1742       }
1743     }
1744 
1745     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1746     field-&gt;initialize(access_flags.as_short(),
1747                       name_index,
1748                       signature_index,
1749                       constantvalue_index);
1750     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1751 
1752     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1753     const FieldAllocationType atype = fac-&gt;update(is_static, type, access_flags.is_flattenable());</span>
1754     field-&gt;set_allocation_type(atype);
1755 
1756     // After field is initialized with type, we can augment it with aux info
1757     if (parsed_annotations.has_any_annotations()) {
1758       parsed_annotations.apply_to(field);
1759       if (field-&gt;is_contended()) {
1760         _has_contended_fields = true;
1761       }
1762     }
1763   }
1764 
1765   int index = length;
1766   if (num_injected != 0) {
1767     for (int n = 0; n &lt; num_injected; n++) {
1768       // Check for duplicates
1769       if (injected[n].may_be_java) {
1770         const Symbol* const name      = injected[n].name();
1771         const Symbol* const signature = injected[n].signature();
1772         bool duplicate = false;
1773         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1778             duplicate = true;
1779             break;
1780           }
1781         }
1782         if (duplicate) {
1783           // These will be removed from the field array at the end
1784           continue;
1785         }
1786       }
1787 
1788       // Injected field
1789       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1790       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1791                         injected[n].name_index,
1792                         injected[n].signature_index,
1793                         0);
1794 
1795       const BasicType type = Signature::basic_type(injected[n].signature());
1796 
1797       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1798       const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
1799       field-&gt;set_allocation_type(atype);
1800       index++;
1801     }
1802   }
1803 
<span class="line-added">1804   if (is_value_type) {</span>
<span class="line-added">1805     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1806     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,</span>
<span class="line-added">1807                       vmSymbols::default_value_name_enum,</span>
<span class="line-added">1808                       vmSymbols::object_signature_enum,</span>
<span class="line-added">1809                       0);</span>
<span class="line-added">1810     const BasicType type = Signature::basic_type(vmSymbols::object_signature());</span>
<span class="line-added">1811     const FieldAllocationType atype = fac-&gt;update(true, type, false);</span>
<span class="line-added">1812     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1813     index++;</span>
<span class="line-added">1814   }</span>
<span class="line-added">1815 </span>
<span class="line-added">1816   if (is_value_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-added">1817     _is_empty_value = true;</span>
<span class="line-added">1818     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1819     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,</span>
<span class="line-added">1820         vmSymbols::empty_marker_name_enum,</span>
<span class="line-added">1821         vmSymbols::byte_signature_enum,</span>
<span class="line-added">1822         0);</span>
<span class="line-added">1823     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());</span>
<span class="line-added">1824     const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
<span class="line-added">1825     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1826     index++;</span>
<span class="line-added">1827   }</span>
<span class="line-added">1828 </span>
1829   assert(NULL == _fields, &quot;invariant&quot;);
1830 
1831   _fields =
1832     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1833                                    index * FieldInfo::field_slots + num_generic_signature,
1834                                    CHECK);
1835   // Sometimes injected fields already exist in the Java source so
1836   // the fields array could be too long.  In that case the
1837   // fields array is trimed. Also unused slots that were reserved
1838   // for generic signature indexes are discarded.
1839   {
1840     int i = 0;
1841     for (; i &lt; index * FieldInfo::field_slots; i++) {
1842       _fields-&gt;at_put(i, fa[i]);
1843     }
1844     for (int j = total_fields * FieldInfo::field_slots;
1845          j &lt; generic_signature_slot; j++) {
1846       _fields-&gt;at_put(i++, fa[j]);
1847     }
1848     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2124         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2125         checked_exception, CHECK_NULL);
2126     }
2127   }
2128   // check exceptions attribute length
2129   if (_need_verify) {
2130     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2131                                                    sizeof(u2) * size),
2132                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2133   }
2134   return checked_exceptions_start;
2135 }
2136 
2137 void ClassFileParser::throwIllegalSignature(const char* type,
2138                                             const Symbol* name,
2139                                             const Symbol* sig,
2140                                             TRAPS) const {
2141   assert(name != NULL, &quot;invariant&quot;);
2142   assert(sig != NULL, &quot;invariant&quot;);
2143 
<span class="line-added">2144   const char* class_note = &quot;&quot;;</span>
<span class="line-added">2145   if (is_value_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2146     class_note = &quot; (an inline class)&quot;;</span>
<span class="line-added">2147   }</span>
<span class="line-added">2148 </span>
2149   ResourceMark rm(THREAD);
2150   Exceptions::fthrow(THREAD_AND_LOCATION,
2151       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2152       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2153       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());</span>
2154 }
2155 
2156 AnnotationCollector::ID
2157 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2158                                       const Symbol* name) {
2159   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2160   // Privileged code can use all annotations.  Other code silently drops some.
2161   const bool privileged = loader_data-&gt;is_the_null_class_loader_data() ||
2162                           loader_data-&gt;is_platform_class_loader_data() ||
2163                           loader_data-&gt;is_unsafe_anonymous();
2164   switch (sid) {
2165     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2166       if (_location != _in_method)  break;  // only allow for methods
2167       if (!privileged)              break;  // only allow in privileged code
2168       return _method_CallerSensitive;
2169     }
2170     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2171       if (_location != _in_method)  break;  // only allow for methods
2172       if (!privileged)              break;  // only allow in privileged code
2173       return _method_ForceInline;
</pre>
<hr />
<pre>
2397                              runtime_visible_type_annotations_length,
2398                              runtime_invisible_type_annotations,
2399                              runtime_invisible_type_annotations_length,
2400                              CHECK);
2401     cm-&gt;set_type_annotations(a);
2402   }
2403 }
2404 
2405 
2406 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2407 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2408 // Method* to save footprint, so we only know the size of the resulting Method* when the
2409 // entire method attribute is parsed.
2410 //
2411 // The promoted_flags parameter is used to pass relevant access_flags
2412 // from the method back up to the containing klass. These flag values
2413 // are added to klass&#39;s access_flags.
2414 
2415 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2416                                       bool is_interface,
<span class="line-added">2417                                       bool is_value_type,</span>
2418                                       const ConstantPool* cp,
2419                                       AccessFlags* const promoted_flags,
2420                                       TRAPS) {
2421   assert(cfs != NULL, &quot;invariant&quot;);
2422   assert(cp != NULL, &quot;invariant&quot;);
2423   assert(promoted_flags != NULL, &quot;invariant&quot;);
2424 
2425   ResourceMark rm(THREAD);
2426   // Parse fixed parts:
2427   // access_flags, name_index, descriptor_index, attributes_count
2428   cfs-&gt;guarantee_more(8, CHECK_NULL);
2429 
2430   int flags = cfs-&gt;get_u2_fast();
2431   const u2 name_index = cfs-&gt;get_u2_fast();
2432   const int cp_size = cp-&gt;length();
2433   check_property(
2434     valid_symbol_at(name_index),
2435     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2436     name_index, CHECK_NULL);
2437   const Symbol* const name = cp-&gt;symbol_at(name_index);
2438   verify_legal_method_name(name, CHECK_NULL);
2439 
2440   const u2 signature_index = cfs-&gt;get_u2_fast();
2441   guarantee_property(
2442     valid_symbol_at(signature_index),
2443     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2444     signature_index, CHECK_NULL);
2445   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2446 
2447   if (name == vmSymbols::class_initializer_name()) {
2448     // We ignore the other access flags for a valid class initializer.
2449     // (JVM Spec 2nd ed., chapter 4.6)
2450     if (_major_version &lt; 51) { // backward compatibility
2451       flags = JVM_ACC_STATIC;
2452     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2453       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2454     } else {
2455       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2456     }
2457   } else {
<span class="line-modified">2458     verify_legal_method_modifiers(flags, is_interface, is_value_type, name, CHECK_NULL);</span>
<span class="line-modified">2459   }</span>
<span class="line-modified">2460 </span>
<span class="line-modified">2461   if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">2462     if (is_interface) {</span>
<span class="line-added">2463       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>
<span class="line-added">2464     } else if (!is_value_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2465       // OK, a constructor</span>
<span class="line-added">2466     } else if (is_value_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2467       // also OK, a static factory, as long as the return value is good</span>
<span class="line-added">2468       bool ok = false;</span>
<span class="line-added">2469       SignatureStream ss((Symbol*) signature, true);</span>
<span class="line-added">2470       while (!ss.at_return_type())  ss.next();</span>
<span class="line-added">2471       if (ss.is_reference()) {</span>
<span class="line-added">2472         Symbol* ret = ss.as_symbol();</span>
<span class="line-added">2473         const Symbol* required = class_name();</span>
<span class="line-added">2474         if (is_unsafe_anonymous()) {</span>
<span class="line-added">2475           // The original class name in the UAC byte stream gets changed.  So</span>
<span class="line-added">2476           // using the original name in the return type is no longer valid.</span>
<span class="line-added">2477           required = vmSymbols::java_lang_Object();</span>
<span class="line-added">2478         }</span>
<span class="line-added">2479         ok = (ret == required);</span>
<span class="line-added">2480       }</span>
<span class="line-added">2481       if (!ok) {</span>
<span class="line-added">2482         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2483       }</span>
<span class="line-added">2484     } else {</span>
<span class="line-added">2485       // not OK, so throw the same error as in verify_legal_method_signature.</span>
<span class="line-added">2486       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2487     }</span>
<span class="line-added">2488     // A declared &lt;init&gt; method must always be either a non-static</span>
<span class="line-added">2489     // object constructor, with a void return, or else it must be a</span>
<span class="line-added">2490     // static factory method, with a non-void return.  No other</span>
<span class="line-added">2491     // definition of &lt;init&gt; is possible.</span>
<span class="line-added">2492     //</span>
<span class="line-added">2493     // The verifier (in verify_invoke_instructions) will inspect the</span>
<span class="line-added">2494     // signature of any attempt to invoke &lt;init&gt;, and ensures that it</span>
<span class="line-added">2495     // returns non-void if and only if it is being invoked by</span>
<span class="line-added">2496     // invokestatic, and void if and only if it is being invoked by</span>
<span class="line-added">2497     // invokespecial.</span>
<span class="line-added">2498     //</span>
<span class="line-added">2499     // When a symbolic reference to &lt;init&gt; is resolved for a</span>
<span class="line-added">2500     // particular invocation mode (special or static), the mode is</span>
<span class="line-added">2501     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.</span>
<span class="line-added">2502     // Thus, it is impossible to statically invoke a constructor, and</span>
<span class="line-added">2503     // impossible to &quot;new + invokespecial&quot; a static factory, either</span>
<span class="line-added">2504     // through bytecode or through reflection.</span>
2505   }
2506 
2507   int args_size = -1;  // only used when _need_verify is true
2508   if (_need_verify) {
2509     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2510                  verify_legal_method_signature(name, signature, CHECK_NULL);
2511     if (args_size &gt; MAX_ARGS_SIZE) {
2512       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2513     }
2514   }
2515 
2516   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2517 
2518   // Default values for code and exceptions attribute elements
2519   u2 max_stack = 0;
2520   u2 max_locals = 0;
2521   u4 code_length = 0;
2522   const u1* code_start = 0;
2523   u2 exception_table_length = 0;
2524   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
3030       _has_finalizer = true;
3031     }
3032   }
3033   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3034       signature == vmSymbols::void_method_signature() &amp;&amp;
3035       m-&gt;is_vanilla_constructor()) {
3036     _has_vanilla_constructor = true;
3037   }
3038 
3039   NOT_PRODUCT(m-&gt;verify());
3040   return m;
3041 }
3042 
3043 
3044 // The promoted_flags parameter is used to pass relevant access_flags
3045 // from the methods back up to the containing klass. These flag values
3046 // are added to klass&#39;s access_flags.
3047 // Side-effects: populates the _methods field in the parser
3048 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3049                                     bool is_interface,
<span class="line-added">3050                                     bool is_value_type,</span>
3051                                     AccessFlags* promoted_flags,
3052                                     bool* has_final_method,
3053                                     bool* declares_nonstatic_concrete_methods,
3054                                     TRAPS) {
3055   assert(cfs != NULL, &quot;invariant&quot;);
3056   assert(promoted_flags != NULL, &quot;invariant&quot;);
3057   assert(has_final_method != NULL, &quot;invariant&quot;);
3058   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3059 
3060   assert(NULL == _methods, &quot;invariant&quot;);
3061 
3062   cfs-&gt;guarantee_more(2, CHECK);  // length
3063   const u2 length = cfs-&gt;get_u2_fast();
3064   if (length == 0) {
3065     _methods = Universe::the_empty_method_array();
3066   } else {
3067     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3068                                                    length,
3069                                                    NULL,
3070                                                    CHECK);
3071 
3072     for (int index = 0; index &lt; length; index++) {
3073       Method* method = parse_method(cfs,
3074                                     is_interface,
<span class="line-added">3075                                     is_value_type,</span>
3076                                     _cp,
3077                                     promoted_flags,
3078                                     CHECK);
3079 
3080       if (method-&gt;is_final()) {
3081         *has_final_method = true;
3082       }
3083       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3084       // used for interface initialization, and default method inheritance analysis
3085       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3086         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3087         *declares_nonstatic_concrete_methods = true;
3088       }
3089       _methods-&gt;at_put(index, method);
3090     }
3091 
3092     if (_need_verify &amp;&amp; length &gt; 1) {
3093       // Check duplicated methods
3094       ResourceMark rm(THREAD);
3095       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3248       valid_klass_reference_at(inner_class_info_index),
3249       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3250       inner_class_info_index, CHECK_0);
3251     // Outer class index
3252     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3253     check_property(
3254       outer_class_info_index == 0 ||
3255         valid_klass_reference_at(outer_class_info_index),
3256       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3257       outer_class_info_index, CHECK_0);
3258     // Inner class name
3259     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3260     check_property(
3261       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3262       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3263       inner_name_index, CHECK_0);
3264     if (_need_verify) {
3265       guarantee_property(inner_class_info_index != outer_class_info_index,
3266                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3267     }
<span class="line-modified">3268 </span>
<span class="line-modified">3269     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
3270     // JVM_ACC_MODULE is defined in JDK-9 and later.
3271     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3272       recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">3273     }</span>
<span class="line-modified">3274     // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">3275     if (supports_value_types()) {</span>
<span class="line-added">3276       recognized_modifiers |= JVM_ACC_VALUE;</span>
3277     }
<span class="line-added">3278 </span>
<span class="line-added">3279     // Access flags</span>
<span class="line-added">3280     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">3281 </span>
3282     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3283       // Set abstract bit for old class files for backward compatibility
3284       flags |= JVM_ACC_ABSTRACT;
3285     }
3286     verify_legal_class_modifiers(flags, CHECK_0);
3287     AccessFlags inner_access_flags(flags);
3288 
3289     inner_classes-&gt;at_put(index++, inner_class_info_index);
3290     inner_classes-&gt;at_put(index++, outer_class_info_index);
3291     inner_classes-&gt;at_put(index++, inner_name_index);
3292     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3293   }
3294 
3295   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3296   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3297     for(int i = 0; i &lt; length * 4; i += 4) {
3298       for(int j = i + 4; j &lt; length * 4; j += 4) {
3299         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3300                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3301                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
3638   bool parsed_sourcefile_attribute = false;
3639   bool parsed_innerclasses_attribute = false;
3640   bool parsed_nest_members_attribute = false;
3641   bool parsed_nest_host_attribute = false;
3642   bool parsed_record_attribute = false;
3643   bool parsed_enclosingmethod_attribute = false;
3644   bool parsed_bootstrap_methods_attribute = false;
3645   const u1* runtime_visible_annotations = NULL;
3646   int runtime_visible_annotations_length = 0;
3647   const u1* runtime_invisible_annotations = NULL;
3648   int runtime_invisible_annotations_length = 0;
3649   const u1* runtime_visible_type_annotations = NULL;
3650   int runtime_visible_type_annotations_length = 0;
3651   const u1* runtime_invisible_type_annotations = NULL;
3652   int runtime_invisible_type_annotations_length = 0;
3653   bool runtime_invisible_type_annotations_exists = false;
3654   bool runtime_invisible_annotations_exists = false;
3655   bool parsed_source_debug_ext_annotations_exist = false;
3656   const u1* inner_classes_attribute_start = NULL;
3657   u4  inner_classes_attribute_length = 0;
<span class="line-added">3658   const u1* value_types_attribute_start = NULL;</span>
<span class="line-added">3659   u4 value_types_attribute_length = 0;</span>
3660   u2  enclosing_method_class_index = 0;
3661   u2  enclosing_method_method_index = 0;
3662   const u1* nest_members_attribute_start = NULL;
3663   u4  nest_members_attribute_length = 0;
3664   const u1* record_attribute_start = NULL;
3665   u4  record_attribute_length = 0;
3666 
3667   // Iterate over attributes
3668   while (attributes_count--) {
3669     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3670     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3671     const u4 attribute_length = cfs-&gt;get_u4_fast();
3672     check_property(
3673       valid_symbol_at(attribute_name_index),
3674       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3675       attribute_name_index, CHECK);
3676     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3677     if (tag == vmSymbols::tag_source_file()) {
3678       // Check for SourceFile tag
3679       if (_need_verify) {
</pre>
<hr />
<pre>
4043       }
4044     }
4045     if (runtime_invisible_annotations != NULL) {
4046       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
4047         int append = runtime_visible_annotations_length+i;
4048         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
4049       }
4050     }
4051   }
4052   return annotations;
4053 }
4054 
4055 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
4056                                                         const int super_class_index,
4057                                                         const bool need_verify,
4058                                                         TRAPS) {
4059   assert(cp != NULL, &quot;invariant&quot;);
4060   const InstanceKlass* super_klass = NULL;
4061 
4062   if (super_class_index == 0) {
<span class="line-modified">4063     check_property(_class_name == vmSymbols::java_lang_Object()</span>
<span class="line-added">4064                    || (_access_flags.get_flags() &amp; JVM_ACC_VALUE),</span>
4065                    &quot;Invalid superclass index %u in class file %s&quot;,
4066                    super_class_index,
4067                    CHECK_NULL);
4068   } else {
4069     check_property(valid_klass_reference_at(super_class_index),
4070                    &quot;Invalid superclass index %u in class file %s&quot;,
4071                    super_class_index,
4072                    CHECK_NULL);
4073     // The class name should be legal because it is checked when parsing constant pool.
4074     // However, make sure it is not an array type.
4075     bool is_array = false;
4076     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4077       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4078       if (need_verify)
4079         is_array = super_klass-&gt;is_array_klass();
4080     } else if (need_verify) {
4081       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4082     }
4083     if (need_verify) {
4084       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4224 }
4225 
4226 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4227   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4228   if (_nonstatic_oop_map_count &gt; 0) {
4229     OopMapBlock* map = _nonstatic_oop_maps;
4230     OopMapBlock* last_map = last_oop_map();
4231     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4232     while (map &lt;= last_map) {
4233       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4234                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4235       map++;
4236     }
4237   }
4238 }
4239 
4240 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4241   print_on(st);
4242 }
4243 
<span class="line-added">4244 void ClassFileParser::throwValueTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-added">4245                                                const char* msg,</span>
<span class="line-added">4246                                                const Symbol* name,</span>
<span class="line-added">4247                                                const Symbol* sig) const {</span>
<span class="line-added">4248 </span>
<span class="line-added">4249   ResourceMark rm(THREAD);</span>
<span class="line-added">4250   if (name == NULL || sig == NULL) {</span>
<span class="line-added">4251     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4252         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4253         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4254   }</span>
<span class="line-added">4255   else {</span>
<span class="line-added">4256     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4257         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4258         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),</span>
<span class="line-added">4259         _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4260   }</span>
<span class="line-added">4261 }</span>
<span class="line-added">4262 </span>
4263 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4264 void ClassFileParser::layout_fields(ConstantPool* cp,
4265                                     const FieldAllocationCount* fac,
4266                                     const ClassAnnotationCollector* parsed_annotations,
4267                                     FieldLayoutInfo* info,
4268                                     TRAPS) {
4269 
4270   assert(cp != NULL, &quot;invariant&quot;);
4271 
4272   // Field size and offset computation
4273   int nonstatic_field_size = _super_klass == NULL ? 0 :
4274                                _super_klass-&gt;nonstatic_field_size();
<span class="line-added">4275   int next_nonstatic_valuetype_offset = 0;</span>
<span class="line-added">4276   int first_nonstatic_valuetype_offset = 0;</span>
<span class="line-added">4277 </span>
<span class="line-added">4278   // Fields that are value types are handled differently depending if they are static or not:</span>
<span class="line-added">4279   // - static fields are oops</span>
<span class="line-added">4280   // - non-static fields are embedded</span>
4281 
4282   // Count the contended fields by type.
4283   //
4284   // We ignore static fields, because @Contended is not supported for them.
4285   // The layout code below will also ignore the static fields.
4286   int nonstatic_contended_count = 0;
4287   FieldAllocationCount fac_contended;
4288   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4289     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4290     if (fs.is_contended()) {
4291       fac_contended.count[atype]++;
4292       if (!fs.access_flags().is_static()) {
4293         nonstatic_contended_count++;
4294       }
4295     }
4296   }
4297 
4298 
4299   // Calculate the starting byte offsets
4300   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-added">4301   // Value types in static fields are not embedded, they are handled with oops</span>
4302   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4303                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);</span>
4304   if (fac-&gt;count[STATIC_DOUBLE]) {
4305     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4306   }
4307 
4308   int next_static_word_offset   = next_static_double_offset +
4309                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4310   int next_static_short_offset  = next_static_word_offset +
4311                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4312   int next_static_byte_offset   = next_static_short_offset +
4313                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4314 
4315   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4316                                 nonstatic_field_size * heapOopSize;
4317 
<span class="line-added">4318   // First field of value types is aligned on a long boundary in order to ease</span>
<span class="line-added">4319   // in-lining of value types (with header removal) in packed arrays and</span>
<span class="line-added">4320   // flatten value types</span>
<span class="line-added">4321   int initial_value_type_padding = 0;</span>
<span class="line-added">4322   if (is_value_type()) {</span>
<span class="line-added">4323     int old = nonstatic_fields_start;</span>
<span class="line-added">4324     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);</span>
<span class="line-added">4325     initial_value_type_padding = nonstatic_fields_start - old;</span>
<span class="line-added">4326   }</span>
<span class="line-added">4327 </span>
4328   int next_nonstatic_field_offset = nonstatic_fields_start;
4329 
4330   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4331 
4332   // Class is contended, pad before all the fields
4333   if (is_contended_class) {
4334     next_nonstatic_field_offset += ContendedPaddingWidth;
4335   }
4336 
<span class="line-added">4337   // Temporary value types restrictions</span>
<span class="line-added">4338   if (is_value_type()) {</span>
<span class="line-added">4339     if (is_contended_class) {</span>
<span class="line-added">4340       throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
<span class="line-added">4341       return;</span>
<span class="line-added">4342     }</span>
<span class="line-added">4343   }</span>
<span class="line-added">4344 </span>
4345   // Compute the non-contended fields count.
4346   // The packing code below relies on these counts to determine if some field
4347   // can be squeezed into the alignment gap. Contended fields are obviously
4348   // exempt from that.
4349   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4350   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4351   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4352   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4353   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4354 
<span class="line-added">4355   int static_value_type_count = 0;</span>
<span class="line-added">4356   int nonstatic_value_type_count = 0;</span>
<span class="line-added">4357   int* nonstatic_value_type_indexes = NULL;</span>
<span class="line-added">4358   Klass** nonstatic_value_type_klasses = NULL;</span>
<span class="line-added">4359   unsigned int value_type_oop_map_count = 0;</span>
<span class="line-added">4360   int not_flattened_value_types = 0;</span>
<span class="line-added">4361   int not_atomic_value_types = 0;</span>
<span class="line-added">4362 </span>
<span class="line-added">4363   int max_nonstatic_value_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
<span class="line-added">4364 </span>
<span class="line-added">4365   nonstatic_value_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-added">4366                                                               max_nonstatic_value_type);</span>
<span class="line-added">4367   for (int i = 0; i &lt; max_nonstatic_value_type; i++) {</span>
<span class="line-added">4368     nonstatic_value_type_indexes[i] = -1;</span>
<span class="line-added">4369   }</span>
<span class="line-added">4370   nonstatic_value_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-added">4371                                                               max_nonstatic_value_type);</span>
<span class="line-added">4372 </span>
<span class="line-added">4373   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {</span>
<span class="line-added">4374     if (fs.allocation_type() == STATIC_FLATTENABLE) {</span>
<span class="line-added">4375       ResourceMark rm;</span>
<span class="line-added">4376       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4377         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4378       }</span>
<span class="line-added">4379       static_value_type_count++;</span>
<span class="line-added">4380     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {</span>
<span class="line-added">4381       // Pre-resolve the flattenable field and check for value type circularity issues.</span>
<span class="line-added">4382       ResourceMark rm;</span>
<span class="line-added">4383       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4384         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4385       }</span>
<span class="line-added">4386       Klass* klass =</span>
<span class="line-added">4387         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">4388                                                             Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">4389                                                             _protection_domain, true, CHECK);</span>
<span class="line-added">4390       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">4391       if (!klass-&gt;access_flags().is_value_type()) {</span>
<span class="line-added">4392         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">4393       }</span>
<span class="line-added">4394       ValueKlass* vk = ValueKlass::cast(klass);</span>
<span class="line-added">4395       // Conditions to apply flattening or not should be defined in a single place</span>
<span class="line-added">4396       bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-added">4397                                  (vk-&gt;size_helper() * HeapWordSize) &gt; ValueFieldMaxFlatSize);</span>
<span class="line-added">4398       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();</span>
<span class="line-added">4399       bool too_volatile_to_flatten = fs.access_flags().is_volatile();</span>
<span class="line-added">4400       if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-added">4401         too_atomic_to_flatten = false;</span>
<span class="line-added">4402         //too_volatile_to_flatten = false; //FIXME</span>
<span class="line-added">4403         // volatile fields are currently never flattened, this could change in the future</span>
<span class="line-added">4404       }</span>
<span class="line-added">4405       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {</span>
<span class="line-added">4406         nonstatic_value_type_indexes[nonstatic_value_type_count] = fs.index();</span>
<span class="line-added">4407         nonstatic_value_type_klasses[nonstatic_value_type_count] = klass;</span>
<span class="line-added">4408         nonstatic_value_type_count++;</span>
<span class="line-added">4409 </span>
<span class="line-added">4410         ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4411         if (vklass-&gt;contains_oops()) {</span>
<span class="line-added">4412           value_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4413         }</span>
<span class="line-added">4414         fs.set_flattened(true);</span>
<span class="line-added">4415         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-added">4416           not_atomic_value_types++;</span>
<span class="line-added">4417         }</span>
<span class="line-added">4418       } else {</span>
<span class="line-added">4419         not_flattened_value_types++;</span>
<span class="line-added">4420         fs.set_flattened(false);</span>
<span class="line-added">4421       }</span>
<span class="line-added">4422     }</span>
<span class="line-added">4423   }</span>
<span class="line-added">4424 </span>
<span class="line-added">4425   // Adjusting non_static_oop_count to take into account not flattened value types;</span>
<span class="line-added">4426   nonstatic_oop_count += not_flattened_value_types;</span>
<span class="line-added">4427 </span>
4428   // Total non-static fields count, including every contended field
4429   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4430                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4431                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];</span>
4432 
4433   const bool super_has_nonstatic_fields =
4434           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4435   const bool has_nonstatic_fields =
4436     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-added">4437   const bool has_nonstatic_value_fields = nonstatic_value_type_count &gt; 0;</span>
4438 
<span class="line-added">4439   if (is_value_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
<span class="line-added">4440     // There are a number of fixes required throughout the type system and JIT</span>
<span class="line-added">4441     throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
<span class="line-added">4442     return;</span>
<span class="line-added">4443   }</span>
4444 
4445   // Prepare list of oops for oop map generation.
4446   //
4447   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4448   // regions. offset[i] is the start of the i-th region, which then has
4449   // count[i] oops following. Before we know how many regions are required,
4450   // we pessimistically allocate the maps to fit all the oops into the
4451   // distinct regions.
<span class="line-modified">4452   //</span>
4453   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4454   int max_oop_map_count =</span>
<span class="line-added">4455       super_oop_map_count +</span>
<span class="line-added">4456       fac-&gt;count[NONSTATIC_OOP] +</span>
<span class="line-added">4457       value_type_oop_map_count +</span>
<span class="line-added">4458       not_flattened_value_types;</span>
4459 
4460   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4461   if (super_oop_map_count &gt; 0) {
4462     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4463                                                     _super_klass-&gt;nonstatic_oop_map_count());
4464   }
4465 
4466   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4467 
4468   bool compact_fields  = true;
4469   bool allocate_oops_first = false;
4470 
4471   // The next classes have predefined hard-coded fields offsets
4472   // (see in JavaClasses::compute_hard_coded_offsets()).
4473   // Use default fields allocation order for them.
4474   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4475       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4476        _class_name == vmSymbols::java_lang_Boolean() ||
4477        _class_name == vmSymbols::java_lang_Character() ||
4478        _class_name == vmSymbols::java_lang_Float() ||
</pre>
<hr />
<pre>
4550   }
4551 
4552   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4553                                      (nonstatic_double_count * BytesPerLong);
4554   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4555                                       (nonstatic_word_count * BytesPerInt);
4556   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4557                                      (nonstatic_short_count * BytesPerShort);
4558   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4559                                        nonstatic_byte_count;
4560 
4561   // let oops jump before padding with this allocation style
4562   if (!allocate_oops_first) {
4563     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4564     if( nonstatic_oop_count &gt; 0 ) {
4565       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4566     }
4567     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4568   }
4569 
<span class="line-added">4570   // Aligning embedded value types</span>
<span class="line-added">4571   // bug below, the current algorithm to layout embedded value types always put them at the</span>
<span class="line-added">4572   // end of the layout, which doesn&#39;t match the different allocation policies the VM is</span>
<span class="line-added">4573   // supposed to provide =&gt; FixMe</span>
<span class="line-added">4574   // Note also that the current alignment policy is to make each value type starting on a</span>
<span class="line-added">4575   // 64 bits boundary. This could be optimized later. For instance, it could be nice to</span>
<span class="line-added">4576   // align value types according to their most constrained internal type.</span>
<span class="line-added">4577   next_nonstatic_valuetype_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-added">4578   int next_value_type_index = 0;</span>
<span class="line-added">4579 </span>
4580   // Iterate over fields again and compute correct offsets.
4581   // The field allocation type was temporarily stored in the offset slot.
4582   // oop fields are located before non-oop fields (static and non-static).
4583   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4584 
4585     // skip already laid out fields
4586     if (fs.is_offset_set()) continue;
4587 
4588     // contended instance fields are handled below
4589     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4590 
4591     int real_offset = 0;
4592     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4593 
4594     // pack the rest of the fields
4595     switch (atype) {
<span class="line-added">4596       // Value types in static fields are handled with oops</span>
<span class="line-added">4597       case STATIC_FLATTENABLE:   // Fallthrough</span>
4598       case STATIC_OOP:
4599         real_offset = next_static_oop_offset;
4600         next_static_oop_offset += heapOopSize;
4601         break;
4602       case STATIC_BYTE:
4603         real_offset = next_static_byte_offset;
4604         next_static_byte_offset += 1;
4605         break;
4606       case STATIC_SHORT:
4607         real_offset = next_static_short_offset;
4608         next_static_short_offset += BytesPerShort;
4609         break;
4610       case STATIC_WORD:
4611         real_offset = next_static_word_offset;
4612         next_static_word_offset += BytesPerInt;
4613         break;
4614       case STATIC_DOUBLE:
4615         real_offset = next_static_double_offset;
4616         next_static_double_offset += BytesPerLong;
4617         break;
<span class="line-added">4618       case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">4619         if (fs.is_flattened()) {</span>
<span class="line-added">4620           Klass* klass = nonstatic_value_type_klasses[next_value_type_index];</span>
<span class="line-added">4621           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);</span>
<span class="line-added">4622           assert(klass-&gt;access_flags().is_value_type(),&quot;Must be a value type&quot;);</span>
<span class="line-added">4623           ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4624           real_offset = next_nonstatic_valuetype_offset;</span>
<span class="line-added">4625           next_nonstatic_valuetype_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-added">4626           // aligning next value type on a 64 bits boundary</span>
<span class="line-added">4627           next_nonstatic_valuetype_offset = align_up(next_nonstatic_valuetype_offset, BytesPerLong);</span>
<span class="line-added">4628           next_value_type_index += 1;</span>
<span class="line-added">4629 </span>
<span class="line-added">4630           if (vklass-&gt;contains_oops()) { // add flatten oop maps</span>
<span class="line-added">4631             int diff = real_offset - vklass-&gt;first_field_offset();</span>
<span class="line-added">4632             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">4633             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4634             while (map &lt; last_map) {</span>
<span class="line-added">4635               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());</span>
<span class="line-added">4636               map++;</span>
<span class="line-added">4637             }</span>
<span class="line-added">4638           }</span>
<span class="line-added">4639           break;</span>
<span class="line-added">4640         } else {</span>
<span class="line-added">4641           // Fall through</span>
<span class="line-added">4642         }</span>
4643       case NONSTATIC_OOP:
4644         if( nonstatic_oop_space_count &gt; 0 ) {
4645           real_offset = nonstatic_oop_space_offset;
4646           nonstatic_oop_space_offset += heapOopSize;
4647           nonstatic_oop_space_count  -= 1;
4648         } else {
4649           real_offset = next_nonstatic_oop_offset;
4650           next_nonstatic_oop_offset += heapOopSize;
4651         }
4652         nonstatic_oop_maps-&gt;add(real_offset, 1);
4653         break;
4654       case NONSTATIC_BYTE:
4655         if( nonstatic_byte_space_count &gt; 0 ) {
4656           real_offset = nonstatic_byte_space_offset;
4657           nonstatic_byte_space_offset += 1;
4658           nonstatic_byte_space_count  -= 1;
4659         } else {
4660           real_offset = next_nonstatic_byte_offset;
4661           next_nonstatic_byte_offset += 1;
4662         }
</pre>
<hr />
<pre>
4741             break;
4742 
4743           case NONSTATIC_SHORT:
4744             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4745             real_offset = next_nonstatic_padded_offset;
4746             next_nonstatic_padded_offset += BytesPerShort;
4747             break;
4748 
4749           case NONSTATIC_WORD:
4750             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4751             real_offset = next_nonstatic_padded_offset;
4752             next_nonstatic_padded_offset += BytesPerInt;
4753             break;
4754 
4755           case NONSTATIC_DOUBLE:
4756             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4757             real_offset = next_nonstatic_padded_offset;
4758             next_nonstatic_padded_offset += BytesPerLong;
4759             break;
4760 
<span class="line-added">4761             // Value types in static fields are handled with oops</span>
<span class="line-added">4762           case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">4763             throwValueTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-added">4764                                      &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
<span class="line-added">4765             return;</span>
<span class="line-added">4766 </span>
4767           case NONSTATIC_OOP:
4768             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4769             real_offset = next_nonstatic_padded_offset;
4770             next_nonstatic_padded_offset += heapOopSize;
4771             nonstatic_oop_maps-&gt;add(real_offset, 1);
4772             break;
4773 
4774           default:
4775             ShouldNotReachHere();
4776         }
4777 
4778         if (fs.contended_group() == 0) {
4779           // Contended group defines the equivalence class over the fields:
4780           // the fields within the same contended group are not inter-padded.
4781           // The only exception is default group, which does not incur the
4782           // equivalence, and so requires intra-padding.
4783           next_nonstatic_padded_offset += ContendedPaddingWidth;
4784         }
4785 
4786         fs.set_offset(real_offset);
4787       } // for
4788 
4789       // Start laying out the next group.
4790       // Note that this will effectively pad the last group in the back;
4791       // this is expected to alleviate memory contention effects for
4792       // subclass fields and/or adjacent object.
4793       // If this was the default group, the padding is already in place.
4794       if (current_group != 0) {
4795         next_nonstatic_padded_offset += ContendedPaddingWidth;
4796       }
4797     }
4798 
4799     // handle static fields
4800   }
4801 
4802   // Entire class is contended, pad in the back.
4803   // This helps to alleviate memory contention effects for subclass fields
4804   // and/or adjacent object.
4805   if (is_contended_class) {
<span class="line-added">4806     assert(!is_value_type(), &quot;@Contended not supported for value types yet&quot;);</span>
4807     next_nonstatic_padded_offset += ContendedPaddingWidth;
4808   }
4809 
<span class="line-modified">4810   int notaligned_nonstatic_fields_end;</span>
<span class="line-added">4811   if (nonstatic_value_type_count != 0) {</span>
<span class="line-added">4812     notaligned_nonstatic_fields_end = next_nonstatic_valuetype_offset;</span>
<span class="line-added">4813   } else {</span>
<span class="line-added">4814     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>
<span class="line-added">4815   }</span>
4816 
<span class="line-modified">4817   int nonstatic_field_sz_align = heapOopSize;</span>
<span class="line-added">4818   if (is_value_type()) {</span>
<span class="line-added">4819     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {</span>
<span class="line-added">4820       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy</span>
<span class="line-added">4821     }</span>
<span class="line-added">4822   }</span>
<span class="line-added">4823   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);</span>
4824   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4825   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4826 
4827   int static_field_size         = (static_fields_end -
4828                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4829   nonstatic_field_size          = nonstatic_field_size +
4830                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4831 
4832   int instance_size             = align_object_size(instance_end / wordSize);
4833 
4834   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4835          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)</span>
<span class="line-modified">4836          + initial_value_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
<span class="line-added">4837 </span>
4838 
4839   // Invariant: nonstatic_field end/start should only change if there are
4840   // nonstatic fields in the class, or if the class is contended. We compare
4841   // against the non-aligned value, so that end alignment will not fail the
4842   // assert without actually having the fields.
4843   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4844          is_contended_class ||
4845          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4846 
4847   // Number of non-static oop map blocks allocated at end of klass.
4848   nonstatic_oop_maps-&gt;compact();
4849 
4850 #ifndef PRODUCT
<span class="line-modified">4851   if ((PrintFieldLayout &amp;&amp; !is_value_type()) ||</span>
<span class="line-added">4852       (PrintValueLayout &amp;&amp; (is_value_type() || has_nonstatic_value_fields))) {</span>
4853     print_field_layout(_class_name,
4854           _fields,
4855           cp,
4856           instance_size,
4857           nonstatic_fields_start,
4858           nonstatic_fields_end,
4859           static_fields_end);
<span class="line-added">4860     nonstatic_oop_maps-&gt;print_on(tty);</span>
<span class="line-added">4861     tty-&gt;print(&quot;\n&quot;);</span>
<span class="line-added">4862     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);</span>
<span class="line-added">4863     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);</span>
<span class="line-added">4864     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);</span>
<span class="line-added">4865     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);</span>
<span class="line-added">4866     tty-&gt;print_cr(&quot;---&quot;);</span>
4867   }
4868 
4869 #endif
4870   // Pass back information needed for InstanceKlass creation
4871   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4872   info-&gt;_instance_size = instance_size;
4873   info-&gt;_static_field_size = static_field_size;
4874   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4875   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<span class="line-added">4876 </span>
<span class="line-added">4877   // A value type is naturally atomic if it has just one field, and</span>
<span class="line-added">4878   // that field is simple enough.</span>
<span class="line-added">4879   info-&gt;_is_naturally_atomic = (is_value_type() &amp;&amp;</span>
<span class="line-added">4880                                 !super_has_nonstatic_fields &amp;&amp;</span>
<span class="line-added">4881                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;</span>
<span class="line-added">4882                                 (not_atomic_value_types == 0) &amp;&amp;</span>
<span class="line-added">4883                                 (nonstatic_contended_count == 0));</span>
<span class="line-added">4884   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="line-added">4885   // bits we could make the decision to align instances of this class</span>
<span class="line-added">4886   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="line-added">4887   // And on machines which supported larger atomics we could similarly</span>
<span class="line-added">4888   // allow larger values to be atomic, if properly aligned.</span>
4889 }
4890 
4891 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4892   assert(ik != NULL, &quot;invariant&quot;);
4893 
4894   const Klass* const super = ik-&gt;super();
4895 
4896   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4897   // in which case we don&#39;t have to register objects as finalizable
4898   if (!_has_empty_finalizer) {
4899     if (_has_finalizer ||
4900         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4901       ik-&gt;set_has_finalizer();
4902     }
4903   }
4904 
4905 #ifdef ASSERT
4906   bool f = false;
4907   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4908                                            vmSymbols::void_method_signature());
4909   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4910       f = true;
4911   }
4912 
4913   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4914   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4915   // will not work as expected we shouldn&#39;t abort vm in this case
4916   if (!ik-&gt;has_redefined_this_or_super()) {
4917     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4918   }
4919 #endif
4920 
4921   // Check if this klass supports the java.lang.Cloneable interface
4922   if (SystemDictionary::Cloneable_klass_loaded()) {
4923     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
<span class="line-added">4924       if (ik-&gt;is_value()) {</span>
<span class="line-added">4925         Thread *THREAD = Thread::current();</span>
<span class="line-added">4926         throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
<span class="line-added">4927         return;</span>
<span class="line-added">4928       }</span>
4929       ik-&gt;set_is_cloneable();
4930     }
4931   }
4932 
4933   // Check if this klass has a vanilla default constructor
4934   if (super == NULL) {
4935     // java.lang.Object has empty default constructor
4936     ik-&gt;set_has_vanilla_constructor();
4937   } else {
4938     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4939         _has_vanilla_constructor) {
4940       ik-&gt;set_has_vanilla_constructor();
4941     }
4942 #ifdef ASSERT
4943     bool v = false;
4944     if (super-&gt;has_vanilla_constructor()) {
4945       const Method* const constructor =
4946         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4947                        vmSymbols::void_method_signature());
4948       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4949         v = true;
4950       }
4951     }
4952     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4953 #endif
4954   }
4955 
4956   // If it cannot be fast-path allocated, set a bit in the layout helper.
4957   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4958   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4959   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4960       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4961       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4962       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4963     // Forbid fast-path allocation.
4964     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4965     ik-&gt;set_layout_helper(lh);
4966   }
4967 }
4968 
<span class="line-added">4969 bool ClassFileParser::supports_value_types() const {</span>
<span class="line-added">4970   // Value types are only supported by class file version 55 and later</span>
<span class="line-added">4971   return _major_version &gt;= JAVA_11_VERSION;</span>
<span class="line-added">4972 }</span>
<span class="line-added">4973 </span>
4974 // utility methods for appending an array with check for duplicates
4975 
4976 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4977                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4978   // iterate over new interfaces
4979   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4980     InstanceKlass* const e = ifs-&gt;at(i);
4981     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4982     // add new interface
4983     result-&gt;append_if_missing(e);
4984   }
4985 }
4986 
4987 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4988                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4989                                                             ClassLoaderData* loader_data,
4990                                                             TRAPS) {
4991   assert(local_ifs != NULL, &quot;invariant&quot;);
4992   assert(loader_data != NULL, &quot;invariant&quot;);
4993 
</pre>
<hr />
<pre>
5217     const Method* const m = methods-&gt;at(index);
5218     // if m is static and not the init method, throw a verify error
5219     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5220       ResourceMark rm(THREAD);
5221       Exceptions::fthrow(
5222         THREAD_AND_LOCATION,
5223         vmSymbols::java_lang_VerifyError(),
5224         &quot;Illegal static method %s in interface %s&quot;,
5225         m-&gt;name()-&gt;as_C_string(),
5226         this_klass-&gt;external_name()
5227       );
5228       return;
5229     }
5230   }
5231 }
5232 
5233 // utility methods for format checking
5234 
5235 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5236   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-added">5237   const bool is_value_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
5238   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-added">5239   assert(supports_value_types() || !is_value_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
5240   if (is_module) {
5241     ResourceMark rm(THREAD);
5242     Exceptions::fthrow(
5243       THREAD_AND_LOCATION,
5244       vmSymbols::java_lang_NoClassDefFoundError(),
5245       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5246       _class_name-&gt;as_C_string());
5247     return;
5248   }
5249 
<span class="line-added">5250   if (is_value_type &amp;&amp; !EnableValhalla) {</span>
<span class="line-added">5251     ResourceMark rm(THREAD);</span>
<span class="line-added">5252     Exceptions::fthrow(</span>
<span class="line-added">5253       THREAD_AND_LOCATION,</span>
<span class="line-added">5254       vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">5255       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,</span>
<span class="line-added">5256       _class_name-&gt;as_C_string()</span>
<span class="line-added">5257     );</span>
<span class="line-added">5258   }</span>
<span class="line-added">5259 </span>
5260   if (!_need_verify) { return; }
5261 
5262   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5263   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5264   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5265   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5266   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5267   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5268   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5269   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5270 
5271   if ((is_abstract &amp;&amp; is_final) ||
5272       (is_interface &amp;&amp; !is_abstract) ||
5273       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">5274       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||</span>
<span class="line-added">5275       (is_value_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
5276     ResourceMark rm(THREAD);
<span class="line-added">5277     const char* class_note = &quot;&quot;;</span>
<span class="line-added">5278     if (is_value_type)  class_note = &quot; (an inline class)&quot;;</span>
5279     Exceptions::fthrow(
5280       THREAD_AND_LOCATION,
5281       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5282       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,</span>
<span class="line-modified">5283       _class_name-&gt;as_C_string(), class_note, flags</span>
5284     );
5285     return;
5286   }
5287 }
5288 
5289 static bool has_illegal_visibility(jint flags) {
5290   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5291   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5292   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5293 
5294   return ((is_public &amp;&amp; is_protected) ||
5295           (is_public &amp;&amp; is_private) ||
5296           (is_protected &amp;&amp; is_private));
5297 }
5298 
5299 // A legal major_version.minor_version must be one of the following:
5300 //
5301 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5302 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5303 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
5342     if (!Arguments::enable_preview()) {
5343       Exceptions::fthrow(
5344         THREAD_AND_LOCATION,
5345         vmSymbols::java_lang_UnsupportedClassVersionError(),
5346         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5347         class_name-&gt;as_C_string(), major, minor);
5348       return;
5349     }
5350 
5351   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5352     Exceptions::fthrow(
5353         THREAD_AND_LOCATION,
5354         vmSymbols::java_lang_UnsupportedClassVersionError(),
5355         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5356         class_name-&gt;as_C_string(), major, minor);
5357   }
5358 }
5359 
5360 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5361                                                    bool is_interface,
<span class="line-added">5362                                                    bool is_value_type,</span>
5363                                                    TRAPS) const {
5364   if (!_need_verify) { return; }
5365 
5366   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5367   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5368   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5369   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5370   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5371   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5372   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5373   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5374   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5375 
5376   bool is_illegal = false;
5377 
5378   if (is_interface) {
5379     if (!is_public || !is_static || !is_final || is_private ||
5380         is_protected || is_volatile || is_transient ||
5381         (major_gte_1_5 &amp;&amp; is_enum)) {
5382       is_illegal = true;
5383     }
5384   } else { // not interface
5385     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5386       is_illegal = true;
<span class="line-added">5387     } else {</span>
<span class="line-added">5388       if (is_value_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
<span class="line-added">5389         is_illegal = true;</span>
<span class="line-added">5390       }</span>
5391     }
5392   }
5393 
5394   if (is_illegal) {
5395     ResourceMark rm(THREAD);
5396     Exceptions::fthrow(
5397       THREAD_AND_LOCATION,
5398       vmSymbols::java_lang_ClassFormatError(),
5399       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5400       _class_name-&gt;as_C_string(), flags);
5401     return;
5402   }
5403 }
5404 
5405 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5406                                                     bool is_interface,
<span class="line-added">5407                                                     bool is_value_type,</span>
5408                                                     const Symbol* name,
5409                                                     TRAPS) const {
5410   if (!_need_verify) { return; }
5411 
5412   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5413   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5414   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5415   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5416   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5417   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5418   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5419   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5420   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5421   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5422   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5423   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5424   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5425 
5426   bool is_illegal = false;
5427 
<span class="line-added">5428   const char* class_note = &quot;&quot;;</span>
<span class="line-added">5429 </span>
5430   if (is_interface) {
5431     if (major_gte_8) {
5432       // Class file version is JAVA_8_VERSION or later Methods of
5433       // interfaces may set any of the flags except ACC_PROTECTED,
5434       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5435       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5436       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5437           (is_native || is_protected || is_final || is_synchronized) ||
5438           // If a specific method of a class or interface has its
5439           // ACC_ABSTRACT flag set, it must not have any of its
5440           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5441           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5442           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5443           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5444           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5445         is_illegal = true;
5446       }
5447     } else if (major_gte_1_5) {
5448       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5449       if (!is_public || is_private || is_protected || is_static || is_final ||
5450           is_synchronized || is_native || !is_abstract || is_strict) {
5451         is_illegal = true;
5452       }
5453     } else {
5454       // Class file version is pre-JAVA_1_5_VERSION
5455       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5456         is_illegal = true;
5457       }
5458     }
5459   } else { // not interface
5460     if (has_illegal_visibility(flags)) {
5461       is_illegal = true;
5462     } else {
5463       if (is_initializer) {
<span class="line-modified">5464         if (is_final || is_synchronized || is_native ||</span>
5465             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5466           is_illegal = true;
5467         }
<span class="line-added">5468         if (!is_static &amp;&amp; !is_value_type) {</span>
<span class="line-added">5469           // OK, an object constructor in a regular class</span>
<span class="line-added">5470         } else if (is_static &amp;&amp; is_value_type) {</span>
<span class="line-added">5471           // OK, a static init factory in an inline class</span>
<span class="line-added">5472         } else {</span>
<span class="line-added">5473           // but no other combinations are allowed</span>
<span class="line-added">5474           is_illegal = true;</span>
<span class="line-added">5475           class_note = (is_value_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
<span class="line-added">5476         }</span>
5477       } else { // not initializer
<span class="line-modified">5478         if (is_value_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
<span class="line-modified">5479           is_illegal = true;</span>
<span class="line-modified">5480           class_note = &quot; (an inline class)&quot;;</span>
<span class="line-modified">5481         } else {</span>
<span class="line-added">5482           if (is_abstract) {</span>
<span class="line-added">5483             if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-added">5484                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-added">5485               is_illegal = true;</span>
<span class="line-added">5486             }</span>
5487           }
5488         }
5489       }
5490     }
5491   }
5492 
5493   if (is_illegal) {
5494     ResourceMark rm(THREAD);
5495     Exceptions::fthrow(
5496       THREAD_AND_LOCATION,
5497       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5498       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5499       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);</span>
5500     return;
5501   }
5502 }
5503 
5504 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5505                                         int length,
5506                                         TRAPS) const {
5507   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5508   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5509     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5510   }
5511 }
5512 
5513 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5514 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5515 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5516 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5517 // method.  Because these names have been checked as special cases before
5518 // calling this method in verify_legal_method_name.
5519 //
</pre>
<hr />
<pre>
5637 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5638 // Return a pointer to just past the signature.
5639 // Return NULL if no legal signature is found.
5640 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5641                                                        bool void_ok,
5642                                                        unsigned int length,
5643                                                        TRAPS) const {
5644   unsigned int array_dim = 0;
5645   while (length &gt; 0) {
5646     switch (signature[0]) {
5647     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5648     case JVM_SIGNATURE_BOOLEAN:
5649     case JVM_SIGNATURE_BYTE:
5650     case JVM_SIGNATURE_CHAR:
5651     case JVM_SIGNATURE_SHORT:
5652     case JVM_SIGNATURE_INT:
5653     case JVM_SIGNATURE_FLOAT:
5654     case JVM_SIGNATURE_LONG:
5655     case JVM_SIGNATURE_DOUBLE:
5656       return signature + 1;
<span class="line-modified">5657     case JVM_SIGNATURE_VALUETYPE:</span>
<span class="line-added">5658       // Can&#39;t enable this check until JDK upgrades the bytecode generators</span>
<span class="line-added">5659       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {</span>
<span class="line-added">5660       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;</span>
<span class="line-added">5661       //                                    &quot;in descriptor in class file %s&quot;,</span>
<span class="line-added">5662       //                                    CHECK_0);</span>
<span class="line-added">5663       // }</span>
<span class="line-added">5664       // fall through</span>
<span class="line-added">5665     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added">5666     {</span>
5667       if (_major_version &lt; JAVA_1_5_VERSION) {
5668         // Skip over the class name if one is there
5669         const char* const p = skip_over_field_name(signature + 1, true, --length);
5670 
5671         // The next character better be a semicolon
5672         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5673           return p + 1;
5674         }
5675       }
5676       else {
<span class="line-modified">5677         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;</span>
5678         signature++;
5679         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5680         // Format check signature
5681         if (c != NULL) {
5682           int newlen = c - (char*) signature;
5683           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5684           if (!legal) {
5685             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5686                                   &quot;in descriptor in class file %s&quot;,
5687                                   CHECK_NULL);
5688             return NULL;
5689           }
5690           return signature + newlen + 1;
5691         }
5692       }
5693       return NULL;
5694     }
5695     case JVM_SIGNATURE_ARRAY:
5696       array_dim++;
5697       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5712 
5713 // Checks if name is a legal class name.
5714 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5715   if (!_need_verify || _relax_verify) { return; }
5716 
5717   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5718   char* bytes = (char*)name-&gt;bytes();
5719   unsigned int length = name-&gt;utf8_length();
5720   bool legal = false;
5721 
5722   if (length &gt; 0) {
5723     const char* p;
5724     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5725       p = skip_over_field_signature(bytes, false, length, CHECK);
5726       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5727     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5728       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5729         p = skip_over_field_name(bytes, true, length);
5730         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5731       }
<span class="line-added">5732     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {</span>
<span class="line-added">5733       // Support for L...; and Q...; descriptors</span>
<span class="line-added">5734       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);</span>
5735     } else {
5736       // 4900761: relax the constraints based on JSR202 spec
5737       // Class names may be drawn from the entire Unicode character set.
5738       // Identifiers between &#39;/&#39; must be unqualified names.
5739       // The utf8 string has been verified when parsing cpool entries.
5740       legal = verify_unqualified_name(bytes, length, LegalClass);
5741     }
5742   }
5743   if (!legal) {
5744     ResourceMark rm(THREAD);
5745     assert(_class_name != NULL, &quot;invariant&quot;);
5746     Exceptions::fthrow(
5747       THREAD_AND_LOCATION,
5748       vmSymbols::java_lang_ClassFormatError(),
5749       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5750       _class_name-&gt;as_C_string()
5751     );
5752     return;
5753   }
5754 }
</pre>
<hr />
<pre>
5864   const char* nextp;
5865 
5866   // The first character must be a &#39;(&#39;
5867   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5868     length--;
5869     // Skip over legal field signatures
5870     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5871     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5872       args_size++;
5873       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5874         args_size++;
5875       }
5876       length -= nextp - p;
5877       p = nextp;
5878       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5879     }
5880     // The first non-signature thing better be a &#39;)&#39;
5881     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5882       length--;
5883       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5884         // All constructor methods must return void</span>
5885         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5886           return args_size;
5887         }
<span class="line-added">5888         // All static init methods must return the current class</span>
<span class="line-added">5889         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)</span>
<span class="line-added">5890             &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">5891           nextp = skip_over_field_signature(p, true, length, CHECK_0);</span>
<span class="line-added">5892           if (nextp &amp;&amp; ((int)length == (nextp - p))) {</span>
<span class="line-added">5893             // The actual class will be checked against current class</span>
<span class="line-added">5894             // when the method is defined (see parse_method).</span>
<span class="line-added">5895             // A reference to a static init with a bad return type</span>
<span class="line-added">5896             // will load and verify OK, but will fail to link.</span>
<span class="line-added">5897             return args_size;</span>
<span class="line-added">5898           }</span>
<span class="line-added">5899         }</span>
<span class="line-added">5900         // The distinction between static factory methods and</span>
<span class="line-added">5901         // constructors depends on the JVM_ACC_STATIC modifier.</span>
<span class="line-added">5902         // This distinction must be reflected in a void or non-void</span>
<span class="line-added">5903         // return. For declared methods, the check is in parse_method.</span>
5904       } else {
5905         // Now we better just have a return value
5906         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5907         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5908           return args_size;
5909         }
5910       }
5911     }
5912   }
5913   // Report error
5914   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5915   return 0;
5916 }
5917 
5918 int ClassFileParser::static_field_size() const {
5919   assert(_field_info != NULL, &quot;invariant&quot;);
5920   return _field_info-&gt;_static_field_size;
5921 }
5922 
5923 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
6004 
6005           if (!match) {
6006             char buf[1000];
6007             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
6008                        &quot;but the method is not available in class [%s].%s&quot;,
6009                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
6010                                                              buf, sizeof(buf)),
6011                         ik-&gt;name()-&gt;as_C_string(),
6012                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6013             );
6014             tty-&gt;cr();
6015             DEBUG_ONLY(vm_exit(1));
6016           }
6017         }
6018       } // end for
6019     } // CheckIntrinsics
6020 #endif // ASSERT
6021   }
6022 }
6023 
<span class="line-added">6024 // Called from a factory method in KlassFactory, not from this file.</span>
6025 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {
6026   if (_klass != NULL) {
6027     return _klass;
6028   }
6029 
6030   InstanceKlass* const ik =
6031     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
6032 
6033   fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);
6034 
6035   assert(_klass == ik, &quot;invariant&quot;);
6036 
6037 
6038   if (ik-&gt;should_store_fingerprint()) {
6039     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6040   }
6041 
6042   ik-&gt;set_has_passed_fingerprint_check(false);
6043   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6044     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6045     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6046     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6047       // This class matches with a class saved in an AOT library
6048       ik-&gt;set_has_passed_fingerprint_check(true);
6049     } else {
6050       ResourceMark rm;
6051       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6052                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6053     }
6054   }
6055 
<span class="line-added">6056   if (ik-&gt;is_value()) {</span>
<span class="line-added">6057     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6058     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">6059     vk-&gt;set_default_value(val);</span>
<span class="line-added">6060   }</span>
<span class="line-added">6061 </span>
6062   return ik;
6063 }
6064 
6065 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
6066   assert(ik != NULL, &quot;invariant&quot;);
6067 
6068   // Set name and CLD before adding to CLD
6069   ik-&gt;set_class_loader_data(_loader_data);
6070   ik-&gt;set_name(_class_name);
6071 
6072   // Add all classes to our internal class loader list here,
6073   // including classes in the bootstrap (NULL) class loader.
6074   const bool publicize = !is_internal();
6075 
6076   _loader_data-&gt;add_class(ik, publicize);
6077 
6078   set_klass_to_deallocate(ik);
6079 
6080   assert(_field_info != NULL, &quot;invariant&quot;);
6081   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6082   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6083          &quot;sanity&quot;);
6084 
6085   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6086   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6087 
6088   // Fill in information already parsed
6089   ik-&gt;set_should_verify_class(_need_verify);
6090 
6091   // Not yet: supers are done below to support the new subtype-checking fields
6092   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6093   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<span class="line-added">6094   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {</span>
<span class="line-added">6095     ik-&gt;set_is_naturally_atomic();</span>
<span class="line-added">6096   }</span>
<span class="line-added">6097   if (_is_empty_value) {</span>
<span class="line-added">6098     ik-&gt;set_is_empty_value();</span>
<span class="line-added">6099   }</span>
6100   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">6101   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);</span>
6102 
6103   // this transfers ownership of a lot of arrays from
6104   // the parser onto the InstanceKlass*
6105   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6106 
6107   // note that is not safe to use the fields in the parser from this point on
6108   assert(NULL == _cp, &quot;invariant&quot;);
6109   assert(NULL == _fields, &quot;invariant&quot;);
6110   assert(NULL == _methods, &quot;invariant&quot;);
6111   assert(NULL == _inner_classes, &quot;invariant&quot;);
6112   assert(NULL == _nest_members, &quot;invariant&quot;);
6113   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6114   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6115   assert(NULL == _record_components, &quot;invariant&quot;);
6116 
6117   if (_has_final_method) {
6118     ik-&gt;set_has_final_method();
6119   }
6120 
6121   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
</pre>
<hr />
<pre>
6126   // has to be changed accordingly.
6127   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6128 
6129   ik-&gt;set_this_class_index(_this_class_index);
6130 
6131   if (is_unsafe_anonymous()) {
6132     // _this_class_index is a CONSTANT_Class entry that refers to this
6133     // anonymous class itself. If this class needs to refer to its own methods or
6134     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
6135     // _this_class_index. However, because this class is anonymous (it&#39;s
6136     // not stored in SystemDictionary), _this_class_index cannot be resolved
6137     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6138     // Therefore, we must eagerly resolve _this_class_index now.
6139     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6140   }
6141 
6142   ik-&gt;set_minor_version(_minor_version);
6143   ik-&gt;set_major_version(_major_version);
6144   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6145   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<span class="line-added">6146   if (_is_declared_atomic) {</span>
<span class="line-added">6147     ik-&gt;set_is_declared_atomic();</span>
<span class="line-added">6148   }</span>
6149 
6150   if (_unsafe_anonymous_host != NULL) {
6151     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6152     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6153   }
6154 
6155   // Set PackageEntry for this_klass
6156   oop cl = ik-&gt;class_loader();
6157   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6158   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6159   ik-&gt;set_package(cld, NULL, CHECK);
6160 
6161   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6162   assert(methods != NULL, &quot;invariant&quot;);
6163   const int methods_len = methods-&gt;length();
6164 
6165   check_methods_for_intrinsics(ik, methods);
6166 
6167   // Fill in field values obtained by parse_classfile_attributes
6168   if (_parsed_annotations-&gt;has_any_annotations()) {
</pre>
<hr />
<pre>
6234 
6235   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6236 
6237   // Generate any default methods - default methods are public interface methods
6238   // that have a default implementation.  This is new with Java 8.
6239   if (_has_nonstatic_concrete_methods) {
6240     DefaultMethods::generate_default_methods(ik,
6241                                              _all_mirandas,
6242                                              CHECK);
6243   }
6244 
6245   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6246   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6247       !module_entry-&gt;has_default_read_edges()) {
6248     if (!module_entry-&gt;set_has_default_read_edges()) {
6249       // We won a potential race
6250       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6251     }
6252   }
6253 
<span class="line-added">6254   int nfields = ik-&gt;java_fields_count();</span>
<span class="line-added">6255   if (ik-&gt;is_value()) nfields++;</span>
<span class="line-added">6256   for (int i = 0; i &lt; nfields; i++) {</span>
<span class="line-added">6257     if (ik-&gt;field_is_flattenable(i)) {</span>
<span class="line-added">6258       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);</span>
<span class="line-added">6259       // Inline classes for instance fields must have been pre-loaded</span>
<span class="line-added">6260       // Inline classes for static fields might not have been loaded yet</span>
<span class="line-added">6261       Klass* klass = SystemDictionary::find(klass_name,</span>
<span class="line-added">6262           Handle(THREAD, ik-&gt;class_loader()),</span>
<span class="line-added">6263           Handle(THREAD, ik-&gt;protection_domain()), CHECK);</span>
<span class="line-added">6264       if (klass != NULL) {</span>
<span class="line-added">6265         assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);</span>
<span class="line-added">6266         ik-&gt;set_value_field_klass(i, klass);</span>
<span class="line-added">6267       }</span>
<span class="line-added">6268       klass_name-&gt;decrement_refcount();</span>
<span class="line-added">6269     } else</span>
<span class="line-added">6270       if (is_value_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
<span class="line-added">6271         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {</span>
<span class="line-added">6272       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));</span>
<span class="line-added">6273     }</span>
<span class="line-added">6274   }</span>
<span class="line-added">6275 </span>
<span class="line-added">6276   if (is_value_type()) {</span>
<span class="line-added">6277     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6278     if (UseNewFieldLayout) {</span>
<span class="line-added">6279       vk-&gt;set_alignment(_alignment);</span>
<span class="line-added">6280       vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="line-added">6281       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
<span class="line-added">6282     } else {</span>
<span class="line-added">6283       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());</span>
<span class="line-added">6284     }</span>
<span class="line-added">6285     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">6286   }</span>
<span class="line-added">6287 </span>
6288   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6289 
6290   if (!is_internal()) {
6291     if (log_is_enabled(Info, class, load)) {
6292       ResourceMark rm;
6293       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6294       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6295     }
6296 
6297     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
6298         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
6299         log_is_enabled(Info, class, preview)) {
6300       ResourceMark rm;
6301       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
6302                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
6303     }
6304 
6305     if (log_is_enabled(Debug, class, resolve))  {
6306       ResourceMark rm;
6307       // print out the superclass.
</pre>
<hr />
<pre>
6459   _access_flags(),
6460   _pub_level(pub_level),
6461   _bad_constant_seen(0),
6462   _synthetic_flag(false),
6463   _sde_length(false),
6464   _sde_buffer(NULL),
6465   _sourcefile_index(0),
6466   _generic_signature_index(0),
6467   _major_version(0),
6468   _minor_version(0),
6469   _this_class_index(0),
6470   _super_class_index(0),
6471   _itfs_len(0),
6472   _java_fields_count(0),
6473   _need_verify(false),
6474   _relax_verify(false),
6475   _has_nonstatic_concrete_methods(false),
6476   _declares_nonstatic_concrete_methods(false),
6477   _has_final_method(false),
6478   _has_contended_fields(false),
<span class="line-added">6479   _has_flattenable_fields(false),</span>
<span class="line-added">6480   _is_empty_value(false),</span>
<span class="line-added">6481   _is_naturally_atomic(false),</span>
<span class="line-added">6482   _is_declared_atomic(false),</span>
6483   _has_finalizer(false),
6484   _has_empty_finalizer(false),
6485   _has_vanilla_constructor(false),
6486   _max_bootstrap_specifier_index(-1) {
6487 
6488   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6489   _class_name-&gt;increment_refcount();
6490 
6491   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6492   assert(_loader_data != NULL, &quot;invariant&quot;);
6493   assert(stream != NULL, &quot;invariant&quot;);
6494   assert(_stream != NULL, &quot;invariant&quot;);
6495   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6496   assert(_class_name != NULL, &quot;invariant&quot;);
6497   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6498 
6499   // Figure out whether we can skip format checking (matching classic VM behavior)
6500   if (DumpSharedSpaces) {
6501     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6502     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6663 
6664   _orig_cp_size = cp_size;
6665   if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6666     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6667   }
6668   cp_size += _max_num_patched_klasses;
6669 
6670   _cp = ConstantPool::allocate(_loader_data,
6671                                cp_size,
6672                                CHECK);
6673 
6674   ConstantPool* const cp = _cp;
6675 
6676   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6677 
6678   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6679 
6680   // ACCESS FLAGS
6681   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6682 
<span class="line-modified">6683   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;</span>

6684   // JVM_ACC_MODULE is defined in JDK-9 and later.
6685   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6686     recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">6687   }</span>
<span class="line-modified">6688   // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">6689   if (supports_value_types()) {</span>
<span class="line-added">6690     recognized_modifiers |= JVM_ACC_VALUE;</span>
6691   }
6692 
<span class="line-added">6693   // Access flags</span>
<span class="line-added">6694   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">6695 </span>
6696   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6697     // Set abstract bit for old class files for backward compatibility
6698     flags |= JVM_ACC_ABSTRACT;
6699   }
6700 
6701   verify_legal_class_modifiers(flags, CHECK);
6702 
6703   short bad_constant = class_bad_constant_seen();
6704   if (bad_constant != 0) {
6705     // Do not throw CFE until after the access_flags are checked because if
6706     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6707     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6708   }
6709 
6710   _access_flags.set_flags(flags);
6711 
6712   // This class and superclass
6713   _this_class_index = stream-&gt;get_u2_fast();
6714   check_property(
6715     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6802           classlist_file-&gt;flush();
6803         }
6804       }
6805     }
6806 #endif
6807   }
6808 
6809   // SUPERKLASS
6810   _super_class_index = stream-&gt;get_u2_fast();
6811   _super_klass = parse_super_class(cp,
6812                                    _super_class_index,
6813                                    _need_verify,
6814                                    CHECK);
6815 
6816   // Interfaces
6817   _itfs_len = stream-&gt;get_u2_fast();
6818   parse_interfaces(stream,
6819                    _itfs_len,
6820                    cp,
6821                    &amp;_has_nonstatic_concrete_methods,
<span class="line-added">6822                    &amp;_is_declared_atomic,</span>
6823                    CHECK);
6824 
6825   assert(_local_interfaces != NULL, &quot;invariant&quot;);
6826 
6827   // Fields (offsets are filled in later)
6828   _fac = new FieldAllocationCount();
6829   parse_fields(stream,
<span class="line-modified">6830                is_interface(),</span>
<span class="line-added">6831                is_value_type(),</span>
6832                _fac,
6833                cp,
6834                cp_size,
6835                &amp;_java_fields_count,
6836                CHECK);
6837 
6838   assert(_fields != NULL, &quot;invariant&quot;);
6839 
6840   // Methods
6841   AccessFlags promoted_flags;
6842   parse_methods(stream,
<span class="line-modified">6843                 is_interface(),</span>
<span class="line-added">6844                 is_value_type(),</span>
6845                 &amp;promoted_flags,
6846                 &amp;_has_final_method,
6847                 &amp;_declares_nonstatic_concrete_methods,
6848                 CHECK);
6849 
6850   assert(_methods != NULL, &quot;invariant&quot;);
6851 
6852   // promote flags from parse_methods() to the klass&#39; flags
6853   _access_flags.add_promoted_flags(promoted_flags.as_int());
6854 
6855   if (_declares_nonstatic_concrete_methods) {
6856     _has_nonstatic_concrete_methods = true;
6857   }
6858 
6859   // Additional attributes/annotations
6860   _parsed_annotations = new ClassAnnotationCollector();
6861   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6862 
6863   assert(_inner_classes != NULL, &quot;invariant&quot;);
6864 
</pre>
<hr />
<pre>
6873 
6874   // all bytes in stream read and parsed
6875 }
6876 
6877 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6878                                                  ConstantPool* cp,
6879                                                  TRAPS) {
6880   assert(stream != NULL, &quot;invariant&quot;);
6881   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6882   assert(cp != NULL, &quot;invariant&quot;);
6883   assert(_loader_data != NULL, &quot;invariant&quot;);
6884 
6885   if (_class_name == vmSymbols::java_lang_Object()) {
6886     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6887                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6888                    CHECK);
6889   }
6890   // We check super class after class file is parsed and format is checked
6891   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6892     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6893     if (is_interface()) {</span>
6894       // Before attempting to resolve the superclass, check for class format
6895       // errors not checked yet.
6896       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6897         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6898         CHECK);
6899     }
6900     Handle loader(THREAD, _loader_data-&gt;class_loader());
6901     _super_klass = (const InstanceKlass*)
6902                        SystemDictionary::resolve_super_or_fail(_class_name,
6903                                                                super_class_name,
6904                                                                loader,
6905                                                                _protection_domain,
6906                                                                true,
6907                                                                CHECK);
6908   }
6909 
6910   if (_super_klass != NULL) {
6911     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6912       _has_nonstatic_concrete_methods = true;
6913     }
<span class="line-added">6914     if (_super_klass-&gt;is_declared_atomic()) {</span>
<span class="line-added">6915       _is_declared_atomic = true;</span>
<span class="line-added">6916     }</span>
6917 
6918     if (_super_klass-&gt;is_interface()) {
6919       ResourceMark rm(THREAD);
6920       Exceptions::fthrow(
6921         THREAD_AND_LOCATION,
6922         vmSymbols::java_lang_IncompatibleClassChangeError(),
6923         &quot;class %s has interface %s as super class&quot;,
6924         _class_name-&gt;as_klass_external_name(),
6925         _super_klass-&gt;external_name()
6926       );
6927       return;
6928     }
<span class="line-added">6929 </span>
<span class="line-added">6930     // For an inline class, only java/lang/Object or special abstract classes</span>
<span class="line-added">6931     // are acceptable super classes.</span>
<span class="line-added">6932     if (_access_flags.get_flags() &amp; JVM_ACC_VALUE) {</span>
<span class="line-added">6933       if (_super_klass-&gt;name() != vmSymbols::java_lang_Object()) {</span>
<span class="line-added">6934         guarantee_property(_super_klass-&gt;is_abstract(),</span>
<span class="line-added">6935           &quot;Inline type must have java.lang.Object or an abstract class as its superclass, class file %s&quot;,</span>
<span class="line-added">6936           CHECK);</span>
<span class="line-added">6937       }</span>
<span class="line-added">6938     }</span>
<span class="line-added">6939 </span>
6940     // Make sure super class is not final
6941     if (_super_klass-&gt;is_final()) {
6942       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6943     }
6944   }
6945 
<span class="line-added">6946   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {</span>
<span class="line-added">6947     // This is the original source of this condition.</span>
<span class="line-added">6948     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.</span>
<span class="line-added">6949     _is_declared_atomic = true;</span>
<span class="line-added">6950   } else if (*ForceNonTearable != &#39;\0&#39;) {</span>
<span class="line-added">6951     // Allow a command line switch to force the same atomicity property:</span>
<span class="line-added">6952     const char* class_name_str = _class_name-&gt;as_C_string();</span>
<span class="line-added">6953     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {</span>
<span class="line-added">6954       _is_declared_atomic = true;</span>
<span class="line-added">6955     }</span>
<span class="line-added">6956   }</span>
<span class="line-added">6957 </span>
6958   // Compute the transitive list of all unique interfaces implemented by this class
6959   _transitive_interfaces =
6960     compute_transitive_interfaces(_super_klass,
6961                                   _local_interfaces,
6962                                   _loader_data,
6963                                   CHECK);
6964 
6965   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6966 
6967   // sort methods
6968   _method_ordering = sort_methods(_methods);
6969 
6970   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6971 
6972   Handle loader(THREAD, _loader_data-&gt;class_loader());
6973   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6974                                                     &amp;_num_miranda_methods,
6975                                                     _all_mirandas,
6976                                                     _super_klass,
6977                                                     _methods,
6978                                                     _access_flags,
6979                                                     _major_version,
6980                                                     loader,
6981                                                     _class_name,
6982                                                     _local_interfaces,
6983                                                     CHECK);
6984 
6985   // Size of Java itable (in words)
<span class="line-modified">6986   _itable_size = is_interface() ? 0 :</span>
6987     klassItable::compute_itable_size(_transitive_interfaces);
6988 
6989   assert(_fac != NULL, &quot;invariant&quot;);
6990   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6991 
<span class="line-added">6992 </span>
<span class="line-added">6993   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-added">6994     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {</span>
<span class="line-added">6995       // Pre-load value class</span>
<span class="line-added">6996       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">6997           Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">6998           _protection_domain, true, CHECK);</span>
<span class="line-added">6999       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">7000       assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);</span>
<span class="line-added">7001       _has_flattenable_fields = true;</span>
<span class="line-added">7002     }</span>
<span class="line-added">7003   }</span>
<span class="line-added">7004 </span>
7005   _field_info = new FieldLayoutInfo();
7006   if (UseNewFieldLayout) {
7007     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">7008         _parsed_annotations-&gt;is_contended(), is_value_type(),</span>
<span class="line-modified">7009         loader_data(), _protection_domain, _field_info);</span>
<span class="line-added">7010     lb.build_layout(CHECK);</span>
<span class="line-added">7011     if (is_value_type()) {</span>
<span class="line-added">7012       _alignment = lb.get_alignment();</span>
<span class="line-added">7013       _first_field_offset = lb.get_first_field_offset();</span>
<span class="line-added">7014       _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
<span class="line-added">7015     }</span>
7016   } else {
7017     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7018   }
7019 
<span class="line-modified">7020   // Compute reference type</span>
7021   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
7022 
7023 }
7024 
7025 void ClassFileParser::set_klass(InstanceKlass* klass) {
7026 
7027 #ifdef ASSERT
7028   if (klass != NULL) {
7029     assert(NULL == _klass, &quot;leaking?&quot;);
7030   }
7031 #endif
7032 
7033   _klass = klass;
7034 }
7035 
7036 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7037 
7038 #ifdef ASSERT
7039   if (klass != NULL) {
7040     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
7041   }
7042 #endif
7043 
7044   _klass_to_deallocate = klass;
7045 }
7046 
7047 // Caller responsible for ResourceMark
7048 // clone stream with rewound position
7049 const ClassFileStream* ClassFileParser::clone_stream() const {
7050   assert(_stream != NULL, &quot;invariant&quot;);
7051 
7052   return _stream-&gt;clone();
7053 }
<span class="line-added">7054 </span>
7055 // ----------------------------------------------------------------------------
7056 // debugging
7057 
7058 #ifdef ASSERT
7059 
7060 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
7061 bool ClassFileParser::is_internal_format(Symbol* class_name) {
7062   if (class_name != NULL) {
7063     ResourceMark rm;
7064     char* name = class_name-&gt;as_C_string();
7065     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
7066   } else {
7067     return true;
7068   }
7069 }
7070 
7071 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../c1/c1_LIRAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
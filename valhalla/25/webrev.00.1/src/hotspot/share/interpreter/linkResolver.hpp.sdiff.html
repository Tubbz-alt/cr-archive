<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/linkResolver.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../memory/universe.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
314   static Method* resolve_special_call_or_null(const LinkInfo&amp; link_info);
315 
316   static int vtable_index_of_interface_method(Klass* klass, const methodHandle&amp; resolved_method);
317 
318   // same as above for compile-time resolution; returns vtable_index if current_klass if linked
319   static int resolve_virtual_vtable_index  (Klass* receiver_klass,
320                                             const LinkInfo&amp; link_info);
321 
322   // static resolving for compiler (does not throw exceptions, returns null handle if unsuccessful)
323   static Method* linktime_resolve_virtual_method_or_null  (const LinkInfo&amp; link_info);
324   static Method* linktime_resolve_interface_method_or_null(const LinkInfo&amp; link_info);
325 
326   // runtime resolving from constant pool
327   static void resolve_invoke(CallInfo&amp; result, Handle recv,
328                              const constantPoolHandle&amp; pool, int index,
329                              Bytecodes::Code byte, TRAPS);
330 
331   // runtime resolving from attached method
332   static void resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
333                              const methodHandle&amp; attached_method,
<span class="line-modified">334                              Bytecodes::Code byte, TRAPS);</span>
335 
336  public:
337   // Only resolved method known.
338   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, TRAPS) {
339     throw_abstract_method_error(resolved_method, methodHandle(), NULL, CHECK);
340   }
341   // Resolved method and receiver klass know.
342   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, Klass *recv_klass, TRAPS) {
343     throw_abstract_method_error(resolved_method, methodHandle(), recv_klass, CHECK);
344   }
345   // Selected method is abstract.
346   static void throw_abstract_method_error(const methodHandle&amp; resolved_method,
347                                           const methodHandle&amp; selected_method,
348                                           Klass *recv_klass, TRAPS);
349 };
350 #endif // SHARE_INTERPRETER_LINKRESOLVER_HPP
</pre>
</td>
<td>
<hr />
<pre>
314   static Method* resolve_special_call_or_null(const LinkInfo&amp; link_info);
315 
316   static int vtable_index_of_interface_method(Klass* klass, const methodHandle&amp; resolved_method);
317 
318   // same as above for compile-time resolution; returns vtable_index if current_klass if linked
319   static int resolve_virtual_vtable_index  (Klass* receiver_klass,
320                                             const LinkInfo&amp; link_info);
321 
322   // static resolving for compiler (does not throw exceptions, returns null handle if unsuccessful)
323   static Method* linktime_resolve_virtual_method_or_null  (const LinkInfo&amp; link_info);
324   static Method* linktime_resolve_interface_method_or_null(const LinkInfo&amp; link_info);
325 
326   // runtime resolving from constant pool
327   static void resolve_invoke(CallInfo&amp; result, Handle recv,
328                              const constantPoolHandle&amp; pool, int index,
329                              Bytecodes::Code byte, TRAPS);
330 
331   // runtime resolving from attached method
332   static void resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
333                              const methodHandle&amp; attached_method,
<span class="line-modified">334                              Bytecodes::Code byte, bool check_null_and_abstract, TRAPS);</span>
335 
336  public:
337   // Only resolved method known.
338   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, TRAPS) {
339     throw_abstract_method_error(resolved_method, methodHandle(), NULL, CHECK);
340   }
341   // Resolved method and receiver klass know.
342   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, Klass *recv_klass, TRAPS) {
343     throw_abstract_method_error(resolved_method, methodHandle(), recv_klass, CHECK);
344   }
345   // Selected method is abstract.
346   static void throw_abstract_method_error(const methodHandle&amp; resolved_method,
347                                           const methodHandle&amp; selected_method,
348                                           Klass *recv_klass, TRAPS);
349 };
350 #endif // SHARE_INTERPRETER_LINKRESOLVER_HPP
</pre>
</td>
</tr>
</table>
<center><a href="linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../memory/universe.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
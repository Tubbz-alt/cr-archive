<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../adlc/formssel.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;

  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 Register LIR_OprDesc::as_register() const {
  34   return FrameMap::cpu_rnr2reg(cpu_regnr());
  35 }
  36 
  37 Register LIR_OprDesc::as_register_lo() const {
  38   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  39 }
  40 
  41 Register LIR_OprDesc::as_register_hi() const {
  42   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  43 }
  44 
  45 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  46 
  47 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  48   ValueTag tag = type-&gt;tag();
  49   switch (tag) {
  50   case metaDataTag : {
</pre>
<hr />
<pre>
  75 //---------------------------------------------------
  76 
  77 
  78 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  79   int elem_size = type2aelembytes(type);
  80   switch (elem_size) {
  81   case 1: return LIR_Address::times_1;
  82   case 2: return LIR_Address::times_2;
  83   case 4: return LIR_Address::times_4;
  84   case 8: return LIR_Address::times_8;
  85   }
  86   ShouldNotReachHere();
  87   return LIR_Address::times_1;
  88 }
  89 
  90 //---------------------------------------------------
  91 
  92 char LIR_OprDesc::type_char(BasicType t) {
  93   switch (t) {
  94     case T_ARRAY:

  95       t = T_OBJECT;
  96     case T_BOOLEAN:
  97     case T_CHAR:
  98     case T_FLOAT:
  99     case T_DOUBLE:
 100     case T_BYTE:
 101     case T_SHORT:
 102     case T_INT:
 103     case T_LONG:
 104     case T_OBJECT:
 105     case T_ADDRESS:
 106     case T_VOID:
 107       return ::type2char(t);
 108     case T_METADATA:
 109       return &#39;M&#39;;
 110     case T_ILLEGAL:
 111       return &#39;?&#39;;
 112 
 113     default:
 114       ShouldNotReachHere();
</pre>
<hr />
<pre>
 133              ARM_ONLY(|| kindfield == cpu_register)
 134              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 135              size_field() == single_size, &quot;must match&quot;);
 136       break;
 137     case T_DOUBLE:
 138       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 139       assert((kindfield == fpu_register || kindfield == stack_value
 140              ARM_ONLY(|| kindfield == cpu_register)
 141              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 142              size_field() == double_size, &quot;must match&quot;);
 143       break;
 144     case T_BOOLEAN:
 145     case T_CHAR:
 146     case T_BYTE:
 147     case T_SHORT:
 148     case T_INT:
 149     case T_ADDRESS:
 150     case T_OBJECT:
 151     case T_METADATA:
 152     case T_ARRAY:

 153       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 154              size_field() == single_size, &quot;must match&quot;);
 155       break;
 156 
 157     case T_ILLEGAL:
 158       // XXX TKR also means unknown right now
 159       // assert(is_illegal(), &quot;must match&quot;);
 160       break;
 161 
 162     default:
 163       ShouldNotReachHere();
 164     }
 165   }
 166 #endif
 167 
 168 }
 169 #endif // PRODUCT
 170 
 171 
 172 bool LIR_OprDesc::is_oop() const {
</pre>
<hr />
<pre>
 279   assert(_ublock != NULL, &quot;must have old block&quot;);
 280   _ublock = b;
 281 }
 282 
 283 void LIR_OpBranch::negate_cond() {
 284   switch (_cond) {
 285     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 286     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 287     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 288     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 289     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 290     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 291     default: ShouldNotReachHere();
 292   }
 293 }
 294 
 295 
 296 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 297                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 298                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
<span class="line-modified"> 299                                  CodeStub* stub)</span>
 300 
 301   : LIR_Op(code, result, NULL)
 302   , _object(object)
 303   , _array(LIR_OprFact::illegalOpr)
 304   , _klass(klass)
 305   , _tmp1(tmp1)
 306   , _tmp2(tmp2)
 307   , _tmp3(tmp3)
 308   , _fast_check(fast_check)
 309   , _info_for_patch(info_for_patch)
 310   , _info_for_exception(info_for_exception)
 311   , _stub(stub)
 312   , _profiled_method(NULL)
 313   , _profiled_bci(-1)
 314   , _should_profile(false)

 315 {
 316   if (code == lir_checkcast) {
 317     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 318   } else if (code == lir_instanceof) {
 319     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 320   } else {
 321     ShouldNotReachHere();
 322   }
 323 }
 324 
 325 
 326 
 327 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 328   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 329   , _object(object)
 330   , _array(array)
 331   , _klass(NULL)
 332   , _tmp1(tmp1)
 333   , _tmp2(tmp2)
 334   , _tmp3(tmp3)
 335   , _fast_check(false)
 336   , _info_for_patch(NULL)
 337   , _info_for_exception(info_for_exception)
 338   , _stub(NULL)
 339   , _profiled_method(NULL)
 340   , _profiled_bci(-1)
 341   , _should_profile(false)

 342 {
 343   if (code == lir_store_check) {
 344     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 345     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 346   } else {
 347     ShouldNotReachHere();
 348   }
 349 }
 350 































 351 
 352 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 353                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 354   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 355   , _src(src)
 356   , _src_pos(src_pos)
 357   , _dst(dst)
 358   , _dst_pos(dst_pos)
 359   , _length(length)
 360   , _tmp(tmp)
 361   , _expected_type(expected_type)
 362   , _flags(flags) {
 363   _stub = new ArrayCopyStub(this);
 364 }
 365 
 366 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 367   : LIR_Op(lir_updatecrc32, res, NULL)
 368   , _crc(crc)
 369   , _val(val) {
 370 }
</pre>
<hr />
<pre>
 398 // switch that adds the operands for each instruction
 399 
 400 void LIR_OpVisitState::visit(LIR_Op* op) {
 401   // copy information from the LIR_Op
 402   reset();
 403   set_op(op);
 404 
 405   switch (op-&gt;code()) {
 406 
 407 // LIR_Op0
 408     case lir_backwardbranch_target:    // result and info always invalid
 409     case lir_fpop_raw:                 // result and info always invalid
 410     case lir_breakpoint:               // result and info always invalid
 411     case lir_membar:                   // result and info always invalid
 412     case lir_membar_acquire:           // result and info always invalid
 413     case lir_membar_release:           // result and info always invalid
 414     case lir_membar_loadload:          // result and info always invalid
 415     case lir_membar_storestore:        // result and info always invalid
 416     case lir_membar_loadstore:         // result and info always invalid
 417     case lir_membar_storeload:         // result and info always invalid

 418     case lir_on_spin_wait:
 419     {
 420       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 421       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 422       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 423       break;
 424     }
 425 
 426     case lir_nop:                      // may have info, result always invalid
 427     case lir_std_entry:                // may have result, info always invalid
 428     case lir_osr_entry:                // may have result, info always invalid
 429     case lir_get_thread:               // may have result, info always invalid
 430     {
 431       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 432       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 433       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 434       break;
 435     }
 436 
 437 
</pre>
<hr />
<pre>
 780 
 781 
 782 // LIR_OpLock
 783     case lir_lock:
 784     case lir_unlock: {
 785       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 786       LIR_OpLock* opLock = (LIR_OpLock*)op;
 787 
 788       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 789 
 790       // TODO: check if these operands really have to be temp
 791       // (or if input is sufficient). This may have influence on the oop map!
 792       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 793       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 794       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 795 
 796       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 797       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 798 
 799       do_stub(opLock-&gt;_stub);

 800 
 801       break;
 802     }
 803 
 804 
 805 // LIR_OpDelay
 806     case lir_delay_slot: {
 807       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 808       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 809 
 810       visit(opDelay-&gt;delay_op());
 811       break;
 812     }
 813 
 814 // LIR_OpTypeCheck
 815     case lir_instanceof:
 816     case lir_checkcast:
 817     case lir_store_check: {
 818       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 819       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 820 
 821       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 822       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 823       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 824       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 825         do_temp(opTypeCheck-&gt;_object);
 826       }
 827       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 828       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 829       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 830       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 831       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 832                                                   do_stub(opTypeCheck-&gt;_stub);
 833       break;
 834     }
 835 













































 836 // LIR_OpCompareAndSwap
 837     case lir_cas_long:
 838     case lir_cas_obj:
 839     case lir_cas_int: {
 840       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 841       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 842 
 843       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 844       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 845       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 846       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 847                                                       do_input(opCompareAndSwap-&gt;_addr);
 848                                                       do_temp(opCompareAndSwap-&gt;_addr);
 849                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 850                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 851                                                       do_input(opCompareAndSwap-&gt;_new_value);
 852                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 853       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 854       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 855       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
</pre>
<hr />
<pre>
 943 #ifdef ASSERT
 944 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
 945   visit(op);
 946 
 947   return opr_count(inputMode) == 0 &amp;&amp;
 948          opr_count(outputMode) == 0 &amp;&amp;
 949          opr_count(tempMode) == 0 &amp;&amp;
 950          info_count() == 0 &amp;&amp;
 951          !has_call() &amp;&amp;
 952          !has_slow_case();
 953 }
 954 #endif
 955 
 956 //---------------------------------------------------
 957 
 958 
 959 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
 960   masm-&gt;emit_call(this);
 961 }
 962 







































 963 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
 964   masm-&gt;emit_rtcall(this);
 965 }
 966 
 967 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
 968   masm-&gt;emit_opLabel(this);
 969 }
 970 
 971 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
 972   masm-&gt;emit_arraycopy(this);
 973   masm-&gt;append_code_stub(stub());
 974 }
 975 
 976 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
 977   masm-&gt;emit_updatecrc32(this);
 978 }
 979 
 980 void LIR_Op0::emit_code(LIR_Assembler* masm) {
 981   masm-&gt;emit_op0(this);
 982 }
</pre>
<hr />
<pre>
1003     masm-&gt;append_code_stub(stub());
1004   }
1005 }
1006 
1007 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1008   masm-&gt;emit_op2(this);
1009 }
1010 
1011 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1012   masm-&gt;emit_alloc_array(this);
1013   masm-&gt;append_code_stub(stub());
1014 }
1015 
1016 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1017   masm-&gt;emit_opTypeCheck(this);
1018   if (stub()) {
1019     masm-&gt;append_code_stub(stub());
1020   }
1021 }
1022 


















1023 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1024   masm-&gt;emit_compare_and_swap(this);
1025 }
1026 
1027 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1028   masm-&gt;emit_op3(this);
1029 }
1030 
1031 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1032   masm-&gt;emit_lock(this);
1033   if (stub()) {
1034     masm-&gt;append_code_stub(stub());
1035   }



1036 }
1037 
1038 #ifdef ASSERT
1039 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1040   masm-&gt;emit_assert(this);
1041 }
1042 #endif
1043 
1044 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1045   masm-&gt;emit_delay(this);
1046 }
1047 
1048 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1049   masm-&gt;emit_profile_call(this);
1050 }
1051 
1052 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1053   masm-&gt;emit_profile_type(this);
1054 }
1055 
</pre>
<hr />
<pre>
1317                     tmp));
1318 }
1319 
1320 
1321 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1322  append(new LIR_Op2(
1323                     lir_ushr,
1324                     value,
1325                     count,
1326                     dst,
1327                     tmp));
1328 }
1329 
1330 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1331   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1332                      left,
1333                      right,
1334                      dst));
1335 }
1336 
<span class="line-modified">1337 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info) {</span>
1338   append(new LIR_OpLock(
1339                     lir_lock,
1340                     hdr,
1341                     obj,
1342                     lock,
1343                     scratch,
1344                     stub,
<span class="line-modified">1345                     info));</span>

1346 }
1347 
1348 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1349   append(new LIR_OpLock(
1350                     lir_unlock,
1351                     hdr,
1352                     obj,
1353                     lock,
1354                     scratch,
1355                     stub,
1356                     NULL));
1357 }
1358 
1359 
1360 void check_LIR() {
1361   // cannot do the proper checking as PRODUCT and other modes return different results
1362   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1363 }
1364 
1365 
1366 
1367 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1368                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1369                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">1370                           ciMethod* profiled_method, int profiled_bci) {</span>



1371   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
<span class="line-modified">1372                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub);</span>

1373   if (profiled_method != NULL) {
1374     c-&gt;set_profiled_method(profiled_method);
1375     c-&gt;set_profiled_bci(profiled_bci);
1376     c-&gt;set_should_profile(true);
1377   }
1378   append(c);
1379 }
1380 
1381 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1382   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1383   if (profiled_method != NULL) {
1384     c-&gt;set_profiled_method(profiled_method);
1385     c-&gt;set_profiled_bci(profiled_bci);
1386     c-&gt;set_should_profile(true);
1387   }
1388   append(c);
1389 }
1390 
1391 
1392 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1393                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {

1394   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1395   if (profiled_method != NULL) {
1396     c-&gt;set_profiled_method(profiled_method);
1397     c-&gt;set_profiled_bci(profiled_bci);
1398     c-&gt;set_should_profile(true);
1399   }
1400   append(c);
1401 }
1402 
1403 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1404   if (deoptimize_on_null) {
1405     // Emit an explicit null check and deoptimize if opr is null
1406     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1407     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1408     branch(lir_cond_equal, T_OBJECT, deopt);
1409   } else {
1410     // Emit an implicit null check
1411     append(new LIR_Op1(lir_null_check, opr, info));
1412   }
1413 }
1414 





















1415 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1416                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1417   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1418 }
1419 
1420 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1421                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1422   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1423 }
1424 
1425 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1426                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1427   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1428 }
1429 
1430 
1431 #ifdef PRODUCT
1432 
1433 void print_LIR(BlockList* blocks) {
1434 }
</pre>
<hr />
<pre>
1612 const char * LIR_Op::name() const {
1613   const char* s = NULL;
1614   switch(code()) {
1615      // LIR_Op0
1616      case lir_membar:                s = &quot;membar&quot;;        break;
1617      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1618      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1619      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1620      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1621      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1622      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1623      case lir_label:                 s = &quot;label&quot;;         break;
1624      case lir_nop:                   s = &quot;nop&quot;;           break;
1625      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1626      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1627      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1628      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1629      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1630      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1631      case lir_get_thread:            s = &quot;get_thread&quot;;    break;

1632      // LIR_Op1
1633      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1634      case lir_fld:                   s = &quot;fld&quot;;           break;
1635      case lir_push:                  s = &quot;push&quot;;          break;
1636      case lir_pop:                   s = &quot;pop&quot;;           break;
1637      case lir_null_check:            s = &quot;null_check&quot;;    break;
1638      case lir_return:                s = &quot;return&quot;;        break;
1639      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1640      case lir_leal:                  s = &quot;leal&quot;;          break;
1641      case lir_branch:                s = &quot;branch&quot;;        break;
1642      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1643      case lir_move:                  s = &quot;move&quot;;          break;
1644      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1645      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1646      case lir_throw:                 s = &quot;throw&quot;;         break;
1647      case lir_unwind:                s = &quot;unwind&quot;;        break;
1648      case lir_convert:               s = &quot;convert&quot;;       break;
1649      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1650      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1651      case lir_pack64:                s = &quot;pack64&quot;;        break;
</pre>
<hr />
<pre>
1682      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1683      // LIR_OpJavaCall
1684      case lir_static_call:           s = &quot;static&quot;;        break;
1685      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1686      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1687      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1688      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1689      // LIR_OpArrayCopy
1690      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1691      // LIR_OpUpdateCRC32
1692      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1693      // LIR_OpLock
1694      case lir_lock:                  s = &quot;lock&quot;;          break;
1695      case lir_unlock:                s = &quot;unlock&quot;;        break;
1696      // LIR_OpDelay
1697      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1698      // LIR_OpTypeCheck
1699      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1700      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1701      case lir_store_check:           s = &quot;store_check&quot;;   break;






1702      // LIR_OpCompareAndSwap
1703      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1704      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1705      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1706      // LIR_OpProfileCall
1707      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1708      // LIR_OpProfileType
1709      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1710      // LIR_OpAssert
1711 #ifdef ASSERT
1712      case lir_assert:                s = &quot;assert&quot;;        break;
1713 #endif
1714      case lir_none:                  ShouldNotReachHere();break;
1715     default:                         s = &quot;illegal_op&quot;;    break;
1716   }
1717   return s;
1718 }
1719 
1720 // LIR_OpJavaCall
1721 void LIR_OpJavaCall::print_instr(outputStream* out) const {
</pre>
<hr />
<pre>
1927   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1928 }
1929 
1930 
1931 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
1932   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
1933   if (code() == lir_store_check) {
1934     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
1935   }
1936   if (code() != lir_store_check) {
1937     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
1938     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
1939   }
1940   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1941   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1942   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1943   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
1944   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
1945 }
1946 






























1947 
1948 // LIR_Op3
1949 void LIR_Op3::print_instr(outputStream* out) const {
1950   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1951   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1952   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1953   result_opr()-&gt;print(out);
1954 }
1955 
1956 
1957 void LIR_OpLock::print_instr(outputStream* out) const {
1958   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1959   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1960   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1961   if (_scratch-&gt;is_valid()) {
1962     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
1963   }
1964   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1965 }
1966 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;
<span class="line-added">  31 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  32 #include &quot;runtime/sharedRuntime.hpp&quot;
  33 
  34 Register LIR_OprDesc::as_register() const {
  35   return FrameMap::cpu_rnr2reg(cpu_regnr());
  36 }
  37 
  38 Register LIR_OprDesc::as_register_lo() const {
  39   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  40 }
  41 
  42 Register LIR_OprDesc::as_register_hi() const {
  43   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  44 }
  45 
  46 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  47 
  48 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  49   ValueTag tag = type-&gt;tag();
  50   switch (tag) {
  51   case metaDataTag : {
</pre>
<hr />
<pre>
  76 //---------------------------------------------------
  77 
  78 
  79 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  80   int elem_size = type2aelembytes(type);
  81   switch (elem_size) {
  82   case 1: return LIR_Address::times_1;
  83   case 2: return LIR_Address::times_2;
  84   case 4: return LIR_Address::times_4;
  85   case 8: return LIR_Address::times_8;
  86   }
  87   ShouldNotReachHere();
  88   return LIR_Address::times_1;
  89 }
  90 
  91 //---------------------------------------------------
  92 
  93 char LIR_OprDesc::type_char(BasicType t) {
  94   switch (t) {
  95     case T_ARRAY:
<span class="line-added">  96     case T_VALUETYPE:</span>
  97       t = T_OBJECT;
  98     case T_BOOLEAN:
  99     case T_CHAR:
 100     case T_FLOAT:
 101     case T_DOUBLE:
 102     case T_BYTE:
 103     case T_SHORT:
 104     case T_INT:
 105     case T_LONG:
 106     case T_OBJECT:
 107     case T_ADDRESS:
 108     case T_VOID:
 109       return ::type2char(t);
 110     case T_METADATA:
 111       return &#39;M&#39;;
 112     case T_ILLEGAL:
 113       return &#39;?&#39;;
 114 
 115     default:
 116       ShouldNotReachHere();
</pre>
<hr />
<pre>
 135              ARM_ONLY(|| kindfield == cpu_register)
 136              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 137              size_field() == single_size, &quot;must match&quot;);
 138       break;
 139     case T_DOUBLE:
 140       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 141       assert((kindfield == fpu_register || kindfield == stack_value
 142              ARM_ONLY(|| kindfield == cpu_register)
 143              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 144              size_field() == double_size, &quot;must match&quot;);
 145       break;
 146     case T_BOOLEAN:
 147     case T_CHAR:
 148     case T_BYTE:
 149     case T_SHORT:
 150     case T_INT:
 151     case T_ADDRESS:
 152     case T_OBJECT:
 153     case T_METADATA:
 154     case T_ARRAY:
<span class="line-added"> 155     case T_VALUETYPE:</span>
 156       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 157              size_field() == single_size, &quot;must match&quot;);
 158       break;
 159 
 160     case T_ILLEGAL:
 161       // XXX TKR also means unknown right now
 162       // assert(is_illegal(), &quot;must match&quot;);
 163       break;
 164 
 165     default:
 166       ShouldNotReachHere();
 167     }
 168   }
 169 #endif
 170 
 171 }
 172 #endif // PRODUCT
 173 
 174 
 175 bool LIR_OprDesc::is_oop() const {
</pre>
<hr />
<pre>
 282   assert(_ublock != NULL, &quot;must have old block&quot;);
 283   _ublock = b;
 284 }
 285 
 286 void LIR_OpBranch::negate_cond() {
 287   switch (_cond) {
 288     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 289     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 290     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 291     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 292     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 293     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 294     default: ShouldNotReachHere();
 295   }
 296 }
 297 
 298 
 299 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 300                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 301                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
<span class="line-modified"> 302                                  CodeStub* stub, bool need_null_check)</span>
 303 
 304   : LIR_Op(code, result, NULL)
 305   , _object(object)
 306   , _array(LIR_OprFact::illegalOpr)
 307   , _klass(klass)
 308   , _tmp1(tmp1)
 309   , _tmp2(tmp2)
 310   , _tmp3(tmp3)
 311   , _fast_check(fast_check)
 312   , _info_for_patch(info_for_patch)
 313   , _info_for_exception(info_for_exception)
 314   , _stub(stub)
 315   , _profiled_method(NULL)
 316   , _profiled_bci(-1)
 317   , _should_profile(false)
<span class="line-added"> 318   , _need_null_check(need_null_check)</span>
 319 {
 320   if (code == lir_checkcast) {
 321     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 322   } else if (code == lir_instanceof) {
 323     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 324   } else {
 325     ShouldNotReachHere();
 326   }
 327 }
 328 
 329 
 330 
 331 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 332   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 333   , _object(object)
 334   , _array(array)
 335   , _klass(NULL)
 336   , _tmp1(tmp1)
 337   , _tmp2(tmp2)
 338   , _tmp3(tmp3)
 339   , _fast_check(false)
 340   , _info_for_patch(NULL)
 341   , _info_for_exception(info_for_exception)
 342   , _stub(NULL)
 343   , _profiled_method(NULL)
 344   , _profiled_bci(-1)
 345   , _should_profile(false)
<span class="line-added"> 346   , _need_null_check(true)</span>
 347 {
 348   if (code == lir_store_check) {
 349     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 350     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 351   } else {
 352     ShouldNotReachHere();
 353   }
 354 }
 355 
<span class="line-added"> 356 LIR_OpFlattenedArrayCheck::LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub)</span>
<span class="line-added"> 357   : LIR_Op(lir_flattened_array_check, LIR_OprFact::illegalOpr, NULL)</span>
<span class="line-added"> 358   , _array(array)</span>
<span class="line-added"> 359   , _value(value)</span>
<span class="line-added"> 360   , _tmp(tmp)</span>
<span class="line-added"> 361   , _stub(stub) {}</span>
<span class="line-added"> 362 </span>
<span class="line-added"> 363 </span>
<span class="line-added"> 364 LIR_OpNullFreeArrayCheck::LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp)</span>
<span class="line-added"> 365   : LIR_Op(lir_null_free_array_check, LIR_OprFact::illegalOpr, NULL)</span>
<span class="line-added"> 366   , _array(array)</span>
<span class="line-added"> 367   , _tmp(tmp) {}</span>
<span class="line-added"> 368 </span>
<span class="line-added"> 369 </span>
<span class="line-added"> 370 LIR_OpSubstitutabilityCheck::LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added"> 371                                                          LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added"> 372                                                          ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added"> 373                                                          CodeEmitInfo* info, CodeStub* stub)</span>
<span class="line-added"> 374   : LIR_Op(lir_substitutability_check, result, info)</span>
<span class="line-added"> 375   , _left(left)</span>
<span class="line-added"> 376   , _right(right)</span>
<span class="line-added"> 377   , _equal_result(equal_result)</span>
<span class="line-added"> 378   , _not_equal_result(not_equal_result)</span>
<span class="line-added"> 379   , _tmp1(tmp1)</span>
<span class="line-added"> 380   , _tmp2(tmp2)</span>
<span class="line-added"> 381   , _left_klass(left_klass)</span>
<span class="line-added"> 382   , _right_klass(right_klass)</span>
<span class="line-added"> 383   , _left_klass_op(left_klass_op)</span>
<span class="line-added"> 384   , _right_klass_op(right_klass_op)</span>
<span class="line-added"> 385   , _stub(stub) {}</span>
<span class="line-added"> 386 </span>
 387 
 388 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 389                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 390   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 391   , _src(src)
 392   , _src_pos(src_pos)
 393   , _dst(dst)
 394   , _dst_pos(dst_pos)
 395   , _length(length)
 396   , _tmp(tmp)
 397   , _expected_type(expected_type)
 398   , _flags(flags) {
 399   _stub = new ArrayCopyStub(this);
 400 }
 401 
 402 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 403   : LIR_Op(lir_updatecrc32, res, NULL)
 404   , _crc(crc)
 405   , _val(val) {
 406 }
</pre>
<hr />
<pre>
 434 // switch that adds the operands for each instruction
 435 
 436 void LIR_OpVisitState::visit(LIR_Op* op) {
 437   // copy information from the LIR_Op
 438   reset();
 439   set_op(op);
 440 
 441   switch (op-&gt;code()) {
 442 
 443 // LIR_Op0
 444     case lir_backwardbranch_target:    // result and info always invalid
 445     case lir_fpop_raw:                 // result and info always invalid
 446     case lir_breakpoint:               // result and info always invalid
 447     case lir_membar:                   // result and info always invalid
 448     case lir_membar_acquire:           // result and info always invalid
 449     case lir_membar_release:           // result and info always invalid
 450     case lir_membar_loadload:          // result and info always invalid
 451     case lir_membar_storestore:        // result and info always invalid
 452     case lir_membar_loadstore:         // result and info always invalid
 453     case lir_membar_storeload:         // result and info always invalid
<span class="line-added"> 454     case lir_check_orig_pc:            // result and info always invalid</span>
 455     case lir_on_spin_wait:
 456     {
 457       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 458       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 459       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 460       break;
 461     }
 462 
 463     case lir_nop:                      // may have info, result always invalid
 464     case lir_std_entry:                // may have result, info always invalid
 465     case lir_osr_entry:                // may have result, info always invalid
 466     case lir_get_thread:               // may have result, info always invalid
 467     {
 468       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 469       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 470       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 471       break;
 472     }
 473 
 474 
</pre>
<hr />
<pre>
 817 
 818 
 819 // LIR_OpLock
 820     case lir_lock:
 821     case lir_unlock: {
 822       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 823       LIR_OpLock* opLock = (LIR_OpLock*)op;
 824 
 825       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 826 
 827       // TODO: check if these operands really have to be temp
 828       // (or if input is sufficient). This may have influence on the oop map!
 829       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 830       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 831       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 832 
 833       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 834       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 835 
 836       do_stub(opLock-&gt;_stub);
<span class="line-added"> 837       do_stub(opLock-&gt;_throw_imse_stub);</span>
 838 
 839       break;
 840     }
 841 
 842 
 843 // LIR_OpDelay
 844     case lir_delay_slot: {
 845       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 846       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 847 
 848       visit(opDelay-&gt;delay_op());
 849       break;
 850     }
 851 
 852 // LIR_OpTypeCheck
 853     case lir_instanceof:
 854     case lir_checkcast:
 855     case lir_store_check: {
 856       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 857       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 858 
 859       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 860       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 861       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 862       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 863         do_temp(opTypeCheck-&gt;_object);
 864       }
 865       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 866       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 867       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 868       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 869       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 870                                                   do_stub(opTypeCheck-&gt;_stub);
 871       break;
 872     }
 873 
<span class="line-added"> 874 // LIR_OpFlattenedArrayCheck</span>
<span class="line-added"> 875     case lir_flattened_array_check: {</span>
<span class="line-added"> 876       assert(op-&gt;as_OpFlattenedArrayCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 877       LIR_OpFlattenedArrayCheck* opFlattenedArrayCheck = (LIR_OpFlattenedArrayCheck*)op;</span>
<span class="line-added"> 878 </span>
<span class="line-added"> 879       if (opFlattenedArrayCheck-&gt;_array-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_array);</span>
<span class="line-added"> 880       if (opFlattenedArrayCheck-&gt;_value-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_value);</span>
<span class="line-added"> 881       if (opFlattenedArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opFlattenedArrayCheck-&gt;_tmp);</span>
<span class="line-added"> 882                                                      do_stub(opFlattenedArrayCheck-&gt;_stub);</span>
<span class="line-added"> 883 </span>
<span class="line-added"> 884       break;</span>
<span class="line-added"> 885     }</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887 // LIR_OpNullFreeArrayCheck</span>
<span class="line-added"> 888     case lir_null_free_array_check: {</span>
<span class="line-added"> 889       assert(op-&gt;as_OpNullFreeArrayCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 890       LIR_OpNullFreeArrayCheck* opNullFreeArrayCheck = (LIR_OpNullFreeArrayCheck*)op;</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892       if (opNullFreeArrayCheck-&gt;_array-&gt;is_valid()) do_input(opNullFreeArrayCheck-&gt;_array);</span>
<span class="line-added"> 893       if (opNullFreeArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opNullFreeArrayCheck-&gt;_tmp);</span>
<span class="line-added"> 894       break;</span>
<span class="line-added"> 895     }</span>
<span class="line-added"> 896 </span>
<span class="line-added"> 897 // LIR_OpSubstitutabilityCheck</span>
<span class="line-added"> 898     case lir_substitutability_check: {</span>
<span class="line-added"> 899       assert(op-&gt;as_OpSubstitutabilityCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 900       LIR_OpSubstitutabilityCheck* opSubstitutabilityCheck = (LIR_OpSubstitutabilityCheck*)op;</span>
<span class="line-added"> 901                                                                 do_input(opSubstitutabilityCheck-&gt;_left);</span>
<span class="line-added"> 902                                                                 do_temp (opSubstitutabilityCheck-&gt;_left);</span>
<span class="line-added"> 903                                                                 do_input(opSubstitutabilityCheck-&gt;_right);</span>
<span class="line-added"> 904                                                                 do_temp (opSubstitutabilityCheck-&gt;_right);</span>
<span class="line-added"> 905                                                                 do_input(opSubstitutabilityCheck-&gt;_equal_result);</span>
<span class="line-added"> 906                                                                 do_temp (opSubstitutabilityCheck-&gt;_equal_result);</span>
<span class="line-added"> 907                                                                 do_input(opSubstitutabilityCheck-&gt;_not_equal_result);</span>
<span class="line-added"> 908                                                                 do_temp (opSubstitutabilityCheck-&gt;_not_equal_result);</span>
<span class="line-added"> 909       if (opSubstitutabilityCheck-&gt;_tmp1-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp1);</span>
<span class="line-added"> 910       if (opSubstitutabilityCheck-&gt;_tmp2-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp2);</span>
<span class="line-added"> 911       if (opSubstitutabilityCheck-&gt;_left_klass_op-&gt;is_valid())  do_temp(opSubstitutabilityCheck-&gt;_left_klass_op);</span>
<span class="line-added"> 912       if (opSubstitutabilityCheck-&gt;_right_klass_op-&gt;is_valid()) do_temp(opSubstitutabilityCheck-&gt;_right_klass_op);</span>
<span class="line-added"> 913       if (opSubstitutabilityCheck-&gt;_result-&gt;is_valid())         do_output(opSubstitutabilityCheck-&gt;_result);</span>
<span class="line-added"> 914                                                                 do_info(opSubstitutabilityCheck-&gt;_info);</span>
<span class="line-added"> 915                                                                 do_stub(opSubstitutabilityCheck-&gt;_stub);</span>
<span class="line-added"> 916       break;</span>
<span class="line-added"> 917     }</span>
<span class="line-added"> 918 </span>
 919 // LIR_OpCompareAndSwap
 920     case lir_cas_long:
 921     case lir_cas_obj:
 922     case lir_cas_int: {
 923       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 924       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 925 
 926       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 927       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 928       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 929       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 930                                                       do_input(opCompareAndSwap-&gt;_addr);
 931                                                       do_temp(opCompareAndSwap-&gt;_addr);
 932                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 933                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 934                                                       do_input(opCompareAndSwap-&gt;_new_value);
 935                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 936       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 937       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 938       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
</pre>
<hr />
<pre>
1026 #ifdef ASSERT
1027 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
1028   visit(op);
1029 
1030   return opr_count(inputMode) == 0 &amp;&amp;
1031          opr_count(outputMode) == 0 &amp;&amp;
1032          opr_count(tempMode) == 0 &amp;&amp;
1033          info_count() == 0 &amp;&amp;
1034          !has_call() &amp;&amp;
1035          !has_slow_case();
1036 }
1037 #endif
1038 
1039 //---------------------------------------------------
1040 
1041 
1042 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
1043   masm-&gt;emit_call(this);
1044 }
1045 
<span class="line-added">1046 bool LIR_OpJavaCall::maybe_return_as_fields(ciValueKlass** vk_ret) const {</span>
<span class="line-added">1047   if (ValueTypeReturnedAsFields) {</span>
<span class="line-added">1048     if (method()-&gt;signature()-&gt;maybe_returns_never_null()) {</span>
<span class="line-added">1049       ciType* return_type = method()-&gt;return_type();</span>
<span class="line-added">1050       if (return_type-&gt;is_valuetype()) {</span>
<span class="line-added">1051         ciValueKlass* vk = return_type-&gt;as_value_klass();</span>
<span class="line-added">1052         if (vk-&gt;can_be_returned_as_fields()) {</span>
<span class="line-added">1053           if (vk_ret != NULL) {</span>
<span class="line-added">1054             *vk_ret = vk;</span>
<span class="line-added">1055           }</span>
<span class="line-added">1056           return true;</span>
<span class="line-added">1057         }</span>
<span class="line-added">1058       } else {</span>
<span class="line-added">1059         assert(return_type-&gt;is_instance_klass() &amp;&amp; !return_type-&gt;as_instance_klass()-&gt;is_loaded(), &quot;must be&quot;);</span>
<span class="line-added">1060         if (vk_ret != NULL) {</span>
<span class="line-added">1061           *vk_ret = NULL;</span>
<span class="line-added">1062         }</span>
<span class="line-added">1063         return true;</span>
<span class="line-added">1064       }</span>
<span class="line-added">1065     } else if (is_method_handle_invoke()) {</span>
<span class="line-added">1066       BasicType bt = method()-&gt;return_type()-&gt;basic_type();</span>
<span class="line-added">1067       if (bt == T_OBJECT || bt == T_VALUETYPE) {</span>
<span class="line-added">1068         // A value type might be returned from the call but we don&#39;t know its</span>
<span class="line-added">1069         // type. Either we get a buffered value (and nothing needs to be done)</span>
<span class="line-added">1070         // or one of the values being returned is the klass of the value type</span>
<span class="line-added">1071         // (RAX on x64, with LSB set to 1) and we need to allocate a value</span>
<span class="line-added">1072         // type instance of that type and initialize it with other values being</span>
<span class="line-added">1073         // returned (in other registers).</span>
<span class="line-added">1074         // type.</span>
<span class="line-added">1075         if (vk_ret != NULL) {</span>
<span class="line-added">1076           *vk_ret = NULL;</span>
<span class="line-added">1077         }</span>
<span class="line-added">1078         return true;</span>
<span class="line-added">1079       }</span>
<span class="line-added">1080     }</span>
<span class="line-added">1081   }</span>
<span class="line-added">1082   return false;</span>
<span class="line-added">1083 }</span>
<span class="line-added">1084 </span>
1085 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
1086   masm-&gt;emit_rtcall(this);
1087 }
1088 
1089 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
1090   masm-&gt;emit_opLabel(this);
1091 }
1092 
1093 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
1094   masm-&gt;emit_arraycopy(this);
1095   masm-&gt;append_code_stub(stub());
1096 }
1097 
1098 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
1099   masm-&gt;emit_updatecrc32(this);
1100 }
1101 
1102 void LIR_Op0::emit_code(LIR_Assembler* masm) {
1103   masm-&gt;emit_op0(this);
1104 }
</pre>
<hr />
<pre>
1125     masm-&gt;append_code_stub(stub());
1126   }
1127 }
1128 
1129 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1130   masm-&gt;emit_op2(this);
1131 }
1132 
1133 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1134   masm-&gt;emit_alloc_array(this);
1135   masm-&gt;append_code_stub(stub());
1136 }
1137 
1138 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1139   masm-&gt;emit_opTypeCheck(this);
1140   if (stub()) {
1141     masm-&gt;append_code_stub(stub());
1142   }
1143 }
1144 
<span class="line-added">1145 void LIR_OpFlattenedArrayCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1146   masm-&gt;emit_opFlattenedArrayCheck(this);</span>
<span class="line-added">1147   if (stub() != NULL) {</span>
<span class="line-added">1148     masm-&gt;append_code_stub(stub());</span>
<span class="line-added">1149   }</span>
<span class="line-added">1150 }</span>
<span class="line-added">1151 </span>
<span class="line-added">1152 void LIR_OpNullFreeArrayCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1153   masm-&gt;emit_opNullFreeArrayCheck(this);</span>
<span class="line-added">1154 }</span>
<span class="line-added">1155 </span>
<span class="line-added">1156 void LIR_OpSubstitutabilityCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1157   masm-&gt;emit_opSubstitutabilityCheck(this);</span>
<span class="line-added">1158   if (stub() != NULL) {</span>
<span class="line-added">1159     masm-&gt;append_code_stub(stub());</span>
<span class="line-added">1160   }</span>
<span class="line-added">1161 }</span>
<span class="line-added">1162 </span>
1163 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1164   masm-&gt;emit_compare_and_swap(this);
1165 }
1166 
1167 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1168   masm-&gt;emit_op3(this);
1169 }
1170 
1171 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1172   masm-&gt;emit_lock(this);
1173   if (stub()) {
1174     masm-&gt;append_code_stub(stub());
1175   }
<span class="line-added">1176   if (throw_imse_stub()) {</span>
<span class="line-added">1177     masm-&gt;append_code_stub(throw_imse_stub());</span>
<span class="line-added">1178   }</span>
1179 }
1180 
1181 #ifdef ASSERT
1182 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1183   masm-&gt;emit_assert(this);
1184 }
1185 #endif
1186 
1187 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1188   masm-&gt;emit_delay(this);
1189 }
1190 
1191 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1192   masm-&gt;emit_profile_call(this);
1193 }
1194 
1195 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1196   masm-&gt;emit_profile_type(this);
1197 }
1198 
</pre>
<hr />
<pre>
1460                     tmp));
1461 }
1462 
1463 
1464 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1465  append(new LIR_Op2(
1466                     lir_ushr,
1467                     value,
1468                     count,
1469                     dst,
1470                     tmp));
1471 }
1472 
1473 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1474   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1475                      left,
1476                      right,
1477                      dst));
1478 }
1479 
<span class="line-modified">1480 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub) {</span>
1481   append(new LIR_OpLock(
1482                     lir_lock,
1483                     hdr,
1484                     obj,
1485                     lock,
1486                     scratch,
1487                     stub,
<span class="line-modified">1488                     info,</span>
<span class="line-added">1489                     throw_imse_stub));</span>
1490 }
1491 
1492 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1493   append(new LIR_OpLock(
1494                     lir_unlock,
1495                     hdr,
1496                     obj,
1497                     lock,
1498                     scratch,
1499                     stub,
1500                     NULL));
1501 }
1502 
1503 
1504 void check_LIR() {
1505   // cannot do the proper checking as PRODUCT and other modes return different results
1506   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1507 }
1508 
1509 
1510 
1511 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1512                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1513                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">1514                           ciMethod* profiled_method, int profiled_bci, bool is_never_null) {</span>
<span class="line-added">1515   // If klass is non-nullable,  LIRGenerator::do_CheckCast has already performed null-check</span>
<span class="line-added">1516   // on the object.</span>
<span class="line-added">1517   bool need_null_check = !is_never_null;</span>
1518   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
<span class="line-modified">1519                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub,</span>
<span class="line-added">1520                                            need_null_check);</span>
1521   if (profiled_method != NULL) {
1522     c-&gt;set_profiled_method(profiled_method);
1523     c-&gt;set_profiled_bci(profiled_bci);
1524     c-&gt;set_should_profile(true);
1525   }
1526   append(c);
1527 }
1528 
1529 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1530   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1531   if (profiled_method != NULL) {
1532     c-&gt;set_profiled_method(profiled_method);
1533     c-&gt;set_profiled_bci(profiled_bci);
1534     c-&gt;set_should_profile(true);
1535   }
1536   append(c);
1537 }
1538 
1539 
1540 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1541                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
<span class="line-added">1542   // FIXME -- if the types of the array and/or the object are known statically, we can avoid loading the klass</span>
1543   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1544   if (profiled_method != NULL) {
1545     c-&gt;set_profiled_method(profiled_method);
1546     c-&gt;set_profiled_bci(profiled_bci);
1547     c-&gt;set_should_profile(true);
1548   }
1549   append(c);
1550 }
1551 
1552 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1553   if (deoptimize_on_null) {
1554     // Emit an explicit null check and deoptimize if opr is null
1555     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1556     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1557     branch(lir_cond_equal, T_OBJECT, deopt);
1558   } else {
1559     // Emit an implicit null check
1560     append(new LIR_Op1(lir_null_check, opr, info));
1561   }
1562 }
1563 
<span class="line-added">1564 void LIR_List::check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub) {</span>
<span class="line-added">1565   LIR_OpFlattenedArrayCheck* c = new LIR_OpFlattenedArrayCheck(array, value, tmp, stub);</span>
<span class="line-added">1566   append(c);</span>
<span class="line-added">1567 }</span>
<span class="line-added">1568 </span>
<span class="line-added">1569 void LIR_List::check_null_free_array(LIR_Opr array, LIR_Opr tmp) {</span>
<span class="line-added">1570   LIR_OpNullFreeArrayCheck* c = new LIR_OpNullFreeArrayCheck(array, tmp);</span>
<span class="line-added">1571   append(c);</span>
<span class="line-added">1572 }</span>
<span class="line-added">1573 </span>
<span class="line-added">1574 void LIR_List::substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added">1575                                       LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added">1576                                       ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added">1577                                       CodeEmitInfo* info, CodeStub* stub) {</span>
<span class="line-added">1578   LIR_OpSubstitutabilityCheck* c = new LIR_OpSubstitutabilityCheck(result, left, right, equal_result, not_equal_result,</span>
<span class="line-added">1579                                                                    tmp1, tmp2,</span>
<span class="line-added">1580                                                                    left_klass, right_klass, left_klass_op, right_klass_op,</span>
<span class="line-added">1581                                                                    info, stub);</span>
<span class="line-added">1582   append(c);</span>
<span class="line-added">1583 }</span>
<span class="line-added">1584 </span>
1585 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1586                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1587   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1588 }
1589 
1590 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1591                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1592   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1593 }
1594 
1595 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1596                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1597   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1598 }
1599 
1600 
1601 #ifdef PRODUCT
1602 
1603 void print_LIR(BlockList* blocks) {
1604 }
</pre>
<hr />
<pre>
1782 const char * LIR_Op::name() const {
1783   const char* s = NULL;
1784   switch(code()) {
1785      // LIR_Op0
1786      case lir_membar:                s = &quot;membar&quot;;        break;
1787      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1788      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1789      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1790      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1791      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1792      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1793      case lir_label:                 s = &quot;label&quot;;         break;
1794      case lir_nop:                   s = &quot;nop&quot;;           break;
1795      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1796      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1797      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1798      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1799      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1800      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1801      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
<span class="line-added">1802      case lir_check_orig_pc:         s = &quot;check_orig_pc&quot;; break;</span>
1803      // LIR_Op1
1804      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1805      case lir_fld:                   s = &quot;fld&quot;;           break;
1806      case lir_push:                  s = &quot;push&quot;;          break;
1807      case lir_pop:                   s = &quot;pop&quot;;           break;
1808      case lir_null_check:            s = &quot;null_check&quot;;    break;
1809      case lir_return:                s = &quot;return&quot;;        break;
1810      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1811      case lir_leal:                  s = &quot;leal&quot;;          break;
1812      case lir_branch:                s = &quot;branch&quot;;        break;
1813      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1814      case lir_move:                  s = &quot;move&quot;;          break;
1815      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1816      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1817      case lir_throw:                 s = &quot;throw&quot;;         break;
1818      case lir_unwind:                s = &quot;unwind&quot;;        break;
1819      case lir_convert:               s = &quot;convert&quot;;       break;
1820      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1821      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1822      case lir_pack64:                s = &quot;pack64&quot;;        break;
</pre>
<hr />
<pre>
1853      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1854      // LIR_OpJavaCall
1855      case lir_static_call:           s = &quot;static&quot;;        break;
1856      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1857      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1858      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1859      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1860      // LIR_OpArrayCopy
1861      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1862      // LIR_OpUpdateCRC32
1863      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1864      // LIR_OpLock
1865      case lir_lock:                  s = &quot;lock&quot;;          break;
1866      case lir_unlock:                s = &quot;unlock&quot;;        break;
1867      // LIR_OpDelay
1868      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1869      // LIR_OpTypeCheck
1870      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1871      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1872      case lir_store_check:           s = &quot;store_check&quot;;   break;
<span class="line-added">1873      // LIR_OpFlattenedArrayCheck</span>
<span class="line-added">1874      case lir_flattened_array_check: s = &quot;flattened_array_check&quot;; break;</span>
<span class="line-added">1875      // LIR_OpNullFreeArrayCheck</span>
<span class="line-added">1876      case lir_null_free_array_check: s = &quot;null_free_array_check&quot;; break;</span>
<span class="line-added">1877      // LIR_OpSubstitutabilityCheck</span>
<span class="line-added">1878      case lir_substitutability_check: s = &quot;substitutability_check&quot;; break;</span>
1879      // LIR_OpCompareAndSwap
1880      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1881      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1882      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1883      // LIR_OpProfileCall
1884      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1885      // LIR_OpProfileType
1886      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1887      // LIR_OpAssert
1888 #ifdef ASSERT
1889      case lir_assert:                s = &quot;assert&quot;;        break;
1890 #endif
1891      case lir_none:                  ShouldNotReachHere();break;
1892     default:                         s = &quot;illegal_op&quot;;    break;
1893   }
1894   return s;
1895 }
1896 
1897 // LIR_OpJavaCall
1898 void LIR_OpJavaCall::print_instr(outputStream* out) const {
</pre>
<hr />
<pre>
2104   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2105 }
2106 
2107 
2108 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
2109   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
2110   if (code() == lir_store_check) {
2111     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
2112   }
2113   if (code() != lir_store_check) {
2114     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
2115     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
2116   }
2117   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2118   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2119   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2120   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2121   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
2122 }
2123 
<span class="line-added">2124 void LIR_OpFlattenedArrayCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2125   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2126   value()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2127   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2128   if (stub() != NULL) {</span>
<span class="line-added">2129     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));</span>
<span class="line-added">2130   }</span>
<span class="line-added">2131 }</span>
<span class="line-added">2132 </span>
<span class="line-added">2133 void LIR_OpNullFreeArrayCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2134   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2135   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2136 }</span>
<span class="line-added">2137 </span>
<span class="line-added">2138 void LIR_OpSubstitutabilityCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2139   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2140   left()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2141   right()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2142   equal_result()-&gt;print(out);            out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2143   not_equal_result()-&gt;print(out);        out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2144   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2145   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2146   left_klass()-&gt;print(out);              out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2147   right_klass()-&gt;print(out);             out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2148   left_klass_op()-&gt;print(out);           out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2149   right_klass_op()-&gt;print(out);          out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2150   if (stub() != NULL) {</span>
<span class="line-added">2151     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));</span>
<span class="line-added">2152   }</span>
<span class="line-added">2153 }</span>
2154 
2155 // LIR_Op3
2156 void LIR_Op3::print_instr(outputStream* out) const {
2157   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2158   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2159   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2160   result_opr()-&gt;print(out);
2161 }
2162 
2163 
2164 void LIR_OpLock::print_instr(outputStream* out) const {
2165   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2166   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2167   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
2168   if (_scratch-&gt;is_valid()) {
2169     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
2170   }
2171   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2172 }
2173 
</pre>
</td>
</tr>
</table>
<center><a href="../adlc/formssel.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 299   friend BasicType as_BasicType(OprType t);
 300 
 301   OprType type_field_valid() const               { assert(is_register() || is_stack(), &quot;should not be called otherwise&quot;); return (OprType)(value() &amp; type_mask); }
 302   OprType type_field() const                     { return is_illegal() ? unknown_type : (OprType)(value() &amp; type_mask); }
 303 
 304   static OprSize size_for(BasicType t) {
 305     switch (t) {
 306       case T_LONG:
 307       case T_DOUBLE:
 308         return double_size;
 309         break;
 310 
 311       case T_FLOAT:
 312       case T_BOOLEAN:
 313       case T_CHAR:
 314       case T_BYTE:
 315       case T_SHORT:
 316       case T_INT:
 317       case T_ADDRESS:
 318       case T_OBJECT:

 319       case T_ARRAY:
 320       case T_METADATA:
 321         return single_size;
 322         break;
 323 
 324       default:
 325         ShouldNotReachHere();
 326         return single_size;
 327       }
 328   }
 329 
 330 
 331   void validate_type() const PRODUCT_RETURN;
 332 
 333   BasicType type() const {
 334     if (is_pointer()) {
 335       return pointer()-&gt;type();
 336     }
 337     return as_BasicType(type_field());
 338   }
</pre>
<hr />
<pre>
 449 #endif
 450 
 451   jint      as_jint()    const { return as_constant_ptr()-&gt;as_jint(); }
 452   jlong     as_jlong()   const { return as_constant_ptr()-&gt;as_jlong(); }
 453   jfloat    as_jfloat()  const { return as_constant_ptr()-&gt;as_jfloat(); }
 454   jdouble   as_jdouble() const { return as_constant_ptr()-&gt;as_jdouble(); }
 455   jobject   as_jobject() const { return as_constant_ptr()-&gt;as_jobject(); }
 456 
 457   void print() const PRODUCT_RETURN;
 458   void print(outputStream* out) const PRODUCT_RETURN;
 459 };
 460 
 461 
 462 inline LIR_OprDesc::OprType as_OprType(BasicType type) {
 463   switch (type) {
 464   case T_INT:      return LIR_OprDesc::int_type;
 465   case T_LONG:     return LIR_OprDesc::long_type;
 466   case T_FLOAT:    return LIR_OprDesc::float_type;
 467   case T_DOUBLE:   return LIR_OprDesc::double_type;
 468   case T_OBJECT:

 469   case T_ARRAY:    return LIR_OprDesc::object_type;
 470   case T_ADDRESS:  return LIR_OprDesc::address_type;
 471   case T_METADATA: return LIR_OprDesc::metadata_type;
 472   case T_ILLEGAL:  // fall through
 473   default: ShouldNotReachHere(); return LIR_OprDesc::unknown_type;
 474   }
 475 }
 476 
 477 inline BasicType as_BasicType(LIR_OprDesc::OprType t) {
 478   switch (t) {
 479   case LIR_OprDesc::int_type:     return T_INT;
 480   case LIR_OprDesc::long_type:    return T_LONG;
 481   case LIR_OprDesc::float_type:   return T_FLOAT;
 482   case LIR_OprDesc::double_type:  return T_DOUBLE;
 483   case LIR_OprDesc::object_type:  return T_OBJECT;
 484   case LIR_OprDesc::address_type: return T_ADDRESS;
 485   case LIR_OprDesc::metadata_type:return T_METADATA;
 486   case LIR_OprDesc::unknown_type: // fall through
 487   default: ShouldNotReachHere();  return T_ILLEGAL;
 488   }
</pre>
<hr />
<pre>
 634     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 635                                LIR_OprDesc::float_type          |
 636                                LIR_OprDesc::fpu_register        |
 637                                LIR_OprDesc::single_size         |
 638                                LIR_OprDesc::is_xmm_mask);
 639   }
 640   static LIR_Opr double_xmm(int reg) {
 641     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 642                                (reg &lt;&lt; LIR_OprDesc::reg2_shift) |
 643                                LIR_OprDesc::double_type         |
 644                                LIR_OprDesc::fpu_register        |
 645                                LIR_OprDesc::double_size         |
 646                                LIR_OprDesc::is_xmm_mask);
 647   }
 648 #endif // X86
 649 
 650   static LIR_Opr virtual_register(int index, BasicType type) {
 651     LIR_Opr res;
 652     switch (type) {
 653       case T_OBJECT: // fall through

 654       case T_ARRAY:
 655         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 656                                             LIR_OprDesc::object_type  |
 657                                             LIR_OprDesc::cpu_register |
 658                                             LIR_OprDesc::single_size  |
 659                                             LIR_OprDesc::virtual_mask);
 660         break;
 661 
 662       case T_METADATA:
 663         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 664                                             LIR_OprDesc::metadata_type|
 665                                             LIR_OprDesc::cpu_register |
 666                                             LIR_OprDesc::single_size  |
 667                                             LIR_OprDesc::virtual_mask);
 668         break;
 669 
 670       case T_INT:
 671         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 672                                   LIR_OprDesc::int_type              |
 673                                   LIR_OprDesc::cpu_register          |
</pre>
<hr />
<pre>
 739                                t |
 740                                LIR_OprDesc::cpu_register |
 741                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 742 #else // __SOFTFP__
 743     LIR_Opr old_res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) | t |
 744                                           ((type == T_FLOAT || type == T_DOUBLE) ?  LIR_OprDesc::fpu_register : LIR_OprDesc::cpu_register) |
 745                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 746     assert(res == old_res, &quot;old and new method not equal&quot;);
 747 #endif // __SOFTFP__
 748 #endif // ASSERT
 749 
 750     return res;
 751   }
 752 
 753   // &#39;index&#39; is computed by FrameMap::local_stack_pos(index); do not use other parameters as
 754   // the index is platform independent; a double stack useing indeces 2 and 3 has always
 755   // index 2.
 756   static LIR_Opr stack(int index, BasicType type) {
 757     LIR_Opr res;
 758     switch (type) {

 759       case T_OBJECT: // fall through
 760       case T_ARRAY:
 761         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 762                                   LIR_OprDesc::object_type           |
 763                                   LIR_OprDesc::stack_value           |
 764                                   LIR_OprDesc::single_size);
 765         break;
 766 
 767       case T_METADATA:
 768         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 769                                   LIR_OprDesc::metadata_type         |
 770                                   LIR_OprDesc::stack_value           |
 771                                   LIR_OprDesc::single_size);
 772         break;
 773       case T_INT:
 774         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 775                                   LIR_OprDesc::int_type              |
 776                                   LIR_OprDesc::stack_value           |
 777                                   LIR_OprDesc::single_size);
 778         break;
</pre>
<hr />
<pre>
 851 //
 852 class  LIR_Op;
 853 class    LIR_Op0;
 854 class      LIR_OpLabel;
 855 class    LIR_Op1;
 856 class      LIR_OpBranch;
 857 class      LIR_OpConvert;
 858 class      LIR_OpAllocObj;
 859 class      LIR_OpRoundFP;
 860 class    LIR_Op2;
 861 class    LIR_OpDelay;
 862 class    LIR_Op3;
 863 class      LIR_OpAllocArray;
 864 class    LIR_OpCall;
 865 class      LIR_OpJavaCall;
 866 class      LIR_OpRTCall;
 867 class    LIR_OpArrayCopy;
 868 class    LIR_OpUpdateCRC32;
 869 class    LIR_OpLock;
 870 class    LIR_OpTypeCheck;



 871 class    LIR_OpCompareAndSwap;
 872 class    LIR_OpProfileCall;
 873 class    LIR_OpProfileType;
 874 #ifdef ASSERT
 875 class    LIR_OpAssert;
 876 #endif
 877 
 878 // LIR operation codes
 879 enum LIR_Code {
 880     lir_none
 881   , begin_op0
 882       , lir_label
 883       , lir_nop
 884       , lir_backwardbranch_target
 885       , lir_std_entry
 886       , lir_osr_entry
 887       , lir_fpop_raw
 888       , lir_breakpoint
 889       , lir_rtcall
 890       , lir_membar
 891       , lir_membar_acquire
 892       , lir_membar_release
 893       , lir_membar_loadload
 894       , lir_membar_storestore
 895       , lir_membar_loadstore
 896       , lir_membar_storeload
 897       , lir_get_thread
 898       , lir_on_spin_wait

 899   , end_op0
 900   , begin_op1
 901       , lir_fxch
 902       , lir_fld
 903       , lir_push
 904       , lir_pop
 905       , lir_null_check
 906       , lir_return
 907       , lir_leal
 908       , lir_branch
 909       , lir_cond_float_branch
 910       , lir_move
 911       , lir_convert
 912       , lir_alloc_object
 913       , lir_monaddr
 914       , lir_roundfp
 915       , lir_safepoint
 916       , lir_pack64
 917       , lir_unpack64
 918       , lir_unwind
</pre>
<hr />
<pre>
 960       , lir_dynamic_call
 961   , end_opJavaCall
 962   , begin_opArrayCopy
 963       , lir_arraycopy
 964   , end_opArrayCopy
 965   , begin_opUpdateCRC32
 966       , lir_updatecrc32
 967   , end_opUpdateCRC32
 968   , begin_opLock
 969     , lir_lock
 970     , lir_unlock
 971   , end_opLock
 972   , begin_delay_slot
 973     , lir_delay_slot
 974   , end_delay_slot
 975   , begin_opTypeCheck
 976     , lir_instanceof
 977     , lir_checkcast
 978     , lir_store_check
 979   , end_opTypeCheck









 980   , begin_opCompareAndSwap
 981     , lir_cas_long
 982     , lir_cas_obj
 983     , lir_cas_int
 984   , end_opCompareAndSwap
 985   , begin_opMDOProfile
 986     , lir_profile_call
 987     , lir_profile_type
 988   , end_opMDOProfile
 989   , begin_opAssert
 990     , lir_assert
 991   , end_opAssert
 992 };
 993 
 994 
 995 enum LIR_Condition {
 996     lir_cond_equal
 997   , lir_cond_notEqual
 998   , lir_cond_less
 999   , lir_cond_lessEqual
</pre>
<hr />
<pre>
1110 
1111   virtual bool is_patching() { return false; }
1112   virtual LIR_OpCall* as_OpCall() { return NULL; }
1113   virtual LIR_OpJavaCall* as_OpJavaCall() { return NULL; }
1114   virtual LIR_OpLabel* as_OpLabel() { return NULL; }
1115   virtual LIR_OpDelay* as_OpDelay() { return NULL; }
1116   virtual LIR_OpLock* as_OpLock() { return NULL; }
1117   virtual LIR_OpAllocArray* as_OpAllocArray() { return NULL; }
1118   virtual LIR_OpAllocObj* as_OpAllocObj() { return NULL; }
1119   virtual LIR_OpRoundFP* as_OpRoundFP() { return NULL; }
1120   virtual LIR_OpBranch* as_OpBranch() { return NULL; }
1121   virtual LIR_OpRTCall* as_OpRTCall() { return NULL; }
1122   virtual LIR_OpConvert* as_OpConvert() { return NULL; }
1123   virtual LIR_Op0* as_Op0() { return NULL; }
1124   virtual LIR_Op1* as_Op1() { return NULL; }
1125   virtual LIR_Op2* as_Op2() { return NULL; }
1126   virtual LIR_Op3* as_Op3() { return NULL; }
1127   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return NULL; }
1128   virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32() { return NULL; }
1129   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return NULL; }



1130   virtual LIR_OpCompareAndSwap* as_OpCompareAndSwap() { return NULL; }
1131   virtual LIR_OpProfileCall* as_OpProfileCall() { return NULL; }
1132   virtual LIR_OpProfileType* as_OpProfileType() { return NULL; }
1133 #ifdef ASSERT
1134   virtual LIR_OpAssert* as_OpAssert() { return NULL; }
1135 #endif
1136 
1137   virtual void verify() const {}
1138 };
1139 
1140 // for calls
1141 class LIR_OpCall: public LIR_Op {
1142  friend class LIR_OpVisitState;
1143 
1144  protected:
1145   address      _addr;
1146   LIR_OprList* _arguments;
1147  protected:
1148   LIR_OpCall(LIR_Code code, address addr, LIR_Opr result,
1149              LIR_OprList* arguments, CodeEmitInfo* info = NULL)
</pre>
<hr />
<pre>
1190   { assert(is_in_range(code, begin_opJavaCall, end_opJavaCall), &quot;code check&quot;); }
1191 
1192   LIR_Opr receiver() const                       { return _receiver; }
1193   ciMethod* method() const                       { return _method;   }
1194 
1195   // JSR 292 support.
1196   bool is_invokedynamic() const                  { return code() == lir_dynamic_call; }
1197   bool is_method_handle_invoke() const {
1198     return method()-&gt;is_compiled_lambda_form() ||   // Java-generated lambda form
1199            method()-&gt;is_method_handle_intrinsic();  // JVM-generated MH intrinsic
1200   }
1201 
1202   intptr_t vtable_offset() const {
1203     assert(_code == lir_virtual_call, &quot;only have vtable for real vcall&quot;);
1204     return (intptr_t) addr();
1205   }
1206 
1207   virtual void emit_code(LIR_Assembler* masm);
1208   virtual LIR_OpJavaCall* as_OpJavaCall() { return this; }
1209   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;


1210 };
1211 
1212 // --------------------------------------------------
1213 // LIR_OpLabel
1214 // --------------------------------------------------
1215 // Location where a branch can continue
1216 class LIR_OpLabel: public LIR_Op {
1217  friend class LIR_OpVisitState;
1218 
1219  private:
1220   Label* _label;
1221  public:
1222   LIR_OpLabel(Label* lbl)
1223    : LIR_Op(lir_label, LIR_OprFact::illegalOpr, NULL)
1224    , _label(lbl)                                 {}
1225   Label* label() const                           { return _label; }
1226 
1227   virtual void emit_code(LIR_Assembler* masm);
1228   virtual LIR_OpLabel* as_OpLabel() { return this; }
1229   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
</pre>
<hr />
<pre>
1241   LIR_Opr   _dst_pos;
1242   LIR_Opr   _length;
1243   LIR_Opr   _tmp;
1244   ciArrayKlass* _expected_type;
1245   int       _flags;
1246 
1247 public:
1248   enum Flags {
1249     src_null_check         = 1 &lt;&lt; 0,
1250     dst_null_check         = 1 &lt;&lt; 1,
1251     src_pos_positive_check = 1 &lt;&lt; 2,
1252     dst_pos_positive_check = 1 &lt;&lt; 3,
1253     length_positive_check  = 1 &lt;&lt; 4,
1254     src_range_check        = 1 &lt;&lt; 5,
1255     dst_range_check        = 1 &lt;&lt; 6,
1256     type_check             = 1 &lt;&lt; 7,
1257     overlapping            = 1 &lt;&lt; 8,
1258     unaligned              = 1 &lt;&lt; 9,
1259     src_objarray           = 1 &lt;&lt; 10,
1260     dst_objarray           = 1 &lt;&lt; 11,
<span class="line-modified">1261     all_flags              = (1 &lt;&lt; 12) - 1</span>



1262   };
1263 
1264   LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp,
1265                   ciArrayKlass* expected_type, int flags, CodeEmitInfo* info);
1266 
1267   LIR_Opr src() const                            { return _src; }
1268   LIR_Opr src_pos() const                        { return _src_pos; }
1269   LIR_Opr dst() const                            { return _dst; }
1270   LIR_Opr dst_pos() const                        { return _dst_pos; }
1271   LIR_Opr length() const                         { return _length; }
1272   LIR_Opr tmp() const                            { return _tmp; }
1273   int flags() const                              { return _flags; }
1274   ciArrayKlass* expected_type() const            { return _expected_type; }
1275   ArrayCopyStub* stub() const                    { return _stub; }
1276 
1277   virtual void emit_code(LIR_Assembler* masm);
1278   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return this; }
1279   void print_instr(outputStream* out) const PRODUCT_RETURN;
1280 };
1281 
</pre>
<hr />
<pre>
1534 };
1535 
1536 // LIR_OpTypeCheck
1537 class LIR_OpTypeCheck: public LIR_Op {
1538  friend class LIR_OpVisitState;
1539 
1540  private:
1541   LIR_Opr       _object;
1542   LIR_Opr       _array;
1543   ciKlass*      _klass;
1544   LIR_Opr       _tmp1;
1545   LIR_Opr       _tmp2;
1546   LIR_Opr       _tmp3;
1547   bool          _fast_check;
1548   CodeEmitInfo* _info_for_patch;
1549   CodeEmitInfo* _info_for_exception;
1550   CodeStub*     _stub;
1551   ciMethod*     _profiled_method;
1552   int           _profiled_bci;
1553   bool          _should_profile;

1554 
1555 public:
1556   LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
1557                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
<span class="line-modified">1558                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub);</span>
1559   LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array,
1560                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception);
1561 
1562   LIR_Opr object() const                         { return _object;         }
1563   LIR_Opr array() const                          { assert(code() == lir_store_check, &quot;not valid&quot;); return _array;         }
1564   LIR_Opr tmp1() const                           { return _tmp1;           }
1565   LIR_Opr tmp2() const                           { return _tmp2;           }
1566   LIR_Opr tmp3() const                           { return _tmp3;           }
1567   ciKlass* klass() const                         { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _klass;          }
1568   bool fast_check() const                        { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _fast_check;     }
1569   CodeEmitInfo* info_for_patch() const           { return _info_for_patch;  }
1570   CodeEmitInfo* info_for_exception() const       { return _info_for_exception; }
1571   CodeStub* stub() const                         { return _stub;           }
1572 
1573   // MethodData* profiling
1574   void set_profiled_method(ciMethod *method)     { _profiled_method = method; }
1575   void set_profiled_bci(int bci)                 { _profiled_bci = bci;       }
1576   void set_should_profile(bool b)                { _should_profile = b;       }
1577   ciMethod* profiled_method() const              { return _profiled_method;   }
1578   int       profiled_bci() const                 { return _profiled_bci;      }
1579   bool      should_profile() const               { return _should_profile;    }
<span class="line-modified">1580 </span>
1581   virtual bool is_patching() { return _info_for_patch != NULL; }
1582   virtual void emit_code(LIR_Assembler* masm);
1583   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return this; }
1584   void print_instr(outputStream* out) const PRODUCT_RETURN;
1585 };
1586 












































































1587 // LIR_Op2
1588 class LIR_Op2: public LIR_Op {
1589  friend class LIR_OpVisitState;
1590 
1591   int  _fpu_stack_size; // for sin/cos implementation on Intel
1592 
1593  protected:
1594   LIR_Opr   _opr1;
1595   LIR_Opr   _opr2;
1596   BasicType _type;
1597   LIR_Opr   _tmp1;
1598   LIR_Opr   _tmp2;
1599   LIR_Opr   _tmp3;
1600   LIR_Opr   _tmp4;
1601   LIR_Opr   _tmp5;
1602   LIR_Condition _condition;
1603 
1604   void verify() const;
1605 
1606  public:
</pre>
<hr />
<pre>
1759 
1760 //--------------------------------
1761 class LabelObj: public CompilationResourceObj {
1762  private:
1763   Label _label;
1764  public:
1765   LabelObj()                                     {}
1766   Label* label()                                 { return &amp;_label; }
1767 };
1768 
1769 
1770 class LIR_OpLock: public LIR_Op {
1771  friend class LIR_OpVisitState;
1772 
1773  private:
1774   LIR_Opr _hdr;
1775   LIR_Opr _obj;
1776   LIR_Opr _lock;
1777   LIR_Opr _scratch;
1778   CodeStub* _stub;

1779  public:
<span class="line-modified">1780   LIR_OpLock(LIR_Code code, LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info)</span>
1781     : LIR_Op(code, LIR_OprFact::illegalOpr, info)
1782     , _hdr(hdr)
1783     , _obj(obj)
1784     , _lock(lock)
1785     , _scratch(scratch)
<span class="line-modified">1786     , _stub(stub)                      {}</span>

1787 
1788   LIR_Opr hdr_opr() const                        { return _hdr; }
1789   LIR_Opr obj_opr() const                        { return _obj; }
1790   LIR_Opr lock_opr() const                       { return _lock; }
1791   LIR_Opr scratch_opr() const                    { return _scratch; }
1792   CodeStub* stub() const                         { return _stub; }

1793 
1794   virtual void emit_code(LIR_Assembler* masm);
1795   virtual LIR_OpLock* as_OpLock() { return this; }
1796   void print_instr(outputStream* out) const PRODUCT_RETURN;
1797 };
1798 
1799 
1800 class LIR_OpDelay: public LIR_Op {
1801  friend class LIR_OpVisitState;
1802 
1803  private:
1804   LIR_Op* _op;
1805 
1806  public:
1807   LIR_OpDelay(LIR_Op* op, CodeEmitInfo* info):
1808     LIR_Op(lir_delay_slot, LIR_OprFact::illegalOpr, info),
1809     _op(op) {
1810     assert(op-&gt;code() == lir_nop || LIRFillDelaySlots, &quot;should be filling with nops&quot;);
1811   }
1812   virtual void emit_code(LIR_Assembler* masm);
</pre>
<hr />
<pre>
2205   void unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp);
2206 
2207   void shift_left(LIR_Opr value, int count, LIR_Opr dst)       { shift_left(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2208   void shift_right(LIR_Opr value, int count, LIR_Opr dst)      { shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2209   void unsigned_shift_right(LIR_Opr value, int count, LIR_Opr dst) { unsigned_shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2210 
2211   void lcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst)        { append(new LIR_Op2(lir_cmp_l2i,  left, right, dst)); }
2212   void fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less);
2213 
2214   void call_runtime_leaf(address routine, LIR_Opr tmp, LIR_Opr result, LIR_OprList* arguments) {
2215     append(new LIR_OpRTCall(routine, tmp, result, arguments));
2216   }
2217 
2218   void call_runtime(address routine, LIR_Opr tmp, LIR_Opr result,
2219                     LIR_OprList* arguments, CodeEmitInfo* info) {
2220     append(new LIR_OpRTCall(routine, tmp, result, arguments, info));
2221   }
2222 
2223   void load_stack_address_monitor(int monitor_ix, LIR_Opr dst)  { append(new LIR_Op1(lir_monaddr, LIR_OprFact::intConst(monitor_ix), dst)); }
2224   void unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub);
<span class="line-modified">2225   void lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info);</span>
2226 
2227   void breakpoint()                                                  { append(new LIR_Op0(lir_breakpoint)); }
2228 
2229   void arraycopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info) { append(new LIR_OpArrayCopy(src, src_pos, dst, dst_pos, length, tmp, expected_type, flags, info)); }
2230 
2231   void update_crc32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)  { append(new LIR_OpUpdateCRC32(crc, val, res)); }
2232 
2233   void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci);
2234   void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci);






2235 
2236   void checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
2237                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
2238                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">2239                   ciMethod* profiled_method, int profiled_bci);</span>
2240   // MethodData* profiling
2241   void profile_call(ciMethod* method, int bci, ciMethod* callee, LIR_Opr mdo, LIR_Opr recv, LIR_Opr t1, ciKlass* cha_klass) {
2242     append(new LIR_OpProfileCall(method, bci, callee, mdo, recv, t1, cha_klass));
2243   }
2244   void profile_type(LIR_Address* mdp, LIR_Opr obj, ciKlass* exact_klass, intptr_t current_klass, LIR_Opr tmp, bool not_null, bool no_conflict) {
2245     append(new LIR_OpProfileType(LIR_OprFact::address(mdp), obj, exact_klass, current_klass, tmp, not_null, no_conflict));
2246   }
2247 
2248   void xadd(LIR_Opr src, LIR_Opr add, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xadd, src, add, res, tmp)); }
2249   void xchg(LIR_Opr src, LIR_Opr set, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xchg, src, set, res, tmp)); }
2250 #ifdef ASSERT
2251   void lir_assert(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, const char* msg, bool halt) { append(new LIR_OpAssert(condition, opr1, opr2, msg, halt)); }
2252 #endif
2253 };
2254 
2255 void print_LIR(BlockList* blocks);
2256 
2257 class LIR_InsertionBuffer : public CompilationResourceObj {
2258  private:
2259   LIR_List*   _lir;   // the lir list where ops of this buffer should be inserted later (NULL when uninitialized)
</pre>
</td>
<td>
<hr />
<pre>
 299   friend BasicType as_BasicType(OprType t);
 300 
 301   OprType type_field_valid() const               { assert(is_register() || is_stack(), &quot;should not be called otherwise&quot;); return (OprType)(value() &amp; type_mask); }
 302   OprType type_field() const                     { return is_illegal() ? unknown_type : (OprType)(value() &amp; type_mask); }
 303 
 304   static OprSize size_for(BasicType t) {
 305     switch (t) {
 306       case T_LONG:
 307       case T_DOUBLE:
 308         return double_size;
 309         break;
 310 
 311       case T_FLOAT:
 312       case T_BOOLEAN:
 313       case T_CHAR:
 314       case T_BYTE:
 315       case T_SHORT:
 316       case T_INT:
 317       case T_ADDRESS:
 318       case T_OBJECT:
<span class="line-added"> 319       case T_VALUETYPE:</span>
 320       case T_ARRAY:
 321       case T_METADATA:
 322         return single_size;
 323         break;
 324 
 325       default:
 326         ShouldNotReachHere();
 327         return single_size;
 328       }
 329   }
 330 
 331 
 332   void validate_type() const PRODUCT_RETURN;
 333 
 334   BasicType type() const {
 335     if (is_pointer()) {
 336       return pointer()-&gt;type();
 337     }
 338     return as_BasicType(type_field());
 339   }
</pre>
<hr />
<pre>
 450 #endif
 451 
 452   jint      as_jint()    const { return as_constant_ptr()-&gt;as_jint(); }
 453   jlong     as_jlong()   const { return as_constant_ptr()-&gt;as_jlong(); }
 454   jfloat    as_jfloat()  const { return as_constant_ptr()-&gt;as_jfloat(); }
 455   jdouble   as_jdouble() const { return as_constant_ptr()-&gt;as_jdouble(); }
 456   jobject   as_jobject() const { return as_constant_ptr()-&gt;as_jobject(); }
 457 
 458   void print() const PRODUCT_RETURN;
 459   void print(outputStream* out) const PRODUCT_RETURN;
 460 };
 461 
 462 
 463 inline LIR_OprDesc::OprType as_OprType(BasicType type) {
 464   switch (type) {
 465   case T_INT:      return LIR_OprDesc::int_type;
 466   case T_LONG:     return LIR_OprDesc::long_type;
 467   case T_FLOAT:    return LIR_OprDesc::float_type;
 468   case T_DOUBLE:   return LIR_OprDesc::double_type;
 469   case T_OBJECT:
<span class="line-added"> 470   case T_VALUETYPE:</span>
 471   case T_ARRAY:    return LIR_OprDesc::object_type;
 472   case T_ADDRESS:  return LIR_OprDesc::address_type;
 473   case T_METADATA: return LIR_OprDesc::metadata_type;
 474   case T_ILLEGAL:  // fall through
 475   default: ShouldNotReachHere(); return LIR_OprDesc::unknown_type;
 476   }
 477 }
 478 
 479 inline BasicType as_BasicType(LIR_OprDesc::OprType t) {
 480   switch (t) {
 481   case LIR_OprDesc::int_type:     return T_INT;
 482   case LIR_OprDesc::long_type:    return T_LONG;
 483   case LIR_OprDesc::float_type:   return T_FLOAT;
 484   case LIR_OprDesc::double_type:  return T_DOUBLE;
 485   case LIR_OprDesc::object_type:  return T_OBJECT;
 486   case LIR_OprDesc::address_type: return T_ADDRESS;
 487   case LIR_OprDesc::metadata_type:return T_METADATA;
 488   case LIR_OprDesc::unknown_type: // fall through
 489   default: ShouldNotReachHere();  return T_ILLEGAL;
 490   }
</pre>
<hr />
<pre>
 636     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 637                                LIR_OprDesc::float_type          |
 638                                LIR_OprDesc::fpu_register        |
 639                                LIR_OprDesc::single_size         |
 640                                LIR_OprDesc::is_xmm_mask);
 641   }
 642   static LIR_Opr double_xmm(int reg) {
 643     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 644                                (reg &lt;&lt; LIR_OprDesc::reg2_shift) |
 645                                LIR_OprDesc::double_type         |
 646                                LIR_OprDesc::fpu_register        |
 647                                LIR_OprDesc::double_size         |
 648                                LIR_OprDesc::is_xmm_mask);
 649   }
 650 #endif // X86
 651 
 652   static LIR_Opr virtual_register(int index, BasicType type) {
 653     LIR_Opr res;
 654     switch (type) {
 655       case T_OBJECT: // fall through
<span class="line-added"> 656       case T_VALUETYPE: // fall through</span>
 657       case T_ARRAY:
 658         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 659                                             LIR_OprDesc::object_type  |
 660                                             LIR_OprDesc::cpu_register |
 661                                             LIR_OprDesc::single_size  |
 662                                             LIR_OprDesc::virtual_mask);
 663         break;
 664 
 665       case T_METADATA:
 666         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 667                                             LIR_OprDesc::metadata_type|
 668                                             LIR_OprDesc::cpu_register |
 669                                             LIR_OprDesc::single_size  |
 670                                             LIR_OprDesc::virtual_mask);
 671         break;
 672 
 673       case T_INT:
 674         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 675                                   LIR_OprDesc::int_type              |
 676                                   LIR_OprDesc::cpu_register          |
</pre>
<hr />
<pre>
 742                                t |
 743                                LIR_OprDesc::cpu_register |
 744                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 745 #else // __SOFTFP__
 746     LIR_Opr old_res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) | t |
 747                                           ((type == T_FLOAT || type == T_DOUBLE) ?  LIR_OprDesc::fpu_register : LIR_OprDesc::cpu_register) |
 748                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 749     assert(res == old_res, &quot;old and new method not equal&quot;);
 750 #endif // __SOFTFP__
 751 #endif // ASSERT
 752 
 753     return res;
 754   }
 755 
 756   // &#39;index&#39; is computed by FrameMap::local_stack_pos(index); do not use other parameters as
 757   // the index is platform independent; a double stack useing indeces 2 and 3 has always
 758   // index 2.
 759   static LIR_Opr stack(int index, BasicType type) {
 760     LIR_Opr res;
 761     switch (type) {
<span class="line-added"> 762       case T_VALUETYPE: // fall through</span>
 763       case T_OBJECT: // fall through
 764       case T_ARRAY:
 765         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 766                                   LIR_OprDesc::object_type           |
 767                                   LIR_OprDesc::stack_value           |
 768                                   LIR_OprDesc::single_size);
 769         break;
 770 
 771       case T_METADATA:
 772         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 773                                   LIR_OprDesc::metadata_type         |
 774                                   LIR_OprDesc::stack_value           |
 775                                   LIR_OprDesc::single_size);
 776         break;
 777       case T_INT:
 778         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 779                                   LIR_OprDesc::int_type              |
 780                                   LIR_OprDesc::stack_value           |
 781                                   LIR_OprDesc::single_size);
 782         break;
</pre>
<hr />
<pre>
 855 //
 856 class  LIR_Op;
 857 class    LIR_Op0;
 858 class      LIR_OpLabel;
 859 class    LIR_Op1;
 860 class      LIR_OpBranch;
 861 class      LIR_OpConvert;
 862 class      LIR_OpAllocObj;
 863 class      LIR_OpRoundFP;
 864 class    LIR_Op2;
 865 class    LIR_OpDelay;
 866 class    LIR_Op3;
 867 class      LIR_OpAllocArray;
 868 class    LIR_OpCall;
 869 class      LIR_OpJavaCall;
 870 class      LIR_OpRTCall;
 871 class    LIR_OpArrayCopy;
 872 class    LIR_OpUpdateCRC32;
 873 class    LIR_OpLock;
 874 class    LIR_OpTypeCheck;
<span class="line-added"> 875 class    LIR_OpFlattenedArrayCheck;</span>
<span class="line-added"> 876 class    LIR_OpNullFreeArrayCheck;</span>
<span class="line-added"> 877 class    LIR_OpSubstitutabilityCheck;</span>
 878 class    LIR_OpCompareAndSwap;
 879 class    LIR_OpProfileCall;
 880 class    LIR_OpProfileType;
 881 #ifdef ASSERT
 882 class    LIR_OpAssert;
 883 #endif
 884 
 885 // LIR operation codes
 886 enum LIR_Code {
 887     lir_none
 888   , begin_op0
 889       , lir_label
 890       , lir_nop
 891       , lir_backwardbranch_target
 892       , lir_std_entry
 893       , lir_osr_entry
 894       , lir_fpop_raw
 895       , lir_breakpoint
 896       , lir_rtcall
 897       , lir_membar
 898       , lir_membar_acquire
 899       , lir_membar_release
 900       , lir_membar_loadload
 901       , lir_membar_storestore
 902       , lir_membar_loadstore
 903       , lir_membar_storeload
 904       , lir_get_thread
 905       , lir_on_spin_wait
<span class="line-added"> 906       , lir_check_orig_pc</span>
 907   , end_op0
 908   , begin_op1
 909       , lir_fxch
 910       , lir_fld
 911       , lir_push
 912       , lir_pop
 913       , lir_null_check
 914       , lir_return
 915       , lir_leal
 916       , lir_branch
 917       , lir_cond_float_branch
 918       , lir_move
 919       , lir_convert
 920       , lir_alloc_object
 921       , lir_monaddr
 922       , lir_roundfp
 923       , lir_safepoint
 924       , lir_pack64
 925       , lir_unpack64
 926       , lir_unwind
</pre>
<hr />
<pre>
 968       , lir_dynamic_call
 969   , end_opJavaCall
 970   , begin_opArrayCopy
 971       , lir_arraycopy
 972   , end_opArrayCopy
 973   , begin_opUpdateCRC32
 974       , lir_updatecrc32
 975   , end_opUpdateCRC32
 976   , begin_opLock
 977     , lir_lock
 978     , lir_unlock
 979   , end_opLock
 980   , begin_delay_slot
 981     , lir_delay_slot
 982   , end_delay_slot
 983   , begin_opTypeCheck
 984     , lir_instanceof
 985     , lir_checkcast
 986     , lir_store_check
 987   , end_opTypeCheck
<span class="line-added"> 988   , begin_opFlattenedArrayCheck</span>
<span class="line-added"> 989     , lir_flattened_array_check</span>
<span class="line-added"> 990   , end_opFlattenedArrayCheck</span>
<span class="line-added"> 991   , begin_opNullFreeArrayCheck</span>
<span class="line-added"> 992     , lir_null_free_array_check</span>
<span class="line-added"> 993   , end_opNullFreeArrayCheck</span>
<span class="line-added"> 994   , begin_opSubstitutabilityCheck</span>
<span class="line-added"> 995     , lir_substitutability_check</span>
<span class="line-added"> 996   , end_opSubstitutabilityCheck</span>
 997   , begin_opCompareAndSwap
 998     , lir_cas_long
 999     , lir_cas_obj
1000     , lir_cas_int
1001   , end_opCompareAndSwap
1002   , begin_opMDOProfile
1003     , lir_profile_call
1004     , lir_profile_type
1005   , end_opMDOProfile
1006   , begin_opAssert
1007     , lir_assert
1008   , end_opAssert
1009 };
1010 
1011 
1012 enum LIR_Condition {
1013     lir_cond_equal
1014   , lir_cond_notEqual
1015   , lir_cond_less
1016   , lir_cond_lessEqual
</pre>
<hr />
<pre>
1127 
1128   virtual bool is_patching() { return false; }
1129   virtual LIR_OpCall* as_OpCall() { return NULL; }
1130   virtual LIR_OpJavaCall* as_OpJavaCall() { return NULL; }
1131   virtual LIR_OpLabel* as_OpLabel() { return NULL; }
1132   virtual LIR_OpDelay* as_OpDelay() { return NULL; }
1133   virtual LIR_OpLock* as_OpLock() { return NULL; }
1134   virtual LIR_OpAllocArray* as_OpAllocArray() { return NULL; }
1135   virtual LIR_OpAllocObj* as_OpAllocObj() { return NULL; }
1136   virtual LIR_OpRoundFP* as_OpRoundFP() { return NULL; }
1137   virtual LIR_OpBranch* as_OpBranch() { return NULL; }
1138   virtual LIR_OpRTCall* as_OpRTCall() { return NULL; }
1139   virtual LIR_OpConvert* as_OpConvert() { return NULL; }
1140   virtual LIR_Op0* as_Op0() { return NULL; }
1141   virtual LIR_Op1* as_Op1() { return NULL; }
1142   virtual LIR_Op2* as_Op2() { return NULL; }
1143   virtual LIR_Op3* as_Op3() { return NULL; }
1144   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return NULL; }
1145   virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32() { return NULL; }
1146   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return NULL; }
<span class="line-added">1147   virtual LIR_OpFlattenedArrayCheck* as_OpFlattenedArrayCheck() { return NULL; }</span>
<span class="line-added">1148   virtual LIR_OpNullFreeArrayCheck* as_OpNullFreeArrayCheck() { return NULL; }</span>
<span class="line-added">1149   virtual LIR_OpSubstitutabilityCheck* as_OpSubstitutabilityCheck() { return NULL; }</span>
1150   virtual LIR_OpCompareAndSwap* as_OpCompareAndSwap() { return NULL; }
1151   virtual LIR_OpProfileCall* as_OpProfileCall() { return NULL; }
1152   virtual LIR_OpProfileType* as_OpProfileType() { return NULL; }
1153 #ifdef ASSERT
1154   virtual LIR_OpAssert* as_OpAssert() { return NULL; }
1155 #endif
1156 
1157   virtual void verify() const {}
1158 };
1159 
1160 // for calls
1161 class LIR_OpCall: public LIR_Op {
1162  friend class LIR_OpVisitState;
1163 
1164  protected:
1165   address      _addr;
1166   LIR_OprList* _arguments;
1167  protected:
1168   LIR_OpCall(LIR_Code code, address addr, LIR_Opr result,
1169              LIR_OprList* arguments, CodeEmitInfo* info = NULL)
</pre>
<hr />
<pre>
1210   { assert(is_in_range(code, begin_opJavaCall, end_opJavaCall), &quot;code check&quot;); }
1211 
1212   LIR_Opr receiver() const                       { return _receiver; }
1213   ciMethod* method() const                       { return _method;   }
1214 
1215   // JSR 292 support.
1216   bool is_invokedynamic() const                  { return code() == lir_dynamic_call; }
1217   bool is_method_handle_invoke() const {
1218     return method()-&gt;is_compiled_lambda_form() ||   // Java-generated lambda form
1219            method()-&gt;is_method_handle_intrinsic();  // JVM-generated MH intrinsic
1220   }
1221 
1222   intptr_t vtable_offset() const {
1223     assert(_code == lir_virtual_call, &quot;only have vtable for real vcall&quot;);
1224     return (intptr_t) addr();
1225   }
1226 
1227   virtual void emit_code(LIR_Assembler* masm);
1228   virtual LIR_OpJavaCall* as_OpJavaCall() { return this; }
1229   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
<span class="line-added">1230 </span>
<span class="line-added">1231   bool maybe_return_as_fields(ciValueKlass** vk = NULL) const;</span>
1232 };
1233 
1234 // --------------------------------------------------
1235 // LIR_OpLabel
1236 // --------------------------------------------------
1237 // Location where a branch can continue
1238 class LIR_OpLabel: public LIR_Op {
1239  friend class LIR_OpVisitState;
1240 
1241  private:
1242   Label* _label;
1243  public:
1244   LIR_OpLabel(Label* lbl)
1245    : LIR_Op(lir_label, LIR_OprFact::illegalOpr, NULL)
1246    , _label(lbl)                                 {}
1247   Label* label() const                           { return _label; }
1248 
1249   virtual void emit_code(LIR_Assembler* masm);
1250   virtual LIR_OpLabel* as_OpLabel() { return this; }
1251   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
</pre>
<hr />
<pre>
1263   LIR_Opr   _dst_pos;
1264   LIR_Opr   _length;
1265   LIR_Opr   _tmp;
1266   ciArrayKlass* _expected_type;
1267   int       _flags;
1268 
1269 public:
1270   enum Flags {
1271     src_null_check         = 1 &lt;&lt; 0,
1272     dst_null_check         = 1 &lt;&lt; 1,
1273     src_pos_positive_check = 1 &lt;&lt; 2,
1274     dst_pos_positive_check = 1 &lt;&lt; 3,
1275     length_positive_check  = 1 &lt;&lt; 4,
1276     src_range_check        = 1 &lt;&lt; 5,
1277     dst_range_check        = 1 &lt;&lt; 6,
1278     type_check             = 1 &lt;&lt; 7,
1279     overlapping            = 1 &lt;&lt; 8,
1280     unaligned              = 1 &lt;&lt; 9,
1281     src_objarray           = 1 &lt;&lt; 10,
1282     dst_objarray           = 1 &lt;&lt; 11,
<span class="line-modified">1283     always_slow_path       = 1 &lt;&lt; 12,</span>
<span class="line-added">1284     src_valuetype_check    = 1 &lt;&lt; 13,</span>
<span class="line-added">1285     dst_valuetype_check    = 1 &lt;&lt; 14,</span>
<span class="line-added">1286     all_flags              = (1 &lt;&lt; 15) - 1</span>
1287   };
1288 
1289   LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp,
1290                   ciArrayKlass* expected_type, int flags, CodeEmitInfo* info);
1291 
1292   LIR_Opr src() const                            { return _src; }
1293   LIR_Opr src_pos() const                        { return _src_pos; }
1294   LIR_Opr dst() const                            { return _dst; }
1295   LIR_Opr dst_pos() const                        { return _dst_pos; }
1296   LIR_Opr length() const                         { return _length; }
1297   LIR_Opr tmp() const                            { return _tmp; }
1298   int flags() const                              { return _flags; }
1299   ciArrayKlass* expected_type() const            { return _expected_type; }
1300   ArrayCopyStub* stub() const                    { return _stub; }
1301 
1302   virtual void emit_code(LIR_Assembler* masm);
1303   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return this; }
1304   void print_instr(outputStream* out) const PRODUCT_RETURN;
1305 };
1306 
</pre>
<hr />
<pre>
1559 };
1560 
1561 // LIR_OpTypeCheck
1562 class LIR_OpTypeCheck: public LIR_Op {
1563  friend class LIR_OpVisitState;
1564 
1565  private:
1566   LIR_Opr       _object;
1567   LIR_Opr       _array;
1568   ciKlass*      _klass;
1569   LIR_Opr       _tmp1;
1570   LIR_Opr       _tmp2;
1571   LIR_Opr       _tmp3;
1572   bool          _fast_check;
1573   CodeEmitInfo* _info_for_patch;
1574   CodeEmitInfo* _info_for_exception;
1575   CodeStub*     _stub;
1576   ciMethod*     _profiled_method;
1577   int           _profiled_bci;
1578   bool          _should_profile;
<span class="line-added">1579   bool          _need_null_check;</span>
1580 
1581 public:
1582   LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
1583                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
<span class="line-modified">1584                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub, bool need_null_check = true);</span>
1585   LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array,
1586                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception);
1587 
1588   LIR_Opr object() const                         { return _object;         }
1589   LIR_Opr array() const                          { assert(code() == lir_store_check, &quot;not valid&quot;); return _array;         }
1590   LIR_Opr tmp1() const                           { return _tmp1;           }
1591   LIR_Opr tmp2() const                           { return _tmp2;           }
1592   LIR_Opr tmp3() const                           { return _tmp3;           }
1593   ciKlass* klass() const                         { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _klass;          }
1594   bool fast_check() const                        { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _fast_check;     }
1595   CodeEmitInfo* info_for_patch() const           { return _info_for_patch;  }
1596   CodeEmitInfo* info_for_exception() const       { return _info_for_exception; }
1597   CodeStub* stub() const                         { return _stub;           }
1598 
1599   // MethodData* profiling
1600   void set_profiled_method(ciMethod *method)     { _profiled_method = method; }
1601   void set_profiled_bci(int bci)                 { _profiled_bci = bci;       }
1602   void set_should_profile(bool b)                { _should_profile = b;       }
1603   ciMethod* profiled_method() const              { return _profiled_method;   }
1604   int       profiled_bci() const                 { return _profiled_bci;      }
1605   bool      should_profile() const               { return _should_profile;    }
<span class="line-modified">1606   bool      need_null_check() const              { return _need_null_check;   }</span>
1607   virtual bool is_patching() { return _info_for_patch != NULL; }
1608   virtual void emit_code(LIR_Assembler* masm);
1609   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return this; }
1610   void print_instr(outputStream* out) const PRODUCT_RETURN;
1611 };
1612 
<span class="line-added">1613 // LIR_OpFlattenedArrayCheck</span>
<span class="line-added">1614 class LIR_OpFlattenedArrayCheck: public LIR_Op {</span>
<span class="line-added">1615  friend class LIR_OpVisitState;</span>
<span class="line-added">1616 </span>
<span class="line-added">1617  private:</span>
<span class="line-added">1618   LIR_Opr       _array;</span>
<span class="line-added">1619   LIR_Opr       _value;</span>
<span class="line-added">1620   LIR_Opr       _tmp;</span>
<span class="line-added">1621   CodeStub*     _stub;</span>
<span class="line-added">1622 public:</span>
<span class="line-added">1623   LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);</span>
<span class="line-added">1624   LIR_Opr array() const                          { return _array;         }</span>
<span class="line-added">1625   LIR_Opr value() const                          { return _value;         }</span>
<span class="line-added">1626   LIR_Opr tmp() const                            { return _tmp;           }</span>
<span class="line-added">1627   CodeStub* stub() const                         { return _stub;          }</span>
<span class="line-added">1628 </span>
<span class="line-added">1629   virtual void emit_code(LIR_Assembler* masm);</span>
<span class="line-added">1630   virtual LIR_OpFlattenedArrayCheck* as_OpFlattenedArrayCheck() { return this; }</span>
<span class="line-added">1631   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;</span>
<span class="line-added">1632 };</span>
<span class="line-added">1633 </span>
<span class="line-added">1634 // LIR_OpNullFreeArrayCheck</span>
<span class="line-added">1635 class LIR_OpNullFreeArrayCheck: public LIR_Op {</span>
<span class="line-added">1636  friend class LIR_OpVisitState;</span>
<span class="line-added">1637 </span>
<span class="line-added">1638  private:</span>
<span class="line-added">1639   LIR_Opr       _array;</span>
<span class="line-added">1640   LIR_Opr       _tmp;</span>
<span class="line-added">1641 public:</span>
<span class="line-added">1642   LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp);</span>
<span class="line-added">1643   LIR_Opr array() const                          { return _array;         }</span>
<span class="line-added">1644   LIR_Opr tmp() const                            { return _tmp;           }</span>
<span class="line-added">1645 </span>
<span class="line-added">1646   virtual void emit_code(LIR_Assembler* masm);</span>
<span class="line-added">1647   virtual LIR_OpNullFreeArrayCheck* as_OpNullFreeArrayCheck() { return this; }</span>
<span class="line-added">1648   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;</span>
<span class="line-added">1649 };</span>
<span class="line-added">1650 </span>
<span class="line-added">1651 class LIR_OpSubstitutabilityCheck: public LIR_Op {</span>
<span class="line-added">1652  friend class LIR_OpVisitState;</span>
<span class="line-added">1653 </span>
<span class="line-added">1654  private:</span>
<span class="line-added">1655   LIR_Opr       _left;</span>
<span class="line-added">1656   LIR_Opr       _right;</span>
<span class="line-added">1657   LIR_Opr       _equal_result;</span>
<span class="line-added">1658   LIR_Opr       _not_equal_result;</span>
<span class="line-added">1659   LIR_Opr       _tmp1;</span>
<span class="line-added">1660   LIR_Opr       _tmp2;</span>
<span class="line-added">1661   ciKlass*      _left_klass;</span>
<span class="line-added">1662   ciKlass*      _right_klass;</span>
<span class="line-added">1663   LIR_Opr       _left_klass_op;</span>
<span class="line-added">1664   LIR_Opr       _right_klass_op;</span>
<span class="line-added">1665   CodeStub*     _stub;</span>
<span class="line-added">1666 public:</span>
<span class="line-added">1667   LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added">1668                               LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added">1669                               ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added">1670                               CodeEmitInfo* info, CodeStub* stub);</span>
<span class="line-added">1671 </span>
<span class="line-added">1672   LIR_Opr left() const             { return _left; }</span>
<span class="line-added">1673   LIR_Opr right() const            { return _right; }</span>
<span class="line-added">1674   LIR_Opr equal_result() const     { return _equal_result; }</span>
<span class="line-added">1675   LIR_Opr not_equal_result() const { return _not_equal_result; }</span>
<span class="line-added">1676   LIR_Opr tmp1() const             { return _tmp1; }</span>
<span class="line-added">1677   LIR_Opr tmp2() const             { return _tmp2; }</span>
<span class="line-added">1678   ciKlass* left_klass() const      { return _left_klass; }</span>
<span class="line-added">1679   ciKlass* right_klass() const     { return _right_klass; }</span>
<span class="line-added">1680   LIR_Opr left_klass_op() const    { return _left_klass_op; }</span>
<span class="line-added">1681   LIR_Opr right_klass_op() const   { return _right_klass_op; }</span>
<span class="line-added">1682   CodeStub* stub() const           { return _stub; }</span>
<span class="line-added">1683 </span>
<span class="line-added">1684   virtual void emit_code(LIR_Assembler* masm);</span>
<span class="line-added">1685   virtual LIR_OpSubstitutabilityCheck* as_OpSubstitutabilityCheck() { return this; }</span>
<span class="line-added">1686   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;</span>
<span class="line-added">1687 };</span>
<span class="line-added">1688 </span>
1689 // LIR_Op2
1690 class LIR_Op2: public LIR_Op {
1691  friend class LIR_OpVisitState;
1692 
1693   int  _fpu_stack_size; // for sin/cos implementation on Intel
1694 
1695  protected:
1696   LIR_Opr   _opr1;
1697   LIR_Opr   _opr2;
1698   BasicType _type;
1699   LIR_Opr   _tmp1;
1700   LIR_Opr   _tmp2;
1701   LIR_Opr   _tmp3;
1702   LIR_Opr   _tmp4;
1703   LIR_Opr   _tmp5;
1704   LIR_Condition _condition;
1705 
1706   void verify() const;
1707 
1708  public:
</pre>
<hr />
<pre>
1861 
1862 //--------------------------------
1863 class LabelObj: public CompilationResourceObj {
1864  private:
1865   Label _label;
1866  public:
1867   LabelObj()                                     {}
1868   Label* label()                                 { return &amp;_label; }
1869 };
1870 
1871 
1872 class LIR_OpLock: public LIR_Op {
1873  friend class LIR_OpVisitState;
1874 
1875  private:
1876   LIR_Opr _hdr;
1877   LIR_Opr _obj;
1878   LIR_Opr _lock;
1879   LIR_Opr _scratch;
1880   CodeStub* _stub;
<span class="line-added">1881   CodeStub* _throw_imse_stub;</span>
1882  public:
<span class="line-modified">1883   LIR_OpLock(LIR_Code code, LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub=NULL)</span>
1884     : LIR_Op(code, LIR_OprFact::illegalOpr, info)
1885     , _hdr(hdr)
1886     , _obj(obj)
1887     , _lock(lock)
1888     , _scratch(scratch)
<span class="line-modified">1889     , _stub(stub)</span>
<span class="line-added">1890     , _throw_imse_stub(throw_imse_stub)                    {}</span>
1891 
1892   LIR_Opr hdr_opr() const                        { return _hdr; }
1893   LIR_Opr obj_opr() const                        { return _obj; }
1894   LIR_Opr lock_opr() const                       { return _lock; }
1895   LIR_Opr scratch_opr() const                    { return _scratch; }
1896   CodeStub* stub() const                         { return _stub; }
<span class="line-added">1897   CodeStub* throw_imse_stub() const              { return _throw_imse_stub; }</span>
1898 
1899   virtual void emit_code(LIR_Assembler* masm);
1900   virtual LIR_OpLock* as_OpLock() { return this; }
1901   void print_instr(outputStream* out) const PRODUCT_RETURN;
1902 };
1903 
1904 
1905 class LIR_OpDelay: public LIR_Op {
1906  friend class LIR_OpVisitState;
1907 
1908  private:
1909   LIR_Op* _op;
1910 
1911  public:
1912   LIR_OpDelay(LIR_Op* op, CodeEmitInfo* info):
1913     LIR_Op(lir_delay_slot, LIR_OprFact::illegalOpr, info),
1914     _op(op) {
1915     assert(op-&gt;code() == lir_nop || LIRFillDelaySlots, &quot;should be filling with nops&quot;);
1916   }
1917   virtual void emit_code(LIR_Assembler* masm);
</pre>
<hr />
<pre>
2310   void unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp);
2311 
2312   void shift_left(LIR_Opr value, int count, LIR_Opr dst)       { shift_left(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2313   void shift_right(LIR_Opr value, int count, LIR_Opr dst)      { shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2314   void unsigned_shift_right(LIR_Opr value, int count, LIR_Opr dst) { unsigned_shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2315 
2316   void lcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst)        { append(new LIR_Op2(lir_cmp_l2i,  left, right, dst)); }
2317   void fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less);
2318 
2319   void call_runtime_leaf(address routine, LIR_Opr tmp, LIR_Opr result, LIR_OprList* arguments) {
2320     append(new LIR_OpRTCall(routine, tmp, result, arguments));
2321   }
2322 
2323   void call_runtime(address routine, LIR_Opr tmp, LIR_Opr result,
2324                     LIR_OprList* arguments, CodeEmitInfo* info) {
2325     append(new LIR_OpRTCall(routine, tmp, result, arguments, info));
2326   }
2327 
2328   void load_stack_address_monitor(int monitor_ix, LIR_Opr dst)  { append(new LIR_Op1(lir_monaddr, LIR_OprFact::intConst(monitor_ix), dst)); }
2329   void unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub);
<span class="line-modified">2330   void lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub=NULL);</span>
2331 
2332   void breakpoint()                                                  { append(new LIR_Op0(lir_breakpoint)); }
2333 
2334   void arraycopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info) { append(new LIR_OpArrayCopy(src, src_pos, dst, dst_pos, length, tmp, expected_type, flags, info)); }
2335 
2336   void update_crc32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)  { append(new LIR_OpUpdateCRC32(crc, val, res)); }
2337 
2338   void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci);
2339   void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci);
<span class="line-added">2340   void check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);</span>
<span class="line-added">2341   void check_null_free_array(LIR_Opr array, LIR_Opr tmp);</span>
<span class="line-added">2342   void substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added">2343                               LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added">2344                               ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added">2345                               CodeEmitInfo* info, CodeStub* stub);</span>
2346 
2347   void checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
2348                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
2349                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">2350                   ciMethod* profiled_method, int profiled_bci, bool is_never_null);</span>
2351   // MethodData* profiling
2352   void profile_call(ciMethod* method, int bci, ciMethod* callee, LIR_Opr mdo, LIR_Opr recv, LIR_Opr t1, ciKlass* cha_klass) {
2353     append(new LIR_OpProfileCall(method, bci, callee, mdo, recv, t1, cha_klass));
2354   }
2355   void profile_type(LIR_Address* mdp, LIR_Opr obj, ciKlass* exact_klass, intptr_t current_klass, LIR_Opr tmp, bool not_null, bool no_conflict) {
2356     append(new LIR_OpProfileType(LIR_OprFact::address(mdp), obj, exact_klass, current_klass, tmp, not_null, no_conflict));
2357   }
2358 
2359   void xadd(LIR_Opr src, LIR_Opr add, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xadd, src, add, res, tmp)); }
2360   void xchg(LIR_Opr src, LIR_Opr set, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xchg, src, set, res, tmp)); }
2361 #ifdef ASSERT
2362   void lir_assert(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, const char* msg, bool halt) { append(new LIR_OpAssert(condition, opr1, opr2, msg, halt)); }
2363 #endif
2364 };
2365 
2366 void print_LIR(BlockList* blocks);
2367 
2368 class LIR_InsertionBuffer : public CompilationResourceObj {
2369  private:
2370   LIR_List*   _lir;   // the lir list where ops of this buffer should be inserted later (NULL when uninitialized)
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
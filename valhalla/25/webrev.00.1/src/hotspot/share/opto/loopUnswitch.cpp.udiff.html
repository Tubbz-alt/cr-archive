<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/loopUnswitch.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopUnswitch.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,10 +22,12 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;opto/mulnode.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;opto/addnode.hpp&quot;</span>
  #include &quot;opto/connode.hpp&quot;
  #include &quot;opto/convertnode.hpp&quot;
  #include &quot;opto/loopnode.hpp&quot;
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -49,10 +51,11 @@</span>
  //                                 endloop
  //                               endif
  //
  // Note: the &quot;else&quot; clause may be empty
  
<span class="udiff-line-added">+ </span>
  //------------------------------policy_unswitching-----------------------------
  // Return TRUE or FALSE if the loop should be unswitched
  // (ie. clone loop with an invariant test that does not exit the loop)
  bool IdealLoopTree::policy_unswitching( PhaseIdealLoop *phase ) const {
    if (!LoopUnswitching) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -72,21 +75,27 @@</span>
  
    LoopNode* head = _head-&gt;as_Loop();
    if (head-&gt;unswitch_count() + 1 &gt; head-&gt;unswitch_max()) {
      return false;
    }
<span class="udiff-line-modified-removed">-   if (phase-&gt;find_unswitching_candidate(this) == NULL) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   if (head-&gt;is_flattened_arrays()) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node_List flattened_checks;</span>
<span class="udiff-line-added">+   if (phase-&gt;find_unswitching_candidate(this, flattened_checks) == NULL &amp;&amp; flattened_checks.size() == 0) {</span>
      return false;
    }
  
    // Too speculative if running low on nodes.
    return phase-&gt;may_require_nodes(est_loop_clone_sz(2));
  }
  
  //------------------------------find_unswitching_candidate-----------------------------
  // Find candidate &quot;if&quot; for unswitching
<span class="udiff-line-modified-removed">- IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop) const {</span>
<span class="udiff-line-modified-added">+ IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop, Node_List&amp; flattened_checks) const {</span>
  
    // Find first invariant test that doesn&#39;t exit the loop
    LoopNode *head = loop-&gt;_head-&gt;as_Loop();
    IfNode* unswitch_iff = NULL;
    Node* n = head-&gt;in(LoopNode::LoopBackControl);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107,10 +116,29 @@</span>
          }
        }
      }
      n = n_dom;
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* array;</span>
<span class="udiff-line-added">+   if (unswitch_iff == NULL || unswitch_iff-&gt;is_flattened_array_check(&amp;_igvn, array)) {</span>
<span class="udiff-line-added">+     // collect all flattened array checks</span>
<span class="udiff-line-added">+     for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {</span>
<span class="udiff-line-added">+       Node* n = loop-&gt;_body.at(i);</span>
<span class="udiff-line-added">+       if (n-&gt;is_If() &amp;&amp; n-&gt;as_If()-&gt;is_flattened_array_check(&amp;_igvn, array) &amp;&amp;</span>
<span class="udiff-line-added">+           loop-&gt;is_invariant(n-&gt;in(1)) &amp;&amp;</span>
<span class="udiff-line-added">+           !loop-&gt;is_loop_exit(n)) {</span>
<span class="udiff-line-added">+         flattened_checks.push(n);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (flattened_checks.size() &gt; 1) {</span>
<span class="udiff-line-added">+       unswitch_iff = NULL;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       flattened_checks.clear();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    return unswitch_iff;
  }
  
  //------------------------------do_unswitching-----------------------------
  // Clone loop with an invariant test (that does not exit) and
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -130,12 +158,16 @@</span>
        // to wrong execution. Remove this bailout, once this is fixed.
        return;
      }
    }
    // Find first invariant test that doesn&#39;t exit the loop
<span class="udiff-line-modified-removed">-   IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop);</span>
<span class="udiff-line-modified-removed">-   assert(unswitch_iff != NULL, &quot;should be at least one&quot;);</span>
<span class="udiff-line-modified-added">+   Node_List flattened_checks;</span>
<span class="udiff-line-modified-added">+   IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop, flattened_checks);</span>
<span class="udiff-line-added">+   assert(unswitch_iff != NULL || flattened_checks.size() &gt; 0, &quot;should be at least one&quot;);</span>
<span class="udiff-line-added">+   if (unswitch_iff == NULL) {</span>
<span class="udiff-line-added">+     unswitch_iff = flattened_checks.at(0)-&gt;as_If();</span>
<span class="udiff-line-added">+   }</span>
  
  #ifndef PRODUCT
    if (TraceLoopOpts) {
      tty-&gt;print(&quot;Unswitch   %d &quot;, head-&gt;unswitch_count()+1);
      loop-&gt;dump_head();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -180,53 +212,123 @@</span>
    // Increment unswitch count
    LoopNode* head_clone = old_new[head-&gt;_idx]-&gt;as_Loop();
    int nct = head-&gt;unswitch_count() + 1;
    head-&gt;set_unswitch_count(nct);
    head_clone-&gt;set_unswitch_count(nct);
<span class="udiff-line-added">+   if (flattened_checks.size() &gt; 0) {</span>
<span class="udiff-line-added">+     head-&gt;mark_flattened_arrays();</span>
<span class="udiff-line-added">+   }</span>
  
    // Add test to new &quot;if&quot; outside of loop
    IfNode* invar_iff   = proj_true-&gt;in(0)-&gt;as_If();
    Node* invar_iff_c   = invar_iff-&gt;in(0);
<span class="udiff-line-modified-removed">-   BoolNode* bol       = unswitch_iff-&gt;in(1)-&gt;as_Bool();</span>
<span class="udiff-line-modified-removed">-   invar_iff-&gt;set_req(1, bol);</span>
<span class="udiff-line-modified-added">+   invar_iff-&gt;_prob    = unswitch_iff-&gt;_prob;</span>
<span class="udiff-line-modified-added">+   if (flattened_checks.size() &gt; 0) {</span>
<span class="udiff-line-added">+     // Flattened array checks are used in</span>
<span class="udiff-line-added">+     // Parse::array_store()/Parse::array_load() to switch between a</span>
<span class="udiff-line-added">+     // legacy object array access and a flattened value array</span>
<span class="udiff-line-added">+     // access. We want the performance impact on legacy accesses to be</span>
<span class="udiff-line-added">+     // as small as possible so we make 2 copies of the loops: a fast</span>
<span class="udiff-line-added">+     // one where all accesses are known to be legacy, a slow one where</span>
<span class="udiff-line-added">+     // some accesses are to flattened arrays. Flattened array checks</span>
<span class="udiff-line-added">+     // can be removed from the first one but not from the second one</span>
<span class="udiff-line-added">+     // as it can have a mix of flattened/legacy accesses.</span>
<span class="udiff-line-added">+     BoolNode* bol       = unswitch_iff-&gt;in(1)-&gt;clone()-&gt;as_Bool();</span>
<span class="udiff-line-added">+     register_new_node(bol, invar_iff-&gt;in(0));</span>
<span class="udiff-line-added">+     Node* cmp = bol-&gt;in(1)-&gt;clone();</span>
<span class="udiff-line-added">+     register_new_node(cmp, invar_iff-&gt;in(0));</span>
<span class="udiff-line-added">+     bol-&gt;set_req(1, cmp);</span>
<span class="udiff-line-added">+     Node* in1 = NULL;</span>
<span class="udiff-line-added">+     for (uint i = 0; i &lt; flattened_checks.size(); i++) {</span>
<span class="udiff-line-added">+       Node* v = flattened_checks.at(i)-&gt;in(1)-&gt;in(1)-&gt;in(1);</span>
<span class="udiff-line-added">+       if (in1 == NULL) {</span>
<span class="udiff-line-added">+         in1 = v;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         if (cmp-&gt;Opcode() == Op_CmpL) {</span>
<span class="udiff-line-added">+           in1 = new OrLNode(in1, v);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           in1 = new OrINode(in1, v);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         register_new_node(in1, invar_iff-&gt;in(0));</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     cmp-&gt;set_req(1, in1);</span>
<span class="udiff-line-added">+     invar_iff-&gt;set_req(1, bol);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     BoolNode* bol       = unswitch_iff-&gt;in(1)-&gt;as_Bool();</span>
<span class="udiff-line-added">+     invar_iff-&gt;set_req(1, bol);</span>
    }
  
    ProjNode* proj_false = invar_iff-&gt;proj_out(0)-&gt;as_Proj();
  
    // Hoist invariant casts out of each loop to the appropriate
    // control projection.
  
    Node_List worklist;
  
<span class="udiff-line-modified-removed">-   for (DUIterator_Fast imax, i = unswitch_iff-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-modified-removed">-     ProjNode* proj= unswitch_iff-&gt;fast_out(i)-&gt;as_Proj();</span>
<span class="udiff-line-modified-removed">-     // Copy to a worklist for easier manipulation</span>
<span class="udiff-line-modified-removed">-     for (DUIterator_Fast jmax, j = proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-modified-removed">-       Node* use = proj-&gt;fast_out(j);</span>
<span class="udiff-line-modified-removed">-       if (use-&gt;Opcode() == Op_CheckCastPP &amp;&amp; loop-&gt;is_invariant(use-&gt;in(1))) {</span>
<span class="udiff-line-modified-removed">-         worklist.push(use);</span>
<span class="udiff-line-modified-added">+   if (flattened_checks.size() &gt; 0) {</span>
<span class="udiff-line-modified-added">+     for (uint i = 0; i &lt; flattened_checks.size(); i++) {</span>
<span class="udiff-line-modified-added">+       IfNode* iff = flattened_checks.at(i)-&gt;as_If();</span>
<span class="udiff-line-modified-added">+       ProjNode* proj= iff-&gt;proj_out(0)-&gt;as_Proj();</span>
<span class="udiff-line-modified-added">+       // Copy to a worklist for easier manipulation</span>
<span class="udiff-line-modified-added">+       for (DUIterator_Fast jmax, j = proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-modified-added">+         Node* use = proj-&gt;fast_out(j);</span>
<span class="udiff-line-added">+         if (use-&gt;Opcode() == Op_CheckCastPP &amp;&amp; loop-&gt;is_invariant(use-&gt;in(1))) {</span>
<span class="udiff-line-added">+           worklist.push(use);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       ProjNode* invar_proj = invar_iff-&gt;proj_out(proj-&gt;_con)-&gt;as_Proj();</span>
<span class="udiff-line-added">+       while (worklist.size() &gt; 0) {</span>
<span class="udiff-line-added">+         Node* use = worklist.pop();</span>
<span class="udiff-line-added">+         Node* nuse = use-&gt;clone();</span>
<span class="udiff-line-added">+         nuse-&gt;set_req(0, invar_proj);</span>
<span class="udiff-line-added">+         _igvn.replace_input_of(use, 1, nuse);</span>
<span class="udiff-line-added">+         register_new_node(nuse, invar_proj);</span>
<span class="udiff-line-added">+         // Same for the clone</span>
<span class="udiff-line-added">+         Node* use_clone = old_new[use-&gt;_idx];</span>
<span class="udiff-line-added">+         _igvn.replace_input_of(use_clone, 1, nuse);</span>
        }
      }
<span class="udiff-line-modified-removed">-     ProjNode* invar_proj = invar_iff-&gt;proj_out(proj-&gt;_con)-&gt;as_Proj();</span>
<span class="udiff-line-modified-removed">-     while (worklist.size() &gt; 0) {</span>
<span class="udiff-line-modified-removed">-       Node* use = worklist.pop();</span>
<span class="udiff-line-modified-removed">-       Node* nuse = use-&gt;clone();</span>
<span class="udiff-line-modified-removed">-       nuse-&gt;set_req(0, invar_proj);</span>
<span class="udiff-line-modified-removed">-       _igvn.replace_input_of(use, 1, nuse);</span>
<span class="udiff-line-modified-removed">-       register_new_node(nuse, invar_proj);</span>
<span class="udiff-line-modified-removed">-       // Same for the clone</span>
<span class="udiff-line-modified-removed">-       Node* use_clone = old_new[use-&gt;_idx];</span>
<span class="udiff-line-modified-removed">-       _igvn.replace_input_of(use_clone, 1, nuse);</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     for (DUIterator_Fast imax, i = unswitch_iff-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-modified-added">+       ProjNode* proj= unswitch_iff-&gt;fast_out(i)-&gt;as_Proj();</span>
<span class="udiff-line-modified-added">+       // Copy to a worklist for easier manipulation</span>
<span class="udiff-line-modified-added">+       for (DUIterator_Fast jmax, j = proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-modified-added">+         Node* use = proj-&gt;fast_out(j);</span>
<span class="udiff-line-modified-added">+         if (use-&gt;Opcode() == Op_CheckCastPP &amp;&amp; loop-&gt;is_invariant(use-&gt;in(1))) {</span>
<span class="udiff-line-modified-added">+           worklist.push(use);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-added">+       ProjNode* invar_proj = invar_iff-&gt;proj_out(proj-&gt;_con)-&gt;as_Proj();</span>
<span class="udiff-line-added">+       while (worklist.size() &gt; 0) {</span>
<span class="udiff-line-added">+         Node* use = worklist.pop();</span>
<span class="udiff-line-added">+         Node* nuse = use-&gt;clone();</span>
<span class="udiff-line-added">+         nuse-&gt;set_req(0, invar_proj);</span>
<span class="udiff-line-added">+         _igvn.replace_input_of(use, 1, nuse);</span>
<span class="udiff-line-added">+         register_new_node(nuse, invar_proj);</span>
<span class="udiff-line-added">+         // Same for the clone</span>
<span class="udiff-line-added">+         Node* use_clone = old_new[use-&gt;_idx];</span>
<span class="udiff-line-added">+         _igvn.replace_input_of(use_clone, 1, nuse);</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  
<span class="udiff-line-modified-removed">-   // Hardwire the control paths in the loops into if(true) and if(false)</span>
<span class="udiff-line-modified-removed">-   _igvn.rehash_node_delayed(unswitch_iff);</span>
<span class="udiff-line-modified-removed">-   dominated_by(proj_true, unswitch_iff, false, false);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   IfNode* unswitch_iff_clone = old_new[unswitch_iff-&gt;_idx]-&gt;as_If();</span>
<span class="udiff-line-modified-removed">-   _igvn.rehash_node_delayed(unswitch_iff_clone);</span>
<span class="udiff-line-modified-added">+   IfNode* unswitch_iff_clone = old_new[unswitch_iff-&gt;_idx]-&gt;as_If();</span>
<span class="udiff-line-modified-added">+   if (flattened_checks.size() &gt; 0) {</span>
<span class="udiff-line-modified-added">+     for (uint i = 0; i &lt; flattened_checks.size(); i++) {</span>
<span class="udiff-line-modified-added">+       IfNode* iff = flattened_checks.at(i)-&gt;as_If();</span>
<span class="udiff-line-modified-added">+       _igvn.rehash_node_delayed(iff);</span>
<span class="udiff-line-modified-added">+       dominated_by(proj_false, old_new[iff-&gt;_idx]-&gt;as_If(), false, false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // Hardwire the control paths in the loops into if(true) and if(false)</span>
<span class="udiff-line-added">+     _igvn.rehash_node_delayed(unswitch_iff);</span>
<span class="udiff-line-added">+     dominated_by(proj_true, unswitch_iff, false, false);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     IfNode* unswitch_iff_clone = old_new[unswitch_iff-&gt;_idx]-&gt;as_If();</span>
<span class="udiff-line-added">+     _igvn.rehash_node_delayed(unswitch_iff_clone);</span>
<span class="udiff-line-added">+     dominated_by(proj_false, unswitch_iff_clone, false, false);</span>
    }
  
    // Reoptimize loops
    loop-&gt;record_for_igvn();
    for(int i = loop-&gt;_body.size() - 1; i &gt;= 0 ; i--) {
</pre>
<center><a href="compile.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
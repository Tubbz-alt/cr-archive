diff a/src/hotspot/share/opto/loopUnswitch.cpp b/src/hotspot/share/opto/loopUnswitch.cpp
--- a/src/hotspot/share/opto/loopUnswitch.cpp
+++ b/src/hotspot/share/opto/loopUnswitch.cpp
@@ -22,10 +22,12 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "memory/allocation.inline.hpp"
+#include "opto/mulnode.hpp"
+#include "opto/addnode.hpp"
 #include "opto/connode.hpp"
 #include "opto/convertnode.hpp"
 #include "opto/loopnode.hpp"
 #include "opto/opaquenode.hpp"
 #include "opto/rootnode.hpp"
@@ -49,10 +51,11 @@
 //                                 endloop
 //                               endif
 //
 // Note: the "else" clause may be empty
 
+
 //------------------------------policy_unswitching-----------------------------
 // Return TRUE or FALSE if the loop should be unswitched
 // (ie. clone loop with an invariant test that does not exit the loop)
 bool IdealLoopTree::policy_unswitching( PhaseIdealLoop *phase ) const {
   if (!LoopUnswitching) {
@@ -72,21 +75,27 @@
 
   LoopNode* head = _head->as_Loop();
   if (head->unswitch_count() + 1 > head->unswitch_max()) {
     return false;
   }
-  if (phase->find_unswitching_candidate(this) == NULL) {
+
+  if (head->is_flattened_arrays()) {
+    return false;
+  }
+
+  Node_List flattened_checks;
+  if (phase->find_unswitching_candidate(this, flattened_checks) == NULL && flattened_checks.size() == 0) {
     return false;
   }
 
   // Too speculative if running low on nodes.
   return phase->may_require_nodes(est_loop_clone_sz(2));
 }
 
 //------------------------------find_unswitching_candidate-----------------------------
 // Find candidate "if" for unswitching
-IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop) const {
+IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop, Node_List& flattened_checks) const {
 
   // Find first invariant test that doesn't exit the loop
   LoopNode *head = loop->_head->as_Loop();
   IfNode* unswitch_iff = NULL;
   Node* n = head->in(LoopNode::LoopBackControl);
@@ -107,10 +116,29 @@
         }
       }
     }
     n = n_dom;
   }
+
+  Node* array;
+  if (unswitch_iff == NULL || unswitch_iff->is_flattened_array_check(&_igvn, array)) {
+    // collect all flattened array checks
+    for (uint i = 0; i < loop->_body.size(); i++) {
+      Node* n = loop->_body.at(i);
+      if (n->is_If() && n->as_If()->is_flattened_array_check(&_igvn, array) &&
+          loop->is_invariant(n->in(1)) &&
+          !loop->is_loop_exit(n)) {
+        flattened_checks.push(n);
+      }
+    }
+    if (flattened_checks.size() > 1) {
+      unswitch_iff = NULL;
+    } else {
+      flattened_checks.clear();
+    }
+  }
+
   return unswitch_iff;
 }
 
 //------------------------------do_unswitching-----------------------------
 // Clone loop with an invariant test (that does not exit) and
@@ -130,12 +158,16 @@
       // to wrong execution. Remove this bailout, once this is fixed.
       return;
     }
   }
   // Find first invariant test that doesn't exit the loop
-  IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop);
-  assert(unswitch_iff != NULL, "should be at least one");
+  Node_List flattened_checks;
+  IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop, flattened_checks);
+  assert(unswitch_iff != NULL || flattened_checks.size() > 0, "should be at least one");
+  if (unswitch_iff == NULL) {
+    unswitch_iff = flattened_checks.at(0)->as_If();
+  }
 
 #ifndef PRODUCT
   if (TraceLoopOpts) {
     tty->print("Unswitch   %d ", head->unswitch_count()+1);
     loop->dump_head();
@@ -180,53 +212,123 @@
   // Increment unswitch count
   LoopNode* head_clone = old_new[head->_idx]->as_Loop();
   int nct = head->unswitch_count() + 1;
   head->set_unswitch_count(nct);
   head_clone->set_unswitch_count(nct);
+  if (flattened_checks.size() > 0) {
+    head->mark_flattened_arrays();
+  }
 
   // Add test to new "if" outside of loop
   IfNode* invar_iff   = proj_true->in(0)->as_If();
   Node* invar_iff_c   = invar_iff->in(0);
-  BoolNode* bol       = unswitch_iff->in(1)->as_Bool();
-  invar_iff->set_req(1, bol);
+  invar_iff->_prob    = unswitch_iff->_prob;
+  if (flattened_checks.size() > 0) {
+    // Flattened array checks are used in
+    // Parse::array_store()/Parse::array_load() to switch between a
+    // legacy object array access and a flattened value array
+    // access. We want the performance impact on legacy accesses to be
+    // as small as possible so we make 2 copies of the loops: a fast
+    // one where all accesses are known to be legacy, a slow one where
+    // some accesses are to flattened arrays. Flattened array checks
+    // can be removed from the first one but not from the second one
+    // as it can have a mix of flattened/legacy accesses.
+    BoolNode* bol       = unswitch_iff->in(1)->clone()->as_Bool();
+    register_new_node(bol, invar_iff->in(0));
+    Node* cmp = bol->in(1)->clone();
+    register_new_node(cmp, invar_iff->in(0));
+    bol->set_req(1, cmp);
+    Node* in1 = NULL;
+    for (uint i = 0; i < flattened_checks.size(); i++) {
+      Node* v = flattened_checks.at(i)->in(1)->in(1)->in(1);
+      if (in1 == NULL) {
+        in1 = v;
+      } else {
+        if (cmp->Opcode() == Op_CmpL) {
+          in1 = new OrLNode(in1, v);
+        } else {
+          in1 = new OrINode(in1, v);
+        }
+        register_new_node(in1, invar_iff->in(0));
+      }
+    }
+    cmp->set_req(1, in1);
+    invar_iff->set_req(1, bol);
+  } else {
+    BoolNode* bol       = unswitch_iff->in(1)->as_Bool();
+    invar_iff->set_req(1, bol);
   invar_iff->_prob    = unswitch_iff->_prob;
 
   ProjNode* proj_false = invar_iff->proj_out(0)->as_Proj();
 
   // Hoist invariant casts out of each loop to the appropriate
   // control projection.
 
   Node_List worklist;
 
-  for (DUIterator_Fast imax, i = unswitch_iff->fast_outs(imax); i < imax; i++) {
-    ProjNode* proj= unswitch_iff->fast_out(i)->as_Proj();
-    // Copy to a worklist for easier manipulation
-    for (DUIterator_Fast jmax, j = proj->fast_outs(jmax); j < jmax; j++) {
-      Node* use = proj->fast_out(j);
-      if (use->Opcode() == Op_CheckCastPP && loop->is_invariant(use->in(1))) {
-        worklist.push(use);
+  if (flattened_checks.size() > 0) {
+    for (uint i = 0; i < flattened_checks.size(); i++) {
+      IfNode* iff = flattened_checks.at(i)->as_If();
+      ProjNode* proj= iff->proj_out(0)->as_Proj();
+      // Copy to a worklist for easier manipulation
+      for (DUIterator_Fast jmax, j = proj->fast_outs(jmax); j < jmax; j++) {
+        Node* use = proj->fast_out(j);
+        if (use->Opcode() == Op_CheckCastPP && loop->is_invariant(use->in(1))) {
+          worklist.push(use);
+        }
+      }
+      ProjNode* invar_proj = invar_iff->proj_out(proj->_con)->as_Proj();
+      while (worklist.size() > 0) {
+        Node* use = worklist.pop();
+        Node* nuse = use->clone();
+        nuse->set_req(0, invar_proj);
+        _igvn.replace_input_of(use, 1, nuse);
+        register_new_node(nuse, invar_proj);
+        // Same for the clone
+        Node* use_clone = old_new[use->_idx];
+        _igvn.replace_input_of(use_clone, 1, nuse);
       }
     }
-    ProjNode* invar_proj = invar_iff->proj_out(proj->_con)->as_Proj();
-    while (worklist.size() > 0) {
-      Node* use = worklist.pop();
-      Node* nuse = use->clone();
-      nuse->set_req(0, invar_proj);
-      _igvn.replace_input_of(use, 1, nuse);
-      register_new_node(nuse, invar_proj);
-      // Same for the clone
-      Node* use_clone = old_new[use->_idx];
-      _igvn.replace_input_of(use_clone, 1, nuse);
+  } else {
+    for (DUIterator_Fast imax, i = unswitch_iff->fast_outs(imax); i < imax; i++) {
+      ProjNode* proj= unswitch_iff->fast_out(i)->as_Proj();
+      // Copy to a worklist for easier manipulation
+      for (DUIterator_Fast jmax, j = proj->fast_outs(jmax); j < jmax; j++) {
+        Node* use = proj->fast_out(j);
+        if (use->Opcode() == Op_CheckCastPP && loop->is_invariant(use->in(1))) {
+          worklist.push(use);
+        }
+      }
+      ProjNode* invar_proj = invar_iff->proj_out(proj->_con)->as_Proj();
+      while (worklist.size() > 0) {
+        Node* use = worklist.pop();
+        Node* nuse = use->clone();
+        nuse->set_req(0, invar_proj);
+        _igvn.replace_input_of(use, 1, nuse);
+        register_new_node(nuse, invar_proj);
+        // Same for the clone
+        Node* use_clone = old_new[use->_idx];
+        _igvn.replace_input_of(use_clone, 1, nuse);
+      }
     }
   }
 
-  // Hardwire the control paths in the loops into if(true) and if(false)
-  _igvn.rehash_node_delayed(unswitch_iff);
-  dominated_by(proj_true, unswitch_iff, false, false);
-
-  IfNode* unswitch_iff_clone = old_new[unswitch_iff->_idx]->as_If();
-  _igvn.rehash_node_delayed(unswitch_iff_clone);
+  IfNode* unswitch_iff_clone = old_new[unswitch_iff->_idx]->as_If();
+  if (flattened_checks.size() > 0) {
+    for (uint i = 0; i < flattened_checks.size(); i++) {
+      IfNode* iff = flattened_checks.at(i)->as_If();
+      _igvn.rehash_node_delayed(iff);
+      dominated_by(proj_false, old_new[iff->_idx]->as_If(), false, false);
+    }
+  } else {
+    // Hardwire the control paths in the loops into if(true) and if(false)
+    _igvn.rehash_node_delayed(unswitch_iff);
+    dominated_by(proj_true, unswitch_iff, false, false);
+
+    IfNode* unswitch_iff_clone = old_new[unswitch_iff->_idx]->as_If();
+    _igvn.rehash_node_delayed(unswitch_iff_clone);
+    dominated_by(proj_false, unswitch_iff_clone, false, false);
   dominated_by(proj_false, unswitch_iff_clone, false, false);
 
   // Reoptimize loops
   loop->record_for_igvn();
   for(int i = loop->_body.size() - 1; i >= 0 ; i--) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/callnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c2_globals.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classes.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/callnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 40,10 ***</span>
<span class="line-new-header">--- 40,12 ---</span>
  #include &quot;opto/parse.hpp&quot;
  #include &quot;opto/regalloc.hpp&quot;
  #include &quot;opto/regmask.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
<span class="line-added">+ #include &quot;opto/valuetypenode.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  #include &quot;utilities/powerOfTwo.hpp&quot;
  
  // Portions of code courtesy of Clifford Click
  
  // Optimization - Graph Style
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,11 ***</span>
    return RegMask::Empty;
  }
  
  //------------------------------match------------------------------------------
  // Construct projections for incoming parameters, and their RegMask info
<span class="line-modified">! Node *StartNode::match( const ProjNode *proj, const Matcher *match ) {</span>
    switch (proj-&gt;_con) {
    case TypeFunc::Control:
    case TypeFunc::I_O:
    case TypeFunc::Memory:
      return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
<span class="line-new-header">--- 76,11 ---</span>
    return RegMask::Empty;
  }
  
  //------------------------------match------------------------------------------
  // Construct projections for incoming parameters, and their RegMask info
<span class="line-modified">! Node *StartNode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {</span>
    switch (proj-&gt;_con) {
    case TypeFunc::Control:
    case TypeFunc::I_O:
    case TypeFunc::Memory:
      return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,21 ***</span>
      }
    }
    return NULL;
  }
  
<span class="line-removed">- //------------------------------StartOSRNode----------------------------------</span>
<span class="line-removed">- // The method start node for an on stack replacement adapter</span>
<span class="line-removed">- </span>
<span class="line-removed">- //------------------------------osr_domain-----------------------------</span>
<span class="line-removed">- const TypeTuple *StartOSRNode::osr_domain() {</span>
<span class="line-removed">-   const Type **fields = TypeTuple::fields(2);</span>
<span class="line-removed">-   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return TypeTuple::make(TypeFunc::Parms+1, fields);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //=============================================================================
  const char * const ParmNode::names[TypeFunc::Parms+1] = {
    &quot;Control&quot;, &quot;I_O&quot;, &quot;Memory&quot;, &quot;FramePtr&quot;, &quot;ReturnAdr&quot;, &quot;Parms&quot;
  };
  
<span class="line-new-header">--- 100,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 478,10 ***</span>
<span class="line-new-header">--- 469,18 ---</span>
          st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
          int ndim = cik-&gt;as_array_klass()-&gt;dimension() - 1;
          while (ndim-- &gt; 0) {
            st-&gt;print(&quot;[]&quot;);
          }
<span class="line-added">+       } else if (cik-&gt;is_value_array_klass()) {</span>
<span class="line-added">+         ciKlass* cie = cik-&gt;as_value_array_klass()-&gt;base_element_klass();</span>
<span class="line-added">+         cie-&gt;print_name_on(st);</span>
<span class="line-added">+         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());</span>
<span class="line-added">+         int ndim = cik-&gt;as_array_klass()-&gt;dimension() - 1;</span>
<span class="line-added">+         while (ndim-- &gt; 0) {</span>
<span class="line-added">+           st-&gt;print(&quot;[]&quot;);</span>
<span class="line-added">+         }</span>
        }
        st-&gt;print(&quot;={&quot;);
        uint nf = spobj-&gt;n_fields();
        if (nf &gt; 0) {
          uint first_ind = spobj-&gt;first_index(mcall-&gt;jvms());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,49 ***</span>
    if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
    if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
  }
  #endif
  
<span class="line-modified">! const Type *CallNode::bottom_type() const { return tf()-&gt;range(); }</span>
  const Type* CallNode::Value(PhaseGVN* phase) const {
<span class="line-modified">!   if (phase-&gt;type(in(0)) == Type::TOP)  return Type::TOP;</span>
<span class="line-modified">!   return tf()-&gt;range();</span>
  }
  
  //------------------------------calling_convention-----------------------------
<span class="line-modified">! void CallNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {</span>
    // Use the standard compiler calling convention
    Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );
  }
  
  
  //------------------------------match------------------------------------------
  // Construct projections for control, I/O, memory-fields, ..., and
  // return result(s) along with their RegMask info
<span class="line-modified">! Node *CallNode::match( const ProjNode *proj, const Matcher *match ) {</span>
<span class="line-modified">!   switch (proj-&gt;_con) {</span>
    case TypeFunc::Control:
    case TypeFunc::I_O:
    case TypeFunc::Memory:
      return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
  
<span class="line-removed">-   case TypeFunc::Parms+1:       // For LONG &amp; DOUBLE returns</span>
<span class="line-removed">-     assert(tf()-&gt;range()-&gt;field_at(TypeFunc::Parms+1) == Type::HALF, &quot;&quot;);</span>
<span class="line-removed">-     // 2nd half of doubles and longs</span>
<span class="line-removed">-     return new MachProjNode(this,proj-&gt;_con, RegMask::Empty, (uint)OptoReg::Bad);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   case TypeFunc::Parms: {       // Normal returns</span>
<span class="line-removed">-     uint ideal_reg = tf()-&gt;range()-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();</span>
<span class="line-removed">-     OptoRegPair regs = is_CallRuntime()</span>
<span class="line-removed">-       ? match-&gt;c_return_value(ideal_reg,true)  // Calls into C runtime</span>
<span class="line-removed">-       : match-&gt;  return_value(ideal_reg,true); // Calls into compiled Java code</span>
<span class="line-removed">-     RegMask rm = RegMask(regs.first());</span>
<span class="line-removed">-     if( OptoReg::is_valid(regs.second()) )</span>
<span class="line-removed">-       rm.Insert( regs.second() );</span>
<span class="line-removed">-     return new MachProjNode(this,proj-&gt;_con,rm,ideal_reg);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    case TypeFunc::ReturnAdr:
    case TypeFunc::FramePtr:
    default:
      ShouldNotReachHere();
    }
<span class="line-new-header">--- 686,68 ---</span>
    if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
    if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
  }
  #endif
  
<span class="line-modified">! const Type *CallNode::bottom_type() const { return tf()-&gt;range_cc(); }</span>
  const Type* CallNode::Value(PhaseGVN* phase) const {
<span class="line-modified">!   if (!in(0) || phase-&gt;type(in(0)) == Type::TOP) {</span>
<span class="line-modified">!     return Type::TOP;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return tf()-&gt;range_cc();</span>
  }
  
  //------------------------------calling_convention-----------------------------
<span class="line-modified">! void CallNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {</span>
<span class="line-added">+   if (_entry_point == StubRoutines::store_value_type_fields_to_buf()) {</span>
<span class="line-added">+     // The call to that stub is a special case: its inputs are</span>
<span class="line-added">+     // multiple values returned from a call and so it should follow</span>
<span class="line-added">+     // the return convention.</span>
<span class="line-added">+     SharedRuntime::java_return_convention(sig_bt, parm_regs, argcnt);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
    // Use the standard compiler calling convention
    Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );
  }
  
  
  //------------------------------match------------------------------------------
  // Construct projections for control, I/O, memory-fields, ..., and
  // return result(s) along with their RegMask info
<span class="line-modified">! Node *CallNode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {</span>
<span class="line-modified">!   uint con = proj-&gt;_con;</span>
<span class="line-added">+   const TypeTuple *range_cc = tf()-&gt;range_cc();</span>
<span class="line-added">+   if (con &gt;= TypeFunc::Parms) {</span>
<span class="line-added">+     if (is_CallRuntime()) {</span>
<span class="line-added">+       if (con == TypeFunc::Parms) {</span>
<span class="line-added">+         uint ideal_reg = range_cc-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();</span>
<span class="line-added">+         OptoRegPair regs = match-&gt;c_return_value(ideal_reg,true);</span>
<span class="line-added">+         RegMask rm = RegMask(regs.first());</span>
<span class="line-added">+         if (OptoReg::is_valid(regs.second())) {</span>
<span class="line-added">+           rm.Insert(regs.second());</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return new MachProjNode(this,con,rm,ideal_reg);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         assert(con == TypeFunc::Parms+1, &quot;only one return value&quot;);</span>
<span class="line-added">+         assert(range_cc-&gt;field_at(TypeFunc::Parms+1) == Type::HALF, &quot;&quot;);</span>
<span class="line-added">+         return new MachProjNode(this,con, RegMask::Empty, (uint)OptoReg::Bad);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // The Call may return multiple values (value type fields): we</span>
<span class="line-added">+       // create one projection per returned values.</span>
<span class="line-added">+       assert(con &lt;= TypeFunc::Parms+1 || ValueTypeReturnedAsFields, &quot;only for multi value return&quot;);</span>
<span class="line-added">+       uint ideal_reg = range_cc-&gt;field_at(con)-&gt;ideal_reg();</span>
<span class="line-added">+       return new MachProjNode(this, con, mask[con-TypeFunc::Parms], ideal_reg);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   switch (con) {</span>
    case TypeFunc::Control:
    case TypeFunc::I_O:
    case TypeFunc::Memory:
      return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
  
    case TypeFunc::ReturnAdr:
    case TypeFunc::FramePtr:
    default:
      ShouldNotReachHere();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,11 ***</span>
  // instance at the specified offset.
  //
  bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
    assert((t_oop != NULL), &quot;sanity&quot;);
    if (is_call_to_arraycopystub() &amp;&amp; strcmp(_name, &quot;unsafe_arraycopy&quot;) != 0) {
<span class="line-modified">!     const TypeTuple* args = _tf-&gt;domain();</span>
      Node* dest = NULL;
      // Stubs that can be called once an ArrayCopyNode is expanded have
      // different signatures. Look for the second pointer argument,
      // that is the destination of the copy.
      for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
<span class="line-new-header">--- 764,11 ---</span>
  // instance at the specified offset.
  //
  bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
    assert((t_oop != NULL), &quot;sanity&quot;);
    if (is_call_to_arraycopystub() &amp;&amp; strcmp(_name, &quot;unsafe_arraycopy&quot;) != 0) {
<span class="line-modified">!     const TypeTuple* args = _tf-&gt;domain_sig();</span>
      Node* dest = NULL;
      // Stubs that can be called once an ArrayCopyNode is expanded have
      // different signatures. Look for the second pointer argument,
      // that is the destination of the copy.
      for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 795,11 ***</span>
          if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
                                   (inst_t-&gt;klass() == boxing_klass))) {
            return true;
          }
        }
<span class="line-modified">!       const TypeTuple* d = tf()-&gt;domain();</span>
        for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
          const TypeInstPtr* inst_t = d-&gt;field_at(i)-&gt;isa_instptr();
          if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
                                   (inst_t-&gt;klass() == boxing_klass))) {
            return true;
<span class="line-new-header">--- 813,11 ---</span>
          if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
                                   (inst_t-&gt;klass() == boxing_klass))) {
            return true;
          }
        }
<span class="line-modified">!       const TypeTuple* d = tf()-&gt;domain_cc();</span>
        for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
          const TypeInstPtr* inst_t = d-&gt;field_at(i)-&gt;isa_instptr();
          if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
                                   (inst_t-&gt;klass() == boxing_klass))) {
            return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 811,20 ***</span>
    return true;
  }
  
  // Does this call have a direct reference to n other than debug information?
  bool CallNode::has_non_debug_use(Node *n) {
<span class="line-modified">!   const TypeTuple * d = tf()-&gt;domain();</span>
    for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
      Node *arg = in(i);
      if (arg == n) {
        return true;
      }
    }
    return false;
  }
  
  // Returns the unique CheckCastPP of a call
  // or &#39;this&#39; if there are several CheckCastPP or unexpected uses
  // or returns NULL if there is no one.
  Node *CallNode::result_cast() {
    Node *cast = NULL;
<span class="line-new-header">--- 829,31 ---</span>
    return true;
  }
  
  // Does this call have a direct reference to n other than debug information?
  bool CallNode::has_non_debug_use(Node *n) {
<span class="line-modified">!   const TypeTuple * d = tf()-&gt;domain_cc();</span>
    for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
      Node *arg = in(i);
      if (arg == n) {
        return true;
      }
    }
    return false;
  }
  
<span class="line-added">+ bool CallNode::has_debug_use(Node *n) {</span>
<span class="line-added">+   assert(jvms() != NULL, &quot;jvms should not be null&quot;);</span>
<span class="line-added">+   for (uint i = jvms()-&gt;debug_start(); i &lt; jvms()-&gt;debug_end(); i++) {</span>
<span class="line-added">+     Node *arg = in(i);</span>
<span class="line-added">+     if (arg == n) {</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Returns the unique CheckCastPP of a call
  // or &#39;this&#39; if there are several CheckCastPP or unexpected uses
  // or returns NULL if there is no one.
  Node *CallNode::result_cast() {
    Node *cast = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 852,20 ***</span>
    }
    return cast;
  }
  
  
<span class="line-modified">! void CallNode::extract_projections(CallProjections* projs, bool separate_io_proj, bool do_asserts) {</span>
<span class="line-modified">!   projs-&gt;fallthrough_proj      = NULL;</span>
<span class="line-modified">!   projs-&gt;fallthrough_catchproj = NULL;</span>
<span class="line-modified">!   projs-&gt;fallthrough_ioproj    = NULL;</span>
<span class="line-modified">!   projs-&gt;catchall_ioproj       = NULL;</span>
<span class="line-modified">!   projs-&gt;catchall_catchproj    = NULL;</span>
<span class="line-modified">!   projs-&gt;fallthrough_memproj   = NULL;</span>
<span class="line-modified">!   projs-&gt;catchall_memproj      = NULL;</span>
<span class="line-modified">!   projs-&gt;resproj               = NULL;</span>
<span class="line-modified">!   projs-&gt;exobj                 = NULL;</span>
  
    for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
      ProjNode *pn = fast_out(i)-&gt;as_Proj();
      if (pn-&gt;outcnt() == 0) continue;
      switch (pn-&gt;_con) {
<span class="line-new-header">--- 881,25 ---</span>
    }
    return cast;
  }
  
  
<span class="line-modified">! CallProjections* CallNode::extract_projections(bool separate_io_proj, bool do_asserts) {</span>
<span class="line-modified">!   uint max_res = TypeFunc::Parms-1;</span>
<span class="line-modified">!   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">!     ProjNode *pn = fast_out(i)-&gt;as_Proj();</span>
<span class="line-modified">!     max_res = MAX2(max_res, pn-&gt;_con);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   assert(max_res &lt; _tf-&gt;range_cc()-&gt;cnt(), &quot;result out of bounds&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   uint projs_size = sizeof(CallProjections);</span>
<span class="line-added">+   if (max_res &gt; TypeFunc::Parms) {</span>
<span class="line-added">+     projs_size += (max_res-TypeFunc::Parms)*sizeof(Node*);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   char* projs_storage = resource_allocate_bytes(projs_size);</span>
<span class="line-added">+   CallProjections* projs = new(projs_storage)CallProjections(max_res - TypeFunc::Parms + 1);</span>
  
    for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
      ProjNode *pn = fast_out(i)-&gt;as_Proj();
      if (pn-&gt;outcnt() == 0) continue;
      switch (pn-&gt;_con) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 908,30 ***</span>
          projs-&gt;catchall_memproj = pn;
        else
          projs-&gt;fallthrough_memproj = pn;
        break;
      case TypeFunc::Parms:
<span class="line-modified">!       projs-&gt;resproj = pn;</span>
        break;
      default:
<span class="line-modified">!       assert(false, &quot;unexpected projection from allocation node.&quot;);</span>
      }
    }
  
    // The resproj may not exist because the result could be ignored
    // and the exception object may not exist if an exception handler
    // swallows the exception but all the other must exist and be found.
<span class="line-modified">!   assert(projs-&gt;fallthrough_proj      != NULL, &quot;must be found&quot;);</span>
    assert(!do_asserts || projs-&gt;fallthrough_proj      != NULL, &quot;must be found&quot;);
    assert(!do_asserts || projs-&gt;fallthrough_catchproj != NULL, &quot;must be found&quot;);
    assert(!do_asserts || projs-&gt;fallthrough_memproj   != NULL, &quot;must be found&quot;);
    assert(!do_asserts || projs-&gt;fallthrough_ioproj    != NULL, &quot;must be found&quot;);
    assert(!do_asserts || projs-&gt;catchall_catchproj    != NULL, &quot;must be found&quot;);
    if (separate_io_proj) {
      assert(!do_asserts || projs-&gt;catchall_memproj    != NULL, &quot;must be found&quot;);
      assert(!do_asserts || projs-&gt;catchall_ioproj     != NULL, &quot;must be found&quot;);
    }
  }
  
  Node *CallNode::Ideal(PhaseGVN *phase, bool can_reshape) {
    CallGenerator* cg = generator();
    if (can_reshape &amp;&amp; cg != NULL &amp;&amp; cg-&gt;is_mh_late_inline() &amp;&amp; !cg-&gt;already_attempted()) {
<span class="line-new-header">--- 942,33 ---</span>
          projs-&gt;catchall_memproj = pn;
        else
          projs-&gt;fallthrough_memproj = pn;
        break;
      case TypeFunc::Parms:
<span class="line-modified">!       projs-&gt;resproj[0] = pn;</span>
        break;
      default:
<span class="line-modified">!       assert(pn-&gt;_con &lt;= max_res, &quot;unexpected projection from allocation node.&quot;);</span>
<span class="line-added">+       projs-&gt;resproj[pn-&gt;_con-TypeFunc::Parms] = pn;</span>
<span class="line-added">+       break;</span>
      }
    }
  
    // The resproj may not exist because the result could be ignored
    // and the exception object may not exist if an exception handler
    // swallows the exception but all the other must exist and be found.
<span class="line-modified">!   do_asserts = do_asserts &amp;&amp; !Compile::current()-&gt;inlining_incrementally();</span>
    assert(!do_asserts || projs-&gt;fallthrough_proj      != NULL, &quot;must be found&quot;);
    assert(!do_asserts || projs-&gt;fallthrough_catchproj != NULL, &quot;must be found&quot;);
    assert(!do_asserts || projs-&gt;fallthrough_memproj   != NULL, &quot;must be found&quot;);
    assert(!do_asserts || projs-&gt;fallthrough_ioproj    != NULL, &quot;must be found&quot;);
    assert(!do_asserts || projs-&gt;catchall_catchproj    != NULL, &quot;must be found&quot;);
    if (separate_io_proj) {
      assert(!do_asserts || projs-&gt;catchall_memproj    != NULL, &quot;must be found&quot;);
      assert(!do_asserts || projs-&gt;catchall_ioproj     != NULL, &quot;must be found&quot;);
    }
<span class="line-added">+   return projs;</span>
  }
  
  Node *CallNode::Ideal(PhaseGVN *phase, bool can_reshape) {
    CallGenerator* cg = generator();
    if (can_reshape &amp;&amp; cg != NULL &amp;&amp; cg-&gt;is_mh_late_inline() &amp;&amp; !cg-&gt;already_attempted()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 966,15 ***</span>
<span class="line-new-header">--- 1003,59 ---</span>
  bool CallJavaNode::cmp( const Node &amp;n ) const {
    CallJavaNode &amp;call = (CallJavaNode&amp;)n;
    return CallNode::cmp(call) &amp;&amp; _method == call._method &amp;&amp;
           _override_symbolic_info == call._override_symbolic_info;
  }
<span class="line-added">+ </span>
<span class="line-added">+ void CallJavaNode::copy_call_debug_info(PhaseIterGVN* phase, CallNode *oldcall) {</span>
<span class="line-added">+   // Copy debug information and adjust JVMState information</span>
<span class="line-added">+   uint old_dbg_start = oldcall-&gt;tf()-&gt;domain_sig()-&gt;cnt();</span>
<span class="line-added">+   uint new_dbg_start = tf()-&gt;domain_sig()-&gt;cnt();</span>
<span class="line-added">+   int jvms_adj  = new_dbg_start - old_dbg_start;</span>
<span class="line-added">+   assert (new_dbg_start == req(), &quot;argument count mismatch&quot;);</span>
<span class="line-added">+   Compile* C = phase-&gt;C;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // SafePointScalarObject node could be referenced several times in debug info.</span>
<span class="line-added">+   // Use Dict to record cloned nodes.</span>
<span class="line-added">+   Dict* sosn_map = new Dict(cmpkey,hashkey);</span>
<span class="line-added">+   for (uint i = old_dbg_start; i &lt; oldcall-&gt;req(); i++) {</span>
<span class="line-added">+     Node* old_in = oldcall-&gt;in(i);</span>
<span class="line-added">+     // Clone old SafePointScalarObjectNodes, adjusting their field contents.</span>
<span class="line-added">+     if (old_in != NULL &amp;&amp; old_in-&gt;is_SafePointScalarObject()) {</span>
<span class="line-added">+       SafePointScalarObjectNode* old_sosn = old_in-&gt;as_SafePointScalarObject();</span>
<span class="line-added">+       uint old_unique = C-&gt;unique();</span>
<span class="line-added">+       Node* new_in = old_sosn-&gt;clone(sosn_map);</span>
<span class="line-added">+       if (old_unique != C-&gt;unique()) { // New node?</span>
<span class="line-added">+         new_in-&gt;set_req(0, C-&gt;root()); // reset control edge</span>
<span class="line-added">+         new_in = phase-&gt;transform(new_in); // Register new node.</span>
<span class="line-added">+       }</span>
<span class="line-added">+       old_in = new_in;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     add_req(old_in);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // JVMS may be shared so clone it before we modify it</span>
<span class="line-added">+   set_jvms(oldcall-&gt;jvms() != NULL ? oldcall-&gt;jvms()-&gt;clone_deep(C) : NULL);</span>
<span class="line-added">+   for (JVMState *jvms = this-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {</span>
<span class="line-added">+     jvms-&gt;set_map(this);</span>
<span class="line-added">+     jvms-&gt;set_locoff(jvms-&gt;locoff()+jvms_adj);</span>
<span class="line-added">+     jvms-&gt;set_stkoff(jvms-&gt;stkoff()+jvms_adj);</span>
<span class="line-added">+     jvms-&gt;set_monoff(jvms-&gt;monoff()+jvms_adj);</span>
<span class="line-added">+     jvms-&gt;set_scloff(jvms-&gt;scloff()+jvms_adj);</span>
<span class="line-added">+     jvms-&gt;set_endoff(jvms-&gt;endoff()+jvms_adj);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #ifdef ASSERT
  bool CallJavaNode::validate_symbolic_info() const {
    if (method() == NULL) {
      return true; // call into runtime or uncommon trap
    }
<span class="line-added">+   Bytecodes::Code bc = jvms()-&gt;method()-&gt;java_code_at_bci(_bci);</span>
<span class="line-added">+   if (EnableValhalla &amp;&amp; (bc == Bytecodes::_if_acmpeq || bc == Bytecodes::_if_acmpne)) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
    ciMethod* symbolic_info = jvms()-&gt;method()-&gt;get_method_at_bci(_bci);
    ciMethod* callee = method();
    if (symbolic_info-&gt;is_method_handle_intrinsic() &amp;&amp; !callee-&gt;is_method_handle_intrinsic()) {
      assert(override_symbolic_info(), &quot;should be set&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1025,10 ***</span>
<span class="line-new-header">--- 1106,161 ---</span>
    }
  #endif
    return call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
  }
  
<span class="line-added">+ bool CallStaticJavaNode::remove_useless_allocation(PhaseGVN *phase, Node* ctl, Node* mem, Node* unc_arg) {</span>
<span class="line-added">+   // Split if can cause the flattened array branch of an array load to</span>
<span class="line-added">+   // end in an uncommon trap. In that case, the allocation of the</span>
<span class="line-added">+   // loaded value and its initialization is useless. Eliminate it. use</span>
<span class="line-added">+   // the jvm state of the allocation to create a new uncommon trap</span>
<span class="line-added">+   // call at the load.</span>
<span class="line-added">+   if (ctl == NULL || ctl-&gt;is_top() || mem == NULL || mem-&gt;is_top() || !mem-&gt;is_MergeMem()) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-added">+   if (ctl-&gt;is_Region()) {</span>
<span class="line-added">+     bool res = false;</span>
<span class="line-added">+     for (uint i = 1; i &lt; ctl-&gt;req(); i++) {</span>
<span class="line-added">+       MergeMemNode* mm = mem-&gt;clone()-&gt;as_MergeMem();</span>
<span class="line-added">+       for (MergeMemStream mms(mm); mms.next_non_empty(); ) {</span>
<span class="line-added">+         Node* m = mms.memory();</span>
<span class="line-added">+         if (m-&gt;is_Phi() &amp;&amp; m-&gt;in(0) == ctl) {</span>
<span class="line-added">+           mms.set_memory(m-&gt;in(i));</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (remove_useless_allocation(phase, ctl-&gt;in(i), mm, unc_arg)) {</span>
<span class="line-added">+         res = true;</span>
<span class="line-added">+         if (!ctl-&gt;in(i)-&gt;is_Region()) {</span>
<span class="line-added">+           igvn-&gt;replace_input_of(ctl, i, phase-&gt;C-&gt;top());</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       igvn-&gt;remove_dead_node(mm);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return res;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   // verify the control flow is ok</span>
<span class="line-added">+   Node* c = ctl;</span>
<span class="line-added">+   Node* copy = NULL;</span>
<span class="line-added">+   Node* alloc = NULL;</span>
<span class="line-added">+   for (;;) {</span>
<span class="line-added">+     if (c == NULL || c-&gt;is_top()) {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (c-&gt;is_Proj() || c-&gt;is_Catch() || c-&gt;is_MemBar()) {</span>
<span class="line-added">+       c = c-&gt;in(0);</span>
<span class="line-added">+     } else if (c-&gt;Opcode() == Op_CallLeaf &amp;&amp;</span>
<span class="line-added">+                c-&gt;as_Call()-&gt;entry_point() == CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_value)) {</span>
<span class="line-added">+       copy = c;</span>
<span class="line-added">+       c = c-&gt;in(0);</span>
<span class="line-added">+     } else if (c-&gt;is_Allocate()) {</span>
<span class="line-added">+       Node* new_obj = c-&gt;as_Allocate()-&gt;result_cast();</span>
<span class="line-added">+       if (copy == NULL || new_obj == NULL) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       Node* copy_dest = copy-&gt;in(TypeFunc::Parms + 2);</span>
<span class="line-added">+       if (copy_dest != new_obj) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       alloc = c;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMState* jvms = alloc-&gt;jvms();</span>
<span class="line-added">+   if (phase-&gt;C-&gt;too_many_traps(jvms-&gt;method(), jvms-&gt;bci(), Deoptimization::trap_request_reason(uncommon_trap_request()))) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Node* alloc_mem = alloc-&gt;in(TypeFunc::Memory);</span>
<span class="line-added">+   if (alloc_mem == NULL || alloc_mem-&gt;is_top()) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!alloc_mem-&gt;is_MergeMem()) {</span>
<span class="line-added">+     alloc_mem = MergeMemNode::make(alloc_mem);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // and that there&#39;s no unexpected side effect</span>
<span class="line-added">+   for (MergeMemStream mms2(mem-&gt;as_MergeMem(), alloc_mem-&gt;as_MergeMem()); mms2.next_non_empty2(); ) {</span>
<span class="line-added">+     Node* m1 = mms2.is_empty() ? mms2.base_memory() : mms2.memory();</span>
<span class="line-added">+     Node* m2 = mms2.memory2();</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (uint i = 0; i &lt; 100; i++) {</span>
<span class="line-added">+       if (m1 == m2) {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       } else if (m1-&gt;is_Proj()) {</span>
<span class="line-added">+         m1 = m1-&gt;in(0);</span>
<span class="line-added">+       } else if (m1-&gt;is_MemBar()) {</span>
<span class="line-added">+         m1 = m1-&gt;in(TypeFunc::Memory);</span>
<span class="line-added">+       } else if (m1-&gt;Opcode() == Op_CallLeaf &amp;&amp;</span>
<span class="line-added">+                  m1-&gt;as_Call()-&gt;entry_point() == CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_value)) {</span>
<span class="line-added">+         if (m1 != copy) {</span>
<span class="line-added">+           return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         m1 = m1-&gt;in(TypeFunc::Memory);</span>
<span class="line-added">+       } else if (m1-&gt;is_Allocate()) {</span>
<span class="line-added">+         if (m1 != alloc) {</span>
<span class="line-added">+           return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       } else if (m1-&gt;is_MergeMem()) {</span>
<span class="line-added">+         MergeMemNode* mm = m1-&gt;as_MergeMem();</span>
<span class="line-added">+         int idx = mms2.alias_idx();</span>
<span class="line-added">+         if (idx == Compile::AliasIdxBot) {</span>
<span class="line-added">+           m1 = mm-&gt;base_memory();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           m1 = mm-&gt;memory_at(idx);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (alloc_mem-&gt;outcnt() == 0) {</span>
<span class="line-added">+     igvn-&gt;remove_dead_node(alloc_mem);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   address call_addr = SharedRuntime::uncommon_trap_blob()-&gt;entry_point();</span>
<span class="line-added">+   CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, &quot;uncommon_trap&quot;,</span>
<span class="line-added">+                                          jvms-&gt;bci(), NULL);</span>
<span class="line-added">+   unc-&gt;init_req(TypeFunc::Control, alloc-&gt;in(0));</span>
<span class="line-added">+   unc-&gt;init_req(TypeFunc::I_O, alloc-&gt;in(TypeFunc::I_O));</span>
<span class="line-added">+   unc-&gt;init_req(TypeFunc::Memory, alloc-&gt;in(TypeFunc::Memory));</span>
<span class="line-added">+   unc-&gt;init_req(TypeFunc::FramePtr,  alloc-&gt;in(TypeFunc::FramePtr));</span>
<span class="line-added">+   unc-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));</span>
<span class="line-added">+   unc-&gt;init_req(TypeFunc::Parms+0, unc_arg);</span>
<span class="line-added">+   unc-&gt;set_cnt(PROB_UNLIKELY_MAG(4));</span>
<span class="line-added">+   unc-&gt;copy_call_debug_info(igvn, alloc-&gt;as_Allocate());</span>
<span class="line-added">+ </span>
<span class="line-added">+   igvn-&gt;replace_input_of(alloc, 0, phase-&gt;C-&gt;top());</span>
<span class="line-added">+ </span>
<span class="line-added">+   igvn-&gt;register_new_node_with_optimizer(unc);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Node* ctrl = phase-&gt;transform(new ProjNode(unc, TypeFunc::Control));</span>
<span class="line-added">+   Node* halt = phase-&gt;transform(new HaltNode(ctrl, alloc-&gt;in(TypeFunc::FramePtr), &quot;uncommon trap returned which should never happen&quot;));</span>
<span class="line-added">+   phase-&gt;C-&gt;root()-&gt;add_req(halt);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ Node* CallStaticJavaNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-added">+   if (can_reshape &amp;&amp; uncommon_trap_request() != 0) {</span>
<span class="line-added">+     if (remove_useless_allocation(phase, in(0), in(TypeFunc::Memory), in(TypeFunc::Parms))) {</span>
<span class="line-added">+       if (!in(0)-&gt;is_Region()) {</span>
<span class="line-added">+         PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-added">+         igvn-&gt;replace_input_of(this, 0, phase-&gt;C-&gt;top());</span>
<span class="line-added">+       }</span>
<span class="line-added">+       return this;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return CallNode::Ideal(phase, can_reshape);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  #ifndef PRODUCT
  void CallStaticJavaNode::dump_spec(outputStream *st) const {
    st-&gt;print(&quot;# Static &quot;);
    if (_name != NULL) {
      st-&gt;print(&quot;%s&quot;, _name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1082,10 ***</span>
<span class="line-new-header">--- 1314,17 ---</span>
  }
  #endif
  
  //------------------------------calling_convention-----------------------------
  void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
<span class="line-added">+   if (_entry_point == NULL) {</span>
<span class="line-added">+     // The call to that stub is a special case: its inputs are</span>
<span class="line-added">+     // multiple values returned from a call and so it should follow</span>
<span class="line-added">+     // the return convention.</span>
<span class="line-added">+     SharedRuntime::java_return_convention(sig_bt, parm_regs, argcnt);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
    Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );
  }
  
  //=============================================================================
  //------------------------------calling_convention-----------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1098,10 ***</span>
<span class="line-new-header">--- 1337,16 ---</span>
    st-&gt;print(&quot;%s&quot;, _name);
    CallNode::dump_spec(st);
  }
  #endif
  
<span class="line-added">+ uint CallLeafNoFPNode::match_edge(uint idx) const {</span>
<span class="line-added">+   // Null entry point is a special case for which the target is in a</span>
<span class="line-added">+   // register. Need to match that edge.</span>
<span class="line-added">+   return entry_point() == NULL &amp;&amp; idx == TypeFunc::Parms;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  //=============================================================================
  
  void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {
    assert(verify_jvms(jvms), &quot;jvms must match&quot;);
    int loc = jvms-&gt;locoff() + idx;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1355,18 ***</span>
  //=============================================================================
  uint AllocateNode::size_of() const { return sizeof(*this); }
  
  AllocateNode::AllocateNode(Compile* C, const TypeFunc *atype,
                             Node *ctrl, Node *mem, Node *abio,
<span class="line-modified">!                            Node *size, Node *klass_node, Node *initial_test)</span>
    : CallNode(atype, NULL, TypeRawPtr::BOTTOM)
  {
    init_class_id(Class_Allocate);
    init_flags(Flag_is_macro);
    _is_scalar_replaceable = false;
    _is_non_escaping = false;
    _is_allocation_MemBar_redundant = false;
    Node *topnode = C-&gt;top();
  
    init_req( TypeFunc::Control  , ctrl );
    init_req( TypeFunc::I_O      , abio );
    init_req( TypeFunc::Memory   , mem );
<span class="line-new-header">--- 1600,21 ---</span>
  //=============================================================================
  uint AllocateNode::size_of() const { return sizeof(*this); }
  
  AllocateNode::AllocateNode(Compile* C, const TypeFunc *atype,
                             Node *ctrl, Node *mem, Node *abio,
<span class="line-modified">!                            Node *size, Node *klass_node,</span>
<span class="line-added">+                            Node* initial_test,</span>
<span class="line-added">+                            ValueTypeBaseNode* value_node)</span>
    : CallNode(atype, NULL, TypeRawPtr::BOTTOM)
  {
    init_class_id(Class_Allocate);
    init_flags(Flag_is_macro);
    _is_scalar_replaceable = false;
    _is_non_escaping = false;
    _is_allocation_MemBar_redundant = false;
<span class="line-added">+   _larval = false;</span>
    Node *topnode = C-&gt;top();
  
    init_req( TypeFunc::Control  , ctrl );
    init_req( TypeFunc::I_O      , abio );
    init_req( TypeFunc::Memory   , mem );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1374,45 ***</span>
    init_req( TypeFunc::FramePtr , topnode );
    init_req( AllocSize          , size);
    init_req( KlassNode          , klass_node);
    init_req( InitialTest        , initial_test);
    init_req( ALength            , topnode);
    C-&gt;add_macro_node(this);
  }
  
  void AllocateNode::compute_MemBar_redundancy(ciMethod* initializer)
  {
    assert(initializer != NULL &amp;&amp;
<span class="line-modified">!          initializer-&gt;is_initializer() &amp;&amp;</span>
<span class="line-modified">!          !initializer-&gt;is_static(),</span>
<span class="line-removed">-              &quot;unexpected initializer method&quot;);</span>
    BCEscapeAnalyzer* analyzer = initializer-&gt;get_bcea();
    if (analyzer == NULL) {
      return;
    }
  
    // Allocation node is first parameter in its initializer
    if (analyzer-&gt;is_arg_stack(0) || analyzer-&gt;is_arg_local(0)) {
      _is_allocation_MemBar_redundant = true;
    }
  }
<span class="line-modified">! Node *AllocateNode::make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem) {</span>
    Node* mark_node = NULL;
    // For now only enable fast locking for non-array types
<span class="line-modified">!   if (UseBiasedLocking &amp;&amp; Opcode() == Op_Allocate) {</span>
      Node* klass_node = in(AllocateNode::KlassNode);
      Node* proto_adr = phase-&gt;transform(new AddPNode(klass_node, klass_node, phase-&gt;MakeConX(in_bytes(Klass::prototype_header_offset()))));
      mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
    } else {
      mark_node = phase-&gt;MakeConX(markWord::prototype().value());
    }
<span class="line-modified">!   return mark_node;</span>
  }
  
  //=============================================================================
  Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
<span class="line-modified">!   if (remove_dead_region(phase, can_reshape))  return this;</span>
    // Don&#39;t bother trying to transform a dead node
    if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
  
    const Type* type = phase-&gt;type(Ideal_length());
    if (type-&gt;isa_int() &amp;&amp; type-&gt;is_int()-&gt;_hi &lt; 0) {
<span class="line-new-header">--- 1622,110 ---</span>
    init_req( TypeFunc::FramePtr , topnode );
    init_req( AllocSize          , size);
    init_req( KlassNode          , klass_node);
    init_req( InitialTest        , initial_test);
    init_req( ALength            , topnode);
<span class="line-added">+   init_req( ValueNode          , value_node);</span>
<span class="line-added">+   // DefaultValue defaults to NULL</span>
<span class="line-added">+   // RawDefaultValue defaults to NULL</span>
<span class="line-added">+   // StorageProperties defaults to NULL</span>
    C-&gt;add_macro_node(this);
  }
  
  void AllocateNode::compute_MemBar_redundancy(ciMethod* initializer)
  {
    assert(initializer != NULL &amp;&amp;
<span class="line-modified">!          initializer-&gt;is_object_constructor_or_class_initializer(),</span>
<span class="line-modified">!          &quot;unexpected initializer method&quot;);</span>
    BCEscapeAnalyzer* analyzer = initializer-&gt;get_bcea();
    if (analyzer == NULL) {
      return;
    }
  
    // Allocation node is first parameter in its initializer
    if (analyzer-&gt;is_arg_stack(0) || analyzer-&gt;is_arg_local(0)) {
      _is_allocation_MemBar_redundant = true;
    }
  }
<span class="line-modified">! </span>
<span class="line-added">+ Node* AllocateNode::Ideal(PhaseGVN* phase, bool can_reshape) {</span>
<span class="line-added">+   // Check for unused value type allocation</span>
<span class="line-added">+   if (can_reshape &amp;&amp; in(AllocateNode::ValueNode) != NULL &amp;&amp;</span>
<span class="line-added">+       outcnt() != 0 &amp;&amp; result_cast() == NULL) {</span>
<span class="line-added">+     // Remove allocation by replacing the projection nodes with its inputs</span>
<span class="line-added">+     InitializeNode* init = initialization();</span>
<span class="line-added">+     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-added">+     CallProjections* projs = extract_projections(true, false);</span>
<span class="line-added">+     assert(projs-&gt;nb_resproj &lt;= 1, &quot;unexpected number of results&quot;);</span>
<span class="line-added">+     if (projs-&gt;fallthrough_catchproj != NULL) {</span>
<span class="line-added">+       igvn-&gt;replace_node(projs-&gt;fallthrough_catchproj, in(TypeFunc::Control));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (projs-&gt;fallthrough_memproj != NULL) {</span>
<span class="line-added">+       igvn-&gt;replace_node(projs-&gt;fallthrough_memproj, in(TypeFunc::Memory));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (projs-&gt;catchall_memproj != NULL) {</span>
<span class="line-added">+       igvn-&gt;replace_node(projs-&gt;catchall_memproj, phase-&gt;C-&gt;top());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (projs-&gt;fallthrough_ioproj != NULL) {</span>
<span class="line-added">+       igvn-&gt;replace_node(projs-&gt;fallthrough_ioproj, in(TypeFunc::I_O));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (projs-&gt;catchall_ioproj != NULL) {</span>
<span class="line-added">+       igvn-&gt;replace_node(projs-&gt;catchall_ioproj, phase-&gt;C-&gt;top());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (projs-&gt;catchall_catchproj != NULL) {</span>
<span class="line-added">+       igvn-&gt;replace_node(projs-&gt;catchall_catchproj, phase-&gt;C-&gt;top());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (projs-&gt;resproj[0] != NULL) {</span>
<span class="line-added">+       // Remove MemBarStoreStore user as well</span>
<span class="line-added">+       for (DUIterator_Fast imax, i = projs-&gt;resproj[0]-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">+         MemBarStoreStoreNode* mb = projs-&gt;resproj[0]-&gt;fast_out(i)-&gt;isa_MemBarStoreStore();</span>
<span class="line-added">+         if (mb != NULL &amp;&amp; mb-&gt;outcnt() == 2) {</span>
<span class="line-added">+           mb-&gt;remove(igvn);</span>
<span class="line-added">+           --i; --imax;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       igvn-&gt;replace_node(projs-&gt;resproj[0], phase-&gt;C-&gt;top());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     igvn-&gt;replace_node(this, phase-&gt;C-&gt;top());</span>
<span class="line-added">+     if (init != NULL) {</span>
<span class="line-added">+       Node* ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);</span>
<span class="line-added">+       Node* mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);</span>
<span class="line-added">+       if (ctrl_proj != NULL) {</span>
<span class="line-added">+         igvn-&gt;replace_node(ctrl_proj, init-&gt;in(TypeFunc::Control));</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (mem_proj != NULL) {</span>
<span class="line-added">+         igvn-&gt;replace_node(mem_proj, init-&gt;in(TypeFunc::Memory));</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return CallNode::Ideal(phase, can_reshape);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Node* AllocateNode::make_ideal_mark(PhaseGVN* phase, Node* control, Node* mem) {</span>
    Node* mark_node = NULL;
    // For now only enable fast locking for non-array types
<span class="line-modified">!   if ((EnableValhalla || UseBiasedLocking) &amp;&amp; Opcode() == Op_Allocate) {</span>
      Node* klass_node = in(AllocateNode::KlassNode);
      Node* proto_adr = phase-&gt;transform(new AddPNode(klass_node, klass_node, phase-&gt;MakeConX(in_bytes(Klass::prototype_header_offset()))));
      mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
    } else {
      mark_node = phase-&gt;MakeConX(markWord::prototype().value());
    }
<span class="line-modified">!   mark_node = phase-&gt;transform(mark_node);</span>
<span class="line-added">+   // Avoid returning a constant (old node) here because this method is used by LoadNode::Ideal</span>
<span class="line-added">+   return new OrXNode(mark_node, phase-&gt;MakeConX(_larval ? markWord::larval_state_pattern : 0));</span>
  }
  
<span class="line-added">+ </span>
  //=============================================================================
  Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
<span class="line-modified">!   Node* res = SafePointNode::Ideal(phase, can_reshape);</span>
<span class="line-added">+   if (res != NULL) {</span>
<span class="line-added">+     return res;</span>
<span class="line-added">+   }</span>
    // Don&#39;t bother trying to transform a dead node
    if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
  
    const Type* type = phase-&gt;type(Ideal_length());
    if (type-&gt;isa_int() &amp;&amp; type-&gt;is_int()-&gt;_hi &lt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1833,11 ***</span>
    // Now see if we can optimize away this lock.  We don&#39;t actually
    // remove the locking here, we simply set the _eliminate flag which
    // prevents macro expansion from expanding the lock.  Since we don&#39;t
    // modify the graph, the value returned from this function is the
    // one computed above.
<span class="line-modified">!   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj()) {</span>
      //
      // If we are locking an unescaped object, the lock/unlock is unnecessary
      //
      ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
      if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
<span class="line-new-header">--- 2146,13 ---</span>
    // Now see if we can optimize away this lock.  We don&#39;t actually
    // remove the locking here, we simply set the _eliminate flag which
    // prevents macro expansion from expanding the lock.  Since we don&#39;t
    // modify the graph, the value returned from this function is the
    // one computed above.
<span class="line-modified">!   const Type* obj_type = phase-&gt;type(obj_node());</span>
<span class="line-added">+   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj() &amp;&amp;</span>
<span class="line-added">+       !obj_type-&gt;isa_valuetype() &amp;&amp; !obj_type-&gt;is_valuetypeptr()) {</span>
      //
      // If we are locking an unescaped object, the lock/unlock is unnecessary
      //
      ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
      if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2001,11 ***</span>
    // remove the unlocking here, we simply set the _eliminate flag which
    // prevents macro expansion from expanding the unlock.  Since we don&#39;t
    // modify the graph, the value returned from this function is the
    // one computed above.
    // Escape state is defined after Parse phase.
<span class="line-modified">!   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj()) {</span>
      //
      // If we are unlocking an unescaped object, the lock/unlock is unnecessary.
      //
      ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
      if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
<span class="line-new-header">--- 2316,13 ---</span>
    // remove the unlocking here, we simply set the _eliminate flag which
    // prevents macro expansion from expanding the unlock.  Since we don&#39;t
    // modify the graph, the value returned from this function is the
    // one computed above.
    // Escape state is defined after Parse phase.
<span class="line-modified">!   const Type* obj_type = phase-&gt;type(obj_node());</span>
<span class="line-added">+   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj() &amp;&amp;</span>
<span class="line-added">+       !obj_type-&gt;isa_valuetype() &amp;&amp; !obj_type-&gt;is_valuetypeptr()) {</span>
      //
      // If we are unlocking an unescaped object, the lock/unlock is unnecessary.
      //
      ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
      if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2083,11 ***</span>
      if (elem == Type::BOTTOM) {
        // An array but we don&#39;t know what elements are
        return true;
      }
  
<span class="line-modified">!     dest_t = dest_t-&gt;add_offset(Type::OffsetBot)-&gt;is_oopptr();</span>
      uint dest_alias = phase-&gt;C-&gt;get_alias_index(dest_t);
      uint t_oop_alias = phase-&gt;C-&gt;get_alias_index(t_oop);
  
      return dest_alias == t_oop_alias;
    }
<span class="line-new-header">--- 2400,12 ---</span>
      if (elem == Type::BOTTOM) {
        // An array but we don&#39;t know what elements are
        return true;
      }
  
<span class="line-modified">!     dest_t = dest_t-&gt;is_aryptr()-&gt;with_field_offset(Type::OffsetBot)-&gt;add_offset(Type::OffsetBot)-&gt;is_oopptr();</span>
<span class="line-added">+     t_oop = t_oop-&gt;is_aryptr()-&gt;with_field_offset(Type::OffsetBot);</span>
      uint dest_alias = phase-&gt;C-&gt;get_alias_index(dest_t);
      uint t_oop_alias = phase-&gt;C-&gt;get_alias_index(t_oop);
  
      return dest_alias == t_oop_alias;
    }
</pre>
<center><a href="c2_globals.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classes.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
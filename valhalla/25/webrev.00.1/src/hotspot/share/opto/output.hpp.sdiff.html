<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/output.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="output.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/output.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 76   int                    _method_size;           // Size of nmethod code segment in bytes
 77   CodeBuffer             _code_buffer;           // Where the code is assembled
 78   int                    _first_block_size;      // Size of unvalidated entry point code / OSR poison code
 79   ExceptionHandlerTable  _handler_table;         // Table of native-code exception handlers
 80   ImplicitExceptionTable _inc_table;             // Table of implicit null checks in native code
 81   OopMapSet*             _oop_map_set;           // Table of oop maps (one for each safepoint location)
 82   BufferBlob*            _scratch_buffer_blob;   // For temporary code buffers.
 83   relocInfo*             _scratch_locs_memory;   // For temporary code buffers.
 84   int                    _scratch_const_size;    // For temporary code buffers.
 85   bool                   _in_scratch_emit_size;  // true when in scratch_emit_size.
 86 
 87   int                    _frame_slots;           // Size of total frame in stack slots
 88   CodeOffsets            _code_offsets;          // Offsets into the code for various interesting entries
 89 
 90   uint                   _node_bundling_limit;
 91   Bundle*                _node_bundling_base;    // Information for instruction bundling
 92 
 93   // For deopt
 94   int                    _orig_pc_slot;
 95   int                    _orig_pc_slot_offset_in_bytes;



 96 
 97   ConstantTable          _constant_table;        // The constant table for this compilation unit.
 98 
 99   BufferSizingData       _buf_sizes;
100   Block*                 _block;
101   uint                   _index;
102 
103   void perform_mach_node_analysis();
104   void pd_perform_mach_node_analysis();
105 
106 public:
107   PhaseOutput();
108   ~PhaseOutput();
109 
110   // Convert Nodes to instruction bits and pass off to the VM
111   void Output();
112   bool need_stack_bang(int frame_size_in_bytes) const;
113   bool need_register_stack_bang() const;
114   void compute_loop_first_inst_sizes();
115 
</pre>
<hr />
<pre>
175   void          set_scratch_locs_memory(relocInfo* b)  { _scratch_locs_memory = b; }
176 
177   // emit to scratch blob, report resulting size
178   uint              scratch_emit_size(const Node* n);
179   void       set_in_scratch_emit_size(bool x)   {        _in_scratch_emit_size = x; }
180   bool           in_scratch_emit_size() const   { return _in_scratch_emit_size;     }
181 
182   enum ScratchBufferBlob {
183     MAX_inst_size       = 2048,
184     MAX_locs_size       = 128, // number of relocInfo elements
185     MAX_const_size      = 128,
186     MAX_stubs_size      = 128
187   };
188 
189   int               frame_slots() const         { return _frame_slots; }
190   int               frame_size_in_words() const; // frame_slots in units of the polymorphic &#39;words&#39;
191   int               frame_size_in_bytes() const { return _frame_slots &lt;&lt; LogBytesPerInt; }
192 
193   int               bang_size_in_bytes() const;
194 


195   uint              node_bundling_limit();
196   Bundle*           node_bundling_base();
197   void          set_node_bundling_limit(uint n) { _node_bundling_limit = n; }
198   void          set_node_bundling_base(Bundle* b) { _node_bundling_base = b; }
199 
200   Bundle* node_bundling(const Node *n);
201   bool valid_bundle_info(const Node *n);
202 
203   bool starts_bundle(const Node *n) const;
204 
205   // Dump formatted assembly
206 #if defined(SUPPORT_OPTO_ASSEMBLY)
207   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit);
208   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { dump_asm_on(tty, pcs, pc_limit); }
209 #else
210   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit) { return; }
211   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { return; }
212 #endif
213 
214   // Build OopMaps for each GC point
</pre>
</td>
<td>
<hr />
<pre>
 76   int                    _method_size;           // Size of nmethod code segment in bytes
 77   CodeBuffer             _code_buffer;           // Where the code is assembled
 78   int                    _first_block_size;      // Size of unvalidated entry point code / OSR poison code
 79   ExceptionHandlerTable  _handler_table;         // Table of native-code exception handlers
 80   ImplicitExceptionTable _inc_table;             // Table of implicit null checks in native code
 81   OopMapSet*             _oop_map_set;           // Table of oop maps (one for each safepoint location)
 82   BufferBlob*            _scratch_buffer_blob;   // For temporary code buffers.
 83   relocInfo*             _scratch_locs_memory;   // For temporary code buffers.
 84   int                    _scratch_const_size;    // For temporary code buffers.
 85   bool                   _in_scratch_emit_size;  // true when in scratch_emit_size.
 86 
 87   int                    _frame_slots;           // Size of total frame in stack slots
 88   CodeOffsets            _code_offsets;          // Offsets into the code for various interesting entries
 89 
 90   uint                   _node_bundling_limit;
 91   Bundle*                _node_bundling_base;    // Information for instruction bundling
 92 
 93   // For deopt
 94   int                    _orig_pc_slot;
 95   int                    _orig_pc_slot_offset_in_bytes;
<span class="line-added"> 96   // For the value type calling convention</span>
<span class="line-added"> 97   int                    _sp_inc_slot;</span>
<span class="line-added"> 98   int                    _sp_inc_slot_offset_in_bytes;</span>
 99 
100   ConstantTable          _constant_table;        // The constant table for this compilation unit.
101 
102   BufferSizingData       _buf_sizes;
103   Block*                 _block;
104   uint                   _index;
105 
106   void perform_mach_node_analysis();
107   void pd_perform_mach_node_analysis();
108 
109 public:
110   PhaseOutput();
111   ~PhaseOutput();
112 
113   // Convert Nodes to instruction bits and pass off to the VM
114   void Output();
115   bool need_stack_bang(int frame_size_in_bytes) const;
116   bool need_register_stack_bang() const;
117   void compute_loop_first_inst_sizes();
118 
</pre>
<hr />
<pre>
178   void          set_scratch_locs_memory(relocInfo* b)  { _scratch_locs_memory = b; }
179 
180   // emit to scratch blob, report resulting size
181   uint              scratch_emit_size(const Node* n);
182   void       set_in_scratch_emit_size(bool x)   {        _in_scratch_emit_size = x; }
183   bool           in_scratch_emit_size() const   { return _in_scratch_emit_size;     }
184 
185   enum ScratchBufferBlob {
186     MAX_inst_size       = 2048,
187     MAX_locs_size       = 128, // number of relocInfo elements
188     MAX_const_size      = 128,
189     MAX_stubs_size      = 128
190   };
191 
192   int               frame_slots() const         { return _frame_slots; }
193   int               frame_size_in_words() const; // frame_slots in units of the polymorphic &#39;words&#39;
194   int               frame_size_in_bytes() const { return _frame_slots &lt;&lt; LogBytesPerInt; }
195 
196   int               bang_size_in_bytes() const;
197 
<span class="line-added">198   int               sp_inc_offset()      const  { return _sp_inc_slot_offset_in_bytes; }</span>
<span class="line-added">199 </span>
200   uint              node_bundling_limit();
201   Bundle*           node_bundling_base();
202   void          set_node_bundling_limit(uint n) { _node_bundling_limit = n; }
203   void          set_node_bundling_base(Bundle* b) { _node_bundling_base = b; }
204 
205   Bundle* node_bundling(const Node *n);
206   bool valid_bundle_info(const Node *n);
207 
208   bool starts_bundle(const Node *n) const;
209 
210   // Dump formatted assembly
211 #if defined(SUPPORT_OPTO_ASSEMBLY)
212   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit);
213   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { dump_asm_on(tty, pcs, pc_limit); }
214 #else
215   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit) { return; }
216   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { return; }
217 #endif
218 
219   // Build OopMaps for each GC point
</pre>
</td>
</tr>
</table>
<center><a href="output.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  47 #include &quot;logging/logStream.hpp&quot;
  48 #include &quot;memory/allocation.inline.hpp&quot;
  49 #include &quot;memory/iterator.inline.hpp&quot;
  50 #include &quot;memory/metadataFactory.hpp&quot;
  51 #include &quot;memory/metaspaceClosure.hpp&quot;
  52 #include &quot;memory/metaspaceShared.hpp&quot;
  53 #include &quot;memory/oopFactory.hpp&quot;
  54 #include &quot;memory/resourceArea.hpp&quot;
  55 #include &quot;memory/universe.hpp&quot;
  56 #include &quot;oops/fieldStreams.inline.hpp&quot;
  57 #include &quot;oops/constantPool.hpp&quot;
  58 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  59 #include &quot;oops/instanceKlass.inline.hpp&quot;
  60 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  61 #include &quot;oops/instanceOop.hpp&quot;
  62 #include &quot;oops/klass.inline.hpp&quot;
  63 #include &quot;oops/method.hpp&quot;
  64 #include &quot;oops/oop.inline.hpp&quot;
  65 #include &quot;oops/recordComponent.hpp&quot;
  66 #include &quot;oops/symbol.hpp&quot;

  67 #include &quot;prims/jvmtiExport.hpp&quot;
  68 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  69 #include &quot;prims/jvmtiThreadState.hpp&quot;
  70 #include &quot;prims/methodComparator.hpp&quot;
  71 #include &quot;runtime/atomic.hpp&quot;
  72 #include &quot;runtime/biasedLocking.hpp&quot;
  73 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  74 #include &quot;runtime/handles.inline.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/mutexLocker.hpp&quot;
  77 #include &quot;runtime/orderAccess.hpp&quot;
  78 #include &quot;runtime/thread.inline.hpp&quot;
  79 #include &quot;services/classLoadingService.hpp&quot;
  80 #include &quot;services/threadService.hpp&quot;
  81 #include &quot;utilities/dtrace.hpp&quot;
  82 #include &quot;utilities/events.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/stringUtils.hpp&quot;
  85 #ifdef COMPILER1
  86 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 356 
 357   bool access = (cur_host == k_nest_host);
 358 
 359   if (log_is_enabled(Trace, class, nestmates)) {
 360     ResourceMark rm(THREAD);
 361     log_trace(class, nestmates)(&quot;Class %s does %shave nestmate access to %s&quot;,
 362                                 this-&gt;external_name(),
 363                                 access ? &quot;&quot; : &quot;NOT &quot;,
 364                                 k-&gt;external_name());
 365   }
 366 
 367   return access;
 368 }
 369 
 370 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 371   const int size = InstanceKlass::size(parser.vtable_size(),
 372                                        parser.itable_size(),
 373                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 374                                        parser.is_interface(),
 375                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 376                                        should_store_fingerprint(parser.is_unsafe_anonymous()));</span>


 377 
 378   const Symbol* const class_name = parser.class_name();
 379   assert(class_name != NULL, &quot;invariant&quot;);
 380   ClassLoaderData* loader_data = parser.loader_data();
 381   assert(loader_data != NULL, &quot;invariant&quot;);
 382 
 383   InstanceKlass* ik;
 384 
 385   // Allocation
 386   if (REF_NONE == parser.reference_type()) {
 387     if (class_name == vmSymbols::java_lang_Class()) {
 388       // mirror
 389       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 390     }</span>
<span class="line-removed"> 391     else if (is_class_loader(class_name, parser)) {</span>
 392       // class loader
 393       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);



 394     } else {
 395       // normal
 396       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);
 397     }
 398   } else {
 399     // reference
 400     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 401   }
 402 
 403   // Check for pending exception before adding to the loader data and incrementing
 404   // class count.  Can get OOM here.
 405   if (HAS_PENDING_EXCEPTION) {
 406     return NULL;
 407   }
 408 







 409   return ik;
 410 }
 411 























 412 
 413 // copy method ordering from resource area to Metaspace
 414 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 415   if (m != NULL) {
 416     // allocate a new array and copy contents (memcpy?)
 417     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 418     for (int i = 0; i &lt; m-&gt;length(); i++) {
 419       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 420     }
 421   } else {
 422     _method_ordering = Universe::the_empty_int_array();
 423   }
 424 }
 425 
 426 // create a new array of vtable_indices for default methods
 427 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 428   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 429   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 430   set_default_vtable_indices(vtable_indices);
 431   return vtable_indices;
 432 }
 433 
 434 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 435   Klass(id),
 436   _nest_members(NULL),
 437   _nest_host_index(0),
 438   _nest_host(NULL),
 439   _record_components(NULL),
 440   _static_field_size(parser.static_field_size()),
 441   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 442   _itable_len(parser.itable_size()),
 443   _init_thread(NULL),
 444   _init_state(allocated),
<span class="line-modified"> 445   _reference_type(parser.reference_type())</span>


 446 {
 447   set_vtable_length(parser.vtable_size());
 448   set_kind(kind);
 449   set_access_flags(parser.access_flags());
 450   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 451   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 452                                                     false));




 453 
<span class="line-modified"> 454   assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 455   assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 456   assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 457 
 458   if (Arguments::is_dumping_archive()) {
<span class="line-modified"> 459     SystemDictionaryShared::init_dumptime_info(this);</span>
<span class="line-modified"> 460   }</span>
 461 
 462   // Set biased locking bit for all instances of this class; it will be
 463   // cleared if revocation occurs too often for this type
 464   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 465     set_prototype_header(markWord::biased_locking_prototype());
 466   }



 467 }
 468 
 469 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 470                                        Array&lt;Method*&gt;* methods) {
 471   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 472       !methods-&gt;is_shared()) {
 473     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 474       Method* method = methods-&gt;at(i);
 475       if (method == NULL) continue;  // maybe null if error processing
 476       // Only want to delete methods that are not executing for RedefineClasses.
 477       // The previous version will point to them so they&#39;re not totally dangling
 478       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 479       MetadataFactory::free_metadata(loader_data, method);
 480     }
 481     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 482   }
 483 }
 484 
 485 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 486                                           const Klass* super_klass,
</pre>
<hr />
<pre>
 798         vmSymbols::java_lang_IncompatibleClassChangeError(),
 799         &quot;class %s has interface %s as super class&quot;,
 800         external_name(),
 801         super_klass-&gt;external_name()
 802       );
 803       return false;
 804     }
 805 
 806     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 807     ik_super-&gt;link_class_impl(CHECK_false);
 808   }
 809 
 810   // link all interfaces implemented by this class before linking this class
 811   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 812   int num_interfaces = interfaces-&gt;length();
 813   for (int index = 0; index &lt; num_interfaces; index++) {
 814     InstanceKlass* interk = interfaces-&gt;at(index);
 815     interk-&gt;link_class_impl(CHECK_false);
 816   }
 817 


























































 818   // in case the class is linked in the process of linking its superclasses
 819   if (is_linked()) {
 820     return true;
 821   }
 822 
 823   // trace only the link time for this klass that includes
 824   // the verification time
 825   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
 826                              ClassLoader::perf_class_link_selftime(),
 827                              ClassLoader::perf_classes_linked(),
 828                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 829                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 830                              PerfClassTraceTime::CLASS_LINK);
 831 
 832   // verification &amp; rewriting
 833   {
 834     HandleMark hm(THREAD);
 835     Handle h_init_lock(THREAD, init_lock());
 836     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 837     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
 867       // Initialize the vtable and interface table after
 868       // methods have been rewritten since rewrite may
 869       // fabricate new Method*s.
 870       // also does loader constraint checking
 871       //
 872       // initialize_vtable and initialize_itable need to be rerun for
 873       // a shared class if the class is not loaded by the NULL classloader.
 874       ClassLoaderData * loader_data = class_loader_data();
 875       if (!(is_shared() &amp;&amp;
 876             loader_data-&gt;is_the_null_class_loader_data())) {
 877         vtable().initialize_vtable(true, CHECK_false);
 878         itable().initialize_itable(true, CHECK_false);
 879       }
 880 #ifdef ASSERT
 881       else {
 882         vtable().verify(tty, true);
 883         // In case itable verification is ever added.
 884         // itable().verify(tty, true);
 885       }
 886 #endif

 887       set_init_state(linked);
 888       if (JvmtiExport::should_post_class_prepare()) {
 889         Thread *thread = THREAD;
 890         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 891         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
 892       }
 893     }
 894   }
 895   return true;
 896 }
 897 
 898 // Rewrite the byte codes of all of the methods of a class.
 899 // The rewriter must be called exactly once. Rewriting must happen after
 900 // verification but before the first method of the class is executed.
 901 void InstanceKlass::rewrite_class(TRAPS) {
 902   assert(is_loaded(), &quot;must be loaded&quot;);
 903   if (is_rewritten()) {
 904     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
 905     return;
 906   }
</pre>
<hr />
<pre>
1020     // having a superinterface that declares, non-static, concrete methods
1021     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1022       initialize_super_interfaces(THREAD);
1023     }
1024 
1025     // If any exceptions, complete abruptly, throwing the same exception as above.
1026     if (HAS_PENDING_EXCEPTION) {
1027       Handle e(THREAD, PENDING_EXCEPTION);
1028       CLEAR_PENDING_EXCEPTION;
1029       {
1030         EXCEPTION_MARK;
1031         // Locks object, set state, and notify all waiting threads
1032         set_initialization_state_and_notify(initialization_error, THREAD);
1033         CLEAR_PENDING_EXCEPTION;
1034       }
1035       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1036       THROW_OOP(e());
1037     }
1038   }
1039 































1040 
1041   // Look for aot compiled methods for this klass, including class initializer.
1042   AOTLoader::load_for_klass(this, THREAD);
1043 
<span class="line-modified">1044   // Step 8</span>
1045   {
1046     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1047     // Timer includes any side effects of class initialization (resolution,
1048     // etc), but not recursive entry into call_class_initializer().
1049     PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1050                              ClassLoader::perf_class_init_selftime(),
1051                              ClassLoader::perf_classes_inited(),
1052                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1053                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1054                              PerfClassTraceTime::CLASS_CLINIT);
1055     call_class_initializer(THREAD);
1056   }
1057 
<span class="line-modified">1058   // Step 9</span>
1059   if (!HAS_PENDING_EXCEPTION) {
1060     set_initialization_state_and_notify(fully_initialized, CHECK);
1061     {
1062       debug_only(vtable().verify(tty, true);)
1063     }
1064   }
1065   else {
<span class="line-modified">1066     // Step 10 and 11</span>
1067     Handle e(THREAD, PENDING_EXCEPTION);
1068     CLEAR_PENDING_EXCEPTION;
1069     // JVMTI has already reported the pending exception
1070     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1071     JvmtiExport::clear_detected_exception(jt);
1072     {
1073       EXCEPTION_MARK;
1074       set_initialization_state_and_notify(initialization_error, THREAD);
1075       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1076       // JVMTI has already reported the pending exception
1077       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1078       JvmtiExport::clear_detected_exception(jt);
1079     }
1080     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1081     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1082       THROW_OOP(e());
1083     } else {
1084       JavaCallArguments args(e);
1085       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1086                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1298   return i;
1299 }
1300 
1301 instanceHandle InstanceKlass::allocate_instance_handle(TRAPS) {
1302   return instanceHandle(THREAD, allocate_instance(THREAD));
1303 }
1304 
1305 void InstanceKlass::check_valid_for_instantiation(bool throwError, TRAPS) {
1306   if (is_interface() || is_abstract()) {
1307     ResourceMark rm(THREAD);
1308     THROW_MSG(throwError ? vmSymbols::java_lang_InstantiationError()
1309               : vmSymbols::java_lang_InstantiationException(), external_name());
1310   }
1311   if (this == SystemDictionary::Class_klass()) {
1312     ResourceMark rm(THREAD);
1313     THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
1314               : vmSymbols::java_lang_IllegalAccessException(), external_name());
1315   }
1316 }
1317 
<span class="line-modified">1318 Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {</span>

1319   // Need load-acquire for lock-free read
1320   if (array_klasses_acquire() == NULL) {
1321     if (or_null) return NULL;
1322 
1323     ResourceMark rm(THREAD);
1324     JavaThread *jt = (JavaThread *)THREAD;
1325     {
1326       // Atomic creation of array_klasses
1327       MutexLocker ma(THREAD, MultiArray_lock);
1328 
1329       // Check if update has already taken place
1330       if (array_klasses() == NULL) {
<span class="line-modified">1331         Klass*    k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);</span>
1332         // use &#39;release&#39; to pair with lock-free load
1333         release_set_array_klasses(k);
1334       }
1335     }
1336   }
1337   // _this will always be set at this point
1338   ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();
1339   if (or_null) {
<span class="line-modified">1340     return oak-&gt;array_klass_or_null(n);</span>
1341   }
<span class="line-modified">1342   return oak-&gt;array_klass(n, THREAD);</span>
1343 }
1344 
<span class="line-modified">1345 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {</span>
<span class="line-modified">1346   return array_klass_impl(or_null, 1, THREAD);</span>
1347 }
1348 
1349 static int call_class_initializer_counter = 0;   // for debugging
1350 
1351 Method* InstanceKlass::class_initializer() const {
1352   Method* clinit = find_method(
1353       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1354   if (clinit != NULL &amp;&amp; clinit-&gt;has_valid_initializer_flags()) {</span>
1355     return clinit;
1356   }
1357   return NULL;
1358 }
1359 
1360 void InstanceKlass::call_class_initializer(TRAPS) {
1361   if (ReplayCompiles &amp;&amp;
1362       (ReplaySuppressInitializers == 1 ||
1363        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1364     // Hide the existence of the initializer for the purpose of replaying the compile
1365     return;
1366   }
1367 
1368   methodHandle h_method(THREAD, class_initializer());
1369   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1370   LogTarget(Info, class, init) lt;
1371   if (lt.is_enabled()) {
1372     ResourceMark rm(THREAD);
1373     LogStream ls(lt);
1374     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1375     name()-&gt;print_value_on(&amp;ls);
1376     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1377   }
1378   if (h_method() != NULL) {
1379     JavaCallArguments args; // No arguments
1380     JavaValue result(T_VOID);
1381     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1382   }
1383 }
1384 
1385 
1386 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1387   InterpreterOopMap* entry_for) {
1388   // Lazily create the _oop_map_cache at first request
1389   // Lock-free access requires load_acquire.
1390   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1391   if (oop_map_cache == NULL) {
<span class="line-modified">1392     MutexLocker x(OopMapCacheAlloc_lock);</span>
1393     // Check if _oop_map_cache was allocated while we were waiting for this lock
1394     if ((oop_map_cache = _oop_map_cache) == NULL) {
1395       oop_map_cache = new OopMapCache();
1396       // Ensure _oop_map_cache is stable, since it is examined without a lock
1397       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1398     }
1399   }
1400   // _oop_map_cache is constant after init; lookup below does its own locking.
1401   oop_map_cache-&gt;lookup(method, bci, entry_for);
1402 }
1403 
<span class="line-removed">1404 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-removed">1405   fieldDescriptor fd;</span>
<span class="line-removed">1406   return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-removed">1407 }</span>
<span class="line-removed">1408 </span>
1409 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1410   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1411     Symbol* f_name = fs.name();
1412     Symbol* f_sig  = fs.signature();
1413     if (f_name == name &amp;&amp; f_sig == sig) {
1414       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1415       return true;
1416     }
1417   }
1418   return false;
1419 }
1420 
1421 
1422 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1423   const int n = local_interfaces()-&gt;length();
1424   for (int i = 0; i &lt; n; i++) {
1425     Klass* intf1 = local_interfaces()-&gt;at(i);
1426     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1427     // search for field in current interface
1428     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1459 
1460 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1461   // search order according to newest JVM spec (5.4.3.2, p.167).
1462   // 1) search for field in current klass
1463   if (find_local_field(name, sig, fd)) {
1464     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1465   }
1466   // 2) search for field recursively in direct superinterfaces
1467   if (is_static) {
1468     Klass* intf = find_interface_field(name, sig, fd);
1469     if (intf != NULL) return intf;
1470   }
1471   // 3) apply field lookup recursively if superclass exists
1472   { Klass* supr = super();
1473     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1474   }
1475   // 4) otherwise field lookup fails
1476   return NULL;
1477 }
1478 









1479 
1480 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1481   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1482     if (fs.offset() == offset) {
1483       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1484       if (fd-&gt;is_static() == is_static) return true;
1485     }
1486   }
1487   return false;
1488 }
1489 
1490 
1491 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1492   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1493   while (klass != NULL) {
1494     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1495       return true;
1496     }
1497     klass = klass-&gt;super();
1498   }
</pre>
<hr />
<pre>
1555     if (!fd.is_static()) {
1556       fields_sorted[j + 0] = fd.offset();
1557       fields_sorted[j + 1] = i;
1558       j += 2;
1559     }
1560   }
1561   if (j &gt; 0) {
1562     length = j;
1563     // _sort_Fn is defined in growableArray.hpp.
1564     qsort(fields_sorted, length/2, 2*sizeof(int), (_sort_Fn)compare_fields_by_offset);
1565     for (int i = 0; i &lt; length; i += 2) {
1566       fd.reinitialize(this, fields_sorted[i + 1]);
1567       assert(!fd.is_static() &amp;&amp; fd.offset() == fields_sorted[i], &quot;only nonstatic fields&quot;);
1568       cl-&gt;do_field(&amp;fd);
1569     }
1570   }
1571   FREE_C_HEAP_ARRAY(int, fields_sorted);
1572 }
1573 
1574 
<span class="line-removed">1575 void InstanceKlass::array_klasses_do(void f(Klass* k, TRAPS), TRAPS) {</span>
<span class="line-removed">1576   if (array_klasses() != NULL)</span>
<span class="line-removed">1577     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f, THREAD);</span>
<span class="line-removed">1578 }</span>
<span class="line-removed">1579 </span>
1580 void InstanceKlass::array_klasses_do(void f(Klass* k)) {
1581   if (array_klasses() != NULL)
1582     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f);
1583 }
1584 
1585 #ifdef ASSERT
1586 static int linear_search(const Array&lt;Method*&gt;* methods,
1587                          const Symbol* name,
1588                          const Symbol* signature) {
1589   const int len = methods-&gt;length();
1590   for (int index = 0; index &lt; len; index++) {
1591     const Method* const m = methods-&gt;at(index);
1592     assert(m-&gt;is_method(), &quot;must be method&quot;);
1593     if (m-&gt;signature() == signature &amp;&amp; m-&gt;name() == name) {
1594        return index;
1595     }
1596   }
1597   return -1;
1598 }
1599 #endif
</pre>
<hr />
<pre>
1843 }
1844 
1845 // uncached_lookup_method searches both the local class methods array and all
1846 // superclasses methods arrays, skipping any overpass methods in superclasses,
1847 // and possibly skipping private methods.
1848 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
1849                                               const Symbol* signature,
1850                                               OverpassLookupMode overpass_mode,
1851                                               PrivateLookupMode private_mode) const {
1852   OverpassLookupMode overpass_local_mode = overpass_mode;
1853   const Klass* klass = this;
1854   while (klass != NULL) {
1855     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
1856                                                                         signature,
1857                                                                         overpass_local_mode,
1858                                                                         find_static,
1859                                                                         private_mode);
1860     if (method != NULL) {
1861       return method;
1862     }



1863     klass = klass-&gt;super();
1864     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
1865   }
1866   return NULL;
1867 }
1868 
1869 #ifdef ASSERT
1870 // search through class hierarchy and return true if this class or
1871 // one of the superclasses was redefined
1872 bool InstanceKlass::has_redefined_this_or_super() const {
1873   const Klass* klass = this;
1874   while (klass != NULL) {
1875     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
1876       return true;
1877     }
1878     klass = klass-&gt;super();
1879   }
1880   return false;
1881 }
1882 #endif
</pre>
<hr />
<pre>
2425 }
2426 
2427 void InstanceKlass::remove_java_mirror() {
2428   Klass::remove_java_mirror();
2429 
2430   // do array classes also.
2431   if (array_klasses() != NULL) {
2432     array_klasses()-&gt;remove_java_mirror();
2433   }
2434 }
2435 
2436 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2437                                              PackageEntry* pkg_entry, TRAPS) {
2438   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2439   // before the InstanceKlass is added to the SystemDictionary. Make
2440   // sure the current state is &lt;loaded.
2441   assert(!is_loaded(), &quot;invalid init state&quot;);
2442   set_package(loader_data, pkg_entry, CHECK);
2443   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2444 




2445   Array&lt;Method*&gt;* methods = this-&gt;methods();
2446   int num_methods = methods-&gt;length();
2447   for (int index = 0; index &lt; num_methods; ++index) {
2448     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2449   }
2450   if (JvmtiExport::has_redefined_a_class()) {
2451     // Reinitialize vtable because RedefineClasses may have changed some
2452     // entries in this vtable for super classes so the CDS vtable might
2453     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2454     // vtables in the shared system dictionary, only the main one.
2455     // It also redefines the itable too so fix that too.
2456     vtable().initialize_vtable(false, CHECK);
2457     itable().initialize_itable(false, CHECK);
2458   }
2459 
2460   // restore constant pool resolved references
2461   constants()-&gt;restore_unshareable_info(CHECK);
2462 
2463   if (array_klasses() != NULL) {
2464     // Array classes have null protection domain.
2465     // --&gt; see ArrayKlass::complete_create_array_klass()
2466     ArrayKlass::cast(array_klasses())-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2467   }
2468 
2469   // Initialize current biased locking state.
<span class="line-modified">2470   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
2471     set_prototype_header(markWord::biased_locking_prototype());
2472   }
2473 }
2474 
2475 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2476   switch (loader_type) {
2477   case ClassLoader::BOOT_LOADER:
2478     _misc_flags |= _misc_is_shared_boot_class;
2479     break;
2480   case ClassLoader::PLATFORM_LOADER:
2481     _misc_flags |= _misc_is_shared_platform_class;
2482     break;
2483   case ClassLoader::APP_LOADER:
2484     _misc_flags |= _misc_is_shared_app_class;
2485     break;
2486   default:
2487     ShouldNotReachHere();
2488     break;
2489   }
2490 }
</pre>
<hr />
<pre>
2567 
2568 #if INCLUDE_JVMTI
2569   // Deallocate breakpoint records
2570   if (breakpoints() != 0x0) {
2571     methods_do(clear_all_breakpoints);
2572     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2573   }
2574 
2575   // deallocate the cached class file
2576   if (_cached_class_file != NULL) {
2577     os::free(_cached_class_file);
2578     _cached_class_file = NULL;
2579   }
2580 #endif
2581 
2582   // Decrement symbol reference counts associated with the unloaded class.
2583   if (_name != NULL) _name-&gt;decrement_refcount();
2584   // unreference array name derived from this class name (arrays of an unloaded
2585   // class can&#39;t be referenced anymore).
2586   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();








2587   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2588 }
2589 
2590 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2591   if (array == NULL) {
2592     _source_debug_extension = NULL;
2593   } else {
2594     // Adding one to the attribute length in order to store a null terminator
2595     // character could cause an overflow because the attribute length is
2596     // already coded with an u4 in the classfile, but in practice, it&#39;s
2597     // unlikely to happen.
2598     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2599     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2600     for (int i = 0; i &lt; length; i++) {
2601       sde[i] = array[i];
2602     }
2603     sde[length] = &#39;\0&#39;;
2604     _source_debug_extension = sde;
2605   }
2606 }
2607 
2608 const char* InstanceKlass::signature_name() const {




2609   int hash_len = 0;
2610   char hash_buf[40];
2611 
2612   // If this is an unsafe anonymous class, append a hash to make the name unique
2613   if (is_unsafe_anonymous()) {
2614     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2615     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2616     hash_len = (int)strlen(hash_buf);
2617   }
2618 
2619   // Get the internal name as a c string
2620   const char* src = (const char*) (name()-&gt;as_C_string());
2621   const int src_length = (int)strlen(src);
2622 
2623   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2624 
<span class="line-modified">2625   // Add L as type indicator</span>
2626   int dest_index = 0;
<span class="line-modified">2627   dest[dest_index++] = JVM_SIGNATURE_CLASS;</span>
2628 
2629   // Add the actual class name
2630   for (int src_index = 0; src_index &lt; src_length; ) {
2631     dest[dest_index++] = src[src_index++];
2632   }
2633 
2634   // If we have a hash, append it
2635   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2636     dest[dest_index++] = hash_buf[hash_index++];
2637   }
2638 
2639   // Add the semicolon and the NULL
2640   dest[dest_index++] = JVM_SIGNATURE_ENDCLASS;
2641   dest[dest_index] = &#39;\0&#39;;
2642   return dest;
2643 }
2644 
2645 ModuleEntry* InstanceKlass::module() const {
2646   // For an unsafe anonymous class return the host class&#39; module
2647   if (is_unsafe_anonymous()) {
</pre>
<hr />
<pre>
3119   }
3120 
3121   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3122   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3123     return best;
3124   }
3125   return NULL;
3126 }
3127 
3128 // -----------------------------------------------------------------------------------------------------
3129 // Printing
3130 
3131 #ifndef PRODUCT
3132 
3133 #define BULLET  &quot; - &quot;
3134 
3135 static const char* state_names[] = {
3136   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3137 };
3138 
<span class="line-modified">3139 static void print_vtable(intptr_t* start, int len, outputStream* st) {</span>



3140   for (int i = 0; i &lt; len; i++) {
3141     intptr_t e = start[i];
3142     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);





3143     if (MetaspaceObj::is_valid((Metadata*)e)) {
3144       st-&gt;print(&quot; &quot;);
3145       ((Metadata*)e)-&gt;print_value_on(st);






3146     }
3147     st-&gt;cr();
3148   }
3149 }
3150 
3151 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3152   return print_vtable(reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>





















3153 }
3154 
3155 void InstanceKlass::print_on(outputStream* st) const {
3156   assert(is_klass(), &quot;must be klass&quot;);
3157   Klass::print_on(st);
3158 
3159   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3160   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3161   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();

3162   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3163   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3164   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3165   st-&gt;print(BULLET&quot;sub:               &quot;);
3166   Klass* sub = subklass();
3167   int n;
3168   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3169     if (n &lt; MaxSubklassPrintSize) {
3170       sub-&gt;print_value_on(st);
3171       st-&gt;print(&quot;   &quot;);
3172     }
3173   }
3174   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3175   st-&gt;cr();
3176 
3177   if (is_interface()) {
3178     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3179     if (nof_implementors() == 1) {
3180       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3181       st-&gt;print(&quot;   &quot;);
3182       implementor()-&gt;print_value_on(st);
3183       st-&gt;cr();
3184     }
3185   }
3186 
3187   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3188   st-&gt;print(BULLET&quot;methods:           &quot;); methods()-&gt;print_value_on(st);                  st-&gt;cr();</span>
<span class="line-modified">3189   if (Verbose || WizardMode) {</span>
<span class="line-modified">3190     Array&lt;Method*&gt;* method_array = methods();</span>
<span class="line-removed">3191     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3192       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3193     }</span>
<span class="line-removed">3194   }</span>
<span class="line-removed">3195   st-&gt;print(BULLET&quot;method ordering:   &quot;); method_ordering()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3196   st-&gt;print(BULLET&quot;default_methods:   &quot;); default_methods()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3197   if (Verbose &amp;&amp; default_methods() != NULL) {</span>
<span class="line-removed">3198     Array&lt;Method*&gt;* method_array = default_methods();</span>
<span class="line-removed">3199     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3200       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3201     }</span>
<span class="line-removed">3202   }</span>
3203   if (default_vtable_indices() != NULL) {
<span class="line-modified">3204     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); default_vtable_indices()-&gt;print_value_on(st);       st-&gt;cr();</span>
3205   }
<span class="line-modified">3206   st-&gt;print(BULLET&quot;local interfaces:  &quot;); local_interfaces()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-modified">3207   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); transitive_interfaces()-&gt;print_value_on(st); st-&gt;cr();</span>
3208   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3209   if (class_loader_data() != NULL) {
3210     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3211     class_loader_data()-&gt;print_value_on(st);
3212     st-&gt;cr();
3213   }
3214   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3215   if (source_file_name() != NULL) {
3216     st-&gt;print(BULLET&quot;source file:       &quot;);
3217     source_file_name()-&gt;print_value_on(st);
3218     st-&gt;cr();
3219   }
3220   if (source_debug_extension() != NULL) {
3221     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3222     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3223     st-&gt;cr();
3224   }
3225   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3226   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3227   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3243   if (generic_signature() != NULL) {
3244     st-&gt;print(BULLET&quot;generic signature: &quot;);
3245     generic_signature()-&gt;print_value_on(st);
3246     st-&gt;cr();
3247   }
3248   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3249   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3250   if (record_components() != NULL) {
3251     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3252   }
3253   if (java_mirror() != NULL) {
3254     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3255     java_mirror()-&gt;print_value_on(st);
3256     st-&gt;cr();
3257   } else {
3258     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3259   }
3260   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3261   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3262   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3263   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);</span>
3264   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3265   FieldPrinter print_static_field(st);
3266   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3267   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3268   FieldPrinter print_nonstatic_field(st);
3269   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3270   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3271 
3272   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3273   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3274   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3275   while (map &lt; end_map) {
3276     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3277     map++;
3278   }
3279   st-&gt;cr();
3280 }
3281 
3282 #endif //PRODUCT
3283 
</pre>
<hr />
<pre>
3982   if (holder == NULL) {
3983     return NULL; // The version of klass is gone, no method is found
3984   }
3985   Method* method = holder-&gt;method_with_orig_idnum(idnum);
3986   return method;
3987 }
3988 
3989 #if INCLUDE_JVMTI
3990 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
3991   return _cached_class_file;
3992 }
3993 
3994 jint InstanceKlass::get_cached_class_file_len() {
3995   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
3996 }
3997 
3998 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
3999   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4000 }
4001 #endif





</pre>
</td>
<td>
<hr />
<pre>
  47 #include &quot;logging/logStream.hpp&quot;
  48 #include &quot;memory/allocation.inline.hpp&quot;
  49 #include &quot;memory/iterator.inline.hpp&quot;
  50 #include &quot;memory/metadataFactory.hpp&quot;
  51 #include &quot;memory/metaspaceClosure.hpp&quot;
  52 #include &quot;memory/metaspaceShared.hpp&quot;
  53 #include &quot;memory/oopFactory.hpp&quot;
  54 #include &quot;memory/resourceArea.hpp&quot;
  55 #include &quot;memory/universe.hpp&quot;
  56 #include &quot;oops/fieldStreams.inline.hpp&quot;
  57 #include &quot;oops/constantPool.hpp&quot;
  58 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  59 #include &quot;oops/instanceKlass.inline.hpp&quot;
  60 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  61 #include &quot;oops/instanceOop.hpp&quot;
  62 #include &quot;oops/klass.inline.hpp&quot;
  63 #include &quot;oops/method.hpp&quot;
  64 #include &quot;oops/oop.inline.hpp&quot;
  65 #include &quot;oops/recordComponent.hpp&quot;
  66 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  67 #include &quot;oops/valueKlass.hpp&quot;</span>
  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  70 #include &quot;prims/jvmtiThreadState.hpp&quot;
  71 #include &quot;prims/methodComparator.hpp&quot;
  72 #include &quot;runtime/atomic.hpp&quot;
  73 #include &quot;runtime/biasedLocking.hpp&quot;
  74 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  75 #include &quot;runtime/handles.inline.hpp&quot;
  76 #include &quot;runtime/javaCalls.hpp&quot;
  77 #include &quot;runtime/mutexLocker.hpp&quot;
  78 #include &quot;runtime/orderAccess.hpp&quot;
  79 #include &quot;runtime/thread.inline.hpp&quot;
  80 #include &quot;services/classLoadingService.hpp&quot;
  81 #include &quot;services/threadService.hpp&quot;
  82 #include &quot;utilities/dtrace.hpp&quot;
  83 #include &quot;utilities/events.hpp&quot;
  84 #include &quot;utilities/macros.hpp&quot;
  85 #include &quot;utilities/stringUtils.hpp&quot;
  86 #ifdef COMPILER1
  87 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 357 
 358   bool access = (cur_host == k_nest_host);
 359 
 360   if (log_is_enabled(Trace, class, nestmates)) {
 361     ResourceMark rm(THREAD);
 362     log_trace(class, nestmates)(&quot;Class %s does %shave nestmate access to %s&quot;,
 363                                 this-&gt;external_name(),
 364                                 access ? &quot;&quot; : &quot;NOT &quot;,
 365                                 k-&gt;external_name());
 366   }
 367 
 368   return access;
 369 }
 370 
 371 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 372   const int size = InstanceKlass::size(parser.vtable_size(),
 373                                        parser.itable_size(),
 374                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 375                                        parser.is_interface(),
 376                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 377                                        should_store_fingerprint(parser.is_unsafe_anonymous()),</span>
<span class="line-added"> 378                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,</span>
<span class="line-added"> 379                                        parser.is_value_type());</span>
 380 
 381   const Symbol* const class_name = parser.class_name();
 382   assert(class_name != NULL, &quot;invariant&quot;);
 383   ClassLoaderData* loader_data = parser.loader_data();
 384   assert(loader_data != NULL, &quot;invariant&quot;);
 385 
 386   InstanceKlass* ik;
 387 
 388   // Allocation
 389   if (REF_NONE == parser.reference_type()) {
 390     if (class_name == vmSymbols::java_lang_Class()) {
 391       // mirror
 392       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 393     } else if (is_class_loader(class_name, parser)) {</span>

 394       // class loader
 395       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
<span class="line-added"> 396     } else if (parser.is_value_type()) {</span>
<span class="line-added"> 397       // value type</span>
<span class="line-added"> 398       ik = new (loader_data, size, THREAD) ValueKlass(parser);</span>
 399     } else {
 400       // normal
 401       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);
 402     }
 403   } else {
 404     // reference
 405     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 406   }
 407 
 408   // Check for pending exception before adding to the loader data and incrementing
 409   // class count.  Can get OOM here.
 410   if (HAS_PENDING_EXCEPTION) {
 411     return NULL;
 412   }
 413 
<span class="line-added"> 414 #ifdef ASSERT</span>
<span class="line-added"> 415   assert(ik-&gt;size() == size, &quot;&quot;);</span>
<span class="line-added"> 416   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);</span>
<span class="line-added"> 417   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);</span>
<span class="line-added"> 418   ik-&gt;bounds_check((address) ik-&gt;end_of_itable(), true, size);</span>
<span class="line-added"> 419   ik-&gt;bounds_check((address) ik-&gt;end_of_nonstatic_oop_maps(), true, size);</span>
<span class="line-added"> 420 #endif //ASSERT</span>
 421   return ik;
 422 }
 423 
<span class="line-added"> 424 #ifndef PRODUCT</span>
<span class="line-added"> 425 bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {</span>
<span class="line-added"> 426   const char* bad = NULL;</span>
<span class="line-added"> 427   address end = NULL;</span>
<span class="line-added"> 428   if (addr &lt; (address)this) {</span>
<span class="line-added"> 429     bad = &quot;before&quot;;</span>
<span class="line-added"> 430   } else if (addr == (address)this) {</span>
<span class="line-added"> 431     if (edge_ok)  return true;</span>
<span class="line-added"> 432     bad = &quot;just before&quot;;</span>
<span class="line-added"> 433   } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes &lt; 0 ? size() : size_in_bytes))) {</span>
<span class="line-added"> 434     if (edge_ok)  return true;</span>
<span class="line-added"> 435     bad = &quot;just after&quot;;</span>
<span class="line-added"> 436   } else if (addr &gt; end) {</span>
<span class="line-added"> 437     bad = &quot;after&quot;;</span>
<span class="line-added"> 438   } else {</span>
<span class="line-added"> 439     return true;</span>
<span class="line-added"> 440   }</span>
<span class="line-added"> 441   tty-&gt;print_cr(&quot;%s object bounds: &quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot;..&quot; INTPTR_FORMAT &quot;]&quot;,</span>
<span class="line-added"> 442       bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);</span>
<span class="line-added"> 443   Verbose = WizardMode = true; this-&gt;print(); //@@</span>
<span class="line-added"> 444   return false;</span>
<span class="line-added"> 445 }</span>
<span class="line-added"> 446 #endif //PRODUCT</span>
 447 
 448 // copy method ordering from resource area to Metaspace
 449 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 450   if (m != NULL) {
 451     // allocate a new array and copy contents (memcpy?)
 452     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 453     for (int i = 0; i &lt; m-&gt;length(); i++) {
 454       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 455     }
 456   } else {
 457     _method_ordering = Universe::the_empty_int_array();
 458   }
 459 }
 460 
 461 // create a new array of vtable_indices for default methods
 462 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 463   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 464   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 465   set_default_vtable_indices(vtable_indices);
 466   return vtable_indices;
 467 }
 468 
 469 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 470   Klass(id),
 471   _nest_members(NULL),
 472   _nest_host_index(0),
 473   _nest_host(NULL),
 474   _record_components(NULL),
 475   _static_field_size(parser.static_field_size()),
 476   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 477   _itable_len(parser.itable_size()),
 478   _init_thread(NULL),
 479   _init_state(allocated),
<span class="line-modified"> 480   _reference_type(parser.reference_type()),</span>
<span class="line-added"> 481   _value_field_klasses(NULL),</span>
<span class="line-added"> 482   _adr_valueklass_fixed_block(NULL)</span>
 483 {
 484   set_vtable_length(parser.vtable_size());
 485   set_kind(kind);
 486   set_access_flags(parser.access_flags());
 487   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 488   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 489                                                     false));
<span class="line-added"> 490     if (parser.has_flattenable_fields()) {</span>
<span class="line-added"> 491       set_has_value_fields();</span>
<span class="line-added"> 492     }</span>
<span class="line-added"> 493     _java_fields_count = parser.java_fields_count();</span>
 494 
<span class="line-modified"> 495     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 496     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 497     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 498 
 499   if (Arguments::is_dumping_archive()) {
<span class="line-modified"> 500       SystemDictionaryShared::init_dumptime_info(this);</span>
<span class="line-modified"> 501     }</span>
 502 
 503   // Set biased locking bit for all instances of this class; it will be
 504   // cleared if revocation occurs too often for this type
 505   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 506     set_prototype_header(markWord::biased_locking_prototype());
 507   }
<span class="line-added"> 508   if (has_value_fields()) {</span>
<span class="line-added"> 509     _value_field_klasses = (const Klass**) adr_value_fields_klasses();</span>
<span class="line-added"> 510   }</span>
 511 }
 512 
 513 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 514                                        Array&lt;Method*&gt;* methods) {
 515   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 516       !methods-&gt;is_shared()) {
 517     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 518       Method* method = methods-&gt;at(i);
 519       if (method == NULL) continue;  // maybe null if error processing
 520       // Only want to delete methods that are not executing for RedefineClasses.
 521       // The previous version will point to them so they&#39;re not totally dangling
 522       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 523       MetadataFactory::free_metadata(loader_data, method);
 524     }
 525     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 526   }
 527 }
 528 
 529 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 530                                           const Klass* super_klass,
</pre>
<hr />
<pre>
 842         vmSymbols::java_lang_IncompatibleClassChangeError(),
 843         &quot;class %s has interface %s as super class&quot;,
 844         external_name(),
 845         super_klass-&gt;external_name()
 846       );
 847       return false;
 848     }
 849 
 850     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 851     ik_super-&gt;link_class_impl(CHECK_false);
 852   }
 853 
 854   // link all interfaces implemented by this class before linking this class
 855   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 856   int num_interfaces = interfaces-&gt;length();
 857   for (int index = 0; index &lt; num_interfaces; index++) {
 858     InstanceKlass* interk = interfaces-&gt;at(index);
 859     interk-&gt;link_class_impl(CHECK_false);
 860   }
 861 
<span class="line-added"> 862 </span>
<span class="line-added"> 863   // If a class declares a method that uses a value class as an argument</span>
<span class="line-added"> 864   // type or return value type, this value class must be loaded during the</span>
<span class="line-added"> 865   // linking of this class because size and properties of the value class</span>
<span class="line-added"> 866   // must be known in order to be able to perform value type optimizations.</span>
<span class="line-added"> 867   // The implementation below is an approximation of this rule, the code</span>
<span class="line-added"> 868   // iterates over all methods of the current class (including overridden</span>
<span class="line-added"> 869   // methods), not only the methods declared by this class. This</span>
<span class="line-added"> 870   // approximation makes the code simpler, and doesn&#39;t change the semantic</span>
<span class="line-added"> 871   // because classes declaring methods overridden by the current class are</span>
<span class="line-added"> 872   // linked (and have performed their own pre-loading) before the linking</span>
<span class="line-added"> 873   // of the current class.</span>
<span class="line-added"> 874   // This is also the moment to detect potential mismatch between the</span>
<span class="line-added"> 875   // ValueTypes attribute and the kind of the class effectively loaded.</span>
<span class="line-added"> 876 </span>
<span class="line-added"> 877 </span>
<span class="line-added"> 878   // Note:</span>
<span class="line-added"> 879   // Value class types used for flattenable fields are loaded during</span>
<span class="line-added"> 880   // the loading phase (see ClassFileParser::post_process_parsed_stream()).</span>
<span class="line-added"> 881   // Value class types used as element types for array creation</span>
<span class="line-added"> 882   // are not pre-loaded. Their loading is triggered by either anewarray</span>
<span class="line-added"> 883   // or multianewarray bytecodes.</span>
<span class="line-added"> 884 </span>
<span class="line-added"> 885   // Could it be possible to do the following processing only if the</span>
<span class="line-added"> 886   // class uses value types?</span>
<span class="line-added"> 887   {</span>
<span class="line-added"> 888     ResourceMark rm(THREAD);</span>
<span class="line-added"> 889     for (int i = 0; i &lt; methods()-&gt;length(); i++) {</span>
<span class="line-added"> 890       Method* m = methods()-&gt;at(i);</span>
<span class="line-added"> 891       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {</span>
<span class="line-added"> 892         if (ss.is_reference()) {</span>
<span class="line-added"> 893           if (ss.is_array()) {</span>
<span class="line-added"> 894             ss.skip_array_prefix();</span>
<span class="line-added"> 895           }</span>
<span class="line-added"> 896           if (ss.type() == T_VALUETYPE) {</span>
<span class="line-added"> 897             Symbol* symb = ss.as_symbol();</span>
<span class="line-added"> 898 </span>
<span class="line-added"> 899             oop loader = class_loader();</span>
<span class="line-added"> 900             oop protection_domain = this-&gt;protection_domain();</span>
<span class="line-added"> 901             Klass* klass = SystemDictionary::resolve_or_fail(symb,</span>
<span class="line-added"> 902                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,</span>
<span class="line-added"> 903                                                              CHECK_false);</span>
<span class="line-added"> 904             if (klass == NULL) {</span>
<span class="line-added"> 905               THROW_(vmSymbols::java_lang_LinkageError(), false);</span>
<span class="line-added"> 906             }</span>
<span class="line-added"> 907             if (!klass-&gt;is_value()) {</span>
<span class="line-added"> 908               Exceptions::fthrow(</span>
<span class="line-added"> 909                 THREAD_AND_LOCATION,</span>
<span class="line-added"> 910                 vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added"> 911                 &quot;class %s is not an inline type&quot;,</span>
<span class="line-added"> 912                 klass-&gt;external_name());</span>
<span class="line-added"> 913             }</span>
<span class="line-added"> 914           }</span>
<span class="line-added"> 915         }</span>
<span class="line-added"> 916       }</span>
<span class="line-added"> 917     }</span>
<span class="line-added"> 918   }</span>
<span class="line-added"> 919 </span>
 920   // in case the class is linked in the process of linking its superclasses
 921   if (is_linked()) {
 922     return true;
 923   }
 924 
 925   // trace only the link time for this klass that includes
 926   // the verification time
 927   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
 928                              ClassLoader::perf_class_link_selftime(),
 929                              ClassLoader::perf_classes_linked(),
 930                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 931                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 932                              PerfClassTraceTime::CLASS_LINK);
 933 
 934   // verification &amp; rewriting
 935   {
 936     HandleMark hm(THREAD);
 937     Handle h_init_lock(THREAD, init_lock());
 938     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 939     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
 969       // Initialize the vtable and interface table after
 970       // methods have been rewritten since rewrite may
 971       // fabricate new Method*s.
 972       // also does loader constraint checking
 973       //
 974       // initialize_vtable and initialize_itable need to be rerun for
 975       // a shared class if the class is not loaded by the NULL classloader.
 976       ClassLoaderData * loader_data = class_loader_data();
 977       if (!(is_shared() &amp;&amp;
 978             loader_data-&gt;is_the_null_class_loader_data())) {
 979         vtable().initialize_vtable(true, CHECK_false);
 980         itable().initialize_itable(true, CHECK_false);
 981       }
 982 #ifdef ASSERT
 983       else {
 984         vtable().verify(tty, true);
 985         // In case itable verification is ever added.
 986         // itable().verify(tty, true);
 987       }
 988 #endif
<span class="line-added"> 989 </span>
 990       set_init_state(linked);
 991       if (JvmtiExport::should_post_class_prepare()) {
 992         Thread *thread = THREAD;
 993         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 994         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
 995       }
 996     }
 997   }
 998   return true;
 999 }
1000 
1001 // Rewrite the byte codes of all of the methods of a class.
1002 // The rewriter must be called exactly once. Rewriting must happen after
1003 // verification but before the first method of the class is executed.
1004 void InstanceKlass::rewrite_class(TRAPS) {
1005   assert(is_loaded(), &quot;must be loaded&quot;);
1006   if (is_rewritten()) {
1007     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
1008     return;
1009   }
</pre>
<hr />
<pre>
1123     // having a superinterface that declares, non-static, concrete methods
1124     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1125       initialize_super_interfaces(THREAD);
1126     }
1127 
1128     // If any exceptions, complete abruptly, throwing the same exception as above.
1129     if (HAS_PENDING_EXCEPTION) {
1130       Handle e(THREAD, PENDING_EXCEPTION);
1131       CLEAR_PENDING_EXCEPTION;
1132       {
1133         EXCEPTION_MARK;
1134         // Locks object, set state, and notify all waiting threads
1135         set_initialization_state_and_notify(initialization_error, THREAD);
1136         CLEAR_PENDING_EXCEPTION;
1137       }
1138       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1139       THROW_OOP(e());
1140     }
1141   }
1142 
<span class="line-added">1143   // Step 8</span>
<span class="line-added">1144   // Initialize classes of flattenable fields</span>
<span class="line-added">1145   {</span>
<span class="line-added">1146     for (AllFieldStream fs(this); !fs.done(); fs.next()) {</span>
<span class="line-added">1147       if (fs.is_flattenable()) {</span>
<span class="line-added">1148         Klass* klass = this-&gt;get_value_field_klass_or_null(fs.index());</span>
<span class="line-added">1149         if (klass == NULL) {</span>
<span class="line-added">1150           assert(fs.access_flags().is_static() &amp;&amp; fs.access_flags().is_flattenable(),</span>
<span class="line-added">1151               &quot;Otherwise should have been pre-loaded&quot;);</span>
<span class="line-added">1152           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),</span>
<span class="line-added">1153               Handle(THREAD, class_loader()),</span>
<span class="line-added">1154               Handle(THREAD, protection_domain()),</span>
<span class="line-added">1155               true, CHECK);</span>
<span class="line-added">1156           if (klass == NULL) {</span>
<span class="line-added">1157             THROW(vmSymbols::java_lang_NoClassDefFoundError());</span>
<span class="line-added">1158           }</span>
<span class="line-added">1159           if (!klass-&gt;is_value()) {</span>
<span class="line-added">1160             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">1161           }</span>
<span class="line-added">1162           this-&gt;set_value_field_klass(fs.index(), klass);</span>
<span class="line-added">1163         }</span>
<span class="line-added">1164         InstanceKlass::cast(klass)-&gt;initialize(CHECK);</span>
<span class="line-added">1165         if (fs.access_flags().is_static()) {</span>
<span class="line-added">1166           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {</span>
<span class="line-added">1167             java_mirror()-&gt;obj_field_put(fs.offset(), ValueKlass::cast(klass)-&gt;default_value());</span>
<span class="line-added">1168           }</span>
<span class="line-added">1169         }</span>
<span class="line-added">1170       }</span>
<span class="line-added">1171     }</span>
<span class="line-added">1172   }</span>
<span class="line-added">1173 </span>
1174 
1175   // Look for aot compiled methods for this klass, including class initializer.
1176   AOTLoader::load_for_klass(this, THREAD);
1177 
<span class="line-modified">1178   // Step 9</span>
1179   {
1180     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1181     // Timer includes any side effects of class initialization (resolution,
1182     // etc), but not recursive entry into call_class_initializer().
1183     PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1184                              ClassLoader::perf_class_init_selftime(),
1185                              ClassLoader::perf_classes_inited(),
1186                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1187                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1188                              PerfClassTraceTime::CLASS_CLINIT);
1189     call_class_initializer(THREAD);
1190   }
1191 
<span class="line-modified">1192   // Step 10</span>
1193   if (!HAS_PENDING_EXCEPTION) {
1194     set_initialization_state_and_notify(fully_initialized, CHECK);
1195     {
1196       debug_only(vtable().verify(tty, true);)
1197     }
1198   }
1199   else {
<span class="line-modified">1200     // Step 11 and 12</span>
1201     Handle e(THREAD, PENDING_EXCEPTION);
1202     CLEAR_PENDING_EXCEPTION;
1203     // JVMTI has already reported the pending exception
1204     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1205     JvmtiExport::clear_detected_exception(jt);
1206     {
1207       EXCEPTION_MARK;
1208       set_initialization_state_and_notify(initialization_error, THREAD);
1209       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1210       // JVMTI has already reported the pending exception
1211       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1212       JvmtiExport::clear_detected_exception(jt);
1213     }
1214     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1215     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1216       THROW_OOP(e());
1217     } else {
1218       JavaCallArguments args(e);
1219       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1220                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1432   return i;
1433 }
1434 
1435 instanceHandle InstanceKlass::allocate_instance_handle(TRAPS) {
1436   return instanceHandle(THREAD, allocate_instance(THREAD));
1437 }
1438 
1439 void InstanceKlass::check_valid_for_instantiation(bool throwError, TRAPS) {
1440   if (is_interface() || is_abstract()) {
1441     ResourceMark rm(THREAD);
1442     THROW_MSG(throwError ? vmSymbols::java_lang_InstantiationError()
1443               : vmSymbols::java_lang_InstantiationException(), external_name());
1444   }
1445   if (this == SystemDictionary::Class_klass()) {
1446     ResourceMark rm(THREAD);
1447     THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
1448               : vmSymbols::java_lang_IllegalAccessException(), external_name());
1449   }
1450 }
1451 
<span class="line-modified">1452 Klass* InstanceKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS) {</span>
<span class="line-added">1453   assert(storage_props.is_empty(), &quot;Unexpected&quot;);</span>
1454   // Need load-acquire for lock-free read
1455   if (array_klasses_acquire() == NULL) {
1456     if (or_null) return NULL;
1457 
1458     ResourceMark rm(THREAD);
1459     JavaThread *jt = (JavaThread *)THREAD;
1460     {
1461       // Atomic creation of array_klasses
1462       MutexLocker ma(THREAD, MultiArray_lock);
1463 
1464       // Check if update has already taken place
1465       if (array_klasses() == NULL) {
<span class="line-modified">1466         Klass*    k = ObjArrayKlass::allocate_objArray_klass(storage_props, 1, this, CHECK_NULL);</span>
1467         // use &#39;release&#39; to pair with lock-free load
1468         release_set_array_klasses(k);
1469       }
1470     }
1471   }
1472   // _this will always be set at this point
1473   ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();
1474   if (or_null) {
<span class="line-modified">1475     return oak-&gt;array_klass_or_null(storage_props, n);</span>
1476   }
<span class="line-modified">1477   return oak-&gt;array_klass(storage_props, n, THREAD);</span>
1478 }
1479 
<span class="line-modified">1480 Klass* InstanceKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS) {</span>
<span class="line-modified">1481   return array_klass_impl(storage_props, or_null, 1, THREAD);</span>
1482 }
1483 
1484 static int call_class_initializer_counter = 0;   // for debugging
1485 
1486 Method* InstanceKlass::class_initializer() const {
1487   Method* clinit = find_method(
1488       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1489   if (clinit != NULL &amp;&amp; clinit-&gt;is_class_initializer()) {</span>
1490     return clinit;
1491   }
1492   return NULL;
1493 }
1494 
1495 void InstanceKlass::call_class_initializer(TRAPS) {
1496   if (ReplayCompiles &amp;&amp;
1497       (ReplaySuppressInitializers == 1 ||
1498        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1499     // Hide the existence of the initializer for the purpose of replaying the compile
1500     return;
1501   }
1502 
1503   methodHandle h_method(THREAD, class_initializer());
1504   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1505   LogTarget(Info, class, init) lt;
1506   if (lt.is_enabled()) {
1507     ResourceMark rm(THREAD);
1508     LogStream ls(lt);
1509     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1510     name()-&gt;print_value_on(&amp;ls);
1511     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1512   }
1513   if (h_method() != NULL) {
1514     JavaCallArguments args; // No arguments
1515     JavaValue result(T_VOID);
1516     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1517   }
1518 }
1519 
1520 
1521 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1522   InterpreterOopMap* entry_for) {
1523   // Lazily create the _oop_map_cache at first request
1524   // Lock-free access requires load_acquire.
1525   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1526   if (oop_map_cache == NULL) {
<span class="line-modified">1527     MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);</span>
1528     // Check if _oop_map_cache was allocated while we were waiting for this lock
1529     if ((oop_map_cache = _oop_map_cache) == NULL) {
1530       oop_map_cache = new OopMapCache();
1531       // Ensure _oop_map_cache is stable, since it is examined without a lock
1532       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1533     }
1534   }
1535   // _oop_map_cache is constant after init; lookup below does its own locking.
1536   oop_map_cache-&gt;lookup(method, bci, entry_for);
1537 }
1538 





1539 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1540   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1541     Symbol* f_name = fs.name();
1542     Symbol* f_sig  = fs.signature();
1543     if (f_name == name &amp;&amp; f_sig == sig) {
1544       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1545       return true;
1546     }
1547   }
1548   return false;
1549 }
1550 
1551 
1552 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1553   const int n = local_interfaces()-&gt;length();
1554   for (int i = 0; i &lt; n; i++) {
1555     Klass* intf1 = local_interfaces()-&gt;at(i);
1556     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1557     // search for field in current interface
1558     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1589 
1590 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1591   // search order according to newest JVM spec (5.4.3.2, p.167).
1592   // 1) search for field in current klass
1593   if (find_local_field(name, sig, fd)) {
1594     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1595   }
1596   // 2) search for field recursively in direct superinterfaces
1597   if (is_static) {
1598     Klass* intf = find_interface_field(name, sig, fd);
1599     if (intf != NULL) return intf;
1600   }
1601   // 3) apply field lookup recursively if superclass exists
1602   { Klass* supr = super();
1603     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1604   }
1605   // 4) otherwise field lookup fails
1606   return NULL;
1607 }
1608 
<span class="line-added">1609 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-added">1610   if (this-&gt;is_value()) {</span>
<span class="line-added">1611     ValueKlass* vk = ValueKlass::cast(this);</span>
<span class="line-added">1612     return offset &gt;= vk-&gt;first_field_offset() &amp;&amp; offset &lt; (vk-&gt;first_field_offset() + vk-&gt;get_exact_size_in_bytes());</span>
<span class="line-added">1613   } else {</span>
<span class="line-added">1614     fieldDescriptor fd;</span>
<span class="line-added">1615     return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-added">1616   }</span>
<span class="line-added">1617 }</span>
1618 
1619 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1620   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1621     if (fs.offset() == offset) {
1622       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1623       if (fd-&gt;is_static() == is_static) return true;
1624     }
1625   }
1626   return false;
1627 }
1628 
1629 
1630 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1631   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1632   while (klass != NULL) {
1633     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1634       return true;
1635     }
1636     klass = klass-&gt;super();
1637   }
</pre>
<hr />
<pre>
1694     if (!fd.is_static()) {
1695       fields_sorted[j + 0] = fd.offset();
1696       fields_sorted[j + 1] = i;
1697       j += 2;
1698     }
1699   }
1700   if (j &gt; 0) {
1701     length = j;
1702     // _sort_Fn is defined in growableArray.hpp.
1703     qsort(fields_sorted, length/2, 2*sizeof(int), (_sort_Fn)compare_fields_by_offset);
1704     for (int i = 0; i &lt; length; i += 2) {
1705       fd.reinitialize(this, fields_sorted[i + 1]);
1706       assert(!fd.is_static() &amp;&amp; fd.offset() == fields_sorted[i], &quot;only nonstatic fields&quot;);
1707       cl-&gt;do_field(&amp;fd);
1708     }
1709   }
1710   FREE_C_HEAP_ARRAY(int, fields_sorted);
1711 }
1712 
1713 





1714 void InstanceKlass::array_klasses_do(void f(Klass* k)) {
1715   if (array_klasses() != NULL)
1716     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f);
1717 }
1718 
1719 #ifdef ASSERT
1720 static int linear_search(const Array&lt;Method*&gt;* methods,
1721                          const Symbol* name,
1722                          const Symbol* signature) {
1723   const int len = methods-&gt;length();
1724   for (int index = 0; index &lt; len; index++) {
1725     const Method* const m = methods-&gt;at(index);
1726     assert(m-&gt;is_method(), &quot;must be method&quot;);
1727     if (m-&gt;signature() == signature &amp;&amp; m-&gt;name() == name) {
1728        return index;
1729     }
1730   }
1731   return -1;
1732 }
1733 #endif
</pre>
<hr />
<pre>
1977 }
1978 
1979 // uncached_lookup_method searches both the local class methods array and all
1980 // superclasses methods arrays, skipping any overpass methods in superclasses,
1981 // and possibly skipping private methods.
1982 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
1983                                               const Symbol* signature,
1984                                               OverpassLookupMode overpass_mode,
1985                                               PrivateLookupMode private_mode) const {
1986   OverpassLookupMode overpass_local_mode = overpass_mode;
1987   const Klass* klass = this;
1988   while (klass != NULL) {
1989     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
1990                                                                         signature,
1991                                                                         overpass_local_mode,
1992                                                                         find_static,
1993                                                                         private_mode);
1994     if (method != NULL) {
1995       return method;
1996     }
<span class="line-added">1997     if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">1998       break;  // &lt;init&gt; is never inherited, not even as a static factory</span>
<span class="line-added">1999     }</span>
2000     klass = klass-&gt;super();
2001     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
2002   }
2003   return NULL;
2004 }
2005 
2006 #ifdef ASSERT
2007 // search through class hierarchy and return true if this class or
2008 // one of the superclasses was redefined
2009 bool InstanceKlass::has_redefined_this_or_super() const {
2010   const Klass* klass = this;
2011   while (klass != NULL) {
2012     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
2013       return true;
2014     }
2015     klass = klass-&gt;super();
2016   }
2017   return false;
2018 }
2019 #endif
</pre>
<hr />
<pre>
2562 }
2563 
2564 void InstanceKlass::remove_java_mirror() {
2565   Klass::remove_java_mirror();
2566 
2567   // do array classes also.
2568   if (array_klasses() != NULL) {
2569     array_klasses()-&gt;remove_java_mirror();
2570   }
2571 }
2572 
2573 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2574                                              PackageEntry* pkg_entry, TRAPS) {
2575   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2576   // before the InstanceKlass is added to the SystemDictionary. Make
2577   // sure the current state is &lt;loaded.
2578   assert(!is_loaded(), &quot;invalid init state&quot;);
2579   set_package(loader_data, pkg_entry, CHECK);
2580   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2581 
<span class="line-added">2582   if (is_value()) {</span>
<span class="line-added">2583     ValueKlass::cast(this)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">2584   }</span>
<span class="line-added">2585 </span>
2586   Array&lt;Method*&gt;* methods = this-&gt;methods();
2587   int num_methods = methods-&gt;length();
2588   for (int index = 0; index &lt; num_methods; ++index) {
2589     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2590   }
2591   if (JvmtiExport::has_redefined_a_class()) {
2592     // Reinitialize vtable because RedefineClasses may have changed some
2593     // entries in this vtable for super classes so the CDS vtable might
2594     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2595     // vtables in the shared system dictionary, only the main one.
2596     // It also redefines the itable too so fix that too.
2597     vtable().initialize_vtable(false, CHECK);
2598     itable().initialize_itable(false, CHECK);
2599   }
2600 
2601   // restore constant pool resolved references
2602   constants()-&gt;restore_unshareable_info(CHECK);
2603 
2604   if (array_klasses() != NULL) {
2605     // Array classes have null protection domain.
2606     // --&gt; see ArrayKlass::complete_create_array_klass()
2607     ArrayKlass::cast(array_klasses())-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2608   }
2609 
2610   // Initialize current biased locking state.
<span class="line-modified">2611   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {</span>
2612     set_prototype_header(markWord::biased_locking_prototype());
2613   }
2614 }
2615 
2616 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2617   switch (loader_type) {
2618   case ClassLoader::BOOT_LOADER:
2619     _misc_flags |= _misc_is_shared_boot_class;
2620     break;
2621   case ClassLoader::PLATFORM_LOADER:
2622     _misc_flags |= _misc_is_shared_platform_class;
2623     break;
2624   case ClassLoader::APP_LOADER:
2625     _misc_flags |= _misc_is_shared_app_class;
2626     break;
2627   default:
2628     ShouldNotReachHere();
2629     break;
2630   }
2631 }
</pre>
<hr />
<pre>
2708 
2709 #if INCLUDE_JVMTI
2710   // Deallocate breakpoint records
2711   if (breakpoints() != 0x0) {
2712     methods_do(clear_all_breakpoints);
2713     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2714   }
2715 
2716   // deallocate the cached class file
2717   if (_cached_class_file != NULL) {
2718     os::free(_cached_class_file);
2719     _cached_class_file = NULL;
2720   }
2721 #endif
2722 
2723   // Decrement symbol reference counts associated with the unloaded class.
2724   if (_name != NULL) _name-&gt;decrement_refcount();
2725   // unreference array name derived from this class name (arrays of an unloaded
2726   // class can&#39;t be referenced anymore).
2727   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
<span class="line-added">2728   if (_value_types != NULL) {</span>
<span class="line-added">2729     for (int i = 0; i &lt; _value_types-&gt;length(); i++) {</span>
<span class="line-added">2730       Symbol* s = _value_types-&gt;at(i)._class_name;</span>
<span class="line-added">2731       if (s != NULL) {</span>
<span class="line-added">2732         s-&gt;decrement_refcount();</span>
<span class="line-added">2733       }</span>
<span class="line-added">2734     }</span>
<span class="line-added">2735   }</span>
2736   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2737 }
2738 
2739 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2740   if (array == NULL) {
2741     _source_debug_extension = NULL;
2742   } else {
2743     // Adding one to the attribute length in order to store a null terminator
2744     // character could cause an overflow because the attribute length is
2745     // already coded with an u4 in the classfile, but in practice, it&#39;s
2746     // unlikely to happen.
2747     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2748     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2749     for (int i = 0; i &lt; length; i++) {
2750       sde[i] = array[i];
2751     }
2752     sde[length] = &#39;\0&#39;;
2753     _source_debug_extension = sde;
2754   }
2755 }
2756 
2757 const char* InstanceKlass::signature_name() const {
<span class="line-added">2758   return signature_name_of(is_value() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS);</span>
<span class="line-added">2759 }</span>
<span class="line-added">2760 </span>
<span class="line-added">2761 const char* InstanceKlass::signature_name_of(char c) const {</span>
2762   int hash_len = 0;
2763   char hash_buf[40];
2764 
2765   // If this is an unsafe anonymous class, append a hash to make the name unique
2766   if (is_unsafe_anonymous()) {
2767     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2768     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2769     hash_len = (int)strlen(hash_buf);
2770   }
2771 
2772   // Get the internal name as a c string
2773   const char* src = (const char*) (name()-&gt;as_C_string());
2774   const int src_length = (int)strlen(src);
2775 
2776   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2777 
<span class="line-modified">2778   // Add L or Q as type indicator</span>
2779   int dest_index = 0;
<span class="line-modified">2780   dest[dest_index++] = c;</span>
2781 
2782   // Add the actual class name
2783   for (int src_index = 0; src_index &lt; src_length; ) {
2784     dest[dest_index++] = src[src_index++];
2785   }
2786 
2787   // If we have a hash, append it
2788   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2789     dest[dest_index++] = hash_buf[hash_index++];
2790   }
2791 
2792   // Add the semicolon and the NULL
2793   dest[dest_index++] = JVM_SIGNATURE_ENDCLASS;
2794   dest[dest_index] = &#39;\0&#39;;
2795   return dest;
2796 }
2797 
2798 ModuleEntry* InstanceKlass::module() const {
2799   // For an unsafe anonymous class return the host class&#39; module
2800   if (is_unsafe_anonymous()) {
</pre>
<hr />
<pre>
3272   }
3273 
3274   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3275   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3276     return best;
3277   }
3278   return NULL;
3279 }
3280 
3281 // -----------------------------------------------------------------------------------------------------
3282 // Printing
3283 
3284 #ifndef PRODUCT
3285 
3286 #define BULLET  &quot; - &quot;
3287 
3288 static const char* state_names[] = {
3289   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3290 };
3291 
<span class="line-modified">3292 static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {</span>
<span class="line-added">3293   ResourceMark rm;</span>
<span class="line-added">3294   int* forward_refs = NEW_RESOURCE_ARRAY(int, len);</span>
<span class="line-added">3295   for (int i = 0; i &lt; len; i++)  forward_refs[i] = 0;</span>
3296   for (int i = 0; i &lt; len; i++) {
3297     intptr_t e = start[i];
3298     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="line-added">3299     if (forward_refs[i] != 0) {</span>
<span class="line-added">3300       int from = forward_refs[i];</span>
<span class="line-added">3301       int off = (int) start[from];</span>
<span class="line-added">3302       st-&gt;print(&quot; (offset %d &lt;= [%d])&quot;, off, from);</span>
<span class="line-added">3303     }</span>
3304     if (MetaspaceObj::is_valid((Metadata*)e)) {
3305       st-&gt;print(&quot; &quot;);
3306       ((Metadata*)e)-&gt;print_value_on(st);
<span class="line-added">3307     } else if (self != NULL &amp;&amp; e &gt; 0 &amp;&amp; e &lt; 0x10000) {</span>
<span class="line-added">3308       address location = self + e;</span>
<span class="line-added">3309       int index = (int)((intptr_t*)location - start);</span>
<span class="line-added">3310       st-&gt;print(&quot; (offset %d =&gt; [%d])&quot;, (int)e, index);</span>
<span class="line-added">3311       if (index &gt;= 0 &amp;&amp; index &lt; len)</span>
<span class="line-added">3312         forward_refs[index] = i;</span>
3313     }
3314     st-&gt;cr();
3315   }
3316 }
3317 
3318 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3319   return print_vtable(NULL, reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>
<span class="line-added">3320 }</span>
<span class="line-added">3321 </span>
<span class="line-added">3322 template&lt;typename T&gt;</span>
<span class="line-added">3323  static void print_array_on(outputStream* st, Array&lt;T&gt;* array) {</span>
<span class="line-added">3324    if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3325    array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3326    if (Verbose || WizardMode) {</span>
<span class="line-added">3327      for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3328        st-&gt;print(&quot;%d : &quot;, i); array-&gt;at(i)-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3329      }</span>
<span class="line-added">3330    }</span>
<span class="line-added">3331  }</span>
<span class="line-added">3332 </span>
<span class="line-added">3333 static void print_array_on(outputStream* st, Array&lt;int&gt;* array) {</span>
<span class="line-added">3334   if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3335   array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3336   if (Verbose || WizardMode) {</span>
<span class="line-added">3337     for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3338       st-&gt;print(&quot;%d : %d&quot;, i, array-&gt;at(i)); st-&gt;cr();</span>
<span class="line-added">3339     }</span>
<span class="line-added">3340   }</span>
3341 }
3342 
3343 void InstanceKlass::print_on(outputStream* st) const {
3344   assert(is_klass(), &quot;must be klass&quot;);
3345   Klass::print_on(st);
3346 
3347   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3348   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3349   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();
<span class="line-added">3350   st-&gt;print(BULLET&quot;misc flags:        0x%x&quot;, _misc_flags);                        st-&gt;cr();</span>
3351   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3352   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3353   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3354   st-&gt;print(BULLET&quot;sub:               &quot;);
3355   Klass* sub = subklass();
3356   int n;
3357   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3358     if (n &lt; MaxSubklassPrintSize) {
3359       sub-&gt;print_value_on(st);
3360       st-&gt;print(&quot;   &quot;);
3361     }
3362   }
3363   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3364   st-&gt;cr();
3365 
3366   if (is_interface()) {
3367     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3368     if (nof_implementors() == 1) {
3369       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3370       st-&gt;print(&quot;   &quot;);
3371       implementor()-&gt;print_value_on(st);
3372       st-&gt;cr();
3373     }
3374   }
3375 
3376   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3377   st-&gt;print(BULLET&quot;methods:           &quot;); print_array_on(st, methods());</span>
<span class="line-modified">3378   st-&gt;print(BULLET&quot;method ordering:   &quot;); print_array_on(st, method_ordering());</span>
<span class="line-modified">3379   st-&gt;print(BULLET&quot;default_methods:   &quot;); print_array_on(st, default_methods());</span>












3380   if (default_vtable_indices() != NULL) {
<span class="line-modified">3381     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); print_array_on(st, default_vtable_indices());</span>
3382   }
<span class="line-modified">3383   st-&gt;print(BULLET&quot;local interfaces:  &quot;); print_array_on(st, local_interfaces());</span>
<span class="line-modified">3384   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); print_array_on(st, transitive_interfaces());</span>
3385   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3386   if (class_loader_data() != NULL) {
3387     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3388     class_loader_data()-&gt;print_value_on(st);
3389     st-&gt;cr();
3390   }
3391   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3392   if (source_file_name() != NULL) {
3393     st-&gt;print(BULLET&quot;source file:       &quot;);
3394     source_file_name()-&gt;print_value_on(st);
3395     st-&gt;cr();
3396   }
3397   if (source_debug_extension() != NULL) {
3398     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3399     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3400     st-&gt;cr();
3401   }
3402   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3403   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3404   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3420   if (generic_signature() != NULL) {
3421     st-&gt;print(BULLET&quot;generic signature: &quot;);
3422     generic_signature()-&gt;print_value_on(st);
3423     st-&gt;cr();
3424   }
3425   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3426   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3427   if (record_components() != NULL) {
3428     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3429   }
3430   if (java_mirror() != NULL) {
3431     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3432     java_mirror()-&gt;print_value_on(st);
3433     st-&gt;cr();
3434   } else {
3435     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3436   }
3437   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3438   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3439   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3440   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(NULL, start_of_itable(), itable_length(), st);</span>
3441   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3442   FieldPrinter print_static_field(st);
3443   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3444   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3445   FieldPrinter print_nonstatic_field(st);
3446   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3447   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3448 
3449   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3450   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3451   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3452   while (map &lt; end_map) {
3453     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3454     map++;
3455   }
3456   st-&gt;cr();
3457 }
3458 
3459 #endif //PRODUCT
3460 
</pre>
<hr />
<pre>
4159   if (holder == NULL) {
4160     return NULL; // The version of klass is gone, no method is found
4161   }
4162   Method* method = holder-&gt;method_with_orig_idnum(idnum);
4163   return method;
4164 }
4165 
4166 #if INCLUDE_JVMTI
4167 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
4168   return _cached_class_file;
4169 }
4170 
4171 jint InstanceKlass::get_cached_class_file_len() {
4172   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
4173 }
4174 
4175 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
4176   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4177 }
4178 #endif
<span class="line-added">4179 </span>
<span class="line-added">4180 #define THROW_DVT_ERROR(s) \</span>
<span class="line-added">4181   Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \</span>
<span class="line-added">4182       &quot;ValueCapableClass class &#39;%s&#39; %s&quot;, external_name(),(s)); \</span>
<span class="line-added">4183       return</span>
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
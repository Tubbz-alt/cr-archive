<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/klass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_KLASS_HPP
 26 #define SHARE_OOPS_KLASS_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;memory/iterator.hpp&quot;
 30 #include &quot;memory/memRegion.hpp&quot;

 31 #include &quot;oops/markWord.hpp&quot;
 32 #include &quot;oops/metadata.hpp&quot;
 33 #include &quot;oops/oop.hpp&quot;
 34 #include &quot;oops/oopHandle.hpp&quot;
 35 #include &quot;utilities/accessFlags.hpp&quot;
 36 #include &quot;utilities/macros.hpp&quot;
 37 #if INCLUDE_JFR
 38 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 39 #endif
 40 
 41 // Klass IDs for all subclasses of Klass
 42 enum KlassID {
 43   InstanceKlassID,
 44   InstanceRefKlassID,
 45   InstanceMirrorKlassID,
 46   InstanceClassLoaderKlassID,
 47   TypeArrayKlassID,

 48   ObjArrayKlassID
 49 };
 50 
<span class="line-modified"> 51 const uint KLASS_ID_COUNT = 6;</span>
 52 
 53 //
 54 // A Klass provides:
 55 //  1: language level class object (method dictionary etc.)
 56 //  2: provide vm dispatch behavior for the object
 57 // Both functions are combined into one C++ class.
 58 
 59 // One reason for the oop/klass dichotomy in the implementation is
 60 // that we don&#39;t want a C++ vtbl pointer in every object.  Thus,
 61 // normal oops don&#39;t have any virtual functions.  Instead, they
 62 // forward all &quot;virtual&quot; functions to their klass, which does have
 63 // a vtbl and does the C++ dispatch depending on the object&#39;s
 64 // actual type.  (See oop.inline.hpp for some of the forwarding code.)
 65 // ALL FUNCTIONS IMPLEMENTING THIS DISPATCH ARE PREFIXED WITH &quot;oop_&quot;!
 66 
 67 // Forward declarations.
 68 template &lt;class T&gt; class Array;
 69 template &lt;class T&gt; class GrowableArray;
 70 class fieldDescriptor;
 71 class klassVtable;
</pre>
<hr />
<pre>
 81  protected:
 82   // If you add a new field that points to any metaspace object, you
 83   // must add this field to Klass::metaspace_pointers_do().
 84 
 85   // note: put frequently-used fields together at start of klass structure
 86   // for better cache behavior (may not make much of a difference but sure won&#39;t hurt)
 87   enum { _primary_super_limit = 8 };
 88 
 89   // The &quot;layout helper&quot; is a combined descriptor of object layout.
 90   // For klasses which are neither instance nor array, the value is zero.
 91   //
 92   // For instances, layout helper is a positive number, the instance size.
 93   // This size is already passed through align_object_size and scaled to bytes.
 94   // The low order bit is set if instances of this class cannot be
 95   // allocated using the fastpath.
 96   //
 97   // For arrays, layout helper is a negative number, containing four
 98   // distinct bytes, as follows:
 99   //    MSB:[tag, hsz, ebt, log2(esz)]:LSB
100   // where:
<span class="line-modified">101   //    tag is 0x80 if the elements are oops, 0xC0 if non-oops</span>
102   //    hsz is array header size in bytes (i.e., offset of first element)
103   //    ebt is the BasicType of the elements
104   //    esz is the element size in bytes
105   // This packed word is arranged so as to be quickly unpacked by the
106   // various fast paths that use the various subfields.
107   //
108   // The esz bits can be used directly by a SLL instruction, without masking.
109   //
110   // Note that the array-kind tag looks like 0x00 for instance klasses,
111   // since their length in bytes is always less than 24Mb.
112   //
113   // Final note:  This comes first, immediately after C++ vtable,
114   // because it is frequently queried.
115   jint        _layout_helper;
116 
117   // Klass identifier used to implement devirtualized oop closure dispatching.
118   const KlassID _id;
119 
120   // The fields _super_check_offset, _secondary_super_cache, _secondary_supers
121   // and _primary_supers all help make fast subtype checks.  See big discussion
</pre>
<hr />
<pre>
330   static ByteSize super_offset()                 { return in_ByteSize(offset_of(Klass, _super)); }
331   static ByteSize super_check_offset_offset()    { return in_ByteSize(offset_of(Klass, _super_check_offset)); }
332   static ByteSize primary_supers_offset()        { return in_ByteSize(offset_of(Klass, _primary_supers)); }
333   static ByteSize secondary_super_cache_offset() { return in_ByteSize(offset_of(Klass, _secondary_super_cache)); }
334   static ByteSize secondary_supers_offset()      { return in_ByteSize(offset_of(Klass, _secondary_supers)); }
335   static ByteSize java_mirror_offset()           { return in_ByteSize(offset_of(Klass, _java_mirror)); }
336   static ByteSize class_loader_data_offset()     { return in_ByteSize(offset_of(Klass, _class_loader_data)); }
337   static ByteSize modifier_flags_offset()        { return in_ByteSize(offset_of(Klass, _modifier_flags)); }
338   static ByteSize layout_helper_offset()         { return in_ByteSize(offset_of(Klass, _layout_helper)); }
339   static ByteSize access_flags_offset()          { return in_ByteSize(offset_of(Klass, _access_flags)); }
340 
341   // Unpacking layout_helper:
342   static const int _lh_neutral_value           = 0;  // neutral non-array non-instance value
343   static const int _lh_instance_slow_path_bit  = 0x01;
344   static const int _lh_log2_element_size_shift = BitsPerByte*0;
345   static const int _lh_log2_element_size_mask  = BitsPerLong-1;
346   static const int _lh_element_type_shift      = BitsPerByte*1;
347   static const int _lh_element_type_mask       = right_n_bits(BitsPerByte);  // shifted mask
348   static const int _lh_header_size_shift       = BitsPerByte*2;
349   static const int _lh_header_size_mask        = right_n_bits(BitsPerByte);  // shifted mask
<span class="line-modified">350   static const int _lh_array_tag_bits          = 2;</span>
351   static const int _lh_array_tag_shift         = BitsPerInt - _lh_array_tag_bits;
<span class="line-modified">352   static const int _lh_array_tag_obj_value     = ~0x01;   // 0x80000000 &gt;&gt; 30</span>
<span class="line-modified">353 </span>

354   static const unsigned int _lh_array_tag_type_value = 0Xffffffff; // ~0x00,  // 0xC0000000 &gt;&gt; 30
355 
356   static int layout_helper_size_in_bytes(jint lh) {
357     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
358     return (int) lh &amp; ~_lh_instance_slow_path_bit;
359   }
360   static bool layout_helper_needs_slow_path(jint lh) {
361     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
362     return (lh &amp; _lh_instance_slow_path_bit) != 0;
363   }
364   static bool layout_helper_is_instance(jint lh) {
365     return (jint)lh &gt; (jint)_lh_neutral_value;
366   }
367   static bool layout_helper_is_array(jint lh) {
368     return (jint)lh &lt; (jint)_lh_neutral_value;
369   }
370   static bool layout_helper_is_typeArray(jint lh) {
<span class="line-modified">371     // _lh_array_tag_type_value == (lh &gt;&gt; _lh_array_tag_shift);</span>
<span class="line-removed">372     return (juint)lh &gt;= (juint)(_lh_array_tag_type_value &lt;&lt; _lh_array_tag_shift);</span>
373   }
374   static bool layout_helper_is_objArray(jint lh) {
<span class="line-modified">375     // _lh_array_tag_obj_value == (lh &gt;&gt; _lh_array_tag_shift);</span>
<span class="line-modified">376     return (jint)lh &lt; (jint)(_lh_array_tag_type_value &lt;&lt; _lh_array_tag_shift);</span>


377   }
378   static int layout_helper_header_size(jint lh) {
379     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
380     int hsize = (lh &gt;&gt; _lh_header_size_shift) &amp; _lh_header_size_mask;
381     assert(hsize &gt; 0 &amp;&amp; hsize &lt; (int)sizeof(oopDesc)*3, &quot;sanity&quot;);
382     return hsize;
383   }
384   static BasicType layout_helper_element_type(jint lh) {
385     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
386     int btvalue = (lh &gt;&gt; _lh_element_type_shift) &amp; _lh_element_type_mask;
<span class="line-modified">387     assert(btvalue &gt;= T_BOOLEAN &amp;&amp; btvalue &lt;= T_OBJECT, &quot;sanity&quot;);</span>
388     return (BasicType) btvalue;
389   }
390 
391   // Want a pattern to quickly diff against layout header in register
392   // find something less clever!
393   static int layout_helper_boolean_diffbit() {
394     jint zlh = array_layout_helper(T_BOOLEAN);
395     jint blh = array_layout_helper(T_BYTE);
396     assert(zlh != blh, &quot;array layout helpers must differ&quot;);
397     int diffbit = 1;
398     while ((diffbit &amp; (zlh ^ blh)) == 0 &amp;&amp; (diffbit &amp; zlh) == 0) {
399       diffbit &lt;&lt;= 1;
400       assert(diffbit != 0, &quot;make sure T_BOOLEAN has a different bit than T_BYTE&quot;);
401     }
402     return diffbit;
403   }
404 
405   static int layout_helper_log2_element_size(jint lh) {
406     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
407     int l2esz = (lh &gt;&gt; _lh_log2_element_size_shift) &amp; _lh_log2_element_size_mask;
<span class="line-modified">408     assert(l2esz &lt;= LogBytesPerLong,</span>
409            &quot;sanity. l2esz: 0x%x for lh: 0x%x&quot;, (uint)l2esz, (uint)lh);
410     return l2esz;
411   }
412   static jint array_layout_helper(jint tag, int hsize, BasicType etype, int log2_esize) {
413     return (tag        &lt;&lt; _lh_array_tag_shift)
414       |    (hsize      &lt;&lt; _lh_header_size_shift)
415       |    ((int)etype &lt;&lt; _lh_element_type_shift)
416       |    (log2_esize &lt;&lt; _lh_log2_element_size_shift);
417   }
418   static jint instance_layout_helper(jint size, bool slow_path_flag) {
419     return (size &lt;&lt; LogBytesPerWord)
420       |    (slow_path_flag ? _lh_instance_slow_path_bit : 0);
421   }
422   static int layout_helper_to_size_helper(jint lh) {
423     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
424     // Note that the following expression discards _lh_instance_slow_path_bit.
425     return lh &gt;&gt; LogBytesPerWord;
426   }
427   // Out-of-line version computes everything based on the etype:
428   static jint array_layout_helper(BasicType etype);
</pre>
<hr />
<pre>
459   // if not, throw either an Error or an Exception.
460   virtual void check_valid_for_instantiation(bool throwError, TRAPS);
461 
462   // array copying
463   virtual void  copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS);
464 
465   // tells if the class should be initialized
466   virtual bool should_be_initialized() const    { return false; }
467   // initializes the klass
468   virtual void initialize(TRAPS);
469   virtual Klass* find_field(Symbol* name, Symbol* signature, fieldDescriptor* fd) const;
470   virtual Method* uncached_lookup_method(const Symbol* name, const Symbol* signature,
471                                          OverpassLookupMode overpass_mode,
472                                          PrivateLookupMode = find_private) const;
473  public:
474   Method* lookup_method(const Symbol* name, const Symbol* signature) const {
475     return uncached_lookup_method(name, signature, find_overpass);
476   }
477 
478   // array class with specific rank
<span class="line-modified">479   Klass* array_klass(int rank, TRAPS)         {  return array_klass_impl(false, rank, THREAD); }</span>






480 
481   // array class with this klass as element type
<span class="line-modified">482   Klass* array_klass(TRAPS)                   {  return array_klass_impl(false, THREAD); }</span>






483 
484   // These will return NULL instead of allocating on the heap:
485   // NB: these can block for a mutex, like other functions with TRAPS arg.
<span class="line-modified">486   Klass* array_klass_or_null(int rank);</span>
<span class="line-modified">487   Klass* array_klass_or_null();</span>
488 
489   virtual oop protection_domain() const = 0;
490 
491   oop class_loader() const;
492 
493   // This loads the klass&#39;s holder as a phantom. This is useful when a weak Klass
494   // pointer has been &quot;peeked&quot; and then must be kept alive before it may
495   // be used safely.  All uses of klass_holder need to apply the appropriate barriers,
496   // except during GC.
497   oop klass_holder() const { return class_loader_data()-&gt;holder_phantom(); }
498 
499  protected:
<span class="line-modified">500   virtual Klass* array_klass_impl(bool or_null, int rank, TRAPS);</span>
<span class="line-modified">501   virtual Klass* array_klass_impl(bool or_null, TRAPS);</span>
502 
503   // Error handling when length &gt; max_length or length &lt; 0
504   static void check_array_allocation_length(int length, int max_length, TRAPS);
505 
506   void set_vtable_length(int len) { _vtable_len= len; }
507 
508   vtableEntry* start_of_vtable() const;
509   void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS);
510  public:
511   Method* method_at_vtable(int index);
512 
513   static ByteSize vtable_start_offset();
514   static ByteSize vtable_length_offset() {
515     return byte_offset_of(Klass, _vtable_len);
516   }
517 
518   // CDS support - remove and restore oops from metadata. Oops are not shared.
519   virtual void remove_unshareable_info();
520   virtual void remove_java_mirror();
521 
</pre>
<hr />
<pre>
534  public:
535   // ALL FUNCTIONS BELOW THIS POINT ARE DISPATCHED FROM AN OOP
536   // These functions describe behavior for the oop not the KLASS.
537 
538   // actual oop size of obj in memory
539   virtual int oop_size(oop obj) const = 0;
540 
541   // Size of klass in word size.
542   virtual int size() const = 0;
543 
544   // Returns the Java name for a class (Resource allocated)
545   // For arrays, this returns the name of the element with a leading &#39;[&#39;.
546   // For classes, this returns the name with the package separators
547   //     turned into &#39;.&#39;s.
548   const char* external_name() const;
549   // Returns the name for a class (Resource allocated) as the class
550   // would appear in a signature.
551   // For arrays, this returns the name of the element with a leading &#39;[&#39;.
552   // For classes, this returns the name with a leading &#39;L&#39; and a trailing &#39;;&#39;
553   //     and the package separators as &#39;/&#39;.


554   virtual const char* signature_name() const;
555 
556   const char* joint_in_module_of_loader(const Klass* class2, bool include_parent_loader = false) const;
557   const char* class_in_module_of_loader(bool use_are = false, bool include_parent_loader = false) const;
558 
559   // Returns &quot;interface&quot;, &quot;abstract class&quot; or &quot;class&quot;.
560   const char* external_kind() const;
561 
562   // type testing operations
563 #ifdef ASSERT
564  protected:
565   virtual bool is_instance_klass_slow()     const { return false; }
566   virtual bool is_array_klass_slow()        const { return false; }
567   virtual bool is_objArray_klass_slow()     const { return false; }
568   virtual bool is_typeArray_klass_slow()    const { return false; }

569 #endif // ASSERT


570  public:
571 
572   // Fast non-virtual versions
573   #ifndef ASSERT
574   #define assert_same_query(xval, xcheck) xval
575   #else
576  private:
577   static bool assert_same_query(bool xval, bool xslow) {
578     assert(xval == xslow, &quot;slow and fast queries agree&quot;);
579     return xval;
580   }
581  public:
582   #endif
583   inline  bool is_instance_klass()            const { return assert_same_query(
584                                                       layout_helper_is_instance(layout_helper()),
585                                                       is_instance_klass_slow()); }
586   inline  bool is_array_klass()               const { return assert_same_query(
587                                                     layout_helper_is_array(layout_helper()),
588                                                     is_array_klass_slow()); }
589   inline  bool is_objArray_klass()            const { return assert_same_query(
590                                                     layout_helper_is_objArray(layout_helper()),
591                                                     is_objArray_klass_slow()); }
592   inline  bool is_typeArray_klass()           const { return assert_same_query(
593                                                     layout_helper_is_typeArray(layout_helper()),
594                                                     is_typeArray_klass_slow()); }





595   #undef assert_same_query
596 
597   // Access flags
598   AccessFlags access_flags() const         { return _access_flags;  }
599   void set_access_flags(AccessFlags flags) { _access_flags = flags; }
600 
601   bool is_public() const                { return _access_flags.is_public(); }
602   bool is_final() const                 { return _access_flags.is_final(); }
603   bool is_interface() const             { return _access_flags.is_interface(); }
604   bool is_abstract() const              { return _access_flags.is_abstract(); }
605   bool is_super() const                 { return _access_flags.is_super(); }
606   bool is_synthetic() const             { return _access_flags.is_synthetic(); }
607   void set_is_synthetic()               { _access_flags.set_is_synthetic(); }
608   bool has_finalizer() const            { return _access_flags.has_finalizer(); }
609   bool has_final_method() const         { return _access_flags.has_final_method(); }
610   void set_has_finalizer()              { _access_flags.set_has_finalizer(); }
611   void set_has_final_method()           { _access_flags.set_has_final_method(); }
612   bool has_vanilla_constructor() const  { return _access_flags.has_vanilla_constructor(); }
613   void set_has_vanilla_constructor()    { _access_flags.set_has_vanilla_constructor(); }
614   bool has_miranda_methods () const     { return access_flags().has_miranda_methods(); }
615   void set_has_miranda_methods()        { _access_flags.set_has_miranda_methods(); }
616   bool is_shared() const                { return access_flags().is_shared_class(); } // shadows MetaspaceObj::is_shared)()
617   void set_is_shared()                  { _access_flags.set_is_shared_class(); }
618 
619   bool is_cloneable() const;
620   void set_is_cloneable();
621 
622   // Biased locking support
623   // Note: the prototype header is always set up to be at least the
624   // prototype markWord. If biased locking is enabled it may further be
625   // biasable and have an epoch.
<span class="line-modified">626   markWord prototype_header() const      { return _prototype_header; }</span>




627   // NOTE: once instances of this klass are floating around in the
628   // system, this header must only be updated at a safepoint.
629   // NOTE 2: currently we only ever set the prototype header to the
630   // biasable prototype for instanceKlasses. There is no technical
631   // reason why it could not be done for arrayKlasses aside from
632   // wanting to reduce the initial scope of this optimization. There
633   // are potential problems in setting the bias pattern for
634   // JVM-internal oops.
635   inline void set_prototype_header(markWord header);
636   static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }
637 
638   int  biased_lock_revocation_count() const { return (int) _biased_lock_revocation_count; }
639   // Atomically increments biased_lock_revocation_count and returns updated value
640   int atomic_incr_biased_lock_revocation_count();
641   void set_biased_lock_revocation_count(int val) { _biased_lock_revocation_count = (jint) val; }
642   jlong last_biased_lock_bulk_revocation_time() { return _last_biased_lock_bulk_revocation_time; }
643   void  set_last_biased_lock_bulk_revocation_time(jlong cur_time) { _last_biased_lock_bulk_revocation_time = cur_time; }
644 
645   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
646 
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_KLASS_HPP
 26 #define SHARE_OOPS_KLASS_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;memory/iterator.hpp&quot;
 30 #include &quot;memory/memRegion.hpp&quot;
<span class="line-added"> 31 #include &quot;oops/arrayStorageProperties.hpp&quot;</span>
 32 #include &quot;oops/markWord.hpp&quot;
 33 #include &quot;oops/metadata.hpp&quot;
 34 #include &quot;oops/oop.hpp&quot;
 35 #include &quot;oops/oopHandle.hpp&quot;
 36 #include &quot;utilities/accessFlags.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 #if INCLUDE_JFR
 39 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 40 #endif
 41 
 42 // Klass IDs for all subclasses of Klass
 43 enum KlassID {
 44   InstanceKlassID,
 45   InstanceRefKlassID,
 46   InstanceMirrorKlassID,
 47   InstanceClassLoaderKlassID,
 48   TypeArrayKlassID,
<span class="line-added"> 49   ValueArrayKlassID,</span>
 50   ObjArrayKlassID
 51 };
 52 
<span class="line-modified"> 53 const uint KLASS_ID_COUNT = 7;</span>
 54 
 55 //
 56 // A Klass provides:
 57 //  1: language level class object (method dictionary etc.)
 58 //  2: provide vm dispatch behavior for the object
 59 // Both functions are combined into one C++ class.
 60 
 61 // One reason for the oop/klass dichotomy in the implementation is
 62 // that we don&#39;t want a C++ vtbl pointer in every object.  Thus,
 63 // normal oops don&#39;t have any virtual functions.  Instead, they
 64 // forward all &quot;virtual&quot; functions to their klass, which does have
 65 // a vtbl and does the C++ dispatch depending on the object&#39;s
 66 // actual type.  (See oop.inline.hpp for some of the forwarding code.)
 67 // ALL FUNCTIONS IMPLEMENTING THIS DISPATCH ARE PREFIXED WITH &quot;oop_&quot;!
 68 
 69 // Forward declarations.
 70 template &lt;class T&gt; class Array;
 71 template &lt;class T&gt; class GrowableArray;
 72 class fieldDescriptor;
 73 class klassVtable;
</pre>
<hr />
<pre>
 83  protected:
 84   // If you add a new field that points to any metaspace object, you
 85   // must add this field to Klass::metaspace_pointers_do().
 86 
 87   // note: put frequently-used fields together at start of klass structure
 88   // for better cache behavior (may not make much of a difference but sure won&#39;t hurt)
 89   enum { _primary_super_limit = 8 };
 90 
 91   // The &quot;layout helper&quot; is a combined descriptor of object layout.
 92   // For klasses which are neither instance nor array, the value is zero.
 93   //
 94   // For instances, layout helper is a positive number, the instance size.
 95   // This size is already passed through align_object_size and scaled to bytes.
 96   // The low order bit is set if instances of this class cannot be
 97   // allocated using the fastpath.
 98   //
 99   // For arrays, layout helper is a negative number, containing four
100   // distinct bytes, as follows:
101   //    MSB:[tag, hsz, ebt, log2(esz)]:LSB
102   // where:
<span class="line-modified">103   //    tag is 0x80 if the elements are oops, 0xC0 if non-oops, 0xA0 if value types</span>
104   //    hsz is array header size in bytes (i.e., offset of first element)
105   //    ebt is the BasicType of the elements
106   //    esz is the element size in bytes
107   // This packed word is arranged so as to be quickly unpacked by the
108   // various fast paths that use the various subfields.
109   //
110   // The esz bits can be used directly by a SLL instruction, without masking.
111   //
112   // Note that the array-kind tag looks like 0x00 for instance klasses,
113   // since their length in bytes is always less than 24Mb.
114   //
115   // Final note:  This comes first, immediately after C++ vtable,
116   // because it is frequently queried.
117   jint        _layout_helper;
118 
119   // Klass identifier used to implement devirtualized oop closure dispatching.
120   const KlassID _id;
121 
122   // The fields _super_check_offset, _secondary_super_cache, _secondary_supers
123   // and _primary_supers all help make fast subtype checks.  See big discussion
</pre>
<hr />
<pre>
332   static ByteSize super_offset()                 { return in_ByteSize(offset_of(Klass, _super)); }
333   static ByteSize super_check_offset_offset()    { return in_ByteSize(offset_of(Klass, _super_check_offset)); }
334   static ByteSize primary_supers_offset()        { return in_ByteSize(offset_of(Klass, _primary_supers)); }
335   static ByteSize secondary_super_cache_offset() { return in_ByteSize(offset_of(Klass, _secondary_super_cache)); }
336   static ByteSize secondary_supers_offset()      { return in_ByteSize(offset_of(Klass, _secondary_supers)); }
337   static ByteSize java_mirror_offset()           { return in_ByteSize(offset_of(Klass, _java_mirror)); }
338   static ByteSize class_loader_data_offset()     { return in_ByteSize(offset_of(Klass, _class_loader_data)); }
339   static ByteSize modifier_flags_offset()        { return in_ByteSize(offset_of(Klass, _modifier_flags)); }
340   static ByteSize layout_helper_offset()         { return in_ByteSize(offset_of(Klass, _layout_helper)); }
341   static ByteSize access_flags_offset()          { return in_ByteSize(offset_of(Klass, _access_flags)); }
342 
343   // Unpacking layout_helper:
344   static const int _lh_neutral_value           = 0;  // neutral non-array non-instance value
345   static const int _lh_instance_slow_path_bit  = 0x01;
346   static const int _lh_log2_element_size_shift = BitsPerByte*0;
347   static const int _lh_log2_element_size_mask  = BitsPerLong-1;
348   static const int _lh_element_type_shift      = BitsPerByte*1;
349   static const int _lh_element_type_mask       = right_n_bits(BitsPerByte);  // shifted mask
350   static const int _lh_header_size_shift       = BitsPerByte*2;
351   static const int _lh_header_size_mask        = right_n_bits(BitsPerByte);  // shifted mask
<span class="line-modified">352   static const int _lh_array_tag_bits          = 3;</span>
353   static const int _lh_array_tag_shift         = BitsPerInt - _lh_array_tag_bits;
<span class="line-modified">354 </span>
<span class="line-modified">355   static const unsigned int _lh_array_tag_type_value = 0Xfffffffc;</span>
<span class="line-added">356   static const unsigned int _lh_array_tag_vt_value   = 0Xfffffffd;</span>
357   static const unsigned int _lh_array_tag_obj_value  = 0Xfffffffe;
358 
359   static int layout_helper_size_in_bytes(jint lh) {
360     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
361     return (int) lh &amp; ~_lh_instance_slow_path_bit;
362   }
363   static bool layout_helper_needs_slow_path(jint lh) {
364     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
365     return (lh &amp; _lh_instance_slow_path_bit) != 0;
366   }
367   static bool layout_helper_is_instance(jint lh) {
368     return (jint)lh &gt; (jint)_lh_neutral_value;
369   }
370   static bool layout_helper_is_array(jint lh) {
371     return (jint)lh &lt; (jint)_lh_neutral_value;
372   }
373   static bool layout_helper_is_typeArray(jint lh) {
<span class="line-modified">374     return (juint) _lh_array_tag_type_value == (juint)(lh &gt;&gt; _lh_array_tag_shift);</span>

375   }
376   static bool layout_helper_is_objArray(jint lh) {
<span class="line-modified">377     return (juint)_lh_array_tag_obj_value == (juint)(lh &gt;&gt; _lh_array_tag_shift);</span>
<span class="line-modified">378   }</span>
<span class="line-added">379   static bool layout_helper_is_valueArray(jint lh) {</span>
<span class="line-added">380     return (juint)_lh_array_tag_vt_value == (juint)(lh &gt;&gt; _lh_array_tag_shift);</span>
381   }
382   static int layout_helper_header_size(jint lh) {
383     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
384     int hsize = (lh &gt;&gt; _lh_header_size_shift) &amp; _lh_header_size_mask;
385     assert(hsize &gt; 0 &amp;&amp; hsize &lt; (int)sizeof(oopDesc)*3, &quot;sanity&quot;);
386     return hsize;
387   }
388   static BasicType layout_helper_element_type(jint lh) {
389     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
390     int btvalue = (lh &gt;&gt; _lh_element_type_shift) &amp; _lh_element_type_mask;
<span class="line-modified">391     assert((btvalue &gt;= T_BOOLEAN &amp;&amp; btvalue &lt;= T_OBJECT) || btvalue == T_VALUETYPE, &quot;sanity&quot;);</span>
392     return (BasicType) btvalue;
393   }
394 
395   // Want a pattern to quickly diff against layout header in register
396   // find something less clever!
397   static int layout_helper_boolean_diffbit() {
398     jint zlh = array_layout_helper(T_BOOLEAN);
399     jint blh = array_layout_helper(T_BYTE);
400     assert(zlh != blh, &quot;array layout helpers must differ&quot;);
401     int diffbit = 1;
402     while ((diffbit &amp; (zlh ^ blh)) == 0 &amp;&amp; (diffbit &amp; zlh) == 0) {
403       diffbit &lt;&lt;= 1;
404       assert(diffbit != 0, &quot;make sure T_BOOLEAN has a different bit than T_BYTE&quot;);
405     }
406     return diffbit;
407   }
408 
409   static int layout_helper_log2_element_size(jint lh) {
410     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
411     int l2esz = (lh &gt;&gt; _lh_log2_element_size_shift) &amp; _lh_log2_element_size_mask;
<span class="line-modified">412     assert(layout_helper_element_type(lh) == T_VALUETYPE || l2esz &lt;= LogBytesPerLong,</span>
413            &quot;sanity. l2esz: 0x%x for lh: 0x%x&quot;, (uint)l2esz, (uint)lh);
414     return l2esz;
415   }
416   static jint array_layout_helper(jint tag, int hsize, BasicType etype, int log2_esize) {
417     return (tag        &lt;&lt; _lh_array_tag_shift)
418       |    (hsize      &lt;&lt; _lh_header_size_shift)
419       |    ((int)etype &lt;&lt; _lh_element_type_shift)
420       |    (log2_esize &lt;&lt; _lh_log2_element_size_shift);
421   }
422   static jint instance_layout_helper(jint size, bool slow_path_flag) {
423     return (size &lt;&lt; LogBytesPerWord)
424       |    (slow_path_flag ? _lh_instance_slow_path_bit : 0);
425   }
426   static int layout_helper_to_size_helper(jint lh) {
427     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
428     // Note that the following expression discards _lh_instance_slow_path_bit.
429     return lh &gt;&gt; LogBytesPerWord;
430   }
431   // Out-of-line version computes everything based on the etype:
432   static jint array_layout_helper(BasicType etype);
</pre>
<hr />
<pre>
463   // if not, throw either an Error or an Exception.
464   virtual void check_valid_for_instantiation(bool throwError, TRAPS);
465 
466   // array copying
467   virtual void  copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS);
468 
469   // tells if the class should be initialized
470   virtual bool should_be_initialized() const    { return false; }
471   // initializes the klass
472   virtual void initialize(TRAPS);
473   virtual Klass* find_field(Symbol* name, Symbol* signature, fieldDescriptor* fd) const;
474   virtual Method* uncached_lookup_method(const Symbol* name, const Symbol* signature,
475                                          OverpassLookupMode overpass_mode,
476                                          PrivateLookupMode = find_private) const;
477  public:
478   Method* lookup_method(const Symbol* name, const Symbol* signature) const {
479     return uncached_lookup_method(name, signature, find_overpass);
480   }
481 
482   // array class with specific rank
<span class="line-modified">483   Klass* array_klass(int rank, TRAPS) {</span>
<span class="line-added">484     return array_klass_impl(ArrayStorageProperties::empty, false, rank, THREAD);</span>
<span class="line-added">485   }</span>
<span class="line-added">486 </span>
<span class="line-added">487   Klass* array_klass(ArrayStorageProperties storage_props, int rank, TRAPS) {</span>
<span class="line-added">488     return array_klass_impl(storage_props, false, rank, THREAD);</span>
<span class="line-added">489   }</span>
490 
491   // array class with this klass as element type
<span class="line-modified">492   Klass* array_klass(TRAPS) {</span>
<span class="line-added">493     return array_klass_impl(ArrayStorageProperties::empty, false, THREAD);</span>
<span class="line-added">494   }</span>
<span class="line-added">495 </span>
<span class="line-added">496   Klass* array_klass(ArrayStorageProperties storage_props, TRAPS) {</span>
<span class="line-added">497     return array_klass_impl(storage_props, false, THREAD);</span>
<span class="line-added">498   }</span>
499 
500   // These will return NULL instead of allocating on the heap:
501   // NB: these can block for a mutex, like other functions with TRAPS arg.
<span class="line-modified">502   Klass* array_klass_or_null(ArrayStorageProperties storage_props, int rank);</span>
<span class="line-modified">503   Klass* array_klass_or_null(ArrayStorageProperties storage_props);</span>
504 
505   virtual oop protection_domain() const = 0;
506 
507   oop class_loader() const;
508 
509   // This loads the klass&#39;s holder as a phantom. This is useful when a weak Klass
510   // pointer has been &quot;peeked&quot; and then must be kept alive before it may
511   // be used safely.  All uses of klass_holder need to apply the appropriate barriers,
512   // except during GC.
513   oop klass_holder() const { return class_loader_data()-&gt;holder_phantom(); }
514 
515  protected:
<span class="line-modified">516   virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int rank, TRAPS);</span>
<span class="line-modified">517   virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS);</span>
518 
519   // Error handling when length &gt; max_length or length &lt; 0
520   static void check_array_allocation_length(int length, int max_length, TRAPS);
521 
522   void set_vtable_length(int len) { _vtable_len= len; }
523 
524   vtableEntry* start_of_vtable() const;
525   void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS);
526  public:
527   Method* method_at_vtable(int index);
528 
529   static ByteSize vtable_start_offset();
530   static ByteSize vtable_length_offset() {
531     return byte_offset_of(Klass, _vtable_len);
532   }
533 
534   // CDS support - remove and restore oops from metadata. Oops are not shared.
535   virtual void remove_unshareable_info();
536   virtual void remove_java_mirror();
537 
</pre>
<hr />
<pre>
550  public:
551   // ALL FUNCTIONS BELOW THIS POINT ARE DISPATCHED FROM AN OOP
552   // These functions describe behavior for the oop not the KLASS.
553 
554   // actual oop size of obj in memory
555   virtual int oop_size(oop obj) const = 0;
556 
557   // Size of klass in word size.
558   virtual int size() const = 0;
559 
560   // Returns the Java name for a class (Resource allocated)
561   // For arrays, this returns the name of the element with a leading &#39;[&#39;.
562   // For classes, this returns the name with the package separators
563   //     turned into &#39;.&#39;s.
564   const char* external_name() const;
565   // Returns the name for a class (Resource allocated) as the class
566   // would appear in a signature.
567   // For arrays, this returns the name of the element with a leading &#39;[&#39;.
568   // For classes, this returns the name with a leading &#39;L&#39; and a trailing &#39;;&#39;
569   //     and the package separators as &#39;/&#39;.
<span class="line-added">570   // For value classes, this returns the name with a leading &#39;Q&#39; and a trailing &#39;;&#39;</span>
<span class="line-added">571   //     and the package separators as &#39;/&#39;.</span>
572   virtual const char* signature_name() const;
573 
574   const char* joint_in_module_of_loader(const Klass* class2, bool include_parent_loader = false) const;
575   const char* class_in_module_of_loader(bool use_are = false, bool include_parent_loader = false) const;
576 
577   // Returns &quot;interface&quot;, &quot;abstract class&quot; or &quot;class&quot;.
578   const char* external_kind() const;
579 
580   // type testing operations
581 #ifdef ASSERT
582  protected:
583   virtual bool is_instance_klass_slow()     const { return false; }
584   virtual bool is_array_klass_slow()        const { return false; }
585   virtual bool is_objArray_klass_slow()     const { return false; }
586   virtual bool is_typeArray_klass_slow()    const { return false; }
<span class="line-added">587   virtual bool is_valueArray_klass_slow()   const { return false; }</span>
588 #endif // ASSERT
<span class="line-added">589   // current implementation uses this method even in non debug builds</span>
<span class="line-added">590   virtual bool is_value_slow()          const { return false; }</span>
591  public:
592 
593   // Fast non-virtual versions
594   #ifndef ASSERT
595   #define assert_same_query(xval, xcheck) xval
596   #else
597  private:
598   static bool assert_same_query(bool xval, bool xslow) {
599     assert(xval == xslow, &quot;slow and fast queries agree&quot;);
600     return xval;
601   }
602  public:
603   #endif
604   inline  bool is_instance_klass()            const { return assert_same_query(
605                                                       layout_helper_is_instance(layout_helper()),
606                                                       is_instance_klass_slow()); }
607   inline  bool is_array_klass()               const { return assert_same_query(
608                                                     layout_helper_is_array(layout_helper()),
609                                                     is_array_klass_slow()); }
610   inline  bool is_objArray_klass()            const { return assert_same_query(
611                                                     layout_helper_is_objArray(layout_helper()),
612                                                     is_objArray_klass_slow()); }
613   inline  bool is_typeArray_klass()           const { return assert_same_query(
614                                                     layout_helper_is_typeArray(layout_helper()),
615                                                     is_typeArray_klass_slow()); }
<span class="line-added">616   inline  bool is_value()                     const { return is_value_slow(); } //temporary hack</span>
<span class="line-added">617   inline  bool is_valueArray_klass()          const { return assert_same_query(</span>
<span class="line-added">618                                                     layout_helper_is_valueArray(layout_helper()),</span>
<span class="line-added">619                                                     is_valueArray_klass_slow()); }</span>
<span class="line-added">620 </span>
621   #undef assert_same_query
622 
623   // Access flags
624   AccessFlags access_flags() const         { return _access_flags;  }
625   void set_access_flags(AccessFlags flags) { _access_flags = flags; }
626 
627   bool is_public() const                { return _access_flags.is_public(); }
628   bool is_final() const                 { return _access_flags.is_final(); }
629   bool is_interface() const             { return _access_flags.is_interface(); }
630   bool is_abstract() const              { return _access_flags.is_abstract(); }
631   bool is_super() const                 { return _access_flags.is_super(); }
632   bool is_synthetic() const             { return _access_flags.is_synthetic(); }
633   void set_is_synthetic()               { _access_flags.set_is_synthetic(); }
634   bool has_finalizer() const            { return _access_flags.has_finalizer(); }
635   bool has_final_method() const         { return _access_flags.has_final_method(); }
636   void set_has_finalizer()              { _access_flags.set_has_finalizer(); }
637   void set_has_final_method()           { _access_flags.set_has_final_method(); }
638   bool has_vanilla_constructor() const  { return _access_flags.has_vanilla_constructor(); }
639   void set_has_vanilla_constructor()    { _access_flags.set_has_vanilla_constructor(); }
640   bool has_miranda_methods () const     { return access_flags().has_miranda_methods(); }
641   void set_has_miranda_methods()        { _access_flags.set_has_miranda_methods(); }
642   bool is_shared() const                { return access_flags().is_shared_class(); } // shadows MetaspaceObj::is_shared)()
643   void set_is_shared()                  { _access_flags.set_is_shared_class(); }
644 
645   bool is_cloneable() const;
646   void set_is_cloneable();
647 
648   // Biased locking support
649   // Note: the prototype header is always set up to be at least the
650   // prototype markWord. If biased locking is enabled it may further be
651   // biasable and have an epoch.
<span class="line-modified">652   markWord prototype_header() const     { return _prototype_header; }</span>
<span class="line-added">653   static inline markWord default_prototype_header(Klass* k) {</span>
<span class="line-added">654     return (k == NULL) ? markWord::prototype() : k-&gt;prototype_header();</span>
<span class="line-added">655   }</span>
<span class="line-added">656 </span>
657   // NOTE: once instances of this klass are floating around in the
658   // system, this header must only be updated at a safepoint.
659   // NOTE 2: currently we only ever set the prototype header to the
660   // biasable prototype for instanceKlasses. There is no technical
661   // reason why it could not be done for arrayKlasses aside from
662   // wanting to reduce the initial scope of this optimization. There
663   // are potential problems in setting the bias pattern for
664   // JVM-internal oops.
665   inline void set_prototype_header(markWord header);
666   static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }
667 
668   int  biased_lock_revocation_count() const { return (int) _biased_lock_revocation_count; }
669   // Atomically increments biased_lock_revocation_count and returns updated value
670   int atomic_incr_biased_lock_revocation_count();
671   void set_biased_lock_revocation_count(int val) { _biased_lock_revocation_count = (jint) val; }
672   jlong last_biased_lock_bulk_revocation_time() { return _last_biased_lock_bulk_revocation_time; }
673   void  set_last_biased_lock_bulk_revocation_time(jlong cur_time) { _last_biased_lock_bulk_revocation_time = cur_time; }
674 
675   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
676 
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
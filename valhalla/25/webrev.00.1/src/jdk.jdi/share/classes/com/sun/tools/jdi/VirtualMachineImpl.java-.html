<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.jdi;
  27 
  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.SoftReference;
  31 import java.text.MessageFormat;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Set;
  41 import java.util.function.Consumer;
  42 
  43 import com.sun.jdi.BooleanType;
  44 import com.sun.jdi.BooleanValue;
  45 import com.sun.jdi.ByteType;
  46 import com.sun.jdi.ByteValue;
  47 import com.sun.jdi.CharType;
  48 import com.sun.jdi.CharValue;
  49 import com.sun.jdi.ClassLoaderReference;
  50 import com.sun.jdi.ClassNotLoadedException;
  51 import com.sun.jdi.DoubleType;
  52 import com.sun.jdi.DoubleValue;
  53 import com.sun.jdi.FloatType;
  54 import com.sun.jdi.FloatValue;
  55 import com.sun.jdi.IntegerType;
  56 import com.sun.jdi.IntegerValue;
  57 import com.sun.jdi.InternalException;
  58 import com.sun.jdi.LongType;
  59 import com.sun.jdi.LongValue;
  60 import com.sun.jdi.ModuleReference;
  61 import com.sun.jdi.ObjectCollectedException;
  62 import com.sun.jdi.PathSearchingVirtualMachine;
  63 import com.sun.jdi.PrimitiveType;
  64 import com.sun.jdi.ReferenceType;
  65 import com.sun.jdi.ShortType;
  66 import com.sun.jdi.ShortValue;
  67 import com.sun.jdi.StringReference;
  68 import com.sun.jdi.ThreadGroupReference;
  69 import com.sun.jdi.ThreadReference;
  70 import com.sun.jdi.Type;
  71 import com.sun.jdi.VMDisconnectedException;
  72 import com.sun.jdi.VirtualMachine;
  73 import com.sun.jdi.VirtualMachineManager;
  74 import com.sun.jdi.VoidType;
  75 import com.sun.jdi.VoidValue;
  76 import com.sun.jdi.connect.spi.Connection;
  77 import com.sun.jdi.event.EventQueue;
  78 import com.sun.jdi.request.BreakpointRequest;
  79 import com.sun.jdi.request.EventRequest;
  80 import com.sun.jdi.request.EventRequestManager;
  81 
  82 class VirtualMachineImpl extends MirrorImpl
  83              implements PathSearchingVirtualMachine, ThreadListener {
  84     // VM Level exported variables, these
  85     // are unique to a given vm
  86     public final int sizeofFieldRef;
  87     public final int sizeofMethodRef;
  88     public final int sizeofObjectRef;
  89     public final int sizeofClassRef;
  90     public final int sizeofFrameRef;
  91     public final int sizeofModuleRef;
  92 
  93     final int sequenceNumber;
  94 
  95     private final TargetVM target;
  96     private final EventQueueImpl eventQueue;
  97     private final EventRequestManagerImpl internalEventRequestManager;
  98     private final EventRequestManagerImpl eventRequestManager;
  99     final VirtualMachineManagerImpl vmManager;
 100     private final ThreadGroup threadGroupForJDI;
 101 
 102     // Allow direct access to this field so that that tracing code slows down
 103     // JDI as little as possible when not enabled.
 104     int traceFlags = TRACE_NONE;
 105 
 106     static int TRACE_RAW_SENDS     = 0x01000000;
 107     static int TRACE_RAW_RECEIVES  = 0x02000000;
 108 
 109     boolean traceReceives = false;   // pre-compute because of frequency
 110 
 111     // ReferenceType access - updated with class prepare and unload events
 112     // Protected by &quot;synchronized(this)&quot;. &quot;retrievedAllTypes&quot; may be
 113     // tested unsynchronized (since once true, it stays true), but must
 114     // be set synchronously
 115     private Map&lt;Long, ReferenceType&gt; typesByID;
 116     private Set&lt;ReferenceType&gt; typesBySignature;
 117     private boolean retrievedAllTypes = false;
 118 
 119     private Map&lt;Long, ModuleReference&gt; modulesByID;
 120 
 121     // For other languages support
 122     private String defaultStratum = null;
 123 
 124     // ObjectReference cache
 125     // &quot;objectsByID&quot; protected by &quot;synchronized(this)&quot;.
 126     private final Map&lt;Long, SoftObjectReference&gt; objectsByID = new HashMap&lt;&gt;();
 127     private final ReferenceQueue&lt;ObjectReferenceImpl&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
 128     static private final int DISPOSE_THRESHOLD = 50;
 129     private final List&lt;SoftObjectReference&gt; batchedDisposeRequests =
 130             Collections.synchronizedList(new ArrayList&lt;&gt;(DISPOSE_THRESHOLD + 10));
 131 
 132     // These are cached once for the life of the VM
 133     private JDWP.VirtualMachine.Version versionInfo;
 134     private JDWP.VirtualMachine.ClassPaths pathInfo;
 135     private JDWP.VirtualMachine.Capabilities capabilities = null;
 136     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew = null;
 137 
 138     // Per-vm singletons for primitive types and for void.
 139     // singleton-ness protected by &quot;synchronized(this)&quot;.
 140     private BooleanType theBooleanType;
 141     private ByteType    theByteType;
 142     private CharType    theCharType;
 143     private ShortType   theShortType;
 144     private IntegerType theIntegerType;
 145     private LongType    theLongType;
 146     private FloatType   theFloatType;
 147     private DoubleType  theDoubleType;
 148 
 149     private VoidType    theVoidType;
 150 
 151     private VoidValue voidVal;
 152 
 153     // Launched debuggee process
 154     private Process process;
 155 
 156     // coordinates state changes and corresponding listener notifications
 157     private VMState state = new VMState(this);
 158 
 159     private Object initMonitor = new Object();
 160     private boolean initComplete = false;
 161     private boolean shutdown = false;
 162 
 163     private void notifyInitCompletion() {
 164         synchronized(initMonitor) {
 165             initComplete = true;
 166             initMonitor.notifyAll();
 167         }
 168     }
 169 
 170     void waitInitCompletion() {
 171         synchronized(initMonitor) {
 172             while (!initComplete) {
 173                 try {
 174                     initMonitor.wait();
 175                 } catch (InterruptedException e) {
 176                     // ignore
 177                 }
 178             }
 179         }
 180     }
 181 
 182     VMState state() {
 183         return state;
 184     }
 185 
 186     /*
 187      * ThreadListener implementation
 188      */
 189     public boolean threadResumable(ThreadAction action) {
 190         /*
 191          * If any thread is resumed, the VM is considered not suspended.
 192          * Just one thread is being resumed so pass it to thaw.
 193          */
 194         state.thaw(action.thread());
 195         return true;
 196     }
 197 
 198     VirtualMachineImpl(VirtualMachineManager manager,
 199                        Connection connection, Process process,
 200                        int sequenceNumber) {
 201         super(null);  // Can&#39;t use super(this)
 202         vm = this;
 203 
 204         this.vmManager = (VirtualMachineManagerImpl)manager;
 205         this.process = process;
 206         this.sequenceNumber = sequenceNumber;
 207 
 208         /* Create ThreadGroup to be used by all threads servicing
 209          * this VM.
 210          */
 211         threadGroupForJDI = new ThreadGroup(vmManager.mainGroupForJDI(),
 212                                             &quot;JDI [&quot; +
 213                                             this.hashCode() + &quot;]&quot;);
 214 
 215         /*
 216          * Set up a thread to communicate with the target VM over
 217          * the specified transport.
 218          */
 219         target = new TargetVM(this, connection);
 220 
 221         /*
 222          * Set up a thread to handle events processed internally
 223          * the JDI implementation.
 224          */
 225         EventQueueImpl internalEventQueue = new EventQueueImpl(this, target);
 226         new InternalEventHandler(this, internalEventQueue);
 227         /*
 228          * Initialize client access to event setting and handling
 229          */
 230         eventQueue = new EventQueueImpl(this, target);
 231         eventRequestManager = new EventRequestManagerImpl(this);
 232 
 233         target.start();
 234 
 235         /*
 236          * Many ids are variably sized, depending on target VM.
 237          * Find out the sizes right away.
 238          */
 239         JDWP.VirtualMachine.IDSizes idSizes;
 240         try {
 241             idSizes = JDWP.VirtualMachine.IDSizes.process(vm);
 242         } catch (JDWPException exc) {
 243             throw exc.toJDIException();
 244         }
 245         sizeofFieldRef  = idSizes.fieldIDSize;
 246         sizeofMethodRef = idSizes.methodIDSize;
 247         sizeofObjectRef = idSizes.objectIDSize;
 248         sizeofClassRef = idSizes.referenceTypeIDSize;
 249         sizeofFrameRef  = idSizes.frameIDSize;
 250         sizeofModuleRef = idSizes.objectIDSize;
 251 
 252         /**
 253          * Set up requests needed by internal event handler.
 254          * Make sure they are distinguished by creating them with
 255          * an internal event request manager.
 256          *
 257          * Warning: create events only with SUSPEND_NONE policy.
 258          * In the current implementation other policies will not
 259          * be handled correctly when the event comes in. (notfiySuspend()
 260          * will not be properly called, and if the event is combined
 261          * with external events in the same set, suspend policy is not
 262          * correctly determined for the internal vs. external event sets)
 263          */
 264         internalEventRequestManager = new EventRequestManagerImpl(this);
 265         EventRequest er = internalEventRequestManager.createClassPrepareRequest();
 266         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 267         er.enable();
 268         er = internalEventRequestManager.createClassUnloadRequest();
 269         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 270         er.enable();
 271 
 272         /*
 273          * Tell other threads, notably TargetVM, that initialization
 274          * is complete.
 275          */
 276         notifyInitCompletion();
 277     }
 278 
 279     EventRequestManagerImpl getInternalEventRequestManager() {
 280         return internalEventRequestManager;
 281     }
 282 
 283     void validateVM() {
 284         /*
 285          * We no longer need to do this.  The spec now says
 286          * that a VMDisconnected _may_ be thrown in these
 287          * cases, not that it _will_ be thrown.
 288          * So, to simplify things we will just let the
 289          * caller&#39;s of this method proceed with their business.
 290          * If the debuggee is disconnected, either because it
 291          * crashed or finished or something, or because the
 292          * debugger called exit() or dispose(), then if
 293          * we end up trying to communicate with the debuggee,
 294          * code in TargetVM will throw a VMDisconnectedException.
 295          * This means that if we can satisfy a request without
 296          * talking to the debuggee, (eg, with cached data) then
 297          * VMDisconnectedException will _not_ be thrown.
 298          * if (shutdown) {
 299          *    throw new VMDisconnectedException();
 300          * }
 301          */
 302     }
 303 
 304     public boolean equals(Object obj) {
 305         return this == obj;
 306     }
 307 
 308     public int hashCode() {
 309         return System.identityHashCode(this);
 310     }
 311 
 312     public List&lt;ModuleReference&gt; allModules() {
 313         validateVM();
 314         List&lt;ModuleReference&gt; modules = retrieveAllModules();
 315         return Collections.unmodifiableList(modules);
 316     }
 317 
 318     public List&lt;ReferenceType&gt; classesByName(String className) {
 319         validateVM();
 320         return classesBySignature(JNITypeParser.typeNameToSignature(className));
 321     }
 322 
 323     List&lt;ReferenceType&gt; classesBySignature(String signature) {
 324         validateVM();
 325         List&lt;ReferenceType&gt; list;
 326         if (retrievedAllTypes) {
 327             list = findReferenceTypes(signature);
 328         } else {
 329             list = retrieveClassesBySignature(signature);
 330         }
 331         return Collections.unmodifiableList(list);
 332     }
 333 
 334     public List&lt;ReferenceType&gt; allClasses() {
 335         validateVM();
 336 
 337         if (!retrievedAllTypes) {
 338             retrieveAllClasses();
 339         }
 340         ArrayList&lt;ReferenceType&gt; a;
 341         synchronized (this) {
 342             a = new ArrayList&lt;&gt;(typesBySignature);
 343         }
 344         return Collections.unmodifiableList(a);
 345     }
 346 
 347     /**
 348      * Performs an action for each loaded type.
 349      */
 350     public void forEachClass(Consumer&lt;ReferenceType&gt; action) {
 351         for (ReferenceType type : allClasses()) {
 352             try {
 353                 action.accept(type);
 354             } catch (ObjectCollectedException ex) {
 355                 // Some classes might be unloaded and garbage collected since
 356                 // we retrieved the copy of all loaded classes and started
 357                 // iterating over them. In this case calling methods on such types
 358                 // might result in com.sun.jdi.ObjectCollectedException
 359                 // being thrown. We ignore such classes and keep iterating.
 360                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {
 361                     vm.printTrace(&quot;ObjectCollectedException was thrown while &quot; +
 362                             &quot;accessing unloaded class &quot; + type.name());
 363                 }
 364             }
 365         }
 366     }
 367 
 368     public void
 369         redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes)
 370     {
 371         int cnt = classToBytes.size();
 372         JDWP.VirtualMachine.RedefineClasses.ClassDef[] defs =
 373             new JDWP.VirtualMachine.RedefineClasses.ClassDef[cnt];
 374         validateVM();
 375         if (!canRedefineClasses()) {
 376             throw new UnsupportedOperationException();
 377         }
 378         Iterator&lt;?&gt; it = classToBytes.entrySet().iterator();
 379         for (int i = 0; it.hasNext(); i++) {
 380             @SuppressWarnings(&quot;rawtypes&quot;)
 381             Map.Entry&lt;?, ?&gt; entry = (Map.Entry)it.next();
 382             ReferenceTypeImpl refType = (ReferenceTypeImpl)entry.getKey();
 383             validateMirror(refType);
 384             defs[i] = new JDWP.VirtualMachine.RedefineClasses
 385                        .ClassDef(refType, (byte[])entry.getValue());
 386         }
 387 
 388         // flush caches and disable caching until the next suspend
 389         vm.state().thaw();
 390 
 391         try {
 392             JDWP.VirtualMachine.RedefineClasses.
 393                 process(vm, defs);
 394         } catch (JDWPException exc) {
 395             switch (exc.errorCode()) {
 396             case JDWP.Error.INVALID_CLASS_FORMAT :
 397                 throw new ClassFormatError(
 398                     &quot;class not in class file format&quot;);
 399             case JDWP.Error.CIRCULAR_CLASS_DEFINITION :
 400                 throw new ClassCircularityError(
 401                     &quot;circularity has been detected while initializing a class&quot;);
 402             case JDWP.Error.FAILS_VERIFICATION :
 403                 throw new VerifyError(
 404                     &quot;verifier detected internal inconsistency or security problem&quot;);
 405             case JDWP.Error.UNSUPPORTED_VERSION :
 406                 throw new UnsupportedClassVersionError(
 407                     &quot;version numbers of class are not supported&quot;);
 408             case JDWP.Error.ADD_METHOD_NOT_IMPLEMENTED:
 409                 throw new UnsupportedOperationException(
 410                     &quot;add method not implemented&quot;);
 411             case JDWP.Error.SCHEMA_CHANGE_NOT_IMPLEMENTED :
 412                 throw new UnsupportedOperationException(
 413                     &quot;schema change not implemented&quot;);
 414             case JDWP.Error.HIERARCHY_CHANGE_NOT_IMPLEMENTED:
 415                 throw new UnsupportedOperationException(
 416                     &quot;hierarchy change not implemented&quot;);
 417             case JDWP.Error.DELETE_METHOD_NOT_IMPLEMENTED :
 418                 throw new UnsupportedOperationException(
 419                     &quot;delete method not implemented&quot;);
 420             case JDWP.Error.CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED:
 421                 throw new UnsupportedOperationException(
 422                     &quot;changes to class modifiers not implemented&quot;);
 423             case JDWP.Error.METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED :
 424                 throw new UnsupportedOperationException(
 425                     &quot;changes to method modifiers not implemented&quot;);
 426             case JDWP.Error.CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED :
 427                 throw new UnsupportedOperationException(
 428                     &quot;changes to class attribute not implemented&quot;);
 429             case JDWP.Error.NAMES_DONT_MATCH :
 430                 throw new NoClassDefFoundError(
 431                     &quot;class names do not match&quot;);
 432             default:
 433                 throw exc.toJDIException();
 434             }
 435         }
 436 
 437         // Delete any record of the breakpoints
 438         List&lt;BreakpointRequest&gt; toDelete = new ArrayList&lt;&gt;();
 439         EventRequestManager erm = eventRequestManager();
 440         it = erm.breakpointRequests().iterator();
 441         while (it.hasNext()) {
 442             BreakpointRequest req = (BreakpointRequest)it.next();
 443             if (classToBytes.containsKey(req.location().declaringType())) {
 444                 toDelete.add(req);
 445             }
 446         }
 447         erm.deleteEventRequests(toDelete);
 448 
 449         // Invalidate any information cached for the classes just redefined.
 450         it = classToBytes.keySet().iterator();
 451         while (it.hasNext()) {
 452             ReferenceTypeImpl rti = (ReferenceTypeImpl)it.next();
 453             rti.noticeRedefineClass();
 454         }
 455     }
 456 
 457     public List&lt;ThreadReference&gt; allThreads() {
 458         validateVM();
 459         return state.allThreads();
 460     }
 461 
 462     public List&lt;ThreadGroupReference&gt; topLevelThreadGroups() {
 463         validateVM();
 464         return state.topLevelThreadGroups();
 465     }
 466 
 467     /*
 468      * Sends a command to the back end which is defined to do an
 469      * implicit vm-wide resume. The VM can no longer be considered
 470      * suspended, so certain cached data must be invalidated.
 471      */
 472     PacketStream sendResumingCommand(CommandSender sender) {
 473         return state.thawCommand(sender);
 474     }
 475 
 476     /*
 477      * The VM has been suspended. Additional caching can be done
 478      * as long as there are no pending resumes.
 479      */
 480     void notifySuspend() {
 481         state.freeze();
 482     }
 483 
 484     public void suspend() {
 485         validateVM();
 486         try {
 487             JDWP.VirtualMachine.Suspend.process(vm);
 488         } catch (JDWPException exc) {
 489             throw exc.toJDIException();
 490         }
 491         notifySuspend();
 492     }
 493 
 494     public void resume() {
 495         validateVM();
 496         CommandSender sender =
 497             new CommandSender() {
 498                 public PacketStream send() {
 499                     return JDWP.VirtualMachine.Resume.enqueueCommand(vm);
 500                 }
 501         };
 502         try {
 503             PacketStream stream = state.thawCommand(sender);
 504             JDWP.VirtualMachine.Resume.waitForReply(vm, stream);
 505         } catch (VMDisconnectedException exc) {
 506             /*
 507              * If the debugger makes a VMDeathRequest with SUSPEND_ALL,
 508              * then when it does an EventSet.resume after getting the
 509              * VMDeathEvent, the normal flow of events is that the
 510              * BE shuts down, but the waitForReply comes back ok.  In this
 511              * case, the run loop in TargetVM that is waiting for a packet
 512              * gets an EOF because the socket closes. It generates a
 513              * VMDisconnectedEvent and everyone is happy.
 514              * However, sometimes, the BE gets shutdown before this
 515              * waitForReply completes.  In this case, TargetVM.waitForReply
 516              * gets awakened with no reply and so gens a VMDisconnectedException
 517              * which is not what we want.  It might be possible to fix this
 518              * in the BE, but it is ok to just ignore the VMDisconnectedException
 519              * here.  This will allow the VMDisconnectedEvent to be generated
 520              * correctly.  And, if the debugger should happen to make another
 521              * request, it will get a VMDisconnectedException at that time.
 522              */
 523         } catch (JDWPException exc) {
 524             switch (exc.errorCode()) {
 525                 case JDWP.Error.VM_DEAD:
 526                     return;
 527                 default:
 528                     throw exc.toJDIException();
 529             }
 530         }
 531     }
 532 
 533     public EventQueue eventQueue() {
 534         /*
 535          * No VM validation here. We allow access to the event queue
 536          * after disconnection, so that there is access to the terminating
 537          * events.
 538          */
 539         return eventQueue;
 540     }
 541 
 542     public EventRequestManager eventRequestManager() {
 543         validateVM();
 544         return eventRequestManager;
 545     }
 546 
 547     EventRequestManagerImpl eventRequestManagerImpl() {
 548         return eventRequestManager;
 549     }
 550 
 551     public BooleanValue mirrorOf(boolean value) {
 552         validateVM();
 553         return new BooleanValueImpl(this,value);
 554     }
 555 
 556     public ByteValue mirrorOf(byte value) {
 557         validateVM();
 558         return new ByteValueImpl(this,value);
 559     }
 560 
 561     public CharValue mirrorOf(char value) {
 562         validateVM();
 563         return new CharValueImpl(this,value);
 564     }
 565 
 566     public ShortValue mirrorOf(short value) {
 567         validateVM();
 568         return new ShortValueImpl(this,value);
 569     }
 570 
 571     public IntegerValue mirrorOf(int value) {
 572         validateVM();
 573         return new IntegerValueImpl(this,value);
 574     }
 575 
 576     public LongValue mirrorOf(long value) {
 577         validateVM();
 578         return new LongValueImpl(this,value);
 579     }
 580 
 581     public FloatValue mirrorOf(float value) {
 582         validateVM();
 583         return new FloatValueImpl(this,value);
 584     }
 585 
 586     public DoubleValue mirrorOf(double value) {
 587         validateVM();
 588         return new DoubleValueImpl(this,value);
 589     }
 590 
 591     public StringReference mirrorOf(String value) {
 592         validateVM();
 593         try {
 594             return JDWP.VirtualMachine.CreateString.
 595                 process(vm, value).stringObject;
 596         } catch (JDWPException exc) {
 597             throw exc.toJDIException();
 598         }
 599     }
 600 
 601     public VoidValue mirrorOfVoid() {
 602         if (voidVal == null) {
 603             voidVal = new VoidValueImpl(this);
 604         }
 605         return voidVal;
 606     }
 607 
 608     public long[] instanceCounts(List&lt;? extends ReferenceType&gt; classes) {
 609         if (!canGetInstanceInfo()) {
 610             throw new UnsupportedOperationException(
 611                 &quot;target does not support getting instances&quot;);
 612         }
 613         long[] retValue ;
 614         ReferenceTypeImpl[] rtArray = new ReferenceTypeImpl[classes.size()];
 615         int ii = 0;
 616         for (ReferenceType rti: classes) {
 617             validateMirror(rti);
 618             rtArray[ii++] = (ReferenceTypeImpl)rti;
 619         }
 620         try {
 621             retValue = JDWP.VirtualMachine.InstanceCounts.
 622                                 process(vm, rtArray).counts;
 623         } catch (JDWPException exc) {
 624             throw exc.toJDIException();
 625         }
 626 
 627         return retValue;
 628     }
 629 
 630     public void dispose() {
 631         validateVM();
 632         shutdown = true;
 633         try {
 634             JDWP.VirtualMachine.Dispose.process(vm);
 635         } catch (JDWPException exc) {
 636             throw exc.toJDIException();
 637         }
 638         target.stopListening();
 639     }
 640 
 641     public void exit(int exitCode) {
 642         validateVM();
 643         shutdown = true;
 644         try {
 645             JDWP.VirtualMachine.Exit.process(vm, exitCode);
 646         } catch (JDWPException exc) {
 647             throw exc.toJDIException();
 648         }
 649         target.stopListening();
 650     }
 651 
 652     public Process process() {
 653         validateVM();
 654         return process;
 655     }
 656 
 657     private JDWP.VirtualMachine.Version versionInfo() {
 658        try {
 659            if (versionInfo == null) {
 660                // Need not be synchronized since it is static information
 661                versionInfo = JDWP.VirtualMachine.Version.process(vm);
 662            }
 663            return versionInfo;
 664        } catch (JDWPException exc) {
 665            throw exc.toJDIException();
 666        }
 667     }
 668 
 669     public String description() {
 670         validateVM();
 671 
 672         return MessageFormat.format(vmManager.getString(&quot;version_format&quot;),
 673                                     &quot;&quot; + vmManager.majorInterfaceVersion(),
 674                                     &quot;&quot; + vmManager.minorInterfaceVersion(),
 675                                      versionInfo().description);
 676     }
 677 
 678     public String version() {
 679         validateVM();
 680         return versionInfo().vmVersion;
 681     }
 682 
 683     public String name() {
 684         validateVM();
 685         return versionInfo().vmName;
 686     }
 687 
 688     public boolean canWatchFieldModification() {
 689         validateVM();
 690         return capabilities().canWatchFieldModification;
 691     }
 692 
 693     public boolean canWatchFieldAccess() {
 694         validateVM();
 695         return capabilities().canWatchFieldAccess;
 696     }
 697 
 698     public boolean canGetBytecodes() {
 699         validateVM();
 700         return capabilities().canGetBytecodes;
 701     }
 702 
 703     public boolean canGetSyntheticAttribute() {
 704         validateVM();
 705         return capabilities().canGetSyntheticAttribute;
 706     }
 707 
 708     public boolean canGetOwnedMonitorInfo() {
 709         validateVM();
 710         return capabilities().canGetOwnedMonitorInfo;
 711     }
 712 
 713     public boolean canGetCurrentContendedMonitor() {
 714         validateVM();
 715         return capabilities().canGetCurrentContendedMonitor;
 716     }
 717 
 718     public boolean canGetMonitorInfo() {
 719         validateVM();
 720         return capabilities().canGetMonitorInfo;
 721     }
 722 
 723     private boolean hasNewCapabilities() {
 724         return versionInfo().jdwpMajor &gt; 1 ||
 725             versionInfo().jdwpMinor &gt;= 4;
 726     }
 727 
 728     boolean canGet1_5LanguageFeatures() {
 729         return versionInfo().jdwpMajor &gt; 1 ||
 730             versionInfo().jdwpMinor &gt;= 5;
 731     }
 732 
 733     public boolean canUseInstanceFilters() {
 734         validateVM();
 735         return hasNewCapabilities() &amp;&amp;
 736             capabilitiesNew().canUseInstanceFilters;
 737     }
 738 
 739     public boolean canRedefineClasses() {
 740         validateVM();
 741         return hasNewCapabilities() &amp;&amp;
 742             capabilitiesNew().canRedefineClasses;
 743     }
 744 
 745     public boolean canAddMethod() {
 746         validateVM();
 747         return hasNewCapabilities() &amp;&amp;
 748             capabilitiesNew().canAddMethod;
 749     }
 750 
 751     public boolean canUnrestrictedlyRedefineClasses() {
 752         validateVM();
 753         return hasNewCapabilities() &amp;&amp;
 754             capabilitiesNew().canUnrestrictedlyRedefineClasses;
 755     }
 756 
 757     public boolean canPopFrames() {
 758         validateVM();
 759         return hasNewCapabilities() &amp;&amp;
 760             capabilitiesNew().canPopFrames;
 761     }
 762 
 763     public boolean canGetMethodReturnValues() {
 764         return versionInfo().jdwpMajor &gt; 1 ||
 765             versionInfo().jdwpMinor &gt;= 6;
 766     }
 767 
 768     public boolean canGetInstanceInfo() {
 769         if (versionInfo().jdwpMajor &gt; 1 ||
 770             versionInfo().jdwpMinor &gt;= 6) {
 771             validateVM();
 772             return hasNewCapabilities() &amp;&amp;
 773                 capabilitiesNew().canGetInstanceInfo;
 774         } else {
 775             return false;
 776         }
 777     }
 778 
 779     public boolean canUseSourceNameFilters() {
 780         return versionInfo().jdwpMajor &gt; 1 ||
 781             versionInfo().jdwpMinor &gt;= 6;
 782     }
 783 
 784     public boolean canForceEarlyReturn() {
 785         validateVM();
 786         return hasNewCapabilities() &amp;&amp;
 787             capabilitiesNew().canForceEarlyReturn;
 788     }
 789 
 790     public boolean canBeModified() {
 791         return true;
 792     }
 793 
 794     public boolean canGetSourceDebugExtension() {
 795         validateVM();
 796         return hasNewCapabilities() &amp;&amp;
 797             capabilitiesNew().canGetSourceDebugExtension;
 798     }
 799 
 800     public boolean canGetClassFileVersion() {
 801         return versionInfo().jdwpMajor &gt; 1 ||
 802             versionInfo().jdwpMinor &gt;= 6;
 803     }
 804 
 805     public boolean canGetConstantPool() {
 806         validateVM();
 807         return hasNewCapabilities() &amp;&amp;
 808             capabilitiesNew().canGetConstantPool;
 809     }
 810 
 811     public boolean canRequestVMDeathEvent() {
 812         validateVM();
 813         return hasNewCapabilities() &amp;&amp;
 814             capabilitiesNew().canRequestVMDeathEvent;
 815     }
 816 
 817     public boolean canRequestMonitorEvents() {
 818         validateVM();
 819         return hasNewCapabilities() &amp;&amp;
 820             capabilitiesNew().canRequestMonitorEvents;
 821     }
 822 
 823     public boolean canGetMonitorFrameInfo() {
 824         validateVM();
 825         return hasNewCapabilities() &amp;&amp;
 826             capabilitiesNew().canGetMonitorFrameInfo;
 827     }
 828 
 829     public boolean canGetModuleInfo() {
 830         validateVM();
 831         return versionInfo().jdwpMajor &gt;= 9;
 832     }
 833 
 834     public void setDebugTraceMode(int traceFlags) {
 835         validateVM();
 836         this.traceFlags = traceFlags;
 837         this.traceReceives = (traceFlags &amp; TRACE_RECEIVES) != 0;
 838     }
 839 
 840     void printTrace(String string) {
 841         System.err.println(&quot;[JDI: &quot; + string + &quot;]&quot;);
 842     }
 843 
 844     void printReceiveTrace(int depth, String string) {
 845         StringBuilder sb = new StringBuilder(&quot;Receiving:&quot;);
 846         for (int i = depth; i &gt; 0; --i) {
 847             sb.append(&quot;    &quot;);
 848         }
 849         sb.append(string);
 850         printTrace(sb.toString());
 851     }
 852 
 853     private synchronized ReferenceTypeImpl addReferenceType(long id,
 854                                                             int tag,
 855                                                             String signature) {
 856         if (typesByID == null) {
 857             initReferenceTypes();
 858         }
 859         ReferenceTypeImpl type = null;
 860         switch(tag) {
 861             case JDWP.TypeTag.CLASS:
 862                 type = new ClassTypeImpl(vm, id);
 863                 break;
 864             case JDWP.TypeTag.INTERFACE:
 865                 type = new InterfaceTypeImpl(vm, id);
 866                 break;
 867             case JDWP.TypeTag.ARRAY:
 868                 type = new ArrayTypeImpl(vm, id);
 869                 break;
 870             default:
 871                 throw new InternalException(&quot;Invalid reference type tag&quot;);
 872         }
 873 
 874         if (signature == null &amp;&amp; retrievedAllTypes) {
 875             // do not cache if signature is not provided
 876             return type;
 877         }
 878 
 879         typesByID.put(id, type);
 880         typesBySignature.add(type);
 881 
 882         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 883            vm.printTrace(&quot;Caching new ReferenceType, sig=&quot; + signature +
 884                          &quot;, id=&quot; + id);
 885         }
 886 
 887         return type;
 888     }
 889 
 890     synchronized void removeReferenceType(String signature) {
 891         if (typesByID == null) {
 892             return;
 893         }
 894         /*
 895          * There can be multiple classes with the same name. Since
 896          * we can&#39;t differentiate here, we first remove all
 897          * matching classes from our cache...
 898          */
 899         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 900         int matches = 0;
 901         while (iter.hasNext()) {
 902             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 903             int comp = signature.compareTo(type.signature());
 904             if (comp == 0) {
 905                 matches++;
 906                 iter.remove();
 907                 typesByID.remove(type.ref());
 908                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 909                    vm.printTrace(&quot;Uncaching ReferenceType, sig=&quot; + signature +
 910                                  &quot;, id=&quot; + type.ref());
 911                 }
 912                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 913                 // in the order we think
 914             }
 915         }
 916 
 917         /*
 918          * ...and if there was more than one, re-retrieve the classes
 919          * with that name
 920          */
 921         if (matches &gt; 1) {
 922             retrieveClassesBySignature(signature);
 923         }
 924     }
 925 
 926     private synchronized List&lt;ReferenceType&gt; findReferenceTypes(String signature) {
 927         if (typesByID == null) {
 928             return new ArrayList&lt;&gt;(0);
 929         }
 930         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 931         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;();
 932         while (iter.hasNext()) {
 933             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 934             int comp = signature.compareTo(type.signature());
 935             if (comp == 0) {
 936                 list.add(type);
 937                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 938                 // in the order we think
 939             }
 940         }
 941         return list;
 942     }
 943 
 944     private void initReferenceTypes() {
 945         typesByID = new HashMap&lt;&gt;(300);
 946         typesBySignature = new HashSet&lt;&gt;();
 947     }
 948 
 949     ReferenceTypeImpl referenceType(long ref, byte tag) {
 950         return referenceType(ref, tag, null);
 951     }
 952 
 953     ClassTypeImpl classType(long ref) {
 954         return (ClassTypeImpl)referenceType(ref, JDWP.TypeTag.CLASS, null);
 955     }
 956 
 957     InterfaceTypeImpl interfaceType(long ref) {
 958         return (InterfaceTypeImpl)referenceType(ref, JDWP.TypeTag.INTERFACE, null);
 959     }
 960 
 961     ArrayTypeImpl arrayType(long ref) {
 962         return (ArrayTypeImpl)referenceType(ref, JDWP.TypeTag.ARRAY, null);
 963     }
 964 
 965     ReferenceTypeImpl referenceType(long id, int tag, String signature) {
 966         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 967             StringBuilder sb = new StringBuilder();
 968             sb.append(&quot;Looking up &quot;);
 969             if (tag == JDWP.TypeTag.CLASS) {
 970                 sb.append(&quot;Class&quot;);
 971             } else if (tag == JDWP.TypeTag.INTERFACE) {
 972                 sb.append(&quot;Interface&quot;);
 973             } else if (tag == JDWP.TypeTag.ARRAY) {
 974                 sb.append(&quot;ArrayType&quot;);
 975             } else {
 976                 sb.append(&quot;UNKNOWN TAG: &quot;).append(tag);
 977             }
 978             if (signature != null) {
 979                 sb.append(&quot;, signature=&#39;&quot;).append(signature).append(&#39;\&#39;&#39;);
 980             }
 981             sb.append(&quot;, id=&quot;).append(id);
 982             vm.printTrace(sb.toString());
 983         }
 984         if (id == 0) {
 985             return null;
 986         } else {
 987             ReferenceTypeImpl retType = null;
 988             synchronized (this) {
 989                 if (typesByID != null) {
 990                     retType = (ReferenceTypeImpl)typesByID.get(id);
 991                 }
 992                 if (retType == null) {
 993                     retType = addReferenceType(id, tag, signature);
 994                 }
 995                 if (signature != null) {
 996                     retType.setSignature(signature);
 997                 }
 998             }
 999             return retType;
1000         }
1001     }
1002 
1003     private JDWP.VirtualMachine.Capabilities capabilities() {
1004         if (capabilities == null) {
1005             try {
1006                 capabilities = JDWP.VirtualMachine
1007                                  .Capabilities.process(vm);
1008             } catch (JDWPException exc) {
1009                 throw exc.toJDIException();
1010             }
1011         }
1012         return capabilities;
1013     }
1014 
1015     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew() {
1016         if (capabilitiesNew == null) {
1017             try {
1018                 capabilitiesNew = JDWP.VirtualMachine
1019                                  .CapabilitiesNew.process(vm);
1020             } catch (JDWPException exc) {
1021                 throw exc.toJDIException();
1022             }
1023         }
1024         return capabilitiesNew;
1025     }
1026 
1027     private synchronized ModuleReference addModule(long id) {
1028         if (modulesByID == null) {
1029             modulesByID = new HashMap&lt;&gt;(77);
1030         }
1031         ModuleReference module = new ModuleReferenceImpl(vm, id);
1032         modulesByID.put(id, module);
1033         return module;
1034     }
1035 
1036     ModuleReference getModule(long id) {
1037         if (id == 0) {
1038             return null;
1039         } else {
1040             ModuleReference module = null;
1041             synchronized (this) {
1042                 if (modulesByID != null) {
1043                     module = modulesByID.get(id);
1044                 }
1045                 if (module == null) {
1046                     module = addModule(id);
1047                 }
1048             }
1049             return module;
1050         }
1051     }
1052 
1053     private synchronized List&lt;ModuleReference&gt; retrieveAllModules() {
1054         ModuleReferenceImpl[] reqModules;
1055         try {
1056             reqModules = JDWP.VirtualMachine.AllModules.process(vm).modules;
1057         } catch (JDWPException exc) {
1058             throw exc.toJDIException();
1059         }
1060         ArrayList&lt;ModuleReference&gt; modules = new ArrayList&lt;&gt;();
1061         for (int i = 0; i &lt; reqModules.length; i++) {
1062             long moduleRef = reqModules[i].ref();
1063             ModuleReference module = getModule(moduleRef);
1064             modules.add(module);
1065         }
1066         return modules;
1067     }
1068 
1069     private List&lt;ReferenceType&gt; retrieveClassesBySignature(String signature) {
1070         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1071             vm.printTrace(&quot;Retrieving matching ReferenceTypes, sig=&quot; + signature);
1072         }
1073         JDWP.VirtualMachine.ClassesBySignature.ClassInfo[] cinfos;
1074         try {
1075             cinfos = JDWP.VirtualMachine.ClassesBySignature.
1076                                       process(vm, signature).classes;
1077         } catch (JDWPException exc) {
1078             throw exc.toJDIException();
1079         }
1080 
1081         int count = cinfos.length;
1082         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;(count);
1083 
1084         // Hold lock during processing to improve performance
1085         synchronized (this) {
1086             for (int i = 0; i &lt; count; i++) {
1087                 JDWP.VirtualMachine.ClassesBySignature.ClassInfo ci =
1088                                                                cinfos[i];
1089                 ReferenceTypeImpl type = referenceType(ci.typeID,
1090                                                        ci.refTypeTag,
1091                                                        signature);
1092                 type.setStatus(ci.status);
1093                 list.add(type);
1094             }
1095         }
1096         return list;
1097     }
1098 
1099     private void retrieveAllClasses1_4() {
1100         JDWP.VirtualMachine.AllClasses.ClassInfo[] cinfos;
1101         try {
1102             cinfos = JDWP.VirtualMachine.AllClasses.process(vm).classes;
1103         } catch (JDWPException exc) {
1104             throw exc.toJDIException();
1105         }
1106 
1107         // Hold lock during processing to improve performance
1108         // and to have safe check/set of retrievedAllTypes
1109         synchronized (this) {
1110             if (!retrievedAllTypes) {
1111                 // Number of classes
1112                 int count = cinfos.length;
1113                 for (int i = 0; i &lt; count; i++) {
1114                     JDWP.VirtualMachine.AllClasses.ClassInfo ci = cinfos[i];
1115                     ReferenceTypeImpl type = referenceType(ci.typeID,
1116                                                            ci.refTypeTag,
1117                                                            ci.signature);
1118                     type.setStatus(ci.status);
1119                 }
1120                 retrievedAllTypes = true;
1121             }
1122         }
1123     }
1124 
1125     private void retrieveAllClasses() {
1126         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1127             vm.printTrace(&quot;Retrieving all ReferenceTypes&quot;);
1128         }
1129 
1130         if (!vm.canGet1_5LanguageFeatures()) {
1131             retrieveAllClasses1_4();
1132             return;
1133         }
1134 
1135         /*
1136          * To save time (assuming the caller will be
1137          * using then) we will get the generic sigs too.
1138          */
1139         JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo[] cinfos;
1140         try {
1141             cinfos = JDWP.VirtualMachine.AllClassesWithGeneric.process(vm).classes;
1142         } catch (JDWPException exc) {
1143             throw exc.toJDIException();
1144         }
1145 
1146         // Hold lock during processing to improve performance
1147         // and to have safe check/set of retrievedAllTypes
1148         synchronized (this) {
1149             if (!retrievedAllTypes) {
1150                 // Number of classes
1151                 int count = cinfos.length;
1152                 for (int i = 0; i &lt; count; i++) {
1153                     JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo ci =
1154                                                                cinfos[i];
1155                     ReferenceTypeImpl type = referenceType(ci.typeID,
1156                                                            ci.refTypeTag,
1157                                                            ci.signature);
1158                     type.setGenericSignature(ci.genericSignature);
1159                     type.setStatus(ci.status);
1160                 }
1161                 retrievedAllTypes = true;
1162             }
1163         }
1164     }
1165 
1166     void sendToTarget(Packet packet) {
1167         target.send(packet);
1168     }
1169 
1170     void waitForTargetReply(Packet packet) {
1171         target.waitForReply(packet);
1172         /*
1173          * If any object disposes have been batched up, send them now.
1174          */
1175         processBatchedDisposes();
1176     }
1177 
1178     Type findBootType(String signature) throws ClassNotLoadedException {
1179         List&lt;ReferenceType&gt; types = retrieveClassesBySignature(signature);
1180         Iterator&lt;ReferenceType&gt; iter = types.iterator();
1181         while (iter.hasNext()) {
1182             ReferenceType type = iter.next();
1183             if (type.classLoader() == null) {
1184                 return type;
1185             }
1186         }
1187         JNITypeParser parser = new JNITypeParser(signature);
1188         throw new ClassNotLoadedException(parser.typeName(),
1189                                          &quot;Type &quot; + parser.typeName() + &quot; not loaded&quot;);
1190     }
1191 
1192     BooleanType theBooleanType() {
1193         if (theBooleanType == null) {
1194             synchronized(this) {
1195                 if (theBooleanType == null) {
1196                     theBooleanType = new BooleanTypeImpl(this);
1197                 }
1198             }
1199         }
1200         return theBooleanType;
1201     }
1202 
1203     ByteType theByteType() {
1204         if (theByteType == null) {
1205             synchronized(this) {
1206                 if (theByteType == null) {
1207                     theByteType = new ByteTypeImpl(this);
1208                 }
1209             }
1210         }
1211         return theByteType;
1212     }
1213 
1214     CharType theCharType() {
1215         if (theCharType == null) {
1216             synchronized(this) {
1217                 if (theCharType == null) {
1218                     theCharType = new CharTypeImpl(this);
1219                 }
1220             }
1221         }
1222         return theCharType;
1223     }
1224 
1225     ShortType theShortType() {
1226         if (theShortType == null) {
1227             synchronized(this) {
1228                 if (theShortType == null) {
1229                     theShortType = new ShortTypeImpl(this);
1230                 }
1231             }
1232         }
1233         return theShortType;
1234     }
1235 
1236     IntegerType theIntegerType() {
1237         if (theIntegerType == null) {
1238             synchronized(this) {
1239                 if (theIntegerType == null) {
1240                     theIntegerType = new IntegerTypeImpl(this);
1241                 }
1242             }
1243         }
1244         return theIntegerType;
1245     }
1246 
1247     LongType theLongType() {
1248         if (theLongType == null) {
1249             synchronized(this) {
1250                 if (theLongType == null) {
1251                     theLongType = new LongTypeImpl(this);
1252                 }
1253             }
1254         }
1255         return theLongType;
1256     }
1257 
1258     FloatType theFloatType() {
1259         if (theFloatType == null) {
1260             synchronized(this) {
1261                 if (theFloatType == null) {
1262                     theFloatType = new FloatTypeImpl(this);
1263                 }
1264             }
1265         }
1266         return theFloatType;
1267     }
1268 
1269     DoubleType theDoubleType() {
1270         if (theDoubleType == null) {
1271             synchronized(this) {
1272                 if (theDoubleType == null) {
1273                     theDoubleType = new DoubleTypeImpl(this);
1274                 }
1275             }
1276         }
1277         return theDoubleType;
1278     }
1279 
1280     VoidType theVoidType() {
1281         if (theVoidType == null) {
1282             synchronized(this) {
1283                 if (theVoidType == null) {
1284                     theVoidType = new VoidTypeImpl(this);
1285                 }
1286             }
1287         }
1288         return theVoidType;
1289     }
1290 
1291     PrimitiveType primitiveTypeMirror(byte tag) {
1292         switch (tag) {
1293             case JDWP.Tag.BOOLEAN:
1294                 return theBooleanType();
1295             case JDWP.Tag.BYTE:
1296                 return theByteType();
1297             case JDWP.Tag.CHAR:
1298                 return theCharType();
1299             case JDWP.Tag.SHORT:
1300                 return theShortType();
1301             case JDWP.Tag.INT:
1302                 return theIntegerType();
1303             case JDWP.Tag.LONG:
1304                 return theLongType();
1305             case JDWP.Tag.FLOAT:
1306                 return theFloatType();
1307             case JDWP.Tag.DOUBLE:
1308                 return theDoubleType();
1309             default:
1310                 throw new IllegalArgumentException(&quot;Unrecognized primitive tag &quot; + tag);
1311         }
1312     }
1313 
1314     private void processBatchedDisposes() {
1315         if (shutdown) {
1316             return;
1317         }
1318 
1319         JDWP.VirtualMachine.DisposeObjects.Request[] requests = null;
1320         synchronized(batchedDisposeRequests) {
1321             int size = batchedDisposeRequests.size();
1322             if (size &gt;= DISPOSE_THRESHOLD) {
1323                 if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1324                     printTrace(&quot;Dispose threashold reached. Will dispose &quot;
1325                                + size + &quot; object references...&quot;);
1326                 }
1327                 requests = new JDWP.VirtualMachine.DisposeObjects.Request[size];
1328                 for (int i = 0; i &lt; requests.length; i++) {
1329                     SoftObjectReference ref = batchedDisposeRequests.get(i);
1330                     if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1331                         printTrace(&quot;Disposing object &quot; + ref.key().longValue() +
1332                                    &quot; (ref count = &quot; + ref.count() + &quot;)&quot;);
1333                     }
1334 
1335                     // This is kludgy. We temporarily re-create an object
1336                     // reference so that we can correctly pass its id to the
1337                     // JDWP command.
1338                     requests[i] =
1339                         new JDWP.VirtualMachine.DisposeObjects.Request(
1340                             new ObjectReferenceImpl(this, ref.key().longValue()),
1341                             ref.count());
1342                 }
1343                 batchedDisposeRequests.clear();
1344             }
1345         }
1346         if (requests != null) {
1347             try {
1348                 JDWP.VirtualMachine.DisposeObjects.process(vm, requests);
1349             } catch (JDWPException exc) {
1350                 throw exc.toJDIException();
1351             }
1352         }
1353     }
1354 
1355     private void batchForDispose(SoftObjectReference ref) {
1356         if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1357             printTrace(&quot;Batching object &quot; + ref.key().longValue() +
1358                        &quot; for dispose (ref count = &quot; + ref.count() + &quot;)&quot;);
1359         }
1360         batchedDisposeRequests.add(ref);
1361     }
1362 
1363     private void processQueue() {
1364         Reference&lt;?&gt; ref;
1365         //if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1366         //    printTrace(&quot;Checking for softly reachable objects&quot;);
1367         //}
1368         while ((ref = referenceQueue.poll()) != null) {
1369             SoftObjectReference softRef = (SoftObjectReference)ref;
1370             removeObjectMirror(softRef);
1371             batchForDispose(softRef);
1372         }
1373     }
1374 
1375     synchronized ObjectReferenceImpl objectMirror(long id, int tag) {
1376 
1377         // Handle any queue elements that are not strongly reachable
1378         processQueue();
1379 
1380         if (id == 0) {
1381             return null;
1382         }
1383         ObjectReferenceImpl object = null;
1384         Long key = id;
1385 
1386         /*
1387          * Attempt to retrieve an existing object reference
1388          */
1389         SoftObjectReference ref = objectsByID.get(key);
1390         if (ref != null) {
1391             object = ref.object();
1392         }
1393 
1394         /*
1395          * If the object wasn&#39;t in the table, or it&#39;s soft reference was
1396          * cleared, create a new instance.
1397          */
1398         if (object == null) {
1399             switch (tag) {
1400                 case JDWP.Tag.OBJECT:
1401                     object = new ObjectReferenceImpl(vm, id);
1402                     break;
1403                 case JDWP.Tag.STRING:
1404                     object = new StringReferenceImpl(vm, id);
1405                     break;
1406                 case JDWP.Tag.ARRAY:
1407                     object = new ArrayReferenceImpl(vm, id);
1408                     break;
1409                 case JDWP.Tag.THREAD:
1410                     ThreadReferenceImpl thread =
1411                         new ThreadReferenceImpl(vm, id);
1412                     thread.addListener(this);
1413                     object = thread;
1414                     break;
1415                 case JDWP.Tag.THREAD_GROUP:
1416                     object = new ThreadGroupReferenceImpl(vm, id);
1417                     break;
1418                 case JDWP.Tag.CLASS_LOADER:
1419                     object = new ClassLoaderReferenceImpl(vm, id);
1420                     break;
1421                 case JDWP.Tag.CLASS_OBJECT:
1422                     object = new ClassObjectReferenceImpl(vm, id);
1423                     break;
1424                 default:
1425                     throw new IllegalArgumentException(&quot;Invalid object tag: &quot; + tag);
1426             }
1427             ref = new SoftObjectReference(key, object, referenceQueue);
1428 
1429             /*
1430              * If there was no previous entry in the table, we add one here
1431              * If the previous entry was cleared, we replace it here.
1432              */
1433             objectsByID.put(key, ref);
1434             if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1435                 printTrace(&quot;Creating new &quot; +
1436                            object.getClass().getName() + &quot; (id = &quot; + id + &quot;)&quot;);
1437             }
1438         } else {
1439             ref.incrementCount();
1440         }
1441 
1442         return object;
1443     }
1444 
1445     synchronized void removeObjectMirror(ObjectReferenceImpl object) {
1446         // Handle any queue elements that are not strongly reachable
1447         processQueue();
1448 
1449         SoftObjectReference ref = objectsByID.remove(object.ref());
1450         if (ref != null) {
1451             batchForDispose(ref);
1452         } else {
1453             /*
1454              * If there&#39;s a live ObjectReference about, it better be part
1455              * of the cache.
1456              */
1457             throw new InternalException(&quot;ObjectReference &quot; + object.ref() +
1458                                         &quot; not found in object cache&quot;);
1459         }
1460     }
1461 
1462     synchronized void removeObjectMirror(SoftObjectReference ref) {
1463         /*
1464          * This will remove the soft reference if it has not been
1465          * replaced in the cache.
1466          */
1467         objectsByID.remove(ref.key());
1468     }
1469 
1470     ObjectReferenceImpl objectMirror(long id) {
1471         return objectMirror(id, JDWP.Tag.OBJECT);
1472     }
1473 
1474     StringReferenceImpl stringMirror(long id) {
1475         return (StringReferenceImpl)objectMirror(id, JDWP.Tag.STRING);
1476     }
1477 
1478     ArrayReferenceImpl arrayMirror(long id) {
1479        return (ArrayReferenceImpl)objectMirror(id, JDWP.Tag.ARRAY);
1480     }
1481 
1482     ThreadReferenceImpl threadMirror(long id) {
1483         return (ThreadReferenceImpl)objectMirror(id, JDWP.Tag.THREAD);
1484     }
1485 
1486     ThreadGroupReferenceImpl threadGroupMirror(long id) {
1487         return (ThreadGroupReferenceImpl)objectMirror(id,
1488                                                       JDWP.Tag.THREAD_GROUP);
1489     }
1490 
1491     ClassLoaderReferenceImpl classLoaderMirror(long id) {
1492         return (ClassLoaderReferenceImpl)objectMirror(id,
1493                                                       JDWP.Tag.CLASS_LOADER);
1494     }
1495 
1496     ClassObjectReferenceImpl classObjectMirror(long id) {
1497         return (ClassObjectReferenceImpl)objectMirror(id,
1498                                                       JDWP.Tag.CLASS_OBJECT);
1499     }
1500 
1501     ModuleReferenceImpl moduleMirror(long id) {
1502         return (ModuleReferenceImpl)getModule(id);
1503     }
1504 
1505     /*
1506      * Implementation of PathSearchingVirtualMachine
1507      */
1508     private JDWP.VirtualMachine.ClassPaths getClasspath() {
1509         if (pathInfo == null) {
1510             try {
1511                 pathInfo = JDWP.VirtualMachine.ClassPaths.process(vm);
1512             } catch (JDWPException exc) {
1513                 throw exc.toJDIException();
1514             }
1515         }
1516         return pathInfo;
1517     }
1518 
1519    public List&lt;String&gt; classPath() {
1520        return Arrays.asList(getClasspath().classpaths);
1521    }
1522 
1523    public List&lt;String&gt; bootClassPath() {
1524        return Collections.emptyList();
1525    }
1526 
1527    public String baseDirectory() {
1528        return getClasspath().baseDir;
1529    }
1530 
1531     public void setDefaultStratum(String stratum) {
1532         defaultStratum = stratum;
1533         if (stratum == null) {
1534             stratum = &quot;&quot;;
1535         }
1536         try {
1537             JDWP.VirtualMachine.SetDefaultStratum.process(vm,
1538                                                           stratum);
1539         } catch (JDWPException exc) {
1540             throw exc.toJDIException();
1541         }
1542     }
1543 
1544     public String getDefaultStratum() {
1545         return defaultStratum;
1546     }
1547 
1548     ThreadGroup threadGroupForJDI() {
1549         return threadGroupForJDI;
1550     }
1551 
1552    static private class SoftObjectReference extends SoftReference&lt;ObjectReferenceImpl&gt; {
1553        int count;
1554        Long key;
1555 
1556        SoftObjectReference(Long key, ObjectReferenceImpl mirror,
1557                            ReferenceQueue&lt;ObjectReferenceImpl&gt; queue) {
1558            super(mirror, queue);
1559            this.count = 1;
1560            this.key = key;
1561        }
1562 
1563        int count() {
1564            return count;
1565        }
1566 
1567        void incrementCount() {
1568            count++;
1569        }
1570 
1571        Long key() {
1572            return key;
1573        }
1574 
1575        ObjectReferenceImpl object() {
1576            return get();
1577        }
1578    }
1579 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.ArrayDeque;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;
  40 import java.util.Deque;
  41 import java.util.EnumSet;
  42 import java.util.HashMap;
  43 import java.util.HashSet;
  44 import java.util.Iterator;
  45 import java.util.LinkedHashMap;
  46 import java.util.LinkedHashSet;
  47 import java.util.List;
  48 import java.util.Locale;
  49 import java.util.Map;
  50 import java.util.Map.Entry;
  51 import java.util.Objects;
  52 import java.util.Set;
  53 import java.util.SortedSet;
  54 import java.util.TreeMap;
  55 import java.util.TreeSet;
  56 import java.util.function.Predicate;
  57 import java.util.stream.Collectors;
  58 
  59 import javax.lang.model.SourceVersion;
  60 import javax.lang.model.element.AnnotationMirror;
  61 import javax.lang.model.element.AnnotationValue;
  62 import javax.lang.model.element.Element;
  63 import javax.lang.model.element.ElementKind;
  64 import javax.lang.model.element.ExecutableElement;
  65 import javax.lang.model.element.Modifier;
  66 import javax.lang.model.element.ModuleElement;
  67 import javax.lang.model.element.ModuleElement.RequiresDirective;
  68 import javax.lang.model.element.PackageElement;
  69 import javax.lang.model.element.RecordComponentElement;
  70 import javax.lang.model.element.TypeElement;
  71 import javax.lang.model.element.TypeParameterElement;
  72 import javax.lang.model.element.VariableElement;
  73 import javax.lang.model.type.ArrayType;
  74 import javax.lang.model.type.DeclaredType;
  75 import javax.lang.model.type.ErrorType;
  76 import javax.lang.model.type.ExecutableType;
  77 import javax.lang.model.type.NoType;
  78 import javax.lang.model.type.PrimitiveType;
  79 import javax.lang.model.type.TypeMirror;
  80 import javax.lang.model.type.TypeVariable;
  81 import javax.lang.model.type.WildcardType;
  82 import javax.lang.model.util.ElementFilter;
  83 import javax.lang.model.util.ElementKindVisitor14;
  84 import javax.lang.model.util.Elements;
  85 import javax.lang.model.util.SimpleElementVisitor14;
  86 import javax.lang.model.util.SimpleTypeVisitor9;
  87 import javax.lang.model.util.TypeKindVisitor9;
  88 import javax.lang.model.util.Types;
  89 import javax.tools.FileObject;
  90 import javax.tools.JavaFileManager;
  91 import javax.tools.JavaFileManager.Location;
  92 import javax.tools.StandardLocation;
  93 
  94 import com.sun.source.doctree.DocCommentTree;
  95 import com.sun.source.doctree.DocTree;
  96 import com.sun.source.doctree.DocTree.Kind;
  97 import com.sun.source.doctree.EndElementTree;
  98 import com.sun.source.doctree.ParamTree;
  99 import com.sun.source.doctree.StartElementTree;
 100 import com.sun.source.doctree.TextTree;
 101 import com.sun.source.doctree.UnknownBlockTagTree;
 102 import com.sun.source.tree.CompilationUnitTree;
 103 import com.sun.source.tree.LineMap;
 104 import com.sun.source.util.DocSourcePositions;
 105 import com.sun.source.util.DocTrees;
 106 import com.sun.source.util.TreePath;
 107 import com.sun.tools.javac.model.JavacTypes;
 108 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 109 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 110 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
 111 import jdk.javadoc.internal.doclets.toolkit.Resources;
 112 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 113 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 114 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 115 import jdk.javadoc.internal.tool.DocEnvImpl;
 116 
 117 import static javax.lang.model.element.ElementKind.*;
 118 import static javax.lang.model.element.Modifier.*;
 119 import static javax.lang.model.type.TypeKind.*;
 120 
 121 import static com.sun.source.doctree.DocTree.Kind.*;
 122 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 123 
 124 /**
 125  * Utilities Class for Doclets.
 126  *
 127  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 128  *  If you write code that depends on this, you do so at your own risk.
 129  *  This code and its internal interfaces are subject to change or
 130  *  deletion without notice.&lt;/b&gt;
 131  */
 132 public class Utils {
 133     public final BaseConfiguration configuration;
 134     private final BaseOptions options;
 135     private final Resources resources;
 136     public final DocTrees docTrees;
 137     public final Elements elementUtils;
 138     public final Types typeUtils;
 139     public final Comparators comparators;
 140     private final JavaScriptScanner javaScriptScanner;
 141 
 142     public Utils(BaseConfiguration c) {
 143         configuration = c;
 144         options = configuration.getOptions();
 145         resources = configuration.getDocResources();
 146         elementUtils = c.docEnv.getElementUtils();
 147         typeUtils = c.docEnv.getTypeUtils();
 148         docTrees = c.docEnv.getDocTrees();
 149         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
 150         comparators = new Comparators(this);
 151     }
 152 
 153     // our own little symbol table
 154     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 155 
 156     public TypeMirror getSymbol(String signature) {
 157         TypeMirror type = symtab.get(signature);
 158         if (type == null) {
 159             TypeElement typeElement = elementUtils.getTypeElement(signature);
 160             if (typeElement == null)
 161                 return null;
 162             type = typeElement.asType();
 163             if (type == null)
 164                 return null;
 165             symtab.put(signature, type);
 166         }
 167         return type;
 168     }
 169 
 170     public TypeMirror getObjectType() {
 171         return getSymbol(&quot;java.lang.Object&quot;);
 172     }
 173 
 174     public TypeMirror getExceptionType() {
 175         return getSymbol(&quot;java.lang.Exception&quot;);
 176     }
 177 
 178     public TypeMirror getErrorType() {
 179         return getSymbol(&quot;java.lang.Error&quot;);
 180     }
 181 
 182     public TypeMirror getSerializableType() {
 183         return getSymbol(&quot;java.io.Serializable&quot;);
 184     }
 185 
 186     public TypeMirror getExternalizableType() {
 187         return getSymbol(&quot;java.io.Externalizable&quot;);
 188     }
 189 
 190     public TypeMirror getIllegalArgumentExceptionType() {
 191         return getSymbol(&quot;java.lang.IllegalArgumentException&quot;);
 192     }
 193 
 194     public TypeMirror getNullPointerExceptionType() {
 195         return getSymbol(&quot;java.lang.NullPointerException&quot;);
 196     }
 197 
 198     public TypeMirror getDeprecatedType() {
 199         return getSymbol(&quot;java.lang.Deprecated&quot;);
 200     }
 201 
 202     public TypeMirror getFunctionalInterface() {
 203         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 204     }
 205 
 206     /**
 207      * Return array of class members whose documentation is to be generated.
 208      * If the member is deprecated do not include such a member in the
 209      * returned array.
 210      *
 211      * @param  members    Array of members to choose from.
 212      * @return List       List of eligible members for whom
 213      *                    documentation is getting generated.
 214      */
 215     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
 216         return members.stream()
 217                       .filter(member -&gt; !isDeprecated(member))
 218                       .sorted(comparators.makeGeneralPurposeComparator())
 219                       .collect(Collectors.toCollection(ArrayList::new));
 220     }
 221 
 222     /**
 223      * Search for the given method in the given class.
 224      *
 225      * @param  te        Class to search into.
 226      * @param  method    Method to be searched.
 227      * @return ExecutableElement Method found, null otherwise.
 228      */
 229     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 230         for (Element m : getMethods(te)) {
 231             if (executableMembersEqual(method, (ExecutableElement) m)) {
 232                 return (ExecutableElement) m;
 233             }
 234         }
 235         return null;
 236     }
 237 
 238     /**
 239      * Test whether a class is a subclass of another class.
 240      *
 241      * @param t1 the candidate superclass.
 242      * @param t2 the target
 243      * @return true if t1 is a superclass of t2.
 244      */
 245     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 246         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 247     }
 248 
 249     /**
 250      * @param e1 the first method to compare.
 251      * @param e2 the second method to compare.
 252      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 253      */
 254     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 255         // TODO: investigate if Elements.hides(..) will work here.
 256         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 257             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 258             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 259             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 260                     parameters1.size() == parameters2.size()) {
 261                 int j;
 262                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 263                     VariableElement v1 = parameters1.get(j);
 264                     VariableElement v2 = parameters2.get(j);
 265                     String t1 = getTypeName(v1.asType(), true);
 266                     String t2 = getTypeName(v2.asType(), true);
 267                     if (!(t1.equals(t2) ||
 268                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 269                         break;
 270                     }
 271                 }
 272                 if (j == parameters1.size()) {
 273                     return true;
 274                 }
 275             }
 276             return false;
 277         } else {
 278             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 279                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 280                     e1.equals(e2);
 281         }
 282     }
 283 
 284     /**
 285      * According to
 286      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 287      * all the outer classes and static inner classes are core classes.
 288      */
 289     public boolean isCoreClass(TypeElement e) {
 290         return getEnclosingTypeElement(e) == null || isStatic(e);
 291     }
 292 
 293     public Location getLocationForPackage(PackageElement pd) {
 294         ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(pd);
 295 
 296         if (mdle == null)
 297             return defaultLocation();
 298 
 299         return getLocationForModule(mdle);
 300     }
 301 
 302     public Location getLocationForModule(ModuleElement mdle) {
 303         Location loc = configuration.workArounds.getLocationForModule(mdle);
 304         if (loc != null)
 305             return loc;
 306 
 307         return defaultLocation();
 308     }
 309 
 310     private Location defaultLocation() {
 311         JavaFileManager fm = configuration.docEnv.getJavaFileManager();
 312         return fm.hasLocation(StandardLocation.SOURCE_PATH)
 313                 ? StandardLocation.SOURCE_PATH
 314                 : StandardLocation.CLASS_PATH;
 315     }
 316 
 317     public boolean isAnnotated(TypeMirror e) {
 318         return !e.getAnnotationMirrors().isEmpty();
 319     }
 320 
 321     public boolean isAnnotated(Element e) {
 322         return !e.getAnnotationMirrors().isEmpty();
 323     }
 324 
 325     @SuppressWarnings(&quot;preview&quot;)
 326     public boolean isAnnotationType(Element e) {
 327         return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
 328             @Override
 329             public Boolean visitExecutable(ExecutableElement e, Void p) {
 330                 return visit(e.getEnclosingElement());
 331             }
 332 
 333             @Override
 334             public Boolean visitUnknown(Element e, Void p) {
 335                 return false;
 336             }
 337 
 338             @Override
 339             protected Boolean defaultAction(Element e, Void p) {
 340                 return e.getKind() == ANNOTATION_TYPE;
 341             }
 342         }.visit(e);
 343     }
 344 
 345     /**
 346      * An Enum implementation is almost identical, thus this method returns if
 347      * this element represents a CLASS or an ENUM
 348      * @param e element
 349      * @return true if class or enum
 350      */
 351     public boolean isClass(Element e) {
 352         return e.getKind().isClass();
 353     }
 354 
 355     public boolean isConstructor(Element e) {
 356          return e.getKind() == CONSTRUCTOR;
 357     }
 358 
 359     public boolean isEnum(Element e) {
 360         return e.getKind() == ENUM;
 361     }
 362 
 363     boolean isEnumConstant(Element e) {
 364         return e.getKind() == ENUM_CONSTANT;
 365     }
 366 
 367     public boolean isField(Element e) {
 368         return e.getKind() == FIELD;
 369     }
 370 
 371     public boolean isInterface(Element e) {
 372         return e.getKind() == INTERFACE;
 373     }
 374 
 375     public boolean isMethod(Element e) {
 376         return e.getKind() == METHOD;
 377     }
 378 
 379     public boolean isModule(Element e) {
 380         return e.getKind() == ElementKind.MODULE;
 381     }
 382 
 383     public boolean isPackage(Element e) {
 384         return e.getKind() == ElementKind.PACKAGE;
 385     }
 386 
 387     public boolean isAbstract(Element e) {
 388         return e.getModifiers().contains(Modifier.ABSTRACT);
 389     }
 390 
 391     public boolean isDefault(Element e) {
 392         return e.getModifiers().contains(Modifier.DEFAULT);
 393     }
 394 
 395     public boolean isPackagePrivate(Element e) {
 396         return !(isPublic(e) || isPrivate(e) || isProtected(e));
 397     }
 398 
 399     public boolean isPrivate(Element e) {
 400         return e.getModifiers().contains(Modifier.PRIVATE);
 401     }
 402 
 403     public boolean isProtected(Element e) {
 404         return e.getModifiers().contains(Modifier.PROTECTED);
 405     }
 406 
 407     public boolean isPublic(Element e) {
 408         return e.getModifiers().contains(Modifier.PUBLIC);
 409     }
 410 
 411     public boolean isProperty(String name) {
 412         return options.javafx() &amp;&amp; name.endsWith(&quot;Property&quot;);
 413     }
 414 
 415     public String getPropertyName(String name) {
 416         return isProperty(name)
 417                 ? name.substring(0, name.length() - &quot;Property&quot;.length())
 418                 : name;
 419     }
 420 
 421     public String getPropertyLabel(String name) {
 422         return name.substring(0, name.lastIndexOf(&quot;Property&quot;));
 423     }
 424 
 425     public boolean isOverviewElement(Element e) {
 426         return e.getKind() == ElementKind.OTHER;
 427     }
 428 
 429     public boolean isStatic(Element e) {
 430         return e.getModifiers().contains(Modifier.STATIC);
 431     }
 432 
 433     public boolean isSerializable(TypeElement e) {
 434         return typeUtils.isSubtype(e.asType(), getSerializableType());
 435     }
 436 
 437     public boolean isExternalizable(TypeElement e) {
 438         return typeUtils.isSubtype(e.asType(), getExternalizableType());
 439     }
 440 
 441     @SuppressWarnings(&quot;preview&quot;)
 442     public boolean isRecord(TypeElement e) {
 443         return e.getKind() == ElementKind.RECORD;
 444     }
 445 
 446     @SuppressWarnings(&quot;preview&quot;)
 447     public boolean isCanonicalRecordConstructor(ExecutableElement ee) {
 448         TypeElement te = (TypeElement) ee.getEnclosingElement();
 449         List&lt;? extends RecordComponentElement&gt; stateComps = te.getRecordComponents();
 450         List&lt;? extends VariableElement&gt; params = ee.getParameters();
 451         if (stateComps.size() != params.size()) {
 452             return false;
 453         }
 454 
 455         Iterator&lt;? extends RecordComponentElement&gt; stateIter = stateComps.iterator();
 456         Iterator&lt;? extends VariableElement&gt; paramIter = params.iterator();
 457         while (paramIter.hasNext() &amp;&amp; stateIter.hasNext()) {
 458             VariableElement param = paramIter.next();
 459             RecordComponentElement comp = stateIter.next();
 460             if (!Objects.equals(param.getSimpleName(), comp.getSimpleName())
 461                     || !typeUtils.isSameType(param.asType(), comp.asType())) {
 462                 return false;
 463             }
 464         }
 465 
 466         return true;
 467     }
 468 
 469     public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
 470         return configuration.workArounds.getSerializableFields(aclass);
 471     }
 472 
 473     public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
 474         return configuration.workArounds.getSerializationMethods(aclass);
 475     }
 476 
 477     public boolean definesSerializableFields(TypeElement aclass) {
 478         return configuration.workArounds.definesSerializableFields( aclass);
 479     }
 480 
 481     @SuppressWarnings(&quot;preview&quot;)
 482     public String modifiersToString(Element e, boolean trailingSpace) {
 483         SortedSet&lt;Modifier&gt; modifiers = new TreeSet&lt;&gt;(e.getModifiers());
 484         modifiers.remove(NATIVE);
 485         modifiers.remove(STRICTFP);
 486         modifiers.remove(SYNCHRONIZED);
 487 
 488         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 489             final StringBuilder sb = new StringBuilder();
 490 
 491             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 492                 if (modifiers.contains(PUBLIC)) {
 493                     append(&quot;public&quot;);
 494                 } else if (modifiers.contains(PROTECTED)) {
 495                     append(&quot;protected&quot;);
 496                 } else if (modifiers.contains(PRIVATE)) {
 497                     append(&quot;private&quot;);
 498                 }
 499             }
 500 
 501             void addStatic(Set&lt;Modifier&gt; modifiers) {
 502                 if (modifiers.contains(STATIC)) {
 503                     append(&quot;static&quot;);
 504                 }
 505             }
 506 
 507             void addModifiers(Set&lt;Modifier&gt; modifiers) {
 508                 modifiers.stream().map(Modifier::toString).forEachOrdered(this::append);
 509             }
 510 
 511             void append(String s) {
 512                 if (sb.length() &gt; 0) {
 513                     sb.append(&quot; &quot;);
 514                 }
 515                 sb.append(s);
 516             }
 517 
 518             String finalString(String s) {
 519                 append(s);
 520                 if (trailingSpace) {
 521                     sb.append(&quot; &quot;);
 522                 }
 523                 return sb.toString();
 524             }
 525 
 526             @Override
 527             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 528                 addVisibilityModifier(mods);
 529                 addStatic(mods);
 530                 return finalString(&quot;interface&quot;);
 531             }
 532 
 533             @Override
 534             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 535                 addVisibilityModifier(mods);
 536                 addStatic(mods);
 537                 return finalString(&quot;enum&quot;);
 538             }
 539 
 540             @Override
 541             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 542                 addVisibilityModifier(mods);
 543                 addStatic(mods);
 544                 return finalString(&quot;@interface&quot;);
 545             }
 546 
 547             @Override
 548             public String visitTypeAsRecord(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 549                 mods.remove(FINAL); // suppress the implicit `final`
 550                 return visitTypeAsClass(e, mods);
 551             }
 552 
 553             @Override
 554             @SuppressWarnings(&quot;preview&quot;)
 555             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 556                 addModifiers(mods);
 557                 String keyword = e.getKind() == ElementKind.RECORD ? &quot;record&quot; : &quot;class&quot;;
 558                 return finalString(keyword);
 559             }
 560 
 561             @Override
 562             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; mods) {
 563                 addModifiers(mods);
 564                 return sb.toString().trim();
 565             }
 566 
 567         }.visit(e, modifiers);
 568     }
 569 
 570     public boolean isFunctionalInterface(AnnotationMirror amirror) {
 571         return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
 572                 configuration.docEnv.getSourceVersion()
 573                         .compareTo(SourceVersion.RELEASE_8) &gt;= 0;
 574     }
 575 
 576     public boolean isNoType(TypeMirror t) {
 577         return t.getKind() == NONE;
 578     }
 579 
 580     public boolean isOrdinaryClass(TypeElement te) {
 581         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 582             return false;
 583         }
 584         if (isError(te) || isException(te)) {
 585             return false;
 586         }
 587         return true;
 588     }
 589 
 590     public boolean isUndocumentedEnclosure(TypeElement enclosingTypeElement) {
 591         return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))
 592                 &amp;&amp; !isLinkable(enclosingTypeElement);
 593     }
 594 
 595     public boolean isError(TypeElement te) {
 596         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 597             return false;
 598         }
 599         return typeUtils.isSubtype(te.asType(), getErrorType());
 600     }
 601 
 602     public boolean isException(TypeElement te) {
 603         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 604             return false;
 605         }
 606         return typeUtils.isSubtype(te.asType(), getExceptionType());
 607     }
 608 
 609     public boolean isPrimitive(TypeMirror t) {
 610         return new SimpleTypeVisitor9&lt;Boolean, Void&gt;() {
 611 
 612             @Override
 613             public Boolean visitNoType(NoType t, Void p) {
 614                 return t.getKind() == VOID;
 615             }
 616             @Override
 617             public Boolean visitPrimitive(PrimitiveType t, Void p) {
 618                 return true;
 619             }
 620             @Override
 621             public Boolean visitArray(ArrayType t, Void p) {
 622                 return visit(t.getComponentType());
 623             }
 624             @Override
 625             protected Boolean defaultAction(TypeMirror e, Void p) {
 626                 return false;
 627             }
 628         }.visit(t);
 629     }
 630 
 631     public boolean isExecutableElement(Element e) {
 632         ElementKind kind = e.getKind();
 633         switch (kind) {
 634             case CONSTRUCTOR: case METHOD: case INSTANCE_INIT:
 635                 return true;
 636             default:
 637                 return false;
 638         }
 639     }
 640 
 641     public boolean isVariableElement(Element e) {
 642         ElementKind kind = e.getKind();
 643         switch(kind) {
 644               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 645               case LOCAL_VARIABLE: case PARAMETER:
 646               case RESOURCE_VARIABLE:
 647                   return true;
 648               default:
 649                   return false;
 650         }
 651     }
 652 
 653     public boolean isTypeElement(Element e) {
 654         switch (e.getKind()) {
 655             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 656                 return true;
 657             default:
 658                 return false;
 659         }
 660     }
 661 
 662     /**
 663      * Get the signature of an executable element with qualified parameter types
 664      * in the context of type element {@code site}.
 665      * For instance, for a method {@code mymethod(String x, int y)},
 666      * it will return {@code (java.lang.String,int)}.
 667      *
 668      * @param e the executable element
 669      * @param site the contextual site
 670      * @return String signature with qualified parameter types
 671      */
 672     public String signature(ExecutableElement e, TypeElement site) {
 673         return makeSignature(e, site, true);
 674     }
 675 
 676     /**
 677      * Get the flat signature of an executable element with simple (unqualified)
 678      * parameter types in the context of type element {@code site}.
 679      * For instance, for a method {@code mymethod(String x, int y)},
 680      * it will return {@code (String, int)}.
 681      *
 682      * @param e the executable element
 683      * @param site the contextual site
 684      * @return String signature with simple (unqualified) parameter types
 685      */
 686     public String flatSignature(ExecutableElement e, TypeElement site) {
 687         return makeSignature(e, site, false);
 688     }
 689 
 690     public String makeSignature(ExecutableElement e, TypeElement site, boolean full) {
 691         return makeSignature(e, site, full, false);
 692     }
 693 
 694     public String makeSignature(ExecutableElement e, TypeElement site, boolean full, boolean ignoreTypeParameters) {
 695         StringBuilder result = new StringBuilder();
 696         result.append(&quot;(&quot;);
 697         ExecutableType executableType = asInstantiatedMethodType(site, e);
 698         Iterator&lt;? extends TypeMirror&gt; iterator = executableType.getParameterTypes().iterator();
 699         while (iterator.hasNext()) {
 700             TypeMirror type = iterator.next();
 701             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 702             if (iterator.hasNext()) {
 703                 result.append(&quot;, &quot;);
 704             }
 705         }
 706         if (e.isVarArgs()) {
 707             int len = result.length();
 708             result.replace(len - 2, len, &quot;...&quot;);
 709         }
 710         result.append(&quot;)&quot;);
 711         return result.toString();
 712     }
 713 
 714     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 715         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 716             final StringBuilder sb = new StringBuilder();
 717 
 718             @Override
 719             public StringBuilder visitArray(ArrayType t, Void p) {
 720                 TypeMirror componentType = t.getComponentType();
 721                 visit(componentType);
 722                 sb.append(&quot;[]&quot;);
 723                 return sb;
 724             }
 725 
 726             @Override
 727             public StringBuilder visitDeclared(DeclaredType t, Void p) {
 728                 Element e = t.asElement();
 729                 sb.append(qualifiedName ? getFullyQualifiedName(e) : getSimpleName(e));
 730                 List&lt;? extends TypeMirror&gt; typeArguments = t.getTypeArguments();
 731                 if (typeArguments.isEmpty() || noTypeParameters) {
 732                     return sb;
 733                 }
 734                 sb.append(&quot;&lt;&quot;);
 735                 Iterator&lt;? extends TypeMirror&gt; iterator = typeArguments.iterator();
 736                 while (iterator.hasNext()) {
 737                     TypeMirror ta = iterator.next();
 738                     visit(ta);
 739                     if (iterator.hasNext()) {
 740                         sb.append(&quot;, &quot;);
 741                     }
 742                 }
 743                 sb.append(&quot;&gt;&quot;);
 744                 return sb;
 745             }
 746 
 747             @Override
 748             public StringBuilder visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
 749                 Element e = t.asElement();
 750                 sb.append(qualifiedName ? getFullyQualifiedName(e, false) : getSimpleName(e));
 751                 return sb;
 752             }
 753 
 754             @Override
 755             public StringBuilder visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
 756                 sb.append(&quot;?&quot;);
 757                 TypeMirror upperBound = t.getExtendsBound();
 758                 if (upperBound != null) {
 759                     sb.append(&quot; extends &quot;);
 760                     visit(upperBound);
 761                 }
 762                 TypeMirror superBound = t.getSuperBound();
 763                 if (superBound != null) {
 764                     sb.append(&quot; super &quot;);
 765                     visit(superBound);
 766                 }
 767                 return sb;
 768             }
 769 
 770             @Override
 771             protected StringBuilder defaultAction(TypeMirror e, Void p) {
 772                 return sb.append(e);
 773             }
 774         }.visit(t).toString();
 775     }
 776 
 777     public boolean isArrayType(TypeMirror t) {
 778         return t.getKind() == ARRAY;
 779     }
 780 
 781     public boolean isDeclaredType(TypeMirror t) {
 782         return t.getKind() == DECLARED;
 783     }
 784 
 785     public boolean isErrorType(TypeMirror t) {
 786         return t.getKind() == ERROR;
 787     }
 788 
 789     public boolean isIntersectionType(TypeMirror t) {
 790         return t.getKind() == INTERSECTION;
 791     }
 792 
 793     public boolean isTypeParameterElement(Element e) {
 794         return e.getKind() == TYPE_PARAMETER;
 795     }
 796 
 797     public boolean isTypeVariable(TypeMirror t) {
 798         return t.getKind() == TYPEVAR;
 799     }
 800 
 801     public boolean isVoid(TypeMirror t) {
 802         return t.getKind() == VOID;
 803     }
 804 
 805     public boolean isWildCard(TypeMirror t) {
 806         return t.getKind() == WILDCARD;
 807     }
 808 
 809     public boolean ignoreBounds(TypeMirror bound) {
 810         return bound.equals(getObjectType()) &amp;&amp; !isAnnotated(bound);
 811     }
 812 
 813     /*
 814      * a direct port of TypeVariable.getBounds
 815      */
 816     public List&lt;? extends TypeMirror&gt; getBounds(TypeParameterElement tpe) {
 817         List&lt;? extends TypeMirror&gt; bounds = tpe.getBounds();
 818         if (!bounds.isEmpty()) {
 819             TypeMirror upperBound = bounds.get(bounds.size() - 1);
 820             if (ignoreBounds(upperBound)) {
 821                 return Collections.emptyList();
 822             }
 823         }
 824         return bounds;
 825     }
 826 
 827     /**
 828      * Returns the TypeMirror of the ExecutableElement if it is a method, or null
 829      * if it is a constructor.
 830      * @param site the contextual type
 831      * @param ee the ExecutableElement
 832      * @return the return type
 833      */
 834     public TypeMirror getReturnType(TypeElement site, ExecutableElement ee) {
 835         return ee.getKind() == CONSTRUCTOR ? null : asInstantiatedMethodType(site, ee).getReturnType();
 836     }
 837 
 838     /**
 839      * Returns the ExecutableType corresponding to the type of the method declaration seen as a
 840      * member of a given declared type. This might cause type-variable substitution to kick in.
 841      * @param site the contextual type.
 842      * @param ee the method declaration.
 843      * @return the instantiated method type.
 844      */
 845     public ExecutableType asInstantiatedMethodType(TypeElement site, ExecutableElement ee) {
 846         return shouldInstantiate(site, ee) ?
 847                 (ExecutableType)typeUtils.asMemberOf((DeclaredType)site.asType(), ee) :
 848                 (ExecutableType)ee.asType();
 849     }
 850 
 851     /**
 852      * Returns the TypeMirror corresponding to the type of the field declaration seen as a
 853      * member of a given declared type. This might cause type-variable substitution to kick in.
 854      * @param site the contextual type.
 855      * @param ve the field declaration.
 856      * @return the instantiated field type.
 857      */
 858     public TypeMirror asInstantiatedFieldType(TypeElement site, VariableElement ve) {
 859         return shouldInstantiate(site, ve) ?
 860                 typeUtils.asMemberOf((DeclaredType)site.asType(), ve) :
 861                 ve.asType();
 862     }
 863 
 864     /*
 865      * We should not instantiate if (i) there&#39;s no contextual type declaration, (ii) the declaration
 866      * to which the member belongs to is the same as the one under consideration, (iii) if the
 867      * delcaration to which the member belongs to is not generic.
 868      */
 869     private boolean shouldInstantiate(TypeElement site, Element e) {
 870         return site != null &amp;&amp;
 871                 site != e.getEnclosingElement() &amp;&amp;
 872                !((DeclaredType)e.getEnclosingElement().asType()).getTypeArguments().isEmpty();
 873     }
 874 
 875     /**
 876      * Return the type containing the method that this method overrides.
 877      * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
 878      */
 879     public TypeMirror overriddenType(ExecutableElement method) {
 880         return configuration.workArounds.overriddenType(method);
 881     }
 882 
 883     private  TypeMirror getType(TypeMirror t) {
 884         return (isNoType(t)) ? getObjectType() : t;
 885     }
 886 
 887     public TypeMirror getSuperType(TypeElement te) {
 888         TypeMirror t = te.getSuperclass();
 889         return getType(t);
 890     }
 891 
 892     /**
 893      * Return the class that originally defined the method that
 894      * is overridden by the current definition, or null if no
 895      * such class exists.
 896      *
 897      * @return a TypeElement representing the superclass that
 898      * originally defined this method, null if this method does
 899      * not override a definition in a superclass.
 900      */
 901     public TypeElement overriddenClass(ExecutableElement ee) {
 902         TypeMirror type = overriddenType(ee);
 903         return (type != null) ? asTypeElement(type) : null;
 904     }
 905 
 906     public ExecutableElement overriddenMethod(ExecutableElement method) {
 907         if (isStatic(method)) {
 908             return null;
 909         }
 910         final TypeElement origin = getEnclosingTypeElement(method);
 911         for (TypeMirror t = getSuperType(origin);
 912                 t.getKind() == DECLARED;
 913                 t = getSuperType(asTypeElement(t))) {
 914             TypeElement te = asTypeElement(t);
 915             if (te == null) {
 916                 return null;
 917             }
 918             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 919             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 920                 ExecutableElement ee = (ExecutableElement)e;
 921                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 922                         !isSimpleOverride(ee)) {
 923                     return ee;
 924                 }
 925             }
 926             if (t.equals(getObjectType()))
 927                 return null;
 928         }
 929         return null;
 930     }
 931 
 932     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 933         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());
 934         typeElements.forEach(set::add);
 935         return set;
 936     }
 937 
 938     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 939         return getBlockTags(member, SERIAL_DATA);
 940     }
 941 
 942     public FileObject getFileObject(TypeElement te) {
 943         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 944     }
 945 
 946     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 947         return getDeclaredType(Collections.emptyList(), enclosing, target);
 948     }
 949 
 950     /**
 951      * Finds the declaration of the enclosing&#39;s type parameter.
 952      *
 953      * @param values
 954      * @param enclosing a TypeElement whose type arguments  we desire
 955      * @param target the TypeMirror of the type as described by the enclosing
 956      * @return
 957      */
 958     public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
 959                                       TypeElement enclosing, TypeMirror target) {
 960         TypeElement targetElement = asTypeElement(target);
 961         List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
 962         if (targetTypeArgs.isEmpty()) {
 963             return target;
 964         }
 965 
 966         List&lt;? extends TypeParameterElement&gt; enclosingTypeArgs = enclosing.getTypeParameters();
 967         List&lt;TypeMirror&gt; targetTypeArgTypes = new ArrayList&lt;&gt;(targetTypeArgs.size());
 968 
 969         if (enclosingTypeArgs.isEmpty()) {
 970             for (TypeMirror te : values) {
 971                 List&lt;? extends TypeMirror&gt; typeArguments = ((DeclaredType)te).getTypeArguments();
 972                 if (typeArguments.size() &gt;= targetTypeArgs.size()) {
 973                     for (int i = 0 ; i &lt; targetTypeArgs.size(); i++) {
 974                         targetTypeArgTypes.add(typeArguments.get(i));
 975                     }
 976                     break;
 977                 }
 978             }
 979             // we found no matches in the hierarchy
 980             if (targetTypeArgTypes.isEmpty()) {
 981                 return target;
 982             }
 983         } else {
 984             if (targetTypeArgs.size() &gt; enclosingTypeArgs.size()) {
 985                 return target;
 986             }
 987             for (int i = 0; i &lt; targetTypeArgs.size(); i++) {
 988                 TypeParameterElement tpe = enclosingTypeArgs.get(i);
 989                 targetTypeArgTypes.add(tpe.asType());
 990             }
 991         }
 992         TypeMirror dt = typeUtils.getDeclaredType(targetElement,
 993                 targetTypeArgTypes.toArray(new TypeMirror[targetTypeArgTypes.size()]));
 994         return dt;
 995     }
 996 
 997     /**
 998      * Returns all the implemented super-interfaces of a given type,
 999      * in the case of classes, include all the super-interfaces of
1000      * the supertype. The super-interfaces are collected before the
1001      * super-interfaces of the supertype.
1002      *
1003      * @param  te the type element to get the super-interfaces for.
1004      * @return the list of super-interfaces.
1005      */
1006     public Set&lt;TypeMirror&gt; getAllInterfaces(TypeElement te) {
1007         Set&lt;TypeMirror&gt; results = new LinkedHashSet&lt;&gt;();
1008         getAllInterfaces(te.asType(), results);
1009         return results;
1010     }
1011 
1012     private void getAllInterfaces(TypeMirror type, Set&lt;TypeMirror&gt; results) {
1013         List&lt;? extends TypeMirror&gt; intfacs = typeUtils.directSupertypes(type);
1014         TypeMirror superType = null;
1015         for (TypeMirror intfac : intfacs) {
1016             if (intfac == getObjectType())
1017                 continue;
1018             TypeElement e = asTypeElement(intfac);
1019             if (isInterface(e)) {
1020                 if (isPublic(e) || isLinkable(e))
1021                     results.add(intfac);
1022 
1023                 getAllInterfaces(intfac, results);
1024             } else {
1025                 // Save the supertype for later.
1026                 superType = intfac;
1027             }
1028         }
1029         // Collect the super-interfaces of the supertype.
1030         if (superType != null)
1031             getAllInterfaces(superType, results);
1032     }
1033 
1034     /**
1035      * Lookup for a class within this package.
1036      *
1037      * @return TypeElement of found class, or null if not found.
1038      */
1039     public TypeElement findClassInPackageElement(PackageElement pkg, String className) {
1040         for (TypeElement c : getAllClasses(pkg)) {
1041             if (getSimpleName(c).equals(className)) {
1042                 return c;
1043             }
1044         }
1045         return null;
1046     }
1047 
1048     /**
1049      * TODO: FIXME: port to javax.lang.model
1050      * Find a class within the context of this class. Search order: qualified name, in this class
1051      * (inner), in this package, in the class imports, in the package imports. Return the
1052      * TypeElement if found, null if not found.
1053      */
1054     //### The specified search order is not the normal rule the
1055     //### compiler would use.  Leave as specified or change it?
1056     public TypeElement findClass(Element element, String className) {
1057         TypeElement encl = getEnclosingTypeElement(element);
1058         TypeElement searchResult = configuration.workArounds.searchClass(encl, className);
1059         if (searchResult == null) {
1060             encl = getEnclosingTypeElement(encl);
1061             //Expand search space to include enclosing class.
1062             while (encl != null &amp;&amp; getEnclosingTypeElement(encl) != null) {
1063                 encl = getEnclosingTypeElement(encl);
1064             }
1065             searchResult = encl == null
1066                     ? null
1067                     : configuration.workArounds.searchClass(encl, className);
1068         }
1069         return searchResult;
1070     }
1071 
1072     /**
1073      * Enclose in quotes, used for paths and filenames that contains spaces
1074      */
1075     public String quote(String filepath) {
1076         return (&quot;\&quot;&quot; + filepath + &quot;\&quot;&quot;);
1077     }
1078 
1079     /**
1080      * Parse the package name.  We only want to display package name up to
1081      * 2 levels.
1082      */
1083     public String parsePackageName(PackageElement p) {
1084         String pkgname = p.isUnnamed() ? &quot;&quot; : getPackageName(p);
1085         int index = -1;
1086         for (int j = 0; j &lt; MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {
1087             index = pkgname.indexOf(&quot;.&quot;, index + 1);
1088         }
1089         if (index != -1) {
1090             pkgname = pkgname.substring(0, index);
1091         }
1092         return pkgname;
1093     }
1094 
1095     /**
1096      * Given a string, replace all occurrences of &#39;newStr&#39; with &#39;oldStr&#39;.
1097      * @param originalStr the string to modify.
1098      * @param oldStr the string to replace.
1099      * @param newStr the string to insert in place of the old string.
1100      */
1101     public String replaceText(String originalStr, String oldStr,
1102             String newStr) {
1103         if (oldStr == null || newStr == null || oldStr.equals(newStr)) {
1104             return originalStr;
1105         }
1106         return originalStr.replace(oldStr, newStr);
1107     }
1108 
1109     /**
1110      * Given an annotation, return true if it should be documented and false
1111      * otherwise.
1112      *
1113      * @param annotation the annotation to check.
1114      *
1115      * @return true return true if it should be documented and false otherwise.
1116      */
1117     public boolean isDocumentedAnnotation(TypeElement annotation) {
1118         for (AnnotationMirror anno : annotation.getAnnotationMirrors()) {
1119             if (getFullyQualifiedName(anno.getAnnotationType().asElement()).equals(
1120                     Documented.class.getName())) {
1121                 return true;
1122             }
1123         }
1124         return false;
1125     }
1126 
1127     /**
1128      * Returns true if this class is linkable and false if we can&#39;t link to it.
1129      *
1130      * &lt;p&gt;
1131      * &lt;b&gt;NOTE:&lt;/b&gt;  You can only link to external classes if they are public or
1132      * protected.
1133      *
1134      * @return true if this class is linkable and false if we can&#39;t link to the
1135      * desired class.
1136      */
1137     public boolean isLinkable(TypeElement typeElem) {
1138         return
1139             (typeElem != null &amp;&amp;
1140                 (isIncluded(typeElem) &amp;&amp; configuration.isGeneratedDoc(typeElem))) ||
1141             (configuration.extern.isExternal(typeElem) &amp;&amp;
1142                 (isPublic(typeElem) || isProtected(typeElem)));
1143     }
1144 
1145     /**
1146      * Returns true if an element is linkable in the context of a given type element.
1147      *
1148      * If the element is a type element, it delegates to {@link #isLinkable(TypeElement)}.
1149      * Otherwise, the element is linkable if any of the following are true:
1150      * &lt;ul&gt;
1151      * &lt;li&gt;it is &quot;included&quot; (see {@link jdk.javadoc.doclet})
1152      * &lt;li&gt;it is inherited from an undocumented supertype
1153      * &lt;li&gt;it is a public or protected member of an external API
1154      * &lt;/ul&gt;
1155      *
1156      * @param typeElem the type element
1157      * @param elem the element
1158      * @return whether or not the element is linkable
1159      */
1160     public boolean isLinkable(TypeElement typeElem, Element elem) {
1161         if (isTypeElement(elem)) {
1162             return isLinkable((TypeElement) elem); // defer to existing behavior
1163         }
1164 
1165         if (isIncluded(elem)) {
1166             return true;
1167         }
1168 
1169         // Allow for the behavior that members of undocumented supertypes
1170         // may be included in documented types
1171         if (isUndocumentedEnclosure(getEnclosingTypeElement(elem))) {
1172             return true;
1173         }
1174 
1175         // Allow for external members
1176         return isLinkable(typeElem)
1177                     &amp;&amp; configuration.extern.isExternal(typeElem)
1178                     &amp;&amp; (isPublic(elem) || isProtected(elem));
1179     }
1180 
1181     /**
1182      * Return this type as a {@code TypeElement} if it represents a class
1183      * interface or annotation.  Array dimensions are ignored.
1184      * If this type {@code ParameterizedType} or {@code WildcardType}, return
1185      * the {@code TypeElement} of the type&#39;s erasure.  If this is an
1186      * annotation, return this as a {@code TypeElement}.
1187      * If this is a primitive type, return null.
1188      *
1189      * @return the {@code TypeElement} of this type,
1190      *         or null if it is a primitive type.
1191      */
1192     public TypeElement asTypeElement(TypeMirror t) {
1193         return new SimpleTypeVisitor9&lt;TypeElement, Void&gt;() {
1194 
1195             @Override
1196             public TypeElement visitDeclared(DeclaredType t, Void p) {
1197                 return (TypeElement) t.asElement();
1198             }
1199 
1200             @Override
1201             public TypeElement visitArray(ArrayType t, Void p) {
1202                 return visit(t.getComponentType());
1203             }
1204 
1205             @Override
1206             public TypeElement visitTypeVariable(TypeVariable t, Void p) {
1207                /* TODO, this may not be an optimal fix.
1208                 * if we have an annotated type @DA T, then erasure returns a
1209                 * none, in this case we use asElement instead.
1210                 */
1211                 if (isAnnotated(t)) {
1212                     return visit(typeUtils.asElement(t).asType());
1213                 }
1214                 return visit(typeUtils.erasure(t));
1215             }
1216 
1217             @Override
1218             public TypeElement visitWildcard(WildcardType t, Void p) {
1219                 return visit(typeUtils.erasure(t));
1220             }
1221 
1222             @Override
1223             public TypeElement visitError(ErrorType t, Void p) {
1224                 return (TypeElement)t.asElement();
1225             }
1226 
1227             @Override
1228             protected TypeElement defaultAction(TypeMirror e, Void p) {
1229                 return super.defaultAction(e, p);
1230             }
1231         }.visit(t);
1232     }
1233 
1234     public TypeMirror getComponentType(TypeMirror t) {
1235         while (isArrayType(t)) {
1236             t = ((ArrayType) t).getComponentType();
1237         }
1238         return t;
1239     }
1240 
1241     /**
1242      * Return the type&#39;s dimension information, as a string.
1243      * &lt;p&gt;
1244      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1245      *
1246      * @return the type&#39;s dimension information as a string.
1247      */
1248     public String getDimension(TypeMirror t) {
1249         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1250             StringBuilder dimension = new StringBuilder();
1251             @Override
1252             public String visitArray(ArrayType t, Void p) {
1253                 dimension.append(&quot;[]&quot;);
1254                 return visit(t.getComponentType());
1255             }
1256 
1257             @Override
1258             protected String defaultAction(TypeMirror e, Void p) {
1259                 return dimension.toString();
1260             }
1261 
1262         }.visit(t);
1263     }
1264 
1265     public TypeElement getSuperClass(TypeElement te) {
1266         if (isInterface(te) || isAnnotationType(te) ||
1267                 te.asType().equals(getObjectType())) {
1268             return null;
1269         }
1270         TypeMirror superclass = te.getSuperclass();
1271         if (isNoType(superclass) &amp;&amp; isClass(te)) {
1272             superclass = getObjectType();
1273         }
1274         return asTypeElement(superclass);
1275     }
1276 
1277     public TypeElement getFirstVisibleSuperClassAsTypeElement(TypeElement te) {
1278         if (isAnnotationType(te) || isInterface(te) ||
1279                 te.asType().equals(getObjectType())) {
1280             return null;
1281         }
1282         TypeMirror firstVisibleSuperClass = getFirstVisibleSuperClass(te);
1283         return firstVisibleSuperClass == null ? null : asTypeElement(firstVisibleSuperClass);
1284     }
1285 
1286     /**
1287      * Given a class, return the closest visible super class.
1288      * @param type the TypeMirror to be interrogated
1289      * @return  the closest visible super class.  Return null if it cannot
1290      *          be found.
1291      */
1292 
1293     public TypeMirror getFirstVisibleSuperClass(TypeMirror type) {
1294         return getFirstVisibleSuperClass(asTypeElement(type));
1295     }
1296 
1297 
1298     /**
1299      * Given a class, return the closest visible super class.
1300      *
1301      * @param te the TypeElement to be interrogated
1302      * @return the closest visible super class.  Return null if it cannot
1303      *         be found..
1304      */
1305     public TypeMirror getFirstVisibleSuperClass(TypeElement te) {
1306         TypeMirror superType = te.getSuperclass();
1307         if (isNoType(superType)) {
1308             superType = getObjectType();
1309         }
1310         TypeElement superClass = asTypeElement(superType);
1311         // skip &quot;hidden&quot; classes
1312         while ((superClass != null &amp;&amp; hasHiddenTag(superClass))
1313                 || (superClass != null &amp;&amp;  !isPublic(superClass) &amp;&amp; !isLinkable(superClass))) {
1314             TypeMirror supersuperType = superClass.getSuperclass();
1315             TypeElement supersuperClass = asTypeElement(supersuperType);
1316             if (supersuperClass == null
1317                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1318                 break;
1319             }
1320             superType = supersuperType;
1321             superClass = supersuperClass;
1322         }
1323         if (te.asType().equals(superType)) {
1324             return null;
1325         }
1326         return superType;
1327     }
1328 
1329     /**
1330      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1331      *
1332      * @param te the TypeElement to check.
1333      * @param lowerCaseOnly true if you want the name returned in lower case.
1334      *                      If false, the first letter of the name is capitalized.
1335      * @return
1336      */
1337     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1338         String typeName = &quot;&quot;;
1339         if (isInterface(te)) {
1340             typeName = &quot;doclet.Interface&quot;;
1341         } else if (isException(te)) {
1342             typeName = &quot;doclet.Exception&quot;;
1343         } else if (isError(te)) {
1344             typeName = &quot;doclet.Error&quot;;
1345         } else if (isAnnotationType(te)) {
1346             typeName = &quot;doclet.AnnotationType&quot;;
1347         } else if (isEnum(te)) {
1348             typeName = &quot;doclet.Enum&quot;;
1349         } else if (isOrdinaryClass(te)) {
1350             typeName = &quot;doclet.Class&quot;;
1351         }
1352         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1353         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1354     }
1355 
1356     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
1357 
1358     public String getTypeName(TypeMirror t, boolean fullyQualified) {
1359         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1360 
1361             @Override
1362             public String visitArray(ArrayType t, Void p) {
1363                 return visit(t.getComponentType());
1364             }
1365 
1366             @Override
1367             public String visitDeclared(DeclaredType t, Void p) {
1368                 TypeElement te = asTypeElement(t);
1369                 return fullyQualified
1370                         ? te.getQualifiedName().toString()
1371                         : getSimpleName(te);
1372             }
1373 
1374             @Override
1375             public String visitExecutable(ExecutableType t, Void p) {
1376                 return t.toString();
1377             }
1378 
1379             @Override
1380             public String visitPrimitive(PrimitiveType t, Void p) {
1381                 return t.toString();
1382             }
1383 
1384             @Override
1385             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1386                 return getSimpleName(t.asElement());
1387             }
1388 
1389             @Override
1390             public String visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
1391                 return t.toString();
1392             }
1393 
1394             @Override
1395             protected String defaultAction(TypeMirror e, Void p) {
1396                 return e.toString();
1397             }
1398         }.visit(t);
1399     }
1400 
1401     /**
1402      * Replace all tabs in a string with the appropriate number of spaces.
1403      * The string may be a multi-line string.
1404      * @param text the text for which the tabs should be expanded
1405      * @return the text with all tabs expanded
1406      */
1407     public String replaceTabs(String text) {
1408         if (!text.contains(&quot;\t&quot;))
1409             return text;
1410 
1411         final int tabLength = options.sourceTabSize();
1412         final String whitespace = &quot; &quot;.repeat(tabLength);
1413         final int textLength = text.length();
1414         StringBuilder result = new StringBuilder(textLength);
1415         int pos = 0;
1416         int lineLength = 0;
1417         for (int i = 0; i &lt; textLength; i++) {
1418             char ch = text.charAt(i);
1419             switch (ch) {
1420                 case &#39;\n&#39;: case &#39;\r&#39;:
1421                     lineLength = 0;
1422                     break;
1423                 case &#39;\t&#39;:
1424                     result.append(text, pos, i);
1425                     int spaceCount = tabLength - lineLength % tabLength;
1426                     result.append(whitespace, 0, spaceCount);
1427                     lineLength += spaceCount;
1428                     pos = i + 1;
1429                     break;
1430                 default:
1431                     lineLength++;
1432             }
1433         }
1434         result.append(text, pos, textLength);
1435         return result.toString();
1436     }
1437 
1438     public CharSequence normalizeNewlines(CharSequence text) {
1439         StringBuilder sb = new StringBuilder();
1440         final int textLength = text.length();
1441         final String NL = DocletConstants.NL;
1442         int pos = 0;
1443         for (int i = 0; i &lt; textLength; i++) {
1444             char ch = text.charAt(i);
1445             switch (ch) {
1446                 case &#39;\n&#39;:
1447                     sb.append(text, pos, i);
1448                     sb.append(NL);
1449                     pos = i + 1;
1450                     break;
1451                 case &#39;\r&#39;:
1452                     sb.append(text, pos, i);
1453                     sb.append(NL);
1454                     if (i + 1 &lt; textLength &amp;&amp; text.charAt(i + 1) == &#39;\n&#39;)
1455                         i++;
1456                     pos = i + 1;
1457                     break;
1458             }
1459         }
1460         sb.append(text, pos, textLength);
1461         return sb;
1462     }
1463 
1464     /**
1465      * Returns a locale independent lower cased String. That is, it
1466      * always uses US locale, this is a clone of the one in StringUtils.
1467      * @param s to convert
1468      * @return converted String
1469      */
1470     public static String toLowerCase(String s) {
1471         return s.toLowerCase(Locale.US);
1472     }
1473 
1474     /**
1475      * Return true if the given Element is deprecated.
1476      *
1477      * @param e the Element to check.
1478      * @return true if the given Element is deprecated.
1479      */
1480     public boolean isDeprecated(Element e) {
1481         if (isPackage(e)) {
1482             return configuration.workArounds.isDeprecated0(e);
1483         }
1484         return elementUtils.isDeprecated(e);
1485     }
1486 
1487     /**
1488      * Return true if the given Element is deprecated for removal.
1489      *
1490      * @param e the Element to check.
1491      * @return true if the given Element is deprecated for removal.
1492      */
1493     public boolean isDeprecatedForRemoval(Element e) {
1494         List&lt;? extends AnnotationMirror&gt; annotationList = e.getAnnotationMirrors();
1495         JavacTypes jctypes = ((DocEnvImpl) configuration.docEnv).toolEnv.typeutils;
1496         for (AnnotationMirror anno : annotationList) {
1497             if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), getDeprecatedType())) {
1498                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = anno.getElementValues();
1499                 if (!pairs.isEmpty()) {
1500                     for (ExecutableElement element : pairs.keySet()) {
1501                         if (element.getSimpleName().contentEquals(&quot;forRemoval&quot;)) {
1502                             return Boolean.parseBoolean((pairs.get(element)).toString());
1503                         }
1504                     }
1505                 }
1506             }
1507         }
1508         return false;
1509     }
1510 
1511     /**
1512      * A convenience method to get property name from the name of the
1513      * getter or setter method.
1514      * @param e the input method.
1515      * @return the name of the property of the given setter of getter.
1516      */
1517     public String propertyName(ExecutableElement e) {
1518         String name = getSimpleName(e);
1519         String propertyName = null;
1520         if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {
1521             propertyName = name.substring(3);
1522         } else if (name.startsWith(&quot;is&quot;)) {
1523             propertyName = name.substring(2);
1524         }
1525         if ((propertyName == null) || propertyName.isEmpty()){
1526             return &quot;&quot;;
1527         }
1528         return propertyName.substring(0, 1).toLowerCase(configuration.getLocale())
1529                 + propertyName.substring(1);
1530     }
1531 
1532     /**
1533      * Returns true if the element is included, contains &amp;#64;hidden tag,
1534      * or if javafx flag is present and element contains &amp;#64;treatAsPrivate
1535      * tag.
1536      * @param e the queried element
1537      * @return true if it exists, false otherwise
1538      */
1539     public boolean hasHiddenTag(Element e) {
1540         // prevent needless tests on elements which are not included
1541         if (!isIncluded(e)) {
1542             return false;
1543         }
1544         if (options.javafx() &amp;&amp;
1545                 hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
1546             return true;
1547         }
1548         return hasBlockTag(e, DocTree.Kind.HIDDEN);
1549     }
1550 
1551     /**
1552      * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
1553      * @param m a method
1554      * @return true if there are no comments, false otherwise
1555      */
1556     public boolean isSimpleOverride(ExecutableElement m) {
1557         if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {
1558             return false;
1559         }
1560 
1561         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1562             return false;
1563 
1564         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1565         return fullBody.isEmpty() ||
1566                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1567     }
1568 
1569     /**
1570      * In case of JavaFX mode on, filters out classes that are private,
1571      * package private, these are not documented in JavaFX mode, also
1572      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1573      *
1574      * @param classlist a collection of TypeElements
1575      * @param javafx set to true if in JavaFX mode.
1576      * @return list of filtered classes.
1577      */
1578     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1579             boolean javafx) {
1580         SortedSet&lt;TypeElement&gt; filteredOutClasses =
1581                 new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());
1582         if (!javafx) {
1583             for (Element te : classlist) {
1584                 if (!hasHiddenTag(te)) {
1585                     filteredOutClasses.add((TypeElement)te);
1586                 }
1587             }
1588             return filteredOutClasses;
1589         }
1590         for (Element e : classlist) {
1591             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1592                 continue;
1593             }
1594             filteredOutClasses.add((TypeElement)e);
1595         }
1596         return filteredOutClasses;
1597     }
1598 
1599     /**
1600      * Compares two elements.
1601      * @param e1 first Element
1602      * @param e2 second Element
1603      * @return a true if they are the same, false otherwise.
1604      */
1605     public boolean elementsEqual(Element e1, Element e2) {
1606         if (e1.getKind() != e2.getKind()) {
1607             return false;
1608         }
1609         String s1 = getSimpleName(e1);
1610         String s2 = getSimpleName(e2);
1611         if (compareStrings(s1, s2) == 0) {
1612             String f1 = getFullyQualifiedName(e1, true);
1613             String f2 = getFullyQualifiedName(e2, true);
1614             return compareStrings(f1, f2) == 0;
1615         }
1616         return false;
1617     }
1618 
1619     /**
1620      * A general purpose case insensitive String comparator, which compares
1621      * two Strings using a Collator strength of &quot;TERTIARY&quot;.
1622      *
1623      * @param s1 first String to compare.
1624      * @param s2 second String to compare.
1625      * @return a negative integer, zero, or a positive integer as the first
1626      *         argument is less than, equal to, or greater than the second.
1627      */
1628     public int compareStrings(String s1, String s2) {
1629         return compareStrings(true, s1, s2);
1630     }
1631 
1632     /**
1633      * A general purpose case sensitive String comparator, which
1634      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1635      *
1636      * @param s1 first String to compare.
1637      * @param s2 second String to compare.
1638      * @return a negative integer, zero, or a positive integer as the first
1639      *         argument is less than, equal to, or greater than the second.
1640      */
1641     public int compareCaseCompare(String s1, String s2) {
1642         return compareStrings(false, s1, s2);
1643     }
1644 
1645     private DocCollator tertiaryCollator = null;
1646     private DocCollator secondaryCollator = null;
1647 
1648     int compareStrings(boolean caseSensitive, String s1, String s2) {
1649         if (caseSensitive) {
1650             if (tertiaryCollator == null) {
1651                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1652             }
1653             return tertiaryCollator.compare(s1, s2);
1654         }
1655         if (secondaryCollator == null) {
1656             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1657         }
1658         return secondaryCollator.compare(s1, s2);
1659     }
1660 
1661     public String getHTMLTitle(Element element) {
1662         List&lt;? extends DocTree&gt; preamble = getPreamble(element);
1663         StringBuilder sb = new StringBuilder();
1664         boolean titleFound = false;
1665         loop:
1666         for (DocTree dt : preamble) {
1667             switch (dt.getKind()) {
1668                 case START_ELEMENT:
1669                     StartElementTree nodeStart = (StartElementTree)dt;
1670                     if (Utils.toLowerCase(nodeStart.getName().toString()).equals(&quot;title&quot;)) {
1671                         titleFound = true;
1672                     }
1673                     break;
1674 
1675                 case END_ELEMENT:
1676                     EndElementTree nodeEnd = (EndElementTree)dt;
1677                     if (Utils.toLowerCase(nodeEnd.getName().toString()).equals(&quot;title&quot;)) {
1678                         break loop;
1679                     }
1680                     break;
1681 
1682                 case TEXT:
1683                     TextTree nodeText = (TextTree)dt;
1684                     if (titleFound)
1685                         sb.append(nodeText.getBody());
1686                     break;
1687 
1688                 default:
1689                     // do nothing
1690             }
1691         }
1692         return sb.toString().trim();
1693     }
1694 
1695     private static class DocCollator {
1696         private final Map&lt;String, CollationKey&gt; keys;
1697         private final Collator instance;
1698         private final int MAX_SIZE = 1000;
1699         private DocCollator(Locale locale, int strength) {
1700             instance = createCollator(locale);
1701             instance.setStrength(strength);
1702 
1703             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1704                 private static final long serialVersionUID = 1L;
1705                 @Override
1706                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1707                     return size() &gt; MAX_SIZE;
1708                 }
1709             };
1710         }
1711 
1712         CollationKey getKey(String s) {
1713             return keys.computeIfAbsent(s, instance :: getCollationKey);
1714         }
1715 
1716         public int compare(String s1, String s2) {
1717             return getKey(s1).compareTo(getKey(s2));
1718         }
1719 
1720         private Collator createCollator(Locale locale) {
1721             Collator baseCollator = Collator.getInstance(locale);
1722             if (baseCollator instanceof RuleBasedCollator) {
1723                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1724                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1725                 try {
1726                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1727                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1728                 } catch (ParseException e) {
1729                     throw new RuntimeException(e);
1730                 }
1731             }
1732             return baseCollator;
1733         }
1734     }
1735 
1736     /**
1737      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1738      * getQualified name, returns  the qualified name of the Reference type
1739      * otherwise the primitive name.
1740      * @param t the type whose name is to be obtained.
1741      * @return the fully qualified name of Reference type or the primitive name
1742      */
1743     public String getQualifiedTypeName(TypeMirror t) {
1744         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1745             @Override
1746             public String visitDeclared(DeclaredType t, Void p) {
1747                 return getFullyQualifiedName(t.asElement());
1748             }
1749 
1750             @Override
1751             public String visitArray(ArrayType t, Void p) {
1752                return visit(t.getComponentType());
1753             }
1754 
1755             @Override
1756             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1757                 // The knee jerk reaction is to do this but don&#39;t!, as we would like
1758                 // it to be compatible with the old world, now if we decide to do so
1759                 // care must be taken to avoid collisions.
1760                 // return getFullyQualifiedName(t.asElement());
1761                 return t.toString();
1762             }
1763 
1764             @Override
1765             protected String defaultAction(TypeMirror t, Void p) {
1766                 return t.toString();
1767             }
1768 
1769         }.visit(t);
1770     }
1771 
1772     /**
1773      * A generic utility which returns the fully qualified names of an entity,
1774      * if the entity is not qualifiable then its enclosing entity, it is upto
1775      * the caller to add the elements name as required.
1776      * @param e the element to get FQN for.
1777      * @return the name
1778      */
1779     public String getFullyQualifiedName(Element e) {
1780         return getFullyQualifiedName(e, true);
1781     }
1782 
1783     @SuppressWarnings(&quot;preview&quot;)
1784     public String getFullyQualifiedName(Element e, final boolean outer) {
1785         return new SimpleElementVisitor14&lt;String, Void&gt;() {
1786             @Override
1787             public String visitModule(ModuleElement e, Void p) {
1788                 return e.getQualifiedName().toString();
1789             }
1790 
1791             @Override
1792             public String visitPackage(PackageElement e, Void p) {
1793                 return e.getQualifiedName().toString();
1794             }
1795 
1796             @Override
1797             public String visitType(TypeElement e, Void p) {
1798                 return e.getQualifiedName().toString();
1799             }
1800 
1801             @Override
1802             protected String defaultAction(Element e, Void p) {
1803                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
1804             }
1805         }.visit(e);
1806     }
1807 
1808 
1809     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
1810         List&lt;TypeElement&gt; out = getInterfaces(pkg);
1811         out.addAll(getClasses(pkg));
1812         out.addAll(getEnums(pkg));
1813         out.addAll(getAnnotationTypes(pkg));
1814         out.addAll(getRecords(pkg));
1815         return out;
1816     }
1817 
1818     // Element related methods
1819     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
1820         List&lt;Element&gt; members = getAnnotationFields(aClass);
1821         members.addAll(getAnnotationMethods(aClass));
1822         return members;
1823     }
1824 
1825     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
1826         return getItems0(aClass, true, FIELD);
1827     }
1828 
1829     List&lt;Element&gt; getAnnotationFieldsUnfiltered(TypeElement aClass) {
1830         return getItems0(aClass, true, FIELD);
1831     }
1832 
1833     public List&lt;Element&gt; getAnnotationMethods(TypeElement aClass) {
1834         return getItems0(aClass, true, METHOD);
1835     }
1836 
1837     public List&lt;TypeElement&gt; getAnnotationTypes(Element e) {
1838         return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));
1839     }
1840 
1841     public List&lt;TypeElement&gt; getAnnotationTypesUnfiltered(Element e) {
1842         return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
1843     }
1844 
1845     @SuppressWarnings(&quot;preview&quot;)
1846     public List&lt;TypeElement&gt; getRecords(Element e) {
1847         return convertToTypeElement(getItems(e, true, RECORD));
1848     }
1849 
1850     @SuppressWarnings(&quot;preview&quot;)
1851     public List&lt;TypeElement&gt; getRecordsUnfiltered(Element e) {
1852         return convertToTypeElement(getItems(e, false, RECORD));
1853     }
1854 
1855     public List&lt;VariableElement&gt; getFields(Element e) {
1856         return convertToVariableElement(getItems(e, true, FIELD));
1857     }
1858 
1859     public List&lt;VariableElement&gt; getFieldsUnfiltered(Element e) {
1860         return convertToVariableElement(getItems(e, false, FIELD));
1861     }
1862 
1863     public List&lt;TypeElement&gt; getClasses(Element e) {
1864        return convertToTypeElement(getItems(e, true, CLASS));
1865     }
1866 
1867     public List&lt;TypeElement&gt; getClassesUnfiltered(Element e) {
1868        return convertToTypeElement(getItems(e, false, CLASS));
1869     }
1870 
1871     public List&lt;ExecutableElement&gt; getConstructors(Element e) {
1872         return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));
1873     }
1874 
1875     public List&lt;ExecutableElement&gt; getMethods(Element e) {
1876         return convertToExecutableElement(getItems(e, true, METHOD));
1877     }
1878 
1879     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
1880         return convertToExecutableElement(getItems(e, false, METHOD));
1881     }
1882 
1883     public int getOrdinalValue(VariableElement member) {
1884         if (member == null || member.getKind() != ENUM_CONSTANT) {
1885             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
1886         }
1887         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
1888     }
1889 
1890     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
1891     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
1892         if (modulePackageMap == null) {
1893             modulePackageMap = new HashMap&lt;&gt;();
1894             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
1895             pkgs.forEach(pkg -&gt; {
1896                 ModuleElement mod = elementUtils.getModuleOf(pkg);
1897                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
1898             });
1899         }
1900         return modulePackageMap;
1901     }
1902 
1903     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
1904         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(comparators.makeModuleComparator());
1905         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
1906         // get all the requires for the element in question
1907         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
1908             ModuleElement dep = rd.getDependency();
1909             // add the dependency to work queue
1910             if (!result.containsKey(dep)) {
1911                 if (rd.isTransitive()) {
1912                     queue.addLast(dep);
1913                 }
1914             }
1915             // add all exports for the primary module
1916             result.put(rd.getDependency(), getModifiers(rd));
1917         }
1918 
1919         // add only requires public for subsequent module dependencies
1920         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
1921             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
1922                 ModuleElement dep = rd.getDependency();
1923                 if (!result.containsKey(dep)) {
1924                     if (rd.isTransitive()) {
1925                         result.put(dep, getModifiers(rd));
1926                         queue.addLast(dep);
1927                     }
1928                 }
1929             }
1930         }
1931         return result;
1932     }
1933 
1934     public String getModifiers(RequiresDirective rd) {
1935         StringBuilder modifiers = new StringBuilder();
1936         String sep = &quot;&quot;;
1937         if (rd.isTransitive()) {
1938             modifiers.append(&quot;transitive&quot;);
1939             sep = &quot; &quot;;
1940         }
1941         if (rd.isStatic()) {
1942             modifiers.append(sep);
1943             modifiers.append(&quot;static&quot;);
1944         }
1945         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
1946     }
1947 
1948     public long getLineNumber(Element e) {
1949         TreePath path = getTreePath(e);
1950         if (path == null) { // maybe null if synthesized
1951             TypeElement encl = getEnclosingTypeElement(e);
1952             path = getTreePath(encl);
1953         }
1954         CompilationUnitTree cu = path.getCompilationUnit();
1955         LineMap lineMap = cu.getLineMap();
1956         DocSourcePositions spos = docTrees.getSourcePositions();
1957         long pos = spos.getStartPosition(cu, path.getLeaf());
1958         return lineMap.getLineNumber(pos);
1959     }
1960 
1961     public List&lt;ExecutableElement&gt; convertToExecutableElement(List&lt;Element&gt; list) {
1962         List&lt;ExecutableElement&gt; out = new ArrayList&lt;&gt;(list.size());
1963         for (Element e : list) {
1964             out.add((ExecutableElement)e);
1965         }
1966         return out;
1967     }
1968 
1969     public List&lt;TypeElement&gt; convertToTypeElement(List&lt;Element&gt; list) {
1970         List&lt;TypeElement&gt; out = new ArrayList&lt;&gt;(list.size());
1971         for (Element e : list) {
1972             out.add((TypeElement)e);
1973         }
1974         return out;
1975     }
1976 
1977     public List&lt;VariableElement&gt; convertToVariableElement(List&lt;Element&gt; list) {
1978         List&lt;VariableElement&gt; out = new ArrayList&lt;&gt;(list.size());
1979         for (Element e : list) {
1980             out.add((VariableElement) e);
1981         }
1982         return out;
1983     }
1984 
1985     public List&lt;TypeElement&gt; getInterfaces(Element e)  {
1986         return convertToTypeElement(getItems(e, true, INTERFACE));
1987     }
1988 
1989     public List&lt;TypeElement&gt; getInterfacesUnfiltered(Element e)  {
1990         return convertToTypeElement(getItems(e, false, INTERFACE));
1991     }
1992 
1993     public List&lt;Element&gt; getEnumConstants(Element e) {
1994         return getItems(e, true, ENUM_CONSTANT);
1995     }
1996 
1997     public List&lt;TypeElement&gt; getEnums(Element e) {
1998         return convertToTypeElement(getItems(e, true, ENUM));
1999     }
2000 
2001     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2002         return convertToTypeElement(getItems(e, false, ENUM));
2003     }
2004 
2005     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2006         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2007         clist.addAll(getInterfacesUnfiltered(e));
2008         clist.addAll(getAnnotationTypesUnfiltered(e));
2009         clist.addAll(getRecordsUnfiltered(e));
2010         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());
2011         oset.addAll(clist);
2012         return oset;
2013     }
2014 
2015     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2016     /**
2017      * Returns a list containing classes and interfaces,
2018      * including annotation types.
2019      * @param e Element
2020      * @return List
2021      */
2022     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2023         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2024         if (oset != null)
2025             return oset;
2026         List&lt;TypeElement&gt; clist = getClasses(e);
2027         clist.addAll(getInterfaces(e));
2028         clist.addAll(getAnnotationTypes(e));
2029         clist.addAll(getEnums(e));
2030         clist.addAll(getRecords(e));
2031         oset = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());
2032         oset.addAll(clist);
2033         cachedClasses.put(e, oset);
2034         return oset;
2035     }
2036 
2037     /*
2038      * Get all the elements unfiltered and filter them finally based
2039      * on its visibility, this works differently from the other getters.
2040      */
2041     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2042         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2043         for (TypeElement te : getClassesUnfiltered(e)) {
2044             if (!filter || configuration.docEnv.isSelected(te)) {
2045                 olist.add(te);
2046             }
2047         }
2048         for (TypeElement te : getInterfacesUnfiltered(e)) {
2049             if (!filter || configuration.docEnv.isSelected(te)) {
2050                 olist.add(te);
2051             }
2052         }
2053         for (TypeElement te : getAnnotationTypesUnfiltered(e)) {
2054             if (!filter || configuration.docEnv.isSelected(te)) {
2055                 olist.add(te);
2056             }
2057         }
2058         for (TypeElement te : getEnumsUnfiltered(e)) {
2059             if (!filter || configuration.docEnv.isSelected(te)) {
2060                 olist.add(te);
2061             }
2062         }
2063         return olist;
2064     }
2065 
2066     public List&lt;TypeElement&gt; getInnerClasses(Element e) {
2067         return getInnerClasses(e, true);
2068     }
2069 
2070     public List&lt;TypeElement&gt; getInnerClassesUnfiltered(Element e) {
2071         return getInnerClasses(e, false);
2072     }
2073 
2074     /**
2075      * Returns a list of classes that are not errors or exceptions
2076      * @param e Element
2077      * @return List
2078      */
2079     public List&lt;TypeElement&gt; getOrdinaryClasses(Element e) {
2080         return getClasses(e).stream()
2081                 .filter(te -&gt; (!isException(te) &amp;&amp; !isError(te)))
2082                 .collect(Collectors.toList());
2083     }
2084 
2085     public List&lt;TypeElement&gt; getErrors(Element e) {
2086         return getClasses(e)
2087                 .stream()
2088                 .filter(this::isError)
2089                 .collect(Collectors.toList());
2090     }
2091 
2092     public List&lt;TypeElement&gt; getExceptions(Element e) {
2093         return getClasses(e)
2094                 .stream()
2095                 .filter(this::isException)
2096                 .collect(Collectors.toList());
2097     }
2098 
2099     @SuppressWarnings(&quot;preview&quot;)
2100     List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
2101         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2102         return new SimpleElementVisitor14&lt;List&lt;Element&gt;, Void&gt;() {
2103 
2104             @Override
2105             public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
2106                 recursiveGetItems(elements, e, filter, select);
2107                 return elements;
2108             }
2109 
2110             @Override
2111             protected List&lt;Element&gt; defaultAction(Element e0, Void p) {
2112                 return getItems0(e0, filter, select);
2113             }
2114 
2115         }.visit(e);
2116     }
2117 
2118     Set&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);
2119     void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
2120         list.addAll(getItems0(e, filter, select));
2121         List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
2122         for (Element c : classes) {
2123             list.addAll(getItems0(c, filter, select));
2124             if (isTypeElement(c)) {
2125                 recursiveGetItems(list, c, filter, select);
2126             }
2127         }
2128     }
2129 
2130     private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
2131         Set&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));
2132         return getItems0(te, filter, kinds);
2133     }
2134 
2135     private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
2136         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2137         for (Element e : te.getEnclosedElements()) {
2138             if (kinds.contains(e.getKind())) {
2139                 if (!filter || shouldDocument(e)) {
2140                     elements.add(e);
2141                 }
2142             }
2143         }
2144         return elements;
2145     }
2146 
2147     @SuppressWarnings(&quot;preview&quot;)
2148     private SimpleElementVisitor14&lt;Boolean, Void&gt; shouldDocumentVisitor = null;
2149 
2150     @SuppressWarnings(&quot;preview&quot;)
2151     public boolean shouldDocument(Element e) {
2152         if (shouldDocumentVisitor == null) {
2153             shouldDocumentVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2154                 private boolean hasSource(TypeElement e) {
2155                     return configuration.docEnv.getFileKind(e) ==
2156                             javax.tools.JavaFileObject.Kind.SOURCE;
2157                 }
2158 
2159                 // handle types
2160                 @Override
2161                 public Boolean visitType(TypeElement e, Void p) {
2162                     // treat inner classes etc as members
2163                     if (e.getNestingKind().isNested()) {
2164                         return defaultAction(e, p);
2165                     }
2166                     return configuration.docEnv.isSelected(e) &amp;&amp; hasSource(e);
2167                 }
2168 
2169                 // handle everything else
2170                 @Override
2171                 protected Boolean defaultAction(Element e, Void p) {
2172                     return configuration.docEnv.isSelected(e);
2173                 }
2174 
2175                 @Override
2176                 public Boolean visitUnknown(Element e, Void p) {
2177                     throw new AssertionError(&quot;unknown element: &quot; + e);
2178                 }
2179             };
2180         }
2181         return shouldDocumentVisitor.visit(e);
2182     }
2183 
2184     /*
2185      * nameCache is maintained for improving the comparator
2186      * performance, noting that the Collator used by the comparators
2187      * use Strings, as of this writing.
2188      * TODO: when those APIs handle charSequences, the use of
2189      * this nameCache must be re-investigated and removed.
2190      */
2191     private final Map&lt;Element, String&gt; nameCache = new LinkedHashMap&lt;&gt;();
2192 
2193     /**
2194      * Returns the name of the element after the last dot of the package name.
2195      * This emulates the behavior of the old doclet.
2196      * @param e an element whose name is required
2197      * @return the name
2198      */
2199     public String getSimpleName(Element e) {
2200         return nameCache.computeIfAbsent(e, this::getSimpleName0);
2201     }
2202 
2203     @SuppressWarnings(&quot;preview&quot;)
2204     private SimpleElementVisitor14&lt;String, Void&gt; snvisitor = null;
2205 
2206     @SuppressWarnings(&quot;preview&quot;)
2207     private String getSimpleName0(Element e) {
2208         if (snvisitor == null) {
2209             snvisitor = new SimpleElementVisitor14&lt;String, Void&gt;() {
2210                 @Override
2211                 public String visitModule(ModuleElement e, Void p) {
2212                     return e.getQualifiedName().toString();  // temp fix for 8182736
2213                 }
2214 
2215                 @Override
2216                 public String visitType(TypeElement e, Void p) {
2217                     StringBuilder sb = new StringBuilder(e.getSimpleName());
2218                     Element enclosed = e.getEnclosingElement();
2219                     while (enclosed != null
2220                             &amp;&amp; (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {
2221                         sb.insert(0, enclosed.getSimpleName() + &quot;.&quot;);
2222                         enclosed = enclosed.getEnclosingElement();
2223                     }
2224                     return sb.toString();
2225                 }
2226 
2227                 @Override
2228                 public String visitExecutable(ExecutableElement e, Void p) {
2229                     if (e.getKind() == CONSTRUCTOR || e.getKind() == STATIC_INIT) {
2230                         return e.getEnclosingElement().getSimpleName().toString();
2231                     }
2232                     return e.getSimpleName().toString();
2233                 }
2234 
2235                 @Override
2236                 protected String defaultAction(Element e, Void p) {
2237                     return e.getSimpleName().toString();
2238                 }
2239             };
2240         }
2241         return snvisitor.visit(e);
2242     }
2243 
2244     public TypeElement getEnclosingTypeElement(Element e) {
2245         if (e.getKind() == ElementKind.PACKAGE)
2246             return null;
2247         Element encl = e.getEnclosingElement();
2248         ElementKind kind = encl.getKind();
2249         if (kind == ElementKind.PACKAGE)
2250             return null;
2251         while (!(kind.isClass() || kind.isInterface())) {
2252             encl = encl.getEnclosingElement();
2253             kind = encl.getKind();
2254         }
2255         return (TypeElement)encl;
2256     }
2257 
2258     private ConstantValueExpression cve = null;
2259 
2260     public String constantValueExpresion(VariableElement ve) {
2261         if (cve == null)
2262             cve = new ConstantValueExpression();
2263         return cve.constantValueExpression(configuration.workArounds, ve);
2264     }
2265 
2266     private static class ConstantValueExpression {
2267         public String constantValueExpression(WorkArounds workArounds, VariableElement ve) {
2268             return new TypeKindVisitor9&lt;String, Object&gt;() {
2269                 /* TODO: we need to fix this correctly.
2270                  * we have a discrepancy here, note the use of getConstValue
2271                  * vs. getConstantValue, at some point we need to use
2272                  * getConstantValue.
2273                  * In the legacy world byte and char primitives appear as Integer values,
2274                  * thus a byte value of 127 will appear as 127, but in the new world,
2275                  * a byte value appears as Byte thus 0x7f will be printed, similarly
2276                  * chars will be  translated to \n, \r etc. however, in the new world,
2277                  * they will be printed as decimal values. The new world is correct,
2278                  * and we should fix this by using getConstantValue and the visitor to
2279                  * address this in the future.
2280                  */
2281                 @Override
2282                 public String visitPrimitiveAsBoolean(PrimitiveType t, Object val) {
2283                     return (int)val == 0 ? &quot;false&quot; : &quot;true&quot;;
2284                 }
2285 
2286                 @Override
2287                 public String visitPrimitiveAsDouble(PrimitiveType t, Object val) {
2288                     return sourceForm(((Double)val), &#39;d&#39;);
2289                 }
2290 
2291                 @Override
2292                 public String visitPrimitiveAsFloat(PrimitiveType t, Object val) {
2293                     return sourceForm(((Float)val).doubleValue(), &#39;f&#39;);
2294                 }
2295 
2296                 @Override
2297                 public String visitPrimitiveAsLong(PrimitiveType t, Object val) {
2298                     return val + &quot;L&quot;;
2299                 }
2300 
2301                 @Override
2302                 protected String defaultAction(TypeMirror e, Object val) {
2303                     if (val == null)
2304                         return null;
2305                     else if (val instanceof Character)
2306                         return sourceForm(((Character)val));
2307                     else if (val instanceof Byte)
2308                         return sourceForm(((Byte)val));
2309                     else if (val instanceof String)
2310                         return sourceForm((String)val);
2311                     return val.toString(); // covers int, short
2312                 }
2313             }.visit(ve.asType(), workArounds.getConstValue(ve));
2314         }
2315 
2316         // where
2317         private String sourceForm(double v, char suffix) {
2318             if (Double.isNaN(v))
2319                 return &quot;0&quot; + suffix + &quot;/0&quot; + suffix;
2320             if (v == Double.POSITIVE_INFINITY)
2321                 return &quot;1&quot; + suffix + &quot;/0&quot; + suffix;
2322             if (v == Double.NEGATIVE_INFINITY)
2323                 return &quot;-1&quot; + suffix + &quot;/0&quot; + suffix;
2324             return v + (suffix == &#39;f&#39; || suffix == &#39;F&#39; ? &quot;&quot; + suffix : &quot;&quot;);
2325         }
2326 
2327         private  String sourceForm(char c) {
2328             StringBuilder buf = new StringBuilder(8);
2329             buf.append(&#39;\&#39;&#39;);
2330             sourceChar(c, buf);
2331             buf.append(&#39;\&#39;&#39;);
2332             return buf.toString();
2333         }
2334 
2335         private String sourceForm(byte c) {
2336             return &quot;0x&quot; + Integer.toString(c &amp; 0xff, 16);
2337         }
2338 
2339         private String sourceForm(String s) {
2340             StringBuilder buf = new StringBuilder(s.length() + 5);
2341             buf.append(&#39;\&quot;&#39;);
2342             for (int i=0; i&lt;s.length(); i++) {
2343                 char c = s.charAt(i);
2344                 sourceChar(c, buf);
2345             }
2346             buf.append(&#39;\&quot;&#39;);
2347             return buf.toString();
2348         }
2349 
2350         private void sourceChar(char c, StringBuilder buf) {
2351             switch (c) {
2352             case &#39;\b&#39;: buf.append(&quot;\\b&quot;); return;
2353             case &#39;\t&#39;: buf.append(&quot;\\t&quot;); return;
2354             case &#39;\n&#39;: buf.append(&quot;\\n&quot;); return;
2355             case &#39;\f&#39;: buf.append(&quot;\\f&quot;); return;
2356             case &#39;\r&#39;: buf.append(&quot;\\r&quot;); return;
2357             case &#39;\&quot;&#39;: buf.append(&quot;\\\&quot;&quot;); return;
2358             case &#39;\&#39;&#39;: buf.append(&quot;\\\&#39;&quot;); return;
2359             case &#39;\\&#39;: buf.append(&quot;\\\\&quot;); return;
2360             default:
2361                 if (isPrintableAscii(c)) {
2362                     buf.append(c); return;
2363                 }
2364                 unicodeEscape(c, buf);
2365                 return;
2366             }
2367         }
2368 
2369         private void unicodeEscape(char c, StringBuilder buf) {
2370             final String chars = &quot;0123456789abcdef&quot;;
2371             buf.append(&quot;\\u&quot;);
2372             buf.append(chars.charAt(15 &amp; (c&gt;&gt;12)));
2373             buf.append(chars.charAt(15 &amp; (c&gt;&gt;8)));
2374             buf.append(chars.charAt(15 &amp; (c&gt;&gt;4)));
2375             buf.append(chars.charAt(15 &amp; (c&gt;&gt;0)));
2376         }
2377         private boolean isPrintableAscii(char c) {
2378             return c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;;
2379         }
2380     }
2381 
2382     public boolean isEnclosingPackageIncluded(TypeElement te) {
2383         return isIncluded(containingPackage(te));
2384     }
2385 
2386     public boolean isIncluded(Element e) {
2387         return configuration.docEnv.isIncluded(e);
2388     }
2389 
2390     @SuppressWarnings(&quot;preview&quot;)
2391     private SimpleElementVisitor14&lt;Boolean, Void&gt; specifiedVisitor = null;
2392     @SuppressWarnings(&quot;preview&quot;)
2393     public boolean isSpecified(Element e) {
2394         if (specifiedVisitor == null) {
2395             specifiedVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2396                 @Override
2397                 public Boolean visitModule(ModuleElement e, Void p) {
2398                     return configuration.getSpecifiedModuleElements().contains(e);
2399                 }
2400 
2401                 @Override
2402                 public Boolean visitPackage(PackageElement e, Void p) {
2403                     return configuration.getSpecifiedPackageElements().contains(e);
2404                 }
2405 
2406                 @Override
2407                 public Boolean visitType(TypeElement e, Void p) {
2408                     return configuration.getSpecifiedTypeElements().contains(e);
2409                 }
2410 
2411                 @Override
2412                 protected Boolean defaultAction(Element e, Void p) {
2413                     return false;
2414                 }
2415             };
2416         }
2417         return specifiedVisitor.visit(e);
2418     }
2419 
2420     /**
2421      * Get the package name for a given package element. An unnamed package is returned as &amp;lt;Unnamed&amp;gt;
2422      *
2423      * @param pkg
2424      * @return
2425      */
2426     public String getPackageName(PackageElement pkg) {
2427         if (pkg == null || pkg.isUnnamed()) {
2428             return DocletConstants.DEFAULT_PACKAGE_NAME;
2429         }
2430         return pkg.getQualifiedName().toString();
2431     }
2432 
2433     /**
2434      * Get the module name for a given module element. An unnamed module is returned as &amp;lt;Unnamed&amp;gt;
2435      *
2436      * @param mdle a ModuleElement
2437      * @return
2438      */
2439     public String getModuleName(ModuleElement mdle) {
2440         if (mdle == null || mdle.isUnnamed()) {
2441             return DocletConstants.DEFAULT_ELEMENT_NAME;
2442         }
2443         return mdle.getQualifiedName().toString();
2444     }
2445 
2446     public boolean isAttribute(DocTree doctree) {
2447         return isKind(doctree, ATTRIBUTE);
2448     }
2449 
2450     public boolean isAuthor(DocTree doctree) {
2451         return isKind(doctree, AUTHOR);
2452     }
2453 
2454     public boolean isComment(DocTree doctree) {
2455         return isKind(doctree, COMMENT);
2456     }
2457 
2458     public boolean isDeprecated(DocTree doctree) {
2459         return isKind(doctree, DEPRECATED);
2460     }
2461 
2462     public boolean isDocComment(DocTree doctree) {
2463         return isKind(doctree, DOC_COMMENT);
2464     }
2465 
2466     public boolean isDocRoot(DocTree doctree) {
2467         return isKind(doctree, DOC_ROOT);
2468     }
2469 
2470     public boolean isEndElement(DocTree doctree) {
2471         return isKind(doctree, END_ELEMENT);
2472     }
2473 
2474     public boolean isEntity(DocTree doctree) {
2475         return isKind(doctree, ENTITY);
2476     }
2477 
2478     public boolean isErroneous(DocTree doctree) {
2479         return isKind(doctree, ERRONEOUS);
2480     }
2481 
2482     public boolean isException(DocTree doctree) {
2483         return isKind(doctree, EXCEPTION);
2484     }
2485 
2486     public boolean isIdentifier(DocTree doctree) {
2487         return isKind(doctree, IDENTIFIER);
2488     }
2489 
2490     public boolean isInheritDoc(DocTree doctree) {
2491         return isKind(doctree, INHERIT_DOC);
2492     }
2493 
2494     public boolean isLink(DocTree doctree) {
2495         return isKind(doctree, LINK);
2496     }
2497 
2498     public boolean isLinkPlain(DocTree doctree) {
2499         return isKind(doctree, LINK_PLAIN);
2500     }
2501 
2502     public boolean isLiteral(DocTree doctree) {
2503         return isKind(doctree, LITERAL);
2504     }
2505 
2506     public boolean isOther(DocTree doctree) {
2507         return doctree.getKind() == DocTree.Kind.OTHER;
2508     }
2509 
2510     public boolean isParam(DocTree doctree) {
2511         return isKind(doctree, PARAM);
2512     }
2513 
2514     public boolean isReference(DocTree doctree) {
2515         return isKind(doctree, REFERENCE);
2516     }
2517 
2518     public boolean isReturn(DocTree doctree) {
2519         return isKind(doctree, RETURN);
2520     }
2521 
2522     public boolean isSee(DocTree doctree) {
2523         return isKind(doctree, SEE);
2524     }
2525 
2526     public boolean isSerial(DocTree doctree) {
2527         return isKind(doctree, SERIAL);
2528     }
2529 
2530     public boolean isSerialData(DocTree doctree) {
2531         return isKind(doctree, SERIAL_DATA);
2532     }
2533 
2534     public boolean isSerialField(DocTree doctree) {
2535         return isKind(doctree, SERIAL_FIELD);
2536     }
2537 
2538     public boolean isSince(DocTree doctree) {
2539         return isKind(doctree, SINCE);
2540     }
2541 
2542     public boolean isStartElement(DocTree doctree) {
2543         return isKind(doctree, START_ELEMENT);
2544     }
2545 
2546     public boolean isText(DocTree doctree) {
2547         return isKind(doctree, TEXT);
2548     }
2549 
2550     public boolean isThrows(DocTree doctree) {
2551         return isKind(doctree, THROWS);
2552     }
2553 
2554     public boolean isUnknownBlockTag(DocTree doctree) {
2555         return isKind(doctree, UNKNOWN_BLOCK_TAG);
2556     }
2557 
2558     public boolean isUnknownInlineTag(DocTree doctree) {
2559         return isKind(doctree, UNKNOWN_INLINE_TAG);
2560     }
2561 
2562     public boolean isValue(DocTree doctree) {
2563         return isKind(doctree, VALUE);
2564     }
2565 
2566     public boolean isVersion(DocTree doctree) {
2567         return isKind(doctree, VERSION);
2568     }
2569 
2570     private boolean isKind(DocTree doctree, DocTree.Kind match) {
2571         return  doctree.getKind() == match;
2572     }
2573 
2574     private final CommentHelperCache commentHelperCache = new CommentHelperCache(this);
2575 
2576     public CommentHelper getCommentHelper(Element element) {
2577         return commentHelperCache.computeIfAbsent(element);
2578     }
2579 
2580     public void removeCommentHelper(Element element) {
2581         commentHelperCache.remove(element);
2582     }
2583 
2584     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {
2585         DocCommentTree dcTree = getDocCommentTree(element);
2586         return dcTree == null ? Collections.emptyList() : dcTree.getBlockTags();
2587     }
2588 
2589     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Predicate&lt;DocTree&gt; filter) {
2590         return getBlockTags(element).stream()
2591                 .filter(t -&gt; t.getKind() != ERRONEOUS)
2592                 .filter(filter)
2593                 .collect(Collectors.toList());
2594     }
2595 
2596     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind) {
2597         return getBlockTags(element, t -&gt; t.getKind() == kind);
2598     }
2599 
2600     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {
2601         return getBlockTags(element, t -&gt; t.getKind() == kind || t.getKind() == altKind);
2602     }
2603 
2604     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Taglet taglet) {
2605         return getBlockTags(element, t -&gt; {
2606             if (taglet instanceof BaseTaglet) {
2607                 return ((BaseTaglet) taglet).accepts(t);
2608             } else if (t instanceof UnknownBlockTagTree) {
2609                 return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());
2610             } else {
2611                 return false;
2612             }
2613         });
2614     }
2615 
2616     public boolean hasBlockTag(Element element, DocTree.Kind kind) {
2617         return hasBlockTag(element, kind, null);
2618     }
2619 
2620     public boolean hasBlockTag(Element element, DocTree.Kind kind, final String tagName) {
2621         CommentHelper ch = getCommentHelper(element);
2622         String tname = tagName != null &amp;&amp; tagName.startsWith(&quot;@&quot;)
2623                 ? tagName.substring(1)
2624                 : tagName;
2625         for (DocTree dt : getBlockTags(element, kind)) {
2626             if (dt.getKind() == kind) {
2627                 if (tname == null || ch.getTagName(dt).equals(tname)) {
2628                     return true;
2629                 }
2630             }
2631         }
2632         return false;
2633     }
2634 
2635     /**
2636      * Gets a TreePath for an Element. Note this method is called very
2637      * frequently, care must be taken to ensure this method is lithe
2638      * and efficient.
2639      * @param e an Element
2640      * @return TreePath
2641      */
2642     public TreePath getTreePath(Element e) {
2643         DocCommentDuo duo = dcTreeCache.get(e);
2644         if (duo != null &amp;&amp; duo.treePath != null) {
2645             return duo.treePath;
2646         }
2647         duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
2648         if (duo != null &amp;&amp; duo.treePath != null) {
2649             return duo.treePath;
2650         }
2651         Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
2652         TreePath path = elementToTreePath.get(e);
2653         if (path != null || elementToTreePath.containsKey(e)) {
2654             // expedite the path and one that is a null
2655             return path;
2656         }
2657         return elementToTreePath.computeIfAbsent(e, docTrees::getPath);
2658     }
2659 
2660     private final Map&lt;Element, DocCommentDuo&gt; dcTreeCache = new LinkedHashMap&lt;&gt;();
2661 
2662     /**
2663      * Retrieves the doc comments for a given element.
2664      * @param element
2665      * @return DocCommentTree for the Element
2666      */
2667     public DocCommentTree getDocCommentTree0(Element element) {
2668 
2669         DocCommentDuo duo = null;
2670 
2671         ElementKind kind = element.getKind();
2672         if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
2673             duo = dcTreeCache.get(element); // local cache
2674             if (duo == null &amp;&amp; kind == ElementKind.PACKAGE) {
2675                 // package-info.java
2676                 duo = getDocCommentTuple(element);
2677             }
2678             if (duo == null) {
2679                 // package.html or overview.html
2680                 duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
2681             }
2682         } else {
2683             duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
2684             if (duo == null) {
2685                 duo = dcTreeCache.get(element); // local cache
2686             }
2687             if (duo == null) {
2688                 duo = getDocCommentTuple(element); // get the real mccoy
2689             }
2690         }
2691 
2692         DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
2693         TreePath path = isValidDuo(duo) ? duo.treePath : null;
2694         if (!dcTreeCache.containsKey(element)) {
2695             if (docCommentTree != null &amp;&amp; path != null) {
2696                 if (!configuration.isAllowScriptInComments()) {
2697                     try {
2698                         javaScriptScanner.scan(docCommentTree, path, p -&gt; {
2699                             throw new JavaScriptScanner.Fault();
2700                         });
2701                     } catch (JavaScriptScanner.Fault jsf) {
2702                         String text = resources.getText(&quot;doclet.JavaScript_in_comment&quot;);
2703                         throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
2704                     }
2705                 }
2706                 configuration.workArounds.runDocLint(path);
2707             }
2708             dcTreeCache.put(element, duo);
2709         }
2710         return docCommentTree;
2711     }
2712 
2713     private DocCommentDuo getDocCommentTuple(Element element) {
2714         // prevent nasty things downstream with overview element
2715         if (element.getKind() != ElementKind.OTHER) {
2716             TreePath path = getTreePath(element);
2717             if (path != null) {
2718                 DocCommentTree docCommentTree = docTrees.getDocCommentTree(path);
2719                 return new DocCommentDuo(path, docCommentTree);
2720             }
2721         }
2722         return null;
2723     }
2724 
2725     public void checkJavaScriptInOption(String name, String value) {
2726         if (!configuration.isAllowScriptInComments()) {
2727             DocCommentTree dct = configuration.cmtUtils.parse(
2728                     URI.create(&quot;option://&quot; + name.replace(&quot;-&quot;, &quot;&quot;)), &quot;&lt;body&gt;&quot; + value + &quot;&lt;/body&gt;&quot;);
2729 
2730             if (dct == null)
2731                 return;
2732 
2733             try {
2734                 javaScriptScanner.scan(dct, null, p -&gt; {
2735                     throw new JavaScriptScanner.Fault();
2736                 });
2737             } catch (JavaScriptScanner.Fault jsf) {
2738                 String text = resources.getText(&quot;doclet.JavaScript_in_option&quot;, name);
2739                 throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
2740             }
2741         }
2742     }
2743 
2744     boolean isValidDuo(DocCommentDuo duo) {
2745         return duo != null &amp;&amp; duo.dcTree != null;
2746     }
2747 
2748     public DocCommentTree getDocCommentTree(Element element) {
2749         CommentHelper ch = commentHelperCache.get(element);
2750         if (ch != null) {
2751             return ch.dcTree;
2752         }
2753         DocCommentTree dcTree = getDocCommentTree0(element);
2754         if (dcTree != null) {
2755             commentHelperCache.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));
2756         }
2757         return dcTree;
2758     }
2759 
2760     public List&lt;? extends DocTree&gt; getPreamble(Element element) {
2761         DocCommentTree docCommentTree = getDocCommentTree(element);
2762         return docCommentTree == null
2763                 ? Collections.emptyList()
2764                 : docCommentTree.getPreamble();
2765     }
2766 
2767     public List&lt;? extends DocTree&gt; getFullBody(Element element) {
2768         DocCommentTree docCommentTree = getDocCommentTree(element);
2769             return (docCommentTree == null)
2770                     ? Collections.emptyList()
2771                     : docCommentTree.getFullBody();
2772     }
2773 
2774     public List&lt;? extends DocTree&gt; getBody(Element element) {
2775         DocCommentTree docCommentTree = getDocCommentTree(element);
2776         return (docCommentTree == null)
2777                 ? Collections.emptyList()
2778                 : docCommentTree.getFullBody();
2779     }
2780 
2781     public List&lt;? extends DocTree&gt; getDeprecatedTrees(Element element) {
2782         return getBlockTags(element, DEPRECATED);
2783     }
2784 
2785     public List&lt;? extends DocTree&gt; getProvidesTrees(Element element) {
2786         return getBlockTags(element, PROVIDES);
2787     }
2788 
2789     public List&lt;? extends DocTree&gt; getSeeTrees(Element element) {
2790         return getBlockTags(element, SEE);
2791     }
2792 
2793     public List&lt;? extends DocTree&gt; getSerialTrees(Element element) {
2794         return getBlockTags(element, SERIAL);
2795     }
2796 
2797     public List&lt;? extends DocTree&gt; getSerialFieldTrees(VariableElement field) {
2798         return getBlockTags(field, DocTree.Kind.SERIAL_FIELD);
2799     }
2800 
2801     public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
2802         return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
2803     }
2804 
2805     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
2806         return getParamTrees(element, true);
2807     }
2808 
2809     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
2810         return getParamTrees(element, false);
2811     }
2812 
2813     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
2814         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
2815         for (DocTree dt : getBlockTags(element, PARAM)) {
2816             ParamTree pt = (ParamTree) dt;
2817             if (pt.isTypeParameter() == isTypeParameters) {
2818                 out.add(pt);
2819             }
2820         }
2821         return out;
2822     }
2823 
2824     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
2825         return new ArrayList&lt;&gt;(getBlockTags(element, RETURN));
2826     }
2827 
2828     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
2829         return getBlockTags(element, USES);
2830     }
2831 
2832     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
2833         DocCommentTree dcTree = getDocCommentTree(element);
2834         if (dcTree == null) {
2835             return Collections.emptyList();
2836         }
2837         return new ArrayList&lt;&gt;(dcTree.getFirstSentence());
2838     }
2839 
2840     public ModuleElement containingModule(Element e) {
2841         return elementUtils.getModuleOf(e);
2842     }
2843 
2844     public PackageElement containingPackage(Element e) {
2845         return elementUtils.getPackageOf(e);
2846     }
2847 
2848     public TypeElement getTopMostContainingTypeElement(Element e) {
2849         if (isPackage(e)) {
2850             return null;
2851         }
2852         TypeElement outer = getEnclosingTypeElement(e);
2853         if (outer == null)
2854             return (TypeElement)e;
2855         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
2856             outer = getEnclosingTypeElement(outer);
2857         }
2858         return outer;
2859     }
2860 
2861     /**
2862      * A memory-sensitive cache for {@link CommentHelper} objects,
2863      * which are expensive to compute.
2864      */
2865     private static class CommentHelperCache {
2866 
2867         private final Map&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; map;
2868         private final Utils utils;
2869 
2870         public CommentHelperCache(Utils utils) {
2871             map = new HashMap&lt;&gt;();
2872             this.utils = utils;
2873         }
2874 
2875         public CommentHelper remove(Element key) {
2876             SoftReference&lt;CommentHelper&gt; value = map.remove(key);
2877             return value == null ? null : value.get();
2878         }
2879 
2880         public CommentHelper put(Element key, CommentHelper value) {
2881             SoftReference&lt;CommentHelper&gt; prev = map.put(key, new SoftReference&lt;&gt;(value));
2882             return prev == null ? null : prev.get();
2883         }
2884 
2885         public CommentHelper get(Object key) {
2886             SoftReference&lt;CommentHelper&gt; value = map.get(key);
2887             return value == null ? null : value.get();
2888         }
2889 
2890         public CommentHelper computeIfAbsent(Element key) {
2891             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);
2892             if (refValue != null) {
2893                 CommentHelper value = refValue.get();
2894                 if (value != null) {
2895                     return value;
2896                 }
2897             }
2898             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
2899                     utils.getDocCommentTree(key));
2900             map.put(key, new SoftReference&lt;&gt;(newValue));
2901             return newValue;
2902         }
2903     }
2904 
2905     /**
2906      * A container holding a pair of values (tuple).
2907      *
2908      * @param &lt;K&gt; the type of the first value
2909      * @param &lt;L&gt; the type of the second value
2910      */
2911     public static class Pair&lt;K, L&gt; {
2912         public final K first;
2913         public final L second;
2914 
2915         public Pair(K first, L second) {
2916             this.first = first;
2917             this.second = second;
2918         }
2919 
2920         @Override
2921         public String toString() {
2922             return first + &quot;:&quot; + second;
2923         }
2924     }
2925 }
    </pre>
  </body>
</html>
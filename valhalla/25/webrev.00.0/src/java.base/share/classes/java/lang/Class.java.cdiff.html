<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/runtime/vmOperations.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 140,11 ***</span>
   * type (or for void) using a class literal.  See Section {@jls
   * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
   * For example:
   *
   * &lt;blockquote&gt;
<span class="line-modified">!  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}</span>
   * &lt;/blockquote&gt;
   *
   * @param &lt;T&gt; the type of the class modeled by this {@code Class}
   * object.  For example, the type of {@code String.class} is {@code
   * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
<span class="line-new-header">--- 140,11 ---</span>
   * type (or for void) using a class literal.  See Section {@jls
   * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
   * For example:
   *
   * &lt;blockquote&gt;
<span class="line-modified">!  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}</span>
   * &lt;/blockquote&gt;
   *
   * @param &lt;T&gt; the type of the class modeled by this {@code Class}
   * object.  For example, the type of {@code String.class} is {@code
   * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,11 ***</span>
       * primitive type, this method returns the name of the primitive type.  If
       * this {@code Class} object represents void this method returns
       * &quot;void&quot;. If this {@code Class} object represents an array type,
       * this method returns &quot;class &quot; followed by {@code getName}.
       *
<span class="line-modified">!      * @return a string representation of this class object.</span>
       */
      public String toString() {
          return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
                 + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
                 + getName() + (isInlineClass() &amp;&amp; isIndirectType() ? &quot;?&quot; : &quot;&quot;);
<span class="line-new-header">--- 190,11 ---</span>
       * primitive type, this method returns the name of the primitive type.  If
       * this {@code Class} object represents void this method returns
       * &quot;void&quot;. If this {@code Class} object represents an array type,
       * this method returns &quot;class &quot; followed by {@code getName}.
       *
<span class="line-modified">!      * @return a string representation of this {@code Class} object.</span>
       */
      public String toString() {
          return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
                 + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
                 + getName() + (isInlineClass() &amp;&amp; isIndirectType() ? &quot;?&quot; : &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,11 ***</span>
       * information about modifiers and type parameters.
       *
       * The string is formatted as a list of type modifiers, if any,
       * followed by the kind of type (empty string for primitive types
       * and {@code class}, {@code enum}, {@code interface},
<span class="line-modified">!      * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, or {@code record} as appropriate), followed</span>
       * by the type&#39;s name, followed by an angle-bracketed
       * comma-separated list of the type&#39;s type parameters, if any,
       * including informative bounds on the type parameters, if any.
       *
       * A space is used to separate modifiers from one another and to
<span class="line-new-header">--- 205,11 ---</span>
       * information about modifiers and type parameters.
       *
       * The string is formatted as a list of type modifiers, if any,
       * followed by the kind of type (empty string for primitive types
       * and {@code class}, {@code enum}, {@code interface},
<span class="line-modified">!      * {@code @interface}, or {@code record} as appropriate), followed</span>
       * by the type&#39;s name, followed by an angle-bracketed
       * comma-separated list of the type&#39;s type parameters, if any,
       * including informative bounds on the type parameters, if any.
       *
       * A space is used to separate modifiers from one another and to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 769,24 ***</span>
      @HotSpotIntrinsicCandidate
      public native boolean isAssignableFrom(Class&lt;?&gt; cls);
  
  
      /**
<span class="line-modified">!      * Determines if the specified {@code Class} object represents an</span>
       * interface type.
       *
<span class="line-modified">!      * @return  {@code true} if this object represents an interface;</span>
       *          {@code false} otherwise.
       */
      @HotSpotIntrinsicCandidate
      public native boolean isInterface();
  
  
      /**
       * Determines if this {@code Class} object represents an array class.
       *
<span class="line-modified">!      * @return  {@code true} if this object represents an array class;</span>
       *          {@code false} otherwise.
       * @since   1.1
       */
      @HotSpotIntrinsicCandidate
      public native boolean isArray();
<span class="line-new-header">--- 769,24 ---</span>
      @HotSpotIntrinsicCandidate
      public native boolean isAssignableFrom(Class&lt;?&gt; cls);
  
  
      /**
<span class="line-modified">!      * Determines if this {@code Class} object represents an</span>
       * interface type.
       *
<span class="line-modified">!      * @return  {@code true} if this {@code Class} object represents an interface;</span>
       *          {@code false} otherwise.
       */
      @HotSpotIntrinsicCandidate
      public native boolean isInterface();
  
  
      /**
       * Determines if this {@code Class} object represents an array class.
       *
<span class="line-modified">!      * @return  {@code true} if this {@code Class} object represents an array class;</span>
       *          {@code false} otherwise.
       * @since   1.1
       */
      @HotSpotIntrinsicCandidate
      public native boolean isArray();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 826,11 ***</span>
      /**
       * Returns true if this {@code Class} object represents an annotation
       * type.  Note that if this method returns true, {@link #isInterface()}
       * would also return true, as all annotation types are also interfaces.
       *
<span class="line-modified">!      * @return {@code true} if this class object represents an annotation</span>
       *      type; {@code false} otherwise
       * @since 1.5
       */
      public boolean isAnnotation() {
          return (getModifiers() &amp; ANNOTATION) != 0;
<span class="line-new-header">--- 826,11 ---</span>
      /**
       * Returns true if this {@code Class} object represents an annotation
       * type.  Note that if this method returns true, {@link #isInterface()}
       * would also return true, as all annotation types are also interfaces.
       *
<span class="line-modified">!      * @return {@code true} if this {@code Class} object represents an annotation</span>
       *      type; {@code false} otherwise
       * @since 1.5
       */
      public boolean isAnnotation() {
          return (getModifiers() &amp; ANNOTATION) != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 851,20 ***</span>
      /**
       * Returns the  name of the entity (class, interface, array class,
       * primitive type, or void) represented by this {@code Class} object,
       * as a {@code String}.
       *
<span class="line-modified">!      * &lt;p&gt; If this class object represents a reference type that is</span>
       * not an array type then the binary name of the class is
       * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language
       * Specification&lt;/cite&gt;.
       *
<span class="line-modified">!      * &lt;p&gt; If this class object represents a primitive type or void, then the</span>
       * name returned is a {@code String} equal to the Java language
       * keyword corresponding to the primitive type or void.
       *
<span class="line-modified">!      * &lt;p&gt; If this class object represents a class of arrays, then the internal</span>
       * form of the name consists of the name of the element type preceded by
       * one or more &#39;{@code [}&#39; characters representing the depth of the array
       * nesting.  The encoding of element type names is as follows:
       *
       * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
<span class="line-new-header">--- 851,20 ---</span>
      /**
       * Returns the  name of the entity (class, interface, array class,
       * primitive type, or void) represented by this {@code Class} object,
       * as a {@code String}.
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a reference type that is</span>
       * not an array type then the binary name of the class is
       * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language
       * Specification&lt;/cite&gt;.
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the</span>
       * name returned is a {@code String} equal to the Java language
       * keyword corresponding to the primitive type or void.
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal</span>
       * form of the name consists of the name of the element type preceded by
       * one or more &#39;{@code [}&#39; characters representing the depth of the array
       * nesting.  The encoding of element type names is as follows:
       *
       * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 908,11 ***</span>
       * (new int[3][4][5][6][7][8][9]).getClass().getName()
       *     returns &quot;[[[[[[[I&quot;
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @return  the name of the class or interface
<span class="line-modified">!      *          represented by this object.</span>
       */
      public String getName() {
          String name = this.name;
          return name != null ? name : initClassName();
      }
<span class="line-new-header">--- 908,11 ---</span>
       * (new int[3][4][5][6][7][8][9]).getClass().getName()
       *     returns &quot;[[[[[[[I&quot;
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @return  the name of the class or interface
<span class="line-modified">!      *          represented by this {@code Class} object.</span>
       */
      public String getName() {
          String name = this.name;
          return name != null ? name : initClassName();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 926,15 ***</span>
       * Returns the class loader for the class.  Some implementations may use
       * null to represent the bootstrap class loader. This method will return
       * null in such implementations if this class was loaded by the bootstrap
       * class loader.
       *
<span class="line-modified">!      * &lt;p&gt;If this object</span>
       * represents a primitive type or void, null is returned.
       *
       * @return  the class loader that loaded the class or interface
<span class="line-modified">!      *          represented by this object.</span>
       * @throws  SecurityException
       *          if a security manager is present, and the caller&#39;s class loader
       *          is not {@code null} and is not the same as or an ancestor of the
       *          class loader for the class whose class loader is requested,
       *          and the caller does not have the
<span class="line-new-header">--- 926,15 ---</span>
       * Returns the class loader for the class.  Some implementations may use
       * null to represent the bootstrap class loader. This method will return
       * null in such implementations if this class was loaded by the bootstrap
       * class loader.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object</span>
       * represents a primitive type or void, null is returned.
       *
       * @return  the class loader that loaded the class or interface
<span class="line-modified">!      *          represented by this {@code Class} object.</span>
       * @throws  SecurityException
       *          if a security manager is present, and the caller&#39;s class loader
       *          is not {@code null} and is not the same as or an ancestor of the
       *          class loader for the class whose class loader is requested,
       *          and the caller does not have the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1016,36 ***</span>
      /**
       * Returns the {@code Class} representing the direct superclass of the
       * entity (class, interface, primitive type or void) represented by
       * this {@code Class}.  If this {@code Class} represents either the
       * {@code Object} class, an interface, a primitive type, or void, then
<span class="line-modified">!      * null is returned.  If this object represents an array class then the</span>
<span class="line-modified">!      * {@code Class} object representing the {@code Object} class is</span>
       * returned.
       *
<span class="line-modified">!      * @return the direct superclass of the class represented by this object</span>
       */
      @HotSpotIntrinsicCandidate
      public native Class&lt;? super T&gt; getSuperclass();
  
  
      /**
       * Returns the {@code Type} representing the direct superclass of
       * the entity (class, interface, primitive type or void) represented by
<span class="line-modified">!      * this {@code Class}.</span>
       *
       * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
       * object returned must accurately reflect the actual type
       * arguments used in the source code. The parameterized type
       * representing the superclass is created if it had not been
       * created before. See the declaration of {@link
       * java.lang.reflect.ParameterizedType ParameterizedType} for the
       * semantics of the creation process for parameterized types.  If
<span class="line-modified">!      * this {@code Class} represents either the {@code Object}</span>
       * class, an interface, a primitive type, or void, then null is
<span class="line-modified">!      * returned.  If this object represents an array class then the</span>
<span class="line-modified">!      * {@code Class} object representing the {@code Object} class is</span>
       * returned.
       *
       * @throws java.lang.reflect.GenericSignatureFormatError if the generic
       *     class signature does not conform to the format specified in
       *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
<span class="line-new-header">--- 1016,36 ---</span>
      /**
       * Returns the {@code Class} representing the direct superclass of the
       * entity (class, interface, primitive type or void) represented by
       * this {@code Class}.  If this {@code Class} represents either the
       * {@code Object} class, an interface, a primitive type, or void, then
<span class="line-modified">!      * null is returned.  If this {@code Class} object represents an array class</span>
<span class="line-modified">!      * then the {@code Class} object representing the {@code Object} class is</span>
       * returned.
       *
<span class="line-modified">!      * @return the direct superclass of the class represented by this {@code Class} object</span>
       */
      @HotSpotIntrinsicCandidate
      public native Class&lt;? super T&gt; getSuperclass();
  
  
      /**
       * Returns the {@code Type} representing the direct superclass of
       * the entity (class, interface, primitive type or void) represented by
<span class="line-modified">!      * this {@code Class} object.</span>
       *
       * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
       * object returned must accurately reflect the actual type
       * arguments used in the source code. The parameterized type
       * representing the superclass is created if it had not been
       * created before. See the declaration of {@link
       * java.lang.reflect.ParameterizedType ParameterizedType} for the
       * semantics of the creation process for parameterized types.  If
<span class="line-modified">!      * this {@code Class} object represents either the {@code Object}</span>
       * class, an interface, a primitive type, or void, then null is
<span class="line-modified">!      * returned.  If this {@code Class} object represents an array class</span>
<span class="line-modified">!      * then the {@code Class} object representing the {@code Object} class is</span>
       * returned.
       *
       * @throws java.lang.reflect.GenericSignatureFormatError if the generic
       *     class signature does not conform to the format specified in
       *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1053,11 ***</span>
       * @throws TypeNotPresentException if the generic superclass
       *     refers to a non-existent type declaration
       * @throws java.lang.reflect.MalformedParameterizedTypeException if the
       *     generic superclass refers to a parameterized type that cannot be
       *     instantiated  for any reason
<span class="line-modified">!      * @return the direct superclass of the class represented by this object</span>
       * @since 1.5
       */
      public Type getGenericSuperclass() {
          ClassRepository info = getGenericInfo();
          if (info == null) {
<span class="line-new-header">--- 1053,11 ---</span>
       * @throws TypeNotPresentException if the generic superclass
       *     refers to a non-existent type declaration
       * @throws java.lang.reflect.MalformedParameterizedTypeException if the
       *     generic superclass refers to a parameterized type that cannot be
       *     instantiated  for any reason
<span class="line-modified">!      * @return the direct superclass of the class represented by this {@code Class} object</span>
       * @since 1.5
       */
      public Type getGenericSuperclass() {
          ClassRepository info = getGenericInfo();
          if (info == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1142,17 ***</span>
      // cached package name
      private transient String packageName;
  
      /**
       * Returns the interfaces directly implemented by the class or interface
<span class="line-modified">!      * represented by this object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a class, the return value is an array</span>
       * containing objects representing all interfaces directly implemented by
       * the class.  The order of the interface objects in the array corresponds
       * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">!      * the declaration of the class represented by this object.  For example,</span>
       * given the declaration:
       * &lt;blockquote&gt;
       * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
       * &lt;/blockquote&gt;
       * suppose the value of {@code s} is an instance of
<span class="line-new-header">--- 1142,17 ---</span>
      // cached package name
      private transient String packageName;
  
      /**
       * Returns the interfaces directly implemented by the class or interface
<span class="line-modified">!      * represented by this {@code Class} object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array</span>
       * containing objects representing all interfaces directly implemented by
       * the class.  The order of the interface objects in the array corresponds
       * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">!      * the declaration of the class represented by this {@code Class} object.  For example,</span>
       * given the declaration:
       * &lt;blockquote&gt;
       * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
       * &lt;/blockquote&gt;
       * suppose the value of {@code s} is an instance of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1166,20 ***</span>
       * {@code s.getClass().getInterfaces()[1]}
       * &lt;/blockquote&gt;
       * is the {@code Class} object that represents interface
       * {@code DessertTopping}.
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents an interface, the array contains objects</span>
       * representing all interfaces directly extended by the interface.  The
       * order of the interface objects in the array corresponds to the order of
       * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">!      * the interface represented by this object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a class or interface that implements no</span>
       * interfaces, the method returns an array of length 0.
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a primitive type or void, the method</span>
       * returns an array of length 0.
       *
       * &lt;p&gt;If this {@code Class} object represents an array type, the
       * interfaces {@code Cloneable} and {@code java.io.Serializable} are
       * returned in that order.
<span class="line-new-header">--- 1166,20 ---</span>
       * {@code s.getClass().getInterfaces()[1]}
       * &lt;/blockquote&gt;
       * is the {@code Class} object that represents interface
       * {@code DessertTopping}.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects</span>
       * representing all interfaces directly extended by the interface.  The
       * order of the interface objects in the array corresponds to the order of
       * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">!      * the interface represented by this {@code Class} object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no</span>
       * interfaces, the method returns an array of length 0.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method</span>
       * returns an array of length 0.
       *
       * &lt;p&gt;If this {@code Class} object represents an array type, the
       * interfaces {@code Cloneable} and {@code java.io.Serializable} are
       * returned in that order.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1210,37 ***</span>
      private native Class&lt;?&gt;[] getInterfaces0();
  
      /**
       * Returns the {@code Type}s representing the interfaces
       * directly implemented by the class or interface represented by
<span class="line-modified">!      * this object.</span>
       *
       * &lt;p&gt;If a superinterface is a parameterized type, the
       * {@code Type} object returned for it must accurately reflect
       * the actual type arguments used in the source code. The
       * parameterized type representing each superinterface is created
       * if it had not been created before. See the declaration of
       * {@link java.lang.reflect.ParameterizedType ParameterizedType}
       * for the semantics of the creation process for parameterized
       * types.
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a class, the return value is an array</span>
       * containing objects representing all interfaces directly implemented by
       * the class.  The order of the interface objects in the array corresponds
       * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">!      * the declaration of the class represented by this object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents an interface, the array contains objects</span>
       * representing all interfaces directly extended by the interface.  The
       * order of the interface objects in the array corresponds to the order of
       * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">!      * the interface represented by this object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a class or interface that implements no</span>
       * interfaces, the method returns an array of length 0.
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a primitive type or void, the method</span>
       * returns an array of length 0.
       *
       * &lt;p&gt;If this {@code Class} object represents an array type, the
       * interfaces {@code Cloneable} and {@code java.io.Serializable} are
       * returned in that order.
<span class="line-new-header">--- 1210,37 ---</span>
      private native Class&lt;?&gt;[] getInterfaces0();
  
      /**
       * Returns the {@code Type}s representing the interfaces
       * directly implemented by the class or interface represented by
<span class="line-modified">!      * this {@code Class} object.</span>
       *
       * &lt;p&gt;If a superinterface is a parameterized type, the
       * {@code Type} object returned for it must accurately reflect
       * the actual type arguments used in the source code. The
       * parameterized type representing each superinterface is created
       * if it had not been created before. See the declaration of
       * {@link java.lang.reflect.ParameterizedType ParameterizedType}
       * for the semantics of the creation process for parameterized
       * types.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array</span>
       * containing objects representing all interfaces directly implemented by
       * the class.  The order of the interface objects in the array corresponds
       * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">!      * the declaration of the class represented by this {@code Class} object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects</span>
       * representing all interfaces directly extended by the interface.  The
       * order of the interface objects in the array corresponds to the order of
       * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">!      * the interface represented by this {@code Class} object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no</span>
       * interfaces, the method returns an array of length 0.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method</span>
       * returns an array of length 0.
       *
       * &lt;p&gt;If this {@code Class} object represents an array type, the
       * interfaces {@code Cloneable} and {@code java.io.Serializable} are
       * returned in that order.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1294,14 ***</span>
       * using the methods of class {@code Modifier}.
       *
       * &lt;p&gt; If the underlying class is an array class, then its
       * {@code public}, {@code private} and {@code protected}
       * modifiers are the same as those of its component type.  If this
<span class="line-modified">!      * {@code Class} represents a primitive type or void, its</span>
       * {@code public} modifier is always {@code true}, and its
       * {@code protected} and {@code private} modifiers are always
<span class="line-modified">!      * {@code false}. If this object represents an array class, a</span>
       * primitive type or void, then its {@code final} modifier is always
       * {@code true} and its interface modifier is always
       * {@code false}. The values of its other modifiers are not determined
       * by this specification.
       *
<span class="line-new-header">--- 1294,14 ---</span>
       * using the methods of class {@code Modifier}.
       *
       * &lt;p&gt; If the underlying class is an array class, then its
       * {@code public}, {@code private} and {@code protected}
       * modifiers are the same as those of its component type.  If this
<span class="line-modified">!      * {@code Class} object represents a primitive type or void, its</span>
       * {@code public} modifier is always {@code true}, and its
       * {@code protected} and {@code private} modifiers are always
<span class="line-modified">!      * {@code false}. If this {@code Class} object represents an array class, a</span>
       * primitive type or void, then its {@code final} modifier is always
       * {@code true} and its interface modifier is always
       * {@code false}. The values of its other modifiers are not determined
       * by this specification.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1317,11 ***</span>
  
      /**
       * Gets the signers of this class.
       *
       * @return  the signers of this class, or null if there are no signers.  In
<span class="line-modified">!      *          particular, this method returns null if this object represents</span>
       *          a primitive type or void.
       * @since   1.1
       */
      public Object[] getSigners() {
          return asPrimaryType().getSigners0();
<span class="line-new-header">--- 1317,11 ---</span>
  
      /**
       * Gets the signers of this class.
       *
       * @return  the signers of this class, or null if there are no signers.  In
<span class="line-modified">!      *          particular, this method returns null if this {@code Class} object represents</span>
       *          a primitive type or void.
       * @since   1.1
       */
      public Object[] getSigners() {
          return asPrimaryType().getSigners0();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2076,11 ***</span>
       * field of the class or interface represented by this {@code Class}
       * object. The {@code name} parameter is a {@code String} specifying the
       * simple name of the desired field.
       *
       * &lt;p&gt; The field to be reflected is determined by the algorithm that
<span class="line-modified">!      * follows.  Let C be the class or interface represented by this object:</span>
       *
       * &lt;OL&gt;
       * &lt;LI&gt; If C declares a public field with the name specified, that is the
       *      field to be reflected.&lt;/LI&gt;
       * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
<span class="line-new-header">--- 2076,11 ---</span>
       * field of the class or interface represented by this {@code Class}
       * object. The {@code name} parameter is a {@code String} specifying the
       * simple name of the desired field.
       *
       * &lt;p&gt; The field to be reflected is determined by the algorithm that
<span class="line-modified">!      * follows.  Let C be the class or interface represented by this {@code Class} object:</span>
       *
       * &lt;OL&gt;
       * &lt;LI&gt; If C declares a public field with the name specified, that is the
       *      field to be reflected.&lt;/LI&gt;
       * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2761,13 ***</span>
       * caller&#39;s module.
       *
       * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
       * searching resources associated with a given class are implemented by the
       * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">!      * delegates to this object&#39;s class loader.  If this object was loaded by</span>
<span class="line-modified">!      * the bootstrap class loader, the method delegates to {@link</span>
<span class="line-modified">!      * ClassLoader#getSystemResourceAsStream}.</span>
       *
       * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
       * given resource name using this algorithm:
       *
       * &lt;ul&gt;
<span class="line-new-header">--- 2761,13 ---</span>
       * caller&#39;s module.
       *
       * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
       * searching resources associated with a given class are implemented by the
       * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">!      * delegates to this {@code Class} object&#39;s class loader.</span>
<span class="line-modified">!      * If this {@code Class} object was loaded by the bootstrap class loader,</span>
<span class="line-modified">!      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.</span>
       *
       * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
       * given resource name using this algorithm:
       *
       * &lt;ul&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2859,13 ***</span>
       * caller&#39;s module.
       *
       * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
       * searching resources associated with a given class are implemented by the
       * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">!      * delegates to this object&#39;s class loader. If this object was loaded by</span>
<span class="line-modified">!      * the bootstrap class loader, the method delegates to {@link</span>
<span class="line-modified">!      * ClassLoader#getSystemResource}.</span>
       *
       * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
       * given resource name using this algorithm:
       *
       * &lt;ul&gt;
<span class="line-new-header">--- 2859,13 ---</span>
       * caller&#39;s module.
       *
       * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
       * searching resources associated with a given class are implemented by the
       * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">!      * delegates to this {@code Class} object&#39;s class loader.</span>
<span class="line-modified">!      * If this {@code Class} object was loaded by the bootstrap class loader,</span>
<span class="line-modified">!      * the method delegates to {@link ClassLoader#getSystemResource}.</span>
       *
       * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
       * given resource name using this algorithm:
       *
       * &lt;ul&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3770,12 ***</span>
      /**
       * Returns the elements of this enum class or null if this
       * Class object does not represent an enum type.
       *
       * @return an array containing the values comprising the enum class
<span class="line-modified">!      *     represented by this Class object in the order they&#39;re</span>
<span class="line-modified">!      *     declared, or null if this Class object does not</span>
       *     represent an enum type
       * @since 1.5
       */
      public T[] getEnumConstants() {
          T[] values = getEnumConstantsShared();
<span class="line-new-header">--- 3770,12 ---</span>
      /**
       * Returns the elements of this enum class or null if this
       * Class object does not represent an enum type.
       *
       * @return an array containing the values comprising the enum class
<span class="line-modified">!      *     represented by this {@code Class} object in the order they&#39;re</span>
<span class="line-modified">!      *     declared, or null if this {@code Class} object does not</span>
       *     represent an enum type
       * @since 1.5
       */
      public T[] getEnumConstants() {
          T[] values = getEnumConstantsShared();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3869,21 ***</span>
  
      /**
       * Casts this {@code Class} object to represent a subclass of the class
       * represented by the specified class object.  Checks that the cast
       * is valid, and throws a {@code ClassCastException} if it is not.  If
<span class="line-modified">!      * this method succeeds, it always returns a reference to this class object.</span>
       *
       * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
       * a {@code Class} object to pass it to an API that restricts the
       * {@code Class} objects that it is willing to accept.  A cast would
       * generate a compile-time warning, as the correctness of the cast
       * could not be checked at runtime (because generic types are implemented
       * by erasure).
       *
<span class="line-modified">!      * @param &lt;U&gt; the type to cast this class object to</span>
<span class="line-modified">!      * @param clazz the class of the type to cast this class object to</span>
       * @return this {@code Class} object, cast to represent a subclass of
       *    the specified class object.
       * @throws ClassCastException if this {@code Class} object does not
       *    represent a subclass of the specified class (here &quot;subclass&quot; includes
       *    the class itself).
<span class="line-new-header">--- 3869,21 ---</span>
  
      /**
       * Casts this {@code Class} object to represent a subclass of the class
       * represented by the specified class object.  Checks that the cast
       * is valid, and throws a {@code ClassCastException} if it is not.  If
<span class="line-modified">!      * this method succeeds, it always returns a reference to this {@code Class} object.</span>
       *
       * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
       * a {@code Class} object to pass it to an API that restricts the
       * {@code Class} objects that it is willing to accept.  A cast would
       * generate a compile-time warning, as the correctness of the cast
       * could not be checked at runtime (because generic types are implemented
       * by erasure).
       *
<span class="line-modified">!      * @param &lt;U&gt; the type to cast this {@code Class} object to</span>
<span class="line-modified">!      * @param clazz the class of the type to cast this {@code Class} object to</span>
       * @return this {@code Class} object, cast to represent a subclass of
       *    the specified class object.
       * @throws ClassCastException if this {@code Class} object does not
       *    represent a subclass of the specified class (here &quot;subclass&quot; includes
       *    the class itself).
</pre>
<center><a href="../../../../../hotspot/share/runtime/vmOperations.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
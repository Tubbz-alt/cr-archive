<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/runtime/vmOperations.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 125  * will typically record a top-level class as the host of a nest where the
 126  * other members are the classes and interfaces whose declarations are
 127  * enclosed within the top-level class declaration.
 128  *
 129  * &lt;p&gt; The following example uses a {@code Class} object to print the
 130  * class name of an object:
 131  *
 132  * &lt;blockquote&gt;&lt;pre&gt;
 133  *     void printClassName(Object obj) {
 134  *         System.out.println(&quot;The class of &quot; + obj +
 135  *                            &quot; is &quot; + obj.getClass().getName());
 136  *     }
 137  * &lt;/pre&gt;&lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
 140  * type (or for void) using a class literal.  See Section {@jls
 141  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 142  * For example:
 143  *
 144  * &lt;blockquote&gt;
<span class="line-modified"> 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}</span>
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
</pre>
<hr />
<pre>
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
<span class="line-modified"> 195      * @return a string representation of this class object.</span>
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 200                + getName() + (isInlineClass() &amp;&amp; isIndirectType() ? &quot;?&quot; : &quot;&quot;);
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
<span class="line-modified"> 210      * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, or {@code record} as appropriate), followed</span>
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
</pre>
<hr />
<pre>
 754      *
 755      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 756      * specified {@code Class} parameter can be converted to the type
 757      * represented by this {@code Class} object via an identity conversion
 758      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 759      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 760      * for details.
 761      *
 762      * @param     cls the {@code Class} object to be checked
 763      * @return    the {@code boolean} value indicating whether objects of the
 764      *            type {@code cls} can be assigned to objects of this class
 765      * @throws    NullPointerException if the specified Class parameter is
 766      *            null.
 767      * @since     1.1
 768      */
 769     @HotSpotIntrinsicCandidate
 770     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 771 
 772 
 773     /**
<span class="line-modified"> 774      * Determines if the specified {@code Class} object represents an</span>
 775      * interface type.
 776      *
<span class="line-modified"> 777      * @return  {@code true} if this object represents an interface;</span>
 778      *          {@code false} otherwise.
 779      */
 780     @HotSpotIntrinsicCandidate
 781     public native boolean isInterface();
 782 
 783 
 784     /**
 785      * Determines if this {@code Class} object represents an array class.
 786      *
<span class="line-modified"> 787      * @return  {@code true} if this object represents an array class;</span>
 788      *          {@code false} otherwise.
 789      * @since   1.1
 790      */
 791     @HotSpotIntrinsicCandidate
 792     public native boolean isArray();
 793 
 794 
 795     /**
 796      * Determines if the specified {@code Class} object represents a
 797      * primitive type.
 798      *
 799      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 800      * the eight primitive types and void.  These are created by the Java
 801      * Virtual Machine, and have the same names as the primitive types that
 802      * they represent, namely {@code boolean}, {@code byte},
 803      * {@code char}, {@code short}, {@code int},
 804      * {@code long}, {@code float}, and {@code double}.
 805      *
 806      * &lt;p&gt; These objects may only be accessed via the following public static
 807      * final variables, and are the only {@code Class} objects for which
</pre>
<hr />
<pre>
 811      *
 812      * @see     java.lang.Boolean#TYPE
 813      * @see     java.lang.Character#TYPE
 814      * @see     java.lang.Byte#TYPE
 815      * @see     java.lang.Short#TYPE
 816      * @see     java.lang.Integer#TYPE
 817      * @see     java.lang.Long#TYPE
 818      * @see     java.lang.Float#TYPE
 819      * @see     java.lang.Double#TYPE
 820      * @see     java.lang.Void#TYPE
 821      * @since 1.1
 822      */
 823     @HotSpotIntrinsicCandidate
 824     public native boolean isPrimitive();
 825 
 826     /**
 827      * Returns true if this {@code Class} object represents an annotation
 828      * type.  Note that if this method returns true, {@link #isInterface()}
 829      * would also return true, as all annotation types are also interfaces.
 830      *
<span class="line-modified"> 831      * @return {@code true} if this class object represents an annotation</span>
 832      *      type; {@code false} otherwise
 833      * @since 1.5
 834      */
 835     public boolean isAnnotation() {
 836         return (getModifiers() &amp; ANNOTATION) != 0;
 837     }
 838 
 839     /**
 840      * Returns {@code true} if this class is a synthetic class;
 841      * returns {@code false} otherwise.
 842      * @return {@code true} if and only if this class is a synthetic class as
 843      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 844      * @jls 13.1 The Form of a Binary
 845      * @since 1.5
 846      */
 847     public boolean isSynthetic() {
 848         return (getModifiers() &amp; SYNTHETIC) != 0;
 849     }
 850 
 851     /**
 852      * Returns the  name of the entity (class, interface, array class,
 853      * primitive type, or void) represented by this {@code Class} object,
 854      * as a {@code String}.
 855      *
<span class="line-modified"> 856      * &lt;p&gt; If this class object represents a reference type that is</span>
 857      * not an array type then the binary name of the class is
 858      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language
 859      * Specification&lt;/cite&gt;.
 860      *
<span class="line-modified"> 861      * &lt;p&gt; If this class object represents a primitive type or void, then the</span>
 862      * name returned is a {@code String} equal to the Java language
 863      * keyword corresponding to the primitive type or void.
 864      *
<span class="line-modified"> 865      * &lt;p&gt; If this class object represents a class of arrays, then the internal</span>
 866      * form of the name consists of the name of the element type preceded by
 867      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 868      * nesting.  The encoding of element type names is as follows:
 869      *
 870      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 871      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 872      * &lt;thead&gt;
 873      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 874      * &lt;/thead&gt;
 875      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 876      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 878      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 880      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
 881      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; non-nullable {@linkplain #isInlineClass() inline class}
 882      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 883      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 885      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
</pre>
<hr />
<pre>
 893      *
 894      * &lt;p&gt; Examples:
 895      * &lt;blockquote&gt;&lt;pre&gt;
 896      * String.class.getName()
 897      *     returns &quot;java.lang.String&quot;
 898      * byte.class.getName()
 899      *     returns &quot;byte&quot;
 900      * Point.class.getName()
 901      *     returns &quot;Point&quot;
 902      * (new Object[3]).getClass().getName()
 903      *     returns &quot;[Ljava.lang.Object;&quot;
 904      * (new Point[3]).getClass().getName()
 905      *     returns &quot;[QPoint;&quot;
 906      * (new Point?[3][4]).getClass().getName()
 907      *     returns &quot;[[LPoint;&quot;
 908      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 909      *     returns &quot;[[[[[[[I&quot;
 910      * &lt;/pre&gt;&lt;/blockquote&gt;
 911      *
 912      * @return  the name of the class or interface
<span class="line-modified"> 913      *          represented by this object.</span>
 914      */
 915     public String getName() {
 916         String name = this.name;
 917         return name != null ? name : initClassName();
 918     }
 919 
 920     // Cache the name to reduce the number of calls into the VM.
 921     // This field would be set by VM itself during initClassName call.
 922     private transient String name;
 923     private native String initClassName();
 924 
 925     /**
 926      * Returns the class loader for the class.  Some implementations may use
 927      * null to represent the bootstrap class loader. This method will return
 928      * null in such implementations if this class was loaded by the bootstrap
 929      * class loader.
 930      *
<span class="line-modified"> 931      * &lt;p&gt;If this object</span>
 932      * represents a primitive type or void, null is returned.
 933      *
 934      * @return  the class loader that loaded the class or interface
<span class="line-modified"> 935      *          represented by this object.</span>
 936      * @throws  SecurityException
 937      *          if a security manager is present, and the caller&#39;s class loader
 938      *          is not {@code null} and is not the same as or an ancestor of the
 939      *          class loader for the class whose class loader is requested,
 940      *          and the caller does not have the
 941      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 942      * @see java.lang.ClassLoader
 943      * @see SecurityManager#checkPermission
 944      * @see java.lang.RuntimePermission
 945      */
 946     @CallerSensitive
 947     @ForceInline // to ensure Reflection.getCallerClass optimization
 948     public ClassLoader getClassLoader() {
 949         ClassLoader cl = getClassLoader0();
 950         if (cl == null)
 951             return null;
 952         SecurityManager sm = System.getSecurityManager();
 953         if (sm != null) {
 954             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 955         }
</pre>
<hr />
<pre>
1001      *     signature of this generic declaration does not conform to
1002      *     the format specified in section {@jvms 4.7.9} of
1003      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,
1004      * @since 1.5
1005      */
1006     @SuppressWarnings(&quot;unchecked&quot;)
1007     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1008         ClassRepository info = getGenericInfo();
1009         if (info != null)
1010             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1011         else
1012             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1013     }
1014 
1015 
1016     /**
1017      * Returns the {@code Class} representing the direct superclass of the
1018      * entity (class, interface, primitive type or void) represented by
1019      * this {@code Class}.  If this {@code Class} represents either the
1020      * {@code Object} class, an interface, a primitive type, or void, then
<span class="line-modified">1021      * null is returned.  If this object represents an array class then the</span>
<span class="line-modified">1022      * {@code Class} object representing the {@code Object} class is</span>
1023      * returned.
1024      *
<span class="line-modified">1025      * @return the direct superclass of the class represented by this object</span>
1026      */
1027     @HotSpotIntrinsicCandidate
1028     public native Class&lt;? super T&gt; getSuperclass();
1029 
1030 
1031     /**
1032      * Returns the {@code Type} representing the direct superclass of
1033      * the entity (class, interface, primitive type or void) represented by
<span class="line-modified">1034      * this {@code Class}.</span>
1035      *
1036      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1037      * object returned must accurately reflect the actual type
1038      * arguments used in the source code. The parameterized type
1039      * representing the superclass is created if it had not been
1040      * created before. See the declaration of {@link
1041      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1042      * semantics of the creation process for parameterized types.  If
<span class="line-modified">1043      * this {@code Class} represents either the {@code Object}</span>
1044      * class, an interface, a primitive type, or void, then null is
<span class="line-modified">1045      * returned.  If this object represents an array class then the</span>
<span class="line-modified">1046      * {@code Class} object representing the {@code Object} class is</span>
1047      * returned.
1048      *
1049      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1050      *     class signature does not conform to the format specified in
1051      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1052      *     Machine Specification&lt;/cite&gt;
1053      * @throws TypeNotPresentException if the generic superclass
1054      *     refers to a non-existent type declaration
1055      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1056      *     generic superclass refers to a parameterized type that cannot be
1057      *     instantiated  for any reason
<span class="line-modified">1058      * @return the direct superclass of the class represented by this object</span>
1059      * @since 1.5
1060      */
1061     public Type getGenericSuperclass() {
1062         ClassRepository info = getGenericInfo();
1063         if (info == null) {
1064             return getSuperclass();
1065         }
1066 
1067         // Historical irregularity:
1068         // Generic signature marks interfaces with superclass = Object
1069         // but this API returns null for interfaces
1070         if (isInterface()) {
1071             return null;
1072         }
1073 
1074         return info.getSuperclass();
1075     }
1076 
1077     /**
1078      * Gets the package of this class.
</pre>
<hr />
<pre>
1127             while (c.isArray()) {
1128                 c = c.getComponentType();
1129             }
1130             if (c.isPrimitive()) {
1131                 pn = &quot;java.lang&quot;;
1132             } else {
1133                 String cn = c.getName();
1134                 int dot = cn.lastIndexOf(&#39;.&#39;);
1135                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1136             }
1137             this.packageName = pn;
1138         }
1139         return pn;
1140     }
1141 
1142     // cached package name
1143     private transient String packageName;
1144 
1145     /**
1146      * Returns the interfaces directly implemented by the class or interface
<span class="line-modified">1147      * represented by this object.</span>
1148      *
<span class="line-modified">1149      * &lt;p&gt;If this object represents a class, the return value is an array</span>
1150      * containing objects representing all interfaces directly implemented by
1151      * the class.  The order of the interface objects in the array corresponds
1152      * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">1153      * the declaration of the class represented by this object.  For example,</span>
1154      * given the declaration:
1155      * &lt;blockquote&gt;
1156      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1157      * &lt;/blockquote&gt;
1158      * suppose the value of {@code s} is an instance of
1159      * {@code Shimmer}; the value of the expression:
1160      * &lt;blockquote&gt;
1161      * {@code s.getClass().getInterfaces()[0]}
1162      * &lt;/blockquote&gt;
1163      * is the {@code Class} object that represents interface
1164      * {@code FloorWax}; and the value of:
1165      * &lt;blockquote&gt;
1166      * {@code s.getClass().getInterfaces()[1]}
1167      * &lt;/blockquote&gt;
1168      * is the {@code Class} object that represents interface
1169      * {@code DessertTopping}.
1170      *
<span class="line-modified">1171      * &lt;p&gt;If this object represents an interface, the array contains objects</span>
1172      * representing all interfaces directly extended by the interface.  The
1173      * order of the interface objects in the array corresponds to the order of
1174      * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">1175      * the interface represented by this object.</span>
1176      *
<span class="line-modified">1177      * &lt;p&gt;If this object represents a class or interface that implements no</span>
1178      * interfaces, the method returns an array of length 0.
1179      *
<span class="line-modified">1180      * &lt;p&gt;If this object represents a primitive type or void, the method</span>
1181      * returns an array of length 0.
1182      *
1183      * &lt;p&gt;If this {@code Class} object represents an array type, the
1184      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1185      * returned in that order.
1186      *
1187      * @return an array of interfaces directly implemented by this class
1188      */
1189     public Class&lt;?&gt;[] getInterfaces() {
1190         // defensively copy before handing over to user code
1191         return getInterfaces(true);
1192     }
1193 
1194     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1195         ReflectionData&lt;T&gt; rd = reflectionData();
1196         if (rd == null) {
1197             // no cloning required
1198             return getInterfaces0();
1199         } else {
1200             Class&lt;?&gt;[] interfaces = rd.interfaces;
1201             if (interfaces == null) {
1202                 interfaces = getInterfaces0();
1203                 rd.interfaces = interfaces;
1204             }
1205             // defensively copy if requested
1206             return cloneArray ? interfaces.clone() : interfaces;
1207         }
1208     }
1209 
1210     private native Class&lt;?&gt;[] getInterfaces0();
1211 
1212     /**
1213      * Returns the {@code Type}s representing the interfaces
1214      * directly implemented by the class or interface represented by
<span class="line-modified">1215      * this object.</span>
1216      *
1217      * &lt;p&gt;If a superinterface is a parameterized type, the
1218      * {@code Type} object returned for it must accurately reflect
1219      * the actual type arguments used in the source code. The
1220      * parameterized type representing each superinterface is created
1221      * if it had not been created before. See the declaration of
1222      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1223      * for the semantics of the creation process for parameterized
1224      * types.
1225      *
<span class="line-modified">1226      * &lt;p&gt;If this object represents a class, the return value is an array</span>
1227      * containing objects representing all interfaces directly implemented by
1228      * the class.  The order of the interface objects in the array corresponds
1229      * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">1230      * the declaration of the class represented by this object.</span>
1231      *
<span class="line-modified">1232      * &lt;p&gt;If this object represents an interface, the array contains objects</span>
1233      * representing all interfaces directly extended by the interface.  The
1234      * order of the interface objects in the array corresponds to the order of
1235      * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">1236      * the interface represented by this object.</span>
1237      *
<span class="line-modified">1238      * &lt;p&gt;If this object represents a class or interface that implements no</span>
1239      * interfaces, the method returns an array of length 0.
1240      *
<span class="line-modified">1241      * &lt;p&gt;If this object represents a primitive type or void, the method</span>
1242      * returns an array of length 0.
1243      *
1244      * &lt;p&gt;If this {@code Class} object represents an array type, the
1245      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1246      * returned in that order.
1247      *
1248      * @throws java.lang.reflect.GenericSignatureFormatError
1249      *     if the generic class signature does not conform to the
1250      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1251      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1252      * @throws TypeNotPresentException if any of the generic
1253      *     superinterfaces refers to a non-existent type declaration
1254      * @throws java.lang.reflect.MalformedParameterizedTypeException
1255      *     if any of the generic superinterfaces refer to a parameterized
1256      *     type that cannot be instantiated for any reason
1257      * @return an array of interfaces directly implemented by this class
1258      * @since 1.5
1259      */
1260     public Type[] getGenericInterfaces() {
1261         ClassRepository info = getGenericInfo();
</pre>
<hr />
<pre>
1279             return componentType;
1280         } else {
1281             return null;
1282         }
1283     }
1284 
1285     private final Class&lt;?&gt; componentType;
1286 
1287 
1288     /**
1289      * Returns the Java language modifiers for this class or interface, encoded
1290      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1291      * constants for {@code public}, {@code protected},
1292      * {@code private}, {@code final}, {@code static},
1293      * {@code abstract} and {@code interface}; they should be decoded
1294      * using the methods of class {@code Modifier}.
1295      *
1296      * &lt;p&gt; If the underlying class is an array class, then its
1297      * {@code public}, {@code private} and {@code protected}
1298      * modifiers are the same as those of its component type.  If this
<span class="line-modified">1299      * {@code Class} represents a primitive type or void, its</span>
1300      * {@code public} modifier is always {@code true}, and its
1301      * {@code protected} and {@code private} modifiers are always
<span class="line-modified">1302      * {@code false}. If this object represents an array class, a</span>
1303      * primitive type or void, then its {@code final} modifier is always
1304      * {@code true} and its interface modifier is always
1305      * {@code false}. The values of its other modifiers are not determined
1306      * by this specification.
1307      *
1308      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1309      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1310      *
1311      * @return the {@code int} representing the modifiers for this class
1312      * @see     java.lang.reflect.Modifier
1313      * @since 1.1
1314      */
1315     @HotSpotIntrinsicCandidate
1316     public native int getModifiers();
1317 
1318     /**
1319      * Gets the signers of this class.
1320      *
1321      * @return  the signers of this class, or null if there are no signers.  In
<span class="line-modified">1322      *          particular, this method returns null if this object represents</span>
1323      *          a primitive type or void.
1324      * @since   1.1
1325      */
1326     public Object[] getSigners() {
1327         return asPrimaryType().getSigners0();
1328     }
1329 
1330     private native Object[] getSigners0();
1331 
1332     /**
1333      * Set the signers of this class.
1334      */
1335     void setSigners(Object[] signers) {
1336         asPrimaryType().setSigners0(signers);
1337     }
1338 
1339     native void setSigners0(Object[] signers);
1340 
1341 
1342     /**
</pre>
<hr />
<pre>
2061      *
2062      * @since 1.1
2063      */
2064     @CallerSensitive
2065     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2066         SecurityManager sm = System.getSecurityManager();
2067         if (sm != null) {
2068             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2069         }
2070         return copyConstructors(privateGetDeclaredConstructors(true));
2071     }
2072 
2073 
2074     /**
2075      * Returns a {@code Field} object that reflects the specified public member
2076      * field of the class or interface represented by this {@code Class}
2077      * object. The {@code name} parameter is a {@code String} specifying the
2078      * simple name of the desired field.
2079      *
2080      * &lt;p&gt; The field to be reflected is determined by the algorithm that
<span class="line-modified">2081      * follows.  Let C be the class or interface represented by this object:</span>
2082      *
2083      * &lt;OL&gt;
2084      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2085      *      field to be reflected.&lt;/LI&gt;
2086      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2087      *      recursively to each direct superinterface of C. The direct
2088      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2089      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2090      *      superclass S, then this algorithm is invoked recursively upon S.
2091      *      If C has no superclass, then a {@code NoSuchFieldException}
2092      *      is thrown.&lt;/LI&gt;
2093      * &lt;/OL&gt;
2094      *
2095      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2096      * method does not find the {@code length} field of the array type.
2097      *
2098      * @param name the field name
2099      * @return the {@code Field} object of this class specified by
2100      *         {@code name}
2101      * @throws NoSuchFieldException if a field with the specified name is
</pre>
<hr />
<pre>
2746     }
2747 
2748     /**
2749      * Finds a resource with a given name.
2750      *
2751      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2752      * will attempt to find the resource in the module. This is done by
2753      * delegating to the module&#39;s class loader {@link
2754      * ClassLoader#findResource(String,String) findResource(String,String)}
2755      * method, invoking it with the module name and the absolute name of the
2756      * resource. Resources in named modules are subject to the rules for
2757      * encapsulation specified in the {@code Module} {@link
2758      * Module#getResourceAsStream getResourceAsStream} method and so this
2759      * method returns {@code null} when the resource is a
2760      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2761      * caller&#39;s module.
2762      *
2763      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2764      * searching resources associated with a given class are implemented by the
2765      * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">2766      * delegates to this object&#39;s class loader.  If this object was loaded by</span>
<span class="line-modified">2767      * the bootstrap class loader, the method delegates to {@link</span>
<span class="line-modified">2768      * ClassLoader#getSystemResourceAsStream}.</span>
2769      *
2770      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2771      * given resource name using this algorithm:
2772      *
2773      * &lt;ul&gt;
2774      *
2775      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2776      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2777      * portion of the {@code name} following the {@code &#39;/&#39;}.
2778      *
2779      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2780      *
2781      * &lt;blockquote&gt;
2782      *   {@code modified_package_name/name}
2783      * &lt;/blockquote&gt;
2784      *
2785      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2786      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2787      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2788      *
</pre>
<hr />
<pre>
2844     }
2845 
2846     /**
2847      * Finds a resource with a given name.
2848      *
2849      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2850      * will attempt to find the resource in the module. This is done by
2851      * delegating to the module&#39;s class loader {@link
2852      * ClassLoader#findResource(String,String) findResource(String,String)}
2853      * method, invoking it with the module name and the absolute name of the
2854      * resource. Resources in named modules are subject to the rules for
2855      * encapsulation specified in the {@code Module} {@link
2856      * Module#getResourceAsStream getResourceAsStream} method and so this
2857      * method returns {@code null} when the resource is a
2858      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2859      * caller&#39;s module.
2860      *
2861      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2862      * searching resources associated with a given class are implemented by the
2863      * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">2864      * delegates to this object&#39;s class loader. If this object was loaded by</span>
<span class="line-modified">2865      * the bootstrap class loader, the method delegates to {@link</span>
<span class="line-modified">2866      * ClassLoader#getSystemResource}.</span>
2867      *
2868      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2869      * given resource name using this algorithm:
2870      *
2871      * &lt;ul&gt;
2872      *
2873      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2874      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2875      * portion of the {@code name} following the {@code &#39;/&#39;}.
2876      *
2877      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2878      *
2879      * &lt;blockquote&gt;
2880      *   {@code modified_package_name/name}
2881      * &lt;/blockquote&gt;
2882      *
2883      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2884      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2885      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2886      *
</pre>
<hr />
<pre>
3755     public boolean isRecord() {
3756         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3757     }
3758 
3759     // Fetches the factory for reflective objects
3760     private static ReflectionFactory getReflectionFactory() {
3761         if (reflectionFactory == null) {
3762             reflectionFactory =
3763                 java.security.AccessController.doPrivileged
3764                     (new ReflectionFactory.GetReflectionFactoryAction());
3765         }
3766         return reflectionFactory;
3767     }
3768     private static ReflectionFactory reflectionFactory;
3769 
3770     /**
3771      * Returns the elements of this enum class or null if this
3772      * Class object does not represent an enum type.
3773      *
3774      * @return an array containing the values comprising the enum class
<span class="line-modified">3775      *     represented by this Class object in the order they&#39;re</span>
<span class="line-modified">3776      *     declared, or null if this Class object does not</span>
3777      *     represent an enum type
3778      * @since 1.5
3779      */
3780     public T[] getEnumConstants() {
3781         T[] values = getEnumConstantsShared();
3782         return (values != null) ? values.clone() : null;
3783     }
3784 
3785     /**
3786      * Returns the elements of this enum class or null if this
3787      * Class object does not represent an enum type;
3788      * identical to getEnumConstants except that the result is
3789      * uncloned, cached, and shared by all callers.
3790      */
3791     T[] getEnumConstantsShared() {
3792         T[] constants = enumConstants;
3793         if (constants == null) {
3794             if (!isEnum()) return null;
3795             try {
3796                 final Method values = getMethod(&quot;values&quot;);
</pre>
<hr />
<pre>
3854      */
3855     @SuppressWarnings(&quot;unchecked&quot;)
3856     @HotSpotIntrinsicCandidate
3857     public T cast(Object obj) {
3858         if (!isNullableType() &amp;&amp; obj == null)
3859             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3860 
3861         if (obj != null &amp;&amp; !isInstance(obj))
3862             throw new ClassCastException(cannotCastMsg(obj));
3863         return (T) obj;
3864     }
3865 
3866     private String cannotCastMsg(Object obj) {
3867         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3868     }
3869 
3870     /**
3871      * Casts this {@code Class} object to represent a subclass of the class
3872      * represented by the specified class object.  Checks that the cast
3873      * is valid, and throws a {@code ClassCastException} if it is not.  If
<span class="line-modified">3874      * this method succeeds, it always returns a reference to this class object.</span>
3875      *
3876      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3877      * a {@code Class} object to pass it to an API that restricts the
3878      * {@code Class} objects that it is willing to accept.  A cast would
3879      * generate a compile-time warning, as the correctness of the cast
3880      * could not be checked at runtime (because generic types are implemented
3881      * by erasure).
3882      *
<span class="line-modified">3883      * @param &lt;U&gt; the type to cast this class object to</span>
<span class="line-modified">3884      * @param clazz the class of the type to cast this class object to</span>
3885      * @return this {@code Class} object, cast to represent a subclass of
3886      *    the specified class object.
3887      * @throws ClassCastException if this {@code Class} object does not
3888      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3889      *    the class itself).
3890      * @since 1.5
3891      */
3892     @SuppressWarnings(&quot;unchecked&quot;)
3893     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3894         if (clazz.isAssignableFrom(this))
3895             return (Class&lt;? extends U&gt;) this;
3896         else
3897             throw new ClassCastException(this.toString());
3898     }
3899 
3900     /**
3901      * @throws NullPointerException {@inheritDoc}
3902      * @since 1.5
3903      */
3904     @SuppressWarnings(&quot;unchecked&quot;)
</pre>
</td>
<td>
<hr />
<pre>
 125  * will typically record a top-level class as the host of a nest where the
 126  * other members are the classes and interfaces whose declarations are
 127  * enclosed within the top-level class declaration.
 128  *
 129  * &lt;p&gt; The following example uses a {@code Class} object to print the
 130  * class name of an object:
 131  *
 132  * &lt;blockquote&gt;&lt;pre&gt;
 133  *     void printClassName(Object obj) {
 134  *         System.out.println(&quot;The class of &quot; + obj +
 135  *                            &quot; is &quot; + obj.getClass().getName());
 136  *     }
 137  * &lt;/pre&gt;&lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
 140  * type (or for void) using a class literal.  See Section {@jls
 141  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 142  * For example:
 143  *
 144  * &lt;blockquote&gt;
<span class="line-modified"> 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}</span>
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
</pre>
<hr />
<pre>
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
<span class="line-modified"> 195      * @return a string representation of this {@code Class} object.</span>
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 200                + getName() + (isInlineClass() &amp;&amp; isIndirectType() ? &quot;?&quot; : &quot;&quot;);
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
<span class="line-modified"> 210      * {@code @interface}, or {@code record} as appropriate), followed</span>
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
</pre>
<hr />
<pre>
 754      *
 755      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 756      * specified {@code Class} parameter can be converted to the type
 757      * represented by this {@code Class} object via an identity conversion
 758      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 759      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 760      * for details.
 761      *
 762      * @param     cls the {@code Class} object to be checked
 763      * @return    the {@code boolean} value indicating whether objects of the
 764      *            type {@code cls} can be assigned to objects of this class
 765      * @throws    NullPointerException if the specified Class parameter is
 766      *            null.
 767      * @since     1.1
 768      */
 769     @HotSpotIntrinsicCandidate
 770     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 771 
 772 
 773     /**
<span class="line-modified"> 774      * Determines if this {@code Class} object represents an</span>
 775      * interface type.
 776      *
<span class="line-modified"> 777      * @return  {@code true} if this {@code Class} object represents an interface;</span>
 778      *          {@code false} otherwise.
 779      */
 780     @HotSpotIntrinsicCandidate
 781     public native boolean isInterface();
 782 
 783 
 784     /**
 785      * Determines if this {@code Class} object represents an array class.
 786      *
<span class="line-modified"> 787      * @return  {@code true} if this {@code Class} object represents an array class;</span>
 788      *          {@code false} otherwise.
 789      * @since   1.1
 790      */
 791     @HotSpotIntrinsicCandidate
 792     public native boolean isArray();
 793 
 794 
 795     /**
 796      * Determines if the specified {@code Class} object represents a
 797      * primitive type.
 798      *
 799      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 800      * the eight primitive types and void.  These are created by the Java
 801      * Virtual Machine, and have the same names as the primitive types that
 802      * they represent, namely {@code boolean}, {@code byte},
 803      * {@code char}, {@code short}, {@code int},
 804      * {@code long}, {@code float}, and {@code double}.
 805      *
 806      * &lt;p&gt; These objects may only be accessed via the following public static
 807      * final variables, and are the only {@code Class} objects for which
</pre>
<hr />
<pre>
 811      *
 812      * @see     java.lang.Boolean#TYPE
 813      * @see     java.lang.Character#TYPE
 814      * @see     java.lang.Byte#TYPE
 815      * @see     java.lang.Short#TYPE
 816      * @see     java.lang.Integer#TYPE
 817      * @see     java.lang.Long#TYPE
 818      * @see     java.lang.Float#TYPE
 819      * @see     java.lang.Double#TYPE
 820      * @see     java.lang.Void#TYPE
 821      * @since 1.1
 822      */
 823     @HotSpotIntrinsicCandidate
 824     public native boolean isPrimitive();
 825 
 826     /**
 827      * Returns true if this {@code Class} object represents an annotation
 828      * type.  Note that if this method returns true, {@link #isInterface()}
 829      * would also return true, as all annotation types are also interfaces.
 830      *
<span class="line-modified"> 831      * @return {@code true} if this {@code Class} object represents an annotation</span>
 832      *      type; {@code false} otherwise
 833      * @since 1.5
 834      */
 835     public boolean isAnnotation() {
 836         return (getModifiers() &amp; ANNOTATION) != 0;
 837     }
 838 
 839     /**
 840      * Returns {@code true} if this class is a synthetic class;
 841      * returns {@code false} otherwise.
 842      * @return {@code true} if and only if this class is a synthetic class as
 843      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 844      * @jls 13.1 The Form of a Binary
 845      * @since 1.5
 846      */
 847     public boolean isSynthetic() {
 848         return (getModifiers() &amp; SYNTHETIC) != 0;
 849     }
 850 
 851     /**
 852      * Returns the  name of the entity (class, interface, array class,
 853      * primitive type, or void) represented by this {@code Class} object,
 854      * as a {@code String}.
 855      *
<span class="line-modified"> 856      * &lt;p&gt; If this {@code Class} object represents a reference type that is</span>
 857      * not an array type then the binary name of the class is
 858      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language
 859      * Specification&lt;/cite&gt;.
 860      *
<span class="line-modified"> 861      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the</span>
 862      * name returned is a {@code String} equal to the Java language
 863      * keyword corresponding to the primitive type or void.
 864      *
<span class="line-modified"> 865      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal</span>
 866      * form of the name consists of the name of the element type preceded by
 867      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 868      * nesting.  The encoding of element type names is as follows:
 869      *
 870      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 871      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 872      * &lt;thead&gt;
 873      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 874      * &lt;/thead&gt;
 875      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 876      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 878      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 880      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
 881      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; non-nullable {@linkplain #isInlineClass() inline class}
 882      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 883      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 885      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
</pre>
<hr />
<pre>
 893      *
 894      * &lt;p&gt; Examples:
 895      * &lt;blockquote&gt;&lt;pre&gt;
 896      * String.class.getName()
 897      *     returns &quot;java.lang.String&quot;
 898      * byte.class.getName()
 899      *     returns &quot;byte&quot;
 900      * Point.class.getName()
 901      *     returns &quot;Point&quot;
 902      * (new Object[3]).getClass().getName()
 903      *     returns &quot;[Ljava.lang.Object;&quot;
 904      * (new Point[3]).getClass().getName()
 905      *     returns &quot;[QPoint;&quot;
 906      * (new Point?[3][4]).getClass().getName()
 907      *     returns &quot;[[LPoint;&quot;
 908      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 909      *     returns &quot;[[[[[[[I&quot;
 910      * &lt;/pre&gt;&lt;/blockquote&gt;
 911      *
 912      * @return  the name of the class or interface
<span class="line-modified"> 913      *          represented by this {@code Class} object.</span>
 914      */
 915     public String getName() {
 916         String name = this.name;
 917         return name != null ? name : initClassName();
 918     }
 919 
 920     // Cache the name to reduce the number of calls into the VM.
 921     // This field would be set by VM itself during initClassName call.
 922     private transient String name;
 923     private native String initClassName();
 924 
 925     /**
 926      * Returns the class loader for the class.  Some implementations may use
 927      * null to represent the bootstrap class loader. This method will return
 928      * null in such implementations if this class was loaded by the bootstrap
 929      * class loader.
 930      *
<span class="line-modified"> 931      * &lt;p&gt;If this {@code Class} object</span>
 932      * represents a primitive type or void, null is returned.
 933      *
 934      * @return  the class loader that loaded the class or interface
<span class="line-modified"> 935      *          represented by this {@code Class} object.</span>
 936      * @throws  SecurityException
 937      *          if a security manager is present, and the caller&#39;s class loader
 938      *          is not {@code null} and is not the same as or an ancestor of the
 939      *          class loader for the class whose class loader is requested,
 940      *          and the caller does not have the
 941      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 942      * @see java.lang.ClassLoader
 943      * @see SecurityManager#checkPermission
 944      * @see java.lang.RuntimePermission
 945      */
 946     @CallerSensitive
 947     @ForceInline // to ensure Reflection.getCallerClass optimization
 948     public ClassLoader getClassLoader() {
 949         ClassLoader cl = getClassLoader0();
 950         if (cl == null)
 951             return null;
 952         SecurityManager sm = System.getSecurityManager();
 953         if (sm != null) {
 954             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 955         }
</pre>
<hr />
<pre>
1001      *     signature of this generic declaration does not conform to
1002      *     the format specified in section {@jvms 4.7.9} of
1003      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,
1004      * @since 1.5
1005      */
1006     @SuppressWarnings(&quot;unchecked&quot;)
1007     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1008         ClassRepository info = getGenericInfo();
1009         if (info != null)
1010             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1011         else
1012             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1013     }
1014 
1015 
1016     /**
1017      * Returns the {@code Class} representing the direct superclass of the
1018      * entity (class, interface, primitive type or void) represented by
1019      * this {@code Class}.  If this {@code Class} represents either the
1020      * {@code Object} class, an interface, a primitive type, or void, then
<span class="line-modified">1021      * null is returned.  If this {@code Class} object represents an array class</span>
<span class="line-modified">1022      * then the {@code Class} object representing the {@code Object} class is</span>
1023      * returned.
1024      *
<span class="line-modified">1025      * @return the direct superclass of the class represented by this {@code Class} object</span>
1026      */
1027     @HotSpotIntrinsicCandidate
1028     public native Class&lt;? super T&gt; getSuperclass();
1029 
1030 
1031     /**
1032      * Returns the {@code Type} representing the direct superclass of
1033      * the entity (class, interface, primitive type or void) represented by
<span class="line-modified">1034      * this {@code Class} object.</span>
1035      *
1036      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1037      * object returned must accurately reflect the actual type
1038      * arguments used in the source code. The parameterized type
1039      * representing the superclass is created if it had not been
1040      * created before. See the declaration of {@link
1041      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1042      * semantics of the creation process for parameterized types.  If
<span class="line-modified">1043      * this {@code Class} object represents either the {@code Object}</span>
1044      * class, an interface, a primitive type, or void, then null is
<span class="line-modified">1045      * returned.  If this {@code Class} object represents an array class</span>
<span class="line-modified">1046      * then the {@code Class} object representing the {@code Object} class is</span>
1047      * returned.
1048      *
1049      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1050      *     class signature does not conform to the format specified in
1051      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1052      *     Machine Specification&lt;/cite&gt;
1053      * @throws TypeNotPresentException if the generic superclass
1054      *     refers to a non-existent type declaration
1055      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1056      *     generic superclass refers to a parameterized type that cannot be
1057      *     instantiated  for any reason
<span class="line-modified">1058      * @return the direct superclass of the class represented by this {@code Class} object</span>
1059      * @since 1.5
1060      */
1061     public Type getGenericSuperclass() {
1062         ClassRepository info = getGenericInfo();
1063         if (info == null) {
1064             return getSuperclass();
1065         }
1066 
1067         // Historical irregularity:
1068         // Generic signature marks interfaces with superclass = Object
1069         // but this API returns null for interfaces
1070         if (isInterface()) {
1071             return null;
1072         }
1073 
1074         return info.getSuperclass();
1075     }
1076 
1077     /**
1078      * Gets the package of this class.
</pre>
<hr />
<pre>
1127             while (c.isArray()) {
1128                 c = c.getComponentType();
1129             }
1130             if (c.isPrimitive()) {
1131                 pn = &quot;java.lang&quot;;
1132             } else {
1133                 String cn = c.getName();
1134                 int dot = cn.lastIndexOf(&#39;.&#39;);
1135                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1136             }
1137             this.packageName = pn;
1138         }
1139         return pn;
1140     }
1141 
1142     // cached package name
1143     private transient String packageName;
1144 
1145     /**
1146      * Returns the interfaces directly implemented by the class or interface
<span class="line-modified">1147      * represented by this {@code Class} object.</span>
1148      *
<span class="line-modified">1149      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array</span>
1150      * containing objects representing all interfaces directly implemented by
1151      * the class.  The order of the interface objects in the array corresponds
1152      * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">1153      * the declaration of the class represented by this {@code Class} object.  For example,</span>
1154      * given the declaration:
1155      * &lt;blockquote&gt;
1156      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1157      * &lt;/blockquote&gt;
1158      * suppose the value of {@code s} is an instance of
1159      * {@code Shimmer}; the value of the expression:
1160      * &lt;blockquote&gt;
1161      * {@code s.getClass().getInterfaces()[0]}
1162      * &lt;/blockquote&gt;
1163      * is the {@code Class} object that represents interface
1164      * {@code FloorWax}; and the value of:
1165      * &lt;blockquote&gt;
1166      * {@code s.getClass().getInterfaces()[1]}
1167      * &lt;/blockquote&gt;
1168      * is the {@code Class} object that represents interface
1169      * {@code DessertTopping}.
1170      *
<span class="line-modified">1171      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects</span>
1172      * representing all interfaces directly extended by the interface.  The
1173      * order of the interface objects in the array corresponds to the order of
1174      * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">1175      * the interface represented by this {@code Class} object.</span>
1176      *
<span class="line-modified">1177      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no</span>
1178      * interfaces, the method returns an array of length 0.
1179      *
<span class="line-modified">1180      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method</span>
1181      * returns an array of length 0.
1182      *
1183      * &lt;p&gt;If this {@code Class} object represents an array type, the
1184      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1185      * returned in that order.
1186      *
1187      * @return an array of interfaces directly implemented by this class
1188      */
1189     public Class&lt;?&gt;[] getInterfaces() {
1190         // defensively copy before handing over to user code
1191         return getInterfaces(true);
1192     }
1193 
1194     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1195         ReflectionData&lt;T&gt; rd = reflectionData();
1196         if (rd == null) {
1197             // no cloning required
1198             return getInterfaces0();
1199         } else {
1200             Class&lt;?&gt;[] interfaces = rd.interfaces;
1201             if (interfaces == null) {
1202                 interfaces = getInterfaces0();
1203                 rd.interfaces = interfaces;
1204             }
1205             // defensively copy if requested
1206             return cloneArray ? interfaces.clone() : interfaces;
1207         }
1208     }
1209 
1210     private native Class&lt;?&gt;[] getInterfaces0();
1211 
1212     /**
1213      * Returns the {@code Type}s representing the interfaces
1214      * directly implemented by the class or interface represented by
<span class="line-modified">1215      * this {@code Class} object.</span>
1216      *
1217      * &lt;p&gt;If a superinterface is a parameterized type, the
1218      * {@code Type} object returned for it must accurately reflect
1219      * the actual type arguments used in the source code. The
1220      * parameterized type representing each superinterface is created
1221      * if it had not been created before. See the declaration of
1222      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1223      * for the semantics of the creation process for parameterized
1224      * types.
1225      *
<span class="line-modified">1226      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array</span>
1227      * containing objects representing all interfaces directly implemented by
1228      * the class.  The order of the interface objects in the array corresponds
1229      * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">1230      * the declaration of the class represented by this {@code Class} object.</span>
1231      *
<span class="line-modified">1232      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects</span>
1233      * representing all interfaces directly extended by the interface.  The
1234      * order of the interface objects in the array corresponds to the order of
1235      * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">1236      * the interface represented by this {@code Class} object.</span>
1237      *
<span class="line-modified">1238      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no</span>
1239      * interfaces, the method returns an array of length 0.
1240      *
<span class="line-modified">1241      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method</span>
1242      * returns an array of length 0.
1243      *
1244      * &lt;p&gt;If this {@code Class} object represents an array type, the
1245      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1246      * returned in that order.
1247      *
1248      * @throws java.lang.reflect.GenericSignatureFormatError
1249      *     if the generic class signature does not conform to the
1250      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1251      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1252      * @throws TypeNotPresentException if any of the generic
1253      *     superinterfaces refers to a non-existent type declaration
1254      * @throws java.lang.reflect.MalformedParameterizedTypeException
1255      *     if any of the generic superinterfaces refer to a parameterized
1256      *     type that cannot be instantiated for any reason
1257      * @return an array of interfaces directly implemented by this class
1258      * @since 1.5
1259      */
1260     public Type[] getGenericInterfaces() {
1261         ClassRepository info = getGenericInfo();
</pre>
<hr />
<pre>
1279             return componentType;
1280         } else {
1281             return null;
1282         }
1283     }
1284 
1285     private final Class&lt;?&gt; componentType;
1286 
1287 
1288     /**
1289      * Returns the Java language modifiers for this class or interface, encoded
1290      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1291      * constants for {@code public}, {@code protected},
1292      * {@code private}, {@code final}, {@code static},
1293      * {@code abstract} and {@code interface}; they should be decoded
1294      * using the methods of class {@code Modifier}.
1295      *
1296      * &lt;p&gt; If the underlying class is an array class, then its
1297      * {@code public}, {@code private} and {@code protected}
1298      * modifiers are the same as those of its component type.  If this
<span class="line-modified">1299      * {@code Class} object represents a primitive type or void, its</span>
1300      * {@code public} modifier is always {@code true}, and its
1301      * {@code protected} and {@code private} modifiers are always
<span class="line-modified">1302      * {@code false}. If this {@code Class} object represents an array class, a</span>
1303      * primitive type or void, then its {@code final} modifier is always
1304      * {@code true} and its interface modifier is always
1305      * {@code false}. The values of its other modifiers are not determined
1306      * by this specification.
1307      *
1308      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1309      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1310      *
1311      * @return the {@code int} representing the modifiers for this class
1312      * @see     java.lang.reflect.Modifier
1313      * @since 1.1
1314      */
1315     @HotSpotIntrinsicCandidate
1316     public native int getModifiers();
1317 
1318     /**
1319      * Gets the signers of this class.
1320      *
1321      * @return  the signers of this class, or null if there are no signers.  In
<span class="line-modified">1322      *          particular, this method returns null if this {@code Class} object represents</span>
1323      *          a primitive type or void.
1324      * @since   1.1
1325      */
1326     public Object[] getSigners() {
1327         return asPrimaryType().getSigners0();
1328     }
1329 
1330     private native Object[] getSigners0();
1331 
1332     /**
1333      * Set the signers of this class.
1334      */
1335     void setSigners(Object[] signers) {
1336         asPrimaryType().setSigners0(signers);
1337     }
1338 
1339     native void setSigners0(Object[] signers);
1340 
1341 
1342     /**
</pre>
<hr />
<pre>
2061      *
2062      * @since 1.1
2063      */
2064     @CallerSensitive
2065     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2066         SecurityManager sm = System.getSecurityManager();
2067         if (sm != null) {
2068             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2069         }
2070         return copyConstructors(privateGetDeclaredConstructors(true));
2071     }
2072 
2073 
2074     /**
2075      * Returns a {@code Field} object that reflects the specified public member
2076      * field of the class or interface represented by this {@code Class}
2077      * object. The {@code name} parameter is a {@code String} specifying the
2078      * simple name of the desired field.
2079      *
2080      * &lt;p&gt; The field to be reflected is determined by the algorithm that
<span class="line-modified">2081      * follows.  Let C be the class or interface represented by this {@code Class} object:</span>
2082      *
2083      * &lt;OL&gt;
2084      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2085      *      field to be reflected.&lt;/LI&gt;
2086      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2087      *      recursively to each direct superinterface of C. The direct
2088      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2089      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2090      *      superclass S, then this algorithm is invoked recursively upon S.
2091      *      If C has no superclass, then a {@code NoSuchFieldException}
2092      *      is thrown.&lt;/LI&gt;
2093      * &lt;/OL&gt;
2094      *
2095      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2096      * method does not find the {@code length} field of the array type.
2097      *
2098      * @param name the field name
2099      * @return the {@code Field} object of this class specified by
2100      *         {@code name}
2101      * @throws NoSuchFieldException if a field with the specified name is
</pre>
<hr />
<pre>
2746     }
2747 
2748     /**
2749      * Finds a resource with a given name.
2750      *
2751      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2752      * will attempt to find the resource in the module. This is done by
2753      * delegating to the module&#39;s class loader {@link
2754      * ClassLoader#findResource(String,String) findResource(String,String)}
2755      * method, invoking it with the module name and the absolute name of the
2756      * resource. Resources in named modules are subject to the rules for
2757      * encapsulation specified in the {@code Module} {@link
2758      * Module#getResourceAsStream getResourceAsStream} method and so this
2759      * method returns {@code null} when the resource is a
2760      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2761      * caller&#39;s module.
2762      *
2763      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2764      * searching resources associated with a given class are implemented by the
2765      * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">2766      * delegates to this {@code Class} object&#39;s class loader.</span>
<span class="line-modified">2767      * If this {@code Class} object was loaded by the bootstrap class loader,</span>
<span class="line-modified">2768      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.</span>
2769      *
2770      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2771      * given resource name using this algorithm:
2772      *
2773      * &lt;ul&gt;
2774      *
2775      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2776      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2777      * portion of the {@code name} following the {@code &#39;/&#39;}.
2778      *
2779      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2780      *
2781      * &lt;blockquote&gt;
2782      *   {@code modified_package_name/name}
2783      * &lt;/blockquote&gt;
2784      *
2785      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2786      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2787      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2788      *
</pre>
<hr />
<pre>
2844     }
2845 
2846     /**
2847      * Finds a resource with a given name.
2848      *
2849      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2850      * will attempt to find the resource in the module. This is done by
2851      * delegating to the module&#39;s class loader {@link
2852      * ClassLoader#findResource(String,String) findResource(String,String)}
2853      * method, invoking it with the module name and the absolute name of the
2854      * resource. Resources in named modules are subject to the rules for
2855      * encapsulation specified in the {@code Module} {@link
2856      * Module#getResourceAsStream getResourceAsStream} method and so this
2857      * method returns {@code null} when the resource is a
2858      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2859      * caller&#39;s module.
2860      *
2861      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2862      * searching resources associated with a given class are implemented by the
2863      * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">2864      * delegates to this {@code Class} object&#39;s class loader.</span>
<span class="line-modified">2865      * If this {@code Class} object was loaded by the bootstrap class loader,</span>
<span class="line-modified">2866      * the method delegates to {@link ClassLoader#getSystemResource}.</span>
2867      *
2868      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2869      * given resource name using this algorithm:
2870      *
2871      * &lt;ul&gt;
2872      *
2873      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2874      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2875      * portion of the {@code name} following the {@code &#39;/&#39;}.
2876      *
2877      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2878      *
2879      * &lt;blockquote&gt;
2880      *   {@code modified_package_name/name}
2881      * &lt;/blockquote&gt;
2882      *
2883      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2884      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2885      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2886      *
</pre>
<hr />
<pre>
3755     public boolean isRecord() {
3756         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3757     }
3758 
3759     // Fetches the factory for reflective objects
3760     private static ReflectionFactory getReflectionFactory() {
3761         if (reflectionFactory == null) {
3762             reflectionFactory =
3763                 java.security.AccessController.doPrivileged
3764                     (new ReflectionFactory.GetReflectionFactoryAction());
3765         }
3766         return reflectionFactory;
3767     }
3768     private static ReflectionFactory reflectionFactory;
3769 
3770     /**
3771      * Returns the elements of this enum class or null if this
3772      * Class object does not represent an enum type.
3773      *
3774      * @return an array containing the values comprising the enum class
<span class="line-modified">3775      *     represented by this {@code Class} object in the order they&#39;re</span>
<span class="line-modified">3776      *     declared, or null if this {@code Class} object does not</span>
3777      *     represent an enum type
3778      * @since 1.5
3779      */
3780     public T[] getEnumConstants() {
3781         T[] values = getEnumConstantsShared();
3782         return (values != null) ? values.clone() : null;
3783     }
3784 
3785     /**
3786      * Returns the elements of this enum class or null if this
3787      * Class object does not represent an enum type;
3788      * identical to getEnumConstants except that the result is
3789      * uncloned, cached, and shared by all callers.
3790      */
3791     T[] getEnumConstantsShared() {
3792         T[] constants = enumConstants;
3793         if (constants == null) {
3794             if (!isEnum()) return null;
3795             try {
3796                 final Method values = getMethod(&quot;values&quot;);
</pre>
<hr />
<pre>
3854      */
3855     @SuppressWarnings(&quot;unchecked&quot;)
3856     @HotSpotIntrinsicCandidate
3857     public T cast(Object obj) {
3858         if (!isNullableType() &amp;&amp; obj == null)
3859             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3860 
3861         if (obj != null &amp;&amp; !isInstance(obj))
3862             throw new ClassCastException(cannotCastMsg(obj));
3863         return (T) obj;
3864     }
3865 
3866     private String cannotCastMsg(Object obj) {
3867         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3868     }
3869 
3870     /**
3871      * Casts this {@code Class} object to represent a subclass of the class
3872      * represented by the specified class object.  Checks that the cast
3873      * is valid, and throws a {@code ClassCastException} if it is not.  If
<span class="line-modified">3874      * this method succeeds, it always returns a reference to this {@code Class} object.</span>
3875      *
3876      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3877      * a {@code Class} object to pass it to an API that restricts the
3878      * {@code Class} objects that it is willing to accept.  A cast would
3879      * generate a compile-time warning, as the correctness of the cast
3880      * could not be checked at runtime (because generic types are implemented
3881      * by erasure).
3882      *
<span class="line-modified">3883      * @param &lt;U&gt; the type to cast this {@code Class} object to</span>
<span class="line-modified">3884      * @param clazz the class of the type to cast this {@code Class} object to</span>
3885      * @return this {@code Class} object, cast to represent a subclass of
3886      *    the specified class object.
3887      * @throws ClassCastException if this {@code Class} object does not
3888      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3889      *    the class itself).
3890      * @since 1.5
3891      */
3892     @SuppressWarnings(&quot;unchecked&quot;)
3893     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3894         if (clazz.isAssignableFrom(this))
3895             return (Class&lt;? extends U&gt;) this;
3896         else
3897             throw new ClassCastException(this.toString());
3898     }
3899 
3900     /**
3901      * @throws NullPointerException {@inheritDoc}
3902      * @since 1.5
3903      */
3904     @SuppressWarnings(&quot;unchecked&quot;)
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../hotspot/share/runtime/vmOperations.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/java/lang/Class.java b/src/java.base/share/classes/java/lang/Class.java
--- a/src/java.base/share/classes/java/lang/Class.java
+++ b/src/java.base/share/classes/java/lang/Class.java
@@ -140,11 +140,11 @@
  * type (or for void) using a class literal.  See Section {@jls
  * 15.8.2} of <cite>The Java&trade; Language Specification</cite>.
  * For example:
  *
  * <blockquote>
- *     {@code System.out.println("The name of class Foo is: "+Foo.class.getName());}
+ *     {@code System.out.println("The name of class Foo is: " + Foo.class.getName());}
  * </blockquote>
  *
  * @param <T> the type of the class modeled by this {@code Class}
  * object.  For example, the type of {@code String.class} is {@code
  * Class<String>}.  Use {@code Class<?>} if the class being modeled is
@@ -190,11 +190,11 @@
      * primitive type, this method returns the name of the primitive type.  If
      * this {@code Class} object represents void this method returns
      * "void". If this {@code Class} object represents an array type,
      * this method returns "class " followed by {@code getName}.
      *
-     * @return a string representation of this class object.
+     * @return a string representation of this {@code Class} object.
      */
     public String toString() {
         return (isInlineClass() ? "inline " : "")
                + (isInterface() ? "interface " : (isPrimitive() ? "" : "class "))
                + getName() + (isInlineClass() && isIndirectType() ? "?" : "");
@@ -205,11 +205,11 @@
      * information about modifiers and type parameters.
      *
      * The string is formatted as a list of type modifiers, if any,
      * followed by the kind of type (empty string for primitive types
      * and {@code class}, {@code enum}, {@code interface},
-     * <code>&#64;</code>{@code interface}, or {@code record} as appropriate), followed
+     * {@code @interface}, or {@code record} as appropriate), followed
      * by the type's name, followed by an angle-bracketed
      * comma-separated list of the type's type parameters, if any,
      * including informative bounds on the type parameters, if any.
      *
      * A space is used to separate modifiers from one another and to
@@ -769,24 +769,24 @@
     @HotSpotIntrinsicCandidate
     public native boolean isAssignableFrom(Class<?> cls);
 
 
     /**
-     * Determines if the specified {@code Class} object represents an
+     * Determines if this {@code Class} object represents an
      * interface type.
      *
-     * @return  {@code true} if this object represents an interface;
+     * @return  {@code true} if this {@code Class} object represents an interface;
      *          {@code false} otherwise.
      */
     @HotSpotIntrinsicCandidate
     public native boolean isInterface();
 
 
     /**
      * Determines if this {@code Class} object represents an array class.
      *
-     * @return  {@code true} if this object represents an array class;
+     * @return  {@code true} if this {@code Class} object represents an array class;
      *          {@code false} otherwise.
      * @since   1.1
      */
     @HotSpotIntrinsicCandidate
     public native boolean isArray();
@@ -826,11 +826,11 @@
     /**
      * Returns true if this {@code Class} object represents an annotation
      * type.  Note that if this method returns true, {@link #isInterface()}
      * would also return true, as all annotation types are also interfaces.
      *
-     * @return {@code true} if this class object represents an annotation
+     * @return {@code true} if this {@code Class} object represents an annotation
      *      type; {@code false} otherwise
      * @since 1.5
      */
     public boolean isAnnotation() {
         return (getModifiers() & ANNOTATION) != 0;
@@ -851,20 +851,20 @@
     /**
      * Returns the  name of the entity (class, interface, array class,
      * primitive type, or void) represented by this {@code Class} object,
      * as a {@code String}.
      *
-     * <p> If this class object represents a reference type that is
+     * <p> If this {@code Class} object represents a reference type that is
      * not an array type then the binary name of the class is
      * returned, as specified by <cite>The Java&trade; Language
      * Specification</cite>.
      *
-     * <p> If this class object represents a primitive type or void, then the
+     * <p> If this {@code Class} object represents a primitive type or void, then the
      * name returned is a {@code String} equal to the Java language
      * keyword corresponding to the primitive type or void.
      *
-     * <p> If this class object represents a class of arrays, then the internal
+     * <p> If this {@code Class} object represents a class of arrays, then the internal
      * form of the name consists of the name of the element type preceded by
      * one or more '{@code [}' characters representing the depth of the array
      * nesting.  The encoding of element type names is as follows:
      *
      * <blockquote><table class="striped">
@@ -908,11 +908,11 @@
      * (new int[3][4][5][6][7][8][9]).getClass().getName()
      *     returns "[[[[[[[I"
      * </pre></blockquote>
      *
      * @return  the name of the class or interface
-     *          represented by this object.
+     *          represented by this {@code Class} object.
      */
     public String getName() {
         String name = this.name;
         return name != null ? name : initClassName();
     }
@@ -926,15 +926,15 @@
      * Returns the class loader for the class.  Some implementations may use
      * null to represent the bootstrap class loader. This method will return
      * null in such implementations if this class was loaded by the bootstrap
      * class loader.
      *
-     * <p>If this object
+     * <p>If this {@code Class} object
      * represents a primitive type or void, null is returned.
      *
      * @return  the class loader that loaded the class or interface
-     *          represented by this object.
+     *          represented by this {@code Class} object.
      * @throws  SecurityException
      *          if a security manager is present, and the caller's class loader
      *          is not {@code null} and is not the same as or an ancestor of the
      *          class loader for the class whose class loader is requested,
      *          and the caller does not have the
@@ -1016,36 +1016,36 @@
     /**
      * Returns the {@code Class} representing the direct superclass of the
      * entity (class, interface, primitive type or void) represented by
      * this {@code Class}.  If this {@code Class} represents either the
      * {@code Object} class, an interface, a primitive type, or void, then
-     * null is returned.  If this object represents an array class then the
-     * {@code Class} object representing the {@code Object} class is
+     * null is returned.  If this {@code Class} object represents an array class
+     * then the {@code Class} object representing the {@code Object} class is
      * returned.
      *
-     * @return the direct superclass of the class represented by this object
+     * @return the direct superclass of the class represented by this {@code Class} object
      */
     @HotSpotIntrinsicCandidate
     public native Class<? super T> getSuperclass();
 
 
     /**
      * Returns the {@code Type} representing the direct superclass of
      * the entity (class, interface, primitive type or void) represented by
-     * this {@code Class}.
+     * this {@code Class} object.
      *
      * <p>If the superclass is a parameterized type, the {@code Type}
      * object returned must accurately reflect the actual type
      * arguments used in the source code. The parameterized type
      * representing the superclass is created if it had not been
      * created before. See the declaration of {@link
      * java.lang.reflect.ParameterizedType ParameterizedType} for the
      * semantics of the creation process for parameterized types.  If
-     * this {@code Class} represents either the {@code Object}
+     * this {@code Class} object represents either the {@code Object}
      * class, an interface, a primitive type, or void, then null is
-     * returned.  If this object represents an array class then the
-     * {@code Class} object representing the {@code Object} class is
+     * returned.  If this {@code Class} object represents an array class
+     * then the {@code Class} object representing the {@code Object} class is
      * returned.
      *
      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
      *     class signature does not conform to the format specified in
      *     section {@jvms 4.7.9} of <cite>The Java&trade; Virtual
@@ -1053,11 +1053,11 @@
      * @throws TypeNotPresentException if the generic superclass
      *     refers to a non-existent type declaration
      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
      *     generic superclass refers to a parameterized type that cannot be
      *     instantiated  for any reason
-     * @return the direct superclass of the class represented by this object
+     * @return the direct superclass of the class represented by this {@code Class} object
      * @since 1.5
      */
     public Type getGenericSuperclass() {
         ClassRepository info = getGenericInfo();
         if (info == null) {
@@ -1142,17 +1142,17 @@
     // cached package name
     private transient String packageName;
 
     /**
      * Returns the interfaces directly implemented by the class or interface
-     * represented by this object.
+     * represented by this {@code Class} object.
      *
-     * <p>If this object represents a class, the return value is an array
+     * <p>If this {@code Class} object represents a class, the return value is an array
      * containing objects representing all interfaces directly implemented by
      * the class.  The order of the interface objects in the array corresponds
      * to the order of the interface names in the {@code implements} clause of
-     * the declaration of the class represented by this object.  For example,
+     * the declaration of the class represented by this {@code Class} object.  For example,
      * given the declaration:
      * <blockquote>
      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
      * </blockquote>
      * suppose the value of {@code s} is an instance of
@@ -1166,20 +1166,20 @@
      * {@code s.getClass().getInterfaces()[1]}
      * </blockquote>
      * is the {@code Class} object that represents interface
      * {@code DessertTopping}.
      *
-     * <p>If this object represents an interface, the array contains objects
+     * <p>If this {@code Class} object represents an interface, the array contains objects
      * representing all interfaces directly extended by the interface.  The
      * order of the interface objects in the array corresponds to the order of
      * the interface names in the {@code extends} clause of the declaration of
-     * the interface represented by this object.
+     * the interface represented by this {@code Class} object.
      *
-     * <p>If this object represents a class or interface that implements no
+     * <p>If this {@code Class} object represents a class or interface that implements no
      * interfaces, the method returns an array of length 0.
      *
-     * <p>If this object represents a primitive type or void, the method
+     * <p>If this {@code Class} object represents a primitive type or void, the method
      * returns an array of length 0.
      *
      * <p>If this {@code Class} object represents an array type, the
      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
      * returned in that order.
@@ -1210,37 +1210,37 @@
     private native Class<?>[] getInterfaces0();
 
     /**
      * Returns the {@code Type}s representing the interfaces
      * directly implemented by the class or interface represented by
-     * this object.
+     * this {@code Class} object.
      *
      * <p>If a superinterface is a parameterized type, the
      * {@code Type} object returned for it must accurately reflect
      * the actual type arguments used in the source code. The
      * parameterized type representing each superinterface is created
      * if it had not been created before. See the declaration of
      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
      * for the semantics of the creation process for parameterized
      * types.
      *
-     * <p>If this object represents a class, the return value is an array
+     * <p>If this {@code Class} object represents a class, the return value is an array
      * containing objects representing all interfaces directly implemented by
      * the class.  The order of the interface objects in the array corresponds
      * to the order of the interface names in the {@code implements} clause of
-     * the declaration of the class represented by this object.
+     * the declaration of the class represented by this {@code Class} object.
      *
-     * <p>If this object represents an interface, the array contains objects
+     * <p>If this {@code Class} object represents an interface, the array contains objects
      * representing all interfaces directly extended by the interface.  The
      * order of the interface objects in the array corresponds to the order of
      * the interface names in the {@code extends} clause of the declaration of
-     * the interface represented by this object.
+     * the interface represented by this {@code Class} object.
      *
-     * <p>If this object represents a class or interface that implements no
+     * <p>If this {@code Class} object represents a class or interface that implements no
      * interfaces, the method returns an array of length 0.
      *
-     * <p>If this object represents a primitive type or void, the method
+     * <p>If this {@code Class} object represents a primitive type or void, the method
      * returns an array of length 0.
      *
      * <p>If this {@code Class} object represents an array type, the
      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
      * returned in that order.
@@ -1294,14 +1294,14 @@
      * using the methods of class {@code Modifier}.
      *
      * <p> If the underlying class is an array class, then its
      * {@code public}, {@code private} and {@code protected}
      * modifiers are the same as those of its component type.  If this
-     * {@code Class} represents a primitive type or void, its
+     * {@code Class} object represents a primitive type or void, its
      * {@code public} modifier is always {@code true}, and its
      * {@code protected} and {@code private} modifiers are always
-     * {@code false}. If this object represents an array class, a
+     * {@code false}. If this {@code Class} object represents an array class, a
      * primitive type or void, then its {@code final} modifier is always
      * {@code true} and its interface modifier is always
      * {@code false}. The values of its other modifiers are not determined
      * by this specification.
      *
@@ -1317,11 +1317,11 @@
 
     /**
      * Gets the signers of this class.
      *
      * @return  the signers of this class, or null if there are no signers.  In
-     *          particular, this method returns null if this object represents
+     *          particular, this method returns null if this {@code Class} object represents
      *          a primitive type or void.
      * @since   1.1
      */
     public Object[] getSigners() {
         return asPrimaryType().getSigners0();
@@ -2076,11 +2076,11 @@
      * field of the class or interface represented by this {@code Class}
      * object. The {@code name} parameter is a {@code String} specifying the
      * simple name of the desired field.
      *
      * <p> The field to be reflected is determined by the algorithm that
-     * follows.  Let C be the class or interface represented by this object:
+     * follows.  Let C be the class or interface represented by this {@code Class} object:
      *
      * <OL>
      * <LI> If C declares a public field with the name specified, that is the
      *      field to be reflected.</LI>
      * <LI> If no field was found in step 1 above, this algorithm is applied
@@ -2761,13 +2761,13 @@
      * caller's module.
      *
      * <p> Otherwise, if this class is not in a named module then the rules for
      * searching resources associated with a given class are implemented by the
      * defining {@linkplain ClassLoader class loader} of the class.  This method
-     * delegates to this object's class loader.  If this object was loaded by
-     * the bootstrap class loader, the method delegates to {@link
-     * ClassLoader#getSystemResourceAsStream}.
+     * delegates to this {@code Class} object's class loader.
+     * If this {@code Class} object was loaded by the bootstrap class loader,
+     * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
      *
      * <p> Before delegation, an absolute resource name is constructed from the
      * given resource name using this algorithm:
      *
      * <ul>
@@ -2859,13 +2859,13 @@
      * caller's module.
      *
      * <p> Otherwise, if this class is not in a named module then the rules for
      * searching resources associated with a given class are implemented by the
      * defining {@linkplain ClassLoader class loader} of the class.  This method
-     * delegates to this object's class loader. If this object was loaded by
-     * the bootstrap class loader, the method delegates to {@link
-     * ClassLoader#getSystemResource}.
+     * delegates to this {@code Class} object's class loader.
+     * If this {@code Class} object was loaded by the bootstrap class loader,
+     * the method delegates to {@link ClassLoader#getSystemResource}.
      *
      * <p> Before delegation, an absolute resource name is constructed from the
      * given resource name using this algorithm:
      *
      * <ul>
@@ -3770,12 +3770,12 @@
     /**
      * Returns the elements of this enum class or null if this
      * Class object does not represent an enum type.
      *
      * @return an array containing the values comprising the enum class
-     *     represented by this Class object in the order they're
-     *     declared, or null if this Class object does not
+     *     represented by this {@code Class} object in the order they're
+     *     declared, or null if this {@code Class} object does not
      *     represent an enum type
      * @since 1.5
      */
     public T[] getEnumConstants() {
         T[] values = getEnumConstantsShared();
@@ -3869,21 +3869,21 @@
 
     /**
      * Casts this {@code Class} object to represent a subclass of the class
      * represented by the specified class object.  Checks that the cast
      * is valid, and throws a {@code ClassCastException} if it is not.  If
-     * this method succeeds, it always returns a reference to this class object.
+     * this method succeeds, it always returns a reference to this {@code Class} object.
      *
      * <p>This method is useful when a client needs to "narrow" the type of
      * a {@code Class} object to pass it to an API that restricts the
      * {@code Class} objects that it is willing to accept.  A cast would
      * generate a compile-time warning, as the correctness of the cast
      * could not be checked at runtime (because generic types are implemented
      * by erasure).
      *
-     * @param <U> the type to cast this class object to
-     * @param clazz the class of the type to cast this class object to
+     * @param <U> the type to cast this {@code Class} object to
+     * @param clazz the class of the type to cast this {@code Class} object to
      * @return this {@code Class} object, cast to represent a subclass of
      *    the specified class object.
      * @throws ClassCastException if this {@code Class} object does not
      *    represent a subclass of the specified class (here "subclass" includes
      *    the class itself).

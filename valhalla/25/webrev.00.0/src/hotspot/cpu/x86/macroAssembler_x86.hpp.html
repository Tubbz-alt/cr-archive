<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_MACROASSEMBLER_X86_HPP
  26 #define CPU_X86_MACROASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;utilities/macros.hpp&quot;
  30 #include &quot;runtime/rtmLocking.hpp&quot;
  31 #include &quot;runtime/signature.hpp&quot;
  32 
  33 class ciValueKlass;
  34 
  35 // MacroAssembler extends Assembler by frequently used macros.
  36 //
  37 // Instructions for which a &#39;better&#39; code sequence exists depending
  38 // on arguments should also go in here.
  39 
  40 class MacroAssembler: public Assembler {
  41   friend class LIR_Assembler;
  42   friend class Runtime1;      // as_Address()
  43 
  44  public:
  45   // Support for VM calls
  46   //
  47   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  48   // may customize this version by overriding it for its purposes (e.g., to save/restore
  49   // additional registers when doing a VM call).
  50 
  51   virtual void call_VM_leaf_base(
  52     address entry_point,               // the entry point
  53     int     number_of_arguments        // the number of arguments to pop after the call
  54   );
  55 
  56  protected:
  57   // This is the base routine called by the different versions of call_VM. The interpreter
  58   // may customize this version by overriding it for its purposes (e.g., to save/restore
  59   // additional registers when doing a VM call).
  60   //
  61   // If no java_thread register is specified (noreg) than rdi will be used instead. call_VM_base
  62   // returns the register which contains the thread upon return. If a thread register has been
  63   // specified, the return value will correspond to that register. If no last_java_sp is specified
  64   // (noreg) than rsp will be used instead.
  65   virtual void call_VM_base(           // returns the register containing the thread upon return
  66     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  67     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  68     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  69     address  entry_point,              // the entry point
  70     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  71     bool     check_exceptions          // whether to check for pending exceptions after return
  72   );
  73 
  74   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  75 
  76   // helpers for FPU flag access
  77   // tmp is a temporary register, if none is available use noreg
  78   void save_rax   (Register tmp);
  79   void restore_rax(Register tmp);
  80 
  81  public:
  82   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
  83 
  84  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
  85  // The implementation is only non-empty for the InterpreterMacroAssembler,
  86  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
  87  virtual void check_and_handle_popframe(Register java_thread);
  88  virtual void check_and_handle_earlyret(Register java_thread);
  89 
  90   Address as_Address(AddressLiteral adr);
  91   Address as_Address(ArrayAddress adr);
  92 
  93   // Support for NULL-checks
  94   //
  95   // Generates code that causes a NULL OS exception if the content of reg is NULL.
  96   // If the accessed location is M[reg + offset] and the offset is known, provide the
  97   // offset. No explicit code generation is needed if the offset is within a certain
  98   // range (0 &lt;= offset &lt;= page_size).
  99 
 100   void null_check(Register reg, int offset = -1);
 101   static bool needs_explicit_null_check(intptr_t offset);
 102   static bool uses_implicit_null_check(void* address);
 103 
 104   // valueKlass queries, kills temp_reg
 105   void test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value);
 106   void test_klass_is_empty_value(Register klass, Register temp_reg, Label&amp; is_empty_value);
 107 
 108   // Get the default value oop for the given ValueKlass
 109   void get_default_value_oop(Register value_klass, Register temp_reg, Register obj);
 110   // The empty value oop, for the given ValueKlass (&quot;empty&quot; as in no instance fields)
 111   // get_default_value_oop with extra assertion for empty value klass
 112   void get_empty_value_oop(Register value_klass, Register temp_reg, Register obj);
 113 
 114   void test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable);
 115   void test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; notFlattenable);
 116   void test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened);
 117 
 118   // Check oops array storage properties, i.e. flattened and/or null-free
 119   void test_flattened_array_oop(Register oop, Register temp_reg, Label&amp;is_flattened_array);
 120   void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&amp;is_non_flattened_array);
 121   void test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array);
 122   void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array);
 123 
 124   // Required platform-specific helpers for Label::patch_instructions.
 125   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 126   void pd_patch_instruction(address branch, address target, const char* file, int line) {
 127     unsigned char op = branch[0];
 128     assert(op == 0xE8 /* call */ ||
 129         op == 0xE9 /* jmp */ ||
 130         op == 0xEB /* short jmp */ ||
 131         (op &amp; 0xF0) == 0x70 /* short jcc */ ||
 132         op == 0x0F &amp;&amp; (branch[1] &amp; 0xF0) == 0x80 /* jcc */ ||
 133         op == 0xC7 &amp;&amp; branch[1] == 0xF8 /* xbegin */,
 134         &quot;Invalid opcode at patch point&quot;);
 135 
 136     if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
 137       // short offset operators (jmp and jcc)
 138       char* disp = (char*) &amp;branch[1];
 139       int imm8 = target - (address) &amp;disp[1];
 140       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;,
 141                 file == NULL ? &quot;&lt;NULL&gt;&quot; : file, line);
 142       *disp = imm8;
 143     } else {
 144       int* disp = (int*) &amp;branch[(op == 0x0F || op == 0xC7)? 2: 1];
 145       int imm32 = target - (address) &amp;disp[1];
 146       *disp = imm32;
 147     }
 148   }
 149 
 150   // The following 4 methods return the offset of the appropriate move instruction
 151 
 152   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 153   int load_unsigned_byte(Register dst, Address src);
 154   int load_unsigned_short(Register dst, Address src);
 155 
 156   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 157   int load_signed_byte(Register dst, Address src);
 158   int load_signed_short(Register dst, Address src);
 159 
 160   // Support for sign-extension (hi:lo = extend_sign(lo))
 161   void extend_sign(Register hi, Register lo);
 162 
 163   // Load and store values by size and signed-ness
 164   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 165   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 166 
 167   // Support for inc/dec with optimal instruction selection depending on value
 168 
 169   void increment(Register reg, int value = 1) { LP64_ONLY(incrementq(reg, value)) NOT_LP64(incrementl(reg, value)) ; }
 170   void decrement(Register reg, int value = 1) { LP64_ONLY(decrementq(reg, value)) NOT_LP64(decrementl(reg, value)) ; }
 171 
 172   void decrementl(Address dst, int value = 1);
 173   void decrementl(Register reg, int value = 1);
 174 
 175   void decrementq(Register reg, int value = 1);
 176   void decrementq(Address dst, int value = 1);
 177 
 178   void incrementl(Address dst, int value = 1);
 179   void incrementl(Register reg, int value = 1);
 180 
 181   void incrementq(Register reg, int value = 1);
 182   void incrementq(Address dst, int value = 1);
 183 
 184   // Support optimal SSE move instructions.
 185   void movflt(XMMRegister dst, XMMRegister src) {
 186     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 187     if (UseXmmRegToRegMoveAll) { movaps(dst, src); return; }
 188     else                       { movss (dst, src); return; }
 189   }
 190   void movflt(XMMRegister dst, Address src) { movss(dst, src); }
 191   void movflt(XMMRegister dst, AddressLiteral src);
 192   void movflt(Address dst, XMMRegister src) { movss(dst, src); }
 193 
 194   void movdbl(XMMRegister dst, XMMRegister src) {
 195     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 196     if (UseXmmRegToRegMoveAll) { movapd(dst, src); return; }
 197     else                       { movsd (dst, src); return; }
 198   }
 199 
 200   void movdbl(XMMRegister dst, AddressLiteral src);
 201 
 202   void movdbl(XMMRegister dst, Address src) {
 203     if (UseXmmLoadAndClearUpper) { movsd (dst, src); return; }
 204     else                         { movlpd(dst, src); return; }
 205   }
 206   void movdbl(Address dst, XMMRegister src) { movsd(dst, src); }
 207 
 208   void incrementl(AddressLiteral dst);
 209   void incrementl(ArrayAddress dst);
 210 
 211   void incrementq(AddressLiteral dst);
 212 
 213   // Alignment
 214   void align(int modulus);
 215   void align(int modulus, int target);
 216 
 217   // A 5 byte nop that is safe for patching (see patch_verified_entry)
 218   void fat_nop();
 219 
 220   // Stack frame creation/removal
 221   void enter();
 222   void leave();
 223 
 224   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 225   // The pointer will be loaded into the thread register.
 226   void get_thread(Register thread);
 227 
 228 
 229   // Support for VM calls
 230   //
 231   // It is imperative that all calls into the VM are handled via the call_VM macros.
 232   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 233   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 234 
 235 
 236   void call_VM(Register oop_result,
 237                address entry_point,
 238                bool check_exceptions = true);
 239   void call_VM(Register oop_result,
 240                address entry_point,
 241                Register arg_1,
 242                bool check_exceptions = true);
 243   void call_VM(Register oop_result,
 244                address entry_point,
 245                Register arg_1, Register arg_2,
 246                bool check_exceptions = true);
 247   void call_VM(Register oop_result,
 248                address entry_point,
 249                Register arg_1, Register arg_2, Register arg_3,
 250                bool check_exceptions = true);
 251 
 252   // Overloadings with last_Java_sp
 253   void call_VM(Register oop_result,
 254                Register last_java_sp,
 255                address entry_point,
 256                int number_of_arguments = 0,
 257                bool check_exceptions = true);
 258   void call_VM(Register oop_result,
 259                Register last_java_sp,
 260                address entry_point,
 261                Register arg_1, bool
 262                check_exceptions = true);
 263   void call_VM(Register oop_result,
 264                Register last_java_sp,
 265                address entry_point,
 266                Register arg_1, Register arg_2,
 267                bool check_exceptions = true);
 268   void call_VM(Register oop_result,
 269                Register last_java_sp,
 270                address entry_point,
 271                Register arg_1, Register arg_2, Register arg_3,
 272                bool check_exceptions = true);
 273 
 274   void get_vm_result  (Register oop_result, Register thread);
 275   void get_vm_result_2(Register metadata_result, Register thread);
 276 
 277   // These always tightly bind to MacroAssembler::call_VM_base
 278   // bypassing the virtual implementation
 279   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 280   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 281   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 282   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 283   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 284 
 285   void call_VM_leaf0(address entry_point);
 286   void call_VM_leaf(address entry_point,
 287                     int number_of_arguments = 0);
 288   void call_VM_leaf(address entry_point,
 289                     Register arg_1);
 290   void call_VM_leaf(address entry_point,
 291                     Register arg_1, Register arg_2);
 292   void call_VM_leaf(address entry_point,
 293                     Register arg_1, Register arg_2, Register arg_3);
 294 
 295   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 296   // bypassing the virtual implementation
 297   void super_call_VM_leaf(address entry_point);
 298   void super_call_VM_leaf(address entry_point, Register arg_1);
 299   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 300   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 301   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 302 
 303   // last Java Frame (fills frame anchor)
 304   void set_last_Java_frame(Register thread,
 305                            Register last_java_sp,
 306                            Register last_java_fp,
 307                            address last_java_pc);
 308 
 309   // thread in the default location (r15_thread on 64bit)
 310   void set_last_Java_frame(Register last_java_sp,
 311                            Register last_java_fp,
 312                            address last_java_pc);
 313 
 314   void reset_last_Java_frame(Register thread, bool clear_fp);
 315 
 316   // thread in the default location (r15_thread on 64bit)
 317   void reset_last_Java_frame(bool clear_fp);
 318 
 319   // jobjects
 320   void clear_jweak_tag(Register possibly_jweak);
 321   void resolve_jobject(Register value, Register thread, Register tmp);
 322 
 323   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 324   void c2bool(Register x);
 325 
 326   // C++ bool manipulation
 327 
 328   void movbool(Register dst, Address src);
 329   void movbool(Address dst, bool boolconst);
 330   void movbool(Address dst, Register src);
 331   void testbool(Register dst);
 332 
 333   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 334   void resolve_weak_handle(Register result, Register tmp);
 335   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 336   void load_method_holder_cld(Register rresult, Register rmethod);
 337 
 338   void load_method_holder(Register holder, Register method);
 339 
 340   // oop manipulations
 341   void load_metadata(Register dst, Register src);
 342   void load_storage_props(Register dst, Register src);
 343   void load_klass(Register dst, Register src);
 344   void store_klass(Register dst, Register src);
 345 
 346   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 347                       Register tmp1, Register thread_tmp);
 348   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 349                        Register tmp1, Register tmp2, Register tmp3 = noreg);
 350 
 351   void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register value_klass);
 352 
 353   // value type data payload offsets...
 354   void first_field_offset(Register value_klass, Register offset);
 355   void data_for_oop(Register oop, Register data, Register value_klass);
 356   // get data payload ptr a flat value array at index, kills rcx and index
 357   void data_for_value_array_index(Register array, Register array_klass,
 358                                   Register index, Register data);
 359 
 360 
 361   // Resolves obj access. Result is placed in the same register.
 362   // All other registers are preserved.
 363   void resolve(DecoratorSet decorators, Register obj);
 364 
 365   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 366                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 367   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 368                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 369   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 370                       Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);
 371 
 372   // Used for storing NULL. All other oop constants should be
 373   // stored using routines that take a jobject.
 374   void store_heap_oop_null(Address dst);
 375 
 376   void load_prototype_header(Register dst, Register src);
 377 
 378 #ifdef _LP64
 379   void store_klass_gap(Register dst, Register src);
 380 
 381   // This dummy is to prevent a call to store_heap_oop from
 382   // converting a zero (like NULL) into a Register by giving
 383   // the compiler two choices it can&#39;t resolve
 384 
 385   void store_heap_oop(Address dst, void* dummy);
 386 
 387   void encode_heap_oop(Register r);
 388   void decode_heap_oop(Register r);
 389   void encode_heap_oop_not_null(Register r);
 390   void decode_heap_oop_not_null(Register r);
 391   void encode_heap_oop_not_null(Register dst, Register src);
 392   void decode_heap_oop_not_null(Register dst, Register src);
 393 
 394   void set_narrow_oop(Register dst, jobject obj);
 395   void set_narrow_oop(Address dst, jobject obj);
 396   void cmp_narrow_oop(Register dst, jobject obj);
 397   void cmp_narrow_oop(Address dst, jobject obj);
 398 
 399   void encode_klass_not_null(Register r);
 400   void decode_klass_not_null(Register r);
 401   void encode_klass_not_null(Register dst, Register src);
 402   void decode_klass_not_null(Register dst, Register src);
 403   void set_narrow_klass(Register dst, Klass* k);
 404   void set_narrow_klass(Address dst, Klass* k);
 405   void cmp_narrow_klass(Register dst, Klass* k);
 406   void cmp_narrow_klass(Address dst, Klass* k);
 407 
 408   // Returns the byte size of the instructions generated by decode_klass_not_null()
 409   // when compressed klass pointers are being used.
 410   static int instr_size_for_decode_klass_not_null();
 411 
 412   // if heap base register is used - reinit it with the correct value
 413   void reinit_heapbase();
 414 
 415   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 416 
 417 #endif // _LP64
 418 
 419   // Int division/remainder for Java
 420   // (as idivl, but checks for special case as described in JVM spec.)
 421   // returns idivl instruction offset for implicit exception handling
 422   int corrected_idivl(Register reg);
 423 
 424   // Long division/remainder for Java
 425   // (as idivq, but checks for special case as described in JVM spec.)
 426   // returns idivq instruction offset for implicit exception handling
 427   int corrected_idivq(Register reg);
 428 
 429   void int3();
 430 
 431   // Long operation macros for a 32bit cpu
 432   // Long negation for Java
 433   void lneg(Register hi, Register lo);
 434 
 435   // Long multiplication for Java
 436   // (destroys contents of eax, ebx, ecx and edx)
 437   void lmul(int x_rsp_offset, int y_rsp_offset); // rdx:rax = x * y
 438 
 439   // Long shifts for Java
 440   // (semantics as described in JVM spec.)
 441   void lshl(Register hi, Register lo);                               // hi:lo &lt;&lt; (rcx &amp; 0x3f)
 442   void lshr(Register hi, Register lo, bool sign_extension = false);  // hi:lo &gt;&gt; (rcx &amp; 0x3f)
 443 
 444   // Long compare for Java
 445   // (semantics as described in JVM spec.)
 446   void lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo); // x_hi = lcmp(x, y)
 447 
 448 
 449   // misc
 450 
 451   // Sign extension
 452   void sign_extend_short(Register reg);
 453   void sign_extend_byte(Register reg);
 454 
 455   // Division by power of 2, rounding towards 0
 456   void division_with_shift(Register reg, int shift_value);
 457 
 458 #ifndef _LP64
 459   // Compares the top-most stack entries on the FPU stack and sets the eflags as follows:
 460   //
 461   // CF (corresponds to C0) if x &lt; y
 462   // PF (corresponds to C2) if unordered
 463   // ZF (corresponds to C3) if x = y
 464   //
 465   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 466   // tmp is a temporary register, if none is available use noreg (only matters for non-P6 code)
 467   void fcmp(Register tmp);
 468   // Variant of the above which allows y to be further down the stack
 469   // and which only pops x and y if specified. If pop_right is
 470   // specified then pop_left must also be specified.
 471   void fcmp(Register tmp, int index, bool pop_left, bool pop_right);
 472 
 473   // Floating-point comparison for Java
 474   // Compares the top-most stack entries on the FPU stack and stores the result in dst.
 475   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 476   // (semantics as described in JVM spec.)
 477   void fcmp2int(Register dst, bool unordered_is_less);
 478   // Variant of the above which allows y to be further down the stack
 479   // and which only pops x and y if specified. If pop_right is
 480   // specified then pop_left must also be specified.
 481   void fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right);
 482 
 483   // Floating-point remainder for Java (ST0 = ST0 fremr ST1, ST1 is empty afterwards)
 484   // tmp is a temporary register, if none is available use noreg
 485   void fremr(Register tmp);
 486 
 487   // only if +VerifyFPU
 488   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 489 #endif // !LP64
 490 
 491   // dst = c = a * b + c
 492   void fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 493   void fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 494 
 495   void vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 496   void vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 497   void vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 498   void vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 499 
 500 
 501   // same as fcmp2int, but using SSE2
 502   void cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 503   void cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 504 
 505   // branch to L if FPU flag C2 is set/not set
 506   // tmp is a temporary register, if none is available use noreg
 507   void jC2 (Register tmp, Label&amp; L);
 508   void jnC2(Register tmp, Label&amp; L);
 509 
 510   // Load float value from &#39;address&#39;. If UseSSE &gt;= 1, the value is loaded into
 511   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 512   void load_float(Address src);
 513 
 514   // Store float value to &#39;address&#39;. If UseSSE &gt;= 1, the value is stored
 515   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 516   void store_float(Address dst);
 517 
 518   // Load double value from &#39;address&#39;. If UseSSE &gt;= 2, the value is loaded into
 519   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 520   void load_double(Address src);
 521 
 522   // Store double value to &#39;address&#39;. If UseSSE &gt;= 2, the value is stored
 523   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 524   void store_double(Address dst);
 525 
 526 #ifndef _LP64
 527   // Pop ST (ffree &amp; fincstp combined)
 528   void fpop();
 529 
 530   void empty_FPU_stack();
 531 #endif // !_LP64
 532 
 533   void push_IU_state();
 534   void pop_IU_state();
 535 
 536   void push_FPU_state();
 537   void pop_FPU_state();
 538 
 539   void push_CPU_state();
 540   void pop_CPU_state();
 541 
 542   // Round up to a power of two
 543   void round_to(Register reg, int modulus);
 544 
 545   // Callee saved registers handling
 546   void push_callee_saved_registers();
 547   void pop_callee_saved_registers();
 548 
 549   // allocation
 550 
 551   // Object / value buffer allocation...
 552   // Allocate instance of klass, assumes klass initialized by caller
 553   // new_obj prefers to be rax
 554   // Kills t1 and t2, perserves klass, return allocation in new_obj (rsi on LP64)
 555   void allocate_instance(Register klass, Register new_obj,
 556                          Register t1, Register t2,
 557                          bool clear_fields, Label&amp; alloc_failed);
 558 
 559   void eden_allocate(
 560     Register thread,                   // Current thread
 561     Register obj,                      // result: pointer to object after successful allocation
 562     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 563     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 564     Register t1,                       // temp register
 565     Label&amp;   slow_case                 // continuation point if fast allocation fails
 566   );
 567   void tlab_allocate(
 568     Register thread,                   // Current thread
 569     Register obj,                      // result: pointer to object after successful allocation
 570     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 571     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 572     Register t1,                       // temp register
 573     Register t2,                       // temp register
 574     Label&amp;   slow_case                 // continuation point if fast allocation fails
 575   );
 576   void zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp);
 577 
 578   // For field &quot;index&quot; within &quot;klass&quot;, return value_klass ...
 579   void get_value_field_klass(Register klass, Register index, Register value_klass);
 580 
 581   // interface method calling
 582   void lookup_interface_method(Register recv_klass,
 583                                Register intf_klass,
 584                                RegisterOrConstant itable_index,
 585                                Register method_result,
 586                                Register scan_temp,
 587                                Label&amp; no_such_interface,
 588                                bool return_method = true);
 589 
 590   // virtual method calling
 591   void lookup_virtual_method(Register recv_klass,
 592                              RegisterOrConstant vtable_index,
 593                              Register method_result);
 594 
 595   // Test sub_klass against super_klass, with fast and slow paths.
 596 
 597   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 598   // One of the three labels can be NULL, meaning take the fall-through.
 599   // If super_check_offset is -1, the value is loaded up from super_klass.
 600   // No registers are killed, except temp_reg.
 601   void check_klass_subtype_fast_path(Register sub_klass,
 602                                      Register super_klass,
 603                                      Register temp_reg,
 604                                      Label* L_success,
 605                                      Label* L_failure,
 606                                      Label* L_slow_path,
 607                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 608 
 609   // The rest of the type check; must be wired to a corresponding fast path.
 610   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 611   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 612   // Updates the sub&#39;s secondary super cache as necessary.
 613   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 614   void check_klass_subtype_slow_path(Register sub_klass,
 615                                      Register super_klass,
 616                                      Register temp_reg,
 617                                      Register temp2_reg,
 618                                      Label* L_success,
 619                                      Label* L_failure,
 620                                      bool set_cond_codes = false);
 621 
 622   // Simplified, combined version, good for typical uses.
 623   // Falls through on failure.
 624   void check_klass_subtype(Register sub_klass,
 625                            Register super_klass,
 626                            Register temp_reg,
 627                            Label&amp; L_success);
 628 
 629   void clinit_barrier(Register klass,
 630                       Register thread,
 631                       Label* L_fast_path = NULL,
 632                       Label* L_slow_path = NULL);
 633 
 634   // method handles (JSR 292)
 635   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 636 
 637   //----
 638   void set_word_if_not_zero(Register reg); // sets reg to 1 if not zero, otherwise 0
 639 
 640   // Debugging
 641 
 642   // only if +VerifyOops
 643   void _verify_oop(Register reg, const char* s, const char* file, int line);
 644   void _verify_oop_addr(Address addr, const char* s, const char* file, int line);
 645 
 646   // TODO: verify method and klass metadata (compare against vptr?)
 647   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 648   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 649 
 650 #define verify_oop(reg) _verify_oop(reg, &quot;broken oop &quot; #reg, __FILE__, __LINE__)
 651 #define verify_oop_msg(reg, msg) _verify_oop(reg, &quot;broken oop &quot; #reg &quot;, &quot; #msg, __FILE__, __LINE__)
 652 #define verify_oop_addr(addr) _verify_oop_addr(addr, &quot;broken oop addr &quot; #addr, __FILE__, __LINE__)
 653 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 654 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 655 
 656   // Verify or restore cpu control state after JNI call
 657   void restore_cpu_control_state_after_jni();
 658 
 659   // prints msg, dumps registers and stops execution
 660   void stop(const char* msg);
 661 
 662   // prints msg and continues
 663   void warn(const char* msg);
 664 
 665   // dumps registers and other state
 666   void print_state();
 667 
 668   static void debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg);
 669   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 670   static void print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip);
 671   static void print_state64(int64_t pc, int64_t regs[]);
 672 
 673   void os_breakpoint();
 674 
 675   void untested()                                { stop(&quot;untested&quot;); }
 676 
 677   void unimplemented(const char* what = &quot;&quot;);
 678 
 679   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 680 
 681   void print_CPU_state();
 682 
 683   // Stack overflow checking
 684   void bang_stack_with_offset(int offset) {
 685     // stack grows down, caller passes positive offset
 686     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 687     movl(Address(rsp, (-offset)), rax);
 688   }
 689 
 690   // Writes to stack successive pages until offset reached to check for
 691   // stack overflow + shadow pages.  Also, clobbers tmp
 692   void bang_stack_size(Register size, Register tmp);
 693 
 694   // Check for reserved stack access in method being exited (for JIT)
 695   void reserved_stack_check();
 696 
 697   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
 698                                                 Register tmp,
 699                                                 int offset);
 700 
 701   // If thread_reg is != noreg the code assumes the register passed contains
 702   // the thread (required on 64 bit).
 703   void safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg);
 704 
 705   void verify_tlab();
 706 
 707   // Biased locking support
 708   // lock_reg and obj_reg must be loaded up with the appropriate values.
 709   // swap_reg must be rax, and is killed.
 710   // tmp_reg is optional. If it is supplied (i.e., != noreg) it will
 711   // be killed; if not supplied, push/pop will be used internally to
 712   // allocate a temporary (inefficient, avoid if possible).
 713   // Optional slow case is for implementations (interpreter and C1) which branch to
 714   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 715   // Returns offset of first potentially-faulting instruction for null
 716   // check info (currently consumed only by C1). If
 717   // swap_reg_contains_mark is true then returns -1 as it is assumed
 718   // the calling code has already passed any potential faults.
 719   int biased_locking_enter(Register lock_reg, Register obj_reg,
 720                            Register swap_reg, Register tmp_reg,
 721                            bool swap_reg_contains_mark,
 722                            Label&amp; done, Label* slow_case = NULL,
 723                            BiasedLockingCounters* counters = NULL);
 724   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 725 
 726   Condition negate_condition(Condition cond);
 727 
 728   // Instructions that use AddressLiteral operands. These instruction can handle 32bit/64bit
 729   // operands. In general the names are modified to avoid hiding the instruction in Assembler
 730   // so that we don&#39;t need to implement all the varieties in the Assembler with trivial wrappers
 731   // here in MacroAssembler. The major exception to this rule is call
 732 
 733   // Arithmetics
 734 
 735 
 736   void addptr(Address dst, int32_t src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)) ; }
 737   void addptr(Address dst, Register src);
 738 
 739   void addptr(Register dst, Address src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)); }
 740   void addptr(Register dst, int32_t src);
 741   void addptr(Register dst, Register src);
 742   void addptr(Register dst, RegisterOrConstant src) {
 743     if (src.is_constant()) addptr(dst, (int) src.as_constant());
 744     else                   addptr(dst,       src.as_register());
 745   }
 746 
 747   void andptr(Register dst, int32_t src);
 748   void andptr(Register src1, Register src2) { LP64_ONLY(andq(src1, src2)) NOT_LP64(andl(src1, src2)) ; }
 749 
 750   void cmp8(AddressLiteral src1, int imm);
 751 
 752   // renamed to drag out the casting of address to int32_t/intptr_t
 753   void cmp32(Register src1, int32_t imm);
 754 
 755   void cmp32(AddressLiteral src1, int32_t imm);
 756   // compare reg - mem, or reg - &amp;mem
 757   void cmp32(Register src1, AddressLiteral src2);
 758 
 759   void cmp32(Register src1, Address src2);
 760 
 761 #ifndef _LP64
 762   void cmpklass(Address dst, Metadata* obj);
 763   void cmpklass(Register dst, Metadata* obj);
 764   void cmpoop(Address dst, jobject obj);
 765   void cmpoop_raw(Address dst, jobject obj);
 766 #endif // _LP64
 767 
 768   void cmpoop(Register src1, Register src2);
 769   void cmpoop(Register src1, Address src2);
 770   void cmpoop(Register dst, jobject obj);
 771   void cmpoop_raw(Register dst, jobject obj);
 772 
 773   // NOTE src2 must be the lval. This is NOT an mem-mem compare
 774   void cmpptr(Address src1, AddressLiteral src2);
 775 
 776   void cmpptr(Register src1, AddressLiteral src2);
 777 
 778   void cmpptr(Register src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 779   void cmpptr(Register src1, Address src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 780   // void cmpptr(Address src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 781 
 782   void cmpptr(Register src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 783   void cmpptr(Address src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 784 
 785   // cmp64 to avoild hiding cmpq
 786   void cmp64(Register src1, AddressLiteral src);
 787 
 788   void cmpxchgptr(Register reg, Address adr);
 789 
 790   void locked_cmpxchgptr(Register reg, AddressLiteral adr);
 791 
 792 
 793   void imulptr(Register dst, Register src) { LP64_ONLY(imulq(dst, src)) NOT_LP64(imull(dst, src)); }
 794   void imulptr(Register dst, Register src, int imm32) { LP64_ONLY(imulq(dst, src, imm32)) NOT_LP64(imull(dst, src, imm32)); }
 795 
 796 
 797   void negptr(Register dst) { LP64_ONLY(negq(dst)) NOT_LP64(negl(dst)); }
 798 
 799   void notptr(Register dst) { LP64_ONLY(notq(dst)) NOT_LP64(notl(dst)); }
 800 
 801   void shlptr(Register dst, int32_t shift);
 802   void shlptr(Register dst) { LP64_ONLY(shlq(dst)) NOT_LP64(shll(dst)); }
 803 
 804   void shrptr(Register dst, int32_t shift);
 805   void shrptr(Register dst) { LP64_ONLY(shrq(dst)) NOT_LP64(shrl(dst)); }
 806 
 807   void sarptr(Register dst) { LP64_ONLY(sarq(dst)) NOT_LP64(sarl(dst)); }
 808   void sarptr(Register dst, int32_t src) { LP64_ONLY(sarq(dst, src)) NOT_LP64(sarl(dst, src)); }
 809 
 810   void subptr(Address dst, int32_t src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 811 
 812   void subptr(Register dst, Address src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 813   void subptr(Register dst, int32_t src);
 814   // Force generation of a 4 byte immediate value even if it fits into 8bit
 815   void subptr_imm32(Register dst, int32_t src);
 816   void subptr(Register dst, Register src);
 817   void subptr(Register dst, RegisterOrConstant src) {
 818     if (src.is_constant()) subptr(dst, (int) src.as_constant());
 819     else                   subptr(dst,       src.as_register());
 820   }
 821 
 822   void sbbptr(Address dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 823   void sbbptr(Register dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 824 
 825   void xchgptr(Register src1, Register src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 826   void xchgptr(Register src1, Address src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 827 
 828   void xaddptr(Address src1, Register src2) { LP64_ONLY(xaddq(src1, src2)) NOT_LP64(xaddl(src1, src2)) ; }
 829 
 830 
 831 
 832   // Helper functions for statistics gathering.
 833   // Conditionally (atomically, on MPs) increments passed counter address, preserving condition codes.
 834   void cond_inc32(Condition cond, AddressLiteral counter_addr);
 835   // Unconditional atomic increment.
 836   void atomic_incl(Address counter_addr);
 837   void atomic_incl(AddressLiteral counter_addr, Register scr = rscratch1);
 838 #ifdef _LP64
 839   void atomic_incq(Address counter_addr);
 840   void atomic_incq(AddressLiteral counter_addr, Register scr = rscratch1);
 841 #endif
 842   void atomic_incptr(AddressLiteral counter_addr, Register scr = rscratch1) { LP64_ONLY(atomic_incq(counter_addr, scr)) NOT_LP64(atomic_incl(counter_addr, scr)) ; }
 843   void atomic_incptr(Address counter_addr) { LP64_ONLY(atomic_incq(counter_addr)) NOT_LP64(atomic_incl(counter_addr)) ; }
 844 
 845   void lea(Register dst, AddressLiteral adr);
 846   void lea(Address dst, AddressLiteral adr);
 847   void lea(Register dst, Address adr) { Assembler::lea(dst, adr); }
 848 
 849   void leal32(Register dst, Address src) { leal(dst, src); }
 850 
 851   // Import other testl() methods from the parent class or else
 852   // they will be hidden by the following overriding declaration.
 853   using Assembler::testl;
 854   void testl(Register dst, AddressLiteral src);
 855 
 856   void orptr(Register dst, Address src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 857   void orptr(Register dst, Register src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 858   void orptr(Register dst, int32_t src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 859   void orptr(Address dst, int32_t imm32) { LP64_ONLY(orq(dst, imm32)) NOT_LP64(orl(dst, imm32)); }
 860 
 861   void testptr(Register src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }
 862   void testptr(Register src1, Address src2) { LP64_ONLY(testq(src1, src2)) NOT_LP64(testl(src1, src2)); }
 863   void testptr(Register src1, Register src2);
 864 
 865   void xorptr(Register dst, Register src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 866   void xorptr(Register dst, Address src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 867 
 868   // Calls
 869 
 870   void call(Label&amp; L, relocInfo::relocType rtype);
 871   void call(Register entry);
 872 
 873   // NOTE: this call transfers to the effective address of entry NOT
 874   // the address contained by entry. This is because this is more natural
 875   // for jumps/calls.
 876   void call(AddressLiteral entry);
 877 
 878   // Emit the CompiledIC call idiom
 879   void ic_call(address entry, jint method_index = 0);
 880 
 881   // Jumps
 882 
 883   // NOTE: these jumps tranfer to the effective address of dst NOT
 884   // the address contained by dst. This is because this is more natural
 885   // for jumps/calls.
 886   void jump(AddressLiteral dst);
 887   void jump_cc(Condition cc, AddressLiteral dst);
 888 
 889   // 32bit can do a case table jump in one instruction but we no longer allow the base
 890   // to be installed in the Address class. This jump will tranfers to the address
 891   // contained in the location described by entry (not the address of entry)
 892   void jump(ArrayAddress entry);
 893 
 894   // Floating
 895 
 896   void andpd(XMMRegister dst, Address src) { Assembler::andpd(dst, src); }
 897   void andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
 898   void andpd(XMMRegister dst, XMMRegister src) { Assembler::andpd(dst, src); }
 899 
 900   void andps(XMMRegister dst, XMMRegister src) { Assembler::andps(dst, src); }
 901   void andps(XMMRegister dst, Address src) { Assembler::andps(dst, src); }
 902   void andps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
 903 
 904   void comiss(XMMRegister dst, XMMRegister src) { Assembler::comiss(dst, src); }
 905   void comiss(XMMRegister dst, Address src) { Assembler::comiss(dst, src); }
 906   void comiss(XMMRegister dst, AddressLiteral src);
 907 
 908   void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
 909   void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
 910   void comisd(XMMRegister dst, AddressLiteral src);
 911 
 912 #ifndef _LP64
 913   void fadd_s(Address src)        { Assembler::fadd_s(src); }
 914   void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
 915 
 916   void fldcw(Address src) { Assembler::fldcw(src); }
 917   void fldcw(AddressLiteral src);
 918 
 919   void fld_s(int index)   { Assembler::fld_s(index); }
 920   void fld_s(Address src) { Assembler::fld_s(src); }
 921   void fld_s(AddressLiteral src);
 922 
 923   void fld_d(Address src) { Assembler::fld_d(src); }
 924   void fld_d(AddressLiteral src);
 925 
 926   void fld_x(Address src) { Assembler::fld_x(src); }
 927   void fld_x(AddressLiteral src);
 928 
 929   void fmul_s(Address src)        { Assembler::fmul_s(src); }
 930   void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }
 931 #endif // _LP64
 932 
 933   void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
 934   void ldmxcsr(AddressLiteral src);
 935 
 936 #ifdef _LP64
 937  private:
 938   void sha256_AVX2_one_round_compute(
 939     Register  reg_old_h,
 940     Register  reg_a,
 941     Register  reg_b,
 942     Register  reg_c,
 943     Register  reg_d,
 944     Register  reg_e,
 945     Register  reg_f,
 946     Register  reg_g,
 947     Register  reg_h,
 948     int iter);
 949   void sha256_AVX2_four_rounds_compute_first(int start);
 950   void sha256_AVX2_four_rounds_compute_last(int start);
 951   void sha256_AVX2_one_round_and_sched(
 952         XMMRegister xmm_0,     /* == ymm4 on 0, 1, 2, 3 iterations, then rotate 4 registers left on 4, 8, 12 iterations */
 953         XMMRegister xmm_1,     /* ymm5 */  /* full cycle is 16 iterations */
 954         XMMRegister xmm_2,     /* ymm6 */
 955         XMMRegister xmm_3,     /* ymm7 */
 956         Register    reg_a,      /* == eax on 0 iteration, then rotate 8 register right on each next iteration */
 957         Register    reg_b,      /* ebx */    /* full cycle is 8 iterations */
 958         Register    reg_c,      /* edi */
 959         Register    reg_d,      /* esi */
 960         Register    reg_e,      /* r8d */
 961         Register    reg_f,      /* r9d */
 962         Register    reg_g,      /* r10d */
 963         Register    reg_h,      /* r11d */
 964         int iter);
 965 
 966   void addm(int disp, Register r1, Register r2);
 967   void gfmul(XMMRegister tmp0, XMMRegister t);
 968   void schoolbookAAD(int i, Register subkeyH, XMMRegister data, XMMRegister tmp0,
 969                      XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3);
 970   void generateHtbl_one_block(Register htbl);
 971   void generateHtbl_eight_blocks(Register htbl);
 972  public:
 973   void sha256_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 974                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 975                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 976                    bool multi_block, XMMRegister shuf_mask);
 977   void avx_ghash(Register state, Register htbl, Register data, Register blocks);
 978 #endif
 979 
 980 #ifdef _LP64
 981  private:
 982   void sha512_AVX2_one_round_compute(Register old_h, Register a, Register b, Register c, Register d,
 983                                      Register e, Register f, Register g, Register h, int iteration);
 984 
 985   void sha512_AVX2_one_round_and_schedule(XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 986                                           Register a, Register b, Register c, Register d, Register e, Register f,
 987                                           Register g, Register h, int iteration);
 988 
 989   void addmq(int disp, Register r1, Register r2);
 990  public:
 991   void sha512_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 992                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 993                    Register buf, Register state, Register ofs, Register limit, Register rsp, bool multi_block,
 994                    XMMRegister shuf_mask);
 995 private:
 996   void roundEnc(XMMRegister key, int rnum);
 997   void lastroundEnc(XMMRegister key, int rnum);
 998   void roundDec(XMMRegister key, int rnum);
 999   void lastroundDec(XMMRegister key, int rnum);
1000   void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask);
1001 
1002 public:
1003   void aesecb_encrypt(Register source_addr, Register dest_addr, Register key, Register len);
1004   void aesecb_decrypt(Register source_addr, Register dest_addr, Register key, Register len);
1005   void aesctr_encrypt(Register src_addr, Register dest_addr, Register key, Register counter,
1006                       Register len_reg, Register used, Register used_addr, Register saved_encCounter_start);
1007 
1008 #endif
1009 
1010   void fast_sha1(XMMRegister abcd, XMMRegister e0, XMMRegister e1, XMMRegister msg0,
1011                  XMMRegister msg1, XMMRegister msg2, XMMRegister msg3, XMMRegister shuf_mask,
1012                  Register buf, Register state, Register ofs, Register limit, Register rsp,
1013                  bool multi_block);
1014 
1015 #ifdef _LP64
1016   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
1017                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
1018                    Register buf, Register state, Register ofs, Register limit, Register rsp,
1019                    bool multi_block, XMMRegister shuf_mask);
1020 #else
1021   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
1022                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
1023                    Register buf, Register state, Register ofs, Register limit, Register rsp,
1024                    bool multi_block);
1025 #endif
1026 
1027   void fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1028                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1029                 Register rax, Register rcx, Register rdx, Register tmp);
1030 
1031 #ifdef _LP64
1032   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1033                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1034                 Register rax, Register rcx, Register rdx, Register tmp1, Register tmp2);
1035 
1036   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1037                   XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1038                   Register rax, Register rcx, Register rdx, Register r11);
1039 
1040   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
1041                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
1042                 Register rdx, Register tmp1, Register tmp2, Register tmp3, Register tmp4);
1043 
1044   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1045                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1046                 Register rax, Register rbx, Register rcx, Register rdx, Register tmp1, Register tmp2,
1047                 Register tmp3, Register tmp4);
1048 
1049   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1050                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1051                 Register rax, Register rcx, Register rdx, Register tmp1,
1052                 Register tmp2, Register tmp3, Register tmp4);
1053   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1054                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1055                 Register rax, Register rcx, Register rdx, Register tmp1,
1056                 Register tmp2, Register tmp3, Register tmp4);
1057 #else
1058   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1059                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1060                 Register rax, Register rcx, Register rdx, Register tmp1);
1061 
1062   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1063                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1064                 Register rax, Register rcx, Register rdx, Register tmp);
1065 
1066   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
1067                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
1068                 Register rdx, Register tmp);
1069 
1070   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1071                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1072                 Register rax, Register rbx, Register rdx);
1073 
1074   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1075                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1076                 Register rax, Register rcx, Register rdx, Register tmp);
1077 
1078   void libm_sincos_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1079                         Register edx, Register ebx, Register esi, Register edi,
1080                         Register ebp, Register esp);
1081 
1082   void libm_reduce_pi04l(Register eax, Register ecx, Register edx, Register ebx,
1083                          Register esi, Register edi, Register ebp, Register esp);
1084 
1085   void libm_tancot_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1086                         Register edx, Register ebx, Register esi, Register edi,
1087                         Register ebp, Register esp);
1088 
1089   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1090                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1091                 Register rax, Register rcx, Register rdx, Register tmp);
1092 #endif
1093 
1094 private:
1095 
1096   // these are private because users should be doing movflt/movdbl
1097 
1098   void movss(XMMRegister dst, XMMRegister src) { Assembler::movss(dst, src); }
1099   void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }
1100   void movss(XMMRegister dst, Address src)     { Assembler::movss(dst, src); }
1101   void movss(XMMRegister dst, AddressLiteral src);
1102 
1103   void movlpd(XMMRegister dst, Address src)    {Assembler::movlpd(dst, src); }
1104   void movlpd(XMMRegister dst, AddressLiteral src);
1105 
1106 public:
1107 
1108   void addsd(XMMRegister dst, XMMRegister src)    { Assembler::addsd(dst, src); }
1109   void addsd(XMMRegister dst, Address src)        { Assembler::addsd(dst, src); }
1110   void addsd(XMMRegister dst, AddressLiteral src);
1111 
1112   void addss(XMMRegister dst, XMMRegister src)    { Assembler::addss(dst, src); }
1113   void addss(XMMRegister dst, Address src)        { Assembler::addss(dst, src); }
1114   void addss(XMMRegister dst, AddressLiteral src);
1115 
1116   void addpd(XMMRegister dst, XMMRegister src)    { Assembler::addpd(dst, src); }
1117   void addpd(XMMRegister dst, Address src)        { Assembler::addpd(dst, src); }
1118   void addpd(XMMRegister dst, AddressLiteral src);
1119 
1120   void divsd(XMMRegister dst, XMMRegister src)    { Assembler::divsd(dst, src); }
1121   void divsd(XMMRegister dst, Address src)        { Assembler::divsd(dst, src); }
1122   void divsd(XMMRegister dst, AddressLiteral src);
1123 
1124   void divss(XMMRegister dst, XMMRegister src)    { Assembler::divss(dst, src); }
1125   void divss(XMMRegister dst, Address src)        { Assembler::divss(dst, src); }
1126   void divss(XMMRegister dst, AddressLiteral src);
1127 
1128   // Move Unaligned Double Quadword
1129   void movdqu(Address     dst, XMMRegister src);
1130   void movdqu(XMMRegister dst, Address src);
1131   void movdqu(XMMRegister dst, XMMRegister src);
1132   void movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg = rscratch1);
1133   // AVX Unaligned forms
1134   void vmovdqu(Address     dst, XMMRegister src);
1135   void vmovdqu(XMMRegister dst, Address src);
1136   void vmovdqu(XMMRegister dst, XMMRegister src);
1137   void vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1138   void evmovdquq(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1139   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1140   void evmovdquq(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1141   void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch);
1142 
1143   // Move Aligned Double Quadword
1144   void movdqa(XMMRegister dst, Address src)       { Assembler::movdqa(dst, src); }
1145   void movdqa(XMMRegister dst, XMMRegister src)   { Assembler::movdqa(dst, src); }
1146   void movdqa(XMMRegister dst, AddressLiteral src);
1147 
1148   void movsd(XMMRegister dst, XMMRegister src) { Assembler::movsd(dst, src); }
1149   void movsd(Address dst, XMMRegister src)     { Assembler::movsd(dst, src); }
1150   void movsd(XMMRegister dst, Address src)     { Assembler::movsd(dst, src); }
1151   void movsd(XMMRegister dst, AddressLiteral src);
1152 
1153   void mulpd(XMMRegister dst, XMMRegister src)    { Assembler::mulpd(dst, src); }
1154   void mulpd(XMMRegister dst, Address src)        { Assembler::mulpd(dst, src); }
1155   void mulpd(XMMRegister dst, AddressLiteral src);
1156 
1157   void mulsd(XMMRegister dst, XMMRegister src)    { Assembler::mulsd(dst, src); }
1158   void mulsd(XMMRegister dst, Address src)        { Assembler::mulsd(dst, src); }
1159   void mulsd(XMMRegister dst, AddressLiteral src);
1160 
1161   void mulss(XMMRegister dst, XMMRegister src)    { Assembler::mulss(dst, src); }
1162   void mulss(XMMRegister dst, Address src)        { Assembler::mulss(dst, src); }
1163   void mulss(XMMRegister dst, AddressLiteral src);
1164 
1165   // Carry-Less Multiplication Quadword
1166   void pclmulldq(XMMRegister dst, XMMRegister src) {
1167     // 0x00 - multiply lower 64 bits [0:63]
1168     Assembler::pclmulqdq(dst, src, 0x00);
1169   }
1170   void pclmulhdq(XMMRegister dst, XMMRegister src) {
1171     // 0x11 - multiply upper 64 bits [64:127]
1172     Assembler::pclmulqdq(dst, src, 0x11);
1173   }
1174 
1175   void pcmpeqb(XMMRegister dst, XMMRegister src);
1176   void pcmpeqw(XMMRegister dst, XMMRegister src);
1177 
1178   void pcmpestri(XMMRegister dst, Address src, int imm8);
1179   void pcmpestri(XMMRegister dst, XMMRegister src, int imm8);
1180 
1181   void pmovzxbw(XMMRegister dst, XMMRegister src);
1182   void pmovzxbw(XMMRegister dst, Address src);
1183 
1184   void pmovmskb(Register dst, XMMRegister src);
1185 
1186   void ptest(XMMRegister dst, XMMRegister src);
1187 
1188   void sqrtsd(XMMRegister dst, XMMRegister src)    { Assembler::sqrtsd(dst, src); }
1189   void sqrtsd(XMMRegister dst, Address src)        { Assembler::sqrtsd(dst, src); }
1190   void sqrtsd(XMMRegister dst, AddressLiteral src);
1191 
1192   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode)    { Assembler::roundsd(dst, src, rmode); }
1193   void roundsd(XMMRegister dst, Address src, int32_t rmode)        { Assembler::roundsd(dst, src, rmode); }
1194   void roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg);
1195 
1196   void sqrtss(XMMRegister dst, XMMRegister src)    { Assembler::sqrtss(dst, src); }
1197   void sqrtss(XMMRegister dst, Address src)        { Assembler::sqrtss(dst, src); }
1198   void sqrtss(XMMRegister dst, AddressLiteral src);
1199 
1200   void subsd(XMMRegister dst, XMMRegister src)    { Assembler::subsd(dst, src); }
1201   void subsd(XMMRegister dst, Address src)        { Assembler::subsd(dst, src); }
1202   void subsd(XMMRegister dst, AddressLiteral src);
1203 
1204   void subss(XMMRegister dst, XMMRegister src)    { Assembler::subss(dst, src); }
1205   void subss(XMMRegister dst, Address src)        { Assembler::subss(dst, src); }
1206   void subss(XMMRegister dst, AddressLiteral src);
1207 
1208   void ucomiss(XMMRegister dst, XMMRegister src) { Assembler::ucomiss(dst, src); }
1209   void ucomiss(XMMRegister dst, Address src)     { Assembler::ucomiss(dst, src); }
1210   void ucomiss(XMMRegister dst, AddressLiteral src);
1211 
1212   void ucomisd(XMMRegister dst, XMMRegister src) { Assembler::ucomisd(dst, src); }
1213   void ucomisd(XMMRegister dst, Address src)     { Assembler::ucomisd(dst, src); }
1214   void ucomisd(XMMRegister dst, AddressLiteral src);
1215 
1216   // Bitwise Logical XOR of Packed Double-Precision Floating-Point Values
1217   void xorpd(XMMRegister dst, XMMRegister src);
1218   void xorpd(XMMRegister dst, Address src)     { Assembler::xorpd(dst, src); }
1219   void xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1220 
1221   // Bitwise Logical XOR of Packed Single-Precision Floating-Point Values
1222   void xorps(XMMRegister dst, XMMRegister src);
1223   void xorps(XMMRegister dst, Address src)     { Assembler::xorps(dst, src); }
1224   void xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1225 
1226   // Shuffle Bytes
1227   void pshufb(XMMRegister dst, XMMRegister src) { Assembler::pshufb(dst, src); }
1228   void pshufb(XMMRegister dst, Address src)     { Assembler::pshufb(dst, src); }
1229   void pshufb(XMMRegister dst, AddressLiteral src);
1230   // AVX 3-operands instructions
1231 
1232   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddsd(dst, nds, src); }
1233   void vaddsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddsd(dst, nds, src); }
1234   void vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1235 
1236   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddss(dst, nds, src); }
1237   void vaddss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddss(dst, nds, src); }
1238   void vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1239 
1240   void vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1241   void vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1242 
1243   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1244   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1245 
1246   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1247   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1248 
1249   void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }
1250   void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }
1251   void vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);
1252 
1253   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1254   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1255   void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1256 
1257   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
1258   void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }
1259 
1260   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1261 
1262   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1263 
1264   void vpmovzxbw(XMMRegister dst, Address src, int vector_len);
1265   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpmovzxbw(dst, src, vector_len); }
1266 
1267   void vpmovmskb(Register dst, XMMRegister src);
1268 
1269   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1270   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1271 
1272   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1273   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1274 
1275   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1276   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1277 
1278   void vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1279   void vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1280 
1281   void evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1282   void evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1283 
1284   void vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1285   void vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1286 
1287   void vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1288   void vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1289 
1290   void vptest(XMMRegister dst, XMMRegister src);
1291 
1292   void punpcklbw(XMMRegister dst, XMMRegister src);
1293   void punpcklbw(XMMRegister dst, Address src) { Assembler::punpcklbw(dst, src); }
1294 
1295   void pshufd(XMMRegister dst, Address src, int mode);
1296   void pshufd(XMMRegister dst, XMMRegister src, int mode) { Assembler::pshufd(dst, src, mode); }
1297 
1298   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1299   void pshuflw(XMMRegister dst, Address src, int mode) { Assembler::pshuflw(dst, src, mode); }
1300 
1301   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }
1302   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandpd(dst, nds, src, vector_len); }
1303   void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1304 
1305   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }
1306   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandps(dst, nds, src, vector_len); }
1307   void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1308 
1309   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivsd(dst, nds, src); }
1310   void vdivsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivsd(dst, nds, src); }
1311   void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1312 
1313   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivss(dst, nds, src); }
1314   void vdivss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivss(dst, nds, src); }
1315   void vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1316 
1317   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulsd(dst, nds, src); }
1318   void vmulsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulsd(dst, nds, src); }
1319   void vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1320 
1321   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulss(dst, nds, src); }
1322   void vmulss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulss(dst, nds, src); }
1323   void vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1324 
1325   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubsd(dst, nds, src); }
1326   void vsubsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubsd(dst, nds, src); }
1327   void vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1328 
1329   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubss(dst, nds, src); }
1330   void vsubss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubss(dst, nds, src); }
1331   void vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1332 
1333   void vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1334   void vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1335 
1336   // AVX Vector instructions
1337 
1338   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1339   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1340   void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1341 
1342   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1343   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1344   void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1345 
1346   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1347     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1348       Assembler::vpxor(dst, nds, src, vector_len);
1349     else
1350       Assembler::vxorpd(dst, nds, src, vector_len);
1351   }
1352   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
1353     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1354       Assembler::vpxor(dst, nds, src, vector_len);
1355     else
1356       Assembler::vxorpd(dst, nds, src, vector_len);
1357   }
1358   void vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1359 
1360   // Simple version for AVX2 256bit vectors
1361   void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }
1362   void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }
1363 
1364   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
1365     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1366       Assembler::vinserti32x4(dst, dst, src, imm8);
1367     } else if (UseAVX &gt; 1) {
1368       // vinserti128 is available only in AVX2
1369       Assembler::vinserti128(dst, nds, src, imm8);
1370     } else {
1371       Assembler::vinsertf128(dst, nds, src, imm8);
1372     }
1373   }
1374 
1375   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
1376     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1377       Assembler::vinserti32x4(dst, dst, src, imm8);
1378     } else if (UseAVX &gt; 1) {
1379       // vinserti128 is available only in AVX2
1380       Assembler::vinserti128(dst, nds, src, imm8);
1381     } else {
1382       Assembler::vinsertf128(dst, nds, src, imm8);
1383     }
1384   }
1385 
1386   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
1387     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1388       Assembler::vextracti32x4(dst, src, imm8);
1389     } else if (UseAVX &gt; 1) {
1390       // vextracti128 is available only in AVX2
1391       Assembler::vextracti128(dst, src, imm8);
1392     } else {
1393       Assembler::vextractf128(dst, src, imm8);
1394     }
1395   }
1396 
1397   void vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
1398     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1399       Assembler::vextracti32x4(dst, src, imm8);
1400     } else if (UseAVX &gt; 1) {
1401       // vextracti128 is available only in AVX2
1402       Assembler::vextracti128(dst, src, imm8);
1403     } else {
1404       Assembler::vextractf128(dst, src, imm8);
1405     }
1406   }
1407 
1408   // 128bit copy to/from high 128 bits of 256bit (YMM) vector registers
1409   void vinserti128_high(XMMRegister dst, XMMRegister src) {
1410     vinserti128(dst, dst, src, 1);
1411   }
1412   void vinserti128_high(XMMRegister dst, Address src) {
1413     vinserti128(dst, dst, src, 1);
1414   }
1415   void vextracti128_high(XMMRegister dst, XMMRegister src) {
1416     vextracti128(dst, src, 1);
1417   }
1418   void vextracti128_high(Address dst, XMMRegister src) {
1419     vextracti128(dst, src, 1);
1420   }
1421 
1422   void vinsertf128_high(XMMRegister dst, XMMRegister src) {
1423     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1424       Assembler::vinsertf32x4(dst, dst, src, 1);
1425     } else {
1426       Assembler::vinsertf128(dst, dst, src, 1);
1427     }
1428   }
1429 
1430   void vinsertf128_high(XMMRegister dst, Address src) {
1431     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1432       Assembler::vinsertf32x4(dst, dst, src, 1);
1433     } else {
1434       Assembler::vinsertf128(dst, dst, src, 1);
1435     }
1436   }
1437 
1438   void vextractf128_high(XMMRegister dst, XMMRegister src) {
1439     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1440       Assembler::vextractf32x4(dst, src, 1);
1441     } else {
1442       Assembler::vextractf128(dst, src, 1);
1443     }
1444   }
1445 
1446   void vextractf128_high(Address dst, XMMRegister src) {
1447     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1448       Assembler::vextractf32x4(dst, src, 1);
1449     } else {
1450       Assembler::vextractf128(dst, src, 1);
1451     }
1452   }
1453 
1454   // 256bit copy to/from high 256 bits of 512bit (ZMM) vector registers
1455   void vinserti64x4_high(XMMRegister dst, XMMRegister src) {
1456     Assembler::vinserti64x4(dst, dst, src, 1);
1457   }
1458   void vinsertf64x4_high(XMMRegister dst, XMMRegister src) {
1459     Assembler::vinsertf64x4(dst, dst, src, 1);
1460   }
1461   void vextracti64x4_high(XMMRegister dst, XMMRegister src) {
1462     Assembler::vextracti64x4(dst, src, 1);
1463   }
1464   void vextractf64x4_high(XMMRegister dst, XMMRegister src) {
1465     Assembler::vextractf64x4(dst, src, 1);
1466   }
1467   void vextractf64x4_high(Address dst, XMMRegister src) {
1468     Assembler::vextractf64x4(dst, src, 1);
1469   }
1470   void vinsertf64x4_high(XMMRegister dst, Address src) {
1471     Assembler::vinsertf64x4(dst, dst, src, 1);
1472   }
1473 
1474   // 128bit copy to/from low 128 bits of 256bit (YMM) vector registers
1475   void vinserti128_low(XMMRegister dst, XMMRegister src) {
1476     vinserti128(dst, dst, src, 0);
1477   }
1478   void vinserti128_low(XMMRegister dst, Address src) {
1479     vinserti128(dst, dst, src, 0);
1480   }
1481   void vextracti128_low(XMMRegister dst, XMMRegister src) {
1482     vextracti128(dst, src, 0);
1483   }
1484   void vextracti128_low(Address dst, XMMRegister src) {
1485     vextracti128(dst, src, 0);
1486   }
1487 
1488   void vinsertf128_low(XMMRegister dst, XMMRegister src) {
1489     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1490       Assembler::vinsertf32x4(dst, dst, src, 0);
1491     } else {
1492       Assembler::vinsertf128(dst, dst, src, 0);
1493     }
1494   }
1495 
1496   void vinsertf128_low(XMMRegister dst, Address src) {
1497     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1498       Assembler::vinsertf32x4(dst, dst, src, 0);
1499     } else {
1500       Assembler::vinsertf128(dst, dst, src, 0);
1501     }
1502   }
1503 
1504   void vextractf128_low(XMMRegister dst, XMMRegister src) {
1505     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1506       Assembler::vextractf32x4(dst, src, 0);
1507     } else {
1508       Assembler::vextractf128(dst, src, 0);
1509     }
1510   }
1511 
1512   void vextractf128_low(Address dst, XMMRegister src) {
1513     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1514       Assembler::vextractf32x4(dst, src, 0);
1515     } else {
1516       Assembler::vextractf128(dst, src, 0);
1517     }
1518   }
1519 
1520   // 256bit copy to/from low 256 bits of 512bit (ZMM) vector registers
1521   void vinserti64x4_low(XMMRegister dst, XMMRegister src) {
1522     Assembler::vinserti64x4(dst, dst, src, 0);
1523   }
1524   void vinsertf64x4_low(XMMRegister dst, XMMRegister src) {
1525     Assembler::vinsertf64x4(dst, dst, src, 0);
1526   }
1527   void vextracti64x4_low(XMMRegister dst, XMMRegister src) {
1528     Assembler::vextracti64x4(dst, src, 0);
1529   }
1530   void vextractf64x4_low(XMMRegister dst, XMMRegister src) {
1531     Assembler::vextractf64x4(dst, src, 0);
1532   }
1533   void vextractf64x4_low(Address dst, XMMRegister src) {
1534     Assembler::vextractf64x4(dst, src, 0);
1535   }
1536   void vinsertf64x4_low(XMMRegister dst, Address src) {
1537     Assembler::vinsertf64x4(dst, dst, src, 0);
1538   }
1539 
1540   // Carry-Less Multiplication Quadword
1541   void vpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1542     // 0x00 - multiply lower 64 bits [0:63]
1543     Assembler::vpclmulqdq(dst, nds, src, 0x00);
1544   }
1545   void vpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1546     // 0x11 - multiply upper 64 bits [64:127]
1547     Assembler::vpclmulqdq(dst, nds, src, 0x11);
1548   }
1549   void vpclmullqhqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1550     // 0x10 - multiply nds[0:63] and src[64:127]
1551     Assembler::vpclmulqdq(dst, nds, src, 0x10);
1552   }
1553   void vpclmulhqlqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1554     //0x01 - multiply nds[64:127] and src[0:63]
1555     Assembler::vpclmulqdq(dst, nds, src, 0x01);
1556   }
1557 
1558   void evpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1559     // 0x00 - multiply lower 64 bits [0:63]
1560     Assembler::evpclmulqdq(dst, nds, src, 0x00, vector_len);
1561   }
1562   void evpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1563     // 0x11 - multiply upper 64 bits [64:127]
1564     Assembler::evpclmulqdq(dst, nds, src, 0x11, vector_len);
1565   }
1566 
1567   // Data
1568 
1569   void cmov32( Condition cc, Register dst, Address  src);
1570   void cmov32( Condition cc, Register dst, Register src);
1571 
1572   void cmov(   Condition cc, Register dst, Register src) { cmovptr(cc, dst, src); }
1573 
1574   void cmovptr(Condition cc, Register dst, Address  src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1575   void cmovptr(Condition cc, Register dst, Register src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1576 
1577   void movoop(Register dst, jobject obj);
1578   void movoop(Address dst, jobject obj);
1579 
1580   void mov_metadata(Register dst, Metadata* obj);
1581   void mov_metadata(Address dst, Metadata* obj);
1582 
1583   void movptr(ArrayAddress dst, Register src);
1584   // can this do an lea?
1585   void movptr(Register dst, ArrayAddress src);
1586 
1587   void movptr(Register dst, Address src);
1588 
1589 #ifdef _LP64
1590   void movptr(Register dst, AddressLiteral src, Register scratch=rscratch1);
1591 #else
1592   void movptr(Register dst, AddressLiteral src, Register scratch=noreg); // Scratch reg is ignored in 32-bit
1593 #endif
1594 
1595   void movptr(Register dst, intptr_t src);
1596   void movptr(Register dst, Register src);
1597   void movptr(Address dst, intptr_t src);
1598 
1599   void movptr(Address dst, Register src);
1600 
1601   void movptr(Register dst, RegisterOrConstant src) {
1602     if (src.is_constant()) movptr(dst, src.as_constant());
1603     else                   movptr(dst, src.as_register());
1604   }
1605 
1606 #ifdef _LP64
1607   // Generally the next two are only used for moving NULL
1608   // Although there are situations in initializing the mark word where
1609   // they could be used. They are dangerous.
1610 
1611   // They only exist on LP64 so that int32_t and intptr_t are not the same
1612   // and we have ambiguous declarations.
1613 
1614   void movptr(Address dst, int32_t imm32);
1615   void movptr(Register dst, int32_t imm32);
1616 #endif // _LP64
1617 
1618   // to avoid hiding movl
1619   void mov32(AddressLiteral dst, Register src);
1620   void mov32(Register dst, AddressLiteral src);
1621 
1622   // to avoid hiding movb
1623   void movbyte(ArrayAddress dst, int src);
1624 
1625   // Import other mov() methods from the parent class or else
1626   // they will be hidden by the following overriding declaration.
1627   using Assembler::movdl;
1628   using Assembler::movq;
1629   void movdl(XMMRegister dst, AddressLiteral src);
1630   void movq(XMMRegister dst, AddressLiteral src);
1631 
1632   // Can push value or effective address
1633   void pushptr(AddressLiteral src);
1634 
1635   void pushptr(Address src) { LP64_ONLY(pushq(src)) NOT_LP64(pushl(src)); }
1636   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1637 
1638   void pushoop(jobject obj);
1639   void pushklass(Metadata* obj);
1640 
1641   // sign extend as need a l to ptr sized element
1642   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1643   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1644 
1645 
1646  public:
1647   // C2 compiled method&#39;s prolog code.
1648   void verified_entry(Compile* C, int sp_inc = 0);
1649 
1650   enum RegState {
1651     reg_readonly,
1652     reg_writable,
1653     reg_written
1654   };
1655 
1656   int store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter = true);
1657 
1658   // Unpack all value type arguments passed as oops
1659   void unpack_value_args(Compile* C, bool receiver_only);
1660   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1661   bool unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
1662                            RegState reg_state[], int ret_off, int extra_stack_offset);
1663   bool pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
1664                          VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
1665                          int ret_off, int extra_stack_offset);
1666   void remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset);
1667 
1668   void shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,
1669                           BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
1670                           int args_passed, int args_on_stack, VMRegPair* regs,
1671                           int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc);
1672   bool shuffle_value_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
1673                                 VMRegPair* regs_from, int from_index, int regs_from_count,
1674                                 RegState* reg_state, int sp_inc, int extra_stack_offset);
1675   VMReg spill_reg_for(VMReg reg);
1676 
1677   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1678   // if &#39;is_large&#39; is set, do not try to produce short loop
1679   void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only);
1680 
1681   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
1682   void xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp);
1683 
1684   // Fill primitive arrays
1685   void generate_fill(BasicType t, bool aligned,
1686                      Register to, Register value, Register count,
1687                      Register rtmp, XMMRegister xtmp);
1688 
1689   void encode_iso_array(Register src, Register dst, Register len,
1690                         XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1691                         XMMRegister tmp4, Register tmp5, Register result);
1692 
1693 #ifdef _LP64
1694   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2);
1695   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1696                              Register y, Register y_idx, Register z,
1697                              Register carry, Register product,
1698                              Register idx, Register kdx);
1699   void multiply_add_128_x_128(Register x_xstart, Register y, Register z,
1700                               Register yz_idx, Register idx,
1701                               Register carry, Register product, int offset);
1702   void multiply_128_x_128_bmi2_loop(Register y, Register z,
1703                                     Register carry, Register carry2,
1704                                     Register idx, Register jdx,
1705                                     Register yz_idx1, Register yz_idx2,
1706                                     Register tmp, Register tmp3, Register tmp4);
1707   void multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
1708                                Register yz_idx, Register idx, Register jdx,
1709                                Register carry, Register product,
1710                                Register carry2);
1711   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
1712                        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5);
1713   void square_rshift(Register x, Register len, Register z, Register tmp1, Register tmp3,
1714                      Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1715   void multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry,
1716                             Register tmp2);
1717   void multiply_add_64(Register sum, Register op1, Register op2, Register carry,
1718                        Register rdxReg, Register raxReg);
1719   void add_one_64(Register z, Register zlen, Register carry, Register tmp1);
1720   void lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1721                        Register tmp3, Register tmp4);
1722   void square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1723                      Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1724 
1725   void mul_add_128_x_32_loop(Register out, Register in, Register offset, Register len, Register tmp1,
1726                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1727                Register raxReg);
1728   void mul_add(Register out, Register in, Register offset, Register len, Register k, Register tmp1,
1729                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1730                Register raxReg);
1731   void vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
1732                            Register result, Register tmp1, Register tmp2,
1733                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3);
1734 #endif
1735 
1736   // CRC32 code for java.util.zip.CRC32::updateBytes() intrinsic.
1737   void update_byte_crc32(Register crc, Register val, Register table);
1738   void kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp);
1739   // CRC32C code for java.util.zip.CRC32C::updateBytes() intrinsic
1740   // Note on a naming convention:
1741   // Prefix w = register only used on a Westmere+ architecture
1742   // Prefix n = register only used on a Nehalem architecture
1743 #ifdef _LP64
1744   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1745                        Register tmp1, Register tmp2, Register tmp3);
1746 #else
1747   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1748                        Register tmp1, Register tmp2, Register tmp3,
1749                        XMMRegister xtmp1, XMMRegister xtmp2);
1750 #endif
1751   void crc32c_pclmulqdq(XMMRegister w_xtmp1,
1752                         Register in_out,
1753                         uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
1754                         XMMRegister w_xtmp2,
1755                         Register tmp1,
1756                         Register n_tmp2, Register n_tmp3);
1757   void crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
1758                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1759                        Register tmp1, Register tmp2,
1760                        Register n_tmp3);
1761   void crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
1762                          Register in_out1, Register in_out2, Register in_out3,
1763                          Register tmp1, Register tmp2, Register tmp3,
1764                          XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1765                          Register tmp4, Register tmp5,
1766                          Register n_tmp6);
1767   void crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
1768                             Register tmp1, Register tmp2, Register tmp3,
1769                             Register tmp4, Register tmp5, Register tmp6,
1770                             XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1771                             bool is_pclmulqdq_supported);
1772   // Fold 128-bit data chunk
1773   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1774   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf);
1775   // Fold 8-bit data
1776   void fold_8bit_crc32(Register crc, Register table, Register tmp);
1777   void fold_8bit_crc32(XMMRegister crc, Register table, XMMRegister xtmp, Register tmp);
1778   void fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1779 
1780   // Compress char[] array to byte[].
1781   void char_array_compress(Register src, Register dst, Register len,
1782                            XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1783                            XMMRegister tmp4, Register tmp5, Register result);
1784 
1785   // Inflate byte[] array to char[].
1786   void byte_array_inflate(Register src, Register dst, Register len,
1787                           XMMRegister tmp1, Register tmp2);
1788 
1789 #ifdef _LP64
1790   void convert_f2i(Register dst, XMMRegister src);
1791   void convert_d2i(Register dst, XMMRegister src);
1792   void convert_f2l(Register dst, XMMRegister src);
1793   void convert_d2l(Register dst, XMMRegister src);
1794 
1795   void cache_wb(Address line);
1796   void cache_wbsync(bool is_pre);
1797 #endif // _LP64
1798 
1799   void vallones(XMMRegister dst, int vector_len);
1800 
1801   #include &quot;asm/macroAssembler_common.hpp&quot;
1802 };
1803 
1804 /**
1805  * class SkipIfEqual:
1806  *
1807  * Instantiating this class will result in assembly code being output that will
1808  * jump around any code emitted between the creation of the instance and it&#39;s
1809  * automatic destruction at the end of a scope block, depending on the value of
1810  * the flag passed to the constructor, which will be checked at run-time.
1811  */
1812 class SkipIfEqual {
1813  private:
1814   MacroAssembler* _masm;
1815   Label _label;
1816 
1817  public:
1818    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1819    ~SkipIfEqual();
1820 };
1821 
1822 #endif // CPU_X86_MACROASSEMBLER_X86_HPP
    </pre>
  </body>
</html>
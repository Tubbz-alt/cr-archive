<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_64.ad.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_32.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 
<span class="line-removed">  317 // Indicate if the safepoint node needs the polling page as an input.</span>
<span class="line-removed">  318 // Since x86 does have absolute addressing, it doesn&#39;t.</span>
<span class="line-removed">  319 bool SafePointNode::needs_polling_address_input() {</span>
<span class="line-removed">  320   return SafepointMechanism::uses_thread_local_poll();</span>
<span class="line-removed">  321 }</span>
<span class="line-removed">  322 </span>
  323 //
  324 // Compute padding required for nodes which need alignment
  325 //
  326 
  327 // The address of the call instruction needs to be 4-byte aligned to
  328 // ensure that it does not span a cache line so that it can be patched.
  329 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  330   current_offset += pre_call_resets_size();  // skip fldcw, if any
  331   current_offset += 1;      // skip call opcode byte
  332   return align_up(current_offset, alignment_required()) - current_offset;
  333 }
  334 
  335 // The address of the call instruction needs to be 4-byte aligned to
  336 // ensure that it does not span a cache line so that it can be patched.
  337 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  338   current_offset += pre_call_resets_size();  // skip fldcw, if any
  339   current_offset += 5;      // skip MOV instruction
  340   current_offset += 1;      // skip call opcode byte
  341   return align_up(current_offset, alignment_required()) - current_offset;
  342 }
</pre>
<hr />
<pre>
  686 
  687   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  688 
  689   if (framesize &gt;= 128) {
  690     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  691     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  692     emit_d32(cbuf, framesize);
  693   } else if (framesize) {
  694     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  695     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  696     emit_d8(cbuf, framesize);
  697   }
  698 
  699   emit_opcode(cbuf, 0x58 | EBP_enc);
  700 
  701   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  702     __ reserved_stack_check();
  703   }
  704 
  705   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
<span class="line-modified">  706     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">  707       Register pollReg = as_Register(EBX_enc);</span>
<span class="line-modified">  708       MacroAssembler masm(&amp;cbuf);</span>
<span class="line-modified">  709       masm.get_thread(pollReg);</span>
<span class="line-modified">  710       masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));</span>
<span class="line-modified">  711       masm.relocate(relocInfo::poll_return_type);</span>
<span class="line-removed">  712       masm.testl(rax, Address(pollReg, 0));</span>
<span class="line-removed">  713     } else {</span>
<span class="line-removed">  714       cbuf.relocate(cbuf.insts_end(), relocInfo::poll_return_type, 0);</span>
<span class="line-removed">  715       emit_opcode(cbuf,0x85);</span>
<span class="line-removed">  716       emit_rm(cbuf, 0x0, EAX_enc, 0x5); // EAX</span>
<span class="line-removed">  717       emit_d32(cbuf, (intptr_t)os::get_polling_page());</span>
<span class="line-removed">  718     }</span>
  719   }
  720 }
  721 
  722 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  723   return MachNode::size(ra_); // too many variables; just compute it
  724                               // the hard way
  725 }
  726 
  727 int MachEpilogNode::reloc() const {
  728   return 0; // a large enough number
  729 }
  730 
  731 const Pipeline * MachEpilogNode::pipeline() const {
  732   return MachNode::pipeline_class();
  733 }
  734 
<span class="line-removed">  735 int MachEpilogNode::safepoint_offset() const { return 0; }</span>
<span class="line-removed">  736 </span>
  737 //=============================================================================
  738 
  739 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  740 static enum RC rc_class( OptoReg::Name reg ) {
  741 
  742   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  743   if (OptoReg::is_stack(reg)) return rc_stack;
  744 
  745   VMReg r = OptoReg::as_VMReg(reg);
  746   if (r-&gt;is_Register()) return rc_int;
  747   if (r-&gt;is_FloatRegister()) {
  748     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  749     return rc_float;
  750   }
  751   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  752   return rc_xmm;
  753 }
  754 
  755 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  756                         int opcode, const char *op_str, int size, outputStream* st ) {
</pre>
<hr />
<pre>
 3128     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3129   %}
 3130 
 3131   // Volatile Store Long.  Must be atomic, so move it into
 3132   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3133   // target address before the store (for null-ptr checks)
 3134   // so the memory operand is used twice in the encoding.
 3135   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3136     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3137     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3138     emit_opcode(cbuf,0xDF);
 3139     int rm_byte_opcode = 0x07;
 3140     int base     = $mem$$base;
 3141     int index    = $mem$$index;
 3142     int scale    = $mem$$scale;
 3143     int displace = $mem$$disp;
 3144     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3145     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3146   %}
 3147 
<span class="line-removed"> 3148   // Safepoint Poll.  This polls the safepoint page, and causes an</span>
<span class="line-removed"> 3149   // exception if it is not readable. Unfortunately, it kills the condition code</span>
<span class="line-removed"> 3150   // in the process</span>
<span class="line-removed"> 3151   // We current use TESTL [spp],EDI</span>
<span class="line-removed"> 3152   // A better choice might be TESTB [spp + pagesize() - CacheLineSize()],0</span>
<span class="line-removed"> 3153 </span>
<span class="line-removed"> 3154   enc_class Safepoint_Poll() %{</span>
<span class="line-removed"> 3155     cbuf.relocate(cbuf.insts_mark(), relocInfo::poll_type, 0);</span>
<span class="line-removed"> 3156     emit_opcode(cbuf,0x85);</span>
<span class="line-removed"> 3157     emit_rm (cbuf, 0x0, 0x7, 0x5);</span>
<span class="line-removed"> 3158     emit_d32(cbuf, (intptr_t)os::get_polling_page());</span>
<span class="line-removed"> 3159   %}</span>
 3160 %}
 3161 
 3162 
 3163 //----------FRAME--------------------------------------------------------------
 3164 // Definition of frame structure and management information.
 3165 //
 3166 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3167 //                             |   (to get allocators register number
 3168 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3169 //  r   CALLER     |        |
 3170 //  o     |        +--------+      pad to even-align allocators stack-slot
 3171 //  w     V        |  pad0  |        numbers; owned by CALLER
 3172 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3173 //  h     ^        |   in   |  5
 3174 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3175 //  |     |        |        |  3
 3176 //  |     |        +--------+
 3177 //  V     |        | old out|      Empty on Intel, window on Sparc
 3178 //        |    old |preserve|      Must be even aligned.
 3179 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
</pre>
<hr />
<pre>
 3376 %}
 3377 
 3378 // Valid scale values for addressing modes
 3379 operand immI2() %{
 3380   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3381   match(ConI);
 3382 
 3383   format %{ %}
 3384   interface(CONST_INTER);
 3385 %}
 3386 
 3387 operand immI8() %{
 3388   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3389   match(ConI);
 3390 
 3391   op_cost(5);
 3392   format %{ %}
 3393   interface(CONST_INTER);
 3394 %}
 3395 









 3396 operand immI16() %{
 3397   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3398   match(ConI);
 3399 
 3400   op_cost(10);
 3401   format %{ %}
 3402   interface(CONST_INTER);
 3403 %}
 3404 
 3405 // Int Immediate non-negative
 3406 operand immU31()
 3407 %{
 3408   predicate(n-&gt;get_int() &gt;= 0);
 3409   match(ConI);
 3410 
 3411   op_cost(0);
 3412   format %{ %}
 3413   interface(CONST_INTER);
 3414 %}
 3415 
</pre>
<hr />
<pre>
13421                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13422   %}
13423   ins_pipe(pipe_slow);
13424 %}
13425 
13426 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13427   match(Set cr (FastUnlock object box));
13428   effect(TEMP tmp, USE_KILL box);
13429   ins_cost(300);
13430   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13431   ins_encode %{
13432     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13433   %}
13434   ins_pipe(pipe_slow);
13435 %}
13436 
13437 
13438 
13439 // ============================================================================
13440 // Safepoint Instruction
<span class="line-removed">13441 instruct safePoint_poll(eFlagsReg cr) %{</span>
<span class="line-removed">13442   predicate(SafepointMechanism::uses_global_page_poll());</span>
<span class="line-removed">13443   match(SafePoint);</span>
<span class="line-removed">13444   effect(KILL cr);</span>
<span class="line-removed">13445 </span>
<span class="line-removed">13446   // TODO-FIXME: we currently poll at offset 0 of the safepoint polling page.</span>
<span class="line-removed">13447   // On SPARC that might be acceptable as we can generate the address with</span>
<span class="line-removed">13448   // just a sethi, saving an or.  By polling at offset 0 we can end up</span>
<span class="line-removed">13449   // putting additional pressure on the index-0 in the D$.  Because of</span>
<span class="line-removed">13450   // alignment (just like the situation at hand) the lower indices tend</span>
<span class="line-removed">13451   // to see more traffic.  It&#39;d be better to change the polling address</span>
<span class="line-removed">13452   // to offset 0 of the last $line in the polling page.</span>
<span class="line-removed">13453 </span>
<span class="line-removed">13454   format %{ &quot;TSTL   #polladdr,EAX\t! Safepoint: poll for GC&quot; %}</span>
<span class="line-removed">13455   ins_cost(125);</span>
<span class="line-removed">13456   size(6) ;</span>
<span class="line-removed">13457   ins_encode( Safepoint_Poll() );</span>
<span class="line-removed">13458   ins_pipe( ialu_reg_mem );</span>
<span class="line-removed">13459 %}</span>
<span class="line-removed">13460 </span>
<span class="line-removed">13461 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{</span>
13462   predicate(SafepointMechanism::uses_thread_local_poll());
13463   match(SafePoint poll);
13464   effect(KILL cr, USE poll);
13465 
13466   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13467   ins_cost(125);
13468   // EBP would need size(3)
13469   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13470   ins_encode %{
13471     __ relocate(relocInfo::poll_type);
13472     address pre_pc = __ pc();
13473     __ testl(rax, Address($poll$$Register, 0));
13474     address post_pc = __ pc();
13475     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13476   %}
13477   ins_pipe(ialu_reg_mem);
13478 %}
13479 
13480 
13481 // ============================================================================
</pre>
</td>
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 






  317 //
  318 // Compute padding required for nodes which need alignment
  319 //
  320 
  321 // The address of the call instruction needs to be 4-byte aligned to
  322 // ensure that it does not span a cache line so that it can be patched.
  323 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  324   current_offset += pre_call_resets_size();  // skip fldcw, if any
  325   current_offset += 1;      // skip call opcode byte
  326   return align_up(current_offset, alignment_required()) - current_offset;
  327 }
  328 
  329 // The address of the call instruction needs to be 4-byte aligned to
  330 // ensure that it does not span a cache line so that it can be patched.
  331 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  332   current_offset += pre_call_resets_size();  // skip fldcw, if any
  333   current_offset += 5;      // skip MOV instruction
  334   current_offset += 1;      // skip call opcode byte
  335   return align_up(current_offset, alignment_required()) - current_offset;
  336 }
</pre>
<hr />
<pre>
  680 
  681   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  682 
  683   if (framesize &gt;= 128) {
  684     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  685     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  686     emit_d32(cbuf, framesize);
  687   } else if (framesize) {
  688     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  689     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  690     emit_d8(cbuf, framesize);
  691   }
  692 
  693   emit_opcode(cbuf, 0x58 | EBP_enc);
  694 
  695   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  696     __ reserved_stack_check();
  697   }
  698 
  699   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
<span class="line-modified">  700     Register pollReg = as_Register(EBX_enc);</span>
<span class="line-modified">  701     MacroAssembler masm(&amp;cbuf);</span>
<span class="line-modified">  702     masm.get_thread(pollReg);</span>
<span class="line-modified">  703     masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));</span>
<span class="line-modified">  704     masm.relocate(relocInfo::poll_return_type);</span>
<span class="line-modified">  705     masm.testl(rax, Address(pollReg, 0));</span>







  706   }
  707 }
  708 
  709 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  710   return MachNode::size(ra_); // too many variables; just compute it
  711                               // the hard way
  712 }
  713 
  714 int MachEpilogNode::reloc() const {
  715   return 0; // a large enough number
  716 }
  717 
  718 const Pipeline * MachEpilogNode::pipeline() const {
  719   return MachNode::pipeline_class();
  720 }
  721 


  722 //=============================================================================
  723 
  724 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  725 static enum RC rc_class( OptoReg::Name reg ) {
  726 
  727   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  728   if (OptoReg::is_stack(reg)) return rc_stack;
  729 
  730   VMReg r = OptoReg::as_VMReg(reg);
  731   if (r-&gt;is_Register()) return rc_int;
  732   if (r-&gt;is_FloatRegister()) {
  733     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  734     return rc_float;
  735   }
  736   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  737   return rc_xmm;
  738 }
  739 
  740 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  741                         int opcode, const char *op_str, int size, outputStream* st ) {
</pre>
<hr />
<pre>
 3113     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3114   %}
 3115 
 3116   // Volatile Store Long.  Must be atomic, so move it into
 3117   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3118   // target address before the store (for null-ptr checks)
 3119   // so the memory operand is used twice in the encoding.
 3120   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3121     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3122     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3123     emit_opcode(cbuf,0xDF);
 3124     int rm_byte_opcode = 0x07;
 3125     int base     = $mem$$base;
 3126     int index    = $mem$$index;
 3127     int scale    = $mem$$scale;
 3128     int displace = $mem$$disp;
 3129     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3130     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3131   %}
 3132 












 3133 %}
 3134 
 3135 
 3136 //----------FRAME--------------------------------------------------------------
 3137 // Definition of frame structure and management information.
 3138 //
 3139 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3140 //                             |   (to get allocators register number
 3141 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3142 //  r   CALLER     |        |
 3143 //  o     |        +--------+      pad to even-align allocators stack-slot
 3144 //  w     V        |  pad0  |        numbers; owned by CALLER
 3145 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3146 //  h     ^        |   in   |  5
 3147 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3148 //  |     |        |        |  3
 3149 //  |     |        +--------+
 3150 //  V     |        | old out|      Empty on Intel, window on Sparc
 3151 //        |    old |preserve|      Must be even aligned.
 3152 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
</pre>
<hr />
<pre>
 3349 %}
 3350 
 3351 // Valid scale values for addressing modes
 3352 operand immI2() %{
 3353   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3354   match(ConI);
 3355 
 3356   format %{ %}
 3357   interface(CONST_INTER);
 3358 %}
 3359 
 3360 operand immI8() %{
 3361   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3362   match(ConI);
 3363 
 3364   op_cost(5);
 3365   format %{ %}
 3366   interface(CONST_INTER);
 3367 %}
 3368 
<span class="line-added"> 3369 operand immU8() %{</span>
<span class="line-added"> 3370   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));</span>
<span class="line-added"> 3371   match(ConI);</span>
<span class="line-added"> 3372 </span>
<span class="line-added"> 3373   op_cost(5);</span>
<span class="line-added"> 3374   format %{ %}</span>
<span class="line-added"> 3375   interface(CONST_INTER);</span>
<span class="line-added"> 3376 %}</span>
<span class="line-added"> 3377 </span>
 3378 operand immI16() %{
 3379   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3380   match(ConI);
 3381 
 3382   op_cost(10);
 3383   format %{ %}
 3384   interface(CONST_INTER);
 3385 %}
 3386 
 3387 // Int Immediate non-negative
 3388 operand immU31()
 3389 %{
 3390   predicate(n-&gt;get_int() &gt;= 0);
 3391   match(ConI);
 3392 
 3393   op_cost(0);
 3394   format %{ %}
 3395   interface(CONST_INTER);
 3396 %}
 3397 
</pre>
<hr />
<pre>
13403                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13404   %}
13405   ins_pipe(pipe_slow);
13406 %}
13407 
13408 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13409   match(Set cr (FastUnlock object box));
13410   effect(TEMP tmp, USE_KILL box);
13411   ins_cost(300);
13412   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13413   ins_encode %{
13414     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13415   %}
13416   ins_pipe(pipe_slow);
13417 %}
13418 
13419 
13420 
13421 // ============================================================================
13422 // Safepoint Instruction





















13423 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{
13424   match(SafePoint poll);
13425   effect(KILL cr, USE poll);
13426 
13427   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13428   ins_cost(125);
13429   // EBP would need size(3)
13430   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13431   ins_encode %{
13432     __ relocate(relocInfo::poll_type);
13433     address pre_pc = __ pc();
13434     __ testl(rax, Address($poll$$Register, 0));
13435     address post_pc = __ pc();
13436     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13437   %}
13438   ins_pipe(ialu_reg_mem);
13439 %}
13440 
13441 
13442 // ============================================================================
</pre>
</td>
</tr>
</table>
<center><a href="templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_64.ad.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../sparc/interp_masm_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 542         // At this point, rax points to the value object (for interpreter or C1 caller).
 543         // The fields of the object are copied into registers (for C2 caller).
 544 #endif
 545       }
 546     }
 547   }
 548 
 549   // Pop the stack before the safepoint code
 550   int initial_framesize = initial_frame_size_in_bytes();
 551   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);
 552 
 553   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 554     __ reserved_stack_check();
 555   }
 556 
 557   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 558 
 559   // Note: we do not need to round double result; float result has the right precision
 560   // the poll sets the condition code, but no data registers
 561 
<span class="line-modified"> 562   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified"> 563 #ifdef _LP64</span>
<span class="line-removed"> 564     const Register poll_addr = rscratch1;</span>
 565     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 566 #else
<span class="line-modified"> 567     const Register poll_addr = rbx;</span>
<span class="line-modified"> 568     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);</span>
<span class="line-modified"> 569     __ get_thread(poll_addr);</span>
<span class="line-modified"> 570     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));</span>
 571 #endif
<span class="line-modified"> 572     __ relocate(relocInfo::poll_return_type);</span>
<span class="line-modified"> 573     __ testl(rax, Address(poll_addr, 0));</span>
<span class="line-removed"> 574   } else {</span>
<span class="line-removed"> 575     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);</span>
<span class="line-removed"> 576 </span>
<span class="line-removed"> 577     if (Assembler::is_polling_page_far()) {</span>
<span class="line-removed"> 578       __ lea(rscratch1, polling_page);</span>
<span class="line-removed"> 579       __ relocate(relocInfo::poll_return_type);</span>
<span class="line-removed"> 580       __ testl(rax, Address(rscratch1, 0));</span>
<span class="line-removed"> 581     } else {</span>
<span class="line-removed"> 582       __ testl(rax, polling_page);</span>
<span class="line-removed"> 583     }</span>
<span class="line-removed"> 584   }</span>
 585   __ ret(0);
 586 }
 587 
 588 
 589 int LIR_Assembler::store_value_type_fields_to_buf(ciValueKlass* vk) {
 590   return (__ store_value_type_fields_to_buf(vk, false));
 591 }
 592 
 593 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 594   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 595   int offset = __ offset();
<span class="line-modified"> 596   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified"> 597 #ifdef _LP64</span>
<span class="line-removed"> 598     const Register poll_addr = rscratch1;</span>
 599     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 600 #else
<span class="line-modified"> 601     assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);</span>
<span class="line-modified"> 602     const Register poll_addr = tmp-&gt;as_register();</span>
<span class="line-modified"> 603     __ get_thread(poll_addr);</span>
<span class="line-modified"> 604     __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));</span>
 605 #endif
<span class="line-modified"> 606     add_debug_info_for_branch(info);</span>
<span class="line-modified"> 607     __ relocate(relocInfo::poll_type);</span>
<span class="line-modified"> 608     address pre_pc = __ pc();</span>
<span class="line-modified"> 609     __ testl(rax, Address(poll_addr, 0));</span>
<span class="line-modified"> 610     address post_pc = __ pc();</span>
<span class="line-modified"> 611     guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);</span>
<span class="line-removed"> 612   } else {</span>
<span class="line-removed"> 613     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_type);</span>
<span class="line-removed"> 614     if (Assembler::is_polling_page_far()) {</span>
<span class="line-removed"> 615       __ lea(rscratch1, polling_page);</span>
<span class="line-removed"> 616       offset = __ offset();</span>
<span class="line-removed"> 617       add_debug_info_for_branch(info);</span>
<span class="line-removed"> 618       __ relocate(relocInfo::poll_type);</span>
<span class="line-removed"> 619       __ testl(rax, Address(rscratch1, 0));</span>
<span class="line-removed"> 620     } else {</span>
<span class="line-removed"> 621       add_debug_info_for_branch(info);</span>
<span class="line-removed"> 622       __ testl(rax, polling_page);</span>
<span class="line-removed"> 623     }</span>
<span class="line-removed"> 624   }</span>
 625   return offset;
 626 }
 627 
 628 
 629 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 630   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 631 }
 632 
 633 void LIR_Assembler::swap_reg(Register a, Register b) {
 634   __ xchgptr(a, b);
 635 }
 636 
 637 
 638 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 639   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 640   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 641   LIR_Const* c = src-&gt;as_constant_ptr();
 642 
 643   switch (c-&gt;type()) {
 644     case T_INT: {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 542         // At this point, rax points to the value object (for interpreter or C1 caller).
 543         // The fields of the object are copied into registers (for C2 caller).
 544 #endif
 545       }
 546     }
 547   }
 548 
 549   // Pop the stack before the safepoint code
 550   int initial_framesize = initial_frame_size_in_bytes();
 551   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);
 552 
 553   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 554     __ reserved_stack_check();
 555   }
 556 
 557   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 558 
 559   // Note: we do not need to round double result; float result has the right precision
 560   // the poll sets the condition code, but no data registers
 561 
<span class="line-modified"> 562 #ifdef _LP64</span>
<span class="line-modified"> 563   const Register poll_addr = rscratch1;</span>

 564   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 565 #else
<span class="line-modified"> 566   const Register poll_addr = rbx;</span>
<span class="line-modified"> 567   assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);</span>
<span class="line-modified"> 568   __ get_thread(poll_addr);</span>
<span class="line-modified"> 569   __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));</span>
 570 #endif
<span class="line-modified"> 571   __ relocate(relocInfo::poll_return_type);</span>
<span class="line-modified"> 572   __ testl(rax, Address(poll_addr, 0));</span>











 573   __ ret(0);
 574 }
 575 
 576 
 577 int LIR_Assembler::store_value_type_fields_to_buf(ciValueKlass* vk) {
 578   return (__ store_value_type_fields_to_buf(vk, false));
 579 }
 580 
 581 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 582   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 583   int offset = __ offset();
<span class="line-modified"> 584 #ifdef _LP64</span>
<span class="line-modified"> 585   const Register poll_addr = rscratch1;</span>

 586   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 587 #else
<span class="line-modified"> 588   assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);</span>
<span class="line-modified"> 589   const Register poll_addr = tmp-&gt;as_register();</span>
<span class="line-modified"> 590   __ get_thread(poll_addr);</span>
<span class="line-modified"> 591   __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));</span>
 592 #endif
<span class="line-modified"> 593   add_debug_info_for_branch(info);</span>
<span class="line-modified"> 594   __ relocate(relocInfo::poll_type);</span>
<span class="line-modified"> 595   address pre_pc = __ pc();</span>
<span class="line-modified"> 596   __ testl(rax, Address(poll_addr, 0));</span>
<span class="line-modified"> 597   address post_pc = __ pc();</span>
<span class="line-modified"> 598   guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);</span>













 599   return offset;
 600 }
 601 
 602 
 603 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 604   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 605 }
 606 
 607 void LIR_Assembler::swap_reg(Register a, Register b) {
 608   __ xchgptr(a, b);
 609 }
 610 
 611 
 612 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 613   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 614   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 615   LIR_Const* c = src-&gt;as_constant_ptr();
 616 
 617   switch (c-&gt;type()) {
 618     case T_INT: {
</pre>
</td>
</tr>
</table>
<center><a href="../sparc/interp_masm_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
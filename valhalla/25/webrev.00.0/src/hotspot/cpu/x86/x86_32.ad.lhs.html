<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
<a name="1" id="anc1"></a><span class="line-modified">    2 // Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // X86 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // architecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // Previously set EBX, ESI, and EDI as save-on-entry for java code
   64 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   65 // Now that allocator is better, turn on ESI and EDI as SOE registers.
   66 
   67 reg_def EBX(SOC, SOE, Op_RegI, 3, rbx-&gt;as_VMReg());
   68 reg_def ECX(SOC, SOC, Op_RegI, 1, rcx-&gt;as_VMReg());
   69 reg_def ESI(SOC, SOE, Op_RegI, 6, rsi-&gt;as_VMReg());
   70 reg_def EDI(SOC, SOE, Op_RegI, 7, rdi-&gt;as_VMReg());
   71 // now that adapter frames are gone EBP is always saved and restored by the prolog/epilog code
   72 reg_def EBP(NS, SOE, Op_RegI, 5, rbp-&gt;as_VMReg());
   73 reg_def EDX(SOC, SOC, Op_RegI, 2, rdx-&gt;as_VMReg());
   74 reg_def EAX(SOC, SOC, Op_RegI, 0, rax-&gt;as_VMReg());
   75 reg_def ESP( NS,  NS, Op_RegI, 4, rsp-&gt;as_VMReg());
   76 
   77 // Float registers.  We treat TOS/FPR0 special.  It is invisible to the
   78 // allocator, and only shows up in the encodings.
   79 reg_def FPR0L( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   80 reg_def FPR0H( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   81 // Ok so here&#39;s the trick FPR1 is really st(0) except in the midst
   82 // of emission of assembly for a machnode. During the emission the fpu stack
   83 // is pushed making FPR1 == st(1) temporarily. However at any safepoint
   84 // the stack will not have this element so FPR1 == st(0) from the
   85 // oopMap viewpoint. This same weirdness with numbering causes
   86 // instruction encoding to have to play games with the register
   87 // encode to correct for this 0/1 issue. See MachSpillCopyNode::implementation
   88 // where it does flt-&gt;flt moves to see an example
   89 //
   90 reg_def FPR1L( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg());
   91 reg_def FPR1H( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg()-&gt;next());
   92 reg_def FPR2L( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg());
   93 reg_def FPR2H( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg()-&gt;next());
   94 reg_def FPR3L( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg());
   95 reg_def FPR3H( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg()-&gt;next());
   96 reg_def FPR4L( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg());
   97 reg_def FPR4H( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg()-&gt;next());
   98 reg_def FPR5L( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg());
   99 reg_def FPR5H( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg()-&gt;next());
  100 reg_def FPR6L( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg());
  101 reg_def FPR6H( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg()-&gt;next());
  102 reg_def FPR7L( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg());
  103 reg_def FPR7H( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg()-&gt;next());
  104 //
  105 // Empty fill registers, which are never used, but supply alignment to xmm regs
  106 //
  107 reg_def FILL0( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());
  108 reg_def FILL1( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());
  109 reg_def FILL2( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());
  110 reg_def FILL3( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());
  111 reg_def FILL4( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());
  112 reg_def FILL5( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());
  113 reg_def FILL6( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());
  114 reg_def FILL7( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());
  115 
  116 // Specify priority of register selection within phases of register
  117 // allocation.  Highest priority is first.  A useful heuristic is to
  118 // give registers a low priority when they are required by machine
  119 // instructions, like EAX and EDX.  Registers which are used as
  120 // pairs must fall on an even boundary (witness the FPR#L&#39;s in this list).
  121 // For the Intel integer registers, the equivalent Long pairs are
  122 // EDX:EAX, EBX:ECX, and EDI:EBP.
  123 alloc_class chunk0( ECX,   EBX,   EBP,   EDI,   EAX,   EDX,   ESI, ESP,
  124                     FPR0L, FPR0H, FPR1L, FPR1H, FPR2L, FPR2H,
  125                     FPR3L, FPR3H, FPR4L, FPR4H, FPR5L, FPR5H,
  126                     FPR6L, FPR6H, FPR7L, FPR7H,
  127                     FILL0, FILL1, FILL2, FILL3, FILL4, FILL5, FILL6, FILL7);
  128 
  129 
  130 //----------Architecture Description Register Classes--------------------------
  131 // Several register classes are automatically defined based upon information in
  132 // this architecture description.
  133 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  134 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  135 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  136 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  137 //
  138 // Class for no registers (empty set).
  139 reg_class no_reg();
  140 
  141 // Class for all registers
  142 reg_class any_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX, ESP);
  143 // Class for all registers (excluding EBP)
  144 reg_class any_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX, ESP);
  145 // Dynamic register class that selects at runtime between register classes
  146 // any_reg and any_no_ebp_reg (depending on the value of the flag PreserveFramePointer).
  147 // Equivalent to: return PreserveFramePointer ? any_no_ebp_reg : any_reg;
  148 reg_class_dynamic any_reg(any_reg_no_ebp, any_reg_with_ebp, %{ PreserveFramePointer %});
  149 
  150 // Class for general registers
  151 reg_class int_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX);
  152 // Class for general registers (excluding EBP).
  153 // This register class can be used for implicit null checks on win95.
  154 // It is also safe for use by tailjumps (we don&#39;t want to allocate in ebp).
  155 // Used also if the PreserveFramePointer flag is true.
  156 reg_class int_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX);
  157 // Dynamic register class that selects between int_reg and int_reg_no_ebp.
  158 reg_class_dynamic int_reg(int_reg_no_ebp, int_reg_with_ebp, %{ PreserveFramePointer %});
  159 
  160 // Class of &quot;X&quot; registers
  161 reg_class int_x_reg(EBX, ECX, EDX, EAX);
  162 
  163 // Class of registers that can appear in an address with no offset.
  164 // EBP and ESP require an extra instruction byte for zero offset.
  165 // Used in fast-unlock
  166 reg_class p_reg(EDX, EDI, ESI, EBX);
  167 
  168 // Class for general registers excluding ECX
  169 reg_class ncx_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, EBX);
  170 // Class for general registers excluding ECX (and EBP)
  171 reg_class ncx_reg_no_ebp(EAX, EDX, EDI, ESI, EBX);
  172 // Dynamic register class that selects between ncx_reg and ncx_reg_no_ebp.
  173 reg_class_dynamic ncx_reg(ncx_reg_no_ebp, ncx_reg_with_ebp, %{ PreserveFramePointer %});
  174 
  175 // Class for general registers excluding EAX
  176 reg_class nax_reg(EDX, EDI, ESI, ECX, EBX);
  177 
  178 // Class for general registers excluding EAX and EBX.
  179 reg_class nabx_reg_with_ebp(EDX, EDI, ESI, ECX, EBP);
  180 // Class for general registers excluding EAX and EBX (and EBP)
  181 reg_class nabx_reg_no_ebp(EDX, EDI, ESI, ECX);
  182 // Dynamic register class that selects between nabx_reg and nabx_reg_no_ebp.
  183 reg_class_dynamic nabx_reg(nabx_reg_no_ebp, nabx_reg_with_ebp, %{ PreserveFramePointer %});
  184 
  185 // Class of EAX (for multiply and divide operations)
  186 reg_class eax_reg(EAX);
  187 
  188 // Class of EBX (for atomic add)
  189 reg_class ebx_reg(EBX);
  190 
  191 // Class of ECX (for shift and JCXZ operations and cmpLTMask)
  192 reg_class ecx_reg(ECX);
  193 
  194 // Class of EDX (for multiply and divide operations)
  195 reg_class edx_reg(EDX);
  196 
  197 // Class of EDI (for synchronization)
  198 reg_class edi_reg(EDI);
  199 
  200 // Class of ESI (for synchronization)
  201 reg_class esi_reg(ESI);
  202 
  203 // Singleton class for stack pointer
  204 reg_class sp_reg(ESP);
  205 
  206 // Singleton class for instruction pointer
  207 // reg_class ip_reg(EIP);
  208 
  209 // Class of integer register pairs
  210 reg_class long_reg_with_ebp( EAX,EDX, ECX,EBX, EBP,EDI );
  211 // Class of integer register pairs (excluding EBP and EDI);
  212 reg_class long_reg_no_ebp( EAX,EDX, ECX,EBX );
  213 // Dynamic register class that selects between long_reg and long_reg_no_ebp.
  214 reg_class_dynamic long_reg(long_reg_no_ebp, long_reg_with_ebp, %{ PreserveFramePointer %});
  215 
  216 // Class of integer register pairs that aligns with calling convention
  217 reg_class eadx_reg( EAX,EDX );
  218 reg_class ebcx_reg( ECX,EBX );
  219 
  220 // Not AX or DX, used in divides
  221 reg_class nadx_reg_with_ebp(EBX, ECX, ESI, EDI, EBP);
  222 // Not AX or DX (and neither EBP), used in divides
  223 reg_class nadx_reg_no_ebp(EBX, ECX, ESI, EDI);
  224 // Dynamic register class that selects between nadx_reg and nadx_reg_no_ebp.
  225 reg_class_dynamic nadx_reg(nadx_reg_no_ebp, nadx_reg_with_ebp, %{ PreserveFramePointer %});
  226 
  227 // Floating point registers.  Notice FPR0 is not a choice.
  228 // FPR0 is not ever allocated; we use clever encodings to fake
  229 // a 2-address instructions out of Intels FP stack.
  230 reg_class fp_flt_reg( FPR1L,FPR2L,FPR3L,FPR4L,FPR5L,FPR6L,FPR7L );
  231 
  232 reg_class fp_dbl_reg( FPR1L,FPR1H, FPR2L,FPR2H, FPR3L,FPR3H,
  233                       FPR4L,FPR4H, FPR5L,FPR5H, FPR6L,FPR6H,
  234                       FPR7L,FPR7H );
  235 
  236 reg_class fp_flt_reg0( FPR1L );
  237 reg_class fp_dbl_reg0( FPR1L,FPR1H );
  238 reg_class fp_dbl_reg1( FPR2L,FPR2H );
  239 reg_class fp_dbl_notreg0( FPR2L,FPR2H, FPR3L,FPR3H, FPR4L,FPR4H,
  240                           FPR5L,FPR5H, FPR6L,FPR6H, FPR7L,FPR7H );
  241 
  242 %}
  243 
  244 
  245 //----------SOURCE BLOCK-------------------------------------------------------
  246 // This is a block of C++ code which provides values, functions, and
  247 // definitions necessary in the rest of the architecture description
  248 source_hpp %{
  249 // Must be visible to the DFA in dfa_x86_32.cpp
  250 extern bool is_operand_hi32_zero(Node* n);
  251 %}
  252 
  253 source %{
  254 #define   RELOC_IMM32    Assembler::imm_operand
  255 #define   RELOC_DISP32   Assembler::disp32_operand
  256 
  257 #define __ _masm.
  258 
  259 // How to find the high register of a Long pair, given the low register
  260 #define   HIGH_FROM_LOW(x) ((x)+2)
  261 
  262 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  263 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  264 // fast versions of NegF/NegD and AbsF/AbsD.
  265 
  266 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  267 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  268   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  269   // of 128-bits operands for SSE instructions.
  270   jlong *operand = (jlong*)(((uintptr_t)adr)&amp;((uintptr_t)(~0xF)));
  271   // Store the value to a 128-bits operand.
  272   operand[0] = lo;
  273   operand[1] = hi;
  274   return operand;
  275 }
  276 
  277 // Buffer for 128-bits masks used by SSE instructions.
  278 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  279 
  280 // Static initialization during VM startup.
  281 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2], CONST64(0x7FFFFFFF7FFFFFFF), CONST64(0x7FFFFFFF7FFFFFFF));
  282 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2], CONST64(0x7FFFFFFFFFFFFFFF), CONST64(0x7FFFFFFFFFFFFFFF));
  283 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], CONST64(0x8000000080000000), CONST64(0x8000000080000000));
  284 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], CONST64(0x8000000000000000), CONST64(0x8000000000000000));
  285 
  286 // Offset hacking within calls.
  287 static int pre_call_resets_size() {
  288   int size = 0;
  289   Compile* C = Compile::current();
  290   if (C-&gt;in_24_bit_fp_mode()) {
  291     size += 6; // fldcw
  292   }
  293   if (VM_Version::supports_vzeroupper()) {
  294     size += 3; // vzeroupper
  295   }
  296   return size;
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 
<a name="2" id="anc2"></a><span class="line-removed">  317 // Indicate if the safepoint node needs the polling page as an input.</span>
<span class="line-removed">  318 // Since x86 does have absolute addressing, it doesn&#39;t.</span>
<span class="line-removed">  319 bool SafePointNode::needs_polling_address_input() {</span>
<span class="line-removed">  320   return SafepointMechanism::uses_thread_local_poll();</span>
<span class="line-removed">  321 }</span>
<span class="line-removed">  322 </span>
  323 //
  324 // Compute padding required for nodes which need alignment
  325 //
  326 
  327 // The address of the call instruction needs to be 4-byte aligned to
  328 // ensure that it does not span a cache line so that it can be patched.
  329 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  330   current_offset += pre_call_resets_size();  // skip fldcw, if any
  331   current_offset += 1;      // skip call opcode byte
  332   return align_up(current_offset, alignment_required()) - current_offset;
  333 }
  334 
  335 // The address of the call instruction needs to be 4-byte aligned to
  336 // ensure that it does not span a cache line so that it can be patched.
  337 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  338   current_offset += pre_call_resets_size();  // skip fldcw, if any
  339   current_offset += 5;      // skip MOV instruction
  340   current_offset += 1;      // skip call opcode byte
  341   return align_up(current_offset, alignment_required()) - current_offset;
  342 }
  343 
  344 // EMIT_RM()
  345 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  346   unsigned char c = (unsigned char)((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  347   cbuf.insts()-&gt;emit_int8(c);
  348 }
  349 
  350 // EMIT_CC()
  351 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  352   unsigned char c = (unsigned char)( f1 | f2 );
  353   cbuf.insts()-&gt;emit_int8(c);
  354 }
  355 
  356 // EMIT_OPCODE()
  357 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  358   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  359 }
  360 
  361 // EMIT_OPCODE() w/ relocation information
  362 void emit_opcode(CodeBuffer &amp;cbuf, int code, relocInfo::relocType reloc, int offset = 0) {
  363   cbuf.relocate(cbuf.insts_mark() + offset, reloc);
  364   emit_opcode(cbuf, code);
  365 }
  366 
  367 // EMIT_D8()
  368 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  369   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  370 }
  371 
  372 // EMIT_D16()
  373 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  374   cbuf.insts()-&gt;emit_int16(d16);
  375 }
  376 
  377 // EMIT_D32()
  378 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  379   cbuf.insts()-&gt;emit_int32(d32);
  380 }
  381 
  382 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  383 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, relocInfo::relocType reloc,
  384         int format) {
  385   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  386   cbuf.insts()-&gt;emit_int32(d32);
  387 }
  388 
  389 // emit 32 bit value and construct relocation entry from RelocationHolder
  390 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, RelocationHolder const&amp; rspec,
  391         int format) {
  392 #ifdef ASSERT
  393   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp; d32 != 0 &amp;&amp; d32 != (int)Universe::non_oop_word()) {
  394     assert(oopDesc::is_oop(cast_to_oop(d32)), &quot;cannot embed broken oops in code&quot;);
  395   }
  396 #endif
  397   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  398   cbuf.insts()-&gt;emit_int32(d32);
  399 }
  400 
  401 // Access stack slot for load or store
  402 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp) {
  403   emit_opcode( cbuf, opcode );               // (e.g., FILD   [ESP+src])
  404   if( -128 &lt;= disp &amp;&amp; disp &lt;= 127 ) {
  405     emit_rm( cbuf, 0x01, rm_field, ESP_enc );  // R/M byte
  406     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  407     emit_d8 (cbuf, disp);     // Displacement  // R/M byte
  408   } else {
  409     emit_rm( cbuf, 0x02, rm_field, ESP_enc );  // R/M byte
  410     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  411     emit_d32(cbuf, disp);     // Displacement  // R/M byte
  412   }
  413 }
  414 
  415    // rRegI ereg, memory mem) %{    // emit_reg_mem
  416 void encode_RegMem( CodeBuffer &amp;cbuf, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {
  417   // There is no index &amp; no scale, use form without SIB byte
  418   if ((index == 0x4) &amp;&amp;
  419       (scale == 0) &amp;&amp; (base != ESP_enc)) {
  420     // If no displacement, mode is 0x0; unless base is [EBP]
  421     if ( (displace == 0) &amp;&amp; (base != EBP_enc) ) {
  422       emit_rm(cbuf, 0x0, reg_encoding, base);
  423     }
  424     else {                    // If 8-bit displacement, mode 0x1
  425       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  426           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  427         emit_rm(cbuf, 0x1, reg_encoding, base);
  428         emit_d8(cbuf, displace);
  429       }
  430       else {                  // If 32-bit displacement
  431         if (base == -1) { // Special flag for absolute address
  432           emit_rm(cbuf, 0x0, reg_encoding, 0x5);
  433           // (manual lies; no SIB needed here)
  434           if ( disp_reloc != relocInfo::none ) {
  435             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  436           } else {
  437             emit_d32      (cbuf, displace);
  438           }
  439         }
  440         else {                // Normal base + offset
  441           emit_rm(cbuf, 0x2, reg_encoding, base);
  442           if ( disp_reloc != relocInfo::none ) {
  443             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  444           } else {
  445             emit_d32      (cbuf, displace);
  446           }
  447         }
  448       }
  449     }
  450   }
  451   else {                      // Else, encode with the SIB byte
  452     // If no displacement, mode is 0x0; unless base is [EBP]
  453     if (displace == 0 &amp;&amp; (base != EBP_enc)) {  // If no displacement
  454       emit_rm(cbuf, 0x0, reg_encoding, 0x4);
  455       emit_rm(cbuf, scale, index, base);
  456     }
  457     else {                    // If 8-bit displacement, mode 0x1
  458       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  459           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  460         emit_rm(cbuf, 0x1, reg_encoding, 0x4);
  461         emit_rm(cbuf, scale, index, base);
  462         emit_d8(cbuf, displace);
  463       }
  464       else {                  // If 32-bit displacement
  465         if (base == 0x04 ) {
  466           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  467           emit_rm(cbuf, scale, index, 0x04);
  468         } else {
  469           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  470           emit_rm(cbuf, scale, index, base);
  471         }
  472         if ( disp_reloc != relocInfo::none ) {
  473           emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  474         } else {
  475           emit_d32      (cbuf, displace);
  476         }
  477       }
  478     }
  479   }
  480 }
  481 
  482 
  483 void encode_Copy( CodeBuffer &amp;cbuf, int dst_encoding, int src_encoding ) {
  484   if( dst_encoding == src_encoding ) {
  485     // reg-reg copy, use an empty encoding
  486   } else {
  487     emit_opcode( cbuf, 0x8B );
  488     emit_rm(cbuf, 0x3, dst_encoding, src_encoding );
  489   }
  490 }
  491 
  492 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  493   Label exit;
  494   __ jccb(Assembler::noParity, exit);
  495   __ pushf();
  496   //
  497   // comiss/ucomiss instructions set ZF,PF,CF flags and
  498   // zero OF,AF,SF for NaN values.
  499   // Fixup flags by zeroing ZF,PF so that compare of NaN
  500   // values returns &#39;less than&#39; result (CF is set).
  501   // Leave the rest of flags unchanged.
  502   //
  503   //    7 6 5 4 3 2 1 0
  504   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  505   //    0 0 1 0 1 0 1 1   (0x2B)
  506   //
  507   __ andl(Address(rsp, 0), 0xffffff2b);
  508   __ popf();
  509   __ bind(exit);
  510 }
  511 
  512 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  513   Label done;
  514   __ movl(dst, -1);
  515   __ jcc(Assembler::parity, done);
  516   __ jcc(Assembler::below, done);
  517   __ setb(Assembler::notEqual, dst);
  518   __ movzbl(dst, dst);
  519   __ bind(done);
  520 }
  521 
  522 
  523 //=============================================================================
  524 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  525 
  526 int ConstantTable::calculate_table_base_offset() const {
  527   return 0;  // absolute addressing, no offset
  528 }
  529 
  530 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  531 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  532   ShouldNotReachHere();
  533 }
  534 
  535 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  536   // Empty encoding
  537 }
  538 
  539 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  540   return 0;
  541 }
  542 
  543 #ifndef PRODUCT
  544 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  545   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  546 }
  547 #endif
  548 
  549 
  550 //=============================================================================
  551 #ifndef PRODUCT
  552 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  553   Compile* C = ra_-&gt;C;
  554 
  555   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  556   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  557   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  558   // Remove wordSize for return addr which is already pushed.
  559   framesize -= wordSize;
  560 
  561   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  562     framesize -= wordSize;
  563     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  564     st-&gt;print(&quot;\n\t&quot;);
  565     st-&gt;print(&quot;PUSH   EBP\t# Save EBP&quot;);
  566     if (PreserveFramePointer) {
  567       st-&gt;print(&quot;\n\t&quot;);
  568       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  569     }
  570     if (framesize) {
  571       st-&gt;print(&quot;\n\t&quot;);
  572       st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  573     }
  574   } else {
  575     st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  576     st-&gt;print(&quot;\n\t&quot;);
  577     framesize -= wordSize;
  578     st-&gt;print(&quot;MOV    [ESP + #%d], EBP\t# Save EBP&quot;,framesize);
  579     if (PreserveFramePointer) {
  580       st-&gt;print(&quot;\n\t&quot;);
  581       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  582       if (framesize &gt; 0) {
  583         st-&gt;print(&quot;\n\t&quot;);
  584         st-&gt;print(&quot;ADD    EBP, #%d&quot;, framesize);
  585       }
  586     }
  587   }
  588 
  589   if (VerifyStackAtCalls) {
  590     st-&gt;print(&quot;\n\t&quot;);
  591     framesize -= wordSize;
  592     st-&gt;print(&quot;MOV    [ESP + #%d], 0xBADB100D\t# Majik cookie for stack depth check&quot;,framesize);
  593   }
  594 
  595   if( C-&gt;in_24_bit_fp_mode() ) {
  596     st-&gt;print(&quot;\n\t&quot;);
  597     st-&gt;print(&quot;FLDCW  \t# load 24 bit fpu control word&quot;);
  598   }
  599   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
  600     st-&gt;print(&quot;\n\t&quot;);
  601     st-&gt;print(&quot;# verify FPU stack (must be clean on entry)&quot;);
  602   }
  603 
  604 #ifdef ASSERT
  605   if (VerifyStackAtCalls) {
  606     st-&gt;print(&quot;\n\t&quot;);
  607     st-&gt;print(&quot;# stack alignment check&quot;);
  608   }
  609 #endif
  610   st-&gt;cr();
  611 }
  612 #endif
  613 
  614 
  615 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  616   Compile* C = ra_-&gt;C;
  617   MacroAssembler _masm(&amp;cbuf);
  618 
  619   __ verified_entry(C);
  620 
  621   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  622 
  623   if (C-&gt;has_mach_constant_base_node()) {
  624     // NOTE: We set the table base offset here because users might be
  625     // emitted before MachConstantBaseNode.
  626     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  627     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  628   }
  629 }
  630 
  631 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  632   return MachNode::size(ra_); // too many variables; just compute it the hard way
  633 }
  634 
  635 int MachPrologNode::reloc() const {
  636   return 0; // a large enough number
  637 }
  638 
  639 //=============================================================================
  640 #ifndef PRODUCT
  641 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  642   Compile *C = ra_-&gt;C;
  643   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  644   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  645   // Remove two words for return addr and rbp,
  646   framesize -= 2*wordSize;
  647 
  648   if (C-&gt;max_vector_size() &gt; 16) {
  649     st-&gt;print(&quot;VZEROUPPER&quot;);
  650     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  651   }
  652   if (C-&gt;in_24_bit_fp_mode()) {
  653     st-&gt;print(&quot;FLDCW  standard control word&quot;);
  654     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  655   }
  656   if (framesize) {
  657     st-&gt;print(&quot;ADD    ESP,%d\t# Destroy frame&quot;,framesize);
  658     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  659   }
  660   st-&gt;print_cr(&quot;POPL   EBP&quot;); st-&gt;print(&quot;\t&quot;);
  661   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  662     st-&gt;print(&quot;TEST   PollPage,EAX\t! Poll Safepoint&quot;);
  663     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  664   }
  665 }
  666 #endif
  667 
  668 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  669   Compile *C = ra_-&gt;C;
  670   MacroAssembler _masm(&amp;cbuf);
  671 
  672   if (C-&gt;max_vector_size() &gt; 16) {
  673     // Clear upper bits of YMM registers when current compiled code uses
  674     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  675     _masm.vzeroupper();
  676   }
  677   // If method set FPU control word, restore to standard control word
  678   if (C-&gt;in_24_bit_fp_mode()) {
  679     _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
  680   }
  681 
  682   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  683   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  684   // Remove two words for return addr and rbp,
  685   framesize -= 2*wordSize;
  686 
  687   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  688 
  689   if (framesize &gt;= 128) {
  690     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  691     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  692     emit_d32(cbuf, framesize);
  693   } else if (framesize) {
  694     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  695     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  696     emit_d8(cbuf, framesize);
  697   }
  698 
  699   emit_opcode(cbuf, 0x58 | EBP_enc);
  700 
  701   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  702     __ reserved_stack_check();
  703   }
  704 
  705   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
<a name="3" id="anc3"></a><span class="line-modified">  706     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">  707       Register pollReg = as_Register(EBX_enc);</span>
<span class="line-modified">  708       MacroAssembler masm(&amp;cbuf);</span>
<span class="line-modified">  709       masm.get_thread(pollReg);</span>
<span class="line-modified">  710       masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));</span>
<span class="line-modified">  711       masm.relocate(relocInfo::poll_return_type);</span>
<span class="line-removed">  712       masm.testl(rax, Address(pollReg, 0));</span>
<span class="line-removed">  713     } else {</span>
<span class="line-removed">  714       cbuf.relocate(cbuf.insts_end(), relocInfo::poll_return_type, 0);</span>
<span class="line-removed">  715       emit_opcode(cbuf,0x85);</span>
<span class="line-removed">  716       emit_rm(cbuf, 0x0, EAX_enc, 0x5); // EAX</span>
<span class="line-removed">  717       emit_d32(cbuf, (intptr_t)os::get_polling_page());</span>
<span class="line-removed">  718     }</span>
  719   }
  720 }
  721 
  722 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  723   return MachNode::size(ra_); // too many variables; just compute it
  724                               // the hard way
  725 }
  726 
  727 int MachEpilogNode::reloc() const {
  728   return 0; // a large enough number
  729 }
  730 
  731 const Pipeline * MachEpilogNode::pipeline() const {
  732   return MachNode::pipeline_class();
  733 }
  734 
<a name="4" id="anc4"></a><span class="line-removed">  735 int MachEpilogNode::safepoint_offset() const { return 0; }</span>
<span class="line-removed">  736 </span>
  737 //=============================================================================
  738 
  739 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  740 static enum RC rc_class( OptoReg::Name reg ) {
  741 
  742   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  743   if (OptoReg::is_stack(reg)) return rc_stack;
  744 
  745   VMReg r = OptoReg::as_VMReg(reg);
  746   if (r-&gt;is_Register()) return rc_int;
  747   if (r-&gt;is_FloatRegister()) {
  748     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  749     return rc_float;
  750   }
  751   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  752   return rc_xmm;
  753 }
  754 
  755 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  756                         int opcode, const char *op_str, int size, outputStream* st ) {
  757   if( cbuf ) {
  758     emit_opcode  (*cbuf, opcode );
  759     encode_RegMem(*cbuf, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);
  760 #ifndef PRODUCT
  761   } else if( !do_size ) {
  762     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  763     if( opcode == 0x8B || opcode == 0x89 ) { // MOV
  764       if( is_load ) st-&gt;print(&quot;%s   %s,[ESP + #%d]&quot;,op_str,Matcher::regName[reg],offset);
  765       else          st-&gt;print(&quot;%s   [ESP + #%d],%s&quot;,op_str,offset,Matcher::regName[reg]);
  766     } else { // FLD, FST, PUSH, POP
  767       st-&gt;print(&quot;%s [ESP + #%d]&quot;,op_str,offset);
  768     }
  769 #endif
  770   }
  771   int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  772   return size+3+offset_size;
  773 }
  774 
  775 // Helper for XMM registers.  Extra opcode bits, limited syntax.
  776 static int impl_x_helper( CodeBuffer *cbuf, bool do_size, bool is_load,
  777                          int offset, int reg_lo, int reg_hi, int size, outputStream* st ) {
  778   int in_size_in_bits = Assembler::EVEX_32bit;
  779   int evex_encoding = 0;
  780   if (reg_lo+1 == reg_hi) {
  781     in_size_in_bits = Assembler::EVEX_64bit;
  782     evex_encoding = Assembler::VEX_W;
  783   }
  784   if (cbuf) {
  785     MacroAssembler _masm(cbuf);
  786     // EVEX spills remain EVEX: Compressed displacemement is better than AVX on spill mem operations,
  787     //                          it maps more cases to single byte displacement
  788     _masm.set_managed();
  789     if (reg_lo+1 == reg_hi) { // double move?
  790       if (is_load) {
  791         __ movdbl(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  792       } else {
  793         __ movdbl(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  794       }
  795     } else {
  796       if (is_load) {
  797         __ movflt(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  798       } else {
  799         __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  800       }
  801     }
  802 #ifndef PRODUCT
  803   } else if (!do_size) {
  804     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  805     if (reg_lo+1 == reg_hi) { // double move?
  806       if (is_load) st-&gt;print(&quot;%s %s,[ESP + #%d]&quot;,
  807                               UseXmmLoadAndClearUpper ? &quot;MOVSD &quot; : &quot;MOVLPD&quot;,
  808                               Matcher::regName[reg_lo], offset);
  809       else         st-&gt;print(&quot;MOVSD  [ESP + #%d],%s&quot;,
  810                               offset, Matcher::regName[reg_lo]);
  811     } else {
  812       if (is_load) st-&gt;print(&quot;MOVSS  %s,[ESP + #%d]&quot;,
  813                               Matcher::regName[reg_lo], offset);
  814       else         st-&gt;print(&quot;MOVSS  [ESP + #%d],%s&quot;,
  815                               offset, Matcher::regName[reg_lo]);
  816     }
  817 #endif
  818   }
  819   bool is_single_byte = false;
  820   if ((UseAVX &gt; 2) &amp;&amp; (offset != 0)) {
  821     is_single_byte = Assembler::query_compressed_disp_byte(offset, true, 0, Assembler::EVEX_T1S, in_size_in_bits, evex_encoding);
  822   }
  823   int offset_size = 0;
  824   if (UseAVX &gt; 2 ) {
  825     offset_size = (offset == 0) ? 0 : ((is_single_byte) ? 1 : 4);
  826   } else {
  827     offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  828   }
  829   size += (UseAVX &gt; 2) ? 2 : 0; // Need an additional two bytes for EVEX
  830   // VEX_2bytes prefix is used if UseAVX &gt; 0, so it takes the same 2 bytes as SIMD prefix.
  831   return size+5+offset_size;
  832 }
  833 
  834 
  835 static int impl_movx_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  836                             int src_hi, int dst_hi, int size, outputStream* st ) {
  837   if (cbuf) {
  838     MacroAssembler _masm(cbuf);
  839     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  840     _masm.set_managed();
  841     if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  842       __ movdbl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  843                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  844     } else {
  845       __ movflt(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  846                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  847     }
  848 #ifndef PRODUCT
  849   } else if (!do_size) {
  850     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  851     if (UseXmmRegToRegMoveAll) {//Use movaps,movapd to move between xmm registers
  852       if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  853         st-&gt;print(&quot;MOVAPD %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  854       } else {
  855         st-&gt;print(&quot;MOVAPS %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  856       }
  857     } else {
  858       if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double move?
  859         st-&gt;print(&quot;MOVSD  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  860       } else {
  861         st-&gt;print(&quot;MOVSS  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  862       }
  863     }
  864 #endif
  865   }
  866   // VEX_2bytes prefix is used if UseAVX &gt; 0, and it takes the same 2 bytes as SIMD prefix.
  867   // Only MOVAPS SSE prefix uses 1 byte.  EVEX uses an additional 2 bytes.
  868   int sz = (UseAVX &gt; 2) ? 6 : 4;
  869   if (!(src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) &amp;&amp;
  870       UseXmmRegToRegMoveAll &amp;&amp; (UseAVX == 0)) sz = 3;
  871   return size + sz;
  872 }
  873 
  874 static int impl_movgpr2x_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  875                             int src_hi, int dst_hi, int size, outputStream* st ) {
  876   // 32-bit
  877   if (cbuf) {
  878     MacroAssembler _masm(cbuf);
  879     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  880     _masm.set_managed();
  881     __ movdl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  882              as_Register(Matcher::_regEncode[src_lo]));
  883 #ifndef PRODUCT
  884   } else if (!do_size) {
  885     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  886 #endif
  887   }
  888   return (UseAVX&gt; 2) ? 6 : 4;
  889 }
  890 
  891 
  892 static int impl_movx2gpr_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  893                                  int src_hi, int dst_hi, int size, outputStream* st ) {
  894   // 32-bit
  895   if (cbuf) {
  896     MacroAssembler _masm(cbuf);
  897     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  898     _masm.set_managed();
  899     __ movdl(as_Register(Matcher::_regEncode[dst_lo]),
  900              as_XMMRegister(Matcher::_regEncode[src_lo]));
  901 #ifndef PRODUCT
  902   } else if (!do_size) {
  903     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  904 #endif
  905   }
  906   return (UseAVX&gt; 2) ? 6 : 4;
  907 }
  908 
  909 static int impl_mov_helper( CodeBuffer *cbuf, bool do_size, int src, int dst, int size, outputStream* st ) {
  910   if( cbuf ) {
  911     emit_opcode(*cbuf, 0x8B );
  912     emit_rm    (*cbuf, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );
  913 #ifndef PRODUCT
  914   } else if( !do_size ) {
  915     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  916     st-&gt;print(&quot;MOV    %s,%s&quot;,Matcher::regName[dst],Matcher::regName[src]);
  917 #endif
  918   }
  919   return size+2;
  920 }
  921 
  922 static int impl_fp_store_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,
  923                                  int offset, int size, outputStream* st ) {
  924   if( src_lo != FPR1L_num ) {      // Move value to top of FP stack, if not already there
  925     if( cbuf ) {
  926       emit_opcode( *cbuf, 0xD9 );  // FLD (i.e., push it)
  927       emit_d8( *cbuf, 0xC0-1+Matcher::_regEncode[src_lo] );
  928 #ifndef PRODUCT
  929     } else if( !do_size ) {
  930       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  931       st-&gt;print(&quot;FLD    %s&quot;,Matcher::regName[src_lo]);
  932 #endif
  933     }
  934     size += 2;
  935   }
  936 
  937   int st_op = (src_lo != FPR1L_num) ? EBX_num /*store &amp; pop*/ : EDX_num /*store no pop*/;
  938   const char *op_str;
  939   int op;
  940   if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double store?
  941     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_D&quot; : &quot;FST_D &quot;;
  942     op = 0xDD;
  943   } else {                   // 32-bit store
  944     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_S&quot; : &quot;FST_S &quot;;
  945     op = 0xD9;
  946     assert( !OptoReg::is_valid(src_hi) &amp;&amp; !OptoReg::is_valid(dst_hi), &quot;no non-adjacent float-stores&quot; );
  947   }
  948 
  949   return impl_helper(cbuf,do_size,false,offset,st_op,op,op_str,size, st);
  950 }
  951 
  952 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
  953 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  954                           int src_hi, int dst_hi, uint ireg, outputStream* st);
  955 
  956 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
  957                             int stack_offset, int reg, uint ireg, outputStream* st);
  958 
  959 static int vec_stack_to_stack_helper(CodeBuffer *cbuf, bool do_size, int src_offset,
  960                                      int dst_offset, uint ireg, outputStream* st) {
  961   int calc_size = 0;
  962   int src_offset_size = (src_offset == 0) ? 0 : ((src_offset &lt; 0x80) ? 1 : 4);
  963   int dst_offset_size = (dst_offset == 0) ? 0 : ((dst_offset &lt; 0x80) ? 1 : 4);
  964   switch (ireg) {
  965   case Op_VecS:
  966     calc_size = 3+src_offset_size + 3+dst_offset_size;
  967     break;
  968   case Op_VecD: {
  969     calc_size = 3+src_offset_size + 3+dst_offset_size;
  970     int tmp_src_offset = src_offset + 4;
  971     int tmp_dst_offset = dst_offset + 4;
  972     src_offset_size = (tmp_src_offset == 0) ? 0 : ((tmp_src_offset &lt; 0x80) ? 1 : 4);
  973     dst_offset_size = (tmp_dst_offset == 0) ? 0 : ((tmp_dst_offset &lt; 0x80) ? 1 : 4);
  974     calc_size += 3+src_offset_size + 3+dst_offset_size;
  975     break;
  976   }
  977   case Op_VecX:
  978   case Op_VecY:
  979   case Op_VecZ:
  980     calc_size = 6 + 6 + 5+src_offset_size + 5+dst_offset_size;
  981     break;
  982   default:
  983     ShouldNotReachHere();
  984   }
  985   if (cbuf) {
  986     MacroAssembler _masm(cbuf);
  987     int offset = __ offset();
  988     switch (ireg) {
  989     case Op_VecS:
  990       __ pushl(Address(rsp, src_offset));
  991       __ popl (Address(rsp, dst_offset));
  992       break;
  993     case Op_VecD:
  994       __ pushl(Address(rsp, src_offset));
  995       __ popl (Address(rsp, dst_offset));
  996       __ pushl(Address(rsp, src_offset+4));
  997       __ popl (Address(rsp, dst_offset+4));
  998       break;
  999     case Op_VecX:
 1000       __ movdqu(Address(rsp, -16), xmm0);
 1001       __ movdqu(xmm0, Address(rsp, src_offset));
 1002       __ movdqu(Address(rsp, dst_offset), xmm0);
 1003       __ movdqu(xmm0, Address(rsp, -16));
 1004       break;
 1005     case Op_VecY:
 1006       __ vmovdqu(Address(rsp, -32), xmm0);
 1007       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1008       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1009       __ vmovdqu(xmm0, Address(rsp, -32));
 1010       break;
 1011     case Op_VecZ:
 1012       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1013       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1014       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1015       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1016       break;
 1017     default:
 1018       ShouldNotReachHere();
 1019     }
 1020     int size = __ offset() - offset;
 1021     assert(size == calc_size, &quot;incorrect size calculation&quot;);
 1022     return size;
 1023 #ifndef PRODUCT
 1024   } else if (!do_size) {
 1025     switch (ireg) {
 1026     case Op_VecS:
 1027       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 32-bit mem-mem spill\n\t&quot;
 1028                 &quot;popl    [rsp + #%d]&quot;,
 1029                 src_offset, dst_offset);
 1030       break;
 1031     case Op_VecD:
 1032       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1033                 &quot;popq    [rsp + #%d]\n\t&quot;
 1034                 &quot;pushl   [rsp + #%d]\n\t&quot;
 1035                 &quot;popq    [rsp + #%d]&quot;,
 1036                 src_offset, dst_offset, src_offset+4, dst_offset+4);
 1037       break;
 1038      case Op_VecX:
 1039       st-&gt;print(&quot;movdqu  [rsp - #16], xmm0\t# 128-bit mem-mem spill\n\t&quot;
 1040                 &quot;movdqu  xmm0, [rsp + #%d]\n\t&quot;
 1041                 &quot;movdqu  [rsp + #%d], xmm0\n\t&quot;
 1042                 &quot;movdqu  xmm0, [rsp - #16]&quot;,
 1043                 src_offset, dst_offset);
 1044       break;
 1045     case Op_VecY:
 1046       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1047                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1048                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1049                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1050                 src_offset, dst_offset);
 1051       break;
 1052     case Op_VecZ:
 1053       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1054                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1055                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1056                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1057                 src_offset, dst_offset);
 1058       break;
 1059     default:
 1060       ShouldNotReachHere();
 1061     }
 1062 #endif
 1063   }
 1064   return calc_size;
 1065 }
 1066 
 1067 uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {
 1068   // Get registers to move
 1069   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1070   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1071   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this );
 1072   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this );
 1073 
 1074   enum RC src_second_rc = rc_class(src_second);
 1075   enum RC src_first_rc = rc_class(src_first);
 1076   enum RC dst_second_rc = rc_class(dst_second);
 1077   enum RC dst_first_rc = rc_class(dst_first);
 1078 
 1079   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
 1080 
 1081   // Generate spill code!
 1082   int size = 0;
 1083 
 1084   if( src_first == dst_first &amp;&amp; src_second == dst_second )
 1085     return size;            // Self copy, no move
 1086 
 1087   if (bottom_type()-&gt;isa_vect() != NULL) {
 1088     uint ireg = ideal_reg();
 1089     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1090     assert((src_first_rc != rc_float &amp;&amp; dst_first_rc != rc_float), &quot;sanity&quot;);
 1091     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1092     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1093       // mem -&gt; mem
 1094       int src_offset = ra_-&gt;reg2offset(src_first);
 1095       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1096       return vec_stack_to_stack_helper(cbuf, do_size, src_offset, dst_offset, ireg, st);
 1097     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1098       return vec_mov_helper(cbuf, do_size, src_first, dst_first, src_second, dst_second, ireg, st);
 1099     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1100       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1101       return vec_spill_helper(cbuf, do_size, false, stack_offset, src_first, ireg, st);
 1102     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_xmm ) {
 1103       int stack_offset = ra_-&gt;reg2offset(src_first);
 1104       return vec_spill_helper(cbuf, do_size, true,  stack_offset, dst_first, ireg, st);
 1105     } else {
 1106       ShouldNotReachHere();
 1107     }
 1108   }
 1109 
 1110   // --------------------------------------
 1111   // Check for mem-mem move.  push/pop to move.
 1112   if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1113     if( src_second == dst_first ) { // overlapping stack copy ranges
 1114       assert( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack, &quot;we only expect a stk-stk copy here&quot; );
 1115       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1116       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1117       src_second_rc = dst_second_rc = rc_bad;  // flag as already moved the second bits
 1118     }
 1119     // move low bits
 1120     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1121     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1122     if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) { // mov second bits
 1123       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1124       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1125     }
 1126     return size;
 1127   }
 1128 
 1129   // --------------------------------------
 1130   // Check for integer reg-reg copy
 1131   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int )
 1132     size = impl_mov_helper(cbuf,do_size,src_first,dst_first,size, st);
 1133 
 1134   // Check for integer store
 1135   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack )
 1136     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first,0x89,&quot;MOV &quot;,size, st);
 1137 
 1138   // Check for integer load
 1139   if( dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack )
 1140     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first,0x8B,&quot;MOV &quot;,size, st);
 1141 
 1142   // Check for integer reg-xmm reg copy
 1143   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_xmm ) {
 1144     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1145             &quot;no 64 bit integer-float reg moves&quot; );
 1146     return impl_movgpr2x_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1147   }
 1148   // --------------------------------------
 1149   // Check for float reg-reg copy
 1150   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1151     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1152             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second), &quot;no non-adjacent float-moves&quot; );
 1153     if( cbuf ) {
 1154 
 1155       // Note the mucking with the register encode to compensate for the 0/1
 1156       // indexing issue mentioned in a comment in the reg_def sections
 1157       // for FPR registers many lines above here.
 1158 
 1159       if( src_first != FPR1L_num ) {
 1160         emit_opcode  (*cbuf, 0xD9 );           // FLD    ST(i)
 1161         emit_d8      (*cbuf, 0xC0+Matcher::_regEncode[src_first]-1 );
 1162         emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1163         emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1164      } else {
 1165         emit_opcode  (*cbuf, 0xDD );           // FST    ST(i)
 1166         emit_d8      (*cbuf, 0xD0+Matcher::_regEncode[dst_first]-1 );
 1167      }
 1168 #ifndef PRODUCT
 1169     } else if( !do_size ) {
 1170       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1171       if( src_first != FPR1L_num ) st-&gt;print(&quot;FLD    %s\n\tFSTP   %s&quot;,Matcher::regName[src_first],Matcher::regName[dst_first]);
 1172       else                      st-&gt;print(             &quot;FST    %s&quot;,                            Matcher::regName[dst_first]);
 1173 #endif
 1174     }
 1175     return size + ((src_first != FPR1L_num) ? 2+2 : 2);
 1176   }
 1177 
 1178   // Check for float store
 1179   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1180     return impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,ra_-&gt;reg2offset(dst_first),size, st);
 1181   }
 1182 
 1183   // Check for float load
 1184   if( dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack ) {
 1185     int offset = ra_-&gt;reg2offset(src_first);
 1186     const char *op_str;
 1187     int op;
 1188     if( src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second ) { // double load?
 1189       op_str = &quot;FLD_D&quot;;
 1190       op = 0xDD;
 1191     } else {                   // 32-bit load
 1192       op_str = &quot;FLD_S&quot;;
 1193       op = 0xD9;
 1194       assert( src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad, &quot;no non-adjacent float-loads&quot; );
 1195     }
 1196     if( cbuf ) {
 1197       emit_opcode  (*cbuf, op );
 1198       encode_RegMem(*cbuf, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);
 1199       emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1200       emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1201 #ifndef PRODUCT
 1202     } else if( !do_size ) {
 1203       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1204       st-&gt;print(&quot;%s  ST,[ESP + #%d]\n\tFSTP   %s&quot;,op_str, offset,Matcher::regName[dst_first]);
 1205 #endif
 1206     }
 1207     int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
 1208     return size + 3+offset_size+2;
 1209   }
 1210 
 1211   // Check for xmm reg-reg copy
 1212   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1213     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1214             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second),
 1215             &quot;no non-adjacent float-moves&quot; );
 1216     return impl_movx_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1217   }
 1218 
 1219   // Check for xmm reg-integer reg copy
 1220   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_int ) {
 1221     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1222             &quot;no 64 bit float-integer reg moves&quot; );
 1223     return impl_movx2gpr_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1224   }
 1225 
 1226   // Check for xmm store
 1227   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1228     return impl_x_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first, src_second, size, st);
 1229   }
 1230 
 1231   // Check for float xmm load
 1232   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_stack ) {
 1233     return impl_x_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first, dst_second, size, st);
 1234   }
 1235 
 1236   // Copy from float reg to xmm reg
 1237   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_float ) {
 1238     // copy to the top of stack from floating point reg
 1239     // and use LEA to preserve flags
 1240     if( cbuf ) {
 1241       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP-8]
 1242       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1243       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1244       emit_d8(*cbuf,0xF8);
 1245 #ifndef PRODUCT
 1246     } else if( !do_size ) {
 1247       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1248       st-&gt;print(&quot;LEA    ESP,[ESP-8]&quot;);
 1249 #endif
 1250     }
 1251     size += 4;
 1252 
 1253     size = impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,0,size, st);
 1254 
 1255     // Copy from the temp memory to the xmm reg.
 1256     size = impl_x_helper(cbuf,do_size,true ,0,dst_first, dst_second, size, st);
 1257 
 1258     if( cbuf ) {
 1259       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP+8]
 1260       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1261       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1262       emit_d8(*cbuf,0x08);
 1263 #ifndef PRODUCT
 1264     } else if( !do_size ) {
 1265       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1266       st-&gt;print(&quot;LEA    ESP,[ESP+8]&quot;);
 1267 #endif
 1268     }
 1269     size += 4;
 1270     return size;
 1271   }
 1272 
 1273   assert( size &gt; 0, &quot;missed a case&quot; );
 1274 
 1275   // --------------------------------------------------------------------
 1276   // Check for second bits still needing moving.
 1277   if( src_second == dst_second )
 1278     return size;               // Self copy; no move
 1279   assert( src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot; );
 1280 
 1281   // Check for second word int-int move
 1282   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_int )
 1283     return impl_mov_helper(cbuf,do_size,src_second,dst_second,size, st);
 1284 
 1285   // Check for second word integer store
 1286   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_stack )
 1287     return impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),src_second,0x89,&quot;MOV &quot;,size, st);
 1288 
 1289   // Check for second word integer load
 1290   if( dst_second_rc == rc_int &amp;&amp; src_second_rc == rc_stack )
 1291     return impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),dst_second,0x8B,&quot;MOV &quot;,size, st);
 1292 
 1293 
 1294   Unimplemented();
 1295   return 0; // Mute compiler
 1296 }
 1297 
 1298 #ifndef PRODUCT
 1299 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1300   implementation( NULL, ra_, false, st );
 1301 }
 1302 #endif
 1303 
 1304 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1305   implementation( &amp;cbuf, ra_, false, NULL );
 1306 }
 1307 
 1308 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1309   return MachNode::size(ra_);
 1310 }
 1311 
 1312 
 1313 //=============================================================================
 1314 #ifndef PRODUCT
 1315 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1316   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1317   int reg = ra_-&gt;get_reg_first(this);
 1318   st-&gt;print(&quot;LEA    %s,[ESP + #%d]&quot;,Matcher::regName[reg],offset);
 1319 }
 1320 #endif
 1321 
 1322 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1323   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1324   int reg = ra_-&gt;get_encode(this);
 1325   if( offset &gt;= 128 ) {
 1326     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1327     emit_rm(cbuf, 0x2, reg, 0x04);
 1328     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1329     emit_d32(cbuf, offset);
 1330   }
 1331   else {
 1332     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1333     emit_rm(cbuf, 0x1, reg, 0x04);
 1334     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1335     emit_d8(cbuf, offset);
 1336   }
 1337 }
 1338 
 1339 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1340   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1341   if( offset &gt;= 128 ) {
 1342     return 7;
 1343   }
 1344   else {
 1345     return 4;
 1346   }
 1347 }
 1348 
 1349 //=============================================================================
 1350 #ifndef PRODUCT
 1351 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1352   st-&gt;print_cr(  &quot;CMP    EAX,[ECX+4]\t# Inline cache check&quot;);
 1353   st-&gt;print_cr(&quot;\tJNE    SharedRuntime::handle_ic_miss_stub&quot;);
 1354   st-&gt;print_cr(&quot;\tNOP&quot;);
 1355   st-&gt;print_cr(&quot;\tNOP&quot;);
 1356   if( !OptoBreakpoint )
 1357     st-&gt;print_cr(&quot;\tNOP&quot;);
 1358 }
 1359 #endif
 1360 
 1361 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1362   MacroAssembler masm(&amp;cbuf);
 1363 #ifdef ASSERT
 1364   uint insts_size = cbuf.insts_size();
 1365 #endif
 1366   masm.cmpptr(rax, Address(rcx, oopDesc::klass_offset_in_bytes()));
 1367   masm.jump_cc(Assembler::notEqual,
 1368                RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1369   /* WARNING these NOPs are critical so that verified entry point is properly
 1370      aligned for patching by NativeJump::patch_verified_entry() */
 1371   int nops_cnt = 2;
 1372   if( !OptoBreakpoint ) // Leave space for int3
 1373      nops_cnt += 1;
 1374   masm.nop(nops_cnt);
 1375 
 1376   assert(cbuf.insts_size() - insts_size == size(ra_), &quot;checking code size of inline cache node&quot;);
 1377 }
 1378 
 1379 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1380   return OptoBreakpoint ? 11 : 12;
 1381 }
 1382 
 1383 
 1384 //=============================================================================
 1385 
 1386 int Matcher::regnum_to_fpu_offset(int regnum) {
 1387   return regnum - 32; // The FP registers are in the second chunk
 1388 }
 1389 
 1390 // This is UltraSparc specific, true just means we have fast l2f conversion
 1391 const bool Matcher::convL2FSupported(void) {
 1392   return true;
 1393 }
 1394 
 1395 // Is this branch offset short enough that a short branch can be used?
 1396 //
 1397 // NOTE: If the platform does not provide any short branch variants, then
 1398 //       this method should return false for offset 0.
 1399 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1400   // The passed offset is relative to address of the branch.
 1401   // On 86 a branch displacement is calculated relative to address
 1402   // of a next instruction.
 1403   offset -= br_size;
 1404 
 1405   // the short version of jmpConUCF2 contains multiple branches,
 1406   // making the reach slightly less
 1407   if (rule == jmpConUCF2_rule)
 1408     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1409   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1410 }
 1411 
 1412 const bool Matcher::isSimpleConstant64(jlong value) {
 1413   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1414   return false;
 1415 }
 1416 
 1417 // The ecx parameter to rep stos for the ClearArray node is in dwords.
 1418 const bool Matcher::init_array_count_is_in_bytes = false;
 1419 
 1420 // Needs 2 CMOV&#39;s for longs.
 1421 const int Matcher::long_cmove_cost() { return 1; }
 1422 
 1423 // No CMOVF/CMOVD with SSE/SSE2
 1424 const int Matcher::float_cmove_cost() { return (UseSSE&gt;=1) ? ConditionalMoveLimit : 0; }
 1425 
 1426 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1427 const bool Matcher::require_postalloc_expand = false;
 1428 
 1429 // Do we need to mask the count passed to shift instructions or does
 1430 // the cpu only look at the lower 5/6 bits anyway?
 1431 const bool Matcher::need_masked_shift_count = false;
 1432 
 1433 bool Matcher::narrow_oop_use_complex_address() {
 1434   ShouldNotCallThis();
 1435   return true;
 1436 }
 1437 
 1438 bool Matcher::narrow_klass_use_complex_address() {
 1439   ShouldNotCallThis();
 1440   return true;
 1441 }
 1442 
 1443 bool Matcher::const_oop_prefer_decode() {
 1444   ShouldNotCallThis();
 1445   return true;
 1446 }
 1447 
 1448 bool Matcher::const_klass_prefer_decode() {
 1449   ShouldNotCallThis();
 1450   return true;
 1451 }
 1452 
 1453 // Is it better to copy float constants, or load them directly from memory?
 1454 // Intel can load a float constant from a direct address, requiring no
 1455 // extra registers.  Most RISCs will have to materialize an address into a
 1456 // register first, so they would do better to copy the constant from stack.
 1457 const bool Matcher::rematerialize_float_constants = true;
 1458 
 1459 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1460 // needed.  Else we split the double into 2 integer pieces and move it
 1461 // piece-by-piece.  Only happens when passing doubles into C code as the
 1462 // Java calling convention forces doubles to be aligned.
 1463 const bool Matcher::misaligned_doubles_ok = true;
 1464 
 1465 
 1466 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1467   // Get the memory operand from the node
 1468   uint numopnds = node-&gt;num_opnds();        // Virtual call for number of operands
 1469   uint skipped  = node-&gt;oper_input_base();  // Sum of leaves skipped so far
 1470   assert( idx &gt;= skipped, &quot;idx too low in pd_implicit_null_fixup&quot; );
 1471   uint opcnt     = 1;                 // First operand
 1472   uint num_edges = node-&gt;_opnds[1]-&gt;num_edges(); // leaves for first operand
 1473   while( idx &gt;= skipped+num_edges ) {
 1474     skipped += num_edges;
 1475     opcnt++;                          // Bump operand count
 1476     assert( opcnt &lt; numopnds, &quot;Accessing non-existent operand&quot; );
 1477     num_edges = node-&gt;_opnds[opcnt]-&gt;num_edges(); // leaves for next operand
 1478   }
 1479 
 1480   MachOper *memory = node-&gt;_opnds[opcnt];
 1481   MachOper *new_memory = NULL;
 1482   switch (memory-&gt;opcode()) {
 1483   case DIRECT:
 1484   case INDOFFSET32X:
 1485     // No transformation necessary.
 1486     return;
 1487   case INDIRECT:
 1488     new_memory = new indirect_win95_safeOper( );
 1489     break;
 1490   case INDOFFSET8:
 1491     new_memory = new indOffset8_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1492     break;
 1493   case INDOFFSET32:
 1494     new_memory = new indOffset32_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1495     break;
 1496   case INDINDEXOFFSET:
 1497     new_memory = new indIndexOffset_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1498     break;
 1499   case INDINDEXSCALE:
 1500     new_memory = new indIndexScale_win95_safeOper(memory-&gt;scale());
 1501     break;
 1502   case INDINDEXSCALEOFFSET:
 1503     new_memory = new indIndexScaleOffset_win95_safeOper(memory-&gt;scale(), memory-&gt;disp(NULL, NULL, 0));
 1504     break;
 1505   case LOAD_LONG_INDIRECT:
 1506   case LOAD_LONG_INDOFFSET32:
 1507     // Does not use EBP as address register, use { EDX, EBX, EDI, ESI}
 1508     return;
 1509   default:
 1510     assert(false, &quot;unexpected memory operand in pd_implicit_null_fixup()&quot;);
 1511     return;
 1512   }
 1513   node-&gt;_opnds[opcnt] = new_memory;
 1514 }
 1515 
 1516 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1517 const bool Matcher::strict_fp_requires_explicit_rounding = true;
 1518 
 1519 // Are floats conerted to double when stored to stack during deoptimization?
 1520 // On x32 it is stored with convertion only when FPU is used for floats.
 1521 bool Matcher::float_in_double() { return (UseSSE == 0); }
 1522 
 1523 // Do ints take an entire long register or just half?
 1524 const bool Matcher::int_in_long = false;
 1525 
 1526 // Return whether or not this register is ever used as an argument.  This
 1527 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1528 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1529 // arguments in those registers not be available to the callee.
 1530 bool Matcher::can_be_java_arg( int reg ) {
 1531   if(  reg == ECX_num   || reg == EDX_num   ) return true;
 1532   if( (reg == XMM0_num  || reg == XMM1_num ) &amp;&amp; UseSSE&gt;=1 ) return true;
 1533   if( (reg == XMM0b_num || reg == XMM1b_num) &amp;&amp; UseSSE&gt;=2 ) return true;
 1534   return false;
 1535 }
 1536 
 1537 bool Matcher::is_spillable_arg( int reg ) {
 1538   return can_be_java_arg(reg);
 1539 }
 1540 
 1541 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1542   // Use hardware integer DIV instruction when
 1543   // it is faster than a code which use multiply.
 1544   // Only when constant divisor fits into 32 bit
 1545   // (min_jint is excluded to get only correct
 1546   // positive 32 bit values from negative).
 1547   return VM_Version::has_fast_idiv() &amp;&amp;
 1548          (divisor == (int)divisor &amp;&amp; divisor != min_jint);
 1549 }
 1550 
 1551 // Register for DIVI projection of divmodI
 1552 RegMask Matcher::divI_proj_mask() {
 1553   return EAX_REG_mask();
 1554 }
 1555 
 1556 // Register for MODI projection of divmodI
 1557 RegMask Matcher::modI_proj_mask() {
 1558   return EDX_REG_mask();
 1559 }
 1560 
 1561 // Register for DIVL projection of divmodL
 1562 RegMask Matcher::divL_proj_mask() {
 1563   ShouldNotReachHere();
 1564   return RegMask();
 1565 }
 1566 
 1567 // Register for MODL projection of divmodL
 1568 RegMask Matcher::modL_proj_mask() {
 1569   ShouldNotReachHere();
 1570   return RegMask();
 1571 }
 1572 
 1573 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1574   return NO_REG_mask();
 1575 }
 1576 
 1577 // Returns true if the high 32 bits of the value is known to be zero.
 1578 bool is_operand_hi32_zero(Node* n) {
 1579   int opc = n-&gt;Opcode();
 1580   if (opc == Op_AndL) {
 1581     Node* o2 = n-&gt;in(2);
 1582     if (o2-&gt;is_Con() &amp;&amp; (o2-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1583       return true;
 1584     }
 1585   }
 1586   if (opc == Op_ConL &amp;&amp; (n-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1587     return true;
 1588   }
 1589   return false;
 1590 }
 1591 
 1592 %}
 1593 
 1594 //----------ENCODING BLOCK-----------------------------------------------------
 1595 // This block specifies the encoding classes used by the compiler to output
 1596 // byte streams.  Encoding classes generate functions which are called by
 1597 // Machine Instruction Nodes in order to generate the bit encoding of the
 1598 // instruction.  Operands specify their base encoding interface with the
 1599 // interface keyword.  There are currently supported four interfaces,
 1600 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1601 // operand to generate a function which returns its register number when
 1602 // queried.   CONST_INTER causes an operand to generate a function which
 1603 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1604 // operand to generate four functions which return the Base Register, the
 1605 // Index Register, the Scale Value, and the Offset Value of the operand when
 1606 // queried.  COND_INTER causes an operand to generate six functions which
 1607 // return the encoding code (ie - encoding bits for the instruction)
 1608 // associated with each basic boolean condition for a conditional instruction.
 1609 // Instructions specify two basic values for encoding.  They use the
 1610 // ins_encode keyword to specify their encoding class (which must be one of
 1611 // the class names specified in the encoding block), and they use the
 1612 // opcode keyword to specify, in order, their primary, secondary, and
 1613 // tertiary opcode.  Only the opcode sections which a particular instruction
 1614 // needs for encoding need to be specified.
 1615 encode %{
 1616   // Build emit functions for each basic byte or larger field in the intel
 1617   // encoding scheme (opcode, rm, sib, immediate), and call them from C++
 1618   // code in the enc_class source block.  Emit functions will live in the
 1619   // main source block for now.  In future, we can generalize this by
 1620   // adding a syntax that specifies the sizes of fields in an order,
 1621   // so that the adlc can build the emit functions automagically
 1622 
 1623   // Emit primary opcode
 1624   enc_class OpcP %{
 1625     emit_opcode(cbuf, $primary);
 1626   %}
 1627 
 1628   // Emit secondary opcode
 1629   enc_class OpcS %{
 1630     emit_opcode(cbuf, $secondary);
 1631   %}
 1632 
 1633   // Emit opcode directly
 1634   enc_class Opcode(immI d8) %{
 1635     emit_opcode(cbuf, $d8$$constant);
 1636   %}
 1637 
 1638   enc_class SizePrefix %{
 1639     emit_opcode(cbuf,0x66);
 1640   %}
 1641 
 1642   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 1643     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1644   %}
 1645 
 1646   enc_class OpcRegReg (immI opcode, rRegI dst, rRegI src) %{    // OpcRegReg(Many)
 1647     emit_opcode(cbuf,$opcode$$constant);
 1648     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1649   %}
 1650 
 1651   enc_class mov_r32_imm0( rRegI dst ) %{
 1652     emit_opcode( cbuf, 0xB8 + $dst$$reg ); // 0xB8+ rd   -- MOV r32  ,imm32
 1653     emit_d32   ( cbuf, 0x0  );             //                         imm32==0x0
 1654   %}
 1655 
 1656   enc_class cdq_enc %{
 1657     // Full implementation of Java idiv and irem; checks for
 1658     // special case as described in JVM spec., p.243 &amp; p.271.
 1659     //
 1660     //         normal case                           special case
 1661     //
 1662     // input : rax,: dividend                         min_int
 1663     //         reg: divisor                          -1
 1664     //
 1665     // output: rax,: quotient  (= rax, idiv reg)       min_int
 1666     //         rdx: remainder (= rax, irem reg)       0
 1667     //
 1668     //  Code sequnce:
 1669     //
 1670     //  81 F8 00 00 00 80    cmp         rax,80000000h
 1671     //  0F 85 0B 00 00 00    jne         normal_case
 1672     //  33 D2                xor         rdx,edx
 1673     //  83 F9 FF             cmp         rcx,0FFh
 1674     //  0F 84 03 00 00 00    je          done
 1675     //                  normal_case:
 1676     //  99                   cdq
 1677     //  F7 F9                idiv        rax,ecx
 1678     //                  done:
 1679     //
 1680     emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);
 1681     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);
 1682     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     // cmp rax,80000000h
 1683     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);
 1684     emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);
 1685     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // jne normal_case
 1686     emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     // xor rdx,edx
 1687     emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); // cmp rcx,0FFh
 1688     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);
 1689     emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);
 1690     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // je done
 1691     // normal_case:
 1692     emit_opcode(cbuf,0x99);                                         // cdq
 1693     // idiv (note: must be emitted by the user of this rule)
 1694     // normal:
 1695   %}
 1696 
 1697   // Dense encoding for older common ops
 1698   enc_class Opc_plus(immI opcode, rRegI reg) %{
 1699     emit_opcode(cbuf, $opcode$$constant + $reg$$reg);
 1700   %}
 1701 
 1702 
 1703   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1704   enc_class OpcSE (immI imm) %{ // Emit primary opcode and set sign-extend bit
 1705     // Check for 8-bit immediate, and set sign extend bit in opcode
 1706     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1707       emit_opcode(cbuf, $primary | 0x02);
 1708     }
 1709     else {                          // If 32-bit immediate
 1710       emit_opcode(cbuf, $primary);
 1711     }
 1712   %}
 1713 
 1714   enc_class OpcSErm (rRegI dst, immI imm) %{    // OpcSEr/m
 1715     // Emit primary opcode and set sign-extend bit
 1716     // Check for 8-bit immediate, and set sign extend bit in opcode
 1717     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1718       emit_opcode(cbuf, $primary | 0x02);    }
 1719     else {                          // If 32-bit immediate
 1720       emit_opcode(cbuf, $primary);
 1721     }
 1722     // Emit r/m byte with secondary opcode, after primary opcode.
 1723     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1724   %}
 1725 
 1726   enc_class Con8or32 (immI imm) %{    // Con8or32(storeImmI), 8 or 32 bits
 1727     // Check for 8-bit immediate, and set sign extend bit in opcode
 1728     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1729       $$$emit8$imm$$constant;
 1730     }
 1731     else {                          // If 32-bit immediate
 1732       // Output immediate
 1733       $$$emit32$imm$$constant;
 1734     }
 1735   %}
 1736 
 1737   enc_class Long_OpcSErm_Lo(eRegL dst, immL imm) %{
 1738     // Emit primary opcode and set sign-extend bit
 1739     // Check for 8-bit immediate, and set sign extend bit in opcode
 1740     int con = (int)$imm$$constant; // Throw away top bits
 1741     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1742     // Emit r/m byte with secondary opcode, after primary opcode.
 1743     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1744     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1745     else                               emit_d32(cbuf,con);
 1746   %}
 1747 
 1748   enc_class Long_OpcSErm_Hi(eRegL dst, immL imm) %{
 1749     // Emit primary opcode and set sign-extend bit
 1750     // Check for 8-bit immediate, and set sign extend bit in opcode
 1751     int con = (int)($imm$$constant &gt;&gt; 32); // Throw away bottom bits
 1752     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1753     // Emit r/m byte with tertiary opcode, after primary opcode.
 1754     emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));
 1755     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1756     else                               emit_d32(cbuf,con);
 1757   %}
 1758 
 1759   enc_class OpcSReg (rRegI dst) %{    // BSWAP
 1760     emit_cc(cbuf, $secondary, $dst$$reg );
 1761   %}
 1762 
 1763   enc_class bswap_long_bytes(eRegL dst) %{ // BSWAP
 1764     int destlo = $dst$$reg;
 1765     int desthi = HIGH_FROM_LOW(destlo);
 1766     // bswap lo
 1767     emit_opcode(cbuf, 0x0F);
 1768     emit_cc(cbuf, 0xC8, destlo);
 1769     // bswap hi
 1770     emit_opcode(cbuf, 0x0F);
 1771     emit_cc(cbuf, 0xC8, desthi);
 1772     // xchg lo and hi
 1773     emit_opcode(cbuf, 0x87);
 1774     emit_rm(cbuf, 0x3, destlo, desthi);
 1775   %}
 1776 
 1777   enc_class RegOpc (rRegI div) %{    // IDIV, IMOD, JMP indirect, ...
 1778     emit_rm(cbuf, 0x3, $secondary, $div$$reg );
 1779   %}
 1780 
 1781   enc_class enc_cmov(cmpOp cop ) %{ // CMOV
 1782     $$$emit8$primary;
 1783     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 1784   %}
 1785 
 1786   enc_class enc_cmov_dpr(cmpOp cop, regDPR src ) %{ // CMOV
 1787     int op = 0xDA00 + $cop$$cmpcode + ($src$$reg-1);
 1788     emit_d8(cbuf, op &gt;&gt; 8 );
 1789     emit_d8(cbuf, op &amp; 255);
 1790   %}
 1791 
 1792   // emulate a CMOV with a conditional branch around a MOV
 1793   enc_class enc_cmov_branch( cmpOp cop, immI brOffs ) %{ // CMOV
 1794     // Invert sense of branch from sense of CMOV
 1795     emit_cc( cbuf, 0x70, ($cop$$cmpcode^1) );
 1796     emit_d8( cbuf, $brOffs$$constant );
 1797   %}
 1798 
 1799   enc_class enc_PartialSubtypeCheck( ) %{
 1800     Register Redi = as_Register(EDI_enc); // result register
 1801     Register Reax = as_Register(EAX_enc); // super class
 1802     Register Recx = as_Register(ECX_enc); // killed
 1803     Register Resi = as_Register(ESI_enc); // sub class
 1804     Label miss;
 1805 
 1806     MacroAssembler _masm(&amp;cbuf);
 1807     __ check_klass_subtype_slow_path(Resi, Reax, Recx, Redi,
 1808                                      NULL, &amp;miss,
 1809                                      /*set_cond_codes:*/ true);
 1810     if ($primary) {
 1811       __ xorptr(Redi, Redi);
 1812     }
 1813     __ bind(miss);
 1814   %}
 1815 
 1816   enc_class FFree_Float_Stack_All %{    // Free_Float_Stack_All
 1817     MacroAssembler masm(&amp;cbuf);
 1818     int start = masm.offset();
 1819     if (UseSSE &gt;= 2) {
 1820       if (VerifyFPU) {
 1821         masm.verify_FPU(0, &quot;must be empty in SSE2+ mode&quot;);
 1822       }
 1823     } else {
 1824       // External c_calling_convention expects the FPU stack to be &#39;clean&#39;.
 1825       // Compiled code leaves it dirty.  Do cleanup now.
 1826       masm.empty_FPU_stack();
 1827     }
 1828     if (sizeof_FFree_Float_Stack_All == -1) {
 1829       sizeof_FFree_Float_Stack_All = masm.offset() - start;
 1830     } else {
 1831       assert(masm.offset() - start == sizeof_FFree_Float_Stack_All, &quot;wrong size&quot;);
 1832     }
 1833   %}
 1834 
 1835   enc_class Verify_FPU_For_Leaf %{
 1836     if( VerifyFPU ) {
 1837       MacroAssembler masm(&amp;cbuf);
 1838       masm.verify_FPU( -3, &quot;Returning from Runtime Leaf call&quot;);
 1839     }
 1840   %}
 1841 
 1842   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime, Java_To_Runtime_Leaf
 1843     // This is the instruction starting address for relocation info.
 1844     cbuf.set_insts_mark();
 1845     $$$emit8$primary;
 1846     // CALL directly to the runtime
 1847     emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1848                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1849 
 1850     if (UseSSE &gt;= 2) {
 1851       MacroAssembler _masm(&amp;cbuf);
 1852       BasicType rt = tf()-&gt;return_type();
 1853 
 1854       if ((rt == T_FLOAT || rt == T_DOUBLE) &amp;&amp; !return_value_is_used()) {
 1855         // A C runtime call where the return value is unused.  In SSE2+
 1856         // mode the result needs to be removed from the FPU stack.  It&#39;s
 1857         // likely that this function call could be removed by the
 1858         // optimizer if the C function is a pure function.
 1859         __ ffree(0);
 1860       } else if (rt == T_FLOAT) {
 1861         __ lea(rsp, Address(rsp, -4));
 1862         __ fstp_s(Address(rsp, 0));
 1863         __ movflt(xmm0, Address(rsp, 0));
 1864         __ lea(rsp, Address(rsp,  4));
 1865       } else if (rt == T_DOUBLE) {
 1866         __ lea(rsp, Address(rsp, -8));
 1867         __ fstp_d(Address(rsp, 0));
 1868         __ movdbl(xmm0, Address(rsp, 0));
 1869         __ lea(rsp, Address(rsp,  8));
 1870       }
 1871     }
 1872   %}
 1873 
 1874   enc_class pre_call_resets %{
 1875     // If method sets FPU control word restore it here
 1876     debug_only(int off0 = cbuf.insts_size());
 1877     if (ra_-&gt;C-&gt;in_24_bit_fp_mode()) {
 1878       MacroAssembler _masm(&amp;cbuf);
 1879       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
 1880     }
 1881     // Clear upper bits of YMM registers when current compiled code uses
 1882     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 1883     MacroAssembler _masm(&amp;cbuf);
 1884     __ vzeroupper();
 1885     debug_only(int off1 = cbuf.insts_size());
 1886     assert(off1 - off0 == pre_call_resets_size(), &quot;correct size prediction&quot;);
 1887   %}
 1888 
 1889   enc_class post_call_FPU %{
 1890     // If method sets FPU control word do it here also
 1891     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
 1892       MacroAssembler masm(&amp;cbuf);
 1893       masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 1894     }
 1895   %}
 1896 
 1897   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 1898     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1899     // who we intended to call.
 1900     cbuf.set_insts_mark();
 1901     $$$emit8$primary;
 1902 
 1903     if (!_method) {
 1904       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1905                      runtime_call_Relocation::spec(),
 1906                      RELOC_IMM32);
 1907     } else {
 1908       int method_index = resolved_method_index(cbuf);
 1909       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1910                                                   : static_call_Relocation::spec(method_index);
 1911       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1912                      rspec, RELOC_DISP32);
 1913       // Emit stubs for static call.
 1914       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1915       if (stub == NULL) {
 1916         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1917         return;
 1918       }
 1919     }
 1920   %}
 1921 
 1922   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
 1923     MacroAssembler _masm(&amp;cbuf);
 1924     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 1925   %}
 1926 
 1927   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
 1928     int disp = in_bytes(Method::from_compiled_offset());
 1929     assert( -128 &lt;= disp &amp;&amp; disp &lt;= 127, &quot;compiled_code_offset isn&#39;t small&quot;);
 1930 
 1931     // CALL *[EAX+in_bytes(Method::from_compiled_code_entry_point_offset())]
 1932     cbuf.set_insts_mark();
 1933     $$$emit8$primary;
 1934     emit_rm(cbuf, 0x01, $secondary, EAX_enc );  // R/M byte
 1935     emit_d8(cbuf, disp);             // Displacement
 1936 
 1937   %}
 1938 
 1939 //   Following encoding is no longer used, but may be restored if calling
 1940 //   convention changes significantly.
 1941 //   Became: Xor_Reg(EBP), Java_To_Runtime( labl )
 1942 //
 1943 //   enc_class Java_Interpreter_Call (label labl) %{    // JAVA INTERPRETER CALL
 1944 //     // int ic_reg     = Matcher::inline_cache_reg();
 1945 //     // int ic_encode  = Matcher::_regEncode[ic_reg];
 1946 //     // int imo_reg    = Matcher::interpreter_method_oop_reg();
 1947 //     // int imo_encode = Matcher::_regEncode[imo_reg];
 1948 //
 1949 //     // // Interpreter expects method_oop in EBX, currently a callee-saved register,
 1950 //     // // so we load it immediately before the call
 1951 //     // emit_opcode(cbuf, 0x8B);                     // MOV    imo_reg,ic_reg  # method_oop
 1952 //     // emit_rm(cbuf, 0x03, imo_encode, ic_encode ); // R/M byte
 1953 //
 1954 //     // xor rbp,ebp
 1955 //     emit_opcode(cbuf, 0x33);
 1956 //     emit_rm(cbuf, 0x3, EBP_enc, EBP_enc);
 1957 //
 1958 //     // CALL to interpreter.
 1959 //     cbuf.set_insts_mark();
 1960 //     $$$emit8$primary;
 1961 //     emit_d32_reloc(cbuf, ($labl$$label - (int)(cbuf.insts_end()) - 4),
 1962 //                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1963 //   %}
 1964 
 1965   enc_class RegOpcImm (rRegI dst, immI8 shift) %{    // SHL, SAR, SHR
 1966     $$$emit8$primary;
 1967     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1968     $$$emit8$shift$$constant;
 1969   %}
 1970 
 1971   enc_class LdImmI (rRegI dst, immI src) %{    // Load Immediate
 1972     // Load immediate does not have a zero or sign extended version
 1973     // for 8-bit immediates
 1974     emit_opcode(cbuf, 0xB8 + $dst$$reg);
 1975     $$$emit32$src$$constant;
 1976   %}
 1977 
 1978   enc_class LdImmP (rRegI dst, immI src) %{    // Load Immediate
 1979     // Load immediate does not have a zero or sign extended version
 1980     // for 8-bit immediates
 1981     emit_opcode(cbuf, $primary + $dst$$reg);
 1982     $$$emit32$src$$constant;
 1983   %}
 1984 
 1985   enc_class LdImmL_Lo( eRegL dst, immL src) %{    // Load Immediate
 1986     // Load immediate does not have a zero or sign extended version
 1987     // for 8-bit immediates
 1988     int dst_enc = $dst$$reg;
 1989     int src_con = $src$$constant &amp; 0x0FFFFFFFFL;
 1990     if (src_con == 0) {
 1991       // xor dst, dst
 1992       emit_opcode(cbuf, 0x33);
 1993       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 1994     } else {
 1995       emit_opcode(cbuf, $primary + dst_enc);
 1996       emit_d32(cbuf, src_con);
 1997     }
 1998   %}
 1999 
 2000   enc_class LdImmL_Hi( eRegL dst, immL src) %{    // Load Immediate
 2001     // Load immediate does not have a zero or sign extended version
 2002     // for 8-bit immediates
 2003     int dst_enc = $dst$$reg + 2;
 2004     int src_con = ((julong)($src$$constant)) &gt;&gt; 32;
 2005     if (src_con == 0) {
 2006       // xor dst, dst
 2007       emit_opcode(cbuf, 0x33);
 2008       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 2009     } else {
 2010       emit_opcode(cbuf, $primary + dst_enc);
 2011       emit_d32(cbuf, src_con);
 2012     }
 2013   %}
 2014 
 2015 
 2016   // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2017   enc_class enc_Copy( rRegI dst, rRegI src ) %{
 2018     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2019   %}
 2020 
 2021   enc_class enc_CopyL_Lo( rRegI dst, eRegL src ) %{
 2022     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2023   %}
 2024 
 2025   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 2026     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2027   %}
 2028 
 2029   enc_class RegReg_Lo(eRegL dst, eRegL src) %{    // RegReg(Many)
 2030     $$$emit8$primary;
 2031     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2032   %}
 2033 
 2034   enc_class RegReg_Hi(eRegL dst, eRegL src) %{    // RegReg(Many)
 2035     $$$emit8$secondary;
 2036     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2037   %}
 2038 
 2039   enc_class RegReg_Lo2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2040     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2041   %}
 2042 
 2043   enc_class RegReg_Hi2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2044     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2045   %}
 2046 
 2047   enc_class RegReg_HiLo( eRegL src, rRegI dst ) %{
 2048     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));
 2049   %}
 2050 
 2051   enc_class Con32 (immI src) %{    // Con32(storeImmI)
 2052     // Output immediate
 2053     $$$emit32$src$$constant;
 2054   %}
 2055 
 2056   enc_class Con32FPR_as_bits(immFPR src) %{        // storeF_imm
 2057     // Output Float immediate bits
 2058     jfloat jf = $src$$constant;
 2059     int    jf_as_bits = jint_cast( jf );
 2060     emit_d32(cbuf, jf_as_bits);
 2061   %}
 2062 
 2063   enc_class Con32F_as_bits(immF src) %{      // storeX_imm
 2064     // Output Float immediate bits
 2065     jfloat jf = $src$$constant;
 2066     int    jf_as_bits = jint_cast( jf );
 2067     emit_d32(cbuf, jf_as_bits);
 2068   %}
 2069 
 2070   enc_class Con16 (immI src) %{    // Con16(storeImmI)
 2071     // Output immediate
 2072     $$$emit16$src$$constant;
 2073   %}
 2074 
 2075   enc_class Con_d32(immI src) %{
 2076     emit_d32(cbuf,$src$$constant);
 2077   %}
 2078 
 2079   enc_class conmemref (eRegP t1) %{    // Con32(storeImmI)
 2080     // Output immediate memory reference
 2081     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2082     emit_d32(cbuf, 0x00);
 2083   %}
 2084 
 2085   enc_class lock_prefix( ) %{
 2086     emit_opcode(cbuf,0xF0);         // [Lock]
 2087   %}
 2088 
 2089   // Cmp-xchg long value.
 2090   // Note: we need to swap rbx, and rcx before and after the
 2091   //       cmpxchg8 instruction because the instruction uses
 2092   //       rcx as the high order word of the new value to store but
 2093   //       our register encoding uses rbx,.
 2094   enc_class enc_cmpxchg8(eSIRegP mem_ptr) %{
 2095 
 2096     // XCHG  rbx,ecx
 2097     emit_opcode(cbuf,0x87);
 2098     emit_opcode(cbuf,0xD9);
 2099     // [Lock]
 2100     emit_opcode(cbuf,0xF0);
 2101     // CMPXCHG8 [Eptr]
 2102     emit_opcode(cbuf,0x0F);
 2103     emit_opcode(cbuf,0xC7);
 2104     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2105     // XCHG  rbx,ecx
 2106     emit_opcode(cbuf,0x87);
 2107     emit_opcode(cbuf,0xD9);
 2108   %}
 2109 
 2110   enc_class enc_cmpxchg(eSIRegP mem_ptr) %{
 2111     // [Lock]
 2112     emit_opcode(cbuf,0xF0);
 2113 
 2114     // CMPXCHG [Eptr]
 2115     emit_opcode(cbuf,0x0F);
 2116     emit_opcode(cbuf,0xB1);
 2117     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2118   %}
 2119 
 2120   enc_class enc_cmpxchgb(eSIRegP mem_ptr) %{
 2121     // [Lock]
 2122     emit_opcode(cbuf,0xF0);
 2123 
 2124     // CMPXCHGB [Eptr]
 2125     emit_opcode(cbuf,0x0F);
 2126     emit_opcode(cbuf,0xB0);
 2127     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2128   %}
 2129 
 2130   enc_class enc_cmpxchgw(eSIRegP mem_ptr) %{
 2131     // [Lock]
 2132     emit_opcode(cbuf,0xF0);
 2133 
 2134     // 16-bit mode
 2135     emit_opcode(cbuf, 0x66);
 2136 
 2137     // CMPXCHGW [Eptr]
 2138     emit_opcode(cbuf,0x0F);
 2139     emit_opcode(cbuf,0xB1);
 2140     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2141   %}
 2142 
 2143   enc_class enc_flags_ne_to_boolean( iRegI res ) %{
 2144     int res_encoding = $res$$reg;
 2145 
 2146     // MOV  res,0
 2147     emit_opcode( cbuf, 0xB8 + res_encoding);
 2148     emit_d32( cbuf, 0 );
 2149     // JNE,s  fail
 2150     emit_opcode(cbuf,0x75);
 2151     emit_d8(cbuf, 5 );
 2152     // MOV  res,1
 2153     emit_opcode( cbuf, 0xB8 + res_encoding);
 2154     emit_d32( cbuf, 1 );
 2155     // fail:
 2156   %}
 2157 
 2158   enc_class set_instruction_start( ) %{
 2159     cbuf.set_insts_mark();            // Mark start of opcode for reloc info in mem operand
 2160   %}
 2161 
 2162   enc_class RegMem (rRegI ereg, memory mem) %{    // emit_reg_mem
 2163     int reg_encoding = $ereg$$reg;
 2164     int base  = $mem$$base;
 2165     int index = $mem$$index;
 2166     int scale = $mem$$scale;
 2167     int displace = $mem$$disp;
 2168     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2169     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2170   %}
 2171 
 2172   enc_class RegMem_Hi(eRegL ereg, memory mem) %{    // emit_reg_mem
 2173     int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  // Hi register of pair, computed from lo
 2174     int base  = $mem$$base;
 2175     int index = $mem$$index;
 2176     int scale = $mem$$scale;
 2177     int displace = $mem$$disp + 4;      // Offset is 4 further in memory
 2178     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;Cannot add 4 to oop&quot; );
 2179     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, relocInfo::none);
 2180   %}
 2181 
 2182   enc_class move_long_small_shift( eRegL dst, immI_1_31 cnt ) %{
 2183     int r1, r2;
 2184     if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2185     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2186     emit_opcode(cbuf,0x0F);
 2187     emit_opcode(cbuf,$tertiary);
 2188     emit_rm(cbuf, 0x3, r1, r2);
 2189     emit_d8(cbuf,$cnt$$constant);
 2190     emit_d8(cbuf,$primary);
 2191     emit_rm(cbuf, 0x3, $secondary, r1);
 2192     emit_d8(cbuf,$cnt$$constant);
 2193   %}
 2194 
 2195   enc_class move_long_big_shift_sign( eRegL dst, immI_32_63 cnt ) %{
 2196     emit_opcode( cbuf, 0x8B ); // Move
 2197     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2198     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2199       emit_d8(cbuf,$primary);
 2200       emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 2201       emit_d8(cbuf,$cnt$$constant-32);
 2202     }
 2203     emit_d8(cbuf,$primary);
 2204     emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));
 2205     emit_d8(cbuf,31);
 2206   %}
 2207 
 2208   enc_class move_long_big_shift_clr( eRegL dst, immI_32_63 cnt ) %{
 2209     int r1, r2;
 2210     if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2211     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2212 
 2213     emit_opcode( cbuf, 0x8B ); // Move r1,r2
 2214     emit_rm(cbuf, 0x3, r1, r2);
 2215     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2216       emit_opcode(cbuf,$primary);
 2217       emit_rm(cbuf, 0x3, $secondary, r1);
 2218       emit_d8(cbuf,$cnt$$constant-32);
 2219     }
 2220     emit_opcode(cbuf,0x33);  // XOR r2,r2
 2221     emit_rm(cbuf, 0x3, r2, r2);
 2222   %}
 2223 
 2224   // Clone of RegMem but accepts an extra parameter to access each
 2225   // half of a double in memory; it never needs relocation info.
 2226   enc_class Mov_MemD_half_to_Reg (immI opcode, memory mem, immI disp_for_half, rRegI rm_reg) %{
 2227     emit_opcode(cbuf,$opcode$$constant);
 2228     int reg_encoding = $rm_reg$$reg;
 2229     int base     = $mem$$base;
 2230     int index    = $mem$$index;
 2231     int scale    = $mem$$scale;
 2232     int displace = $mem$$disp + $disp_for_half$$constant;
 2233     relocInfo::relocType disp_reloc = relocInfo::none;
 2234     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2235   %}
 2236 
 2237   // !!!!! Special Custom Code used by MemMove, and stack access instructions !!!!!
 2238   //
 2239   // Clone of RegMem except the RM-byte&#39;s reg/opcode field is an ADLC-time constant
 2240   // and it never needs relocation information.
 2241   // Frequently used to move data between FPU&#39;s Stack Top and memory.
 2242   enc_class RMopc_Mem_no_oop (immI rm_opcode, memory mem) %{
 2243     int rm_byte_opcode = $rm_opcode$$constant;
 2244     int base     = $mem$$base;
 2245     int index    = $mem$$index;
 2246     int scale    = $mem$$scale;
 2247     int displace = $mem$$disp;
 2248     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;No oops here because no reloc info allowed&quot; );
 2249     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, relocInfo::none);
 2250   %}
 2251 
 2252   enc_class RMopc_Mem (immI rm_opcode, memory mem) %{
 2253     int rm_byte_opcode = $rm_opcode$$constant;
 2254     int base     = $mem$$base;
 2255     int index    = $mem$$index;
 2256     int scale    = $mem$$scale;
 2257     int displace = $mem$$disp;
 2258     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2259     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 2260   %}
 2261 
 2262   enc_class RegLea (rRegI dst, rRegI src0, immI src1 ) %{    // emit_reg_lea
 2263     int reg_encoding = $dst$$reg;
 2264     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2265     int index        = 0x04;            // 0x04 indicates no index
 2266     int scale        = 0x00;            // 0x00 indicates no scale
 2267     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2268     relocInfo::relocType disp_reloc = relocInfo::none;
 2269     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2270   %}
 2271 
 2272   enc_class min_enc (rRegI dst, rRegI src) %{    // MIN
 2273     // Compare dst,src
 2274     emit_opcode(cbuf,0x3B);
 2275     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2276     // jmp dst &lt; src around move
 2277     emit_opcode(cbuf,0x7C);
 2278     emit_d8(cbuf,2);
 2279     // move dst,src
 2280     emit_opcode(cbuf,0x8B);
 2281     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2282   %}
 2283 
 2284   enc_class max_enc (rRegI dst, rRegI src) %{    // MAX
 2285     // Compare dst,src
 2286     emit_opcode(cbuf,0x3B);
 2287     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2288     // jmp dst &gt; src around move
 2289     emit_opcode(cbuf,0x7F);
 2290     emit_d8(cbuf,2);
 2291     // move dst,src
 2292     emit_opcode(cbuf,0x8B);
 2293     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2294   %}
 2295 
 2296   enc_class enc_FPR_store(memory mem, regDPR src) %{
 2297     // If src is FPR1, we can just FST to store it.
 2298     // Else we need to FLD it to FPR1, then FSTP to store/pop it.
 2299     int reg_encoding = 0x2; // Just store
 2300     int base  = $mem$$base;
 2301     int index = $mem$$index;
 2302     int scale = $mem$$scale;
 2303     int displace = $mem$$disp;
 2304     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2305     if( $src$$reg != FPR1L_enc ) {
 2306       reg_encoding = 0x3;  // Store &amp; pop
 2307       emit_opcode( cbuf, 0xD9 ); // FLD (i.e., push it)
 2308       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2309     }
 2310     cbuf.set_insts_mark();       // Mark start of opcode for reloc info in mem operand
 2311     emit_opcode(cbuf,$primary);
 2312     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2313   %}
 2314 
 2315   enc_class neg_reg(rRegI dst) %{
 2316     // NEG $dst
 2317     emit_opcode(cbuf,0xF7);
 2318     emit_rm(cbuf, 0x3, 0x03, $dst$$reg );
 2319   %}
 2320 
 2321   enc_class setLT_reg(eCXRegI dst) %{
 2322     // SETLT $dst
 2323     emit_opcode(cbuf,0x0F);
 2324     emit_opcode(cbuf,0x9C);
 2325     emit_rm( cbuf, 0x3, 0x4, $dst$$reg );
 2326   %}
 2327 
 2328   enc_class enc_cmpLTP(ncxRegI p, ncxRegI q, ncxRegI y, eCXRegI tmp) %{    // cadd_cmpLT
 2329     int tmpReg = $tmp$$reg;
 2330 
 2331     // SUB $p,$q
 2332     emit_opcode(cbuf,0x2B);
 2333     emit_rm(cbuf, 0x3, $p$$reg, $q$$reg);
 2334     // SBB $tmp,$tmp
 2335     emit_opcode(cbuf,0x1B);
 2336     emit_rm(cbuf, 0x3, tmpReg, tmpReg);
 2337     // AND $tmp,$y
 2338     emit_opcode(cbuf,0x23);
 2339     emit_rm(cbuf, 0x3, tmpReg, $y$$reg);
 2340     // ADD $p,$tmp
 2341     emit_opcode(cbuf,0x03);
 2342     emit_rm(cbuf, 0x3, $p$$reg, tmpReg);
 2343   %}
 2344 
 2345   enc_class shift_left_long( eRegL dst, eCXRegI shift ) %{
 2346     // TEST shift,32
 2347     emit_opcode(cbuf,0xF7);
 2348     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2349     emit_d32(cbuf,0x20);
 2350     // JEQ,s small
 2351     emit_opcode(cbuf, 0x74);
 2352     emit_d8(cbuf, 0x04);
 2353     // MOV    $dst.hi,$dst.lo
 2354     emit_opcode( cbuf, 0x8B );
 2355     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2356     // CLR    $dst.lo
 2357     emit_opcode(cbuf, 0x33);
 2358     emit_rm(cbuf, 0x3, $dst$$reg, $dst$$reg);
 2359 // small:
 2360     // SHLD   $dst.hi,$dst.lo,$shift
 2361     emit_opcode(cbuf,0x0F);
 2362     emit_opcode(cbuf,0xA5);
 2363     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2364     // SHL    $dst.lo,$shift&quot;
 2365     emit_opcode(cbuf,0xD3);
 2366     emit_rm(cbuf, 0x3, 0x4, $dst$$reg );
 2367   %}
 2368 
 2369   enc_class shift_right_long( eRegL dst, eCXRegI shift ) %{
 2370     // TEST shift,32
 2371     emit_opcode(cbuf,0xF7);
 2372     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2373     emit_d32(cbuf,0x20);
 2374     // JEQ,s small
 2375     emit_opcode(cbuf, 0x74);
 2376     emit_d8(cbuf, 0x04);
 2377     // MOV    $dst.lo,$dst.hi
 2378     emit_opcode( cbuf, 0x8B );
 2379     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2380     // CLR    $dst.hi
 2381     emit_opcode(cbuf, 0x33);
 2382     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));
 2383 // small:
 2384     // SHRD   $dst.lo,$dst.hi,$shift
 2385     emit_opcode(cbuf,0x0F);
 2386     emit_opcode(cbuf,0xAD);
 2387     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2388     // SHR    $dst.hi,$shift&quot;
 2389     emit_opcode(cbuf,0xD3);
 2390     emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );
 2391   %}
 2392 
 2393   enc_class shift_right_arith_long( eRegL dst, eCXRegI shift ) %{
 2394     // TEST shift,32
 2395     emit_opcode(cbuf,0xF7);
 2396     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2397     emit_d32(cbuf,0x20);
 2398     // JEQ,s small
 2399     emit_opcode(cbuf, 0x74);
 2400     emit_d8(cbuf, 0x05);
 2401     // MOV    $dst.lo,$dst.hi
 2402     emit_opcode( cbuf, 0x8B );
 2403     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2404     // SAR    $dst.hi,31
 2405     emit_opcode(cbuf, 0xC1);
 2406     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );
 2407     emit_d8(cbuf, 0x1F );
 2408 // small:
 2409     // SHRD   $dst.lo,$dst.hi,$shift
 2410     emit_opcode(cbuf,0x0F);
 2411     emit_opcode(cbuf,0xAD);
 2412     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2413     // SAR    $dst.hi,$shift&quot;
 2414     emit_opcode(cbuf,0xD3);
 2415     emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );
 2416   %}
 2417 
 2418 
 2419   // ----------------- Encodings for floating point unit -----------------
 2420   // May leave result in FPU-TOS or FPU reg depending on opcodes
 2421   enc_class OpcReg_FPR(regFPR src) %{    // FMUL, FDIV
 2422     $$$emit8$primary;
 2423     emit_rm(cbuf, 0x3, $secondary, $src$$reg );
 2424   %}
 2425 
 2426   // Pop argument in FPR0 with FSTP ST(0)
 2427   enc_class PopFPU() %{
 2428     emit_opcode( cbuf, 0xDD );
 2429     emit_d8( cbuf, 0xD8 );
 2430   %}
 2431 
 2432   // !!!!! equivalent to Pop_Reg_F
 2433   enc_class Pop_Reg_DPR( regDPR dst ) %{
 2434     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2435     emit_d8( cbuf, 0xD8+$dst$$reg );
 2436   %}
 2437 
 2438   enc_class Push_Reg_DPR( regDPR dst ) %{
 2439     emit_opcode( cbuf, 0xD9 );
 2440     emit_d8( cbuf, 0xC0-1+$dst$$reg );   // FLD ST(i-1)
 2441   %}
 2442 
 2443   enc_class strictfp_bias1( regDPR dst ) %{
 2444     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2445     emit_opcode( cbuf, 0x2D );
 2446     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias1() );
 2447     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2448     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2449   %}
 2450 
 2451   enc_class strictfp_bias2( regDPR dst ) %{
 2452     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2453     emit_opcode( cbuf, 0x2D );
 2454     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias2() );
 2455     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2456     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2457   %}
 2458 
 2459   // Special case for moving an integer register to a stack slot.
 2460   enc_class OpcPRegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2461     store_to_stackslot( cbuf, $primary, $src$$reg, $dst$$disp );
 2462   %}
 2463 
 2464   // Special case for moving a register to a stack slot.
 2465   enc_class RegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2466     // Opcode already emitted
 2467     emit_rm( cbuf, 0x02, $src$$reg, ESP_enc );   // R/M byte
 2468     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);          // SIB byte
 2469     emit_d32(cbuf, $dst$$disp);   // Displacement
 2470   %}
 2471 
 2472   // Push the integer in stackSlot &#39;src&#39; onto FP-stack
 2473   enc_class Push_Mem_I( memory src ) %{    // FILD   [ESP+src]
 2474     store_to_stackslot( cbuf, $primary, $secondary, $src$$disp );
 2475   %}
 2476 
 2477   // Push FPU&#39;s TOS float to a stack-slot, and pop FPU-stack
 2478   enc_class Pop_Mem_FPR( stackSlotF dst ) %{ // FSTP_S [ESP+dst]
 2479     store_to_stackslot( cbuf, 0xD9, 0x03, $dst$$disp );
 2480   %}
 2481 
 2482   // Same as Pop_Mem_F except for opcode
 2483   // Push FPU&#39;s TOS double to a stack-slot, and pop FPU-stack
 2484   enc_class Pop_Mem_DPR( stackSlotD dst ) %{ // FSTP_D [ESP+dst]
 2485     store_to_stackslot( cbuf, 0xDD, 0x03, $dst$$disp );
 2486   %}
 2487 
 2488   enc_class Pop_Reg_FPR( regFPR dst ) %{
 2489     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2490     emit_d8( cbuf, 0xD8+$dst$$reg );
 2491   %}
 2492 
 2493   enc_class Push_Reg_FPR( regFPR dst ) %{
 2494     emit_opcode( cbuf, 0xD9 );           // FLD    ST(i-1)
 2495     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2496   %}
 2497 
 2498   // Push FPU&#39;s float to a stack-slot, and pop FPU-stack
 2499   enc_class Pop_Mem_Reg_FPR( stackSlotF dst, regFPR src ) %{
 2500     int pop = 0x02;
 2501     if ($src$$reg != FPR1L_enc) {
 2502       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2503       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2504       pop = 0x03;
 2505     }
 2506     store_to_stackslot( cbuf, 0xD9, pop, $dst$$disp ); // FST&lt;P&gt;_S  [ESP+dst]
 2507   %}
 2508 
 2509   // Push FPU&#39;s double to a stack-slot, and pop FPU-stack
 2510   enc_class Pop_Mem_Reg_DPR( stackSlotD dst, regDPR src ) %{
 2511     int pop = 0x02;
 2512     if ($src$$reg != FPR1L_enc) {
 2513       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2514       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2515       pop = 0x03;
 2516     }
 2517     store_to_stackslot( cbuf, 0xDD, pop, $dst$$disp ); // FST&lt;P&gt;_D  [ESP+dst]
 2518   %}
 2519 
 2520   // Push FPU&#39;s double to a FPU-stack-slot, and pop FPU-stack
 2521   enc_class Pop_Reg_Reg_DPR( regDPR dst, regFPR src ) %{
 2522     int pop = 0xD0 - 1; // -1 since we skip FLD
 2523     if ($src$$reg != FPR1L_enc) {
 2524       emit_opcode( cbuf, 0xD9 );         // FLD    ST(src-1)
 2525       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2526       pop = 0xD8;
 2527     }
 2528     emit_opcode( cbuf, 0xDD );
 2529     emit_d8( cbuf, pop+$dst$$reg );      // FST&lt;P&gt; ST(i)
 2530   %}
 2531 
 2532 
 2533   enc_class Push_Reg_Mod_DPR( regDPR dst, regDPR src) %{
 2534     // load dst in FPR0
 2535     emit_opcode( cbuf, 0xD9 );
 2536     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2537     if ($src$$reg != FPR1L_enc) {
 2538       // fincstp
 2539       emit_opcode (cbuf, 0xD9);
 2540       emit_opcode (cbuf, 0xF7);
 2541       // swap src with FPR1:
 2542       // FXCH FPR1 with src
 2543       emit_opcode(cbuf, 0xD9);
 2544       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2545       // fdecstp
 2546       emit_opcode (cbuf, 0xD9);
 2547       emit_opcode (cbuf, 0xF6);
 2548     }
 2549   %}
 2550 
 2551   enc_class Push_ModD_encoding(regD src0, regD src1) %{
 2552     MacroAssembler _masm(&amp;cbuf);
 2553     __ subptr(rsp, 8);
 2554     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
 2555     __ fld_d(Address(rsp, 0));
 2556     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
 2557     __ fld_d(Address(rsp, 0));
 2558   %}
 2559 
 2560   enc_class Push_ModF_encoding(regF src0, regF src1) %{
 2561     MacroAssembler _masm(&amp;cbuf);
 2562     __ subptr(rsp, 4);
 2563     __ movflt(Address(rsp, 0), $src1$$XMMRegister);
 2564     __ fld_s(Address(rsp, 0));
 2565     __ movflt(Address(rsp, 0), $src0$$XMMRegister);
 2566     __ fld_s(Address(rsp, 0));
 2567   %}
 2568 
 2569   enc_class Push_ResultD(regD dst) %{
 2570     MacroAssembler _masm(&amp;cbuf);
 2571     __ fstp_d(Address(rsp, 0));
 2572     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2573     __ addptr(rsp, 8);
 2574   %}
 2575 
 2576   enc_class Push_ResultF(regF dst, immI d8) %{
 2577     MacroAssembler _masm(&amp;cbuf);
 2578     __ fstp_s(Address(rsp, 0));
 2579     __ movflt($dst$$XMMRegister, Address(rsp, 0));
 2580     __ addptr(rsp, $d8$$constant);
 2581   %}
 2582 
 2583   enc_class Push_SrcD(regD src) %{
 2584     MacroAssembler _masm(&amp;cbuf);
 2585     __ subptr(rsp, 8);
 2586     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2587     __ fld_d(Address(rsp, 0));
 2588   %}
 2589 
 2590   enc_class push_stack_temp_qword() %{
 2591     MacroAssembler _masm(&amp;cbuf);
 2592     __ subptr(rsp, 8);
 2593   %}
 2594 
 2595   enc_class pop_stack_temp_qword() %{
 2596     MacroAssembler _masm(&amp;cbuf);
 2597     __ addptr(rsp, 8);
 2598   %}
 2599 
 2600   enc_class push_xmm_to_fpr1(regD src) %{
 2601     MacroAssembler _masm(&amp;cbuf);
 2602     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2603     __ fld_d(Address(rsp, 0));
 2604   %}
 2605 
 2606   enc_class Push_Result_Mod_DPR( regDPR src) %{
 2607     if ($src$$reg != FPR1L_enc) {
 2608       // fincstp
 2609       emit_opcode (cbuf, 0xD9);
 2610       emit_opcode (cbuf, 0xF7);
 2611       // FXCH FPR1 with src
 2612       emit_opcode(cbuf, 0xD9);
 2613       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2614       // fdecstp
 2615       emit_opcode (cbuf, 0xD9);
 2616       emit_opcode (cbuf, 0xF6);
 2617     }
 2618     // // following asm replaced with Pop_Reg_F or Pop_Mem_F
 2619     // // FSTP   FPR$dst$$reg
 2620     // emit_opcode( cbuf, 0xDD );
 2621     // emit_d8( cbuf, 0xD8+$dst$$reg );
 2622   %}
 2623 
 2624   enc_class fnstsw_sahf_skip_parity() %{
 2625     // fnstsw ax
 2626     emit_opcode( cbuf, 0xDF );
 2627     emit_opcode( cbuf, 0xE0 );
 2628     // sahf
 2629     emit_opcode( cbuf, 0x9E );
 2630     // jnp  ::skip
 2631     emit_opcode( cbuf, 0x7B );
 2632     emit_opcode( cbuf, 0x05 );
 2633   %}
 2634 
 2635   enc_class emitModDPR() %{
 2636     // fprem must be iterative
 2637     // :: loop
 2638     // fprem
 2639     emit_opcode( cbuf, 0xD9 );
 2640     emit_opcode( cbuf, 0xF8 );
 2641     // wait
 2642     emit_opcode( cbuf, 0x9b );
 2643     // fnstsw ax
 2644     emit_opcode( cbuf, 0xDF );
 2645     emit_opcode( cbuf, 0xE0 );
 2646     // sahf
 2647     emit_opcode( cbuf, 0x9E );
 2648     // jp  ::loop
 2649     emit_opcode( cbuf, 0x0F );
 2650     emit_opcode( cbuf, 0x8A );
 2651     emit_opcode( cbuf, 0xF4 );
 2652     emit_opcode( cbuf, 0xFF );
 2653     emit_opcode( cbuf, 0xFF );
 2654     emit_opcode( cbuf, 0xFF );
 2655   %}
 2656 
 2657   enc_class fpu_flags() %{
 2658     // fnstsw_ax
 2659     emit_opcode( cbuf, 0xDF);
 2660     emit_opcode( cbuf, 0xE0);
 2661     // test ax,0x0400
 2662     emit_opcode( cbuf, 0x66 );   // operand-size prefix for 16-bit immediate
 2663     emit_opcode( cbuf, 0xA9 );
 2664     emit_d16   ( cbuf, 0x0400 );
 2665     // // // This sequence works, but stalls for 12-16 cycles on PPro
 2666     // // test rax,0x0400
 2667     // emit_opcode( cbuf, 0xA9 );
 2668     // emit_d32   ( cbuf, 0x00000400 );
 2669     //
 2670     // jz exit (no unordered comparison)
 2671     emit_opcode( cbuf, 0x74 );
 2672     emit_d8    ( cbuf, 0x02 );
 2673     // mov ah,1 - treat as LT case (set carry flag)
 2674     emit_opcode( cbuf, 0xB4 );
 2675     emit_d8    ( cbuf, 0x01 );
 2676     // sahf
 2677     emit_opcode( cbuf, 0x9E);
 2678   %}
 2679 
 2680   enc_class cmpF_P6_fixup() %{
 2681     // Fixup the integer flags in case comparison involved a NaN
 2682     //
 2683     // JNP exit (no unordered comparison, P-flag is set by NaN)
 2684     emit_opcode( cbuf, 0x7B );
 2685     emit_d8    ( cbuf, 0x03 );
 2686     // MOV AH,1 - treat as LT case (set carry flag)
 2687     emit_opcode( cbuf, 0xB4 );
 2688     emit_d8    ( cbuf, 0x01 );
 2689     // SAHF
 2690     emit_opcode( cbuf, 0x9E);
 2691     // NOP     // target for branch to avoid branch to branch
 2692     emit_opcode( cbuf, 0x90);
 2693   %}
 2694 
 2695 //     fnstsw_ax();
 2696 //     sahf();
 2697 //     movl(dst, nan_result);
 2698 //     jcc(Assembler::parity, exit);
 2699 //     movl(dst, less_result);
 2700 //     jcc(Assembler::below, exit);
 2701 //     movl(dst, equal_result);
 2702 //     jcc(Assembler::equal, exit);
 2703 //     movl(dst, greater_result);
 2704 
 2705 // less_result     =  1;
 2706 // greater_result  = -1;
 2707 // equal_result    = 0;
 2708 // nan_result      = -1;
 2709 
 2710   enc_class CmpF_Result(rRegI dst) %{
 2711     // fnstsw_ax();
 2712     emit_opcode( cbuf, 0xDF);
 2713     emit_opcode( cbuf, 0xE0);
 2714     // sahf
 2715     emit_opcode( cbuf, 0x9E);
 2716     // movl(dst, nan_result);
 2717     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2718     emit_d32( cbuf, -1 );
 2719     // jcc(Assembler::parity, exit);
 2720     emit_opcode( cbuf, 0x7A );
 2721     emit_d8    ( cbuf, 0x13 );
 2722     // movl(dst, less_result);
 2723     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2724     emit_d32( cbuf, -1 );
 2725     // jcc(Assembler::below, exit);
 2726     emit_opcode( cbuf, 0x72 );
 2727     emit_d8    ( cbuf, 0x0C );
 2728     // movl(dst, equal_result);
 2729     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2730     emit_d32( cbuf, 0 );
 2731     // jcc(Assembler::equal, exit);
 2732     emit_opcode( cbuf, 0x74 );
 2733     emit_d8    ( cbuf, 0x05 );
 2734     // movl(dst, greater_result);
 2735     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2736     emit_d32( cbuf, 1 );
 2737   %}
 2738 
 2739 
 2740   // Compare the longs and set flags
 2741   // BROKEN!  Do Not use as-is
 2742   enc_class cmpl_test( eRegL src1, eRegL src2 ) %{
 2743     // CMP    $src1.hi,$src2.hi
 2744     emit_opcode( cbuf, 0x3B );
 2745     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2746     // JNE,s  done
 2747     emit_opcode(cbuf,0x75);
 2748     emit_d8(cbuf, 2 );
 2749     // CMP    $src1.lo,$src2.lo
 2750     emit_opcode( cbuf, 0x3B );
 2751     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2752 // done:
 2753   %}
 2754 
 2755   enc_class convert_int_long( regL dst, rRegI src ) %{
 2756     // mov $dst.lo,$src
 2757     int dst_encoding = $dst$$reg;
 2758     int src_encoding = $src$$reg;
 2759     encode_Copy( cbuf, dst_encoding  , src_encoding );
 2760     // mov $dst.hi,$src
 2761     encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );
 2762     // sar $dst.hi,31
 2763     emit_opcode( cbuf, 0xC1 );
 2764     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );
 2765     emit_d8(cbuf, 0x1F );
 2766   %}
 2767 
 2768   enc_class convert_long_double( eRegL src ) %{
 2769     // push $src.hi
 2770     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2771     // push $src.lo
 2772     emit_opcode(cbuf, 0x50+$src$$reg  );
 2773     // fild 64-bits at [SP]
 2774     emit_opcode(cbuf,0xdf);
 2775     emit_d8(cbuf, 0x6C);
 2776     emit_d8(cbuf, 0x24);
 2777     emit_d8(cbuf, 0x00);
 2778     // pop stack
 2779     emit_opcode(cbuf, 0x83); // add  SP, #8
 2780     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2781     emit_d8(cbuf, 0x8);
 2782   %}
 2783 
 2784   enc_class multiply_con_and_shift_high( eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr ) %{
 2785     // IMUL   EDX:EAX,$src1
 2786     emit_opcode( cbuf, 0xF7 );
 2787     emit_rm( cbuf, 0x3, 0x5, $src1$$reg );
 2788     // SAR    EDX,$cnt-32
 2789     int shift_count = ((int)$cnt$$constant) - 32;
 2790     if (shift_count &gt; 0) {
 2791       emit_opcode(cbuf, 0xC1);
 2792       emit_rm(cbuf, 0x3, 7, $dst$$reg );
 2793       emit_d8(cbuf, shift_count);
 2794     }
 2795   %}
 2796 
 2797   // this version doesn&#39;t have add sp, 8
 2798   enc_class convert_long_double2( eRegL src ) %{
 2799     // push $src.hi
 2800     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2801     // push $src.lo
 2802     emit_opcode(cbuf, 0x50+$src$$reg  );
 2803     // fild 64-bits at [SP]
 2804     emit_opcode(cbuf,0xdf);
 2805     emit_d8(cbuf, 0x6C);
 2806     emit_d8(cbuf, 0x24);
 2807     emit_d8(cbuf, 0x00);
 2808   %}
 2809 
 2810   enc_class long_int_multiply( eADXRegL dst, nadxRegI src) %{
 2811     // Basic idea: long = (long)int * (long)int
 2812     // IMUL EDX:EAX, src
 2813     emit_opcode( cbuf, 0xF7 );
 2814     emit_rm( cbuf, 0x3, 0x5, $src$$reg);
 2815   %}
 2816 
 2817   enc_class long_uint_multiply( eADXRegL dst, nadxRegI src) %{
 2818     // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 2819     // MUL EDX:EAX, src
 2820     emit_opcode( cbuf, 0xF7 );
 2821     emit_rm( cbuf, 0x3, 0x4, $src$$reg);
 2822   %}
 2823 
 2824   enc_class long_multiply( eADXRegL dst, eRegL src, rRegI tmp ) %{
 2825     // Basic idea: lo(result) = lo(x_lo * y_lo)
 2826     //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 2827     // MOV    $tmp,$src.lo
 2828     encode_Copy( cbuf, $tmp$$reg, $src$$reg );
 2829     // IMUL   $tmp,EDX
 2830     emit_opcode( cbuf, 0x0F );
 2831     emit_opcode( cbuf, 0xAF );
 2832     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2833     // MOV    EDX,$src.hi
 2834     encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );
 2835     // IMUL   EDX,EAX
 2836     emit_opcode( cbuf, 0x0F );
 2837     emit_opcode( cbuf, 0xAF );
 2838     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2839     // ADD    $tmp,EDX
 2840     emit_opcode( cbuf, 0x03 );
 2841     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2842     // MUL   EDX:EAX,$src.lo
 2843     emit_opcode( cbuf, 0xF7 );
 2844     emit_rm( cbuf, 0x3, 0x4, $src$$reg );
 2845     // ADD    EDX,ESI
 2846     emit_opcode( cbuf, 0x03 );
 2847     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );
 2848   %}
 2849 
 2850   enc_class long_multiply_con( eADXRegL dst, immL_127 src, rRegI tmp ) %{
 2851     // Basic idea: lo(result) = lo(src * y_lo)
 2852     //             hi(result) = hi(src * y_lo) + lo(src * y_hi)
 2853     // IMUL   $tmp,EDX,$src
 2854     emit_opcode( cbuf, 0x6B );
 2855     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2856     emit_d8( cbuf, (int)$src$$constant );
 2857     // MOV    EDX,$src
 2858     emit_opcode(cbuf, 0xB8 + EDX_enc);
 2859     emit_d32( cbuf, (int)$src$$constant );
 2860     // MUL   EDX:EAX,EDX
 2861     emit_opcode( cbuf, 0xF7 );
 2862     emit_rm( cbuf, 0x3, 0x4, EDX_enc );
 2863     // ADD    EDX,ESI
 2864     emit_opcode( cbuf, 0x03 );
 2865     emit_rm( cbuf, 0x3, EDX_enc, $tmp$$reg );
 2866   %}
 2867 
 2868   enc_class long_div( eRegL src1, eRegL src2 ) %{
 2869     // PUSH src1.hi
 2870     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2871     // PUSH src1.lo
 2872     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2873     // PUSH src2.hi
 2874     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2875     // PUSH src2.lo
 2876     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2877     // CALL directly to the runtime
 2878     cbuf.set_insts_mark();
 2879     emit_opcode(cbuf,0xE8);       // Call into runtime
 2880     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2881     // Restore stack
 2882     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2883     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2884     emit_d8(cbuf, 4*4);
 2885   %}
 2886 
 2887   enc_class long_mod( eRegL src1, eRegL src2 ) %{
 2888     // PUSH src1.hi
 2889     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2890     // PUSH src1.lo
 2891     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2892     // PUSH src2.hi
 2893     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2894     // PUSH src2.lo
 2895     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2896     // CALL directly to the runtime
 2897     cbuf.set_insts_mark();
 2898     emit_opcode(cbuf,0xE8);       // Call into runtime
 2899     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2900     // Restore stack
 2901     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2902     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2903     emit_d8(cbuf, 4*4);
 2904   %}
 2905 
 2906   enc_class long_cmp_flags0( eRegL src, rRegI tmp ) %{
 2907     // MOV   $tmp,$src.lo
 2908     emit_opcode(cbuf, 0x8B);
 2909     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg);
 2910     // OR    $tmp,$src.hi
 2911     emit_opcode(cbuf, 0x0B);
 2912     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));
 2913   %}
 2914 
 2915   enc_class long_cmp_flags1( eRegL src1, eRegL src2 ) %{
 2916     // CMP    $src1.lo,$src2.lo
 2917     emit_opcode( cbuf, 0x3B );
 2918     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2919     // JNE,s  skip
 2920     emit_cc(cbuf, 0x70, 0x5);
 2921     emit_d8(cbuf,2);
 2922     // CMP    $src1.hi,$src2.hi
 2923     emit_opcode( cbuf, 0x3B );
 2924     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2925   %}
 2926 
 2927   enc_class long_cmp_flags2( eRegL src1, eRegL src2, rRegI tmp ) %{
 2928     // CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits
 2929     emit_opcode( cbuf, 0x3B );
 2930     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2931     // MOV    $tmp,$src1.hi
 2932     emit_opcode( cbuf, 0x8B );
 2933     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );
 2934     // SBB   $tmp,$src2.hi\t! Compute flags for long compare
 2935     emit_opcode( cbuf, 0x1B );
 2936     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );
 2937   %}
 2938 
 2939   enc_class long_cmp_flags3( eRegL src, rRegI tmp ) %{
 2940     // XOR    $tmp,$tmp
 2941     emit_opcode(cbuf,0x33);  // XOR
 2942     emit_rm(cbuf,0x3, $tmp$$reg, $tmp$$reg);
 2943     // CMP    $tmp,$src.lo
 2944     emit_opcode( cbuf, 0x3B );
 2945     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg );
 2946     // SBB    $tmp,$src.hi
 2947     emit_opcode( cbuf, 0x1B );
 2948     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );
 2949   %}
 2950 
 2951  // Sniff, sniff... smells like Gnu Superoptimizer
 2952   enc_class neg_long( eRegL dst ) %{
 2953     emit_opcode(cbuf,0xF7);    // NEG hi
 2954     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2955     emit_opcode(cbuf,0xF7);    // NEG lo
 2956     emit_rm    (cbuf,0x3, 0x3,               $dst$$reg );
 2957     emit_opcode(cbuf,0x83);    // SBB hi,0
 2958     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2959     emit_d8    (cbuf,0 );
 2960   %}
 2961 
 2962   enc_class enc_pop_rdx() %{
 2963     emit_opcode(cbuf,0x5A);
 2964   %}
 2965 
 2966   enc_class enc_rethrow() %{
 2967     cbuf.set_insts_mark();
 2968     emit_opcode(cbuf, 0xE9);        // jmp    entry
 2969     emit_d32_reloc(cbuf, (int)OptoRuntime::rethrow_stub() - ((int)cbuf.insts_end())-4,
 2970                    runtime_call_Relocation::spec(), RELOC_IMM32 );
 2971   %}
 2972 
 2973 
 2974   // Convert a double to an int.  Java semantics require we do complex
 2975   // manglelations in the corner cases.  So we set the rounding mode to
 2976   // &#39;zero&#39;, store the darned double down as an int, and reset the
 2977   // rounding mode to &#39;nearest&#39;.  The hardware throws an exception which
 2978   // patches up the correct value directly to the stack.
 2979   enc_class DPR2I_encoding( regDPR src ) %{
 2980     // Flip to round-to-zero mode.  We attempted to allow invalid-op
 2981     // exceptions here, so that a NAN or other corner-case value will
 2982     // thrown an exception (but normal values get converted at full speed).
 2983     // However, I2C adapters and other float-stack manglers leave pending
 2984     // invalid-op exceptions hanging.  We would have to clear them before
 2985     // enabling them and that is more expensive than just testing for the
 2986     // invalid value Intel stores down in the corner cases.
 2987     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 2988     emit_opcode(cbuf,0x2D);
 2989     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 2990     // Allocate a word
 2991     emit_opcode(cbuf,0x83);            // SUB ESP,4
 2992     emit_opcode(cbuf,0xEC);
 2993     emit_d8(cbuf,0x04);
 2994     // Encoding assumes a double has been pushed into FPR0.
 2995     // Store down the double as an int, popping the FPU stack
 2996     emit_opcode(cbuf,0xDB);            // FISTP [ESP]
 2997     emit_opcode(cbuf,0x1C);
 2998     emit_d8(cbuf,0x24);
 2999     // Restore the rounding mode; mask the exception
 3000     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 3001     emit_opcode(cbuf,0x2D);
 3002     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 3003         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 3004         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 3005 
 3006     // Load the converted int; adjust CPU stack
 3007     emit_opcode(cbuf,0x58);       // POP EAX
 3008     emit_opcode(cbuf,0x3D);       // CMP EAX,imm
 3009     emit_d32   (cbuf,0x80000000); //         0x80000000
 3010     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3011     emit_d8    (cbuf,0x07);       // Size of slow_call
 3012     // Push src onto stack slow-path
 3013     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3014     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3015     // CALL directly to the runtime
 3016     cbuf.set_insts_mark();
 3017     emit_opcode(cbuf,0xE8);       // Call into runtime
 3018     emit_d32_reloc(cbuf, (StubRoutines::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3019     // Carry on here...
 3020   %}
 3021 
 3022   enc_class DPR2L_encoding( regDPR src ) %{
 3023     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 3024     emit_opcode(cbuf,0x2D);
 3025     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 3026     // Allocate a word
 3027     emit_opcode(cbuf,0x83);            // SUB ESP,8
 3028     emit_opcode(cbuf,0xEC);
 3029     emit_d8(cbuf,0x08);
 3030     // Encoding assumes a double has been pushed into FPR0.
 3031     // Store down the double as a long, popping the FPU stack
 3032     emit_opcode(cbuf,0xDF);            // FISTP [ESP]
 3033     emit_opcode(cbuf,0x3C);
 3034     emit_d8(cbuf,0x24);
 3035     // Restore the rounding mode; mask the exception
 3036     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 3037     emit_opcode(cbuf,0x2D);
 3038     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 3039         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 3040         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 3041 
 3042     // Load the converted int; adjust CPU stack
 3043     emit_opcode(cbuf,0x58);       // POP EAX
 3044     emit_opcode(cbuf,0x5A);       // POP EDX
 3045     emit_opcode(cbuf,0x81);       // CMP EDX,imm
 3046     emit_d8    (cbuf,0xFA);       // rdx
 3047     emit_d32   (cbuf,0x80000000); //         0x80000000
 3048     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3049     emit_d8    (cbuf,0x07+4);     // Size of slow_call
 3050     emit_opcode(cbuf,0x85);       // TEST EAX,EAX
 3051     emit_opcode(cbuf,0xC0);       // 2/rax,/rax,
 3052     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3053     emit_d8    (cbuf,0x07);       // Size of slow_call
 3054     // Push src onto stack slow-path
 3055     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3056     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3057     // CALL directly to the runtime
 3058     cbuf.set_insts_mark();
 3059     emit_opcode(cbuf,0xE8);       // Call into runtime
 3060     emit_d32_reloc(cbuf, (StubRoutines::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3061     // Carry on here...
 3062   %}
 3063 
 3064   enc_class FMul_ST_reg( eRegFPR src1 ) %{
 3065     // Operand was loaded from memory into fp ST (stack top)
 3066     // FMUL   ST,$src  /* D8 C8+i */
 3067     emit_opcode(cbuf, 0xD8);
 3068     emit_opcode(cbuf, 0xC8 + $src1$$reg);
 3069   %}
 3070 
 3071   enc_class FAdd_ST_reg( eRegFPR src2 ) %{
 3072     // FADDP  ST,src2  /* D8 C0+i */
 3073     emit_opcode(cbuf, 0xD8);
 3074     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3075     //could use FADDP  src2,fpST  /* DE C0+i */
 3076   %}
 3077 
 3078   enc_class FAddP_reg_ST( eRegFPR src2 ) %{
 3079     // FADDP  src2,ST  /* DE C0+i */
 3080     emit_opcode(cbuf, 0xDE);
 3081     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3082   %}
 3083 
 3084   enc_class subFPR_divFPR_encode( eRegFPR src1, eRegFPR src2) %{
 3085     // Operand has been loaded into fp ST (stack top)
 3086       // FSUB   ST,$src1
 3087       emit_opcode(cbuf, 0xD8);
 3088       emit_opcode(cbuf, 0xE0 + $src1$$reg);
 3089 
 3090       // FDIV
 3091       emit_opcode(cbuf, 0xD8);
 3092       emit_opcode(cbuf, 0xF0 + $src2$$reg);
 3093   %}
 3094 
 3095   enc_class MulFAddF (eRegFPR src1, eRegFPR src2) %{
 3096     // Operand was loaded from memory into fp ST (stack top)
 3097     // FADD   ST,$src  /* D8 C0+i */
 3098     emit_opcode(cbuf, 0xD8);
 3099     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3100 
 3101     // FMUL  ST,src2  /* D8 C*+i */
 3102     emit_opcode(cbuf, 0xD8);
 3103     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3104   %}
 3105 
 3106 
 3107   enc_class MulFAddFreverse (eRegFPR src1, eRegFPR src2) %{
 3108     // Operand was loaded from memory into fp ST (stack top)
 3109     // FADD   ST,$src  /* D8 C0+i */
 3110     emit_opcode(cbuf, 0xD8);
 3111     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3112 
 3113     // FMULP  src2,ST  /* DE C8+i */
 3114     emit_opcode(cbuf, 0xDE);
 3115     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3116   %}
 3117 
 3118   // Atomically load the volatile long
 3119   enc_class enc_loadL_volatile( memory mem, stackSlotL dst ) %{
 3120     emit_opcode(cbuf,0xDF);
 3121     int rm_byte_opcode = 0x05;
 3122     int base     = $mem$$base;
 3123     int index    = $mem$$index;
 3124     int scale    = $mem$$scale;
 3125     int displace = $mem$$disp;
 3126     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3127     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3128     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3129   %}
 3130 
 3131   // Volatile Store Long.  Must be atomic, so move it into
 3132   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3133   // target address before the store (for null-ptr checks)
 3134   // so the memory operand is used twice in the encoding.
 3135   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3136     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3137     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3138     emit_opcode(cbuf,0xDF);
 3139     int rm_byte_opcode = 0x07;
 3140     int base     = $mem$$base;
 3141     int index    = $mem$$index;
 3142     int scale    = $mem$$scale;
 3143     int displace = $mem$$disp;
 3144     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3145     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3146   %}
 3147 
<a name="5" id="anc5"></a><span class="line-removed"> 3148   // Safepoint Poll.  This polls the safepoint page, and causes an</span>
<span class="line-removed"> 3149   // exception if it is not readable. Unfortunately, it kills the condition code</span>
<span class="line-removed"> 3150   // in the process</span>
<span class="line-removed"> 3151   // We current use TESTL [spp],EDI</span>
<span class="line-removed"> 3152   // A better choice might be TESTB [spp + pagesize() - CacheLineSize()],0</span>
<span class="line-removed"> 3153 </span>
<span class="line-removed"> 3154   enc_class Safepoint_Poll() %{</span>
<span class="line-removed"> 3155     cbuf.relocate(cbuf.insts_mark(), relocInfo::poll_type, 0);</span>
<span class="line-removed"> 3156     emit_opcode(cbuf,0x85);</span>
<span class="line-removed"> 3157     emit_rm (cbuf, 0x0, 0x7, 0x5);</span>
<span class="line-removed"> 3158     emit_d32(cbuf, (intptr_t)os::get_polling_page());</span>
<span class="line-removed"> 3159   %}</span>
 3160 %}
 3161 
 3162 
 3163 //----------FRAME--------------------------------------------------------------
 3164 // Definition of frame structure and management information.
 3165 //
 3166 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3167 //                             |   (to get allocators register number
 3168 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3169 //  r   CALLER     |        |
 3170 //  o     |        +--------+      pad to even-align allocators stack-slot
 3171 //  w     V        |  pad0  |        numbers; owned by CALLER
 3172 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3173 //  h     ^        |   in   |  5
 3174 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3175 //  |     |        |        |  3
 3176 //  |     |        +--------+
 3177 //  V     |        | old out|      Empty on Intel, window on Sparc
 3178 //        |    old |preserve|      Must be even aligned.
 3179 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 3180 //        |        |   in   |  3   area for Intel ret address
 3181 //     Owned by    |preserve|      Empty on Sparc.
 3182 //       SELF      +--------+
 3183 //        |        |  pad2  |  2   pad to align old SP
 3184 //        |        +--------+  1
 3185 //        |        | locks  |  0
 3186 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 3187 //        |        |  pad1  | 11   pad to align new SP
 3188 //        |        +--------+
 3189 //        |        |        | 10
 3190 //        |        | spills |  9   spills
 3191 //        V        |        |  8   (pad0 slot for callee)
 3192 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 3193 //        ^        |  out   |  7
 3194 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 3195 //     Owned by    +--------+
 3196 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 3197 //        |    new |preserve|      Must be even-aligned.
 3198 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 3199 //        |        |        |
 3200 //
 3201 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 3202 //         known from SELF&#39;s arguments and the Java calling convention.
 3203 //         Region 6-7 is determined per call site.
 3204 // Note 2: If the calling convention leaves holes in the incoming argument
 3205 //         area, those holes are owned by SELF.  Holes in the outgoing area
 3206 //         are owned by the CALLEE.  Holes should not be nessecary in the
 3207 //         incoming area, as the Java calling convention is completely under
 3208 //         the control of the AD file.  Doubles can be sorted and packed to
 3209 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 3210 //         varargs C calling conventions.
 3211 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 3212 //         even aligned with pad0 as needed.
 3213 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 3214 //         region 6-11 is even aligned; it may be padded out more so that
 3215 //         the region from SP to FP meets the minimum stack alignment.
 3216 
 3217 frame %{
 3218   // What direction does stack grow in (assumed to be same for C &amp; Java)
 3219   stack_direction(TOWARDS_LOW);
 3220 
 3221   // These three registers define part of the calling convention
 3222   // between compiled code and the interpreter.
 3223   inline_cache_reg(EAX);                // Inline Cache Register
 3224   interpreter_method_oop_reg(EBX);      // Method Oop Register when calling interpreter
 3225 
 3226   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 3227   cisc_spilling_operand_name(indOffset32);
 3228 
 3229   // Number of stack slots consumed by locking an object
 3230   sync_stack_slots(1);
 3231 
 3232   // Compiled code&#39;s Frame Pointer
 3233   frame_pointer(ESP);
 3234   // Interpreter stores its frame pointer in a register which is
 3235   // stored to the stack by I2CAdaptors.
 3236   // I2CAdaptors convert from interpreted java to compiled java.
 3237   interpreter_frame_pointer(EBP);
 3238 
 3239   // Stack alignment requirement
 3240   // Alignment size in bytes (128-bit -&gt; 16 bytes)
 3241   stack_alignment(StackAlignmentInBytes);
 3242 
 3243   // Number of stack slots between incoming argument block and the start of
 3244   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3245   // EPILOG must remove this many slots.  Intel needs one slot for
 3246   // return address and one for rbp, (must save rbp)
 3247   in_preserve_stack_slots(2+VerifyStackAtCalls);
 3248 
 3249   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3250   // for calls to C.  Supports the var-args backing area for register parms.
 3251   varargs_C_out_slots_killed(0);
 3252 
 3253   // The after-PROLOG location of the return address.  Location of
 3254   // return address specifies a type (REG or STACK) and a number
 3255   // representing the register number (i.e. - use a register name) or
 3256   // stack slot.
 3257   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 3258   // Otherwise, it is above the locks and verification slot and alignment word
 3259   return_addr(STACK - 1 +
 3260               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 3261                         Compile::current()-&gt;fixed_slots()),
 3262                        stack_alignment_in_slots()));
 3263 
 3264   // Body of function which returns an integer array locating
 3265   // arguments either in registers or in stack slots.  Passed an array
 3266   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3267   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3268   // arguments for a CALLEE.  Incoming stack arguments are
 3269   // automatically biased by the preserve_stack_slots field above.
 3270   calling_convention %{
 3271     // No difference between ingoing/outgoing just pass false
 3272     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 3273   %}
 3274 
 3275 
 3276   // Body of function which returns an integer array locating
 3277   // arguments either in registers or in stack slots.  Passed an array
 3278   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3279   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3280   // arguments for a CALLEE.  Incoming stack arguments are
 3281   // automatically biased by the preserve_stack_slots field above.
 3282   c_calling_convention %{
 3283     // This is obviously always outgoing
 3284     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3285   %}
 3286 
 3287   // Location of C &amp; interpreter return values
 3288   c_return_value %{
 3289     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3290     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3291     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3292 
 3293     // in SSE2+ mode we want to keep the FPU stack clean so pretend
 3294     // that C functions return float and double results in XMM0.
 3295     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3296       return OptoRegPair(XMM0b_num,XMM0_num);
 3297     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=2 )
 3298       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3299 
 3300     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3301   %}
 3302 
 3303   // Location of return values
 3304   return_value %{
 3305     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3306     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3307     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3308     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3309       return OptoRegPair(XMM0b_num,XMM0_num);
 3310     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=1 )
 3311       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3312     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3313   %}
 3314 
 3315 %}
 3316 
 3317 //----------ATTRIBUTES---------------------------------------------------------
 3318 //----------Operand Attributes-------------------------------------------------
 3319 op_attrib op_cost(0);        // Required cost attribute
 3320 
 3321 //----------Instruction Attributes---------------------------------------------
 3322 ins_attrib ins_cost(100);       // Required cost attribute
 3323 ins_attrib ins_size(8);         // Required size attribute (in bits)
 3324 ins_attrib ins_short_branch(0); // Required flag: is this instruction a
 3325                                 // non-matching short branch variant of some
 3326                                                             // long branch?
 3327 ins_attrib ins_alignment(1);    // Required alignment attribute (must be a power of 2)
 3328                                 // specifies the alignment that some part of the instruction (not
 3329                                 // necessarily the start) requires.  If &gt; 1, a compute_padding()
 3330                                 // function must be provided for the instruction
 3331 
 3332 //----------OPERANDS-----------------------------------------------------------
 3333 // Operand definitions must precede instruction definitions for correct parsing
 3334 // in the ADLC because operands constitute user defined types which are used in
 3335 // instruction definitions.
 3336 
 3337 //----------Simple Operands----------------------------------------------------
 3338 // Immediate Operands
 3339 // Integer Immediate
 3340 operand immI() %{
 3341   match(ConI);
 3342 
 3343   op_cost(10);
 3344   format %{ %}
 3345   interface(CONST_INTER);
 3346 %}
 3347 
 3348 // Constant for test vs zero
 3349 operand immI0() %{
 3350   predicate(n-&gt;get_int() == 0);
 3351   match(ConI);
 3352 
 3353   op_cost(0);
 3354   format %{ %}
 3355   interface(CONST_INTER);
 3356 %}
 3357 
 3358 // Constant for increment
 3359 operand immI1() %{
 3360   predicate(n-&gt;get_int() == 1);
 3361   match(ConI);
 3362 
 3363   op_cost(0);
 3364   format %{ %}
 3365   interface(CONST_INTER);
 3366 %}
 3367 
 3368 // Constant for decrement
 3369 operand immI_M1() %{
 3370   predicate(n-&gt;get_int() == -1);
 3371   match(ConI);
 3372 
 3373   op_cost(0);
 3374   format %{ %}
 3375   interface(CONST_INTER);
 3376 %}
 3377 
 3378 // Valid scale values for addressing modes
 3379 operand immI2() %{
 3380   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3381   match(ConI);
 3382 
 3383   format %{ %}
 3384   interface(CONST_INTER);
 3385 %}
 3386 
 3387 operand immI8() %{
 3388   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3389   match(ConI);
 3390 
 3391   op_cost(5);
 3392   format %{ %}
 3393   interface(CONST_INTER);
 3394 %}
 3395 
<a name="6" id="anc6"></a>








 3396 operand immI16() %{
 3397   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3398   match(ConI);
 3399 
 3400   op_cost(10);
 3401   format %{ %}
 3402   interface(CONST_INTER);
 3403 %}
 3404 
 3405 // Int Immediate non-negative
 3406 operand immU31()
 3407 %{
 3408   predicate(n-&gt;get_int() &gt;= 0);
 3409   match(ConI);
 3410 
 3411   op_cost(0);
 3412   format %{ %}
 3413   interface(CONST_INTER);
 3414 %}
 3415 
 3416 // Constant for long shifts
 3417 operand immI_32() %{
 3418   predicate( n-&gt;get_int() == 32 );
 3419   match(ConI);
 3420 
 3421   op_cost(0);
 3422   format %{ %}
 3423   interface(CONST_INTER);
 3424 %}
 3425 
 3426 operand immI_1_31() %{
 3427   predicate( n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31 );
 3428   match(ConI);
 3429 
 3430   op_cost(0);
 3431   format %{ %}
 3432   interface(CONST_INTER);
 3433 %}
 3434 
 3435 operand immI_32_63() %{
 3436   predicate( n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63 );
 3437   match(ConI);
 3438   op_cost(0);
 3439 
 3440   format %{ %}
 3441   interface(CONST_INTER);
 3442 %}
 3443 
 3444 operand immI_1() %{
 3445   predicate( n-&gt;get_int() == 1 );
 3446   match(ConI);
 3447 
 3448   op_cost(0);
 3449   format %{ %}
 3450   interface(CONST_INTER);
 3451 %}
 3452 
 3453 operand immI_2() %{
 3454   predicate( n-&gt;get_int() == 2 );
 3455   match(ConI);
 3456 
 3457   op_cost(0);
 3458   format %{ %}
 3459   interface(CONST_INTER);
 3460 %}
 3461 
 3462 operand immI_3() %{
 3463   predicate( n-&gt;get_int() == 3 );
 3464   match(ConI);
 3465 
 3466   op_cost(0);
 3467   format %{ %}
 3468   interface(CONST_INTER);
 3469 %}
 3470 
 3471 // Pointer Immediate
 3472 operand immP() %{
 3473   match(ConP);
 3474 
 3475   op_cost(10);
 3476   format %{ %}
 3477   interface(CONST_INTER);
 3478 %}
 3479 
 3480 // NULL Pointer Immediate
 3481 operand immP0() %{
 3482   predicate( n-&gt;get_ptr() == 0 );
 3483   match(ConP);
 3484   op_cost(0);
 3485 
 3486   format %{ %}
 3487   interface(CONST_INTER);
 3488 %}
 3489 
 3490 // Long Immediate
 3491 operand immL() %{
 3492   match(ConL);
 3493 
 3494   op_cost(20);
 3495   format %{ %}
 3496   interface(CONST_INTER);
 3497 %}
 3498 
 3499 // Long Immediate zero
 3500 operand immL0() %{
 3501   predicate( n-&gt;get_long() == 0L );
 3502   match(ConL);
 3503   op_cost(0);
 3504 
 3505   format %{ %}
 3506   interface(CONST_INTER);
 3507 %}
 3508 
 3509 // Long Immediate zero
 3510 operand immL_M1() %{
 3511   predicate( n-&gt;get_long() == -1L );
 3512   match(ConL);
 3513   op_cost(0);
 3514 
 3515   format %{ %}
 3516   interface(CONST_INTER);
 3517 %}
 3518 
 3519 // Long immediate from 0 to 127.
 3520 // Used for a shorter form of long mul by 10.
 3521 operand immL_127() %{
 3522   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 127));
 3523   match(ConL);
 3524   op_cost(0);
 3525 
 3526   format %{ %}
 3527   interface(CONST_INTER);
 3528 %}
 3529 
 3530 // Long Immediate: low 32-bit mask
 3531 operand immL_32bits() %{
 3532   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3533   match(ConL);
 3534   op_cost(0);
 3535 
 3536   format %{ %}
 3537   interface(CONST_INTER);
 3538 %}
 3539 
 3540 // Long Immediate: low 32-bit mask
 3541 operand immL32() %{
 3542   predicate(n-&gt;get_long() == (int)(n-&gt;get_long()));
 3543   match(ConL);
 3544   op_cost(20);
 3545 
 3546   format %{ %}
 3547   interface(CONST_INTER);
 3548 %}
 3549 
 3550 //Double Immediate zero
 3551 operand immDPR0() %{
 3552   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3553   // bug that generates code such that NaNs compare equal to 0.0
 3554   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 0.0 &amp;&amp; !g_isnan(n-&gt;getd()) );
 3555   match(ConD);
 3556 
 3557   op_cost(5);
 3558   format %{ %}
 3559   interface(CONST_INTER);
 3560 %}
 3561 
 3562 // Double Immediate one
 3563 operand immDPR1() %{
 3564   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 1.0 );
 3565   match(ConD);
 3566 
 3567   op_cost(5);
 3568   format %{ %}
 3569   interface(CONST_INTER);
 3570 %}
 3571 
 3572 // Double Immediate
 3573 operand immDPR() %{
 3574   predicate(UseSSE&lt;=1);
 3575   match(ConD);
 3576 
 3577   op_cost(5);
 3578   format %{ %}
 3579   interface(CONST_INTER);
 3580 %}
 3581 
 3582 operand immD() %{
 3583   predicate(UseSSE&gt;=2);
 3584   match(ConD);
 3585 
 3586   op_cost(5);
 3587   format %{ %}
 3588   interface(CONST_INTER);
 3589 %}
 3590 
 3591 // Double Immediate zero
 3592 operand immD0() %{
 3593   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3594   // bug that generates code such that NaNs compare equal to 0.0 AND do not
 3595   // compare equal to -0.0.
 3596   predicate( UseSSE&gt;=2 &amp;&amp; jlong_cast(n-&gt;getd()) == 0 );
 3597   match(ConD);
 3598 
 3599   format %{ %}
 3600   interface(CONST_INTER);
 3601 %}
 3602 
 3603 // Float Immediate zero
 3604 operand immFPR0() %{
 3605   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 0.0F);
 3606   match(ConF);
 3607 
 3608   op_cost(5);
 3609   format %{ %}
 3610   interface(CONST_INTER);
 3611 %}
 3612 
 3613 // Float Immediate one
 3614 operand immFPR1() %{
 3615   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 1.0F);
 3616   match(ConF);
 3617 
 3618   op_cost(5);
 3619   format %{ %}
 3620   interface(CONST_INTER);
 3621 %}
 3622 
 3623 // Float Immediate
 3624 operand immFPR() %{
 3625   predicate( UseSSE == 0 );
 3626   match(ConF);
 3627 
 3628   op_cost(5);
 3629   format %{ %}
 3630   interface(CONST_INTER);
 3631 %}
 3632 
 3633 // Float Immediate
 3634 operand immF() %{
 3635   predicate(UseSSE &gt;= 1);
 3636   match(ConF);
 3637 
 3638   op_cost(5);
 3639   format %{ %}
 3640   interface(CONST_INTER);
 3641 %}
 3642 
 3643 // Float Immediate zero.  Zero and not -0.0
 3644 operand immF0() %{
 3645   predicate( UseSSE &gt;= 1 &amp;&amp; jint_cast(n-&gt;getf()) == 0 );
 3646   match(ConF);
 3647 
 3648   op_cost(5);
 3649   format %{ %}
 3650   interface(CONST_INTER);
 3651 %}
 3652 
 3653 // Immediates for special shifts (sign extend)
 3654 
 3655 // Constants for increment
 3656 operand immI_16() %{
 3657   predicate( n-&gt;get_int() == 16 );
 3658   match(ConI);
 3659 
 3660   format %{ %}
 3661   interface(CONST_INTER);
 3662 %}
 3663 
 3664 operand immI_24() %{
 3665   predicate( n-&gt;get_int() == 24 );
 3666   match(ConI);
 3667 
 3668   format %{ %}
 3669   interface(CONST_INTER);
 3670 %}
 3671 
 3672 // Constant for byte-wide masking
 3673 operand immI_255() %{
 3674   predicate( n-&gt;get_int() == 255 );
 3675   match(ConI);
 3676 
 3677   format %{ %}
 3678   interface(CONST_INTER);
 3679 %}
 3680 
 3681 // Constant for short-wide masking
 3682 operand immI_65535() %{
 3683   predicate(n-&gt;get_int() == 65535);
 3684   match(ConI);
 3685 
 3686   format %{ %}
 3687   interface(CONST_INTER);
 3688 %}
 3689 
 3690 // Register Operands
 3691 // Integer Register
 3692 operand rRegI() %{
 3693   constraint(ALLOC_IN_RC(int_reg));
 3694   match(RegI);
 3695   match(xRegI);
 3696   match(eAXRegI);
 3697   match(eBXRegI);
 3698   match(eCXRegI);
 3699   match(eDXRegI);
 3700   match(eDIRegI);
 3701   match(eSIRegI);
 3702 
 3703   format %{ %}
 3704   interface(REG_INTER);
 3705 %}
 3706 
 3707 // Subset of Integer Register
 3708 operand xRegI(rRegI reg) %{
 3709   constraint(ALLOC_IN_RC(int_x_reg));
 3710   match(reg);
 3711   match(eAXRegI);
 3712   match(eBXRegI);
 3713   match(eCXRegI);
 3714   match(eDXRegI);
 3715 
 3716   format %{ %}
 3717   interface(REG_INTER);
 3718 %}
 3719 
 3720 // Special Registers
 3721 operand eAXRegI(xRegI reg) %{
 3722   constraint(ALLOC_IN_RC(eax_reg));
 3723   match(reg);
 3724   match(rRegI);
 3725 
 3726   format %{ &quot;EAX&quot; %}
 3727   interface(REG_INTER);
 3728 %}
 3729 
 3730 // Special Registers
 3731 operand eBXRegI(xRegI reg) %{
 3732   constraint(ALLOC_IN_RC(ebx_reg));
 3733   match(reg);
 3734   match(rRegI);
 3735 
 3736   format %{ &quot;EBX&quot; %}
 3737   interface(REG_INTER);
 3738 %}
 3739 
 3740 operand eCXRegI(xRegI reg) %{
 3741   constraint(ALLOC_IN_RC(ecx_reg));
 3742   match(reg);
 3743   match(rRegI);
 3744 
 3745   format %{ &quot;ECX&quot; %}
 3746   interface(REG_INTER);
 3747 %}
 3748 
 3749 operand eDXRegI(xRegI reg) %{
 3750   constraint(ALLOC_IN_RC(edx_reg));
 3751   match(reg);
 3752   match(rRegI);
 3753 
 3754   format %{ &quot;EDX&quot; %}
 3755   interface(REG_INTER);
 3756 %}
 3757 
 3758 operand eDIRegI(xRegI reg) %{
 3759   constraint(ALLOC_IN_RC(edi_reg));
 3760   match(reg);
 3761   match(rRegI);
 3762 
 3763   format %{ &quot;EDI&quot; %}
 3764   interface(REG_INTER);
 3765 %}
 3766 
 3767 operand naxRegI() %{
 3768   constraint(ALLOC_IN_RC(nax_reg));
 3769   match(RegI);
 3770   match(eCXRegI);
 3771   match(eDXRegI);
 3772   match(eSIRegI);
 3773   match(eDIRegI);
 3774 
 3775   format %{ %}
 3776   interface(REG_INTER);
 3777 %}
 3778 
 3779 operand nadxRegI() %{
 3780   constraint(ALLOC_IN_RC(nadx_reg));
 3781   match(RegI);
 3782   match(eBXRegI);
 3783   match(eCXRegI);
 3784   match(eSIRegI);
 3785   match(eDIRegI);
 3786 
 3787   format %{ %}
 3788   interface(REG_INTER);
 3789 %}
 3790 
 3791 operand ncxRegI() %{
 3792   constraint(ALLOC_IN_RC(ncx_reg));
 3793   match(RegI);
 3794   match(eAXRegI);
 3795   match(eDXRegI);
 3796   match(eSIRegI);
 3797   match(eDIRegI);
 3798 
 3799   format %{ %}
 3800   interface(REG_INTER);
 3801 %}
 3802 
 3803 // // This operand was used by cmpFastUnlock, but conflicted with &#39;object&#39; reg
 3804 // //
 3805 operand eSIRegI(xRegI reg) %{
 3806    constraint(ALLOC_IN_RC(esi_reg));
 3807    match(reg);
 3808    match(rRegI);
 3809 
 3810    format %{ &quot;ESI&quot; %}
 3811    interface(REG_INTER);
 3812 %}
 3813 
 3814 // Pointer Register
 3815 operand anyRegP() %{
 3816   constraint(ALLOC_IN_RC(any_reg));
 3817   match(RegP);
 3818   match(eAXRegP);
 3819   match(eBXRegP);
 3820   match(eCXRegP);
 3821   match(eDIRegP);
 3822   match(eRegP);
 3823 
 3824   format %{ %}
 3825   interface(REG_INTER);
 3826 %}
 3827 
 3828 operand eRegP() %{
 3829   constraint(ALLOC_IN_RC(int_reg));
 3830   match(RegP);
 3831   match(eAXRegP);
 3832   match(eBXRegP);
 3833   match(eCXRegP);
 3834   match(eDIRegP);
 3835 
 3836   format %{ %}
 3837   interface(REG_INTER);
 3838 %}
 3839 
 3840 // On windows95, EBP is not safe to use for implicit null tests.
 3841 operand eRegP_no_EBP() %{
 3842   constraint(ALLOC_IN_RC(int_reg_no_ebp));
 3843   match(RegP);
 3844   match(eAXRegP);
 3845   match(eBXRegP);
 3846   match(eCXRegP);
 3847   match(eDIRegP);
 3848 
 3849   op_cost(100);
 3850   format %{ %}
 3851   interface(REG_INTER);
 3852 %}
 3853 
 3854 operand naxRegP() %{
 3855   constraint(ALLOC_IN_RC(nax_reg));
 3856   match(RegP);
 3857   match(eBXRegP);
 3858   match(eDXRegP);
 3859   match(eCXRegP);
 3860   match(eSIRegP);
 3861   match(eDIRegP);
 3862 
 3863   format %{ %}
 3864   interface(REG_INTER);
 3865 %}
 3866 
 3867 operand nabxRegP() %{
 3868   constraint(ALLOC_IN_RC(nabx_reg));
 3869   match(RegP);
 3870   match(eCXRegP);
 3871   match(eDXRegP);
 3872   match(eSIRegP);
 3873   match(eDIRegP);
 3874 
 3875   format %{ %}
 3876   interface(REG_INTER);
 3877 %}
 3878 
 3879 operand pRegP() %{
 3880   constraint(ALLOC_IN_RC(p_reg));
 3881   match(RegP);
 3882   match(eBXRegP);
 3883   match(eDXRegP);
 3884   match(eSIRegP);
 3885   match(eDIRegP);
 3886 
 3887   format %{ %}
 3888   interface(REG_INTER);
 3889 %}
 3890 
 3891 // Special Registers
 3892 // Return a pointer value
 3893 operand eAXRegP(eRegP reg) %{
 3894   constraint(ALLOC_IN_RC(eax_reg));
 3895   match(reg);
 3896   format %{ &quot;EAX&quot; %}
 3897   interface(REG_INTER);
 3898 %}
 3899 
 3900 // Used in AtomicAdd
 3901 operand eBXRegP(eRegP reg) %{
 3902   constraint(ALLOC_IN_RC(ebx_reg));
 3903   match(reg);
 3904   format %{ &quot;EBX&quot; %}
 3905   interface(REG_INTER);
 3906 %}
 3907 
 3908 // Tail-call (interprocedural jump) to interpreter
 3909 operand eCXRegP(eRegP reg) %{
 3910   constraint(ALLOC_IN_RC(ecx_reg));
 3911   match(reg);
 3912   format %{ &quot;ECX&quot; %}
 3913   interface(REG_INTER);
 3914 %}
 3915 
 3916 operand eDXRegP(eRegP reg) %{
 3917   constraint(ALLOC_IN_RC(edx_reg));
 3918   match(reg);
 3919   format %{ &quot;EDX&quot; %}
 3920   interface(REG_INTER);
 3921 %}
 3922 
 3923 operand eSIRegP(eRegP reg) %{
 3924   constraint(ALLOC_IN_RC(esi_reg));
 3925   match(reg);
 3926   format %{ &quot;ESI&quot; %}
 3927   interface(REG_INTER);
 3928 %}
 3929 
 3930 // Used in rep stosw
 3931 operand eDIRegP(eRegP reg) %{
 3932   constraint(ALLOC_IN_RC(edi_reg));
 3933   match(reg);
 3934   format %{ &quot;EDI&quot; %}
 3935   interface(REG_INTER);
 3936 %}
 3937 
 3938 operand eRegL() %{
 3939   constraint(ALLOC_IN_RC(long_reg));
 3940   match(RegL);
 3941   match(eADXRegL);
 3942 
 3943   format %{ %}
 3944   interface(REG_INTER);
 3945 %}
 3946 
 3947 operand eADXRegL( eRegL reg ) %{
 3948   constraint(ALLOC_IN_RC(eadx_reg));
 3949   match(reg);
 3950 
 3951   format %{ &quot;EDX:EAX&quot; %}
 3952   interface(REG_INTER);
 3953 %}
 3954 
 3955 operand eBCXRegL( eRegL reg ) %{
 3956   constraint(ALLOC_IN_RC(ebcx_reg));
 3957   match(reg);
 3958 
 3959   format %{ &quot;EBX:ECX&quot; %}
 3960   interface(REG_INTER);
 3961 %}
 3962 
 3963 // Special case for integer high multiply
 3964 operand eADXRegL_low_only() %{
 3965   constraint(ALLOC_IN_RC(eadx_reg));
 3966   match(RegL);
 3967 
 3968   format %{ &quot;EAX&quot; %}
 3969   interface(REG_INTER);
 3970 %}
 3971 
 3972 // Flags register, used as output of compare instructions
 3973 operand eFlagsReg() %{
 3974   constraint(ALLOC_IN_RC(int_flags));
 3975   match(RegFlags);
 3976 
 3977   format %{ &quot;EFLAGS&quot; %}
 3978   interface(REG_INTER);
 3979 %}
 3980 
 3981 // Flags register, used as output of FLOATING POINT compare instructions
 3982 operand eFlagsRegU() %{
 3983   constraint(ALLOC_IN_RC(int_flags));
 3984   match(RegFlags);
 3985 
 3986   format %{ &quot;EFLAGS_U&quot; %}
 3987   interface(REG_INTER);
 3988 %}
 3989 
 3990 operand eFlagsRegUCF() %{
 3991   constraint(ALLOC_IN_RC(int_flags));
 3992   match(RegFlags);
 3993   predicate(false);
 3994 
 3995   format %{ &quot;EFLAGS_U_CF&quot; %}
 3996   interface(REG_INTER);
 3997 %}
 3998 
 3999 // Condition Code Register used by long compare
 4000 operand flagsReg_long_LTGE() %{
 4001   constraint(ALLOC_IN_RC(int_flags));
 4002   match(RegFlags);
 4003   format %{ &quot;FLAGS_LTGE&quot; %}
 4004   interface(REG_INTER);
 4005 %}
 4006 operand flagsReg_long_EQNE() %{
 4007   constraint(ALLOC_IN_RC(int_flags));
 4008   match(RegFlags);
 4009   format %{ &quot;FLAGS_EQNE&quot; %}
 4010   interface(REG_INTER);
 4011 %}
 4012 operand flagsReg_long_LEGT() %{
 4013   constraint(ALLOC_IN_RC(int_flags));
 4014   match(RegFlags);
 4015   format %{ &quot;FLAGS_LEGT&quot; %}
 4016   interface(REG_INTER);
 4017 %}
 4018 
 4019 // Condition Code Register used by unsigned long compare
 4020 operand flagsReg_ulong_LTGE() %{
 4021   constraint(ALLOC_IN_RC(int_flags));
 4022   match(RegFlags);
 4023   format %{ &quot;FLAGS_U_LTGE&quot; %}
 4024   interface(REG_INTER);
 4025 %}
 4026 operand flagsReg_ulong_EQNE() %{
 4027   constraint(ALLOC_IN_RC(int_flags));
 4028   match(RegFlags);
 4029   format %{ &quot;FLAGS_U_EQNE&quot; %}
 4030   interface(REG_INTER);
 4031 %}
 4032 operand flagsReg_ulong_LEGT() %{
 4033   constraint(ALLOC_IN_RC(int_flags));
 4034   match(RegFlags);
 4035   format %{ &quot;FLAGS_U_LEGT&quot; %}
 4036   interface(REG_INTER);
 4037 %}
 4038 
 4039 // Float register operands
 4040 operand regDPR() %{
 4041   predicate( UseSSE &lt; 2 );
 4042   constraint(ALLOC_IN_RC(fp_dbl_reg));
 4043   match(RegD);
 4044   match(regDPR1);
 4045   match(regDPR2);
 4046   format %{ %}
 4047   interface(REG_INTER);
 4048 %}
 4049 
 4050 operand regDPR1(regDPR reg) %{
 4051   predicate( UseSSE &lt; 2 );
 4052   constraint(ALLOC_IN_RC(fp_dbl_reg0));
 4053   match(reg);
 4054   format %{ &quot;FPR1&quot; %}
 4055   interface(REG_INTER);
 4056 %}
 4057 
 4058 operand regDPR2(regDPR reg) %{
 4059   predicate( UseSSE &lt; 2 );
 4060   constraint(ALLOC_IN_RC(fp_dbl_reg1));
 4061   match(reg);
 4062   format %{ &quot;FPR2&quot; %}
 4063   interface(REG_INTER);
 4064 %}
 4065 
 4066 operand regnotDPR1(regDPR reg) %{
 4067   predicate( UseSSE &lt; 2 );
 4068   constraint(ALLOC_IN_RC(fp_dbl_notreg0));
 4069   match(reg);
 4070   format %{ %}
 4071   interface(REG_INTER);
 4072 %}
 4073 
 4074 // Float register operands
 4075 operand regFPR() %{
 4076   predicate( UseSSE &lt; 2 );
 4077   constraint(ALLOC_IN_RC(fp_flt_reg));
 4078   match(RegF);
 4079   match(regFPR1);
 4080   format %{ %}
 4081   interface(REG_INTER);
 4082 %}
 4083 
 4084 // Float register operands
 4085 operand regFPR1(regFPR reg) %{
 4086   predicate( UseSSE &lt; 2 );
 4087   constraint(ALLOC_IN_RC(fp_flt_reg0));
 4088   match(reg);
 4089   format %{ &quot;FPR1&quot; %}
 4090   interface(REG_INTER);
 4091 %}
 4092 
 4093 // XMM Float register operands
 4094 operand regF() %{
 4095   predicate( UseSSE&gt;=1 );
 4096   constraint(ALLOC_IN_RC(float_reg_legacy));
 4097   match(RegF);
 4098   format %{ %}
 4099   interface(REG_INTER);
 4100 %}
 4101 
 4102 // Float register operands
 4103 operand vlRegF() %{
 4104    constraint(ALLOC_IN_RC(float_reg_vl));
 4105    match(RegF);
 4106 
 4107    format %{ %}
 4108    interface(REG_INTER);
 4109 %}
 4110 
 4111 // XMM Double register operands
 4112 operand regD() %{
 4113   predicate( UseSSE&gt;=2 );
 4114   constraint(ALLOC_IN_RC(double_reg_legacy));
 4115   match(RegD);
 4116   format %{ %}
 4117   interface(REG_INTER);
 4118 %}
 4119 
 4120 // Double register operands
 4121 operand vlRegD() %{
 4122    constraint(ALLOC_IN_RC(double_reg_vl));
 4123    match(RegD);
 4124 
 4125    format %{ %}
 4126    interface(REG_INTER);
 4127 %}
 4128 
 4129 //----------Memory Operands----------------------------------------------------
 4130 // Direct Memory Operand
 4131 operand direct(immP addr) %{
 4132   match(addr);
 4133 
 4134   format %{ &quot;[$addr]&quot; %}
 4135   interface(MEMORY_INTER) %{
 4136     base(0xFFFFFFFF);
 4137     index(0x4);
 4138     scale(0x0);
 4139     disp($addr);
 4140   %}
 4141 %}
 4142 
 4143 // Indirect Memory Operand
 4144 operand indirect(eRegP reg) %{
 4145   constraint(ALLOC_IN_RC(int_reg));
 4146   match(reg);
 4147 
 4148   format %{ &quot;[$reg]&quot; %}
 4149   interface(MEMORY_INTER) %{
 4150     base($reg);
 4151     index(0x4);
 4152     scale(0x0);
 4153     disp(0x0);
 4154   %}
 4155 %}
 4156 
 4157 // Indirect Memory Plus Short Offset Operand
 4158 operand indOffset8(eRegP reg, immI8 off) %{
 4159   match(AddP reg off);
 4160 
 4161   format %{ &quot;[$reg + $off]&quot; %}
 4162   interface(MEMORY_INTER) %{
 4163     base($reg);
 4164     index(0x4);
 4165     scale(0x0);
 4166     disp($off);
 4167   %}
 4168 %}
 4169 
 4170 // Indirect Memory Plus Long Offset Operand
 4171 operand indOffset32(eRegP reg, immI off) %{
 4172   match(AddP reg off);
 4173 
 4174   format %{ &quot;[$reg + $off]&quot; %}
 4175   interface(MEMORY_INTER) %{
 4176     base($reg);
 4177     index(0x4);
 4178     scale(0x0);
 4179     disp($off);
 4180   %}
 4181 %}
 4182 
 4183 // Indirect Memory Plus Long Offset Operand
 4184 operand indOffset32X(rRegI reg, immP off) %{
 4185   match(AddP off reg);
 4186 
 4187   format %{ &quot;[$reg + $off]&quot; %}
 4188   interface(MEMORY_INTER) %{
 4189     base($reg);
 4190     index(0x4);
 4191     scale(0x0);
 4192     disp($off);
 4193   %}
 4194 %}
 4195 
 4196 // Indirect Memory Plus Index Register Plus Offset Operand
 4197 operand indIndexOffset(eRegP reg, rRegI ireg, immI off) %{
 4198   match(AddP (AddP reg ireg) off);
 4199 
 4200   op_cost(10);
 4201   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4202   interface(MEMORY_INTER) %{
 4203     base($reg);
 4204     index($ireg);
 4205     scale(0x0);
 4206     disp($off);
 4207   %}
 4208 %}
 4209 
 4210 // Indirect Memory Plus Index Register Plus Offset Operand
 4211 operand indIndex(eRegP reg, rRegI ireg) %{
 4212   match(AddP reg ireg);
 4213 
 4214   op_cost(10);
 4215   format %{&quot;[$reg + $ireg]&quot; %}
 4216   interface(MEMORY_INTER) %{
 4217     base($reg);
 4218     index($ireg);
 4219     scale(0x0);
 4220     disp(0x0);
 4221   %}
 4222 %}
 4223 
 4224 // // -------------------------------------------------------------------------
 4225 // // 486 architecture doesn&#39;t support &quot;scale * index + offset&quot; with out a base
 4226 // // -------------------------------------------------------------------------
 4227 // // Scaled Memory Operands
 4228 // // Indirect Memory Times Scale Plus Offset Operand
 4229 // operand indScaleOffset(immP off, rRegI ireg, immI2 scale) %{
 4230 //   match(AddP off (LShiftI ireg scale));
 4231 //
 4232 //   op_cost(10);
 4233 //   format %{&quot;[$off + $ireg &lt;&lt; $scale]&quot; %}
 4234 //   interface(MEMORY_INTER) %{
 4235 //     base(0x4);
 4236 //     index($ireg);
 4237 //     scale($scale);
 4238 //     disp($off);
 4239 //   %}
 4240 // %}
 4241 
 4242 // Indirect Memory Times Scale Plus Index Register
 4243 operand indIndexScale(eRegP reg, rRegI ireg, immI2 scale) %{
 4244   match(AddP reg (LShiftI ireg scale));
 4245 
 4246   op_cost(10);
 4247   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4248   interface(MEMORY_INTER) %{
 4249     base($reg);
 4250     index($ireg);
 4251     scale($scale);
 4252     disp(0x0);
 4253   %}
 4254 %}
 4255 
 4256 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4257 operand indIndexScaleOffset(eRegP reg, immI off, rRegI ireg, immI2 scale) %{
 4258   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4259 
 4260   op_cost(10);
 4261   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4262   interface(MEMORY_INTER) %{
 4263     base($reg);
 4264     index($ireg);
 4265     scale($scale);
 4266     disp($off);
 4267   %}
 4268 %}
 4269 
 4270 //----------Load Long Memory Operands------------------------------------------
 4271 // The load-long idiom will use it&#39;s address expression again after loading
 4272 // the first word of the long.  If the load-long destination overlaps with
 4273 // registers used in the addressing expression, the 2nd half will be loaded
 4274 // from a clobbered address.  Fix this by requiring that load-long use
 4275 // address registers that do not overlap with the load-long target.
 4276 
 4277 // load-long support
 4278 operand load_long_RegP() %{
 4279   constraint(ALLOC_IN_RC(esi_reg));
 4280   match(RegP);
 4281   match(eSIRegP);
 4282   op_cost(100);
 4283   format %{  %}
 4284   interface(REG_INTER);
 4285 %}
 4286 
 4287 // Indirect Memory Operand Long
 4288 operand load_long_indirect(load_long_RegP reg) %{
 4289   constraint(ALLOC_IN_RC(esi_reg));
 4290   match(reg);
 4291 
 4292   format %{ &quot;[$reg]&quot; %}
 4293   interface(MEMORY_INTER) %{
 4294     base($reg);
 4295     index(0x4);
 4296     scale(0x0);
 4297     disp(0x0);
 4298   %}
 4299 %}
 4300 
 4301 // Indirect Memory Plus Long Offset Operand
 4302 operand load_long_indOffset32(load_long_RegP reg, immI off) %{
 4303   match(AddP reg off);
 4304 
 4305   format %{ &quot;[$reg + $off]&quot; %}
 4306   interface(MEMORY_INTER) %{
 4307     base($reg);
 4308     index(0x4);
 4309     scale(0x0);
 4310     disp($off);
 4311   %}
 4312 %}
 4313 
 4314 opclass load_long_memory(load_long_indirect, load_long_indOffset32);
 4315 
 4316 
 4317 //----------Special Memory Operands--------------------------------------------
 4318 // Stack Slot Operand - This operand is used for loading and storing temporary
 4319 //                      values on the stack where a match requires a value to
 4320 //                      flow through memory.
 4321 operand stackSlotP(sRegP reg) %{
 4322   constraint(ALLOC_IN_RC(stack_slots));
 4323   // No match rule because this operand is only generated in matching
 4324   format %{ &quot;[$reg]&quot; %}
 4325   interface(MEMORY_INTER) %{
 4326     base(0x4);   // ESP
 4327     index(0x4);  // No Index
 4328     scale(0x0);  // No Scale
 4329     disp($reg);  // Stack Offset
 4330   %}
 4331 %}
 4332 
 4333 operand stackSlotI(sRegI reg) %{
 4334   constraint(ALLOC_IN_RC(stack_slots));
 4335   // No match rule because this operand is only generated in matching
 4336   format %{ &quot;[$reg]&quot; %}
 4337   interface(MEMORY_INTER) %{
 4338     base(0x4);   // ESP
 4339     index(0x4);  // No Index
 4340     scale(0x0);  // No Scale
 4341     disp($reg);  // Stack Offset
 4342   %}
 4343 %}
 4344 
 4345 operand stackSlotF(sRegF reg) %{
 4346   constraint(ALLOC_IN_RC(stack_slots));
 4347   // No match rule because this operand is only generated in matching
 4348   format %{ &quot;[$reg]&quot; %}
 4349   interface(MEMORY_INTER) %{
 4350     base(0x4);   // ESP
 4351     index(0x4);  // No Index
 4352     scale(0x0);  // No Scale
 4353     disp($reg);  // Stack Offset
 4354   %}
 4355 %}
 4356 
 4357 operand stackSlotD(sRegD reg) %{
 4358   constraint(ALLOC_IN_RC(stack_slots));
 4359   // No match rule because this operand is only generated in matching
 4360   format %{ &quot;[$reg]&quot; %}
 4361   interface(MEMORY_INTER) %{
 4362     base(0x4);   // ESP
 4363     index(0x4);  // No Index
 4364     scale(0x0);  // No Scale
 4365     disp($reg);  // Stack Offset
 4366   %}
 4367 %}
 4368 
 4369 operand stackSlotL(sRegL reg) %{
 4370   constraint(ALLOC_IN_RC(stack_slots));
 4371   // No match rule because this operand is only generated in matching
 4372   format %{ &quot;[$reg]&quot; %}
 4373   interface(MEMORY_INTER) %{
 4374     base(0x4);   // ESP
 4375     index(0x4);  // No Index
 4376     scale(0x0);  // No Scale
 4377     disp($reg);  // Stack Offset
 4378   %}
 4379 %}
 4380 
 4381 //----------Memory Operands - Win95 Implicit Null Variants----------------
 4382 // Indirect Memory Operand
 4383 operand indirect_win95_safe(eRegP_no_EBP reg)
 4384 %{
 4385   constraint(ALLOC_IN_RC(int_reg));
 4386   match(reg);
 4387 
 4388   op_cost(100);
 4389   format %{ &quot;[$reg]&quot; %}
 4390   interface(MEMORY_INTER) %{
 4391     base($reg);
 4392     index(0x4);
 4393     scale(0x0);
 4394     disp(0x0);
 4395   %}
 4396 %}
 4397 
 4398 // Indirect Memory Plus Short Offset Operand
 4399 operand indOffset8_win95_safe(eRegP_no_EBP reg, immI8 off)
 4400 %{
 4401   match(AddP reg off);
 4402 
 4403   op_cost(100);
 4404   format %{ &quot;[$reg + $off]&quot; %}
 4405   interface(MEMORY_INTER) %{
 4406     base($reg);
 4407     index(0x4);
 4408     scale(0x0);
 4409     disp($off);
 4410   %}
 4411 %}
 4412 
 4413 // Indirect Memory Plus Long Offset Operand
 4414 operand indOffset32_win95_safe(eRegP_no_EBP reg, immI off)
 4415 %{
 4416   match(AddP reg off);
 4417 
 4418   op_cost(100);
 4419   format %{ &quot;[$reg + $off]&quot; %}
 4420   interface(MEMORY_INTER) %{
 4421     base($reg);
 4422     index(0x4);
 4423     scale(0x0);
 4424     disp($off);
 4425   %}
 4426 %}
 4427 
 4428 // Indirect Memory Plus Index Register Plus Offset Operand
 4429 operand indIndexOffset_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI off)
 4430 %{
 4431   match(AddP (AddP reg ireg) off);
 4432 
 4433   op_cost(100);
 4434   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4435   interface(MEMORY_INTER) %{
 4436     base($reg);
 4437     index($ireg);
 4438     scale(0x0);
 4439     disp($off);
 4440   %}
 4441 %}
 4442 
 4443 // Indirect Memory Times Scale Plus Index Register
 4444 operand indIndexScale_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI2 scale)
 4445 %{
 4446   match(AddP reg (LShiftI ireg scale));
 4447 
 4448   op_cost(100);
 4449   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4450   interface(MEMORY_INTER) %{
 4451     base($reg);
 4452     index($ireg);
 4453     scale($scale);
 4454     disp(0x0);
 4455   %}
 4456 %}
 4457 
 4458 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4459 operand indIndexScaleOffset_win95_safe(eRegP_no_EBP reg, immI off, rRegI ireg, immI2 scale)
 4460 %{
 4461   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4462 
 4463   op_cost(100);
 4464   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4465   interface(MEMORY_INTER) %{
 4466     base($reg);
 4467     index($ireg);
 4468     scale($scale);
 4469     disp($off);
 4470   %}
 4471 %}
 4472 
 4473 //----------Conditional Branch Operands----------------------------------------
 4474 // Comparison Op  - This is the operation of the comparison, and is limited to
 4475 //                  the following set of codes:
 4476 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4477 //
 4478 // Other attributes of the comparison, such as unsignedness, are specified
 4479 // by the comparison instruction that sets a condition code flags register.
 4480 // That result is represented by a flags operand whose subtype is appropriate
 4481 // to the unsignedness (etc.) of the comparison.
 4482 //
 4483 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4484 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4485 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4486 
 4487 // Comparision Code
 4488 operand cmpOp() %{
 4489   match(Bool);
 4490 
 4491   format %{ &quot;&quot; %}
 4492   interface(COND_INTER) %{
 4493     equal(0x4, &quot;e&quot;);
 4494     not_equal(0x5, &quot;ne&quot;);
 4495     less(0xC, &quot;l&quot;);
 4496     greater_equal(0xD, &quot;ge&quot;);
 4497     less_equal(0xE, &quot;le&quot;);
 4498     greater(0xF, &quot;g&quot;);
 4499     overflow(0x0, &quot;o&quot;);
 4500     no_overflow(0x1, &quot;no&quot;);
 4501   %}
 4502 %}
 4503 
 4504 // Comparison Code, unsigned compare.  Used by FP also, with
 4505 // C2 (unordered) turned into GT or LT already.  The other bits
 4506 // C0 and C3 are turned into Carry &amp; Zero flags.
 4507 operand cmpOpU() %{
 4508   match(Bool);
 4509 
 4510   format %{ &quot;&quot; %}
 4511   interface(COND_INTER) %{
 4512     equal(0x4, &quot;e&quot;);
 4513     not_equal(0x5, &quot;ne&quot;);
 4514     less(0x2, &quot;b&quot;);
 4515     greater_equal(0x3, &quot;nb&quot;);
 4516     less_equal(0x6, &quot;be&quot;);
 4517     greater(0x7, &quot;nbe&quot;);
 4518     overflow(0x0, &quot;o&quot;);
 4519     no_overflow(0x1, &quot;no&quot;);
 4520   %}
 4521 %}
 4522 
 4523 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4524 operand cmpOpUCF() %{
 4525   match(Bool);
 4526   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4527             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4528             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4529             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4530   format %{ &quot;&quot; %}
 4531   interface(COND_INTER) %{
 4532     equal(0x4, &quot;e&quot;);
 4533     not_equal(0x5, &quot;ne&quot;);
 4534     less(0x2, &quot;b&quot;);
 4535     greater_equal(0x3, &quot;nb&quot;);
 4536     less_equal(0x6, &quot;be&quot;);
 4537     greater(0x7, &quot;nbe&quot;);
 4538     overflow(0x0, &quot;o&quot;);
 4539     no_overflow(0x1, &quot;no&quot;);
 4540   %}
 4541 %}
 4542 
 4543 
 4544 // Floating comparisons that can be fixed up with extra conditional jumps
 4545 operand cmpOpUCF2() %{
 4546   match(Bool);
 4547   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4548             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4549   format %{ &quot;&quot; %}
 4550   interface(COND_INTER) %{
 4551     equal(0x4, &quot;e&quot;);
 4552     not_equal(0x5, &quot;ne&quot;);
 4553     less(0x2, &quot;b&quot;);
 4554     greater_equal(0x3, &quot;nb&quot;);
 4555     less_equal(0x6, &quot;be&quot;);
 4556     greater(0x7, &quot;nbe&quot;);
 4557     overflow(0x0, &quot;o&quot;);
 4558     no_overflow(0x1, &quot;no&quot;);
 4559   %}
 4560 %}
 4561 
 4562 // Comparison Code for FP conditional move
 4563 operand cmpOp_fcmov() %{
 4564   match(Bool);
 4565 
 4566   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4567             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4568   format %{ &quot;&quot; %}
 4569   interface(COND_INTER) %{
 4570     equal        (0x0C8);
 4571     not_equal    (0x1C8);
 4572     less         (0x0C0);
 4573     greater_equal(0x1C0);
 4574     less_equal   (0x0D0);
 4575     greater      (0x1D0);
 4576     overflow(0x0, &quot;o&quot;); // not really supported by the instruction
 4577     no_overflow(0x1, &quot;no&quot;); // not really supported by the instruction
 4578   %}
 4579 %}
 4580 
 4581 // Comparison Code used in long compares
 4582 operand cmpOp_commute() %{
 4583   match(Bool);
 4584 
 4585   format %{ &quot;&quot; %}
 4586   interface(COND_INTER) %{
 4587     equal(0x4, &quot;e&quot;);
 4588     not_equal(0x5, &quot;ne&quot;);
 4589     less(0xF, &quot;g&quot;);
 4590     greater_equal(0xE, &quot;le&quot;);
 4591     less_equal(0xD, &quot;ge&quot;);
 4592     greater(0xC, &quot;l&quot;);
 4593     overflow(0x0, &quot;o&quot;);
 4594     no_overflow(0x1, &quot;no&quot;);
 4595   %}
 4596 %}
 4597 
 4598 // Comparison Code used in unsigned long compares
 4599 operand cmpOpU_commute() %{
 4600   match(Bool);
 4601 
 4602   format %{ &quot;&quot; %}
 4603   interface(COND_INTER) %{
 4604     equal(0x4, &quot;e&quot;);
 4605     not_equal(0x5, &quot;ne&quot;);
 4606     less(0x7, &quot;nbe&quot;);
 4607     greater_equal(0x6, &quot;be&quot;);
 4608     less_equal(0x3, &quot;nb&quot;);
 4609     greater(0x2, &quot;b&quot;);
 4610     overflow(0x0, &quot;o&quot;);
 4611     no_overflow(0x1, &quot;no&quot;);
 4612   %}
 4613 %}
 4614 
 4615 //----------OPERAND CLASSES----------------------------------------------------
 4616 // Operand Classes are groups of operands that are used as to simplify
 4617 // instruction definitions by not requiring the AD writer to specify separate
 4618 // instructions for every form of operand when the instruction accepts
 4619 // multiple operand types with the same basic encoding and format.  The classic
 4620 // case of this is memory operands.
 4621 
 4622 opclass memory(direct, indirect, indOffset8, indOffset32, indOffset32X, indIndexOffset,
 4623                indIndex, indIndexScale, indIndexScaleOffset);
 4624 
 4625 // Long memory operations are encoded in 2 instructions and a +4 offset.
 4626 // This means some kind of offset is always required and you cannot use
 4627 // an oop as the offset (done when working on static globals).
 4628 opclass long_memory(direct, indirect, indOffset8, indOffset32, indIndexOffset,
 4629                     indIndex, indIndexScale, indIndexScaleOffset);
 4630 
 4631 
 4632 //----------PIPELINE-----------------------------------------------------------
 4633 // Rules which define the behavior of the target architectures pipeline.
 4634 pipeline %{
 4635 
 4636 //----------ATTRIBUTES---------------------------------------------------------
 4637 attributes %{
 4638   variable_size_instructions;        // Fixed size instructions
 4639   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4640   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4641   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4642   instruction_fetch_units = 1;       // of 16 bytes
 4643 
 4644   // List of nop instructions
 4645   nops( MachNop );
 4646 %}
 4647 
 4648 //----------RESOURCES----------------------------------------------------------
 4649 // Resources are the functional units available to the machine
 4650 
 4651 // Generic P2/P3 pipeline
 4652 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4653 // 3 instructions decoded per cycle.
 4654 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4655 // 2 ALU op, only ALU0 handles mul/div instructions.
 4656 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4657            MS0, MS1, MEM = MS0 | MS1,
 4658            BR, FPU,
 4659            ALU0, ALU1, ALU = ALU0 | ALU1 );
 4660 
 4661 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4662 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4663 
 4664 // Generic P2/P3 pipeline
 4665 pipe_desc(S0, S1, S2, S3, S4, S5);
 4666 
 4667 //----------PIPELINE CLASSES---------------------------------------------------
 4668 // Pipeline Classes describe the stages in which input and output are
 4669 // referenced by the hardware pipeline.
 4670 
 4671 // Naming convention: ialu or fpu
 4672 // Then: _reg
 4673 // Then: _reg if there is a 2nd register
 4674 // Then: _long if it&#39;s a pair of instructions implementing a long
 4675 // Then: _fat if it requires the big decoder
 4676 //   Or: _mem if it requires the big decoder and a memory unit.
 4677 
 4678 // Integer ALU reg operation
 4679 pipe_class ialu_reg(rRegI dst) %{
 4680     single_instruction;
 4681     dst    : S4(write);
 4682     dst    : S3(read);
 4683     DECODE : S0;        // any decoder
 4684     ALU    : S3;        // any alu
 4685 %}
 4686 
 4687 // Long ALU reg operation
 4688 pipe_class ialu_reg_long(eRegL dst) %{
 4689     instruction_count(2);
 4690     dst    : S4(write);
 4691     dst    : S3(read);
 4692     DECODE : S0(2);     // any 2 decoders
 4693     ALU    : S3(2);     // both alus
 4694 %}
 4695 
 4696 // Integer ALU reg operation using big decoder
 4697 pipe_class ialu_reg_fat(rRegI dst) %{
 4698     single_instruction;
 4699     dst    : S4(write);
 4700     dst    : S3(read);
 4701     D0     : S0;        // big decoder only
 4702     ALU    : S3;        // any alu
 4703 %}
 4704 
 4705 // Long ALU reg operation using big decoder
 4706 pipe_class ialu_reg_long_fat(eRegL dst) %{
 4707     instruction_count(2);
 4708     dst    : S4(write);
 4709     dst    : S3(read);
 4710     D0     : S0(2);     // big decoder only; twice
 4711     ALU    : S3(2);     // any 2 alus
 4712 %}
 4713 
 4714 // Integer ALU reg-reg operation
 4715 pipe_class ialu_reg_reg(rRegI dst, rRegI src) %{
 4716     single_instruction;
 4717     dst    : S4(write);
 4718     src    : S3(read);
 4719     DECODE : S0;        // any decoder
 4720     ALU    : S3;        // any alu
 4721 %}
 4722 
 4723 // Long ALU reg-reg operation
 4724 pipe_class ialu_reg_reg_long(eRegL dst, eRegL src) %{
 4725     instruction_count(2);
 4726     dst    : S4(write);
 4727     src    : S3(read);
 4728     DECODE : S0(2);     // any 2 decoders
 4729     ALU    : S3(2);     // both alus
 4730 %}
 4731 
 4732 // Integer ALU reg-reg operation
 4733 pipe_class ialu_reg_reg_fat(rRegI dst, memory src) %{
 4734     single_instruction;
 4735     dst    : S4(write);
 4736     src    : S3(read);
 4737     D0     : S0;        // big decoder only
 4738     ALU    : S3;        // any alu
 4739 %}
 4740 
 4741 // Long ALU reg-reg operation
 4742 pipe_class ialu_reg_reg_long_fat(eRegL dst, eRegL src) %{
 4743     instruction_count(2);
 4744     dst    : S4(write);
 4745     src    : S3(read);
 4746     D0     : S0(2);     // big decoder only; twice
 4747     ALU    : S3(2);     // both alus
 4748 %}
 4749 
 4750 // Integer ALU reg-mem operation
 4751 pipe_class ialu_reg_mem(rRegI dst, memory mem) %{
 4752     single_instruction;
 4753     dst    : S5(write);
 4754     mem    : S3(read);
 4755     D0     : S0;        // big decoder only
 4756     ALU    : S4;        // any alu
 4757     MEM    : S3;        // any mem
 4758 %}
 4759 
 4760 // Long ALU reg-mem operation
 4761 pipe_class ialu_reg_long_mem(eRegL dst, load_long_memory mem) %{
 4762     instruction_count(2);
 4763     dst    : S5(write);
 4764     mem    : S3(read);
 4765     D0     : S0(2);     // big decoder only; twice
 4766     ALU    : S4(2);     // any 2 alus
 4767     MEM    : S3(2);     // both mems
 4768 %}
 4769 
 4770 // Integer mem operation (prefetch)
 4771 pipe_class ialu_mem(memory mem)
 4772 %{
 4773     single_instruction;
 4774     mem    : S3(read);
 4775     D0     : S0;        // big decoder only
 4776     MEM    : S3;        // any mem
 4777 %}
 4778 
 4779 // Integer Store to Memory
 4780 pipe_class ialu_mem_reg(memory mem, rRegI src) %{
 4781     single_instruction;
 4782     mem    : S3(read);
 4783     src    : S5(read);
 4784     D0     : S0;        // big decoder only
 4785     ALU    : S4;        // any alu
 4786     MEM    : S3;
 4787 %}
 4788 
 4789 // Long Store to Memory
 4790 pipe_class ialu_mem_long_reg(memory mem, eRegL src) %{
 4791     instruction_count(2);
 4792     mem    : S3(read);
 4793     src    : S5(read);
 4794     D0     : S0(2);     // big decoder only; twice
 4795     ALU    : S4(2);     // any 2 alus
 4796     MEM    : S3(2);     // Both mems
 4797 %}
 4798 
 4799 // Integer Store to Memory
 4800 pipe_class ialu_mem_imm(memory mem) %{
 4801     single_instruction;
 4802     mem    : S3(read);
 4803     D0     : S0;        // big decoder only
 4804     ALU    : S4;        // any alu
 4805     MEM    : S3;
 4806 %}
 4807 
 4808 // Integer ALU0 reg-reg operation
 4809 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src) %{
 4810     single_instruction;
 4811     dst    : S4(write);
 4812     src    : S3(read);
 4813     D0     : S0;        // Big decoder only
 4814     ALU0   : S3;        // only alu0
 4815 %}
 4816 
 4817 // Integer ALU0 reg-mem operation
 4818 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem) %{
 4819     single_instruction;
 4820     dst    : S5(write);
 4821     mem    : S3(read);
 4822     D0     : S0;        // big decoder only
 4823     ALU0   : S4;        // ALU0 only
 4824     MEM    : S3;        // any mem
 4825 %}
 4826 
 4827 // Integer ALU reg-reg operation
 4828 pipe_class ialu_cr_reg_reg(eFlagsReg cr, rRegI src1, rRegI src2) %{
 4829     single_instruction;
 4830     cr     : S4(write);
 4831     src1   : S3(read);
 4832     src2   : S3(read);
 4833     DECODE : S0;        // any decoder
 4834     ALU    : S3;        // any alu
 4835 %}
 4836 
 4837 // Integer ALU reg-imm operation
 4838 pipe_class ialu_cr_reg_imm(eFlagsReg cr, rRegI src1) %{
 4839     single_instruction;
 4840     cr     : S4(write);
 4841     src1   : S3(read);
 4842     DECODE : S0;        // any decoder
 4843     ALU    : S3;        // any alu
 4844 %}
 4845 
 4846 // Integer ALU reg-mem operation
 4847 pipe_class ialu_cr_reg_mem(eFlagsReg cr, rRegI src1, memory src2) %{
 4848     single_instruction;
 4849     cr     : S4(write);
 4850     src1   : S3(read);
 4851     src2   : S3(read);
 4852     D0     : S0;        // big decoder only
 4853     ALU    : S4;        // any alu
 4854     MEM    : S3;
 4855 %}
 4856 
 4857 // Conditional move reg-reg
 4858 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y ) %{
 4859     instruction_count(4);
 4860     y      : S4(read);
 4861     q      : S3(read);
 4862     p      : S3(read);
 4863     DECODE : S0(4);     // any decoder
 4864 %}
 4865 
 4866 // Conditional move reg-reg
 4867 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, eFlagsReg cr ) %{
 4868     single_instruction;
 4869     dst    : S4(write);
 4870     src    : S3(read);
 4871     cr     : S3(read);
 4872     DECODE : S0;        // any decoder
 4873 %}
 4874 
 4875 // Conditional move reg-mem
 4876 pipe_class pipe_cmov_mem( eFlagsReg cr, rRegI dst, memory src) %{
 4877     single_instruction;
 4878     dst    : S4(write);
 4879     src    : S3(read);
 4880     cr     : S3(read);
 4881     DECODE : S0;        // any decoder
 4882     MEM    : S3;
 4883 %}
 4884 
 4885 // Conditional move reg-reg long
 4886 pipe_class pipe_cmov_reg_long( eFlagsReg cr, eRegL dst, eRegL src) %{
 4887     single_instruction;
 4888     dst    : S4(write);
 4889     src    : S3(read);
 4890     cr     : S3(read);
 4891     DECODE : S0(2);     // any 2 decoders
 4892 %}
 4893 
 4894 // Conditional move double reg-reg
 4895 pipe_class pipe_cmovDPR_reg( eFlagsReg cr, regDPR1 dst, regDPR src) %{
 4896     single_instruction;
 4897     dst    : S4(write);
 4898     src    : S3(read);
 4899     cr     : S3(read);
 4900     DECODE : S0;        // any decoder
 4901 %}
 4902 
 4903 // Float reg-reg operation
 4904 pipe_class fpu_reg(regDPR dst) %{
 4905     instruction_count(2);
 4906     dst    : S3(read);
 4907     DECODE : S0(2);     // any 2 decoders
 4908     FPU    : S3;
 4909 %}
 4910 
 4911 // Float reg-reg operation
 4912 pipe_class fpu_reg_reg(regDPR dst, regDPR src) %{
 4913     instruction_count(2);
 4914     dst    : S4(write);
 4915     src    : S3(read);
 4916     DECODE : S0(2);     // any 2 decoders
 4917     FPU    : S3;
 4918 %}
 4919 
 4920 // Float reg-reg operation
 4921 pipe_class fpu_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2) %{
 4922     instruction_count(3);
 4923     dst    : S4(write);
 4924     src1   : S3(read);
 4925     src2   : S3(read);
 4926     DECODE : S0(3);     // any 3 decoders
 4927     FPU    : S3(2);
 4928 %}
 4929 
 4930 // Float reg-reg operation
 4931 pipe_class fpu_reg_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2, regDPR src3) %{
 4932     instruction_count(4);
 4933     dst    : S4(write);
 4934     src1   : S3(read);
 4935     src2   : S3(read);
 4936     src3   : S3(read);
 4937     DECODE : S0(4);     // any 3 decoders
 4938     FPU    : S3(2);
 4939 %}
 4940 
 4941 // Float reg-reg operation
 4942 pipe_class fpu_reg_mem_reg_reg(regDPR dst, memory src1, regDPR src2, regDPR src3) %{
 4943     instruction_count(4);
 4944     dst    : S4(write);
 4945     src1   : S3(read);
 4946     src2   : S3(read);
 4947     src3   : S3(read);
 4948     DECODE : S1(3);     // any 3 decoders
 4949     D0     : S0;        // Big decoder only
 4950     FPU    : S3(2);
 4951     MEM    : S3;
 4952 %}
 4953 
 4954 // Float reg-mem operation
 4955 pipe_class fpu_reg_mem(regDPR dst, memory mem) %{
 4956     instruction_count(2);
 4957     dst    : S5(write);
 4958     mem    : S3(read);
 4959     D0     : S0;        // big decoder only
 4960     DECODE : S1;        // any decoder for FPU POP
 4961     FPU    : S4;
 4962     MEM    : S3;        // any mem
 4963 %}
 4964 
 4965 // Float reg-mem operation
 4966 pipe_class fpu_reg_reg_mem(regDPR dst, regDPR src1, memory mem) %{
 4967     instruction_count(3);
 4968     dst    : S5(write);
 4969     src1   : S3(read);
 4970     mem    : S3(read);
 4971     D0     : S0;        // big decoder only
 4972     DECODE : S1(2);     // any decoder for FPU POP
 4973     FPU    : S4;
 4974     MEM    : S3;        // any mem
 4975 %}
 4976 
 4977 // Float mem-reg operation
 4978 pipe_class fpu_mem_reg(memory mem, regDPR src) %{
 4979     instruction_count(2);
 4980     src    : S5(read);
 4981     mem    : S3(read);
 4982     DECODE : S0;        // any decoder for FPU PUSH
 4983     D0     : S1;        // big decoder only
 4984     FPU    : S4;
 4985     MEM    : S3;        // any mem
 4986 %}
 4987 
 4988 pipe_class fpu_mem_reg_reg(memory mem, regDPR src1, regDPR src2) %{
 4989     instruction_count(3);
 4990     src1   : S3(read);
 4991     src2   : S3(read);
 4992     mem    : S3(read);
 4993     DECODE : S0(2);     // any decoder for FPU PUSH
 4994     D0     : S1;        // big decoder only
 4995     FPU    : S4;
 4996     MEM    : S3;        // any mem
 4997 %}
 4998 
 4999 pipe_class fpu_mem_reg_mem(memory mem, regDPR src1, memory src2) %{
 5000     instruction_count(3);
 5001     src1   : S3(read);
 5002     src2   : S3(read);
 5003     mem    : S4(read);
 5004     DECODE : S0;        // any decoder for FPU PUSH
 5005     D0     : S0(2);     // big decoder only
 5006     FPU    : S4;
 5007     MEM    : S3(2);     // any mem
 5008 %}
 5009 
 5010 pipe_class fpu_mem_mem(memory dst, memory src1) %{
 5011     instruction_count(2);
 5012     src1   : S3(read);
 5013     dst    : S4(read);
 5014     D0     : S0(2);     // big decoder only
 5015     MEM    : S3(2);     // any mem
 5016 %}
 5017 
 5018 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2) %{
 5019     instruction_count(3);
 5020     src1   : S3(read);
 5021     src2   : S3(read);
 5022     dst    : S4(read);
 5023     D0     : S0(3);     // big decoder only
 5024     FPU    : S4;
 5025     MEM    : S3(3);     // any mem
 5026 %}
 5027 
 5028 pipe_class fpu_mem_reg_con(memory mem, regDPR src1) %{
 5029     instruction_count(3);
 5030     src1   : S4(read);
 5031     mem    : S4(read);
 5032     DECODE : S0;        // any decoder for FPU PUSH
 5033     D0     : S0(2);     // big decoder only
 5034     FPU    : S4;
 5035     MEM    : S3(2);     // any mem
 5036 %}
 5037 
 5038 // Float load constant
 5039 pipe_class fpu_reg_con(regDPR dst) %{
 5040     instruction_count(2);
 5041     dst    : S5(write);
 5042     D0     : S0;        // big decoder only for the load
 5043     DECODE : S1;        // any decoder for FPU POP
 5044     FPU    : S4;
 5045     MEM    : S3;        // any mem
 5046 %}
 5047 
 5048 // Float load constant
 5049 pipe_class fpu_reg_reg_con(regDPR dst, regDPR src) %{
 5050     instruction_count(3);
 5051     dst    : S5(write);
 5052     src    : S3(read);
 5053     D0     : S0;        // big decoder only for the load
 5054     DECODE : S1(2);     // any decoder for FPU POP
 5055     FPU    : S4;
 5056     MEM    : S3;        // any mem
 5057 %}
 5058 
 5059 // UnConditional branch
 5060 pipe_class pipe_jmp( label labl ) %{
 5061     single_instruction;
 5062     BR   : S3;
 5063 %}
 5064 
 5065 // Conditional branch
 5066 pipe_class pipe_jcc( cmpOp cmp, eFlagsReg cr, label labl ) %{
 5067     single_instruction;
 5068     cr    : S1(read);
 5069     BR    : S3;
 5070 %}
 5071 
 5072 // Allocation idiom
 5073 pipe_class pipe_cmpxchg( eRegP dst, eRegP heap_ptr ) %{
 5074     instruction_count(1); force_serialization;
 5075     fixed_latency(6);
 5076     heap_ptr : S3(read);
 5077     DECODE   : S0(3);
 5078     D0       : S2;
 5079     MEM      : S3;
 5080     ALU      : S3(2);
 5081     dst      : S5(write);
 5082     BR       : S5;
 5083 %}
 5084 
 5085 // Generic big/slow expanded idiom
 5086 pipe_class pipe_slow(  ) %{
 5087     instruction_count(10); multiple_bundles; force_serialization;
 5088     fixed_latency(100);
 5089     D0  : S0(2);
 5090     MEM : S3(2);
 5091 %}
 5092 
 5093 // The real do-nothing guy
 5094 pipe_class empty( ) %{
 5095     instruction_count(0);
 5096 %}
 5097 
 5098 // Define the class for the Nop node
 5099 define %{
 5100    MachNop = empty;
 5101 %}
 5102 
 5103 %}
 5104 
 5105 //----------INSTRUCTIONS-------------------------------------------------------
 5106 //
 5107 // match      -- States which machine-independent subtree may be replaced
 5108 //               by this instruction.
 5109 // ins_cost   -- The estimated cost of this instruction is used by instruction
 5110 //               selection to identify a minimum cost tree of machine
 5111 //               instructions that matches a tree of machine-independent
 5112 //               instructions.
 5113 // format     -- A string providing the disassembly for this instruction.
 5114 //               The value of an instruction&#39;s operand may be inserted
 5115 //               by referring to it with a &#39;$&#39; prefix.
 5116 // opcode     -- Three instruction opcodes may be provided.  These are referred
 5117 //               to within an encode class as $primary, $secondary, and $tertiary
 5118 //               respectively.  The primary opcode is commonly used to
 5119 //               indicate the type of machine instruction, while secondary
 5120 //               and tertiary are often used for prefix options or addressing
 5121 //               modes.
 5122 // ins_encode -- A list of encode classes with parameters. The encode class
 5123 //               name must have been defined in an &#39;enc_class&#39; specification
 5124 //               in the encode section of the architecture description.
 5125 
 5126 //----------BSWAP-Instruction--------------------------------------------------
 5127 instruct bytes_reverse_int(rRegI dst) %{
 5128   match(Set dst (ReverseBytesI dst));
 5129 
 5130   format %{ &quot;BSWAP  $dst&quot; %}
 5131   opcode(0x0F, 0xC8);
 5132   ins_encode( OpcP, OpcSReg(dst) );
 5133   ins_pipe( ialu_reg );
 5134 %}
 5135 
 5136 instruct bytes_reverse_long(eRegL dst) %{
 5137   match(Set dst (ReverseBytesL dst));
 5138 
 5139   format %{ &quot;BSWAP  $dst.lo\n\t&quot;
 5140             &quot;BSWAP  $dst.hi\n\t&quot;
 5141             &quot;XCHG   $dst.lo $dst.hi&quot; %}
 5142 
 5143   ins_cost(125);
 5144   ins_encode( bswap_long_bytes(dst) );
 5145   ins_pipe( ialu_reg_reg);
 5146 %}
 5147 
 5148 instruct bytes_reverse_unsigned_short(rRegI dst, eFlagsReg cr) %{
 5149   match(Set dst (ReverseBytesUS dst));
 5150   effect(KILL cr);
 5151 
 5152   format %{ &quot;BSWAP  $dst\n\t&quot;
 5153             &quot;SHR    $dst,16\n\t&quot; %}
 5154   ins_encode %{
 5155     __ bswapl($dst$$Register);
 5156     __ shrl($dst$$Register, 16);
 5157   %}
 5158   ins_pipe( ialu_reg );
 5159 %}
 5160 
 5161 instruct bytes_reverse_short(rRegI dst, eFlagsReg cr) %{
 5162   match(Set dst (ReverseBytesS dst));
 5163   effect(KILL cr);
 5164 
 5165   format %{ &quot;BSWAP  $dst\n\t&quot;
 5166             &quot;SAR    $dst,16\n\t&quot; %}
 5167   ins_encode %{
 5168     __ bswapl($dst$$Register);
 5169     __ sarl($dst$$Register, 16);
 5170   %}
 5171   ins_pipe( ialu_reg );
 5172 %}
 5173 
 5174 
 5175 //---------- Zeros Count Instructions ------------------------------------------
 5176 
 5177 instruct countLeadingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5178   predicate(UseCountLeadingZerosInstruction);
 5179   match(Set dst (CountLeadingZerosI src));
 5180   effect(KILL cr);
 5181 
 5182   format %{ &quot;LZCNT  $dst, $src\t# count leading zeros (int)&quot; %}
 5183   ins_encode %{
 5184     __ lzcntl($dst$$Register, $src$$Register);
 5185   %}
 5186   ins_pipe(ialu_reg);
 5187 %}
 5188 
 5189 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, eFlagsReg cr) %{
 5190   predicate(!UseCountLeadingZerosInstruction);
 5191   match(Set dst (CountLeadingZerosI src));
 5192   effect(KILL cr);
 5193 
 5194   format %{ &quot;BSR    $dst, $src\t# count leading zeros (int)\n\t&quot;
 5195             &quot;JNZ    skip\n\t&quot;
 5196             &quot;MOV    $dst, -1\n&quot;
 5197       &quot;skip:\n\t&quot;
 5198             &quot;NEG    $dst\n\t&quot;
 5199             &quot;ADD    $dst, 31&quot; %}
 5200   ins_encode %{
 5201     Register Rdst = $dst$$Register;
 5202     Register Rsrc = $src$$Register;
 5203     Label skip;
 5204     __ bsrl(Rdst, Rsrc);
 5205     __ jccb(Assembler::notZero, skip);
 5206     __ movl(Rdst, -1);
 5207     __ bind(skip);
 5208     __ negl(Rdst);
 5209     __ addl(Rdst, BitsPerInt - 1);
 5210   %}
 5211   ins_pipe(ialu_reg);
 5212 %}
 5213 
 5214 instruct countLeadingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5215   predicate(UseCountLeadingZerosInstruction);
 5216   match(Set dst (CountLeadingZerosL src));
 5217   effect(TEMP dst, KILL cr);
 5218 
 5219   format %{ &quot;LZCNT  $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5220             &quot;JNC    done\n\t&quot;
 5221             &quot;LZCNT  $dst, $src.lo\n\t&quot;
 5222             &quot;ADD    $dst, 32\n&quot;
 5223       &quot;done:&quot; %}
 5224   ins_encode %{
 5225     Register Rdst = $dst$$Register;
 5226     Register Rsrc = $src$$Register;
 5227     Label done;
 5228     __ lzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5229     __ jccb(Assembler::carryClear, done);
 5230     __ lzcntl(Rdst, Rsrc);
 5231     __ addl(Rdst, BitsPerInt);
 5232     __ bind(done);
 5233   %}
 5234   ins_pipe(ialu_reg);
 5235 %}
 5236 
 5237 instruct countLeadingZerosL_bsr(rRegI dst, eRegL src, eFlagsReg cr) %{
 5238   predicate(!UseCountLeadingZerosInstruction);
 5239   match(Set dst (CountLeadingZerosL src));
 5240   effect(TEMP dst, KILL cr);
 5241 
 5242   format %{ &quot;BSR    $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5243             &quot;JZ     msw_is_zero\n\t&quot;
 5244             &quot;ADD    $dst, 32\n\t&quot;
 5245             &quot;JMP    not_zero\n&quot;
 5246       &quot;msw_is_zero:\n\t&quot;
 5247             &quot;BSR    $dst, $src.lo\n\t&quot;
 5248             &quot;JNZ    not_zero\n\t&quot;
 5249             &quot;MOV    $dst, -1\n&quot;
 5250       &quot;not_zero:\n\t&quot;
 5251             &quot;NEG    $dst\n\t&quot;
 5252             &quot;ADD    $dst, 63\n&quot; %}
 5253  ins_encode %{
 5254     Register Rdst = $dst$$Register;
 5255     Register Rsrc = $src$$Register;
 5256     Label msw_is_zero;
 5257     Label not_zero;
 5258     __ bsrl(Rdst, HIGH_FROM_LOW(Rsrc));
 5259     __ jccb(Assembler::zero, msw_is_zero);
 5260     __ addl(Rdst, BitsPerInt);
 5261     __ jmpb(not_zero);
 5262     __ bind(msw_is_zero);
 5263     __ bsrl(Rdst, Rsrc);
 5264     __ jccb(Assembler::notZero, not_zero);
 5265     __ movl(Rdst, -1);
 5266     __ bind(not_zero);
 5267     __ negl(Rdst);
 5268     __ addl(Rdst, BitsPerLong - 1);
 5269   %}
 5270   ins_pipe(ialu_reg);
 5271 %}
 5272 
 5273 instruct countTrailingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5274   predicate(UseCountTrailingZerosInstruction);
 5275   match(Set dst (CountTrailingZerosI src));
 5276   effect(KILL cr);
 5277 
 5278   format %{ &quot;TZCNT    $dst, $src\t# count trailing zeros (int)&quot; %}
 5279   ins_encode %{
 5280     __ tzcntl($dst$$Register, $src$$Register);
 5281   %}
 5282   ins_pipe(ialu_reg);
 5283 %}
 5284 
 5285 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, eFlagsReg cr) %{
 5286   predicate(!UseCountTrailingZerosInstruction);
 5287   match(Set dst (CountTrailingZerosI src));
 5288   effect(KILL cr);
 5289 
 5290   format %{ &quot;BSF    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 5291             &quot;JNZ    done\n\t&quot;
 5292             &quot;MOV    $dst, 32\n&quot;
 5293       &quot;done:&quot; %}
 5294   ins_encode %{
 5295     Register Rdst = $dst$$Register;
 5296     Label done;
 5297     __ bsfl(Rdst, $src$$Register);
 5298     __ jccb(Assembler::notZero, done);
 5299     __ movl(Rdst, BitsPerInt);
 5300     __ bind(done);
 5301   %}
 5302   ins_pipe(ialu_reg);
 5303 %}
 5304 
 5305 instruct countTrailingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5306   predicate(UseCountTrailingZerosInstruction);
 5307   match(Set dst (CountTrailingZerosL src));
 5308   effect(TEMP dst, KILL cr);
 5309 
 5310   format %{ &quot;TZCNT  $dst, $src.lo\t# count trailing zeros (long) \n\t&quot;
 5311             &quot;JNC    done\n\t&quot;
 5312             &quot;TZCNT  $dst, $src.hi\n\t&quot;
 5313             &quot;ADD    $dst, 32\n&quot;
 5314             &quot;done:&quot; %}
 5315   ins_encode %{
 5316     Register Rdst = $dst$$Register;
 5317     Register Rsrc = $src$$Register;
 5318     Label done;
 5319     __ tzcntl(Rdst, Rsrc);
 5320     __ jccb(Assembler::carryClear, done);
 5321     __ tzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5322     __ addl(Rdst, BitsPerInt);
 5323     __ bind(done);
 5324   %}
 5325   ins_pipe(ialu_reg);
 5326 %}
 5327 
 5328 instruct countTrailingZerosL_bsf(rRegI dst, eRegL src, eFlagsReg cr) %{
 5329   predicate(!UseCountTrailingZerosInstruction);
 5330   match(Set dst (CountTrailingZerosL src));
 5331   effect(TEMP dst, KILL cr);
 5332 
 5333   format %{ &quot;BSF    $dst, $src.lo\t# count trailing zeros (long)\n\t&quot;
 5334             &quot;JNZ    done\n\t&quot;
 5335             &quot;BSF    $dst, $src.hi\n\t&quot;
 5336             &quot;JNZ    msw_not_zero\n\t&quot;
 5337             &quot;MOV    $dst, 32\n&quot;
 5338       &quot;msw_not_zero:\n\t&quot;
 5339             &quot;ADD    $dst, 32\n&quot;
 5340       &quot;done:&quot; %}
 5341   ins_encode %{
 5342     Register Rdst = $dst$$Register;
 5343     Register Rsrc = $src$$Register;
 5344     Label msw_not_zero;
 5345     Label done;
 5346     __ bsfl(Rdst, Rsrc);
 5347     __ jccb(Assembler::notZero, done);
 5348     __ bsfl(Rdst, HIGH_FROM_LOW(Rsrc));
 5349     __ jccb(Assembler::notZero, msw_not_zero);
 5350     __ movl(Rdst, BitsPerInt);
 5351     __ bind(msw_not_zero);
 5352     __ addl(Rdst, BitsPerInt);
 5353     __ bind(done);
 5354   %}
 5355   ins_pipe(ialu_reg);
 5356 %}
 5357 
 5358 
 5359 //---------- Population Count Instructions -------------------------------------
 5360 
 5361 instruct popCountI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5362   predicate(UsePopCountInstruction);
 5363   match(Set dst (PopCountI src));
 5364   effect(KILL cr);
 5365 
 5366   format %{ &quot;POPCNT $dst, $src&quot; %}
 5367   ins_encode %{
 5368     __ popcntl($dst$$Register, $src$$Register);
 5369   %}
 5370   ins_pipe(ialu_reg);
 5371 %}
 5372 
 5373 instruct popCountI_mem(rRegI dst, memory mem, eFlagsReg cr) %{
 5374   predicate(UsePopCountInstruction);
 5375   match(Set dst (PopCountI (LoadI mem)));
 5376   effect(KILL cr);
 5377 
 5378   format %{ &quot;POPCNT $dst, $mem&quot; %}
 5379   ins_encode %{
 5380     __ popcntl($dst$$Register, $mem$$Address);
 5381   %}
 5382   ins_pipe(ialu_reg);
 5383 %}
 5384 
 5385 // Note: Long.bitCount(long) returns an int.
 5386 instruct popCountL(rRegI dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 5387   predicate(UsePopCountInstruction);
 5388   match(Set dst (PopCountL src));
 5389   effect(KILL cr, TEMP tmp, TEMP dst);
 5390 
 5391   format %{ &quot;POPCNT $dst, $src.lo\n\t&quot;
 5392             &quot;POPCNT $tmp, $src.hi\n\t&quot;
 5393             &quot;ADD    $dst, $tmp&quot; %}
 5394   ins_encode %{
 5395     __ popcntl($dst$$Register, $src$$Register);
 5396     __ popcntl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 5397     __ addl($dst$$Register, $tmp$$Register);
 5398   %}
 5399   ins_pipe(ialu_reg);
 5400 %}
 5401 
 5402 // Note: Long.bitCount(long) returns an int.
 5403 instruct popCountL_mem(rRegI dst, memory mem, rRegI tmp, eFlagsReg cr) %{
 5404   predicate(UsePopCountInstruction);
 5405   match(Set dst (PopCountL (LoadL mem)));
 5406   effect(KILL cr, TEMP tmp, TEMP dst);
 5407 
 5408   format %{ &quot;POPCNT $dst, $mem\n\t&quot;
 5409             &quot;POPCNT $tmp, $mem+4\n\t&quot;
 5410             &quot;ADD    $dst, $tmp&quot; %}
 5411   ins_encode %{
 5412     //__ popcntl($dst$$Register, $mem$$Address$$first);
 5413     //__ popcntl($tmp$$Register, $mem$$Address$$second);
 5414     __ popcntl($dst$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none));
 5415     __ popcntl($tmp$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none));
 5416     __ addl($dst$$Register, $tmp$$Register);
 5417   %}
 5418   ins_pipe(ialu_reg);
 5419 %}
 5420 
 5421 
 5422 //----------Load/Store/Move Instructions---------------------------------------
 5423 //----------Load Instructions--------------------------------------------------
 5424 // Load Byte (8bit signed)
 5425 instruct loadB(xRegI dst, memory mem) %{
 5426   match(Set dst (LoadB mem));
 5427 
 5428   ins_cost(125);
 5429   format %{ &quot;MOVSX8 $dst,$mem\t# byte&quot; %}
 5430 
 5431   ins_encode %{
 5432     __ movsbl($dst$$Register, $mem$$Address);
 5433   %}
 5434 
 5435   ins_pipe(ialu_reg_mem);
 5436 %}
 5437 
 5438 // Load Byte (8bit signed) into Long Register
 5439 instruct loadB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5440   match(Set dst (ConvI2L (LoadB mem)));
 5441   effect(KILL cr);
 5442 
 5443   ins_cost(375);
 5444   format %{ &quot;MOVSX8 $dst.lo,$mem\t# byte -&gt; long\n\t&quot;
 5445             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5446             &quot;SAR    $dst.hi,7&quot; %}
 5447 
 5448   ins_encode %{
 5449     __ movsbl($dst$$Register, $mem$$Address);
 5450     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5451     __ sarl(HIGH_FROM_LOW($dst$$Register), 7); // 24+1 MSB are already signed extended.
 5452   %}
 5453 
 5454   ins_pipe(ialu_reg_mem);
 5455 %}
 5456 
 5457 // Load Unsigned Byte (8bit UNsigned)
 5458 instruct loadUB(xRegI dst, memory mem) %{
 5459   match(Set dst (LoadUB mem));
 5460 
 5461   ins_cost(125);
 5462   format %{ &quot;MOVZX8 $dst,$mem\t# ubyte -&gt; int&quot; %}
 5463 
 5464   ins_encode %{
 5465     __ movzbl($dst$$Register, $mem$$Address);
 5466   %}
 5467 
 5468   ins_pipe(ialu_reg_mem);
 5469 %}
 5470 
 5471 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 5472 instruct loadUB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5473   match(Set dst (ConvI2L (LoadUB mem)));
 5474   effect(KILL cr);
 5475 
 5476   ins_cost(250);
 5477   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte -&gt; long\n\t&quot;
 5478             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5479 
 5480   ins_encode %{
 5481     Register Rdst = $dst$$Register;
 5482     __ movzbl(Rdst, $mem$$Address);
 5483     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5484   %}
 5485 
 5486   ins_pipe(ialu_reg_mem);
 5487 %}
 5488 
 5489 // Load Unsigned Byte (8 bit UNsigned) with mask into Long Register
 5490 instruct loadUB2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5491   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5492   effect(KILL cr);
 5493 
 5494   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5495             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5496             &quot;AND    $dst.lo,right_n_bits($mask, 8)&quot; %}
 5497   ins_encode %{
 5498     Register Rdst = $dst$$Register;
 5499     __ movzbl(Rdst, $mem$$Address);
 5500     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5501     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 5502   %}
 5503   ins_pipe(ialu_reg_mem);
 5504 %}
 5505 
 5506 // Load Short (16bit signed)
 5507 instruct loadS(rRegI dst, memory mem) %{
 5508   match(Set dst (LoadS mem));
 5509 
 5510   ins_cost(125);
 5511   format %{ &quot;MOVSX  $dst,$mem\t# short&quot; %}
 5512 
 5513   ins_encode %{
 5514     __ movswl($dst$$Register, $mem$$Address);
 5515   %}
 5516 
 5517   ins_pipe(ialu_reg_mem);
 5518 %}
 5519 
 5520 // Load Short (16 bit signed) to Byte (8 bit signed)
 5521 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5522   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5523 
 5524   ins_cost(125);
 5525   format %{ &quot;MOVSX  $dst, $mem\t# short -&gt; byte&quot; %}
 5526   ins_encode %{
 5527     __ movsbl($dst$$Register, $mem$$Address);
 5528   %}
 5529   ins_pipe(ialu_reg_mem);
 5530 %}
 5531 
 5532 // Load Short (16bit signed) into Long Register
 5533 instruct loadS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5534   match(Set dst (ConvI2L (LoadS mem)));
 5535   effect(KILL cr);
 5536 
 5537   ins_cost(375);
 5538   format %{ &quot;MOVSX  $dst.lo,$mem\t# short -&gt; long\n\t&quot;
 5539             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5540             &quot;SAR    $dst.hi,15&quot; %}
 5541 
 5542   ins_encode %{
 5543     __ movswl($dst$$Register, $mem$$Address);
 5544     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5545     __ sarl(HIGH_FROM_LOW($dst$$Register), 15); // 16+1 MSB are already signed extended.
 5546   %}
 5547 
 5548   ins_pipe(ialu_reg_mem);
 5549 %}
 5550 
 5551 // Load Unsigned Short/Char (16bit unsigned)
 5552 instruct loadUS(rRegI dst, memory mem) %{
 5553   match(Set dst (LoadUS mem));
 5554 
 5555   ins_cost(125);
 5556   format %{ &quot;MOVZX  $dst,$mem\t# ushort/char -&gt; int&quot; %}
 5557 
 5558   ins_encode %{
 5559     __ movzwl($dst$$Register, $mem$$Address);
 5560   %}
 5561 
 5562   ins_pipe(ialu_reg_mem);
 5563 %}
 5564 
 5565 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5566 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5567   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5568 
 5569   ins_cost(125);
 5570   format %{ &quot;MOVSX  $dst, $mem\t# ushort -&gt; byte&quot; %}
 5571   ins_encode %{
 5572     __ movsbl($dst$$Register, $mem$$Address);
 5573   %}
 5574   ins_pipe(ialu_reg_mem);
 5575 %}
 5576 
 5577 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 5578 instruct loadUS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5579   match(Set dst (ConvI2L (LoadUS mem)));
 5580   effect(KILL cr);
 5581 
 5582   ins_cost(250);
 5583   format %{ &quot;MOVZX  $dst.lo,$mem\t# ushort/char -&gt; long\n\t&quot;
 5584             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5585 
 5586   ins_encode %{
 5587     __ movzwl($dst$$Register, $mem$$Address);
 5588     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5589   %}
 5590 
 5591   ins_pipe(ialu_reg_mem);
 5592 %}
 5593 
 5594 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 5595 instruct loadUS2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5596   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5597   effect(KILL cr);
 5598 
 5599   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ushort/char &amp; 0xFF -&gt; long\n\t&quot;
 5600             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5601   ins_encode %{
 5602     Register Rdst = $dst$$Register;
 5603     __ movzbl(Rdst, $mem$$Address);
 5604     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5605   %}
 5606   ins_pipe(ialu_reg_mem);
 5607 %}
 5608 
 5609 // Load Unsigned Short/Char (16 bit UNsigned) with a 32-bit mask into Long Register
 5610 instruct loadUS2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5611   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5612   effect(KILL cr);
 5613 
 5614   format %{ &quot;MOVZX  $dst.lo, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5615             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5616             &quot;AND    $dst.lo,right_n_bits($mask, 16)&quot; %}
 5617   ins_encode %{
 5618     Register Rdst = $dst$$Register;
 5619     __ movzwl(Rdst, $mem$$Address);
 5620     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5621     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 5622   %}
 5623   ins_pipe(ialu_reg_mem);
 5624 %}
 5625 
 5626 // Load Integer
 5627 instruct loadI(rRegI dst, memory mem) %{
 5628   match(Set dst (LoadI mem));
 5629 
 5630   ins_cost(125);
 5631   format %{ &quot;MOV    $dst,$mem\t# int&quot; %}
 5632 
 5633   ins_encode %{
 5634     __ movl($dst$$Register, $mem$$Address);
 5635   %}
 5636 
 5637   ins_pipe(ialu_reg_mem);
 5638 %}
 5639 
 5640 // Load Integer (32 bit signed) to Byte (8 bit signed)
 5641 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5642   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5643 
 5644   ins_cost(125);
 5645   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; byte&quot; %}
 5646   ins_encode %{
 5647     __ movsbl($dst$$Register, $mem$$Address);
 5648   %}
 5649   ins_pipe(ialu_reg_mem);
 5650 %}
 5651 
 5652 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 5653 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 5654   match(Set dst (AndI (LoadI mem) mask));
 5655 
 5656   ins_cost(125);
 5657   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ubyte&quot; %}
 5658   ins_encode %{
 5659     __ movzbl($dst$$Register, $mem$$Address);
 5660   %}
 5661   ins_pipe(ialu_reg_mem);
 5662 %}
 5663 
 5664 // Load Integer (32 bit signed) to Short (16 bit signed)
 5665 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5666   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5667 
 5668   ins_cost(125);
 5669   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; short&quot; %}
 5670   ins_encode %{
 5671     __ movswl($dst$$Register, $mem$$Address);
 5672   %}
 5673   ins_pipe(ialu_reg_mem);
 5674 %}
 5675 
 5676 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5677 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5678   match(Set dst (AndI (LoadI mem) mask));
 5679 
 5680   ins_cost(125);
 5681   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5682   ins_encode %{
 5683     __ movzwl($dst$$Register, $mem$$Address);
 5684   %}
 5685   ins_pipe(ialu_reg_mem);
 5686 %}
 5687 
 5688 // Load Integer into Long Register
 5689 instruct loadI2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5690   match(Set dst (ConvI2L (LoadI mem)));
 5691   effect(KILL cr);
 5692 
 5693   ins_cost(375);
 5694   format %{ &quot;MOV    $dst.lo,$mem\t# int -&gt; long\n\t&quot;
 5695             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5696             &quot;SAR    $dst.hi,31&quot; %}
 5697 
 5698   ins_encode %{
 5699     __ movl($dst$$Register, $mem$$Address);
 5700     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5701     __ sarl(HIGH_FROM_LOW($dst$$Register), 31);
 5702   %}
 5703 
 5704   ins_pipe(ialu_reg_mem);
 5705 %}
 5706 
 5707 // Load Integer with mask 0xFF into Long Register
 5708 instruct loadI2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5709   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5710   effect(KILL cr);
 5711 
 5712   format %{ &quot;MOVZX8 $dst.lo,$mem\t# int &amp; 0xFF -&gt; long\n\t&quot;
 5713             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5714   ins_encode %{
 5715     Register Rdst = $dst$$Register;
 5716     __ movzbl(Rdst, $mem$$Address);
 5717     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5718   %}
 5719   ins_pipe(ialu_reg_mem);
 5720 %}
 5721 
 5722 // Load Integer with mask 0xFFFF into Long Register
 5723 instruct loadI2L_immI_65535(eRegL dst, memory mem, immI_65535 mask, eFlagsReg cr) %{
 5724   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5725   effect(KILL cr);
 5726 
 5727   format %{ &quot;MOVZX  $dst.lo,$mem\t# int &amp; 0xFFFF -&gt; long\n\t&quot;
 5728             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5729   ins_encode %{
 5730     Register Rdst = $dst$$Register;
 5731     __ movzwl(Rdst, $mem$$Address);
 5732     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5733   %}
 5734   ins_pipe(ialu_reg_mem);
 5735 %}
 5736 
 5737 // Load Integer with 31-bit mask into Long Register
 5738 instruct loadI2L_immU31(eRegL dst, memory mem, immU31 mask, eFlagsReg cr) %{
 5739   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5740   effect(KILL cr);
 5741 
 5742   format %{ &quot;MOV    $dst.lo,$mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5743             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5744             &quot;AND    $dst.lo,$mask&quot; %}
 5745   ins_encode %{
 5746     Register Rdst = $dst$$Register;
 5747     __ movl(Rdst, $mem$$Address);
 5748     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5749     __ andl(Rdst, $mask$$constant);
 5750   %}
 5751   ins_pipe(ialu_reg_mem);
 5752 %}
 5753 
 5754 // Load Unsigned Integer into Long Register
 5755 instruct loadUI2L(eRegL dst, memory mem, immL_32bits mask, eFlagsReg cr) %{
 5756   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5757   effect(KILL cr);
 5758 
 5759   ins_cost(250);
 5760   format %{ &quot;MOV    $dst.lo,$mem\t# uint -&gt; long\n\t&quot;
 5761             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5762 
 5763   ins_encode %{
 5764     __ movl($dst$$Register, $mem$$Address);
 5765     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5766   %}
 5767 
 5768   ins_pipe(ialu_reg_mem);
 5769 %}
 5770 
 5771 // Load Long.  Cannot clobber address while loading, so restrict address
 5772 // register to ESI
 5773 instruct loadL(eRegL dst, load_long_memory mem) %{
 5774   predicate(!((LoadLNode*)n)-&gt;require_atomic_access());
 5775   match(Set dst (LoadL mem));
 5776 
 5777   ins_cost(250);
 5778   format %{ &quot;MOV    $dst.lo,$mem\t# long\n\t&quot;
 5779             &quot;MOV    $dst.hi,$mem+4&quot; %}
 5780 
 5781   ins_encode %{
 5782     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 5783     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 5784     __ movl($dst$$Register, Amemlo);
 5785     __ movl(HIGH_FROM_LOW($dst$$Register), Amemhi);
 5786   %}
 5787 
 5788   ins_pipe(ialu_reg_long_mem);
 5789 %}
 5790 
 5791 // Volatile Load Long.  Must be atomic, so do 64-bit FILD
 5792 // then store it down to the stack and reload on the int
 5793 // side.
 5794 instruct loadL_volatile(stackSlotL dst, memory mem) %{
 5795   predicate(UseSSE&lt;=1 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5796   match(Set dst (LoadL mem));
 5797 
 5798   ins_cost(200);
 5799   format %{ &quot;FILD   $mem\t# Atomic volatile long load\n\t&quot;
 5800             &quot;FISTp  $dst&quot; %}
 5801   ins_encode(enc_loadL_volatile(mem,dst));
 5802   ins_pipe( fpu_reg_mem );
 5803 %}
 5804 
 5805 instruct loadLX_volatile(stackSlotL dst, memory mem, regD tmp) %{
 5806   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5807   match(Set dst (LoadL mem));
 5808   effect(TEMP tmp);
 5809   ins_cost(180);
 5810   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5811             &quot;MOVSD  $dst,$tmp&quot; %}
 5812   ins_encode %{
 5813     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5814     __ movdbl(Address(rsp, $dst$$disp), $tmp$$XMMRegister);
 5815   %}
 5816   ins_pipe( pipe_slow );
 5817 %}
 5818 
 5819 instruct loadLX_reg_volatile(eRegL dst, memory mem, regD tmp) %{
 5820   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5821   match(Set dst (LoadL mem));
 5822   effect(TEMP tmp);
 5823   ins_cost(160);
 5824   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5825             &quot;MOVD   $dst.lo,$tmp\n\t&quot;
 5826             &quot;PSRLQ  $tmp,32\n\t&quot;
 5827             &quot;MOVD   $dst.hi,$tmp&quot; %}
 5828   ins_encode %{
 5829     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5830     __ movdl($dst$$Register, $tmp$$XMMRegister);
 5831     __ psrlq($tmp$$XMMRegister, 32);
 5832     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
 5833   %}
 5834   ins_pipe( pipe_slow );
 5835 %}
 5836 
 5837 // Load Range
 5838 instruct loadRange(rRegI dst, memory mem) %{
 5839   match(Set dst (LoadRange mem));
 5840 
 5841   ins_cost(125);
 5842   format %{ &quot;MOV    $dst,$mem&quot; %}
 5843   opcode(0x8B);
 5844   ins_encode( OpcP, RegMem(dst,mem));
 5845   ins_pipe( ialu_reg_mem );
 5846 %}
 5847 
 5848 
 5849 // Load Pointer
 5850 instruct loadP(eRegP dst, memory mem) %{
 5851   match(Set dst (LoadP mem));
 5852 
 5853   ins_cost(125);
 5854   format %{ &quot;MOV    $dst,$mem&quot; %}
 5855   opcode(0x8B);
 5856   ins_encode( OpcP, RegMem(dst,mem));
 5857   ins_pipe( ialu_reg_mem );
 5858 %}
 5859 
 5860 // Load Klass Pointer
 5861 instruct loadKlass(eRegP dst, memory mem) %{
 5862   match(Set dst (LoadKlass mem));
 5863 
 5864   ins_cost(125);
 5865   format %{ &quot;MOV    $dst,$mem&quot; %}
 5866   opcode(0x8B);
 5867   ins_encode( OpcP, RegMem(dst,mem));
 5868   ins_pipe( ialu_reg_mem );
 5869 %}
 5870 
 5871 // Load Double
 5872 instruct loadDPR(regDPR dst, memory mem) %{
 5873   predicate(UseSSE&lt;=1);
 5874   match(Set dst (LoadD mem));
 5875 
 5876   ins_cost(150);
 5877   format %{ &quot;FLD_D  ST,$mem\n\t&quot;
 5878             &quot;FSTP   $dst&quot; %}
 5879   opcode(0xDD);               /* DD /0 */
 5880   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5881               Pop_Reg_DPR(dst) );
 5882   ins_pipe( fpu_reg_mem );
 5883 %}
 5884 
 5885 // Load Double to XMM
 5886 instruct loadD(regD dst, memory mem) %{
 5887   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
 5888   match(Set dst (LoadD mem));
 5889   ins_cost(145);
 5890   format %{ &quot;MOVSD  $dst,$mem&quot; %}
 5891   ins_encode %{
 5892     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5893   %}
 5894   ins_pipe( pipe_slow );
 5895 %}
 5896 
 5897 instruct loadD_partial(regD dst, memory mem) %{
 5898   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
 5899   match(Set dst (LoadD mem));
 5900   ins_cost(145);
 5901   format %{ &quot;MOVLPD $dst,$mem&quot; %}
 5902   ins_encode %{
 5903     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5904   %}
 5905   ins_pipe( pipe_slow );
 5906 %}
 5907 
 5908 // Load to XMM register (single-precision floating point)
 5909 // MOVSS instruction
 5910 instruct loadF(regF dst, memory mem) %{
 5911   predicate(UseSSE&gt;=1);
 5912   match(Set dst (LoadF mem));
 5913   ins_cost(145);
 5914   format %{ &quot;MOVSS  $dst,$mem&quot; %}
 5915   ins_encode %{
 5916     __ movflt ($dst$$XMMRegister, $mem$$Address);
 5917   %}
 5918   ins_pipe( pipe_slow );
 5919 %}
 5920 
 5921 // Load Float
 5922 instruct loadFPR(regFPR dst, memory mem) %{
 5923   predicate(UseSSE==0);
 5924   match(Set dst (LoadF mem));
 5925 
 5926   ins_cost(150);
 5927   format %{ &quot;FLD_S  ST,$mem\n\t&quot;
 5928             &quot;FSTP   $dst&quot; %}
 5929   opcode(0xD9);               /* D9 /0 */
 5930   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5931               Pop_Reg_FPR(dst) );
 5932   ins_pipe( fpu_reg_mem );
 5933 %}
 5934 
 5935 // Load Effective Address
 5936 instruct leaP8(eRegP dst, indOffset8 mem) %{
 5937   match(Set dst mem);
 5938 
 5939   ins_cost(110);
 5940   format %{ &quot;LEA    $dst,$mem&quot; %}
 5941   opcode(0x8D);
 5942   ins_encode( OpcP, RegMem(dst,mem));
 5943   ins_pipe( ialu_reg_reg_fat );
 5944 %}
 5945 
 5946 instruct leaP32(eRegP dst, indOffset32 mem) %{
 5947   match(Set dst mem);
 5948 
 5949   ins_cost(110);
 5950   format %{ &quot;LEA    $dst,$mem&quot; %}
 5951   opcode(0x8D);
 5952   ins_encode( OpcP, RegMem(dst,mem));
 5953   ins_pipe( ialu_reg_reg_fat );
 5954 %}
 5955 
 5956 instruct leaPIdxOff(eRegP dst, indIndexOffset mem) %{
 5957   match(Set dst mem);
 5958 
 5959   ins_cost(110);
 5960   format %{ &quot;LEA    $dst,$mem&quot; %}
 5961   opcode(0x8D);
 5962   ins_encode( OpcP, RegMem(dst,mem));
 5963   ins_pipe( ialu_reg_reg_fat );
 5964 %}
 5965 
 5966 instruct leaPIdxScale(eRegP dst, indIndexScale mem) %{
 5967   match(Set dst mem);
 5968 
 5969   ins_cost(110);
 5970   format %{ &quot;LEA    $dst,$mem&quot; %}
 5971   opcode(0x8D);
 5972   ins_encode( OpcP, RegMem(dst,mem));
 5973   ins_pipe( ialu_reg_reg_fat );
 5974 %}
 5975 
 5976 instruct leaPIdxScaleOff(eRegP dst, indIndexScaleOffset mem) %{
 5977   match(Set dst mem);
 5978 
 5979   ins_cost(110);
 5980   format %{ &quot;LEA    $dst,$mem&quot; %}
 5981   opcode(0x8D);
 5982   ins_encode( OpcP, RegMem(dst,mem));
 5983   ins_pipe( ialu_reg_reg_fat );
 5984 %}
 5985 
 5986 // Load Constant
 5987 instruct loadConI(rRegI dst, immI src) %{
 5988   match(Set dst src);
 5989 
 5990   format %{ &quot;MOV    $dst,$src&quot; %}
 5991   ins_encode( LdImmI(dst, src) );
 5992   ins_pipe( ialu_reg_fat );
 5993 %}
 5994 
 5995 // Load Constant zero
 5996 instruct loadConI0(rRegI dst, immI0 src, eFlagsReg cr) %{
 5997   match(Set dst src);
 5998   effect(KILL cr);
 5999 
 6000   ins_cost(50);
 6001   format %{ &quot;XOR    $dst,$dst&quot; %}
 6002   opcode(0x33);  /* + rd */
 6003   ins_encode( OpcP, RegReg( dst, dst ) );
 6004   ins_pipe( ialu_reg );
 6005 %}
 6006 
 6007 instruct loadConP(eRegP dst, immP src) %{
 6008   match(Set dst src);
 6009 
 6010   format %{ &quot;MOV    $dst,$src&quot; %}
 6011   opcode(0xB8);  /* + rd */
 6012   ins_encode( LdImmP(dst, src) );
 6013   ins_pipe( ialu_reg_fat );
 6014 %}
 6015 
 6016 instruct loadConL(eRegL dst, immL src, eFlagsReg cr) %{
 6017   match(Set dst src);
 6018   effect(KILL cr);
 6019   ins_cost(200);
 6020   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
 6021             &quot;MOV    $dst.hi,$src.hi&quot; %}
 6022   opcode(0xB8);
 6023   ins_encode( LdImmL_Lo(dst, src), LdImmL_Hi(dst, src) );
 6024   ins_pipe( ialu_reg_long_fat );
 6025 %}
 6026 
 6027 instruct loadConL0(eRegL dst, immL0 src, eFlagsReg cr) %{
 6028   match(Set dst src);
 6029   effect(KILL cr);
 6030   ins_cost(150);
 6031   format %{ &quot;XOR    $dst.lo,$dst.lo\n\t&quot;
 6032             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 6033   opcode(0x33,0x33);
 6034   ins_encode( RegReg_Lo(dst,dst), RegReg_Hi(dst, dst) );
 6035   ins_pipe( ialu_reg_long );
 6036 %}
 6037 
 6038 // The instruction usage is guarded by predicate in operand immFPR().
 6039 instruct loadConFPR(regFPR dst, immFPR con) %{
 6040   match(Set dst con);
 6041   ins_cost(125);
 6042   format %{ &quot;FLD_S  ST,[$constantaddress]\t# load from constant table: float=$con\n\t&quot;
 6043             &quot;FSTP   $dst&quot; %}
 6044   ins_encode %{
 6045     __ fld_s($constantaddress($con));
 6046     __ fstp_d($dst$$reg);
 6047   %}
 6048   ins_pipe(fpu_reg_con);
 6049 %}
 6050 
 6051 // The instruction usage is guarded by predicate in operand immFPR0().
 6052 instruct loadConFPR0(regFPR dst, immFPR0 con) %{
 6053   match(Set dst con);
 6054   ins_cost(125);
 6055   format %{ &quot;FLDZ   ST\n\t&quot;
 6056             &quot;FSTP   $dst&quot; %}
 6057   ins_encode %{
 6058     __ fldz();
 6059     __ fstp_d($dst$$reg);
 6060   %}
 6061   ins_pipe(fpu_reg_con);
 6062 %}
 6063 
 6064 // The instruction usage is guarded by predicate in operand immFPR1().
 6065 instruct loadConFPR1(regFPR dst, immFPR1 con) %{
 6066   match(Set dst con);
 6067   ins_cost(125);
 6068   format %{ &quot;FLD1   ST\n\t&quot;
 6069             &quot;FSTP   $dst&quot; %}
 6070   ins_encode %{
 6071     __ fld1();
 6072     __ fstp_d($dst$$reg);
 6073   %}
 6074   ins_pipe(fpu_reg_con);
 6075 %}
 6076 
 6077 // The instruction usage is guarded by predicate in operand immF().
 6078 instruct loadConF(regF dst, immF con) %{
 6079   match(Set dst con);
 6080   ins_cost(125);
 6081   format %{ &quot;MOVSS  $dst,[$constantaddress]\t# load from constant table: float=$con&quot; %}
 6082   ins_encode %{
 6083     __ movflt($dst$$XMMRegister, $constantaddress($con));
 6084   %}
 6085   ins_pipe(pipe_slow);
 6086 %}
 6087 
 6088 // The instruction usage is guarded by predicate in operand immF0().
 6089 instruct loadConF0(regF dst, immF0 src) %{
 6090   match(Set dst src);
 6091   ins_cost(100);
 6092   format %{ &quot;XORPS  $dst,$dst\t# float 0.0&quot; %}
 6093   ins_encode %{
 6094     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 6095   %}
 6096   ins_pipe(pipe_slow);
 6097 %}
 6098 
 6099 // The instruction usage is guarded by predicate in operand immDPR().
 6100 instruct loadConDPR(regDPR dst, immDPR con) %{
 6101   match(Set dst con);
 6102   ins_cost(125);
 6103 
 6104   format %{ &quot;FLD_D  ST,[$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 6105             &quot;FSTP   $dst&quot; %}
 6106   ins_encode %{
 6107     __ fld_d($constantaddress($con));
 6108     __ fstp_d($dst$$reg);
 6109   %}
 6110   ins_pipe(fpu_reg_con);
 6111 %}
 6112 
 6113 // The instruction usage is guarded by predicate in operand immDPR0().
 6114 instruct loadConDPR0(regDPR dst, immDPR0 con) %{
 6115   match(Set dst con);
 6116   ins_cost(125);
 6117 
 6118   format %{ &quot;FLDZ   ST\n\t&quot;
 6119             &quot;FSTP   $dst&quot; %}
 6120   ins_encode %{
 6121     __ fldz();
 6122     __ fstp_d($dst$$reg);
 6123   %}
 6124   ins_pipe(fpu_reg_con);
 6125 %}
 6126 
 6127 // The instruction usage is guarded by predicate in operand immDPR1().
 6128 instruct loadConDPR1(regDPR dst, immDPR1 con) %{
 6129   match(Set dst con);
 6130   ins_cost(125);
 6131 
 6132   format %{ &quot;FLD1   ST\n\t&quot;
 6133             &quot;FSTP   $dst&quot; %}
 6134   ins_encode %{
 6135     __ fld1();
 6136     __ fstp_d($dst$$reg);
 6137   %}
 6138   ins_pipe(fpu_reg_con);
 6139 %}
 6140 
 6141 // The instruction usage is guarded by predicate in operand immD().
 6142 instruct loadConD(regD dst, immD con) %{
 6143   match(Set dst con);
 6144   ins_cost(125);
 6145   format %{ &quot;MOVSD  $dst,[$constantaddress]\t# load from constant table: double=$con&quot; %}
 6146   ins_encode %{
 6147     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 6148   %}
 6149   ins_pipe(pipe_slow);
 6150 %}
 6151 
 6152 // The instruction usage is guarded by predicate in operand immD0().
 6153 instruct loadConD0(regD dst, immD0 src) %{
 6154   match(Set dst src);
 6155   ins_cost(100);
 6156   format %{ &quot;XORPD  $dst,$dst\t# double 0.0&quot; %}
 6157   ins_encode %{
 6158     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 6159   %}
 6160   ins_pipe( pipe_slow );
 6161 %}
 6162 
 6163 // Load Stack Slot
 6164 instruct loadSSI(rRegI dst, stackSlotI src) %{
 6165   match(Set dst src);
 6166   ins_cost(125);
 6167 
 6168   format %{ &quot;MOV    $dst,$src&quot; %}
 6169   opcode(0x8B);
 6170   ins_encode( OpcP, RegMem(dst,src));
 6171   ins_pipe( ialu_reg_mem );
 6172 %}
 6173 
 6174 instruct loadSSL(eRegL dst, stackSlotL src) %{
 6175   match(Set dst src);
 6176 
 6177   ins_cost(200);
 6178   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6179             &quot;MOV    $dst+4,$src.hi&quot; %}
 6180   opcode(0x8B, 0x8B);
 6181   ins_encode( OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ) );
 6182   ins_pipe( ialu_mem_long_reg );
 6183 %}
 6184 
 6185 // Load Stack Slot
 6186 instruct loadSSP(eRegP dst, stackSlotP src) %{
 6187   match(Set dst src);
 6188   ins_cost(125);
 6189 
 6190   format %{ &quot;MOV    $dst,$src&quot; %}
 6191   opcode(0x8B);
 6192   ins_encode( OpcP, RegMem(dst,src));
 6193   ins_pipe( ialu_reg_mem );
 6194 %}
 6195 
 6196 // Load Stack Slot
 6197 instruct loadSSF(regFPR dst, stackSlotF src) %{
 6198   match(Set dst src);
 6199   ins_cost(125);
 6200 
 6201   format %{ &quot;FLD_S  $src\n\t&quot;
 6202             &quot;FSTP   $dst&quot; %}
 6203   opcode(0xD9);               /* D9 /0, FLD m32real */
 6204   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6205               Pop_Reg_FPR(dst) );
 6206   ins_pipe( fpu_reg_mem );
 6207 %}
 6208 
 6209 // Load Stack Slot
 6210 instruct loadSSD(regDPR dst, stackSlotD src) %{
 6211   match(Set dst src);
 6212   ins_cost(125);
 6213 
 6214   format %{ &quot;FLD_D  $src\n\t&quot;
 6215             &quot;FSTP   $dst&quot; %}
 6216   opcode(0xDD);               /* DD /0, FLD m64real */
 6217   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6218               Pop_Reg_DPR(dst) );
 6219   ins_pipe( fpu_reg_mem );
 6220 %}
 6221 
 6222 // Prefetch instructions for allocation.
 6223 // Must be safe to execute with invalid address (cannot fault).
 6224 
 6225 instruct prefetchAlloc0( memory mem ) %{
 6226   predicate(UseSSE==0 &amp;&amp; AllocatePrefetchInstr!=3);
 6227   match(PrefetchAllocation mem);
 6228   ins_cost(0);
 6229   size(0);
 6230   format %{ &quot;Prefetch allocation (non-SSE is empty encoding)&quot; %}
 6231   ins_encode();
 6232   ins_pipe(empty);
 6233 %}
 6234 
 6235 instruct prefetchAlloc( memory mem ) %{
 6236   predicate(AllocatePrefetchInstr==3);
 6237   match( PrefetchAllocation mem );
 6238   ins_cost(100);
 6239 
 6240   format %{ &quot;PREFETCHW $mem\t! Prefetch allocation into L1 cache and mark modified&quot; %}
 6241   ins_encode %{
 6242     __ prefetchw($mem$$Address);
 6243   %}
 6244   ins_pipe(ialu_mem);
 6245 %}
 6246 
 6247 instruct prefetchAllocNTA( memory mem ) %{
 6248   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==0);
 6249   match(PrefetchAllocation mem);
 6250   ins_cost(100);
 6251 
 6252   format %{ &quot;PREFETCHNTA $mem\t! Prefetch allocation into non-temporal cache for write&quot; %}
 6253   ins_encode %{
 6254     __ prefetchnta($mem$$Address);
 6255   %}
 6256   ins_pipe(ialu_mem);
 6257 %}
 6258 
 6259 instruct prefetchAllocT0( memory mem ) %{
 6260   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==1);
 6261   match(PrefetchAllocation mem);
 6262   ins_cost(100);
 6263 
 6264   format %{ &quot;PREFETCHT0 $mem\t! Prefetch allocation into L1 and L2 caches for write&quot; %}
 6265   ins_encode %{
 6266     __ prefetcht0($mem$$Address);
 6267   %}
 6268   ins_pipe(ialu_mem);
 6269 %}
 6270 
 6271 instruct prefetchAllocT2( memory mem ) %{
 6272   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==2);
 6273   match(PrefetchAllocation mem);
 6274   ins_cost(100);
 6275 
 6276   format %{ &quot;PREFETCHT2 $mem\t! Prefetch allocation into L2 cache for write&quot; %}
 6277   ins_encode %{
 6278     __ prefetcht2($mem$$Address);
 6279   %}
 6280   ins_pipe(ialu_mem);
 6281 %}
 6282 
 6283 //----------Store Instructions-------------------------------------------------
 6284 
 6285 // Store Byte
 6286 instruct storeB(memory mem, xRegI src) %{
 6287   match(Set mem (StoreB mem src));
 6288 
 6289   ins_cost(125);
 6290   format %{ &quot;MOV8   $mem,$src&quot; %}
 6291   opcode(0x88);
 6292   ins_encode( OpcP, RegMem( src, mem ) );
 6293   ins_pipe( ialu_mem_reg );
 6294 %}
 6295 
 6296 // Store Char/Short
 6297 instruct storeC(memory mem, rRegI src) %{
 6298   match(Set mem (StoreC mem src));
 6299 
 6300   ins_cost(125);
 6301   format %{ &quot;MOV16  $mem,$src&quot; %}
 6302   opcode(0x89, 0x66);
 6303   ins_encode( OpcS, OpcP, RegMem( src, mem ) );
 6304   ins_pipe( ialu_mem_reg );
 6305 %}
 6306 
 6307 // Store Integer
 6308 instruct storeI(memory mem, rRegI src) %{
 6309   match(Set mem (StoreI mem src));
 6310 
 6311   ins_cost(125);
 6312   format %{ &quot;MOV    $mem,$src&quot; %}
 6313   opcode(0x89);
 6314   ins_encode( OpcP, RegMem( src, mem ) );
 6315   ins_pipe( ialu_mem_reg );
 6316 %}
 6317 
 6318 // Store Long
 6319 instruct storeL(long_memory mem, eRegL src) %{
 6320   predicate(!((StoreLNode*)n)-&gt;require_atomic_access());
 6321   match(Set mem (StoreL mem src));
 6322 
 6323   ins_cost(200);
 6324   format %{ &quot;MOV    $mem,$src.lo\n\t&quot;
 6325             &quot;MOV    $mem+4,$src.hi&quot; %}
 6326   opcode(0x89, 0x89);
 6327   ins_encode( OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ) );
 6328   ins_pipe( ialu_mem_long_reg );
 6329 %}
 6330 
 6331 // Store Long to Integer
 6332 instruct storeL2I(memory mem, eRegL src) %{
 6333   match(Set mem (StoreI mem (ConvL2I src)));
 6334 
 6335   format %{ &quot;MOV    $mem,$src.lo\t# long -&gt; int&quot; %}
 6336   ins_encode %{
 6337     __ movl($mem$$Address, $src$$Register);
 6338   %}
 6339   ins_pipe(ialu_mem_reg);
 6340 %}
 6341 
 6342 // Volatile Store Long.  Must be atomic, so move it into
 6343 // the FP TOS and then do a 64-bit FIST.  Has to probe the
 6344 // target address before the store (for null-ptr checks)
 6345 // so the memory operand is used twice in the encoding.
 6346 instruct storeL_volatile(memory mem, stackSlotL src, eFlagsReg cr ) %{
 6347   predicate(UseSSE&lt;=1 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6348   match(Set mem (StoreL mem src));
 6349   effect( KILL cr );
 6350   ins_cost(400);
 6351   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6352             &quot;FILD   $src\n\t&quot;
 6353             &quot;FISTp  $mem\t # 64-bit atomic volatile long store&quot; %}
 6354   opcode(0x3B);
 6355   ins_encode( OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src));
 6356   ins_pipe( fpu_reg_mem );
 6357 %}
 6358 
 6359 instruct storeLX_volatile(memory mem, stackSlotL src, regD tmp, eFlagsReg cr) %{
 6360   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6361   match(Set mem (StoreL mem src));
 6362   effect( TEMP tmp, KILL cr );
 6363   ins_cost(380);
 6364   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6365             &quot;MOVSD  $tmp,$src\n\t&quot;
 6366             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6367   ins_encode %{
 6368     __ cmpl(rax, $mem$$Address);
 6369     __ movdbl($tmp$$XMMRegister, Address(rsp, $src$$disp));
 6370     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6371   %}
 6372   ins_pipe( pipe_slow );
 6373 %}
 6374 
 6375 instruct storeLX_reg_volatile(memory mem, eRegL src, regD tmp2, regD tmp, eFlagsReg cr) %{
 6376   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6377   match(Set mem (StoreL mem src));
 6378   effect( TEMP tmp2 , TEMP tmp, KILL cr );
 6379   ins_cost(360);
 6380   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6381             &quot;MOVD   $tmp,$src.lo\n\t&quot;
 6382             &quot;MOVD   $tmp2,$src.hi\n\t&quot;
 6383             &quot;PUNPCKLDQ $tmp,$tmp2\n\t&quot;
 6384             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6385   ins_encode %{
 6386     __ cmpl(rax, $mem$$Address);
 6387     __ movdl($tmp$$XMMRegister, $src$$Register);
 6388     __ movdl($tmp2$$XMMRegister, HIGH_FROM_LOW($src$$Register));
 6389     __ punpckldq($tmp$$XMMRegister, $tmp2$$XMMRegister);
 6390     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6391   %}
 6392   ins_pipe( pipe_slow );
 6393 %}
 6394 
 6395 // Store Pointer; for storing unknown oops and raw pointers
 6396 instruct storeP(memory mem, anyRegP src) %{
 6397   match(Set mem (StoreP mem src));
 6398 
 6399   ins_cost(125);
 6400   format %{ &quot;MOV    $mem,$src&quot; %}
 6401   opcode(0x89);
 6402   ins_encode( OpcP, RegMem( src, mem ) );
 6403   ins_pipe( ialu_mem_reg );
 6404 %}
 6405 
 6406 // Store Integer Immediate
 6407 instruct storeImmI(memory mem, immI src) %{
 6408   match(Set mem (StoreI mem src));
 6409 
 6410   ins_cost(150);
 6411   format %{ &quot;MOV    $mem,$src&quot; %}
 6412   opcode(0xC7);               /* C7 /0 */
 6413   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6414   ins_pipe( ialu_mem_imm );
 6415 %}
 6416 
 6417 // Store Short/Char Immediate
 6418 instruct storeImmI16(memory mem, immI16 src) %{
 6419   predicate(UseStoreImmI16);
 6420   match(Set mem (StoreC mem src));
 6421 
 6422   ins_cost(150);
 6423   format %{ &quot;MOV16  $mem,$src&quot; %}
 6424   opcode(0xC7);     /* C7 /0 Same as 32 store immediate with prefix */
 6425   ins_encode( SizePrefix, OpcP, RMopc_Mem(0x00,mem),  Con16( src ));
 6426   ins_pipe( ialu_mem_imm );
 6427 %}
 6428 
 6429 // Store Pointer Immediate; null pointers or constant oops that do not
 6430 // need card-mark barriers.
 6431 instruct storeImmP(memory mem, immP src) %{
 6432   match(Set mem (StoreP mem src));
 6433 
 6434   ins_cost(150);
 6435   format %{ &quot;MOV    $mem,$src&quot; %}
 6436   opcode(0xC7);               /* C7 /0 */
 6437   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6438   ins_pipe( ialu_mem_imm );
 6439 %}
 6440 
 6441 // Store Byte Immediate
 6442 instruct storeImmB(memory mem, immI8 src) %{
 6443   match(Set mem (StoreB mem src));
 6444 
 6445   ins_cost(150);
 6446   format %{ &quot;MOV8   $mem,$src&quot; %}
 6447   opcode(0xC6);               /* C6 /0 */
 6448   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6449   ins_pipe( ialu_mem_imm );
 6450 %}
 6451 
 6452 // Store CMS card-mark Immediate
 6453 instruct storeImmCM(memory mem, immI8 src) %{
 6454   match(Set mem (StoreCM mem src));
 6455 
 6456   ins_cost(150);
 6457   format %{ &quot;MOV8   $mem,$src\t! CMS card-mark imm0&quot; %}
 6458   opcode(0xC6);               /* C6 /0 */
 6459   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6460   ins_pipe( ialu_mem_imm );
 6461 %}
 6462 
 6463 // Store Double
 6464 instruct storeDPR( memory mem, regDPR1 src) %{
 6465   predicate(UseSSE&lt;=1);
 6466   match(Set mem (StoreD mem src));
 6467 
 6468   ins_cost(100);
 6469   format %{ &quot;FST_D  $mem,$src&quot; %}
 6470   opcode(0xDD);       /* DD /2 */
 6471   ins_encode( enc_FPR_store(mem,src) );
 6472   ins_pipe( fpu_mem_reg );
 6473 %}
 6474 
 6475 // Store double does rounding on x86
 6476 instruct storeDPR_rounded( memory mem, regDPR1 src) %{
 6477   predicate(UseSSE&lt;=1);
 6478   match(Set mem (StoreD mem (RoundDouble src)));
 6479 
 6480   ins_cost(100);
 6481   format %{ &quot;FST_D  $mem,$src\t# round&quot; %}
 6482   opcode(0xDD);       /* DD /2 */
 6483   ins_encode( enc_FPR_store(mem,src) );
 6484   ins_pipe( fpu_mem_reg );
 6485 %}
 6486 
 6487 // Store XMM register to memory (double-precision floating points)
 6488 // MOVSD instruction
 6489 instruct storeD(memory mem, regD src) %{
 6490   predicate(UseSSE&gt;=2);
 6491   match(Set mem (StoreD mem src));
 6492   ins_cost(95);
 6493   format %{ &quot;MOVSD  $mem,$src&quot; %}
 6494   ins_encode %{
 6495     __ movdbl($mem$$Address, $src$$XMMRegister);
 6496   %}
 6497   ins_pipe( pipe_slow );
 6498 %}
 6499 
 6500 // Load Double
 6501 instruct MoveD2VL(vlRegD dst, regD src) %{
 6502   match(Set dst src);
 6503   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6504   ins_encode %{
 6505     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6506   %}
 6507   ins_pipe( fpu_reg_reg );
 6508 %}
 6509 
 6510 // Load Double
 6511 instruct MoveVL2D(regD dst, vlRegD src) %{
 6512   match(Set dst src);
 6513   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6514   ins_encode %{
 6515     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6516   %}
 6517   ins_pipe( fpu_reg_reg );
 6518 %}
 6519 
 6520 // Store XMM register to memory (single-precision floating point)
 6521 // MOVSS instruction
 6522 instruct storeF(memory mem, regF src) %{
 6523   predicate(UseSSE&gt;=1);
 6524   match(Set mem (StoreF mem src));
 6525   ins_cost(95);
 6526   format %{ &quot;MOVSS  $mem,$src&quot; %}
 6527   ins_encode %{
 6528     __ movflt($mem$$Address, $src$$XMMRegister);
 6529   %}
 6530   ins_pipe( pipe_slow );
 6531 %}
 6532 
 6533 // Load Float
 6534 instruct MoveF2VL(vlRegF dst, regF src) %{
 6535   match(Set dst src);
 6536   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6537   ins_encode %{
 6538     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6539   %}
 6540   ins_pipe( fpu_reg_reg );
 6541 %}
 6542 
 6543 // Load Float
 6544 instruct MoveVL2F(regF dst, vlRegF src) %{
 6545   match(Set dst src);
 6546   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6547   ins_encode %{
 6548     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6549   %}
 6550   ins_pipe( fpu_reg_reg );
 6551 %}
 6552 
 6553 // Store Float
 6554 instruct storeFPR( memory mem, regFPR1 src) %{
 6555   predicate(UseSSE==0);
 6556   match(Set mem (StoreF mem src));
 6557 
 6558   ins_cost(100);
 6559   format %{ &quot;FST_S  $mem,$src&quot; %}
 6560   opcode(0xD9);       /* D9 /2 */
 6561   ins_encode( enc_FPR_store(mem,src) );
 6562   ins_pipe( fpu_mem_reg );
 6563 %}
 6564 
 6565 // Store Float does rounding on x86
 6566 instruct storeFPR_rounded( memory mem, regFPR1 src) %{
 6567   predicate(UseSSE==0);
 6568   match(Set mem (StoreF mem (RoundFloat src)));
 6569 
 6570   ins_cost(100);
 6571   format %{ &quot;FST_S  $mem,$src\t# round&quot; %}
 6572   opcode(0xD9);       /* D9 /2 */
 6573   ins_encode( enc_FPR_store(mem,src) );
 6574   ins_pipe( fpu_mem_reg );
 6575 %}
 6576 
 6577 // Store Float does rounding on x86
 6578 instruct storeFPR_Drounded( memory mem, regDPR1 src) %{
 6579   predicate(UseSSE&lt;=1);
 6580   match(Set mem (StoreF mem (ConvD2F src)));
 6581 
 6582   ins_cost(100);
 6583   format %{ &quot;FST_S  $mem,$src\t# D-round&quot; %}
 6584   opcode(0xD9);       /* D9 /2 */
 6585   ins_encode( enc_FPR_store(mem,src) );
 6586   ins_pipe( fpu_mem_reg );
 6587 %}
 6588 
 6589 // Store immediate Float value (it is faster than store from FPU register)
 6590 // The instruction usage is guarded by predicate in operand immFPR().
 6591 instruct storeFPR_imm( memory mem, immFPR src) %{
 6592   match(Set mem (StoreF mem src));
 6593 
 6594   ins_cost(50);
 6595   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6596   opcode(0xC7);               /* C7 /0 */
 6597   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits( src ));
 6598   ins_pipe( ialu_mem_imm );
 6599 %}
 6600 
 6601 // Store immediate Float value (it is faster than store from XMM register)
 6602 // The instruction usage is guarded by predicate in operand immF().
 6603 instruct storeF_imm( memory mem, immF src) %{
 6604   match(Set mem (StoreF mem src));
 6605 
 6606   ins_cost(50);
 6607   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6608   opcode(0xC7);               /* C7 /0 */
 6609   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits( src ));
 6610   ins_pipe( ialu_mem_imm );
 6611 %}
 6612 
 6613 // Store Integer to stack slot
 6614 instruct storeSSI(stackSlotI dst, rRegI src) %{
 6615   match(Set dst src);
 6616 
 6617   ins_cost(100);
 6618   format %{ &quot;MOV    $dst,$src&quot; %}
 6619   opcode(0x89);
 6620   ins_encode( OpcPRegSS( dst, src ) );
 6621   ins_pipe( ialu_mem_reg );
 6622 %}
 6623 
 6624 // Store Integer to stack slot
 6625 instruct storeSSP(stackSlotP dst, eRegP src) %{
 6626   match(Set dst src);
 6627 
 6628   ins_cost(100);
 6629   format %{ &quot;MOV    $dst,$src&quot; %}
 6630   opcode(0x89);
 6631   ins_encode( OpcPRegSS( dst, src ) );
 6632   ins_pipe( ialu_mem_reg );
 6633 %}
 6634 
 6635 // Store Long to stack slot
 6636 instruct storeSSL(stackSlotL dst, eRegL src) %{
 6637   match(Set dst src);
 6638 
 6639   ins_cost(200);
 6640   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6641             &quot;MOV    $dst+4,$src.hi&quot; %}
 6642   opcode(0x89, 0x89);
 6643   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
 6644   ins_pipe( ialu_mem_long_reg );
 6645 %}
 6646 
 6647 //----------MemBar Instructions-----------------------------------------------
 6648 // Memory barrier flavors
 6649 
 6650 instruct membar_acquire() %{
 6651   match(MemBarAcquire);
 6652   match(LoadFence);
 6653   ins_cost(400);
 6654 
 6655   size(0);
 6656   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6657   ins_encode();
 6658   ins_pipe(empty);
 6659 %}
 6660 
 6661 instruct membar_acquire_lock() %{
 6662   match(MemBarAcquireLock);
 6663   ins_cost(0);
 6664 
 6665   size(0);
 6666   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6667   ins_encode( );
 6668   ins_pipe(empty);
 6669 %}
 6670 
 6671 instruct membar_release() %{
 6672   match(MemBarRelease);
 6673   match(StoreFence);
 6674   ins_cost(400);
 6675 
 6676   size(0);
 6677   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6678   ins_encode( );
 6679   ins_pipe(empty);
 6680 %}
 6681 
 6682 instruct membar_release_lock() %{
 6683   match(MemBarReleaseLock);
 6684   ins_cost(0);
 6685 
 6686   size(0);
 6687   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6688   ins_encode( );
 6689   ins_pipe(empty);
 6690 %}
 6691 
 6692 instruct membar_volatile(eFlagsReg cr) %{
 6693   match(MemBarVolatile);
 6694   effect(KILL cr);
 6695   ins_cost(400);
 6696 
 6697   format %{
 6698     $$template
 6699     $$emit$$&quot;LOCK ADDL [ESP + #0], 0\t! membar_volatile&quot;
 6700   %}
 6701   ins_encode %{
 6702     __ membar(Assembler::StoreLoad);
 6703   %}
 6704   ins_pipe(pipe_slow);
 6705 %}
 6706 
 6707 instruct unnecessary_membar_volatile() %{
 6708   match(MemBarVolatile);
 6709   predicate(Matcher::post_store_load_barrier(n));
 6710   ins_cost(0);
 6711 
 6712   size(0);
 6713   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6714   ins_encode( );
 6715   ins_pipe(empty);
 6716 %}
 6717 
 6718 instruct membar_storestore() %{
 6719   match(MemBarStoreStore);
 6720   ins_cost(0);
 6721 
 6722   size(0);
 6723   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6724   ins_encode( );
 6725   ins_pipe(empty);
 6726 %}
 6727 
 6728 //----------Move Instructions--------------------------------------------------
 6729 instruct castX2P(eAXRegP dst, eAXRegI src) %{
 6730   match(Set dst (CastX2P src));
 6731   format %{ &quot;# X2P  $dst, $src&quot; %}
 6732   ins_encode( /*empty encoding*/ );
 6733   ins_cost(0);
 6734   ins_pipe(empty);
 6735 %}
 6736 
 6737 instruct castP2X(rRegI dst, eRegP src ) %{
 6738   match(Set dst (CastP2X src));
 6739   ins_cost(50);
 6740   format %{ &quot;MOV    $dst, $src\t# CastP2X&quot; %}
 6741   ins_encode( enc_Copy( dst, src) );
 6742   ins_pipe( ialu_reg_reg );
 6743 %}
 6744 
 6745 //----------Conditional Move---------------------------------------------------
 6746 // Conditional move
 6747 instruct jmovI_reg(cmpOp cop, eFlagsReg cr, rRegI dst, rRegI src) %{
 6748   predicate(!VM_Version::supports_cmov() );
 6749   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6750   ins_cost(200);
 6751   format %{ &quot;J$cop,us skip\t# signed cmove\n\t&quot;
 6752             &quot;MOV    $dst,$src\n&quot;
 6753       &quot;skip:&quot; %}
 6754   ins_encode %{
 6755     Label Lskip;
 6756     // Invert sense of branch from sense of CMOV
 6757     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6758     __ movl($dst$$Register, $src$$Register);
 6759     __ bind(Lskip);
 6760   %}
 6761   ins_pipe( pipe_cmov_reg );
 6762 %}
 6763 
 6764 instruct jmovI_regU(cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src) %{
 6765   predicate(!VM_Version::supports_cmov() );
 6766   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6767   ins_cost(200);
 6768   format %{ &quot;J$cop,us skip\t# unsigned cmove\n\t&quot;
 6769             &quot;MOV    $dst,$src\n&quot;
 6770       &quot;skip:&quot; %}
 6771   ins_encode %{
 6772     Label Lskip;
 6773     // Invert sense of branch from sense of CMOV
 6774     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6775     __ movl($dst$$Register, $src$$Register);
 6776     __ bind(Lskip);
 6777   %}
 6778   ins_pipe( pipe_cmov_reg );
 6779 %}
 6780 
 6781 instruct cmovI_reg(rRegI dst, rRegI src, eFlagsReg cr, cmpOp cop ) %{
 6782   predicate(VM_Version::supports_cmov() );
 6783   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6784   ins_cost(200);
 6785   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6786   opcode(0x0F,0x40);
 6787   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6788   ins_pipe( pipe_cmov_reg );
 6789 %}
 6790 
 6791 instruct cmovI_regU( cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src ) %{
 6792   predicate(VM_Version::supports_cmov() );
 6793   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6794   ins_cost(200);
 6795   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6796   opcode(0x0F,0x40);
 6797   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6798   ins_pipe( pipe_cmov_reg );
 6799 %}
 6800 
 6801 instruct cmovI_regUCF( cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, rRegI src ) %{
 6802   predicate(VM_Version::supports_cmov() );
 6803   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6804   ins_cost(200);
 6805   expand %{
 6806     cmovI_regU(cop, cr, dst, src);
 6807   %}
 6808 %}
 6809 
 6810 // Conditional move
 6811 instruct cmovI_mem(cmpOp cop, eFlagsReg cr, rRegI dst, memory src) %{
 6812   predicate(VM_Version::supports_cmov() );
 6813   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6814   ins_cost(250);
 6815   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6816   opcode(0x0F,0x40);
 6817   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6818   ins_pipe( pipe_cmov_mem );
 6819 %}
 6820 
 6821 // Conditional move
 6822 instruct cmovI_memU(cmpOpU cop, eFlagsRegU cr, rRegI dst, memory src) %{
 6823   predicate(VM_Version::supports_cmov() );
 6824   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6825   ins_cost(250);
 6826   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6827   opcode(0x0F,0x40);
 6828   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6829   ins_pipe( pipe_cmov_mem );
 6830 %}
 6831 
 6832 instruct cmovI_memUCF(cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, memory src) %{
 6833   predicate(VM_Version::supports_cmov() );
 6834   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6835   ins_cost(250);
 6836   expand %{
 6837     cmovI_memU(cop, cr, dst, src);
 6838   %}
 6839 %}
 6840 
 6841 // Conditional move
 6842 instruct cmovP_reg(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6843   predicate(VM_Version::supports_cmov() );
 6844   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6845   ins_cost(200);
 6846   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6847   opcode(0x0F,0x40);
 6848   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6849   ins_pipe( pipe_cmov_reg );
 6850 %}
 6851 
 6852 // Conditional move (non-P6 version)
 6853 // Note:  a CMoveP is generated for  stubs and native wrappers
 6854 //        regardless of whether we are on a P6, so we
 6855 //        emulate a cmov here
 6856 instruct cmovP_reg_nonP6(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6857   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6858   ins_cost(300);
 6859   format %{ &quot;Jn$cop   skip\n\t&quot;
 6860           &quot;MOV    $dst,$src\t# pointer\n&quot;
 6861       &quot;skip:&quot; %}
 6862   opcode(0x8b);
 6863   ins_encode( enc_cmov_branch(cop, 0x2), OpcP, RegReg(dst, src));
 6864   ins_pipe( pipe_cmov_reg );
 6865 %}
 6866 
 6867 // Conditional move
 6868 instruct cmovP_regU(cmpOpU cop, eFlagsRegU cr, eRegP dst, eRegP src ) %{
 6869   predicate(VM_Version::supports_cmov() );
 6870   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6871   ins_cost(200);
 6872   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6873   opcode(0x0F,0x40);
 6874   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6875   ins_pipe( pipe_cmov_reg );
 6876 %}
 6877 
 6878 instruct cmovP_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegP dst, eRegP src ) %{
 6879   predicate(VM_Version::supports_cmov() );
 6880   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6881   ins_cost(200);
 6882   expand %{
 6883     cmovP_regU(cop, cr, dst, src);
 6884   %}
 6885 %}
 6886 
 6887 // DISABLED: Requires the ADLC to emit a bottom_type call that
 6888 // correctly meets the two pointer arguments; one is an incoming
 6889 // register but the other is a memory operand.  ALSO appears to
 6890 // be buggy with implicit null checks.
 6891 //
 6892 //// Conditional move
 6893 //instruct cmovP_mem(cmpOp cop, eFlagsReg cr, eRegP dst, memory src) %{
 6894 //  predicate(VM_Version::supports_cmov() );
 6895 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6896 //  ins_cost(250);
 6897 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6898 //  opcode(0x0F,0x40);
 6899 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6900 //  ins_pipe( pipe_cmov_mem );
 6901 //%}
 6902 //
 6903 //// Conditional move
 6904 //instruct cmovP_memU(cmpOpU cop, eFlagsRegU cr, eRegP dst, memory src) %{
 6905 //  predicate(VM_Version::supports_cmov() );
 6906 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6907 //  ins_cost(250);
 6908 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6909 //  opcode(0x0F,0x40);
 6910 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6911 //  ins_pipe( pipe_cmov_mem );
 6912 //%}
 6913 
 6914 // Conditional move
 6915 instruct fcmovDPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regDPR1 dst, regDPR src) %{
 6916   predicate(UseSSE&lt;=1);
 6917   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6918   ins_cost(200);
 6919   format %{ &quot;FCMOV$cop $dst,$src\t# double&quot; %}
 6920   opcode(0xDA);
 6921   ins_encode( enc_cmov_dpr(cop,src) );
 6922   ins_pipe( pipe_cmovDPR_reg );
 6923 %}
 6924 
 6925 // Conditional move
 6926 instruct fcmovFPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regFPR1 dst, regFPR src) %{
 6927   predicate(UseSSE==0);
 6928   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6929   ins_cost(200);
 6930   format %{ &quot;FCMOV$cop $dst,$src\t# float&quot; %}
 6931   opcode(0xDA);
 6932   ins_encode( enc_cmov_dpr(cop,src) );
 6933   ins_pipe( pipe_cmovDPR_reg );
 6934 %}
 6935 
 6936 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6937 instruct fcmovDPR_regS(cmpOp cop, eFlagsReg cr, regDPR dst, regDPR src) %{
 6938   predicate(UseSSE&lt;=1);
 6939   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6940   ins_cost(200);
 6941   format %{ &quot;Jn$cop   skip\n\t&quot;
 6942             &quot;MOV    $dst,$src\t# double\n&quot;
 6943       &quot;skip:&quot; %}
 6944   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6945   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_DPR(src), OpcP, RegOpc(dst) );
 6946   ins_pipe( pipe_cmovDPR_reg );
 6947 %}
 6948 
 6949 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6950 instruct fcmovFPR_regS(cmpOp cop, eFlagsReg cr, regFPR dst, regFPR src) %{
 6951   predicate(UseSSE==0);
 6952   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6953   ins_cost(200);
 6954   format %{ &quot;Jn$cop    skip\n\t&quot;
 6955             &quot;MOV    $dst,$src\t# float\n&quot;
 6956       &quot;skip:&quot; %}
 6957   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6958   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_FPR(src), OpcP, RegOpc(dst) );
 6959   ins_pipe( pipe_cmovDPR_reg );
 6960 %}
 6961 
 6962 // No CMOVE with SSE/SSE2
 6963 instruct fcmovF_regS(cmpOp cop, eFlagsReg cr, regF dst, regF src) %{
 6964   predicate (UseSSE&gt;=1);
 6965   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6966   ins_cost(200);
 6967   format %{ &quot;Jn$cop   skip\n\t&quot;
 6968             &quot;MOVSS  $dst,$src\t# float\n&quot;
 6969       &quot;skip:&quot; %}
 6970   ins_encode %{
 6971     Label skip;
 6972     // Invert sense of branch from sense of CMOV
 6973     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6974     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6975     __ bind(skip);
 6976   %}
 6977   ins_pipe( pipe_slow );
 6978 %}
 6979 
 6980 // No CMOVE with SSE/SSE2
 6981 instruct fcmovD_regS(cmpOp cop, eFlagsReg cr, regD dst, regD src) %{
 6982   predicate (UseSSE&gt;=2);
 6983   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6984   ins_cost(200);
 6985   format %{ &quot;Jn$cop   skip\n\t&quot;
 6986             &quot;MOVSD  $dst,$src\t# float\n&quot;
 6987       &quot;skip:&quot; %}
 6988   ins_encode %{
 6989     Label skip;
 6990     // Invert sense of branch from sense of CMOV
 6991     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6992     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6993     __ bind(skip);
 6994   %}
 6995   ins_pipe( pipe_slow );
 6996 %}
 6997 
 6998 // unsigned version
 6999 instruct fcmovF_regU(cmpOpU cop, eFlagsRegU cr, regF dst, regF src) %{
 7000   predicate (UseSSE&gt;=1);
 7001   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7002   ins_cost(200);
 7003   format %{ &quot;Jn$cop   skip\n\t&quot;
 7004             &quot;MOVSS  $dst,$src\t# float\n&quot;
 7005       &quot;skip:&quot; %}
 7006   ins_encode %{
 7007     Label skip;
 7008     // Invert sense of branch from sense of CMOV
 7009     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 7010     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7011     __ bind(skip);
 7012   %}
 7013   ins_pipe( pipe_slow );
 7014 %}
 7015 
 7016 instruct fcmovF_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regF dst, regF src) %{
 7017   predicate (UseSSE&gt;=1);
 7018   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7019   ins_cost(200);
 7020   expand %{
 7021     fcmovF_regU(cop, cr, dst, src);
 7022   %}
 7023 %}
 7024 
 7025 // unsigned version
 7026 instruct fcmovD_regU(cmpOpU cop, eFlagsRegU cr, regD dst, regD src) %{
 7027   predicate (UseSSE&gt;=2);
 7028   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7029   ins_cost(200);
 7030   format %{ &quot;Jn$cop   skip\n\t&quot;
 7031             &quot;MOVSD  $dst,$src\t# float\n&quot;
 7032       &quot;skip:&quot; %}
 7033   ins_encode %{
 7034     Label skip;
 7035     // Invert sense of branch from sense of CMOV
 7036     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 7037     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7038     __ bind(skip);
 7039   %}
 7040   ins_pipe( pipe_slow );
 7041 %}
 7042 
 7043 instruct fcmovD_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regD dst, regD src) %{
 7044   predicate (UseSSE&gt;=2);
 7045   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7046   ins_cost(200);
 7047   expand %{
 7048     fcmovD_regU(cop, cr, dst, src);
 7049   %}
 7050 %}
 7051 
 7052 instruct cmovL_reg(cmpOp cop, eFlagsReg cr, eRegL dst, eRegL src) %{
 7053   predicate(VM_Version::supports_cmov() );
 7054   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7055   ins_cost(200);
 7056   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7057             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7058   opcode(0x0F,0x40);
 7059   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7060   ins_pipe( pipe_cmov_reg_long );
 7061 %}
 7062 
 7063 instruct cmovL_regU(cmpOpU cop, eFlagsRegU cr, eRegL dst, eRegL src) %{
 7064   predicate(VM_Version::supports_cmov() );
 7065   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7066   ins_cost(200);
 7067   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7068             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7069   opcode(0x0F,0x40);
 7070   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7071   ins_pipe( pipe_cmov_reg_long );
 7072 %}
 7073 
 7074 instruct cmovL_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegL dst, eRegL src) %{
 7075   predicate(VM_Version::supports_cmov() );
 7076   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7077   ins_cost(200);
 7078   expand %{
 7079     cmovL_regU(cop, cr, dst, src);
 7080   %}
 7081 %}
 7082 
 7083 //----------Arithmetic Instructions--------------------------------------------
 7084 //----------Addition Instructions----------------------------------------------
 7085 
 7086 // Integer Addition Instructions
 7087 instruct addI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7088   match(Set dst (AddI dst src));
 7089   effect(KILL cr);
 7090 
 7091   size(2);
 7092   format %{ &quot;ADD    $dst,$src&quot; %}
 7093   opcode(0x03);
 7094   ins_encode( OpcP, RegReg( dst, src) );
 7095   ins_pipe( ialu_reg_reg );
 7096 %}
 7097 
 7098 instruct addI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7099   match(Set dst (AddI dst src));
 7100   effect(KILL cr);
 7101 
 7102   format %{ &quot;ADD    $dst,$src&quot; %}
 7103   opcode(0x81, 0x00); /* /0 id */
 7104   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7105   ins_pipe( ialu_reg );
 7106 %}
 7107 
 7108 instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
 7109   predicate(UseIncDec);
 7110   match(Set dst (AddI dst src));
 7111   effect(KILL cr);
 7112 
 7113   size(1);
 7114   format %{ &quot;INC    $dst&quot; %}
 7115   opcode(0x40); /*  */
 7116   ins_encode( Opc_plus( primary, dst ) );
 7117   ins_pipe( ialu_reg );
 7118 %}
 7119 
 7120 instruct leaI_eReg_immI(rRegI dst, rRegI src0, immI src1) %{
 7121   match(Set dst (AddI src0 src1));
 7122   ins_cost(110);
 7123 
 7124   format %{ &quot;LEA    $dst,[$src0 + $src1]&quot; %}
 7125   opcode(0x8D); /* 0x8D /r */
 7126   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7127   ins_pipe( ialu_reg_reg );
 7128 %}
 7129 
 7130 instruct leaP_eReg_immI(eRegP dst, eRegP src0, immI src1) %{
 7131   match(Set dst (AddP src0 src1));
 7132   ins_cost(110);
 7133 
 7134   format %{ &quot;LEA    $dst,[$src0 + $src1]\t# ptr&quot; %}
 7135   opcode(0x8D); /* 0x8D /r */
 7136   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7137   ins_pipe( ialu_reg_reg );
 7138 %}
 7139 
 7140 instruct decI_eReg(rRegI dst, immI_M1 src, eFlagsReg cr) %{
 7141   predicate(UseIncDec);
 7142   match(Set dst (AddI dst src));
 7143   effect(KILL cr);
 7144 
 7145   size(1);
 7146   format %{ &quot;DEC    $dst&quot; %}
 7147   opcode(0x48); /*  */
 7148   ins_encode( Opc_plus( primary, dst ) );
 7149   ins_pipe( ialu_reg );
 7150 %}
 7151 
 7152 instruct addP_eReg(eRegP dst, rRegI src, eFlagsReg cr) %{
 7153   match(Set dst (AddP dst src));
 7154   effect(KILL cr);
 7155 
 7156   size(2);
 7157   format %{ &quot;ADD    $dst,$src&quot; %}
 7158   opcode(0x03);
 7159   ins_encode( OpcP, RegReg( dst, src) );
 7160   ins_pipe( ialu_reg_reg );
 7161 %}
 7162 
 7163 instruct addP_eReg_imm(eRegP dst, immI src, eFlagsReg cr) %{
 7164   match(Set dst (AddP dst src));
 7165   effect(KILL cr);
 7166 
 7167   format %{ &quot;ADD    $dst,$src&quot; %}
 7168   opcode(0x81,0x00); /* Opcode 81 /0 id */
 7169   // ins_encode( RegImm( dst, src) );
 7170   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7171   ins_pipe( ialu_reg );
 7172 %}
 7173 
 7174 instruct addI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7175   match(Set dst (AddI dst (LoadI src)));
 7176   effect(KILL cr);
 7177 
 7178   ins_cost(125);
 7179   format %{ &quot;ADD    $dst,$src&quot; %}
 7180   opcode(0x03);
 7181   ins_encode( OpcP, RegMem( dst, src) );
 7182   ins_pipe( ialu_reg_mem );
 7183 %}
 7184 
 7185 instruct addI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7186   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7187   effect(KILL cr);
 7188 
 7189   ins_cost(150);
 7190   format %{ &quot;ADD    $dst,$src&quot; %}
 7191   opcode(0x01);  /* Opcode 01 /r */
 7192   ins_encode( OpcP, RegMem( src, dst ) );
 7193   ins_pipe( ialu_mem_reg );
 7194 %}
 7195 
 7196 // Add Memory with Immediate
 7197 instruct addI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 7198   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7199   effect(KILL cr);
 7200 
 7201   ins_cost(125);
 7202   format %{ &quot;ADD    $dst,$src&quot; %}
 7203   opcode(0x81);               /* Opcode 81 /0 id */
 7204   ins_encode( OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32( src ) );
 7205   ins_pipe( ialu_mem_imm );
 7206 %}
 7207 
 7208 instruct incI_mem(memory dst, immI1 src, eFlagsReg cr) %{
 7209   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7210   effect(KILL cr);
 7211 
 7212   ins_cost(125);
 7213   format %{ &quot;INC    $dst&quot; %}
 7214   opcode(0xFF);               /* Opcode FF /0 */
 7215   ins_encode( OpcP, RMopc_Mem(0x00,dst));
 7216   ins_pipe( ialu_mem_imm );
 7217 %}
 7218 
 7219 instruct decI_mem(memory dst, immI_M1 src, eFlagsReg cr) %{
 7220   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7221   effect(KILL cr);
 7222 
 7223   ins_cost(125);
 7224   format %{ &quot;DEC    $dst&quot; %}
 7225   opcode(0xFF);               /* Opcode FF /1 */
 7226   ins_encode( OpcP, RMopc_Mem(0x01,dst));
 7227   ins_pipe( ialu_mem_imm );
 7228 %}
 7229 
 7230 
 7231 instruct checkCastPP( eRegP dst ) %{
 7232   match(Set dst (CheckCastPP dst));
 7233 
 7234   size(0);
 7235   format %{ &quot;#checkcastPP of $dst&quot; %}
 7236   ins_encode( /*empty encoding*/ );
 7237   ins_pipe( empty );
 7238 %}
 7239 
 7240 instruct castPP( eRegP dst ) %{
 7241   match(Set dst (CastPP dst));
 7242   format %{ &quot;#castPP of $dst&quot; %}
 7243   ins_encode( /*empty encoding*/ );
 7244   ins_pipe( empty );
 7245 %}
 7246 
 7247 instruct castII( rRegI dst ) %{
 7248   match(Set dst (CastII dst));
 7249   format %{ &quot;#castII of $dst&quot; %}
 7250   ins_encode( /*empty encoding*/ );
 7251   ins_cost(0);
 7252   ins_pipe( empty );
 7253 %}
 7254 
 7255 instruct castLL( eRegL dst ) %{
 7256   match(Set dst (CastLL dst));
 7257   format %{ &quot;#castLL of $dst&quot; %}
 7258   ins_encode( /*empty encoding*/ );
 7259   ins_cost(0);
 7260   ins_pipe( empty );
 7261 %}
 7262 
 7263 
 7264 // Load-locked - same as a regular pointer load when used with compare-swap
 7265 instruct loadPLocked(eRegP dst, memory mem) %{
 7266   match(Set dst (LoadPLocked mem));
 7267 
 7268   ins_cost(125);
 7269   format %{ &quot;MOV    $dst,$mem\t# Load ptr. locked&quot; %}
 7270   opcode(0x8B);
 7271   ins_encode( OpcP, RegMem(dst,mem));
 7272   ins_pipe( ialu_reg_mem );
 7273 %}
 7274 
 7275 // Conditional-store of the updated heap-top.
 7276 // Used during allocation of the shared heap.
 7277 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7278 instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{
 7279   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7280   // EAX is killed if there is contention, but then it&#39;s also unused.
 7281   // In the common case of no contention, EAX holds the new oop address.
 7282   format %{ &quot;CMPXCHG $heap_top_ptr,$newval\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr&quot; %}
 7283   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval,heap_top_ptr) );
 7284   ins_pipe( pipe_cmpxchg );
 7285 %}
 7286 
 7287 // Conditional-store of an int value.
 7288 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG on Intel.
 7289 instruct storeIConditional( memory mem, eAXRegI oldval, rRegI newval, eFlagsReg cr ) %{
 7290   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7291   effect(KILL oldval);
 7292   format %{ &quot;CMPXCHG $mem,$newval\t# If EAX==$mem Then store $newval into $mem&quot; %}
 7293   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval, mem) );
 7294   ins_pipe( pipe_cmpxchg );
 7295 %}
 7296 
 7297 // Conditional-store of a long value.
 7298 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG8 on Intel.
 7299 instruct storeLConditional( memory mem, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7300   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7301   effect(KILL oldval);
 7302   format %{ &quot;XCHG   EBX,ECX\t# correct order for CMPXCHG8 instruction\n\t&quot;
 7303             &quot;CMPXCHG8 $mem,ECX:EBX\t# If EDX:EAX==$mem Then store ECX:EBX into $mem\n\t&quot;
 7304             &quot;XCHG   EBX,ECX&quot;
 7305   %}
 7306   ins_encode %{
 7307     // Note: we need to swap rbx, and rcx before and after the
 7308     //       cmpxchg8 instruction because the instruction uses
 7309     //       rcx as the high order word of the new value to store but
 7310     //       our register encoding uses rbx.
 7311     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7312     __ lock();
 7313     __ cmpxchg8($mem$$Address);
 7314     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7315   %}
 7316   ins_pipe( pipe_cmpxchg );
 7317 %}
 7318 
 7319 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7320 
 7321 instruct compareAndSwapL( rRegI res, eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7322   predicate(VM_Version::supports_cx8());
 7323   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7324   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7325   effect(KILL cr, KILL oldval);
 7326   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7327             &quot;MOV    $res,0\n\t&quot;
 7328             &quot;JNE,s  fail\n\t&quot;
 7329             &quot;MOV    $res,1\n&quot;
 7330           &quot;fail:&quot; %}
 7331   ins_encode( enc_cmpxchg8(mem_ptr),
 7332               enc_flags_ne_to_boolean(res) );
 7333   ins_pipe( pipe_cmpxchg );
 7334 %}
 7335 
 7336 instruct compareAndSwapP( rRegI res,  pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7337   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7338   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7339   effect(KILL cr, KILL oldval);
 7340   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7341             &quot;MOV    $res,0\n\t&quot;
 7342             &quot;JNE,s  fail\n\t&quot;
 7343             &quot;MOV    $res,1\n&quot;
 7344           &quot;fail:&quot; %}
 7345   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7346   ins_pipe( pipe_cmpxchg );
 7347 %}
 7348 
 7349 instruct compareAndSwapB( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7350   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7351   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7352   effect(KILL cr, KILL oldval);
 7353   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7354             &quot;MOV    $res,0\n\t&quot;
 7355             &quot;JNE,s  fail\n\t&quot;
 7356             &quot;MOV    $res,1\n&quot;
 7357           &quot;fail:&quot; %}
 7358   ins_encode( enc_cmpxchgb(mem_ptr),
 7359               enc_flags_ne_to_boolean(res) );
 7360   ins_pipe( pipe_cmpxchg );
 7361 %}
 7362 
 7363 instruct compareAndSwapS( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7364   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7365   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7366   effect(KILL cr, KILL oldval);
 7367   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7368             &quot;MOV    $res,0\n\t&quot;
 7369             &quot;JNE,s  fail\n\t&quot;
 7370             &quot;MOV    $res,1\n&quot;
 7371           &quot;fail:&quot; %}
 7372   ins_encode( enc_cmpxchgw(mem_ptr),
 7373               enc_flags_ne_to_boolean(res) );
 7374   ins_pipe( pipe_cmpxchg );
 7375 %}
 7376 
 7377 instruct compareAndSwapI( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7378   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7379   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7380   effect(KILL cr, KILL oldval);
 7381   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7382             &quot;MOV    $res,0\n\t&quot;
 7383             &quot;JNE,s  fail\n\t&quot;
 7384             &quot;MOV    $res,1\n&quot;
 7385           &quot;fail:&quot; %}
 7386   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7387   ins_pipe( pipe_cmpxchg );
 7388 %}
 7389 
 7390 instruct compareAndExchangeL( eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7391   predicate(VM_Version::supports_cx8());
 7392   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7393   effect(KILL cr);
 7394   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7395   ins_encode( enc_cmpxchg8(mem_ptr) );
 7396   ins_pipe( pipe_cmpxchg );
 7397 %}
 7398 
 7399 instruct compareAndExchangeP( pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7400   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7401   effect(KILL cr);
 7402   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7403   ins_encode( enc_cmpxchg(mem_ptr) );
 7404   ins_pipe( pipe_cmpxchg );
 7405 %}
 7406 
 7407 instruct compareAndExchangeB( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7408   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7409   effect(KILL cr);
 7410   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7411   ins_encode( enc_cmpxchgb(mem_ptr) );
 7412   ins_pipe( pipe_cmpxchg );
 7413 %}
 7414 
 7415 instruct compareAndExchangeS( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7416   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7417   effect(KILL cr);
 7418   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7419   ins_encode( enc_cmpxchgw(mem_ptr) );
 7420   ins_pipe( pipe_cmpxchg );
 7421 %}
 7422 
 7423 instruct compareAndExchangeI( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7424   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7425   effect(KILL cr);
 7426   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7427   ins_encode( enc_cmpxchg(mem_ptr) );
 7428   ins_pipe( pipe_cmpxchg );
 7429 %}
 7430 
 7431 instruct xaddB_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7432   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7433   match(Set dummy (GetAndAddB mem add));
 7434   effect(KILL cr);
 7435   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7436   ins_encode %{
 7437     __ lock();
 7438     __ addb($mem$$Address, $add$$constant);
 7439   %}
 7440   ins_pipe( pipe_cmpxchg );
 7441 %}
 7442 
 7443 // Important to match to xRegI: only 8-bit regs.
 7444 instruct xaddB( memory mem, xRegI newval, eFlagsReg cr) %{
 7445   match(Set newval (GetAndAddB mem newval));
 7446   effect(KILL cr);
 7447   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7448   ins_encode %{
 7449     __ lock();
 7450     __ xaddb($mem$$Address, $newval$$Register);
 7451   %}
 7452   ins_pipe( pipe_cmpxchg );
 7453 %}
 7454 
 7455 instruct xaddS_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7456   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7457   match(Set dummy (GetAndAddS mem add));
 7458   effect(KILL cr);
 7459   format %{ &quot;ADDS  [$mem],$add&quot; %}
 7460   ins_encode %{
 7461     __ lock();
 7462     __ addw($mem$$Address, $add$$constant);
 7463   %}
 7464   ins_pipe( pipe_cmpxchg );
 7465 %}
 7466 
 7467 instruct xaddS( memory mem, rRegI newval, eFlagsReg cr) %{
 7468   match(Set newval (GetAndAddS mem newval));
 7469   effect(KILL cr);
 7470   format %{ &quot;XADDS  [$mem],$newval&quot; %}
 7471   ins_encode %{
 7472     __ lock();
 7473     __ xaddw($mem$$Address, $newval$$Register);
 7474   %}
 7475   ins_pipe( pipe_cmpxchg );
 7476 %}
 7477 
 7478 instruct xaddI_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7479   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7480   match(Set dummy (GetAndAddI mem add));
 7481   effect(KILL cr);
 7482   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7483   ins_encode %{
 7484     __ lock();
 7485     __ addl($mem$$Address, $add$$constant);
 7486   %}
 7487   ins_pipe( pipe_cmpxchg );
 7488 %}
 7489 
 7490 instruct xaddI( memory mem, rRegI newval, eFlagsReg cr) %{
 7491   match(Set newval (GetAndAddI mem newval));
 7492   effect(KILL cr);
 7493   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7494   ins_encode %{
 7495     __ lock();
 7496     __ xaddl($mem$$Address, $newval$$Register);
 7497   %}
 7498   ins_pipe( pipe_cmpxchg );
 7499 %}
 7500 
 7501 // Important to match to xRegI: only 8-bit regs.
 7502 instruct xchgB( memory mem, xRegI newval) %{
 7503   match(Set newval (GetAndSetB mem newval));
 7504   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7505   ins_encode %{
 7506     __ xchgb($newval$$Register, $mem$$Address);
 7507   %}
 7508   ins_pipe( pipe_cmpxchg );
 7509 %}
 7510 
 7511 instruct xchgS( memory mem, rRegI newval) %{
 7512   match(Set newval (GetAndSetS mem newval));
 7513   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7514   ins_encode %{
 7515     __ xchgw($newval$$Register, $mem$$Address);
 7516   %}
 7517   ins_pipe( pipe_cmpxchg );
 7518 %}
 7519 
 7520 instruct xchgI( memory mem, rRegI newval) %{
 7521   match(Set newval (GetAndSetI mem newval));
 7522   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7523   ins_encode %{
 7524     __ xchgl($newval$$Register, $mem$$Address);
 7525   %}
 7526   ins_pipe( pipe_cmpxchg );
 7527 %}
 7528 
 7529 instruct xchgP( memory mem, pRegP newval) %{
 7530   match(Set newval (GetAndSetP mem newval));
 7531   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7532   ins_encode %{
 7533     __ xchgl($newval$$Register, $mem$$Address);
 7534   %}
 7535   ins_pipe( pipe_cmpxchg );
 7536 %}
 7537 
 7538 //----------Subtraction Instructions-------------------------------------------
 7539 
 7540 // Integer Subtraction Instructions
 7541 instruct subI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7542   match(Set dst (SubI dst src));
 7543   effect(KILL cr);
 7544 
 7545   size(2);
 7546   format %{ &quot;SUB    $dst,$src&quot; %}
 7547   opcode(0x2B);
 7548   ins_encode( OpcP, RegReg( dst, src) );
 7549   ins_pipe( ialu_reg_reg );
 7550 %}
 7551 
 7552 instruct subI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7553   match(Set dst (SubI dst src));
 7554   effect(KILL cr);
 7555 
 7556   format %{ &quot;SUB    $dst,$src&quot; %}
 7557   opcode(0x81,0x05);  /* Opcode 81 /5 */
 7558   // ins_encode( RegImm( dst, src) );
 7559   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7560   ins_pipe( ialu_reg );
 7561 %}
 7562 
 7563 instruct subI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7564   match(Set dst (SubI dst (LoadI src)));
 7565   effect(KILL cr);
 7566 
 7567   ins_cost(125);
 7568   format %{ &quot;SUB    $dst,$src&quot; %}
 7569   opcode(0x2B);
 7570   ins_encode( OpcP, RegMem( dst, src) );
 7571   ins_pipe( ialu_reg_mem );
 7572 %}
 7573 
 7574 instruct subI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7575   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 7576   effect(KILL cr);
 7577 
 7578   ins_cost(150);
 7579   format %{ &quot;SUB    $dst,$src&quot; %}
 7580   opcode(0x29);  /* Opcode 29 /r */
 7581   ins_encode( OpcP, RegMem( src, dst ) );
 7582   ins_pipe( ialu_mem_reg );
 7583 %}
 7584 
 7585 // Subtract from a pointer
 7586 instruct subP_eReg(eRegP dst, rRegI src, immI0 zero, eFlagsReg cr) %{
 7587   match(Set dst (AddP dst (SubI zero src)));
 7588   effect(KILL cr);
 7589 
 7590   size(2);
 7591   format %{ &quot;SUB    $dst,$src&quot; %}
 7592   opcode(0x2B);
 7593   ins_encode( OpcP, RegReg( dst, src) );
 7594   ins_pipe( ialu_reg_reg );
 7595 %}
 7596 
 7597 instruct negI_eReg(rRegI dst, immI0 zero, eFlagsReg cr) %{
 7598   match(Set dst (SubI zero dst));
 7599   effect(KILL cr);
 7600 
 7601   size(2);
 7602   format %{ &quot;NEG    $dst&quot; %}
 7603   opcode(0xF7,0x03);  // Opcode F7 /3
 7604   ins_encode( OpcP, RegOpc( dst ) );
 7605   ins_pipe( ialu_reg );
 7606 %}
 7607 
 7608 //----------Multiplication/Division Instructions-------------------------------
 7609 // Integer Multiplication Instructions
 7610 // Multiply Register
 7611 instruct mulI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7612   match(Set dst (MulI dst src));
 7613   effect(KILL cr);
 7614 
 7615   size(3);
 7616   ins_cost(300);
 7617   format %{ &quot;IMUL   $dst,$src&quot; %}
 7618   opcode(0xAF, 0x0F);
 7619   ins_encode( OpcS, OpcP, RegReg( dst, src) );
 7620   ins_pipe( ialu_reg_reg_alu0 );
 7621 %}
 7622 
 7623 // Multiply 32-bit Immediate
 7624 instruct mulI_eReg_imm(rRegI dst, rRegI src, immI imm, eFlagsReg cr) %{
 7625   match(Set dst (MulI src imm));
 7626   effect(KILL cr);
 7627 
 7628   ins_cost(300);
 7629   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7630   opcode(0x69);  /* 69 /r id */
 7631   ins_encode( OpcSE(imm), RegReg( dst, src ), Con8or32( imm ) );
 7632   ins_pipe( ialu_reg_reg_alu0 );
 7633 %}
 7634 
 7635 instruct loadConL_low_only(eADXRegL_low_only dst, immL32 src, eFlagsReg cr) %{
 7636   match(Set dst src);
 7637   effect(KILL cr);
 7638 
 7639   // Note that this is artificially increased to make it more expensive than loadConL
 7640   ins_cost(250);
 7641   format %{ &quot;MOV    EAX,$src\t// low word only&quot; %}
 7642   opcode(0xB8);
 7643   ins_encode( LdImmL_Lo(dst, src) );
 7644   ins_pipe( ialu_reg_fat );
 7645 %}
 7646 
 7647 // Multiply by 32-bit Immediate, taking the shifted high order results
 7648 //  (special case for shift by 32)
 7649 instruct mulI_imm_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32 cnt, eFlagsReg cr) %{
 7650   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7651   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7652              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7653              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7654   effect(USE src1, KILL cr);
 7655 
 7656   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7657   ins_cost(0*100 + 1*400 - 150);
 7658   format %{ &quot;IMUL   EDX:EAX,$src1&quot; %}
 7659   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7660   ins_pipe( pipe_slow );
 7661 %}
 7662 
 7663 // Multiply by 32-bit Immediate, taking the shifted high order results
 7664 instruct mulI_imm_RShift_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr) %{
 7665   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7666   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7667              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7668              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7669   effect(USE src1, KILL cr);
 7670 
 7671   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7672   ins_cost(1*100 + 1*400 - 150);
 7673   format %{ &quot;IMUL   EDX:EAX,$src1\n\t&quot;
 7674             &quot;SAR    EDX,$cnt-32&quot; %}
 7675   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7676   ins_pipe( pipe_slow );
 7677 %}
 7678 
 7679 // Multiply Memory 32-bit Immediate
 7680 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, eFlagsReg cr) %{
 7681   match(Set dst (MulI (LoadI src) imm));
 7682   effect(KILL cr);
 7683 
 7684   ins_cost(300);
 7685   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7686   opcode(0x69);  /* 69 /r id */
 7687   ins_encode( OpcSE(imm), RegMem( dst, src ), Con8or32( imm ) );
 7688   ins_pipe( ialu_reg_mem_alu0 );
 7689 %}
 7690 
 7691 // Multiply Memory
 7692 instruct mulI(rRegI dst, memory src, eFlagsReg cr) %{
 7693   match(Set dst (MulI dst (LoadI src)));
 7694   effect(KILL cr);
 7695 
 7696   ins_cost(350);
 7697   format %{ &quot;IMUL   $dst,$src&quot; %}
 7698   opcode(0xAF, 0x0F);
 7699   ins_encode( OpcS, OpcP, RegMem( dst, src) );
 7700   ins_pipe( ialu_reg_mem_alu0 );
 7701 %}
 7702 
 7703 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, eFlagsReg cr)
 7704 %{
 7705   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 7706   effect(KILL cr, KILL src2);
 7707 
 7708   expand %{ mulI_eReg(dst, src1, cr);
 7709            mulI_eReg(src2, src3, cr);
 7710            addI_eReg(dst, src2, cr); %}
 7711 %}
 7712 
 7713 // Multiply Register Int to Long
 7714 instruct mulI2L(eADXRegL dst, eAXRegI src, nadxRegI src1, eFlagsReg flags) %{
 7715   // Basic Idea: long = (long)int * (long)int
 7716   match(Set dst (MulL (ConvI2L src) (ConvI2L src1)));
 7717   effect(DEF dst, USE src, USE src1, KILL flags);
 7718 
 7719   ins_cost(300);
 7720   format %{ &quot;IMUL   $dst,$src1&quot; %}
 7721 
 7722   ins_encode( long_int_multiply( dst, src1 ) );
 7723   ins_pipe( ialu_reg_reg_alu0 );
 7724 %}
 7725 
 7726 instruct mulIS_eReg(eADXRegL dst, immL_32bits mask, eFlagsReg flags, eAXRegI src, nadxRegI src1) %{
 7727   // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 7728   match(Set dst (MulL (AndL (ConvI2L src) mask) (AndL (ConvI2L src1) mask)));
 7729   effect(KILL flags);
 7730 
 7731   ins_cost(300);
 7732   format %{ &quot;MUL    $dst,$src1&quot; %}
 7733 
 7734   ins_encode( long_uint_multiply(dst, src1) );
 7735   ins_pipe( ialu_reg_reg_alu0 );
 7736 %}
 7737 
 7738 // Multiply Register Long
 7739 instruct mulL_eReg(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7740   match(Set dst (MulL dst src));
 7741   effect(KILL cr, TEMP tmp);
 7742   ins_cost(4*100+3*400);
 7743 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7744 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 7745   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7746             &quot;IMUL   $tmp,EDX\n\t&quot;
 7747             &quot;MOV    EDX,$src.hi\n\t&quot;
 7748             &quot;IMUL   EDX,EAX\n\t&quot;
 7749             &quot;ADD    $tmp,EDX\n\t&quot;
 7750             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7751             &quot;ADD    EDX,$tmp&quot; %}
 7752   ins_encode( long_multiply( dst, src, tmp ) );
 7753   ins_pipe( pipe_slow );
 7754 %}
 7755 
 7756 // Multiply Register Long where the left operand&#39;s high 32 bits are zero
 7757 instruct mulL_eReg_lhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7758   predicate(is_operand_hi32_zero(n-&gt;in(1)));
 7759   match(Set dst (MulL dst src));
 7760   effect(KILL cr, TEMP tmp);
 7761   ins_cost(2*100+2*400);
 7762 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7763 //             hi(result) = hi(x_lo * y_lo) + lo(x_lo * y_hi) where lo(x_hi * y_lo) = 0 because x_hi = 0
 7764   format %{ &quot;MOV    $tmp,$src.hi\n\t&quot;
 7765             &quot;IMUL   $tmp,EAX\n\t&quot;
 7766             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7767             &quot;ADD    EDX,$tmp&quot; %}
 7768   ins_encode %{
 7769     __ movl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 7770     __ imull($tmp$$Register, rax);
 7771     __ mull($src$$Register);
 7772     __ addl(rdx, $tmp$$Register);
 7773   %}
 7774   ins_pipe( pipe_slow );
 7775 %}
 7776 
 7777 // Multiply Register Long where the right operand&#39;s high 32 bits are zero
 7778 instruct mulL_eReg_rhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7779   predicate(is_operand_hi32_zero(n-&gt;in(2)));
 7780   match(Set dst (MulL dst src));
 7781   effect(KILL cr, TEMP tmp);
 7782   ins_cost(2*100+2*400);
 7783 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7784 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) where lo(x_lo * y_hi) = 0 because y_hi = 0
 7785   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7786             &quot;IMUL   $tmp,EDX\n\t&quot;
 7787             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7788             &quot;ADD    EDX,$tmp&quot; %}
 7789   ins_encode %{
 7790     __ movl($tmp$$Register, $src$$Register);
 7791     __ imull($tmp$$Register, rdx);
 7792     __ mull($src$$Register);
 7793     __ addl(rdx, $tmp$$Register);
 7794   %}
 7795   ins_pipe( pipe_slow );
 7796 %}
 7797 
 7798 // Multiply Register Long where the left and the right operands&#39; high 32 bits are zero
 7799 instruct mulL_eReg_hi0(eADXRegL dst, eRegL src, eFlagsReg cr) %{
 7800   predicate(is_operand_hi32_zero(n-&gt;in(1)) &amp;&amp; is_operand_hi32_zero(n-&gt;in(2)));
 7801   match(Set dst (MulL dst src));
 7802   effect(KILL cr);
 7803   ins_cost(1*400);
 7804 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7805 //             hi(result) = hi(x_lo * y_lo) where lo(x_hi * y_lo) = 0 and lo(x_lo * y_hi) = 0 because x_hi = 0 and y_hi = 0
 7806   format %{ &quot;MUL    EDX:EAX,$src.lo\n\t&quot; %}
 7807   ins_encode %{
 7808     __ mull($src$$Register);
 7809   %}
 7810   ins_pipe( pipe_slow );
 7811 %}
 7812 
 7813 // Multiply Register Long by small constant
 7814 instruct mulL_eReg_con(eADXRegL dst, immL_127 src, rRegI tmp, eFlagsReg cr) %{
 7815   match(Set dst (MulL dst src));
 7816   effect(KILL cr, TEMP tmp);
 7817   ins_cost(2*100+2*400);
 7818   size(12);
 7819 // Basic idea: lo(result) = lo(src * EAX)
 7820 //             hi(result) = hi(src * EAX) + lo(src * EDX)
 7821   format %{ &quot;IMUL   $tmp,EDX,$src\n\t&quot;
 7822             &quot;MOV    EDX,$src\n\t&quot;
 7823             &quot;MUL    EDX\t# EDX*EAX -&gt; EDX:EAX\n\t&quot;
 7824             &quot;ADD    EDX,$tmp&quot; %}
 7825   ins_encode( long_multiply_con( dst, src, tmp ) );
 7826   ins_pipe( pipe_slow );
 7827 %}
 7828 
 7829 // Integer DIV with Register
 7830 instruct divI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7831   match(Set rax (DivI rax div));
 7832   effect(KILL rdx, KILL cr);
 7833   size(26);
 7834   ins_cost(30*100+10*100);
 7835   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7836             &quot;JNE,s  normal\n\t&quot;
 7837             &quot;XOR    EDX,EDX\n\t&quot;
 7838             &quot;CMP    ECX,-1\n\t&quot;
 7839             &quot;JE,s   done\n&quot;
 7840     &quot;normal: CDQ\n\t&quot;
 7841             &quot;IDIV   $div\n\t&quot;
 7842     &quot;done:&quot;        %}
 7843   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7844   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7845   ins_pipe( ialu_reg_reg_alu0 );
 7846 %}
 7847 
 7848 // Divide Register Long
 7849 instruct divL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7850   match(Set dst (DivL src1 src2));
 7851   effect( KILL cr, KILL cx, KILL bx );
 7852   ins_cost(10000);
 7853   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7854             &quot;PUSH   $src1.lo\n\t&quot;
 7855             &quot;PUSH   $src2.hi\n\t&quot;
 7856             &quot;PUSH   $src2.lo\n\t&quot;
 7857             &quot;CALL   SharedRuntime::ldiv\n\t&quot;
 7858             &quot;ADD    ESP,16&quot; %}
 7859   ins_encode( long_div(src1,src2) );
 7860   ins_pipe( pipe_slow );
 7861 %}
 7862 
 7863 // Integer DIVMOD with Register, both quotient and mod results
 7864 instruct divModI_eReg_divmod(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7865   match(DivModI rax div);
 7866   effect(KILL cr);
 7867   size(26);
 7868   ins_cost(30*100+10*100);
 7869   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7870             &quot;JNE,s  normal\n\t&quot;
 7871             &quot;XOR    EDX,EDX\n\t&quot;
 7872             &quot;CMP    ECX,-1\n\t&quot;
 7873             &quot;JE,s   done\n&quot;
 7874     &quot;normal: CDQ\n\t&quot;
 7875             &quot;IDIV   $div\n\t&quot;
 7876     &quot;done:&quot;        %}
 7877   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7878   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7879   ins_pipe( pipe_slow );
 7880 %}
 7881 
 7882 // Integer MOD with Register
 7883 instruct modI_eReg(eDXRegI rdx, eAXRegI rax, eCXRegI div, eFlagsReg cr) %{
 7884   match(Set rdx (ModI rax div));
 7885   effect(KILL rax, KILL cr);
 7886 
 7887   size(26);
 7888   ins_cost(300);
 7889   format %{ &quot;CDQ\n\t&quot;
 7890             &quot;IDIV   $div&quot; %}
 7891   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7892   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7893   ins_pipe( ialu_reg_reg_alu0 );
 7894 %}
 7895 
 7896 // Remainder Register Long
 7897 instruct modL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7898   match(Set dst (ModL src1 src2));
 7899   effect( KILL cr, KILL cx, KILL bx );
 7900   ins_cost(10000);
 7901   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7902             &quot;PUSH   $src1.lo\n\t&quot;
 7903             &quot;PUSH   $src2.hi\n\t&quot;
 7904             &quot;PUSH   $src2.lo\n\t&quot;
 7905             &quot;CALL   SharedRuntime::lrem\n\t&quot;
 7906             &quot;ADD    ESP,16&quot; %}
 7907   ins_encode( long_mod(src1,src2) );
 7908   ins_pipe( pipe_slow );
 7909 %}
 7910 
 7911 // Divide Register Long (no special case since divisor != -1)
 7912 instruct divL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7913   match(Set dst (DivL dst imm));
 7914   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7915   ins_cost(1000);
 7916   format %{ &quot;MOV    $tmp,abs($imm) # ldiv EDX:EAX,$imm\n\t&quot;
 7917             &quot;XOR    $tmp2,$tmp2\n\t&quot;
 7918             &quot;CMP    $tmp,EDX\n\t&quot;
 7919             &quot;JA,s   fast\n\t&quot;
 7920             &quot;MOV    $tmp2,EAX\n\t&quot;
 7921             &quot;MOV    EAX,EDX\n\t&quot;
 7922             &quot;MOV    EDX,0\n\t&quot;
 7923             &quot;JLE,s  pos\n\t&quot;
 7924             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7925             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7926             &quot;XCHG   EAX,$tmp2\n\t&quot;
 7927             &quot;DIV    $tmp\n\t&quot;
 7928             &quot;LNEG   $tmp2 : EAX\n\t&quot;
 7929             &quot;JMP,s  done\n&quot;
 7930     &quot;pos:\n\t&quot;
 7931             &quot;DIV    $tmp\n\t&quot;
 7932             &quot;XCHG   EAX,$tmp2\n&quot;
 7933     &quot;fast:\n\t&quot;
 7934             &quot;DIV    $tmp\n&quot;
 7935     &quot;done:\n\t&quot;
 7936             &quot;MOV    EDX,$tmp2\n\t&quot;
 7937             &quot;NEG    EDX:EAX # if $imm &lt; 0&quot; %}
 7938   ins_encode %{
 7939     int con = (int)$imm$$constant;
 7940     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 7941     int pcon = (con &gt; 0) ? con : -con;
 7942     Label Lfast, Lpos, Ldone;
 7943 
 7944     __ movl($tmp$$Register, pcon);
 7945     __ xorl($tmp2$$Register,$tmp2$$Register);
 7946     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 7947     __ jccb(Assembler::above, Lfast); // result fits into 32 bit
 7948 
 7949     __ movl($tmp2$$Register, $dst$$Register); // save
 7950     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 7951     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 7952     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 7953 
 7954     // Negative dividend.
 7955     // convert value to positive to use unsigned division
 7956     __ lneg($dst$$Register, $tmp2$$Register);
 7957     __ divl($tmp$$Register);
 7958     __ xchgl($dst$$Register, $tmp2$$Register);
 7959     __ divl($tmp$$Register);
 7960     // revert result back to negative
 7961     __ lneg($tmp2$$Register, $dst$$Register);
 7962     __ jmpb(Ldone);
 7963 
 7964     __ bind(Lpos);
 7965     __ divl($tmp$$Register); // Use unsigned division
 7966     __ xchgl($dst$$Register, $tmp2$$Register);
 7967     // Fallthrow for final divide, tmp2 has 32 bit hi result
 7968 
 7969     __ bind(Lfast);
 7970     // fast path: src is positive
 7971     __ divl($tmp$$Register); // Use unsigned division
 7972 
 7973     __ bind(Ldone);
 7974     __ movl(HIGH_FROM_LOW($dst$$Register),$tmp2$$Register);
 7975     if (con &lt; 0) {
 7976       __ lneg(HIGH_FROM_LOW($dst$$Register), $dst$$Register);
 7977     }
 7978   %}
 7979   ins_pipe( pipe_slow );
 7980 %}
 7981 
 7982 // Remainder Register Long (remainder fit into 32 bits)
 7983 instruct modL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7984   match(Set dst (ModL dst imm));
 7985   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7986   ins_cost(1000);
 7987   format %{ &quot;MOV    $tmp,abs($imm) # lrem EDX:EAX,$imm\n\t&quot;
 7988             &quot;CMP    $tmp,EDX\n\t&quot;
 7989             &quot;JA,s   fast\n\t&quot;
 7990             &quot;MOV    $tmp2,EAX\n\t&quot;
 7991             &quot;MOV    EAX,EDX\n\t&quot;
 7992             &quot;MOV    EDX,0\n\t&quot;
 7993             &quot;JLE,s  pos\n\t&quot;
 7994             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7995             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7996             &quot;MOV    EAX,$tmp2\n\t&quot;
 7997             &quot;DIV    $tmp\n\t&quot;
 7998             &quot;NEG    EDX\n\t&quot;
 7999             &quot;JMP,s  done\n&quot;
 8000     &quot;pos:\n\t&quot;
 8001             &quot;DIV    $tmp\n\t&quot;
 8002             &quot;MOV    EAX,$tmp2\n&quot;
 8003     &quot;fast:\n\t&quot;
 8004             &quot;DIV    $tmp\n&quot;
 8005     &quot;done:\n\t&quot;
 8006             &quot;MOV    EAX,EDX\n\t&quot;
 8007             &quot;SAR    EDX,31\n\t&quot; %}
 8008   ins_encode %{
 8009     int con = (int)$imm$$constant;
 8010     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 8011     int pcon = (con &gt; 0) ? con : -con;
 8012     Label  Lfast, Lpos, Ldone;
 8013 
 8014     __ movl($tmp$$Register, pcon);
 8015     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 8016     __ jccb(Assembler::above, Lfast); // src is positive and result fits into 32 bit
 8017 
 8018     __ movl($tmp2$$Register, $dst$$Register); // save
 8019     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8020     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 8021     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 8022 
 8023     // Negative dividend.
 8024     // convert value to positive to use unsigned division
 8025     __ lneg($dst$$Register, $tmp2$$Register);
 8026     __ divl($tmp$$Register);
 8027     __ movl($dst$$Register, $tmp2$$Register);
 8028     __ divl($tmp$$Register);
 8029     // revert remainder back to negative
 8030     __ negl(HIGH_FROM_LOW($dst$$Register));
 8031     __ jmpb(Ldone);
 8032 
 8033     __ bind(Lpos);
 8034     __ divl($tmp$$Register);
 8035     __ movl($dst$$Register, $tmp2$$Register);
 8036 
 8037     __ bind(Lfast);
 8038     // fast path: src is positive
 8039     __ divl($tmp$$Register);
 8040 
 8041     __ bind(Ldone);
 8042     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8043     __ sarl(HIGH_FROM_LOW($dst$$Register), 31); // result sign
 8044 
 8045   %}
 8046   ins_pipe( pipe_slow );
 8047 %}
 8048 
 8049 // Integer Shift Instructions
 8050 // Shift Left by one
 8051 instruct shlI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8052   match(Set dst (LShiftI dst shift));
 8053   effect(KILL cr);
 8054 
 8055   size(2);
 8056   format %{ &quot;SHL    $dst,$shift&quot; %}
 8057   opcode(0xD1, 0x4);  /* D1 /4 */
 8058   ins_encode( OpcP, RegOpc( dst ) );
 8059   ins_pipe( ialu_reg );
 8060 %}
 8061 
 8062 // Shift Left by 8-bit immediate
 8063 instruct salI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8064   match(Set dst (LShiftI dst shift));
 8065   effect(KILL cr);
 8066 
 8067   size(3);
 8068   format %{ &quot;SHL    $dst,$shift&quot; %}
 8069   opcode(0xC1, 0x4);  /* C1 /4 ib */
 8070   ins_encode( RegOpcImm( dst, shift) );
 8071   ins_pipe( ialu_reg );
 8072 %}
 8073 
 8074 // Shift Left by variable
 8075 instruct salI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8076   match(Set dst (LShiftI dst shift));
 8077   effect(KILL cr);
 8078 
 8079   size(2);
 8080   format %{ &quot;SHL    $dst,$shift&quot; %}
 8081   opcode(0xD3, 0x4);  /* D3 /4 */
 8082   ins_encode( OpcP, RegOpc( dst ) );
 8083   ins_pipe( ialu_reg_reg );
 8084 %}
 8085 
 8086 // Arithmetic shift right by one
 8087 instruct sarI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8088   match(Set dst (RShiftI dst shift));
 8089   effect(KILL cr);
 8090 
 8091   size(2);
 8092   format %{ &quot;SAR    $dst,$shift&quot; %}
 8093   opcode(0xD1, 0x7);  /* D1 /7 */
 8094   ins_encode( OpcP, RegOpc( dst ) );
 8095   ins_pipe( ialu_reg );
 8096 %}
 8097 
 8098 // Arithmetic shift right by one
 8099 instruct sarI_mem_1(memory dst, immI1 shift, eFlagsReg cr) %{
 8100   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8101   effect(KILL cr);
 8102   format %{ &quot;SAR    $dst,$shift&quot; %}
 8103   opcode(0xD1, 0x7);  /* D1 /7 */
 8104   ins_encode( OpcP, RMopc_Mem(secondary,dst) );
 8105   ins_pipe( ialu_mem_imm );
 8106 %}
 8107 
 8108 // Arithmetic Shift Right by 8-bit immediate
 8109 instruct sarI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8110   match(Set dst (RShiftI dst shift));
 8111   effect(KILL cr);
 8112 
 8113   size(3);
 8114   format %{ &quot;SAR    $dst,$shift&quot; %}
 8115   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8116   ins_encode( RegOpcImm( dst, shift ) );
 8117   ins_pipe( ialu_mem_imm );
 8118 %}
 8119 
 8120 // Arithmetic Shift Right by 8-bit immediate
 8121 instruct sarI_mem_imm(memory dst, immI8 shift, eFlagsReg cr) %{
 8122   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8123   effect(KILL cr);
 8124 
 8125   format %{ &quot;SAR    $dst,$shift&quot; %}
 8126   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8127   ins_encode( OpcP, RMopc_Mem(secondary, dst ), Con8or32( shift ) );
 8128   ins_pipe( ialu_mem_imm );
 8129 %}
 8130 
 8131 // Arithmetic Shift Right by variable
 8132 instruct sarI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8133   match(Set dst (RShiftI dst shift));
 8134   effect(KILL cr);
 8135 
 8136   size(2);
 8137   format %{ &quot;SAR    $dst,$shift&quot; %}
 8138   opcode(0xD3, 0x7);  /* D3 /7 */
 8139   ins_encode( OpcP, RegOpc( dst ) );
 8140   ins_pipe( ialu_reg_reg );
 8141 %}
 8142 
 8143 // Logical shift right by one
 8144 instruct shrI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8145   match(Set dst (URShiftI dst shift));
 8146   effect(KILL cr);
 8147 
 8148   size(2);
 8149   format %{ &quot;SHR    $dst,$shift&quot; %}
 8150   opcode(0xD1, 0x5);  /* D1 /5 */
 8151   ins_encode( OpcP, RegOpc( dst ) );
 8152   ins_pipe( ialu_reg );
 8153 %}
 8154 
 8155 // Logical Shift Right by 8-bit immediate
 8156 instruct shrI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8157   match(Set dst (URShiftI dst shift));
 8158   effect(KILL cr);
 8159 
 8160   size(3);
 8161   format %{ &quot;SHR    $dst,$shift&quot; %}
 8162   opcode(0xC1, 0x5);  /* C1 /5 ib */
 8163   ins_encode( RegOpcImm( dst, shift) );
 8164   ins_pipe( ialu_reg );
 8165 %}
 8166 
 8167 
 8168 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8169 // This idiom is used by the compiler for the i2b bytecode.
 8170 instruct i2b(rRegI dst, xRegI src, immI_24 twentyfour) %{
 8171   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8172 
 8173   size(3);
 8174   format %{ &quot;MOVSX  $dst,$src :8&quot; %}
 8175   ins_encode %{
 8176     __ movsbl($dst$$Register, $src$$Register);
 8177   %}
 8178   ins_pipe(ialu_reg_reg);
 8179 %}
 8180 
 8181 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8182 // This idiom is used by the compiler the i2s bytecode.
 8183 instruct i2s(rRegI dst, xRegI src, immI_16 sixteen) %{
 8184   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8185 
 8186   size(3);
 8187   format %{ &quot;MOVSX  $dst,$src :16&quot; %}
 8188   ins_encode %{
 8189     __ movswl($dst$$Register, $src$$Register);
 8190   %}
 8191   ins_pipe(ialu_reg_reg);
 8192 %}
 8193 
 8194 
 8195 // Logical Shift Right by variable
 8196 instruct shrI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8197   match(Set dst (URShiftI dst shift));
 8198   effect(KILL cr);
 8199 
 8200   size(2);
 8201   format %{ &quot;SHR    $dst,$shift&quot; %}
 8202   opcode(0xD3, 0x5);  /* D3 /5 */
 8203   ins_encode( OpcP, RegOpc( dst ) );
 8204   ins_pipe( ialu_reg_reg );
 8205 %}
 8206 
 8207 
 8208 //----------Logical Instructions-----------------------------------------------
 8209 //----------Integer Logical Instructions---------------------------------------
 8210 // And Instructions
 8211 // And Register with Register
 8212 instruct andI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8213   match(Set dst (AndI dst src));
 8214   effect(KILL cr);
 8215 
 8216   size(2);
 8217   format %{ &quot;AND    $dst,$src&quot; %}
 8218   opcode(0x23);
 8219   ins_encode( OpcP, RegReg( dst, src) );
 8220   ins_pipe( ialu_reg_reg );
 8221 %}
 8222 
 8223 // And Register with Immediate
 8224 instruct andI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8225   match(Set dst (AndI dst src));
 8226   effect(KILL cr);
 8227 
 8228   format %{ &quot;AND    $dst,$src&quot; %}
 8229   opcode(0x81,0x04);  /* Opcode 81 /4 */
 8230   // ins_encode( RegImm( dst, src) );
 8231   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8232   ins_pipe( ialu_reg );
 8233 %}
 8234 
 8235 // And Register with Memory
 8236 instruct andI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8237   match(Set dst (AndI dst (LoadI src)));
 8238   effect(KILL cr);
 8239 
 8240   ins_cost(125);
 8241   format %{ &quot;AND    $dst,$src&quot; %}
 8242   opcode(0x23);
 8243   ins_encode( OpcP, RegMem( dst, src) );
 8244   ins_pipe( ialu_reg_mem );
 8245 %}
 8246 
 8247 // And Memory with Register
 8248 instruct andI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8249   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8250   effect(KILL cr);
 8251 
 8252   ins_cost(150);
 8253   format %{ &quot;AND    $dst,$src&quot; %}
 8254   opcode(0x21);  /* Opcode 21 /r */
 8255   ins_encode( OpcP, RegMem( src, dst ) );
 8256   ins_pipe( ialu_mem_reg );
 8257 %}
 8258 
 8259 // And Memory with Immediate
 8260 instruct andI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8261   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8262   effect(KILL cr);
 8263 
 8264   ins_cost(125);
 8265   format %{ &quot;AND    $dst,$src&quot; %}
 8266   opcode(0x81, 0x4);  /* Opcode 81 /4 id */
 8267   // ins_encode( MemImm( dst, src) );
 8268   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8269   ins_pipe( ialu_mem_imm );
 8270 %}
 8271 
 8272 // BMI1 instructions
 8273 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, eFlagsReg cr) %{
 8274   match(Set dst (AndI (XorI src1 minus_1) src2));
 8275   predicate(UseBMI1Instructions);
 8276   effect(KILL cr);
 8277 
 8278   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8279 
 8280   ins_encode %{
 8281     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 8282   %}
 8283   ins_pipe(ialu_reg);
 8284 %}
 8285 
 8286 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, eFlagsReg cr) %{
 8287   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2) ));
 8288   predicate(UseBMI1Instructions);
 8289   effect(KILL cr);
 8290 
 8291   ins_cost(125);
 8292   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8293 
 8294   ins_encode %{
 8295     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 8296   %}
 8297   ins_pipe(ialu_reg_mem);
 8298 %}
 8299 
 8300 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, eFlagsReg cr) %{
 8301   match(Set dst (AndI (SubI imm_zero src) src));
 8302   predicate(UseBMI1Instructions);
 8303   effect(KILL cr);
 8304 
 8305   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8306 
 8307   ins_encode %{
 8308     __ blsil($dst$$Register, $src$$Register);
 8309   %}
 8310   ins_pipe(ialu_reg);
 8311 %}
 8312 
 8313 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, eFlagsReg cr) %{
 8314   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 8315   predicate(UseBMI1Instructions);
 8316   effect(KILL cr);
 8317 
 8318   ins_cost(125);
 8319   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8320 
 8321   ins_encode %{
 8322     __ blsil($dst$$Register, $src$$Address);
 8323   %}
 8324   ins_pipe(ialu_reg_mem);
 8325 %}
 8326 
 8327 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8328 %{
 8329   match(Set dst (XorI (AddI src minus_1) src));
 8330   predicate(UseBMI1Instructions);
 8331   effect(KILL cr);
 8332 
 8333   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8334 
 8335   ins_encode %{
 8336     __ blsmskl($dst$$Register, $src$$Register);
 8337   %}
 8338 
 8339   ins_pipe(ialu_reg);
 8340 %}
 8341 
 8342 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8343 %{
 8344   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ));
 8345   predicate(UseBMI1Instructions);
 8346   effect(KILL cr);
 8347 
 8348   ins_cost(125);
 8349   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8350 
 8351   ins_encode %{
 8352     __ blsmskl($dst$$Register, $src$$Address);
 8353   %}
 8354 
 8355   ins_pipe(ialu_reg_mem);
 8356 %}
 8357 
 8358 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8359 %{
 8360   match(Set dst (AndI (AddI src minus_1) src) );
 8361   predicate(UseBMI1Instructions);
 8362   effect(KILL cr);
 8363 
 8364   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8365 
 8366   ins_encode %{
 8367     __ blsrl($dst$$Register, $src$$Register);
 8368   %}
 8369 
 8370   ins_pipe(ialu_reg);
 8371 %}
 8372 
 8373 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8374 %{
 8375   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ));
 8376   predicate(UseBMI1Instructions);
 8377   effect(KILL cr);
 8378 
 8379   ins_cost(125);
 8380   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8381 
 8382   ins_encode %{
 8383     __ blsrl($dst$$Register, $src$$Address);
 8384   %}
 8385 
 8386   ins_pipe(ialu_reg_mem);
 8387 %}
 8388 
 8389 // Or Instructions
 8390 // Or Register with Register
 8391 instruct orI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8392   match(Set dst (OrI dst src));
 8393   effect(KILL cr);
 8394 
 8395   size(2);
 8396   format %{ &quot;OR     $dst,$src&quot; %}
 8397   opcode(0x0B);
 8398   ins_encode( OpcP, RegReg( dst, src) );
 8399   ins_pipe( ialu_reg_reg );
 8400 %}
 8401 
 8402 instruct orI_eReg_castP2X(rRegI dst, eRegP src, eFlagsReg cr) %{
 8403   match(Set dst (OrI dst (CastP2X src)));
 8404   effect(KILL cr);
 8405 
 8406   size(2);
 8407   format %{ &quot;OR     $dst,$src&quot; %}
 8408   opcode(0x0B);
 8409   ins_encode( OpcP, RegReg( dst, src) );
 8410   ins_pipe( ialu_reg_reg );
 8411 %}
 8412 
 8413 
 8414 // Or Register with Immediate
 8415 instruct orI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8416   match(Set dst (OrI dst src));
 8417   effect(KILL cr);
 8418 
 8419   format %{ &quot;OR     $dst,$src&quot; %}
 8420   opcode(0x81,0x01);  /* Opcode 81 /1 id */
 8421   // ins_encode( RegImm( dst, src) );
 8422   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8423   ins_pipe( ialu_reg );
 8424 %}
 8425 
 8426 // Or Register with Memory
 8427 instruct orI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8428   match(Set dst (OrI dst (LoadI src)));
 8429   effect(KILL cr);
 8430 
 8431   ins_cost(125);
 8432   format %{ &quot;OR     $dst,$src&quot; %}
 8433   opcode(0x0B);
 8434   ins_encode( OpcP, RegMem( dst, src) );
 8435   ins_pipe( ialu_reg_mem );
 8436 %}
 8437 
 8438 // Or Memory with Register
 8439 instruct orI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8440   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8441   effect(KILL cr);
 8442 
 8443   ins_cost(150);
 8444   format %{ &quot;OR     $dst,$src&quot; %}
 8445   opcode(0x09);  /* Opcode 09 /r */
 8446   ins_encode( OpcP, RegMem( src, dst ) );
 8447   ins_pipe( ialu_mem_reg );
 8448 %}
 8449 
 8450 // Or Memory with Immediate
 8451 instruct orI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8452   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8453   effect(KILL cr);
 8454 
 8455   ins_cost(125);
 8456   format %{ &quot;OR     $dst,$src&quot; %}
 8457   opcode(0x81,0x1);  /* Opcode 81 /1 id */
 8458   // ins_encode( MemImm( dst, src) );
 8459   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8460   ins_pipe( ialu_mem_imm );
 8461 %}
 8462 
 8463 // ROL/ROR
 8464 // ROL expand
 8465 instruct rolI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8466   effect(USE_DEF dst, USE shift, KILL cr);
 8467 
 8468   format %{ &quot;ROL    $dst, $shift&quot; %}
 8469   opcode(0xD1, 0x0); /* Opcode D1 /0 */
 8470   ins_encode( OpcP, RegOpc( dst ));
 8471   ins_pipe( ialu_reg );
 8472 %}
 8473 
 8474 instruct rolI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8475   effect(USE_DEF dst, USE shift, KILL cr);
 8476 
 8477   format %{ &quot;ROL    $dst, $shift&quot; %}
 8478   opcode(0xC1, 0x0); /*Opcode /C1  /0  */
 8479   ins_encode( RegOpcImm(dst, shift) );
 8480   ins_pipe(ialu_reg);
 8481 %}
 8482 
 8483 instruct rolI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8484   effect(USE_DEF dst, USE shift, KILL cr);
 8485 
 8486   format %{ &quot;ROL    $dst, $shift&quot; %}
 8487   opcode(0xD3, 0x0);    /* Opcode D3 /0 */
 8488   ins_encode(OpcP, RegOpc(dst));
 8489   ins_pipe( ialu_reg_reg );
 8490 %}
 8491 // end of ROL expand
 8492 
 8493 // ROL 32bit by one once
 8494 instruct rolI_eReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, eFlagsReg cr) %{
 8495   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8496 
 8497   expand %{
 8498     rolI_eReg_imm1(dst, lshift, cr);
 8499   %}
 8500 %}
 8501 
 8502 // ROL 32bit var by imm8 once
 8503 instruct rolI_eReg_i8(rRegI dst, immI8 lshift, immI8 rshift, eFlagsReg cr) %{
 8504   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8505   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8506 
 8507   expand %{
 8508     rolI_eReg_imm8(dst, lshift, cr);
 8509   %}
 8510 %}
 8511 
 8512 // ROL 32bit var by var once
 8513 instruct rolI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8514   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 8515 
 8516   expand %{
 8517     rolI_eReg_CL(dst, shift, cr);
 8518   %}
 8519 %}
 8520 
 8521 // ROL 32bit var by var once
 8522 instruct rolI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8523   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 8524 
 8525   expand %{
 8526     rolI_eReg_CL(dst, shift, cr);
 8527   %}
 8528 %}
 8529 
 8530 // ROR expand
 8531 instruct rorI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8532   effect(USE_DEF dst, USE shift, KILL cr);
 8533 
 8534   format %{ &quot;ROR    $dst, $shift&quot; %}
 8535   opcode(0xD1,0x1);  /* Opcode D1 /1 */
 8536   ins_encode( OpcP, RegOpc( dst ) );
 8537   ins_pipe( ialu_reg );
 8538 %}
 8539 
 8540 instruct rorI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8541   effect (USE_DEF dst, USE shift, KILL cr);
 8542 
 8543   format %{ &quot;ROR    $dst, $shift&quot; %}
 8544   opcode(0xC1, 0x1); /* Opcode /C1 /1 ib */
 8545   ins_encode( RegOpcImm(dst, shift) );
 8546   ins_pipe( ialu_reg );
 8547 %}
 8548 
 8549 instruct rorI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr)%{
 8550   effect(USE_DEF dst, USE shift, KILL cr);
 8551 
 8552   format %{ &quot;ROR    $dst, $shift&quot; %}
 8553   opcode(0xD3, 0x1);    /* Opcode D3 /1 */
 8554   ins_encode(OpcP, RegOpc(dst));
 8555   ins_pipe( ialu_reg_reg );
 8556 %}
 8557 // end of ROR expand
 8558 
 8559 // ROR right once
 8560 instruct rorI_eReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, eFlagsReg cr) %{
 8561   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8562 
 8563   expand %{
 8564     rorI_eReg_imm1(dst, rshift, cr);
 8565   %}
 8566 %}
 8567 
 8568 // ROR 32bit by immI8 once
 8569 instruct rorI_eReg_i8(rRegI dst, immI8 rshift, immI8 lshift, eFlagsReg cr) %{
 8570   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8571   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8572 
 8573   expand %{
 8574     rorI_eReg_imm8(dst, rshift, cr);
 8575   %}
 8576 %}
 8577 
 8578 // ROR 32bit var by var once
 8579 instruct rorI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8580   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 8581 
 8582   expand %{
 8583     rorI_eReg_CL(dst, shift, cr);
 8584   %}
 8585 %}
 8586 
 8587 // ROR 32bit var by var once
 8588 instruct rorI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8589   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 8590 
 8591   expand %{
 8592     rorI_eReg_CL(dst, shift, cr);
 8593   %}
 8594 %}
 8595 
 8596 // Xor Instructions
 8597 // Xor Register with Register
 8598 instruct xorI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8599   match(Set dst (XorI dst src));
 8600   effect(KILL cr);
 8601 
 8602   size(2);
 8603   format %{ &quot;XOR    $dst,$src&quot; %}
 8604   opcode(0x33);
 8605   ins_encode( OpcP, RegReg( dst, src) );
 8606   ins_pipe( ialu_reg_reg );
 8607 %}
 8608 
 8609 // Xor Register with Immediate -1
 8610 instruct xorI_eReg_im1(rRegI dst, immI_M1 imm) %{
 8611   match(Set dst (XorI dst imm));
 8612 
 8613   size(2);
 8614   format %{ &quot;NOT    $dst&quot; %}
 8615   ins_encode %{
 8616      __ notl($dst$$Register);
 8617   %}
 8618   ins_pipe( ialu_reg );
 8619 %}
 8620 
 8621 // Xor Register with Immediate
 8622 instruct xorI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8623   match(Set dst (XorI dst src));
 8624   effect(KILL cr);
 8625 
 8626   format %{ &quot;XOR    $dst,$src&quot; %}
 8627   opcode(0x81,0x06);  /* Opcode 81 /6 id */
 8628   // ins_encode( RegImm( dst, src) );
 8629   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8630   ins_pipe( ialu_reg );
 8631 %}
 8632 
 8633 // Xor Register with Memory
 8634 instruct xorI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8635   match(Set dst (XorI dst (LoadI src)));
 8636   effect(KILL cr);
 8637 
 8638   ins_cost(125);
 8639   format %{ &quot;XOR    $dst,$src&quot; %}
 8640   opcode(0x33);
 8641   ins_encode( OpcP, RegMem(dst, src) );
 8642   ins_pipe( ialu_reg_mem );
 8643 %}
 8644 
 8645 // Xor Memory with Register
 8646 instruct xorI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8647   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8648   effect(KILL cr);
 8649 
 8650   ins_cost(150);
 8651   format %{ &quot;XOR    $dst,$src&quot; %}
 8652   opcode(0x31);  /* Opcode 31 /r */
 8653   ins_encode( OpcP, RegMem( src, dst ) );
 8654   ins_pipe( ialu_mem_reg );
 8655 %}
 8656 
 8657 // Xor Memory with Immediate
 8658 instruct xorI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8659   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8660   effect(KILL cr);
 8661 
 8662   ins_cost(125);
 8663   format %{ &quot;XOR    $dst,$src&quot; %}
 8664   opcode(0x81,0x6);  /* Opcode 81 /6 id */
 8665   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8666   ins_pipe( ialu_mem_imm );
 8667 %}
 8668 
 8669 //----------Convert Int to Boolean---------------------------------------------
 8670 
 8671 instruct movI_nocopy(rRegI dst, rRegI src) %{
 8672   effect( DEF dst, USE src );
 8673   format %{ &quot;MOV    $dst,$src&quot; %}
 8674   ins_encode( enc_Copy( dst, src) );
 8675   ins_pipe( ialu_reg_reg );
 8676 %}
 8677 
 8678 instruct ci2b( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8679   effect( USE_DEF dst, USE src, KILL cr );
 8680 
 8681   size(4);
 8682   format %{ &quot;NEG    $dst\n\t&quot;
 8683             &quot;ADC    $dst,$src&quot; %}
 8684   ins_encode( neg_reg(dst),
 8685               OpcRegReg(0x13,dst,src) );
 8686   ins_pipe( ialu_reg_reg_long );
 8687 %}
 8688 
 8689 instruct convI2B( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8690   match(Set dst (Conv2B src));
 8691 
 8692   expand %{
 8693     movI_nocopy(dst,src);
 8694     ci2b(dst,src,cr);
 8695   %}
 8696 %}
 8697 
 8698 instruct movP_nocopy(rRegI dst, eRegP src) %{
 8699   effect( DEF dst, USE src );
 8700   format %{ &quot;MOV    $dst,$src&quot; %}
 8701   ins_encode( enc_Copy( dst, src) );
 8702   ins_pipe( ialu_reg_reg );
 8703 %}
 8704 
 8705 instruct cp2b( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8706   effect( USE_DEF dst, USE src, KILL cr );
 8707   format %{ &quot;NEG    $dst\n\t&quot;
 8708             &quot;ADC    $dst,$src&quot; %}
 8709   ins_encode( neg_reg(dst),
 8710               OpcRegReg(0x13,dst,src) );
 8711   ins_pipe( ialu_reg_reg_long );
 8712 %}
 8713 
 8714 instruct convP2B( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8715   match(Set dst (Conv2B src));
 8716 
 8717   expand %{
 8718     movP_nocopy(dst,src);
 8719     cp2b(dst,src,cr);
 8720   %}
 8721 %}
 8722 
 8723 instruct cmpLTMask(eCXRegI dst, ncxRegI p, ncxRegI q, eFlagsReg cr) %{
 8724   match(Set dst (CmpLTMask p q));
 8725   effect(KILL cr);
 8726   ins_cost(400);
 8727 
 8728   // SETlt can only use low byte of EAX,EBX, ECX, or EDX as destination
 8729   format %{ &quot;XOR    $dst,$dst\n\t&quot;
 8730             &quot;CMP    $p,$q\n\t&quot;
 8731             &quot;SETlt  $dst\n\t&quot;
 8732             &quot;NEG    $dst&quot; %}
 8733   ins_encode %{
 8734     Register Rp = $p$$Register;
 8735     Register Rq = $q$$Register;
 8736     Register Rd = $dst$$Register;
 8737     Label done;
 8738     __ xorl(Rd, Rd);
 8739     __ cmpl(Rp, Rq);
 8740     __ setb(Assembler::less, Rd);
 8741     __ negl(Rd);
 8742   %}
 8743 
 8744   ins_pipe(pipe_slow);
 8745 %}
 8746 
 8747 instruct cmpLTMask0(rRegI dst, immI0 zero, eFlagsReg cr) %{
 8748   match(Set dst (CmpLTMask dst zero));
 8749   effect(DEF dst, KILL cr);
 8750   ins_cost(100);
 8751 
 8752   format %{ &quot;SAR    $dst,31\t# cmpLTMask0&quot; %}
 8753   ins_encode %{
 8754   __ sarl($dst$$Register, 31);
 8755   %}
 8756   ins_pipe(ialu_reg);
 8757 %}
 8758 
 8759 /* better to save a register than avoid a branch */
 8760 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8761   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 8762   effect(KILL cr);
 8763   ins_cost(400);
 8764   format %{ &quot;SUB    $p,$q\t# cadd_cmpLTMask\n\t&quot;
 8765             &quot;JGE    done\n\t&quot;
 8766             &quot;ADD    $p,$y\n&quot;
 8767             &quot;done:  &quot; %}
 8768   ins_encode %{
 8769     Register Rp = $p$$Register;
 8770     Register Rq = $q$$Register;
 8771     Register Ry = $y$$Register;
 8772     Label done;
 8773     __ subl(Rp, Rq);
 8774     __ jccb(Assembler::greaterEqual, done);
 8775     __ addl(Rp, Ry);
 8776     __ bind(done);
 8777   %}
 8778 
 8779   ins_pipe(pipe_cmplt);
 8780 %}
 8781 
 8782 /* better to save a register than avoid a branch */
 8783 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8784   match(Set y (AndI (CmpLTMask p q) y));
 8785   effect(KILL cr);
 8786 
 8787   ins_cost(300);
 8788 
 8789   format %{ &quot;CMPL     $p, $q\t# and_cmpLTMask\n\t&quot;
 8790             &quot;JLT      done\n\t&quot;
 8791             &quot;XORL     $y, $y\n&quot;
 8792             &quot;done:  &quot; %}
 8793   ins_encode %{
 8794     Register Rp = $p$$Register;
 8795     Register Rq = $q$$Register;
 8796     Register Ry = $y$$Register;
 8797     Label done;
 8798     __ cmpl(Rp, Rq);
 8799     __ jccb(Assembler::less, done);
 8800     __ xorl(Ry, Ry);
 8801     __ bind(done);
 8802   %}
 8803 
 8804   ins_pipe(pipe_cmplt);
 8805 %}
 8806 
 8807 /* If I enable this, I encourage spilling in the inner loop of compress.
 8808 instruct cadd_cmpLTMask_mem(ncxRegI p, ncxRegI q, memory y, eCXRegI tmp, eFlagsReg cr) %{
 8809   match(Set p (AddI (AndI (CmpLTMask p q) (LoadI y)) (SubI p q)));
 8810 */
 8811 //----------Overflow Math Instructions-----------------------------------------
 8812 
 8813 instruct overflowAddI_eReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8814 %{
 8815   match(Set cr (OverflowAddI op1 op2));
 8816   effect(DEF cr, USE_KILL op1, USE op2);
 8817 
 8818   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8819 
 8820   ins_encode %{
 8821     __ addl($op1$$Register, $op2$$Register);
 8822   %}
 8823   ins_pipe(ialu_reg_reg);
 8824 %}
 8825 
 8826 instruct overflowAddI_rReg_imm(eFlagsReg cr, eAXRegI op1, immI op2)
 8827 %{
 8828   match(Set cr (OverflowAddI op1 op2));
 8829   effect(DEF cr, USE_KILL op1, USE op2);
 8830 
 8831   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8832 
 8833   ins_encode %{
 8834     __ addl($op1$$Register, $op2$$constant);
 8835   %}
 8836   ins_pipe(ialu_reg_reg);
 8837 %}
 8838 
 8839 instruct overflowSubI_rReg(eFlagsReg cr, rRegI op1, rRegI op2)
 8840 %{
 8841   match(Set cr (OverflowSubI op1 op2));
 8842 
 8843   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8844   ins_encode %{
 8845     __ cmpl($op1$$Register, $op2$$Register);
 8846   %}
 8847   ins_pipe(ialu_reg_reg);
 8848 %}
 8849 
 8850 instruct overflowSubI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2)
 8851 %{
 8852   match(Set cr (OverflowSubI op1 op2));
 8853 
 8854   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8855   ins_encode %{
 8856     __ cmpl($op1$$Register, $op2$$constant);
 8857   %}
 8858   ins_pipe(ialu_reg_reg);
 8859 %}
 8860 
 8861 instruct overflowNegI_rReg(eFlagsReg cr, immI0 zero, eAXRegI op2)
 8862 %{
 8863   match(Set cr (OverflowSubI zero op2));
 8864   effect(DEF cr, USE_KILL op2);
 8865 
 8866   format %{ &quot;NEG    $op2\t# overflow check int&quot; %}
 8867   ins_encode %{
 8868     __ negl($op2$$Register);
 8869   %}
 8870   ins_pipe(ialu_reg_reg);
 8871 %}
 8872 
 8873 instruct overflowMulI_rReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8874 %{
 8875   match(Set cr (OverflowMulI op1 op2));
 8876   effect(DEF cr, USE_KILL op1, USE op2);
 8877 
 8878   format %{ &quot;IMUL    $op1, $op2\t# overflow check int&quot; %}
 8879   ins_encode %{
 8880     __ imull($op1$$Register, $op2$$Register);
 8881   %}
 8882   ins_pipe(ialu_reg_reg_alu0);
 8883 %}
 8884 
 8885 instruct overflowMulI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
 8886 %{
 8887   match(Set cr (OverflowMulI op1 op2));
 8888   effect(DEF cr, TEMP tmp, USE op1, USE op2);
 8889 
 8890   format %{ &quot;IMUL    $tmp, $op1, $op2\t# overflow check int&quot; %}
 8891   ins_encode %{
 8892     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
 8893   %}
 8894   ins_pipe(ialu_reg_reg_alu0);
 8895 %}
 8896 
 8897 // Integer Absolute Instructions
 8898 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, eFlagsReg cr)
 8899 %{
 8900   match(Set dst (AbsI src));
 8901   effect(TEMP dst, TEMP tmp, KILL cr);
 8902   format %{ &quot;movl $tmp, $src\n\t&quot;
 8903             &quot;sarl $tmp, 31\n\t&quot;
 8904             &quot;movl $dst, $src\n\t&quot;
 8905             &quot;xorl $dst, $tmp\n\t&quot;
 8906             &quot;subl $dst, $tmp\n&quot;
 8907           %}
 8908   ins_encode %{
 8909     __ movl($tmp$$Register, $src$$Register);
 8910     __ sarl($tmp$$Register, 31);
 8911     __ movl($dst$$Register, $src$$Register);
 8912     __ xorl($dst$$Register, $tmp$$Register);
 8913     __ subl($dst$$Register, $tmp$$Register);
 8914   %}
 8915 
 8916   ins_pipe(ialu_reg_reg);
 8917 %}
 8918 
 8919 //----------Long Instructions------------------------------------------------
 8920 // Add Long Register with Register
 8921 instruct addL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8922   match(Set dst (AddL dst src));
 8923   effect(KILL cr);
 8924   ins_cost(200);
 8925   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8926             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8927   opcode(0x03, 0x13);
 8928   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8929   ins_pipe( ialu_reg_reg_long );
 8930 %}
 8931 
 8932 // Add Long Register with Immediate
 8933 instruct addL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8934   match(Set dst (AddL dst src));
 8935   effect(KILL cr);
 8936   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8937             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8938   opcode(0x81,0x00,0x02);  /* Opcode 81 /0, 81 /2 */
 8939   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8940   ins_pipe( ialu_reg_long );
 8941 %}
 8942 
 8943 // Add Long Register with Memory
 8944 instruct addL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8945   match(Set dst (AddL dst (LoadL mem)));
 8946   effect(KILL cr);
 8947   ins_cost(125);
 8948   format %{ &quot;ADD    $dst.lo,$mem\n\t&quot;
 8949             &quot;ADC    $dst.hi,$mem+4&quot; %}
 8950   opcode(0x03, 0x13);
 8951   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8952   ins_pipe( ialu_reg_long_mem );
 8953 %}
 8954 
 8955 // Subtract Long Register with Register.
 8956 instruct subL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8957   match(Set dst (SubL dst src));
 8958   effect(KILL cr);
 8959   ins_cost(200);
 8960   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8961             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8962   opcode(0x2B, 0x1B);
 8963   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8964   ins_pipe( ialu_reg_reg_long );
 8965 %}
 8966 
 8967 // Subtract Long Register with Immediate
 8968 instruct subL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8969   match(Set dst (SubL dst src));
 8970   effect(KILL cr);
 8971   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8972             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8973   opcode(0x81,0x05,0x03);  /* Opcode 81 /5, 81 /3 */
 8974   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8975   ins_pipe( ialu_reg_long );
 8976 %}
 8977 
 8978 // Subtract Long Register with Memory
 8979 instruct subL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8980   match(Set dst (SubL dst (LoadL mem)));
 8981   effect(KILL cr);
 8982   ins_cost(125);
 8983   format %{ &quot;SUB    $dst.lo,$mem\n\t&quot;
 8984             &quot;SBB    $dst.hi,$mem+4&quot; %}
 8985   opcode(0x2B, 0x1B);
 8986   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8987   ins_pipe( ialu_reg_long_mem );
 8988 %}
 8989 
 8990 instruct negL_eReg(eRegL dst, immL0 zero, eFlagsReg cr) %{
 8991   match(Set dst (SubL zero dst));
 8992   effect(KILL cr);
 8993   ins_cost(300);
 8994   format %{ &quot;NEG    $dst.hi\n\tNEG    $dst.lo\n\tSBB    $dst.hi,0&quot; %}
 8995   ins_encode( neg_long(dst) );
 8996   ins_pipe( ialu_reg_reg_long );
 8997 %}
 8998 
 8999 // And Long Register with Register
 9000 instruct andL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9001   match(Set dst (AndL dst src));
 9002   effect(KILL cr);
 9003   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 9004             &quot;AND    $dst.hi,$src.hi&quot; %}
 9005   opcode(0x23,0x23);
 9006   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9007   ins_pipe( ialu_reg_reg_long );
 9008 %}
 9009 
 9010 // And Long Register with Immediate
 9011 instruct andL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9012   match(Set dst (AndL dst src));
 9013   effect(KILL cr);
 9014   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 9015             &quot;AND    $dst.hi,$src.hi&quot; %}
 9016   opcode(0x81,0x04,0x04);  /* Opcode 81 /4, 81 /4 */
 9017   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9018   ins_pipe( ialu_reg_long );
 9019 %}
 9020 
 9021 // And Long Register with Memory
 9022 instruct andL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9023   match(Set dst (AndL dst (LoadL mem)));
 9024   effect(KILL cr);
 9025   ins_cost(125);
 9026   format %{ &quot;AND    $dst.lo,$mem\n\t&quot;
 9027             &quot;AND    $dst.hi,$mem+4&quot; %}
 9028   opcode(0x23, 0x23);
 9029   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9030   ins_pipe( ialu_reg_long_mem );
 9031 %}
 9032 
 9033 // BMI1 instructions
 9034 instruct andnL_eReg_eReg_eReg(eRegL dst, eRegL src1, eRegL src2, immL_M1 minus_1, eFlagsReg cr) %{
 9035   match(Set dst (AndL (XorL src1 minus_1) src2));
 9036   predicate(UseBMI1Instructions);
 9037   effect(KILL cr, TEMP dst);
 9038 
 9039   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2.lo\n\t&quot;
 9040             &quot;ANDNL  $dst.hi, $src1.hi, $src2.hi&quot;
 9041          %}
 9042 
 9043   ins_encode %{
 9044     Register Rdst = $dst$$Register;
 9045     Register Rsrc1 = $src1$$Register;
 9046     Register Rsrc2 = $src2$$Register;
 9047     __ andnl(Rdst, Rsrc1, Rsrc2);
 9048     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), HIGH_FROM_LOW(Rsrc2));
 9049   %}
 9050   ins_pipe(ialu_reg_reg_long);
 9051 %}
 9052 
 9053 instruct andnL_eReg_eReg_mem(eRegL dst, eRegL src1, memory src2, immL_M1 minus_1, eFlagsReg cr) %{
 9054   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2) ));
 9055   predicate(UseBMI1Instructions);
 9056   effect(KILL cr, TEMP dst);
 9057 
 9058   ins_cost(125);
 9059   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2\n\t&quot;
 9060             &quot;ANDNL  $dst.hi, $src1.hi, $src2+4&quot;
 9061          %}
 9062 
 9063   ins_encode %{
 9064     Register Rdst = $dst$$Register;
 9065     Register Rsrc1 = $src1$$Register;
 9066     Address src2_hi = Address::make_raw($src2$$base, $src2$$index, $src2$$scale, $src2$$disp + 4, relocInfo::none);
 9067 
 9068     __ andnl(Rdst, Rsrc1, $src2$$Address);
 9069     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), src2_hi);
 9070   %}
 9071   ins_pipe(ialu_reg_mem);
 9072 %}
 9073 
 9074 instruct blsiL_eReg_eReg(eRegL dst, eRegL src, immL0 imm_zero, eFlagsReg cr) %{
 9075   match(Set dst (AndL (SubL imm_zero src) src));
 9076   predicate(UseBMI1Instructions);
 9077   effect(KILL cr, TEMP dst);
 9078 
 9079   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9080             &quot;BLSIL  $dst.lo, $src.lo\n\t&quot;
 9081             &quot;JNZ    done\n\t&quot;
 9082             &quot;BLSIL  $dst.hi, $src.hi\n&quot;
 9083             &quot;done:&quot;
 9084          %}
 9085 
 9086   ins_encode %{
 9087     Label done;
 9088     Register Rdst = $dst$$Register;
 9089     Register Rsrc = $src$$Register;
 9090     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9091     __ blsil(Rdst, Rsrc);
 9092     __ jccb(Assembler::notZero, done);
 9093     __ blsil(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9094     __ bind(done);
 9095   %}
 9096   ins_pipe(ialu_reg);
 9097 %}
 9098 
 9099 instruct blsiL_eReg_mem(eRegL dst, memory src, immL0 imm_zero, eFlagsReg cr) %{
 9100   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9101   predicate(UseBMI1Instructions);
 9102   effect(KILL cr, TEMP dst);
 9103 
 9104   ins_cost(125);
 9105   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9106             &quot;BLSIL  $dst.lo, $src\n\t&quot;
 9107             &quot;JNZ    done\n\t&quot;
 9108             &quot;BLSIL  $dst.hi, $src+4\n&quot;
 9109             &quot;done:&quot;
 9110          %}
 9111 
 9112   ins_encode %{
 9113     Label done;
 9114     Register Rdst = $dst$$Register;
 9115     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9116 
 9117     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9118     __ blsil(Rdst, $src$$Address);
 9119     __ jccb(Assembler::notZero, done);
 9120     __ blsil(HIGH_FROM_LOW(Rdst), src_hi);
 9121     __ bind(done);
 9122   %}
 9123   ins_pipe(ialu_reg_mem);
 9124 %}
 9125 
 9126 instruct blsmskL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9127 %{
 9128   match(Set dst (XorL (AddL src minus_1) src));
 9129   predicate(UseBMI1Instructions);
 9130   effect(KILL cr, TEMP dst);
 9131 
 9132   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9133             &quot;BLSMSKL $dst.lo, $src.lo\n\t&quot;
 9134             &quot;JNC     done\n\t&quot;
 9135             &quot;BLSMSKL $dst.hi, $src.hi\n&quot;
 9136             &quot;done:&quot;
 9137          %}
 9138 
 9139   ins_encode %{
 9140     Label done;
 9141     Register Rdst = $dst$$Register;
 9142     Register Rsrc = $src$$Register;
 9143     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9144     __ blsmskl(Rdst, Rsrc);
 9145     __ jccb(Assembler::carryClear, done);
 9146     __ blsmskl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9147     __ bind(done);
 9148   %}
 9149 
 9150   ins_pipe(ialu_reg);
 9151 %}
 9152 
 9153 instruct blsmskL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9154 %{
 9155   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ));
 9156   predicate(UseBMI1Instructions);
 9157   effect(KILL cr, TEMP dst);
 9158 
 9159   ins_cost(125);
 9160   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9161             &quot;BLSMSKL $dst.lo, $src\n\t&quot;
 9162             &quot;JNC     done\n\t&quot;
 9163             &quot;BLSMSKL $dst.hi, $src+4\n&quot;
 9164             &quot;done:&quot;
 9165          %}
 9166 
 9167   ins_encode %{
 9168     Label done;
 9169     Register Rdst = $dst$$Register;
 9170     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9171 
 9172     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9173     __ blsmskl(Rdst, $src$$Address);
 9174     __ jccb(Assembler::carryClear, done);
 9175     __ blsmskl(HIGH_FROM_LOW(Rdst), src_hi);
 9176     __ bind(done);
 9177   %}
 9178 
 9179   ins_pipe(ialu_reg_mem);
 9180 %}
 9181 
 9182 instruct blsrL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9183 %{
 9184   match(Set dst (AndL (AddL src minus_1) src) );
 9185   predicate(UseBMI1Instructions);
 9186   effect(KILL cr, TEMP dst);
 9187 
 9188   format %{ &quot;MOVL   $dst.hi, $src.hi\n\t&quot;
 9189             &quot;BLSRL  $dst.lo, $src.lo\n\t&quot;
 9190             &quot;JNC    done\n\t&quot;
 9191             &quot;BLSRL  $dst.hi, $src.hi\n&quot;
 9192             &quot;done:&quot;
 9193   %}
 9194 
 9195   ins_encode %{
 9196     Label done;
 9197     Register Rdst = $dst$$Register;
 9198     Register Rsrc = $src$$Register;
 9199     __ movl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9200     __ blsrl(Rdst, Rsrc);
 9201     __ jccb(Assembler::carryClear, done);
 9202     __ blsrl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9203     __ bind(done);
 9204   %}
 9205 
 9206   ins_pipe(ialu_reg);
 9207 %}
 9208 
 9209 instruct blsrL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9210 %{
 9211   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src) ));
 9212   predicate(UseBMI1Instructions);
 9213   effect(KILL cr, TEMP dst);
 9214 
 9215   ins_cost(125);
 9216   format %{ &quot;MOVL   $dst.hi, $src+4\n\t&quot;
 9217             &quot;BLSRL  $dst.lo, $src\n\t&quot;
 9218             &quot;JNC    done\n\t&quot;
 9219             &quot;BLSRL  $dst.hi, $src+4\n&quot;
 9220             &quot;done:&quot;
 9221   %}
 9222 
 9223   ins_encode %{
 9224     Label done;
 9225     Register Rdst = $dst$$Register;
 9226     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9227     __ movl(HIGH_FROM_LOW(Rdst), src_hi);
 9228     __ blsrl(Rdst, $src$$Address);
 9229     __ jccb(Assembler::carryClear, done);
 9230     __ blsrl(HIGH_FROM_LOW(Rdst), src_hi);
 9231     __ bind(done);
 9232   %}
 9233 
 9234   ins_pipe(ialu_reg_mem);
 9235 %}
 9236 
 9237 // Or Long Register with Register
 9238 instruct orl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9239   match(Set dst (OrL dst src));
 9240   effect(KILL cr);
 9241   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9242             &quot;OR     $dst.hi,$src.hi&quot; %}
 9243   opcode(0x0B,0x0B);
 9244   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9245   ins_pipe( ialu_reg_reg_long );
 9246 %}
 9247 
 9248 // Or Long Register with Immediate
 9249 instruct orl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9250   match(Set dst (OrL dst src));
 9251   effect(KILL cr);
 9252   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9253             &quot;OR     $dst.hi,$src.hi&quot; %}
 9254   opcode(0x81,0x01,0x01);  /* Opcode 81 /1, 81 /1 */
 9255   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9256   ins_pipe( ialu_reg_long );
 9257 %}
 9258 
 9259 // Or Long Register with Memory
 9260 instruct orl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9261   match(Set dst (OrL dst (LoadL mem)));
 9262   effect(KILL cr);
 9263   ins_cost(125);
 9264   format %{ &quot;OR     $dst.lo,$mem\n\t&quot;
 9265             &quot;OR     $dst.hi,$mem+4&quot; %}
 9266   opcode(0x0B,0x0B);
 9267   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9268   ins_pipe( ialu_reg_long_mem );
 9269 %}
 9270 
 9271 // Xor Long Register with Register
 9272 instruct xorl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9273   match(Set dst (XorL dst src));
 9274   effect(KILL cr);
 9275   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9276             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9277   opcode(0x33,0x33);
 9278   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9279   ins_pipe( ialu_reg_reg_long );
 9280 %}
 9281 
 9282 // Xor Long Register with Immediate -1
 9283 instruct xorl_eReg_im1(eRegL dst, immL_M1 imm) %{
 9284   match(Set dst (XorL dst imm));
 9285   format %{ &quot;NOT    $dst.lo\n\t&quot;
 9286             &quot;NOT    $dst.hi&quot; %}
 9287   ins_encode %{
 9288      __ notl($dst$$Register);
 9289      __ notl(HIGH_FROM_LOW($dst$$Register));
 9290   %}
 9291   ins_pipe( ialu_reg_long );
 9292 %}
 9293 
 9294 // Xor Long Register with Immediate
 9295 instruct xorl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9296   match(Set dst (XorL dst src));
 9297   effect(KILL cr);
 9298   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9299             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9300   opcode(0x81,0x06,0x06);  /* Opcode 81 /6, 81 /6 */
 9301   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9302   ins_pipe( ialu_reg_long );
 9303 %}
 9304 
 9305 // Xor Long Register with Memory
 9306 instruct xorl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9307   match(Set dst (XorL dst (LoadL mem)));
 9308   effect(KILL cr);
 9309   ins_cost(125);
 9310   format %{ &quot;XOR    $dst.lo,$mem\n\t&quot;
 9311             &quot;XOR    $dst.hi,$mem+4&quot; %}
 9312   opcode(0x33,0x33);
 9313   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9314   ins_pipe( ialu_reg_long_mem );
 9315 %}
 9316 
 9317 // Shift Left Long by 1
 9318 instruct shlL_eReg_1(eRegL dst, immI_1 cnt, eFlagsReg cr) %{
 9319   predicate(UseNewLongLShift);
 9320   match(Set dst (LShiftL dst cnt));
 9321   effect(KILL cr);
 9322   ins_cost(100);
 9323   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9324             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9325   ins_encode %{
 9326     __ addl($dst$$Register,$dst$$Register);
 9327     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9328   %}
 9329   ins_pipe( ialu_reg_long );
 9330 %}
 9331 
 9332 // Shift Left Long by 2
 9333 instruct shlL_eReg_2(eRegL dst, immI_2 cnt, eFlagsReg cr) %{
 9334   predicate(UseNewLongLShift);
 9335   match(Set dst (LShiftL dst cnt));
 9336   effect(KILL cr);
 9337   ins_cost(100);
 9338   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9339             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9340             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9341             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9342   ins_encode %{
 9343     __ addl($dst$$Register,$dst$$Register);
 9344     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9345     __ addl($dst$$Register,$dst$$Register);
 9346     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9347   %}
 9348   ins_pipe( ialu_reg_long );
 9349 %}
 9350 
 9351 // Shift Left Long by 3
 9352 instruct shlL_eReg_3(eRegL dst, immI_3 cnt, eFlagsReg cr) %{
 9353   predicate(UseNewLongLShift);
 9354   match(Set dst (LShiftL dst cnt));
 9355   effect(KILL cr);
 9356   ins_cost(100);
 9357   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9358             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9359             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9360             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9361             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9362             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9363   ins_encode %{
 9364     __ addl($dst$$Register,$dst$$Register);
 9365     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9366     __ addl($dst$$Register,$dst$$Register);
 9367     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9368     __ addl($dst$$Register,$dst$$Register);
 9369     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9370   %}
 9371   ins_pipe( ialu_reg_long );
 9372 %}
 9373 
 9374 // Shift Left Long by 1-31
 9375 instruct shlL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9376   match(Set dst (LShiftL dst cnt));
 9377   effect(KILL cr);
 9378   ins_cost(200);
 9379   format %{ &quot;SHLD   $dst.hi,$dst.lo,$cnt\n\t&quot;
 9380             &quot;SHL    $dst.lo,$cnt&quot; %}
 9381   opcode(0xC1, 0x4, 0xA4);  /* 0F/A4, then C1 /4 ib */
 9382   ins_encode( move_long_small_shift(dst,cnt) );
 9383   ins_pipe( ialu_reg_long );
 9384 %}
 9385 
 9386 // Shift Left Long by 32-63
 9387 instruct shlL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9388   match(Set dst (LShiftL dst cnt));
 9389   effect(KILL cr);
 9390   ins_cost(300);
 9391   format %{ &quot;MOV    $dst.hi,$dst.lo\n&quot;
 9392           &quot;\tSHL    $dst.hi,$cnt-32\n&quot;
 9393           &quot;\tXOR    $dst.lo,$dst.lo&quot; %}
 9394   opcode(0xC1, 0x4);  /* C1 /4 ib */
 9395   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9396   ins_pipe( ialu_reg_long );
 9397 %}
 9398 
 9399 // Shift Left Long by variable
 9400 instruct salL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9401   match(Set dst (LShiftL dst shift));
 9402   effect(KILL cr);
 9403   ins_cost(500+200);
 9404   size(17);
 9405   format %{ &quot;TEST   $shift,32\n\t&quot;
 9406             &quot;JEQ,s  small\n\t&quot;
 9407             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 9408             &quot;XOR    $dst.lo,$dst.lo\n&quot;
 9409     &quot;small:\tSHLD   $dst.hi,$dst.lo,$shift\n\t&quot;
 9410             &quot;SHL    $dst.lo,$shift&quot; %}
 9411   ins_encode( shift_left_long( dst, shift ) );
 9412   ins_pipe( pipe_slow );
 9413 %}
 9414 
 9415 // Shift Right Long by 1-31
 9416 instruct shrL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9417   match(Set dst (URShiftL dst cnt));
 9418   effect(KILL cr);
 9419   ins_cost(200);
 9420   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9421             &quot;SHR    $dst.hi,$cnt&quot; %}
 9422   opcode(0xC1, 0x5, 0xAC);  /* 0F/AC, then C1 /5 ib */
 9423   ins_encode( move_long_small_shift(dst,cnt) );
 9424   ins_pipe( ialu_reg_long );
 9425 %}
 9426 
 9427 // Shift Right Long by 32-63
 9428 instruct shrL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9429   match(Set dst (URShiftL dst cnt));
 9430   effect(KILL cr);
 9431   ins_cost(300);
 9432   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9433           &quot;\tSHR    $dst.lo,$cnt-32\n&quot;
 9434           &quot;\tXOR    $dst.hi,$dst.hi&quot; %}
 9435   opcode(0xC1, 0x5);  /* C1 /5 ib */
 9436   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9437   ins_pipe( ialu_reg_long );
 9438 %}
 9439 
 9440 // Shift Right Long by variable
 9441 instruct shrL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9442   match(Set dst (URShiftL dst shift));
 9443   effect(KILL cr);
 9444   ins_cost(600);
 9445   size(17);
 9446   format %{ &quot;TEST   $shift,32\n\t&quot;
 9447             &quot;JEQ,s  small\n\t&quot;
 9448             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9449             &quot;XOR    $dst.hi,$dst.hi\n&quot;
 9450     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9451             &quot;SHR    $dst.hi,$shift&quot; %}
 9452   ins_encode( shift_right_long( dst, shift ) );
 9453   ins_pipe( pipe_slow );
 9454 %}
 9455 
 9456 // Shift Right Long by 1-31
 9457 instruct sarL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9458   match(Set dst (RShiftL dst cnt));
 9459   effect(KILL cr);
 9460   ins_cost(200);
 9461   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9462             &quot;SAR    $dst.hi,$cnt&quot; %}
 9463   opcode(0xC1, 0x7, 0xAC);  /* 0F/AC, then C1 /7 ib */
 9464   ins_encode( move_long_small_shift(dst,cnt) );
 9465   ins_pipe( ialu_reg_long );
 9466 %}
 9467 
 9468 // Shift Right Long by 32-63
 9469 instruct sarL_eReg_32_63( eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9470   match(Set dst (RShiftL dst cnt));
 9471   effect(KILL cr);
 9472   ins_cost(300);
 9473   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9474           &quot;\tSAR    $dst.lo,$cnt-32\n&quot;
 9475           &quot;\tSAR    $dst.hi,31&quot; %}
 9476   opcode(0xC1, 0x7);  /* C1 /7 ib */
 9477   ins_encode( move_long_big_shift_sign(dst,cnt) );
 9478   ins_pipe( ialu_reg_long );
 9479 %}
 9480 
 9481 // Shift Right arithmetic Long by variable
 9482 instruct sarL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9483   match(Set dst (RShiftL dst shift));
 9484   effect(KILL cr);
 9485   ins_cost(600);
 9486   size(18);
 9487   format %{ &quot;TEST   $shift,32\n\t&quot;
 9488             &quot;JEQ,s  small\n\t&quot;
 9489             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9490             &quot;SAR    $dst.hi,31\n&quot;
 9491     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9492             &quot;SAR    $dst.hi,$shift&quot; %}
 9493   ins_encode( shift_right_arith_long( dst, shift ) );
 9494   ins_pipe( pipe_slow );
 9495 %}
 9496 
 9497 
 9498 //----------Double Instructions------------------------------------------------
 9499 // Double Math
 9500 
 9501 // Compare &amp; branch
 9502 
 9503 // P6 version of float compare, sets condition codes in EFLAGS
 9504 instruct cmpDPR_cc_P6(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9505   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9506   match(Set cr (CmpD src1 src2));
 9507   effect(KILL rax);
 9508   ins_cost(150);
 9509   format %{ &quot;FLD    $src1\n\t&quot;
 9510             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
 9511             &quot;JNP    exit\n\t&quot;
 9512             &quot;MOV    ah,1       // saw a NaN, set CF\n\t&quot;
 9513             &quot;SAHF\n&quot;
 9514      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
 9515   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9516   ins_encode( Push_Reg_DPR(src1),
 9517               OpcP, RegOpc(src2),
 9518               cmpF_P6_fixup );
 9519   ins_pipe( pipe_slow );
 9520 %}
 9521 
 9522 instruct cmpDPR_cc_P6CF(eFlagsRegUCF cr, regDPR src1, regDPR src2) %{
 9523   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9524   match(Set cr (CmpD src1 src2));
 9525   ins_cost(150);
 9526   format %{ &quot;FLD    $src1\n\t&quot;
 9527             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
 9528   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9529   ins_encode( Push_Reg_DPR(src1),
 9530               OpcP, RegOpc(src2));
 9531   ins_pipe( pipe_slow );
 9532 %}
 9533 
 9534 // Compare &amp; branch
 9535 instruct cmpDPR_cc(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9536   predicate(UseSSE&lt;=1);
 9537   match(Set cr (CmpD src1 src2));
 9538   effect(KILL rax);
 9539   ins_cost(200);
 9540   format %{ &quot;FLD    $src1\n\t&quot;
 9541             &quot;FCOMp  $src2\n\t&quot;
 9542             &quot;FNSTSW AX\n\t&quot;
 9543             &quot;TEST   AX,0x400\n\t&quot;
 9544             &quot;JZ,s   flags\n\t&quot;
 9545             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
 9546     &quot;flags:\tSAHF&quot; %}
 9547   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9548   ins_encode( Push_Reg_DPR(src1),
 9549               OpcP, RegOpc(src2),
 9550               fpu_flags);
 9551   ins_pipe( pipe_slow );
 9552 %}
 9553 
 9554 // Compare vs zero into -1,0,1
 9555 instruct cmpDPR_0(rRegI dst, regDPR src1, immDPR0 zero, eAXRegI rax, eFlagsReg cr) %{
 9556   predicate(UseSSE&lt;=1);
 9557   match(Set dst (CmpD3 src1 zero));
 9558   effect(KILL cr, KILL rax);
 9559   ins_cost(280);
 9560   format %{ &quot;FTSTD  $dst,$src1&quot; %}
 9561   opcode(0xE4, 0xD9);
 9562   ins_encode( Push_Reg_DPR(src1),
 9563               OpcS, OpcP, PopFPU,
 9564               CmpF_Result(dst));
 9565   ins_pipe( pipe_slow );
 9566 %}
 9567 
 9568 // Compare into -1,0,1
 9569 instruct cmpDPR_reg(rRegI dst, regDPR src1, regDPR src2, eAXRegI rax, eFlagsReg cr) %{
 9570   predicate(UseSSE&lt;=1);
 9571   match(Set dst (CmpD3 src1 src2));
 9572   effect(KILL cr, KILL rax);
 9573   ins_cost(300);
 9574   format %{ &quot;FCMPD  $dst,$src1,$src2&quot; %}
 9575   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9576   ins_encode( Push_Reg_DPR(src1),
 9577               OpcP, RegOpc(src2),
 9578               CmpF_Result(dst));
 9579   ins_pipe( pipe_slow );
 9580 %}
 9581 
 9582 // float compare and set condition codes in EFLAGS by XMM regs
 9583 instruct cmpD_cc(eFlagsRegU cr, regD src1, regD src2) %{
 9584   predicate(UseSSE&gt;=2);
 9585   match(Set cr (CmpD src1 src2));
 9586   ins_cost(145);
 9587   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9588             &quot;JNP,s   exit\n\t&quot;
 9589             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9590             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9591             &quot;POPF\n&quot;
 9592     &quot;exit:&quot; %}
 9593   ins_encode %{
 9594     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9595     emit_cmpfp_fixup(_masm);
 9596   %}
 9597   ins_pipe( pipe_slow );
 9598 %}
 9599 
 9600 instruct cmpD_ccCF(eFlagsRegUCF cr, regD src1, regD src2) %{
 9601   predicate(UseSSE&gt;=2);
 9602   match(Set cr (CmpD src1 src2));
 9603   ins_cost(100);
 9604   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9605   ins_encode %{
 9606     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9607   %}
 9608   ins_pipe( pipe_slow );
 9609 %}
 9610 
 9611 // float compare and set condition codes in EFLAGS by XMM regs
 9612 instruct cmpD_ccmem(eFlagsRegU cr, regD src1, memory src2) %{
 9613   predicate(UseSSE&gt;=2);
 9614   match(Set cr (CmpD src1 (LoadD src2)));
 9615   ins_cost(145);
 9616   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9617             &quot;JNP,s   exit\n\t&quot;
 9618             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9619             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9620             &quot;POPF\n&quot;
 9621     &quot;exit:&quot; %}
 9622   ins_encode %{
 9623     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9624     emit_cmpfp_fixup(_masm);
 9625   %}
 9626   ins_pipe( pipe_slow );
 9627 %}
 9628 
 9629 instruct cmpD_ccmemCF(eFlagsRegUCF cr, regD src1, memory src2) %{
 9630   predicate(UseSSE&gt;=2);
 9631   match(Set cr (CmpD src1 (LoadD src2)));
 9632   ins_cost(100);
 9633   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9634   ins_encode %{
 9635     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9636   %}
 9637   ins_pipe( pipe_slow );
 9638 %}
 9639 
 9640 // Compare into -1,0,1 in XMM
 9641 instruct cmpD_reg(xRegI dst, regD src1, regD src2, eFlagsReg cr) %{
 9642   predicate(UseSSE&gt;=2);
 9643   match(Set dst (CmpD3 src1 src2));
 9644   effect(KILL cr);
 9645   ins_cost(255);
 9646   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9647             &quot;MOV     $dst, #-1\n\t&quot;
 9648             &quot;JP,s    done\n\t&quot;
 9649             &quot;JB,s    done\n\t&quot;
 9650             &quot;SETNE   $dst\n\t&quot;
 9651             &quot;MOVZB   $dst, $dst\n&quot;
 9652     &quot;done:&quot; %}
 9653   ins_encode %{
 9654     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9655     emit_cmpfp3(_masm, $dst$$Register);
 9656   %}
 9657   ins_pipe( pipe_slow );
 9658 %}
 9659 
 9660 // Compare into -1,0,1 in XMM and memory
 9661 instruct cmpD_regmem(xRegI dst, regD src1, memory src2, eFlagsReg cr) %{
 9662   predicate(UseSSE&gt;=2);
 9663   match(Set dst (CmpD3 src1 (LoadD src2)));
 9664   effect(KILL cr);
 9665   ins_cost(275);
 9666   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9667             &quot;MOV     $dst, #-1\n\t&quot;
 9668             &quot;JP,s    done\n\t&quot;
 9669             &quot;JB,s    done\n\t&quot;
 9670             &quot;SETNE   $dst\n\t&quot;
 9671             &quot;MOVZB   $dst, $dst\n&quot;
 9672     &quot;done:&quot; %}
 9673   ins_encode %{
 9674     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9675     emit_cmpfp3(_masm, $dst$$Register);
 9676   %}
 9677   ins_pipe( pipe_slow );
 9678 %}
 9679 
 9680 
 9681 instruct subDPR_reg(regDPR dst, regDPR src) %{
 9682   predicate (UseSSE &lt;=1);
 9683   match(Set dst (SubD dst src));
 9684 
 9685   format %{ &quot;FLD    $src\n\t&quot;
 9686             &quot;DSUBp  $dst,ST&quot; %}
 9687   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
 9688   ins_cost(150);
 9689   ins_encode( Push_Reg_DPR(src),
 9690               OpcP, RegOpc(dst) );
 9691   ins_pipe( fpu_reg_reg );
 9692 %}
 9693 
 9694 instruct subDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9695   predicate (UseSSE &lt;=1);
 9696   match(Set dst (RoundDouble (SubD src1 src2)));
 9697   ins_cost(250);
 9698 
 9699   format %{ &quot;FLD    $src2\n\t&quot;
 9700             &quot;DSUB   ST,$src1\n\t&quot;
 9701             &quot;FSTP_D $dst\t# D-round&quot; %}
 9702   opcode(0xD8, 0x5);
 9703   ins_encode( Push_Reg_DPR(src2),
 9704               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9705   ins_pipe( fpu_mem_reg_reg );
 9706 %}
 9707 
 9708 
 9709 instruct subDPR_reg_mem(regDPR dst, memory src) %{
 9710   predicate (UseSSE &lt;=1);
 9711   match(Set dst (SubD dst (LoadD src)));
 9712   ins_cost(150);
 9713 
 9714   format %{ &quot;FLD    $src\n\t&quot;
 9715             &quot;DSUBp  $dst,ST&quot; %}
 9716   opcode(0xDE, 0x5, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9717   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9718               OpcP, RegOpc(dst) );
 9719   ins_pipe( fpu_reg_mem );
 9720 %}
 9721 
 9722 instruct absDPR_reg(regDPR1 dst, regDPR1 src) %{
 9723   predicate (UseSSE&lt;=1);
 9724   match(Set dst (AbsD src));
 9725   ins_cost(100);
 9726   format %{ &quot;FABS&quot; %}
 9727   opcode(0xE1, 0xD9);
 9728   ins_encode( OpcS, OpcP );
 9729   ins_pipe( fpu_reg_reg );
 9730 %}
 9731 
 9732 instruct negDPR_reg(regDPR1 dst, regDPR1 src) %{
 9733   predicate(UseSSE&lt;=1);
 9734   match(Set dst (NegD src));
 9735   ins_cost(100);
 9736   format %{ &quot;FCHS&quot; %}
 9737   opcode(0xE0, 0xD9);
 9738   ins_encode( OpcS, OpcP );
 9739   ins_pipe( fpu_reg_reg );
 9740 %}
 9741 
 9742 instruct addDPR_reg(regDPR dst, regDPR src) %{
 9743   predicate(UseSSE&lt;=1);
 9744   match(Set dst (AddD dst src));
 9745   format %{ &quot;FLD    $src\n\t&quot;
 9746             &quot;DADD   $dst,ST&quot; %}
 9747   size(4);
 9748   ins_cost(150);
 9749   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
 9750   ins_encode( Push_Reg_DPR(src),
 9751               OpcP, RegOpc(dst) );
 9752   ins_pipe( fpu_reg_reg );
 9753 %}
 9754 
 9755 
 9756 instruct addDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9757   predicate(UseSSE&lt;=1);
 9758   match(Set dst (RoundDouble (AddD src1 src2)));
 9759   ins_cost(250);
 9760 
 9761   format %{ &quot;FLD    $src2\n\t&quot;
 9762             &quot;DADD   ST,$src1\n\t&quot;
 9763             &quot;FSTP_D $dst\t# D-round&quot; %}
 9764   opcode(0xD8, 0x0); /* D8 C0+i or D8 /0*/
 9765   ins_encode( Push_Reg_DPR(src2),
 9766               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9767   ins_pipe( fpu_mem_reg_reg );
 9768 %}
 9769 
 9770 
 9771 instruct addDPR_reg_mem(regDPR dst, memory src) %{
 9772   predicate(UseSSE&lt;=1);
 9773   match(Set dst (AddD dst (LoadD src)));
 9774   ins_cost(150);
 9775 
 9776   format %{ &quot;FLD    $src\n\t&quot;
 9777             &quot;DADDp  $dst,ST&quot; %}
 9778   opcode(0xDE, 0x0, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9779   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9780               OpcP, RegOpc(dst) );
 9781   ins_pipe( fpu_reg_mem );
 9782 %}
 9783 
 9784 // add-to-memory
 9785 instruct addDPR_mem_reg(memory dst, regDPR src) %{
 9786   predicate(UseSSE&lt;=1);
 9787   match(Set dst (StoreD dst (RoundDouble (AddD (LoadD dst) src))));
 9788   ins_cost(150);
 9789 
 9790   format %{ &quot;FLD_D  $dst\n\t&quot;
 9791             &quot;DADD   ST,$src\n\t&quot;
 9792             &quot;FST_D  $dst&quot; %}
 9793   opcode(0xDD, 0x0);
 9794   ins_encode( Opcode(0xDD), RMopc_Mem(0x00,dst),
 9795               Opcode(0xD8), RegOpc(src),
 9796               set_instruction_start,
 9797               Opcode(0xDD), RMopc_Mem(0x03,dst) );
 9798   ins_pipe( fpu_reg_mem );
 9799 %}
 9800 
 9801 instruct addDPR_reg_imm1(regDPR dst, immDPR1 con) %{
 9802   predicate(UseSSE&lt;=1);
 9803   match(Set dst (AddD dst con));
 9804   ins_cost(125);
 9805   format %{ &quot;FLD1\n\t&quot;
 9806             &quot;DADDp  $dst,ST&quot; %}
 9807   ins_encode %{
 9808     __ fld1();
 9809     __ faddp($dst$$reg);
 9810   %}
 9811   ins_pipe(fpu_reg);
 9812 %}
 9813 
 9814 instruct addDPR_reg_imm(regDPR dst, immDPR con) %{
 9815   predicate(UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9816   match(Set dst (AddD dst con));
 9817   ins_cost(200);
 9818   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9819             &quot;DADDp  $dst,ST&quot; %}
 9820   ins_encode %{
 9821     __ fld_d($constantaddress($con));
 9822     __ faddp($dst$$reg);
 9823   %}
 9824   ins_pipe(fpu_reg_mem);
 9825 %}
 9826 
 9827 instruct addDPR_reg_imm_round(stackSlotD dst, regDPR src, immDPR con) %{
 9828   predicate(UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9829   match(Set dst (RoundDouble (AddD src con)));
 9830   ins_cost(200);
 9831   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9832             &quot;DADD   ST,$src\n\t&quot;
 9833             &quot;FSTP_D $dst\t# D-round&quot; %}
 9834   ins_encode %{
 9835     __ fld_d($constantaddress($con));
 9836     __ fadd($src$$reg);
 9837     __ fstp_d(Address(rsp, $dst$$disp));
 9838   %}
 9839   ins_pipe(fpu_mem_reg_con);
 9840 %}
 9841 
 9842 instruct mulDPR_reg(regDPR dst, regDPR src) %{
 9843   predicate(UseSSE&lt;=1);
 9844   match(Set dst (MulD dst src));
 9845   format %{ &quot;FLD    $src\n\t&quot;
 9846             &quot;DMULp  $dst,ST&quot; %}
 9847   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9848   ins_cost(150);
 9849   ins_encode( Push_Reg_DPR(src),
 9850               OpcP, RegOpc(dst) );
 9851   ins_pipe( fpu_reg_reg );
 9852 %}
 9853 
 9854 // Strict FP instruction biases argument before multiply then
 9855 // biases result to avoid double rounding of subnormals.
 9856 //
 9857 // scale arg1 by multiplying arg1 by 2^(-15360)
 9858 // load arg2
 9859 // multiply scaled arg1 by arg2
 9860 // rescale product by 2^(15360)
 9861 //
 9862 instruct strictfp_mulDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9863   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9864   match(Set dst (MulD dst src));
 9865   ins_cost(1);   // Select this instruction for all strict FP double multiplies
 9866 
 9867   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9868             &quot;DMULp  $dst,ST\n\t&quot;
 9869             &quot;FLD    $src\n\t&quot;
 9870             &quot;DMULp  $dst,ST\n\t&quot;
 9871             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9872             &quot;DMULp  $dst,ST\n\t&quot; %}
 9873   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9874   ins_encode( strictfp_bias1(dst),
 9875               Push_Reg_DPR(src),
 9876               OpcP, RegOpc(dst),
 9877               strictfp_bias2(dst) );
 9878   ins_pipe( fpu_reg_reg );
 9879 %}
 9880 
 9881 instruct mulDPR_reg_imm(regDPR dst, immDPR con) %{
 9882   predicate( UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9883   match(Set dst (MulD dst con));
 9884   ins_cost(200);
 9885   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9886             &quot;DMULp  $dst,ST&quot; %}
 9887   ins_encode %{
 9888     __ fld_d($constantaddress($con));
 9889     __ fmulp($dst$$reg);
 9890   %}
 9891   ins_pipe(fpu_reg_mem);
 9892 %}
 9893 
 9894 
 9895 instruct mulDPR_reg_mem(regDPR dst, memory src) %{
 9896   predicate( UseSSE&lt;=1 );
 9897   match(Set dst (MulD dst (LoadD src)));
 9898   ins_cost(200);
 9899   format %{ &quot;FLD_D  $src\n\t&quot;
 9900             &quot;DMULp  $dst,ST&quot; %}
 9901   opcode(0xDE, 0x1, 0xDD); /* DE C8+i or DE /1*/  /* LoadD  DD /0 */
 9902   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9903               OpcP, RegOpc(dst) );
 9904   ins_pipe( fpu_reg_mem );
 9905 %}
 9906 
 9907 //
 9908 // Cisc-alternate to reg-reg multiply
 9909 instruct mulDPR_reg_mem_cisc(regDPR dst, regDPR src, memory mem) %{
 9910   predicate( UseSSE&lt;=1 );
 9911   match(Set dst (MulD src (LoadD mem)));
 9912   ins_cost(250);
 9913   format %{ &quot;FLD_D  $mem\n\t&quot;
 9914             &quot;DMUL   ST,$src\n\t&quot;
 9915             &quot;FSTP_D $dst&quot; %}
 9916   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadD D9 /0 */
 9917   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem),
 9918               OpcReg_FPR(src),
 9919               Pop_Reg_DPR(dst) );
 9920   ins_pipe( fpu_reg_reg_mem );
 9921 %}
 9922 
 9923 
 9924 // MACRO3 -- addDPR a mulDPR
 9925 // This instruction is a &#39;2-address&#39; instruction in that the result goes
 9926 // back to src2.  This eliminates a move from the macro; possibly the
 9927 // register allocator will have to add it back (and maybe not).
 9928 instruct addDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9929   predicate( UseSSE&lt;=1 );
 9930   match(Set src2 (AddD (MulD src0 src1) src2));
 9931   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9932             &quot;DMUL   ST,$src1\n\t&quot;
 9933             &quot;DADDp  $src2,ST&quot; %}
 9934   ins_cost(250);
 9935   opcode(0xDD); /* LoadD DD /0 */
 9936   ins_encode( Push_Reg_FPR(src0),
 9937               FMul_ST_reg(src1),
 9938               FAddP_reg_ST(src2) );
 9939   ins_pipe( fpu_reg_reg_reg );
 9940 %}
 9941 
 9942 
 9943 // MACRO3 -- subDPR a mulDPR
 9944 instruct subDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9945   predicate( UseSSE&lt;=1 );
 9946   match(Set src2 (SubD (MulD src0 src1) src2));
 9947   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9948             &quot;DMUL   ST,$src1\n\t&quot;
 9949             &quot;DSUBRp $src2,ST&quot; %}
 9950   ins_cost(250);
 9951   ins_encode( Push_Reg_FPR(src0),
 9952               FMul_ST_reg(src1),
 9953               Opcode(0xDE), Opc_plus(0xE0,src2));
 9954   ins_pipe( fpu_reg_reg_reg );
 9955 %}
 9956 
 9957 
 9958 instruct divDPR_reg(regDPR dst, regDPR src) %{
 9959   predicate( UseSSE&lt;=1 );
 9960   match(Set dst (DivD dst src));
 9961 
 9962   format %{ &quot;FLD    $src\n\t&quot;
 9963             &quot;FDIVp  $dst,ST&quot; %}
 9964   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9965   ins_cost(150);
 9966   ins_encode( Push_Reg_DPR(src),
 9967               OpcP, RegOpc(dst) );
 9968   ins_pipe( fpu_reg_reg );
 9969 %}
 9970 
 9971 // Strict FP instruction biases argument before division then
 9972 // biases result, to avoid double rounding of subnormals.
 9973 //
 9974 // scale dividend by multiplying dividend by 2^(-15360)
 9975 // load divisor
 9976 // divide scaled dividend by divisor
 9977 // rescale quotient by 2^(15360)
 9978 //
 9979 instruct strictfp_divDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9980   predicate (UseSSE&lt;=1);
 9981   match(Set dst (DivD dst src));
 9982   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9983   ins_cost(01);
 9984 
 9985   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9986             &quot;DMULp  $dst,ST\n\t&quot;
 9987             &quot;FLD    $src\n\t&quot;
 9988             &quot;FDIVp  $dst,ST\n\t&quot;
 9989             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9990             &quot;DMULp  $dst,ST\n\t&quot; %}
 9991   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9992   ins_encode( strictfp_bias1(dst),
 9993               Push_Reg_DPR(src),
 9994               OpcP, RegOpc(dst),
 9995               strictfp_bias2(dst) );
 9996   ins_pipe( fpu_reg_reg );
 9997 %}
 9998 
 9999 instruct divDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
10000   predicate( UseSSE&lt;=1 &amp;&amp; !(Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict()) );
10001   match(Set dst (RoundDouble (DivD src1 src2)));
10002 
10003   format %{ &quot;FLD    $src1\n\t&quot;
10004             &quot;FDIV   ST,$src2\n\t&quot;
10005             &quot;FSTP_D $dst\t# D-round&quot; %}
10006   opcode(0xD8, 0x6); /* D8 F0+i or D8 /6 */
10007   ins_encode( Push_Reg_DPR(src1),
10008               OpcP, RegOpc(src2), Pop_Mem_DPR(dst) );
10009   ins_pipe( fpu_mem_reg_reg );
10010 %}
10011 
10012 
10013 instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{
10014   predicate(UseSSE&lt;=1);
10015   match(Set dst (ModD dst src));
10016   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10017 
10018   format %{ &quot;DMOD   $dst,$src&quot; %}
10019   ins_cost(250);
10020   ins_encode(Push_Reg_Mod_DPR(dst, src),
10021               emitModDPR(),
10022               Push_Result_Mod_DPR(src),
10023               Pop_Reg_DPR(dst));
10024   ins_pipe( pipe_slow );
10025 %}
10026 
10027 instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{
10028   predicate(UseSSE&gt;=2);
10029   match(Set dst (ModD src0 src1));
10030   effect(KILL rax, KILL cr);
10031 
10032   format %{ &quot;SUB    ESP,8\t # DMOD\n&quot;
10033           &quot;\tMOVSD  [ESP+0],$src1\n&quot;
10034           &quot;\tFLD_D  [ESP+0]\n&quot;
10035           &quot;\tMOVSD  [ESP+0],$src0\n&quot;
10036           &quot;\tFLD_D  [ESP+0]\n&quot;
10037      &quot;loop:\tFPREM\n&quot;
10038           &quot;\tFWAIT\n&quot;
10039           &quot;\tFNSTSW AX\n&quot;
10040           &quot;\tSAHF\n&quot;
10041           &quot;\tJP     loop\n&quot;
10042           &quot;\tFSTP_D [ESP+0]\n&quot;
10043           &quot;\tMOVSD  $dst,[ESP+0]\n&quot;
10044           &quot;\tADD    ESP,8\n&quot;
10045           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10046     %}
10047   ins_cost(250);
10048   ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);
10049   ins_pipe( pipe_slow );
10050 %}
10051 
10052 instruct atanDPR_reg(regDPR dst, regDPR src) %{
10053   predicate (UseSSE&lt;=1);
10054   match(Set dst(AtanD dst src));
10055   format %{ &quot;DATA   $dst,$src&quot; %}
10056   opcode(0xD9, 0xF3);
10057   ins_encode( Push_Reg_DPR(src),
10058               OpcP, OpcS, RegOpc(dst) );
10059   ins_pipe( pipe_slow );
10060 %}
10061 
10062 instruct atanD_reg(regD dst, regD src, eFlagsReg cr) %{
10063   predicate (UseSSE&gt;=2);
10064   match(Set dst(AtanD dst src));
10065   effect(KILL cr); // Push_{Src|Result}D() uses &quot;{SUB|ADD} ESP,8&quot;
10066   format %{ &quot;DATA   $dst,$src&quot; %}
10067   opcode(0xD9, 0xF3);
10068   ins_encode( Push_SrcD(src),
10069               OpcP, OpcS, Push_ResultD(dst) );
10070   ins_pipe( pipe_slow );
10071 %}
10072 
10073 instruct sqrtDPR_reg(regDPR dst, regDPR src) %{
10074   predicate (UseSSE&lt;=1);
10075   match(Set dst (SqrtD src));
10076   format %{ &quot;DSQRT  $dst,$src&quot; %}
10077   opcode(0xFA, 0xD9);
10078   ins_encode( Push_Reg_DPR(src),
10079               OpcS, OpcP, Pop_Reg_DPR(dst) );
10080   ins_pipe( pipe_slow );
10081 %}
10082 
10083 //-------------Float Instructions-------------------------------
10084 // Float Math
10085 
10086 // Code for float compare:
10087 //     fcompp();
10088 //     fwait(); fnstsw_ax();
10089 //     sahf();
10090 //     movl(dst, unordered_result);
10091 //     jcc(Assembler::parity, exit);
10092 //     movl(dst, less_result);
10093 //     jcc(Assembler::below, exit);
10094 //     movl(dst, equal_result);
10095 //     jcc(Assembler::equal, exit);
10096 //     movl(dst, greater_result);
10097 //   exit:
10098 
10099 // P6 version of float compare, sets condition codes in EFLAGS
10100 instruct cmpFPR_cc_P6(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10101   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10102   match(Set cr (CmpF src1 src2));
10103   effect(KILL rax);
10104   ins_cost(150);
10105   format %{ &quot;FLD    $src1\n\t&quot;
10106             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
10107             &quot;JNP    exit\n\t&quot;
10108             &quot;MOV    ah,1       // saw a NaN, set CF (treat as LT)\n\t&quot;
10109             &quot;SAHF\n&quot;
10110      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
10111   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10112   ins_encode( Push_Reg_DPR(src1),
10113               OpcP, RegOpc(src2),
10114               cmpF_P6_fixup );
10115   ins_pipe( pipe_slow );
10116 %}
10117 
10118 instruct cmpFPR_cc_P6CF(eFlagsRegUCF cr, regFPR src1, regFPR src2) %{
10119   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10120   match(Set cr (CmpF src1 src2));
10121   ins_cost(100);
10122   format %{ &quot;FLD    $src1\n\t&quot;
10123             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
10124   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10125   ins_encode( Push_Reg_DPR(src1),
10126               OpcP, RegOpc(src2));
10127   ins_pipe( pipe_slow );
10128 %}
10129 
10130 
10131 // Compare &amp; branch
10132 instruct cmpFPR_cc(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10133   predicate(UseSSE == 0);
10134   match(Set cr (CmpF src1 src2));
10135   effect(KILL rax);
10136   ins_cost(200);
10137   format %{ &quot;FLD    $src1\n\t&quot;
10138             &quot;FCOMp  $src2\n\t&quot;
10139             &quot;FNSTSW AX\n\t&quot;
10140             &quot;TEST   AX,0x400\n\t&quot;
10141             &quot;JZ,s   flags\n\t&quot;
10142             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
10143     &quot;flags:\tSAHF&quot; %}
10144   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10145   ins_encode( Push_Reg_DPR(src1),
10146               OpcP, RegOpc(src2),
10147               fpu_flags);
10148   ins_pipe( pipe_slow );
10149 %}
10150 
10151 // Compare vs zero into -1,0,1
10152 instruct cmpFPR_0(rRegI dst, regFPR src1, immFPR0 zero, eAXRegI rax, eFlagsReg cr) %{
10153   predicate(UseSSE == 0);
10154   match(Set dst (CmpF3 src1 zero));
10155   effect(KILL cr, KILL rax);
10156   ins_cost(280);
10157   format %{ &quot;FTSTF  $dst,$src1&quot; %}
10158   opcode(0xE4, 0xD9);
10159   ins_encode( Push_Reg_DPR(src1),
10160               OpcS, OpcP, PopFPU,
10161               CmpF_Result(dst));
10162   ins_pipe( pipe_slow );
10163 %}
10164 
10165 // Compare into -1,0,1
10166 instruct cmpFPR_reg(rRegI dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10167   predicate(UseSSE == 0);
10168   match(Set dst (CmpF3 src1 src2));
10169   effect(KILL cr, KILL rax);
10170   ins_cost(300);
10171   format %{ &quot;FCMPF  $dst,$src1,$src2&quot; %}
10172   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10173   ins_encode( Push_Reg_DPR(src1),
10174               OpcP, RegOpc(src2),
10175               CmpF_Result(dst));
10176   ins_pipe( pipe_slow );
10177 %}
10178 
10179 // float compare and set condition codes in EFLAGS by XMM regs
10180 instruct cmpF_cc(eFlagsRegU cr, regF src1, regF src2) %{
10181   predicate(UseSSE&gt;=1);
10182   match(Set cr (CmpF src1 src2));
10183   ins_cost(145);
10184   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10185             &quot;JNP,s   exit\n\t&quot;
10186             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10187             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10188             &quot;POPF\n&quot;
10189     &quot;exit:&quot; %}
10190   ins_encode %{
10191     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10192     emit_cmpfp_fixup(_masm);
10193   %}
10194   ins_pipe( pipe_slow );
10195 %}
10196 
10197 instruct cmpF_ccCF(eFlagsRegUCF cr, regF src1, regF src2) %{
10198   predicate(UseSSE&gt;=1);
10199   match(Set cr (CmpF src1 src2));
10200   ins_cost(100);
10201   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10202   ins_encode %{
10203     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10204   %}
10205   ins_pipe( pipe_slow );
10206 %}
10207 
10208 // float compare and set condition codes in EFLAGS by XMM regs
10209 instruct cmpF_ccmem(eFlagsRegU cr, regF src1, memory src2) %{
10210   predicate(UseSSE&gt;=1);
10211   match(Set cr (CmpF src1 (LoadF src2)));
10212   ins_cost(165);
10213   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10214             &quot;JNP,s   exit\n\t&quot;
10215             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10216             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10217             &quot;POPF\n&quot;
10218     &quot;exit:&quot; %}
10219   ins_encode %{
10220     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10221     emit_cmpfp_fixup(_masm);
10222   %}
10223   ins_pipe( pipe_slow );
10224 %}
10225 
10226 instruct cmpF_ccmemCF(eFlagsRegUCF cr, regF src1, memory src2) %{
10227   predicate(UseSSE&gt;=1);
10228   match(Set cr (CmpF src1 (LoadF src2)));
10229   ins_cost(100);
10230   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10231   ins_encode %{
10232     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10233   %}
10234   ins_pipe( pipe_slow );
10235 %}
10236 
10237 // Compare into -1,0,1 in XMM
10238 instruct cmpF_reg(xRegI dst, regF src1, regF src2, eFlagsReg cr) %{
10239   predicate(UseSSE&gt;=1);
10240   match(Set dst (CmpF3 src1 src2));
10241   effect(KILL cr);
10242   ins_cost(255);
10243   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10244             &quot;MOV     $dst, #-1\n\t&quot;
10245             &quot;JP,s    done\n\t&quot;
10246             &quot;JB,s    done\n\t&quot;
10247             &quot;SETNE   $dst\n\t&quot;
10248             &quot;MOVZB   $dst, $dst\n&quot;
10249     &quot;done:&quot; %}
10250   ins_encode %{
10251     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10252     emit_cmpfp3(_masm, $dst$$Register);
10253   %}
10254   ins_pipe( pipe_slow );
10255 %}
10256 
10257 // Compare into -1,0,1 in XMM and memory
10258 instruct cmpF_regmem(xRegI dst, regF src1, memory src2, eFlagsReg cr) %{
10259   predicate(UseSSE&gt;=1);
10260   match(Set dst (CmpF3 src1 (LoadF src2)));
10261   effect(KILL cr);
10262   ins_cost(275);
10263   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10264             &quot;MOV     $dst, #-1\n\t&quot;
10265             &quot;JP,s    done\n\t&quot;
10266             &quot;JB,s    done\n\t&quot;
10267             &quot;SETNE   $dst\n\t&quot;
10268             &quot;MOVZB   $dst, $dst\n&quot;
10269     &quot;done:&quot; %}
10270   ins_encode %{
10271     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10272     emit_cmpfp3(_masm, $dst$$Register);
10273   %}
10274   ins_pipe( pipe_slow );
10275 %}
10276 
10277 // Spill to obtain 24-bit precision
10278 instruct subFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10279   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10280   match(Set dst (SubF src1 src2));
10281 
10282   format %{ &quot;FSUB   $dst,$src1 - $src2&quot; %}
10283   opcode(0xD8, 0x4); /* D8 E0+i or D8 /4 mod==0x3 ;; result in TOS */
10284   ins_encode( Push_Reg_FPR(src1),
10285               OpcReg_FPR(src2),
10286               Pop_Mem_FPR(dst) );
10287   ins_pipe( fpu_mem_reg_reg );
10288 %}
10289 //
10290 // This instruction does not round to 24-bits
10291 instruct subFPR_reg(regFPR dst, regFPR src) %{
10292   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10293   match(Set dst (SubF dst src));
10294 
10295   format %{ &quot;FSUB   $dst,$src&quot; %}
10296   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
10297   ins_encode( Push_Reg_FPR(src),
10298               OpcP, RegOpc(dst) );
10299   ins_pipe( fpu_reg_reg );
10300 %}
10301 
10302 // Spill to obtain 24-bit precision
10303 instruct addFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10304   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10305   match(Set dst (AddF src1 src2));
10306 
10307   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10308   opcode(0xD8, 0x0); /* D8 C0+i */
10309   ins_encode( Push_Reg_FPR(src2),
10310               OpcReg_FPR(src1),
10311               Pop_Mem_FPR(dst) );
10312   ins_pipe( fpu_mem_reg_reg );
10313 %}
10314 //
10315 // This instruction does not round to 24-bits
10316 instruct addFPR_reg(regFPR dst, regFPR src) %{
10317   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10318   match(Set dst (AddF dst src));
10319 
10320   format %{ &quot;FLD    $src\n\t&quot;
10321             &quot;FADDp  $dst,ST&quot; %}
10322   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
10323   ins_encode( Push_Reg_FPR(src),
10324               OpcP, RegOpc(dst) );
10325   ins_pipe( fpu_reg_reg );
10326 %}
10327 
10328 instruct absFPR_reg(regFPR1 dst, regFPR1 src) %{
10329   predicate(UseSSE==0);
10330   match(Set dst (AbsF src));
10331   ins_cost(100);
10332   format %{ &quot;FABS&quot; %}
10333   opcode(0xE1, 0xD9);
10334   ins_encode( OpcS, OpcP );
10335   ins_pipe( fpu_reg_reg );
10336 %}
10337 
10338 instruct negFPR_reg(regFPR1 dst, regFPR1 src) %{
10339   predicate(UseSSE==0);
10340   match(Set dst (NegF src));
10341   ins_cost(100);
10342   format %{ &quot;FCHS&quot; %}
10343   opcode(0xE0, 0xD9);
10344   ins_encode( OpcS, OpcP );
10345   ins_pipe( fpu_reg_reg );
10346 %}
10347 
10348 // Cisc-alternate to addFPR_reg
10349 // Spill to obtain 24-bit precision
10350 instruct addFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10351   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10352   match(Set dst (AddF src1 (LoadF src2)));
10353 
10354   format %{ &quot;FLD    $src2\n\t&quot;
10355             &quot;FADD   ST,$src1\n\t&quot;
10356             &quot;FSTP_S $dst&quot; %}
10357   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10358   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10359               OpcReg_FPR(src1),
10360               Pop_Mem_FPR(dst) );
10361   ins_pipe( fpu_mem_reg_mem );
10362 %}
10363 //
10364 // Cisc-alternate to addFPR_reg
10365 // This instruction does not round to 24-bits
10366 instruct addFPR_reg_mem(regFPR dst, memory src) %{
10367   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10368   match(Set dst (AddF dst (LoadF src)));
10369 
10370   format %{ &quot;FADD   $dst,$src&quot; %}
10371   opcode(0xDE, 0x0, 0xD9); /* DE C0+i or DE /0*/  /* LoadF  D9 /0 */
10372   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
10373               OpcP, RegOpc(dst) );
10374   ins_pipe( fpu_reg_mem );
10375 %}
10376 
10377 // // Following two instructions for _222_mpegaudio
10378 // Spill to obtain 24-bit precision
10379 instruct addFPR24_mem_reg(stackSlotF dst, regFPR src2, memory src1 ) %{
10380   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10381   match(Set dst (AddF src1 src2));
10382 
10383   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10384   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10385   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src1),
10386               OpcReg_FPR(src2),
10387               Pop_Mem_FPR(dst) );
10388   ins_pipe( fpu_mem_reg_mem );
10389 %}
10390 
10391 // Cisc-spill variant
10392 // Spill to obtain 24-bit precision
10393 instruct addFPR24_mem_cisc(stackSlotF dst, memory src1, memory src2) %{
10394   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10395   match(Set dst (AddF src1 (LoadF src2)));
10396 
10397   format %{ &quot;FADD   $dst,$src1,$src2 cisc&quot; %}
10398   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10399   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10400               set_instruction_start,
10401               OpcP, RMopc_Mem(secondary,src1),
10402               Pop_Mem_FPR(dst) );
10403   ins_pipe( fpu_mem_mem_mem );
10404 %}
10405 
10406 // Spill to obtain 24-bit precision
10407 instruct addFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10408   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10409   match(Set dst (AddF src1 src2));
10410 
10411   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10412   opcode(0xD8, 0x0, 0xD9); /* D8 /0 */  /* LoadF  D9 /0 */
10413   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10414               set_instruction_start,
10415               OpcP, RMopc_Mem(secondary,src1),
10416               Pop_Mem_FPR(dst) );
10417   ins_pipe( fpu_mem_mem_mem );
10418 %}
10419 
10420 
10421 // Spill to obtain 24-bit precision
10422 instruct addFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10423   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10424   match(Set dst (AddF src con));
10425   format %{ &quot;FLD    $src\n\t&quot;
10426             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10427             &quot;FSTP_S $dst&quot;  %}
10428   ins_encode %{
10429     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10430     __ fadd_s($constantaddress($con));
10431     __ fstp_s(Address(rsp, $dst$$disp));
10432   %}
10433   ins_pipe(fpu_mem_reg_con);
10434 %}
10435 //
10436 // This instruction does not round to 24-bits
10437 instruct addFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10438   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10439   match(Set dst (AddF src con));
10440   format %{ &quot;FLD    $src\n\t&quot;
10441             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10442             &quot;FSTP   $dst&quot;  %}
10443   ins_encode %{
10444     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10445     __ fadd_s($constantaddress($con));
10446     __ fstp_d($dst$$reg);
10447   %}
10448   ins_pipe(fpu_reg_reg_con);
10449 %}
10450 
10451 // Spill to obtain 24-bit precision
10452 instruct mulFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10453   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10454   match(Set dst (MulF src1 src2));
10455 
10456   format %{ &quot;FLD    $src1\n\t&quot;
10457             &quot;FMUL   $src2\n\t&quot;
10458             &quot;FSTP_S $dst&quot;  %}
10459   opcode(0xD8, 0x1); /* D8 C8+i or D8 /1 ;; result in TOS */
10460   ins_encode( Push_Reg_FPR(src1),
10461               OpcReg_FPR(src2),
10462               Pop_Mem_FPR(dst) );
10463   ins_pipe( fpu_mem_reg_reg );
10464 %}
10465 //
10466 // This instruction does not round to 24-bits
10467 instruct mulFPR_reg(regFPR dst, regFPR src1, regFPR src2) %{
10468   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10469   match(Set dst (MulF src1 src2));
10470 
10471   format %{ &quot;FLD    $src1\n\t&quot;
10472             &quot;FMUL   $src2\n\t&quot;
10473             &quot;FSTP_S $dst&quot;  %}
10474   opcode(0xD8, 0x1); /* D8 C8+i */
10475   ins_encode( Push_Reg_FPR(src2),
10476               OpcReg_FPR(src1),
10477               Pop_Reg_FPR(dst) );
10478   ins_pipe( fpu_reg_reg_reg );
10479 %}
10480 
10481 
10482 // Spill to obtain 24-bit precision
10483 // Cisc-alternate to reg-reg multiply
10484 instruct mulFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10485   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10486   match(Set dst (MulF src1 (LoadF src2)));
10487 
10488   format %{ &quot;FLD_S  $src2\n\t&quot;
10489             &quot;FMUL   $src1\n\t&quot;
10490             &quot;FSTP_S $dst&quot;  %}
10491   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or DE /1*/  /* LoadF D9 /0 */
10492   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10493               OpcReg_FPR(src1),
10494               Pop_Mem_FPR(dst) );
10495   ins_pipe( fpu_mem_reg_mem );
10496 %}
10497 //
10498 // This instruction does not round to 24-bits
10499 // Cisc-alternate to reg-reg multiply
10500 instruct mulFPR_reg_mem(regFPR dst, regFPR src1, memory src2) %{
10501   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10502   match(Set dst (MulF src1 (LoadF src2)));
10503 
10504   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10505   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadF D9 /0 */
10506   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10507               OpcReg_FPR(src1),
10508               Pop_Reg_FPR(dst) );
10509   ins_pipe( fpu_reg_reg_mem );
10510 %}
10511 
10512 // Spill to obtain 24-bit precision
10513 instruct mulFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10514   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10515   match(Set dst (MulF src1 src2));
10516 
10517   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10518   opcode(0xD8, 0x1, 0xD9); /* D8 /1 */  /* LoadF D9 /0 */
10519   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10520               set_instruction_start,
10521               OpcP, RMopc_Mem(secondary,src1),
10522               Pop_Mem_FPR(dst) );
10523   ins_pipe( fpu_mem_mem_mem );
10524 %}
10525 
10526 // Spill to obtain 24-bit precision
10527 instruct mulFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10528   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10529   match(Set dst (MulF src con));
10530 
10531   format %{ &quot;FLD    $src\n\t&quot;
10532             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10533             &quot;FSTP_S $dst&quot;  %}
10534   ins_encode %{
10535     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10536     __ fmul_s($constantaddress($con));
10537     __ fstp_s(Address(rsp, $dst$$disp));
10538   %}
10539   ins_pipe(fpu_mem_reg_con);
10540 %}
10541 //
10542 // This instruction does not round to 24-bits
10543 instruct mulFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10544   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10545   match(Set dst (MulF src con));
10546 
10547   format %{ &quot;FLD    $src\n\t&quot;
10548             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10549             &quot;FSTP   $dst&quot;  %}
10550   ins_encode %{
10551     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10552     __ fmul_s($constantaddress($con));
10553     __ fstp_d($dst$$reg);
10554   %}
10555   ins_pipe(fpu_reg_reg_con);
10556 %}
10557 
10558 
10559 //
10560 // MACRO1 -- subsume unshared load into mulFPR
10561 // This instruction does not round to 24-bits
10562 instruct mulFPR_reg_load1(regFPR dst, regFPR src, memory mem1 ) %{
10563   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10564   match(Set dst (MulF (LoadF mem1) src));
10565 
10566   format %{ &quot;FLD    $mem1    ===MACRO1===\n\t&quot;
10567             &quot;FMUL   ST,$src\n\t&quot;
10568             &quot;FSTP   $dst&quot; %}
10569   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or D8 /1 */  /* LoadF D9 /0 */
10570   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem1),
10571               OpcReg_FPR(src),
10572               Pop_Reg_FPR(dst) );
10573   ins_pipe( fpu_reg_reg_mem );
10574 %}
10575 //
10576 // MACRO2 -- addFPR a mulFPR which subsumed an unshared load
10577 // This instruction does not round to 24-bits
10578 instruct addFPR_mulFPR_reg_load1(regFPR dst, memory mem1, regFPR src1, regFPR src2) %{
10579   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10580   match(Set dst (AddF (MulF (LoadF mem1) src1) src2));
10581   ins_cost(95);
10582 
10583   format %{ &quot;FLD    $mem1     ===MACRO2===\n\t&quot;
10584             &quot;FMUL   ST,$src1  subsume mulFPR left load\n\t&quot;
10585             &quot;FADD   ST,$src2\n\t&quot;
10586             &quot;FSTP   $dst&quot; %}
10587   opcode(0xD9); /* LoadF D9 /0 */
10588   ins_encode( OpcP, RMopc_Mem(0x00,mem1),
10589               FMul_ST_reg(src1),
10590               FAdd_ST_reg(src2),
10591               Pop_Reg_FPR(dst) );
10592   ins_pipe( fpu_reg_mem_reg_reg );
10593 %}
10594 
10595 // MACRO3 -- addFPR a mulFPR
10596 // This instruction does not round to 24-bits.  It is a &#39;2-address&#39;
10597 // instruction in that the result goes back to src2.  This eliminates
10598 // a move from the macro; possibly the register allocator will have
10599 // to add it back (and maybe not).
10600 instruct addFPR_mulFPR_reg(regFPR src2, regFPR src1, regFPR src0) %{
10601   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10602   match(Set src2 (AddF (MulF src0 src1) src2));
10603 
10604   format %{ &quot;FLD    $src0     ===MACRO3===\n\t&quot;
10605             &quot;FMUL   ST,$src1\n\t&quot;
10606             &quot;FADDP  $src2,ST&quot; %}
10607   opcode(0xD9); /* LoadF D9 /0 */
10608   ins_encode( Push_Reg_FPR(src0),
10609               FMul_ST_reg(src1),
10610               FAddP_reg_ST(src2) );
10611   ins_pipe( fpu_reg_reg_reg );
10612 %}
10613 
10614 // MACRO4 -- divFPR subFPR
10615 // This instruction does not round to 24-bits
10616 instruct subFPR_divFPR_reg(regFPR dst, regFPR src1, regFPR src2, regFPR src3) %{
10617   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10618   match(Set dst (DivF (SubF src2 src1) src3));
10619 
10620   format %{ &quot;FLD    $src2   ===MACRO4===\n\t&quot;
10621             &quot;FSUB   ST,$src1\n\t&quot;
10622             &quot;FDIV   ST,$src3\n\t&quot;
10623             &quot;FSTP  $dst&quot; %}
10624   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10625   ins_encode( Push_Reg_FPR(src2),
10626               subFPR_divFPR_encode(src1,src3),
10627               Pop_Reg_FPR(dst) );
10628   ins_pipe( fpu_reg_reg_reg_reg );
10629 %}
10630 
10631 // Spill to obtain 24-bit precision
10632 instruct divFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10633   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10634   match(Set dst (DivF src1 src2));
10635 
10636   format %{ &quot;FDIV   $dst,$src1,$src2&quot; %}
10637   opcode(0xD8, 0x6); /* D8 F0+i or DE /6*/
10638   ins_encode( Push_Reg_FPR(src1),
10639               OpcReg_FPR(src2),
10640               Pop_Mem_FPR(dst) );
10641   ins_pipe( fpu_mem_reg_reg );
10642 %}
10643 //
10644 // This instruction does not round to 24-bits
10645 instruct divFPR_reg(regFPR dst, regFPR src) %{
10646   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10647   match(Set dst (DivF dst src));
10648 
10649   format %{ &quot;FDIV   $dst,$src&quot; %}
10650   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10651   ins_encode( Push_Reg_FPR(src),
10652               OpcP, RegOpc(dst) );
10653   ins_pipe( fpu_reg_reg );
10654 %}
10655 
10656 
10657 // Spill to obtain 24-bit precision
10658 instruct modFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10659   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10660   match(Set dst (ModF src1 src2));
10661   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10662 
10663   format %{ &quot;FMOD   $dst,$src1,$src2&quot; %}
10664   ins_encode( Push_Reg_Mod_DPR(src1, src2),
10665               emitModDPR(),
10666               Push_Result_Mod_DPR(src2),
10667               Pop_Mem_FPR(dst));
10668   ins_pipe( pipe_slow );
10669 %}
10670 //
10671 // This instruction does not round to 24-bits
10672 instruct modFPR_reg(regFPR dst, regFPR src, eAXRegI rax, eFlagsReg cr) %{
10673   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10674   match(Set dst (ModF dst src));
10675   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10676 
10677   format %{ &quot;FMOD   $dst,$src&quot; %}
10678   ins_encode(Push_Reg_Mod_DPR(dst, src),
10679               emitModDPR(),
10680               Push_Result_Mod_DPR(src),
10681               Pop_Reg_FPR(dst));
10682   ins_pipe( pipe_slow );
10683 %}
10684 
10685 instruct modF_reg(regF dst, regF src0, regF src1, eAXRegI rax, eFlagsReg cr) %{
10686   predicate(UseSSE&gt;=1);
10687   match(Set dst (ModF src0 src1));
10688   effect(KILL rax, KILL cr);
10689   format %{ &quot;SUB    ESP,4\t # FMOD\n&quot;
10690           &quot;\tMOVSS  [ESP+0],$src1\n&quot;
10691           &quot;\tFLD_S  [ESP+0]\n&quot;
10692           &quot;\tMOVSS  [ESP+0],$src0\n&quot;
10693           &quot;\tFLD_S  [ESP+0]\n&quot;
10694      &quot;loop:\tFPREM\n&quot;
10695           &quot;\tFWAIT\n&quot;
10696           &quot;\tFNSTSW AX\n&quot;
10697           &quot;\tSAHF\n&quot;
10698           &quot;\tJP     loop\n&quot;
10699           &quot;\tFSTP_S [ESP+0]\n&quot;
10700           &quot;\tMOVSS  $dst,[ESP+0]\n&quot;
10701           &quot;\tADD    ESP,4\n&quot;
10702           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10703     %}
10704   ins_cost(250);
10705   ins_encode( Push_ModF_encoding(src0, src1), emitModDPR(), Push_ResultF(dst,0x4), PopFPU);
10706   ins_pipe( pipe_slow );
10707 %}
10708 
10709 
10710 //----------Arithmetic Conversion Instructions---------------------------------
10711 // The conversions operations are all Alpha sorted.  Please keep it that way!
10712 
10713 instruct roundFloat_mem_reg(stackSlotF dst, regFPR src) %{
10714   predicate(UseSSE==0);
10715   match(Set dst (RoundFloat src));
10716   ins_cost(125);
10717   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10718   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
10719   ins_pipe( fpu_mem_reg );
10720 %}
10721 
10722 instruct roundDouble_mem_reg(stackSlotD dst, regDPR src) %{
10723   predicate(UseSSE&lt;=1);
10724   match(Set dst (RoundDouble src));
10725   ins_cost(125);
10726   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10727   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
10728   ins_pipe( fpu_mem_reg );
10729 %}
10730 
10731 // Force rounding to 24-bit precision and 6-bit exponent
10732 instruct convDPR2FPR_reg(stackSlotF dst, regDPR src) %{
10733   predicate(UseSSE==0);
10734   match(Set dst (ConvD2F src));
10735   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10736   expand %{
10737     roundFloat_mem_reg(dst,src);
10738   %}
10739 %}
10740 
10741 // Force rounding to 24-bit precision and 6-bit exponent
10742 instruct convDPR2F_reg(regF dst, regDPR src, eFlagsReg cr) %{
10743   predicate(UseSSE==1);
10744   match(Set dst (ConvD2F src));
10745   effect( KILL cr );
10746   format %{ &quot;SUB    ESP,4\n\t&quot;
10747             &quot;FST_S  [ESP],$src\t# F-round\n\t&quot;
10748             &quot;MOVSS  $dst,[ESP]\n\t&quot;
10749             &quot;ADD ESP,4&quot; %}
10750   ins_encode %{
10751     __ subptr(rsp, 4);
10752     if ($src$$reg != FPR1L_enc) {
10753       __ fld_s($src$$reg-1);
10754       __ fstp_s(Address(rsp, 0));
10755     } else {
10756       __ fst_s(Address(rsp, 0));
10757     }
10758     __ movflt($dst$$XMMRegister, Address(rsp, 0));
10759     __ addptr(rsp, 4);
10760   %}
10761   ins_pipe( pipe_slow );
10762 %}
10763 
10764 // Force rounding double precision to single precision
10765 instruct convD2F_reg(regF dst, regD src) %{
10766   predicate(UseSSE&gt;=2);
10767   match(Set dst (ConvD2F src));
10768   format %{ &quot;CVTSD2SS $dst,$src\t# F-round&quot; %}
10769   ins_encode %{
10770     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10771   %}
10772   ins_pipe( pipe_slow );
10773 %}
10774 
10775 instruct convFPR2DPR_reg_reg(regDPR dst, regFPR src) %{
10776   predicate(UseSSE==0);
10777   match(Set dst (ConvF2D src));
10778   format %{ &quot;FST_S  $dst,$src\t# D-round&quot; %}
10779   ins_encode( Pop_Reg_Reg_DPR(dst, src));
10780   ins_pipe( fpu_reg_reg );
10781 %}
10782 
10783 instruct convFPR2D_reg(stackSlotD dst, regFPR src) %{
10784   predicate(UseSSE==1);
10785   match(Set dst (ConvF2D src));
10786   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10787   expand %{
10788     roundDouble_mem_reg(dst,src);
10789   %}
10790 %}
10791 
10792 instruct convF2DPR_reg(regDPR dst, regF src, eFlagsReg cr) %{
10793   predicate(UseSSE==1);
10794   match(Set dst (ConvF2D src));
10795   effect( KILL cr );
10796   format %{ &quot;SUB    ESP,4\n\t&quot;
10797             &quot;MOVSS  [ESP] $src\n\t&quot;
10798             &quot;FLD_S  [ESP]\n\t&quot;
10799             &quot;ADD    ESP,4\n\t&quot;
10800             &quot;FSTP   $dst\t# D-round&quot; %}
10801   ins_encode %{
10802     __ subptr(rsp, 4);
10803     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10804     __ fld_s(Address(rsp, 0));
10805     __ addptr(rsp, 4);
10806     __ fstp_d($dst$$reg);
10807   %}
10808   ins_pipe( pipe_slow );
10809 %}
10810 
10811 instruct convF2D_reg(regD dst, regF src) %{
10812   predicate(UseSSE&gt;=2);
10813   match(Set dst (ConvF2D src));
10814   format %{ &quot;CVTSS2SD $dst,$src\t# D-round&quot; %}
10815   ins_encode %{
10816     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10817   %}
10818   ins_pipe( pipe_slow );
10819 %}
10820 
10821 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10822 instruct convDPR2I_reg_reg( eAXRegI dst, eDXRegI tmp, regDPR src, eFlagsReg cr ) %{
10823   predicate(UseSSE&lt;=1);
10824   match(Set dst (ConvD2I src));
10825   effect( KILL tmp, KILL cr );
10826   format %{ &quot;FLD    $src\t# Convert double to int \n\t&quot;
10827             &quot;FLDCW  trunc mode\n\t&quot;
10828             &quot;SUB    ESP,4\n\t&quot;
10829             &quot;FISTp  [ESP + #0]\n\t&quot;
10830             &quot;FLDCW  std/24-bit mode\n\t&quot;
10831             &quot;POP    EAX\n\t&quot;
10832             &quot;CMP    EAX,0x80000000\n\t&quot;
10833             &quot;JNE,s  fast\n\t&quot;
10834             &quot;FLD_D  $src\n\t&quot;
10835             &quot;CALL   d2i_wrapper\n&quot;
10836       &quot;fast:&quot; %}
10837   ins_encode( Push_Reg_DPR(src), DPR2I_encoding(src) );
10838   ins_pipe( pipe_slow );
10839 %}
10840 
10841 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10842 instruct convD2I_reg_reg( eAXRegI dst, eDXRegI tmp, regD src, eFlagsReg cr ) %{
10843   predicate(UseSSE&gt;=2);
10844   match(Set dst (ConvD2I src));
10845   effect( KILL tmp, KILL cr );
10846   format %{ &quot;CVTTSD2SI $dst, $src\n\t&quot;
10847             &quot;CMP    $dst,0x80000000\n\t&quot;
10848             &quot;JNE,s  fast\n\t&quot;
10849             &quot;SUB    ESP, 8\n\t&quot;
10850             &quot;MOVSD  [ESP], $src\n\t&quot;
10851             &quot;FLD_D  [ESP]\n\t&quot;
10852             &quot;ADD    ESP, 8\n\t&quot;
10853             &quot;CALL   d2i_wrapper\n&quot;
10854       &quot;fast:&quot; %}
10855   ins_encode %{
10856     Label fast;
10857     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10858     __ cmpl($dst$$Register, 0x80000000);
10859     __ jccb(Assembler::notEqual, fast);
10860     __ subptr(rsp, 8);
10861     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10862     __ fld_d(Address(rsp, 0));
10863     __ addptr(rsp, 8);
10864     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10865     __ bind(fast);
10866   %}
10867   ins_pipe( pipe_slow );
10868 %}
10869 
10870 instruct convDPR2L_reg_reg( eADXRegL dst, regDPR src, eFlagsReg cr ) %{
10871   predicate(UseSSE&lt;=1);
10872   match(Set dst (ConvD2L src));
10873   effect( KILL cr );
10874   format %{ &quot;FLD    $src\t# Convert double to long\n\t&quot;
10875             &quot;FLDCW  trunc mode\n\t&quot;
10876             &quot;SUB    ESP,8\n\t&quot;
10877             &quot;FISTp  [ESP + #0]\n\t&quot;
10878             &quot;FLDCW  std/24-bit mode\n\t&quot;
10879             &quot;POP    EAX\n\t&quot;
10880             &quot;POP    EDX\n\t&quot;
10881             &quot;CMP    EDX,0x80000000\n\t&quot;
10882             &quot;JNE,s  fast\n\t&quot;
10883             &quot;TEST   EAX,EAX\n\t&quot;
10884             &quot;JNE,s  fast\n\t&quot;
10885             &quot;FLD    $src\n\t&quot;
10886             &quot;CALL   d2l_wrapper\n&quot;
10887       &quot;fast:&quot; %}
10888   ins_encode( Push_Reg_DPR(src),  DPR2L_encoding(src) );
10889   ins_pipe( pipe_slow );
10890 %}
10891 
10892 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
10893 instruct convD2L_reg_reg( eADXRegL dst, regD src, eFlagsReg cr ) %{
10894   predicate (UseSSE&gt;=2);
10895   match(Set dst (ConvD2L src));
10896   effect( KILL cr );
10897   format %{ &quot;SUB    ESP,8\t# Convert double to long\n\t&quot;
10898             &quot;MOVSD  [ESP],$src\n\t&quot;
10899             &quot;FLD_D  [ESP]\n\t&quot;
10900             &quot;FLDCW  trunc mode\n\t&quot;
10901             &quot;FISTp  [ESP + #0]\n\t&quot;
10902             &quot;FLDCW  std/24-bit mode\n\t&quot;
10903             &quot;POP    EAX\n\t&quot;
10904             &quot;POP    EDX\n\t&quot;
10905             &quot;CMP    EDX,0x80000000\n\t&quot;
10906             &quot;JNE,s  fast\n\t&quot;
10907             &quot;TEST   EAX,EAX\n\t&quot;
10908             &quot;JNE,s  fast\n\t&quot;
10909             &quot;SUB    ESP,8\n\t&quot;
10910             &quot;MOVSD  [ESP],$src\n\t&quot;
10911             &quot;FLD_D  [ESP]\n\t&quot;
10912             &quot;ADD    ESP,8\n\t&quot;
10913             &quot;CALL   d2l_wrapper\n&quot;
10914       &quot;fast:&quot; %}
10915   ins_encode %{
10916     Label fast;
10917     __ subptr(rsp, 8);
10918     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10919     __ fld_d(Address(rsp, 0));
10920     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
10921     __ fistp_d(Address(rsp, 0));
10922     // Restore the rounding mode, mask the exception
10923     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
10924       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
10925     } else {
10926       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
10927     }
10928     // Load the converted long, adjust CPU stack
10929     __ pop(rax);
10930     __ pop(rdx);
10931     __ cmpl(rdx, 0x80000000);
10932     __ jccb(Assembler::notEqual, fast);
10933     __ testl(rax, rax);
10934     __ jccb(Assembler::notEqual, fast);
10935     __ subptr(rsp, 8);
10936     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10937     __ fld_d(Address(rsp, 0));
10938     __ addptr(rsp, 8);
10939     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
10940     __ bind(fast);
10941   %}
10942   ins_pipe( pipe_slow );
10943 %}
10944 
10945 // Convert a double to an int.  Java semantics require we do complex
10946 // manglations in the corner cases.  So we set the rounding mode to
10947 // &#39;zero&#39;, store the darned double down as an int, and reset the
10948 // rounding mode to &#39;nearest&#39;.  The hardware stores a flag value down
10949 // if we would overflow or converted a NAN; we check for this and
10950 // and go the slow path if needed.
10951 instruct convFPR2I_reg_reg(eAXRegI dst, eDXRegI tmp, regFPR src, eFlagsReg cr ) %{
10952   predicate(UseSSE==0);
10953   match(Set dst (ConvF2I src));
10954   effect( KILL tmp, KILL cr );
10955   format %{ &quot;FLD    $src\t# Convert float to int \n\t&quot;
10956             &quot;FLDCW  trunc mode\n\t&quot;
10957             &quot;SUB    ESP,4\n\t&quot;
10958             &quot;FISTp  [ESP + #0]\n\t&quot;
10959             &quot;FLDCW  std/24-bit mode\n\t&quot;
10960             &quot;POP    EAX\n\t&quot;
10961             &quot;CMP    EAX,0x80000000\n\t&quot;
10962             &quot;JNE,s  fast\n\t&quot;
10963             &quot;FLD    $src\n\t&quot;
10964             &quot;CALL   d2i_wrapper\n&quot;
10965       &quot;fast:&quot; %}
10966   // DPR2I_encoding works for FPR2I
10967   ins_encode( Push_Reg_FPR(src), DPR2I_encoding(src) );
10968   ins_pipe( pipe_slow );
10969 %}
10970 
10971 // Convert a float in xmm to an int reg.
10972 instruct convF2I_reg(eAXRegI dst, eDXRegI tmp, regF src, eFlagsReg cr ) %{
10973   predicate(UseSSE&gt;=1);
10974   match(Set dst (ConvF2I src));
10975   effect( KILL tmp, KILL cr );
10976   format %{ &quot;CVTTSS2SI $dst, $src\n\t&quot;
10977             &quot;CMP    $dst,0x80000000\n\t&quot;
10978             &quot;JNE,s  fast\n\t&quot;
10979             &quot;SUB    ESP, 4\n\t&quot;
10980             &quot;MOVSS  [ESP], $src\n\t&quot;
10981             &quot;FLD    [ESP]\n\t&quot;
10982             &quot;ADD    ESP, 4\n\t&quot;
10983             &quot;CALL   d2i_wrapper\n&quot;
10984       &quot;fast:&quot; %}
10985   ins_encode %{
10986     Label fast;
10987     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
10988     __ cmpl($dst$$Register, 0x80000000);
10989     __ jccb(Assembler::notEqual, fast);
10990     __ subptr(rsp, 4);
10991     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10992     __ fld_s(Address(rsp, 0));
10993     __ addptr(rsp, 4);
10994     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10995     __ bind(fast);
10996   %}
10997   ins_pipe( pipe_slow );
10998 %}
10999 
11000 instruct convFPR2L_reg_reg( eADXRegL dst, regFPR src, eFlagsReg cr ) %{
11001   predicate(UseSSE==0);
11002   match(Set dst (ConvF2L src));
11003   effect( KILL cr );
11004   format %{ &quot;FLD    $src\t# Convert float to long\n\t&quot;
11005             &quot;FLDCW  trunc mode\n\t&quot;
11006             &quot;SUB    ESP,8\n\t&quot;
11007             &quot;FISTp  [ESP + #0]\n\t&quot;
11008             &quot;FLDCW  std/24-bit mode\n\t&quot;
11009             &quot;POP    EAX\n\t&quot;
11010             &quot;POP    EDX\n\t&quot;
11011             &quot;CMP    EDX,0x80000000\n\t&quot;
11012             &quot;JNE,s  fast\n\t&quot;
11013             &quot;TEST   EAX,EAX\n\t&quot;
11014             &quot;JNE,s  fast\n\t&quot;
11015             &quot;FLD    $src\n\t&quot;
11016             &quot;CALL   d2l_wrapper\n&quot;
11017       &quot;fast:&quot; %}
11018   // DPR2L_encoding works for FPR2L
11019   ins_encode( Push_Reg_FPR(src), DPR2L_encoding(src) );
11020   ins_pipe( pipe_slow );
11021 %}
11022 
11023 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
11024 instruct convF2L_reg_reg( eADXRegL dst, regF src, eFlagsReg cr ) %{
11025   predicate (UseSSE&gt;=1);
11026   match(Set dst (ConvF2L src));
11027   effect( KILL cr );
11028   format %{ &quot;SUB    ESP,8\t# Convert float to long\n\t&quot;
11029             &quot;MOVSS  [ESP],$src\n\t&quot;
11030             &quot;FLD_S  [ESP]\n\t&quot;
11031             &quot;FLDCW  trunc mode\n\t&quot;
11032             &quot;FISTp  [ESP + #0]\n\t&quot;
11033             &quot;FLDCW  std/24-bit mode\n\t&quot;
11034             &quot;POP    EAX\n\t&quot;
11035             &quot;POP    EDX\n\t&quot;
11036             &quot;CMP    EDX,0x80000000\n\t&quot;
11037             &quot;JNE,s  fast\n\t&quot;
11038             &quot;TEST   EAX,EAX\n\t&quot;
11039             &quot;JNE,s  fast\n\t&quot;
11040             &quot;SUB    ESP,4\t# Convert float to long\n\t&quot;
11041             &quot;MOVSS  [ESP],$src\n\t&quot;
11042             &quot;FLD_S  [ESP]\n\t&quot;
11043             &quot;ADD    ESP,4\n\t&quot;
11044             &quot;CALL   d2l_wrapper\n&quot;
11045       &quot;fast:&quot; %}
11046   ins_encode %{
11047     Label fast;
11048     __ subptr(rsp, 8);
11049     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11050     __ fld_s(Address(rsp, 0));
11051     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
11052     __ fistp_d(Address(rsp, 0));
11053     // Restore the rounding mode, mask the exception
11054     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
11055       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
11056     } else {
11057       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
11058     }
11059     // Load the converted long, adjust CPU stack
11060     __ pop(rax);
11061     __ pop(rdx);
11062     __ cmpl(rdx, 0x80000000);
11063     __ jccb(Assembler::notEqual, fast);
11064     __ testl(rax, rax);
11065     __ jccb(Assembler::notEqual, fast);
11066     __ subptr(rsp, 4);
11067     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11068     __ fld_s(Address(rsp, 0));
11069     __ addptr(rsp, 4);
11070     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
11071     __ bind(fast);
11072   %}
11073   ins_pipe( pipe_slow );
11074 %}
11075 
11076 instruct convI2DPR_reg(regDPR dst, stackSlotI src) %{
11077   predicate( UseSSE&lt;=1 );
11078   match(Set dst (ConvI2D src));
11079   format %{ &quot;FILD   $src\n\t&quot;
11080             &quot;FSTP   $dst&quot; %}
11081   opcode(0xDB, 0x0);  /* DB /0 */
11082   ins_encode(Push_Mem_I(src), Pop_Reg_DPR(dst));
11083   ins_pipe( fpu_reg_mem );
11084 %}
11085 
11086 instruct convI2D_reg(regD dst, rRegI src) %{
11087   predicate( UseSSE&gt;=2 &amp;&amp; !UseXmmI2D );
11088   match(Set dst (ConvI2D src));
11089   format %{ &quot;CVTSI2SD $dst,$src&quot; %}
11090   ins_encode %{
11091     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
11092   %}
11093   ins_pipe( pipe_slow );
11094 %}
11095 
11096 instruct convI2D_mem(regD dst, memory mem) %{
11097   predicate( UseSSE&gt;=2 );
11098   match(Set dst (ConvI2D (LoadI mem)));
11099   format %{ &quot;CVTSI2SD $dst,$mem&quot; %}
11100   ins_encode %{
11101     __ cvtsi2sdl ($dst$$XMMRegister, $mem$$Address);
11102   %}
11103   ins_pipe( pipe_slow );
11104 %}
11105 
11106 instruct convXI2D_reg(regD dst, rRegI src)
11107 %{
11108   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2D );
11109   match(Set dst (ConvI2D src));
11110 
11111   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11112             &quot;CVTDQ2PD $dst,$dst\t# i2d&quot; %}
11113   ins_encode %{
11114     __ movdl($dst$$XMMRegister, $src$$Register);
11115     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
11116   %}
11117   ins_pipe(pipe_slow); // XXX
11118 %}
11119 
11120 instruct convI2DPR_mem(regDPR dst, memory mem) %{
11121   predicate( UseSSE&lt;=1 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11122   match(Set dst (ConvI2D (LoadI mem)));
11123   format %{ &quot;FILD   $mem\n\t&quot;
11124             &quot;FSTP   $dst&quot; %}
11125   opcode(0xDB);      /* DB /0 */
11126   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11127               Pop_Reg_DPR(dst));
11128   ins_pipe( fpu_reg_mem );
11129 %}
11130 
11131 // Convert a byte to a float; no rounding step needed.
11132 instruct conv24I2FPR_reg(regFPR dst, stackSlotI src) %{
11133   predicate( UseSSE==0 &amp;&amp; n-&gt;in(1)-&gt;Opcode() == Op_AndI &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;get_int() == 255 );
11134   match(Set dst (ConvI2F src));
11135   format %{ &quot;FILD   $src\n\t&quot;
11136             &quot;FSTP   $dst&quot; %}
11137 
11138   opcode(0xDB, 0x0);  /* DB /0 */
11139   ins_encode(Push_Mem_I(src), Pop_Reg_FPR(dst));
11140   ins_pipe( fpu_reg_mem );
11141 %}
11142 
11143 // In 24-bit mode, force exponent rounding by storing back out
11144 instruct convI2FPR_SSF(stackSlotF dst, stackSlotI src) %{
11145   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11146   match(Set dst (ConvI2F src));
11147   ins_cost(200);
11148   format %{ &quot;FILD   $src\n\t&quot;
11149             &quot;FSTP_S $dst&quot; %}
11150   opcode(0xDB, 0x0);  /* DB /0 */
11151   ins_encode( Push_Mem_I(src),
11152               Pop_Mem_FPR(dst));
11153   ins_pipe( fpu_mem_mem );
11154 %}
11155 
11156 // In 24-bit mode, force exponent rounding by storing back out
11157 instruct convI2FPR_SSF_mem(stackSlotF dst, memory mem) %{
11158   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11159   match(Set dst (ConvI2F (LoadI mem)));
11160   ins_cost(200);
11161   format %{ &quot;FILD   $mem\n\t&quot;
11162             &quot;FSTP_S $dst&quot; %}
11163   opcode(0xDB);  /* DB /0 */
11164   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11165               Pop_Mem_FPR(dst));
11166   ins_pipe( fpu_mem_mem );
11167 %}
11168 
11169 // This instruction does not round to 24-bits
11170 instruct convI2FPR_reg(regFPR dst, stackSlotI src) %{
11171   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11172   match(Set dst (ConvI2F src));
11173   format %{ &quot;FILD   $src\n\t&quot;
11174             &quot;FSTP   $dst&quot; %}
11175   opcode(0xDB, 0x0);  /* DB /0 */
11176   ins_encode( Push_Mem_I(src),
11177               Pop_Reg_FPR(dst));
11178   ins_pipe( fpu_reg_mem );
11179 %}
11180 
11181 // This instruction does not round to 24-bits
11182 instruct convI2FPR_mem(regFPR dst, memory mem) %{
11183   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11184   match(Set dst (ConvI2F (LoadI mem)));
11185   format %{ &quot;FILD   $mem\n\t&quot;
11186             &quot;FSTP   $dst&quot; %}
11187   opcode(0xDB);      /* DB /0 */
11188   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11189               Pop_Reg_FPR(dst));
11190   ins_pipe( fpu_reg_mem );
11191 %}
11192 
11193 // Convert an int to a float in xmm; no rounding step needed.
11194 instruct convI2F_reg(regF dst, rRegI src) %{
11195   predicate( UseSSE==1 || UseSSE&gt;=2 &amp;&amp; !UseXmmI2F );
11196   match(Set dst (ConvI2F src));
11197   format %{ &quot;CVTSI2SS $dst, $src&quot; %}
11198   ins_encode %{
11199     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
11200   %}
11201   ins_pipe( pipe_slow );
11202 %}
11203 
11204  instruct convXI2F_reg(regF dst, rRegI src)
11205 %{
11206   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2F );
11207   match(Set dst (ConvI2F src));
11208 
11209   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11210             &quot;CVTDQ2PS $dst,$dst\t# i2f&quot; %}
11211   ins_encode %{
11212     __ movdl($dst$$XMMRegister, $src$$Register);
11213     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
11214   %}
11215   ins_pipe(pipe_slow); // XXX
11216 %}
11217 
11218 instruct convI2L_reg( eRegL dst, rRegI src, eFlagsReg cr) %{
11219   match(Set dst (ConvI2L src));
11220   effect(KILL cr);
11221   ins_cost(375);
11222   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11223             &quot;MOV    $dst.hi,$src\n\t&quot;
11224             &quot;SAR    $dst.hi,31&quot; %}
11225   ins_encode(convert_int_long(dst,src));
11226   ins_pipe( ialu_reg_reg_long );
11227 %}
11228 
11229 // Zero-extend convert int to long
11230 instruct convI2L_reg_zex(eRegL dst, rRegI src, immL_32bits mask, eFlagsReg flags ) %{
11231   match(Set dst (AndL (ConvI2L src) mask) );
11232   effect( KILL flags );
11233   ins_cost(250);
11234   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11235             &quot;XOR    $dst.hi,$dst.hi&quot; %}
11236   opcode(0x33); // XOR
11237   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11238   ins_pipe( ialu_reg_reg_long );
11239 %}
11240 
11241 // Zero-extend long
11242 instruct zerox_long(eRegL dst, eRegL src, immL_32bits mask, eFlagsReg flags ) %{
11243   match(Set dst (AndL src mask) );
11244   effect( KILL flags );
11245   ins_cost(250);
11246   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
11247             &quot;XOR    $dst.hi,$dst.hi\n\t&quot; %}
11248   opcode(0x33); // XOR
11249   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11250   ins_pipe( ialu_reg_reg_long );
11251 %}
11252 
11253 instruct convL2DPR_reg( stackSlotD dst, eRegL src, eFlagsReg cr) %{
11254   predicate (UseSSE&lt;=1);
11255   match(Set dst (ConvL2D src));
11256   effect( KILL cr );
11257   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11258             &quot;PUSH   $src.lo\n\t&quot;
11259             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11260             &quot;ADD    ESP,8\n\t&quot;
11261             &quot;FSTP_D $dst\t# D-round&quot; %}
11262   opcode(0xDF, 0x5);  /* DF /5 */
11263   ins_encode(convert_long_double(src), Pop_Mem_DPR(dst));
11264   ins_pipe( pipe_slow );
11265 %}
11266 
11267 instruct convL2D_reg( regD dst, eRegL src, eFlagsReg cr) %{
11268   predicate (UseSSE&gt;=2);
11269   match(Set dst (ConvL2D src));
11270   effect( KILL cr );
11271   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11272             &quot;PUSH   $src.lo\n\t&quot;
11273             &quot;FILD_D [ESP]\n\t&quot;
11274             &quot;FSTP_D [ESP]\n\t&quot;
11275             &quot;MOVSD  $dst,[ESP]\n\t&quot;
11276             &quot;ADD    ESP,8&quot; %}
11277   opcode(0xDF, 0x5);  /* DF /5 */
11278   ins_encode(convert_long_double2(src), Push_ResultD(dst));
11279   ins_pipe( pipe_slow );
11280 %}
11281 
11282 instruct convL2F_reg( regF dst, eRegL src, eFlagsReg cr) %{
11283   predicate (UseSSE&gt;=1);
11284   match(Set dst (ConvL2F src));
11285   effect( KILL cr );
11286   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11287             &quot;PUSH   $src.lo\n\t&quot;
11288             &quot;FILD_D [ESP]\n\t&quot;
11289             &quot;FSTP_S [ESP]\n\t&quot;
11290             &quot;MOVSS  $dst,[ESP]\n\t&quot;
11291             &quot;ADD    ESP,8&quot; %}
11292   opcode(0xDF, 0x5);  /* DF /5 */
11293   ins_encode(convert_long_double2(src), Push_ResultF(dst,0x8));
11294   ins_pipe( pipe_slow );
11295 %}
11296 
11297 instruct convL2FPR_reg( stackSlotF dst, eRegL src, eFlagsReg cr) %{
11298   match(Set dst (ConvL2F src));
11299   effect( KILL cr );
11300   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11301             &quot;PUSH   $src.lo\n\t&quot;
11302             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11303             &quot;ADD    ESP,8\n\t&quot;
11304             &quot;FSTP_S $dst\t# F-round&quot; %}
11305   opcode(0xDF, 0x5);  /* DF /5 */
11306   ins_encode(convert_long_double(src), Pop_Mem_FPR(dst));
11307   ins_pipe( pipe_slow );
11308 %}
11309 
11310 instruct convL2I_reg( rRegI dst, eRegL src ) %{
11311   match(Set dst (ConvL2I src));
11312   effect( DEF dst, USE src );
11313   format %{ &quot;MOV    $dst,$src.lo&quot; %}
11314   ins_encode(enc_CopyL_Lo(dst,src));
11315   ins_pipe( ialu_reg_reg );
11316 %}
11317 
11318 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
11319   match(Set dst (MoveF2I src));
11320   effect( DEF dst, USE src );
11321   ins_cost(100);
11322   format %{ &quot;MOV    $dst,$src\t# MoveF2I_stack_reg&quot; %}
11323   ins_encode %{
11324     __ movl($dst$$Register, Address(rsp, $src$$disp));
11325   %}
11326   ins_pipe( ialu_reg_mem );
11327 %}
11328 
11329 instruct MoveFPR2I_reg_stack(stackSlotI dst, regFPR src) %{
11330   predicate(UseSSE==0);
11331   match(Set dst (MoveF2I src));
11332   effect( DEF dst, USE src );
11333 
11334   ins_cost(125);
11335   format %{ &quot;FST_S  $dst,$src\t# MoveF2I_reg_stack&quot; %}
11336   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
11337   ins_pipe( fpu_mem_reg );
11338 %}
11339 
11340 instruct MoveF2I_reg_stack_sse(stackSlotI dst, regF src) %{
11341   predicate(UseSSE&gt;=1);
11342   match(Set dst (MoveF2I src));
11343   effect( DEF dst, USE src );
11344 
11345   ins_cost(95);
11346   format %{ &quot;MOVSS  $dst,$src\t# MoveF2I_reg_stack_sse&quot; %}
11347   ins_encode %{
11348     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
11349   %}
11350   ins_pipe( pipe_slow );
11351 %}
11352 
11353 instruct MoveF2I_reg_reg_sse(rRegI dst, regF src) %{
11354   predicate(UseSSE&gt;=2);
11355   match(Set dst (MoveF2I src));
11356   effect( DEF dst, USE src );
11357   ins_cost(85);
11358   format %{ &quot;MOVD   $dst,$src\t# MoveF2I_reg_reg_sse&quot; %}
11359   ins_encode %{
11360     __ movdl($dst$$Register, $src$$XMMRegister);
11361   %}
11362   ins_pipe( pipe_slow );
11363 %}
11364 
11365 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
11366   match(Set dst (MoveI2F src));
11367   effect( DEF dst, USE src );
11368 
11369   ins_cost(100);
11370   format %{ &quot;MOV    $dst,$src\t# MoveI2F_reg_stack&quot; %}
11371   ins_encode %{
11372     __ movl(Address(rsp, $dst$$disp), $src$$Register);
11373   %}
11374   ins_pipe( ialu_mem_reg );
11375 %}
11376 
11377 
11378 instruct MoveI2FPR_stack_reg(regFPR dst, stackSlotI src) %{
11379   predicate(UseSSE==0);
11380   match(Set dst (MoveI2F src));
11381   effect(DEF dst, USE src);
11382 
11383   ins_cost(125);
11384   format %{ &quot;FLD_S  $src\n\t&quot;
11385             &quot;FSTP   $dst\t# MoveI2F_stack_reg&quot; %}
11386   opcode(0xD9);               /* D9 /0, FLD m32real */
11387   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11388               Pop_Reg_FPR(dst) );
11389   ins_pipe( fpu_reg_mem );
11390 %}
11391 
11392 instruct MoveI2F_stack_reg_sse(regF dst, stackSlotI src) %{
11393   predicate(UseSSE&gt;=1);
11394   match(Set dst (MoveI2F src));
11395   effect( DEF dst, USE src );
11396 
11397   ins_cost(95);
11398   format %{ &quot;MOVSS  $dst,$src\t# MoveI2F_stack_reg_sse&quot; %}
11399   ins_encode %{
11400     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
11401   %}
11402   ins_pipe( pipe_slow );
11403 %}
11404 
11405 instruct MoveI2F_reg_reg_sse(regF dst, rRegI src) %{
11406   predicate(UseSSE&gt;=2);
11407   match(Set dst (MoveI2F src));
11408   effect( DEF dst, USE src );
11409 
11410   ins_cost(85);
11411   format %{ &quot;MOVD   $dst,$src\t# MoveI2F_reg_reg_sse&quot; %}
11412   ins_encode %{
11413     __ movdl($dst$$XMMRegister, $src$$Register);
11414   %}
11415   ins_pipe( pipe_slow );
11416 %}
11417 
11418 instruct MoveD2L_stack_reg(eRegL dst, stackSlotD src) %{
11419   match(Set dst (MoveD2L src));
11420   effect(DEF dst, USE src);
11421 
11422   ins_cost(250);
11423   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11424             &quot;MOV    $dst.hi,$src+4\t# MoveD2L_stack_reg&quot; %}
11425   opcode(0x8B, 0x8B);
11426   ins_encode( OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src));
11427   ins_pipe( ialu_mem_long_reg );
11428 %}
11429 
11430 instruct MoveDPR2L_reg_stack(stackSlotL dst, regDPR src) %{
11431   predicate(UseSSE&lt;=1);
11432   match(Set dst (MoveD2L src));
11433   effect(DEF dst, USE src);
11434 
11435   ins_cost(125);
11436   format %{ &quot;FST_D  $dst,$src\t# MoveD2L_reg_stack&quot; %}
11437   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
11438   ins_pipe( fpu_mem_reg );
11439 %}
11440 
11441 instruct MoveD2L_reg_stack_sse(stackSlotL dst, regD src) %{
11442   predicate(UseSSE&gt;=2);
11443   match(Set dst (MoveD2L src));
11444   effect(DEF dst, USE src);
11445   ins_cost(95);
11446   format %{ &quot;MOVSD  $dst,$src\t# MoveD2L_reg_stack_sse&quot; %}
11447   ins_encode %{
11448     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
11449   %}
11450   ins_pipe( pipe_slow );
11451 %}
11452 
11453 instruct MoveD2L_reg_reg_sse(eRegL dst, regD src, regD tmp) %{
11454   predicate(UseSSE&gt;=2);
11455   match(Set dst (MoveD2L src));
11456   effect(DEF dst, USE src, TEMP tmp);
11457   ins_cost(85);
11458   format %{ &quot;MOVD   $dst.lo,$src\n\t&quot;
11459             &quot;PSHUFLW $tmp,$src,0x4E\n\t&quot;
11460             &quot;MOVD   $dst.hi,$tmp\t# MoveD2L_reg_reg_sse&quot; %}
11461   ins_encode %{
11462     __ movdl($dst$$Register, $src$$XMMRegister);
11463     __ pshuflw($tmp$$XMMRegister, $src$$XMMRegister, 0x4e);
11464     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
11465   %}
11466   ins_pipe( pipe_slow );
11467 %}
11468 
11469 instruct MoveL2D_reg_stack(stackSlotD dst, eRegL src) %{
11470   match(Set dst (MoveL2D src));
11471   effect(DEF dst, USE src);
11472 
11473   ins_cost(200);
11474   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
11475             &quot;MOV    $dst+4,$src.hi\t# MoveL2D_reg_stack&quot; %}
11476   opcode(0x89, 0x89);
11477   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
11478   ins_pipe( ialu_mem_long_reg );
11479 %}
11480 
11481 
11482 instruct MoveL2DPR_stack_reg(regDPR dst, stackSlotL src) %{
11483   predicate(UseSSE&lt;=1);
11484   match(Set dst (MoveL2D src));
11485   effect(DEF dst, USE src);
11486   ins_cost(125);
11487 
11488   format %{ &quot;FLD_D  $src\n\t&quot;
11489             &quot;FSTP   $dst\t# MoveL2D_stack_reg&quot; %}
11490   opcode(0xDD);               /* DD /0, FLD m64real */
11491   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11492               Pop_Reg_DPR(dst) );
11493   ins_pipe( fpu_reg_mem );
11494 %}
11495 
11496 
11497 instruct MoveL2D_stack_reg_sse(regD dst, stackSlotL src) %{
11498   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
11499   match(Set dst (MoveL2D src));
11500   effect(DEF dst, USE src);
11501 
11502   ins_cost(95);
11503   format %{ &quot;MOVSD  $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11504   ins_encode %{
11505     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11506   %}
11507   ins_pipe( pipe_slow );
11508 %}
11509 
11510 instruct MoveL2D_stack_reg_sse_partial(regD dst, stackSlotL src) %{
11511   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
11512   match(Set dst (MoveL2D src));
11513   effect(DEF dst, USE src);
11514 
11515   ins_cost(95);
11516   format %{ &quot;MOVLPD $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11517   ins_encode %{
11518     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11519   %}
11520   ins_pipe( pipe_slow );
11521 %}
11522 
11523 instruct MoveL2D_reg_reg_sse(regD dst, eRegL src, regD tmp) %{
11524   predicate(UseSSE&gt;=2);
11525   match(Set dst (MoveL2D src));
11526   effect(TEMP dst, USE src, TEMP tmp);
11527   ins_cost(85);
11528   format %{ &quot;MOVD   $dst,$src.lo\n\t&quot;
11529             &quot;MOVD   $tmp,$src.hi\n\t&quot;
11530             &quot;PUNPCKLDQ $dst,$tmp\t# MoveL2D_reg_reg_sse&quot; %}
11531   ins_encode %{
11532     __ movdl($dst$$XMMRegister, $src$$Register);
11533     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));
11534     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);
11535   %}
11536   ins_pipe( pipe_slow );
11537 %}
11538 
11539 
11540 // =======================================================================
11541 // fast clearing of an array
11542 instruct rep_stos(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11543   predicate(!((ClearArrayNode*)n)-&gt;is_large());
11544   match(Set dummy (ClearArray cnt base));
11545   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11546 
11547   format %{ $$template
11548     $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11549     $$emit$$&quot;CMP    InitArrayShortSize,rcx\n\t&quot;
11550     $$emit$$&quot;JG     LARGE\n\t&quot;
11551     $$emit$$&quot;SHL    ECX, 1\n\t&quot;
11552     $$emit$$&quot;DEC    ECX\n\t&quot;
11553     $$emit$$&quot;JS     DONE\t# Zero length\n\t&quot;
11554     $$emit$$&quot;MOV    EAX,(EDI,ECX,4)\t# LOOP\n\t&quot;
11555     $$emit$$&quot;DEC    ECX\n\t&quot;
11556     $$emit$$&quot;JGE    LOOP\n\t&quot;
11557     $$emit$$&quot;JMP    DONE\n\t&quot;
11558     $$emit$$&quot;# LARGE:\n\t&quot;
11559     if (UseFastStosb) {
11560        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11561        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11562     } else if (UseXMMForObjInit) {
11563        $$emit$$&quot;MOV     RDI,RAX\n\t&quot;
11564        $$emit$$&quot;VPXOR    YMM0,YMM0,YMM0\n\t&quot;
11565        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11566        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11567        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11568        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11569        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11570        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11571        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11572        $$emit$$&quot;JGE     L_loop\n\t&quot;
11573        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11574        $$emit$$&quot;JL      L_tail\n\t&quot;
11575        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11576        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11577        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11578        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11579        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11580        $$emit$$&quot;JLE     L_end\n\t&quot;
11581        $$emit$$&quot;DEC     RCX\n\t&quot;
11582        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11583        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11584        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11585        $$emit$$&quot;DEC     RCX\n\t&quot;
11586        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11587        $$emit$$&quot;# L_end:\n\t&quot;
11588     } else {
11589        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11590        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11591     }
11592     $$emit$$&quot;# DONE&quot;
11593   %}
11594   ins_encode %{
11595     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11596                  $tmp$$XMMRegister, false);
11597   %}
11598   ins_pipe( pipe_slow );
11599 %}
11600 
11601 instruct rep_stos_large(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11602   predicate(((ClearArrayNode*)n)-&gt;is_large());
11603   match(Set dummy (ClearArray cnt base));
11604   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11605   format %{ $$template
11606     if (UseFastStosb) {
11607        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11608        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11609        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11610     } else if (UseXMMForObjInit) {
11611        $$emit$$&quot;MOV     RDI,RAX\t# ClearArray:\n\t&quot;
11612        $$emit$$&quot;VPXOR   YMM0,YMM0,YMM0\n\t&quot;
11613        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11614        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11615        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11616        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11617        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11618        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11619        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11620        $$emit$$&quot;JGE     L_loop\n\t&quot;
11621        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11622        $$emit$$&quot;JL      L_tail\n\t&quot;
11623        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11624        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11625        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11626        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11627        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11628        $$emit$$&quot;JLE     L_end\n\t&quot;
11629        $$emit$$&quot;DEC     RCX\n\t&quot;
11630        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11631        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11632        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11633        $$emit$$&quot;DEC     RCX\n\t&quot;
11634        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11635        $$emit$$&quot;# L_end:\n\t&quot;
11636     } else {
11637        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11638        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11639        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11640     }
11641     $$emit$$&quot;# DONE&quot;
11642   %}
11643   ins_encode %{
11644     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11645                  $tmp$$XMMRegister, true);
11646   %}
11647   ins_pipe( pipe_slow );
11648 %}
11649 
11650 instruct string_compareL(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11651                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11652   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11653   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11654   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11655 
11656   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11657   ins_encode %{
11658     __ string_compare($str1$$Register, $str2$$Register,
11659                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11660                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11661   %}
11662   ins_pipe( pipe_slow );
11663 %}
11664 
11665 instruct string_compareU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11666                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11667   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11668   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11669   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11670 
11671   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11672   ins_encode %{
11673     __ string_compare($str1$$Register, $str2$$Register,
11674                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11675                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11676   %}
11677   ins_pipe( pipe_slow );
11678 %}
11679 
11680 instruct string_compareLU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11681                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11682   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11683   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11684   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11685 
11686   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11687   ins_encode %{
11688     __ string_compare($str1$$Register, $str2$$Register,
11689                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11690                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11691   %}
11692   ins_pipe( pipe_slow );
11693 %}
11694 
11695 instruct string_compareUL(eSIRegP str1, eDXRegI cnt1, eDIRegP str2, eCXRegI cnt2,
11696                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11697   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11698   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11699   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11700 
11701   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11702   ins_encode %{
11703     __ string_compare($str2$$Register, $str1$$Register,
11704                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11705                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11706   %}
11707   ins_pipe( pipe_slow );
11708 %}
11709 
11710 // fast string equals
11711 instruct string_equals(eDIRegP str1, eSIRegP str2, eCXRegI cnt, eAXRegI result,
11712                        regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr) %{
11713   match(Set result (StrEquals (Binary str1 str2) cnt));
11714   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11715 
11716   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11717   ins_encode %{
11718     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11719                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11720                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11721   %}
11722 
11723   ins_pipe( pipe_slow );
11724 %}
11725 
11726 // fast search of substring with known size.
11727 instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11728                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11729   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11730   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11731   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11732 
11733   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11734   ins_encode %{
11735     int icnt2 = (int)$int_cnt2$$constant;
11736     if (icnt2 &gt;= 16) {
11737       // IndexOf for constant substrings with size &gt;= 16 elements
11738       // which don&#39;t need to be loaded through stack.
11739       __ string_indexofC8($str1$$Register, $str2$$Register,
11740                           $cnt1$$Register, $cnt2$$Register,
11741                           icnt2, $result$$Register,
11742                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11743     } else {
11744       // Small strings are loaded through stack if they cross page boundary.
11745       __ string_indexof($str1$$Register, $str2$$Register,
11746                         $cnt1$$Register, $cnt2$$Register,
11747                         icnt2, $result$$Register,
11748                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11749     }
11750   %}
11751   ins_pipe( pipe_slow );
11752 %}
11753 
11754 // fast search of substring with known size.
11755 instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11756                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11757   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11758   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11759   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11760 
11761   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11762   ins_encode %{
11763     int icnt2 = (int)$int_cnt2$$constant;
11764     if (icnt2 &gt;= 8) {
11765       // IndexOf for constant substrings with size &gt;= 8 elements
11766       // which don&#39;t need to be loaded through stack.
11767       __ string_indexofC8($str1$$Register, $str2$$Register,
11768                           $cnt1$$Register, $cnt2$$Register,
11769                           icnt2, $result$$Register,
11770                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11771     } else {
11772       // Small strings are loaded through stack if they cross page boundary.
11773       __ string_indexof($str1$$Register, $str2$$Register,
11774                         $cnt1$$Register, $cnt2$$Register,
11775                         icnt2, $result$$Register,
11776                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11777     }
11778   %}
11779   ins_pipe( pipe_slow );
11780 %}
11781 
11782 // fast search of substring with known size.
11783 instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11784                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11785   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11786   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11787   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11788 
11789   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11790   ins_encode %{
11791     int icnt2 = (int)$int_cnt2$$constant;
11792     if (icnt2 &gt;= 8) {
11793       // IndexOf for constant substrings with size &gt;= 8 elements
11794       // which don&#39;t need to be loaded through stack.
11795       __ string_indexofC8($str1$$Register, $str2$$Register,
11796                           $cnt1$$Register, $cnt2$$Register,
11797                           icnt2, $result$$Register,
11798                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11799     } else {
11800       // Small strings are loaded through stack if they cross page boundary.
11801       __ string_indexof($str1$$Register, $str2$$Register,
11802                         $cnt1$$Register, $cnt2$$Register,
11803                         icnt2, $result$$Register,
11804                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11805     }
11806   %}
11807   ins_pipe( pipe_slow );
11808 %}
11809 
11810 instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11811                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11812   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11813   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11814   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11815 
11816   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11817   ins_encode %{
11818     __ string_indexof($str1$$Register, $str2$$Register,
11819                       $cnt1$$Register, $cnt2$$Register,
11820                       (-1), $result$$Register,
11821                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11822   %}
11823   ins_pipe( pipe_slow );
11824 %}
11825 
11826 instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11827                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11828   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11829   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11830   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11831 
11832   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11833   ins_encode %{
11834     __ string_indexof($str1$$Register, $str2$$Register,
11835                       $cnt1$$Register, $cnt2$$Register,
11836                       (-1), $result$$Register,
11837                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11838   %}
11839   ins_pipe( pipe_slow );
11840 %}
11841 
11842 instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11843                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11844   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11845   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11846   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11847 
11848   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11849   ins_encode %{
11850     __ string_indexof($str1$$Register, $str2$$Register,
11851                       $cnt1$$Register, $cnt2$$Register,
11852                       (-1), $result$$Register,
11853                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11854   %}
11855   ins_pipe( pipe_slow );
11856 %}
11857 
11858 instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
11859                               eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{
11860   predicate(UseSSE42Intrinsics);
11861   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11862   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11863   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11864   ins_encode %{
11865     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11866                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);
11867   %}
11868   ins_pipe( pipe_slow );
11869 %}
11870 
11871 // fast array equals
11872 instruct array_equalsB(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11873                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11874 %{
11875   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11876   match(Set result (AryEq ary1 ary2));
11877   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11878   //ins_cost(300);
11879 
11880   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11881   ins_encode %{
11882     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11883                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11884                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11885   %}
11886   ins_pipe( pipe_slow );
11887 %}
11888 
11889 instruct array_equalsC(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11890                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11891 %{
11892   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11893   match(Set result (AryEq ary1 ary2));
11894   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11895   //ins_cost(300);
11896 
11897   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11898   ins_encode %{
11899     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11900                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11901                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11902   %}
11903   ins_pipe( pipe_slow );
11904 %}
11905 
11906 instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,
11907                       regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)
11908 %{
11909   match(Set result (HasNegatives ary1 len));
11910   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11911 
11912   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11913   ins_encode %{
11914     __ has_negatives($ary1$$Register, $len$$Register,
11915                      $result$$Register, $tmp3$$Register,
11916                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11917   %}
11918   ins_pipe( pipe_slow );
11919 %}
11920 
11921 // fast char[] to byte[] compression
11922 instruct string_compress(eSIRegP src, eDIRegP dst, eDXRegI len, regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11923                          eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11924   match(Set result (StrCompressedCopy src (Binary dst len)));
11925   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11926 
11927   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11928   ins_encode %{
11929     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11930                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11931                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11932   %}
11933   ins_pipe( pipe_slow );
11934 %}
11935 
11936 // fast byte[] to char[] inflation
11937 instruct string_inflate(Universe dummy, eSIRegP src, eDIRegP dst, eDXRegI len,
11938                         regD tmp1, eCXRegI tmp2, eFlagsReg cr) %{
11939   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11940   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11941 
11942   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11943   ins_encode %{
11944     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11945                           $tmp1$$XMMRegister, $tmp2$$Register);
11946   %}
11947   ins_pipe( pipe_slow );
11948 %}
11949 
11950 // encode char[] to byte[] in ISO_8859_1
11951 instruct encode_iso_array(eSIRegP src, eDIRegP dst, eDXRegI len,
11952                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11953                           eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11954   match(Set result (EncodeISOArray src (Binary dst len)));
11955   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11956 
11957   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL ECX, EDX, $tmp1, $tmp2, $tmp3, $tmp4, ESI, EDI &quot; %}
11958   ins_encode %{
11959     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11960                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11961                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11962   %}
11963   ins_pipe( pipe_slow );
11964 %}
11965 
11966 
11967 //----------Control Flow Instructions------------------------------------------
11968 // Signed compare Instructions
11969 instruct compI_eReg(eFlagsReg cr, rRegI op1, rRegI op2) %{
11970   match(Set cr (CmpI op1 op2));
11971   effect( DEF cr, USE op1, USE op2 );
11972   format %{ &quot;CMP    $op1,$op2&quot; %}
11973   opcode(0x3B);  /* Opcode 3B /r */
11974   ins_encode( OpcP, RegReg( op1, op2) );
11975   ins_pipe( ialu_cr_reg_reg );
11976 %}
11977 
11978 instruct compI_eReg_imm(eFlagsReg cr, rRegI op1, immI op2) %{
11979   match(Set cr (CmpI op1 op2));
11980   effect( DEF cr, USE op1 );
11981   format %{ &quot;CMP    $op1,$op2&quot; %}
11982   opcode(0x81,0x07);  /* Opcode 81 /7 */
11983   // ins_encode( RegImm( op1, op2) );  /* Was CmpImm */
11984   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
11985   ins_pipe( ialu_cr_reg_imm );
11986 %}
11987 
11988 // Cisc-spilled version of cmpI_eReg
11989 instruct compI_eReg_mem(eFlagsReg cr, rRegI op1, memory op2) %{
11990   match(Set cr (CmpI op1 (LoadI op2)));
11991 
11992   format %{ &quot;CMP    $op1,$op2&quot; %}
11993   ins_cost(500);
11994   opcode(0x3B);  /* Opcode 3B /r */
11995   ins_encode( OpcP, RegMem( op1, op2) );
11996   ins_pipe( ialu_cr_reg_mem );
11997 %}
11998 
11999 instruct testI_reg( eFlagsReg cr, rRegI src, immI0 zero ) %{
12000   match(Set cr (CmpI src zero));
12001   effect( DEF cr, USE src );
12002 
12003   format %{ &quot;TEST   $src,$src&quot; %}
12004   opcode(0x85);
12005   ins_encode( OpcP, RegReg( src, src ) );
12006   ins_pipe( ialu_cr_reg_imm );
12007 %}
12008 
12009 instruct testI_reg_imm( eFlagsReg cr, rRegI src, immI con, immI0 zero ) %{
12010   match(Set cr (CmpI (AndI src con) zero));
12011 
12012   format %{ &quot;TEST   $src,$con&quot; %}
12013   opcode(0xF7,0x00);
12014   ins_encode( OpcP, RegOpc(src), Con32(con) );
12015   ins_pipe( ialu_cr_reg_imm );
12016 %}
12017 
12018 instruct testI_reg_mem( eFlagsReg cr, rRegI src, memory mem, immI0 zero ) %{
12019   match(Set cr (CmpI (AndI src mem) zero));
12020 
12021   format %{ &quot;TEST   $src,$mem&quot; %}
12022   opcode(0x85);
12023   ins_encode( OpcP, RegMem( src, mem ) );
12024   ins_pipe( ialu_cr_reg_mem );
12025 %}
12026 
12027 // Unsigned compare Instructions; really, same as signed except they
12028 // produce an eFlagsRegU instead of eFlagsReg.
12029 instruct compU_eReg(eFlagsRegU cr, rRegI op1, rRegI op2) %{
12030   match(Set cr (CmpU op1 op2));
12031 
12032   format %{ &quot;CMPu   $op1,$op2&quot; %}
12033   opcode(0x3B);  /* Opcode 3B /r */
12034   ins_encode( OpcP, RegReg( op1, op2) );
12035   ins_pipe( ialu_cr_reg_reg );
12036 %}
12037 
12038 instruct compU_eReg_imm(eFlagsRegU cr, rRegI op1, immI op2) %{
12039   match(Set cr (CmpU op1 op2));
12040 
12041   format %{ &quot;CMPu   $op1,$op2&quot; %}
12042   opcode(0x81,0x07);  /* Opcode 81 /7 */
12043   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12044   ins_pipe( ialu_cr_reg_imm );
12045 %}
12046 
12047 // // Cisc-spilled version of cmpU_eReg
12048 instruct compU_eReg_mem(eFlagsRegU cr, rRegI op1, memory op2) %{
12049   match(Set cr (CmpU op1 (LoadI op2)));
12050 
12051   format %{ &quot;CMPu   $op1,$op2&quot; %}
12052   ins_cost(500);
12053   opcode(0x3B);  /* Opcode 3B /r */
12054   ins_encode( OpcP, RegMem( op1, op2) );
12055   ins_pipe( ialu_cr_reg_mem );
12056 %}
12057 
12058 // // Cisc-spilled version of cmpU_eReg
12059 //instruct compU_mem_eReg(eFlagsRegU cr, memory op1, rRegI op2) %{
12060 //  match(Set cr (CmpU (LoadI op1) op2));
12061 //
12062 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12063 //  ins_cost(500);
12064 //  opcode(0x39);  /* Opcode 39 /r */
12065 //  ins_encode( OpcP, RegMem( op1, op2) );
12066 //%}
12067 
12068 instruct testU_reg( eFlagsRegU cr, rRegI src, immI0 zero ) %{
12069   match(Set cr (CmpU src zero));
12070 
12071   format %{ &quot;TESTu  $src,$src&quot; %}
12072   opcode(0x85);
12073   ins_encode( OpcP, RegReg( src, src ) );
12074   ins_pipe( ialu_cr_reg_imm );
12075 %}
12076 
12077 // Unsigned pointer compare Instructions
12078 instruct compP_eReg(eFlagsRegU cr, eRegP op1, eRegP op2) %{
12079   match(Set cr (CmpP op1 op2));
12080 
12081   format %{ &quot;CMPu   $op1,$op2&quot; %}
12082   opcode(0x3B);  /* Opcode 3B /r */
12083   ins_encode( OpcP, RegReg( op1, op2) );
12084   ins_pipe( ialu_cr_reg_reg );
12085 %}
12086 
12087 instruct compP_eReg_imm(eFlagsRegU cr, eRegP op1, immP op2) %{
12088   match(Set cr (CmpP op1 op2));
12089 
12090   format %{ &quot;CMPu   $op1,$op2&quot; %}
12091   opcode(0x81,0x07);  /* Opcode 81 /7 */
12092   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12093   ins_pipe( ialu_cr_reg_imm );
12094 %}
12095 
12096 // // Cisc-spilled version of cmpP_eReg
12097 instruct compP_eReg_mem(eFlagsRegU cr, eRegP op1, memory op2) %{
12098   match(Set cr (CmpP op1 (LoadP op2)));
12099 
12100   format %{ &quot;CMPu   $op1,$op2&quot; %}
12101   ins_cost(500);
12102   opcode(0x3B);  /* Opcode 3B /r */
12103   ins_encode( OpcP, RegMem( op1, op2) );
12104   ins_pipe( ialu_cr_reg_mem );
12105 %}
12106 
12107 // // Cisc-spilled version of cmpP_eReg
12108 //instruct compP_mem_eReg(eFlagsRegU cr, memory op1, eRegP op2) %{
12109 //  match(Set cr (CmpP (LoadP op1) op2));
12110 //
12111 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12112 //  ins_cost(500);
12113 //  opcode(0x39);  /* Opcode 39 /r */
12114 //  ins_encode( OpcP, RegMem( op1, op2) );
12115 //%}
12116 
12117 // Compare raw pointer (used in out-of-heap check).
12118 // Only works because non-oop pointers must be raw pointers
12119 // and raw pointers have no anti-dependencies.
12120 instruct compP_mem_eReg( eFlagsRegU cr, eRegP op1, memory op2 ) %{
12121   predicate( n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none );
12122   match(Set cr (CmpP op1 (LoadP op2)));
12123 
12124   format %{ &quot;CMPu   $op1,$op2&quot; %}
12125   opcode(0x3B);  /* Opcode 3B /r */
12126   ins_encode( OpcP, RegMem( op1, op2) );
12127   ins_pipe( ialu_cr_reg_mem );
12128 %}
12129 
12130 //
12131 // This will generate a signed flags result. This should be ok
12132 // since any compare to a zero should be eq/neq.
12133 instruct testP_reg( eFlagsReg cr, eRegP src, immP0 zero ) %{
12134   match(Set cr (CmpP src zero));
12135 
12136   format %{ &quot;TEST   $src,$src&quot; %}
12137   opcode(0x85);
12138   ins_encode( OpcP, RegReg( src, src ) );
12139   ins_pipe( ialu_cr_reg_imm );
12140 %}
12141 
12142 // Cisc-spilled version of testP_reg
12143 // This will generate a signed flags result. This should be ok
12144 // since any compare to a zero should be eq/neq.
12145 instruct testP_Reg_mem( eFlagsReg cr, memory op, immI0 zero ) %{
12146   match(Set cr (CmpP (LoadP op) zero));
12147 
12148   format %{ &quot;TEST   $op,0xFFFFFFFF&quot; %}
12149   ins_cost(500);
12150   opcode(0xF7);               /* Opcode F7 /0 */
12151   ins_encode( OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF) );
12152   ins_pipe( ialu_cr_reg_imm );
12153 %}
12154 
12155 // Yanked all unsigned pointer compare operations.
12156 // Pointer compares are done with CmpP which is already unsigned.
12157 
12158 //----------Max and Min--------------------------------------------------------
12159 // Min Instructions
12160 ////
12161 //   *** Min and Max using the conditional move are slower than the
12162 //   *** branch version on a Pentium III.
12163 // // Conditional move for min
12164 //instruct cmovI_reg_lt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12165 //  effect( USE_DEF op2, USE op1, USE cr );
12166 //  format %{ &quot;CMOVlt $op2,$op1\t! min&quot; %}
12167 //  opcode(0x4C,0x0F);
12168 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12169 //  ins_pipe( pipe_cmov_reg );
12170 //%}
12171 //
12172 //// Min Register with Register (P6 version)
12173 //instruct minI_eReg_p6( rRegI op1, rRegI op2 ) %{
12174 //  predicate(VM_Version::supports_cmov() );
12175 //  match(Set op2 (MinI op1 op2));
12176 //  ins_cost(200);
12177 //  expand %{
12178 //    eFlagsReg cr;
12179 //    compI_eReg(cr,op1,op2);
12180 //    cmovI_reg_lt(op2,op1,cr);
12181 //  %}
12182 //%}
12183 
12184 // Min Register with Register (generic version)
12185 instruct minI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12186   match(Set dst (MinI dst src));
12187   effect(KILL flags);
12188   ins_cost(300);
12189 
12190   format %{ &quot;MIN    $dst,$src&quot; %}
12191   opcode(0xCC);
12192   ins_encode( min_enc(dst,src) );
12193   ins_pipe( pipe_slow );
12194 %}
12195 
12196 // Max Register with Register
12197 //   *** Min and Max using the conditional move are slower than the
12198 //   *** branch version on a Pentium III.
12199 // // Conditional move for max
12200 //instruct cmovI_reg_gt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12201 //  effect( USE_DEF op2, USE op1, USE cr );
12202 //  format %{ &quot;CMOVgt $op2,$op1\t! max&quot; %}
12203 //  opcode(0x4F,0x0F);
12204 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12205 //  ins_pipe( pipe_cmov_reg );
12206 //%}
12207 //
12208 // // Max Register with Register (P6 version)
12209 //instruct maxI_eReg_p6( rRegI op1, rRegI op2 ) %{
12210 //  predicate(VM_Version::supports_cmov() );
12211 //  match(Set op2 (MaxI op1 op2));
12212 //  ins_cost(200);
12213 //  expand %{
12214 //    eFlagsReg cr;
12215 //    compI_eReg(cr,op1,op2);
12216 //    cmovI_reg_gt(op2,op1,cr);
12217 //  %}
12218 //%}
12219 
12220 // Max Register with Register (generic version)
12221 instruct maxI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12222   match(Set dst (MaxI dst src));
12223   effect(KILL flags);
12224   ins_cost(300);
12225 
12226   format %{ &quot;MAX    $dst,$src&quot; %}
12227   opcode(0xCC);
12228   ins_encode( max_enc(dst,src) );
12229   ins_pipe( pipe_slow );
12230 %}
12231 
12232 // ============================================================================
12233 // Counted Loop limit node which represents exact final iterator value.
12234 // Note: the resulting value should fit into integer range since
12235 // counted loops have limit check on overflow.
12236 instruct loopLimit_eReg(eAXRegI limit, nadxRegI init, immI stride, eDXRegI limit_hi, nadxRegI tmp, eFlagsReg flags) %{
12237   match(Set limit (LoopLimit (Binary init limit) stride));
12238   effect(TEMP limit_hi, TEMP tmp, KILL flags);
12239   ins_cost(300);
12240 
12241   format %{ &quot;loopLimit $init,$limit,$stride  # $limit = $init + $stride *( $limit - $init + $stride -1)/ $stride, kills $limit_hi&quot; %}
12242   ins_encode %{
12243     int strd = (int)$stride$$constant;
12244     assert(strd != 1 &amp;&amp; strd != -1, &quot;sanity&quot;);
12245     int m1 = (strd &gt; 0) ? 1 : -1;
12246     // Convert limit to long (EAX:EDX)
12247     __ cdql();
12248     // Convert init to long (init:tmp)
12249     __ movl($tmp$$Register, $init$$Register);
12250     __ sarl($tmp$$Register, 31);
12251     // $limit - $init
12252     __ subl($limit$$Register, $init$$Register);
12253     __ sbbl($limit_hi$$Register, $tmp$$Register);
12254     // + ($stride - 1)
12255     if (strd &gt; 0) {
12256       __ addl($limit$$Register, (strd - 1));
12257       __ adcl($limit_hi$$Register, 0);
12258       __ movl($tmp$$Register, strd);
12259     } else {
12260       __ addl($limit$$Register, (strd + 1));
12261       __ adcl($limit_hi$$Register, -1);
12262       __ lneg($limit_hi$$Register, $limit$$Register);
12263       __ movl($tmp$$Register, -strd);
12264     }
12265     // signed devision: (EAX:EDX) / pos_stride
12266     __ idivl($tmp$$Register);
12267     if (strd &lt; 0) {
12268       // restore sign
12269       __ negl($tmp$$Register);
12270     }
12271     // (EAX) * stride
12272     __ mull($tmp$$Register);
12273     // + init (ignore upper bits)
12274     __ addl($limit$$Register, $init$$Register);
12275   %}
12276   ins_pipe( pipe_slow );
12277 %}
12278 
12279 // ============================================================================
12280 // Branch Instructions
12281 // Jump Table
12282 instruct jumpXtnd(rRegI switch_val) %{
12283   match(Jump switch_val);
12284   ins_cost(350);
12285   format %{  &quot;JMP    [$constantaddress](,$switch_val,1)\n\t&quot; %}
12286   ins_encode %{
12287     // Jump to Address(table_base + switch_reg)
12288     Address index(noreg, $switch_val$$Register, Address::times_1);
12289     __ jump(ArrayAddress($constantaddress, index));
12290   %}
12291   ins_pipe(pipe_jmp);
12292 %}
12293 
12294 // Jump Direct - Label defines a relative address from JMP+1
12295 instruct jmpDir(label labl) %{
12296   match(Goto);
12297   effect(USE labl);
12298 
12299   ins_cost(300);
12300   format %{ &quot;JMP    $labl&quot; %}
12301   size(5);
12302   ins_encode %{
12303     Label* L = $labl$$label;
12304     __ jmp(*L, false); // Always long jump
12305   %}
12306   ins_pipe( pipe_jmp );
12307 %}
12308 
12309 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12310 instruct jmpCon(cmpOp cop, eFlagsReg cr, label labl) %{
12311   match(If cop cr);
12312   effect(USE labl);
12313 
12314   ins_cost(300);
12315   format %{ &quot;J$cop    $labl&quot; %}
12316   size(6);
12317   ins_encode %{
12318     Label* L = $labl$$label;
12319     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12320   %}
12321   ins_pipe( pipe_jcc );
12322 %}
12323 
12324 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12325 instruct jmpLoopEnd(cmpOp cop, eFlagsReg cr, label labl) %{
12326   predicate(!n-&gt;has_vector_mask_set());
12327   match(CountedLoopEnd cop cr);
12328   effect(USE labl);
12329 
12330   ins_cost(300);
12331   format %{ &quot;J$cop    $labl\t# Loop end&quot; %}
12332   size(6);
12333   ins_encode %{
12334     Label* L = $labl$$label;
12335     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12336   %}
12337   ins_pipe( pipe_jcc );
12338 %}
12339 
12340 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12341 instruct jmpLoopEndU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12342   predicate(!n-&gt;has_vector_mask_set());
12343   match(CountedLoopEnd cop cmp);
12344   effect(USE labl);
12345 
12346   ins_cost(300);
12347   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12348   size(6);
12349   ins_encode %{
12350     Label* L = $labl$$label;
12351     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12352   %}
12353   ins_pipe( pipe_jcc );
12354 %}
12355 
12356 instruct jmpLoopEndUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12357   predicate(!n-&gt;has_vector_mask_set());
12358   match(CountedLoopEnd cop cmp);
12359   effect(USE labl);
12360 
12361   ins_cost(200);
12362   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12363   size(6);
12364   ins_encode %{
12365     Label* L = $labl$$label;
12366     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12367   %}
12368   ins_pipe( pipe_jcc );
12369 %}
12370 
12371 // mask version
12372 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12373 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, eFlagsReg cr, label labl) %{
12374   predicate(n-&gt;has_vector_mask_set());
12375   match(CountedLoopEnd cop cr);
12376   effect(USE labl);
12377 
12378   ins_cost(400);
12379   format %{ &quot;J$cop    $labl\t# Loop end\n\t&quot;
12380             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12381   size(10);
12382   ins_encode %{
12383     Label* L = $labl$$label;
12384     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12385     __ restorevectmask();
12386   %}
12387   ins_pipe( pipe_jcc );
12388 %}
12389 
12390 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12391 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12392   predicate(n-&gt;has_vector_mask_set());
12393   match(CountedLoopEnd cop cmp);
12394   effect(USE labl);
12395 
12396   ins_cost(400);
12397   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12398             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12399   size(10);
12400   ins_encode %{
12401     Label* L = $labl$$label;
12402     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12403     __ restorevectmask();
12404   %}
12405   ins_pipe( pipe_jcc );
12406 %}
12407 
12408 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12409   predicate(n-&gt;has_vector_mask_set());
12410   match(CountedLoopEnd cop cmp);
12411   effect(USE labl);
12412 
12413   ins_cost(300);
12414   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12415             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12416   size(10);
12417   ins_encode %{
12418     Label* L = $labl$$label;
12419     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12420     __ restorevectmask();
12421   %}
12422   ins_pipe( pipe_jcc );
12423 %}
12424 
12425 // Jump Direct Conditional - using unsigned comparison
12426 instruct jmpConU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12427   match(If cop cmp);
12428   effect(USE labl);
12429 
12430   ins_cost(300);
12431   format %{ &quot;J$cop,u  $labl&quot; %}
12432   size(6);
12433   ins_encode %{
12434     Label* L = $labl$$label;
12435     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12436   %}
12437   ins_pipe(pipe_jcc);
12438 %}
12439 
12440 instruct jmpConUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12441   match(If cop cmp);
12442   effect(USE labl);
12443 
12444   ins_cost(200);
12445   format %{ &quot;J$cop,u  $labl&quot; %}
12446   size(6);
12447   ins_encode %{
12448     Label* L = $labl$$label;
12449     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12450   %}
12451   ins_pipe(pipe_jcc);
12452 %}
12453 
12454 instruct jmpConUCF2(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12455   match(If cop cmp);
12456   effect(USE labl);
12457 
12458   ins_cost(200);
12459   format %{ $$template
12460     if ($cop$$cmpcode == Assembler::notEqual) {
12461       $$emit$$&quot;JP,u   $labl\n\t&quot;
12462       $$emit$$&quot;J$cop,u   $labl&quot;
12463     } else {
12464       $$emit$$&quot;JP,u   done\n\t&quot;
12465       $$emit$$&quot;J$cop,u   $labl\n\t&quot;
12466       $$emit$$&quot;done:&quot;
12467     }
12468   %}
12469   ins_encode %{
12470     Label* l = $labl$$label;
12471     if ($cop$$cmpcode == Assembler::notEqual) {
12472       __ jcc(Assembler::parity, *l, false);
12473       __ jcc(Assembler::notEqual, *l, false);
12474     } else if ($cop$$cmpcode == Assembler::equal) {
12475       Label done;
12476       __ jccb(Assembler::parity, done);
12477       __ jcc(Assembler::equal, *l, false);
12478       __ bind(done);
12479     } else {
12480        ShouldNotReachHere();
12481     }
12482   %}
12483   ins_pipe(pipe_jcc);
12484 %}
12485 
12486 // ============================================================================
12487 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
12488 // array for an instance of the superklass.  Set a hidden internal cache on a
12489 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
12490 // NZ for a miss or zero for a hit.  The encoding ALSO sets flags.
12491 instruct partialSubtypeCheck( eDIRegP result, eSIRegP sub, eAXRegP super, eCXRegI rcx, eFlagsReg cr ) %{
12492   match(Set result (PartialSubtypeCheck sub super));
12493   effect( KILL rcx, KILL cr );
12494 
12495   ins_cost(1100);  // slightly larger than the next version
12496   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12497             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12498             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12499             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12500             &quot;JNE,s  miss\t\t# Missed: EDI not-zero\n\t&quot;
12501             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache\n\t&quot;
12502             &quot;XOR    $result,$result\t\t Hit: EDI zero\n\t&quot;
12503      &quot;miss:\t&quot; %}
12504 
12505   opcode(0x1); // Force a XOR of EDI
12506   ins_encode( enc_PartialSubtypeCheck() );
12507   ins_pipe( pipe_slow );
12508 %}
12509 
12510 instruct partialSubtypeCheck_vs_Zero( eFlagsReg cr, eSIRegP sub, eAXRegP super, eCXRegI rcx, eDIRegP result, immP0 zero ) %{
12511   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12512   effect( KILL rcx, KILL result );
12513 
12514   ins_cost(1000);
12515   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12516             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12517             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12518             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12519             &quot;JNE,s  miss\t\t# Missed: flags NZ\n\t&quot;
12520             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache, flags Z\n\t&quot;
12521      &quot;miss:\t&quot; %}
12522 
12523   opcode(0x0);  // No need to XOR EDI
12524   ins_encode( enc_PartialSubtypeCheck() );
12525   ins_pipe( pipe_slow );
12526 %}
12527 
12528 // ============================================================================
12529 // Branch Instructions -- short offset versions
12530 //
12531 // These instructions are used to replace jumps of a long offset (the default
12532 // match) with jumps of a shorter offset.  These instructions are all tagged
12533 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12534 // match rules in general matching.  Instead, the ADLC generates a conversion
12535 // method in the MachNode which can be used to do in-place replacement of the
12536 // long variant with the shorter variant.  The compiler will determine if a
12537 // branch can be taken by the is_short_branch_offset() predicate in the machine
12538 // specific code section of the file.
12539 
12540 // Jump Direct - Label defines a relative address from JMP+1
12541 instruct jmpDir_short(label labl) %{
12542   match(Goto);
12543   effect(USE labl);
12544 
12545   ins_cost(300);
12546   format %{ &quot;JMP,s  $labl&quot; %}
12547   size(2);
12548   ins_encode %{
12549     Label* L = $labl$$label;
12550     __ jmpb(*L);
12551   %}
12552   ins_pipe( pipe_jmp );
12553   ins_short_branch(1);
12554 %}
12555 
12556 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12557 instruct jmpCon_short(cmpOp cop, eFlagsReg cr, label labl) %{
12558   match(If cop cr);
12559   effect(USE labl);
12560 
12561   ins_cost(300);
12562   format %{ &quot;J$cop,s  $labl&quot; %}
12563   size(2);
12564   ins_encode %{
12565     Label* L = $labl$$label;
12566     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12567   %}
12568   ins_pipe( pipe_jcc );
12569   ins_short_branch(1);
12570 %}
12571 
12572 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12573 instruct jmpLoopEnd_short(cmpOp cop, eFlagsReg cr, label labl) %{
12574   match(CountedLoopEnd cop cr);
12575   effect(USE labl);
12576 
12577   ins_cost(300);
12578   format %{ &quot;J$cop,s  $labl\t# Loop end&quot; %}
12579   size(2);
12580   ins_encode %{
12581     Label* L = $labl$$label;
12582     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12583   %}
12584   ins_pipe( pipe_jcc );
12585   ins_short_branch(1);
12586 %}
12587 
12588 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12589 instruct jmpLoopEndU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12590   match(CountedLoopEnd cop cmp);
12591   effect(USE labl);
12592 
12593   ins_cost(300);
12594   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12595   size(2);
12596   ins_encode %{
12597     Label* L = $labl$$label;
12598     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12599   %}
12600   ins_pipe( pipe_jcc );
12601   ins_short_branch(1);
12602 %}
12603 
12604 instruct jmpLoopEndUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12605   match(CountedLoopEnd cop cmp);
12606   effect(USE labl);
12607 
12608   ins_cost(300);
12609   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12610   size(2);
12611   ins_encode %{
12612     Label* L = $labl$$label;
12613     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12614   %}
12615   ins_pipe( pipe_jcc );
12616   ins_short_branch(1);
12617 %}
12618 
12619 // Jump Direct Conditional - using unsigned comparison
12620 instruct jmpConU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12621   match(If cop cmp);
12622   effect(USE labl);
12623 
12624   ins_cost(300);
12625   format %{ &quot;J$cop,us $labl&quot; %}
12626   size(2);
12627   ins_encode %{
12628     Label* L = $labl$$label;
12629     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12630   %}
12631   ins_pipe( pipe_jcc );
12632   ins_short_branch(1);
12633 %}
12634 
12635 instruct jmpConUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12636   match(If cop cmp);
12637   effect(USE labl);
12638 
12639   ins_cost(300);
12640   format %{ &quot;J$cop,us $labl&quot; %}
12641   size(2);
12642   ins_encode %{
12643     Label* L = $labl$$label;
12644     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12645   %}
12646   ins_pipe( pipe_jcc );
12647   ins_short_branch(1);
12648 %}
12649 
12650 instruct jmpConUCF2_short(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12651   match(If cop cmp);
12652   effect(USE labl);
12653 
12654   ins_cost(300);
12655   format %{ $$template
12656     if ($cop$$cmpcode == Assembler::notEqual) {
12657       $$emit$$&quot;JP,u,s   $labl\n\t&quot;
12658       $$emit$$&quot;J$cop,u,s   $labl&quot;
12659     } else {
12660       $$emit$$&quot;JP,u,s   done\n\t&quot;
12661       $$emit$$&quot;J$cop,u,s  $labl\n\t&quot;
12662       $$emit$$&quot;done:&quot;
12663     }
12664   %}
12665   size(4);
12666   ins_encode %{
12667     Label* l = $labl$$label;
12668     if ($cop$$cmpcode == Assembler::notEqual) {
12669       __ jccb(Assembler::parity, *l);
12670       __ jccb(Assembler::notEqual, *l);
12671     } else if ($cop$$cmpcode == Assembler::equal) {
12672       Label done;
12673       __ jccb(Assembler::parity, done);
12674       __ jccb(Assembler::equal, *l);
12675       __ bind(done);
12676     } else {
12677        ShouldNotReachHere();
12678     }
12679   %}
12680   ins_pipe(pipe_jcc);
12681   ins_short_branch(1);
12682 %}
12683 
12684 // ============================================================================
12685 // Long Compare
12686 //
12687 // Currently we hold longs in 2 registers.  Comparing such values efficiently
12688 // is tricky.  The flavor of compare used depends on whether we are testing
12689 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
12690 // The GE test is the negated LT test.  The LE test can be had by commuting
12691 // the operands (yielding a GE test) and then negating; negate again for the
12692 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
12693 // NE test is negated from that.
12694 
12695 // Due to a shortcoming in the ADLC, it mixes up expressions like:
12696 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
12697 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
12698 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
12699 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
12700 // foo match ends up with the wrong leaf.  One fix is to not match both
12701 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
12702 // both forms beat the trinary form of long-compare and both are very useful
12703 // on Intel which has so few registers.
12704 
12705 // Manifest a CmpL result in an integer register.  Very painful.
12706 // This is the test to avoid.
12707 instruct cmpL3_reg_reg(eSIRegI dst, eRegL src1, eRegL src2, eFlagsReg flags ) %{
12708   match(Set dst (CmpL3 src1 src2));
12709   effect( KILL flags );
12710   ins_cost(1000);
12711   format %{ &quot;XOR    $dst,$dst\n\t&quot;
12712             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12713             &quot;JLT,s  m_one\n\t&quot;
12714             &quot;JGT,s  p_one\n\t&quot;
12715             &quot;CMP    $src1.lo,$src2.lo\n\t&quot;
12716             &quot;JB,s   m_one\n\t&quot;
12717             &quot;JEQ,s  done\n&quot;
12718     &quot;p_one:\tINC    $dst\n\t&quot;
12719             &quot;JMP,s  done\n&quot;
12720     &quot;m_one:\tDEC    $dst\n&quot;
12721      &quot;done:&quot; %}
12722   ins_encode %{
12723     Label p_one, m_one, done;
12724     __ xorptr($dst$$Register, $dst$$Register);
12725     __ cmpl(HIGH_FROM_LOW($src1$$Register), HIGH_FROM_LOW($src2$$Register));
12726     __ jccb(Assembler::less,    m_one);
12727     __ jccb(Assembler::greater, p_one);
12728     __ cmpl($src1$$Register, $src2$$Register);
12729     __ jccb(Assembler::below,   m_one);
12730     __ jccb(Assembler::equal,   done);
12731     __ bind(p_one);
12732     __ incrementl($dst$$Register);
12733     __ jmpb(done);
12734     __ bind(m_one);
12735     __ decrementl($dst$$Register);
12736     __ bind(done);
12737   %}
12738   ins_pipe( pipe_slow );
12739 %}
12740 
12741 //======
12742 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12743 // compares.  Can be used for LE or GT compares by reversing arguments.
12744 // NOT GOOD FOR EQ/NE tests.
12745 instruct cmpL_zero_flags_LTGE( flagsReg_long_LTGE flags, eRegL src, immL0 zero ) %{
12746   match( Set flags (CmpL src zero ));
12747   ins_cost(100);
12748   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12749   opcode(0x85);
12750   ins_encode( OpcP, RegReg_Hi2( src, src ) );
12751   ins_pipe( ialu_cr_reg_reg );
12752 %}
12753 
12754 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12755 // compares.  Can be used for LE or GT compares by reversing arguments.
12756 // NOT GOOD FOR EQ/NE tests.
12757 instruct cmpL_reg_flags_LTGE( flagsReg_long_LTGE flags, eRegL src1, eRegL src2, rRegI tmp ) %{
12758   match( Set flags (CmpL src1 src2 ));
12759   effect( TEMP tmp );
12760   ins_cost(300);
12761   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12762             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12763             &quot;SBB    $tmp,$src2.hi\t! Compute flags for long compare&quot; %}
12764   ins_encode( long_cmp_flags2( src1, src2, tmp ) );
12765   ins_pipe( ialu_cr_reg_reg );
12766 %}
12767 
12768 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
12769 // Just a wrapper for a normal branch, plus the predicate test.
12770 instruct cmpL_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, label labl) %{
12771   match(If cmp flags);
12772   effect(USE labl);
12773   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12774   expand %{
12775     jmpCon(cmp,flags,labl);    // JLT or JGE...
12776   %}
12777 %}
12778 
12779 //======
12780 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12781 // compares.  Can be used for LE or GT compares by reversing arguments.
12782 // NOT GOOD FOR EQ/NE tests.
12783 instruct cmpUL_zero_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src, immL0 zero) %{
12784   match(Set flags (CmpUL src zero));
12785   ins_cost(100);
12786   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12787   opcode(0x85);
12788   ins_encode(OpcP, RegReg_Hi2(src, src));
12789   ins_pipe(ialu_cr_reg_reg);
12790 %}
12791 
12792 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12793 // compares.  Can be used for LE or GT compares by reversing arguments.
12794 // NOT GOOD FOR EQ/NE tests.
12795 instruct cmpUL_reg_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src1, eRegL src2, rRegI tmp) %{
12796   match(Set flags (CmpUL src1 src2));
12797   effect(TEMP tmp);
12798   ins_cost(300);
12799   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12800             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12801             &quot;SBB    $tmp,$src2.hi\t! Compute flags for unsigned long compare&quot; %}
12802   ins_encode(long_cmp_flags2(src1, src2, tmp));
12803   ins_pipe(ialu_cr_reg_reg);
12804 %}
12805 
12806 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
12807 // Just a wrapper for a normal branch, plus the predicate test.
12808 instruct cmpUL_LTGE(cmpOpU cmp, flagsReg_ulong_LTGE flags, label labl) %{
12809   match(If cmp flags);
12810   effect(USE labl);
12811   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
12812   expand %{
12813     jmpCon(cmp, flags, labl);    // JLT or JGE...
12814   %}
12815 %}
12816 
12817 // Compare 2 longs and CMOVE longs.
12818 instruct cmovLL_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, eRegL src) %{
12819   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12820   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12821   ins_cost(400);
12822   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12823             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12824   opcode(0x0F,0x40);
12825   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12826   ins_pipe( pipe_cmov_reg_long );
12827 %}
12828 
12829 instruct cmovLL_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, load_long_memory src) %{
12830   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12831   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12832   ins_cost(500);
12833   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12834             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12835   opcode(0x0F,0x40);
12836   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
12837   ins_pipe( pipe_cmov_reg_long );
12838 %}
12839 
12840 // Compare 2 longs and CMOVE ints.
12841 instruct cmovII_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, rRegI src) %{
12842   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12843   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
12844   ins_cost(200);
12845   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12846   opcode(0x0F,0x40);
12847   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12848   ins_pipe( pipe_cmov_reg );
12849 %}
12850 
12851 instruct cmovII_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, memory src) %{
12852   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12853   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
12854   ins_cost(250);
12855   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12856   opcode(0x0F,0x40);
12857   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
12858   ins_pipe( pipe_cmov_mem );
12859 %}
12860 
12861 // Compare 2 longs and CMOVE ints.
12862 instruct cmovPP_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegP dst, eRegP src) %{
12863   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12864   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
12865   ins_cost(200);
12866   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12867   opcode(0x0F,0x40);
12868   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12869   ins_pipe( pipe_cmov_reg );
12870 %}
12871 
12872 // Compare 2 longs and CMOVE doubles
12873 instruct cmovDDPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regDPR dst, regDPR src) %{
12874   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12875   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12876   ins_cost(200);
12877   expand %{
12878     fcmovDPR_regS(cmp,flags,dst,src);
12879   %}
12880 %}
12881 
12882 // Compare 2 longs and CMOVE doubles
12883 instruct cmovDD_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regD dst, regD src) %{
12884   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12885   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12886   ins_cost(200);
12887   expand %{
12888     fcmovD_regS(cmp,flags,dst,src);
12889   %}
12890 %}
12891 
12892 instruct cmovFFPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regFPR dst, regFPR src) %{
12893   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12894   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12895   ins_cost(200);
12896   expand %{
12897     fcmovFPR_regS(cmp,flags,dst,src);
12898   %}
12899 %}
12900 
12901 instruct cmovFF_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regF dst, regF src) %{
12902   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12903   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12904   ins_cost(200);
12905   expand %{
12906     fcmovF_regS(cmp,flags,dst,src);
12907   %}
12908 %}
12909 
12910 //======
12911 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12912 instruct cmpL_zero_flags_EQNE( flagsReg_long_EQNE flags, eRegL src, immL0 zero, rRegI tmp ) %{
12913   match( Set flags (CmpL src zero ));
12914   effect(TEMP tmp);
12915   ins_cost(200);
12916   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12917             &quot;OR     $tmp,$src.hi\t! Long is EQ/NE 0?&quot; %}
12918   ins_encode( long_cmp_flags0( src, tmp ) );
12919   ins_pipe( ialu_reg_reg_long );
12920 %}
12921 
12922 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12923 instruct cmpL_reg_flags_EQNE( flagsReg_long_EQNE flags, eRegL src1, eRegL src2 ) %{
12924   match( Set flags (CmpL src1 src2 ));
12925   ins_cost(200+300);
12926   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12927             &quot;JNE,s  skip\n\t&quot;
12928             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12929      &quot;skip:\t&quot; %}
12930   ins_encode( long_cmp_flags1( src1, src2 ) );
12931   ins_pipe( ialu_cr_reg_reg );
12932 %}
12933 
12934 // Long compare reg == zero/reg OR reg != zero/reg
12935 // Just a wrapper for a normal branch, plus the predicate test.
12936 instruct cmpL_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, label labl) %{
12937   match(If cmp flags);
12938   effect(USE labl);
12939   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
12940   expand %{
12941     jmpCon(cmp,flags,labl);    // JEQ or JNE...
12942   %}
12943 %}
12944 
12945 //======
12946 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12947 instruct cmpUL_zero_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src, immL0 zero, rRegI tmp) %{
12948   match(Set flags (CmpUL src zero));
12949   effect(TEMP tmp);
12950   ins_cost(200);
12951   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12952             &quot;OR     $tmp,$src.hi\t! Unsigned long is EQ/NE 0?&quot; %}
12953   ins_encode(long_cmp_flags0(src, tmp));
12954   ins_pipe(ialu_reg_reg_long);
12955 %}
12956 
12957 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12958 instruct cmpUL_reg_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src1, eRegL src2) %{
12959   match(Set flags (CmpUL src1 src2));
12960   ins_cost(200+300);
12961   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12962             &quot;JNE,s  skip\n\t&quot;
12963             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12964      &quot;skip:\t&quot; %}
12965   ins_encode(long_cmp_flags1(src1, src2));
12966   ins_pipe(ialu_cr_reg_reg);
12967 %}
12968 
12969 // Unsigned long compare reg == zero/reg OR reg != zero/reg
12970 // Just a wrapper for a normal branch, plus the predicate test.
12971 instruct cmpUL_EQNE(cmpOpU cmp, flagsReg_ulong_EQNE flags, label labl) %{
12972   match(If cmp flags);
12973   effect(USE labl);
12974   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne);
12975   expand %{
12976     jmpCon(cmp, flags, labl);    // JEQ or JNE...
12977   %}
12978 %}
12979 
12980 // Compare 2 longs and CMOVE longs.
12981 instruct cmovLL_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, eRegL src) %{
12982   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12983   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12984   ins_cost(400);
12985   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12986             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12987   opcode(0x0F,0x40);
12988   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12989   ins_pipe( pipe_cmov_reg_long );
12990 %}
12991 
12992 instruct cmovLL_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, load_long_memory src) %{
12993   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12994   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12995   ins_cost(500);
12996   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12997             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12998   opcode(0x0F,0x40);
12999   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
13000   ins_pipe( pipe_cmov_reg_long );
13001 %}
13002 
13003 // Compare 2 longs and CMOVE ints.
13004 instruct cmovII_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, rRegI src) %{
13005   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13006   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
13007   ins_cost(200);
13008   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13009   opcode(0x0F,0x40);
13010   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13011   ins_pipe( pipe_cmov_reg );
13012 %}
13013 
13014 instruct cmovII_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, memory src) %{
13015   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13016   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13017   ins_cost(250);
13018   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13019   opcode(0x0F,0x40);
13020   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13021   ins_pipe( pipe_cmov_mem );
13022 %}
13023 
13024 // Compare 2 longs and CMOVE ints.
13025 instruct cmovPP_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegP dst, eRegP src) %{
13026   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13027   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13028   ins_cost(200);
13029   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13030   opcode(0x0F,0x40);
13031   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13032   ins_pipe( pipe_cmov_reg );
13033 %}
13034 
13035 // Compare 2 longs and CMOVE doubles
13036 instruct cmovDDPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regDPR dst, regDPR src) %{
13037   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13038   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13039   ins_cost(200);
13040   expand %{
13041     fcmovDPR_regS(cmp,flags,dst,src);
13042   %}
13043 %}
13044 
13045 // Compare 2 longs and CMOVE doubles
13046 instruct cmovDD_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regD dst, regD src) %{
13047   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13048   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13049   ins_cost(200);
13050   expand %{
13051     fcmovD_regS(cmp,flags,dst,src);
13052   %}
13053 %}
13054 
13055 instruct cmovFFPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regFPR dst, regFPR src) %{
13056   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13057   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13058   ins_cost(200);
13059   expand %{
13060     fcmovFPR_regS(cmp,flags,dst,src);
13061   %}
13062 %}
13063 
13064 instruct cmovFF_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regF dst, regF src) %{
13065   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13066   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13067   ins_cost(200);
13068   expand %{
13069     fcmovF_regS(cmp,flags,dst,src);
13070   %}
13071 %}
13072 
13073 //======
13074 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13075 // Same as cmpL_reg_flags_LEGT except must negate src
13076 instruct cmpL_zero_flags_LEGT( flagsReg_long_LEGT flags, eRegL src, immL0 zero, rRegI tmp ) %{
13077   match( Set flags (CmpL src zero ));
13078   effect( TEMP tmp );
13079   ins_cost(300);
13080   format %{ &quot;XOR    $tmp,$tmp\t# Long compare for -$src &lt; 0, use commuted test\n\t&quot;
13081             &quot;CMP    $tmp,$src.lo\n\t&quot;
13082             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13083   ins_encode( long_cmp_flags3(src, tmp) );
13084   ins_pipe( ialu_reg_reg_long );
13085 %}
13086 
13087 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13088 // Same as cmpL_reg_flags_LTGE except operands swapped.  Swapping operands
13089 // requires a commuted test to get the same result.
13090 instruct cmpL_reg_flags_LEGT( flagsReg_long_LEGT flags, eRegL src1, eRegL src2, rRegI tmp ) %{
13091   match( Set flags (CmpL src1 src2 ));
13092   effect( TEMP tmp );
13093   ins_cost(300);
13094   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Long compare, swapped operands, use with commuted test\n\t&quot;
13095             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13096             &quot;SBB    $tmp,$src1.hi\t! Compute flags for long compare&quot; %}
13097   ins_encode( long_cmp_flags2( src2, src1, tmp ) );
13098   ins_pipe( ialu_cr_reg_reg );
13099 %}
13100 
13101 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
13102 // Just a wrapper for a normal branch, plus the predicate test
13103 instruct cmpL_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, label labl) %{
13104   match(If cmp flags);
13105   effect(USE labl);
13106   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le );
13107   ins_cost(300);
13108   expand %{
13109     jmpCon(cmp,flags,labl);    // JGT or JLE...
13110   %}
13111 %}
13112 
13113 //======
13114 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13115 // Same as cmpUL_reg_flags_LEGT except must negate src
13116 instruct cmpUL_zero_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src, immL0 zero, rRegI tmp) %{
13117   match(Set flags (CmpUL src zero));
13118   effect(TEMP tmp);
13119   ins_cost(300);
13120   format %{ &quot;XOR    $tmp,$tmp\t# Unsigned long compare for -$src &lt; 0, use commuted test\n\t&quot;
13121             &quot;CMP    $tmp,$src.lo\n\t&quot;
13122             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13123   ins_encode(long_cmp_flags3(src, tmp));
13124   ins_pipe(ialu_reg_reg_long);
13125 %}
13126 
13127 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13128 // Same as cmpUL_reg_flags_LTGE except operands swapped.  Swapping operands
13129 // requires a commuted test to get the same result.
13130 instruct cmpUL_reg_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src1, eRegL src2, rRegI tmp) %{
13131   match(Set flags (CmpUL src1 src2));
13132   effect(TEMP tmp);
13133   ins_cost(300);
13134   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Unsigned long compare, swapped operands, use with commuted test\n\t&quot;
13135             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13136             &quot;SBB    $tmp,$src1.hi\t! Compute flags for unsigned long compare&quot; %}
13137   ins_encode(long_cmp_flags2( src2, src1, tmp));
13138   ins_pipe(ialu_cr_reg_reg);
13139 %}
13140 
13141 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
13142 // Just a wrapper for a normal branch, plus the predicate test
13143 instruct cmpUL_LEGT(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, label labl) %{
13144   match(If cmp flags);
13145   effect(USE labl);
13146   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le);
13147   ins_cost(300);
13148   expand %{
13149     jmpCon(cmp, flags, labl);    // JGT or JLE...
13150   %}
13151 %}
13152 
13153 // Compare 2 longs and CMOVE longs.
13154 instruct cmovLL_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, eRegL src) %{
13155   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
13156   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13157   ins_cost(400);
13158   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13159             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
13160   opcode(0x0F,0x40);
13161   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
13162   ins_pipe( pipe_cmov_reg_long );
13163 %}
13164 
13165 instruct cmovLL_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, load_long_memory src) %{
13166   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
13167   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13168   ins_cost(500);
13169   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13170             &quot;CMOV$cmp $dst.hi,$src.hi+4&quot; %}
13171   opcode(0x0F,0x40);
13172   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
13173   ins_pipe( pipe_cmov_reg_long );
13174 %}
13175 
13176 // Compare 2 longs and CMOVE ints.
13177 instruct cmovII_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, rRegI src) %{
13178   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13179   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
13180   ins_cost(200);
13181   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13182   opcode(0x0F,0x40);
13183   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13184   ins_pipe( pipe_cmov_reg );
13185 %}
13186 
13187 instruct cmovII_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, memory src) %{
13188   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13189   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13190   ins_cost(250);
13191   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13192   opcode(0x0F,0x40);
13193   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13194   ins_pipe( pipe_cmov_mem );
13195 %}
13196 
13197 // Compare 2 longs and CMOVE ptrs.
13198 instruct cmovPP_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegP dst, eRegP src) %{
13199   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13200   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13201   ins_cost(200);
13202   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13203   opcode(0x0F,0x40);
13204   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13205   ins_pipe( pipe_cmov_reg );
13206 %}
13207 
13208 // Compare 2 longs and CMOVE doubles
13209 instruct cmovDDPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regDPR dst, regDPR src) %{
13210   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13211   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13212   ins_cost(200);
13213   expand %{
13214     fcmovDPR_regS(cmp,flags,dst,src);
13215   %}
13216 %}
13217 
13218 // Compare 2 longs and CMOVE doubles
13219 instruct cmovDD_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regD dst, regD src) %{
13220   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13221   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13222   ins_cost(200);
13223   expand %{
13224     fcmovD_regS(cmp,flags,dst,src);
13225   %}
13226 %}
13227 
13228 instruct cmovFFPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regFPR dst, regFPR src) %{
13229   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13230   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13231   ins_cost(200);
13232   expand %{
13233     fcmovFPR_regS(cmp,flags,dst,src);
13234   %}
13235 %}
13236 
13237 
13238 instruct cmovFF_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regF dst, regF src) %{
13239   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13240   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13241   ins_cost(200);
13242   expand %{
13243     fcmovF_regS(cmp,flags,dst,src);
13244   %}
13245 %}
13246 
13247 
13248 // ============================================================================
13249 // Procedure Call/Return Instructions
13250 // Call Java Static Instruction
13251 // Note: If this code changes, the corresponding ret_addr_offset() and
13252 //       compute_padding() functions will have to be adjusted.
13253 instruct CallStaticJavaDirect(method meth) %{
13254   match(CallStaticJava);
13255   effect(USE meth);
13256 
13257   ins_cost(300);
13258   format %{ &quot;CALL,static &quot; %}
13259   opcode(0xE8); /* E8 cd */
13260   ins_encode( pre_call_resets,
13261               Java_Static_Call( meth ),
13262               call_epilog,
13263               post_call_FPU );
13264   ins_pipe( pipe_slow );
13265   ins_alignment(4);
13266 %}
13267 
13268 // Call Java Dynamic Instruction
13269 // Note: If this code changes, the corresponding ret_addr_offset() and
13270 //       compute_padding() functions will have to be adjusted.
13271 instruct CallDynamicJavaDirect(method meth) %{
13272   match(CallDynamicJava);
13273   effect(USE meth);
13274 
13275   ins_cost(300);
13276   format %{ &quot;MOV    EAX,(oop)-1\n\t&quot;
13277             &quot;CALL,dynamic&quot; %}
13278   opcode(0xE8); /* E8 cd */
13279   ins_encode( pre_call_resets,
13280               Java_Dynamic_Call( meth ),
13281               call_epilog,
13282               post_call_FPU );
13283   ins_pipe( pipe_slow );
13284   ins_alignment(4);
13285 %}
13286 
13287 // Call Runtime Instruction
13288 instruct CallRuntimeDirect(method meth) %{
13289   match(CallRuntime );
13290   effect(USE meth);
13291 
13292   ins_cost(300);
13293   format %{ &quot;CALL,runtime &quot; %}
13294   opcode(0xE8); /* E8 cd */
13295   // Use FFREEs to clear entries in float stack
13296   ins_encode( pre_call_resets,
13297               FFree_Float_Stack_All,
13298               Java_To_Runtime( meth ),
13299               post_call_FPU );
13300   ins_pipe( pipe_slow );
13301 %}
13302 
13303 // Call runtime without safepoint
13304 instruct CallLeafDirect(method meth) %{
13305   match(CallLeaf);
13306   effect(USE meth);
13307 
13308   ins_cost(300);
13309   format %{ &quot;CALL_LEAF,runtime &quot; %}
13310   opcode(0xE8); /* E8 cd */
13311   ins_encode( pre_call_resets,
13312               FFree_Float_Stack_All,
13313               Java_To_Runtime( meth ),
13314               Verify_FPU_For_Leaf, post_call_FPU );
13315   ins_pipe( pipe_slow );
13316 %}
13317 
13318 instruct CallLeafNoFPDirect(method meth) %{
13319   match(CallLeafNoFP);
13320   effect(USE meth);
13321 
13322   ins_cost(300);
13323   format %{ &quot;CALL_LEAF_NOFP,runtime &quot; %}
13324   opcode(0xE8); /* E8 cd */
13325   ins_encode(pre_call_resets, Java_To_Runtime(meth));
13326   ins_pipe( pipe_slow );
13327 %}
13328 
13329 
13330 // Return Instruction
13331 // Remove the return address &amp; jump to it.
13332 instruct Ret() %{
13333   match(Return);
13334   format %{ &quot;RET&quot; %}
13335   opcode(0xC3);
13336   ins_encode(OpcP);
13337   ins_pipe( pipe_jmp );
13338 %}
13339 
13340 // Tail Call; Jump from runtime stub to Java code.
13341 // Also known as an &#39;interprocedural jump&#39;.
13342 // Target of jump will eventually return to caller.
13343 // TailJump below removes the return address.
13344 instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_oop) %{
13345   match(TailCall jump_target method_oop );
13346   ins_cost(300);
13347   format %{ &quot;JMP    $jump_target \t# EBX holds method oop&quot; %}
13348   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13349   ins_encode( OpcP, RegOpc(jump_target) );
13350   ins_pipe( pipe_jmp );
13351 %}
13352 
13353 
13354 // Tail Jump; remove the return address; jump to target.
13355 // TailCall above leaves the return address around.
13356 instruct tailjmpInd(eRegP_no_EBP jump_target, eAXRegP ex_oop) %{
13357   match( TailJump jump_target ex_oop );
13358   ins_cost(300);
13359   format %{ &quot;POP    EDX\t# pop return address into dummy\n\t&quot;
13360             &quot;JMP    $jump_target &quot; %}
13361   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13362   ins_encode( enc_pop_rdx,
13363               OpcP, RegOpc(jump_target) );
13364   ins_pipe( pipe_jmp );
13365 %}
13366 
13367 // Create exception oop: created by stack-crawling runtime code.
13368 // Created exception is now available to this handler, and is setup
13369 // just prior to jumping to this handler.  No code emitted.
13370 instruct CreateException( eAXRegP ex_oop )
13371 %{
13372   match(Set ex_oop (CreateEx));
13373 
13374   size(0);
13375   // use the following format syntax
13376   format %{ &quot;# exception oop is in EAX; no code emitted&quot; %}
13377   ins_encode();
13378   ins_pipe( empty );
13379 %}
13380 
13381 
13382 // Rethrow exception:
13383 // The exception oop will come in the first argument position.
13384 // Then JUMP (not call) to the rethrow stub code.
13385 instruct RethrowException()
13386 %{
13387   match(Rethrow);
13388 
13389   // use the following format syntax
13390   format %{ &quot;JMP    rethrow_stub&quot; %}
13391   ins_encode(enc_rethrow);
13392   ins_pipe( pipe_jmp );
13393 %}
13394 
13395 // inlined locking and unlocking
13396 
13397 instruct cmpFastLockRTM(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eDXRegI scr, rRegI cx1, rRegI cx2) %{
13398   predicate(Compile::current()-&gt;use_rtm());
13399   match(Set cr (FastLock object box));
13400   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
13401   ins_cost(300);
13402   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
13403   ins_encode %{
13404     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13405                  $scr$$Register, $cx1$$Register, $cx2$$Register,
13406                  _counters, _rtm_counters, _stack_rtm_counters,
13407                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
13408                  true, ra_-&gt;C-&gt;profile_rtm());
13409   %}
13410   ins_pipe(pipe_slow);
13411 %}
13412 
13413 instruct cmpFastLock(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eRegP scr) %{
13414   predicate(!Compile::current()-&gt;use_rtm());
13415   match(Set cr (FastLock object box));
13416   effect(TEMP tmp, TEMP scr, USE_KILL box);
13417   ins_cost(300);
13418   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr&quot; %}
13419   ins_encode %{
13420     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13421                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13422   %}
13423   ins_pipe(pipe_slow);
13424 %}
13425 
13426 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13427   match(Set cr (FastUnlock object box));
13428   effect(TEMP tmp, USE_KILL box);
13429   ins_cost(300);
13430   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13431   ins_encode %{
13432     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13433   %}
13434   ins_pipe(pipe_slow);
13435 %}
13436 
13437 
13438 
13439 // ============================================================================
13440 // Safepoint Instruction
<a name="7" id="anc7"></a><span class="line-removed">13441 instruct safePoint_poll(eFlagsReg cr) %{</span>
<span class="line-removed">13442   predicate(SafepointMechanism::uses_global_page_poll());</span>
<span class="line-removed">13443   match(SafePoint);</span>
<span class="line-removed">13444   effect(KILL cr);</span>
<span class="line-removed">13445 </span>
<span class="line-removed">13446   // TODO-FIXME: we currently poll at offset 0 of the safepoint polling page.</span>
<span class="line-removed">13447   // On SPARC that might be acceptable as we can generate the address with</span>
<span class="line-removed">13448   // just a sethi, saving an or.  By polling at offset 0 we can end up</span>
<span class="line-removed">13449   // putting additional pressure on the index-0 in the D$.  Because of</span>
<span class="line-removed">13450   // alignment (just like the situation at hand) the lower indices tend</span>
<span class="line-removed">13451   // to see more traffic.  It&#39;d be better to change the polling address</span>
<span class="line-removed">13452   // to offset 0 of the last $line in the polling page.</span>
<span class="line-removed">13453 </span>
<span class="line-removed">13454   format %{ &quot;TSTL   #polladdr,EAX\t! Safepoint: poll for GC&quot; %}</span>
<span class="line-removed">13455   ins_cost(125);</span>
<span class="line-removed">13456   size(6) ;</span>
<span class="line-removed">13457   ins_encode( Safepoint_Poll() );</span>
<span class="line-removed">13458   ins_pipe( ialu_reg_mem );</span>
<span class="line-removed">13459 %}</span>
<span class="line-removed">13460 </span>
<span class="line-removed">13461 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{</span>
13462   predicate(SafepointMechanism::uses_thread_local_poll());
13463   match(SafePoint poll);
13464   effect(KILL cr, USE poll);
13465 
13466   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13467   ins_cost(125);
13468   // EBP would need size(3)
13469   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13470   ins_encode %{
13471     __ relocate(relocInfo::poll_type);
13472     address pre_pc = __ pc();
13473     __ testl(rax, Address($poll$$Register, 0));
13474     address post_pc = __ pc();
13475     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13476   %}
13477   ins_pipe(ialu_reg_mem);
13478 %}
13479 
13480 
13481 // ============================================================================
13482 // This name is KNOWN by the ADLC and cannot be changed.
13483 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
13484 // for this guy.
13485 instruct tlsLoadP(eRegP dst, eFlagsReg cr) %{
13486   match(Set dst (ThreadLocal));
13487   effect(DEF dst, KILL cr);
13488 
13489   format %{ &quot;MOV    $dst, Thread::current()&quot; %}
13490   ins_encode %{
13491     Register dstReg = as_Register($dst$$reg);
13492     __ get_thread(dstReg);
13493   %}
13494   ins_pipe( ialu_reg_fat );
13495 %}
13496 
13497 
13498 
13499 //----------PEEPHOLE RULES-----------------------------------------------------
13500 // These must follow all instruction definitions as they use the names
13501 // defined in the instructions definitions.
13502 //
13503 // peepmatch ( root_instr_name [preceding_instruction]* );
13504 //
13505 // peepconstraint %{
13506 // (instruction_number.operand_name relational_op instruction_number.operand_name
13507 //  [, ...] );
13508 // // instruction numbers are zero-based using left to right order in peepmatch
13509 //
13510 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
13511 // // provide an instruction_number.operand_name for each operand that appears
13512 // // in the replacement instruction&#39;s match rule
13513 //
13514 // ---------VM FLAGS---------------------------------------------------------
13515 //
13516 // All peephole optimizations can be turned off using -XX:-OptoPeephole
13517 //
13518 // Each peephole rule is given an identifying number starting with zero and
13519 // increasing by one in the order seen by the parser.  An individual peephole
13520 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
13521 // on the command-line.
13522 //
13523 // ---------CURRENT LIMITATIONS----------------------------------------------
13524 //
13525 // Only match adjacent instructions in same basic block
13526 // Only equality constraints
13527 // Only constraints between operands, not (0.dest_reg == EAX_enc)
13528 // Only one replacement instruction
13529 //
13530 // ---------EXAMPLE----------------------------------------------------------
13531 //
13532 // // pertinent parts of existing instructions in architecture description
13533 // instruct movI(rRegI dst, rRegI src) %{
13534 //   match(Set dst (CopyI src));
13535 // %}
13536 //
13537 // instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
13538 //   match(Set dst (AddI dst src));
13539 //   effect(KILL cr);
13540 // %}
13541 //
13542 // // Change (inc mov) to lea
13543 // peephole %{
13544 //   // increment preceeded by register-register move
13545 //   peepmatch ( incI_eReg movI );
13546 //   // require that the destination register of the increment
13547 //   // match the destination register of the move
13548 //   peepconstraint ( 0.dst == 1.dst );
13549 //   // construct a replacement instruction that sets
13550 //   // the destination to ( move&#39;s source register + one )
13551 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13552 // %}
13553 //
13554 // Implementation no longer uses movX instructions since
13555 // machine-independent system no longer uses CopyX nodes.
13556 //
13557 // peephole %{
13558 //   peepmatch ( incI_eReg movI );
13559 //   peepconstraint ( 0.dst == 1.dst );
13560 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13561 // %}
13562 //
13563 // peephole %{
13564 //   peepmatch ( decI_eReg movI );
13565 //   peepconstraint ( 0.dst == 1.dst );
13566 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13567 // %}
13568 //
13569 // peephole %{
13570 //   peepmatch ( addI_eReg_imm movI );
13571 //   peepconstraint ( 0.dst == 1.dst );
13572 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13573 // %}
13574 //
13575 // peephole %{
13576 //   peepmatch ( addP_eReg_imm movP );
13577 //   peepconstraint ( 0.dst == 1.dst );
13578 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
13579 // %}
13580 
13581 // // Change load of spilled value to only a spill
13582 // instruct storeI(memory mem, rRegI src) %{
13583 //   match(Set mem (StoreI mem src));
13584 // %}
13585 //
13586 // instruct loadI(rRegI dst, memory mem) %{
13587 //   match(Set dst (LoadI mem));
13588 // %}
13589 //
13590 peephole %{
13591   peepmatch ( loadI storeI );
13592   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13593   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
13594 %}
13595 
13596 //----------SMARTSPILL RULES---------------------------------------------------
13597 // These must follow all instruction definitions as they use the names
13598 // defined in the instructions definitions.
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
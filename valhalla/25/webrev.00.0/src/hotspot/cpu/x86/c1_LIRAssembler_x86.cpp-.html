<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;ci/ciValueKlass.hpp&quot;
  36 #include &quot;gc/shared/collectedHeap.hpp&quot;
  37 #include &quot;nativeInst_x86.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 #include &quot;vmreg_x86.inline.hpp&quot;
  45 
  46 
  47 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  48 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  49 // fast versions of NegF/NegD and AbsF/AbsD.
  50 
  51 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  52 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  53   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  54   // of 128-bits operands for SSE instructions.
  55   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  56   // Store the value to a 128-bits operand.
  57   operand[0] = lo;
  58   operand[1] = hi;
  59   return operand;
  60 }
  61 
  62 // Buffer for 128-bits masks used by SSE instructions.
  63 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  64 
  65 // Static initialization during VM startup.
  66 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  67 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  68 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  69 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  70 
  71 
  72 NEEDS_CLEANUP // remove this definitions ?
  73 const Register IC_Klass    = rax;   // where the IC klass is cached
  74 const Register SYNC_header = rax;   // synchronization header
  75 const Register SHIFT_count = rcx;   // where count for shift operations must be
  76 
  77 #define __ _masm-&gt;
  78 
  79 
  80 static void select_different_registers(Register preserve,
  81                                        Register extra,
  82                                        Register &amp;tmp1,
  83                                        Register &amp;tmp2) {
  84   if (tmp1 == preserve) {
  85     assert_different_registers(tmp1, tmp2, extra);
  86     tmp1 = extra;
  87   } else if (tmp2 == preserve) {
  88     assert_different_registers(tmp1, tmp2, extra);
  89     tmp2 = extra;
  90   }
  91   assert_different_registers(preserve, tmp1, tmp2);
  92 }
  93 
  94 
  95 
  96 static void select_different_registers(Register preserve,
  97                                        Register extra,
  98                                        Register &amp;tmp1,
  99                                        Register &amp;tmp2,
 100                                        Register &amp;tmp3) {
 101   if (tmp1 == preserve) {
 102     assert_different_registers(tmp1, tmp2, tmp3, extra);
 103     tmp1 = extra;
 104   } else if (tmp2 == preserve) {
 105     assert_different_registers(tmp1, tmp2, tmp3, extra);
 106     tmp2 = extra;
 107   } else if (tmp3 == preserve) {
 108     assert_different_registers(tmp1, tmp2, tmp3, extra);
 109     tmp3 = extra;
 110   }
 111   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 112 }
 113 
 114 
 115 
 116 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 117   if (opr-&gt;is_constant()) {
 118     LIR_Const* constant = opr-&gt;as_constant_ptr();
 119     switch (constant-&gt;type()) {
 120       case T_INT: {
 121         return true;
 122       }
 123 
 124       default:
 125         return false;
 126     }
 127   }
 128   return false;
 129 }
 130 
 131 
 132 LIR_Opr LIR_Assembler::receiverOpr() {
 133   return FrameMap::receiver_opr;
 134 }
 135 
 136 LIR_Opr LIR_Assembler::osrBufferPointer() {
 137   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 138 }
 139 
 140 //--------------fpu register translations-----------------------
 141 
 142 
 143 address LIR_Assembler::float_constant(float f) {
 144   address const_addr = __ float_constant(f);
 145   if (const_addr == NULL) {
 146     bailout(&quot;const section overflow&quot;);
 147     return __ code()-&gt;consts()-&gt;start();
 148   } else {
 149     return const_addr;
 150   }
 151 }
 152 
 153 
 154 address LIR_Assembler::double_constant(double d) {
 155   address const_addr = __ double_constant(d);
 156   if (const_addr == NULL) {
 157     bailout(&quot;const section overflow&quot;);
 158     return __ code()-&gt;consts()-&gt;start();
 159   } else {
 160     return const_addr;
 161   }
 162 }
 163 
 164 #ifndef _LP64
 165 void LIR_Assembler::fpop() {
 166   __ fpop();
 167 }
 168 
 169 void LIR_Assembler::fxch(int i) {
 170   __ fxch(i);
 171 }
 172 
 173 void LIR_Assembler::fld(int i) {
 174   __ fld_s(i);
 175 }
 176 
 177 void LIR_Assembler::ffree(int i) {
 178   __ ffree(i);
 179 }
 180 #endif // !_LP64
 181 
 182 void LIR_Assembler::breakpoint() {
 183   __ int3();
 184 }
 185 
 186 void LIR_Assembler::push(LIR_Opr opr) {
 187   if (opr-&gt;is_single_cpu()) {
 188     __ push_reg(opr-&gt;as_register());
 189   } else if (opr-&gt;is_double_cpu()) {
 190     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 191     __ push_reg(opr-&gt;as_register_lo());
 192   } else if (opr-&gt;is_stack()) {
 193     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 194   } else if (opr-&gt;is_constant()) {
 195     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
 196     if (const_opr-&gt;type() == T_OBJECT || const_opr-&gt;type() == T_VALUETYPE) {
 197       __ push_oop(const_opr-&gt;as_jobject());
 198     } else if (const_opr-&gt;type() == T_INT) {
 199       __ push_jint(const_opr-&gt;as_jint());
 200     } else {
 201       ShouldNotReachHere();
 202     }
 203 
 204   } else {
 205     ShouldNotReachHere();
 206   }
 207 }
 208 
 209 void LIR_Assembler::pop(LIR_Opr opr) {
 210   if (opr-&gt;is_single_cpu()) {
 211     __ pop_reg(opr-&gt;as_register());
 212   } else {
 213     ShouldNotReachHere();
 214   }
 215 }
 216 
 217 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 218   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 219 }
 220 
 221 //-------------------------------------------
 222 
 223 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 224   return as_Address(addr, rscratch1);
 225 }
 226 
 227 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 228   if (addr-&gt;base()-&gt;is_illegal()) {
 229     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 230     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 231     if (! __ reachable(laddr)) {
 232       __ movptr(tmp, laddr.addr());
 233       Address res(tmp, 0);
 234       return res;
 235     } else {
 236       return __ as_Address(laddr);
 237     }
 238   }
 239 
 240   Register base = addr-&gt;base()-&gt;as_pointer_register();
 241 
 242   if (addr-&gt;index()-&gt;is_illegal()) {
 243     return Address( base, addr-&gt;disp());
 244   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 245     Register index = addr-&gt;index()-&gt;as_pointer_register();
 246     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 247   } else if (addr-&gt;index()-&gt;is_constant()) {
 248     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 249     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 250 
 251     return Address(base, addr_offset);
 252   } else {
 253     Unimplemented();
 254     return Address();
 255   }
 256 }
 257 
 258 
 259 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 260   Address base = as_Address(addr);
 261   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 262 }
 263 
 264 
 265 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 266   return as_Address(addr);
 267 }
 268 
 269 
 270 void LIR_Assembler::osr_entry() {
 271   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 272   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 273   ValueStack* entry_state = osr_entry-&gt;state();
 274   int number_of_locks = entry_state-&gt;locks_size();
 275 
 276   // we jump here if osr happens with the interpreter
 277   // state set up to continue at the beginning of the
 278   // loop that triggered osr - in particular, we have
 279   // the following registers setup:
 280   //
 281   // rcx: osr buffer
 282   //
 283 
 284   // build frame
 285   ciMethod* m = compilation()-&gt;method();
 286   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 287 
 288   // OSR buffer is
 289   //
 290   // locals[nlocals-1..0]
 291   // monitors[0..number_of_locks]
 292   //
 293   // locals is a direct copy of the interpreter frame so in the osr buffer
 294   // so first slot in the local array is the last local from the interpreter
 295   // and last slot is local[0] (receiver) from the interpreter
 296   //
 297   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 298   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 299   // in the interpreter frame (the method lock if a sync method)
 300 
 301   // Initialize monitors in the compiled activation.
 302   //   rcx: pointer to osr buffer
 303   //
 304   // All other registers are dead at this point and the locals will be
 305   // copied into place by code emitted in the IR.
 306 
 307   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 308   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 309     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 310       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 311     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 312     // the OSR buffer using 2 word entries: first the lock and then
 313     // the oop.
 314     for (int i = 0; i &lt; number_of_locks; i++) {
 315       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 316 #ifdef ASSERT
 317       // verify the interpreter&#39;s monitor has a non-null object
 318       {
 319         Label L;
 320         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 321         __ jcc(Assembler::notZero, L);
 322         __ stop(&quot;locked object is NULL&quot;);
 323         __ bind(L);
 324       }
 325 #endif
 326       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 327       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 328       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 329       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 330     }
 331   }
 332 }
 333 
 334 
 335 // inline cache check; done before the frame is built.
 336 int LIR_Assembler::check_icache() {
 337   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 338   Register ic_klass = IC_Klass;
 339   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 340   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 341   if (!do_post_padding) {
 342     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 343     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 344   }
 345   int offset = __ offset();
 346   __ inline_cache_check(receiver, IC_Klass);
 347   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 348   if (do_post_padding) {
 349     // force alignment after the cache check.
 350     // It&#39;s been verified to be aligned if !VerifyOops
 351     __ align(CodeEntryAlignment);
 352   }
 353   return offset;
 354 }
 355 
 356 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 357   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 358   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 359 
 360   Label L_skip_barrier;
 361   Register klass = rscratch1;
 362   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );
 363   assert(thread != noreg, &quot;x86_32 not implemented&quot;);
 364 
 365   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());
 366   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);
 367 
 368   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 369 
 370   __ bind(L_skip_barrier);
 371 }
 372 
 373 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 374   jobject o = NULL;
 375   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 376   __ movoop(reg, o);
 377   patching_epilog(patch, lir_patch_normal, reg, info);
 378 }
 379 
 380 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 381   Metadata* o = NULL;
 382   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 383   __ mov_metadata(reg, o);
 384   patching_epilog(patch, lir_patch_normal, reg, info);
 385 }
 386 
 387 // This specifies the rsp decrement needed to build the frame
 388 int LIR_Assembler::initial_frame_size_in_bytes() const {
 389   // if rounding, must let FrameMap know!
 390 
 391   // The frame_map records size in slots (32bit word)
 392 
 393   // subtract two words to account for return address and link
 394   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 395 }
 396 
 397 
 398 int LIR_Assembler::emit_exception_handler() {
 399   // if the last instruction is a call (typically to do a throw which
 400   // is coming at the end after block reordering) the return address
 401   // must still point into the code area in order to avoid assertion
 402   // failures when searching for the corresponding bci =&gt; add a nop
 403   // (was bug 5/14/1999 - gri)
 404   __ nop();
 405 
 406   // generate code for exception handler
 407   address handler_base = __ start_a_stub(exception_handler_size());
 408   if (handler_base == NULL) {
 409     // not enough space left for the handler
 410     bailout(&quot;exception handler overflow&quot;);
 411     return -1;
 412   }
 413 
 414   int offset = code_offset();
 415 
 416   // the exception oop and pc are in rax, and rdx
 417   // no other registers need to be preserved, so invalidate them
 418   __ invalidate_registers(false, true, true, false, true, true);
 419 
 420   // check that there is really an exception
 421   __ verify_not_null_oop(rax);
 422 
 423   // search an exception handler (rax: exception oop, rdx: throwing pc)
 424   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 425   __ should_not_reach_here();
 426   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 427   __ end_a_stub();
 428 
 429   return offset;
 430 }
 431 
 432 
 433 // Emit the code to remove the frame from the stack in the exception
 434 // unwind path.
 435 int LIR_Assembler::emit_unwind_handler() {
 436 #ifndef PRODUCT
 437   if (CommentedAssembly) {
 438     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 439   }
 440 #endif
 441 
 442   int offset = code_offset();
 443 
 444   // Fetch the exception from TLS and clear out exception related thread state
 445   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 446   NOT_LP64(__ get_thread(rsi));
 447   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 448   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 449   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 450 
 451   __ bind(_unwind_handler_entry);
 452   __ verify_not_null_oop(rax);
 453   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 454     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 455   }
 456 
 457   // Preform needed unlocking
 458   MonitorExitStub* stub = NULL;
 459   if (method()-&gt;is_synchronized()) {
 460     monitor_address(0, FrameMap::rax_opr);
 461     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 462     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 463     __ bind(*stub-&gt;continuation());
 464   }
 465 
 466   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 467 #ifdef _LP64
 468     __ mov(rdi, r15_thread);
 469     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 470 #else
 471     __ get_thread(rax);
 472     __ movptr(Address(rsp, 0), rax);
 473     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 474 #endif
 475     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 476   }
 477 
 478   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 479     __ mov(rax, rbx);  // Restore the exception
 480   }
 481 
 482   // remove the activation and dispatch to the unwind handler
 483   int initial_framesize = initial_frame_size_in_bytes();
 484   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);
 485   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 486 
 487   // Emit the slow path assembly
 488   if (stub != NULL) {
 489     stub-&gt;emit_code(this);
 490   }
 491 
 492   return offset;
 493 }
 494 
 495 
 496 int LIR_Assembler::emit_deopt_handler() {
 497   // if the last instruction is a call (typically to do a throw which
 498   // is coming at the end after block reordering) the return address
 499   // must still point into the code area in order to avoid assertion
 500   // failures when searching for the corresponding bci =&gt; add a nop
 501   // (was bug 5/14/1999 - gri)
 502   __ nop();
 503 
 504   // generate code for exception handler
 505   address handler_base = __ start_a_stub(deopt_handler_size());
 506   if (handler_base == NULL) {
 507     // not enough space left for the handler
 508     bailout(&quot;deopt handler overflow&quot;);
 509     return -1;
 510   }
 511 
 512   int offset = code_offset();
 513   InternalAddress here(__ pc());
 514 
 515   __ pushptr(here.addr());
 516   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 517   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 518   __ end_a_stub();
 519 
 520   return offset;
 521 }
 522 
 523 
 524 void LIR_Assembler::return_op(LIR_Opr result) {
 525   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 526   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 527     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 528   }
 529 
 530   ciMethod* method = compilation()-&gt;method();
 531   if (ValueTypeReturnedAsFields &amp;&amp; method-&gt;signature()-&gt;returns_never_null()) {
 532     ciType* return_type = method-&gt;return_type();
 533     if (return_type-&gt;is_valuetype()) {
 534       ciValueKlass* vk = return_type-&gt;as_value_klass();
 535       if (vk-&gt;can_be_returned_as_fields()) {
 536 #ifndef _LP64
 537         Unimplemented();
 538 #else
 539         address unpack_handler = vk-&gt;unpack_handler();
 540         assert(unpack_handler != NULL, &quot;must be&quot;);
 541         __ call(RuntimeAddress(unpack_handler));
 542         // At this point, rax points to the value object (for interpreter or C1 caller).
 543         // The fields of the object are copied into registers (for C2 caller).
 544 #endif
 545       }
 546     }
 547   }
 548 
 549   // Pop the stack before the safepoint code
 550   int initial_framesize = initial_frame_size_in_bytes();
 551   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);
 552 
 553   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 554     __ reserved_stack_check();
 555   }
 556 
 557   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 558 
 559   // Note: we do not need to round double result; float result has the right precision
 560   // the poll sets the condition code, but no data registers
 561 
 562   if (SafepointMechanism::uses_thread_local_poll()) {
 563 #ifdef _LP64
 564     const Register poll_addr = rscratch1;
 565     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 566 #else
 567     const Register poll_addr = rbx;
 568     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 569     __ get_thread(poll_addr);
 570     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 571 #endif
 572     __ relocate(relocInfo::poll_return_type);
 573     __ testl(rax, Address(poll_addr, 0));
 574   } else {
 575     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 576 
 577     if (Assembler::is_polling_page_far()) {
 578       __ lea(rscratch1, polling_page);
 579       __ relocate(relocInfo::poll_return_type);
 580       __ testl(rax, Address(rscratch1, 0));
 581     } else {
 582       __ testl(rax, polling_page);
 583     }
 584   }
 585   __ ret(0);
 586 }
 587 
 588 
 589 int LIR_Assembler::store_value_type_fields_to_buf(ciValueKlass* vk) {
 590   return (__ store_value_type_fields_to_buf(vk, false));
 591 }
 592 
 593 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 594   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 595   int offset = __ offset();
 596   if (SafepointMechanism::uses_thread_local_poll()) {
 597 #ifdef _LP64
 598     const Register poll_addr = rscratch1;
 599     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 600 #else
 601     assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);
 602     const Register poll_addr = tmp-&gt;as_register();
 603     __ get_thread(poll_addr);
 604     __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));
 605 #endif
 606     add_debug_info_for_branch(info);
 607     __ relocate(relocInfo::poll_type);
 608     address pre_pc = __ pc();
 609     __ testl(rax, Address(poll_addr, 0));
 610     address post_pc = __ pc();
 611     guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);
 612   } else {
 613     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_type);
 614     if (Assembler::is_polling_page_far()) {
 615       __ lea(rscratch1, polling_page);
 616       offset = __ offset();
 617       add_debug_info_for_branch(info);
 618       __ relocate(relocInfo::poll_type);
 619       __ testl(rax, Address(rscratch1, 0));
 620     } else {
 621       add_debug_info_for_branch(info);
 622       __ testl(rax, polling_page);
 623     }
 624   }
 625   return offset;
 626 }
 627 
 628 
 629 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 630   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 631 }
 632 
 633 void LIR_Assembler::swap_reg(Register a, Register b) {
 634   __ xchgptr(a, b);
 635 }
 636 
 637 
 638 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 639   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 640   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 641   LIR_Const* c = src-&gt;as_constant_ptr();
 642 
 643   switch (c-&gt;type()) {
 644     case T_INT: {
 645       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 646       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 647       break;
 648     }
 649 
 650     case T_ADDRESS: {
 651       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 652       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 653       break;
 654     }
 655 
 656     case T_LONG: {
 657       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 658 #ifdef _LP64
 659       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 660 #else
 661       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 662       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 663 #endif // _LP64
 664       break;
 665     }
 666 
 667     case T_VALUETYPE: // Fall through
 668     case T_OBJECT: {
 669       if (patch_code != lir_patch_none) {
 670         jobject2reg_with_patching(dest-&gt;as_register(), info);
 671       } else {
 672         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 673       }
 674       break;
 675     }
 676 
 677     case T_METADATA: {
 678       if (patch_code != lir_patch_none) {
 679         klass2reg_with_patching(dest-&gt;as_register(), info);
 680       } else {
 681         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 682       }
 683       break;
 684     }
 685 
 686     case T_FLOAT: {
 687       if (dest-&gt;is_single_xmm()) {
 688         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 689           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 690         } else {
 691           __ movflt(dest-&gt;as_xmm_float_reg(),
 692                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 693         }
 694       } else {
 695 #ifndef _LP64
 696         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 697         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 698         if (c-&gt;is_zero_float()) {
 699           __ fldz();
 700         } else if (c-&gt;is_one_float()) {
 701           __ fld1();
 702         } else {
 703           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 704         }
 705 #else
 706         ShouldNotReachHere();
 707 #endif // !_LP64
 708       }
 709       break;
 710     }
 711 
 712     case T_DOUBLE: {
 713       if (dest-&gt;is_double_xmm()) {
 714         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 715           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 716         } else {
 717           __ movdbl(dest-&gt;as_xmm_double_reg(),
 718                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 719         }
 720       } else {
 721 #ifndef _LP64
 722         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 723         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 724         if (c-&gt;is_zero_double()) {
 725           __ fldz();
 726         } else if (c-&gt;is_one_double()) {
 727           __ fld1();
 728         } else {
 729           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 730         }
 731 #else
 732         ShouldNotReachHere();
 733 #endif // !_LP64
 734       }
 735       break;
 736     }
 737 
 738     default:
 739       ShouldNotReachHere();
 740   }
 741 }
 742 
 743 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 744   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 745   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 746   LIR_Const* c = src-&gt;as_constant_ptr();
 747 
 748   switch (c-&gt;type()) {
 749     case T_INT:  // fall through
 750     case T_FLOAT:
 751       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 752       break;
 753 
 754     case T_ADDRESS:
 755       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 756       break;
 757 
 758     case T_VALUETYPE: // Fall through
 759     case T_OBJECT:
 760       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 761       break;
 762 
 763     case T_LONG:  // fall through
 764     case T_DOUBLE:
 765 #ifdef _LP64
 766       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 767                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 768 #else
 769       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 770                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 771       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 772                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 773 #endif // _LP64
 774       break;
 775 
 776     default:
 777       ShouldNotReachHere();
 778   }
 779 }
 780 
 781 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 782   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 783   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 784   LIR_Const* c = src-&gt;as_constant_ptr();
 785   LIR_Address* addr = dest-&gt;as_address_ptr();
 786 
 787   int null_check_here = code_offset();
 788   switch (type) {
 789     case T_INT:    // fall through
 790     case T_FLOAT:
 791       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 792       break;
 793 
 794     case T_ADDRESS:
 795       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 796       break;
 797 
 798     case T_VALUETYPE: // fall through
 799     case T_OBJECT:  // fall through
 800     case T_ARRAY:
 801       if (c-&gt;as_jobject() == NULL) {
 802         if (UseCompressedOops &amp;&amp; !wide) {
 803           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 804         } else {
 805 #ifdef _LP64
 806           __ xorptr(rscratch1, rscratch1);
 807           null_check_here = code_offset();
 808           __ movptr(as_Address(addr), rscratch1);
 809 #else
 810           __ movptr(as_Address(addr), NULL_WORD);
 811 #endif
 812         }
 813       } else {
 814         if (is_literal_address(addr)) {
 815           ShouldNotReachHere();
 816           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 817         } else {
 818 #ifdef _LP64
 819           __ movoop(rscratch1, c-&gt;as_jobject());
 820           if (UseCompressedOops &amp;&amp; !wide) {
 821             __ encode_heap_oop(rscratch1);
 822             null_check_here = code_offset();
 823             __ movl(as_Address_lo(addr), rscratch1);
 824           } else {
 825             null_check_here = code_offset();
 826             __ movptr(as_Address_lo(addr), rscratch1);
 827           }
 828 #else
 829           __ movoop(as_Address(addr), c-&gt;as_jobject());
 830 #endif
 831         }
 832       }
 833       break;
 834 
 835     case T_LONG:    // fall through
 836     case T_DOUBLE:
 837 #ifdef _LP64
 838       if (is_literal_address(addr)) {
 839         ShouldNotReachHere();
 840         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 841       } else {
 842         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 843         null_check_here = code_offset();
 844         __ movptr(as_Address_lo(addr), r10);
 845       }
 846 #else
 847       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 848       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 849       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 850 #endif // _LP64
 851       break;
 852 
 853     case T_BOOLEAN: // fall through
 854     case T_BYTE:
 855       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 856       break;
 857 
 858     case T_CHAR:    // fall through
 859     case T_SHORT:
 860       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 861       break;
 862 
 863     default:
 864       ShouldNotReachHere();
 865   };
 866 
 867   if (info != NULL) {
 868     add_debug_info_for_null_check(null_check_here, info);
 869   }
 870 }
 871 
 872 
 873 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 874   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 875   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 876 
 877   // move between cpu-registers
 878   if (dest-&gt;is_single_cpu()) {
 879 #ifdef _LP64
 880     if (src-&gt;type() == T_LONG) {
 881       // Can do LONG -&gt; OBJECT
 882       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 883       return;
 884     }
 885 #endif
 886     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 887     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_VALUETYPE) {
 888       __ verify_oop(src-&gt;as_register());
 889     }
 890     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 891 
 892   } else if (dest-&gt;is_double_cpu()) {
 893 #ifdef _LP64
 894     if (is_reference_type(src-&gt;type())) {
 895       // Surprising to me but we can see move of a long to t_object
 896       __ verify_oop(src-&gt;as_register());
 897       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 898       return;
 899     }
 900 #endif
 901     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 902     Register f_lo = src-&gt;as_register_lo();
 903     Register f_hi = src-&gt;as_register_hi();
 904     Register t_lo = dest-&gt;as_register_lo();
 905     Register t_hi = dest-&gt;as_register_hi();
 906 #ifdef _LP64
 907     assert(f_hi == f_lo, &quot;must be same&quot;);
 908     assert(t_hi == t_lo, &quot;must be same&quot;);
 909     move_regs(f_lo, t_lo);
 910 #else
 911     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 912 
 913 
 914     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 915       swap_reg(f_lo, f_hi);
 916     } else if (f_hi == t_lo) {
 917       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 918       move_regs(f_hi, t_hi);
 919       move_regs(f_lo, t_lo);
 920     } else {
 921       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 922       move_regs(f_lo, t_lo);
 923       move_regs(f_hi, t_hi);
 924     }
 925 #endif // LP64
 926 
 927 #ifndef _LP64
 928     // special moves from fpu-register to xmm-register
 929     // necessary for method results
 930   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 931     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 932     __ fld_s(Address(rsp, 0));
 933   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 934     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 935     __ fld_d(Address(rsp, 0));
 936   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 937     __ fstp_s(Address(rsp, 0));
 938     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 939   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 940     __ fstp_d(Address(rsp, 0));
 941     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 942 #endif // !_LP64
 943 
 944     // move between xmm-registers
 945   } else if (dest-&gt;is_single_xmm()) {
 946     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 947     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 948   } else if (dest-&gt;is_double_xmm()) {
 949     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 950     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 951 
 952 #ifndef _LP64
 953     // move between fpu-registers (no instruction necessary because of fpu-stack)
 954   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 955     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 956     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 957 #endif // !_LP64
 958 
 959   } else {
 960     ShouldNotReachHere();
 961   }
 962 }
 963 
 964 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 965   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 966   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 967 
 968   if (src-&gt;is_single_cpu()) {
 969     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 970     if (is_reference_type(type)) {
 971       __ verify_oop(src-&gt;as_register());
 972       __ movptr (dst, src-&gt;as_register());
 973     } else if (type == T_METADATA || type == T_ADDRESS) {
 974       __ movptr (dst, src-&gt;as_register());
 975     } else {
 976       __ movl (dst, src-&gt;as_register());
 977     }
 978 
 979   } else if (src-&gt;is_double_cpu()) {
 980     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 981     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 982     __ movptr (dstLO, src-&gt;as_register_lo());
 983     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 984 
 985   } else if (src-&gt;is_single_xmm()) {
 986     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 987     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 988 
 989   } else if (src-&gt;is_double_xmm()) {
 990     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 991     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 992 
 993 #ifndef _LP64
 994   } else if (src-&gt;is_single_fpu()) {
 995     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 996     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 997     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 998     else                   __ fst_s  (dst_addr);
 999 
1000   } else if (src-&gt;is_double_fpu()) {
1001     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1002     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1003     if (pop_fpu_stack)     __ fstp_d (dst_addr);
1004     else                   __ fst_d  (dst_addr);
1005 #endif // !_LP64
1006 
1007   } else {
1008     ShouldNotReachHere();
1009   }
1010 }
1011 
1012 
1013 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
1014   LIR_Address* to_addr = dest-&gt;as_address_ptr();
1015   PatchingStub* patch = NULL;
1016   Register compressed_src = rscratch1;
1017 
1018   if (is_reference_type(type)) {
1019     __ verify_oop(src-&gt;as_register());
1020 #ifdef _LP64
1021     if (UseCompressedOops &amp;&amp; !wide) {
1022       __ movptr(compressed_src, src-&gt;as_register());
1023       __ encode_heap_oop(compressed_src);
1024       if (patch_code != lir_patch_none) {
1025         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
1026       }
1027     }
1028 #endif
1029   }
1030 
1031   if (patch_code != lir_patch_none) {
1032     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1033     Address toa = as_Address(to_addr);
1034     assert(toa.disp() != 0, &quot;must have&quot;);
1035   }
1036 
1037   int null_check_here = code_offset();
1038   switch (type) {
1039     case T_FLOAT: {
1040 #ifdef _LP64
1041       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);
1042       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1043 #else
1044       if (src-&gt;is_single_xmm()) {
1045         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1046       } else {
1047         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
1048         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
1049         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
1050         else                    __ fst_s (as_Address(to_addr));
1051       }
1052 #endif // _LP64
1053       break;
1054     }
1055 
1056     case T_DOUBLE: {
1057 #ifdef _LP64
1058       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);
1059       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1060 #else
1061       if (src-&gt;is_double_xmm()) {
1062         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1063       } else {
1064         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1065         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1066         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1067         else                    __ fst_d (as_Address(to_addr));
1068       }
1069 #endif // _LP64
1070       break;
1071     }
1072 
1073     case T_VALUETYPE: // fall through
1074     case T_ARRAY:   // fall through
1075     case T_OBJECT:  // fall through
1076       if (UseCompressedOops &amp;&amp; !wide) {
1077         __ movl(as_Address(to_addr), compressed_src);
1078       } else {
1079         __ movptr(as_Address(to_addr), src-&gt;as_register());
1080       }
1081       break;
1082     case T_METADATA:
1083       // We get here to store a method pointer to the stack to pass to
1084       // a dtrace runtime call. This can&#39;t work on 64 bit with
1085       // compressed klass ptrs: T_METADATA can be a compressed klass
1086       // ptr or a 64 bit method pointer.
1087       LP64_ONLY(ShouldNotReachHere());
1088       __ movptr(as_Address(to_addr), src-&gt;as_register());
1089       break;
1090     case T_ADDRESS:
1091       __ movptr(as_Address(to_addr), src-&gt;as_register());
1092       break;
1093     case T_INT:
1094       __ movl(as_Address(to_addr), src-&gt;as_register());
1095       break;
1096 
1097     case T_LONG: {
1098       Register from_lo = src-&gt;as_register_lo();
1099       Register from_hi = src-&gt;as_register_hi();
1100 #ifdef _LP64
1101       __ movptr(as_Address_lo(to_addr), from_lo);
1102 #else
1103       Register base = to_addr-&gt;base()-&gt;as_register();
1104       Register index = noreg;
1105       if (to_addr-&gt;index()-&gt;is_register()) {
1106         index = to_addr-&gt;index()-&gt;as_register();
1107       }
1108       if (base == from_lo || index == from_lo) {
1109         assert(base != from_hi, &quot;can&#39;t be&quot;);
1110         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1111         __ movl(as_Address_hi(to_addr), from_hi);
1112         if (patch != NULL) {
1113           patching_epilog(patch, lir_patch_high, base, info);
1114           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1115           patch_code = lir_patch_low;
1116         }
1117         __ movl(as_Address_lo(to_addr), from_lo);
1118       } else {
1119         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1120         __ movl(as_Address_lo(to_addr), from_lo);
1121         if (patch != NULL) {
1122           patching_epilog(patch, lir_patch_low, base, info);
1123           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1124           patch_code = lir_patch_high;
1125         }
1126         __ movl(as_Address_hi(to_addr), from_hi);
1127       }
1128 #endif // _LP64
1129       break;
1130     }
1131 
1132     case T_BYTE:    // fall through
1133     case T_BOOLEAN: {
1134       Register src_reg = src-&gt;as_register();
1135       Address dst_addr = as_Address(to_addr);
1136       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1137       __ movb(dst_addr, src_reg);
1138       break;
1139     }
1140 
1141     case T_CHAR:    // fall through
1142     case T_SHORT:
1143       __ movw(as_Address(to_addr), src-&gt;as_register());
1144       break;
1145 
1146     default:
1147       ShouldNotReachHere();
1148   }
1149   if (info != NULL) {
1150     add_debug_info_for_null_check(null_check_here, info);
1151   }
1152 
1153   if (patch_code != lir_patch_none) {
1154     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1155   }
1156 }
1157 
1158 
1159 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1160   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1161   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1162 
1163   if (dest-&gt;is_single_cpu()) {
1164     if (is_reference_type(type)) {
1165       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1166       __ verify_oop(dest-&gt;as_register());
1167     } else if (type == T_METADATA || type == T_ADDRESS) {
1168       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1169     } else {
1170       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1171     }
1172 
1173   } else if (dest-&gt;is_double_cpu()) {
1174     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1175     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1176     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1177     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1178 
1179   } else if (dest-&gt;is_single_xmm()) {
1180     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1181     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1182 
1183   } else if (dest-&gt;is_double_xmm()) {
1184     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1185     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1186 
1187 #ifndef _LP64
1188   } else if (dest-&gt;is_single_fpu()) {
1189     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1190     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1191     __ fld_s(src_addr);
1192 
1193   } else if (dest-&gt;is_double_fpu()) {
1194     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1195     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1196     __ fld_d(src_addr);
1197 #endif // _LP64
1198 
1199   } else {
1200     ShouldNotReachHere();
1201   }
1202 }
1203 
1204 
1205 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1206   if (src-&gt;is_single_stack()) {
1207     if (is_reference_type(type)) {
1208       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1209       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1210     } else {
1211 #ifndef _LP64
1212       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1213       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1214 #else
1215       //no pushl on 64bits
1216       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1217       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1218 #endif
1219     }
1220 
1221   } else if (src-&gt;is_double_stack()) {
1222 #ifdef _LP64
1223     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1224     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1225 #else
1226     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1227     // push and pop the part at src + wordSize, adding wordSize for the previous push
1228     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1229     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1230     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1231 #endif // _LP64
1232 
1233   } else {
1234     ShouldNotReachHere();
1235   }
1236 }
1237 
1238 
1239 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1240   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1241   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1242 
1243   LIR_Address* addr = src-&gt;as_address_ptr();
1244   Address from_addr = as_Address(addr);
1245 
1246   if (addr-&gt;base()-&gt;type() == T_OBJECT || addr-&gt;base()-&gt;type() == T_VALUETYPE) {
1247     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1248   }
1249 
1250   switch (type) {
1251     case T_BOOLEAN: // fall through
1252     case T_BYTE:    // fall through
1253     case T_CHAR:    // fall through
1254     case T_SHORT:
1255       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1256         // on pre P6 processors we may get partial register stalls
1257         // so blow away the value of to_rinfo before loading a
1258         // partial word into it.  Do it here so that it precedes
1259         // the potential patch point below.
1260         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1261       }
1262       break;
1263    default:
1264      break;
1265   }
1266 
1267   PatchingStub* patch = NULL;
1268   if (patch_code != lir_patch_none) {
1269     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1270     assert(from_addr.disp() != 0, &quot;must have&quot;);
1271   }
1272   if (info != NULL) {
1273     add_debug_info_for_null_check_here(info);
1274   }
1275 
1276   switch (type) {
1277     case T_FLOAT: {
1278       if (dest-&gt;is_single_xmm()) {
1279         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1280       } else {
1281 #ifndef _LP64
1282         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1283         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1284         __ fld_s(from_addr);
1285 #else
1286         ShouldNotReachHere();
1287 #endif // !LP64
1288       }
1289       break;
1290     }
1291 
1292     case T_DOUBLE: {
1293       if (dest-&gt;is_double_xmm()) {
1294         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1295       } else {
1296 #ifndef _LP64
1297         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1298         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1299         __ fld_d(from_addr);
1300 #else
1301         ShouldNotReachHere();
1302 #endif // !LP64
1303       }
1304       break;
1305     }
1306 
1307     case T_VALUETYPE: // fall through
1308     case T_OBJECT:  // fall through
1309     case T_ARRAY:   // fall through
1310       if (UseCompressedOops &amp;&amp; !wide) {
1311         __ movl(dest-&gt;as_register(), from_addr);
1312       } else {
1313         __ movptr(dest-&gt;as_register(), from_addr);
1314       }
1315       break;
1316 
1317     case T_ADDRESS:
1318       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1319         __ movl(dest-&gt;as_register(), from_addr);
1320       } else {
1321         __ movptr(dest-&gt;as_register(), from_addr);
1322       }
1323       break;
1324     case T_INT:
1325       __ movl(dest-&gt;as_register(), from_addr);
1326       break;
1327 
1328     case T_LONG: {
1329       Register to_lo = dest-&gt;as_register_lo();
1330       Register to_hi = dest-&gt;as_register_hi();
1331 #ifdef _LP64
1332       __ movptr(to_lo, as_Address_lo(addr));
1333 #else
1334       Register base = addr-&gt;base()-&gt;as_register();
1335       Register index = noreg;
1336       if (addr-&gt;index()-&gt;is_register()) {
1337         index = addr-&gt;index()-&gt;as_register();
1338       }
1339       if ((base == to_lo &amp;&amp; index == to_hi) ||
1340           (base == to_hi &amp;&amp; index == to_lo)) {
1341         // addresses with 2 registers are only formed as a result of
1342         // array access so this code will never have to deal with
1343         // patches or null checks.
1344         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1345         __ lea(to_hi, as_Address(addr));
1346         __ movl(to_lo, Address(to_hi, 0));
1347         __ movl(to_hi, Address(to_hi, BytesPerWord));
1348       } else if (base == to_lo || index == to_lo) {
1349         assert(base != to_hi, &quot;can&#39;t be&quot;);
1350         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1351         __ movl(to_hi, as_Address_hi(addr));
1352         if (patch != NULL) {
1353           patching_epilog(patch, lir_patch_high, base, info);
1354           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1355           patch_code = lir_patch_low;
1356         }
1357         __ movl(to_lo, as_Address_lo(addr));
1358       } else {
1359         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1360         __ movl(to_lo, as_Address_lo(addr));
1361         if (patch != NULL) {
1362           patching_epilog(patch, lir_patch_low, base, info);
1363           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1364           patch_code = lir_patch_high;
1365         }
1366         __ movl(to_hi, as_Address_hi(addr));
1367       }
1368 #endif // _LP64
1369       break;
1370     }
1371 
1372     case T_BOOLEAN: // fall through
1373     case T_BYTE: {
1374       Register dest_reg = dest-&gt;as_register();
1375       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1376       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1377         __ movsbl(dest_reg, from_addr);
1378       } else {
1379         __ movb(dest_reg, from_addr);
1380         __ shll(dest_reg, 24);
1381         __ sarl(dest_reg, 24);
1382       }
1383       break;
1384     }
1385 
1386     case T_CHAR: {
1387       Register dest_reg = dest-&gt;as_register();
1388       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1389       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1390         __ movzwl(dest_reg, from_addr);
1391       } else {
1392         __ movw(dest_reg, from_addr);
1393       }
1394       break;
1395     }
1396 
1397     case T_SHORT: {
1398       Register dest_reg = dest-&gt;as_register();
1399       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1400         __ movswl(dest_reg, from_addr);
1401       } else {
1402         __ movw(dest_reg, from_addr);
1403         __ shll(dest_reg, 16);
1404         __ sarl(dest_reg, 16);
1405       }
1406       break;
1407     }
1408 
1409     default:
1410       ShouldNotReachHere();
1411   }
1412 
1413   if (patch != NULL) {
1414     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1415   }
1416 
1417   if (is_reference_type(type)) {
1418 #ifdef _LP64
1419     if (UseCompressedOops &amp;&amp; !wide) {
1420       __ decode_heap_oop(dest-&gt;as_register());
1421     }
1422 #endif
1423 
1424     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1425     if (!UseZGC) {
1426       __ verify_oop(dest-&gt;as_register());
1427     }
1428   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1429 #ifdef _LP64
1430     if (UseCompressedClassPointers) {
1431       __ andl(dest-&gt;as_register(), oopDesc::compressed_klass_mask());
1432       __ decode_klass_not_null(dest-&gt;as_register());
1433     } else {
1434       __ shlq(dest-&gt;as_register(), oopDesc::storage_props_nof_bits);
1435       __ shrq(dest-&gt;as_register(), oopDesc::storage_props_nof_bits);
1436     }
1437 #else
1438     __ andl(dest-&gt;as_register(), oopDesc::wide_klass_mask());
1439 #endif
1440   }
1441 }
1442 
1443 
1444 NEEDS_CLEANUP; // This could be static?
1445 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1446   int elem_size = type2aelembytes(type);
1447   switch (elem_size) {
1448     case 1: return Address::times_1;
1449     case 2: return Address::times_2;
1450     case 4: return Address::times_4;
1451     case 8: return Address::times_8;
1452   }
1453   ShouldNotReachHere();
1454   return Address::no_scale;
1455 }
1456 
1457 
1458 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1459   switch (op-&gt;code()) {
1460     case lir_idiv:
1461     case lir_irem:
1462       arithmetic_idiv(op-&gt;code(),
1463                       op-&gt;in_opr1(),
1464                       op-&gt;in_opr2(),
1465                       op-&gt;in_opr3(),
1466                       op-&gt;result_opr(),
1467                       op-&gt;info());
1468       break;
1469     case lir_fmad:
1470       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1471               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1472               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1473               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1474       break;
1475     case lir_fmaf:
1476       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1477               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1478               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1479               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1480       break;
1481     default:      ShouldNotReachHere(); break;
1482   }
1483 }
1484 
1485 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1486 #ifdef ASSERT
1487   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1488   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1489   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1490 #endif
1491 
1492   if (op-&gt;cond() == lir_cond_always) {
1493     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1494     __ jmp (*(op-&gt;label()));
1495   } else {
1496     Assembler::Condition acond = Assembler::zero;
1497     if (op-&gt;code() == lir_cond_float_branch) {
1498       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1499       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1500       switch(op-&gt;cond()) {
1501         case lir_cond_equal:        acond = Assembler::equal;      break;
1502         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1503         case lir_cond_less:         acond = Assembler::below;      break;
1504         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1505         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1506         case lir_cond_greater:      acond = Assembler::above;      break;
1507         default:                         ShouldNotReachHere();
1508       }
1509     } else {
1510       switch (op-&gt;cond()) {
1511         case lir_cond_equal:        acond = Assembler::equal;       break;
1512         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1513         case lir_cond_less:         acond = Assembler::less;        break;
1514         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1515         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1516         case lir_cond_greater:      acond = Assembler::greater;     break;
1517         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1518         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1519         default:                         ShouldNotReachHere();
1520       }
1521     }
1522     __ jcc(acond,*(op-&gt;label()));
1523   }
1524 }
1525 
1526 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1527   LIR_Opr src  = op-&gt;in_opr();
1528   LIR_Opr dest = op-&gt;result_opr();
1529 
1530   switch (op-&gt;bytecode()) {
1531     case Bytecodes::_i2l:
1532 #ifdef _LP64
1533       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1534 #else
1535       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1536       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1537       __ sarl(dest-&gt;as_register_hi(), 31);
1538 #endif // LP64
1539       break;
1540 
1541     case Bytecodes::_l2i:
1542 #ifdef _LP64
1543       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1544 #else
1545       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1546 #endif
1547       break;
1548 
1549     case Bytecodes::_i2b:
1550       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1551       __ sign_extend_byte(dest-&gt;as_register());
1552       break;
1553 
1554     case Bytecodes::_i2c:
1555       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1556       __ andl(dest-&gt;as_register(), 0xFFFF);
1557       break;
1558 
1559     case Bytecodes::_i2s:
1560       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1561       __ sign_extend_short(dest-&gt;as_register());
1562       break;
1563 
1564 
1565 #ifdef _LP64
1566     case Bytecodes::_f2d:
1567       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1568       break;
1569 
1570     case Bytecodes::_d2f:
1571       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1572       break;
1573 
1574     case Bytecodes::_i2f:
1575       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1576       break;
1577 
1578     case Bytecodes::_i2d:
1579       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1580       break;
1581 
1582     case Bytecodes::_l2f:
1583       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());
1584       break;
1585 
1586     case Bytecodes::_l2d:
1587       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());
1588       break;
1589 
1590     case Bytecodes::_f2i:
1591       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1592       break;
1593 
1594     case Bytecodes::_d2i:
1595       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1596       break;
1597 
1598     case Bytecodes::_f2l:
1599       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());
1600       break;
1601 
1602     case Bytecodes::_d2l:
1603       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
1604       break;
1605 #else
1606     case Bytecodes::_f2d:
1607     case Bytecodes::_d2f:
1608       if (dest-&gt;is_single_xmm()) {
1609         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1610       } else if (dest-&gt;is_double_xmm()) {
1611         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1612       } else {
1613         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1614         // do nothing (float result is rounded later through spilling)
1615       }
1616       break;
1617 
1618     case Bytecodes::_i2f:
1619     case Bytecodes::_i2d:
1620       if (dest-&gt;is_single_xmm()) {
1621         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1622       } else if (dest-&gt;is_double_xmm()) {
1623         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1624       } else {
1625         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1626         __ movl(Address(rsp, 0), src-&gt;as_register());
1627         __ fild_s(Address(rsp, 0));
1628       }
1629       break;
1630 
1631     case Bytecodes::_l2f:
1632     case Bytecodes::_l2d:
1633       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1634       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1635       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());
1636       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());
1637       __ fild_d(Address(rsp, 0));
1638       // float result is rounded later through spilling
1639       break;
1640 
1641     case Bytecodes::_f2i:
1642     case Bytecodes::_d2i:
1643       if (src-&gt;is_single_xmm()) {
1644         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1645       } else if (src-&gt;is_double_xmm()) {
1646         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1647       } else {
1648         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1649         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1650         __ fist_s(Address(rsp, 0));
1651         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1652         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1653       }
1654       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1655       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1656       __ cmpl(dest-&gt;as_register(), 0x80000000);
1657       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1658       __ bind(*op-&gt;stub()-&gt;continuation());
1659       break;
1660 
1661     case Bytecodes::_f2l:
1662     case Bytecodes::_d2l:
1663       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1664       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1665       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1666 
1667       // instruction sequence too long to inline it here
1668       {
1669         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1670       }
1671       break;
1672 #endif // _LP64
1673 
1674     default: ShouldNotReachHere();
1675   }
1676 }
1677 
1678 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1679   if (op-&gt;init_check()) {
1680     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1681     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1682                     InstanceKlass::init_state_offset()),
1683                     InstanceKlass::fully_initialized);
1684     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1685   }
1686   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1687                      op-&gt;tmp1()-&gt;as_register(),
1688                      op-&gt;tmp2()-&gt;as_register(),
1689                      op-&gt;header_size(),
1690                      op-&gt;object_size(),
1691                      op-&gt;klass()-&gt;as_register(),
1692                      *op-&gt;stub()-&gt;entry());
1693   __ bind(*op-&gt;stub()-&gt;continuation());
1694 }
1695 
1696 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1697   Register len =  op-&gt;len()-&gt;as_register();
1698   LP64_ONLY( __ movslq(len, len); )
1699 
1700   if (UseSlowPath || op-&gt;type() == T_VALUETYPE ||
1701       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1702       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1703     __ jmp(*op-&gt;stub()-&gt;entry());
1704   } else {
1705     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1706     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1707     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1708     if (len == tmp1) {
1709       tmp1 = tmp3;
1710     } else if (len == tmp2) {
1711       tmp2 = tmp3;
1712     } else if (len == tmp3) {
1713       // everything is ok
1714     } else {
1715       __ mov(tmp3, len);
1716     }
1717     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1718                       len,
1719                       tmp1,
1720                       tmp2,
1721                       arrayOopDesc::header_size(op-&gt;type()),
1722                       array_element_size(op-&gt;type()),
1723                       op-&gt;klass()-&gt;as_register(),
1724                       *op-&gt;stub()-&gt;entry());
1725   }
1726   __ bind(*op-&gt;stub()-&gt;continuation());
1727 }
1728 
1729 void LIR_Assembler::type_profile_helper(Register mdo,
1730                                         ciMethodData *md, ciProfileData *data,
1731                                         Register recv, Label* update_done) {
1732   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1733     Label next_test;
1734     // See if the receiver is receiver[n].
1735     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1736     __ jccb(Assembler::notEqual, next_test);
1737     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1738     __ addptr(data_addr, DataLayout::counter_increment);
1739     __ jmp(*update_done);
1740     __ bind(next_test);
1741   }
1742 
1743   // Didn&#39;t find receiver; find next empty slot and fill it in
1744   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1745     Label next_test;
1746     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1747     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1748     __ jccb(Assembler::notEqual, next_test);
1749     __ movptr(recv_addr, recv);
1750     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1751     __ jmp(*update_done);
1752     __ bind(next_test);
1753   }
1754 }
1755 
1756 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1757   // we always need a stub for the failure case.
1758   CodeStub* stub = op-&gt;stub();
1759   Register obj = op-&gt;object()-&gt;as_register();
1760   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1761   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1762   Register dst = op-&gt;result_opr()-&gt;as_register();
1763   ciKlass* k = op-&gt;klass();
1764   Register Rtmp1 = noreg;
1765 
1766   // check if it needs to be profiled
1767   ciMethodData* md = NULL;
1768   ciProfileData* data = NULL;
1769 
1770   if (op-&gt;should_profile()) {
1771     ciMethod* method = op-&gt;profiled_method();
1772     assert(method != NULL, &quot;Should have method&quot;);
1773     int bci = op-&gt;profiled_bci();
1774     md = method-&gt;method_data_or_null();
1775     assert(md != NULL, &quot;Sanity&quot;);
1776     data = md-&gt;bci_to_data(bci);
1777     assert(data != NULL,                &quot;need data for type check&quot;);
1778     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1779   }
1780   Label profile_cast_success, profile_cast_failure;
1781   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1782   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1783 
1784   if (obj == k_RInfo) {
1785     k_RInfo = dst;
1786   } else if (obj == klass_RInfo) {
1787     klass_RInfo = dst;
1788   }
1789   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1790     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1791   } else {
1792     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1793     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1794   }
1795 
1796   assert_different_registers(obj, k_RInfo, klass_RInfo);
1797 
1798   if (op-&gt;need_null_check()) {
1799     __ cmpptr(obj, (int32_t)NULL_WORD);
1800     if (op-&gt;should_profile()) {
1801       Label not_null;
1802       __ jccb(Assembler::notEqual, not_null);
1803       // Object is null; update MDO and exit
1804       Register mdo  = klass_RInfo;
1805       __ mov_metadata(mdo, md-&gt;constant_encoding());
1806       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1807       int header_bits = BitData::null_seen_byte_constant();
1808       __ orb(data_addr, header_bits);
1809       __ jmp(*obj_is_null);
1810       __ bind(not_null);
1811     } else {
1812       __ jcc(Assembler::equal, *obj_is_null);
1813     }
1814   }
1815 
1816   if (!k-&gt;is_loaded()) {
1817     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1818   } else {
1819 #ifdef _LP64
1820     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1821 #endif // _LP64
1822   }
1823   __ verify_oop(obj);
1824 
1825   if (op-&gt;fast_check()) {
1826     // get object class
1827     // not a safepoint as obj null check happens earlier
1828 #ifdef _LP64
1829     if (UseCompressedClassPointers) {
1830       __ load_klass(Rtmp1, obj);
1831       __ cmpptr(k_RInfo, Rtmp1);
1832     } else {
1833       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1834     }
1835 #else
1836     if (k-&gt;is_loaded()) {
1837       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1838     } else {
1839       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1840     }
1841 #endif
1842     __ jcc(Assembler::notEqual, *failure_target);
1843     // successful cast, fall through to profile or jump
1844   } else {
1845     // get object class
1846     // not a safepoint as obj null check happens earlier
1847     __ load_klass(klass_RInfo, obj);
1848     if (k-&gt;is_loaded()) {
1849       // See if we get an immediate positive hit
1850 #ifdef _LP64
1851       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1852 #else
1853       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1854 #endif // _LP64
1855       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1856         __ jcc(Assembler::notEqual, *failure_target);
1857         // successful cast, fall through to profile or jump
1858       } else {
1859         // See if we get an immediate positive hit
1860         __ jcc(Assembler::equal, *success_target);
1861         // check for self
1862 #ifdef _LP64
1863         __ cmpptr(klass_RInfo, k_RInfo);
1864 #else
1865         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1866 #endif // _LP64
1867         __ jcc(Assembler::equal, *success_target);
1868 
1869         __ push(klass_RInfo);
1870 #ifdef _LP64
1871         __ push(k_RInfo);
1872 #else
1873         __ pushklass(k-&gt;constant_encoding());
1874 #endif // _LP64
1875         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1876         __ pop(klass_RInfo);
1877         __ pop(klass_RInfo);
1878         // result is a boolean
1879         __ cmpl(klass_RInfo, 0);
1880         __ jcc(Assembler::equal, *failure_target);
1881         // successful cast, fall through to profile or jump
1882       }
1883     } else {
1884       // perform the fast part of the checking logic
1885       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1886       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1887       __ push(klass_RInfo);
1888       __ push(k_RInfo);
1889       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1890       __ pop(klass_RInfo);
1891       __ pop(k_RInfo);
1892       // result is a boolean
1893       __ cmpl(k_RInfo, 0);
1894       __ jcc(Assembler::equal, *failure_target);
1895       // successful cast, fall through to profile or jump
1896     }
1897   }
1898   if (op-&gt;should_profile()) {
1899     Register mdo  = klass_RInfo, recv = k_RInfo;
1900     __ bind(profile_cast_success);
1901     __ mov_metadata(mdo, md-&gt;constant_encoding());
1902     __ load_klass(recv, obj);
1903     type_profile_helper(mdo, md, data, recv, success);
1904     __ jmp(*success);
1905 
1906     __ bind(profile_cast_failure);
1907     __ mov_metadata(mdo, md-&gt;constant_encoding());
1908     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1909     __ subptr(counter_addr, DataLayout::counter_increment);
1910     __ jmp(*failure);
1911   }
1912   __ jmp(*success);
1913 }
1914 
1915 
1916 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1917   LIR_Code code = op-&gt;code();
1918   if (code == lir_store_check) {
1919     Register value = op-&gt;object()-&gt;as_register();
1920     Register array = op-&gt;array()-&gt;as_register();
1921     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1922     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1923     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1924 
1925     CodeStub* stub = op-&gt;stub();
1926 
1927     // check if it needs to be profiled
1928     ciMethodData* md = NULL;
1929     ciProfileData* data = NULL;
1930 
1931     if (op-&gt;should_profile()) {
1932       ciMethod* method = op-&gt;profiled_method();
1933       assert(method != NULL, &quot;Should have method&quot;);
1934       int bci = op-&gt;profiled_bci();
1935       md = method-&gt;method_data_or_null();
1936       assert(md != NULL, &quot;Sanity&quot;);
1937       data = md-&gt;bci_to_data(bci);
1938       assert(data != NULL,                &quot;need data for type check&quot;);
1939       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1940     }
1941     Label profile_cast_success, profile_cast_failure, done;
1942     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1943     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1944 
1945     __ cmpptr(value, (int32_t)NULL_WORD);
1946     if (op-&gt;should_profile()) {
1947       Label not_null;
1948       __ jccb(Assembler::notEqual, not_null);
1949       // Object is null; update MDO and exit
1950       Register mdo  = klass_RInfo;
1951       __ mov_metadata(mdo, md-&gt;constant_encoding());
1952       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1953       int header_bits = BitData::null_seen_byte_constant();
1954       __ orb(data_addr, header_bits);
1955       __ jmp(done);
1956       __ bind(not_null);
1957     } else {
1958       __ jcc(Assembler::equal, done);
1959     }
1960 
1961     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1962     __ load_klass(k_RInfo, array);
1963     __ load_klass(klass_RInfo, value);
1964 
1965     // get instance klass (it&#39;s already uncompressed)
1966     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1967     // perform the fast part of the checking logic
1968     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1969     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1970     __ push(klass_RInfo);
1971     __ push(k_RInfo);
1972     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1973     __ pop(klass_RInfo);
1974     __ pop(k_RInfo);
1975     // result is a boolean
1976     __ cmpl(k_RInfo, 0);
1977     __ jcc(Assembler::equal, *failure_target);
1978     // fall through to the success case
1979 
1980     if (op-&gt;should_profile()) {
1981       Register mdo  = klass_RInfo, recv = k_RInfo;
1982       __ bind(profile_cast_success);
1983       __ mov_metadata(mdo, md-&gt;constant_encoding());
1984       __ load_klass(recv, value);
1985       type_profile_helper(mdo, md, data, recv, &amp;done);
1986       __ jmpb(done);
1987 
1988       __ bind(profile_cast_failure);
1989       __ mov_metadata(mdo, md-&gt;constant_encoding());
1990       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1991       __ subptr(counter_addr, DataLayout::counter_increment);
1992       __ jmp(*stub-&gt;entry());
1993     }
1994 
1995     __ bind(done);
1996   } else
1997     if (code == lir_checkcast) {
1998       Register obj = op-&gt;object()-&gt;as_register();
1999       Register dst = op-&gt;result_opr()-&gt;as_register();
2000       Label success;
2001       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
2002       __ bind(success);
2003       if (dst != obj) {
2004         __ mov(dst, obj);
2005       }
2006     } else
2007       if (code == lir_instanceof) {
2008         Register obj = op-&gt;object()-&gt;as_register();
2009         Register dst = op-&gt;result_opr()-&gt;as_register();
2010         Label success, failure, done;
2011         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
2012         __ bind(failure);
2013         __ xorptr(dst, dst);
2014         __ jmpb(done);
2015         __ bind(success);
2016         __ movptr(dst, 1);
2017         __ bind(done);
2018       } else {
2019         ShouldNotReachHere();
2020       }
2021 
2022 }
2023 
2024 void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {
2025   // We are loading/storing an array that *may* be a flattened array (the declared type
2026   // Object[], interface[], or VT?[]). If this array is flattened, take slow path.
2027 
2028   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());
2029   __ testb(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::flattened_value);
2030   __ jcc(Assembler::notZero, *op-&gt;stub()-&gt;entry());
2031   if (!op-&gt;value()-&gt;is_illegal()) {
2032     // We are storing into the array.
2033     Label skip;
2034     __ testb(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::null_free_value);
2035     __ jcc(Assembler::zero, skip);
2036     // The array is not flattened, but it is null_free. If we are storing
2037     // a null, take the slow path (which will throw NPE).
2038     __ cmpptr(op-&gt;value()-&gt;as_register(), (int32_t)NULL_WORD);
2039     __ jcc(Assembler::zero, *op-&gt;stub()-&gt;entry());
2040     __ bind(skip);
2041   }
2042 }
2043 
2044 void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {
2045   // This is called when we use aastore into a an array declared as &quot;[LVT;&quot;,
2046   // where we know VT is not flattenable (due to ValueArrayElemMaxFlatOops, etc).
2047   // However, we need to do a NULL check if the actual array is a &quot;[QVT;&quot;.
2048 
2049   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());
2050   __ testb(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::null_free_value);
2051 }
2052 
2053 void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {
2054   Label L_oops_equal;
2055   Label L_oops_not_equal;
2056   Label L_end;
2057 
2058   Register left  = op-&gt;left()-&gt;as_register();
2059   Register right = op-&gt;right()-&gt;as_register();
2060 
2061   __ cmpptr(left, right);
2062   __ jcc(Assembler::equal, L_oops_equal);
2063 
2064   // (1) Null check -- if one of the operands is null, the other must not be null (because
2065   //     the two references are not equal), so they are not substitutable,
2066   //     FIXME: do null check only if the operand is nullable
2067   {
2068     __ cmpptr(left, (int32_t)NULL_WORD);
2069     __ jcc(Assembler::equal, L_oops_not_equal);
2070 
2071     __ cmpptr(right, (int32_t)NULL_WORD);
2072     __ jcc(Assembler::equal, L_oops_not_equal);
2073   }
2074 
2075   ciKlass* left_klass = op-&gt;left_klass();
2076   ciKlass* right_klass = op-&gt;right_klass();
2077 
2078   // (2) Value object check -- if either of the operands is not a value object,
2079   //     they are not substitutable. We do this only if we are not sure that the
2080   //     operands are value objects
2081   if ((left_klass == NULL || right_klass == NULL) ||// The klass is still unloaded, or came from a Phi node.
2082       !left_klass-&gt;is_valuetype() || !right_klass-&gt;is_valuetype()) {
2083     Register tmp1  = op-&gt;tmp1()-&gt;as_register();
2084     __ movptr(tmp1, (intptr_t)markWord::always_locked_pattern);
2085     __ andl(tmp1, Address(left, oopDesc::mark_offset_in_bytes()));
2086     __ andl(tmp1, Address(right, oopDesc::mark_offset_in_bytes()));
2087     __ cmpptr(tmp1, (intptr_t)markWord::always_locked_pattern);
2088     __ jcc(Assembler::notEqual, L_oops_not_equal);
2089   }
2090 
2091   // (3) Same klass check: if the operands are of different klasses, they are not substitutable.
2092   if (left_klass != NULL &amp;&amp; left_klass-&gt;is_valuetype() &amp;&amp; left_klass == right_klass) {
2093     // No need to load klass -- the operands are statically known to be the same value klass.
2094     __ jmp(*op-&gt;stub()-&gt;entry());
2095   } else {
2096     Register left_klass_op = op-&gt;left_klass_op()-&gt;as_register();
2097     Register right_klass_op = op-&gt;right_klass_op()-&gt;as_register();
2098 
2099     if (UseCompressedOops) {
2100       __ movl(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
2101       __ movl(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
2102       __ cmpl(left_klass_op, right_klass_op);
2103     } else {
2104       __ movptr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
2105       __ movptr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
2106       __ cmpptr(left_klass_op, right_klass_op);
2107     }
2108 
2109     __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry()); // same klass -&gt; do slow check
2110     // fall through to L_oops_not_equal
2111   }
2112 
2113   __ bind(L_oops_not_equal);
2114   move(op-&gt;not_equal_result(), op-&gt;result_opr());
2115   __ jmp(L_end);
2116 
2117   __ bind(L_oops_equal);
2118   move(op-&gt;equal_result(), op-&gt;result_opr());
2119   __ jmp(L_end);
2120 
2121   // We&#39;ve returned from the stub. RAX contains 0x0 IFF the two
2122   // operands are not substitutable. (Don&#39;t compare against 0x1 in case the
2123   // C compiler is naughty)
2124   __ bind(*op-&gt;stub()-&gt;continuation());
2125   __ cmpl(rax, 0);
2126   __ jcc(Assembler::equal, L_oops_not_equal); // (call_stub() == 0x0) -&gt; not_equal
2127   move(op-&gt;equal_result(), op-&gt;result_opr()); // (call_stub() != 0x0) -&gt; equal
2128   // fall-through
2129   __ bind(L_end);
2130 }
2131 
2132 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2133   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
2134     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
2135     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
2136     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
2137     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
2138     Register addr = op-&gt;addr()-&gt;as_register();
2139     __ lock();
2140     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
2141 
2142   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
2143     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
2144     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2145     Register newval = op-&gt;new_value()-&gt;as_register();
2146     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
2147     assert(cmpval == rax, &quot;wrong register&quot;);
2148     assert(newval != NULL, &quot;new val must be register&quot;);
2149     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2150     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2151     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2152 
2153     if ( op-&gt;code() == lir_cas_obj) {
2154 #ifdef _LP64
2155       if (UseCompressedOops) {
2156         __ encode_heap_oop(cmpval);
2157         __ mov(rscratch1, newval);
2158         __ encode_heap_oop(rscratch1);
2159         __ lock();
2160         // cmpval (rax) is implicitly used by this instruction
2161         __ cmpxchgl(rscratch1, Address(addr, 0));
2162       } else
2163 #endif
2164       {
2165         __ lock();
2166         __ cmpxchgptr(newval, Address(addr, 0));
2167       }
2168     } else {
2169       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
2170       __ lock();
2171       __ cmpxchgl(newval, Address(addr, 0));
2172     }
2173 #ifdef _LP64
2174   } else if (op-&gt;code() == lir_cas_long) {
2175     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2176     Register newval = op-&gt;new_value()-&gt;as_register_lo();
2177     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
2178     assert(cmpval == rax, &quot;wrong register&quot;);
2179     assert(newval != NULL, &quot;new val must be register&quot;);
2180     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2181     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2182     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2183     __ lock();
2184     __ cmpxchgq(newval, Address(addr, 0));
2185 #endif // _LP64
2186   } else {
2187     Unimplemented();
2188   }
2189 }
2190 
2191 void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {
2192   assert(dst-&gt;is_cpu_register(), &quot;must be&quot;);
2193   assert(dst-&gt;type() == src-&gt;type(), &quot;must be&quot;);
2194 
2195   if (src-&gt;is_cpu_register()) {
2196     reg2reg(src, dst);
2197   } else if (src-&gt;is_stack()) {
2198     stack2reg(src, dst, dst-&gt;type());
2199   } else if (src-&gt;is_constant()) {
2200     const2reg(src, dst, lir_patch_none, NULL);
2201   } else {
2202     ShouldNotReachHere();
2203   }
2204 }
2205 
2206 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
2207   Assembler::Condition acond, ncond;
2208   switch (condition) {
2209     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
2210     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
2211     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
2212     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
2213     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
2214     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
2215     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
2216     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
2217     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
2218                                 ShouldNotReachHere();
2219   }
2220 
2221   if (opr1-&gt;is_cpu_register()) {
2222     reg2reg(opr1, result);
2223   } else if (opr1-&gt;is_stack()) {
2224     stack2reg(opr1, result, result-&gt;type());
2225   } else if (opr1-&gt;is_constant()) {
2226     const2reg(opr1, result, lir_patch_none, NULL);
2227   } else {
2228     ShouldNotReachHere();
2229   }
2230 
2231   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
2232     // optimized version that does not require a branch
2233     if (opr2-&gt;is_single_cpu()) {
2234       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
2235       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
2236     } else if (opr2-&gt;is_double_cpu()) {
2237       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2238       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2239       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
2240       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
2241     } else if (opr2-&gt;is_single_stack()) {
2242       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2243     } else if (opr2-&gt;is_double_stack()) {
2244       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2245       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2246     } else {
2247       ShouldNotReachHere();
2248     }
2249 
2250   } else {
2251     Label skip;
2252     __ jcc (acond, skip);
2253     if (opr2-&gt;is_cpu_register()) {
2254       reg2reg(opr2, result);
2255     } else if (opr2-&gt;is_stack()) {
2256       stack2reg(opr2, result, result-&gt;type());
2257     } else if (opr2-&gt;is_constant()) {
2258       const2reg(opr2, result, lir_patch_none, NULL);
2259     } else {
2260       ShouldNotReachHere();
2261     }
2262     __ bind(skip);
2263   }
2264 }
2265 
2266 
2267 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2268   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2269 
2270   if (left-&gt;is_single_cpu()) {
2271     assert(left == dest, &quot;left and dest must be equal&quot;);
2272     Register lreg = left-&gt;as_register();
2273 
2274     if (right-&gt;is_single_cpu()) {
2275       // cpu register - cpu register
2276       Register rreg = right-&gt;as_register();
2277       switch (code) {
2278         case lir_add: __ addl (lreg, rreg); break;
2279         case lir_sub: __ subl (lreg, rreg); break;
2280         case lir_mul: __ imull(lreg, rreg); break;
2281         default:      ShouldNotReachHere();
2282       }
2283 
2284     } else if (right-&gt;is_stack()) {
2285       // cpu register - stack
2286       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2287       switch (code) {
2288         case lir_add: __ addl(lreg, raddr); break;
2289         case lir_sub: __ subl(lreg, raddr); break;
2290         default:      ShouldNotReachHere();
2291       }
2292 
2293     } else if (right-&gt;is_constant()) {
2294       // cpu register - constant
2295       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2296       switch (code) {
2297         case lir_add: {
2298           __ incrementl(lreg, c);
2299           break;
2300         }
2301         case lir_sub: {
2302           __ decrementl(lreg, c);
2303           break;
2304         }
2305         default: ShouldNotReachHere();
2306       }
2307 
2308     } else {
2309       ShouldNotReachHere();
2310     }
2311 
2312   } else if (left-&gt;is_double_cpu()) {
2313     assert(left == dest, &quot;left and dest must be equal&quot;);
2314     Register lreg_lo = left-&gt;as_register_lo();
2315     Register lreg_hi = left-&gt;as_register_hi();
2316 
2317     if (right-&gt;is_double_cpu()) {
2318       // cpu register - cpu register
2319       Register rreg_lo = right-&gt;as_register_lo();
2320       Register rreg_hi = right-&gt;as_register_hi();
2321       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2322       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2323       switch (code) {
2324         case lir_add:
2325           __ addptr(lreg_lo, rreg_lo);
2326           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2327           break;
2328         case lir_sub:
2329           __ subptr(lreg_lo, rreg_lo);
2330           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2331           break;
2332         case lir_mul:
2333 #ifdef _LP64
2334           __ imulq(lreg_lo, rreg_lo);
2335 #else
2336           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2337           __ imull(lreg_hi, rreg_lo);
2338           __ imull(rreg_hi, lreg_lo);
2339           __ addl (rreg_hi, lreg_hi);
2340           __ mull (rreg_lo);
2341           __ addl (lreg_hi, rreg_hi);
2342 #endif // _LP64
2343           break;
2344         default:
2345           ShouldNotReachHere();
2346       }
2347 
2348     } else if (right-&gt;is_constant()) {
2349       // cpu register - constant
2350 #ifdef _LP64
2351       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2352       __ movptr(r10, (intptr_t) c);
2353       switch (code) {
2354         case lir_add:
2355           __ addptr(lreg_lo, r10);
2356           break;
2357         case lir_sub:
2358           __ subptr(lreg_lo, r10);
2359           break;
2360         default:
2361           ShouldNotReachHere();
2362       }
2363 #else
2364       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2365       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2366       switch (code) {
2367         case lir_add:
2368           __ addptr(lreg_lo, c_lo);
2369           __ adcl(lreg_hi, c_hi);
2370           break;
2371         case lir_sub:
2372           __ subptr(lreg_lo, c_lo);
2373           __ sbbl(lreg_hi, c_hi);
2374           break;
2375         default:
2376           ShouldNotReachHere();
2377       }
2378 #endif // _LP64
2379 
2380     } else {
2381       ShouldNotReachHere();
2382     }
2383 
2384   } else if (left-&gt;is_single_xmm()) {
2385     assert(left == dest, &quot;left and dest must be equal&quot;);
2386     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2387 
2388     if (right-&gt;is_single_xmm()) {
2389       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2390       switch (code) {
2391         case lir_add: __ addss(lreg, rreg);  break;
2392         case lir_sub: __ subss(lreg, rreg);  break;
2393         case lir_mul_strictfp: // fall through
2394         case lir_mul: __ mulss(lreg, rreg);  break;
2395         case lir_div_strictfp: // fall through
2396         case lir_div: __ divss(lreg, rreg);  break;
2397         default: ShouldNotReachHere();
2398       }
2399     } else {
2400       Address raddr;
2401       if (right-&gt;is_single_stack()) {
2402         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2403       } else if (right-&gt;is_constant()) {
2404         // hack for now
2405         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2406       } else {
2407         ShouldNotReachHere();
2408       }
2409       switch (code) {
2410         case lir_add: __ addss(lreg, raddr);  break;
2411         case lir_sub: __ subss(lreg, raddr);  break;
2412         case lir_mul_strictfp: // fall through
2413         case lir_mul: __ mulss(lreg, raddr);  break;
2414         case lir_div_strictfp: // fall through
2415         case lir_div: __ divss(lreg, raddr);  break;
2416         default: ShouldNotReachHere();
2417       }
2418     }
2419 
2420   } else if (left-&gt;is_double_xmm()) {
2421     assert(left == dest, &quot;left and dest must be equal&quot;);
2422 
2423     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2424     if (right-&gt;is_double_xmm()) {
2425       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2426       switch (code) {
2427         case lir_add: __ addsd(lreg, rreg);  break;
2428         case lir_sub: __ subsd(lreg, rreg);  break;
2429         case lir_mul_strictfp: // fall through
2430         case lir_mul: __ mulsd(lreg, rreg);  break;
2431         case lir_div_strictfp: // fall through
2432         case lir_div: __ divsd(lreg, rreg);  break;
2433         default: ShouldNotReachHere();
2434       }
2435     } else {
2436       Address raddr;
2437       if (right-&gt;is_double_stack()) {
2438         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2439       } else if (right-&gt;is_constant()) {
2440         // hack for now
2441         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2442       } else {
2443         ShouldNotReachHere();
2444       }
2445       switch (code) {
2446         case lir_add: __ addsd(lreg, raddr);  break;
2447         case lir_sub: __ subsd(lreg, raddr);  break;
2448         case lir_mul_strictfp: // fall through
2449         case lir_mul: __ mulsd(lreg, raddr);  break;
2450         case lir_div_strictfp: // fall through
2451         case lir_div: __ divsd(lreg, raddr);  break;
2452         default: ShouldNotReachHere();
2453       }
2454     }
2455 
2456 #ifndef _LP64
2457   } else if (left-&gt;is_single_fpu()) {
2458     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2459 
2460     if (right-&gt;is_single_fpu()) {
2461       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2462 
2463     } else {
2464       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2465       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2466 
2467       Address raddr;
2468       if (right-&gt;is_single_stack()) {
2469         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2470       } else if (right-&gt;is_constant()) {
2471         address const_addr = float_constant(right-&gt;as_jfloat());
2472         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2473         // hack for now
2474         raddr = __ as_Address(InternalAddress(const_addr));
2475       } else {
2476         ShouldNotReachHere();
2477       }
2478 
2479       switch (code) {
2480         case lir_add: __ fadd_s(raddr); break;
2481         case lir_sub: __ fsub_s(raddr); break;
2482         case lir_mul_strictfp: // fall through
2483         case lir_mul: __ fmul_s(raddr); break;
2484         case lir_div_strictfp: // fall through
2485         case lir_div: __ fdiv_s(raddr); break;
2486         default:      ShouldNotReachHere();
2487       }
2488     }
2489 
2490   } else if (left-&gt;is_double_fpu()) {
2491     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2492 
2493     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2494       // Double values require special handling for strictfp mul/div on x86
2495       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2496       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2497     }
2498 
2499     if (right-&gt;is_double_fpu()) {
2500       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2501 
2502     } else {
2503       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2504       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2505 
2506       Address raddr;
2507       if (right-&gt;is_double_stack()) {
2508         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2509       } else if (right-&gt;is_constant()) {
2510         // hack for now
2511         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2512       } else {
2513         ShouldNotReachHere();
2514       }
2515 
2516       switch (code) {
2517         case lir_add: __ fadd_d(raddr); break;
2518         case lir_sub: __ fsub_d(raddr); break;
2519         case lir_mul_strictfp: // fall through
2520         case lir_mul: __ fmul_d(raddr); break;
2521         case lir_div_strictfp: // fall through
2522         case lir_div: __ fdiv_d(raddr); break;
2523         default: ShouldNotReachHere();
2524       }
2525     }
2526 
2527     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2528       // Double values require special handling for strictfp mul/div on x86
2529       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2530       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2531     }
2532 #endif // !_LP64
2533 
2534   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2535     assert(left == dest, &quot;left and dest must be equal&quot;);
2536 
2537     Address laddr;
2538     if (left-&gt;is_single_stack()) {
2539       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2540     } else if (left-&gt;is_address()) {
2541       laddr = as_Address(left-&gt;as_address_ptr());
2542     } else {
2543       ShouldNotReachHere();
2544     }
2545 
2546     if (right-&gt;is_single_cpu()) {
2547       Register rreg = right-&gt;as_register();
2548       switch (code) {
2549         case lir_add: __ addl(laddr, rreg); break;
2550         case lir_sub: __ subl(laddr, rreg); break;
2551         default:      ShouldNotReachHere();
2552       }
2553     } else if (right-&gt;is_constant()) {
2554       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2555       switch (code) {
2556         case lir_add: {
2557           __ incrementl(laddr, c);
2558           break;
2559         }
2560         case lir_sub: {
2561           __ decrementl(laddr, c);
2562           break;
2563         }
2564         default: ShouldNotReachHere();
2565       }
2566     } else {
2567       ShouldNotReachHere();
2568     }
2569 
2570   } else {
2571     ShouldNotReachHere();
2572   }
2573 }
2574 
2575 #ifndef _LP64
2576 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2577   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2578   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2579   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2580 
2581   bool left_is_tos = (left_index == 0);
2582   bool dest_is_tos = (dest_index == 0);
2583   int non_tos_index = (left_is_tos ? right_index : left_index);
2584 
2585   switch (code) {
2586     case lir_add:
2587       if (pop_fpu_stack)       __ faddp(non_tos_index);
2588       else if (dest_is_tos)    __ fadd (non_tos_index);
2589       else                     __ fadda(non_tos_index);
2590       break;
2591 
2592     case lir_sub:
2593       if (left_is_tos) {
2594         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2595         else if (dest_is_tos)  __ fsub  (non_tos_index);
2596         else                   __ fsubra(non_tos_index);
2597       } else {
2598         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2599         else if (dest_is_tos)  __ fsubr (non_tos_index);
2600         else                   __ fsuba (non_tos_index);
2601       }
2602       break;
2603 
2604     case lir_mul_strictfp: // fall through
2605     case lir_mul:
2606       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2607       else if (dest_is_tos)    __ fmul (non_tos_index);
2608       else                     __ fmula(non_tos_index);
2609       break;
2610 
2611     case lir_div_strictfp: // fall through
2612     case lir_div:
2613       if (left_is_tos) {
2614         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2615         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2616         else                   __ fdivra(non_tos_index);
2617       } else {
2618         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2619         else if (dest_is_tos)  __ fdivr (non_tos_index);
2620         else                   __ fdiva (non_tos_index);
2621       }
2622       break;
2623 
2624     case lir_rem:
2625       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2626       __ fremr(noreg);
2627       break;
2628 
2629     default:
2630       ShouldNotReachHere();
2631   }
2632 }
2633 #endif // _LP64
2634 
2635 
2636 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2637   if (value-&gt;is_double_xmm()) {
2638     switch(code) {
2639       case lir_abs :
2640         {
2641 #ifdef _LP64
2642           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2643             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2644             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2645           } else
2646 #endif
2647           {
2648             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2649               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2650             }
2651             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2652             __ andpd(dest-&gt;as_xmm_double_reg(),
2653                      ExternalAddress((address)double_signmask_pool));
2654           }
2655         }
2656         break;
2657 
2658       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2659       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2660       default      : ShouldNotReachHere();
2661     }
2662 
2663 #ifndef _LP64
2664   } else if (value-&gt;is_double_fpu()) {
2665     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2666     switch(code) {
2667       case lir_abs   : __ fabs() ; break;
2668       case lir_sqrt  : __ fsqrt(); break;
2669       default      : ShouldNotReachHere();
2670     }
2671 #endif // !_LP64
2672   } else {
2673     Unimplemented();
2674   }
2675 }
2676 
2677 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2678   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2679   if (left-&gt;is_single_cpu()) {
2680     Register reg = left-&gt;as_register();
2681     if (right-&gt;is_constant()) {
2682       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2683       switch (code) {
2684         case lir_logic_and: __ andl (reg, val); break;
2685         case lir_logic_or:  __ orl  (reg, val); break;
2686         case lir_logic_xor: __ xorl (reg, val); break;
2687         default: ShouldNotReachHere();
2688       }
2689     } else if (right-&gt;is_stack()) {
2690       // added support for stack operands
2691       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2692       switch (code) {
2693         case lir_logic_and: __ andl (reg, raddr); break;
2694         case lir_logic_or:  __ orl  (reg, raddr); break;
2695         case lir_logic_xor: __ xorl (reg, raddr); break;
2696         default: ShouldNotReachHere();
2697       }
2698     } else {
2699       Register rright = right-&gt;as_register();
2700       switch (code) {
2701         case lir_logic_and: __ andptr (reg, rright); break;
2702         case lir_logic_or : __ orptr  (reg, rright); break;
2703         case lir_logic_xor: __ xorptr (reg, rright); break;
2704         default: ShouldNotReachHere();
2705       }
2706     }
2707     move_regs(reg, dst-&gt;as_register());
2708   } else {
2709     Register l_lo = left-&gt;as_register_lo();
2710     Register l_hi = left-&gt;as_register_hi();
2711     if (right-&gt;is_constant()) {
2712 #ifdef _LP64
2713       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2714       switch (code) {
2715         case lir_logic_and:
2716           __ andq(l_lo, rscratch1);
2717           break;
2718         case lir_logic_or:
2719           __ orq(l_lo, rscratch1);
2720           break;
2721         case lir_logic_xor:
2722           __ xorq(l_lo, rscratch1);
2723           break;
2724         default: ShouldNotReachHere();
2725       }
2726 #else
2727       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2728       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2729       switch (code) {
2730         case lir_logic_and:
2731           __ andl(l_lo, r_lo);
2732           __ andl(l_hi, r_hi);
2733           break;
2734         case lir_logic_or:
2735           __ orl(l_lo, r_lo);
2736           __ orl(l_hi, r_hi);
2737           break;
2738         case lir_logic_xor:
2739           __ xorl(l_lo, r_lo);
2740           __ xorl(l_hi, r_hi);
2741           break;
2742         default: ShouldNotReachHere();
2743       }
2744 #endif // _LP64
2745     } else {
2746 #ifdef _LP64
2747       Register r_lo;
2748       if (is_reference_type(right-&gt;type())) {
2749         r_lo = right-&gt;as_register();
2750       } else {
2751         r_lo = right-&gt;as_register_lo();
2752       }
2753 #else
2754       Register r_lo = right-&gt;as_register_lo();
2755       Register r_hi = right-&gt;as_register_hi();
2756       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2757 #endif
2758       switch (code) {
2759         case lir_logic_and:
2760           __ andptr(l_lo, r_lo);
2761           NOT_LP64(__ andptr(l_hi, r_hi);)
2762           break;
2763         case lir_logic_or:
2764           __ orptr(l_lo, r_lo);
2765           NOT_LP64(__ orptr(l_hi, r_hi);)
2766           break;
2767         case lir_logic_xor:
2768           __ xorptr(l_lo, r_lo);
2769           NOT_LP64(__ xorptr(l_hi, r_hi);)
2770           break;
2771         default: ShouldNotReachHere();
2772       }
2773     }
2774 
2775     Register dst_lo = dst-&gt;as_register_lo();
2776     Register dst_hi = dst-&gt;as_register_hi();
2777 
2778 #ifdef _LP64
2779     move_regs(l_lo, dst_lo);
2780 #else
2781     if (dst_lo == l_hi) {
2782       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2783       move_regs(l_hi, dst_hi);
2784       move_regs(l_lo, dst_lo);
2785     } else {
2786       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2787       move_regs(l_lo, dst_lo);
2788       move_regs(l_hi, dst_hi);
2789     }
2790 #endif // _LP64
2791   }
2792 }
2793 
2794 
2795 // we assume that rax, and rdx can be overwritten
2796 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2797 
2798   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2799   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2800   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2801 
2802   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2803   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2804 
2805   Register lreg = left-&gt;as_register();
2806   Register dreg = result-&gt;as_register();
2807 
2808   if (right-&gt;is_constant()) {
2809     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2810     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2811     if (code == lir_idiv) {
2812       assert(lreg == rax, &quot;must be rax,&quot;);
2813       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2814       __ cdql(); // sign extend into rdx:rax
2815       if (divisor == 2) {
2816         __ subl(lreg, rdx);
2817       } else {
2818         __ andl(rdx, divisor - 1);
2819         __ addl(lreg, rdx);
2820       }
2821       __ sarl(lreg, log2_jint(divisor));
2822       move_regs(lreg, dreg);
2823     } else if (code == lir_irem) {
2824       Label done;
2825       __ mov(dreg, lreg);
2826       __ andl(dreg, 0x80000000 | (divisor - 1));
2827       __ jcc(Assembler::positive, done);
2828       __ decrement(dreg);
2829       __ orl(dreg, ~(divisor - 1));
2830       __ increment(dreg);
2831       __ bind(done);
2832     } else {
2833       ShouldNotReachHere();
2834     }
2835   } else {
2836     Register rreg = right-&gt;as_register();
2837     assert(lreg == rax, &quot;left register must be rax,&quot;);
2838     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2839     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2840 
2841     move_regs(lreg, rax);
2842 
2843     int idivl_offset = __ corrected_idivl(rreg);
2844     if (ImplicitDiv0Checks) {
2845       add_debug_info_for_div0(idivl_offset, info);
2846     }
2847     if (code == lir_irem) {
2848       move_regs(rdx, dreg); // result is in rdx
2849     } else {
2850       move_regs(rax, dreg);
2851     }
2852   }
2853 }
2854 
2855 
2856 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2857   if (opr1-&gt;is_single_cpu()) {
2858     Register reg1 = opr1-&gt;as_register();
2859     if (opr2-&gt;is_single_cpu()) {
2860       // cpu register - cpu register
2861       if (is_reference_type(opr1-&gt;type())) {
2862         __ cmpoop(reg1, opr2-&gt;as_register());
2863       } else {
2864         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2865         __ cmpl(reg1, opr2-&gt;as_register());
2866       }
2867     } else if (opr2-&gt;is_stack()) {
2868       // cpu register - stack
2869       if (is_reference_type(opr1-&gt;type())) {
2870         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2871       } else {
2872         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2873       }
2874     } else if (opr2-&gt;is_constant()) {
2875       // cpu register - constant
2876       LIR_Const* c = opr2-&gt;as_constant_ptr();
2877       if (c-&gt;type() == T_INT) {
2878         __ cmpl(reg1, c-&gt;as_jint());
2879       } else if (c-&gt;type() == T_METADATA) {
2880         // All we need for now is a comparison with NULL for equality.
2881         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
2882         Metadata* m = c-&gt;as_metadata();
2883         if (m == NULL) {
2884           __ cmpptr(reg1, (int32_t)0);
2885         } else {
2886           ShouldNotReachHere();
2887         }
2888       } else if (is_reference_type(c-&gt;type())) {
2889         // In 64bit oops are single register
2890         jobject o = c-&gt;as_jobject();
2891         if (o == NULL) {
2892           __ cmpptr(reg1, (int32_t)NULL_WORD);
2893         } else {
2894           __ cmpoop(reg1, o);
2895         }
2896       } else {
2897         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2898       }
2899       // cpu register - address
2900     } else if (opr2-&gt;is_address()) {
2901       if (op-&gt;info() != NULL) {
2902         add_debug_info_for_null_check_here(op-&gt;info());
2903       }
2904       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2905     } else {
2906       ShouldNotReachHere();
2907     }
2908 
2909   } else if(opr1-&gt;is_double_cpu()) {
2910     Register xlo = opr1-&gt;as_register_lo();
2911     Register xhi = opr1-&gt;as_register_hi();
2912     if (opr2-&gt;is_double_cpu()) {
2913 #ifdef _LP64
2914       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2915 #else
2916       // cpu register - cpu register
2917       Register ylo = opr2-&gt;as_register_lo();
2918       Register yhi = opr2-&gt;as_register_hi();
2919       __ subl(xlo, ylo);
2920       __ sbbl(xhi, yhi);
2921       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2922         __ orl(xhi, xlo);
2923       }
2924 #endif // _LP64
2925     } else if (opr2-&gt;is_constant()) {
2926       // cpu register - constant 0
2927       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2928 #ifdef _LP64
2929       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2930 #else
2931       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2932       __ orl(xhi, xlo);
2933 #endif // _LP64
2934     } else {
2935       ShouldNotReachHere();
2936     }
2937 
2938   } else if (opr1-&gt;is_single_xmm()) {
2939     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2940     if (opr2-&gt;is_single_xmm()) {
2941       // xmm register - xmm register
2942       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2943     } else if (opr2-&gt;is_stack()) {
2944       // xmm register - stack
2945       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2946     } else if (opr2-&gt;is_constant()) {
2947       // xmm register - constant
2948       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2949     } else if (opr2-&gt;is_address()) {
2950       // xmm register - address
2951       if (op-&gt;info() != NULL) {
2952         add_debug_info_for_null_check_here(op-&gt;info());
2953       }
2954       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2955     } else {
2956       ShouldNotReachHere();
2957     }
2958 
2959   } else if (opr1-&gt;is_double_xmm()) {
2960     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2961     if (opr2-&gt;is_double_xmm()) {
2962       // xmm register - xmm register
2963       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2964     } else if (opr2-&gt;is_stack()) {
2965       // xmm register - stack
2966       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2967     } else if (opr2-&gt;is_constant()) {
2968       // xmm register - constant
2969       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2970     } else if (opr2-&gt;is_address()) {
2971       // xmm register - address
2972       if (op-&gt;info() != NULL) {
2973         add_debug_info_for_null_check_here(op-&gt;info());
2974       }
2975       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2976     } else {
2977       ShouldNotReachHere();
2978     }
2979 
2980 #ifndef _LP64
2981   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2982     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2983     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2984     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2985 #endif // LP64
2986 
2987   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2988     LIR_Const* c = opr2-&gt;as_constant_ptr();
2989 #ifdef _LP64
2990     if (is_reference_type(c-&gt;type())) {
2991       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2992       __ movoop(rscratch1, c-&gt;as_jobject());
2993     }
2994 #endif // LP64
2995     if (op-&gt;info() != NULL) {
2996       add_debug_info_for_null_check_here(op-&gt;info());
2997     }
2998     // special case: address - constant
2999     LIR_Address* addr = opr1-&gt;as_address_ptr();
3000     if (c-&gt;type() == T_INT) {
3001       __ cmpl(as_Address(addr), c-&gt;as_jint());
3002     } else if (is_reference_type(c-&gt;type())) {
3003 #ifdef _LP64
3004       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
3005       // better strategy by giving noreg as the temp for as_Address
3006       __ cmpoop(rscratch1, as_Address(addr, noreg));
3007 #else
3008       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
3009 #endif // _LP64
3010     } else {
3011       ShouldNotReachHere();
3012     }
3013 
3014   } else {
3015     ShouldNotReachHere();
3016   }
3017 }
3018 
3019 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
3020   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
3021     if (left-&gt;is_single_xmm()) {
3022       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
3023       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
3024     } else if (left-&gt;is_double_xmm()) {
3025       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
3026       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
3027 
3028     } else {
3029 #ifdef _LP64
3030       ShouldNotReachHere();
3031 #else
3032       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
3033       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
3034 
3035       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
3036       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
3037                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
3038 #endif // LP64
3039     }
3040   } else {
3041     assert(code == lir_cmp_l2i, &quot;check&quot;);
3042 #ifdef _LP64
3043     Label done;
3044     Register dest = dst-&gt;as_register();
3045     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
3046     __ movl(dest, -1);
3047     __ jccb(Assembler::less, done);
3048     __ set_byte_if_not_zero(dest);
3049     __ movzbl(dest, dest);
3050     __ bind(done);
3051 #else
3052     __ lcmp2int(left-&gt;as_register_hi(),
3053                 left-&gt;as_register_lo(),
3054                 right-&gt;as_register_hi(),
3055                 right-&gt;as_register_lo());
3056     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
3057 #endif // _LP64
3058   }
3059 }
3060 
3061 
3062 void LIR_Assembler::align_call(LIR_Code code) {
3063   // make sure that the displacement word of the call ends up word aligned
3064   int offset = __ offset();
3065   switch (code) {
3066   case lir_static_call:
3067   case lir_optvirtual_call:
3068   case lir_dynamic_call:
3069     offset += NativeCall::displacement_offset;
3070     break;
3071   case lir_icvirtual_call:
3072     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
3073     break;
3074   case lir_virtual_call:  // currently, sparc-specific for niagara
3075   default: ShouldNotReachHere();
3076   }
3077   __ align(BytesPerWord, offset);
3078 }
3079 
3080 
3081 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
3082   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
3083          &quot;must be aligned&quot;);
3084   __ call(AddressLiteral(op-&gt;addr(), rtype));
3085   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());
3086 }
3087 
3088 
3089 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
3090   __ ic_call(op-&gt;addr());
3091   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());
3092   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
3093          &quot;must be aligned&quot;);
3094 }
3095 
3096 
3097 /* Currently, vtable-dispatch is only enabled for sparc platforms */
3098 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
3099   ShouldNotReachHere();
3100 }
3101 
3102 
3103 void LIR_Assembler::emit_static_call_stub() {
3104   address call_pc = __ pc();
3105   address stub = __ start_a_stub(call_stub_size());
3106   if (stub == NULL) {
3107     bailout(&quot;static call stub overflow&quot;);
3108     return;
3109   }
3110 
3111   int start = __ offset();
3112 
3113   // make sure that the displacement word of the call ends up word aligned
3114   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
3115   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
3116   __ mov_metadata(rbx, (Metadata*)NULL);
3117   // must be set to -1 at code generation time
3118   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
3119   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
3120   __ jump(RuntimeAddress(__ pc()));
3121 
3122   if (UseAOT) {
3123     // Trampoline to aot code
3124     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
3125 #ifdef _LP64
3126     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
3127 #else
3128     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
3129 #endif
3130     __ jmp(rax);
3131   }
3132   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
3133   __ end_a_stub();
3134 }
3135 
3136 
3137 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
3138   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3139   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
3140 
3141   // exception object is not added to oop map by LinearScan
3142   // (LinearScan assumes that no oops are in fixed registers)
3143   info-&gt;add_register_oop(exceptionOop);
3144   Runtime1::StubID unwind_id;
3145 
3146   // get current pc information
3147   // pc is only needed if the method has an exception handler, the unwind code does not need it.
3148   int pc_for_athrow_offset = __ offset();
3149   InternalAddress pc_for_athrow(__ pc());
3150   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
3151   add_call_info(pc_for_athrow_offset, info); // for exception handler
3152 
3153   __ verify_not_null_oop(rax);
3154   // search an exception handler (rax: exception oop, rdx: throwing pc)
3155   if (compilation()-&gt;has_fpu_code()) {
3156     unwind_id = Runtime1::handle_exception_id;
3157   } else {
3158     unwind_id = Runtime1::handle_exception_nofpu_id;
3159   }
3160   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
3161 
3162   // enough room for two byte trap
3163   __ nop();
3164 }
3165 
3166 
3167 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
3168   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3169 
3170   __ jmp(_unwind_handler_entry);
3171 }
3172 
3173 
3174 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
3175 
3176   // optimized version for linear scan:
3177   // * count must be already in ECX (guaranteed by LinearScan)
3178   // * left and dest must be equal
3179   // * tmp must be unused
3180   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
3181   assert(left == dest, &quot;left and dest must be equal&quot;);
3182   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3183 
3184   if (left-&gt;is_single_cpu()) {
3185     Register value = left-&gt;as_register();
3186     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
3187 
3188     switch (code) {
3189       case lir_shl:  __ shll(value); break;
3190       case lir_shr:  __ sarl(value); break;
3191       case lir_ushr: __ shrl(value); break;
3192       default: ShouldNotReachHere();
3193     }
3194   } else if (left-&gt;is_double_cpu()) {
3195     Register lo = left-&gt;as_register_lo();
3196     Register hi = left-&gt;as_register_hi();
3197     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
3198 #ifdef _LP64
3199     switch (code) {
3200       case lir_shl:  __ shlptr(lo);        break;
3201       case lir_shr:  __ sarptr(lo);        break;
3202       case lir_ushr: __ shrptr(lo);        break;
3203       default: ShouldNotReachHere();
3204     }
3205 #else
3206 
3207     switch (code) {
3208       case lir_shl:  __ lshl(hi, lo);        break;
3209       case lir_shr:  __ lshr(hi, lo, true);  break;
3210       case lir_ushr: __ lshr(hi, lo, false); break;
3211       default: ShouldNotReachHere();
3212     }
3213 #endif // LP64
3214   } else {
3215     ShouldNotReachHere();
3216   }
3217 }
3218 
3219 
3220 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
3221   if (dest-&gt;is_single_cpu()) {
3222     // first move left into dest so that left is not destroyed by the shift
3223     Register value = dest-&gt;as_register();
3224     count = count &amp; 0x1F; // Java spec
3225 
3226     move_regs(left-&gt;as_register(), value);
3227     switch (code) {
3228       case lir_shl:  __ shll(value, count); break;
3229       case lir_shr:  __ sarl(value, count); break;
3230       case lir_ushr: __ shrl(value, count); break;
3231       default: ShouldNotReachHere();
3232     }
3233   } else if (dest-&gt;is_double_cpu()) {
3234 #ifndef _LP64
3235     Unimplemented();
3236 #else
3237     // first move left into dest so that left is not destroyed by the shift
3238     Register value = dest-&gt;as_register_lo();
3239     count = count &amp; 0x1F; // Java spec
3240 
3241     move_regs(left-&gt;as_register_lo(), value);
3242     switch (code) {
3243       case lir_shl:  __ shlptr(value, count); break;
3244       case lir_shr:  __ sarptr(value, count); break;
3245       case lir_ushr: __ shrptr(value, count); break;
3246       default: ShouldNotReachHere();
3247     }
3248 #endif // _LP64
3249   } else {
3250     ShouldNotReachHere();
3251   }
3252 }
3253 
3254 
3255 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
3256   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3257   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3258   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3259   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
3260 }
3261 
3262 
3263 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
3264   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3265   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3266   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3267   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3268 }
3269 
3270 
3271 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3272   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3273   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3274   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3275   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3276 }
3277 
3278 
3279 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3280   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3281   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3282   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3283   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3284 }
3285 
3286 
3287 void LIR_Assembler::arraycopy_valuetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest, bool null_check) {
3288   if (null_check) {
3289     __ testptr(obj, obj);
3290     __ jcc(Assembler::zero, *slow_path-&gt;entry());
3291   }
3292   __ load_storage_props(tmp, obj);
3293   if (is_dest) {
3294     // We also take slow path if it&#39;s a null_free destination array, just in case the source array
3295     // contains NULLs.
3296     __ testb(tmp, ArrayStorageProperties::flattened_value | ArrayStorageProperties::null_free_value);
3297   } else {
3298     __ testb(tmp, ArrayStorageProperties::flattened_value);
3299   }
3300   __ jcc(Assembler::notEqual, *slow_path-&gt;entry());
3301 }
3302 
3303 
3304 // This code replaces a call to arraycopy; no exception may
3305 // be thrown in this code, they must be thrown in the System.arraycopy
3306 // activation frame; we could save some checks if this would not be the case
3307 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3308   ciArrayKlass* default_type = op-&gt;expected_type();
3309   Register src = op-&gt;src()-&gt;as_register();
3310   Register dst = op-&gt;dst()-&gt;as_register();
3311   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3312   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3313   Register length  = op-&gt;length()-&gt;as_register();
3314   Register tmp = op-&gt;tmp()-&gt;as_register();
3315 
3316   __ resolve(ACCESS_READ, src);
3317   __ resolve(ACCESS_WRITE, dst);
3318 
3319   CodeStub* stub = op-&gt;stub();
3320   int flags = op-&gt;flags();
3321   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3322   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3323 
3324   if (flags &amp; LIR_OpArrayCopy::always_slow_path) {
3325     __ jmp(*stub-&gt;entry());
3326     __ bind(*stub-&gt;continuation());
3327     return;
3328   }
3329 
3330   if (flags &amp; LIR_OpArrayCopy::src_valuetype_check) {
3331     arraycopy_valuetype_check(src, tmp, stub, false, (flags &amp; LIR_OpArrayCopy::src_null_check));
3332   }
3333 
3334   if (flags &amp; LIR_OpArrayCopy::dst_valuetype_check) {
3335     arraycopy_valuetype_check(dst, tmp, stub, true, (flags &amp; LIR_OpArrayCopy::dst_null_check));
3336   }
3337 
3338   // if we don&#39;t know anything, just go through the generic arraycopy
3339   if (default_type == NULL) {
3340     // save outgoing arguments on stack in case call to System.arraycopy is needed
3341     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3342     // for interpreter calling conventions. Now we have to do it in new style conventions.
3343     // For the moment until C1 gets the new register allocator I just force all the
3344     // args to the right place (except the register args) and then on the back side
3345     // reload the register args properly if we go slow path. Yuck
3346 
3347     // These are proper for the calling convention
3348     store_parameter(length, 2);
3349     store_parameter(dst_pos, 1);
3350     store_parameter(dst, 0);
3351 
3352     // these are just temporary placements until we need to reload
3353     store_parameter(src_pos, 3);
3354     store_parameter(src, 4);
3355     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3356 
3357     address copyfunc_addr = StubRoutines::generic_arraycopy();
3358     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3359 
3360     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3361 #ifdef _LP64
3362     // The arguments are in java calling convention so we can trivially shift them to C
3363     // convention
3364     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3365     __ mov(c_rarg0, j_rarg0);
3366     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3367     __ mov(c_rarg1, j_rarg1);
3368     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3369     __ mov(c_rarg2, j_rarg2);
3370     assert_different_registers(c_rarg3, j_rarg4);
3371     __ mov(c_rarg3, j_rarg3);
3372 #ifdef _WIN64
3373     // Allocate abi space for args but be sure to keep stack aligned
3374     __ subptr(rsp, 6*wordSize);
3375     store_parameter(j_rarg4, 4);
3376 #ifndef PRODUCT
3377     if (PrintC1Statistics) {
3378       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3379     }
3380 #endif
3381     __ call(RuntimeAddress(copyfunc_addr));
3382     __ addptr(rsp, 6*wordSize);
3383 #else
3384     __ mov(c_rarg4, j_rarg4);
3385 #ifndef PRODUCT
3386     if (PrintC1Statistics) {
3387       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3388     }
3389 #endif
3390     __ call(RuntimeAddress(copyfunc_addr));
3391 #endif // _WIN64
3392 #else
3393     __ push(length);
3394     __ push(dst_pos);
3395     __ push(dst);
3396     __ push(src_pos);
3397     __ push(src);
3398 
3399 #ifndef PRODUCT
3400     if (PrintC1Statistics) {
3401       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3402     }
3403 #endif
3404     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3405 
3406 #endif // _LP64
3407 
3408     __ cmpl(rax, 0);
3409     __ jcc(Assembler::equal, *stub-&gt;continuation());
3410 
3411     __ mov(tmp, rax);
3412     __ xorl(tmp, -1);
3413 
3414     // Reload values from the stack so they are where the stub
3415     // expects them.
3416     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3417     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3418     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3419     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3420     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3421 
3422     __ subl(length, tmp);
3423     __ addl(src_pos, tmp);
3424     __ addl(dst_pos, tmp);
3425     __ jmp(*stub-&gt;entry());
3426 
3427     __ bind(*stub-&gt;continuation());
3428     return;
3429   }
3430 
3431   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3432 
3433   int elem_size = type2aelembytes(basic_type);
3434   Address::ScaleFactor scale;
3435 
3436   switch (elem_size) {
3437     case 1 :
3438       scale = Address::times_1;
3439       break;
3440     case 2 :
3441       scale = Address::times_2;
3442       break;
3443     case 4 :
3444       scale = Address::times_4;
3445       break;
3446     case 8 :
3447       scale = Address::times_8;
3448       break;
3449     default:
3450       scale = Address::no_scale;
3451       ShouldNotReachHere();
3452   }
3453 
3454   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3455   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3456   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3457   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3458 
3459   // length and pos&#39;s are all sign extended at this point on 64bit
3460 
3461   // test for NULL
3462   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3463     __ testptr(src, src);
3464     __ jcc(Assembler::zero, *stub-&gt;entry());
3465   }
3466   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3467     __ testptr(dst, dst);
3468     __ jcc(Assembler::zero, *stub-&gt;entry());
3469   }
3470 
3471   // If the compiler was not able to prove that exact type of the source or the destination
3472   // of the arraycopy is an array type, check at runtime if the source or the destination is
3473   // an instance type.
3474   if (flags &amp; LIR_OpArrayCopy::type_check) {
3475     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3476       __ load_klass(tmp, dst);
3477       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3478       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3479     }
3480 
3481     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3482       __ load_klass(tmp, src);
3483       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3484       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3485     }
3486   }
3487 
3488   // check if negative
3489   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3490     __ testl(src_pos, src_pos);
3491     __ jcc(Assembler::less, *stub-&gt;entry());
3492   }
3493   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3494     __ testl(dst_pos, dst_pos);
3495     __ jcc(Assembler::less, *stub-&gt;entry());
3496   }
3497 
3498   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3499     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3500     __ cmpl(tmp, src_length_addr);
3501     __ jcc(Assembler::above, *stub-&gt;entry());
3502   }
3503   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3504     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3505     __ cmpl(tmp, dst_length_addr);
3506     __ jcc(Assembler::above, *stub-&gt;entry());
3507   }
3508 
3509   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3510     __ testl(length, length);
3511     __ jcc(Assembler::less, *stub-&gt;entry());
3512   }
3513 
3514 #ifdef _LP64
3515   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3516   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3517 #endif
3518 
3519   if (flags &amp; LIR_OpArrayCopy::type_check) {
3520     // We don&#39;t know the array types are compatible
3521     if (basic_type != T_OBJECT) {
3522       // Simple test for basic type arrays
3523       if (UseCompressedClassPointers) {
3524         __ movl(tmp, src_klass_addr);
3525         __ cmpl(tmp, dst_klass_addr);
3526       } else {
3527         __ movptr(tmp, src_klass_addr);
3528         __ cmpptr(tmp, dst_klass_addr);
3529       }
3530       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3531     } else {
3532       // For object arrays, if src is a sub class of dst then we can
3533       // safely do the copy.
3534       Label cont, slow;
3535 
3536       __ push(src);
3537       __ push(dst);
3538 
3539       __ load_klass(src, src);
3540       __ load_klass(dst, dst);
3541 
3542       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3543 
3544       __ push(src);
3545       __ push(dst);
3546       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3547       __ pop(dst);
3548       __ pop(src);
3549 
3550       __ cmpl(src, 0);
3551       __ jcc(Assembler::notEqual, cont);
3552 
3553       __ bind(slow);
3554       __ pop(dst);
3555       __ pop(src);
3556 
3557       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3558       if (copyfunc_addr != NULL) { // use stub if available
3559         // src is not a sub class of dst so we have to do a
3560         // per-element check.
3561 
3562         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3563         if ((flags &amp; mask) != mask) {
3564           // Check that at least both of them object arrays.
3565           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3566 
3567           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3568             __ load_klass(tmp, src);
3569           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3570             __ load_klass(tmp, dst);
3571           }
3572           int lh_offset = in_bytes(Klass::layout_helper_offset());
3573           Address klass_lh_addr(tmp, lh_offset);
3574           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3575           __ cmpl(klass_lh_addr, objArray_lh);
3576           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3577         }
3578 
3579        // Spill because stubs can use any register they like and it&#39;s
3580        // easier to restore just those that we care about.
3581        store_parameter(dst, 0);
3582        store_parameter(dst_pos, 1);
3583        store_parameter(length, 2);
3584        store_parameter(src_pos, 3);
3585        store_parameter(src, 4);
3586 
3587 #ifndef _LP64
3588         __ movptr(tmp, dst_klass_addr);
3589         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3590         __ push(tmp);
3591         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3592         __ push(tmp);
3593         __ push(length);
3594         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3595         __ push(tmp);
3596         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3597         __ push(tmp);
3598 
3599         __ call_VM_leaf(copyfunc_addr, 5);
3600 #else
3601         __ movl2ptr(length, length); //higher 32bits must be null
3602 
3603         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3604         assert_different_registers(c_rarg0, dst, dst_pos, length);
3605         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3606         assert_different_registers(c_rarg1, dst, length);
3607 
3608         __ mov(c_rarg2, length);
3609         assert_different_registers(c_rarg2, dst);
3610 
3611 #ifdef _WIN64
3612         // Allocate abi space for args but be sure to keep stack aligned
3613         __ subptr(rsp, 6*wordSize);
3614         __ load_klass(c_rarg3, dst);
3615         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3616         store_parameter(c_rarg3, 4);
3617         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3618         __ call(RuntimeAddress(copyfunc_addr));
3619         __ addptr(rsp, 6*wordSize);
3620 #else
3621         __ load_klass(c_rarg4, dst);
3622         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3623         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3624         __ call(RuntimeAddress(copyfunc_addr));
3625 #endif
3626 
3627 #endif
3628 
3629 #ifndef PRODUCT
3630         if (PrintC1Statistics) {
3631           Label failed;
3632           __ testl(rax, rax);
3633           __ jcc(Assembler::notZero, failed);
3634           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3635           __ bind(failed);
3636         }
3637 #endif
3638 
3639         __ testl(rax, rax);
3640         __ jcc(Assembler::zero, *stub-&gt;continuation());
3641 
3642 #ifndef PRODUCT
3643         if (PrintC1Statistics) {
3644           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3645         }
3646 #endif
3647 
3648         __ mov(tmp, rax);
3649 
3650         __ xorl(tmp, -1);
3651 
3652         // Restore previously spilled arguments
3653         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3654         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3655         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3656         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3657         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3658 
3659 
3660         __ subl(length, tmp);
3661         __ addl(src_pos, tmp);
3662         __ addl(dst_pos, tmp);
3663       }
3664 
3665       __ jmp(*stub-&gt;entry());
3666 
3667       __ bind(cont);
3668       __ pop(dst);
3669       __ pop(src);
3670     }
3671   }
3672 
3673 #ifdef ASSERT
3674   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3675     // Sanity check the known type with the incoming class.  For the
3676     // primitive case the types must match exactly with src.klass and
3677     // dst.klass each exactly matching the default type.  For the
3678     // object array case, if no type check is needed then either the
3679     // dst type is exactly the expected type and the src type is a
3680     // subtype which we can&#39;t check or src is the same array as dst
3681     // but not necessarily exactly of type default_type.
3682     Label known_ok, halt;
3683     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3684 #ifdef _LP64
3685     if (UseCompressedClassPointers) {
3686       __ encode_klass_not_null(tmp);
3687     }
3688 #endif
3689 
3690     if (basic_type != T_OBJECT) {
3691 
3692       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3693       else                   __ cmpptr(tmp, dst_klass_addr);
3694       __ jcc(Assembler::notEqual, halt);
3695       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3696       else                   __ cmpptr(tmp, src_klass_addr);
3697       __ jcc(Assembler::equal, known_ok);
3698     } else {
3699       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3700       else                   __ cmpptr(tmp, dst_klass_addr);
3701       __ jcc(Assembler::equal, known_ok);
3702       __ cmpptr(src, dst);
3703       __ jcc(Assembler::equal, known_ok);
3704     }
3705     __ bind(halt);
3706     __ stop(&quot;incorrect type information in arraycopy&quot;);
3707     __ bind(known_ok);
3708   }
3709 #endif
3710 
3711 #ifndef PRODUCT
3712   if (PrintC1Statistics) {
3713     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3714   }
3715 #endif
3716 
3717 #ifdef _LP64
3718   assert_different_registers(c_rarg0, dst, dst_pos, length);
3719   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3720   assert_different_registers(c_rarg1, length);
3721   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3722   __ mov(c_rarg2, length);
3723 
3724 #else
3725   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3726   store_parameter(tmp, 0);
3727   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3728   store_parameter(tmp, 1);
3729   store_parameter(length, 2);
3730 #endif // _LP64
3731 
3732   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3733   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3734   const char *name;
3735   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3736   __ call_VM_leaf(entry, 0);
3737 
3738   __ bind(*stub-&gt;continuation());
3739 }
3740 
3741 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3742   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3743   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3744   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3745   Register crc = op-&gt;crc()-&gt;as_register();
3746   Register val = op-&gt;val()-&gt;as_register();
3747   Register res = op-&gt;result_opr()-&gt;as_register();
3748 
3749   assert_different_registers(val, crc, res);
3750 
3751   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3752   __ notl(crc); // ~crc
3753   __ update_byte_crc32(crc, val, res);
3754   __ notl(crc); // ~crc
3755   __ mov(res, crc);
3756 }
3757 
3758 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3759   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3760   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3761   Register lock = op-&gt;lock_opr()-&gt;as_register();
3762   if (!UseFastLocking) {
3763     __ jmp(*op-&gt;stub()-&gt;entry());
3764   } else if (op-&gt;code() == lir_lock) {
3765     Register scratch = noreg;
3766     if (UseBiasedLocking) {
3767       scratch = op-&gt;scratch_opr()-&gt;as_register();
3768     }
3769     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3770     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3771     // add debug info for NullPointerException only if one is possible
3772     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3773     if (op-&gt;info() != NULL) {
3774       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3775     }
3776     // done
3777   } else if (op-&gt;code() == lir_unlock) {
3778     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3779     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3780   } else {
3781     Unimplemented();
3782   }
3783   __ bind(*op-&gt;stub()-&gt;continuation());
3784 }
3785 
3786 
3787 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3788   ciMethod* method = op-&gt;profiled_method();
3789   int bci          = op-&gt;profiled_bci();
3790   ciMethod* callee = op-&gt;profiled_callee();
3791 
3792   // Update counter for all call types
3793   ciMethodData* md = method-&gt;method_data_or_null();
3794   assert(md != NULL, &quot;Sanity&quot;);
3795   ciProfileData* data = md-&gt;bci_to_data(bci);
3796   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3797   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3798   Register mdo  = op-&gt;mdo()-&gt;as_register();
3799   __ mov_metadata(mdo, md-&gt;constant_encoding());
3800   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3801   // Perform additional virtual call profiling for invokevirtual and
3802   // invokeinterface bytecodes
3803   if (op-&gt;should_profile_receiver_type()) {
3804     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3805     Register recv = op-&gt;recv()-&gt;as_register();
3806     assert_different_registers(mdo, recv);
3807     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3808     ciKlass* known_klass = op-&gt;known_holder();
3809     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3810       // We know the type that will be seen at this call site; we can
3811       // statically update the MethodData* rather than needing to do
3812       // dynamic tests on the receiver type
3813 
3814       // NOTE: we should probably put a lock around this search to
3815       // avoid collisions by concurrent compilations
3816       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3817       uint i;
3818       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3819         ciKlass* receiver = vc_data-&gt;receiver(i);
3820         if (known_klass-&gt;equals(receiver)) {
3821           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3822           __ addptr(data_addr, DataLayout::counter_increment);
3823           return;
3824         }
3825       }
3826 
3827       // Receiver type not found in profile data; select an empty slot
3828 
3829       // Note that this is less efficient than it should be because it
3830       // always does a write to the receiver part of the
3831       // VirtualCallData rather than just the first time
3832       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3833         ciKlass* receiver = vc_data-&gt;receiver(i);
3834         if (receiver == NULL) {
3835           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3836           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3837           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3838           __ addptr(data_addr, DataLayout::counter_increment);
3839           return;
3840         }
3841       }
3842     } else {
3843       __ load_klass(recv, recv);
3844       Label update_done;
3845       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3846       // Receiver did not match any saved receiver and there is no empty row for it.
3847       // Increment total counter to indicate polymorphic case.
3848       __ addptr(counter_addr, DataLayout::counter_increment);
3849 
3850       __ bind(update_done);
3851     }
3852   } else {
3853     // Static call
3854     __ addptr(counter_addr, DataLayout::counter_increment);
3855   }
3856 }
3857 
3858 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3859   Register obj = op-&gt;obj()-&gt;as_register();
3860   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3861   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3862   ciKlass* exact_klass = op-&gt;exact_klass();
3863   intptr_t current_klass = op-&gt;current_klass();
3864   bool not_null = op-&gt;not_null();
3865   bool no_conflict = op-&gt;no_conflict();
3866 
3867   Label update, next, none;
3868 
3869   bool do_null = !not_null;
3870   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3871   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3872 
3873   assert(do_null || do_update, &quot;why are we here?&quot;);
3874   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3875 
3876   __ verify_oop(obj);
3877 
3878   if (tmp != obj) {
3879     __ mov(tmp, obj);
3880   }
3881   if (do_null) {
3882     __ testptr(tmp, tmp);
3883     __ jccb(Assembler::notZero, update);
3884     if (!TypeEntries::was_null_seen(current_klass)) {
3885       __ orptr(mdo_addr, TypeEntries::null_seen);
3886     }
3887     if (do_update) {
3888 #ifndef ASSERT
3889       __ jmpb(next);
3890     }
3891 #else
3892       __ jmp(next);
3893     }
3894   } else {
3895     __ testptr(tmp, tmp);
3896     __ jcc(Assembler::notZero, update);
3897     __ stop(&quot;unexpect null obj&quot;);
3898 #endif
3899   }
3900 
3901   __ bind(update);
3902 
3903   if (do_update) {
3904 #ifdef ASSERT
3905     if (exact_klass != NULL) {
3906       Label ok;
3907       __ load_klass(tmp, tmp);
3908       __ push(tmp);
3909       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3910       __ cmpptr(tmp, Address(rsp, 0));
3911       __ jcc(Assembler::equal, ok);
3912       __ stop(&quot;exact klass and actual klass differ&quot;);
3913       __ bind(ok);
3914       __ pop(tmp);
3915     }
3916 #endif
3917     if (!no_conflict) {
3918       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3919         if (exact_klass != NULL) {
3920           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3921         } else {
3922           __ load_klass(tmp, tmp);
3923         }
3924 
3925         __ xorptr(tmp, mdo_addr);
3926         __ testptr(tmp, TypeEntries::type_klass_mask);
3927         // klass seen before, nothing to do. The unknown bit may have been
3928         // set already but no need to check.
3929         __ jccb(Assembler::zero, next);
3930 
3931         __ testptr(tmp, TypeEntries::type_unknown);
3932         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3933 
3934         if (TypeEntries::is_type_none(current_klass)) {
3935           __ cmpptr(mdo_addr, 0);
3936           __ jccb(Assembler::equal, none);
3937           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3938           __ jccb(Assembler::equal, none);
3939           // There is a chance that the checks above (re-reading profiling
3940           // data from memory) fail if another thread has just set the
3941           // profiling to this obj&#39;s klass
3942           __ xorptr(tmp, mdo_addr);
3943           __ testptr(tmp, TypeEntries::type_klass_mask);
3944           __ jccb(Assembler::zero, next);
3945         }
3946       } else {
3947         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3948                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3949 
3950         __ movptr(tmp, mdo_addr);
3951         __ testptr(tmp, TypeEntries::type_unknown);
3952         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3953       }
3954 
3955       // different than before. Cannot keep accurate profile.
3956       __ orptr(mdo_addr, TypeEntries::type_unknown);
3957 
3958       if (TypeEntries::is_type_none(current_klass)) {
3959         __ jmpb(next);
3960 
3961         __ bind(none);
3962         // first time here. Set profile type.
3963         __ movptr(mdo_addr, tmp);
3964       }
3965     } else {
3966       // There&#39;s a single possible klass at this profile point
3967       assert(exact_klass != NULL, &quot;should be&quot;);
3968       if (TypeEntries::is_type_none(current_klass)) {
3969         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3970         __ xorptr(tmp, mdo_addr);
3971         __ testptr(tmp, TypeEntries::type_klass_mask);
3972 #ifdef ASSERT
3973         __ jcc(Assembler::zero, next);
3974 
3975         {
3976           Label ok;
3977           __ push(tmp);
3978           __ cmpptr(mdo_addr, 0);
3979           __ jcc(Assembler::equal, ok);
3980           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3981           __ jcc(Assembler::equal, ok);
3982           // may have been set by another thread
3983           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3984           __ xorptr(tmp, mdo_addr);
3985           __ testptr(tmp, TypeEntries::type_mask);
3986           __ jcc(Assembler::zero, ok);
3987 
3988           __ stop(&quot;unexpected profiling mismatch&quot;);
3989           __ bind(ok);
3990           __ pop(tmp);
3991         }
3992 #else
3993         __ jccb(Assembler::zero, next);
3994 #endif
3995         // first time here. Set profile type.
3996         __ movptr(mdo_addr, tmp);
3997       } else {
3998         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3999                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
4000 
4001         __ movptr(tmp, mdo_addr);
4002         __ testptr(tmp, TypeEntries::type_unknown);
4003         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
4004 
4005         __ orptr(mdo_addr, TypeEntries::type_unknown);
4006       }
4007     }
4008 
4009     __ bind(next);
4010   }
4011 }
4012 
4013 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
4014   Unimplemented();
4015 }
4016 
4017 
4018 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
4019   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
4020 }
4021 
4022 
4023 void LIR_Assembler::align_backward_branch_target() {
4024   __ align(BytesPerWord);
4025 }
4026 
4027 
4028 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
4029   if (left-&gt;is_single_cpu()) {
4030     __ negl(left-&gt;as_register());
4031     move_regs(left-&gt;as_register(), dest-&gt;as_register());
4032 
4033   } else if (left-&gt;is_double_cpu()) {
4034     Register lo = left-&gt;as_register_lo();
4035 #ifdef _LP64
4036     Register dst = dest-&gt;as_register_lo();
4037     __ movptr(dst, lo);
4038     __ negptr(dst);
4039 #else
4040     Register hi = left-&gt;as_register_hi();
4041     __ lneg(hi, lo);
4042     if (dest-&gt;as_register_lo() == hi) {
4043       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
4044       move_regs(hi, dest-&gt;as_register_hi());
4045       move_regs(lo, dest-&gt;as_register_lo());
4046     } else {
4047       move_regs(lo, dest-&gt;as_register_lo());
4048       move_regs(hi, dest-&gt;as_register_hi());
4049     }
4050 #endif // _LP64
4051 
4052   } else if (dest-&gt;is_single_xmm()) {
4053 #ifdef _LP64
4054     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
4055       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
4056       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
4057       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
4058     }
4059     else
4060 #endif
4061     {
4062       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
4063       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
4064         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
4065       }
4066       __ xorps(dest-&gt;as_xmm_float_reg(),
4067                ExternalAddress((address)float_signflip_pool));
4068     }
4069   } else if (dest-&gt;is_double_xmm()) {
4070 #ifdef _LP64
4071     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
4072       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
4073       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
4074       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
4075     }
4076     else
4077 #endif
4078     {
4079       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
4080       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
4081         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
4082       }
4083       __ xorpd(dest-&gt;as_xmm_double_reg(),
4084                ExternalAddress((address)double_signflip_pool));
4085     }
4086 #ifndef _LP64
4087   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
4088     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
4089     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
4090     __ fchs();
4091 #endif // !_LP64
4092 
4093   } else {
4094     ShouldNotReachHere();
4095   }
4096 }
4097 
4098 
4099 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
4100   assert(src-&gt;is_address(), &quot;must be an address&quot;);
4101   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
4102 
4103   PatchingStub* patch = NULL;
4104   if (patch_code != lir_patch_none) {
4105     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
4106   }
4107 
4108   Register reg = dest-&gt;as_pointer_register();
4109   LIR_Address* addr = src-&gt;as_address_ptr();
4110   __ lea(reg, as_Address(addr));
4111 
4112   if (patch != NULL) {
4113     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
4114   }
4115 }
4116 
4117 
4118 
4119 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
4120   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
4121   __ call(RuntimeAddress(dest));
4122   if (info != NULL) {
4123     add_call_info_here(info);
4124   }
4125 }
4126 
4127 
4128 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
4129   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
4130 
4131   if (info != NULL) {
4132     add_debug_info_for_null_check_here(info);
4133   }
4134 
4135   if (src-&gt;is_double_xmm()) {
4136     if (dest-&gt;is_double_cpu()) {
4137 #ifdef _LP64
4138       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
4139 #else
4140       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
4141       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
4142       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
4143 #endif // _LP64
4144     } else if (dest-&gt;is_double_stack()) {
4145       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
4146     } else if (dest-&gt;is_address()) {
4147       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
4148     } else {
4149       ShouldNotReachHere();
4150     }
4151 
4152   } else if (dest-&gt;is_double_xmm()) {
4153     if (src-&gt;is_double_stack()) {
4154       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
4155     } else if (src-&gt;is_address()) {
4156       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
4157     } else {
4158       ShouldNotReachHere();
4159     }
4160 
4161 #ifndef _LP64
4162   } else if (src-&gt;is_double_fpu()) {
4163     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
4164     if (dest-&gt;is_double_stack()) {
4165       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
4166     } else if (dest-&gt;is_address()) {
4167       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
4168     } else {
4169       ShouldNotReachHere();
4170     }
4171 
4172   } else if (dest-&gt;is_double_fpu()) {
4173     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
4174     if (src-&gt;is_double_stack()) {
4175       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
4176     } else if (src-&gt;is_address()) {
4177       __ fild_d(as_Address(src-&gt;as_address_ptr()));
4178     } else {
4179       ShouldNotReachHere();
4180     }
4181 #endif // !_LP64
4182 
4183   } else {
4184     ShouldNotReachHere();
4185   }
4186 }
4187 
4188 #ifdef ASSERT
4189 // emit run-time assertion
4190 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
4191   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
4192 
4193   if (op-&gt;in_opr1()-&gt;is_valid()) {
4194     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
4195     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
4196   } else {
4197     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
4198     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
4199   }
4200 
4201   Label ok;
4202   if (op-&gt;condition() != lir_cond_always) {
4203     Assembler::Condition acond = Assembler::zero;
4204     switch (op-&gt;condition()) {
4205       case lir_cond_equal:        acond = Assembler::equal;       break;
4206       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
4207       case lir_cond_less:         acond = Assembler::less;        break;
4208       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
4209       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
4210       case lir_cond_greater:      acond = Assembler::greater;     break;
4211       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
4212       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
4213       default:                    ShouldNotReachHere();
4214     }
4215     __ jcc(acond, ok);
4216   }
4217   if (op-&gt;halt()) {
4218     const char* str = __ code_string(op-&gt;msg());
4219     __ stop(str);
4220   } else {
4221     breakpoint();
4222   }
4223   __ bind(ok);
4224 }
4225 #endif
4226 
4227 void LIR_Assembler::membar() {
4228   // QQQ sparc TSO uses this,
4229   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
4230 }
4231 
4232 void LIR_Assembler::membar_acquire() {
4233   // No x86 machines currently require load fences
4234 }
4235 
4236 void LIR_Assembler::membar_release() {
4237   // No x86 machines currently require store fences
4238 }
4239 
4240 void LIR_Assembler::membar_loadload() {
4241   // no-op
4242   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
4243 }
4244 
4245 void LIR_Assembler::membar_storestore() {
4246   // no-op
4247   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
4248 }
4249 
4250 void LIR_Assembler::membar_loadstore() {
4251   // no-op
4252   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
4253 }
4254 
4255 void LIR_Assembler::membar_storeload() {
4256   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4257 }
4258 
4259 void LIR_Assembler::on_spin_wait() {
4260   __ pause ();
4261 }
4262 
4263 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4264   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4265 #ifdef _LP64
4266   // __ get_thread(result_reg-&gt;as_register_lo());
4267   __ mov(result_reg-&gt;as_register(), r15_thread);
4268 #else
4269   __ get_thread(result_reg-&gt;as_register());
4270 #endif // _LP64
4271 }
4272 
4273 void LIR_Assembler::check_orig_pc() {
4274   __ cmpptr(frame_map()-&gt;address_for_orig_pc_addr(), (int32_t)NULL_WORD);
4275 }
4276 
4277 void LIR_Assembler::peephole(LIR_List*) {
4278   // do nothing for now
4279 }
4280 
4281 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4282   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4283 
4284   if (data-&gt;type() == T_INT) {
4285     if (code == lir_xadd) {
4286       __ lock();
4287       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4288     } else {
4289       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4290     }
4291   } else if (data-&gt;is_oop()) {
4292     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4293     Register obj = data-&gt;as_register();
4294 #ifdef _LP64
4295     if (UseCompressedOops) {
4296       __ encode_heap_oop(obj);
4297       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4298       __ decode_heap_oop(obj);
4299     } else {
4300       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
4301     }
4302 #else
4303     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4304 #endif
4305   } else if (data-&gt;type() == T_LONG) {
4306 #ifdef _LP64
4307     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4308     if (code == lir_xadd) {
4309       __ lock();
4310       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4311     } else {
4312       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4313     }
4314 #else
4315     ShouldNotReachHere();
4316 #endif
4317   } else {
4318     ShouldNotReachHere();
4319   }
4320 }
4321 
4322 #undef __
    </pre>
  </body>
</html>
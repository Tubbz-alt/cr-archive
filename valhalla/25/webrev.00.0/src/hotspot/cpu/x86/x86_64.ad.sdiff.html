<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/formssel.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
<span class="line-removed">  462 // Indicate if the safepoint node needs the polling page as an input,</span>
<span class="line-removed">  463 // it does if the polling page is more than disp32 away.</span>
<span class="line-removed">  464 bool SafePointNode::needs_polling_address_input()</span>
<span class="line-removed">  465 {</span>
<span class="line-removed">  466   return SafepointMechanism::uses_thread_local_poll() || Assembler::is_polling_page_far();</span>
<span class="line-removed">  467 }</span>
<span class="line-removed">  468 </span>
  469 //
  470 // Compute padding required for nodes which need alignment
  471 //
  472 
  473 // The address of the call instruction needs to be 4-byte aligned to
  474 // ensure that it does not span a cache line so that it can be patched.
  475 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  476 {
  477   current_offset += clear_avx_size(); // skip vzeroupper
  478   current_offset += 1; // skip call opcode byte
  479   return align_up(current_offset, alignment_required()) - current_offset;
  480 }
  481 
  482 // The address of the call instruction needs to be 4-byte aligned to
  483 // ensure that it does not span a cache line so that it can be patched.
  484 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  485 {
  486   current_offset += clear_avx_size(); // skip vzeroupper
  487   current_offset += 11; // skip movq instruction + call opcode byte
  488   return align_up(current_offset, alignment_required()) - current_offset;
</pre>
<hr />
<pre>
  919   Compile* C = ra_-&gt;C;
  920   if (generate_vzeroupper(C)) {
  921     st-&gt;print(&quot;vzeroupper&quot;);
  922     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  923   }
  924 
  925   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  926   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  927   // Remove word for return adr already pushed
  928   // and RBP
  929   framesize -= 2*wordSize;
  930 
  931   if (framesize) {
  932     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  933     st-&gt;print(&quot;\t&quot;);
  934   }
  935 
  936   st-&gt;print_cr(&quot;popq    rbp&quot;);
  937   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  938     st-&gt;print(&quot;\t&quot;);
<span class="line-modified">  939     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">  940       st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;</span>
<span class="line-modified">  941                    &quot;testl   rax, [rscratch1]\t&quot;</span>
<span class="line-removed">  942                    &quot;# Safepoint: poll for GC&quot;);</span>
<span class="line-removed">  943     } else if (Assembler::is_polling_page_far()) {</span>
<span class="line-removed">  944       st-&gt;print_cr(&quot;movq    rscratch1, #polling_page_address\n\t&quot;</span>
<span class="line-removed">  945                    &quot;testl   rax, [rscratch1]\t&quot;</span>
<span class="line-removed">  946                    &quot;# Safepoint: poll for GC&quot;);</span>
<span class="line-removed">  947     } else {</span>
<span class="line-removed">  948       st-&gt;print_cr(&quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;</span>
<span class="line-removed">  949                    &quot;# Safepoint: poll for GC&quot;);</span>
<span class="line-removed">  950     }</span>
  951   }
  952 }
  953 #endif
  954 
  955 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  956 {
  957   Compile* C = ra_-&gt;C;
  958   MacroAssembler _masm(&amp;cbuf);
  959 
  960   if (generate_vzeroupper(C)) {
  961     // Clear upper bits of YMM registers when current compiled code uses
  962     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  963     __ vzeroupper();
  964   }
  965 
  966   // Subtract two words to account for return address and rbp
  967   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;
  968   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());
  969 
  970   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  971     __ reserved_stack_check();
  972   }
  973 
  974   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  975     MacroAssembler _masm(&amp;cbuf);
<span class="line-modified">  976     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">  977       __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));</span>
<span class="line-modified">  978       __ relocate(relocInfo::poll_return_type);</span>
<span class="line-removed">  979       __ testl(rax, Address(rscratch1, 0));</span>
<span class="line-removed">  980     } else {</span>
<span class="line-removed">  981       AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);</span>
<span class="line-removed">  982       if (Assembler::is_polling_page_far()) {</span>
<span class="line-removed">  983         __ lea(rscratch1, polling_page);</span>
<span class="line-removed">  984         __ relocate(relocInfo::poll_return_type);</span>
<span class="line-removed">  985         __ testl(rax, Address(rscratch1, 0));</span>
<span class="line-removed">  986       } else {</span>
<span class="line-removed">  987         __ testl(rax, polling_page);</span>
<span class="line-removed">  988       }</span>
<span class="line-removed">  989     }</span>
  990   }
  991 }
  992 
  993 int MachEpilogNode::reloc() const
  994 {
  995   return 2; // a large enough number
  996 }
  997 
  998 const Pipeline* MachEpilogNode::pipeline() const
  999 {
 1000   return MachNode::pipeline_class();
 1001 }
 1002 
<span class="line-removed"> 1003 int MachEpilogNode::safepoint_offset() const</span>
<span class="line-removed"> 1004 {</span>
<span class="line-removed"> 1005   return 0;</span>
<span class="line-removed"> 1006 }</span>
<span class="line-removed"> 1007 </span>
 1008 //=============================================================================
 1009 
 1010 enum RC {
 1011   rc_bad,
 1012   rc_int,
 1013   rc_float,
 1014   rc_stack
 1015 };
 1016 
 1017 static enum RC rc_class(OptoReg::Name reg)
 1018 {
 1019   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1020 
 1021   if (OptoReg::is_stack(reg)) return rc_stack;
 1022 
 1023   VMReg r = OptoReg::as_VMReg(reg);
 1024 
 1025   if (r-&gt;is_Register()) return rc_int;
 1026 
 1027   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
</pre>
<hr />
<pre>
12705     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12706                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12707   %}
12708   ins_pipe(pipe_slow);
12709 %}
12710 
12711 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12712   match(Set cr (FastUnlock object box));
12713   effect(TEMP tmp, USE_KILL box);
12714   ins_cost(300);
12715   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12716   ins_encode %{
12717     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12718   %}
12719   ins_pipe(pipe_slow);
12720 %}
12721 
12722 
12723 // ============================================================================
12724 // Safepoint Instructions
<span class="line-removed">12725 instruct safePoint_poll(rFlagsReg cr)</span>
<span class="line-removed">12726 %{</span>
<span class="line-removed">12727   predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());</span>
<span class="line-removed">12728   match(SafePoint);</span>
<span class="line-removed">12729   effect(KILL cr);</span>
<span class="line-removed">12730 </span>
<span class="line-removed">12731   format %{ &quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;</span>
<span class="line-removed">12732             &quot;# Safepoint: poll for GC&quot; %}</span>
<span class="line-removed">12733   ins_cost(125);</span>
<span class="line-removed">12734   ins_encode %{</span>
<span class="line-removed">12735     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);</span>
<span class="line-removed">12736     __ testl(rax, addr);</span>
<span class="line-removed">12737   %}</span>
<span class="line-removed">12738   ins_pipe(ialu_reg_mem);</span>
<span class="line-removed">12739 %}</span>
<span class="line-removed">12740 </span>
<span class="line-removed">12741 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)</span>
<span class="line-removed">12742 %{</span>
<span class="line-removed">12743   predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());</span>
<span class="line-removed">12744   match(SafePoint poll);</span>
<span class="line-removed">12745   effect(KILL cr, USE poll);</span>
<span class="line-removed">12746 </span>
<span class="line-removed">12747   format %{ &quot;testl   rax, [$poll]\t&quot;</span>
<span class="line-removed">12748             &quot;# Safepoint: poll for GC&quot; %}</span>
<span class="line-removed">12749   ins_cost(125);</span>
<span class="line-removed">12750   ins_encode %{</span>
<span class="line-removed">12751     __ relocate(relocInfo::poll_type);</span>
<span class="line-removed">12752     __ testl(rax, Address($poll$$Register, 0));</span>
<span class="line-removed">12753   %}</span>
<span class="line-removed">12754   ins_pipe(ialu_reg_mem);</span>
<span class="line-removed">12755 %}</span>
<span class="line-removed">12756 </span>
12757 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12758 %{
<span class="line-removed">12759   predicate(SafepointMechanism::uses_thread_local_poll());</span>
12760   match(SafePoint poll);
12761   effect(KILL cr, USE poll);
12762 
12763   format %{ &quot;testl   rax, [$poll]\t&quot;
12764             &quot;# Safepoint: poll for GC&quot; %}
12765   ins_cost(125);
12766   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12767   ins_encode %{
12768     __ relocate(relocInfo::poll_type);
12769     address pre_pc = __ pc();
12770     __ testl(rax, Address($poll$$Register, 0));
12771     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12772   %}
12773   ins_pipe(ialu_reg_mem);
12774 %}
12775 
12776 // ============================================================================
12777 // Procedure Call/Return Instructions
12778 // Call Java Static Instruction
12779 // Note: If this code changes, the corresponding ret_addr_offset() and
</pre>
</td>
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 







  462 //
  463 // Compute padding required for nodes which need alignment
  464 //
  465 
  466 // The address of the call instruction needs to be 4-byte aligned to
  467 // ensure that it does not span a cache line so that it can be patched.
  468 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  469 {
  470   current_offset += clear_avx_size(); // skip vzeroupper
  471   current_offset += 1; // skip call opcode byte
  472   return align_up(current_offset, alignment_required()) - current_offset;
  473 }
  474 
  475 // The address of the call instruction needs to be 4-byte aligned to
  476 // ensure that it does not span a cache line so that it can be patched.
  477 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  478 {
  479   current_offset += clear_avx_size(); // skip vzeroupper
  480   current_offset += 11; // skip movq instruction + call opcode byte
  481   return align_up(current_offset, alignment_required()) - current_offset;
</pre>
<hr />
<pre>
  912   Compile* C = ra_-&gt;C;
  913   if (generate_vzeroupper(C)) {
  914     st-&gt;print(&quot;vzeroupper&quot;);
  915     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  916   }
  917 
  918   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  919   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  920   // Remove word for return adr already pushed
  921   // and RBP
  922   framesize -= 2*wordSize;
  923 
  924   if (framesize) {
  925     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  926     st-&gt;print(&quot;\t&quot;);
  927   }
  928 
  929   st-&gt;print_cr(&quot;popq    rbp&quot;);
  930   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  931     st-&gt;print(&quot;\t&quot;);
<span class="line-modified">  932     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;</span>
<span class="line-modified">  933                  &quot;testl   rax, [rscratch1]\t&quot;</span>
<span class="line-modified">  934                  &quot;# Safepoint: poll for GC&quot;);</span>









  935   }
  936 }
  937 #endif
  938 
  939 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  940 {
  941   Compile* C = ra_-&gt;C;
  942   MacroAssembler _masm(&amp;cbuf);
  943 
  944   if (generate_vzeroupper(C)) {
  945     // Clear upper bits of YMM registers when current compiled code uses
  946     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  947     __ vzeroupper();
  948   }
  949 
  950   // Subtract two words to account for return address and rbp
  951   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;
  952   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());
  953 
  954   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  955     __ reserved_stack_check();
  956   }
  957 
  958   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  959     MacroAssembler _masm(&amp;cbuf);
<span class="line-modified">  960     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));</span>
<span class="line-modified">  961     __ relocate(relocInfo::poll_return_type);</span>
<span class="line-modified">  962     __ testl(rax, Address(rscratch1, 0));</span>











  963   }
  964 }
  965 
  966 int MachEpilogNode::reloc() const
  967 {
  968   return 2; // a large enough number
  969 }
  970 
  971 const Pipeline* MachEpilogNode::pipeline() const
  972 {
  973   return MachNode::pipeline_class();
  974 }
  975 





  976 //=============================================================================
  977 
  978 enum RC {
  979   rc_bad,
  980   rc_int,
  981   rc_float,
  982   rc_stack
  983 };
  984 
  985 static enum RC rc_class(OptoReg::Name reg)
  986 {
  987   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  988 
  989   if (OptoReg::is_stack(reg)) return rc_stack;
  990 
  991   VMReg r = OptoReg::as_VMReg(reg);
  992 
  993   if (r-&gt;is_Register()) return rc_int;
  994 
  995   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
</pre>
<hr />
<pre>
12673     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12674                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12675   %}
12676   ins_pipe(pipe_slow);
12677 %}
12678 
12679 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12680   match(Set cr (FastUnlock object box));
12681   effect(TEMP tmp, USE_KILL box);
12682   ins_cost(300);
12683   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12684   ins_encode %{
12685     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12686   %}
12687   ins_pipe(pipe_slow);
12688 %}
12689 
12690 
12691 // ============================================================================
12692 // Safepoint Instructions
































12693 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12694 %{

12695   match(SafePoint poll);
12696   effect(KILL cr, USE poll);
12697 
12698   format %{ &quot;testl   rax, [$poll]\t&quot;
12699             &quot;# Safepoint: poll for GC&quot; %}
12700   ins_cost(125);
12701   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12702   ins_encode %{
12703     __ relocate(relocInfo::poll_type);
12704     address pre_pc = __ pc();
12705     __ testl(rax, Address($poll$$Register, 0));
12706     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12707   %}
12708   ins_pipe(ialu_reg_mem);
12709 %}
12710 
12711 // ============================================================================
12712 // Procedure Call/Return Instructions
12713 // Call Java Static Instruction
12714 // Note: If this code changes, the corresponding ret_addr_offset() and
</pre>
</td>
</tr>
</table>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/formssel.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ppc/interp_masm_ppc_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;classfile/symbolTable.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;code/icBuffer.hpp&quot;
  32 #include &quot;code/vtableStubs.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;interpreter/interp_masm.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;nativeInst_aarch64.hpp&quot;
  38 #include &quot;oops/compiledICHolder.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/vframeArray.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
  44 #include &quot;vmreg_aarch64.inline.hpp&quot;
  45 #ifdef COMPILER1
  46 #include &quot;c1/c1_Runtime1.hpp&quot;
  47 #endif
<span class="line-modified">  48 #if COMPILER2_OR_JVMCI</span>
  49 #include &quot;adfiles/ad_aarch64.hpp&quot;
  50 #include &quot;opto/runtime.hpp&quot;
  51 #endif
  52 #if INCLUDE_JVMCI
  53 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  54 #endif
  55 
  56 #define __ masm-&gt;
  57 
  58 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  59 
  60 class SimpleRuntimeFrame {
  61 
  62   public:
  63 
  64   // Most of the runtime stubs have this simple frame layout.
  65   // This class exists to make the layout shared in one place.
  66   // Offsets are for compiler stack slots, which are jints.
  67   enum layout {
  68     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
</pre>
<hr />
<pre>
 154       // Register slots are 8 bytes wide, 32 floating-point registers.
 155       int sp_offset = RegisterImpl::max_slots_per_register * i +
 156                       FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;
 157       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
 158                                 r-&gt;as_VMReg());
 159     }
 160   }
 161 
 162   for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
 163     FloatRegister r = as_FloatRegister(i);
 164     int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :
 165                                    (FloatRegisterImpl::save_slots_per_register * i);
 166     oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 167                               r-&gt;as_VMReg());
 168   }
 169 
 170   return oop_map;
 171 }
 172 
 173 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
<span class="line-modified"> 174 #ifndef COMPILER2</span>
<span class="line-removed"> 175   assert(!restore_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);</span>
<span class="line-removed"> 176 #endif</span>
 177   __ pop_CPU_state(restore_vectors);
 178   __ leave();



 179 }
 180 
 181 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 182 
 183   // Just restore result register. Only used by deoptimization. By
 184   // now any callee save register that needs to be restored to a c2
 185   // caller of the deoptee has been extracted into the vframeArray
 186   // and will be stuffed into the c2i adapter we create for later
 187   // restoration so only result registers need to be restored here.
 188 
 189   // Restore fp result register
 190   __ ldrd(v0, Address(sp, v0_offset_in_bytes()));
 191   // Restore integer result register
 192   __ ldr(r0, Address(sp, r0_offset_in_bytes()));
 193 
 194   // Pop all of the register save are off the stack
 195   __ add(sp, sp, align_up(return_offset_in_bytes(), 16));
 196 }
 197 
 198 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
</pre>
<hr />
<pre>
2803   // Jump to interpreter
2804   __ ret(lr);
2805 
2806   // Make sure all code is generated
2807   masm-&gt;flush();
2808 
2809   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2810   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2811 #if INCLUDE_JVMCI
2812   if (EnableJVMCI || UseAOT) {
2813     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
2814     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
2815   }
2816 #endif
2817 }
2818 
2819 uint SharedRuntime::out_preserve_stack_slots() {
2820   return 0;
2821 }
2822 
<span class="line-modified">2823 #if COMPILER2_OR_JVMCI</span>
2824 //------------------------------generate_uncommon_trap_blob--------------------
2825 void SharedRuntime::generate_uncommon_trap_blob() {
2826   // Allocate space for the code
2827   ResourceMark rm;
2828   // Setup code generation tools
2829   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
2830   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2831 
2832   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2833 
2834   address start = __ pc();
2835 
2836   // Push self-frame.  We get here with a return address in LR
2837   // and sp should be 16 byte aligned
2838   // push rfp and retaddr by hand
2839   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2840   // we don&#39;t expect an arg reg save area
2841 #ifndef PRODUCT
2842   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2843 #endif
</pre>
<hr />
<pre>
2994 
2995   // Set an oopmap for the call site
2996   // Use the same PC we used for the last java frame
2997   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
2998 
2999   // Clear fp AND pc
3000   __ reset_last_Java_frame(true);
3001 
3002   // Pop self-frame.
3003   __ leave();                 // Epilog
3004 
3005   // Jump to interpreter
3006   __ ret(lr);
3007 
3008   // Make sure all code is generated
3009   masm-&gt;flush();
3010 
3011   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
3012                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
3013 }
<span class="line-modified">3014 #endif // COMPILER2_OR_JVMCI</span>
3015 
3016 
3017 //------------------------------generate_handler_blob------
3018 //
3019 // Generate a special Compile2Runtime blob that saves all registers,
3020 // and setup oopmap.
3021 //
3022 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
3023   ResourceMark rm;
3024   OopMapSet *oop_maps = new OopMapSet();
3025   OopMap* map;
3026 
3027   // Allocate space for the code.  Setup code generation tools.
3028   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
3029   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3030 
3031   address start   = __ pc();
3032   address call_pc = NULL;
3033   int frame_size_in_words;
3034   bool cause_return = (poll_type == POLL_AT_RETURN);
</pre>
<hr />
<pre>
3072   Label noException;
3073 
3074   __ reset_last_Java_frame(false);
3075 
3076   __ maybe_isb();
3077   __ membar(Assembler::LoadLoad | Assembler::LoadStore);
3078 
3079   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
3080   __ cbz(rscratch1, noException);
3081 
3082   // Exception pending
3083 
3084   RegisterSaver::restore_live_registers(masm, save_vectors);
3085 
3086   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3087 
3088   // No exception case
3089   __ bind(noException);
3090 
3091   Label no_adjust, bail;
<span class="line-modified">3092   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; !cause_return) {</span>
3093     // If our stashed return pc was modified by the runtime we avoid touching it
3094     __ ldr(rscratch1, Address(rfp, wordSize));
3095     __ cmp(r20, rscratch1);
3096     __ br(Assembler::NE, no_adjust);
3097 
3098 #ifdef ASSERT
3099     // Verify the correct encoding of the poll we&#39;re about to skip.
3100     // See NativeInstruction::is_ldrw_to_zr()
3101     __ ldrw(rscratch1, Address(r20));
3102     __ ubfx(rscratch2, rscratch1, 22, 10);
3103     __ cmpw(rscratch2, 0b1011100101);
3104     __ br(Assembler::NE, bail);
3105     __ ubfx(rscratch2, rscratch1, 0, 5);
3106     __ cmpw(rscratch2, 0b11111);
3107     __ br(Assembler::NE, bail);
3108 #endif
3109     // Adjust return pc forward to step over the safepoint poll instruction
3110     __ add(r20, r20, NativeInstruction::instruction_size);
3111     __ str(r20, Address(rfp, wordSize));
3112   }
</pre>
<hr />
<pre>
3202   __ bind(pending);
3203 
3204   RegisterSaver::restore_live_registers(masm);
3205 
3206   // exception pending =&gt; remove activation and forward to exception handler
3207 
3208   __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
3209 
3210   __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
3211   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3212 
3213   // -------------
3214   // make sure all code is generated
3215   masm-&gt;flush();
3216 
3217   // return the  blob
3218   // frame_size_words or bytes??
3219   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_words, oop_maps, true);
3220 }
3221 
<span class="line-modified">3222 #if COMPILER2_OR_JVMCI</span>
3223 // This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame
3224 //
3225 //------------------------------generate_exception_blob---------------------------
3226 // creates exception blob at the end
3227 // Using exception blob, this code is jumped from a compiled method.
3228 // (see emit_exception_handler in x86_64.ad file)
3229 //
3230 // Given an exception pc at a call we call into the runtime for the
3231 // handler in this method. This handler might merely restore state
3232 // (i.e. callee save registers) unwind the frame and jump to the
3233 // exception handler for the nmethod if there is no Java level handler
3234 // for the nmethod.
3235 //
3236 // This code is entered with a jmp.
3237 //
3238 // Arguments:
3239 //   r0: exception oop
3240 //   r3: exception pc
3241 //
3242 // Results:
</pre>
<hr />
<pre>
3331 #ifdef ASSERT
3332   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3333   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3334 #endif
3335   // Clear the exception oop so GC no longer processes it as a root.
3336   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3337 
3338   // r0: exception oop
3339   // r8:  exception handler
3340   // r4: exception pc
3341   // Jump to handler
3342 
3343   __ br(r8);
3344 
3345   // Make sure all code is generated
3346   masm-&gt;flush();
3347 
3348   // Set exception blob
3349   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3350 }
<span class="line-removed">3351 #endif // COMPILER2_OR_JVMCI</span>
3352 
3353 BufferedValueTypeBlob* SharedRuntime::generate_buffered_value_type_adapter(const ValueKlass* vk) {
3354   BufferBlob* buf = BufferBlob::create(&quot;value types pack/unpack&quot;, 16 * K);
3355   CodeBuffer buffer(buf);
3356   short buffer_locs[20];
3357   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3358                                          sizeof(buffer_locs)/sizeof(relocInfo));
3359 
3360   MacroAssembler _masm(&amp;buffer);
3361   MacroAssembler* masm = &amp;_masm;
3362 
3363   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3364   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3365 
3366   int pack_fields_off = __ offset();
3367 
3368   int j = 1;
3369   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3370     BasicType bt = sig_vk-&gt;at(i)._bt;
3371     if (bt == T_VALUETYPE) {
</pre>
<hr />
<pre>
3437     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3438        assert_different_registers(r0, r_1-&gt;as_Register());
3439        __ load_heap_oop(r_1-&gt;as_Register(), from);
3440     } else {
3441       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3442       assert_different_registers(r0, r_1-&gt;as_Register());
3443 
3444       size_t size_in_bytes = type2aelembytes(bt);
3445       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);
3446     }
3447     j++;
3448   }
3449   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3450 
3451   __ ret(lr);
3452 
3453   __ flush();
3454 
3455   return BufferedValueTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);
3456 }

</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;classfile/symbolTable.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;code/icBuffer.hpp&quot;
  32 #include &quot;code/vtableStubs.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;interpreter/interp_masm.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;nativeInst_aarch64.hpp&quot;
  38 #include &quot;oops/compiledICHolder.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/vframeArray.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
  44 #include &quot;vmreg_aarch64.inline.hpp&quot;
  45 #ifdef COMPILER1
  46 #include &quot;c1/c1_Runtime1.hpp&quot;
  47 #endif
<span class="line-modified">  48 #ifdef COMPILER2</span>
  49 #include &quot;adfiles/ad_aarch64.hpp&quot;
  50 #include &quot;opto/runtime.hpp&quot;
  51 #endif
  52 #if INCLUDE_JVMCI
  53 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  54 #endif
  55 
  56 #define __ masm-&gt;
  57 
  58 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  59 
  60 class SimpleRuntimeFrame {
  61 
  62   public:
  63 
  64   // Most of the runtime stubs have this simple frame layout.
  65   // This class exists to make the layout shared in one place.
  66   // Offsets are for compiler stack slots, which are jints.
  67   enum layout {
  68     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
</pre>
<hr />
<pre>
 154       // Register slots are 8 bytes wide, 32 floating-point registers.
 155       int sp_offset = RegisterImpl::max_slots_per_register * i +
 156                       FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;
 157       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
 158                                 r-&gt;as_VMReg());
 159     }
 160   }
 161 
 162   for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
 163     FloatRegister r = as_FloatRegister(i);
 164     int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :
 165                                    (FloatRegisterImpl::save_slots_per_register * i);
 166     oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 167                               r-&gt;as_VMReg());
 168   }
 169 
 170   return oop_map;
 171 }
 172 
 173 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
<span class="line-modified"> 174 #if COMPILER2_OR_JVMCI</span>


 175   __ pop_CPU_state(restore_vectors);
 176   __ leave();
<span class="line-added"> 177 #else</span>
<span class="line-added"> 178   assert(!restore_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);</span>
<span class="line-added"> 179 #endif</span>
 180 }
 181 
 182 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 183 
 184   // Just restore result register. Only used by deoptimization. By
 185   // now any callee save register that needs to be restored to a c2
 186   // caller of the deoptee has been extracted into the vframeArray
 187   // and will be stuffed into the c2i adapter we create for later
 188   // restoration so only result registers need to be restored here.
 189 
 190   // Restore fp result register
 191   __ ldrd(v0, Address(sp, v0_offset_in_bytes()));
 192   // Restore integer result register
 193   __ ldr(r0, Address(sp, r0_offset_in_bytes()));
 194 
 195   // Pop all of the register save are off the stack
 196   __ add(sp, sp, align_up(return_offset_in_bytes(), 16));
 197 }
 198 
 199 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
</pre>
<hr />
<pre>
2804   // Jump to interpreter
2805   __ ret(lr);
2806 
2807   // Make sure all code is generated
2808   masm-&gt;flush();
2809 
2810   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2811   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2812 #if INCLUDE_JVMCI
2813   if (EnableJVMCI || UseAOT) {
2814     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
2815     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
2816   }
2817 #endif
2818 }
2819 
2820 uint SharedRuntime::out_preserve_stack_slots() {
2821   return 0;
2822 }
2823 
<span class="line-modified">2824 #ifdef COMPILER2</span>
2825 //------------------------------generate_uncommon_trap_blob--------------------
2826 void SharedRuntime::generate_uncommon_trap_blob() {
2827   // Allocate space for the code
2828   ResourceMark rm;
2829   // Setup code generation tools
2830   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
2831   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2832 
2833   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2834 
2835   address start = __ pc();
2836 
2837   // Push self-frame.  We get here with a return address in LR
2838   // and sp should be 16 byte aligned
2839   // push rfp and retaddr by hand
2840   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2841   // we don&#39;t expect an arg reg save area
2842 #ifndef PRODUCT
2843   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2844 #endif
</pre>
<hr />
<pre>
2995 
2996   // Set an oopmap for the call site
2997   // Use the same PC we used for the last java frame
2998   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
2999 
3000   // Clear fp AND pc
3001   __ reset_last_Java_frame(true);
3002 
3003   // Pop self-frame.
3004   __ leave();                 // Epilog
3005 
3006   // Jump to interpreter
3007   __ ret(lr);
3008 
3009   // Make sure all code is generated
3010   masm-&gt;flush();
3011 
3012   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
3013                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
3014 }
<span class="line-modified">3015 #endif // COMPILER2</span>
3016 
3017 
3018 //------------------------------generate_handler_blob------
3019 //
3020 // Generate a special Compile2Runtime blob that saves all registers,
3021 // and setup oopmap.
3022 //
3023 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
3024   ResourceMark rm;
3025   OopMapSet *oop_maps = new OopMapSet();
3026   OopMap* map;
3027 
3028   // Allocate space for the code.  Setup code generation tools.
3029   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
3030   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3031 
3032   address start   = __ pc();
3033   address call_pc = NULL;
3034   int frame_size_in_words;
3035   bool cause_return = (poll_type == POLL_AT_RETURN);
</pre>
<hr />
<pre>
3073   Label noException;
3074 
3075   __ reset_last_Java_frame(false);
3076 
3077   __ maybe_isb();
3078   __ membar(Assembler::LoadLoad | Assembler::LoadStore);
3079 
3080   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
3081   __ cbz(rscratch1, noException);
3082 
3083   // Exception pending
3084 
3085   RegisterSaver::restore_live_registers(masm, save_vectors);
3086 
3087   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3088 
3089   // No exception case
3090   __ bind(noException);
3091 
3092   Label no_adjust, bail;
<span class="line-modified">3093   if (!cause_return) {</span>
3094     // If our stashed return pc was modified by the runtime we avoid touching it
3095     __ ldr(rscratch1, Address(rfp, wordSize));
3096     __ cmp(r20, rscratch1);
3097     __ br(Assembler::NE, no_adjust);
3098 
3099 #ifdef ASSERT
3100     // Verify the correct encoding of the poll we&#39;re about to skip.
3101     // See NativeInstruction::is_ldrw_to_zr()
3102     __ ldrw(rscratch1, Address(r20));
3103     __ ubfx(rscratch2, rscratch1, 22, 10);
3104     __ cmpw(rscratch2, 0b1011100101);
3105     __ br(Assembler::NE, bail);
3106     __ ubfx(rscratch2, rscratch1, 0, 5);
3107     __ cmpw(rscratch2, 0b11111);
3108     __ br(Assembler::NE, bail);
3109 #endif
3110     // Adjust return pc forward to step over the safepoint poll instruction
3111     __ add(r20, r20, NativeInstruction::instruction_size);
3112     __ str(r20, Address(rfp, wordSize));
3113   }
</pre>
<hr />
<pre>
3203   __ bind(pending);
3204 
3205   RegisterSaver::restore_live_registers(masm);
3206 
3207   // exception pending =&gt; remove activation and forward to exception handler
3208 
3209   __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
3210 
3211   __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
3212   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3213 
3214   // -------------
3215   // make sure all code is generated
3216   masm-&gt;flush();
3217 
3218   // return the  blob
3219   // frame_size_words or bytes??
3220   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_words, oop_maps, true);
3221 }
3222 
<span class="line-modified">3223 #ifdef COMPILER2</span>
3224 // This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame
3225 //
3226 //------------------------------generate_exception_blob---------------------------
3227 // creates exception blob at the end
3228 // Using exception blob, this code is jumped from a compiled method.
3229 // (see emit_exception_handler in x86_64.ad file)
3230 //
3231 // Given an exception pc at a call we call into the runtime for the
3232 // handler in this method. This handler might merely restore state
3233 // (i.e. callee save registers) unwind the frame and jump to the
3234 // exception handler for the nmethod if there is no Java level handler
3235 // for the nmethod.
3236 //
3237 // This code is entered with a jmp.
3238 //
3239 // Arguments:
3240 //   r0: exception oop
3241 //   r3: exception pc
3242 //
3243 // Results:
</pre>
<hr />
<pre>
3332 #ifdef ASSERT
3333   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3334   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3335 #endif
3336   // Clear the exception oop so GC no longer processes it as a root.
3337   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3338 
3339   // r0: exception oop
3340   // r8:  exception handler
3341   // r4: exception pc
3342   // Jump to handler
3343 
3344   __ br(r8);
3345 
3346   // Make sure all code is generated
3347   masm-&gt;flush();
3348 
3349   // Set exception blob
3350   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3351 }

3352 
3353 BufferedValueTypeBlob* SharedRuntime::generate_buffered_value_type_adapter(const ValueKlass* vk) {
3354   BufferBlob* buf = BufferBlob::create(&quot;value types pack/unpack&quot;, 16 * K);
3355   CodeBuffer buffer(buf);
3356   short buffer_locs[20];
3357   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3358                                          sizeof(buffer_locs)/sizeof(relocInfo));
3359 
3360   MacroAssembler _masm(&amp;buffer);
3361   MacroAssembler* masm = &amp;_masm;
3362 
3363   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3364   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3365 
3366   int pack_fields_off = __ offset();
3367 
3368   int j = 1;
3369   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3370     BasicType bt = sig_vk-&gt;at(i)._bt;
3371     if (bt == T_VALUETYPE) {
</pre>
<hr />
<pre>
3437     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3438        assert_different_registers(r0, r_1-&gt;as_Register());
3439        __ load_heap_oop(r_1-&gt;as_Register(), from);
3440     } else {
3441       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3442       assert_different_registers(r0, r_1-&gt;as_Register());
3443 
3444       size_t size_in_bytes = type2aelembytes(bt);
3445       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);
3446     }
3447     j++;
3448   }
3449   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3450 
3451   __ ret(lr);
3452 
3453   __ flush();
3454 
3455   return BufferedValueTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);
3456 }
<span class="line-added">3457 #endif // COMPILER2</span>
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ppc/interp_masm_ppc_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/conf/jib-profiles.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 1010   }
 1011 };
 1012 
 1013 class HandlerImpl {
 1014 
 1015  public:
 1016 
 1017   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1018   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1019 
 1020   static uint size_exception_handler() {
 1021     return MacroAssembler::far_branch_size();
 1022   }
 1023 
 1024   static uint size_deopt_handler() {
 1025     // count one adr and one far branch instruction
 1026     return 4 * NativeInstruction::instruction_size;
 1027   }
 1028 };
 1029 







 1030  bool is_CAS(int opcode, bool maybe_volatile);
 1031 
 1032   // predicates controlling emit of ldr&lt;x&gt;/ldar&lt;x&gt; and associated dmb
 1033 
 1034   bool unnecessary_acquire(const Node *barrier);
 1035   bool needs_acquiring_load(const Node *load);
 1036 
 1037   // predicates controlling emit of str&lt;x&gt;/stlr&lt;x&gt; and associated dmbs
 1038 
 1039   bool unnecessary_release(const Node *barrier);
 1040   bool unnecessary_volatile(const Node *barrier);
 1041   bool needs_releasing_store(const Node *store);
 1042 
 1043   // predicate controlling translation of CompareAndSwapX
 1044   bool needs_acquiring_load_exclusive(const Node *load);
 1045 
 1046   // predicate controlling addressing modes
 1047   bool size_fits_all_mem_uses(AddPNode* addp, int shift);
 1048 %}
 1049 
 1050 source %{
 1051 
 1052   // Derived RegMask with conditionally allocatable registers
 1053 











 1054   RegMask _ANY_REG32_mask;
 1055   RegMask _ANY_REG_mask;
 1056   RegMask _PTR_REG_mask;
 1057   RegMask _NO_SPECIAL_REG32_mask;
 1058   RegMask _NO_SPECIAL_REG_mask;
 1059   RegMask _NO_SPECIAL_PTR_REG_mask;
 1060 
 1061   void reg_mask_init() {
 1062     // We derive below RegMask(s) from the ones which are auto-generated from
 1063     // adlc register classes to make AArch64 rheapbase (r27) and rfp (r29)
 1064     // registers conditionally reserved.
 1065 
 1066     _ANY_REG32_mask = _ALL_REG32_mask;
 1067     _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp-&gt;as_VMReg()));
 1068 
 1069     _ANY_REG_mask = _ALL_REG_mask;
 1070 
 1071     _PTR_REG_mask = _ALL_REG_mask;
 1072 
 1073     _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;
</pre>
<hr />
<pre>
 1653 #ifndef PRODUCT
 1654 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1655   Compile* C = ra_-&gt;C;
 1656   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1657 
 1658   st-&gt;print(&quot;# pop frame %d\n\t&quot;,framesize);
 1659 
 1660   if (framesize == 0) {
 1661     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1662   } else if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1663     st-&gt;print(&quot;ldp  lr, rfp, [sp,#%d]\n\t&quot;, framesize - 2 * wordSize);
 1664     st-&gt;print(&quot;add  sp, sp, #%d\n\t&quot;, framesize);
 1665   } else {
 1666     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1667     st-&gt;print(&quot;add  sp, sp, rscratch1\n\t&quot;);
 1668     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1669   }
 1670 
 1671   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1672     st-&gt;print(&quot;# touch polling page\n\t&quot;);
<span class="line-modified"> 1673     st-&gt;print(&quot;mov  rscratch1, #0x%lx\n\t&quot;, p2i(os::get_polling_page()));</span>
 1674     st-&gt;print(&quot;ldr zr, [rscratch1]&quot;);
 1675   }
 1676 }
 1677 #endif
 1678 
 1679 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1680   Compile* C = ra_-&gt;C;
 1681   C2_MacroAssembler _masm(&amp;cbuf);
 1682   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1683 
 1684   __ remove_frame(framesize);
 1685 
 1686   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1687     __ reserved_stack_check();
 1688   }
 1689 
 1690   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
<span class="line-modified"> 1691     __ read_polling_page(rscratch1, os::get_polling_page(), relocInfo::poll_return_type);</span>
 1692   }
 1693 }
 1694 
 1695 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1696   // Variable size. Determine dynamically.
 1697   return MachNode::size(ra_);
 1698 }
 1699 
 1700 int MachEpilogNode::reloc() const {
 1701   // Return number of relocatable values contained in this instruction.
 1702   return 1; // 1 for polling page.
 1703 }
 1704 
 1705 const Pipeline * MachEpilogNode::pipeline() const {
 1706   return MachNode::pipeline_class();
 1707 }
 1708 
<span class="line-removed"> 1709 // This method seems to be obsolete. It is declared in machnode.hpp</span>
<span class="line-removed"> 1710 // and defined in all *.ad files, but it is never called. Should we</span>
<span class="line-removed"> 1711 // get rid of it?</span>
<span class="line-removed"> 1712 int MachEpilogNode::safepoint_offset() const {</span>
<span class="line-removed"> 1713   assert(do_polling(), &quot;no return for this epilog node&quot;);</span>
<span class="line-removed"> 1714   return 4;</span>
<span class="line-removed"> 1715 }</span>
<span class="line-removed"> 1716 </span>
 1717 //=============================================================================
 1718 
 1719 // Figure out which register class each belongs in: rc_int, rc_float or
 1720 // rc_stack.
 1721 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1722 
 1723 static enum RC rc_class(OptoReg::Name reg) {
 1724 
 1725   if (reg == OptoReg::Bad) {
 1726     return rc_bad;
 1727   }
 1728 
 1729   // we have 30 int registers * 2 halves
 1730   // (rscratch1 and rscratch2 are omitted)
 1731   int slots_of_int_registers = RegisterImpl::max_slots_per_register * (RegisterImpl::number_of_registers - 2);
 1732 
 1733   if (reg &lt; slots_of_int_registers) {
 1734     return rc_int;
 1735   }
 1736 
</pre>
<hr />
<pre>
 3173           unsigned long offset;
 3174           __ adrp(dst_reg, con, offset);
 3175           __ add(dst_reg, dst_reg, offset);
 3176         }
 3177       }
 3178     }
 3179   %}
 3180 
 3181   enc_class aarch64_enc_mov_p0(iRegP dst, immP0 src) %{
 3182     C2_MacroAssembler _masm(&amp;cbuf);
 3183     Register dst_reg = as_Register($dst$$reg);
 3184     __ mov(dst_reg, zr);
 3185   %}
 3186 
 3187   enc_class aarch64_enc_mov_p1(iRegP dst, immP_1 src) %{
 3188     C2_MacroAssembler _masm(&amp;cbuf);
 3189     Register dst_reg = as_Register($dst$$reg);
 3190     __ mov(dst_reg, (u_int64_t)1);
 3191   %}
 3192 
<span class="line-removed"> 3193   enc_class aarch64_enc_mov_poll_page(iRegP dst, immPollPage src) %{</span>
<span class="line-removed"> 3194     C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-removed"> 3195     address page = (address)$src$$constant;</span>
<span class="line-removed"> 3196     Register dst_reg = as_Register($dst$$reg);</span>
<span class="line-removed"> 3197     unsigned long off;</span>
<span class="line-removed"> 3198     __ adrp(dst_reg, Address(page, relocInfo::poll_type), off);</span>
<span class="line-removed"> 3199     assert(off == 0, &quot;assumed offset == 0&quot;);</span>
<span class="line-removed"> 3200   %}</span>
<span class="line-removed"> 3201 </span>
 3202   enc_class aarch64_enc_mov_byte_map_base(iRegP dst, immByteMapBase src) %{
 3203     C2_MacroAssembler _masm(&amp;cbuf);
 3204     __ load_byte_map_base($dst$$Register);
 3205   %}
 3206 
 3207   enc_class aarch64_enc_mov_n(iRegN dst, immN src) %{
 3208     C2_MacroAssembler _masm(&amp;cbuf);
 3209     Register dst_reg = as_Register($dst$$reg);
 3210     address con = (address)$src$$constant;
 3211     if (con == NULL) {
 3212       ShouldNotReachHere();
 3213     } else {
 3214       relocInfo::relocType rtype = $src-&gt;constant_reloc();
 3215       assert(rtype == relocInfo::oop_type, &quot;unexpected reloc type&quot;);
 3216       __ set_narrow_oop(dst_reg, (jobject)con);
 3217     }
 3218   %}
 3219 
 3220   enc_class aarch64_enc_mov_n0(iRegN dst, immN0 src) %{
 3221     C2_MacroAssembler _masm(&amp;cbuf);
</pre>
<hr />
<pre>
 4374   predicate(n-&gt;get_ptr() == 0);
 4375   match(ConP);
 4376 
 4377   op_cost(0);
 4378   format %{ %}
 4379   interface(CONST_INTER);
 4380 %}
 4381 
 4382 // Pointer Immediate One
 4383 // this is used in object initialization (initial object header)
 4384 operand immP_1()
 4385 %{
 4386   predicate(n-&gt;get_ptr() == 1);
 4387   match(ConP);
 4388 
 4389   op_cost(0);
 4390   format %{ %}
 4391   interface(CONST_INTER);
 4392 %}
 4393 
<span class="line-removed"> 4394 // Polling Page Pointer Immediate</span>
<span class="line-removed"> 4395 operand immPollPage()</span>
<span class="line-removed"> 4396 %{</span>
<span class="line-removed"> 4397   predicate((address)n-&gt;get_ptr() == os::get_polling_page());</span>
<span class="line-removed"> 4398   match(ConP);</span>
<span class="line-removed"> 4399 </span>
<span class="line-removed"> 4400   op_cost(0);</span>
<span class="line-removed"> 4401   format %{ %}</span>
<span class="line-removed"> 4402   interface(CONST_INTER);</span>
<span class="line-removed"> 4403 %}</span>
<span class="line-removed"> 4404 </span>
 4405 // Card Table Byte Map Base
 4406 operand immByteMapBase()
 4407 %{
 4408   // Get base of card map
 4409   predicate(BarrierSet::barrier_set()-&gt;is_a(BarrierSet::CardTableBarrierSet) &amp;&amp;
 4410             (CardTable::CardValue*)n-&gt;get_ptr() == ((CardTableBarrierSet*)(BarrierSet::barrier_set()))-&gt;card_table()-&gt;byte_map_base());
 4411   match(ConP);
 4412 
 4413   op_cost(0);
 4414   format %{ %}
 4415   interface(CONST_INTER);
 4416 %}
 4417 
 4418 // Pointer Immediate Minus One
 4419 // this is used when we want to write the current PC to the thread anchor
 4420 operand immP_M1()
 4421 %{
 4422   predicate(n-&gt;get_ptr() == -1);
 4423   match(ConP);
 4424 
</pre>
<hr />
<pre>
 7181 
 7182   ins_encode(aarch64_enc_mov_p0(dst, con));
 7183 
 7184   ins_pipe(ialu_imm);
 7185 %}
 7186 
 7187 // Load Pointer Constant One
 7188 
 7189 instruct loadConP1(iRegPNoSp dst, immP_1 con)
 7190 %{
 7191   match(Set dst con);
 7192 
 7193   ins_cost(INSN_COST);
 7194   format %{ &quot;mov  $dst, $con\t# NULL ptr&quot; %}
 7195 
 7196   ins_encode(aarch64_enc_mov_p1(dst, con));
 7197 
 7198   ins_pipe(ialu_imm);
 7199 %}
 7200 
<span class="line-removed"> 7201 // Load Poll Page Constant</span>
<span class="line-removed"> 7202 </span>
<span class="line-removed"> 7203 instruct loadConPollPage(iRegPNoSp dst, immPollPage con)</span>
<span class="line-removed"> 7204 %{</span>
<span class="line-removed"> 7205   match(Set dst con);</span>
<span class="line-removed"> 7206 </span>
<span class="line-removed"> 7207   ins_cost(INSN_COST);</span>
<span class="line-removed"> 7208   format %{ &quot;adr  $dst, $con\t# Poll Page Ptr&quot; %}</span>
<span class="line-removed"> 7209 </span>
<span class="line-removed"> 7210   ins_encode(aarch64_enc_mov_poll_page(dst, con));</span>
<span class="line-removed"> 7211 </span>
<span class="line-removed"> 7212   ins_pipe(ialu_imm);</span>
<span class="line-removed"> 7213 %}</span>
<span class="line-removed"> 7214 </span>
 7215 // Load Byte Map Base Constant
 7216 
 7217 instruct loadByteMapBase(iRegPNoSp dst, immByteMapBase con)
 7218 %{
 7219   match(Set dst con);
 7220 
 7221   ins_cost(INSN_COST);
 7222   format %{ &quot;adr  $dst, $con\t# Byte Map Base&quot; %}
 7223 
 7224   ins_encode(aarch64_enc_mov_byte_map_base(dst, con));
 7225 
 7226   ins_pipe(ialu_imm);
 7227 %}
 7228 
 7229 // Load Narrow Pointer Constant
 7230 
 7231 instruct loadConN(iRegNNoSp dst, immN con)
 7232 %{
 7233   match(Set dst con);
 7234 
</pre>
<hr />
<pre>
18059   format %{ &quot;frint  $dst, $src, $rmode&quot; %}
18060   ins_encode %{
18061     switch ($rmode$$constant) {
18062       case RoundDoubleModeNode::rmode_rint:
18063         __ frintn(as_FloatRegister($dst$$reg), __ T2D,
18064                   as_FloatRegister($src$$reg));
18065         break;
18066       case RoundDoubleModeNode::rmode_floor:
18067         __ frintm(as_FloatRegister($dst$$reg), __ T2D,
18068                   as_FloatRegister($src$$reg));
18069         break;
18070       case RoundDoubleModeNode::rmode_ceil:
18071         __ frintp(as_FloatRegister($dst$$reg), __ T2D,
18072                   as_FloatRegister($src$$reg));
18073         break;
18074     }
18075   %}
18076   ins_pipe(vdop_fp128);
18077 %}
18078 






































18079 //----------PEEPHOLE RULES-----------------------------------------------------
18080 // These must follow all instruction definitions as they use the names
18081 // defined in the instructions definitions.
18082 //
18083 // peepmatch ( root_instr_name [preceding_instruction]* );
18084 //
18085 // peepconstraint %{
18086 // (instruction_number.operand_name relational_op instruction_number.operand_name
18087 //  [, ...] );
18088 // // instruction numbers are zero-based using left to right order in peepmatch
18089 //
18090 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
18091 // // provide an instruction_number.operand_name for each operand that appears
18092 // // in the replacement instruction&#39;s match rule
18093 //
18094 // ---------VM FLAGS---------------------------------------------------------
18095 //
18096 // All peephole optimizations can be turned off using -XX:-OptoPeephole
18097 //
18098 // Each peephole rule is given an identifying number starting with zero and
</pre>
</td>
<td>
<hr />
<pre>
 1010   }
 1011 };
 1012 
 1013 class HandlerImpl {
 1014 
 1015  public:
 1016 
 1017   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1018   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1019 
 1020   static uint size_exception_handler() {
 1021     return MacroAssembler::far_branch_size();
 1022   }
 1023 
 1024   static uint size_deopt_handler() {
 1025     // count one adr and one far branch instruction
 1026     return 4 * NativeInstruction::instruction_size;
 1027   }
 1028 };
 1029 
<span class="line-added"> 1030 class Node::PD {</span>
<span class="line-added"> 1031 public:</span>
<span class="line-added"> 1032   enum NodeFlags {</span>
<span class="line-added"> 1033     _last_flag = Node::_last_flag</span>
<span class="line-added"> 1034   };</span>
<span class="line-added"> 1035 };</span>
<span class="line-added"> 1036 </span>
 1037  bool is_CAS(int opcode, bool maybe_volatile);
 1038 
 1039   // predicates controlling emit of ldr&lt;x&gt;/ldar&lt;x&gt; and associated dmb
 1040 
 1041   bool unnecessary_acquire(const Node *barrier);
 1042   bool needs_acquiring_load(const Node *load);
 1043 
 1044   // predicates controlling emit of str&lt;x&gt;/stlr&lt;x&gt; and associated dmbs
 1045 
 1046   bool unnecessary_release(const Node *barrier);
 1047   bool unnecessary_volatile(const Node *barrier);
 1048   bool needs_releasing_store(const Node *store);
 1049 
 1050   // predicate controlling translation of CompareAndSwapX
 1051   bool needs_acquiring_load_exclusive(const Node *load);
 1052 
 1053   // predicate controlling addressing modes
 1054   bool size_fits_all_mem_uses(AddPNode* addp, int shift);
 1055 %}
 1056 
 1057 source %{
 1058 
 1059   // Derived RegMask with conditionally allocatable registers
 1060 
<span class="line-added"> 1061   void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added"> 1062   }</span>
<span class="line-added"> 1063 </span>
<span class="line-added"> 1064   int MachNode::pd_alignment_required() const {</span>
<span class="line-added"> 1065     return 1;</span>
<span class="line-added"> 1066   }</span>
<span class="line-added"> 1067 </span>
<span class="line-added"> 1068   int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added"> 1069     return 0;</span>
<span class="line-added"> 1070   }</span>
<span class="line-added"> 1071 </span>
 1072   RegMask _ANY_REG32_mask;
 1073   RegMask _ANY_REG_mask;
 1074   RegMask _PTR_REG_mask;
 1075   RegMask _NO_SPECIAL_REG32_mask;
 1076   RegMask _NO_SPECIAL_REG_mask;
 1077   RegMask _NO_SPECIAL_PTR_REG_mask;
 1078 
 1079   void reg_mask_init() {
 1080     // We derive below RegMask(s) from the ones which are auto-generated from
 1081     // adlc register classes to make AArch64 rheapbase (r27) and rfp (r29)
 1082     // registers conditionally reserved.
 1083 
 1084     _ANY_REG32_mask = _ALL_REG32_mask;
 1085     _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp-&gt;as_VMReg()));
 1086 
 1087     _ANY_REG_mask = _ALL_REG_mask;
 1088 
 1089     _PTR_REG_mask = _ALL_REG_mask;
 1090 
 1091     _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;
</pre>
<hr />
<pre>
 1671 #ifndef PRODUCT
 1672 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1673   Compile* C = ra_-&gt;C;
 1674   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1675 
 1676   st-&gt;print(&quot;# pop frame %d\n\t&quot;,framesize);
 1677 
 1678   if (framesize == 0) {
 1679     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1680   } else if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1681     st-&gt;print(&quot;ldp  lr, rfp, [sp,#%d]\n\t&quot;, framesize - 2 * wordSize);
 1682     st-&gt;print(&quot;add  sp, sp, #%d\n\t&quot;, framesize);
 1683   } else {
 1684     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1685     st-&gt;print(&quot;add  sp, sp, rscratch1\n\t&quot;);
 1686     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1687   }
 1688 
 1689   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1690     st-&gt;print(&quot;# touch polling page\n\t&quot;);
<span class="line-modified"> 1691     st-&gt;print(&quot;ldr rscratch1, [rthread],#polling_page_offset\n\t&quot;);</span>
 1692     st-&gt;print(&quot;ldr zr, [rscratch1]&quot;);
 1693   }
 1694 }
 1695 #endif
 1696 
 1697 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1698   Compile* C = ra_-&gt;C;
 1699   C2_MacroAssembler _masm(&amp;cbuf);
 1700   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1701 
 1702   __ remove_frame(framesize);
 1703 
 1704   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1705     __ reserved_stack_check();
 1706   }
 1707 
 1708   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
<span class="line-modified"> 1709     __ fetch_and_read_polling_page(rscratch1, relocInfo::poll_return_type);</span>
 1710   }
 1711 }
 1712 
 1713 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1714   // Variable size. Determine dynamically.
 1715   return MachNode::size(ra_);
 1716 }
 1717 
 1718 int MachEpilogNode::reloc() const {
 1719   // Return number of relocatable values contained in this instruction.
 1720   return 1; // 1 for polling page.
 1721 }
 1722 
 1723 const Pipeline * MachEpilogNode::pipeline() const {
 1724   return MachNode::pipeline_class();
 1725 }
 1726 








 1727 //=============================================================================
 1728 
 1729 // Figure out which register class each belongs in: rc_int, rc_float or
 1730 // rc_stack.
 1731 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1732 
 1733 static enum RC rc_class(OptoReg::Name reg) {
 1734 
 1735   if (reg == OptoReg::Bad) {
 1736     return rc_bad;
 1737   }
 1738 
 1739   // we have 30 int registers * 2 halves
 1740   // (rscratch1 and rscratch2 are omitted)
 1741   int slots_of_int_registers = RegisterImpl::max_slots_per_register * (RegisterImpl::number_of_registers - 2);
 1742 
 1743   if (reg &lt; slots_of_int_registers) {
 1744     return rc_int;
 1745   }
 1746 
</pre>
<hr />
<pre>
 3183           unsigned long offset;
 3184           __ adrp(dst_reg, con, offset);
 3185           __ add(dst_reg, dst_reg, offset);
 3186         }
 3187       }
 3188     }
 3189   %}
 3190 
 3191   enc_class aarch64_enc_mov_p0(iRegP dst, immP0 src) %{
 3192     C2_MacroAssembler _masm(&amp;cbuf);
 3193     Register dst_reg = as_Register($dst$$reg);
 3194     __ mov(dst_reg, zr);
 3195   %}
 3196 
 3197   enc_class aarch64_enc_mov_p1(iRegP dst, immP_1 src) %{
 3198     C2_MacroAssembler _masm(&amp;cbuf);
 3199     Register dst_reg = as_Register($dst$$reg);
 3200     __ mov(dst_reg, (u_int64_t)1);
 3201   %}
 3202 









 3203   enc_class aarch64_enc_mov_byte_map_base(iRegP dst, immByteMapBase src) %{
 3204     C2_MacroAssembler _masm(&amp;cbuf);
 3205     __ load_byte_map_base($dst$$Register);
 3206   %}
 3207 
 3208   enc_class aarch64_enc_mov_n(iRegN dst, immN src) %{
 3209     C2_MacroAssembler _masm(&amp;cbuf);
 3210     Register dst_reg = as_Register($dst$$reg);
 3211     address con = (address)$src$$constant;
 3212     if (con == NULL) {
 3213       ShouldNotReachHere();
 3214     } else {
 3215       relocInfo::relocType rtype = $src-&gt;constant_reloc();
 3216       assert(rtype == relocInfo::oop_type, &quot;unexpected reloc type&quot;);
 3217       __ set_narrow_oop(dst_reg, (jobject)con);
 3218     }
 3219   %}
 3220 
 3221   enc_class aarch64_enc_mov_n0(iRegN dst, immN0 src) %{
 3222     C2_MacroAssembler _masm(&amp;cbuf);
</pre>
<hr />
<pre>
 4375   predicate(n-&gt;get_ptr() == 0);
 4376   match(ConP);
 4377 
 4378   op_cost(0);
 4379   format %{ %}
 4380   interface(CONST_INTER);
 4381 %}
 4382 
 4383 // Pointer Immediate One
 4384 // this is used in object initialization (initial object header)
 4385 operand immP_1()
 4386 %{
 4387   predicate(n-&gt;get_ptr() == 1);
 4388   match(ConP);
 4389 
 4390   op_cost(0);
 4391   format %{ %}
 4392   interface(CONST_INTER);
 4393 %}
 4394 











 4395 // Card Table Byte Map Base
 4396 operand immByteMapBase()
 4397 %{
 4398   // Get base of card map
 4399   predicate(BarrierSet::barrier_set()-&gt;is_a(BarrierSet::CardTableBarrierSet) &amp;&amp;
 4400             (CardTable::CardValue*)n-&gt;get_ptr() == ((CardTableBarrierSet*)(BarrierSet::barrier_set()))-&gt;card_table()-&gt;byte_map_base());
 4401   match(ConP);
 4402 
 4403   op_cost(0);
 4404   format %{ %}
 4405   interface(CONST_INTER);
 4406 %}
 4407 
 4408 // Pointer Immediate Minus One
 4409 // this is used when we want to write the current PC to the thread anchor
 4410 operand immP_M1()
 4411 %{
 4412   predicate(n-&gt;get_ptr() == -1);
 4413   match(ConP);
 4414 
</pre>
<hr />
<pre>
 7171 
 7172   ins_encode(aarch64_enc_mov_p0(dst, con));
 7173 
 7174   ins_pipe(ialu_imm);
 7175 %}
 7176 
 7177 // Load Pointer Constant One
 7178 
 7179 instruct loadConP1(iRegPNoSp dst, immP_1 con)
 7180 %{
 7181   match(Set dst con);
 7182 
 7183   ins_cost(INSN_COST);
 7184   format %{ &quot;mov  $dst, $con\t# NULL ptr&quot; %}
 7185 
 7186   ins_encode(aarch64_enc_mov_p1(dst, con));
 7187 
 7188   ins_pipe(ialu_imm);
 7189 %}
 7190 














 7191 // Load Byte Map Base Constant
 7192 
 7193 instruct loadByteMapBase(iRegPNoSp dst, immByteMapBase con)
 7194 %{
 7195   match(Set dst con);
 7196 
 7197   ins_cost(INSN_COST);
 7198   format %{ &quot;adr  $dst, $con\t# Byte Map Base&quot; %}
 7199 
 7200   ins_encode(aarch64_enc_mov_byte_map_base(dst, con));
 7201 
 7202   ins_pipe(ialu_imm);
 7203 %}
 7204 
 7205 // Load Narrow Pointer Constant
 7206 
 7207 instruct loadConN(iRegNNoSp dst, immN con)
 7208 %{
 7209   match(Set dst con);
 7210 
</pre>
<hr />
<pre>
18035   format %{ &quot;frint  $dst, $src, $rmode&quot; %}
18036   ins_encode %{
18037     switch ($rmode$$constant) {
18038       case RoundDoubleModeNode::rmode_rint:
18039         __ frintn(as_FloatRegister($dst$$reg), __ T2D,
18040                   as_FloatRegister($src$$reg));
18041         break;
18042       case RoundDoubleModeNode::rmode_floor:
18043         __ frintm(as_FloatRegister($dst$$reg), __ T2D,
18044                   as_FloatRegister($src$$reg));
18045         break;
18046       case RoundDoubleModeNode::rmode_ceil:
18047         __ frintp(as_FloatRegister($dst$$reg), __ T2D,
18048                   as_FloatRegister($src$$reg));
18049         break;
18050     }
18051   %}
18052   ins_pipe(vdop_fp128);
18053 %}
18054 
<span class="line-added">18055 instruct vpopcount4I(vecX dst, vecX src) %{</span>
<span class="line-added">18056   predicate(UsePopCountInstruction &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-added">18057   match(Set dst (PopCountVI src));</span>
<span class="line-added">18058   format %{</span>
<span class="line-added">18059     &quot;cnt     $dst, $src\t# vector (16B)\n\t&quot;</span>
<span class="line-added">18060     &quot;uaddlp  $dst, $dst\t# vector (16B)\n\t&quot;</span>
<span class="line-added">18061     &quot;uaddlp  $dst, $dst\t# vector (8H)&quot;</span>
<span class="line-added">18062   %}</span>
<span class="line-added">18063   ins_encode %{</span>
<span class="line-added">18064      __ cnt(as_FloatRegister($dst$$reg), __ T16B,</span>
<span class="line-added">18065             as_FloatRegister($src$$reg));</span>
<span class="line-added">18066      __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,</span>
<span class="line-added">18067                as_FloatRegister($dst$$reg));</span>
<span class="line-added">18068      __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,</span>
<span class="line-added">18069                as_FloatRegister($dst$$reg));</span>
<span class="line-added">18070   %}</span>
<span class="line-added">18071   ins_pipe(pipe_class_default);</span>
<span class="line-added">18072 %}</span>
<span class="line-added">18073 </span>
<span class="line-added">18074 instruct vpopcount2I(vecD dst, vecD src) %{</span>
<span class="line-added">18075   predicate(UsePopCountInstruction &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-added">18076   match(Set dst (PopCountVI src));</span>
<span class="line-added">18077   format %{</span>
<span class="line-added">18078     &quot;cnt     $dst, $src\t# vector (8B)\n\t&quot;</span>
<span class="line-added">18079     &quot;uaddlp  $dst, $dst\t# vector (8B)\n\t&quot;</span>
<span class="line-added">18080     &quot;uaddlp  $dst, $dst\t# vector (4H)&quot;</span>
<span class="line-added">18081   %}</span>
<span class="line-added">18082   ins_encode %{</span>
<span class="line-added">18083      __ cnt(as_FloatRegister($dst$$reg), __ T8B,</span>
<span class="line-added">18084             as_FloatRegister($src$$reg));</span>
<span class="line-added">18085      __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,</span>
<span class="line-added">18086                as_FloatRegister($dst$$reg));</span>
<span class="line-added">18087      __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,</span>
<span class="line-added">18088                as_FloatRegister($dst$$reg));</span>
<span class="line-added">18089   %}</span>
<span class="line-added">18090   ins_pipe(pipe_class_default);</span>
<span class="line-added">18091 %}</span>
<span class="line-added">18092 </span>
18093 //----------PEEPHOLE RULES-----------------------------------------------------
18094 // These must follow all instruction definitions as they use the names
18095 // defined in the instructions definitions.
18096 //
18097 // peepmatch ( root_instr_name [preceding_instruction]* );
18098 //
18099 // peepconstraint %{
18100 // (instruction_number.operand_name relational_op instruction_number.operand_name
18101 //  [, ...] );
18102 // // instruction numbers are zero-based using left to right order in peepmatch
18103 //
18104 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
18105 // // provide an instruction_number.operand_name for each operand that appears
18106 // // in the replacement instruction&#39;s match rule
18107 //
18108 // ---------VM FLAGS---------------------------------------------------------
18109 //
18110 // All peephole optimizations can be turned off using -XX:-OptoPeephole
18111 //
18112 // Each peephole rule is given an identifying number starting with zero and
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/conf/jib-profiles.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
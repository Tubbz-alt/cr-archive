<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 275       ShouldNotReachHere();
 276     }
 277   } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
 278     u_int32_t *insns = (u_int32_t *)insn_addr;
 279     // Move wide constant: movz, movk, movk.  See movptr().
 280     assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 281     assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 282     return address(u_int64_t(Instruction_aarch64::extract(insns[0], 20, 5))
 283                    + (u_int64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)
 284                    + (u_int64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));
 285   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 286              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 287     return 0;
 288   } else {
 289     ShouldNotReachHere();
 290   }
 291   return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 292 }
 293 
 294 void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
<span class="line-modified"> 295   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified"> 296     ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-removed"> 297     tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>
<span class="line-removed"> 298   } else {</span>
<span class="line-removed"> 299     unsigned long offset;</span>
<span class="line-removed"> 300     adrp(rscratch1, ExternalAddress(SafepointSynchronize::address_of_state()), offset);</span>
<span class="line-removed"> 301     ldrw(rscratch1, Address(rscratch1, offset));</span>
<span class="line-removed"> 302     assert(SafepointSynchronize::_not_synchronized == 0, &quot;rewrite this code&quot;);</span>
<span class="line-removed"> 303     cbnz(rscratch1, slow_path);</span>
<span class="line-removed"> 304   }</span>
 305 }
 306 
 307 // Just like safepoint_poll, but use an acquiring load for thread-
 308 // local polling.
 309 //
 310 // We need an acquire here to ensure that any subsequent load of the
 311 // global SafepointSynchronize::_state flag is ordered after this load
 312 // of the local Thread::_polling page.  We don&#39;t want this poll to
 313 // return false (i.e. not safepointing) and a later poll of the global
 314 // SafepointSynchronize::_state spuriously to return true.
 315 //
 316 // This is to avoid a race when we&#39;re in a native-&gt;Java transition
 317 // racing the code which wakes up from a safepoint.
 318 //
 319 void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
<span class="line-modified"> 320   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified"> 321     lea(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-modified"> 322     ldar(rscratch1, rscratch1);</span>
<span class="line-removed"> 323     tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>
<span class="line-removed"> 324   } else {</span>
<span class="line-removed"> 325     safepoint_poll(slow_path);</span>
<span class="line-removed"> 326   }</span>
 327 }
 328 
 329 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 330   // we must set sp to zero to clear frame
 331   str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
 332 
 333   // must clear fp, so that compiled frames are not confused; it is
 334   // possible that we need it only for debugging
 335   if (clear_fp) {
 336     str(zr, Address(rthread, JavaThread::last_Java_fp_offset()));
 337   }
 338 
 339   // Always clear the pc because it could have been set by make_walkable()
 340   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 341 }
 342 
 343 // Calls to C land
 344 //
 345 // When entering C land, the rfp, &amp; resp of the last Java frame have to be recorded
 346 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
</pre>
<hr />
<pre>
4353   bind(loop);
4354   lea(tmp, Address(tmp, -os::vm_page_size()));
4355   subsw(size, size, rscratch1);
4356   str(size, Address(tmp));
4357   br(Assembler::GT, loop);
4358 
4359   // Bang down shadow pages too.
4360   // At this point, (tmp-0) is the last address touched, so don&#39;t
4361   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
4362   // was post-decremented.)  Skip this address by starting at i=1, and
4363   // touch a few more pages below.  N.B.  It is important to touch all
4364   // the way down to and including i=StackShadowPages.
4365   for (int i = 0; i &lt; (int)(JavaThread::stack_shadow_zone_size() / os::vm_page_size()) - 1; i++) {
4366     // this could be any sized move but this is can be a debugging crumb
4367     // so the bigger the better.
4368     lea(tmp, Address(tmp, -os::vm_page_size()));
4369     str(size, Address(tmp));
4370   }
4371 }
4372 
<span class="line-modified">4373 </span>
<span class="line-modified">4374 // Move the address of the polling page into dest.</span>
<span class="line-removed">4375 void MacroAssembler::get_polling_page(Register dest, address page, relocInfo::relocType rtype) {</span>
<span class="line-removed">4376   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed">4377     ldr(dest, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-removed">4378   } else {</span>
<span class="line-removed">4379     unsigned long off;</span>
<span class="line-removed">4380     adrp(dest, Address(page, rtype), off);</span>
<span class="line-removed">4381     assert(off == 0, &quot;polling page must be page aligned&quot;);</span>
4382   }
4383 }
4384 
4385 // Move the address of the polling page into r, then read the polling
4386 // page.
<span class="line-modified">4387 address MacroAssembler::read_polling_page(Register r, address page, relocInfo::relocType rtype) {</span>
<span class="line-modified">4388   get_polling_page(r, page, rtype);</span>
4389   return read_polling_page(r, rtype);
4390 }
4391 
4392 // Read the polling page.  The address of the polling page must
4393 // already be in r.
4394 address MacroAssembler::read_polling_page(Register r, relocInfo::relocType rtype) {
4395   InstructionMark im(this);
4396   code_section()-&gt;relocate(inst_mark(), rtype);
4397   ldrw(zr, Address(r, 0));
4398   return inst_mark();
4399 }
4400 
4401 void MacroAssembler::adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset) {
4402   relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
4403   unsigned long low_page = (unsigned long)CodeCache::low_bound() &gt;&gt; 12;
4404   unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) &gt;&gt; 12;
4405   unsigned long dest_page = (unsigned long)dest.target() &gt;&gt; 12;
4406   long offset_low = dest_page - low_page;
4407   long offset_high = dest_page - high_page;
4408 
</pre>
</td>
<td>
<hr />
<pre>
 275       ShouldNotReachHere();
 276     }
 277   } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
 278     u_int32_t *insns = (u_int32_t *)insn_addr;
 279     // Move wide constant: movz, movk, movk.  See movptr().
 280     assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 281     assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 282     return address(u_int64_t(Instruction_aarch64::extract(insns[0], 20, 5))
 283                    + (u_int64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)
 284                    + (u_int64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));
 285   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 286              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 287     return 0;
 288   } else {
 289     ShouldNotReachHere();
 290   }
 291   return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 292 }
 293 
 294 void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
<span class="line-modified"> 295   ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-modified"> 296   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>








 297 }
 298 
 299 // Just like safepoint_poll, but use an acquiring load for thread-
 300 // local polling.
 301 //
 302 // We need an acquire here to ensure that any subsequent load of the
 303 // global SafepointSynchronize::_state flag is ordered after this load
 304 // of the local Thread::_polling page.  We don&#39;t want this poll to
 305 // return false (i.e. not safepointing) and a later poll of the global
 306 // SafepointSynchronize::_state spuriously to return true.
 307 //
 308 // This is to avoid a race when we&#39;re in a native-&gt;Java transition
 309 // racing the code which wakes up from a safepoint.
 310 //
 311 void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
<span class="line-modified"> 312   lea(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-modified"> 313   ldar(rscratch1, rscratch1);</span>
<span class="line-modified"> 314   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>




 315 }
 316 
 317 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 318   // we must set sp to zero to clear frame
 319   str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
 320 
 321   // must clear fp, so that compiled frames are not confused; it is
 322   // possible that we need it only for debugging
 323   if (clear_fp) {
 324     str(zr, Address(rthread, JavaThread::last_Java_fp_offset()));
 325   }
 326 
 327   // Always clear the pc because it could have been set by make_walkable()
 328   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 329 }
 330 
 331 // Calls to C land
 332 //
 333 // When entering C land, the rfp, &amp; resp of the last Java frame have to be recorded
 334 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
</pre>
<hr />
<pre>
4341   bind(loop);
4342   lea(tmp, Address(tmp, -os::vm_page_size()));
4343   subsw(size, size, rscratch1);
4344   str(size, Address(tmp));
4345   br(Assembler::GT, loop);
4346 
4347   // Bang down shadow pages too.
4348   // At this point, (tmp-0) is the last address touched, so don&#39;t
4349   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
4350   // was post-decremented.)  Skip this address by starting at i=1, and
4351   // touch a few more pages below.  N.B.  It is important to touch all
4352   // the way down to and including i=StackShadowPages.
4353   for (int i = 0; i &lt; (int)(JavaThread::stack_shadow_zone_size() / os::vm_page_size()) - 1; i++) {
4354     // this could be any sized move but this is can be a debugging crumb
4355     // so the bigger the better.
4356     lea(tmp, Address(tmp, -os::vm_page_size()));
4357     str(size, Address(tmp));
4358   }
4359 }
4360 
<span class="line-modified">4361 // Move the address of the polling page into dest.</span>
<span class="line-modified">4362 void MacroAssembler::get_polling_page(Register dest, relocInfo::relocType rtype) {</span>







4363   ldr(dest, Address(rthread, Thread::polling_page_offset()));
4364 }
4365 
4366 // Move the address of the polling page into r, then read the polling
4367 // page.
<span class="line-modified">4368 address MacroAssembler::fetch_and_read_polling_page(Register r, relocInfo::relocType rtype) {</span>
<span class="line-modified">4369   get_polling_page(r, rtype);</span>
4370   return read_polling_page(r, rtype);
4371 }
4372 
4373 // Read the polling page.  The address of the polling page must
4374 // already be in r.
4375 address MacroAssembler::read_polling_page(Register r, relocInfo::relocType rtype) {
4376   InstructionMark im(this);
4377   code_section()-&gt;relocate(inst_mark(), rtype);
4378   ldrw(zr, Address(r, 0));
4379   return inst_mark();
4380 }
4381 
4382 void MacroAssembler::adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset) {
4383   relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
4384   unsigned long low_page = (unsigned long)CodeCache::low_bound() &gt;&gt; 12;
4385   unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) &gt;&gt; 12;
4386   unsigned long dest_page = (unsigned long)dest.target() &gt;&gt; 12;
4387   long offset_low = dest_page - low_page;
4388   long offset_high = dest_page - high_page;
4389 
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
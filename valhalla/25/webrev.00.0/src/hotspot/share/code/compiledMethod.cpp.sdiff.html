<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/compiledMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/shenandoah/c2/shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/compiledMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
639 
640     case relocInfo::metadata_type: {
641       // Only the metadata relocations contained in static/opt virtual call stubs
642       // contains the Method* passed to c2i adapters. It is the only metadata
643       // relocation that needs to be walked, as it is the one metadata relocation
644       // that violates the invariant that all metadata relocations have an oop
645       // in the compiled method (due to deferred resolution and code patching).
646 
647       // This causes dead metadata to remain in compiled methods that are not
648       // unloading. Unless these slippery metadata relocations of the static
649       // stubs are at least cleared, subsequent class redefinition operations
650       // will access potentially free memory, and JavaThread execution
651       // concurrent to class unloading may call c2i adapters with dead methods.
652       if (!is_in_static_stub) {
653         // The first metadata relocation after a static stub relocation is the
654         // metadata relocation of the static stub used to pass the Method* to
655         // c2i adapters.
656         continue;
657       }
658       is_in_static_stub = false;





659       metadata_Relocation* r = iter.metadata_reloc();
660       Metadata* md = r-&gt;metadata_value();
661       if (md != NULL &amp;&amp; md-&gt;is_method()) {
662         Method* method = static_cast&lt;Method*&gt;(md);
663         if (!method-&gt;method_holder()-&gt;is_loader_alive()) {
664           Atomic::store(r-&gt;metadata_addr(), (Method*)NULL);
665 
666           if (!r-&gt;metadata_is_immediate()) {
667             r-&gt;fix_metadata_relocation();
668           }
669         }
670       }
671       break;
672     }
673 
674     default:
675       break;
676     }
677   }
678 
</pre>
</td>
<td>
<hr />
<pre>
639 
640     case relocInfo::metadata_type: {
641       // Only the metadata relocations contained in static/opt virtual call stubs
642       // contains the Method* passed to c2i adapters. It is the only metadata
643       // relocation that needs to be walked, as it is the one metadata relocation
644       // that violates the invariant that all metadata relocations have an oop
645       // in the compiled method (due to deferred resolution and code patching).
646 
647       // This causes dead metadata to remain in compiled methods that are not
648       // unloading. Unless these slippery metadata relocations of the static
649       // stubs are at least cleared, subsequent class redefinition operations
650       // will access potentially free memory, and JavaThread execution
651       // concurrent to class unloading may call c2i adapters with dead methods.
652       if (!is_in_static_stub) {
653         // The first metadata relocation after a static stub relocation is the
654         // metadata relocation of the static stub used to pass the Method* to
655         // c2i adapters.
656         continue;
657       }
658       is_in_static_stub = false;
<span class="line-added">659       if (is_unloading()) {</span>
<span class="line-added">660         // If the nmethod itself is dying, then it may point at dead metadata.</span>
<span class="line-added">661         // Nobody should follow that metadata; it is strictly unsafe.</span>
<span class="line-added">662         continue;</span>
<span class="line-added">663       }</span>
664       metadata_Relocation* r = iter.metadata_reloc();
665       Metadata* md = r-&gt;metadata_value();
666       if (md != NULL &amp;&amp; md-&gt;is_method()) {
667         Method* method = static_cast&lt;Method*&gt;(md);
668         if (!method-&gt;method_holder()-&gt;is_loader_alive()) {
669           Atomic::store(r-&gt;metadata_addr(), (Method*)NULL);
670 
671           if (!r-&gt;metadata_is_immediate()) {
672             r-&gt;fix_metadata_relocation();
673           }
674         }
675       }
676       break;
677     }
678 
679     default:
680       break;
681     }
682   }
683 
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/shenandoah/c2/shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
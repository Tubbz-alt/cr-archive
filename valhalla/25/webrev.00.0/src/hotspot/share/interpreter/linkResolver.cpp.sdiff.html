<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/shenandoah/shenandoahBarrierSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;prims/methodHandles.hpp&quot;
  51 #include &quot;prims/nativeLookup.hpp&quot;
  52 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  53 #include &quot;runtime/frame.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/reflection.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vmThread.hpp&quot;
  60 
  61 //------------------------------------------------------------------------------------------------------------------------
  62 // Implementation of CallInfo
  63 
  64 
  65 void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
  66   int vtable_index = Method::nonvirtual_vtable_index;
<span class="line-modified">  67   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
  68 }
  69 
  70 
  71 void CallInfo::set_interface(Klass* resolved_klass,
<span class="line-removed">  72                              Klass* selected_klass,</span>
  73                              const methodHandle&amp; resolved_method,
  74                              const methodHandle&amp; selected_method,
  75                              int itable_index, TRAPS) {
  76   // This is only called for interface methods. If the resolved_method
  77   // comes from java/lang/Object, it can be the subject of a virtual call, so
  78   // we should pick the vtable index from the resolved method.
  79   // In that case, the caller must call set_virtual instead of set_interface.
  80   assert(resolved_method-&gt;method_holder()-&gt;is_interface(), &quot;&quot;);
  81   assert(itable_index == resolved_method()-&gt;itable_index(), &quot;&quot;);
<span class="line-modified">  82   set_common(resolved_klass, selected_klass, resolved_method, selected_method, CallInfo::itable_call, itable_index, CHECK);</span>
  83 }
  84 
  85 void CallInfo::set_virtual(Klass* resolved_klass,
<span class="line-removed">  86                            Klass* selected_klass,</span>
  87                            const methodHandle&amp; resolved_method,
  88                            const methodHandle&amp; selected_method,
  89                            int vtable_index, TRAPS) {
  90   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index, &quot;valid index&quot;);
  91   assert(vtable_index &lt; 0 || !resolved_method-&gt;has_vtable_index() || vtable_index == resolved_method-&gt;vtable_index(), &quot;&quot;);
  92   CallKind kind = (vtable_index &gt;= 0 &amp;&amp; !resolved_method-&gt;can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);
<span class="line-modified">  93   set_common(resolved_klass, selected_klass, resolved_method, selected_method, kind, vtable_index, CHECK);</span>
  94   assert(!resolved_method-&gt;is_compiled_lambda_form(), &quot;these must be handled via an invokehandle call&quot;);
  95 }
  96 
  97 void CallInfo::set_handle(const methodHandle&amp; resolved_method,
  98                           Handle resolved_appendix, TRAPS) {
  99   set_handle(SystemDictionary::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);
 100 }
 101 
 102 void CallInfo::set_handle(Klass* resolved_klass,
 103                           const methodHandle&amp; resolved_method,
 104                           Handle resolved_appendix, TRAPS) {
 105   guarantee(resolved_method.not_null(), &quot;resolved method is null&quot;);
 106   assert(resolved_method-&gt;intrinsic_id() == vmIntrinsics::_invokeBasic ||
 107          resolved_method-&gt;is_compiled_lambda_form(),
 108          &quot;linkMethod must return one of these&quot;);
 109   int vtable_index = Method::nonvirtual_vtable_index;
 110   assert(!resolved_method-&gt;has_vtable_index(), &quot;&quot;);
<span class="line-modified"> 111   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
 112   _resolved_appendix = resolved_appendix;
 113 }
 114 
 115 void CallInfo::set_common(Klass* resolved_klass,
<span class="line-removed"> 116                           Klass* selected_klass,</span>
 117                           const methodHandle&amp; resolved_method,
 118                           const methodHandle&amp; selected_method,
 119                           CallKind kind,
 120                           int index,
 121                           TRAPS) {
 122   assert(resolved_method-&gt;signature() == selected_method-&gt;signature(), &quot;signatures must correspond&quot;);
 123   _resolved_klass  = resolved_klass;
<span class="line-removed"> 124   _selected_klass  = selected_klass;</span>
 125   _resolved_method = resolved_method;
 126   _selected_method = selected_method;
 127   _call_kind       = kind;
 128   _call_index      = index;
 129   _resolved_appendix = Handle();
 130   DEBUG_ONLY(verify());  // verify before making side effects
 131 
 132   CompilationPolicy::compile_if_required(selected_method, THREAD);
 133 }
 134 
 135 // utility query for unreflecting a method
 136 CallInfo::CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS) {
 137   Klass* resolved_method_holder = resolved_method-&gt;method_holder();
 138   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
 139     resolved_klass = resolved_method_holder;
 140   }
 141   _resolved_klass  = resolved_klass;
<span class="line-removed"> 142   _selected_klass  = resolved_klass;</span>
 143   _resolved_method = methodHandle(THREAD, resolved_method);
 144   _selected_method = methodHandle(THREAD, resolved_method);
 145   // classify:
 146   CallKind kind = CallInfo::unknown_kind;
 147   int index = resolved_method-&gt;vtable_index();
 148   if (resolved_method-&gt;can_be_statically_bound()) {
 149     kind = CallInfo::direct_call;
 150   } else if (!resolved_method_holder-&gt;is_interface()) {
 151     // Could be an Object method inherited into an interface, but still a vtable call.
 152     kind = CallInfo::vtable_call;
 153   } else if (!resolved_klass-&gt;is_interface()) {
 154     // A default or miranda method.  Compute the vtable index.
 155     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
 156                            _resolved_method);
 157     assert(index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
 158 
 159     kind = CallInfo::vtable_call;
 160   } else if (resolved_method-&gt;has_vtable_index()) {
 161     // Can occur if an interface redeclares a method of Object.
 162 
</pre>
<hr />
<pre>
 260   _current_method = methodHandle();
 261 
 262   // Coming from the constant pool always checks access
 263   _check_access  = true;
 264 }
 265 
 266 #ifndef PRODUCT
 267 void LinkInfo::print() {
 268   ResourceMark rm;
 269   tty-&gt;print_cr(&quot;Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s&quot;,
 270                 _resolved_klass-&gt;name()-&gt;as_C_string(),
 271                 _name-&gt;as_C_string(),
 272                 _signature-&gt;as_C_string(),
 273                 _current_klass == NULL ? &quot;(none)&quot; : _current_klass-&gt;name()-&gt;as_C_string(),
 274                 _check_access ? &quot;true&quot; : &quot;false&quot;);
 275 }
 276 #endif // PRODUCT
 277 //------------------------------------------------------------------------------------------------------------------------
 278 // Klass resolution
 279 
<span class="line-modified"> 280 void LinkResolver::check_klass_accessability(Klass* ref_klass, Klass* sel_klass,</span>
<span class="line-removed"> 281                                              bool fold_type_to_class, TRAPS) {</span>
 282   Klass* base_klass = sel_klass;
<span class="line-modified"> 283   if (fold_type_to_class) {</span>
<span class="line-modified"> 284     if (sel_klass-&gt;is_objArray_klass()) {</span>
<span class="line-removed"> 285       base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();</span>
<span class="line-removed"> 286     }</span>
<span class="line-removed"> 287     // The element type could be a typeArray - we only need the access</span>
<span class="line-removed"> 288     // check if it is a reference to another class.</span>
<span class="line-removed"> 289     if (!base_klass-&gt;is_instance_klass()) {</span>
<span class="line-removed"> 290       return;  // no relevant check to do</span>
<span class="line-removed"> 291     }</span>
 292   }






 293   Reflection::VerifyClassAccessResults vca_result =
 294     Reflection::verify_class_access(ref_klass, InstanceKlass::cast(base_klass), true);
 295   if (vca_result != Reflection::ACCESS_OK) {
 296     ResourceMark rm(THREAD);
 297     char* msg = Reflection::verify_class_access_msg(ref_klass,
 298                                                     InstanceKlass::cast(base_klass),
 299                                                     vca_result);
 300     bool same_module = (base_klass-&gt;module() == ref_klass-&gt;module());
 301     if (msg == NULL) {
 302       Exceptions::fthrow(
 303         THREAD_AND_LOCATION,
 304         vmSymbols::java_lang_IllegalAccessError(),
 305         &quot;failed to access class %s from class %s (%s%s%s)&quot;,
 306         base_klass-&gt;external_name(),
 307         ref_klass-&gt;external_name(),
 308         (same_module) ? base_klass-&gt;joint_in_module_of_loader(ref_klass) : base_klass-&gt;class_in_module_of_loader(),
 309         (same_module) ? &quot;&quot; : &quot;; &quot;,
 310         (same_module) ? &quot;&quot; : ref_klass-&gt;class_in_module_of_loader());
 311     } else {
 312       // Use module specific message returned by verify_class_access_msg().
</pre>
<hr />
<pre>
 973   if (link_info.check_access()) {
 974 
 975     // check access
 976     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 977 
 978     // check for errors
 979     if (is_static != fd.is_static()) {
 980       ResourceMark rm(THREAD);
 981       char msg[200];
 982       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
 983       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
 984     }
 985 
 986     // A final field can be modified only
 987     // (1) by methods declared in the class declaring the field and
 988     // (2) by the &lt;clinit&gt; method (in case of a static field)
 989     //     or by the &lt;init&gt; method (in case of an instance field).
 990     // (3) by withfield when field is in a value type and the
 991     //     selected class and current class are nest mates.
 992     if (is_put &amp;&amp; fd.access_flags().is_final()) {
<span class="line-removed"> 993       ResourceMark rm(THREAD);</span>
<span class="line-removed"> 994       stringStream ss;</span>
 995 
 996       if (sel_klass != current_klass) {
 997       // If byte code is a withfield check if they are nestmates.
 998       bool are_nestmates = false;
 999       if (sel_klass-&gt;is_instance_klass() &amp;&amp;
1000           InstanceKlass::cast(sel_klass)-&gt;is_value() &amp;&amp;
1001           current_klass-&gt;is_instance_klass()) {
1002         are_nestmates = InstanceKlass::cast(link_info.current_klass())-&gt;has_nestmate_access_to(
1003                                                         InstanceKlass::cast(sel_klass), THREAD);
1004       }
1005       if (!are_nestmates) {


1006         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
1007                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1008                   current_klass-&gt;external_name());
1009         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1010       }
1011       }
1012 
1013       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
1014         Method* m = link_info.current_method();
1015         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
1016         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1017                                                    fd.is_static() &amp;&amp;
1018                                                    !m-&gt;is_class_initializer());
1019         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1020                                                      !fd.is_static() &amp;&amp;
1021                                                      !m-&gt;is_object_constructor());
1022 
1023         if (is_initialized_static_final_update || is_initialized_instance_final_update) {


1024           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1025                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1026                    m-&gt;name()-&gt;as_C_string(),
1027                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1028           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1029         }
1030       }
1031     }
1032 
1033     // initialize resolved_klass if necessary
1034     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1035     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1036     //
1037     // note 2: we don&#39;t want to force initialization if we are just checking
1038     //         if the field access is legal; e.g., during compilation
1039     if (is_static &amp;&amp; initialize_class) {
1040       sel_klass-&gt;initialize(CHECK);
1041     }
1042   }
1043 
</pre>
<hr />
<pre>
1394     }
1395   }
1396 
1397   // check if method exists
1398   if (selected_method.is_null()) {
1399     throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1400   }
1401 
1402   // check if abstract
1403   if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1404     // Pass arguments for generating a verbose error message.
1405     throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1406   }
1407 
1408   if (log_develop_is_enabled(Trace, vtables)) {
1409     trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
1410                             recv_klass, resolved_klass, selected_method(),
1411                             false, vtable_index);
1412   }
1413   // setup result
<span class="line-modified">1414   result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1415 }
1416 
1417 void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
1418                                           const LinkInfo&amp; link_info,
1419                                           bool check_null_and_abstract, TRAPS) {
1420   // throws linktime exceptions
1421   Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);
1422   methodHandle mh(THREAD, resolved_method);
1423   runtime_resolve_interface_method(result, mh, link_info.resolved_klass(),
1424                                    recv, recv_klass, check_null_and_abstract, CHECK);
1425 }
1426 
1427 Method* LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,
1428                                                              TRAPS) {
1429   // normal interface method resolution
1430   Method* resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);
1431   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1432   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1433 
1434   return resolved_method;
</pre>
<hr />
<pre>
1490       ss.print(&quot;&#39;&quot;);
1491       Method::print_external_name(&amp;ss, recv_klass, selected_method-&gt;name(), selected_method-&gt;signature());
1492       ss.print(&quot;&#39;&quot;);
1493       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1494     }
1495     // check if abstract
1496     if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1497       throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1498     }
1499   }
1500 
1501   if (log_develop_is_enabled(Trace, itables)) {
1502     trace_method_resolution(&quot;invokeinterface selected method: receiver-class:&quot;,
1503                             recv_klass, resolved_klass, selected_method(), true);
1504   }
1505   // setup result
1506   if (resolved_method-&gt;has_vtable_index()) {
1507     int vtable_index = resolved_method-&gt;vtable_index();
1508     log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
1509     assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
<span class="line-modified">1510     result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1511   } else if (resolved_method-&gt;has_itable_index()) {
1512     int itable_index = resolved_method()-&gt;itable_index();
1513     log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
<span class="line-modified">1514     result.set_interface(resolved_klass, recv_klass, resolved_method, selected_method, itable_index, CHECK);</span>
1515   } else {
1516     int index = resolved_method-&gt;vtable_index();
1517     log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
1518     assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
1519     assert(resolved_method()-&gt;is_private() ||
1520            (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
1521            &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
1522     assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
1523     // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
<span class="line-modified">1524     result.set_virtual(resolved_klass, resolved_klass, resolved_method, resolved_method, index, CHECK);</span>
1525   }
1526 }
1527 
1528 
1529 Method* LinkResolver::linktime_resolve_interface_method_or_null(
1530                                                  const LinkInfo&amp; link_info) {
1531   EXCEPTION_MARK;
1532   Method* method_result = linktime_resolve_interface_method(link_info, THREAD);
1533   if (HAS_PENDING_EXCEPTION) {
1534     CLEAR_PENDING_EXCEPTION;
1535     return NULL;
1536   } else {
1537     return method_result;
1538   }
1539 }
1540 
1541 Method* LinkResolver::linktime_resolve_virtual_method_or_null(
1542                                                  const LinkInfo&amp; link_info) {
1543   EXCEPTION_MARK;
1544   Method* method_result = linktime_resolve_virtual_method(link_info, THREAD);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;prims/methodHandles.hpp&quot;
  51 #include &quot;prims/nativeLookup.hpp&quot;
  52 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  53 #include &quot;runtime/frame.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/reflection.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vmThread.hpp&quot;
  60 
  61 //------------------------------------------------------------------------------------------------------------------------
  62 // Implementation of CallInfo
  63 
  64 
  65 void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
  66   int vtable_index = Method::nonvirtual_vtable_index;
<span class="line-modified">  67   set_common(resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
  68 }
  69 
  70 
  71 void CallInfo::set_interface(Klass* resolved_klass,

  72                              const methodHandle&amp; resolved_method,
  73                              const methodHandle&amp; selected_method,
  74                              int itable_index, TRAPS) {
  75   // This is only called for interface methods. If the resolved_method
  76   // comes from java/lang/Object, it can be the subject of a virtual call, so
  77   // we should pick the vtable index from the resolved method.
  78   // In that case, the caller must call set_virtual instead of set_interface.
  79   assert(resolved_method-&gt;method_holder()-&gt;is_interface(), &quot;&quot;);
  80   assert(itable_index == resolved_method()-&gt;itable_index(), &quot;&quot;);
<span class="line-modified">  81   set_common(resolved_klass, resolved_method, selected_method, CallInfo::itable_call, itable_index, CHECK);</span>
  82 }
  83 
  84 void CallInfo::set_virtual(Klass* resolved_klass,

  85                            const methodHandle&amp; resolved_method,
  86                            const methodHandle&amp; selected_method,
  87                            int vtable_index, TRAPS) {
  88   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index, &quot;valid index&quot;);
  89   assert(vtable_index &lt; 0 || !resolved_method-&gt;has_vtable_index() || vtable_index == resolved_method-&gt;vtable_index(), &quot;&quot;);
  90   CallKind kind = (vtable_index &gt;= 0 &amp;&amp; !resolved_method-&gt;can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);
<span class="line-modified">  91   set_common(resolved_klass, resolved_method, selected_method, kind, vtable_index, CHECK);</span>
  92   assert(!resolved_method-&gt;is_compiled_lambda_form(), &quot;these must be handled via an invokehandle call&quot;);
  93 }
  94 
  95 void CallInfo::set_handle(const methodHandle&amp; resolved_method,
  96                           Handle resolved_appendix, TRAPS) {
  97   set_handle(SystemDictionary::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);
  98 }
  99 
 100 void CallInfo::set_handle(Klass* resolved_klass,
 101                           const methodHandle&amp; resolved_method,
 102                           Handle resolved_appendix, TRAPS) {
 103   guarantee(resolved_method.not_null(), &quot;resolved method is null&quot;);
 104   assert(resolved_method-&gt;intrinsic_id() == vmIntrinsics::_invokeBasic ||
 105          resolved_method-&gt;is_compiled_lambda_form(),
 106          &quot;linkMethod must return one of these&quot;);
 107   int vtable_index = Method::nonvirtual_vtable_index;
 108   assert(!resolved_method-&gt;has_vtable_index(), &quot;&quot;);
<span class="line-modified"> 109   set_common(resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
 110   _resolved_appendix = resolved_appendix;
 111 }
 112 
 113 void CallInfo::set_common(Klass* resolved_klass,

 114                           const methodHandle&amp; resolved_method,
 115                           const methodHandle&amp; selected_method,
 116                           CallKind kind,
 117                           int index,
 118                           TRAPS) {
 119   assert(resolved_method-&gt;signature() == selected_method-&gt;signature(), &quot;signatures must correspond&quot;);
 120   _resolved_klass  = resolved_klass;

 121   _resolved_method = resolved_method;
 122   _selected_method = selected_method;
 123   _call_kind       = kind;
 124   _call_index      = index;
 125   _resolved_appendix = Handle();
 126   DEBUG_ONLY(verify());  // verify before making side effects
 127 
 128   CompilationPolicy::compile_if_required(selected_method, THREAD);
 129 }
 130 
 131 // utility query for unreflecting a method
 132 CallInfo::CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS) {
 133   Klass* resolved_method_holder = resolved_method-&gt;method_holder();
 134   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
 135     resolved_klass = resolved_method_holder;
 136   }
 137   _resolved_klass  = resolved_klass;

 138   _resolved_method = methodHandle(THREAD, resolved_method);
 139   _selected_method = methodHandle(THREAD, resolved_method);
 140   // classify:
 141   CallKind kind = CallInfo::unknown_kind;
 142   int index = resolved_method-&gt;vtable_index();
 143   if (resolved_method-&gt;can_be_statically_bound()) {
 144     kind = CallInfo::direct_call;
 145   } else if (!resolved_method_holder-&gt;is_interface()) {
 146     // Could be an Object method inherited into an interface, but still a vtable call.
 147     kind = CallInfo::vtable_call;
 148   } else if (!resolved_klass-&gt;is_interface()) {
 149     // A default or miranda method.  Compute the vtable index.
 150     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
 151                            _resolved_method);
 152     assert(index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
 153 
 154     kind = CallInfo::vtable_call;
 155   } else if (resolved_method-&gt;has_vtable_index()) {
 156     // Can occur if an interface redeclares a method of Object.
 157 
</pre>
<hr />
<pre>
 255   _current_method = methodHandle();
 256 
 257   // Coming from the constant pool always checks access
 258   _check_access  = true;
 259 }
 260 
 261 #ifndef PRODUCT
 262 void LinkInfo::print() {
 263   ResourceMark rm;
 264   tty-&gt;print_cr(&quot;Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s&quot;,
 265                 _resolved_klass-&gt;name()-&gt;as_C_string(),
 266                 _name-&gt;as_C_string(),
 267                 _signature-&gt;as_C_string(),
 268                 _current_klass == NULL ? &quot;(none)&quot; : _current_klass-&gt;name()-&gt;as_C_string(),
 269                 _check_access ? &quot;true&quot; : &quot;false&quot;);
 270 }
 271 #endif // PRODUCT
 272 //------------------------------------------------------------------------------------------------------------------------
 273 // Klass resolution
 274 
<span class="line-modified"> 275 void LinkResolver::check_klass_accessibility(Klass* ref_klass, Klass* sel_klass, TRAPS) {</span>

 276   Klass* base_klass = sel_klass;
<span class="line-modified"> 277   if (sel_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified"> 278     base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();</span>







 279   }
<span class="line-added"> 280   // The element type could be a typeArray - we only need the access</span>
<span class="line-added"> 281   // check if it is a reference to another class.</span>
<span class="line-added"> 282   if (!base_klass-&gt;is_instance_klass()) {</span>
<span class="line-added"> 283     return;  // no relevant check to do</span>
<span class="line-added"> 284   }</span>
<span class="line-added"> 285 </span>
 286   Reflection::VerifyClassAccessResults vca_result =
 287     Reflection::verify_class_access(ref_klass, InstanceKlass::cast(base_klass), true);
 288   if (vca_result != Reflection::ACCESS_OK) {
 289     ResourceMark rm(THREAD);
 290     char* msg = Reflection::verify_class_access_msg(ref_klass,
 291                                                     InstanceKlass::cast(base_klass),
 292                                                     vca_result);
 293     bool same_module = (base_klass-&gt;module() == ref_klass-&gt;module());
 294     if (msg == NULL) {
 295       Exceptions::fthrow(
 296         THREAD_AND_LOCATION,
 297         vmSymbols::java_lang_IllegalAccessError(),
 298         &quot;failed to access class %s from class %s (%s%s%s)&quot;,
 299         base_klass-&gt;external_name(),
 300         ref_klass-&gt;external_name(),
 301         (same_module) ? base_klass-&gt;joint_in_module_of_loader(ref_klass) : base_klass-&gt;class_in_module_of_loader(),
 302         (same_module) ? &quot;&quot; : &quot;; &quot;,
 303         (same_module) ? &quot;&quot; : ref_klass-&gt;class_in_module_of_loader());
 304     } else {
 305       // Use module specific message returned by verify_class_access_msg().
</pre>
<hr />
<pre>
 966   if (link_info.check_access()) {
 967 
 968     // check access
 969     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 970 
 971     // check for errors
 972     if (is_static != fd.is_static()) {
 973       ResourceMark rm(THREAD);
 974       char msg[200];
 975       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
 976       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
 977     }
 978 
 979     // A final field can be modified only
 980     // (1) by methods declared in the class declaring the field and
 981     // (2) by the &lt;clinit&gt; method (in case of a static field)
 982     //     or by the &lt;init&gt; method (in case of an instance field).
 983     // (3) by withfield when field is in a value type and the
 984     //     selected class and current class are nest mates.
 985     if (is_put &amp;&amp; fd.access_flags().is_final()) {


 986 
 987       if (sel_klass != current_klass) {
 988       // If byte code is a withfield check if they are nestmates.
 989       bool are_nestmates = false;
 990       if (sel_klass-&gt;is_instance_klass() &amp;&amp;
 991           InstanceKlass::cast(sel_klass)-&gt;is_value() &amp;&amp;
 992           current_klass-&gt;is_instance_klass()) {
 993         are_nestmates = InstanceKlass::cast(link_info.current_klass())-&gt;has_nestmate_access_to(
 994                                                         InstanceKlass::cast(sel_klass), THREAD);
 995       }
 996       if (!are_nestmates) {
<span class="line-added"> 997         ResourceMark rm(THREAD);</span>
<span class="line-added"> 998         stringStream ss;</span>
 999         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
1000                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1001                   current_klass-&gt;external_name());
1002         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1003       }
1004       }
1005 
1006       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
1007         Method* m = link_info.current_method();
1008         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
1009         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1010                                                    fd.is_static() &amp;&amp;
1011                                                    !m-&gt;is_class_initializer());
1012         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1013                                                      !fd.is_static() &amp;&amp;
1014                                                      !m-&gt;is_object_constructor());
1015 
1016         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
<span class="line-added">1017           ResourceMark rm(THREAD);</span>
<span class="line-added">1018           stringStream ss;</span>
1019           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1020                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1021                    m-&gt;name()-&gt;as_C_string(),
1022                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1023           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1024         }
1025       }
1026     }
1027 
1028     // initialize resolved_klass if necessary
1029     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1030     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1031     //
1032     // note 2: we don&#39;t want to force initialization if we are just checking
1033     //         if the field access is legal; e.g., during compilation
1034     if (is_static &amp;&amp; initialize_class) {
1035       sel_klass-&gt;initialize(CHECK);
1036     }
1037   }
1038 
</pre>
<hr />
<pre>
1389     }
1390   }
1391 
1392   // check if method exists
1393   if (selected_method.is_null()) {
1394     throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1395   }
1396 
1397   // check if abstract
1398   if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1399     // Pass arguments for generating a verbose error message.
1400     throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1401   }
1402 
1403   if (log_develop_is_enabled(Trace, vtables)) {
1404     trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
1405                             recv_klass, resolved_klass, selected_method(),
1406                             false, vtable_index);
1407   }
1408   // setup result
<span class="line-modified">1409   result.set_virtual(resolved_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1410 }
1411 
1412 void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
1413                                           const LinkInfo&amp; link_info,
1414                                           bool check_null_and_abstract, TRAPS) {
1415   // throws linktime exceptions
1416   Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);
1417   methodHandle mh(THREAD, resolved_method);
1418   runtime_resolve_interface_method(result, mh, link_info.resolved_klass(),
1419                                    recv, recv_klass, check_null_and_abstract, CHECK);
1420 }
1421 
1422 Method* LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,
1423                                                              TRAPS) {
1424   // normal interface method resolution
1425   Method* resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);
1426   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1427   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1428 
1429   return resolved_method;
</pre>
<hr />
<pre>
1485       ss.print(&quot;&#39;&quot;);
1486       Method::print_external_name(&amp;ss, recv_klass, selected_method-&gt;name(), selected_method-&gt;signature());
1487       ss.print(&quot;&#39;&quot;);
1488       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1489     }
1490     // check if abstract
1491     if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1492       throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1493     }
1494   }
1495 
1496   if (log_develop_is_enabled(Trace, itables)) {
1497     trace_method_resolution(&quot;invokeinterface selected method: receiver-class:&quot;,
1498                             recv_klass, resolved_klass, selected_method(), true);
1499   }
1500   // setup result
1501   if (resolved_method-&gt;has_vtable_index()) {
1502     int vtable_index = resolved_method-&gt;vtable_index();
1503     log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
1504     assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
<span class="line-modified">1505     result.set_virtual(resolved_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1506   } else if (resolved_method-&gt;has_itable_index()) {
1507     int itable_index = resolved_method()-&gt;itable_index();
1508     log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
<span class="line-modified">1509     result.set_interface(resolved_klass, resolved_method, selected_method, itable_index, CHECK);</span>
1510   } else {
1511     int index = resolved_method-&gt;vtable_index();
1512     log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
1513     assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
1514     assert(resolved_method()-&gt;is_private() ||
1515            (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
1516            &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
1517     assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
1518     // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
<span class="line-modified">1519     result.set_virtual(resolved_klass, resolved_method, resolved_method, index, CHECK);</span>
1520   }
1521 }
1522 
1523 
1524 Method* LinkResolver::linktime_resolve_interface_method_or_null(
1525                                                  const LinkInfo&amp; link_info) {
1526   EXCEPTION_MARK;
1527   Method* method_result = linktime_resolve_interface_method(link_info, THREAD);
1528   if (HAS_PENDING_EXCEPTION) {
1529     CLEAR_PENDING_EXCEPTION;
1530     return NULL;
1531   } else {
1532     return method_result;
1533   }
1534 }
1535 
1536 Method* LinkResolver::linktime_resolve_virtual_method_or_null(
1537                                                  const LinkInfo&amp; link_info) {
1538   EXCEPTION_MARK;
1539   Method* method_result = linktime_resolve_virtual_method(link_info, THREAD);
</pre>
</td>
</tr>
</table>
<center><a href="../gc/shenandoah/shenandoahBarrierSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
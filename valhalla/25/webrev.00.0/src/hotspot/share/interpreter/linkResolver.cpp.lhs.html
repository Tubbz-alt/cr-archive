<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/defaultMethods.hpp&quot;
  28 #include &quot;classfile/javaClasses.hpp&quot;
  29 #include &quot;classfile/resolutionErrors.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;compiler/compilationPolicy.hpp&quot;
  34 #include &quot;compiler/compileBroker.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  36 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  37 #include &quot;interpreter/bytecode.hpp&quot;
  38 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  39 #include &quot;interpreter/linkResolver.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;logging/logStream.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;oops/constantPool.hpp&quot;
  44 #include &quot;oops/cpCache.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/method.hpp&quot;
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;prims/methodHandles.hpp&quot;
  51 #include &quot;prims/nativeLookup.hpp&quot;
  52 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  53 #include &quot;runtime/frame.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/reflection.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vmThread.hpp&quot;
  60 
  61 //------------------------------------------------------------------------------------------------------------------------
  62 // Implementation of CallInfo
  63 
  64 
  65 void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
  66   int vtable_index = Method::nonvirtual_vtable_index;
<a name="2" id="anc2"></a><span class="line-modified">  67   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
  68 }
  69 
  70 
  71 void CallInfo::set_interface(Klass* resolved_klass,
<a name="3" id="anc3"></a><span class="line-removed">  72                              Klass* selected_klass,</span>
  73                              const methodHandle&amp; resolved_method,
  74                              const methodHandle&amp; selected_method,
  75                              int itable_index, TRAPS) {
  76   // This is only called for interface methods. If the resolved_method
  77   // comes from java/lang/Object, it can be the subject of a virtual call, so
  78   // we should pick the vtable index from the resolved method.
  79   // In that case, the caller must call set_virtual instead of set_interface.
  80   assert(resolved_method-&gt;method_holder()-&gt;is_interface(), &quot;&quot;);
  81   assert(itable_index == resolved_method()-&gt;itable_index(), &quot;&quot;);
<a name="4" id="anc4"></a><span class="line-modified">  82   set_common(resolved_klass, selected_klass, resolved_method, selected_method, CallInfo::itable_call, itable_index, CHECK);</span>
  83 }
  84 
  85 void CallInfo::set_virtual(Klass* resolved_klass,
<a name="5" id="anc5"></a><span class="line-removed">  86                            Klass* selected_klass,</span>
  87                            const methodHandle&amp; resolved_method,
  88                            const methodHandle&amp; selected_method,
  89                            int vtable_index, TRAPS) {
  90   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index, &quot;valid index&quot;);
  91   assert(vtable_index &lt; 0 || !resolved_method-&gt;has_vtable_index() || vtable_index == resolved_method-&gt;vtable_index(), &quot;&quot;);
  92   CallKind kind = (vtable_index &gt;= 0 &amp;&amp; !resolved_method-&gt;can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);
<a name="6" id="anc6"></a><span class="line-modified">  93   set_common(resolved_klass, selected_klass, resolved_method, selected_method, kind, vtable_index, CHECK);</span>
  94   assert(!resolved_method-&gt;is_compiled_lambda_form(), &quot;these must be handled via an invokehandle call&quot;);
  95 }
  96 
  97 void CallInfo::set_handle(const methodHandle&amp; resolved_method,
  98                           Handle resolved_appendix, TRAPS) {
  99   set_handle(SystemDictionary::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);
 100 }
 101 
 102 void CallInfo::set_handle(Klass* resolved_klass,
 103                           const methodHandle&amp; resolved_method,
 104                           Handle resolved_appendix, TRAPS) {
 105   guarantee(resolved_method.not_null(), &quot;resolved method is null&quot;);
 106   assert(resolved_method-&gt;intrinsic_id() == vmIntrinsics::_invokeBasic ||
 107          resolved_method-&gt;is_compiled_lambda_form(),
 108          &quot;linkMethod must return one of these&quot;);
 109   int vtable_index = Method::nonvirtual_vtable_index;
 110   assert(!resolved_method-&gt;has_vtable_index(), &quot;&quot;);
<a name="7" id="anc7"></a><span class="line-modified"> 111   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
 112   _resolved_appendix = resolved_appendix;
 113 }
 114 
 115 void CallInfo::set_common(Klass* resolved_klass,
<a name="8" id="anc8"></a><span class="line-removed"> 116                           Klass* selected_klass,</span>
 117                           const methodHandle&amp; resolved_method,
 118                           const methodHandle&amp; selected_method,
 119                           CallKind kind,
 120                           int index,
 121                           TRAPS) {
 122   assert(resolved_method-&gt;signature() == selected_method-&gt;signature(), &quot;signatures must correspond&quot;);
 123   _resolved_klass  = resolved_klass;
<a name="9" id="anc9"></a><span class="line-removed"> 124   _selected_klass  = selected_klass;</span>
 125   _resolved_method = resolved_method;
 126   _selected_method = selected_method;
 127   _call_kind       = kind;
 128   _call_index      = index;
 129   _resolved_appendix = Handle();
 130   DEBUG_ONLY(verify());  // verify before making side effects
 131 
 132   CompilationPolicy::compile_if_required(selected_method, THREAD);
 133 }
 134 
 135 // utility query for unreflecting a method
 136 CallInfo::CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS) {
 137   Klass* resolved_method_holder = resolved_method-&gt;method_holder();
 138   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
 139     resolved_klass = resolved_method_holder;
 140   }
 141   _resolved_klass  = resolved_klass;
<a name="10" id="anc10"></a><span class="line-removed"> 142   _selected_klass  = resolved_klass;</span>
 143   _resolved_method = methodHandle(THREAD, resolved_method);
 144   _selected_method = methodHandle(THREAD, resolved_method);
 145   // classify:
 146   CallKind kind = CallInfo::unknown_kind;
 147   int index = resolved_method-&gt;vtable_index();
 148   if (resolved_method-&gt;can_be_statically_bound()) {
 149     kind = CallInfo::direct_call;
 150   } else if (!resolved_method_holder-&gt;is_interface()) {
 151     // Could be an Object method inherited into an interface, but still a vtable call.
 152     kind = CallInfo::vtable_call;
 153   } else if (!resolved_klass-&gt;is_interface()) {
 154     // A default or miranda method.  Compute the vtable index.
 155     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
 156                            _resolved_method);
 157     assert(index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
 158 
 159     kind = CallInfo::vtable_call;
 160   } else if (resolved_method-&gt;has_vtable_index()) {
 161     // Can occur if an interface redeclares a method of Object.
 162 
 163 #ifdef ASSERT
 164     // Ensure that this is really the case.
 165     Klass* object_klass = SystemDictionary::Object_klass();
 166     Method * object_resolved_method = object_klass-&gt;vtable().method_at(index);
 167     assert(object_resolved_method-&gt;name() == resolved_method-&gt;name(),
 168       &quot;Object and interface method names should match at vtable index %d, %s != %s&quot;,
 169       index, object_resolved_method-&gt;name()-&gt;as_C_string(), resolved_method-&gt;name()-&gt;as_C_string());
 170     assert(object_resolved_method-&gt;signature() == resolved_method-&gt;signature(),
 171       &quot;Object and interface method signatures should match at vtable index %d, %s != %s&quot;,
 172       index, object_resolved_method-&gt;signature()-&gt;as_C_string(), resolved_method-&gt;signature()-&gt;as_C_string());
 173 #endif // ASSERT
 174 
 175     kind = CallInfo::vtable_call;
 176   } else {
 177     // A regular interface call.
 178     kind = CallInfo::itable_call;
 179     index = resolved_method-&gt;itable_index();
 180   }
 181   assert(index == Method::nonvirtual_vtable_index || index &gt;= 0, &quot;bad index %d&quot;, index);
 182   _call_kind  = kind;
 183   _call_index = index;
 184   _resolved_appendix = Handle();
 185   // Find or create a ResolvedMethod instance for this Method*
 186   set_resolved_method_name(CHECK);
 187 
 188   DEBUG_ONLY(verify());
 189 }
 190 
 191 void CallInfo::set_resolved_method_name(TRAPS) {
 192   assert(_resolved_method() != NULL, &quot;Should already have a Method*&quot;);
 193   oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(_resolved_method, CHECK);
 194   _resolved_method_name = Handle(THREAD, rmethod_name);
 195 }
 196 
 197 #ifdef ASSERT
 198 void CallInfo::verify() {
 199   switch (call_kind()) {  // the meaning and allowed value of index depends on kind
 200   case CallInfo::direct_call:
 201     if (_call_index == Method::nonvirtual_vtable_index)  break;
 202     // else fall through to check vtable index:
 203   case CallInfo::vtable_call:
 204     assert(resolved_klass()-&gt;verify_vtable_index(_call_index), &quot;&quot;);
 205     break;
 206   case CallInfo::itable_call:
 207     assert(resolved_method()-&gt;method_holder()-&gt;verify_itable_index(_call_index), &quot;&quot;);
 208     break;
 209   case CallInfo::unknown_kind:
 210     assert(call_kind() != CallInfo::unknown_kind, &quot;CallInfo must be set&quot;);
 211     break;
 212   default:
 213     fatal(&quot;Unexpected call kind %d&quot;, call_kind());
 214   }
 215 }
 216 #endif // ASSERT
 217 
 218 #ifndef PRODUCT
 219 void CallInfo::print() {
 220   ResourceMark rm;
 221   const char* kindstr;
 222   switch (_call_kind) {
 223   case direct_call: kindstr = &quot;direct&quot;;  break;
 224   case vtable_call: kindstr = &quot;vtable&quot;;  break;
 225   case itable_call: kindstr = &quot;itable&quot;;  break;
 226   default         : kindstr = &quot;unknown&quot;; break;
 227   }
 228   tty-&gt;print_cr(&quot;Call %s@%d %s&quot;, kindstr, _call_index,
 229                 _resolved_method.is_null() ? &quot;(none)&quot; : _resolved_method-&gt;name_and_sig_as_C_string());
 230 }
 231 #endif
 232 
 233 //------------------------------------------------------------------------------------------------------------------------
 234 // Implementation of LinkInfo
 235 
 236 LinkInfo::LinkInfo(const constantPoolHandle&amp; pool, int index, const methodHandle&amp; current_method, TRAPS) {
 237    // resolve klass
 238   _resolved_klass = pool-&gt;klass_ref_at(index, CHECK);
 239 
 240   // Get name, signature, and static klass
 241   _name          = pool-&gt;name_ref_at(index);
 242   _signature     = pool-&gt;signature_ref_at(index);
 243   _tag           = pool-&gt;tag_ref_at(index);
 244   _current_klass = pool-&gt;pool_holder();
 245   _current_method = current_method;
 246 
 247   // Coming from the constant pool always checks access
 248   _check_access  = true;
 249 }
 250 
 251 LinkInfo::LinkInfo(const constantPoolHandle&amp; pool, int index, TRAPS) {
 252    // resolve klass
 253   _resolved_klass = pool-&gt;klass_ref_at(index, CHECK);
 254 
 255   // Get name, signature, and static klass
 256   _name          = pool-&gt;name_ref_at(index);
 257   _signature     = pool-&gt;signature_ref_at(index);
 258   _tag           = pool-&gt;tag_ref_at(index);
 259   _current_klass = pool-&gt;pool_holder();
 260   _current_method = methodHandle();
 261 
 262   // Coming from the constant pool always checks access
 263   _check_access  = true;
 264 }
 265 
 266 #ifndef PRODUCT
 267 void LinkInfo::print() {
 268   ResourceMark rm;
 269   tty-&gt;print_cr(&quot;Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s&quot;,
 270                 _resolved_klass-&gt;name()-&gt;as_C_string(),
 271                 _name-&gt;as_C_string(),
 272                 _signature-&gt;as_C_string(),
 273                 _current_klass == NULL ? &quot;(none)&quot; : _current_klass-&gt;name()-&gt;as_C_string(),
 274                 _check_access ? &quot;true&quot; : &quot;false&quot;);
 275 }
 276 #endif // PRODUCT
 277 //------------------------------------------------------------------------------------------------------------------------
 278 // Klass resolution
 279 
<a name="11" id="anc11"></a><span class="line-modified"> 280 void LinkResolver::check_klass_accessability(Klass* ref_klass, Klass* sel_klass,</span>
<span class="line-removed"> 281                                              bool fold_type_to_class, TRAPS) {</span>
 282   Klass* base_klass = sel_klass;
<a name="12" id="anc12"></a><span class="line-modified"> 283   if (fold_type_to_class) {</span>
<span class="line-modified"> 284     if (sel_klass-&gt;is_objArray_klass()) {</span>
<span class="line-removed"> 285       base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();</span>
<span class="line-removed"> 286     }</span>
<span class="line-removed"> 287     // The element type could be a typeArray - we only need the access</span>
<span class="line-removed"> 288     // check if it is a reference to another class.</span>
<span class="line-removed"> 289     if (!base_klass-&gt;is_instance_klass()) {</span>
<span class="line-removed"> 290       return;  // no relevant check to do</span>
<span class="line-removed"> 291     }</span>
 292   }
<a name="13" id="anc13"></a>





 293   Reflection::VerifyClassAccessResults vca_result =
 294     Reflection::verify_class_access(ref_klass, InstanceKlass::cast(base_klass), true);
 295   if (vca_result != Reflection::ACCESS_OK) {
 296     ResourceMark rm(THREAD);
 297     char* msg = Reflection::verify_class_access_msg(ref_klass,
 298                                                     InstanceKlass::cast(base_klass),
 299                                                     vca_result);
 300     bool same_module = (base_klass-&gt;module() == ref_klass-&gt;module());
 301     if (msg == NULL) {
 302       Exceptions::fthrow(
 303         THREAD_AND_LOCATION,
 304         vmSymbols::java_lang_IllegalAccessError(),
 305         &quot;failed to access class %s from class %s (%s%s%s)&quot;,
 306         base_klass-&gt;external_name(),
 307         ref_klass-&gt;external_name(),
 308         (same_module) ? base_klass-&gt;joint_in_module_of_loader(ref_klass) : base_klass-&gt;class_in_module_of_loader(),
 309         (same_module) ? &quot;&quot; : &quot;; &quot;,
 310         (same_module) ? &quot;&quot; : ref_klass-&gt;class_in_module_of_loader());
 311     } else {
 312       // Use module specific message returned by verify_class_access_msg().
 313       Exceptions::fthrow(
 314         THREAD_AND_LOCATION,
 315         vmSymbols::java_lang_IllegalAccessError(),
 316         &quot;%s&quot;, msg);
 317     }
 318   }
 319 }
 320 
 321 //------------------------------------------------------------------------------------------------------------------------
 322 // Method resolution
 323 //
 324 // According to JVM spec. $5.4.3c &amp; $5.4.3d
 325 
 326 // Look up method in klasses, including static methods
 327 // Then look up local default methods
 328 Method* LinkResolver::lookup_method_in_klasses(const LinkInfo&amp; link_info,
 329                                                bool checkpolymorphism,
 330                                                bool in_imethod_resolve) {
 331   NoSafepointVerifier nsv;  // Method* returned may not be reclaimed
 332 
 333   Klass* klass = link_info.resolved_klass();
 334   Symbol* name = link_info.name();
 335   Symbol* signature = link_info.signature();
 336 
 337   // Ignore overpasses so statics can be found during resolution
 338   Method* result = klass-&gt;uncached_lookup_method(name, signature, Klass::skip_overpass);
 339 
 340   if (klass-&gt;is_array_klass()) {
 341     // Only consider klass and super klass for arrays
 342     return result;
 343   }
 344 
 345   InstanceKlass* ik = InstanceKlass::cast(klass);
 346 
 347   // JDK 8, JVMS 5.4.3.4: Interface method resolution should
 348   // ignore static and non-public methods of java.lang.Object,
 349   // like clone, finalize, registerNatives.
 350   if (in_imethod_resolve &amp;&amp;
 351       result != NULL &amp;&amp;
 352       ik-&gt;is_interface() &amp;&amp;
 353       (result-&gt;is_static() || !result-&gt;is_public()) &amp;&amp;
 354       result-&gt;method_holder() == SystemDictionary::Object_klass()) {
 355     result = NULL;
 356   }
 357 
 358   // Before considering default methods, check for an overpass in the
 359   // current class if a method has not been found.
 360   if (result == NULL) {
 361     result = ik-&gt;find_method(name, signature);
 362   }
 363 
 364   if (result == NULL) {
 365     Array&lt;Method*&gt;* default_methods = ik-&gt;default_methods();
 366     if (default_methods != NULL) {
 367       result = InstanceKlass::find_method(default_methods, name, signature);
 368     }
 369   }
 370 
 371   if (checkpolymorphism &amp;&amp; result != NULL) {
 372     vmIntrinsics::ID iid = result-&gt;intrinsic_id();
 373     if (MethodHandles::is_signature_polymorphic(iid)) {
 374       // Do not link directly to these.  The VM must produce a synthetic one using lookup_polymorphic_method.
 375       return NULL;
 376     }
 377   }
 378   return result;
 379 }
 380 
 381 // returns first instance method
 382 // Looks up method in classes, then looks up local default methods
 383 Method* LinkResolver::lookup_instance_method_in_klasses(Klass* klass,
 384                                                         Symbol* name,
 385                                                         Symbol* signature,
 386                                                         Klass::PrivateLookupMode private_mode, TRAPS) {
 387   Method* result = klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
 388 
 389   while (result != NULL &amp;&amp; result-&gt;is_static() &amp;&amp; result-&gt;method_holder()-&gt;super() != NULL) {
 390     Klass* super_klass = result-&gt;method_holder()-&gt;super();
 391     result = super_klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
 392   }
 393 
 394   if (klass-&gt;is_array_klass()) {
 395     // Only consider klass and super klass for arrays
 396     return result;
 397   }
 398 
 399   if (result == NULL) {
 400     Array&lt;Method*&gt;* default_methods = InstanceKlass::cast(klass)-&gt;default_methods();
 401     if (default_methods != NULL) {
 402       result = InstanceKlass::find_method(default_methods, name, signature);
 403       assert(result == NULL || !result-&gt;is_static(), &quot;static defaults not allowed&quot;);
 404     }
 405   }
 406   return result;
 407 }
 408 
 409 int LinkResolver::vtable_index_of_interface_method(Klass* klass,
 410                                                    const methodHandle&amp; resolved_method) {
 411 
 412   int vtable_index = Method::invalid_vtable_index;
 413   Symbol* name = resolved_method-&gt;name();
 414   Symbol* signature = resolved_method-&gt;signature();
 415   InstanceKlass* ik = InstanceKlass::cast(klass);
 416 
 417   // First check in default method array
 418   if (!resolved_method-&gt;is_abstract() &amp;&amp; ik-&gt;default_methods() != NULL) {
 419     int index = InstanceKlass::find_method_index(ik-&gt;default_methods(),
 420                                                  name, signature, Klass::find_overpass,
 421                                                  Klass::find_static, Klass::find_private);
 422     if (index &gt;= 0 ) {
 423       vtable_index = ik-&gt;default_vtable_indices()-&gt;at(index);
 424     }
 425   }
 426   if (vtable_index == Method::invalid_vtable_index) {
 427     // get vtable_index for miranda methods
 428     klassVtable vt = ik-&gt;vtable();
 429     vtable_index = vt.index_of_miranda(name, signature);
 430   }
 431   return vtable_index;
 432 }
 433 
 434 Method* LinkResolver::lookup_method_in_interfaces(const LinkInfo&amp; cp_info) {
 435   InstanceKlass *ik = InstanceKlass::cast(cp_info.resolved_klass());
 436 
 437   // Specify &#39;true&#39; in order to skip default methods when searching the
 438   // interfaces.  Function lookup_method_in_klasses() already looked for
 439   // the method in the default methods table.
 440   return ik-&gt;lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
 441 }
 442 
 443 Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,
 444                                                 Handle *appendix_result_or_null,
 445                                                 TRAPS) {
 446   Klass* klass = link_info.resolved_klass();
 447   Symbol* name = link_info.name();
 448   Symbol* full_signature = link_info.signature();
 449 
 450   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
 451   if (TraceMethodHandles) {
 452     ResourceMark rm(THREAD);
 453     tty-&gt;print_cr(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,
 454                   vmIntrinsics::name_at(iid), klass-&gt;external_name(),
 455                   name-&gt;as_C_string(), full_signature-&gt;as_C_string());
 456   }
 457   if ((klass == SystemDictionary::MethodHandle_klass() ||
 458        klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
 459       iid != vmIntrinsics::_none) {
 460     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
 461       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
 462       // Do not erase last argument type (MemberName) if it is a static linkTo method.
 463       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
 464       TempNewSymbol basic_signature =
 465         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
 466       if (TraceMethodHandles) {
 467         ResourceMark rm(THREAD);
 468         tty-&gt;print_cr(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,
 469                       name-&gt;as_C_string(),
 470                       full_signature-&gt;as_C_string(),
 471                       basic_signature-&gt;as_C_string());
 472       }
 473       Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
 474                                                               basic_signature,
 475                                                               CHECK_NULL);
 476       if (result != NULL) {
 477         assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
 478         assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
 479         assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
 480         if (TraceMethodHandles) {
 481           ttyLocker ttyl;
 482           tty-&gt;print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);
 483           result-&gt;print_on(tty);
 484         }
 485       }
 486       return result;
 487     } else if (iid == vmIntrinsics::_invokeGeneric
 488                &amp;&amp; THREAD-&gt;can_call_java()
 489                &amp;&amp; appendix_result_or_null != NULL) {
 490       // This is a method with type-checking semantics.
 491       // We will ask Java code to spin an adapter method for it.
 492       if (!MethodHandles::enabled()) {
 493         // Make sure the Java part of the runtime has been booted up.
 494         Klass* natives = SystemDictionary::MethodHandleNatives_klass();
 495         if (natives == NULL || InstanceKlass::cast(natives)-&gt;is_not_initialized()) {
 496           SystemDictionary::resolve_or_fail(vmSymbols::java_lang_invoke_MethodHandleNatives(),
 497                                             Handle(),
 498                                             Handle(),
 499                                             true,
 500                                             CHECK_NULL);
 501         }
 502       }
 503 
 504       Handle appendix;
 505       Handle method_type;
 506       Method* result = SystemDictionary::find_method_handle_invoker(
 507                                                             klass,
 508                                                             name,
 509                                                             full_signature,
 510                                                             link_info.current_klass(),
 511                                                             &amp;appendix,
 512                                                             CHECK_NULL);
 513       if (TraceMethodHandles) {
 514         ttyLocker ttyl;
 515         tty-&gt;print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);
 516         result-&gt;print_on(tty);
 517         tty-&gt;print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);
 518         if (appendix.is_null())  tty-&gt;print_cr(&quot;(none)&quot;);
 519         else                     appendix-&gt;print_on(tty);
 520       }
 521       if (result != NULL) {
 522 #ifdef ASSERT
 523         ResourceMark rm(THREAD);
 524 
 525         TempNewSymbol basic_signature =
 526           MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
 527         int actual_size_of_params = result-&gt;size_of_parameters();
 528         int expected_size_of_params = ArgumentSizeComputer(basic_signature).size();
 529         // +1 for MethodHandle.this, +1 for trailing MethodType
 530         if (!MethodHandles::is_signature_polymorphic_static(iid))  expected_size_of_params += 1;
 531         if (appendix.not_null())                                   expected_size_of_params += 1;
 532         if (actual_size_of_params != expected_size_of_params) {
 533           tty-&gt;print_cr(&quot;*** basic_signature=%s&quot;, basic_signature-&gt;as_C_string());
 534           tty-&gt;print_cr(&quot;*** result for %s: &quot;, vmIntrinsics::name_at(iid));
 535           result-&gt;print();
 536         }
 537         assert(actual_size_of_params == expected_size_of_params,
 538                &quot;%d != %d&quot;, actual_size_of_params, expected_size_of_params);
 539 #endif //ASSERT
 540 
 541         assert(appendix_result_or_null != NULL, &quot;&quot;);
 542         (*appendix_result_or_null) = appendix;
 543       }
 544       return result;
 545     }
 546   }
 547   return NULL;
 548 }
 549 
 550 void LinkResolver::check_method_accessability(Klass* ref_klass,
 551                                               Klass* resolved_klass,
 552                                               Klass* sel_klass,
 553                                               const methodHandle&amp; sel_method,
 554                                               TRAPS) {
 555 
 556   AccessFlags flags = sel_method-&gt;access_flags();
 557 
 558   // Special case:  arrays always override &quot;clone&quot;. JVMS 2.15.
 559   // If the resolved klass is an array class, and the declaring class
 560   // is java.lang.Object and the method is &quot;clone&quot;, set the flags
 561   // to public.
 562   //
 563   // We&#39;ll check for the method name first, as that&#39;s most likely
 564   // to be false (so we&#39;ll short-circuit out of these tests).
 565   if (sel_method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 566       sel_klass == SystemDictionary::Object_klass() &amp;&amp;
 567       resolved_klass-&gt;is_array_klass()) {
 568     // We need to change &quot;protected&quot; to &quot;public&quot;.
 569     assert(flags.is_protected(), &quot;clone not protected?&quot;);
 570     jint new_flags = flags.as_int();
 571     new_flags = new_flags &amp; (~JVM_ACC_PROTECTED);
 572     new_flags = new_flags | JVM_ACC_PUBLIC;
 573     flags.set_flags(new_flags);
 574   }
 575 //  assert(extra_arg_result_or_null != NULL, &quot;must be able to return extra argument&quot;);
 576 
 577   bool can_access = Reflection::verify_member_access(ref_klass,
 578                                                      resolved_klass,
 579                                                      sel_klass,
 580                                                      flags,
 581                                                      true, false, CHECK);
 582   // Any existing exceptions that may have been thrown, for example LinkageErrors
 583   // from nest-host resolution, have been allowed to propagate.
 584   if (!can_access) {
 585     ResourceMark rm(THREAD);
 586     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 587     Exceptions::fthrow(
 588       THREAD_AND_LOCATION,
 589       vmSymbols::java_lang_IllegalAccessError(),
 590       &quot;class %s tried to access %s%s%smethod &#39;%s&#39; (%s%s%s)&quot;,
 591       ref_klass-&gt;external_name(),
 592       sel_method-&gt;is_abstract()  ? &quot;abstract &quot;  : &quot;&quot;,
 593       sel_method-&gt;is_protected() ? &quot;protected &quot; : &quot;&quot;,
 594       sel_method-&gt;is_private()   ? &quot;private &quot;   : &quot;&quot;,
 595       sel_method-&gt;external_name(),
 596       (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),
 597       (same_module) ? &quot;&quot; : &quot;; &quot;,
 598       (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()
 599     );
 600     return;
 601   }
 602 }
 603 
 604 Method* LinkResolver::resolve_method_statically(Bytecodes::Code code,
 605                                                 const constantPoolHandle&amp; pool, int index, TRAPS) {
 606   // This method is used only
 607   // (1) in C2 from InlineTree::ok_to_inline (via ciMethod::check_call),
 608   // and
 609   // (2) in Bytecode_invoke::static_target
 610   // It appears to fail when applied to an invokeinterface call site.
 611   // FIXME: Remove this method and ciMethod::check_call; refactor to use the other LinkResolver entry points.
 612   // resolve klass
 613   if (code == Bytecodes::_invokedynamic) {
 614     Klass* resolved_klass = SystemDictionary::MethodHandle_klass();
 615     Symbol* method_name = vmSymbols::invoke_name();
 616     Symbol* method_signature = pool-&gt;signature_ref_at(index);
 617     Klass*  current_klass = pool-&gt;pool_holder();
 618     LinkInfo link_info(resolved_klass, method_name, method_signature, current_klass);
 619     return resolve_method(link_info, code, THREAD);
 620   }
 621 
 622   LinkInfo link_info(pool, index, methodHandle(), CHECK_NULL);
 623   Klass* resolved_klass = link_info.resolved_klass();
 624 
 625   if (pool-&gt;has_preresolution()
 626       || (resolved_klass == SystemDictionary::MethodHandle_klass() &amp;&amp;
 627           MethodHandles::is_signature_polymorphic_name(resolved_klass, link_info.name()))) {
 628     Method* result = ConstantPool::method_at_if_loaded(pool, index);
 629     if (result != NULL) {
 630       return result;
 631     }
 632   }
 633 
 634   if (code == Bytecodes::_invokeinterface) {
 635     return resolve_interface_method(link_info, code, THREAD);
 636   } else if (code == Bytecodes::_invokevirtual) {
 637     return resolve_method(link_info, code, THREAD);
 638   } else if (!resolved_klass-&gt;is_interface()) {
 639     return resolve_method(link_info, code, THREAD);
 640   } else {
 641     return resolve_interface_method(link_info, code, THREAD);
 642   }
 643 }
 644 
 645 // Check and print a loader constraint violation message for method or interface method
 646 void LinkResolver::check_method_loader_constraints(const LinkInfo&amp; link_info,
 647                                                    const methodHandle&amp; resolved_method,
 648                                                    const char* method_type, TRAPS) {
 649   Handle current_loader(THREAD, link_info.current_klass()-&gt;class_loader());
 650   Handle resolved_loader(THREAD, resolved_method-&gt;method_holder()-&gt;class_loader());
 651 
 652   ResourceMark rm(THREAD);
 653   Symbol* failed_type_symbol =
 654     SystemDictionary::check_signature_loaders(link_info.signature(), current_loader,
 655                                               resolved_loader, true, CHECK);
 656   if (failed_type_symbol != NULL) {
 657     Klass* current_class = link_info.current_klass();
 658     ClassLoaderData* current_loader_data = current_class-&gt;class_loader_data();
 659     assert(current_loader_data != NULL, &quot;current class has no class loader data&quot;);
 660     Klass* resolved_method_class = resolved_method-&gt;method_holder();
 661     ClassLoaderData* target_loader_data = resolved_method_class-&gt;class_loader_data();
 662     assert(target_loader_data != NULL, &quot;resolved method&#39;s class has no class loader data&quot;);
 663 
 664     stringStream ss;
 665     ss.print(&quot;loader constraint violation: when resolving %s &#39;&quot;, method_type);
 666     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());
 667     ss.print(&quot;&#39; the class loader %s of the current class, %s,&quot;
 668              &quot; and the class loader %s for the method&#39;s defining class, %s, have&quot;
 669              &quot; different Class objects for the type %s used in the signature (%s; %s)&quot;,
 670              current_loader_data-&gt;loader_name_and_id(),
 671              current_class-&gt;name()-&gt;as_C_string(),
 672              target_loader_data-&gt;loader_name_and_id(),
 673              resolved_method_class-&gt;name()-&gt;as_C_string(),
 674              failed_type_symbol-&gt;as_C_string(),
 675              current_class-&gt;class_in_module_of_loader(false, true),
 676              resolved_method_class-&gt;class_in_module_of_loader(false, true));
 677     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
 678   }
 679 }
 680 
 681 void LinkResolver::check_field_loader_constraints(Symbol* field, Symbol* sig,
 682                                                   Klass* current_klass,
 683                                                   Klass* sel_klass, TRAPS) {
 684   Handle ref_loader(THREAD, current_klass-&gt;class_loader());
 685   Handle sel_loader(THREAD, sel_klass-&gt;class_loader());
 686 
 687   ResourceMark rm(THREAD);  // needed for check_signature_loaders
 688   Symbol* failed_type_symbol =
 689     SystemDictionary::check_signature_loaders(sig,
 690                                               ref_loader, sel_loader,
 691                                               false,
 692                                               CHECK);
 693   if (failed_type_symbol != NULL) {
 694     stringStream ss;
 695     const char* failed_type_name = failed_type_symbol-&gt;as_klass_external_name();
 696 
 697     ss.print(&quot;loader constraint violation: when resolving field \&quot;%s\&quot; of type %s, &quot;
 698              &quot;the class loader %s of the current class, %s, &quot;
 699              &quot;and the class loader %s for the field&#39;s defining %s, %s, &quot;
 700              &quot;have different Class objects for type %s (%s; %s)&quot;,
 701              field-&gt;as_C_string(),
 702              failed_type_name,
 703              current_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 704              current_klass-&gt;external_name(),
 705              sel_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 706              sel_klass-&gt;external_kind(),
 707              sel_klass-&gt;external_name(),
 708              failed_type_name,
 709              current_klass-&gt;class_in_module_of_loader(false, true),
 710              sel_klass-&gt;class_in_module_of_loader(false, true));
 711     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
 712   }
 713 }
 714 
 715 Method* LinkResolver::resolve_method(const LinkInfo&amp; link_info,
 716                                      Bytecodes::Code code, TRAPS) {
 717 
 718   Handle nested_exception;
 719   Klass* resolved_klass = link_info.resolved_klass();
 720 
 721   // 1. For invokevirtual, cannot call an interface method
 722   if (code == Bytecodes::_invokevirtual &amp;&amp; resolved_klass-&gt;is_interface()) {
 723     ResourceMark rm(THREAD);
 724     char buf[200];
 725     jio_snprintf(buf, sizeof(buf), &quot;Found interface %s, but class was expected&quot;,
 726         resolved_klass-&gt;external_name());
 727     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 728   }
 729 
 730   // 2. check constant pool tag for called method - must be JVM_CONSTANT_Methodref
 731   if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_method()) {
 732     ResourceMark rm(THREAD);
 733     stringStream ss;
 734     ss.print(&quot;Method &#39;&quot;);
 735     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());
 736     ss.print(&quot;&#39; must be Methodref constant&quot;);
 737     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
 738   }
 739 
 740   // 3. lookup method in resolved klass and its super klasses
 741   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, true, false));
 742 
 743   // 4. lookup method in all the interfaces implemented by the resolved klass
 744   if (resolved_method.is_null() &amp;&amp; !resolved_klass-&gt;is_array_klass()) { // not found in the class hierarchy
 745     resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
 746 
 747     if (resolved_method.is_null()) {
 748       // JSR 292:  see if this is an implicitly generated method MethodHandle.linkToVirtual(*...), etc
 749       Method* method = lookup_polymorphic_method(link_info, (Handle*)NULL, THREAD);
 750       resolved_method = methodHandle(THREAD, method);
 751       if (HAS_PENDING_EXCEPTION) {
 752         nested_exception = Handle(THREAD, PENDING_EXCEPTION);
 753         CLEAR_PENDING_EXCEPTION;
 754       }
 755     }
 756   }
 757 
 758   // 5. method lookup failed
 759   if (resolved_method.is_null()) {
 760     ResourceMark rm(THREAD);
 761     stringStream ss;
 762     ss.print(&quot;&#39;&quot;);
 763     Method::print_external_name(&amp;ss, resolved_klass, link_info.name(), link_info.signature());
 764     ss.print(&quot;&#39;&quot;);
 765     THROW_MSG_CAUSE_(vmSymbols::java_lang_NoSuchMethodError(),
 766                      ss.as_string(), nested_exception, NULL);
 767   }
 768 
 769   // 6. access checks, access checking may be turned off when calling from within the VM.
 770   Klass* current_klass = link_info.current_klass();
 771   if (link_info.check_access()) {
 772     assert(current_klass != NULL , &quot;current_klass should not be null&quot;);
 773 
 774     // check if method can be accessed by the referring class
 775     check_method_accessability(current_klass,
 776                                resolved_klass,
 777                                resolved_method-&gt;method_holder(),
 778                                resolved_method,
 779                                CHECK_NULL);
 780 
 781     // check loader constraints
 782     check_method_loader_constraints(link_info, resolved_method, &quot;method&quot;, CHECK_NULL);
 783   }
 784 
 785   return resolved_method();
 786 }
 787 
 788 static void trace_method_resolution(const char* prefix,
 789                                     Klass* klass,
 790                                     Klass* resolved_klass,
 791                                     Method* method,
 792                                     bool logitables,
 793                                     int index = -1) {
 794 #ifndef PRODUCT
 795   ResourceMark rm;
 796   Log(itables) logi;
 797   LogStream lsi(logi.trace());
 798   Log(vtables) logv;
 799   LogStream lsv(logv.trace());
 800   outputStream* st;
 801   if (logitables) {
 802     st = &amp;lsi;
 803   } else {
 804     st = &amp;lsv;
 805   }
 806   st-&gt;print(&quot;%s%s, compile-time-class:%s, method:%s, method_holder:%s, access_flags: &quot;,
 807             prefix,
 808             (klass == NULL ? &quot;&lt;NULL&gt;&quot; : klass-&gt;internal_name()),
 809             (resolved_klass == NULL ? &quot;&lt;NULL&gt;&quot; : resolved_klass-&gt;internal_name()),
 810             Method::name_and_sig_as_C_string(resolved_klass,
 811                                              method-&gt;name(),
 812                                              method-&gt;signature()),
 813             method-&gt;method_holder()-&gt;internal_name());
 814   method-&gt;print_linkage_flags(st);
 815   if (index != -1) {
 816     st-&gt;print(&quot;vtable_index:%d&quot;, index);
 817   }
 818   st-&gt;cr();
 819 #endif // PRODUCT
 820 }
 821 
 822 // Do linktime resolution of a method in the interface within the context of the specied bytecode.
 823 Method* LinkResolver::resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS) {
 824 
 825   Klass* resolved_klass = link_info.resolved_klass();
 826 
 827   // check if klass is interface
 828   if (!resolved_klass-&gt;is_interface()) {
 829     ResourceMark rm(THREAD);
 830     char buf[200];
 831     jio_snprintf(buf, sizeof(buf), &quot;Found class %s, but interface was expected&quot;, resolved_klass-&gt;external_name());
 832     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 833   }
 834 
 835   // check constant pool tag for called method - must be JVM_CONSTANT_InterfaceMethodref
 836   if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_interface_method()) {
 837     ResourceMark rm(THREAD);
 838     stringStream ss;
 839     ss.print(&quot;Method &#39;&quot;);
 840     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());
 841     ss.print(&quot;&#39; must be InterfaceMethodref constant&quot;);
 842     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
 843   }
 844 
 845   // lookup method in this interface or its super, java.lang.Object
 846   // JDK8: also look for static methods
 847   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, false, true));
 848 
 849   if (resolved_method.is_null() &amp;&amp; !resolved_klass-&gt;is_array_klass()) {
 850     // lookup method in all the super-interfaces
 851     resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
 852   }
 853 
 854   if (resolved_method.is_null()) {
 855     // no method found
 856     ResourceMark rm(THREAD);
 857     stringStream ss;
 858     ss.print(&quot;&#39;&quot;);
 859     Method::print_external_name(&amp;ss, resolved_klass, link_info.name(), link_info.signature());
 860     ss.print(&quot;&#39;&quot;);
 861     THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());
 862   }
 863 
 864   if (link_info.check_access()) {
 865     // JDK8 adds non-public interface methods, and accessability check requirement
 866     Klass* current_klass = link_info.current_klass();
 867 
 868     assert(current_klass != NULL , &quot;current_klass should not be null&quot;);
 869 
 870     // check if method can be accessed by the referring class
 871     check_method_accessability(current_klass,
 872                                resolved_klass,
 873                                resolved_method-&gt;method_holder(),
 874                                resolved_method,
 875                                CHECK_NULL);
 876 
 877     check_method_loader_constraints(link_info, resolved_method, &quot;interface method&quot;, CHECK_NULL);
 878   }
 879 
 880   if (code != Bytecodes::_invokestatic &amp;&amp; resolved_method-&gt;is_static()) {
 881     ResourceMark rm(THREAD);
 882     stringStream ss;
 883     ss.print(&quot;Expected instance not static method &#39;&quot;);
 884     Method::print_external_name(&amp;ss, resolved_klass,
 885                                 resolved_method-&gt;name(), resolved_method-&gt;signature());
 886     ss.print(&quot;&#39;&quot;);
 887     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
 888   }
 889 
 890   if (log_develop_is_enabled(Trace, itables)) {
 891     char buf[200];
 892     jio_snprintf(buf, sizeof(buf), &quot;%s resolved interface method: caller-class:&quot;,
 893                  Bytecodes::name(code));
 894     trace_method_resolution(buf, link_info.current_klass(), resolved_klass, resolved_method(), true);
 895   }
 896 
 897   return resolved_method();
 898 }
 899 
 900 //------------------------------------------------------------------------------------------------------------------------
 901 // Field resolution
 902 
 903 void LinkResolver::check_field_accessability(Klass* ref_klass,
 904                                              Klass* resolved_klass,
 905                                              Klass* sel_klass,
 906                                              const fieldDescriptor&amp; fd,
 907                                              TRAPS) {
 908   bool can_access = Reflection::verify_member_access(ref_klass,
 909                                                      resolved_klass,
 910                                                      sel_klass,
 911                                                      fd.access_flags(),
 912                                                      true, false, CHECK);
 913   // Any existing exceptions that may have been thrown, for example LinkageErrors
 914   // from nest-host resolution, have been allowed to propagate.
 915   if (!can_access) {
 916     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 917     ResourceMark rm(THREAD);
 918     Exceptions::fthrow(
 919       THREAD_AND_LOCATION,
 920       vmSymbols::java_lang_IllegalAccessError(),
 921       &quot;class %s tried to access %s%sfield %s.%s (%s%s%s)&quot;,
 922       ref_klass-&gt;external_name(),
 923       fd.is_protected() ? &quot;protected &quot; : &quot;&quot;,
 924       fd.is_private()   ? &quot;private &quot;   : &quot;&quot;,
 925       sel_klass-&gt;external_name(),
 926       fd.name()-&gt;as_C_string(),
 927       (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),
 928       (same_module) ? &quot;&quot; : &quot;; &quot;,
 929       (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()
 930     );
 931     return;
 932   }
 933 }
 934 
 935 void LinkResolver::resolve_field_access(fieldDescriptor&amp; fd, const constantPoolHandle&amp; pool, int index, const methodHandle&amp; method, Bytecodes::Code byte, TRAPS) {
 936   LinkInfo link_info(pool, index, method, CHECK);
 937   resolve_field(fd, link_info, byte, true, CHECK);
 938 }
 939 
 940 void LinkResolver::resolve_field(fieldDescriptor&amp; fd,
 941                                  const LinkInfo&amp; link_info,
 942                                  Bytecodes::Code byte, bool initialize_class,
 943                                  TRAPS) {
 944   assert(byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic ||
 945          byte == Bytecodes::_getfield  || byte == Bytecodes::_putfield  ||
 946          byte == Bytecodes::_withfield ||
 947          byte == Bytecodes::_nofast_getfield  || byte == Bytecodes::_nofast_putfield  ||
 948          (byte == Bytecodes::_nop &amp;&amp; !link_info.check_access()), &quot;bad field access bytecode&quot;);
 949 
 950   bool is_static = (byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic);
 951   bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic ||
 952                     byte == Bytecodes::_nofast_putfield || byte == Bytecodes::_withfield);
 953   // Check if there&#39;s a resolved klass containing the field
 954   Klass* resolved_klass = link_info.resolved_klass();
 955   Symbol* field = link_info.name();
 956   Symbol* sig = link_info.signature();
 957 
 958   if (resolved_klass == NULL) {
 959     ResourceMark rm(THREAD);
 960     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 961   }
 962 
 963   // Resolve instance field
 964   Klass* sel_klass = resolved_klass-&gt;find_field(field, sig, &amp;fd);
 965   // check if field exists; i.e., if a klass containing the field def has been selected
 966   if (sel_klass == NULL) {
 967     ResourceMark rm(THREAD);
 968     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 969   }
 970 
 971   // Access checking may be turned off when calling from within the VM.
 972   Klass* current_klass = link_info.current_klass();
 973   if (link_info.check_access()) {
 974 
 975     // check access
 976     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 977 
 978     // check for errors
 979     if (is_static != fd.is_static()) {
 980       ResourceMark rm(THREAD);
 981       char msg[200];
 982       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
 983       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
 984     }
 985 
 986     // A final field can be modified only
 987     // (1) by methods declared in the class declaring the field and
 988     // (2) by the &lt;clinit&gt; method (in case of a static field)
 989     //     or by the &lt;init&gt; method (in case of an instance field).
 990     // (3) by withfield when field is in a value type and the
 991     //     selected class and current class are nest mates.
 992     if (is_put &amp;&amp; fd.access_flags().is_final()) {
<a name="14" id="anc14"></a><span class="line-removed"> 993       ResourceMark rm(THREAD);</span>
<span class="line-removed"> 994       stringStream ss;</span>
 995 
 996       if (sel_klass != current_klass) {
 997       // If byte code is a withfield check if they are nestmates.
 998       bool are_nestmates = false;
 999       if (sel_klass-&gt;is_instance_klass() &amp;&amp;
1000           InstanceKlass::cast(sel_klass)-&gt;is_value() &amp;&amp;
1001           current_klass-&gt;is_instance_klass()) {
1002         are_nestmates = InstanceKlass::cast(link_info.current_klass())-&gt;has_nestmate_access_to(
1003                                                         InstanceKlass::cast(sel_klass), THREAD);
1004       }
1005       if (!are_nestmates) {
<a name="15" id="anc15"></a>

1006         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
1007                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1008                   current_klass-&gt;external_name());
1009         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1010       }
1011       }
1012 
1013       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
1014         Method* m = link_info.current_method();
1015         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
1016         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1017                                                    fd.is_static() &amp;&amp;
1018                                                    !m-&gt;is_class_initializer());
1019         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1020                                                      !fd.is_static() &amp;&amp;
1021                                                      !m-&gt;is_object_constructor());
1022 
1023         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
<a name="16" id="anc16"></a>

1024           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1025                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1026                    m-&gt;name()-&gt;as_C_string(),
1027                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1028           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1029         }
1030       }
1031     }
1032 
1033     // initialize resolved_klass if necessary
1034     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1035     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1036     //
1037     // note 2: we don&#39;t want to force initialization if we are just checking
1038     //         if the field access is legal; e.g., during compilation
1039     if (is_static &amp;&amp; initialize_class) {
1040       sel_klass-&gt;initialize(CHECK);
1041     }
1042   }
1043 
1044   if ((sel_klass != current_klass) &amp;&amp; (current_klass != NULL)) {
1045     check_field_loader_constraints(field, sig, current_klass, sel_klass, CHECK);
1046   }
1047 
1048   // return information. note that the klass is set to the actual klass containing the
1049   // field, otherwise access of static fields in superclasses will not work.
1050 }
1051 
1052 
1053 //------------------------------------------------------------------------------------------------------------------------
1054 // Invoke resolution
1055 //
1056 // Naming conventions:
1057 //
1058 // resolved_method    the specified method (i.e., static receiver specified via constant pool index)
1059 // sel_method         the selected method  (selected via run-time lookup; e.g., based on dynamic receiver class)
1060 // resolved_klass     the specified klass  (i.e., specified via constant pool index)
1061 // recv_klass         the receiver klass
1062 
1063 
1064 void LinkResolver::resolve_static_call(CallInfo&amp; result,
1065                                        const LinkInfo&amp; link_info,
1066                                        bool initialize_class, TRAPS) {
1067   Method* resolved_method = linktime_resolve_static_method(link_info, CHECK);
1068 
1069   // The resolved class can change as a result of this resolution.
1070   Klass* resolved_klass = resolved_method-&gt;method_holder();
1071 
1072   // Initialize klass (this should only happen if everything is ok)
1073   if (initialize_class &amp;&amp; resolved_klass-&gt;should_be_initialized()) {
1074     resolved_klass-&gt;initialize(CHECK);
1075     // Use updated LinkInfo to reresolve with resolved method holder
1076     LinkInfo new_info(resolved_klass, link_info.name(), link_info.signature(),
1077                       link_info.current_klass(),
1078                       link_info.check_access() ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
1079     resolved_method = linktime_resolve_static_method(new_info, CHECK);
1080   }
1081 
1082   // setup result
1083   result.set_static(resolved_klass, methodHandle(THREAD, resolved_method), CHECK);
1084 }
1085 
1086 // throws linktime exceptions
1087 Method* LinkResolver::linktime_resolve_static_method(const LinkInfo&amp; link_info, TRAPS) {
1088 
1089   Klass* resolved_klass = link_info.resolved_klass();
1090   Method* resolved_method;
1091   if (!resolved_klass-&gt;is_interface()) {
1092     resolved_method = resolve_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
1093   } else {
1094     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
1095   }
1096   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name(), &quot;should have been checked in verifier&quot;);
1097 
1098   // check if static
1099   if (!resolved_method-&gt;is_static()) {
1100     ResourceMark rm(THREAD);
1101     stringStream ss;
1102     ss.print(&quot;Expected static method &#39;&quot;);
1103     resolved_method-&gt;print_external_name(&amp;ss);
1104     ss.print(&quot;&#39;&quot;);
1105     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1106   }
1107   return resolved_method;
1108 }
1109 
1110 
1111 void LinkResolver::resolve_special_call(CallInfo&amp; result,
1112                                         Handle recv,
1113                                         const LinkInfo&amp; link_info,
1114                                         TRAPS) {
1115   Method* resolved_method = linktime_resolve_special_method(link_info, CHECK);
1116   runtime_resolve_special_method(result, link_info, methodHandle(THREAD, resolved_method), recv, CHECK);
1117 }
1118 
1119 // throws linktime exceptions
1120 Method* LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info, TRAPS) {
1121 
1122   // Invokespecial is called for multiple special reasons:
1123   // &lt;init&gt;
1124   // local private method invocation, for classes and interfaces
1125   // superclass.method, which can also resolve to a default method
1126   // and the selected method is recalculated relative to the direct superclass
1127   // superinterface.method, which explicitly does not check shadowing
1128   Klass* resolved_klass = link_info.resolved_klass();
1129   Method* resolved_method;
1130 
1131   if (!resolved_klass-&gt;is_interface()) {
1132     resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1133   } else {
1134     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1135   }
1136 
1137   // check if method name is &lt;init&gt;, that it is found in same klass as static type
1138   // Since this method is never inherited from a super, any appearance here under
1139   // the wrong class would be an error.
1140   if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
1141       resolved_method-&gt;method_holder() != resolved_klass) {
1142     ResourceMark rm(THREAD);
1143     stringStream ss;
1144     ss.print(&quot;%s: method &#39;&quot;, resolved_klass-&gt;external_name());
1145     resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);
1146     ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());
1147     resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);
1148     ss.print(&quot;)&#39; not found&quot;);
1149     Exceptions::fthrow(
1150       THREAD_AND_LOCATION,
1151       vmSymbols::java_lang_NoSuchMethodError(),
1152       &quot;%s&quot;, ss.as_string());
1153     return NULL;
1154   }
1155 
1156   // ensure that invokespecial&#39;s interface method reference is in
1157   // a direct superinterface, not an indirect superinterface
1158   Klass* current_klass = link_info.current_klass();
1159   if (current_klass != NULL &amp;&amp; resolved_klass-&gt;is_interface()) {
1160     InstanceKlass* ck = InstanceKlass::cast(current_klass);
1161     InstanceKlass *klass_to_check = !ck-&gt;is_unsafe_anonymous() ?
1162                                     ck :
1163                                     ck-&gt;unsafe_anonymous_host();
1164     // Disable verification for the dynamically-generated reflection bytecodes.
1165     bool is_reflect = klass_to_check-&gt;is_subclass_of(
1166                         SystemDictionary::reflect_MagicAccessorImpl_klass());
1167 
1168     if (!is_reflect &amp;&amp;
1169         !klass_to_check-&gt;is_same_or_direct_interface(resolved_klass)) {
1170       ResourceMark rm(THREAD);
1171       stringStream ss;
1172       ss.print(&quot;Interface method reference: &#39;&quot;);
1173       resolved_method-&gt;print_external_name(&amp;ss);
1174       ss.print(&quot;&#39;, is in an indirect superinterface of %s&quot;,
1175                current_klass-&gt;external_name());
1176       THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1177     }
1178   }
1179 
1180   // check if not static
1181   if (resolved_method-&gt;is_static()) {
1182     ResourceMark rm(THREAD);
1183     stringStream ss;
1184     ss.print(&quot;Expecting non-static method &#39;&quot;);
1185     resolved_method-&gt;print_external_name(&amp;ss);
1186     ss.print(&quot;&#39;&quot;);
1187     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1188   }
1189 
1190   if (log_develop_is_enabled(Trace, itables)) {
1191     trace_method_resolution(&quot;invokespecial resolved method: caller-class:&quot;,
1192                             current_klass, resolved_klass, resolved_method, true);
1193   }
1194 
1195   return resolved_method;
1196 }
1197 
1198 // throws runtime exceptions
1199 void LinkResolver::runtime_resolve_special_method(CallInfo&amp; result,
1200                                                   const LinkInfo&amp; link_info,
1201                                                   const methodHandle&amp; resolved_method,
1202                                                   Handle recv, TRAPS) {
1203 
1204   Klass* resolved_klass = link_info.resolved_klass();
1205 
1206   // resolved method is selected method unless we have an old-style lookup
1207   // for a superclass method
1208   // Invokespecial for a superinterface, resolved method is selected method,
1209   // no checks for shadowing
1210   methodHandle sel_method(THREAD, resolved_method());
1211 
1212   if (link_info.check_access() &amp;&amp;
1213       // check if the method is not &lt;init&gt;, which is never inherited
1214       resolved_method-&gt;name() != vmSymbols::object_initializer_name()) {
1215 
1216     Klass* current_klass = link_info.current_klass();
1217 
1218     // Check if the class of the resolved_klass is a superclass
1219     // (not supertype in order to exclude interface classes) of the current class.
1220     // This check is not performed for super.invoke for interface methods
1221     // in super interfaces.
1222     if (current_klass-&gt;is_subclass_of(resolved_klass) &amp;&amp;
1223         current_klass != resolved_klass) {
1224       // Lookup super method
1225       Klass* super_klass = current_klass-&gt;super();
1226       Method* instance_method = lookup_instance_method_in_klasses(super_klass,
1227                                                      resolved_method-&gt;name(),
1228                                                      resolved_method-&gt;signature(),
1229                                                      Klass::find_private, CHECK);
1230       sel_method = methodHandle(THREAD, instance_method);
1231 
1232       // check if found
1233       if (sel_method.is_null()) {
1234         ResourceMark rm(THREAD);
1235         stringStream ss;
1236         ss.print(&quot;&#39;&quot;);
1237         resolved_method-&gt;print_external_name(&amp;ss);
1238         ss.print(&quot;&#39;&quot;);
1239         THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1240       // check loader constraints if found a different method
1241       } else if (sel_method() != resolved_method()) {
1242         check_method_loader_constraints(link_info, sel_method, &quot;method&quot;, CHECK);
1243       }
1244     }
1245 
1246     // Check that the class of objectref (the receiver) is the current class or interface,
1247     // or a subtype of the current class or interface (the sender), otherwise invokespecial
1248     // throws IllegalAccessError.
1249     // The verifier checks that the sender is a subtype of the class in the I/MR operand.
1250     // The verifier also checks that the receiver is a subtype of the sender, if the sender is
1251     // a class.  If the sender is an interface, the check has to be performed at runtime.
1252     InstanceKlass* sender = InstanceKlass::cast(current_klass);
1253     sender = sender-&gt;is_unsafe_anonymous() ? sender-&gt;unsafe_anonymous_host() : sender;
1254     if (sender-&gt;is_interface() &amp;&amp; recv.not_null()) {
1255       Klass* receiver_klass = recv-&gt;klass();
1256       if (!receiver_klass-&gt;is_subtype_of(sender)) {
1257         ResourceMark rm(THREAD);
1258         char buf[500];
1259         jio_snprintf(buf, sizeof(buf),
1260                      &quot;Receiver class %s must be the current class or a subtype of interface %s&quot;,
1261                      receiver_klass-&gt;external_name(),
1262                      sender-&gt;external_name());
1263         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), buf);
1264       }
1265     }
1266   }
1267 
1268   // check if not static
1269   if (sel_method-&gt;is_static()) {
1270     ResourceMark rm(THREAD);
1271     stringStream ss;
1272     ss.print(&quot;Expecting non-static method &#39;&quot;);
1273     resolved_method-&gt;print_external_name(&amp;ss);
1274     ss.print(&quot;&#39;&quot;);
1275     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1276   }
1277 
1278   // check if abstract
1279   if (sel_method-&gt;is_abstract()) {
1280     ResourceMark rm(THREAD);
1281     stringStream ss;
1282     ss.print(&quot;&#39;&quot;);
1283     Method::print_external_name(&amp;ss, resolved_klass, sel_method-&gt;name(), sel_method-&gt;signature());
1284     ss.print(&quot;&#39;&quot;);
1285     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1286   }
1287 
1288   if (log_develop_is_enabled(Trace, itables)) {
1289     trace_method_resolution(&quot;invokespecial selected method: resolved-class:&quot;,
1290                             resolved_klass, resolved_klass, sel_method(), true);
1291   }
1292 
1293   // setup result
1294   result.set_static(resolved_klass, sel_method, CHECK);
1295 }
1296 
1297 void LinkResolver::resolve_virtual_call(CallInfo&amp; result, Handle recv, Klass* receiver_klass,
1298                                         const LinkInfo&amp; link_info,
1299                                         bool check_null_and_abstract, TRAPS) {
1300   Method* resolved_method = linktime_resolve_virtual_method(link_info, CHECK);
1301   runtime_resolve_virtual_method(result, methodHandle(THREAD, resolved_method),
1302                                  link_info.resolved_klass(),
1303                                  recv, receiver_klass,
1304                                  check_null_and_abstract, CHECK);
1305 }
1306 
1307 // throws linktime exceptions
1308 Method* LinkResolver::linktime_resolve_virtual_method(const LinkInfo&amp; link_info,
1309                                                            TRAPS) {
1310   // normal method resolution
1311   Method* resolved_method = resolve_method(link_info, Bytecodes::_invokevirtual, CHECK_NULL);
1312 
1313   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1314   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1315 
1316   // check if private interface method
1317   Klass* resolved_klass = link_info.resolved_klass();
1318   Klass* current_klass = link_info.current_klass();
1319 
1320   // This is impossible, if resolve_klass is an interface, we&#39;ve thrown icce in resolve_method
1321   if (resolved_klass-&gt;is_interface() &amp;&amp; resolved_method-&gt;is_private()) {
1322     ResourceMark rm(THREAD);
1323     stringStream ss;
1324     ss.print(&quot;private interface method requires invokespecial, not invokevirtual: method &#39;&quot;);
1325     resolved_method-&gt;print_external_name(&amp;ss);
1326     ss.print(&quot;&#39;, caller-class: %s&quot;,
1327              (current_klass == NULL ? &quot;&lt;null&gt;&quot; : current_klass-&gt;internal_name()));
1328     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1329   }
1330 
1331   // check if not static
1332   if (resolved_method-&gt;is_static()) {
1333     ResourceMark rm(THREAD);
1334     stringStream ss;
1335     ss.print(&quot;Expecting non-static method &#39;&quot;);
1336     resolved_method-&gt;print_external_name(&amp;ss);
1337     ss.print(&quot;&#39;&quot;);
1338     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1339   }
1340 
1341   if (log_develop_is_enabled(Trace, vtables)) {
1342     trace_method_resolution(&quot;invokevirtual resolved method: caller-class:&quot;,
1343                             current_klass, resolved_klass, resolved_method, false);
1344   }
1345 
1346   return resolved_method;
1347 }
1348 
1349 // throws runtime exceptions
1350 void LinkResolver::runtime_resolve_virtual_method(CallInfo&amp; result,
1351                                                   const methodHandle&amp; resolved_method,
1352                                                   Klass* resolved_klass,
1353                                                   Handle recv,
1354                                                   Klass* recv_klass,
1355                                                   bool check_null_and_abstract,
1356                                                   TRAPS) {
1357 
1358   // setup default return values
1359   int vtable_index = Method::invalid_vtable_index;
1360   methodHandle selected_method;
1361 
1362   // runtime method resolution
1363   if (check_null_and_abstract &amp;&amp; recv.is_null()) { // check if receiver exists
1364     THROW(vmSymbols::java_lang_NullPointerException());
1365   }
1366 
1367   // Virtual methods cannot be resolved before its klass has been linked, for otherwise the Method*&#39;s
1368   // has not been rewritten, and the vtable initialized. Make sure to do this after the nullcheck, since
1369   // a missing receiver might result in a bogus lookup.
1370   assert(resolved_method-&gt;method_holder()-&gt;is_linked(), &quot;must be linked&quot;);
1371 
1372   // do lookup based on receiver klass using the vtable index
1373   if (resolved_method-&gt;method_holder()-&gt;is_interface()) { // default or miranda method
1374     vtable_index = vtable_index_of_interface_method(resolved_klass, resolved_method);
1375     assert(vtable_index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
1376 
1377     selected_method = methodHandle(THREAD, recv_klass-&gt;method_at_vtable(vtable_index));
1378   } else {
1379     // at this point we are sure that resolved_method is virtual and not
1380     // a default or miranda method; therefore, it must have a valid vtable index.
1381     assert(!resolved_method-&gt;has_itable_index(), &quot;&quot;);
1382     vtable_index = resolved_method-&gt;vtable_index();
1383     // We could get a negative vtable_index of nonvirtual_vtable_index for private
1384     // methods, or for final methods. Private methods never appear in the vtable
1385     // and never override other methods. As an optimization, final methods are
1386     // never put in the vtable, unless they override an existing method.
1387     // So if we do get nonvirtual_vtable_index, it means the selected method is the
1388     // resolved method, and it can never be changed by an override.
1389     if (vtable_index == Method::nonvirtual_vtable_index) {
1390       assert(resolved_method-&gt;can_be_statically_bound(), &quot;cannot override this method&quot;);
1391       selected_method = resolved_method;
1392     } else {
1393       selected_method = methodHandle(THREAD, recv_klass-&gt;method_at_vtable(vtable_index));
1394     }
1395   }
1396 
1397   // check if method exists
1398   if (selected_method.is_null()) {
1399     throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1400   }
1401 
1402   // check if abstract
1403   if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1404     // Pass arguments for generating a verbose error message.
1405     throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1406   }
1407 
1408   if (log_develop_is_enabled(Trace, vtables)) {
1409     trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
1410                             recv_klass, resolved_klass, selected_method(),
1411                             false, vtable_index);
1412   }
1413   // setup result
<a name="17" id="anc17"></a><span class="line-modified">1414   result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1415 }
1416 
1417 void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
1418                                           const LinkInfo&amp; link_info,
1419                                           bool check_null_and_abstract, TRAPS) {
1420   // throws linktime exceptions
1421   Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);
1422   methodHandle mh(THREAD, resolved_method);
1423   runtime_resolve_interface_method(result, mh, link_info.resolved_klass(),
1424                                    recv, recv_klass, check_null_and_abstract, CHECK);
1425 }
1426 
1427 Method* LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,
1428                                                              TRAPS) {
1429   // normal interface method resolution
1430   Method* resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);
1431   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1432   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1433 
1434   return resolved_method;
1435 }
1436 
1437 // throws runtime exceptions
1438 void LinkResolver::runtime_resolve_interface_method(CallInfo&amp; result,
1439                                                     const methodHandle&amp; resolved_method,
1440                                                     Klass* resolved_klass,
1441                                                     Handle recv,
1442                                                     Klass* recv_klass,
1443                                                     bool check_null_and_abstract, TRAPS) {
1444 
1445   // check if receiver exists
1446   if (check_null_and_abstract &amp;&amp; recv.is_null()) {
1447     THROW(vmSymbols::java_lang_NullPointerException());
1448   }
1449 
1450   // check if receiver klass implements the resolved interface
1451   if (!recv_klass-&gt;is_subtype_of(resolved_klass)) {
1452     ResourceMark rm(THREAD);
1453     char buf[200];
1454     jio_snprintf(buf, sizeof(buf), &quot;Class %s does not implement the requested interface %s&quot;,
1455                  recv_klass-&gt;external_name(),
1456                  resolved_klass-&gt;external_name());
1457     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
1458   }
1459 
1460   methodHandle selected_method = resolved_method;
1461 
1462   // resolve the method in the receiver class, unless it is private
1463   if (!resolved_method()-&gt;is_private()) {
1464     // do lookup based on receiver klass
1465     // This search must match the linktime preparation search for itable initialization
1466     // to correctly enforce loader constraints for interface method inheritance.
1467     // Private methods are skipped as the resolved method was not private.
1468     Method* method = lookup_instance_method_in_klasses(recv_klass,
1469                                                        resolved_method-&gt;name(),
1470                                                        resolved_method-&gt;signature(),
1471                                                        Klass::skip_private, CHECK);
1472     selected_method = methodHandle(THREAD, method);
1473 
1474     if (selected_method.is_null() &amp;&amp; !check_null_and_abstract) {
1475       // In theory this is a harmless placeholder value, but
1476       // in practice leaving in null affects the nsk default method tests.
1477       // This needs further study.
1478       selected_method = resolved_method;
1479     }
1480     // check if method exists
1481     if (selected_method.is_null()) {
1482       // Pass arguments for generating a verbose error message.
1483       throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1484     }
1485     // check access
1486     // Throw Illegal Access Error if selected_method is not public.
1487     if (!selected_method-&gt;is_public()) {
1488       ResourceMark rm(THREAD);
1489       stringStream ss;
1490       ss.print(&quot;&#39;&quot;);
1491       Method::print_external_name(&amp;ss, recv_klass, selected_method-&gt;name(), selected_method-&gt;signature());
1492       ss.print(&quot;&#39;&quot;);
1493       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1494     }
1495     // check if abstract
1496     if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1497       throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1498     }
1499   }
1500 
1501   if (log_develop_is_enabled(Trace, itables)) {
1502     trace_method_resolution(&quot;invokeinterface selected method: receiver-class:&quot;,
1503                             recv_klass, resolved_klass, selected_method(), true);
1504   }
1505   // setup result
1506   if (resolved_method-&gt;has_vtable_index()) {
1507     int vtable_index = resolved_method-&gt;vtable_index();
1508     log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
1509     assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
<a name="18" id="anc18"></a><span class="line-modified">1510     result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1511   } else if (resolved_method-&gt;has_itable_index()) {
1512     int itable_index = resolved_method()-&gt;itable_index();
1513     log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
<a name="19" id="anc19"></a><span class="line-modified">1514     result.set_interface(resolved_klass, recv_klass, resolved_method, selected_method, itable_index, CHECK);</span>
1515   } else {
1516     int index = resolved_method-&gt;vtable_index();
1517     log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
1518     assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
1519     assert(resolved_method()-&gt;is_private() ||
1520            (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
1521            &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
1522     assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
1523     // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
<a name="20" id="anc20"></a><span class="line-modified">1524     result.set_virtual(resolved_klass, resolved_klass, resolved_method, resolved_method, index, CHECK);</span>
1525   }
1526 }
1527 
1528 
1529 Method* LinkResolver::linktime_resolve_interface_method_or_null(
1530                                                  const LinkInfo&amp; link_info) {
1531   EXCEPTION_MARK;
1532   Method* method_result = linktime_resolve_interface_method(link_info, THREAD);
1533   if (HAS_PENDING_EXCEPTION) {
1534     CLEAR_PENDING_EXCEPTION;
1535     return NULL;
1536   } else {
1537     return method_result;
1538   }
1539 }
1540 
1541 Method* LinkResolver::linktime_resolve_virtual_method_or_null(
1542                                                  const LinkInfo&amp; link_info) {
1543   EXCEPTION_MARK;
1544   Method* method_result = linktime_resolve_virtual_method(link_info, THREAD);
1545   if (HAS_PENDING_EXCEPTION) {
1546     CLEAR_PENDING_EXCEPTION;
1547     return NULL;
1548   } else {
1549     return method_result;
1550   }
1551 }
1552 
1553 Method* LinkResolver::resolve_virtual_call_or_null(
1554                                                  Klass* receiver_klass,
1555                                                  const LinkInfo&amp; link_info) {
1556   EXCEPTION_MARK;
1557   CallInfo info;
1558   resolve_virtual_call(info, Handle(), receiver_klass, link_info, false, THREAD);
1559   if (HAS_PENDING_EXCEPTION) {
1560     CLEAR_PENDING_EXCEPTION;
1561     return NULL;
1562   }
1563   return info.selected_method();
1564 }
1565 
1566 Method* LinkResolver::resolve_interface_call_or_null(
1567                                                  Klass* receiver_klass,
1568                                                  const LinkInfo&amp; link_info) {
1569   EXCEPTION_MARK;
1570   CallInfo info;
1571   resolve_interface_call(info, Handle(), receiver_klass, link_info, false, THREAD);
1572   if (HAS_PENDING_EXCEPTION) {
1573     CLEAR_PENDING_EXCEPTION;
1574     return NULL;
1575   }
1576   return info.selected_method();
1577 }
1578 
1579 int LinkResolver::resolve_virtual_vtable_index(Klass* receiver_klass,
1580                                                const LinkInfo&amp; link_info) {
1581   EXCEPTION_MARK;
1582   CallInfo info;
1583   resolve_virtual_call(info, Handle(), receiver_klass, link_info,
1584                        /*check_null_or_abstract*/false, THREAD);
1585   if (HAS_PENDING_EXCEPTION) {
1586     CLEAR_PENDING_EXCEPTION;
1587     return Method::invalid_vtable_index;
1588   }
1589   return info.vtable_index();
1590 }
1591 
1592 Method* LinkResolver::resolve_static_call_or_null(const LinkInfo&amp; link_info) {
1593   EXCEPTION_MARK;
1594   CallInfo info;
1595   resolve_static_call(info, link_info, /*initialize_class*/false, THREAD);
1596   if (HAS_PENDING_EXCEPTION) {
1597     CLEAR_PENDING_EXCEPTION;
1598     return NULL;
1599   }
1600   return info.selected_method();
1601 }
1602 
1603 Method* LinkResolver::resolve_special_call_or_null(const LinkInfo&amp; link_info) {
1604   EXCEPTION_MARK;
1605   CallInfo info;
1606   resolve_special_call(info, Handle(), link_info, THREAD);
1607   if (HAS_PENDING_EXCEPTION) {
1608     CLEAR_PENDING_EXCEPTION;
1609     return NULL;
1610   }
1611   return info.selected_method();
1612 }
1613 
1614 
1615 
1616 //------------------------------------------------------------------------------------------------------------------------
1617 // ConstantPool entries
1618 
1619 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, Bytecodes::Code byte, TRAPS) {
1620   switch (byte) {
1621     case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;
1622     case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;
1623     case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;
1624     case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;
1625     case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;
1626     case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;
1627     default                         :                                                            break;
1628   }
1629   return;
1630 }
1631 
1632 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
1633                                   const methodHandle&amp; attached_method,
1634                                   Bytecodes::Code byte, bool check_null_and_abstract, TRAPS) {
1635   Klass* defc = attached_method-&gt;method_holder();
1636   Symbol* name = attached_method-&gt;name();
1637   Symbol* type = attached_method-&gt;signature();
1638   LinkInfo link_info(defc, name, type);
1639   Klass* recv_klass = recv.is_null() ? defc : recv-&gt;klass();
1640   switch(byte) {
1641     case Bytecodes::_invokevirtual:
1642       resolve_virtual_call(result, recv, recv_klass, link_info,
1643                            check_null_and_abstract, CHECK);
1644       break;
1645     case Bytecodes::_invokeinterface:
1646       resolve_interface_call(result, recv, recv_klass, link_info,
1647                              check_null_and_abstract, CHECK);
1648       break;
1649     case Bytecodes::_invokestatic:
1650       resolve_static_call(result, link_info, /*initialize_class=*/false, CHECK);
1651       break;
1652     case Bytecodes::_invokespecial:
1653       resolve_special_call(result, recv, link_info, CHECK);
1654       break;
1655     default:
1656       fatal(&quot;bad call: %s&quot;, Bytecodes::name(byte));
1657       break;
1658   }
1659 }
1660 
1661 void LinkResolver::resolve_invokestatic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1662   LinkInfo link_info(pool, index, CHECK);
1663   resolve_static_call(result, link_info, /*initialize_class*/true, CHECK);
1664 }
1665 
1666 
1667 void LinkResolver::resolve_invokespecial(CallInfo&amp; result, Handle recv,
1668                                          const constantPoolHandle&amp; pool, int index, TRAPS) {
1669   LinkInfo link_info(pool, index, CHECK);
1670   resolve_special_call(result, recv, link_info, CHECK);
1671 }
1672 
1673 
1674 void LinkResolver::resolve_invokevirtual(CallInfo&amp; result, Handle recv,
1675                                           const constantPoolHandle&amp; pool, int index,
1676                                           TRAPS) {
1677 
1678   LinkInfo link_info(pool, index, CHECK);
1679   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1680   resolve_virtual_call(result, recv, recvrKlass, link_info, /*check_null_or_abstract*/true, CHECK);
1681 }
1682 
1683 
1684 void LinkResolver::resolve_invokeinterface(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, TRAPS) {
1685   LinkInfo link_info(pool, index, CHECK);
1686   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1687   resolve_interface_call(result, recv, recvrKlass, link_info, true, CHECK);
1688 }
1689 
1690 
1691 void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1692   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
1693   LinkInfo link_info(pool, index, CHECK);
1694   if (TraceMethodHandles) {
1695     ResourceMark rm(THREAD);
1696     tty-&gt;print_cr(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),
1697                   link_info.signature()-&gt;as_C_string());
1698   }
1699   resolve_handle_call(result, link_info, CHECK);
1700 }
1701 
1702 void LinkResolver::resolve_handle_call(CallInfo&amp; result,
1703                                        const LinkInfo&amp; link_info,
1704                                        TRAPS) {
1705   // JSR 292:  this must be an implicitly generated method MethodHandle.invokeExact(*...) or similar
1706   Klass* resolved_klass = link_info.resolved_klass();
1707   assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
1708          resolved_klass == SystemDictionary::VarHandle_klass(), &quot;&quot;);
1709   assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), &quot;&quot;);
1710   Handle       resolved_appendix;
1711   Method* resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);
1712   result.set_handle(resolved_klass, methodHandle(THREAD, resolved_method), resolved_appendix, CHECK);
1713 }
1714 
1715 void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int indy_index, TRAPS) {
1716   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(indy_index);
1717   int pool_index = cpce-&gt;constant_pool_index();
1718 
1719   // Resolve the bootstrap specifier (BSM + optional arguments).
1720   BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);
1721 
1722   // Check if CallSite has been bound already or failed already, and short circuit:
1723   {
1724     bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1725     if (is_done) return;
1726   }
1727 
1728   // The initial step in Call Site Specifier Resolution is to resolve the symbolic
1729   // reference to a method handle which will be the bootstrap method for a dynamic
1730   // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap
1731   // method fails, then a MethodHandleInError is stored at the corresponding bootstrap
1732   // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to
1733   // set the indy_rf flag since any subsequent invokedynamic instruction which shares
1734   // this bootstrap method will encounter the resolution of MethodHandleInError.
1735 
1736   resolve_dynamic_call(result, bootstrap_specifier, CHECK);
1737 
1738   if (TraceMethodHandles) {
1739     bootstrap_specifier.print_msg_on(tty, &quot;resolve_invokedynamic&quot;);
1740   }
1741 
1742   // The returned linkage result is provisional up to the moment
1743   // the interpreter or runtime performs a serialized check of
1744   // the relevant CPCE::f1 field.  This is done by the caller
1745   // of this method, via CPCE::set_dynamic_call, which uses
1746   // an ObjectLocker to do the final serialization of updates
1747   // to CPCE state, including f1.
1748 }
1749 
1750 void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
1751                                         BootstrapInfo&amp; bootstrap_specifier,
1752                                         TRAPS) {
1753   // JSR 292:  this must resolve to an implicitly generated method
1754   // such as MH.linkToCallSite(*...) or some other call-site shape.
1755   // The appendix argument is likely to be a freshly-created CallSite.
1756   // It may also be a MethodHandle from an unwrapped ConstantCallSite,
1757   // or any other reference.  The resolved_method as well as the appendix
1758   // are both recorded together via CallInfo::set_handle.
1759   SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
1760   Exceptions::wrap_dynamic_exception(THREAD);
1761 
1762   if (HAS_PENDING_EXCEPTION) {
1763     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1764       // Let any random low-level IE or SOE or OOME just bleed through.
1765       // Basically we pretend that the bootstrap method was never called,
1766       // if it fails this way:  We neither record a successful linkage,
1767       // nor do we memorize a LE for posterity.
1768       return;
1769     }
1770     // JVMS 5.4.3 says: If an attempt by the Java Virtual Machine to resolve
1771     // a symbolic reference fails because an error is thrown that is an
1772     // instance of LinkageError (or a subclass), then subsequent attempts to
1773     // resolve the reference always fail with the same error that was thrown
1774     // as a result of the initial resolution attempt.
1775      bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);
1776      if (!recorded_res_status) {
1777        // Another thread got here just before we did.  So, either use the method
1778        // that it resolved or throw the LinkageError exception that it threw.
1779        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1780        if (is_done) return;
1781      }
1782      assert(bootstrap_specifier.invokedynamic_cp_cache_entry()-&gt;indy_resolution_failed(),
1783             &quot;Resolution failure flag wasn&#39;t set&quot;);
1784   }
1785 
1786   bootstrap_specifier.resolve_newly_linked_invokedynamic(result, CHECK);
1787   // Exceptions::wrap_dynamic_exception not used because
1788   // set_handle doesn&#39;t throw linkage errors
1789 }
1790 
1791 // Selected method is abstract.
1792 void LinkResolver::throw_abstract_method_error(const methodHandle&amp; resolved_method,
1793                                                const methodHandle&amp; selected_method,
1794                                                Klass *recv_klass, TRAPS) {
1795   Klass *resolved_klass = resolved_method-&gt;method_holder();
1796   ResourceMark rm(THREAD);
1797   stringStream ss;
1798 
1799   if (recv_klass != NULL) {
1800     ss.print(&quot;Receiver class %s does not define or inherit an &quot;
1801              &quot;implementation of the&quot;,
1802              recv_klass-&gt;external_name());
1803   } else {
1804     ss.print(&quot;Missing implementation of&quot;);
1805   }
1806 
1807   assert(resolved_method.not_null(), &quot;Sanity&quot;);
1808   ss.print(&quot; resolved method &#39;%s%s&quot;,
1809            resolved_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
1810            resolved_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;);
1811   resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);
1812   ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());
1813   resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);
1814   ss.print(&quot;)&#39; of %s %s.&quot;,
1815            resolved_klass-&gt;external_kind(),
1816            resolved_klass-&gt;external_name());
1817 
1818   if (selected_method.not_null() &amp;&amp; !(resolved_method == selected_method)) {
1819     ss.print(&quot; Selected method is &#39;%s%s&quot;,
1820              selected_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
1821              selected_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;);
1822     selected_method-&gt;print_external_name(&amp;ss);
1823     ss.print(&quot;&#39;.&quot;);
1824   }
1825 
1826   THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1827 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../code/compiledMethod.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
586   static SymbolPropertyTable* invoke_method_table() { return _invoke_method_table; }
587 
588   // Basic loading operations
589   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
590                                                               Handle class_loader,
591                                                               Handle protection_domain,
592                                                               TRAPS);
593   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
594   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
595   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
596   // Wait on SystemDictionary_lock; unlocks lockObject before
597   // waiting; relocks lockObject with correct recursion count
598   // after waiting, but before reentering SystemDictionary_lock
599   // to preserve lock order semantics.
600   static void double_lock_wait(Handle lockObject, TRAPS);
601   static void define_instance_class(InstanceKlass* k, TRAPS);
602   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
603                                                 Handle class_loader,
604                                                 InstanceKlass* k, TRAPS);
605   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,

606                                       Handle class_loader, TRAPS);
607   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,
608                                             Handle class_loader,  Handle protection_domain,
609                                             bool is_superclass, TRAPS);
610   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
611                                                Handle protection_domain, TRAPS);
612   static InstanceKlass* load_shared_class(InstanceKlass* ik,
613                                           Handle class_loader,
614                                           Handle protection_domain,
615                                           const ClassFileStream *cfs,

616                                           TRAPS);
617   // Second part of load_shared_class
618   static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;
619   static InstanceKlass* load_shared_boot_class(Symbol* class_name,

620                                                TRAPS);
621   static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);
622   static Handle compute_loader_lock_object(Handle class_loader, TRAPS);
623   static void check_loader_lock_contention(Handle loader_lock, TRAPS);
624   static bool is_parallelCapable(Handle class_loader);
625   static bool is_parallelDefine(Handle class_loader);
626 
627 public:
628   static bool is_system_class_loader(oop class_loader);
629   static bool is_platform_class_loader(oop class_loader);
630 
631   // Returns TRUE if the method is a non-public member of class java.lang.Object.
632   static bool is_nonpublic_Object_method(Method* m) {
633     assert(m != NULL, &quot;Unexpected NULL Method*&quot;);
634     return !m-&gt;is_public() &amp;&amp; m-&gt;method_holder() == SystemDictionary::Object_klass();
635   }
636 
637 protected:
638   // Setup link to hierarchy
639   static void add_to_hierarchy(InstanceKlass* k, TRAPS);
</pre>
</td>
<td>
<hr />
<pre>
586   static SymbolPropertyTable* invoke_method_table() { return _invoke_method_table; }
587 
588   // Basic loading operations
589   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
590                                                               Handle class_loader,
591                                                               Handle protection_domain,
592                                                               TRAPS);
593   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
594   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
595   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
596   // Wait on SystemDictionary_lock; unlocks lockObject before
597   // waiting; relocks lockObject with correct recursion count
598   // after waiting, but before reentering SystemDictionary_lock
599   // to preserve lock order semantics.
600   static void double_lock_wait(Handle lockObject, TRAPS);
601   static void define_instance_class(InstanceKlass* k, TRAPS);
602   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
603                                                 Handle class_loader,
604                                                 InstanceKlass* k, TRAPS);
605   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
<span class="line-added">606                                       PackageEntry* pkg_entry,</span>
607                                       Handle class_loader, TRAPS);
608   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,
609                                             Handle class_loader,  Handle protection_domain,
610                                             bool is_superclass, TRAPS);
611   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
612                                                Handle protection_domain, TRAPS);
613   static InstanceKlass* load_shared_class(InstanceKlass* ik,
614                                           Handle class_loader,
615                                           Handle protection_domain,
616                                           const ClassFileStream *cfs,
<span class="line-added">617                                           PackageEntry* pkg_entry,</span>
618                                           TRAPS);
619   // Second part of load_shared_class
620   static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;
621   static InstanceKlass* load_shared_boot_class(Symbol* class_name,
<span class="line-added">622                                                PackageEntry* pkg_entry,</span>
623                                                TRAPS);
624   static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);
625   static Handle compute_loader_lock_object(Handle class_loader, TRAPS);
626   static void check_loader_lock_contention(Handle loader_lock, TRAPS);
627   static bool is_parallelCapable(Handle class_loader);
628   static bool is_parallelDefine(Handle class_loader);
629 
630 public:
631   static bool is_system_class_loader(oop class_loader);
632   static bool is_platform_class_loader(oop class_loader);
633 
634   // Returns TRUE if the method is a non-public member of class java.lang.Object.
635   static bool is_nonpublic_Object_method(Method* m) {
636     assert(m != NULL, &quot;Unexpected NULL Method*&quot;);
637     return !m-&gt;is_public() &amp;&amp; m-&gt;method_holder() == SystemDictionary::Object_klass();
638   }
639 
640 protected:
641   // Setup link to hierarchy
642   static void add_to_hierarchy(InstanceKlass* k, TRAPS);
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../code/compiledMethod.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
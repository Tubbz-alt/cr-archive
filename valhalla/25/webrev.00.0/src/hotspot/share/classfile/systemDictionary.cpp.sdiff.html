<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1187     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1188     loader_data-&gt;add_to_deallocate_list(k);
1189     return NULL;
1190   }
1191 
1192   // Make sure we have an entry in the SystemDictionary on success
1193   debug_only( {
1194     MutexLocker mu(THREAD, SystemDictionary_lock);
1195 
1196     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1197     assert(check == k, &quot;should be present in the dictionary&quot;);
1198   } );
1199 
1200   return k;
1201 }
1202 
1203 #if INCLUDE_CDS
1204 // Load a class for boot loader from the shared spaces. This also
1205 // forces the super class and all interfaces to be loaded.
1206 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,

1207                                                         TRAPS) {
1208   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1209   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
<span class="line-modified">1210     return load_shared_class(ik, Handle(), Handle(), NULL, THREAD);</span>
1211   }
1212   return NULL;
1213 }
1214 
1215 // Check if a shared class can be loaded by the specific classloader:
1216 //
1217 // NULL classloader:
1218 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1219 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1220 //     be defined in an unnamed module.
1221 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1222                                                InstanceKlass* ik,

1223                                                Handle class_loader, TRAPS) {
1224   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1225          &quot;Cannot use sharing if java.base is patched&quot;);
1226   ResourceMark rm(THREAD);
1227   int path_index = ik-&gt;shared_classpath_index();
1228   ClassLoaderData* loader_data = class_loader_data(class_loader);
1229   if (path_index &lt; 0) {
1230     // path_index &lt; 0 indicates that the class is intended for a custom loader
1231     // and should not be loaded by boot/platform/app loaders
1232     if (loader_data-&gt;is_builtin_class_loader_data()) {
1233       return false;
1234     } else {
1235       return true;
1236     }
1237   }
1238   SharedClassPathEntry* ent =
1239             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1240   if (!Universe::is_module_initialized()) {
1241     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1242            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1243     assert(class_loader.is_null(), &quot;sanity&quot;);
1244     return true;
1245   }
1246   // Get the pkg_entry from the classloader
<span class="line-modified">1247   PackageEntry* pkg_entry = NULL;</span>
<span class="line-modified">1248   ModuleEntry* mod_entry = NULL;</span>
1249   TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1250   if (pkg_name != NULL) {
1251     if (loader_data != NULL) {
<span class="line-removed">1252       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);</span>
1253       if (pkg_entry != NULL) {
1254         mod_entry = pkg_entry-&gt;module();
1255         // If the archived class is from a module that has been patched at runtime,
1256         // the class cannot be loaded from the archive.
1257         if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {
1258           return false;
1259         }
1260       }
1261     }
1262   }
1263 
1264   if (class_loader.is_null()) {
1265     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1266     // The NULL classloader can load archived class originated from the
1267     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1268     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1269     // by the NULL classloader.
1270     if (mod_entry != NULL) {
1271       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1272       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
</pre>
<hr />
<pre>
1329       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1330                                      class_loader, protection_domain, true, THREAD)) {
1331     return false;
1332   }
1333 
1334   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1335   int num_interfaces = interfaces-&gt;length();
1336   for (int index = 0; index &lt; num_interfaces; index++) {
1337     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1338       return false;
1339     }
1340   }
1341 
1342   return true;
1343 }
1344 
1345 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1346                                                    Handle class_loader,
1347                                                    Handle protection_domain,
1348                                                    const ClassFileStream *cfs,

1349                                                    TRAPS) {
1350   assert(ik != NULL, &quot;sanity&quot;);
1351   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1352   Symbol* class_name = ik-&gt;name();
1353 
1354   bool visible = is_shared_class_visible(
<span class="line-modified">1355                           class_name, ik, class_loader, CHECK_NULL);</span>
1356   if (!visible) {
1357     return NULL;
1358   }
1359 
1360   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1361     return NULL;
1362   }
1363 
1364   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1365       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1366   if (new_ik != NULL) {
1367     // The class is changed by CFLH. Return the new class. The shared class is
1368     // not used.
1369     return new_ik;
1370   }
1371 
1372   // Adjust methods to recover missing data.  They need addresses for
1373   // interpreter entry points and their default native method address
1374   // must be reset.
1375 
1376   // Updating methods must be done under a lock so multiple
1377   // threads don&#39;t update these in parallel
1378   //
1379   // Shared classes are all currently loaded by either the bootstrap or
1380   // internal parallel class loaders, so this will never cause a deadlock
1381   // on a custom class loader lock.
1382 
1383   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1384   {
1385     HandleMark hm(THREAD);
1386     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1387     check_loader_lock_contention(lockObject, THREAD);
1388     ObjectLocker ol(lockObject, THREAD, true);
1389     // prohibited package check assumes all classes loaded from archive call
1390     // restore_unshareable_info which calls ik-&gt;set_package()
<span class="line-modified">1391     ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);</span>
1392   }
1393 
1394   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1395   return ik;
1396 }
1397 
1398 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1399   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1400 
1401   // For boot loader, ensure that GetSystemPackage knows that a class in this
1402   // package was loaded.
1403   if (loader_data-&gt;is_the_null_class_loader_data()) {
1404     int path_index = ik-&gt;shared_classpath_index();
1405     ClassLoader::add_package(ik, path_index, THREAD);
1406   }
1407 
1408   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1409     // Only dump the classes that can be stored into CDS archive
1410     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1411       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
1438   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1439   if (klass-&gt;class_loader_data() != NULL) {
1440     return;
1441   }
1442 
1443   // add super and interfaces first
1444   Klass* super = klass-&gt;super();
1445   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1446     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1447     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1448   }
1449 
1450   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1451   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1452     InstanceKlass* ik = ifs-&gt;at(i);
1453     if (ik-&gt;class_loader_data()  == NULL) {
1454       quick_resolve(ik, loader_data, domain, CHECK);
1455     }
1456   }
1457 
<span class="line-modified">1458   klass-&gt;restore_unshareable_info(loader_data, domain, THREAD);</span>
1459   load_shared_class_misc(klass, loader_data, CHECK);
1460   Dictionary* dictionary = loader_data-&gt;dictionary();
1461   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1462   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1463   add_to_hierarchy(klass, CHECK);
1464   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1465 }
1466 #endif // INCLUDE_CDS
1467 
1468 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1469 
1470   if (class_loader.is_null()) {
1471     ResourceMark rm(THREAD);
1472     PackageEntry* pkg_entry = NULL;
1473     bool search_only_bootloader_append = false;
1474     ClassLoaderData *loader_data = class_loader_data(class_loader);
1475 
1476     // Find the package in the boot loader&#39;s package entry table.
1477     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1478     if (pkg_name != NULL) {
</pre>
<hr />
<pre>
1518         if (!ClassLoader::has_bootclasspath_append()) {
1519            // If there is no bootclasspath append entry, no need to continue
1520            // searching.
1521            return NULL;
1522         }
1523         search_only_bootloader_append = true;
1524       }
1525     }
1526 
1527     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1528     // of the boot loader&#39;s module path
1529     assert(Universe::is_module_initialized() ||
1530            !search_only_bootloader_append,
1531            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1532 
1533     // Search for classes in the CDS archive.
1534     InstanceKlass* k = NULL;
1535     {
1536 #if INCLUDE_CDS
1537       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
<span class="line-modified">1538       k = load_shared_boot_class(class_name, THREAD);</span>
1539 #endif
1540     }
1541 
1542     if (k == NULL) {
1543       // Use VM class loader
1544       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1545       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1546     }
1547 
1548     // find_or_define_instance_class may return a different InstanceKlass
1549     if (k != NULL) {
1550       InstanceKlass* defined_k =
1551         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1552       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1553         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1554         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1555         loader_data-&gt;add_to_deallocate_list(k);
1556         k = defined_k;
1557       } else if (HAS_PENDING_EXCEPTION) {
1558         loader_data-&gt;add_to_deallocate_list(k);
</pre>
<hr />
<pre>
2596          &quot;one or the other, or perhaps neither&quot;);
2597 
2598   // What we have here must be a valid field descriptor,
2599   // and all valid field descriptors are supported.
2600   // Produce the same java.lang.Class that reflection reports.
2601   if (accessing_klass != NULL) {
2602     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2603     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2604   }
2605   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2606   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2607   if (mirror_oop == NULL) {
2608     return Handle();  // report failure this way
2609   }
2610   Handle mirror(THREAD, mirror_oop);
2611 
2612   if (accessing_klass != NULL) {
2613     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2614     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2615     if (sel_klass != NULL) {
<span class="line-modified">2616       bool fold_type_to_class = true;</span>
<span class="line-removed">2617       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,</span>
<span class="line-removed">2618                                               fold_type_to_class, CHECK_NH);</span>
2619     }
2620   }
2621   return mirror;
2622 }
2623 
2624 
2625 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2626 // signature, as interpreted relative to the given class loader.
2627 // Because of class loader constraints, all method handle usage must be
2628 // consistent with this loader.
2629 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2630                                                  Klass* accessing_klass,
2631                                                  TRAPS) {
2632   Handle empty;
2633   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2634   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2635   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2636   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2637   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2638     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
</pre>
<hr />
<pre>
2663         // Fall back to accessing_klass context.
2664         can_be_cached = false;
2665       }
2666     }
2667     if (!can_be_cached) {
2668       // Resolve, throwing a real error if it doesn&#39;t work.
2669       mirror = ss.as_java_mirror(class_loader, protection_domain,
2670                                  SignatureStream::NCDFError, CHECK_(empty));
2671     }
2672     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2673     if (ss.at_return_type())
2674       rt = Handle(THREAD, mirror);
2675     else
2676       pts-&gt;obj_at_put(arg++, mirror);
2677 
2678     // Check accessibility.
2679     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2680       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2681       mirror = NULL;  // safety
2682       // Emulate ConstantPool::verify_constant_pool_resolve.
<span class="line-modified">2683       bool fold_type_to_class = true;</span>
<span class="line-removed">2684       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,</span>
<span class="line-removed">2685                                               fold_type_to_class, CHECK_(empty));</span>
2686     }
2687   }
2688   assert(arg == npts, &quot;&quot;);
2689 
2690   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2691   JavaCallArguments args(Handle(THREAD, rt()));
2692   args.push_oop(pts);
2693   JavaValue result(T_OBJECT);
2694   JavaCalls::call_static(&amp;result,
2695                          SystemDictionary::MethodHandleNatives_klass(),
2696                          vmSymbols::findMethodHandleType_name(),
2697                          vmSymbols::findMethodHandleType_signature(),
2698                          &amp;args, CHECK_(empty));
2699   Handle method_type(THREAD, (oop) result.get_jobject());
2700 
2701   if (can_be_cached) {
2702     // We can cache this MethodType inside the JVM.
2703     MutexLocker ml(THREAD, SystemDictionary_lock);
2704     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2705     if (spe == NULL)
</pre>
</td>
<td>
<hr />
<pre>
1187     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1188     loader_data-&gt;add_to_deallocate_list(k);
1189     return NULL;
1190   }
1191 
1192   // Make sure we have an entry in the SystemDictionary on success
1193   debug_only( {
1194     MutexLocker mu(THREAD, SystemDictionary_lock);
1195 
1196     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1197     assert(check == k, &quot;should be present in the dictionary&quot;);
1198   } );
1199 
1200   return k;
1201 }
1202 
1203 #if INCLUDE_CDS
1204 // Load a class for boot loader from the shared spaces. This also
1205 // forces the super class and all interfaces to be loaded.
1206 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
<span class="line-added">1207                                                         PackageEntry* pkg_entry,</span>
1208                                                         TRAPS) {
1209   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1210   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
<span class="line-modified">1211     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);</span>
1212   }
1213   return NULL;
1214 }
1215 
1216 // Check if a shared class can be loaded by the specific classloader:
1217 //
1218 // NULL classloader:
1219 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1220 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1221 //     be defined in an unnamed module.
1222 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1223                                                InstanceKlass* ik,
<span class="line-added">1224                                                PackageEntry* pkg_entry,</span>
1225                                                Handle class_loader, TRAPS) {
1226   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1227          &quot;Cannot use sharing if java.base is patched&quot;);
1228   ResourceMark rm(THREAD);
1229   int path_index = ik-&gt;shared_classpath_index();
1230   ClassLoaderData* loader_data = class_loader_data(class_loader);
1231   if (path_index &lt; 0) {
1232     // path_index &lt; 0 indicates that the class is intended for a custom loader
1233     // and should not be loaded by boot/platform/app loaders
1234     if (loader_data-&gt;is_builtin_class_loader_data()) {
1235       return false;
1236     } else {
1237       return true;
1238     }
1239   }
1240   SharedClassPathEntry* ent =
1241             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1242   if (!Universe::is_module_initialized()) {
1243     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1244            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1245     assert(class_loader.is_null(), &quot;sanity&quot;);
1246     return true;
1247   }
1248   // Get the pkg_entry from the classloader
<span class="line-modified">1249   ModuleEntry* mod_entry = NULL;</span>
<span class="line-modified">1250   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() :</span>
1251                                                ClassLoader::package_from_class_name(class_name);
1252   if (pkg_name != NULL) {
1253     if (loader_data != NULL) {

1254       if (pkg_entry != NULL) {
1255         mod_entry = pkg_entry-&gt;module();
1256         // If the archived class is from a module that has been patched at runtime,
1257         // the class cannot be loaded from the archive.
1258         if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {
1259           return false;
1260         }
1261       }
1262     }
1263   }
1264 
1265   if (class_loader.is_null()) {
1266     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1267     // The NULL classloader can load archived class originated from the
1268     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1269     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1270     // by the NULL classloader.
1271     if (mod_entry != NULL) {
1272       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1273       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
</pre>
<hr />
<pre>
1330       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1331                                      class_loader, protection_domain, true, THREAD)) {
1332     return false;
1333   }
1334 
1335   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1336   int num_interfaces = interfaces-&gt;length();
1337   for (int index = 0; index &lt; num_interfaces; index++) {
1338     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1339       return false;
1340     }
1341   }
1342 
1343   return true;
1344 }
1345 
1346 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1347                                                    Handle class_loader,
1348                                                    Handle protection_domain,
1349                                                    const ClassFileStream *cfs,
<span class="line-added">1350                                                    PackageEntry* pkg_entry,</span>
1351                                                    TRAPS) {
1352   assert(ik != NULL, &quot;sanity&quot;);
1353   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1354   Symbol* class_name = ik-&gt;name();
1355 
1356   bool visible = is_shared_class_visible(
<span class="line-modified">1357                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);</span>
1358   if (!visible) {
1359     return NULL;
1360   }
1361 
1362   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1363     return NULL;
1364   }
1365 
1366   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1367       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1368   if (new_ik != NULL) {
1369     // The class is changed by CFLH. Return the new class. The shared class is
1370     // not used.
1371     return new_ik;
1372   }
1373 
1374   // Adjust methods to recover missing data.  They need addresses for
1375   // interpreter entry points and their default native method address
1376   // must be reset.
1377 
1378   // Updating methods must be done under a lock so multiple
1379   // threads don&#39;t update these in parallel
1380   //
1381   // Shared classes are all currently loaded by either the bootstrap or
1382   // internal parallel class loaders, so this will never cause a deadlock
1383   // on a custom class loader lock.
1384 
1385   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1386   {
1387     HandleMark hm(THREAD);
1388     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1389     check_loader_lock_contention(lockObject, THREAD);
1390     ObjectLocker ol(lockObject, THREAD, true);
1391     // prohibited package check assumes all classes loaded from archive call
1392     // restore_unshareable_info which calls ik-&gt;set_package()
<span class="line-modified">1393     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);</span>
1394   }
1395 
1396   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1397   return ik;
1398 }
1399 
1400 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1401   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1402 
1403   // For boot loader, ensure that GetSystemPackage knows that a class in this
1404   // package was loaded.
1405   if (loader_data-&gt;is_the_null_class_loader_data()) {
1406     int path_index = ik-&gt;shared_classpath_index();
1407     ClassLoader::add_package(ik, path_index, THREAD);
1408   }
1409 
1410   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1411     // Only dump the classes that can be stored into CDS archive
1412     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1413       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
1440   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1441   if (klass-&gt;class_loader_data() != NULL) {
1442     return;
1443   }
1444 
1445   // add super and interfaces first
1446   Klass* super = klass-&gt;super();
1447   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1448     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1449     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1450   }
1451 
1452   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1453   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1454     InstanceKlass* ik = ifs-&gt;at(i);
1455     if (ik-&gt;class_loader_data()  == NULL) {
1456       quick_resolve(ik, loader_data, domain, CHECK);
1457     }
1458   }
1459 
<span class="line-modified">1460   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);</span>
1461   load_shared_class_misc(klass, loader_data, CHECK);
1462   Dictionary* dictionary = loader_data-&gt;dictionary();
1463   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1464   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1465   add_to_hierarchy(klass, CHECK);
1466   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1467 }
1468 #endif // INCLUDE_CDS
1469 
1470 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1471 
1472   if (class_loader.is_null()) {
1473     ResourceMark rm(THREAD);
1474     PackageEntry* pkg_entry = NULL;
1475     bool search_only_bootloader_append = false;
1476     ClassLoaderData *loader_data = class_loader_data(class_loader);
1477 
1478     // Find the package in the boot loader&#39;s package entry table.
1479     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1480     if (pkg_name != NULL) {
</pre>
<hr />
<pre>
1520         if (!ClassLoader::has_bootclasspath_append()) {
1521            // If there is no bootclasspath append entry, no need to continue
1522            // searching.
1523            return NULL;
1524         }
1525         search_only_bootloader_append = true;
1526       }
1527     }
1528 
1529     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1530     // of the boot loader&#39;s module path
1531     assert(Universe::is_module_initialized() ||
1532            !search_only_bootloader_append,
1533            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1534 
1535     // Search for classes in the CDS archive.
1536     InstanceKlass* k = NULL;
1537     {
1538 #if INCLUDE_CDS
1539       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
<span class="line-modified">1540       k = load_shared_boot_class(class_name, pkg_entry, THREAD);</span>
1541 #endif
1542     }
1543 
1544     if (k == NULL) {
1545       // Use VM class loader
1546       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1547       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1548     }
1549 
1550     // find_or_define_instance_class may return a different InstanceKlass
1551     if (k != NULL) {
1552       InstanceKlass* defined_k =
1553         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1554       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1555         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1556         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1557         loader_data-&gt;add_to_deallocate_list(k);
1558         k = defined_k;
1559       } else if (HAS_PENDING_EXCEPTION) {
1560         loader_data-&gt;add_to_deallocate_list(k);
</pre>
<hr />
<pre>
2598          &quot;one or the other, or perhaps neither&quot;);
2599 
2600   // What we have here must be a valid field descriptor,
2601   // and all valid field descriptors are supported.
2602   // Produce the same java.lang.Class that reflection reports.
2603   if (accessing_klass != NULL) {
2604     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2605     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2606   }
2607   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2608   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2609   if (mirror_oop == NULL) {
2610     return Handle();  // report failure this way
2611   }
2612   Handle mirror(THREAD, mirror_oop);
2613 
2614   if (accessing_klass != NULL) {
2615     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2616     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2617     if (sel_klass != NULL) {
<span class="line-modified">2618       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_NH);</span>


2619     }
2620   }
2621   return mirror;
2622 }
2623 
2624 
2625 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2626 // signature, as interpreted relative to the given class loader.
2627 // Because of class loader constraints, all method handle usage must be
2628 // consistent with this loader.
2629 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2630                                                  Klass* accessing_klass,
2631                                                  TRAPS) {
2632   Handle empty;
2633   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2634   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2635   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2636   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2637   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2638     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
</pre>
<hr />
<pre>
2663         // Fall back to accessing_klass context.
2664         can_be_cached = false;
2665       }
2666     }
2667     if (!can_be_cached) {
2668       // Resolve, throwing a real error if it doesn&#39;t work.
2669       mirror = ss.as_java_mirror(class_loader, protection_domain,
2670                                  SignatureStream::NCDFError, CHECK_(empty));
2671     }
2672     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2673     if (ss.at_return_type())
2674       rt = Handle(THREAD, mirror);
2675     else
2676       pts-&gt;obj_at_put(arg++, mirror);
2677 
2678     // Check accessibility.
2679     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2680       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2681       mirror = NULL;  // safety
2682       // Emulate ConstantPool::verify_constant_pool_resolve.
<span class="line-modified">2683       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_(empty));</span>


2684     }
2685   }
2686   assert(arg == npts, &quot;&quot;);
2687 
2688   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2689   JavaCallArguments args(Handle(THREAD, rt()));
2690   args.push_oop(pts);
2691   JavaValue result(T_OBJECT);
2692   JavaCalls::call_static(&amp;result,
2693                          SystemDictionary::MethodHandleNatives_klass(),
2694                          vmSymbols::findMethodHandleType_name(),
2695                          vmSymbols::findMethodHandleType_signature(),
2696                          &amp;args, CHECK_(empty));
2697   Handle method_type(THREAD, (oop) result.get_jobject());
2698 
2699   if (can_be_cached) {
2700     // We can cache this MethodType inside the JVM.
2701     MutexLocker ml(THREAD, SystemDictionary_lock);
2702     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2703     if (spe == NULL)
</pre>
</td>
</tr>
</table>
<center><a href="classLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
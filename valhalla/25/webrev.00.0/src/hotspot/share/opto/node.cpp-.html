<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/node.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/cfgnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/machnode.hpp&quot;
  36 #include &quot;opto/matcher.hpp&quot;
  37 #include &quot;opto/node.hpp&quot;
  38 #include &quot;opto/opcodes.hpp&quot;
  39 #include &quot;opto/regmask.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/copy.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
  44 #include &quot;utilities/powerOfTwo.hpp&quot;
  45 
  46 class RegMask;
  47 // #include &quot;phase.hpp&quot;
  48 class PhaseTransform;
  49 class PhaseGVN;
  50 
  51 // Arena we are currently building Nodes in
  52 const uint Node::NotAMachineReg = 0xffff0000;
  53 
  54 #ifndef PRODUCT
  55 extern int nodes_created;
  56 #endif
  57 #ifdef __clang__
  58 #pragma clang diagnostic push
  59 #pragma GCC diagnostic ignored &quot;-Wuninitialized&quot;
  60 #endif
  61 
  62 #ifdef ASSERT
  63 
  64 //-------------------------- construct_node------------------------------------
  65 // Set a breakpoint here to identify where a particular node index is built.
  66 void Node::verify_construction() {
  67   _debug_orig = NULL;
  68   int old_debug_idx = Compile::debug_idx();
  69   int new_debug_idx = old_debug_idx+1;
  70   if (new_debug_idx &gt; 0) {
  71     // Arrange that the lowest five decimal digits of _debug_idx
  72     // will repeat those of _idx. In case this is somehow pathological,
  73     // we continue to assign negative numbers (!) consecutively.
  74     const int mod = 100000;
  75     int bump = (int)(_idx - new_debug_idx) % mod;
  76     if (bump &lt; 0)  bump += mod;
  77     assert(bump &gt;= 0 &amp;&amp; bump &lt; mod, &quot;&quot;);
  78     new_debug_idx += bump;
  79   }
  80   Compile::set_debug_idx(new_debug_idx);
  81   set_debug_idx( new_debug_idx );
  82   assert(Compile::current()-&gt;unique() &lt; (INT_MAX - 1), &quot;Node limit exceeded INT_MAX&quot;);
  83   assert(Compile::current()-&gt;live_nodes() &lt; Compile::current()-&gt;max_node_limit(), &quot;Live Node limit exceeded limit&quot;);
  84   if (BreakAtNode != 0 &amp;&amp; (_debug_idx == BreakAtNode || (int)_idx == BreakAtNode)) {
  85     tty-&gt;print_cr(&quot;BreakAtNode: _idx=%d _debug_idx=%d&quot;, _idx, _debug_idx);
  86     BREAKPOINT;
  87   }
  88 #if OPTO_DU_ITERATOR_ASSERT
  89   _last_del = NULL;
  90   _del_tick = 0;
  91 #endif
  92   _hash_lock = 0;
  93 }
  94 
  95 
  96 // #ifdef ASSERT ...
  97 
  98 #if OPTO_DU_ITERATOR_ASSERT
  99 void DUIterator_Common::sample(const Node* node) {
 100   _vdui     = VerifyDUIterators;
 101   _node     = node;
 102   _outcnt   = node-&gt;_outcnt;
 103   _del_tick = node-&gt;_del_tick;
 104   _last     = NULL;
 105 }
 106 
 107 void DUIterator_Common::verify(const Node* node, bool at_end_ok) {
 108   assert(_node     == node, &quot;consistent iterator source&quot;);
 109   assert(_del_tick == node-&gt;_del_tick, &quot;no unexpected deletions allowed&quot;);
 110 }
 111 
 112 void DUIterator_Common::verify_resync() {
 113   // Ensure that the loop body has just deleted the last guy produced.
 114   const Node* node = _node;
 115   // Ensure that at least one copy of the last-seen edge was deleted.
 116   // Note:  It is OK to delete multiple copies of the last-seen edge.
 117   // Unfortunately, we have no way to verify that all the deletions delete
 118   // that same edge.  On this point we must use the Honor System.
 119   assert(node-&gt;_del_tick &gt;= _del_tick+1, &quot;must have deleted an edge&quot;);
 120   assert(node-&gt;_last_del == _last, &quot;must have deleted the edge just produced&quot;);
 121   // We liked this deletion, so accept the resulting outcnt and tick.
 122   _outcnt   = node-&gt;_outcnt;
 123   _del_tick = node-&gt;_del_tick;
 124 }
 125 
 126 void DUIterator_Common::reset(const DUIterator_Common&amp; that) {
 127   if (this == &amp;that)  return;  // ignore assignment to self
 128   if (!_vdui) {
 129     // We need to initialize everything, overwriting garbage values.
 130     _last = that._last;
 131     _vdui = that._vdui;
 132   }
 133   // Note:  It is legal (though odd) for an iterator over some node x
 134   // to be reassigned to iterate over another node y.  Some doubly-nested
 135   // progress loops depend on being able to do this.
 136   const Node* node = that._node;
 137   // Re-initialize everything, except _last.
 138   _node     = node;
 139   _outcnt   = node-&gt;_outcnt;
 140   _del_tick = node-&gt;_del_tick;
 141 }
 142 
 143 void DUIterator::sample(const Node* node) {
 144   DUIterator_Common::sample(node);      // Initialize the assertion data.
 145   _refresh_tick = 0;                    // No refreshes have happened, as yet.
 146 }
 147 
 148 void DUIterator::verify(const Node* node, bool at_end_ok) {
 149   DUIterator_Common::verify(node, at_end_ok);
 150   assert(_idx      &lt;  node-&gt;_outcnt + (uint)at_end_ok, &quot;idx in range&quot;);
 151 }
 152 
 153 void DUIterator::verify_increment() {
 154   if (_refresh_tick &amp; 1) {
 155     // We have refreshed the index during this loop.
 156     // Fix up _idx to meet asserts.
 157     if (_idx &gt; _outcnt)  _idx = _outcnt;
 158   }
 159   verify(_node, true);
 160 }
 161 
 162 void DUIterator::verify_resync() {
 163   // Note:  We do not assert on _outcnt, because insertions are OK here.
 164   DUIterator_Common::verify_resync();
 165   // Make sure we are still in sync, possibly with no more out-edges:
 166   verify(_node, true);
 167 }
 168 
 169 void DUIterator::reset(const DUIterator&amp; that) {
 170   if (this == &amp;that)  return;  // self assignment is always a no-op
 171   assert(that._refresh_tick == 0, &quot;assign only the result of Node::outs()&quot;);
 172   assert(that._idx          == 0, &quot;assign only the result of Node::outs()&quot;);
 173   assert(_idx               == that._idx, &quot;already assigned _idx&quot;);
 174   if (!_vdui) {
 175     // We need to initialize everything, overwriting garbage values.
 176     sample(that._node);
 177   } else {
 178     DUIterator_Common::reset(that);
 179     if (_refresh_tick &amp; 1) {
 180       _refresh_tick++;                  // Clear the &quot;was refreshed&quot; flag.
 181     }
 182     assert(_refresh_tick &lt; 2*100000, &quot;DU iteration must converge quickly&quot;);
 183   }
 184 }
 185 
 186 void DUIterator::refresh() {
 187   DUIterator_Common::sample(_node);     // Re-fetch assertion data.
 188   _refresh_tick |= 1;                   // Set the &quot;was refreshed&quot; flag.
 189 }
 190 
 191 void DUIterator::verify_finish() {
 192   // If the loop has killed the node, do not require it to re-run.
 193   if (_node-&gt;_outcnt == 0)  _refresh_tick &amp;= ~1;
 194   // If this assert triggers, it means that a loop used refresh_out_pos
 195   // to re-synch an iteration index, but the loop did not correctly
 196   // re-run itself, using a &quot;while (progress)&quot; construct.
 197   // This iterator enforces the rule that you must keep trying the loop
 198   // until it &quot;runs clean&quot; without any need for refreshing.
 199   assert(!(_refresh_tick &amp; 1), &quot;the loop must run once with no refreshing&quot;);
 200 }
 201 
 202 
 203 void DUIterator_Fast::verify(const Node* node, bool at_end_ok) {
 204   DUIterator_Common::verify(node, at_end_ok);
 205   Node** out    = node-&gt;_out;
 206   uint   cnt    = node-&gt;_outcnt;
 207   assert(cnt == _outcnt, &quot;no insertions allowed&quot;);
 208   assert(_outp &gt;= out &amp;&amp; _outp &lt;= out + cnt - !at_end_ok, &quot;outp in range&quot;);
 209   // This last check is carefully designed to work for NO_OUT_ARRAY.
 210 }
 211 
 212 void DUIterator_Fast::verify_limit() {
 213   const Node* node = _node;
 214   verify(node, true);
 215   assert(_outp == node-&gt;_out + node-&gt;_outcnt, &quot;limit still correct&quot;);
 216 }
 217 
 218 void DUIterator_Fast::verify_resync() {
 219   const Node* node = _node;
 220   if (_outp == node-&gt;_out + _outcnt) {
 221     // Note that the limit imax, not the pointer i, gets updated with the
 222     // exact count of deletions.  (For the pointer it&#39;s always &quot;--i&quot;.)
 223     assert(node-&gt;_outcnt+node-&gt;_del_tick == _outcnt+_del_tick, &quot;no insertions allowed with deletion(s)&quot;);
 224     // This is a limit pointer, with a name like &quot;imax&quot;.
 225     // Fudge the _last field so that the common assert will be happy.
 226     _last = (Node*) node-&gt;_last_del;
 227     DUIterator_Common::verify_resync();
 228   } else {
 229     assert(node-&gt;_outcnt &lt; _outcnt, &quot;no insertions allowed with deletion(s)&quot;);
 230     // A normal internal pointer.
 231     DUIterator_Common::verify_resync();
 232     // Make sure we are still in sync, possibly with no more out-edges:
 233     verify(node, true);
 234   }
 235 }
 236 
 237 void DUIterator_Fast::verify_relimit(uint n) {
 238   const Node* node = _node;
 239   assert((int)n &gt; 0, &quot;use imax -= n only with a positive count&quot;);
 240   // This must be a limit pointer, with a name like &quot;imax&quot;.
 241   assert(_outp == node-&gt;_out + node-&gt;_outcnt, &quot;apply -= only to a limit (imax)&quot;);
 242   // The reported number of deletions must match what the node saw.
 243   assert(node-&gt;_del_tick == _del_tick + n, &quot;must have deleted n edges&quot;);
 244   // Fudge the _last field so that the common assert will be happy.
 245   _last = (Node*) node-&gt;_last_del;
 246   DUIterator_Common::verify_resync();
 247 }
 248 
 249 void DUIterator_Fast::reset(const DUIterator_Fast&amp; that) {
 250   assert(_outp              == that._outp, &quot;already assigned _outp&quot;);
 251   DUIterator_Common::reset(that);
 252 }
 253 
 254 void DUIterator_Last::verify(const Node* node, bool at_end_ok) {
 255   // at_end_ok means the _outp is allowed to underflow by 1
 256   _outp += at_end_ok;
 257   DUIterator_Fast::verify(node, at_end_ok);  // check _del_tick, etc.
 258   _outp -= at_end_ok;
 259   assert(_outp == (node-&gt;_out + node-&gt;_outcnt) - 1, &quot;pointer must point to end of nodes&quot;);
 260 }
 261 
 262 void DUIterator_Last::verify_limit() {
 263   // Do not require the limit address to be resynched.
 264   //verify(node, true);
 265   assert(_outp == _node-&gt;_out, &quot;limit still correct&quot;);
 266 }
 267 
 268 void DUIterator_Last::verify_step(uint num_edges) {
 269   assert((int)num_edges &gt; 0, &quot;need non-zero edge count for loop progress&quot;);
 270   _outcnt   -= num_edges;
 271   _del_tick += num_edges;
 272   // Make sure we are still in sync, possibly with no more out-edges:
 273   const Node* node = _node;
 274   verify(node, true);
 275   assert(node-&gt;_last_del == _last, &quot;must have deleted the edge just produced&quot;);
 276 }
 277 
 278 #endif //OPTO_DU_ITERATOR_ASSERT
 279 
 280 
 281 #endif //ASSERT
 282 
 283 
 284 // This constant used to initialize _out may be any non-null value.
 285 // The value NULL is reserved for the top node only.
 286 #define NO_OUT_ARRAY ((Node**)-1)
 287 
 288 // Out-of-line code from node constructors.
 289 // Executed only when extra debug info. is being passed around.
 290 static void init_node_notes(Compile* C, int idx, Node_Notes* nn) {
 291   C-&gt;set_node_notes_at(idx, nn);
 292 }
 293 
 294 // Shared initialization code.
 295 inline int Node::Init(int req) {
 296   Compile* C = Compile::current();
 297   int idx = C-&gt;next_unique();
 298 
 299   // Allocate memory for the necessary number of edges.
 300   if (req &gt; 0) {
 301     // Allocate space for _in array to have double alignment.
 302     _in = (Node **) ((char *) (C-&gt;node_arena()-&gt;Amalloc_D(req * sizeof(void*))));
 303   }
 304   // If there are default notes floating around, capture them:
 305   Node_Notes* nn = C-&gt;default_node_notes();
 306   if (nn != NULL)  init_node_notes(C, idx, nn);
 307 
 308   // Note:  At this point, C is dead,
 309   // and we begin to initialize the new Node.
 310 
 311   _cnt = _max = req;
 312   _outcnt = _outmax = 0;
 313   _class_id = Class_Node;
 314   _flags = 0;
 315   _out = NO_OUT_ARRAY;
 316   return idx;
 317 }
 318 
 319 //------------------------------Node-------------------------------------------
 320 // Create a Node, with a given number of required edges.
 321 Node::Node(uint req)
 322   : _idx(Init(req))
 323 #ifdef ASSERT
 324   , _parse_idx(_idx)
 325 #endif
 326 {
 327   assert( req &lt; Compile::current()-&gt;max_node_limit() - NodeLimitFudgeFactor, &quot;Input limit exceeded&quot; );
 328   debug_only( verify_construction() );
 329   NOT_PRODUCT(nodes_created++);
 330   if (req == 0) {
 331     _in = NULL;
 332   } else {
 333     Node** to = _in;
 334     for(uint i = 0; i &lt; req; i++) {
 335       to[i] = NULL;
 336     }
 337   }
 338 }
 339 
 340 //------------------------------Node-------------------------------------------
 341 Node::Node(Node *n0)
 342   : _idx(Init(1))
 343 #ifdef ASSERT
 344   , _parse_idx(_idx)
 345 #endif
 346 {
 347   debug_only( verify_construction() );
 348   NOT_PRODUCT(nodes_created++);
 349   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 350   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 351 }
 352 
 353 //------------------------------Node-------------------------------------------
 354 Node::Node(Node *n0, Node *n1)
 355   : _idx(Init(2))
 356 #ifdef ASSERT
 357   , _parse_idx(_idx)
 358 #endif
 359 {
 360   debug_only( verify_construction() );
 361   NOT_PRODUCT(nodes_created++);
 362   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 363   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 364   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 365   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 366 }
 367 
 368 //------------------------------Node-------------------------------------------
 369 Node::Node(Node *n0, Node *n1, Node *n2)
 370   : _idx(Init(3))
 371 #ifdef ASSERT
 372   , _parse_idx(_idx)
 373 #endif
 374 {
 375   debug_only( verify_construction() );
 376   NOT_PRODUCT(nodes_created++);
 377   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 378   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 379   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 380   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 381   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 382   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 383 }
 384 
 385 //------------------------------Node-------------------------------------------
 386 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3)
 387   : _idx(Init(4))
 388 #ifdef ASSERT
 389   , _parse_idx(_idx)
 390 #endif
 391 {
 392   debug_only( verify_construction() );
 393   NOT_PRODUCT(nodes_created++);
 394   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 395   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 396   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 397   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 398   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 399   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 400   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 401   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 402 }
 403 
 404 //------------------------------Node-------------------------------------------
 405 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3, Node *n4)
 406   : _idx(Init(5))
 407 #ifdef ASSERT
 408   , _parse_idx(_idx)
 409 #endif
 410 {
 411   debug_only( verify_construction() );
 412   NOT_PRODUCT(nodes_created++);
 413   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 414   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 415   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 416   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 417   assert( is_not_dead(n4), &quot;can not use dead node&quot;);
 418   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 419   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 420   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 421   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 422   _in[4] = n4; if (n4 != NULL) n4-&gt;add_out((Node *)this);
 423 }
 424 
 425 //------------------------------Node-------------------------------------------
 426 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3,
 427                      Node *n4, Node *n5)
 428   : _idx(Init(6))
 429 #ifdef ASSERT
 430   , _parse_idx(_idx)
 431 #endif
 432 {
 433   debug_only( verify_construction() );
 434   NOT_PRODUCT(nodes_created++);
 435   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 436   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 437   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 438   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 439   assert( is_not_dead(n4), &quot;can not use dead node&quot;);
 440   assert( is_not_dead(n5), &quot;can not use dead node&quot;);
 441   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 442   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 443   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 444   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 445   _in[4] = n4; if (n4 != NULL) n4-&gt;add_out((Node *)this);
 446   _in[5] = n5; if (n5 != NULL) n5-&gt;add_out((Node *)this);
 447 }
 448 
 449 //------------------------------Node-------------------------------------------
 450 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3,
 451                      Node *n4, Node *n5, Node *n6)
 452   : _idx(Init(7))
 453 #ifdef ASSERT
 454   , _parse_idx(_idx)
 455 #endif
 456 {
 457   debug_only( verify_construction() );
 458   NOT_PRODUCT(nodes_created++);
 459   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 460   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 461   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 462   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 463   assert( is_not_dead(n4), &quot;can not use dead node&quot;);
 464   assert( is_not_dead(n5), &quot;can not use dead node&quot;);
 465   assert( is_not_dead(n6), &quot;can not use dead node&quot;);
 466   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 467   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 468   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 469   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 470   _in[4] = n4; if (n4 != NULL) n4-&gt;add_out((Node *)this);
 471   _in[5] = n5; if (n5 != NULL) n5-&gt;add_out((Node *)this);
 472   _in[6] = n6; if (n6 != NULL) n6-&gt;add_out((Node *)this);
 473 }
 474 
 475 #ifdef __clang__
 476 #pragma clang diagnostic pop
 477 #endif
 478 
 479 
 480 //------------------------------clone------------------------------------------
 481 // Clone a Node.
 482 Node *Node::clone() const {
 483   Compile* C = Compile::current();
 484   uint s = size_of();           // Size of inherited Node
 485   Node *n = (Node*)C-&gt;node_arena()-&gt;Amalloc_D(size_of() + _max*sizeof(Node*));
 486   Copy::conjoint_words_to_lower((HeapWord*)this, (HeapWord*)n, s);
 487   // Set the new input pointer array
 488   n-&gt;_in = (Node**)(((char*)n)+s);
 489   // Cannot share the old output pointer array, so kill it
 490   n-&gt;_out = NO_OUT_ARRAY;
 491   // And reset the counters to 0
 492   n-&gt;_outcnt = 0;
 493   n-&gt;_outmax = 0;
 494   // Unlock this guy, since he is not in any hash table.
 495   debug_only(n-&gt;_hash_lock = 0);
 496   // Walk the old node&#39;s input list to duplicate its edges
 497   uint i;
 498   for( i = 0; i &lt; len(); i++ ) {
 499     Node *x = in(i);
 500     n-&gt;_in[i] = x;
 501     if (x != NULL) x-&gt;add_out(n);
 502   }
 503   if (is_macro())
 504     C-&gt;add_macro_node(n);
 505   if (is_expensive())
 506     C-&gt;add_expensive_node(n);
 507   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 508   bs-&gt;register_potential_barrier_node(n);
 509   // If the cloned node is a range check dependent CastII, add it to the list.
 510   CastIINode* cast = n-&gt;isa_CastII();
 511   if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
 512     C-&gt;add_range_check_cast(cast);
 513   }
 514   if (n-&gt;Opcode() == Op_Opaque4) {
 515     C-&gt;add_opaque4_node(n);
 516   }
 517 
 518   n-&gt;set_idx(C-&gt;next_unique()); // Get new unique index as well
 519   debug_only( n-&gt;verify_construction() );
 520   NOT_PRODUCT(nodes_created++);
 521   // Do not patch over the debug_idx of a clone, because it makes it
 522   // impossible to break on the clone&#39;s moment of creation.
 523   //debug_only( n-&gt;set_debug_idx( debug_idx() ) );
 524 
 525   C-&gt;copy_node_notes_to(n, (Node*) this);
 526 
 527   // MachNode clone
 528   uint nopnds;
 529   if (this-&gt;is_Mach() &amp;&amp; (nopnds = this-&gt;as_Mach()-&gt;num_opnds()) &gt; 0) {
 530     MachNode *mach  = n-&gt;as_Mach();
 531     MachNode *mthis = this-&gt;as_Mach();
 532     // Get address of _opnd_array.
 533     // It should be the same offset since it is the clone of this node.
 534     MachOper **from = mthis-&gt;_opnds;
 535     MachOper **to = (MachOper **)((size_t)(&amp;mach-&gt;_opnds) +
 536                     pointer_delta((const void*)from,
 537                                   (const void*)(&amp;mthis-&gt;_opnds), 1));
 538     mach-&gt;_opnds = to;
 539     for ( uint i = 0; i &lt; nopnds; ++i ) {
 540       to[i] = from[i]-&gt;clone();
 541     }
 542   }
 543   // cloning CallNode may need to clone JVMState
 544   if (n-&gt;is_Call()) {
 545     n-&gt;as_Call()-&gt;clone_jvms(C);
 546   }
 547   if (n-&gt;is_SafePoint()) {
 548     n-&gt;as_SafePoint()-&gt;clone_replaced_nodes();
 549   }
 550   if (n-&gt;is_ValueTypeBase()) {
 551     C-&gt;add_value_type(n);
 552   }
 553   return n;                     // Return the clone
 554 }
 555 
 556 //---------------------------setup_is_top--------------------------------------
 557 // Call this when changing the top node, to reassert the invariants
 558 // required by Node::is_top.  See Compile::set_cached_top_node.
 559 void Node::setup_is_top() {
 560   if (this == (Node*)Compile::current()-&gt;top()) {
 561     // This node has just become top.  Kill its out array.
 562     _outcnt = _outmax = 0;
 563     _out = NULL;                           // marker value for top
 564     assert(is_top(), &quot;must be top&quot;);
 565   } else {
 566     if (_out == NULL)  _out = NO_OUT_ARRAY;
 567     assert(!is_top(), &quot;must not be top&quot;);
 568   }
 569 }
 570 
 571 //------------------------------~Node------------------------------------------
 572 // Fancy destructor; eagerly attempt to reclaim Node numberings and storage
 573 void Node::destruct() {
 574   // Eagerly reclaim unique Node numberings
 575   Compile* compile = Compile::current();
 576   if ((uint)_idx+1 == compile-&gt;unique()) {
 577     compile-&gt;set_unique(compile-&gt;unique()-1);
 578   }
 579   // Clear debug info:
 580   Node_Notes* nn = compile-&gt;node_notes_at(_idx);
 581   if (nn != NULL)  nn-&gt;clear();
 582   // Walk the input array, freeing the corresponding output edges
 583   _cnt = _max;  // forget req/prec distinction
 584   uint i;
 585   for( i = 0; i &lt; _max; i++ ) {
 586     set_req(i, NULL);
 587     //assert(def-&gt;out(def-&gt;outcnt()-1) == (Node *)this,&quot;bad def-use hacking in reclaim&quot;);
 588   }
 589   assert(outcnt() == 0, &quot;deleting a node must not leave a dangling use&quot;);
 590   // See if the input array was allocated just prior to the object
 591   int edge_size = _max*sizeof(void*);
 592   int out_edge_size = _outmax*sizeof(void*);
 593   char *edge_end = ((char*)_in) + edge_size;
 594   char *out_array = (char*)(_out == NO_OUT_ARRAY? NULL: _out);
 595   int node_size = size_of();
 596 
 597   // Free the output edge array
 598   if (out_edge_size &gt; 0) {
 599     compile-&gt;node_arena()-&gt;Afree(out_array, out_edge_size);
 600   }
 601 
 602   // Free the input edge array and the node itself
 603   if( edge_end == (char*)this ) {
 604     // It was; free the input array and object all in one hit
 605 #ifndef ASSERT
 606     compile-&gt;node_arena()-&gt;Afree(_in,edge_size+node_size);
 607 #endif
 608   } else {
 609     // Free just the input array
 610     compile-&gt;node_arena()-&gt;Afree(_in,edge_size);
 611 
 612     // Free just the object
 613 #ifndef ASSERT
 614     compile-&gt;node_arena()-&gt;Afree(this,node_size);
 615 #endif
 616   }
 617   if (is_macro()) {
 618     compile-&gt;remove_macro_node(this);
 619   }
 620   if (is_expensive()) {
 621     compile-&gt;remove_expensive_node(this);
 622   }
 623   CastIINode* cast = isa_CastII();
 624   if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
 625     compile-&gt;remove_range_check_cast(cast);
 626   }
 627   if (Opcode() == Op_Opaque4) {
 628     compile-&gt;remove_opaque4_node(this);
 629   }
 630   if (is_ValueTypeBase()) {
 631     compile-&gt;remove_value_type(this);
 632   }
 633 
 634   if (is_SafePoint()) {
 635     as_SafePoint()-&gt;delete_replaced_nodes();
 636   }
 637   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 638   bs-&gt;unregister_potential_barrier_node(this);
 639 #ifdef ASSERT
 640   // We will not actually delete the storage, but we&#39;ll make the node unusable.
 641   *(address*)this = badAddress;  // smash the C++ vtbl, probably
 642   _in = _out = (Node**) badAddress;
 643   _max = _cnt = _outmax = _outcnt = 0;
 644   compile-&gt;remove_modified_node(this);
 645 #endif
 646 }
 647 
 648 //------------------------------grow-------------------------------------------
 649 // Grow the input array, making space for more edges
 650 void Node::grow( uint len ) {
 651   Arena* arena = Compile::current()-&gt;node_arena();
 652   uint new_max = _max;
 653   if( new_max == 0 ) {
 654     _max = 4;
 655     _in = (Node**)arena-&gt;Amalloc(4*sizeof(Node*));
 656     Node** to = _in;
 657     to[0] = NULL;
 658     to[1] = NULL;
 659     to[2] = NULL;
 660     to[3] = NULL;
 661     return;
 662   }
 663   new_max = next_power_of_2(len);
 664   // Trimming to limit allows a uint8 to handle up to 255 edges.
 665   // Previously I was using only powers-of-2 which peaked at 128 edges.
 666   //if( new_max &gt;= limit ) new_max = limit-1;
 667   _in = (Node**)arena-&gt;Arealloc(_in, _max*sizeof(Node*), new_max*sizeof(Node*));
 668   Copy::zero_to_bytes(&amp;_in[_max], (new_max-_max)*sizeof(Node*)); // NULL all new space
 669   _max = new_max;               // Record new max length
 670   // This assertion makes sure that Node::_max is wide enough to
 671   // represent the numerical value of new_max.
 672   assert(_max == new_max &amp;&amp; _max &gt; len, &quot;int width of _max is too small&quot;);
 673 }
 674 
 675 //-----------------------------out_grow----------------------------------------
 676 // Grow the input array, making space for more edges
 677 void Node::out_grow( uint len ) {
 678   assert(!is_top(), &quot;cannot grow a top node&#39;s out array&quot;);
 679   Arena* arena = Compile::current()-&gt;node_arena();
 680   uint new_max = _outmax;
 681   if( new_max == 0 ) {
 682     _outmax = 4;
 683     _out = (Node **)arena-&gt;Amalloc(4*sizeof(Node*));
 684     return;
 685   }
 686   new_max = next_power_of_2(len);
 687   // Trimming to limit allows a uint8 to handle up to 255 edges.
 688   // Previously I was using only powers-of-2 which peaked at 128 edges.
 689   //if( new_max &gt;= limit ) new_max = limit-1;
 690   assert(_out != NULL &amp;&amp; _out != NO_OUT_ARRAY, &quot;out must have sensible value&quot;);
 691   _out = (Node**)arena-&gt;Arealloc(_out,_outmax*sizeof(Node*),new_max*sizeof(Node*));
 692   //Copy::zero_to_bytes(&amp;_out[_outmax], (new_max-_outmax)*sizeof(Node*)); // NULL all new space
 693   _outmax = new_max;               // Record new max length
 694   // This assertion makes sure that Node::_max is wide enough to
 695   // represent the numerical value of new_max.
 696   assert(_outmax == new_max &amp;&amp; _outmax &gt; len, &quot;int width of _outmax is too small&quot;);
 697 }
 698 
 699 #ifdef ASSERT
 700 //------------------------------is_dead----------------------------------------
 701 bool Node::is_dead() const {
 702   // Mach and pinch point nodes may look like dead.
 703   if( is_top() || is_Mach() || (Opcode() == Op_Node &amp;&amp; _outcnt &gt; 0) )
 704     return false;
 705   for( uint i = 0; i &lt; _max; i++ )
 706     if( _in[i] != NULL )
 707       return false;
 708   dump();
 709   return true;
 710 }
 711 
 712 bool Node::is_reachable_from_root() const {
 713   ResourceMark rm;
 714   Unique_Node_List wq;
 715   wq.push((Node*)this);
 716   RootNode* root = Compile::current()-&gt;root();
 717   for (uint i = 0; i &lt; wq.size(); i++) {
 718     Node* m = wq.at(i);
 719     if (m == root) {
 720       return true;
 721     }
 722     for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 723       Node* u = m-&gt;fast_out(j);
 724       wq.push(u);
 725     }
 726   }
 727   return false;
 728 }
 729 #endif
 730 
 731 //------------------------------is_unreachable---------------------------------
 732 bool Node::is_unreachable(PhaseIterGVN &amp;igvn) const {
 733   assert(!is_Mach(), &quot;doesn&#39;t work with MachNodes&quot;);
 734   return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != NULL &amp;&amp; in(0)-&gt;is_top());
 735 }
 736 
 737 //------------------------------add_req----------------------------------------
 738 // Add a new required input at the end
 739 void Node::add_req( Node *n ) {
 740   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 741 
 742   // Look to see if I can move precedence down one without reallocating
 743   if( (_cnt &gt;= _max) || (in(_max-1) != NULL) )
 744     grow( _max+1 );
 745 
 746   // Find a precedence edge to move
 747   if( in(_cnt) != NULL ) {       // Next precedence edge is busy?
 748     uint i;
 749     for( i=_cnt; i&lt;_max; i++ )
 750       if( in(i) == NULL )       // Find the NULL at end of prec edge list
 751         break;                  // There must be one, since we grew the array
 752     _in[i] = in(_cnt);          // Move prec over, making space for req edge
 753   }
 754   _in[_cnt++] = n;            // Stuff over old prec edge
 755   if (n != NULL) n-&gt;add_out((Node *)this);
 756 }
 757 
 758 //---------------------------add_req_batch-------------------------------------
 759 // Add a new required input at the end
 760 void Node::add_req_batch( Node *n, uint m ) {
 761   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 762   // check various edge cases
 763   if ((int)m &lt;= 1) {
 764     assert((int)m &gt;= 0, &quot;oob&quot;);
 765     if (m != 0)  add_req(n);
 766     return;
 767   }
 768 
 769   // Look to see if I can move precedence down one without reallocating
 770   if( (_cnt+m) &gt; _max || _in[_max-m] )
 771     grow( _max+m );
 772 
 773   // Find a precedence edge to move
 774   if( _in[_cnt] != NULL ) {     // Next precedence edge is busy?
 775     uint i;
 776     for( i=_cnt; i&lt;_max; i++ )
 777       if( _in[i] == NULL )      // Find the NULL at end of prec edge list
 778         break;                  // There must be one, since we grew the array
 779     // Slide all the precs over by m positions (assume #prec &lt;&lt; m).
 780     Copy::conjoint_words_to_higher((HeapWord*)&amp;_in[_cnt], (HeapWord*)&amp;_in[_cnt+m], ((i-_cnt)*sizeof(Node*)));
 781   }
 782 
 783   // Stuff over the old prec edges
 784   for(uint i=0; i&lt;m; i++ ) {
 785     _in[_cnt++] = n;
 786   }
 787 
 788   // Insert multiple out edges on the node.
 789   if (n != NULL &amp;&amp; !n-&gt;is_top()) {
 790     for(uint i=0; i&lt;m; i++ ) {
 791       n-&gt;add_out((Node *)this);
 792     }
 793   }
 794 }
 795 
 796 //------------------------------del_req----------------------------------------
 797 // Delete the required edge and compact the edge array
 798 void Node::del_req( uint idx ) {
 799   assert( idx &lt; _cnt, &quot;oob&quot;);
 800   assert( !VerifyHashTableKeys || _hash_lock == 0,
 801           &quot;remove node from hash table before modifying it&quot;);
 802   // First remove corresponding def-use edge
 803   Node *n = in(idx);
 804   if (n != NULL) n-&gt;del_out((Node *)this);
 805   _in[idx] = in(--_cnt); // Compact the array
 806   // Avoid spec violation: Gap in prec edges.
 807   close_prec_gap_at(_cnt);
 808   Compile::current()-&gt;record_modified_node(this);
 809 }
 810 
 811 //------------------------------del_req_ordered--------------------------------
 812 // Delete the required edge and compact the edge array with preserved order
 813 void Node::del_req_ordered( uint idx ) {
 814   assert( idx &lt; _cnt, &quot;oob&quot;);
 815   assert( !VerifyHashTableKeys || _hash_lock == 0,
 816           &quot;remove node from hash table before modifying it&quot;);
 817   // First remove corresponding def-use edge
 818   Node *n = in(idx);
 819   if (n != NULL) n-&gt;del_out((Node *)this);
 820   if (idx &lt; --_cnt) {    // Not last edge ?
 821     Copy::conjoint_words_to_lower((HeapWord*)&amp;_in[idx+1], (HeapWord*)&amp;_in[idx], ((_cnt-idx)*sizeof(Node*)));
 822   }
 823   // Avoid spec violation: Gap in prec edges.
 824   close_prec_gap_at(_cnt);
 825   Compile::current()-&gt;record_modified_node(this);
 826 }
 827 
 828 //------------------------------ins_req----------------------------------------
 829 // Insert a new required input at the end
 830 void Node::ins_req( uint idx, Node *n ) {
 831   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 832   add_req(NULL);                // Make space
 833   assert( idx &lt; _max, &quot;Must have allocated enough space&quot;);
 834   // Slide over
 835   if(_cnt-idx-1 &gt; 0) {
 836     Copy::conjoint_words_to_higher((HeapWord*)&amp;_in[idx], (HeapWord*)&amp;_in[idx+1], ((_cnt-idx-1)*sizeof(Node*)));
 837   }
 838   _in[idx] = n;                            // Stuff over old required edge
 839   if (n != NULL) n-&gt;add_out((Node *)this); // Add reciprocal def-use edge
 840 }
 841 
 842 //-----------------------------find_edge---------------------------------------
 843 int Node::find_edge(Node* n) {
 844   for (uint i = 0; i &lt; len(); i++) {
 845     if (_in[i] == n)  return i;
 846   }
 847   return -1;
 848 }
 849 
 850 //----------------------------replace_edge-------------------------------------
 851 int Node::replace_edge(Node* old, Node* neww) {
 852   if (old == neww)  return 0;  // nothing to do
 853   uint nrep = 0;
 854   for (uint i = 0; i &lt; len(); i++) {
 855     if (in(i) == old) {
 856       if (i &lt; req()) {
 857         set_req(i, neww);
 858       } else {
 859         assert(find_prec_edge(neww) == -1, &quot;spec violation: duplicated prec edge (node %d -&gt; %d)&quot;, _idx, neww-&gt;_idx);
 860         set_prec(i, neww);
 861       }
 862       nrep++;
 863     }
 864   }
 865   return nrep;
 866 }
 867 
 868 /**
 869  * Replace input edges in the range pointing to &#39;old&#39; node.
 870  */
 871 int Node::replace_edges_in_range(Node* old, Node* neww, int start, int end) {
 872   if (old == neww)  return 0;  // nothing to do
 873   uint nrep = 0;
 874   for (int i = start; i &lt; end; i++) {
 875     if (in(i) == old) {
 876       set_req(i, neww);
 877       nrep++;
 878     }
 879   }
 880   return nrep;
 881 }
 882 
 883 //-------------------------disconnect_inputs-----------------------------------
 884 // NULL out all inputs to eliminate incoming Def-Use edges.
 885 // Return the number of edges between &#39;n&#39; and &#39;this&#39;
 886 int Node::disconnect_inputs(Node *n, Compile* C) {
 887   int edges_to_n = 0;
 888 
 889   uint cnt = req();
 890   for( uint i = 0; i &lt; cnt; ++i ) {
 891     if( in(i) == 0 ) continue;
 892     if( in(i) == n ) ++edges_to_n;
 893     set_req(i, NULL);
 894   }
 895   // Remove precedence edges if any exist
 896   // Note: Safepoints may have precedence edges, even during parsing
 897   if( (req() != len()) &amp;&amp; (in(req()) != NULL) ) {
 898     uint max = len();
 899     for( uint i = 0; i &lt; max; ++i ) {
 900       if( in(i) == 0 ) continue;
 901       if( in(i) == n ) ++edges_to_n;
 902       set_prec(i, NULL);
 903     }
 904   }
 905 
 906   // Node::destruct requires all out edges be deleted first
 907   // debug_only(destruct();)   // no reuse benefit expected
 908   if (edges_to_n == 0) {
 909     C-&gt;record_dead_node(_idx);
 910   }
 911   return edges_to_n;
 912 }
 913 
 914 //-----------------------------uncast---------------------------------------
 915 // %%% Temporary, until we sort out CheckCastPP vs. CastPP.
 916 // Strip away casting.  (It is depth-limited.)
 917 // Optionally, keep casts with dependencies.
 918 Node* Node::uncast(bool keep_deps) const {
 919   // Should be inline:
 920   //return is_ConstraintCast() ? uncast_helper(this) : (Node*) this;
 921   if (is_ConstraintCast()) {
 922     return uncast_helper(this, keep_deps);
 923   } else {
 924     return (Node*) this;
 925   }
 926 }
 927 
 928 // Find out of current node that matches opcode.
 929 Node* Node::find_out_with(int opcode) {
 930   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 931     Node* use = fast_out(i);
 932     if (use-&gt;Opcode() == opcode) {
 933       return use;
 934     }
 935   }
 936   return NULL;
 937 }
 938 
 939 // Return true if the current node has an out that matches opcode.
 940 bool Node::has_out_with(int opcode) {
 941   return (find_out_with(opcode) != NULL);
 942 }
 943 
 944 // Return true if the current node has an out that matches any of the opcodes.
 945 bool Node::has_out_with(int opcode1, int opcode2, int opcode3, int opcode4) {
 946   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 947       int opcode = fast_out(i)-&gt;Opcode();
 948       if (opcode == opcode1 || opcode == opcode2 || opcode == opcode3 || opcode == opcode4) {
 949         return true;
 950       }
 951   }
 952   return false;
 953 }
 954 
 955 
 956 //---------------------------uncast_helper-------------------------------------
 957 Node* Node::uncast_helper(const Node* p, bool keep_deps) {
 958 #ifdef ASSERT
 959   uint depth_count = 0;
 960   const Node* orig_p = p;
 961 #endif
 962 
 963   while (true) {
 964 #ifdef ASSERT
 965     if (depth_count &gt;= K) {
 966       orig_p-&gt;dump(4);
 967       if (p != orig_p)
 968         p-&gt;dump(1);
 969     }
 970     assert(depth_count++ &lt; K, &quot;infinite loop in Node::uncast_helper&quot;);
 971 #endif
 972     if (p == NULL || p-&gt;req() != 2) {
 973       break;
 974     } else if (p-&gt;is_ConstraintCast()) {
 975       if (keep_deps &amp;&amp; p-&gt;as_ConstraintCast()-&gt;carry_dependency()) {
 976         break; // stop at casts with dependencies
 977       }
 978       p = p-&gt;in(1);
 979     } else {
 980       break;
 981     }
 982   }
 983   return (Node*) p;
 984 }
 985 
 986 //------------------------------add_prec---------------------------------------
 987 // Add a new precedence input.  Precedence inputs are unordered, with
 988 // duplicates removed and NULLs packed down at the end.
 989 void Node::add_prec( Node *n ) {
 990   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 991 
 992   // Check for NULL at end
 993   if( _cnt &gt;= _max || in(_max-1) )
 994     grow( _max+1 );
 995 
 996   // Find a precedence edge to move
 997   uint i = _cnt;
 998   while( in(i) != NULL ) {
 999     if (in(i) == n) return; // Avoid spec violation: duplicated prec edge.
1000     i++;
1001   }
1002   _in[i] = n;                                // Stuff prec edge over NULL
1003   if ( n != NULL) n-&gt;add_out((Node *)this);  // Add mirror edge
1004 
1005 #ifdef ASSERT
1006   while ((++i)&lt;_max) { assert(_in[i] == NULL, &quot;spec violation: Gap in prec edges (node %d)&quot;, _idx); }
1007 #endif
1008 }
1009 
1010 //------------------------------rm_prec----------------------------------------
1011 // Remove a precedence input.  Precedence inputs are unordered, with
1012 // duplicates removed and NULLs packed down at the end.
1013 void Node::rm_prec( uint j ) {
1014   assert(j &lt; _max, &quot;oob: i=%d, _max=%d&quot;, j, _max);
1015   assert(j &gt;= _cnt, &quot;not a precedence edge&quot;);
1016   if (_in[j] == NULL) return;   // Avoid spec violation: Gap in prec edges.
1017   _in[j]-&gt;del_out((Node *)this);
1018   close_prec_gap_at(j);
1019 }
1020 
1021 //------------------------------size_of----------------------------------------
1022 uint Node::size_of() const { return sizeof(*this); }
1023 
1024 //------------------------------ideal_reg--------------------------------------
1025 uint Node::ideal_reg() const { return 0; }
1026 
1027 //------------------------------jvms-------------------------------------------
1028 JVMState* Node::jvms() const { return NULL; }
1029 
1030 #ifdef ASSERT
1031 //------------------------------jvms-------------------------------------------
1032 bool Node::verify_jvms(const JVMState* using_jvms) const {
1033   for (JVMState* jvms = this-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {
1034     if (jvms == using_jvms)  return true;
1035   }
1036   return false;
1037 }
1038 
1039 //------------------------------init_NodeProperty------------------------------
1040 void Node::init_NodeProperty() {
1041   assert(_max_classes &lt;= max_jushort, &quot;too many NodeProperty classes&quot;);
1042   assert(_max_flags &lt;= max_jushort, &quot;too many NodeProperty flags&quot;);
1043 }
1044 #endif
1045 
1046 //------------------------------format-----------------------------------------
1047 // Print as assembly
1048 void Node::format( PhaseRegAlloc *, outputStream *st ) const {}
1049 //------------------------------emit-------------------------------------------
1050 // Emit bytes starting at parameter &#39;ptr&#39;.
1051 void Node::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {}
1052 //------------------------------size-------------------------------------------
1053 // Size of instruction in bytes
1054 uint Node::size(PhaseRegAlloc *ra_) const { return 0; }
1055 
1056 //------------------------------CFG Construction-------------------------------
1057 // Nodes that end basic blocks, e.g. IfTrue/IfFalse, JumpProjNode, Root,
1058 // Goto and Return.
1059 const Node *Node::is_block_proj() const { return 0; }
1060 
1061 // Minimum guaranteed type
1062 const Type *Node::bottom_type() const { return Type::BOTTOM; }
1063 
1064 
1065 //------------------------------raise_bottom_type------------------------------
1066 // Get the worst-case Type output for this Node.
1067 void Node::raise_bottom_type(const Type* new_type) {
1068   if (is_Type()) {
1069     TypeNode *n = this-&gt;as_Type();
1070     if (VerifyAliases) {
1071       assert(new_type-&gt;higher_equal_speculative(n-&gt;type()), &quot;new type must refine old type&quot;);
1072     }
1073     n-&gt;set_type(new_type);
1074   } else if (is_Load()) {
1075     LoadNode *n = this-&gt;as_Load();
1076     if (VerifyAliases) {
1077       assert(new_type-&gt;higher_equal_speculative(n-&gt;type()), &quot;new type must refine old type&quot;);
1078     }
1079     n-&gt;set_type(new_type);
1080   }
1081 }
1082 
1083 //------------------------------Identity---------------------------------------
1084 // Return a node that the given node is equivalent to.
1085 Node* Node::Identity(PhaseGVN* phase) {
1086   return this;                  // Default to no identities
1087 }
1088 
1089 //------------------------------Value------------------------------------------
1090 // Compute a new Type for a node using the Type of the inputs.
1091 const Type* Node::Value(PhaseGVN* phase) const {
1092   return bottom_type();         // Default to worst-case Type
1093 }
1094 
1095 //------------------------------Ideal------------------------------------------
1096 //
1097 // &#39;Idealize&#39; the graph rooted at this Node.
1098 //
1099 // In order to be efficient and flexible there are some subtle invariants
1100 // these Ideal calls need to hold.  Running with &#39;+VerifyIterativeGVN&#39; checks
1101 // these invariants, although its too slow to have on by default.  If you are
1102 // hacking an Ideal call, be sure to test with +VerifyIterativeGVN!
1103 //
1104 // The Ideal call almost arbitrarily reshape the graph rooted at the &#39;this&#39;
1105 // pointer.  If ANY change is made, it must return the root of the reshaped
1106 // graph - even if the root is the same Node.  Example: swapping the inputs
1107 // to an AddINode gives the same answer and same root, but you still have to
1108 // return the &#39;this&#39; pointer instead of NULL.
1109 //
1110 // You cannot return an OLD Node, except for the &#39;this&#39; pointer.  Use the
1111 // Identity call to return an old Node; basically if Identity can find
1112 // another Node have the Ideal call make no change and return NULL.
1113 // Example: AddINode::Ideal must check for add of zero; in this case it
1114 // returns NULL instead of doing any graph reshaping.
1115 //
1116 // You cannot modify any old Nodes except for the &#39;this&#39; pointer.  Due to
1117 // sharing there may be other users of the old Nodes relying on their current
1118 // semantics.  Modifying them will break the other users.
1119 // Example: when reshape &quot;(X+3)+4&quot; into &quot;X+7&quot; you must leave the Node for
1120 // &quot;X+3&quot; unchanged in case it is shared.
1121 //
1122 // If you modify the &#39;this&#39; pointer&#39;s inputs, you should use
1123 // &#39;set_req&#39;.  If you are making a new Node (either as the new root or
1124 // some new internal piece) you may use &#39;init_req&#39; to set the initial
1125 // value.  You can make a new Node with either &#39;new&#39; or &#39;clone&#39;.  In
1126 // either case, def-use info is correctly maintained.
1127 //
1128 // Example: reshape &quot;(X+3)+4&quot; into &quot;X+7&quot;:
1129 //    set_req(1, in(1)-&gt;in(1));
1130 //    set_req(2, phase-&gt;intcon(7));
1131 //    return this;
1132 // Example: reshape &quot;X*4&quot; into &quot;X&lt;&lt;2&quot;
1133 //    return new LShiftINode(in(1), phase-&gt;intcon(2));
1134 //
1135 // You must call &#39;phase-&gt;transform(X)&#39; on any new Nodes X you make, except
1136 // for the returned root node.  Example: reshape &quot;X*31&quot; with &quot;(X&lt;&lt;5)-X&quot;.
1137 //    Node *shift=phase-&gt;transform(new LShiftINode(in(1),phase-&gt;intcon(5)));
1138 //    return new AddINode(shift, in(1));
1139 //
1140 // When making a Node for a constant use &#39;phase-&gt;makecon&#39; or &#39;phase-&gt;intcon&#39;.
1141 // These forms are faster than &#39;phase-&gt;transform(new ConNode())&#39; and Do
1142 // The Right Thing with def-use info.
1143 //
1144 // You cannot bury the &#39;this&#39; Node inside of a graph reshape.  If the reshaped
1145 // graph uses the &#39;this&#39; Node it must be the root.  If you want a Node with
1146 // the same Opcode as the &#39;this&#39; pointer use &#39;clone&#39;.
1147 //
1148 Node *Node::Ideal(PhaseGVN *phase, bool can_reshape) {
1149   return NULL;                  // Default to being Ideal already
1150 }
1151 
1152 // Some nodes have specific Ideal subgraph transformations only if they are
1153 // unique users of specific nodes. Such nodes should be put on IGVN worklist
1154 // for the transformations to happen.
1155 bool Node::has_special_unique_user() const {
1156   assert(outcnt() == 1, &quot;match only for unique out&quot;);
1157   Node* n = unique_out();
1158   int op  = Opcode();
1159   if (this-&gt;is_Store()) {
1160     // Condition for back-to-back stores folding.
1161     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(MemNode::Memory) == this;
1162   } else if (this-&gt;is_Load() || this-&gt;is_DecodeN() || this-&gt;is_Phi()) {
1163     // Condition for removing an unused LoadNode or DecodeNNode from the MemBarAcquire precedence input
1164     return n-&gt;Opcode() == Op_MemBarAcquire;
1165   } else if (op == Op_AddL) {
1166     // Condition for convL2I(addL(x,y)) ==&gt; addI(convL2I(x),convL2I(y))
1167     return n-&gt;Opcode() == Op_ConvL2I &amp;&amp; n-&gt;in(1) == this;
1168   } else if (op == Op_SubI || op == Op_SubL) {
1169     // Condition for subI(x,subI(y,z)) ==&gt; subI(addI(x,z),y)
1170     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(2) == this;
1171   } else if (is_If() &amp;&amp; (n-&gt;is_IfFalse() || n-&gt;is_IfTrue())) {
1172     // See IfProjNode::Identity()
1173     return true;
1174   } else {
1175     return false;
1176   }
1177 };
1178 
1179 //--------------------------find_exact_control---------------------------------
1180 // Skip Proj and CatchProj nodes chains. Check for Null and Top.
1181 Node* Node::find_exact_control(Node* ctrl) {
1182   if (ctrl == NULL &amp;&amp; this-&gt;is_Region())
1183     ctrl = this-&gt;as_Region()-&gt;is_copy();
1184 
1185   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_CatchProj()) {
1186     if (ctrl-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index)
1187       ctrl = ctrl-&gt;in(0);
1188     if (ctrl != NULL &amp;&amp; !ctrl-&gt;is_top())
1189       ctrl = ctrl-&gt;in(0);
1190   }
1191 
1192   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_Proj())
1193     ctrl = ctrl-&gt;in(0);
1194 
1195   return ctrl;
1196 }
1197 
1198 //--------------------------dominates------------------------------------------
1199 // Helper function for MemNode::all_controls_dominate().
1200 // Check if &#39;this&#39; control node dominates or equal to &#39;sub&#39; control node.
1201 // We already know that if any path back to Root or Start reaches &#39;this&#39;,
1202 // then all paths so, so this is a simple search for one example,
1203 // not an exhaustive search for a counterexample.
1204 bool Node::dominates(Node* sub, Node_List &amp;nlist) {
1205   assert(this-&gt;is_CFG(), &quot;expecting control&quot;);
1206   assert(sub != NULL &amp;&amp; sub-&gt;is_CFG(), &quot;expecting control&quot;);
1207 
1208   // detect dead cycle without regions
1209   int iterations_without_region_limit = DominatorSearchLimit;
1210 
1211   Node* orig_sub = sub;
1212   Node* dom      = this;
1213   bool  met_dom  = false;
1214   nlist.clear();
1215 
1216   // Walk &#39;sub&#39; backward up the chain to &#39;dom&#39;, watching for regions.
1217   // After seeing &#39;dom&#39;, continue up to Root or Start.
1218   // If we hit a region (backward split point), it may be a loop head.
1219   // Keep going through one of the region&#39;s inputs.  If we reach the
1220   // same region again, go through a different input.  Eventually we
1221   // will either exit through the loop head, or give up.
1222   // (If we get confused, break out and return a conservative &#39;false&#39;.)
1223   while (sub != NULL) {
1224     if (sub-&gt;is_top())  break; // Conservative answer for dead code.
1225     if (sub == dom) {
1226       if (nlist.size() == 0) {
1227         // No Region nodes except loops were visited before and the EntryControl
1228         // path was taken for loops: it did not walk in a cycle.
1229         return true;
1230       } else if (met_dom) {
1231         break;          // already met before: walk in a cycle
1232       } else {
1233         // Region nodes were visited. Continue walk up to Start or Root
1234         // to make sure that it did not walk in a cycle.
1235         met_dom = true; // first time meet
1236         iterations_without_region_limit = DominatorSearchLimit; // Reset
1237      }
1238     }
1239     if (sub-&gt;is_Start() || sub-&gt;is_Root()) {
1240       // Success if we met &#39;dom&#39; along a path to Start or Root.
1241       // We assume there are no alternative paths that avoid &#39;dom&#39;.
1242       // (This assumption is up to the caller to ensure!)
1243       return met_dom;
1244     }
1245     Node* up = sub-&gt;in(0);
1246     // Normalize simple pass-through regions and projections:
1247     up = sub-&gt;find_exact_control(up);
1248     // If sub == up, we found a self-loop.  Try to push past it.
1249     if (sub == up &amp;&amp; sub-&gt;is_Loop()) {
1250       // Take loop entry path on the way up to &#39;dom&#39;.
1251       up = sub-&gt;in(1); // in(LoopNode::EntryControl);
1252     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() == 2) {
1253       // Take in(1) path on the way up to &#39;dom&#39; for regions with only one input
1254       up = sub-&gt;in(1);
1255     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() == 3) {
1256       // Try both paths for Regions with 2 input paths (it may be a loop head).
1257       // It could give conservative &#39;false&#39; answer without information
1258       // which region&#39;s input is the entry path.
1259       iterations_without_region_limit = DominatorSearchLimit; // Reset
1260 
1261       bool region_was_visited_before = false;
1262       // Was this Region node visited before?
1263       // If so, we have reached it because we accidentally took a
1264       // loop-back edge from &#39;sub&#39; back into the body of the loop,
1265       // and worked our way up again to the loop header &#39;sub&#39;.
1266       // So, take the first unexplored path on the way up to &#39;dom&#39;.
1267       for (int j = nlist.size() - 1; j &gt;= 0; j--) {
1268         intptr_t ni = (intptr_t)nlist.at(j);
1269         Node* visited = (Node*)(ni &amp; ~1);
1270         bool  visited_twice_already = ((ni &amp; 1) != 0);
1271         if (visited == sub) {
1272           if (visited_twice_already) {
1273             // Visited 2 paths, but still stuck in loop body.  Give up.
1274             return false;
1275           }
1276           // The Region node was visited before only once.
1277           // (We will repush with the low bit set, below.)
1278           nlist.remove(j);
1279           // We will find a new edge and re-insert.
1280           region_was_visited_before = true;
1281           break;
1282         }
1283       }
1284 
1285       // Find an incoming edge which has not been seen yet; walk through it.
1286       assert(up == sub, &quot;&quot;);
1287       uint skip = region_was_visited_before ? 1 : 0;
1288       for (uint i = 1; i &lt; sub-&gt;req(); i++) {
1289         Node* in = sub-&gt;in(i);
1290         if (in != NULL &amp;&amp; !in-&gt;is_top() &amp;&amp; in != sub) {
1291           if (skip == 0) {
1292             up = in;
1293             break;
1294           }
1295           --skip;               // skip this nontrivial input
1296         }
1297       }
1298 
1299       // Set 0 bit to indicate that both paths were taken.
1300       nlist.push((Node*)((intptr_t)sub + (region_was_visited_before ? 1 : 0)));
1301     }
1302 
1303     if (up == sub) {
1304       break;    // some kind of tight cycle
1305     }
1306     if (up == orig_sub &amp;&amp; met_dom) {
1307       // returned back after visiting &#39;dom&#39;
1308       break;    // some kind of cycle
1309     }
1310     if (--iterations_without_region_limit &lt; 0) {
1311       break;    // dead cycle
1312     }
1313     sub = up;
1314   }
1315 
1316   // Did not meet Root or Start node in pred. chain.
1317   // Conservative answer for dead code.
1318   return false;
1319 }
1320 
1321 //------------------------------remove_dead_region-----------------------------
1322 // This control node is dead.  Follow the subgraph below it making everything
1323 // using it dead as well.  This will happen normally via the usual IterGVN
1324 // worklist but this call is more efficient.  Do not update use-def info
1325 // inside the dead region, just at the borders.
1326 static void kill_dead_code( Node *dead, PhaseIterGVN *igvn ) {
1327   // Con&#39;s are a popular node to re-hit in the hash table again.
1328   if( dead-&gt;is_Con() ) return;
1329 
1330   ResourceMark rm;
1331   Node_List  nstack(Thread::current()-&gt;resource_area());
1332 
1333   Node *top = igvn-&gt;C-&gt;top();
1334   nstack.push(dead);
1335   bool has_irreducible_loop = igvn-&gt;C-&gt;has_irreducible_loop();
1336 
1337   while (nstack.size() &gt; 0) {
1338     dead = nstack.pop();
1339     if (dead-&gt;Opcode() == Op_SafePoint) {
1340       dead-&gt;as_SafePoint()-&gt;disconnect_from_root(igvn);
1341     }
1342     if (dead-&gt;outcnt() &gt; 0) {
1343       // Keep dead node on stack until all uses are processed.
1344       nstack.push(dead);
1345       // For all Users of the Dead...    ;-)
1346       for (DUIterator_Last kmin, k = dead-&gt;last_outs(kmin); k &gt;= kmin; ) {
1347         Node* use = dead-&gt;last_out(k);
1348         igvn-&gt;hash_delete(use);       // Yank from hash table prior to mod
1349         if (use-&gt;in(0) == dead) {     // Found another dead node
1350           assert (!use-&gt;is_Con(), &quot;Control for Con node should be Root node.&quot;);
1351           use-&gt;set_req(0, top);       // Cut dead edge to prevent processing
1352           nstack.push(use);           // the dead node again.
1353         } else if (!has_irreducible_loop &amp;&amp; // Backedge could be alive in irreducible loop
1354                    use-&gt;is_Loop() &amp;&amp; !use-&gt;is_Root() &amp;&amp;       // Don&#39;t kill Root (RootNode extends LoopNode)
1355                    use-&gt;in(LoopNode::EntryControl) == dead) { // Dead loop if its entry is dead
1356           use-&gt;set_req(LoopNode::EntryControl, top);          // Cut dead edge to prevent processing
1357           use-&gt;set_req(0, top);       // Cut self edge
1358           nstack.push(use);
1359         } else {                      // Else found a not-dead user
1360           // Dead if all inputs are top or null
1361           bool dead_use = !use-&gt;is_Root(); // Keep empty graph alive
1362           for (uint j = 1; j &lt; use-&gt;req(); j++) {
1363             Node* in = use-&gt;in(j);
1364             if (in == dead) {         // Turn all dead inputs into TOP
1365               use-&gt;set_req(j, top);
1366             } else if (in != NULL &amp;&amp; !in-&gt;is_top()) {
1367               dead_use = false;
1368             }
1369           }
1370           if (dead_use) {
1371             if (use-&gt;is_Region()) {
1372               use-&gt;set_req(0, top);   // Cut self edge
1373             }
1374             nstack.push(use);
1375           } else {
1376             igvn-&gt;_worklist.push(use);
1377           }
1378         }
1379         // Refresh the iterator, since any number of kills might have happened.
1380         k = dead-&gt;last_outs(kmin);
1381       }
1382     } else { // (dead-&gt;outcnt() == 0)
1383       // Done with outputs.
1384       igvn-&gt;hash_delete(dead);
1385       igvn-&gt;_worklist.remove(dead);
1386       igvn-&gt;C-&gt;remove_modified_node(dead);
1387       igvn-&gt;set_type(dead, Type::TOP);
1388       if (dead-&gt;is_macro()) {
1389         igvn-&gt;C-&gt;remove_macro_node(dead);
1390       }
1391       if (dead-&gt;is_expensive()) {
1392         igvn-&gt;C-&gt;remove_expensive_node(dead);
1393       }
1394       CastIINode* cast = dead-&gt;isa_CastII();
1395       if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
1396         igvn-&gt;C-&gt;remove_range_check_cast(cast);
1397       }
1398       if (dead-&gt;Opcode() == Op_Opaque4) {
1399         igvn-&gt;C-&gt;remove_opaque4_node(dead);
1400       }
1401       if (dead-&gt;is_ValueTypeBase()) {
1402         igvn-&gt;C-&gt;remove_value_type(dead);
1403       }
1404       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1405       bs-&gt;unregister_potential_barrier_node(dead);
1406       igvn-&gt;C-&gt;record_dead_node(dead-&gt;_idx);
1407       // Kill all inputs to the dead guy
1408       for (uint i=0; i &lt; dead-&gt;req(); i++) {
1409         Node *n = dead-&gt;in(i);      // Get input to dead guy
1410         if (n != NULL &amp;&amp; !n-&gt;is_top()) { // Input is valid?
1411           dead-&gt;set_req(i, top);    // Smash input away
1412           if (n-&gt;outcnt() == 0) {   // Input also goes dead?
1413             if (!n-&gt;is_Con())
1414               nstack.push(n);       // Clear it out as well
1415           } else if (n-&gt;outcnt() == 1 &amp;&amp;
1416                      n-&gt;has_special_unique_user()) {
1417             igvn-&gt;add_users_to_worklist( n );
1418           } else if (n-&gt;outcnt() &lt;= 2 &amp;&amp; n-&gt;is_Store()) {
1419             // Push store&#39;s uses on worklist to enable folding optimization for
1420             // store/store and store/load to the same address.
1421             // The restriction (outcnt() &lt;= 2) is the same as in set_req_X()
1422             // and remove_globally_dead_node().
1423             igvn-&gt;add_users_to_worklist( n );
1424           } else {
1425             BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;enqueue_useful_gc_barrier(igvn, n);
1426           }
1427         }
1428       }
1429     } // (dead-&gt;outcnt() == 0)
1430   }   // while (nstack.size() &gt; 0) for outputs
1431   return;
1432 }
1433 
1434 //------------------------------remove_dead_region-----------------------------
1435 bool Node::remove_dead_region(PhaseGVN *phase, bool can_reshape) {
1436   Node *n = in(0);
1437   if( !n ) return false;
1438   // Lost control into this guy?  I.e., it became unreachable?
1439   // Aggressively kill all unreachable code.
1440   if (can_reshape &amp;&amp; n-&gt;is_top()) {
1441     kill_dead_code(this, phase-&gt;is_IterGVN());
1442     return false; // Node is dead.
1443   }
1444 
1445   if( n-&gt;is_Region() &amp;&amp; n-&gt;as_Region()-&gt;is_copy() ) {
1446     Node *m = n-&gt;nonnull_req();
1447     set_req(0, m);
1448     return true;
1449   }
1450   return false;
1451 }
1452 
1453 //------------------------------hash-------------------------------------------
1454 // Hash function over Nodes.
1455 uint Node::hash() const {
1456   uint sum = 0;
1457   for( uint i=0; i&lt;_cnt; i++ )  // Add in all inputs
1458     sum = (sum&lt;&lt;1)-(uintptr_t)in(i);        // Ignore embedded NULLs
1459   return (sum&gt;&gt;2) + _cnt + Opcode();
1460 }
1461 
1462 //------------------------------cmp--------------------------------------------
1463 // Compare special parts of simple Nodes
1464 bool Node::cmp( const Node &amp;n ) const {
1465   return true;                  // Must be same
1466 }
1467 
1468 //------------------------------rematerialize-----------------------------------
1469 // Should we clone rather than spill this instruction?
1470 bool Node::rematerialize() const {
1471   if ( is_Mach() )
1472     return this-&gt;as_Mach()-&gt;rematerialize();
1473   else
1474     return (_flags &amp; Flag_rematerialize) != 0;
1475 }
1476 
1477 //------------------------------needs_anti_dependence_check---------------------
1478 // Nodes which use memory without consuming it, hence need antidependences.
1479 bool Node::needs_anti_dependence_check() const {
1480   if (req() &lt; 2 || (_flags &amp; Flag_needs_anti_dependence_check) == 0) {
1481     return false;
1482   }
1483   return in(1)-&gt;bottom_type()-&gt;has_memory();
1484 }
1485 
1486 // Get an integer constant from a ConNode (or CastIINode).
1487 // Return a default value if there is no apparent constant here.
1488 const TypeInt* Node::find_int_type() const {
1489   if (this-&gt;is_Type()) {
1490     return this-&gt;as_Type()-&gt;type()-&gt;isa_int();
1491   } else if (this-&gt;is_Con()) {
1492     assert(is_Mach(), &quot;should be ConNode(TypeNode) or else a MachNode&quot;);
1493     return this-&gt;bottom_type()-&gt;isa_int();
1494   }
1495   return NULL;
1496 }
1497 
1498 // Get a pointer constant from a ConstNode.
1499 // Returns the constant if it is a pointer ConstNode
1500 intptr_t Node::get_ptr() const {
1501   assert( Opcode() == Op_ConP, &quot;&quot; );
1502   return ((ConPNode*)this)-&gt;type()-&gt;is_ptr()-&gt;get_con();
1503 }
1504 
1505 // Get a narrow oop constant from a ConNNode.
1506 intptr_t Node::get_narrowcon() const {
1507   assert( Opcode() == Op_ConN, &quot;&quot; );
1508   return ((ConNNode*)this)-&gt;type()-&gt;is_narrowoop()-&gt;get_con();
1509 }
1510 
1511 // Get a long constant from a ConNode.
1512 // Return a default value if there is no apparent constant here.
1513 const TypeLong* Node::find_long_type() const {
1514   if (this-&gt;is_Type()) {
1515     return this-&gt;as_Type()-&gt;type()-&gt;isa_long();
1516   } else if (this-&gt;is_Con()) {
1517     assert(is_Mach(), &quot;should be ConNode(TypeNode) or else a MachNode&quot;);
1518     return this-&gt;bottom_type()-&gt;isa_long();
1519   }
1520   return NULL;
1521 }
1522 
1523 
1524 /**
1525  * Return a ptr type for nodes which should have it.
1526  */
1527 const TypePtr* Node::get_ptr_type() const {
1528   const TypePtr* tp = this-&gt;bottom_type()-&gt;make_ptr();
1529 #ifdef ASSERT
1530   if (tp == NULL) {
1531     this-&gt;dump(1);
1532     assert((tp != NULL), &quot;unexpected node type&quot;);
1533   }
1534 #endif
1535   return tp;
1536 }
1537 
1538 // Get a double constant from a ConstNode.
1539 // Returns the constant if it is a double ConstNode
1540 jdouble Node::getd() const {
1541   assert( Opcode() == Op_ConD, &quot;&quot; );
1542   return ((ConDNode*)this)-&gt;type()-&gt;is_double_constant()-&gt;getd();
1543 }
1544 
1545 // Get a float constant from a ConstNode.
1546 // Returns the constant if it is a float ConstNode
1547 jfloat Node::getf() const {
1548   assert( Opcode() == Op_ConF, &quot;&quot; );
1549   return ((ConFNode*)this)-&gt;type()-&gt;is_float_constant()-&gt;getf();
1550 }
1551 
1552 #ifndef PRODUCT
1553 
1554 //------------------------------find------------------------------------------
1555 // Find a neighbor of this Node with the given _idx
1556 // If idx is negative, find its absolute value, following both _in and _out.
1557 static void find_recur(Compile* C,  Node* &amp;result, Node *n, int idx, bool only_ctrl,
1558                         VectorSet* old_space, VectorSet* new_space ) {
1559   int node_idx = (idx &gt;= 0) ? idx : -idx;
1560   if (NotANode(n))  return;  // Gracefully handle NULL, -1, 0xabababab, etc.
1561   // Contained in new_space or old_space?   Check old_arena first since it&#39;s mostly empty.
1562   VectorSet *v = C-&gt;old_arena()-&gt;contains(n) ? old_space : new_space;
1563   if( v-&gt;test(n-&gt;_idx) ) return;
1564   if( (int)n-&gt;_idx == node_idx
1565       debug_only(|| n-&gt;debug_idx() == node_idx) ) {
1566     if (result != NULL)
1567       tty-&gt;print(&quot;find: &quot; INTPTR_FORMAT &quot; and &quot; INTPTR_FORMAT &quot; both have idx==%d\n&quot;,
1568                  (uintptr_t)result, (uintptr_t)n, node_idx);
1569     result = n;
1570   }
1571   v-&gt;set(n-&gt;_idx);
1572   for( uint i=0; i&lt;n-&gt;len(); i++ ) {
1573     if( only_ctrl &amp;&amp; !(n-&gt;is_Region()) &amp;&amp; (n-&gt;Opcode() != Op_Root) &amp;&amp; (i != TypeFunc::Control) ) continue;
1574     find_recur(C, result, n-&gt;in(i), idx, only_ctrl, old_space, new_space );
1575   }
1576   // Search along forward edges also:
1577   if (idx &lt; 0 &amp;&amp; !only_ctrl) {
1578     for( uint j=0; j&lt;n-&gt;outcnt(); j++ ) {
1579       find_recur(C, result, n-&gt;raw_out(j), idx, only_ctrl, old_space, new_space );
1580     }
1581   }
1582 #ifdef ASSERT
1583   // Search along debug_orig edges last, checking for cycles
1584   Node* orig = n-&gt;debug_orig();
1585   if (orig != NULL) {
1586     do {
1587       if (NotANode(orig))  break;
1588       find_recur(C, result, orig, idx, only_ctrl, old_space, new_space );
1589       orig = orig-&gt;debug_orig();
1590     } while (orig != NULL &amp;&amp; orig != n-&gt;debug_orig());
1591   }
1592 #endif //ASSERT
1593 }
1594 
1595 // call this from debugger:
1596 Node* find_node(Node* n, int idx) {
1597   return n-&gt;find(idx);
1598 }
1599 
1600 //------------------------------find-------------------------------------------
1601 Node* Node::find(int idx) const {
1602   ResourceArea *area = Thread::current()-&gt;resource_area();
1603   VectorSet old_space(area), new_space(area);
1604   Node* result = NULL;
1605   find_recur(Compile::current(), result, (Node*) this, idx, false, &amp;old_space, &amp;new_space );
1606   return result;
1607 }
1608 
1609 //------------------------------find_ctrl--------------------------------------
1610 // Find an ancestor to this node in the control history with given _idx
1611 Node* Node::find_ctrl(int idx) const {
1612   ResourceArea *area = Thread::current()-&gt;resource_area();
1613   VectorSet old_space(area), new_space(area);
1614   Node* result = NULL;
1615   find_recur(Compile::current(), result, (Node*) this, idx, true, &amp;old_space, &amp;new_space );
1616   return result;
1617 }
1618 #endif
1619 
1620 
1621 
1622 #ifndef PRODUCT
1623 
1624 // -----------------------------Name-------------------------------------------
1625 extern const char *NodeClassNames[];
1626 const char *Node::Name() const { return NodeClassNames[Opcode()]; }
1627 
1628 static bool is_disconnected(const Node* n) {
1629   for (uint i = 0; i &lt; n-&gt;req(); i++) {
1630     if (n-&gt;in(i) != NULL)  return false;
1631   }
1632   return true;
1633 }
1634 
1635 #ifdef ASSERT
1636 void Node::dump_orig(outputStream *st, bool print_key) const {
1637   Compile* C = Compile::current();
1638   Node* orig = _debug_orig;
1639   if (NotANode(orig)) orig = NULL;
1640   if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1641   if (orig == NULL) return;
1642   if (print_key) {
1643     st-&gt;print(&quot; !orig=&quot;);
1644   }
1645   Node* fast = orig-&gt;debug_orig(); // tortoise &amp; hare algorithm to detect loops
1646   if (NotANode(fast)) fast = NULL;
1647   while (orig != NULL) {
1648     bool discon = is_disconnected(orig);  // if discon, print [123] else 123
1649     if (discon) st-&gt;print(&quot;[&quot;);
1650     if (!Compile::current()-&gt;node_arena()-&gt;contains(orig))
1651       st-&gt;print(&quot;o&quot;);
1652     st-&gt;print(&quot;%d&quot;, orig-&gt;_idx);
1653     if (discon) st-&gt;print(&quot;]&quot;);
1654     orig = orig-&gt;debug_orig();
1655     if (NotANode(orig)) orig = NULL;
1656     if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1657     if (orig != NULL) st-&gt;print(&quot;,&quot;);
1658     if (fast != NULL) {
1659       // Step fast twice for each single step of orig:
1660       fast = fast-&gt;debug_orig();
1661       if (NotANode(fast)) fast = NULL;
1662       if (fast != NULL &amp;&amp; fast != orig) {
1663         fast = fast-&gt;debug_orig();
1664         if (NotANode(fast)) fast = NULL;
1665       }
1666       if (fast == orig) {
1667         st-&gt;print(&quot;...&quot;);
1668         break;
1669       }
1670     }
1671   }
1672 }
1673 
1674 void Node::set_debug_orig(Node* orig) {
1675   _debug_orig = orig;
1676   if (BreakAtNode == 0)  return;
1677   if (NotANode(orig))  orig = NULL;
1678   int trip = 10;
1679   while (orig != NULL) {
1680     if (orig-&gt;debug_idx() == BreakAtNode || (int)orig-&gt;_idx == BreakAtNode) {
1681       tty-&gt;print_cr(&quot;BreakAtNode: _idx=%d _debug_idx=%d orig._idx=%d orig._debug_idx=%d&quot;,
1682                     this-&gt;_idx, this-&gt;debug_idx(), orig-&gt;_idx, orig-&gt;debug_idx());
1683       BREAKPOINT;
1684     }
1685     orig = orig-&gt;debug_orig();
1686     if (NotANode(orig))  orig = NULL;
1687     if (trip-- &lt;= 0)  break;
1688   }
1689 }
1690 #endif //ASSERT
1691 
1692 //------------------------------dump------------------------------------------
1693 // Dump a Node
1694 void Node::dump(const char* suffix, bool mark, outputStream *st) const {
1695   Compile* C = Compile::current();
1696   bool is_new = C-&gt;node_arena()-&gt;contains(this);
1697   C-&gt;_in_dump_cnt++;
1698   st-&gt;print(&quot;%c%d%s\t%s\t=== &quot;, is_new ? &#39; &#39; : &#39;o&#39;, _idx, mark ? &quot; &gt;&quot; : &quot;&quot;, Name());
1699 
1700   // Dump the required and precedence inputs
1701   dump_req(st);
1702   dump_prec(st);
1703   // Dump the outputs
1704   dump_out(st);
1705 
1706   if (is_disconnected(this)) {
1707 #ifdef ASSERT
1708     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1709     dump_orig(st);
1710 #endif
1711     st-&gt;cr();
1712     C-&gt;_in_dump_cnt--;
1713     return;                     // don&#39;t process dead nodes
1714   }
1715 
1716   if (C-&gt;clone_map().value(_idx) != 0) {
1717     C-&gt;clone_map().dump(_idx);
1718   }
1719   // Dump node-specific info
1720   dump_spec(st);
1721 #ifdef ASSERT
1722   // Dump the non-reset _debug_idx
1723   if (Verbose &amp;&amp; WizardMode) {
1724     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1725   }
1726 #endif
1727 
1728   const Type *t = bottom_type();
1729 
1730   if (t != NULL &amp;&amp; (t-&gt;isa_instptr() || t-&gt;isa_klassptr())) {
1731     const TypeInstPtr  *toop = t-&gt;isa_instptr();
1732     const TypeKlassPtr *tkls = t-&gt;isa_klassptr();
1733     ciKlass*           klass = toop ? toop-&gt;klass() : (tkls ? tkls-&gt;klass() : NULL );
1734     if (klass &amp;&amp; klass-&gt;is_loaded() &amp;&amp; klass-&gt;is_interface()) {
1735       st-&gt;print(&quot;  Interface:&quot;);
1736     } else if (toop) {
1737       st-&gt;print(&quot;  Oop:&quot;);
1738     } else if (tkls) {
1739       st-&gt;print(&quot;  Klass:&quot;);
1740     }
1741     t-&gt;dump_on(st);
1742   } else if (t == Type::MEMORY) {
1743     st-&gt;print(&quot;  Memory:&quot;);
1744     MemNode::dump_adr_type(this, adr_type(), st);
1745   } else if (Verbose || WizardMode) {
1746     st-&gt;print(&quot;  Type:&quot;);
1747     if (t) {
1748       t-&gt;dump_on(st);
1749     } else {
1750       st-&gt;print(&quot;no type&quot;);
1751     }
1752   } else if (t-&gt;isa_vect() &amp;&amp; this-&gt;is_MachSpillCopy()) {
1753     // Dump MachSpillcopy vector type.
1754     t-&gt;dump_on(st);
1755   }
1756   if (is_new) {
1757     DEBUG_ONLY(dump_orig(st));
1758     Node_Notes* nn = C-&gt;node_notes_at(_idx);
1759     if (nn != NULL &amp;&amp; !nn-&gt;is_clear()) {
1760       if (nn-&gt;jvms() != NULL) {
1761         st-&gt;print(&quot; !jvms:&quot;);
1762         nn-&gt;jvms()-&gt;dump_spec(st);
1763       }
1764     }
1765   }
1766   if (suffix) st-&gt;print(&quot;%s&quot;, suffix);
1767   C-&gt;_in_dump_cnt--;
1768 }
1769 
1770 //------------------------------dump_req--------------------------------------
1771 void Node::dump_req(outputStream *st) const {
1772   // Dump the required input edges
1773   for (uint i = 0; i &lt; req(); i++) {    // For all required inputs
1774     Node* d = in(i);
1775     if (d == NULL) {
1776       st-&gt;print(&quot;_ &quot;);
1777     } else if (NotANode(d)) {
1778       st-&gt;print(&quot;NotANode &quot;);  // uninitialized, sentinel, garbage, etc.
1779     } else {
1780       st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(d) ? &#39; &#39; : &#39;o&#39;, d-&gt;_idx);
1781     }
1782   }
1783 }
1784 
1785 
1786 //------------------------------dump_prec-------------------------------------
1787 void Node::dump_prec(outputStream *st) const {
1788   // Dump the precedence edges
1789   int any_prec = 0;
1790   for (uint i = req(); i &lt; len(); i++) {       // For all precedence inputs
1791     Node* p = in(i);
1792     if (p != NULL) {
1793       if (!any_prec++) st-&gt;print(&quot; |&quot;);
1794       if (NotANode(p)) { st-&gt;print(&quot;NotANode &quot;); continue; }
1795       st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
1796     }
1797   }
1798 }
1799 
1800 //------------------------------dump_out--------------------------------------
1801 void Node::dump_out(outputStream *st) const {
1802   // Delimit the output edges
1803   st-&gt;print(&quot; [[&quot;);
1804   // Dump the output edges
1805   for (uint i = 0; i &lt; _outcnt; i++) {    // For all outputs
1806     Node* u = _out[i];
1807     if (u == NULL) {
1808       st-&gt;print(&quot;_ &quot;);
1809     } else if (NotANode(u)) {
1810       st-&gt;print(&quot;NotANode &quot;);
1811     } else {
1812       st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(u) ? &#39; &#39; : &#39;o&#39;, u-&gt;_idx);
1813     }
1814   }
1815   st-&gt;print(&quot;]] &quot;);
1816 }
1817 
1818 //----------------------------collect_nodes_i----------------------------------
1819 // Collects nodes from an Ideal graph, starting from a given start node and
1820 // moving in a given direction until a certain depth (distance from the start
1821 // node) is reached. Duplicates are ignored.
1822 // Arguments:
1823 //   nstack:        the nodes are collected into this array.
1824 //   start:         the node at which to start collecting.
1825 //   direction:     if this is a positive number, collect input nodes; if it is
1826 //                  a negative number, collect output nodes.
1827 //   depth:         collect nodes up to this distance from the start node.
1828 //   include_start: whether to include the start node in the result collection.
1829 //   only_ctrl:     whether to regard control edges only during traversal.
1830 //   only_data:     whether to regard data edges only during traversal.
1831 static void collect_nodes_i(GrowableArray&lt;Node*&gt; *nstack, const Node* start, int direction, uint depth, bool include_start, bool only_ctrl, bool only_data) {
1832   Node* s = (Node*) start; // remove const
1833   nstack-&gt;append(s);
1834   int begin = 0;
1835   int end = 0;
1836   for(uint i = 0; i &lt; depth; i++) {
1837     end = nstack-&gt;length();
1838     for(int j = begin; j &lt; end; j++) {
1839       Node* tp  = nstack-&gt;at(j);
1840       uint limit = direction &gt; 0 ? tp-&gt;len() : tp-&gt;outcnt();
1841       for(uint k = 0; k &lt; limit; k++) {
1842         Node* n = direction &gt; 0 ? tp-&gt;in(k) : tp-&gt;raw_out(k);
1843 
1844         if (NotANode(n))  continue;
1845         // do not recurse through top or the root (would reach unrelated stuff)
1846         if (n-&gt;is_Root() || n-&gt;is_top()) continue;
1847         if (only_ctrl &amp;&amp; !n-&gt;is_CFG()) continue;
1848         if (only_data &amp;&amp; n-&gt;is_CFG()) continue;
1849 
1850         bool on_stack = nstack-&gt;contains(n);
1851         if (!on_stack) {
1852           nstack-&gt;append(n);
1853         }
1854       }
1855     }
1856     begin = end;
1857   }
1858   if (!include_start) {
1859     nstack-&gt;remove(s);
1860   }
1861 }
1862 
1863 //------------------------------dump_nodes-------------------------------------
1864 static void dump_nodes(const Node* start, int d, bool only_ctrl) {
1865   if (NotANode(start)) return;
1866 
1867   GrowableArray &lt;Node *&gt; nstack(Compile::current()-&gt;live_nodes());
1868   collect_nodes_i(&amp;nstack, start, d, (uint) ABS(d), true, only_ctrl, false);
1869 
1870   int end = nstack.length();
1871   if (d &gt; 0) {
1872     for(int j = end-1; j &gt;= 0; j--) {
1873       nstack.at(j)-&gt;dump();
1874     }
1875   } else {
1876     for(int j = 0; j &lt; end; j++) {
1877       nstack.at(j)-&gt;dump();
1878     }
1879   }
1880 }
1881 
1882 //------------------------------dump-------------------------------------------
1883 void Node::dump(int d) const {
1884   dump_nodes(this, d, false);
1885 }
1886 
1887 //------------------------------dump_ctrl--------------------------------------
1888 // Dump a Node&#39;s control history to depth
1889 void Node::dump_ctrl(int d) const {
1890   dump_nodes(this, d, true);
1891 }
1892 
1893 //-----------------------------dump_compact------------------------------------
1894 void Node::dump_comp() const {
1895   this-&gt;dump_comp(&quot;\n&quot;);
1896 }
1897 
1898 //-----------------------------dump_compact------------------------------------
1899 // Dump a Node in compact representation, i.e., just print its name and index.
1900 // Nodes can specify additional specifics to print in compact representation by
1901 // implementing dump_compact_spec.
1902 void Node::dump_comp(const char* suffix, outputStream *st) const {
1903   Compile* C = Compile::current();
1904   C-&gt;_in_dump_cnt++;
1905   st-&gt;print(&quot;%s(%d)&quot;, Name(), _idx);
1906   this-&gt;dump_compact_spec(st);
1907   if (suffix) {
1908     st-&gt;print(&quot;%s&quot;, suffix);
1909   }
1910   C-&gt;_in_dump_cnt--;
1911 }
1912 
1913 //----------------------------dump_related-------------------------------------
1914 // Dump a Node&#39;s related nodes - the notion of &quot;related&quot; depends on the Node at
1915 // hand and is determined by the implementation of the virtual method rel.
1916 void Node::dump_related() const {
1917   Compile* C = Compile::current();
1918   GrowableArray &lt;Node *&gt; in_rel(C-&gt;unique());
1919   GrowableArray &lt;Node *&gt; out_rel(C-&gt;unique());
1920   this-&gt;related(&amp;in_rel, &amp;out_rel, false);
1921   for (int i = in_rel.length() - 1; i &gt;= 0; i--) {
1922     in_rel.at(i)-&gt;dump();
1923   }
1924   this-&gt;dump(&quot;\n&quot;, true);
1925   for (int i = 0; i &lt; out_rel.length(); i++) {
1926     out_rel.at(i)-&gt;dump();
1927   }
1928 }
1929 
1930 //----------------------------dump_related-------------------------------------
1931 // Dump a Node&#39;s related nodes up to a given depth (distance from the start
1932 // node).
1933 // Arguments:
1934 //   d_in:  depth for input nodes.
1935 //   d_out: depth for output nodes (note: this also is a positive number).
1936 void Node::dump_related(uint d_in, uint d_out) const {
1937   Compile* C = Compile::current();
1938   GrowableArray &lt;Node *&gt; in_rel(C-&gt;unique());
1939   GrowableArray &lt;Node *&gt; out_rel(C-&gt;unique());
1940 
1941   // call collect_nodes_i directly
1942   collect_nodes_i(&amp;in_rel, this, 1, d_in, false, false, false);
1943   collect_nodes_i(&amp;out_rel, this, -1, d_out, false, false, false);
1944 
1945   for (int i = in_rel.length() - 1; i &gt;= 0; i--) {
1946     in_rel.at(i)-&gt;dump();
1947   }
1948   this-&gt;dump(&quot;\n&quot;, true);
1949   for (int i = 0; i &lt; out_rel.length(); i++) {
1950     out_rel.at(i)-&gt;dump();
1951   }
1952 }
1953 
1954 //------------------------dump_related_compact---------------------------------
1955 // Dump a Node&#39;s related nodes in compact representation. The notion of
1956 // &quot;related&quot; depends on the Node at hand and is determined by the implementation
1957 // of the virtual method rel.
1958 void Node::dump_related_compact() const {
1959   Compile* C = Compile::current();
1960   GrowableArray &lt;Node *&gt; in_rel(C-&gt;unique());
1961   GrowableArray &lt;Node *&gt; out_rel(C-&gt;unique());
1962   this-&gt;related(&amp;in_rel, &amp;out_rel, true);
1963   int n_in = in_rel.length();
1964   int n_out = out_rel.length();
1965 
1966   this-&gt;dump_comp(n_in == 0 ? &quot;\n&quot; : &quot;  &quot;);
1967   for (int i = 0; i &lt; n_in; i++) {
1968     in_rel.at(i)-&gt;dump_comp(i == n_in - 1 ? &quot;\n&quot; : &quot;  &quot;);
1969   }
1970   for (int i = 0; i &lt; n_out; i++) {
1971     out_rel.at(i)-&gt;dump_comp(i == n_out - 1 ? &quot;\n&quot; : &quot;  &quot;);
1972   }
1973 }
1974 
1975 //------------------------------related----------------------------------------
1976 // Collect a Node&#39;s related nodes. The default behaviour just collects the
1977 // inputs and outputs at depth 1, including both control and data flow edges,
1978 // regardless of whether the presentation is compact or not. For data nodes,
1979 // the default is to collect all data inputs (till level 1 if compact), and
1980 // outputs till level 1.
1981 void Node::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1982   if (this-&gt;is_CFG()) {
1983     collect_nodes_i(in_rel, this, 1, 1, false, false, false);
1984     collect_nodes_i(out_rel, this, -1, 1, false, false, false);
1985   } else {
1986     if (compact) {
1987       this-&gt;collect_nodes(in_rel, 1, false, true);
1988     } else {
1989       this-&gt;collect_nodes_in_all_data(in_rel, false);
1990     }
1991     this-&gt;collect_nodes(out_rel, -1, false, false);
1992   }
1993 }
1994 
1995 //---------------------------collect_nodes-------------------------------------
1996 // An entry point to the low-level node collection facility, to start from a
1997 // given node in the graph. The start node is by default not included in the
1998 // result.
1999 // Arguments:
2000 //   ns:   collect the nodes into this data structure.
2001 //   d:    the depth (distance from start node) to which nodes should be
2002 //         collected. A value &gt;0 indicates input nodes, a value &lt;0, output
2003 //         nodes.
2004 //   ctrl: include only control nodes.
2005 //   data: include only data nodes.
2006 void Node::collect_nodes(GrowableArray&lt;Node*&gt; *ns, int d, bool ctrl, bool data) const {
2007   if (ctrl &amp;&amp; data) {
2008     // ignore nonsensical combination
2009     return;
2010   }
2011   collect_nodes_i(ns, this, d, (uint) ABS(d), false, ctrl, data);
2012 }
2013 
2014 //--------------------------collect_nodes_in-----------------------------------
2015 static void collect_nodes_in(Node* start, GrowableArray&lt;Node*&gt; *ns, bool primary_is_data, bool collect_secondary) {
2016   // The maximum depth is determined using a BFS that visits all primary (data
2017   // or control) inputs and increments the depth at each level.
2018   uint d_in = 0;
2019   GrowableArray&lt;Node*&gt; nodes(Compile::current()-&gt;unique());
2020   nodes.push(start);
2021   int nodes_at_current_level = 1;
2022   int n_idx = 0;
2023   while (nodes_at_current_level &gt; 0) {
2024     // Add all primary inputs reachable from the current level to the list, and
2025     // increase the depth if there were any.
2026     int nodes_at_next_level = 0;
2027     bool nodes_added = false;
2028     while (nodes_at_current_level &gt; 0) {
2029       nodes_at_current_level--;
2030       Node* current = nodes.at(n_idx++);
2031       for (uint i = 0; i &lt; current-&gt;len(); i++) {
2032         Node* n = current-&gt;in(i);
2033         if (NotANode(n)) {
2034           continue;
2035         }
2036         if ((primary_is_data &amp;&amp; n-&gt;is_CFG()) || (!primary_is_data &amp;&amp; !n-&gt;is_CFG())) {
2037           continue;
2038         }
2039         if (!nodes.contains(n)) {
2040           nodes.push(n);
2041           nodes_added = true;
2042           nodes_at_next_level++;
2043         }
2044       }
2045     }
2046     if (nodes_added) {
2047       d_in++;
2048     }
2049     nodes_at_current_level = nodes_at_next_level;
2050   }
2051   start-&gt;collect_nodes(ns, d_in, !primary_is_data, primary_is_data);
2052   if (collect_secondary) {
2053     // Now, iterate over the secondary nodes in ns and add the respective
2054     // boundary reachable from them.
2055     GrowableArray&lt;Node*&gt; sns(Compile::current()-&gt;unique());
2056     for (GrowableArrayIterator&lt;Node*&gt; it = ns-&gt;begin(); it != ns-&gt;end(); ++it) {
2057       Node* n = *it;
2058       n-&gt;collect_nodes(&amp;sns, 1, primary_is_data, !primary_is_data);
2059       for (GrowableArrayIterator&lt;Node*&gt; d = sns.begin(); d != sns.end(); ++d) {
2060         ns-&gt;append_if_missing(*d);
2061       }
2062       sns.clear();
2063     }
2064   }
2065 }
2066 
2067 //---------------------collect_nodes_in_all_data-------------------------------
2068 // Collect the entire data input graph. Include the control boundary if
2069 // requested.
2070 // Arguments:
2071 //   ns:   collect the nodes into this data structure.
2072 //   ctrl: if true, include the control boundary.
2073 void Node::collect_nodes_in_all_data(GrowableArray&lt;Node*&gt; *ns, bool ctrl) const {
2074   collect_nodes_in((Node*) this, ns, true, ctrl);
2075 }
2076 
2077 //--------------------------collect_nodes_in_all_ctrl--------------------------
2078 // Collect the entire control input graph. Include the data boundary if
2079 // requested.
2080 //   ns:   collect the nodes into this data structure.
2081 //   data: if true, include the control boundary.
2082 void Node::collect_nodes_in_all_ctrl(GrowableArray&lt;Node*&gt; *ns, bool data) const {
2083   collect_nodes_in((Node*) this, ns, false, data);
2084 }
2085 
2086 //------------------collect_nodes_out_all_ctrl_boundary------------------------
2087 // Collect the entire output graph until hitting control node boundaries, and
2088 // include those.
2089 void Node::collect_nodes_out_all_ctrl_boundary(GrowableArray&lt;Node*&gt; *ns) const {
2090   // Perform a BFS and stop at control nodes.
2091   GrowableArray&lt;Node*&gt; nodes(Compile::current()-&gt;unique());
2092   nodes.push((Node*) this);
2093   while (nodes.length() &gt; 0) {
2094     Node* current = nodes.pop();
2095     if (NotANode(current)) {
2096       continue;
2097     }
2098     ns-&gt;append_if_missing(current);
2099     if (!current-&gt;is_CFG()) {
2100       for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2101         nodes.push(current-&gt;out(i));
2102       }
2103     }
2104   }
2105   ns-&gt;remove((Node*) this);
2106 }
2107 
2108 // VERIFICATION CODE
2109 // For each input edge to a node (ie - for each Use-Def edge), verify that
2110 // there is a corresponding Def-Use edge.
2111 //------------------------------verify_edges-----------------------------------
2112 void Node::verify_edges(Unique_Node_List &amp;visited) {
2113   uint i, j, idx;
2114   int  cnt;
2115   Node *n;
2116 
2117   // Recursive termination test
2118   if (visited.member(this))  return;
2119   visited.push(this);
2120 
2121   // Walk over all input edges, checking for correspondence
2122   for( i = 0; i &lt; len(); i++ ) {
2123     n = in(i);
2124     if (n != NULL &amp;&amp; !n-&gt;is_top()) {
2125       // Count instances of (Node *)this
2126       cnt = 0;
2127       for (idx = 0; idx &lt; n-&gt;_outcnt; idx++ ) {
2128         if (n-&gt;_out[idx] == (Node *)this)  cnt++;
2129       }
2130       assert( cnt &gt; 0,&quot;Failed to find Def-Use edge.&quot; );
2131       // Check for duplicate edges
2132       // walk the input array downcounting the input edges to n
2133       for( j = 0; j &lt; len(); j++ ) {
2134         if( in(j) == n ) cnt--;
2135       }
2136       assert( cnt == 0,&quot;Mismatched edge count.&quot;);
2137     } else if (n == NULL) {
2138       assert(i &gt;= req() || i == 0 || is_Region() || is_Phi() || is_ArrayCopy() ||
2139              (is_Allocate() &amp;&amp; i &gt;= AllocateNode::ValueNode) ||
2140              (is_Unlock() &amp;&amp; i == req()-1),
2141              &quot;only region, phi, arraycopy, allocate or unlock nodes have null data edges&quot;);
2142     } else {
2143       assert(n-&gt;is_top(), &quot;sanity&quot;);
2144       // Nothing to check.
2145     }
2146   }
2147   // Recursive walk over all input edges
2148   for( i = 0; i &lt; len(); i++ ) {
2149     n = in(i);
2150     if( n != NULL )
2151       in(i)-&gt;verify_edges(visited);
2152   }
2153 }
2154 
2155 void Node::verify_recur(const Node *n, int verify_depth,
2156                         VectorSet &amp;old_space, VectorSet &amp;new_space) {
2157   if ( verify_depth == 0 )  return;
2158   if (verify_depth &gt; 0)  --verify_depth;
2159 
2160   Compile* C = Compile::current();
2161 
2162   // Contained in new_space or old_space?
2163   VectorSet *v = C-&gt;node_arena()-&gt;contains(n) ? &amp;new_space : &amp;old_space;
2164   // Check for visited in the proper space.  Numberings are not unique
2165   // across spaces so we need a separate VectorSet for each space.
2166   if( v-&gt;test_set(n-&gt;_idx) ) return;
2167 
2168   if (n-&gt;is_Con() &amp;&amp; n-&gt;bottom_type() == Type::TOP) {
2169     if (C-&gt;cached_top_node() == NULL)
2170       C-&gt;set_cached_top_node((Node*)n);
2171     assert(C-&gt;cached_top_node() == n, &quot;TOP node must be unique&quot;);
2172   }
2173 
2174   for( uint i = 0; i &lt; n-&gt;len(); i++ ) {
2175     Node *x = n-&gt;in(i);
2176     if (!x || x-&gt;is_top()) continue;
2177 
2178     // Verify my input has a def-use edge to me
2179     if (true /*VerifyDefUse*/) {
2180       // Count use-def edges from n to x
2181       int cnt = 0;
2182       for( uint j = 0; j &lt; n-&gt;len(); j++ )
2183         if( n-&gt;in(j) == x )
2184           cnt++;
2185       // Count def-use edges from x to n
2186       uint max = x-&gt;_outcnt;
2187       for( uint k = 0; k &lt; max; k++ )
2188         if (x-&gt;_out[k] == n)
2189           cnt--;
2190       assert( cnt == 0, &quot;mismatched def-use edge counts&quot; );
2191     }
2192 
2193     verify_recur(x, verify_depth, old_space, new_space);
2194   }
2195 
2196 }
2197 
2198 //------------------------------verify-----------------------------------------
2199 // Check Def-Use info for my subgraph
2200 void Node::verify() const {
2201   Compile* C = Compile::current();
2202   Node* old_top = C-&gt;cached_top_node();
2203   ResourceMark rm;
2204   ResourceArea *area = Thread::current()-&gt;resource_area();
2205   VectorSet old_space(area), new_space(area);
2206   verify_recur(this, -1, old_space, new_space);
2207   C-&gt;set_cached_top_node(old_top);
2208 }
2209 #endif
2210 
2211 
2212 //------------------------------walk-------------------------------------------
2213 // Graph walk, with both pre-order and post-order functions
2214 void Node::walk(NFunc pre, NFunc post, void *env) {
2215   VectorSet visited(Thread::current()-&gt;resource_area()); // Setup for local walk
2216   walk_(pre, post, env, visited);
2217 }
2218 
2219 void Node::walk_(NFunc pre, NFunc post, void *env, VectorSet &amp;visited) {
2220   if( visited.test_set(_idx) ) return;
2221   pre(*this,env);               // Call the pre-order walk function
2222   for( uint i=0; i&lt;_max; i++ )
2223     if( in(i) )                 // Input exists and is not walked?
2224       in(i)-&gt;walk_(pre,post,env,visited); // Walk it with pre &amp; post functions
2225   post(*this,env);              // Call the post-order walk function
2226 }
2227 
2228 void Node::nop(Node &amp;, void*) {}
2229 
2230 //------------------------------Registers--------------------------------------
2231 // Do we Match on this edge index or not?  Generally false for Control
2232 // and true for everything else.  Weird for calls &amp; returns.
2233 uint Node::match_edge(uint idx) const {
2234   return idx;                   // True for other than index 0 (control)
2235 }
2236 
2237 static RegMask _not_used_at_all;
2238 // Register classes are defined for specific machines
2239 const RegMask &amp;Node::out_RegMask() const {
2240   ShouldNotCallThis();
2241   return _not_used_at_all;
2242 }
2243 
2244 const RegMask &amp;Node::in_RegMask(uint) const {
2245   ShouldNotCallThis();
2246   return _not_used_at_all;
2247 }
2248 
2249 //=============================================================================
2250 //-----------------------------------------------------------------------------
2251 void Node_Array::reset( Arena *new_arena ) {
2252   _a-&gt;Afree(_nodes,_max*sizeof(Node*));
2253   _max   = 0;
2254   _nodes = NULL;
2255   _a     = new_arena;
2256 }
2257 
2258 //------------------------------clear------------------------------------------
2259 // Clear all entries in _nodes to NULL but keep storage
2260 void Node_Array::clear() {
2261   Copy::zero_to_bytes( _nodes, _max*sizeof(Node*) );
2262 }
2263 
2264 //-----------------------------------------------------------------------------
2265 void Node_Array::grow( uint i ) {
2266   if( !_max ) {
2267     _max = 1;
2268     _nodes = (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
2269     _nodes[0] = NULL;
2270   }
2271   uint old = _max;
2272   _max = next_power_of_2(i);
2273   _nodes = (Node**)_a-&gt;Arealloc( _nodes, old*sizeof(Node*),_max*sizeof(Node*));
2274   Copy::zero_to_bytes( &amp;_nodes[old], (_max-old)*sizeof(Node*) );
2275 }
2276 
2277 //-----------------------------------------------------------------------------
2278 void Node_Array::insert( uint i, Node *n ) {
2279   if( _nodes[_max-1] ) grow(_max);      // Get more space if full
2280   Copy::conjoint_words_to_higher((HeapWord*)&amp;_nodes[i], (HeapWord*)&amp;_nodes[i+1], ((_max-i-1)*sizeof(Node*)));
2281   _nodes[i] = n;
2282 }
2283 
2284 //-----------------------------------------------------------------------------
2285 void Node_Array::remove( uint i ) {
2286   Copy::conjoint_words_to_lower((HeapWord*)&amp;_nodes[i+1], (HeapWord*)&amp;_nodes[i], ((_max-i-1)*sizeof(Node*)));
2287   _nodes[_max-1] = NULL;
2288 }
2289 
2290 //-----------------------------------------------------------------------------
2291 void Node_Array::sort( C_sort_func_t func) {
2292   qsort( _nodes, _max, sizeof( Node* ), func );
2293 }
2294 
2295 //-----------------------------------------------------------------------------
2296 void Node_Array::dump() const {
2297 #ifndef PRODUCT
2298   for( uint i = 0; i &lt; _max; i++ ) {
2299     Node *nn = _nodes[i];
2300     if( nn != NULL ) {
2301       tty-&gt;print(&quot;%5d--&gt; &quot;,i); nn-&gt;dump();
2302     }
2303   }
2304 #endif
2305 }
2306 
2307 //--------------------------is_iteratively_computed------------------------------
2308 // Operation appears to be iteratively computed (such as an induction variable)
2309 // It is possible for this operation to return false for a loop-varying
2310 // value, if it appears (by local graph inspection) to be computed by a simple conditional.
2311 bool Node::is_iteratively_computed() {
2312   if (ideal_reg()) { // does operation have a result register?
2313     for (uint i = 1; i &lt; req(); i++) {
2314       Node* n = in(i);
2315       if (n != NULL &amp;&amp; n-&gt;is_Phi()) {
2316         for (uint j = 1; j &lt; n-&gt;req(); j++) {
2317           if (n-&gt;in(j) == this) {
2318             return true;
2319           }
2320         }
2321       }
2322     }
2323   }
2324   return false;
2325 }
2326 
2327 //--------------------------find_similar------------------------------
2328 // Return a node with opcode &quot;opc&quot; and same inputs as &quot;this&quot; if one can
2329 // be found; Otherwise return NULL;
2330 Node* Node::find_similar(int opc) {
2331   if (req() &gt;= 2) {
2332     Node* def = in(1);
2333     if (def &amp;&amp; def-&gt;outcnt() &gt;= 2) {
2334       for (DUIterator_Fast dmax, i = def-&gt;fast_outs(dmax); i &lt; dmax; i++) {
2335         Node* use = def-&gt;fast_out(i);
2336         if (use != this &amp;&amp;
2337             use-&gt;Opcode() == opc &amp;&amp;
2338             use-&gt;req() == req()) {
2339           uint j;
2340           for (j = 0; j &lt; use-&gt;req(); j++) {
2341             if (use-&gt;in(j) != in(j)) {
2342               break;
2343             }
2344           }
2345           if (j == use-&gt;req()) {
2346             return use;
2347           }
2348         }
2349       }
2350     }
2351   }
2352   return NULL;
2353 }
2354 
2355 
2356 //--------------------------unique_ctrl_out------------------------------
2357 // Return the unique control out if only one. Null if none or more than one.
2358 Node* Node::unique_ctrl_out() const {
2359   Node* found = NULL;
2360   for (uint i = 0; i &lt; outcnt(); i++) {
2361     Node* use = raw_out(i);
2362     if (use-&gt;is_CFG() &amp;&amp; use != this) {
2363       if (found != NULL) return NULL;
2364       found = use;
2365     }
2366   }
2367   return found;
2368 }
2369 
2370 void Node::ensure_control_or_add_prec(Node* c) {
2371   if (in(0) == NULL) {
2372     set_req(0, c);
2373   } else if (in(0) != c) {
2374     add_prec(c);
2375   }
2376 }
2377 
2378 //=============================================================================
2379 //------------------------------yank-------------------------------------------
2380 // Find and remove
2381 void Node_List::yank( Node *n ) {
2382   uint i;
2383   for( i = 0; i &lt; _cnt; i++ )
2384     if( _nodes[i] == n )
2385       break;
2386 
2387   if( i &lt; _cnt )
2388     _nodes[i] = _nodes[--_cnt];
2389 }
2390 
2391 //------------------------------dump-------------------------------------------
2392 void Node_List::dump() const {
2393 #ifndef PRODUCT
2394   for( uint i = 0; i &lt; _cnt; i++ )
2395     if( _nodes[i] ) {
2396       tty-&gt;print(&quot;%5d--&gt; &quot;,i);
2397       _nodes[i]-&gt;dump();
2398     }
2399 #endif
2400 }
2401 
2402 void Node_List::dump_simple() const {
2403 #ifndef PRODUCT
2404   for( uint i = 0; i &lt; _cnt; i++ )
2405     if( _nodes[i] ) {
2406       tty-&gt;print(&quot; %d&quot;, _nodes[i]-&gt;_idx);
2407     } else {
2408       tty-&gt;print(&quot; NULL&quot;);
2409     }
2410 #endif
2411 }
2412 
2413 //=============================================================================
2414 //------------------------------remove-----------------------------------------
2415 void Unique_Node_List::remove(Node* n) {
2416   if (_in_worklist.test(n-&gt;_idx)) {
2417     for (uint i = 0; i &lt; size(); i++) {
2418       if (_nodes[i] == n) {
2419         map(i, Node_List::pop());
2420         _in_worklist.remove(n-&gt;_idx);
2421         return;
2422       }
2423     }
2424     ShouldNotReachHere();
2425   }
2426 }
2427 
2428 //-----------------------remove_useless_nodes----------------------------------
2429 // Remove useless nodes from worklist
2430 void Unique_Node_List::remove_useless_nodes(VectorSet &amp;useful) {
2431 
2432   for (uint i = 0; i &lt; size(); ++i) {
2433     Node *n = at(i);
2434     assert( n != NULL, &quot;Did not expect null entries in worklist&quot;);
2435     if (!useful.test(n-&gt;_idx)) {
2436       _in_worklist.remove(n-&gt;_idx);
2437       map(i,Node_List::pop());
2438       // Node *replacement = Node_List::pop();
2439       // if( i != size() ) { // Check if removing last entry
2440       //   _nodes[i] = replacement;
2441       // }
2442       --i;  // Visit popped node
2443       // If it was last entry, loop terminates since size() was also reduced
2444     }
2445   }
2446 }
2447 
2448 //=============================================================================
2449 void Node_Stack::grow() {
2450   size_t old_top = pointer_delta(_inode_top,_inodes,sizeof(INode)); // save _top
2451   size_t old_max = pointer_delta(_inode_max,_inodes,sizeof(INode));
2452   size_t max = old_max &lt;&lt; 1;             // max * 2
2453   _inodes = REALLOC_ARENA_ARRAY(_a, INode, _inodes, old_max, max);
2454   _inode_max = _inodes + max;
2455   _inode_top = _inodes + old_top;        // restore _top
2456 }
2457 
2458 // Node_Stack is used to map nodes.
2459 Node* Node_Stack::find(uint idx) const {
2460   uint sz = size();
2461   for (uint i=0; i &lt; sz; i++) {
2462     if (idx == index_at(i) )
2463       return node_at(i);
2464   }
2465   return NULL;
2466 }
2467 
2468 //=============================================================================
2469 uint TypeNode::size_of() const { return sizeof(*this); }
2470 #ifndef PRODUCT
2471 void TypeNode::dump_spec(outputStream *st) const {
2472   if( !Verbose &amp;&amp; !WizardMode ) {
2473     // standard dump does this in Verbose and WizardMode
2474     st-&gt;print(&quot; #&quot;); _type-&gt;dump_on(st);
2475   }
2476 }
2477 
2478 void TypeNode::dump_compact_spec(outputStream *st) const {
2479   st-&gt;print(&quot;#&quot;);
2480   _type-&gt;dump_on(st);
2481 }
2482 #endif
2483 uint TypeNode::hash() const {
2484   return Node::hash() + _type-&gt;hash();
2485 }
2486 bool TypeNode::cmp( const Node &amp;n ) const
2487 { return !Type::cmp( _type, ((TypeNode&amp;)n)._type ); }
2488 const Type *TypeNode::bottom_type() const { return _type; }
2489 const Type* TypeNode::Value(PhaseGVN* phase) const { return _type; }
2490 
2491 //------------------------------ideal_reg--------------------------------------
2492 uint TypeNode::ideal_reg() const {
2493   return _type-&gt;ideal_reg();
2494 }
    </pre>
  </body>
</html>
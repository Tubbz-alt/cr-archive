<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parse1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="output.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="subtypenode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
2410     }
2411     mms.memory()-&gt;add_req(mms.memory2());
2412   }
2413 
2414   if (_first_return) {
2415     _exits.map()-&gt;transfer_replaced_nodes_from(map(), _new_idx);
2416     _first_return = false;
2417   } else {
2418     _exits.map()-&gt;merge_replaced_nodes_with(map());
2419   }
2420 
2421   stop_and_kill_map();          // This CFG path dies here
2422 }
2423 
2424 
2425 //------------------------------add_safepoint----------------------------------
2426 void Parse::add_safepoint() {
2427   // See if we can avoid this safepoint.  No need for a SafePoint immediately
2428   // after a Call (except Leaf Call) or another SafePoint.
2429   Node *proj = control();
<span class="line-modified">2430   bool add_poll_param = SafePointNode::needs_polling_address_input();</span>
<span class="line-removed">2431   uint parms = add_poll_param ? TypeFunc::Parms+1 : TypeFunc::Parms;</span>
2432   if( proj-&gt;is_Proj() ) {
2433     Node *n0 = proj-&gt;in(0);
2434     if( n0-&gt;is_Catch() ) {
2435       n0 = n0-&gt;in(0)-&gt;in(0);
2436       assert( n0-&gt;is_Call(), &quot;expect a call here&quot; );
2437     }
2438     if( n0-&gt;is_Call() ) {
2439       if( n0-&gt;as_Call()-&gt;guaranteed_safepoint() )
2440         return;
2441     } else if( n0-&gt;is_SafePoint() &amp;&amp; n0-&gt;req() &gt;= parms ) {
2442       return;
2443     }
2444   }
2445 
2446   // Clear out dead values from the debug info.
2447   kill_dead_locals();
2448 
2449   // Clone the JVM State
2450   SafePointNode *sfpnt = new SafePointNode(parms, NULL);
2451 
</pre>
<hr />
<pre>
2458 
2459   // We do not need to WRITE the memory state after a SafePoint.  The control
2460   // edge will keep card-marks and oop-stores from floating up from below a
2461   // SafePoint and our true dependency added here will keep them from floating
2462   // down below a SafePoint.
2463 
2464   // Clone the current memory state
2465   Node* mem = MergeMemNode::make(map()-&gt;memory());
2466 
2467   mem = _gvn.transform(mem);
2468 
2469   // Pass control through the safepoint
2470   sfpnt-&gt;init_req(TypeFunc::Control  , control());
2471   // Fix edges normally used by a call
2472   sfpnt-&gt;init_req(TypeFunc::I_O      , top() );
2473   sfpnt-&gt;init_req(TypeFunc::Memory   , mem   );
2474   sfpnt-&gt;init_req(TypeFunc::ReturnAdr, top() );
2475   sfpnt-&gt;init_req(TypeFunc::FramePtr , top() );
2476 
2477   // Create a node for the polling address
<span class="line-modified">2478   if( add_poll_param ) {</span>
<span class="line-modified">2479     Node *polladr;</span>
<span class="line-modified">2480     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">2481       Node *thread = _gvn.transform(new ThreadLocalNode());</span>
<span class="line-modified">2482       Node *polling_page_load_addr = _gvn.transform(basic_plus_adr(top(), thread, in_bytes(Thread::polling_page_offset())));</span>
<span class="line-removed">2483       polladr = make_load(control(), polling_page_load_addr, TypeRawPtr::BOTTOM, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered);</span>
<span class="line-removed">2484     } else {</span>
<span class="line-removed">2485       polladr = ConPNode::make((address)os::get_polling_page());</span>
<span class="line-removed">2486     }</span>
<span class="line-removed">2487     sfpnt-&gt;init_req(TypeFunc::Parms+0, _gvn.transform(polladr));</span>
<span class="line-removed">2488   }</span>
2489 
2490   // Fix up the JVM State edges
2491   add_safepoint_edges(sfpnt);
2492   Node *transformed_sfpnt = _gvn.transform(sfpnt);
2493   set_control(transformed_sfpnt);
2494 
2495   // Provide an edge from root to safepoint.  This makes the safepoint
2496   // appear useful until the parse has completed.
2497   if( OptoRemoveUseless &amp;&amp; transformed_sfpnt-&gt;is_SafePoint() ) {
2498     assert(C-&gt;root() != NULL, &quot;Expect parse is still valid&quot;);
2499     C-&gt;root()-&gt;add_prec(transformed_sfpnt);
2500   }
2501 }
2502 
2503 #ifndef PRODUCT
2504 //------------------------show_parse_info--------------------------------------
2505 void Parse::show_parse_info() {
2506   InlineTree* ilt = NULL;
2507   if (C-&gt;ilt() != NULL) {
2508     JVMState* caller_jvms = is_osr_parse() ? caller()-&gt;caller() : caller();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
2410     }
2411     mms.memory()-&gt;add_req(mms.memory2());
2412   }
2413 
2414   if (_first_return) {
2415     _exits.map()-&gt;transfer_replaced_nodes_from(map(), _new_idx);
2416     _first_return = false;
2417   } else {
2418     _exits.map()-&gt;merge_replaced_nodes_with(map());
2419   }
2420 
2421   stop_and_kill_map();          // This CFG path dies here
2422 }
2423 
2424 
2425 //------------------------------add_safepoint----------------------------------
2426 void Parse::add_safepoint() {
2427   // See if we can avoid this safepoint.  No need for a SafePoint immediately
2428   // after a Call (except Leaf Call) or another SafePoint.
2429   Node *proj = control();
<span class="line-modified">2430   uint parms = TypeFunc::Parms+1;</span>

2431   if( proj-&gt;is_Proj() ) {
2432     Node *n0 = proj-&gt;in(0);
2433     if( n0-&gt;is_Catch() ) {
2434       n0 = n0-&gt;in(0)-&gt;in(0);
2435       assert( n0-&gt;is_Call(), &quot;expect a call here&quot; );
2436     }
2437     if( n0-&gt;is_Call() ) {
2438       if( n0-&gt;as_Call()-&gt;guaranteed_safepoint() )
2439         return;
2440     } else if( n0-&gt;is_SafePoint() &amp;&amp; n0-&gt;req() &gt;= parms ) {
2441       return;
2442     }
2443   }
2444 
2445   // Clear out dead values from the debug info.
2446   kill_dead_locals();
2447 
2448   // Clone the JVM State
2449   SafePointNode *sfpnt = new SafePointNode(parms, NULL);
2450 
</pre>
<hr />
<pre>
2457 
2458   // We do not need to WRITE the memory state after a SafePoint.  The control
2459   // edge will keep card-marks and oop-stores from floating up from below a
2460   // SafePoint and our true dependency added here will keep them from floating
2461   // down below a SafePoint.
2462 
2463   // Clone the current memory state
2464   Node* mem = MergeMemNode::make(map()-&gt;memory());
2465 
2466   mem = _gvn.transform(mem);
2467 
2468   // Pass control through the safepoint
2469   sfpnt-&gt;init_req(TypeFunc::Control  , control());
2470   // Fix edges normally used by a call
2471   sfpnt-&gt;init_req(TypeFunc::I_O      , top() );
2472   sfpnt-&gt;init_req(TypeFunc::Memory   , mem   );
2473   sfpnt-&gt;init_req(TypeFunc::ReturnAdr, top() );
2474   sfpnt-&gt;init_req(TypeFunc::FramePtr , top() );
2475 
2476   // Create a node for the polling address
<span class="line-modified">2477   Node *polladr;</span>
<span class="line-modified">2478   Node *thread = _gvn.transform(new ThreadLocalNode());</span>
<span class="line-modified">2479   Node *polling_page_load_addr = _gvn.transform(basic_plus_adr(top(), thread, in_bytes(Thread::polling_page_offset())));</span>
<span class="line-modified">2480   polladr = make_load(control(), polling_page_load_addr, TypeRawPtr::BOTTOM, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered);</span>
<span class="line-modified">2481   sfpnt-&gt;init_req(TypeFunc::Parms+0, _gvn.transform(polladr));</span>






2482 
2483   // Fix up the JVM State edges
2484   add_safepoint_edges(sfpnt);
2485   Node *transformed_sfpnt = _gvn.transform(sfpnt);
2486   set_control(transformed_sfpnt);
2487 
2488   // Provide an edge from root to safepoint.  This makes the safepoint
2489   // appear useful until the parse has completed.
2490   if( OptoRemoveUseless &amp;&amp; transformed_sfpnt-&gt;is_SafePoint() ) {
2491     assert(C-&gt;root() != NULL, &quot;Expect parse is still valid&quot;);
2492     C-&gt;root()-&gt;add_prec(transformed_sfpnt);
2493   }
2494 }
2495 
2496 #ifndef PRODUCT
2497 //------------------------show_parse_info--------------------------------------
2498 void Parse::show_parse_info() {
2499   InlineTree* ilt = NULL;
2500   if (C-&gt;ilt() != NULL) {
2501     JVMState* caller_jvms = is_osr_parse() ? caller()-&gt;caller() : caller();
</pre>
</td>
</tr>
</table>
<center><a href="output.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="subtypenode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  60 #include &quot;opto/narrowptrnode.hpp&quot;
  61 #include &quot;opto/node.hpp&quot;
  62 #include &quot;opto/opcodes.hpp&quot;
  63 #include &quot;opto/output.hpp&quot;
  64 #include &quot;opto/parse.hpp&quot;
  65 #include &quot;opto/phaseX.hpp&quot;
  66 #include &quot;opto/rootnode.hpp&quot;
  67 #include &quot;opto/runtime.hpp&quot;
  68 #include &quot;opto/stringopts.hpp&quot;
  69 #include &quot;opto/type.hpp&quot;
  70 #include &quot;opto/valuetypenode.hpp&quot;
  71 #include &quot;opto/vectornode.hpp&quot;
  72 #include &quot;runtime/arguments.hpp&quot;
  73 #include &quot;runtime/sharedRuntime.hpp&quot;
  74 #include &quot;runtime/signature.hpp&quot;
  75 #include &quot;runtime/stubRoutines.hpp&quot;
  76 #include &quot;runtime/timer.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/copy.hpp&quot;
  79 #include &quot;utilities/macros.hpp&quot;

  80 
  81 
  82 // -------------------- Compile::mach_constant_base_node -----------------------
  83 // Constant table base node singleton.
  84 MachConstantBaseNode* Compile::mach_constant_base_node() {
  85   if (_mach_constant_base_node == NULL) {
  86     _mach_constant_base_node = new MachConstantBaseNode();
  87     _mach_constant_base_node-&gt;add_req(C-&gt;root());
  88   }
  89   return _mach_constant_base_node;
  90 }
  91 
  92 
  93 /// Support for intrinsics.
  94 
  95 // Return the index at which m must be inserted (or already exists).
  96 // The sort order is by the address of the ciMethod, with is_virtual as minor key.
  97 class IntrinsicDescPair {
  98  private:
  99   ciMethod* _m;
</pre>
<hr />
<pre>
2615       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2616       return;
2617     }
2618     print_method(PHASE_MACRO_EXPANSION, 2);
2619   }
2620 
2621   {
2622     TracePhase tp(&quot;barrierExpand&quot;, &amp;timers[_t_barrierExpand]);
2623     if (bs-&gt;expand_barriers(this, igvn)) {
2624       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2625       return;
2626     }
2627     print_method(PHASE_BARRIER_EXPANSION, 2);
2628   }
2629 
2630   if (opaque4_count() &gt; 0) {
2631     C-&gt;remove_opaque4_nodes(igvn);
2632     igvn.optimize();
2633   }
2634 





2635   DEBUG_ONLY( _modified_nodes = NULL; )
2636  } // (End scope of igvn; run destructor if necessary for asserts.)
2637 
2638  process_print_inlining();
2639  // A method with only infinite loops has no edges entering loops from root
2640  {
2641    TracePhase tp(&quot;graphReshape&quot;, &amp;timers[_t_graphReshaping]);
2642    if (final_graph_reshaping()) {
2643      assert(failing(), &quot;must bail out w/ explicit message&quot;);
2644      return;
2645    }
2646  }
2647 
2648  print_method(PHASE_OPTIMIZE_FINISHED, 2);
2649 }
2650 
























































































































































































































































































































2651 //------------------------------Code_Gen---------------------------------------
2652 // Given a graph, generate code for it
2653 void Compile::Code_Gen() {
2654   if (failing()) {
2655     return;
2656   }
2657 
2658   // Perform instruction selection.  You might think we could reclaim Matcher
2659   // memory PDQ, but actually the Matcher is used in generating spill code.
2660   // Internals of the Matcher (including some VectorSets) must remain live
2661   // for awhile - thus I cannot reclaim Matcher memory lest a VectorSet usage
2662   // set a bit in reclaimed memory.
2663 
2664   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2665   // nodes.  Mapping is only valid at the root of each matched subtree.
2666   NOT_PRODUCT( verify_graph_edges(); )
2667 
2668   Matcher matcher;
2669   _matcher = &amp;matcher;
2670   {
</pre>
<hr />
<pre>
4707     int t = gen(di._key);
4708     if (g &lt; t) {
4709       g = t;
4710 #ifndef PRODUCT
4711       if (is_debug()) {
4712         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
4713       }
4714 #endif
4715     }
4716   }
4717   return g;
4718 }
4719 
4720 void CloneMap::dump(node_idx_t key) const {
4721   uint64_t val = value(key);
4722   if (val != 0) {
4723     NodeCloneInfo ni(val);
4724     ni.dump();
4725   }
4726 }


















</pre>
</td>
<td>
<hr />
<pre>
  60 #include &quot;opto/narrowptrnode.hpp&quot;
  61 #include &quot;opto/node.hpp&quot;
  62 #include &quot;opto/opcodes.hpp&quot;
  63 #include &quot;opto/output.hpp&quot;
  64 #include &quot;opto/parse.hpp&quot;
  65 #include &quot;opto/phaseX.hpp&quot;
  66 #include &quot;opto/rootnode.hpp&quot;
  67 #include &quot;opto/runtime.hpp&quot;
  68 #include &quot;opto/stringopts.hpp&quot;
  69 #include &quot;opto/type.hpp&quot;
  70 #include &quot;opto/valuetypenode.hpp&quot;
  71 #include &quot;opto/vectornode.hpp&quot;
  72 #include &quot;runtime/arguments.hpp&quot;
  73 #include &quot;runtime/sharedRuntime.hpp&quot;
  74 #include &quot;runtime/signature.hpp&quot;
  75 #include &quot;runtime/stubRoutines.hpp&quot;
  76 #include &quot;runtime/timer.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/copy.hpp&quot;
  79 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  80 #include &quot;utilities/resourceHash.hpp&quot;</span>
  81 
  82 
  83 // -------------------- Compile::mach_constant_base_node -----------------------
  84 // Constant table base node singleton.
  85 MachConstantBaseNode* Compile::mach_constant_base_node() {
  86   if (_mach_constant_base_node == NULL) {
  87     _mach_constant_base_node = new MachConstantBaseNode();
  88     _mach_constant_base_node-&gt;add_req(C-&gt;root());
  89   }
  90   return _mach_constant_base_node;
  91 }
  92 
  93 
  94 /// Support for intrinsics.
  95 
  96 // Return the index at which m must be inserted (or already exists).
  97 // The sort order is by the address of the ciMethod, with is_virtual as minor key.
  98 class IntrinsicDescPair {
  99  private:
 100   ciMethod* _m;
</pre>
<hr />
<pre>
2616       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2617       return;
2618     }
2619     print_method(PHASE_MACRO_EXPANSION, 2);
2620   }
2621 
2622   {
2623     TracePhase tp(&quot;barrierExpand&quot;, &amp;timers[_t_barrierExpand]);
2624     if (bs-&gt;expand_barriers(this, igvn)) {
2625       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2626       return;
2627     }
2628     print_method(PHASE_BARRIER_EXPANSION, 2);
2629   }
2630 
2631   if (opaque4_count() &gt; 0) {
2632     C-&gt;remove_opaque4_nodes(igvn);
2633     igvn.optimize();
2634   }
2635 
<span class="line-added">2636   if (C-&gt;max_vector_size() &gt; 0) {</span>
<span class="line-added">2637     C-&gt;optimize_logic_cones(igvn);</span>
<span class="line-added">2638     igvn.optimize();</span>
<span class="line-added">2639   }</span>
<span class="line-added">2640 </span>
2641   DEBUG_ONLY( _modified_nodes = NULL; )
2642  } // (End scope of igvn; run destructor if necessary for asserts.)
2643 
2644  process_print_inlining();
2645  // A method with only infinite loops has no edges entering loops from root
2646  {
2647    TracePhase tp(&quot;graphReshape&quot;, &amp;timers[_t_graphReshaping]);
2648    if (final_graph_reshaping()) {
2649      assert(failing(), &quot;must bail out w/ explicit message&quot;);
2650      return;
2651    }
2652  }
2653 
2654  print_method(PHASE_OPTIMIZE_FINISHED, 2);
2655 }
2656 
<span class="line-added">2657 //---------------------------- Bitwise operation packing optimization ---------------------------</span>
<span class="line-added">2658 </span>
<span class="line-added">2659 static bool is_vector_unary_bitwise_op(Node* n) {</span>
<span class="line-added">2660   return n-&gt;Opcode() == Op_XorV &amp;&amp;</span>
<span class="line-added">2661          VectorNode::is_vector_bitwise_not_pattern(n);</span>
<span class="line-added">2662 }</span>
<span class="line-added">2663 </span>
<span class="line-added">2664 static bool is_vector_binary_bitwise_op(Node* n) {</span>
<span class="line-added">2665   switch (n-&gt;Opcode()) {</span>
<span class="line-added">2666     case Op_AndV:</span>
<span class="line-added">2667     case Op_OrV:</span>
<span class="line-added">2668       return true;</span>
<span class="line-added">2669 </span>
<span class="line-added">2670     case Op_XorV:</span>
<span class="line-added">2671       return !is_vector_unary_bitwise_op(n);</span>
<span class="line-added">2672 </span>
<span class="line-added">2673     default:</span>
<span class="line-added">2674       return false;</span>
<span class="line-added">2675   }</span>
<span class="line-added">2676 }</span>
<span class="line-added">2677 </span>
<span class="line-added">2678 static bool is_vector_ternary_bitwise_op(Node* n) {</span>
<span class="line-added">2679   return n-&gt;Opcode() == Op_MacroLogicV;</span>
<span class="line-added">2680 }</span>
<span class="line-added">2681 </span>
<span class="line-added">2682 static bool is_vector_bitwise_op(Node* n) {</span>
<span class="line-added">2683   return is_vector_unary_bitwise_op(n)  ||</span>
<span class="line-added">2684          is_vector_binary_bitwise_op(n) ||</span>
<span class="line-added">2685          is_vector_ternary_bitwise_op(n);</span>
<span class="line-added">2686 }</span>
<span class="line-added">2687 </span>
<span class="line-added">2688 static bool is_vector_bitwise_cone_root(Node* n) {</span>
<span class="line-added">2689   if (!is_vector_bitwise_op(n)) {</span>
<span class="line-added">2690     return false;</span>
<span class="line-added">2691   }</span>
<span class="line-added">2692   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">2693     if (is_vector_bitwise_op(n-&gt;fast_out(i))) {</span>
<span class="line-added">2694       return false;</span>
<span class="line-added">2695     }</span>
<span class="line-added">2696   }</span>
<span class="line-added">2697   return true;</span>
<span class="line-added">2698 }</span>
<span class="line-added">2699 </span>
<span class="line-added">2700 static uint collect_unique_inputs(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {</span>
<span class="line-added">2701   uint cnt = 0;</span>
<span class="line-added">2702   if (is_vector_bitwise_op(n)) {</span>
<span class="line-added">2703     if (VectorNode::is_vector_bitwise_not_pattern(n)) {</span>
<span class="line-added">2704       for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-added">2705         Node* in = n-&gt;in(i);</span>
<span class="line-added">2706         bool skip = VectorNode::is_all_ones_vector(in);</span>
<span class="line-added">2707         if (!skip &amp;&amp; !inputs.member(in)) {</span>
<span class="line-added">2708           inputs.push(in);</span>
<span class="line-added">2709           cnt++;</span>
<span class="line-added">2710         }</span>
<span class="line-added">2711       }</span>
<span class="line-added">2712       assert(cnt &lt;= 1, &quot;not unary&quot;);</span>
<span class="line-added">2713     } else {</span>
<span class="line-added">2714       uint last_req = n-&gt;req();</span>
<span class="line-added">2715       if (is_vector_ternary_bitwise_op(n)) {</span>
<span class="line-added">2716         last_req = n-&gt;req() - 1; // skip last input</span>
<span class="line-added">2717       }</span>
<span class="line-added">2718       for (uint i = 1; i &lt; last_req; i++) {</span>
<span class="line-added">2719         Node* def = n-&gt;in(i);</span>
<span class="line-added">2720         if (!inputs.member(def)) {</span>
<span class="line-added">2721           inputs.push(def);</span>
<span class="line-added">2722           cnt++;</span>
<span class="line-added">2723         }</span>
<span class="line-added">2724       }</span>
<span class="line-added">2725     }</span>
<span class="line-added">2726     partition.push(n);</span>
<span class="line-added">2727   } else { // not a bitwise operations</span>
<span class="line-added">2728     if (!inputs.member(n)) {</span>
<span class="line-added">2729       inputs.push(n);</span>
<span class="line-added">2730       cnt++;</span>
<span class="line-added">2731     }</span>
<span class="line-added">2732   }</span>
<span class="line-added">2733   return cnt;</span>
<span class="line-added">2734 }</span>
<span class="line-added">2735 </span>
<span class="line-added">2736 void Compile::collect_logic_cone_roots(Unique_Node_List&amp; list) {</span>
<span class="line-added">2737   Unique_Node_List useful_nodes;</span>
<span class="line-added">2738   C-&gt;identify_useful_nodes(useful_nodes);</span>
<span class="line-added">2739 </span>
<span class="line-added">2740   for (uint i = 0; i &lt; useful_nodes.size(); i++) {</span>
<span class="line-added">2741     Node* n = useful_nodes.at(i);</span>
<span class="line-added">2742     if (is_vector_bitwise_cone_root(n)) {</span>
<span class="line-added">2743       list.push(n);</span>
<span class="line-added">2744     }</span>
<span class="line-added">2745   }</span>
<span class="line-added">2746 }</span>
<span class="line-added">2747 </span>
<span class="line-added">2748 Node* Compile::xform_to_MacroLogicV(PhaseIterGVN&amp; igvn,</span>
<span class="line-added">2749                                     const TypeVect* vt,</span>
<span class="line-added">2750                                     Unique_Node_List&amp; partition,</span>
<span class="line-added">2751                                     Unique_Node_List&amp; inputs) {</span>
<span class="line-added">2752   assert(partition.size() == 2 || partition.size() == 3, &quot;not supported&quot;);</span>
<span class="line-added">2753   assert(inputs.size()    == 2 || inputs.size()    == 3, &quot;not supported&quot;);</span>
<span class="line-added">2754   assert(Matcher::match_rule_supported_vector(Op_MacroLogicV, vt-&gt;length(), vt-&gt;element_basic_type()), &quot;not supported&quot;);</span>
<span class="line-added">2755 </span>
<span class="line-added">2756   Node* in1 = inputs.at(0);</span>
<span class="line-added">2757   Node* in2 = inputs.at(1);</span>
<span class="line-added">2758   Node* in3 = (inputs.size() == 3 ? inputs.at(2) : in2);</span>
<span class="line-added">2759 </span>
<span class="line-added">2760   uint func = compute_truth_table(partition, inputs);</span>
<span class="line-added">2761   return igvn.transform(MacroLogicVNode::make(igvn, in3, in2, in1, func, vt));</span>
<span class="line-added">2762 }</span>
<span class="line-added">2763 </span>
<span class="line-added">2764 static uint extract_bit(uint func, uint pos) {</span>
<span class="line-added">2765   return (func &amp; (1 &lt;&lt; pos)) &gt;&gt; pos;</span>
<span class="line-added">2766 }</span>
<span class="line-added">2767 </span>
<span class="line-added">2768 //</span>
<span class="line-added">2769 //  A macro logic node represents a truth table. It has 4 inputs,</span>
<span class="line-added">2770 //  First three inputs corresponds to 3 columns of a truth table</span>
<span class="line-added">2771 //  and fourth input captures the logic function.</span>
<span class="line-added">2772 //</span>
<span class="line-added">2773 //  eg.  fn = (in1 AND in2) OR in3;</span>
<span class="line-added">2774 //</span>
<span class="line-added">2775 //      MacroNode(in1,in2,in3,fn)</span>
<span class="line-added">2776 //</span>
<span class="line-added">2777 //  -----------------</span>
<span class="line-added">2778 //  in1 in2 in3  fn</span>
<span class="line-added">2779 //  -----------------</span>
<span class="line-added">2780 //  0    0   0    0</span>
<span class="line-added">2781 //  0    0   1    1</span>
<span class="line-added">2782 //  0    1   0    0</span>
<span class="line-added">2783 //  0    1   1    1</span>
<span class="line-added">2784 //  1    0   0    0</span>
<span class="line-added">2785 //  1    0   1    1</span>
<span class="line-added">2786 //  1    1   0    1</span>
<span class="line-added">2787 //  1    1   1    1</span>
<span class="line-added">2788 //</span>
<span class="line-added">2789 </span>
<span class="line-added">2790 uint Compile::eval_macro_logic_op(uint func, uint in1 , uint in2, uint in3) {</span>
<span class="line-added">2791   int res = 0;</span>
<span class="line-added">2792   for (int i = 0; i &lt; 8; i++) {</span>
<span class="line-added">2793     int bit1 = extract_bit(in1, i);</span>
<span class="line-added">2794     int bit2 = extract_bit(in2, i);</span>
<span class="line-added">2795     int bit3 = extract_bit(in3, i);</span>
<span class="line-added">2796 </span>
<span class="line-added">2797     int func_bit_pos = (bit1 &lt;&lt; 2 | bit2 &lt;&lt; 1 | bit3);</span>
<span class="line-added">2798     int func_bit = extract_bit(func, func_bit_pos);</span>
<span class="line-added">2799 </span>
<span class="line-added">2800     res |= func_bit &lt;&lt; i;</span>
<span class="line-added">2801   }</span>
<span class="line-added">2802   return res;</span>
<span class="line-added">2803 }</span>
<span class="line-added">2804 </span>
<span class="line-added">2805 static uint eval_operand(Node* n, ResourceHashtable&lt;Node*,uint&gt;&amp; eval_map) {</span>
<span class="line-added">2806   assert(n != NULL, &quot;&quot;);</span>
<span class="line-added">2807   assert(eval_map.contains(n), &quot;absent&quot;);</span>
<span class="line-added">2808   return *(eval_map.get(n));</span>
<span class="line-added">2809 }</span>
<span class="line-added">2810 </span>
<span class="line-added">2811 static void eval_operands(Node* n,</span>
<span class="line-added">2812                           uint&amp; func1, uint&amp; func2, uint&amp; func3,</span>
<span class="line-added">2813                           ResourceHashtable&lt;Node*,uint&gt;&amp; eval_map) {</span>
<span class="line-added">2814   assert(is_vector_bitwise_op(n), &quot;&quot;);</span>
<span class="line-added">2815   func1 = eval_operand(n-&gt;in(1), eval_map);</span>
<span class="line-added">2816 </span>
<span class="line-added">2817   if (is_vector_binary_bitwise_op(n)) {</span>
<span class="line-added">2818     func2 = eval_operand(n-&gt;in(2), eval_map);</span>
<span class="line-added">2819   } else if (is_vector_ternary_bitwise_op(n)) {</span>
<span class="line-added">2820     func2 = eval_operand(n-&gt;in(2), eval_map);</span>
<span class="line-added">2821     func3 = eval_operand(n-&gt;in(3), eval_map);</span>
<span class="line-added">2822   } else {</span>
<span class="line-added">2823     assert(is_vector_unary_bitwise_op(n), &quot;not unary&quot;);</span>
<span class="line-added">2824   }</span>
<span class="line-added">2825 }</span>
<span class="line-added">2826 </span>
<span class="line-added">2827 uint Compile::compute_truth_table(Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {</span>
<span class="line-added">2828   assert(inputs.size() &lt;= 3, &quot;sanity&quot;);</span>
<span class="line-added">2829   ResourceMark rm;</span>
<span class="line-added">2830   uint res = 0;</span>
<span class="line-added">2831   ResourceHashtable&lt;Node*,uint&gt; eval_map;</span>
<span class="line-added">2832 </span>
<span class="line-added">2833   // Populate precomputed functions for inputs.</span>
<span class="line-added">2834   // Each input corresponds to one column of 3 input truth-table.</span>
<span class="line-added">2835   uint input_funcs[] = { 0xAA,   // (_, _, a) -&gt; a</span>
<span class="line-added">2836                          0xCC,   // (_, b, _) -&gt; b</span>
<span class="line-added">2837                          0xF0 }; // (c, _, _) -&gt; c</span>
<span class="line-added">2838   for (uint i = 0; i &lt; inputs.size(); i++) {</span>
<span class="line-added">2839     eval_map.put(inputs.at(i), input_funcs[i]);</span>
<span class="line-added">2840   }</span>
<span class="line-added">2841 </span>
<span class="line-added">2842   for (uint i = 0; i &lt; partition.size(); i++) {</span>
<span class="line-added">2843     Node* n = partition.at(i);</span>
<span class="line-added">2844 </span>
<span class="line-added">2845     uint func1 = 0, func2 = 0, func3 = 0;</span>
<span class="line-added">2846     eval_operands(n, func1, func2, func3, eval_map);</span>
<span class="line-added">2847 </span>
<span class="line-added">2848     switch (n-&gt;Opcode()) {</span>
<span class="line-added">2849       case Op_OrV:</span>
<span class="line-added">2850         assert(func3 == 0, &quot;not binary&quot;);</span>
<span class="line-added">2851         res = func1 | func2;</span>
<span class="line-added">2852         break;</span>
<span class="line-added">2853       case Op_AndV:</span>
<span class="line-added">2854         assert(func3 == 0, &quot;not binary&quot;);</span>
<span class="line-added">2855         res = func1 &amp; func2;</span>
<span class="line-added">2856         break;</span>
<span class="line-added">2857       case Op_XorV:</span>
<span class="line-added">2858         if (VectorNode::is_vector_bitwise_not_pattern(n)) {</span>
<span class="line-added">2859           assert(func2 == 0 &amp;&amp; func3 == 0, &quot;not unary&quot;);</span>
<span class="line-added">2860           res = (~func1) &amp; 0xFF;</span>
<span class="line-added">2861         } else {</span>
<span class="line-added">2862           assert(func3 == 0, &quot;not binary&quot;);</span>
<span class="line-added">2863           res = func1 ^ func2;</span>
<span class="line-added">2864         }</span>
<span class="line-added">2865         break;</span>
<span class="line-added">2866       case Op_MacroLogicV:</span>
<span class="line-added">2867         // Ordering of inputs may change during evaluation of sub-tree</span>
<span class="line-added">2868         // containing MacroLogic node as a child node, thus a re-evaluation</span>
<span class="line-added">2869         // makes sure that function is evaluated in context of current</span>
<span class="line-added">2870         // inputs.</span>
<span class="line-added">2871         res = eval_macro_logic_op(n-&gt;in(4)-&gt;get_int(), func1, func2, func3);</span>
<span class="line-added">2872         break;</span>
<span class="line-added">2873 </span>
<span class="line-added">2874       default: assert(false, &quot;not supported: %s&quot;, n-&gt;Name());</span>
<span class="line-added">2875     }</span>
<span class="line-added">2876     assert(res &lt;= 0xFF, &quot;invalid&quot;);</span>
<span class="line-added">2877     eval_map.put(n, res);</span>
<span class="line-added">2878   }</span>
<span class="line-added">2879   return res;</span>
<span class="line-added">2880 }</span>
<span class="line-added">2881 </span>
<span class="line-added">2882 bool Compile::compute_logic_cone(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {</span>
<span class="line-added">2883   assert(partition.size() == 0, &quot;not empty&quot;);</span>
<span class="line-added">2884   assert(inputs.size() == 0, &quot;not empty&quot;);</span>
<span class="line-added">2885   assert(!is_vector_ternary_bitwise_op(n), &quot;not supported&quot;);</span>
<span class="line-added">2886 </span>
<span class="line-added">2887   bool is_unary_op = is_vector_unary_bitwise_op(n);</span>
<span class="line-added">2888   if (is_unary_op) {</span>
<span class="line-added">2889     assert(collect_unique_inputs(n, partition, inputs) == 1, &quot;not unary&quot;);</span>
<span class="line-added">2890     return false; // too few inputs</span>
<span class="line-added">2891   }</span>
<span class="line-added">2892 </span>
<span class="line-added">2893   assert(is_vector_binary_bitwise_op(n), &quot;not binary&quot;);</span>
<span class="line-added">2894   Node* in1 = n-&gt;in(1);</span>
<span class="line-added">2895   Node* in2 = n-&gt;in(2);</span>
<span class="line-added">2896 </span>
<span class="line-added">2897   int in1_unique_inputs_cnt = collect_unique_inputs(in1, partition, inputs);</span>
<span class="line-added">2898   int in2_unique_inputs_cnt = collect_unique_inputs(in2, partition, inputs);</span>
<span class="line-added">2899   partition.push(n);</span>
<span class="line-added">2900 </span>
<span class="line-added">2901   // Too many inputs?</span>
<span class="line-added">2902   if (inputs.size() &gt; 3) {</span>
<span class="line-added">2903     partition.clear();</span>
<span class="line-added">2904     inputs.clear();</span>
<span class="line-added">2905     { // Recompute in2 inputs</span>
<span class="line-added">2906       Unique_Node_List not_used;</span>
<span class="line-added">2907       in2_unique_inputs_cnt = collect_unique_inputs(in2, not_used, not_used);</span>
<span class="line-added">2908     }</span>
<span class="line-added">2909     // Pick the node with minimum number of inputs.</span>
<span class="line-added">2910     if (in1_unique_inputs_cnt &gt;= 3 &amp;&amp; in2_unique_inputs_cnt &gt;= 3) {</span>
<span class="line-added">2911       return false; // still too many inputs</span>
<span class="line-added">2912     }</span>
<span class="line-added">2913     // Recompute partition &amp; inputs.</span>
<span class="line-added">2914     Node* child       = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in1 : in2);</span>
<span class="line-added">2915     collect_unique_inputs(child, partition, inputs);</span>
<span class="line-added">2916 </span>
<span class="line-added">2917     Node* other_input = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in2 : in1);</span>
<span class="line-added">2918     inputs.push(other_input);</span>
<span class="line-added">2919 </span>
<span class="line-added">2920     partition.push(n);</span>
<span class="line-added">2921   }</span>
<span class="line-added">2922 </span>
<span class="line-added">2923   return (partition.size() == 2 || partition.size() == 3) &amp;&amp;</span>
<span class="line-added">2924          (inputs.size()    == 2 || inputs.size()    == 3);</span>
<span class="line-added">2925 }</span>
<span class="line-added">2926 </span>
<span class="line-added">2927 void Compile::process_logic_cone_root(PhaseIterGVN &amp;igvn, Node *n, VectorSet &amp;visited) {</span>
<span class="line-added">2928   assert(is_vector_bitwise_op(n), &quot;not a root&quot;);</span>
<span class="line-added">2929 </span>
<span class="line-added">2930   visited.set(n-&gt;_idx);</span>
<span class="line-added">2931 </span>
<span class="line-added">2932   // 1) Do a DFS walk over the logic cone.</span>
<span class="line-added">2933   for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-added">2934     Node* in = n-&gt;in(i);</span>
<span class="line-added">2935     if (!visited.test(in-&gt;_idx) &amp;&amp; is_vector_bitwise_op(in)) {</span>
<span class="line-added">2936       process_logic_cone_root(igvn, in, visited);</span>
<span class="line-added">2937     }</span>
<span class="line-added">2938   }</span>
<span class="line-added">2939 </span>
<span class="line-added">2940   // 2) Bottom up traversal: Merge node[s] with</span>
<span class="line-added">2941   // the parent to form macro logic node.</span>
<span class="line-added">2942   Unique_Node_List partition;</span>
<span class="line-added">2943   Unique_Node_List inputs;</span>
<span class="line-added">2944   if (compute_logic_cone(n, partition, inputs)) {</span>
<span class="line-added">2945     const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();</span>
<span class="line-added">2946     Node* macro_logic = xform_to_MacroLogicV(igvn, vt, partition, inputs);</span>
<span class="line-added">2947     igvn.replace_node(n, macro_logic);</span>
<span class="line-added">2948   }</span>
<span class="line-added">2949 }</span>
<span class="line-added">2950 </span>
<span class="line-added">2951 void Compile::optimize_logic_cones(PhaseIterGVN &amp;igvn) {</span>
<span class="line-added">2952   ResourceMark rm;</span>
<span class="line-added">2953   if (Matcher::match_rule_supported(Op_MacroLogicV)) {</span>
<span class="line-added">2954     Unique_Node_List list;</span>
<span class="line-added">2955     collect_logic_cone_roots(list);</span>
<span class="line-added">2956 </span>
<span class="line-added">2957     while (list.size() &gt; 0) {</span>
<span class="line-added">2958       Node* n = list.pop();</span>
<span class="line-added">2959       const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();</span>
<span class="line-added">2960       bool supported = Matcher::match_rule_supported_vector(Op_MacroLogicV, vt-&gt;length(), vt-&gt;element_basic_type());</span>
<span class="line-added">2961       if (supported) {</span>
<span class="line-added">2962         VectorSet visited(comp_arena());</span>
<span class="line-added">2963         process_logic_cone_root(igvn, n, visited);</span>
<span class="line-added">2964       }</span>
<span class="line-added">2965     }</span>
<span class="line-added">2966   }</span>
<span class="line-added">2967 }</span>
<span class="line-added">2968 </span>
2969 //------------------------------Code_Gen---------------------------------------
2970 // Given a graph, generate code for it
2971 void Compile::Code_Gen() {
2972   if (failing()) {
2973     return;
2974   }
2975 
2976   // Perform instruction selection.  You might think we could reclaim Matcher
2977   // memory PDQ, but actually the Matcher is used in generating spill code.
2978   // Internals of the Matcher (including some VectorSets) must remain live
2979   // for awhile - thus I cannot reclaim Matcher memory lest a VectorSet usage
2980   // set a bit in reclaimed memory.
2981 
2982   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2983   // nodes.  Mapping is only valid at the root of each matched subtree.
2984   NOT_PRODUCT( verify_graph_edges(); )
2985 
2986   Matcher matcher;
2987   _matcher = &amp;matcher;
2988   {
</pre>
<hr />
<pre>
5025     int t = gen(di._key);
5026     if (g &lt; t) {
5027       g = t;
5028 #ifndef PRODUCT
5029       if (is_debug()) {
5030         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
5031       }
5032 #endif
5033     }
5034   }
5035   return g;
5036 }
5037 
5038 void CloneMap::dump(node_idx_t key) const {
5039   uint64_t val = value(key);
5040   if (val != 0) {
5041     NodeCloneInfo ni(val);
5042     ni.dump();
5043   }
5044 }
<span class="line-added">5045 </span>
<span class="line-added">5046 </span>
<span class="line-added">5047 // Move Allocate nodes to the start of the list</span>
<span class="line-added">5048 void Compile::sort_macro_nodes() {</span>
<span class="line-added">5049   int count = macro_count();</span>
<span class="line-added">5050   int allocates = 0;</span>
<span class="line-added">5051   for (int i = 0; i &lt; count; i++) {</span>
<span class="line-added">5052     Node* n = macro_node(i);</span>
<span class="line-added">5053     if (n-&gt;is_Allocate()) {</span>
<span class="line-added">5054       if (i != allocates) {</span>
<span class="line-added">5055         Node* tmp = macro_node(allocates);</span>
<span class="line-added">5056         _macro_nodes-&gt;at_put(allocates, n);</span>
<span class="line-added">5057         _macro_nodes-&gt;at_put(i, tmp);</span>
<span class="line-added">5058       }</span>
<span class="line-added">5059       allocates++;</span>
<span class="line-added">5060     }</span>
<span class="line-added">5061   }</span>
<span class="line-added">5062 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopUnswitch.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopUnswitch.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
299         }
300       }
301       ProjNode* invar_proj = invar_iff-&gt;proj_out(proj-&gt;_con)-&gt;as_Proj();
302       while (worklist.size() &gt; 0) {
303         Node* use = worklist.pop();
304         Node* nuse = use-&gt;clone();
305         nuse-&gt;set_req(0, invar_proj);
306         _igvn.replace_input_of(use, 1, nuse);
307         register_new_node(nuse, invar_proj);
308         // Same for the clone
309         Node* use_clone = old_new[use-&gt;_idx];
310         _igvn.replace_input_of(use_clone, 1, nuse);
311       }
312     }
313   }
314 
315   IfNode* unswitch_iff_clone = old_new[unswitch_iff-&gt;_idx]-&gt;as_If();
316   if (flattened_checks.size() &gt; 0) {
317     for (uint i = 0; i &lt; flattened_checks.size(); i++) {
318       IfNode* iff = flattened_checks.at(i)-&gt;as_If();
<span class="line-modified">319       _igvn.rehash_node_delayed(iff);</span>
320       short_circuit_if(old_new[iff-&gt;_idx]-&gt;as_If(), proj_false);
321     }
322   } else {
323     // Hardwire the control paths in the loops into if(true) and if(false)
<span class="line-modified">324     _igvn.rehash_node_delayed(unswitch_iff);</span>
325     short_circuit_if(unswitch_iff, proj_true);

326 
<span class="line-modified">327     _igvn.rehash_node_delayed(unswitch_iff_clone);</span>
328     short_circuit_if(unswitch_iff_clone, proj_false);
329   }
330 
331   // Reoptimize loops
332   loop-&gt;record_for_igvn();
333   for(int i = loop-&gt;_body.size() - 1; i &gt;= 0 ; i--) {
334     Node *n = loop-&gt;_body[i];
335     Node *n_clone = old_new[n-&gt;_idx];
336     _igvn._worklist.push(n_clone);
337   }
338 
339 #ifndef PRODUCT
340   if (TraceLoopUnswitching) {
341     tty-&gt;print_cr(&quot;Loop unswitching orig: %d @ %d  new: %d @ %d&quot;,
342                   head-&gt;_idx,                unswitch_iff-&gt;_idx,
343                   old_new[head-&gt;_idx]-&gt;_idx, unswitch_iff_clone-&gt;_idx);
344   }
345 #endif
346 
347   C-&gt;set_major_progress();
</pre>
</td>
<td>
<hr />
<pre>
299         }
300       }
301       ProjNode* invar_proj = invar_iff-&gt;proj_out(proj-&gt;_con)-&gt;as_Proj();
302       while (worklist.size() &gt; 0) {
303         Node* use = worklist.pop();
304         Node* nuse = use-&gt;clone();
305         nuse-&gt;set_req(0, invar_proj);
306         _igvn.replace_input_of(use, 1, nuse);
307         register_new_node(nuse, invar_proj);
308         // Same for the clone
309         Node* use_clone = old_new[use-&gt;_idx];
310         _igvn.replace_input_of(use_clone, 1, nuse);
311       }
312     }
313   }
314 
315   IfNode* unswitch_iff_clone = old_new[unswitch_iff-&gt;_idx]-&gt;as_If();
316   if (flattened_checks.size() &gt; 0) {
317     for (uint i = 0; i &lt; flattened_checks.size(); i++) {
318       IfNode* iff = flattened_checks.at(i)-&gt;as_If();
<span class="line-modified">319       _igvn.rehash_node_delayed(iff);</span>
320       dominated_by(proj_false, old_new[iff-&gt;_idx]-&gt;as_If(), false, false);
321     }
322   } else {
323     // Hardwire the control paths in the loops into if(true) and if(false)
<span class="line-modified">324     _igvn.rehash_node_delayed(unswitch_iff);</span>
325     dominated_by(proj_true, unswitch_iff, false, false);
<span class="line-added">326 </span>
327     IfNode* unswitch_iff_clone = old_new[unswitch_iff-&gt;_idx]-&gt;as_If();
<span class="line-modified">328     _igvn.rehash_node_delayed(unswitch_iff_clone);</span>
329     dominated_by(proj_false, unswitch_iff_clone, false, false);
330   }
331 
332   // Reoptimize loops
333   loop-&gt;record_for_igvn();
334   for(int i = loop-&gt;_body.size() - 1; i &gt;= 0 ; i--) {
335     Node *n = loop-&gt;_body[i];
336     Node *n_clone = old_new[n-&gt;_idx];
337     _igvn._worklist.push(n_clone);
338   }
339 
340 #ifndef PRODUCT
341   if (TraceLoopUnswitching) {
342     tty-&gt;print_cr(&quot;Loop unswitching orig: %d @ %d  new: %d @ %d&quot;,
343                   head-&gt;_idx,                unswitch_iff-&gt;_idx,
344                   old_new[head-&gt;_idx]-&gt;_idx, unswitch_iff_clone-&gt;_idx);
345   }
346 #endif
347 
348   C-&gt;set_major_progress();
</pre>
</td>
</tr>
</table>
<center><a href="compile.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
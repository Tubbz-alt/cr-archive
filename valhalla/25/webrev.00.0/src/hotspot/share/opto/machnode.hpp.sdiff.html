<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/machnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="machnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/machnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 270   // specific MachNodes described in the ADL.
 271   uint _num_opnds;
 272   MachOper **_opnds;
 273   uint  num_opnds() const { return _num_opnds; }
 274 
 275   // Emit bytes into cbuf
 276   virtual void  emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 277   // Expand node after register allocation.
 278   // Node is replaced by several nodes in the postalloc expand phase.
 279   // Corresponding methods are generated for nodes if they specify
 280   // postalloc_expand. See block.cpp for more documentation.
 281   virtual bool requires_postalloc_expand() const { return false; }
 282   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 283   // Size of instruction in bytes
 284   virtual uint  size(PhaseRegAlloc *ra_) const;
 285   // Helper function that computes size by emitting code
 286   virtual uint  emit_size(PhaseRegAlloc *ra_) const;
 287 
 288   // Return the alignment required (in units of relocInfo::addr_unit())
 289   // for this instruction (must be a power of 2)
<span class="line-modified"> 290   virtual int   alignment_required() const { return 1; }</span>

 291 
 292   // Return the padding (in bytes) to be emitted before this
 293   // instruction to properly align it.
<span class="line-modified"> 294   virtual int   compute_padding(int current_offset) const { return 0; }</span>
 295 
 296   // Return number of relocatable values contained in this instruction
 297   virtual int   reloc() const { return 0; }
 298 
 299   // Return number of words used for double constants in this instruction
 300   virtual int   ins_num_consts() const { return 0; }
 301 
 302   // Hash and compare over operands.  Used to do GVN on machine Nodes.
 303   virtual uint  hash() const;
 304   virtual bool  cmp( const Node &amp;n ) const;
 305 
 306   // Expand method for MachNode, replaces nodes representing pseudo
 307   // instructions with a set of nodes which represent real machine
 308   // instructions and compute the same value.
 309   virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
 310 
 311   // Bottom_type call; value comes from operand0
 312   virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
 313   virtual uint ideal_reg() const {
 314     const Type *t = _opnds[0]-&gt;type();
</pre>
<hr />
<pre>
 542   virtual const char *Name() const { return &quot;Prolog&quot;; }
 543   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 544 #endif
 545 };
 546 
 547 //------------------------------MachEpilogNode--------------------------------
 548 // Machine function Epilog Node
 549 class MachEpilogNode : public MachIdealNode {
 550 public:
 551   MachEpilogNode(bool do_poll = false) : _do_polling(do_poll) {}
 552   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 553   virtual int reloc() const;
 554   virtual const Pipeline *pipeline() const;
 555 
 556 private:
 557   bool _do_polling;
 558 
 559 public:
 560   bool do_polling() const { return _do_polling; }
 561 
<span class="line-removed"> 562   // Offset of safepoint from the beginning of the node</span>
<span class="line-removed"> 563   int safepoint_offset() const;</span>
<span class="line-removed"> 564 </span>
 565 #ifndef PRODUCT
 566   virtual const char *Name() const { return &quot;Epilog&quot;; }
 567   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 568 #endif
 569 };
 570 
 571 //------------------------------MachNopNode-----------------------------------
 572 // Machine function Nop Node
 573 class MachNopNode : public MachIdealNode {
 574 private:
 575   int _count;
 576 public:
 577   MachNopNode( ) : _count(1) {}
 578   MachNopNode( int count ) : _count(count) {}
 579   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 580   virtual uint size(PhaseRegAlloc *ra_) const;
 581 
 582   virtual const class Type *bottom_type() const { return Type::CONTROL; }
 583 
 584   virtual int ideal_Opcode() const { return Op_Con; } // bogus; see output.cpp
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 270   // specific MachNodes described in the ADL.
 271   uint _num_opnds;
 272   MachOper **_opnds;
 273   uint  num_opnds() const { return _num_opnds; }
 274 
 275   // Emit bytes into cbuf
 276   virtual void  emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 277   // Expand node after register allocation.
 278   // Node is replaced by several nodes in the postalloc expand phase.
 279   // Corresponding methods are generated for nodes if they specify
 280   // postalloc_expand. See block.cpp for more documentation.
 281   virtual bool requires_postalloc_expand() const { return false; }
 282   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 283   // Size of instruction in bytes
 284   virtual uint  size(PhaseRegAlloc *ra_) const;
 285   // Helper function that computes size by emitting code
 286   virtual uint  emit_size(PhaseRegAlloc *ra_) const;
 287 
 288   // Return the alignment required (in units of relocInfo::addr_unit())
 289   // for this instruction (must be a power of 2)
<span class="line-modified"> 290   int           pd_alignment_required() const;</span>
<span class="line-added"> 291   virtual int   alignment_required() const { return pd_alignment_required(); }</span>
 292 
 293   // Return the padding (in bytes) to be emitted before this
 294   // instruction to properly align it.
<span class="line-modified"> 295   virtual int   compute_padding(int current_offset) const;</span>
 296 
 297   // Return number of relocatable values contained in this instruction
 298   virtual int   reloc() const { return 0; }
 299 
 300   // Return number of words used for double constants in this instruction
 301   virtual int   ins_num_consts() const { return 0; }
 302 
 303   // Hash and compare over operands.  Used to do GVN on machine Nodes.
 304   virtual uint  hash() const;
 305   virtual bool  cmp( const Node &amp;n ) const;
 306 
 307   // Expand method for MachNode, replaces nodes representing pseudo
 308   // instructions with a set of nodes which represent real machine
 309   // instructions and compute the same value.
 310   virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
 311 
 312   // Bottom_type call; value comes from operand0
 313   virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
 314   virtual uint ideal_reg() const {
 315     const Type *t = _opnds[0]-&gt;type();
</pre>
<hr />
<pre>
 543   virtual const char *Name() const { return &quot;Prolog&quot;; }
 544   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 545 #endif
 546 };
 547 
 548 //------------------------------MachEpilogNode--------------------------------
 549 // Machine function Epilog Node
 550 class MachEpilogNode : public MachIdealNode {
 551 public:
 552   MachEpilogNode(bool do_poll = false) : _do_polling(do_poll) {}
 553   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 554   virtual int reloc() const;
 555   virtual const Pipeline *pipeline() const;
 556 
 557 private:
 558   bool _do_polling;
 559 
 560 public:
 561   bool do_polling() const { return _do_polling; }
 562 



 563 #ifndef PRODUCT
 564   virtual const char *Name() const { return &quot;Epilog&quot;; }
 565   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 566 #endif
 567 };
 568 
 569 //------------------------------MachNopNode-----------------------------------
 570 // Machine function Nop Node
 571 class MachNopNode : public MachIdealNode {
 572 private:
 573   int _count;
 574 public:
 575   MachNopNode( ) : _count(1) {}
 576   MachNopNode( int count ) : _count(count) {}
 577   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 578   virtual uint size(PhaseRegAlloc *ra_) const;
 579 
 580   virtual const class Type *bottom_type() const { return Type::CONTROL; }
 581 
 582   virtual int ideal_Opcode() const { return Op_Con; } // bogus; see output.cpp
</pre>
</td>
</tr>
</table>
<center><a href="machnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
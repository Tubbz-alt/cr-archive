<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopUnswitch.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  67 class OptoReg;
  68 class PhaseCFG;
  69 class PhaseGVN;
  70 class PhaseIterGVN;
  71 class PhaseRegAlloc;
  72 class PhaseCCP;
  73 class PhaseCCP_DCE;
  74 class PhaseOutput;
  75 class RootNode;
  76 class relocInfo;
  77 class Scope;
  78 class StartNode;
  79 class SafePointNode;
  80 class JVMState;
  81 class Type;
  82 class TypeData;
  83 class TypeInt;
  84 class TypePtr;
  85 class TypeOopPtr;
  86 class TypeFunc;
<span class="line-modified">  87 class ValueTypeBaseNode;</span>
  88 class Unique_Node_List;

  89 class nmethod;
  90 class WarmCallInfo;
  91 class Node_Stack;
  92 struct Final_Reshape_Counts;
  93 
  94 enum LoopOptsMode {
  95   LoopOptsDefault,
  96   LoopOptsNone,
  97   LoopOptsMaxUnroll,
  98   LoopOptsShenandoahExpand,
  99   LoopOptsShenandoahPostExpand,
 100   LoopOptsSkipSplitIf,
 101   LoopOptsVerify
 102 };
 103 
 104 typedef unsigned int node_idx_t;
 105 class NodeCloneInfo {
 106  private:
 107   uint64_t _idx_clone_orig;
 108  public:
</pre>
<hr />
<pre>
 721   void  remove_range_check_casts(PhaseIterGVN &amp;igvn);
 722 
 723   void add_opaque4_node(Node* n);
 724   void remove_opaque4_node(Node* n) {
 725     if (_opaque4_nodes-&gt;contains(n)) {
 726       _opaque4_nodes-&gt;remove(n);
 727     }
 728   }
 729   Node* opaque4_node(int idx) const { return _opaque4_nodes-&gt;at(idx);  }
 730   int   opaque4_count()       const { return _opaque4_nodes-&gt;length(); }
 731   void  remove_opaque4_nodes(PhaseIterGVN &amp;igvn);
 732 
 733   // Keep track of value type nodes for later processing
 734   void add_value_type(Node* n);
 735   void remove_value_type(Node* n);
 736   void process_value_types(PhaseIterGVN &amp;igvn);
 737   bool can_add_value_type() const { return _value_type_nodes != NULL; }
 738 
 739   void adjust_flattened_array_access_aliases(PhaseIterGVN&amp; igvn);
 740 


 741   // remove the opaque nodes that protect the predicates so that the unused checks and
 742   // uncommon traps will be eliminated from the graph.
 743   void cleanup_loop_predicates(PhaseIterGVN &amp;igvn);
 744   bool is_predicate_opaq(Node * n) {
 745     return _predicate_opaqs-&gt;contains(n);
 746   }
 747 
 748   // Are there candidate expensive nodes for optimization?
 749   bool should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn);
 750   // Check whether n1 and n2 are similar
 751   static int cmp_expensive_nodes(Node* n1, Node* n2);
 752   // Sort expensive nodes to locate similar expensive nodes
 753   void sort_expensive_nodes();
 754 
 755   // Compilation environment.
 756   Arena*      comp_arena()           { return &amp;_comp_arena; }
 757   ciEnv*      env() const            { return _env; }
 758   CompileLog* log() const            { return _log; }
 759   bool        failing() const        { return _env-&gt;failing() || _failure_reason != NULL; }
 760   const char* failure_reason() const { return (_env-&gt;failing()) ? _env-&gt;failure_reason() : _failure_reason; }
</pre>
<hr />
<pre>
1107   void verify_top(Node*) const PRODUCT_RETURN;
1108 
1109   // Intrinsic setup.
1110   void           register_library_intrinsics();                            // initializer
1111   CallGenerator* make_vm_intrinsic(ciMethod* m, bool is_virtual);          // constructor
1112   int            intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found);  // helper
1113   CallGenerator* find_intrinsic(ciMethod* m, bool is_virtual);             // query fn
1114   void           register_intrinsic(CallGenerator* cg);                    // update fn
1115 
1116 #ifndef PRODUCT
1117   static juint  _intrinsic_hist_count[vmIntrinsics::ID_LIMIT];
1118   static jubyte _intrinsic_hist_flags[vmIntrinsics::ID_LIMIT];
1119 #endif
1120   // Function calls made by the public function final_graph_reshaping.
1121   // No need to be made public as they are not called elsewhere.
1122   void final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc);
1123   void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop);
1124   void final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc );
1125   void eliminate_redundant_card_marks(Node* n);
1126 









1127  public:
1128 
1129   // Note:  Histogram array size is about 1 Kb.
1130   enum {                        // flag bits:
1131     _intrinsic_worked = 1,      // succeeded at least once
1132     _intrinsic_failed = 2,      // tried it but it failed
1133     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1134     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1135     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1136   };
1137   // Update histogram.  Return boolean if this is a first-time occurrence.
1138   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1139                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1140   static void print_intrinsic_statistics() PRODUCT_RETURN;
1141 
1142   // Graph verification code
1143   // Walk the node list, verifying that there is a one-to-one
1144   // correspondence between Use-Def edges and Def-Use edges
1145   // The option no_dead_code enables stronger checks that the
1146   // graph is strongly connected from root in both directions.
</pre>
</td>
<td>
<hr />
<pre>
  67 class OptoReg;
  68 class PhaseCFG;
  69 class PhaseGVN;
  70 class PhaseIterGVN;
  71 class PhaseRegAlloc;
  72 class PhaseCCP;
  73 class PhaseCCP_DCE;
  74 class PhaseOutput;
  75 class RootNode;
  76 class relocInfo;
  77 class Scope;
  78 class StartNode;
  79 class SafePointNode;
  80 class JVMState;
  81 class Type;
  82 class TypeData;
  83 class TypeInt;
  84 class TypePtr;
  85 class TypeOopPtr;
  86 class TypeFunc;
<span class="line-modified">  87 class TypeVect;</span>
  88 class Unique_Node_List;
<span class="line-added">  89 class ValueTypeBaseNode;</span>
  90 class nmethod;
  91 class WarmCallInfo;
  92 class Node_Stack;
  93 struct Final_Reshape_Counts;
  94 
  95 enum LoopOptsMode {
  96   LoopOptsDefault,
  97   LoopOptsNone,
  98   LoopOptsMaxUnroll,
  99   LoopOptsShenandoahExpand,
 100   LoopOptsShenandoahPostExpand,
 101   LoopOptsSkipSplitIf,
 102   LoopOptsVerify
 103 };
 104 
 105 typedef unsigned int node_idx_t;
 106 class NodeCloneInfo {
 107  private:
 108   uint64_t _idx_clone_orig;
 109  public:
</pre>
<hr />
<pre>
 722   void  remove_range_check_casts(PhaseIterGVN &amp;igvn);
 723 
 724   void add_opaque4_node(Node* n);
 725   void remove_opaque4_node(Node* n) {
 726     if (_opaque4_nodes-&gt;contains(n)) {
 727       _opaque4_nodes-&gt;remove(n);
 728     }
 729   }
 730   Node* opaque4_node(int idx) const { return _opaque4_nodes-&gt;at(idx);  }
 731   int   opaque4_count()       const { return _opaque4_nodes-&gt;length(); }
 732   void  remove_opaque4_nodes(PhaseIterGVN &amp;igvn);
 733 
 734   // Keep track of value type nodes for later processing
 735   void add_value_type(Node* n);
 736   void remove_value_type(Node* n);
 737   void process_value_types(PhaseIterGVN &amp;igvn);
 738   bool can_add_value_type() const { return _value_type_nodes != NULL; }
 739 
 740   void adjust_flattened_array_access_aliases(PhaseIterGVN&amp; igvn);
 741 
<span class="line-added"> 742   void sort_macro_nodes();</span>
<span class="line-added"> 743 </span>
 744   // remove the opaque nodes that protect the predicates so that the unused checks and
 745   // uncommon traps will be eliminated from the graph.
 746   void cleanup_loop_predicates(PhaseIterGVN &amp;igvn);
 747   bool is_predicate_opaq(Node * n) {
 748     return _predicate_opaqs-&gt;contains(n);
 749   }
 750 
 751   // Are there candidate expensive nodes for optimization?
 752   bool should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn);
 753   // Check whether n1 and n2 are similar
 754   static int cmp_expensive_nodes(Node* n1, Node* n2);
 755   // Sort expensive nodes to locate similar expensive nodes
 756   void sort_expensive_nodes();
 757 
 758   // Compilation environment.
 759   Arena*      comp_arena()           { return &amp;_comp_arena; }
 760   ciEnv*      env() const            { return _env; }
 761   CompileLog* log() const            { return _log; }
 762   bool        failing() const        { return _env-&gt;failing() || _failure_reason != NULL; }
 763   const char* failure_reason() const { return (_env-&gt;failing()) ? _env-&gt;failure_reason() : _failure_reason; }
</pre>
<hr />
<pre>
1110   void verify_top(Node*) const PRODUCT_RETURN;
1111 
1112   // Intrinsic setup.
1113   void           register_library_intrinsics();                            // initializer
1114   CallGenerator* make_vm_intrinsic(ciMethod* m, bool is_virtual);          // constructor
1115   int            intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found);  // helper
1116   CallGenerator* find_intrinsic(ciMethod* m, bool is_virtual);             // query fn
1117   void           register_intrinsic(CallGenerator* cg);                    // update fn
1118 
1119 #ifndef PRODUCT
1120   static juint  _intrinsic_hist_count[vmIntrinsics::ID_LIMIT];
1121   static jubyte _intrinsic_hist_flags[vmIntrinsics::ID_LIMIT];
1122 #endif
1123   // Function calls made by the public function final_graph_reshaping.
1124   // No need to be made public as they are not called elsewhere.
1125   void final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc);
1126   void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop);
1127   void final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc );
1128   void eliminate_redundant_card_marks(Node* n);
1129 
<span class="line-added">1130   // Logic cone optimization.</span>
<span class="line-added">1131   void optimize_logic_cones(PhaseIterGVN &amp;igvn);</span>
<span class="line-added">1132   void collect_logic_cone_roots(Unique_Node_List&amp; list);</span>
<span class="line-added">1133   void process_logic_cone_root(PhaseIterGVN &amp;igvn, Node* n, VectorSet&amp; visited);</span>
<span class="line-added">1134   bool compute_logic_cone(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs);</span>
<span class="line-added">1135   uint compute_truth_table(Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs);</span>
<span class="line-added">1136   uint eval_macro_logic_op(uint func, uint op1, uint op2, uint op3);</span>
<span class="line-added">1137   Node* xform_to_MacroLogicV(PhaseIterGVN &amp;igvn, const TypeVect* vt, Unique_Node_List&amp; partitions, Unique_Node_List&amp; inputs);</span>
<span class="line-added">1138 </span>
1139  public:
1140 
1141   // Note:  Histogram array size is about 1 Kb.
1142   enum {                        // flag bits:
1143     _intrinsic_worked = 1,      // succeeded at least once
1144     _intrinsic_failed = 2,      // tried it but it failed
1145     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1146     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1147     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1148   };
1149   // Update histogram.  Return boolean if this is a first-time occurrence.
1150   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1151                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1152   static void print_intrinsic_statistics() PRODUCT_RETURN;
1153 
1154   // Graph verification code
1155   // Walk the node list, verifying that there is a one-to-one
1156   // correspondence between Use-Def edges and Def-Use edges
1157   // The option no_dead_code enables stronger checks that the
1158   // graph is strongly connected from root in both directions.
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopUnswitch.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
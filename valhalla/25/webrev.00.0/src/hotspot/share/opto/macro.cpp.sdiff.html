<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="machnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2960       default:
2961         assert(n-&gt;Opcode() == Op_LoopLimit ||
2962                n-&gt;Opcode() == Op_Opaque1   ||
2963                n-&gt;Opcode() == Op_Opaque2   ||
2964                n-&gt;Opcode() == Op_Opaque3   ||
2965                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2966                &quot;unknown node type in macro list&quot;);
2967       }
2968       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2969       progress = progress || success;
2970     }
2971   }
2972 }
2973 
2974 //------------------------------expand_macro_nodes----------------------
2975 //  Returns true if a failure occurred.
2976 bool PhaseMacroExpand::expand_macro_nodes() {
2977   // Last attempt to eliminate macro nodes.
2978   eliminate_macro_nodes();
2979 
<span class="line-removed">2980   // Make sure expansion will not cause node limit to be exceeded.</span>
<span class="line-removed">2981   // Worst case is a macro node gets expanded into about 200 nodes.</span>
<span class="line-removed">2982   // Allow 50% more for optimization.</span>
<span class="line-removed">2983   if (C-&gt;check_node_count(C-&gt;macro_count() * 300, &quot;out of nodes before macro expansion&quot; ) )</span>
<span class="line-removed">2984     return true;</span>
<span class="line-removed">2985 </span>
2986   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.
2987   bool progress = true;
2988   while (progress) {
2989     progress = false;
2990     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2991       Node* n = C-&gt;macro_node(i-1);
2992       bool success = false;
2993       debug_only(int old_macro_count = C-&gt;macro_count(););
2994       if (n-&gt;Opcode() == Op_LoopLimit) {
2995         // Remove it from macro list and put on IGVN worklist to optimize.
2996         C-&gt;remove_macro_node(n);
2997         _igvn._worklist.push(n);
2998         success = true;
2999       } else if (n-&gt;Opcode() == Op_CallStaticJava) {
3000         CallStaticJavaNode* call = n-&gt;as_CallStaticJava();
3001         if (!call-&gt;method()-&gt;is_method_handle_intrinsic()) {
3002           // Remove it from macro list and put on IGVN worklist to optimize.
3003           C-&gt;remove_macro_node(n);
3004           _igvn._worklist.push(n);
3005           success = true;
</pre>
<hr />
<pre>
3024 #endif
3025         Node* repl = n-&gt;in(1);
3026         if (!_has_locks) {
3027           // Remove RTM state check if there are no locks in the code.
3028           // Replace input to compare the same value.
3029           repl = (cmp-&gt;in(1) == n) ? cmp-&gt;in(2) : cmp-&gt;in(1);
3030         }
3031         _igvn.replace_node(n, repl);
3032         success = true;
3033 #endif
3034       } else if (n-&gt;Opcode() == Op_OuterStripMinedLoop) {
3035         n-&gt;as_OuterStripMinedLoop()-&gt;adjust_strip_mined_loop(&amp;_igvn);
3036         C-&gt;remove_macro_node(n);
3037         success = true;
3038       }
3039       assert(!success || (C-&gt;macro_count() == (old_macro_count - 1)), &quot;elimination must have deleted one node from macro list&quot;);
3040       progress = progress || success;
3041     }
3042   }
3043 
















3044   // expand arraycopy &quot;macro&quot; nodes first
3045   // For ReduceBulkZeroing, we must first process all arraycopy nodes
3046   // before the allocate nodes are expanded.
<span class="line-modified">3047   for (int i = C-&gt;macro_count(); i &gt; 0; i--) {</span>
<span class="line-modified">3048     Node* n = C-&gt;macro_node(i-1);</span>

3049     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
3050     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
3051       // node is unreachable, so don&#39;t try to expand it
3052       C-&gt;remove_macro_node(n);
3053       continue;
3054     }










3055     debug_only(int old_macro_count = C-&gt;macro_count(););
3056     switch (n-&gt;class_id()) {
3057     case Node::Class_Lock:
3058       expand_lock_node(n-&gt;as_Lock());
3059       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3060       break;
3061     case Node::Class_Unlock:
3062       expand_unlock_node(n-&gt;as_Unlock());
3063       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3064       break;
3065     case Node::Class_ArrayCopy:
3066       expand_arraycopy_node(n-&gt;as_ArrayCopy());
3067       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3068       break;
3069     case Node::Class_SubTypeCheck:
3070       expand_subtypecheck_node(n-&gt;as_SubTypeCheck());
3071       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3072       break;







3073     }







3074     if (C-&gt;failing())  return true;

3075   }
3076 
3077   // All nodes except Allocate nodes are expanded now. There could be
3078   // new optimization opportunities (such as folding newly created
3079   // load from a just allocated object). Run IGVN.
<span class="line-removed">3080   _igvn.set_delay_transform(false);</span>
<span class="line-removed">3081   _igvn.optimize();</span>
<span class="line-removed">3082   if (C-&gt;failing())  return true;</span>
<span class="line-removed">3083 </span>
<span class="line-removed">3084   _igvn.set_delay_transform(true);</span>
3085 
3086   // expand &quot;macro&quot; nodes
3087   // nodes are removed from the macro list as they are processed
3088   while (C-&gt;macro_count() &gt; 0) {
3089     int macro_count = C-&gt;macro_count();
3090     Node * n = C-&gt;macro_node(macro_count-1);
3091     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
3092     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
3093       // node is unreachable, so don&#39;t try to expand it
3094       C-&gt;remove_macro_node(n);
3095       continue;
3096     }






3097     switch (n-&gt;class_id()) {
3098     case Node::Class_Allocate:
3099       expand_allocate(n-&gt;as_Allocate());
3100       break;
3101     case Node::Class_AllocateArray:
3102       expand_allocate_array(n-&gt;as_AllocateArray());
3103       break;
<span class="line-removed">3104     case Node::Class_CallStaticJava:</span>
<span class="line-removed">3105       expand_mh_intrinsic_return(n-&gt;as_CallStaticJava());</span>
<span class="line-removed">3106       C-&gt;remove_macro_node(n);</span>
<span class="line-removed">3107       break;</span>
3108     default:
3109       assert(false, &quot;unknown node type in macro list&quot;);
3110     }
3111     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
3112     if (C-&gt;failing())  return true;







3113   }
3114 
3115   _igvn.set_delay_transform(false);
<span class="line-removed">3116   _igvn.optimize();</span>
<span class="line-removed">3117   if (C-&gt;failing())  return true;</span>
3118   return false;
3119 }
</pre>
</td>
<td>
<hr />
<pre>
2960       default:
2961         assert(n-&gt;Opcode() == Op_LoopLimit ||
2962                n-&gt;Opcode() == Op_Opaque1   ||
2963                n-&gt;Opcode() == Op_Opaque2   ||
2964                n-&gt;Opcode() == Op_Opaque3   ||
2965                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2966                &quot;unknown node type in macro list&quot;);
2967       }
2968       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2969       progress = progress || success;
2970     }
2971   }
2972 }
2973 
2974 //------------------------------expand_macro_nodes----------------------
2975 //  Returns true if a failure occurred.
2976 bool PhaseMacroExpand::expand_macro_nodes() {
2977   // Last attempt to eliminate macro nodes.
2978   eliminate_macro_nodes();
2979 






2980   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.
2981   bool progress = true;
2982   while (progress) {
2983     progress = false;
2984     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2985       Node* n = C-&gt;macro_node(i-1);
2986       bool success = false;
2987       debug_only(int old_macro_count = C-&gt;macro_count(););
2988       if (n-&gt;Opcode() == Op_LoopLimit) {
2989         // Remove it from macro list and put on IGVN worklist to optimize.
2990         C-&gt;remove_macro_node(n);
2991         _igvn._worklist.push(n);
2992         success = true;
2993       } else if (n-&gt;Opcode() == Op_CallStaticJava) {
2994         CallStaticJavaNode* call = n-&gt;as_CallStaticJava();
2995         if (!call-&gt;method()-&gt;is_method_handle_intrinsic()) {
2996           // Remove it from macro list and put on IGVN worklist to optimize.
2997           C-&gt;remove_macro_node(n);
2998           _igvn._worklist.push(n);
2999           success = true;
</pre>
<hr />
<pre>
3018 #endif
3019         Node* repl = n-&gt;in(1);
3020         if (!_has_locks) {
3021           // Remove RTM state check if there are no locks in the code.
3022           // Replace input to compare the same value.
3023           repl = (cmp-&gt;in(1) == n) ? cmp-&gt;in(2) : cmp-&gt;in(1);
3024         }
3025         _igvn.replace_node(n, repl);
3026         success = true;
3027 #endif
3028       } else if (n-&gt;Opcode() == Op_OuterStripMinedLoop) {
3029         n-&gt;as_OuterStripMinedLoop()-&gt;adjust_strip_mined_loop(&amp;_igvn);
3030         C-&gt;remove_macro_node(n);
3031         success = true;
3032       }
3033       assert(!success || (C-&gt;macro_count() == (old_macro_count - 1)), &quot;elimination must have deleted one node from macro list&quot;);
3034       progress = progress || success;
3035     }
3036   }
3037 
<span class="line-added">3038   // Clean up the graph so we&#39;re less likely to hit the maximum node</span>
<span class="line-added">3039   // limit</span>
<span class="line-added">3040   _igvn.set_delay_transform(false);</span>
<span class="line-added">3041   _igvn.optimize();</span>
<span class="line-added">3042   if (C-&gt;failing())  return true;</span>
<span class="line-added">3043   _igvn.set_delay_transform(true);</span>
<span class="line-added">3044 </span>
<span class="line-added">3045 </span>
<span class="line-added">3046   // Because we run IGVN after each expansion, some macro nodes may go</span>
<span class="line-added">3047   // dead and be removed from the list as we iterate over it. Move</span>
<span class="line-added">3048   // Allocate nodes (processed in a second pass) at the beginning of</span>
<span class="line-added">3049   // the list and then iterate from the last element of the list until</span>
<span class="line-added">3050   // an Allocate node is seen. This is robust to random deletion in</span>
<span class="line-added">3051   // the list due to nodes going dead.</span>
<span class="line-added">3052   C-&gt;sort_macro_nodes();</span>
<span class="line-added">3053 </span>
3054   // expand arraycopy &quot;macro&quot; nodes first
3055   // For ReduceBulkZeroing, we must first process all arraycopy nodes
3056   // before the allocate nodes are expanded.
<span class="line-modified">3057   while (C-&gt;macro_count() &gt; 0) {</span>
<span class="line-modified">3058     int macro_count = C-&gt;macro_count();</span>
<span class="line-added">3059     Node * n = C-&gt;macro_node(macro_count-1);</span>
3060     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
3061     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
3062       // node is unreachable, so don&#39;t try to expand it
3063       C-&gt;remove_macro_node(n);
3064       continue;
3065     }
<span class="line-added">3066     if (n-&gt;is_Allocate()) {</span>
<span class="line-added">3067       break;</span>
<span class="line-added">3068     }</span>
<span class="line-added">3069     // Make sure expansion will not cause node limit to be exceeded.</span>
<span class="line-added">3070     // Worst case is a macro node gets expanded into about 200 nodes.</span>
<span class="line-added">3071     // Allow 50% more for optimization.</span>
<span class="line-added">3072     if (C-&gt;check_node_count(300, &quot;out of nodes before macro expansion&quot;)) {</span>
<span class="line-added">3073       return true;</span>
<span class="line-added">3074     }</span>
<span class="line-added">3075 </span>
3076     debug_only(int old_macro_count = C-&gt;macro_count(););
3077     switch (n-&gt;class_id()) {
3078     case Node::Class_Lock:
3079       expand_lock_node(n-&gt;as_Lock());
3080       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3081       break;
3082     case Node::Class_Unlock:
3083       expand_unlock_node(n-&gt;as_Unlock());
3084       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3085       break;
3086     case Node::Class_ArrayCopy:
3087       expand_arraycopy_node(n-&gt;as_ArrayCopy());
3088       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3089       break;
3090     case Node::Class_SubTypeCheck:
3091       expand_subtypecheck_node(n-&gt;as_SubTypeCheck());
3092       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3093       break;
<span class="line-added">3094     case Node::Class_CallStaticJava:</span>
<span class="line-added">3095       expand_mh_intrinsic_return(n-&gt;as_CallStaticJava());</span>
<span class="line-added">3096       C-&gt;remove_macro_node(n);</span>
<span class="line-added">3097       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);</span>
<span class="line-added">3098       break;</span>
<span class="line-added">3099     default:</span>
<span class="line-added">3100       assert(false, &quot;unknown node type in macro list&quot;);</span>
3101     }
<span class="line-added">3102     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);</span>
<span class="line-added">3103     if (C-&gt;failing())  return true;</span>
<span class="line-added">3104 </span>
<span class="line-added">3105     // Clean up the graph so we&#39;re less likely to hit the maximum node</span>
<span class="line-added">3106     // limit</span>
<span class="line-added">3107     _igvn.set_delay_transform(false);</span>
<span class="line-added">3108     _igvn.optimize();</span>
3109     if (C-&gt;failing())  return true;
<span class="line-added">3110     _igvn.set_delay_transform(true);</span>
3111   }
3112 
3113   // All nodes except Allocate nodes are expanded now. There could be
3114   // new optimization opportunities (such as folding newly created
3115   // load from a just allocated object). Run IGVN.





3116 
3117   // expand &quot;macro&quot; nodes
3118   // nodes are removed from the macro list as they are processed
3119   while (C-&gt;macro_count() &gt; 0) {
3120     int macro_count = C-&gt;macro_count();
3121     Node * n = C-&gt;macro_node(macro_count-1);
3122     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
3123     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
3124       // node is unreachable, so don&#39;t try to expand it
3125       C-&gt;remove_macro_node(n);
3126       continue;
3127     }
<span class="line-added">3128     // Make sure expansion will not cause node limit to be exceeded.</span>
<span class="line-added">3129     // Worst case is a macro node gets expanded into about 200 nodes.</span>
<span class="line-added">3130     // Allow 50% more for optimization.</span>
<span class="line-added">3131     if (C-&gt;check_node_count(300, &quot;out of nodes before macro expansion&quot;)) {</span>
<span class="line-added">3132       return true;</span>
<span class="line-added">3133     }</span>
3134     switch (n-&gt;class_id()) {
3135     case Node::Class_Allocate:
3136       expand_allocate(n-&gt;as_Allocate());
3137       break;
3138     case Node::Class_AllocateArray:
3139       expand_allocate_array(n-&gt;as_AllocateArray());
3140       break;




3141     default:
3142       assert(false, &quot;unknown node type in macro list&quot;);
3143     }
3144     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
3145     if (C-&gt;failing())  return true;
<span class="line-added">3146 </span>
<span class="line-added">3147     // Clean up the graph so we&#39;re less likely to hit the maximum node</span>
<span class="line-added">3148     // limit</span>
<span class="line-added">3149     _igvn.set_delay_transform(false);</span>
<span class="line-added">3150     _igvn.optimize();</span>
<span class="line-added">3151     if (C-&gt;failing())  return true;</span>
<span class="line-added">3152     _igvn.set_delay_transform(true);</span>
3153   }
3154 
3155   _igvn.set_delay_transform(false);


3156   return false;
3157 }
</pre>
</td>
</tr>
</table>
<center><a href="machnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
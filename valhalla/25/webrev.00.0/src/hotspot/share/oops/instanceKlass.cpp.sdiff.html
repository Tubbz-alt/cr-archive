<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2553 
2554   _init_thread = NULL;
2555   _methods_jmethod_ids = NULL;
2556   _jni_ids = NULL;
2557   _oop_map_cache = NULL;
2558   // clear _nest_host to ensure re-load at runtime
2559   _nest_host = NULL;
2560   _package_entry = NULL;
2561   _dep_context_last_cleaned = 0;
2562 }
2563 
2564 void InstanceKlass::remove_java_mirror() {
2565   Klass::remove_java_mirror();
2566 
2567   // do array classes also.
2568   if (array_klasses() != NULL) {
2569     array_klasses()-&gt;remove_java_mirror();
2570   }
2571 }
2572 
<span class="line-modified">2573 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {</span>

2574   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2575   // before the InstanceKlass is added to the SystemDictionary. Make
2576   // sure the current state is &lt;loaded.
2577   assert(!is_loaded(), &quot;invalid init state&quot;);
<span class="line-modified">2578   set_package(loader_data, CHECK);</span>
2579   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2580 
2581   if (is_value()) {
2582     ValueKlass::cast(this)-&gt;initialize_calling_convention(CHECK);
2583   }
2584 
2585   Array&lt;Method*&gt;* methods = this-&gt;methods();
2586   int num_methods = methods-&gt;length();
2587   for (int index = 0; index &lt; num_methods; ++index) {
2588     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2589   }
2590   if (JvmtiExport::has_redefined_a_class()) {
2591     // Reinitialize vtable because RedefineClasses may have changed some
2592     // entries in this vtable for super classes so the CDS vtable might
2593     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2594     // vtables in the shared system dictionary, only the main one.
2595     // It also redefines the itable too so fix that too.
2596     vtable().initialize_vtable(false, CHECK);
2597     itable().initialize_itable(false, CHECK);
2598   }
2599 
2600   // restore constant pool resolved references
2601   constants()-&gt;restore_unshareable_info(CHECK);
2602 
2603   if (array_klasses() != NULL) {
2604     // Array classes have null protection domain.
2605     // --&gt; see ArrayKlass::complete_create_array_klass()
<span class="line-modified">2606     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);</span>
2607   }
2608 
2609   // Initialize current biased locking state.
2610   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {
2611     set_prototype_header(markWord::biased_locking_prototype());
2612   }
2613 }
2614 
2615 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2616   switch (loader_type) {
2617   case ClassLoader::BOOT_LOADER:
2618     _misc_flags |= _misc_is_shared_boot_class;
2619     break;
2620   case ClassLoader::PLATFORM_LOADER:
2621     _misc_flags |= _misc_is_shared_platform_class;
2622     break;
2623   case ClassLoader::APP_LOADER:
2624     _misc_flags |= _misc_is_shared_app_class;
2625     break;
2626   default:
</pre>
<hr />
<pre>
2793   dest[dest_index] = &#39;\0&#39;;
2794   return dest;
2795 }
2796 
2797 ModuleEntry* InstanceKlass::module() const {
2798   // For an unsafe anonymous class return the host class&#39; module
2799   if (is_unsafe_anonymous()) {
2800     assert(unsafe_anonymous_host() != NULL, &quot;unsafe anonymous class must have a host class&quot;);
2801     return unsafe_anonymous_host()-&gt;module();
2802   }
2803 
2804   // Class is in a named package
2805   if (!in_unnamed_package()) {
2806     return _package_entry-&gt;module();
2807   }
2808 
2809   // Class is in an unnamed package, return its loader&#39;s unnamed module
2810   return class_loader_data()-&gt;unnamed_module();
2811 }
2812 
<span class="line-modified">2813 void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {</span>
2814 
2815   // ensure java/ packages only loaded by boot or platform builtin loaders
2816   check_prohibited_package(name(), loader_data, CHECK);
2817 
<span class="line-modified">2818   TempNewSymbol pkg_name = ClassLoader::package_from_class_name(name());</span>
2819 
2820   if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
2821 
2822     // Find in class loader&#39;s package entry table.
<span class="line-modified">2823     _package_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);</span>
2824 
2825     // If the package name is not found in the loader&#39;s package
2826     // entry table, it is an indication that the package has not
2827     // been defined. Consider it defined within the unnamed module.
2828     if (_package_entry == NULL) {
<span class="line-removed">2829       ResourceMark rm(THREAD);</span>
2830 
2831       if (!ModuleEntryTable::javabase_defined()) {
2832         // Before java.base is defined during bootstrapping, define all packages in
2833         // the java.base module.  If a non-java.base package is erroneously placed
2834         // in the java.base module it will be caught later when java.base
2835         // is defined by ModuleEntryTable::verify_javabase_packages check.
2836         assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME &quot; module is NULL&quot;);
2837         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());
2838       } else {
2839         assert(loader_data-&gt;unnamed_module() != NULL, &quot;unnamed module is NULL&quot;);
2840         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name,
2841                                                          loader_data-&gt;unnamed_module());
2842       }
2843 
2844       // A package should have been successfully created

2845       assert(_package_entry != NULL, &quot;Package entry for class %s not found, loader %s&quot;,
2846              name()-&gt;as_C_string(), loader_data-&gt;loader_name_and_id());
2847     }
2848 
2849     if (log_is_enabled(Debug, module)) {
2850       ResourceMark rm(THREAD);
2851       ModuleEntry* m = _package_entry-&gt;module();
2852       log_trace(module)(&quot;Setting package: class: %s, package: %s, loader: %s, module: %s&quot;,
2853                         external_name(),
2854                         pkg_name-&gt;as_C_string(),
2855                         loader_data-&gt;loader_name_and_id(),
2856                         (m-&gt;is_named() ? m-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE));
2857     }
2858   } else {
2859     ResourceMark rm(THREAD);
2860     log_trace(module)(&quot;Setting package: class: %s, package: unnamed, loader: %s, module: %s&quot;,
2861                       external_name(),
2862                       (loader_data != NULL) ? loader_data-&gt;loader_name_and_id() : &quot;NULL&quot;,
2863                       UNNAMED_MODULE);
2864   }
</pre>
</td>
<td>
<hr />
<pre>
2553 
2554   _init_thread = NULL;
2555   _methods_jmethod_ids = NULL;
2556   _jni_ids = NULL;
2557   _oop_map_cache = NULL;
2558   // clear _nest_host to ensure re-load at runtime
2559   _nest_host = NULL;
2560   _package_entry = NULL;
2561   _dep_context_last_cleaned = 0;
2562 }
2563 
2564 void InstanceKlass::remove_java_mirror() {
2565   Klass::remove_java_mirror();
2566 
2567   // do array classes also.
2568   if (array_klasses() != NULL) {
2569     array_klasses()-&gt;remove_java_mirror();
2570   }
2571 }
2572 
<span class="line-modified">2573 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,</span>
<span class="line-added">2574                                              PackageEntry* pkg_entry, TRAPS) {</span>
2575   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2576   // before the InstanceKlass is added to the SystemDictionary. Make
2577   // sure the current state is &lt;loaded.
2578   assert(!is_loaded(), &quot;invalid init state&quot;);
<span class="line-modified">2579   set_package(loader_data, pkg_entry, CHECK);</span>
2580   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2581 
2582   if (is_value()) {
2583     ValueKlass::cast(this)-&gt;initialize_calling_convention(CHECK);
2584   }
2585 
2586   Array&lt;Method*&gt;* methods = this-&gt;methods();
2587   int num_methods = methods-&gt;length();
2588   for (int index = 0; index &lt; num_methods; ++index) {
2589     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2590   }
2591   if (JvmtiExport::has_redefined_a_class()) {
2592     // Reinitialize vtable because RedefineClasses may have changed some
2593     // entries in this vtable for super classes so the CDS vtable might
2594     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2595     // vtables in the shared system dictionary, only the main one.
2596     // It also redefines the itable too so fix that too.
2597     vtable().initialize_vtable(false, CHECK);
2598     itable().initialize_itable(false, CHECK);
2599   }
2600 
2601   // restore constant pool resolved references
2602   constants()-&gt;restore_unshareable_info(CHECK);
2603 
2604   if (array_klasses() != NULL) {
2605     // Array classes have null protection domain.
2606     // --&gt; see ArrayKlass::complete_create_array_klass()
<span class="line-modified">2607     ArrayKlass::cast(array_klasses())-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);</span>
2608   }
2609 
2610   // Initialize current biased locking state.
2611   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {
2612     set_prototype_header(markWord::biased_locking_prototype());
2613   }
2614 }
2615 
2616 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2617   switch (loader_type) {
2618   case ClassLoader::BOOT_LOADER:
2619     _misc_flags |= _misc_is_shared_boot_class;
2620     break;
2621   case ClassLoader::PLATFORM_LOADER:
2622     _misc_flags |= _misc_is_shared_platform_class;
2623     break;
2624   case ClassLoader::APP_LOADER:
2625     _misc_flags |= _misc_is_shared_app_class;
2626     break;
2627   default:
</pre>
<hr />
<pre>
2794   dest[dest_index] = &#39;\0&#39;;
2795   return dest;
2796 }
2797 
2798 ModuleEntry* InstanceKlass::module() const {
2799   // For an unsafe anonymous class return the host class&#39; module
2800   if (is_unsafe_anonymous()) {
2801     assert(unsafe_anonymous_host() != NULL, &quot;unsafe anonymous class must have a host class&quot;);
2802     return unsafe_anonymous_host()-&gt;module();
2803   }
2804 
2805   // Class is in a named package
2806   if (!in_unnamed_package()) {
2807     return _package_entry-&gt;module();
2808   }
2809 
2810   // Class is in an unnamed package, return its loader&#39;s unnamed module
2811   return class_loader_data()-&gt;unnamed_module();
2812 }
2813 
<span class="line-modified">2814 void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {</span>
2815 
2816   // ensure java/ packages only loaded by boot or platform builtin loaders
2817   check_prohibited_package(name(), loader_data, CHECK);
2818 
<span class="line-modified">2819   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() : ClassLoader::package_from_class_name(name());</span>
2820 
2821   if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
2822 
2823     // Find in class loader&#39;s package entry table.
<span class="line-modified">2824     _package_entry = pkg_entry != NULL ? pkg_entry : loader_data-&gt;packages()-&gt;lookup_only(pkg_name);</span>
2825 
2826     // If the package name is not found in the loader&#39;s package
2827     // entry table, it is an indication that the package has not
2828     // been defined. Consider it defined within the unnamed module.
2829     if (_package_entry == NULL) {

2830 
2831       if (!ModuleEntryTable::javabase_defined()) {
2832         // Before java.base is defined during bootstrapping, define all packages in
2833         // the java.base module.  If a non-java.base package is erroneously placed
2834         // in the java.base module it will be caught later when java.base
2835         // is defined by ModuleEntryTable::verify_javabase_packages check.
2836         assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME &quot; module is NULL&quot;);
2837         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());
2838       } else {
2839         assert(loader_data-&gt;unnamed_module() != NULL, &quot;unnamed module is NULL&quot;);
2840         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name,
2841                                                          loader_data-&gt;unnamed_module());
2842       }
2843 
2844       // A package should have been successfully created
<span class="line-added">2845       DEBUG_ONLY(ResourceMark rm(THREAD));</span>
2846       assert(_package_entry != NULL, &quot;Package entry for class %s not found, loader %s&quot;,
2847              name()-&gt;as_C_string(), loader_data-&gt;loader_name_and_id());
2848     }
2849 
2850     if (log_is_enabled(Debug, module)) {
2851       ResourceMark rm(THREAD);
2852       ModuleEntry* m = _package_entry-&gt;module();
2853       log_trace(module)(&quot;Setting package: class: %s, package: %s, loader: %s, module: %s&quot;,
2854                         external_name(),
2855                         pkg_name-&gt;as_C_string(),
2856                         loader_data-&gt;loader_name_and_id(),
2857                         (m-&gt;is_named() ? m-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE));
2858     }
2859   } else {
2860     ResourceMark rm(THREAD);
2861     log_trace(module)(&quot;Setting package: class: %s, package: unnamed, loader: %s, module: %s&quot;,
2862                       external_name(),
2863                       (loader_data != NULL) ? loader_data-&gt;loader_name_and_id() : &quot;NULL&quot;,
2864                       UNNAMED_MODULE);
2865   }
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 573     inner_class_outer_class_info_offset = 1,
 574     inner_class_inner_name_offset = 2,
 575     inner_class_access_flags_offset = 3,
 576     inner_class_next_offset = 4
 577   };
 578 
 579   enum EnclosingMethodAttributeOffset {
 580     enclosing_method_class_index_offset = 0,
 581     enclosing_method_method_index_offset = 1,
 582     enclosing_method_attribute_size = 2
 583   };
 584 
 585   // method override check
 586   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 587 
 588   // package
 589   PackageEntry* package() const     { return _package_entry; }
 590   ModuleEntry* module() const;
 591   bool in_unnamed_package() const   { return (_package_entry == NULL); }
 592   void set_package(PackageEntry* p) { _package_entry = p; }
<span class="line-modified"> 593   void set_package(ClassLoaderData* loader_data, TRAPS);</span>
 594   bool is_same_class_package(const Klass* class2) const;
 595   bool is_same_class_package(oop other_class_loader, const Symbol* other_class_name) const;
 596 
 597   // find an enclosing class
 598   InstanceKlass* compute_enclosing_class(bool* inner_is_member, TRAPS) const;
 599 
 600   // Find InnerClasses attribute and return outer_class_info_index &amp; inner_name_index.
 601   bool find_inner_classes_attr(int* ooff, int* noff, TRAPS) const;
 602 
 603  private:
 604   // Check prohibited package (&quot;java/&quot; only loadable by boot or platform loaders)
 605   static void check_prohibited_package(Symbol* class_name,
 606                                        ClassLoaderData* loader_data,
 607                                        TRAPS);
 608  public:
 609   // initialization state
 610   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 611   bool is_linked() const                   { return _init_state &gt;= linked; }
 612   bool is_initialized() const              { return _init_state == fully_initialized; }
 613   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
</pre>
<hr />
<pre>
1451 
1452   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1453                                   const Symbol* name,
1454                                   const Symbol* signature,
1455                                   OverpassLookupMode overpass_mode,
1456                                   StaticLookupMode static_mode,
1457                                   PrivateLookupMode private_mode);
1458 
1459   // Free CHeap allocated fields.
1460   void release_C_heap_structures();
1461 
1462 #if INCLUDE_JVMTI
1463   // RedefineClasses support
1464   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1465   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1466 #endif
1467 public:
1468   // CDS support - remove and restore oops from metadata. Oops are not shared.
1469   virtual void remove_unshareable_info();
1470   virtual void remove_java_mirror();
<span class="line-modified">1471   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS);</span>
1472 
1473   // jvm support
1474   jint compute_modifier_flags(TRAPS) const;
1475 
1476 public:
1477   // JVMTI support
1478   jint jvmti_class_status() const;
1479 
1480   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1481 
1482  public:
1483   // Printing
1484 #ifndef PRODUCT
1485   void print_on(outputStream* st) const;
1486 #endif
1487   void print_value_on(outputStream* st) const;
1488 
1489   void oop_print_value_on(oop obj, outputStream* st);
1490 
1491 #ifndef PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
 573     inner_class_outer_class_info_offset = 1,
 574     inner_class_inner_name_offset = 2,
 575     inner_class_access_flags_offset = 3,
 576     inner_class_next_offset = 4
 577   };
 578 
 579   enum EnclosingMethodAttributeOffset {
 580     enclosing_method_class_index_offset = 0,
 581     enclosing_method_method_index_offset = 1,
 582     enclosing_method_attribute_size = 2
 583   };
 584 
 585   // method override check
 586   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 587 
 588   // package
 589   PackageEntry* package() const     { return _package_entry; }
 590   ModuleEntry* module() const;
 591   bool in_unnamed_package() const   { return (_package_entry == NULL); }
 592   void set_package(PackageEntry* p) { _package_entry = p; }
<span class="line-modified"> 593   void set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS);</span>
 594   bool is_same_class_package(const Klass* class2) const;
 595   bool is_same_class_package(oop other_class_loader, const Symbol* other_class_name) const;
 596 
 597   // find an enclosing class
 598   InstanceKlass* compute_enclosing_class(bool* inner_is_member, TRAPS) const;
 599 
 600   // Find InnerClasses attribute and return outer_class_info_index &amp; inner_name_index.
 601   bool find_inner_classes_attr(int* ooff, int* noff, TRAPS) const;
 602 
 603  private:
 604   // Check prohibited package (&quot;java/&quot; only loadable by boot or platform loaders)
 605   static void check_prohibited_package(Symbol* class_name,
 606                                        ClassLoaderData* loader_data,
 607                                        TRAPS);
 608  public:
 609   // initialization state
 610   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 611   bool is_linked() const                   { return _init_state &gt;= linked; }
 612   bool is_initialized() const              { return _init_state == fully_initialized; }
 613   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
</pre>
<hr />
<pre>
1451 
1452   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1453                                   const Symbol* name,
1454                                   const Symbol* signature,
1455                                   OverpassLookupMode overpass_mode,
1456                                   StaticLookupMode static_mode,
1457                                   PrivateLookupMode private_mode);
1458 
1459   // Free CHeap allocated fields.
1460   void release_C_heap_structures();
1461 
1462 #if INCLUDE_JVMTI
1463   // RedefineClasses support
1464   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1465   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1466 #endif
1467 public:
1468   // CDS support - remove and restore oops from metadata. Oops are not shared.
1469   virtual void remove_unshareable_info();
1470   virtual void remove_java_mirror();
<span class="line-modified">1471   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);</span>
1472 
1473   // jvm support
1474   jint compute_modifier_flags(TRAPS) const;
1475 
1476 public:
1477   // JVMTI support
1478   jint jvmti_class_status() const;
1479 
1480   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1481 
1482  public:
1483   // Printing
1484 #ifndef PRODUCT
1485   void print_on(outputStream* st) const;
1486 #endif
1487   void print_value_on(outputStream* st) const;
1488 
1489   void oop_print_value_on(oop obj, outputStream* st);
1490 
1491 #ifndef PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
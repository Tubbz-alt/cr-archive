<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/heapShared.hpp&quot;
  37 #include &quot;memory/metadataFactory.hpp&quot;
  38 #include &quot;memory/metaspaceClosure.hpp&quot;
  39 #include &quot;memory/metaspaceShared.hpp&quot;
  40 #include &quot;memory/oopFactory.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/array.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/cpCache.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.inline.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  51 #include &quot;oops/valueArrayKlass.hpp&quot;
  52 #include &quot;runtime/atomic.hpp&quot;
  53 #include &quot;runtime/handles.inline.hpp&quot;
  54 #include &quot;runtime/init.hpp&quot;
  55 #include &quot;runtime/javaCalls.hpp&quot;
  56 #include &quot;runtime/signature.hpp&quot;
  57 #include &quot;runtime/thread.inline.hpp&quot;
  58 #include &quot;runtime/vframe.inline.hpp&quot;
  59 #include &quot;utilities/copy.hpp&quot;
  60 
  61 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  62   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  63   int size = ConstantPool::size(length);
  64   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  65 }
  66 
  67 #ifdef ASSERT
  68 
  69 // MetaspaceObj allocation invariant is calloc equivalent memory
  70 // simple verification of this here (JVM_CONSTANT_Invalid == 0 )
  71 static bool tag_array_is_zero_initialized(Array&lt;u1&gt;* tags) {
  72   assert(tags != NULL, &quot;invariant&quot;);
  73   const int length = tags-&gt;length();
  74   for (int index = 0; index &lt; length; ++index) {
  75     if (JVM_CONSTANT_Invalid != tags-&gt;at(index)) {
  76       return false;
  77     }
  78   }
  79   return true;
  80 }
  81 
  82 #endif
  83 
  84 ConstantPool::ConstantPool(Array&lt;u1&gt;* tags) :
  85   _tags(tags),
  86   _length(tags-&gt;length()) {
  87 
  88     assert(_tags != NULL, &quot;invariant&quot;);
  89     assert(tags-&gt;length() == _length, &quot;invariant&quot;);
  90     assert(tag_array_is_zero_initialized(tags), &quot;invariant&quot;);
  91     assert(0 == flags(), &quot;invariant&quot;);
  92     assert(0 == version(), &quot;invariant&quot;);
  93     assert(NULL == _pool_holder, &quot;invariant&quot;);
  94 }
  95 
  96 void ConstantPool::deallocate_contents(ClassLoaderData* loader_data) {
  97   if (cache() != NULL) {
  98     MetadataFactory::free_metadata(loader_data, cache());
  99     set_cache(NULL);
 100   }
 101 
 102   MetadataFactory::free_array&lt;Klass*&gt;(loader_data, resolved_klasses());
 103   set_resolved_klasses(NULL);
 104 
 105   MetadataFactory::free_array&lt;jushort&gt;(loader_data, operands());
 106   set_operands(NULL);
 107 
 108   release_C_heap_structures();
 109 
 110   // free tag array
 111   MetadataFactory::free_array&lt;u1&gt;(loader_data, tags());
 112   set_tags(NULL);
 113 }
 114 
 115 void ConstantPool::release_C_heap_structures() {
 116   // walk constant pool and decrement symbol reference counts
 117   unreference_symbols();
 118 }
 119 
 120 void ConstantPool::metaspace_pointers_do(MetaspaceClosure* it) {
 121   log_trace(cds)(&quot;Iter(ConstantPool): %p&quot;, this);
 122 
 123   it-&gt;push(&amp;_tags, MetaspaceClosure::_writable);
 124   it-&gt;push(&amp;_cache);
 125   it-&gt;push(&amp;_pool_holder);
 126   it-&gt;push(&amp;_operands);
 127   it-&gt;push(&amp;_resolved_klasses, MetaspaceClosure::_writable);
 128 
 129   for (int i = 0; i &lt; length(); i++) {
 130     // The only MSO&#39;s embedded in the CP entries are Symbols:
 131     //   JVM_CONSTANT_String (normal and pseudo)
 132     //   JVM_CONSTANT_Utf8
 133     constantTag ctag = tag_at(i);
 134     if (ctag.is_string() || ctag.is_utf8()) {
 135       it-&gt;push(symbol_at_addr(i));
 136     }
 137   }
 138 }
 139 
 140 objArrayOop ConstantPool::resolved_references() const {
 141   return (objArrayOop)_cache-&gt;resolved_references();
 142 }
 143 
 144 // Called from outside constant pool resolution where a resolved_reference array
 145 // may not be present.
 146 objArrayOop ConstantPool::resolved_references_or_null() const {
 147   if (_cache == NULL) {
 148     return NULL;
 149   } else {
 150     return (objArrayOop)_cache-&gt;resolved_references();
 151   }
 152 }
 153 
 154 // Create resolved_references array and mapping array for original cp indexes
 155 // The ldc bytecode was rewritten to have the resolved reference array index so need a way
 156 // to map it back for resolving and some unlikely miscellaneous uses.
 157 // The objects created by invokedynamic are appended to this list.
 158 void ConstantPool::initialize_resolved_references(ClassLoaderData* loader_data,
 159                                                   const intStack&amp; reference_map,
 160                                                   int constant_pool_map_length,
 161                                                   TRAPS) {
 162   // Initialized the resolved object cache.
 163   int map_length = reference_map.length();
 164   if (map_length &gt; 0) {
 165     // Only need mapping back to constant pool entries.  The map isn&#39;t used for
 166     // invokedynamic resolved_reference entries.  For invokedynamic entries,
 167     // the constant pool cache index has the mapping back to both the constant
 168     // pool and to the resolved reference index.
 169     if (constant_pool_map_length &gt; 0) {
 170       Array&lt;u2&gt;* om = MetadataFactory::new_array&lt;u2&gt;(loader_data, constant_pool_map_length, CHECK);
 171 
 172       for (int i = 0; i &lt; constant_pool_map_length; i++) {
 173         int x = reference_map.at(i);
 174         assert(x == (int)(jushort) x, &quot;klass index is too big&quot;);
 175         om-&gt;at_put(i, (jushort)x);
 176       }
 177       set_reference_map(om);
 178     }
 179 
 180     // Create Java array for holding resolved strings, methodHandles,
 181     // methodTypes, invokedynamic and invokehandle appendix objects, etc.
 182     objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 183     Handle refs_handle (THREAD, (oop)stom);  // must handleize.
 184     set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 185   }
 186 }
 187 
 188 void ConstantPool::allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS) {
 189   // A ConstantPool can&#39;t possibly have 0xffff valid class entries,
 190   // because entry #0 must be CONSTANT_Invalid, and each class entry must refer to a UTF8
 191   // entry for the class&#39;s name. So at most we will have 0xfffe class entries.
 192   // This allows us to use 0xffff (ConstantPool::_temp_resolved_klass_index) to indicate
 193   // UnresolvedKlass entries that are temporarily created during class redefinition.
 194   assert(num_klasses &lt; CPKlassSlot::_temp_resolved_klass_index, &quot;sanity&quot;);
 195   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 196   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 197   set_resolved_klasses(rk);
 198 }
 199 
 200 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 201   int len = length();
 202   int num_klasses = 0;
 203   for (int i = 1; i &lt;len; i++) {
 204     switch (tag_at(i).value()) {
 205     case JVM_CONSTANT_ClassIndex:
 206       {
 207         const int class_index = klass_index_at(i);
 208         unresolved_klass_at_put(i, class_index, num_klasses++);
 209       }
 210       break;
 211 #ifndef PRODUCT
 212     case JVM_CONSTANT_Class:
 213     case JVM_CONSTANT_UnresolvedClass:
 214     case JVM_CONSTANT_UnresolvedClassInError:
 215       // All of these should have been reverted back to Unresolved before calling
 216       // this function.
 217       ShouldNotReachHere();
 218 #endif
 219     }
 220   }
 221   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 222 }
 223 
 224 // Unsafe anonymous class support:
 225 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 226   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 227   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 228   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 229   *int_at_addr(class_index) =
 230     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 231 
 232   symbol_at_put(name_index, name);
 233   name-&gt;increment_refcount();
 234   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 235   Atomic::release_store(adr, k);
 236 
 237   // The interpreter assumes when the tag is stored, the klass is resolved
 238   // and the Klass* non-NULL, so we need hardware store ordering here.
 239   jbyte qdesc_bit = (name-&gt;is_Q_signature()) ? (jbyte) JVM_CONSTANT_QDescBit : 0;
 240   if (k != NULL) {
 241     release_tag_at_put(class_index, JVM_CONSTANT_Class | qdesc_bit);
 242   } else {
 243     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);
 244   }
 245 }
 246 
 247 // Unsafe anonymous class support:
 248 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 249   assert(k != NULL, &quot;must be valid klass&quot;);
 250   CPKlassSlot kslot = klass_slot_at(class_index);
 251   int resolved_klass_index = kslot.resolved_klass_index();
 252   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 253   Atomic::release_store(adr, k);
 254 
 255   // The interpreter assumes when the tag is stored, the klass is resolved
 256   // and the Klass* non-NULL, so we need hardware store ordering here.
 257   assert(!k-&gt;name()-&gt;is_Q_signature(), &quot;Q-type without JVM_CONSTANT_QDescBit&quot;);
 258   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 259 }
 260 
 261 #if INCLUDE_CDS_JAVA_HEAP
 262 // Archive the resolved references
 263 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 264   if (_cache == NULL) {
 265     return; // nothing to do
 266   }
 267 
 268   InstanceKlass *ik = pool_holder();
 269   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 270         ik-&gt;is_shared_app_class())) {
 271     // Archiving resolved references for classes from non-builtin loaders
 272     // is not yet supported.
 273     set_resolved_references(NULL);
 274     return;
 275   }
 276 
 277   objArrayOop rr = resolved_references();
 278   Array&lt;u2&gt;* ref_map = reference_map();
 279   if (rr != NULL) {
 280     int ref_map_len = ref_map == NULL ? 0 : ref_map-&gt;length();
 281     int rr_len = rr-&gt;length();
 282     for (int i = 0; i &lt; rr_len; i++) {
 283       oop p = rr-&gt;obj_at(i);
 284       rr-&gt;obj_at_put(i, NULL);
 285       if (p != NULL &amp;&amp; i &lt; ref_map_len) {
 286         int index = object_to_cp_index(i);
 287         if (tag_at(index).is_string()) {
 288           oop op = StringTable::create_archived_string(p, THREAD);
 289           // If the String object is not archived (possibly too large),
 290           // NULL is returned. Also set it in the array, so we won&#39;t
 291           // have a &#39;bad&#39; reference in the archived resolved_reference
 292           // array.
 293           rr-&gt;obj_at_put(i, op);
 294         }
 295       }
 296     }
 297 
 298     oop archived = HeapShared::archive_heap_object(rr, THREAD);
 299     // If the resolved references array is not archived (too large),
 300     // the &#39;archived&#39; object is NULL. No need to explicitly check
 301     // the return value of archive_heap_object here. At runtime, the
 302     // resolved references will be created using the normal process
 303     // when there is no archived value.
 304     _cache-&gt;set_archived_references(archived);
 305     set_resolved_references(NULL);
 306   }
 307 }
 308 
 309 void ConstantPool::resolve_class_constants(TRAPS) {
 310   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
 311   // The _cache may be NULL if the _pool_holder klass fails verification
 312   // at dump time due to missing dependencies.
 313   if (cache() == NULL || reference_map() == NULL) {
 314     return; // nothing to do
 315   }
 316 
 317   constantPoolHandle cp(THREAD, this);
 318   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 319     if (tag_at(index).is_string() &amp;&amp; !cp-&gt;is_pseudo_string_at(index)) {
 320       int cache_index = cp-&gt;cp_to_object_index(index);
 321       string_at_impl(cp, index, cache_index, CHECK);
 322     }
 323   }
 324 }
 325 #endif
 326 
 327 // CDS support. Create a new resolved_references array.
 328 void ConstantPool::restore_unshareable_info(TRAPS) {
 329   assert(is_constantPool(), &quot;ensure C++ vtable is restored&quot;);
 330   assert(on_stack(), &quot;should always be set for shared constant pools&quot;);
 331   assert(is_shared(), &quot;should always be set for shared constant pools&quot;);
 332   assert(_cache != NULL, &quot;constant pool _cache should not be NULL&quot;);
 333 
 334   // Only create the new resolved references array if it hasn&#39;t been attempted before
 335   if (resolved_references() != NULL) return;
 336 
 337   // restore the C++ vtable from the shared archive
 338   restore_vtable();
 339 
 340   if (SystemDictionary::Object_klass_loaded()) {
 341     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
 342 #if INCLUDE_CDS_JAVA_HEAP
 343     if (HeapShared::open_archive_heap_region_mapped() &amp;&amp;
 344         _cache-&gt;archived_references() != NULL) {
 345       oop archived = _cache-&gt;archived_references();
 346       // Create handle for the archived resolved reference array object
 347       Handle refs_handle(THREAD, archived);
 348       set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 349     } else
 350 #endif
 351     {
 352       // No mapped archived resolved reference array
 353       // Recreate the object array and add to ClassLoaderData.
 354       int map_length = resolved_reference_length();
 355       if (map_length &gt; 0) {
 356         objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 357         Handle refs_handle(THREAD, (oop)stom);  // must handleize.
 358         set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 359       }
 360     }
 361   }
 362 }
 363 
 364 void ConstantPool::remove_unshareable_info() {
 365   // Resolved references are not in the shared archive.
 366   // Save the length for restoration.  It is not necessarily the same length
 367   // as reference_map.length() if invokedynamic is saved. It is needed when
 368   // re-creating the resolved reference array if archived heap data cannot be map
 369   // at runtime.
 370   set_resolved_reference_length(
 371     resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
 372 
 373   // If archiving heap objects is not allowed, clear the resolved references.
 374   // Otherwise, it is cleared after the resolved references array is cached
 375   // (see archive_resolved_references()).
 376   // If DynamicDumpSharedSpaces is enabled, clear the resolved references also
 377   // as java objects are not archived in the top layer.
 378   if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {
 379     set_resolved_references(NULL);
 380   }
 381 
 382   // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
 383   // The _on_stack flag is used to prevent ConstantPools from deallocation during
 384   // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
 385   // we always set _on_stack to true to avoid having to change _flags during runtime.
 386   _flags |= (_on_stack | _is_shared);
 387   int num_klasses = 0;
 388   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 389     if (!DynamicDumpSharedSpaces) {
 390       assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during static dump time&quot;);
 391     } else {
 392       if (tag_at(index).is_unresolved_klass_in_error() ||
 393           tag_at(index).is_method_handle_in_error()    ||
 394           tag_at(index).is_method_type_in_error()      ||
 395           tag_at(index).is_dynamic_constant_in_error()) {
 396         tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 397       }
 398     }
 399     if (tag_at(index).is_klass()) {
 400       // This class was resolved as a side effect of executing Java code
 401       // during dump time. We need to restore it back to an UnresolvedClass,
 402       // so that the proper class loading and initialization can happen
 403       // at runtime.
 404       CPKlassSlot kslot = klass_slot_at(index);
 405       int resolved_klass_index = kslot.resolved_klass_index();
 406       int name_index = kslot.name_index();
 407       assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 408       resolved_klasses()-&gt;at_put(resolved_klass_index, NULL);
 409       tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 410       assert(klass_name_at(index) == symbol_at(name_index), &quot;sanity&quot;);
 411     }
 412   }
 413   if (cache() != NULL) {
 414     cache()-&gt;remove_unshareable_info();
 415   }
 416 }
 417 
 418 int ConstantPool::cp_to_object_index(int cp_index) {
 419   // this is harder don&#39;t do this so much.
 420   int i = reference_map()-&gt;find(cp_index);
 421   // We might not find the index for jsr292 call.
 422   return (i &lt; 0) ? _no_index_sentinel : i;
 423 }
 424 
 425 void ConstantPool::string_at_put(int which, int obj_index, oop str) {
 426   resolved_references()-&gt;obj_at_put(obj_index, str);
 427 }
 428 
 429 void ConstantPool::trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k) {
 430   ResourceMark rm;
 431   int line_number = -1;
 432   const char * source_file = NULL;
 433   if (JavaThread::current()-&gt;has_last_Java_frame()) {
 434     // try to identify the method which called this function.
 435     vframeStream vfst(JavaThread::current());
 436     if (!vfst.at_end()) {
 437       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 438       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 439       if (s != NULL) {
 440         source_file = s-&gt;as_C_string();
 441       }
 442     }
 443   }
 444   if (k != this_cp-&gt;pool_holder()) {
 445     // only print something if the classes are different
 446     if (source_file != NULL) {
 447       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 448                  this_cp-&gt;pool_holder()-&gt;external_name(),
 449                  k-&gt;external_name(), source_file, line_number);
 450     } else {
 451       log_debug(class, resolve)(&quot;%s %s&quot;,
 452                  this_cp-&gt;pool_holder()-&gt;external_name(),
 453                  k-&gt;external_name());
 454     }
 455   }
 456 }
 457 
 458 void check_is_value_type(Klass* k, TRAPS) {
 459   if (!k-&gt;is_value()) {
 460     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 461   }
 462 }
 463 
 464 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 465                                    bool save_resolution_error, TRAPS) {
 466   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 467   JavaThread* javaThread = (JavaThread*)THREAD;
 468 
 469   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 470   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 471   // the entry and tag is not updated atomicly.
 472   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 473   int resolved_klass_index = kslot.resolved_klass_index();
 474   int name_index = kslot.name_index();
 475   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 476 
 477   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 478   if (klass != NULL) {
 479     return klass;
 480   }
 481 
 482   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 483   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 484     // The original attempt to resolve this constant pool entry failed so find the
 485     // class of the original error and throw another error of the same class
 486     // (JVMS 5.4.3).
 487     // If there is a detail message, pass that detail message to the error.
 488     // The JVMS does not strictly require us to duplicate the same detail message,
 489     // or any internal exception fields such as cause or stacktrace.  But since the
 490     // detail message is often a class name or other literal string, we will repeat it
 491     // if we can find it in the symbol table.
 492     throw_resolution_error(this_cp, which, CHECK_NULL);
 493     ShouldNotReachHere();
 494   }
 495 
 496   Handle mirror_handle;
 497   Symbol* name = this_cp-&gt;symbol_at(name_index);
 498   bool value_type_signature = false;
 499   if (name-&gt;is_Q_signature()) {
 500     name = name-&gt;fundamental_name(THREAD);
 501     value_type_signature = true;
 502   }
 503   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 504   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 505 
 506   Klass* k;
 507   {
 508     // Turn off the single stepping while doing class resolution
 509     JvmtiHideSingleStepping jhss(javaThread);
 510     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 511   } //  JvmtiHideSingleStepping jhss(javaThread);
 512   if (value_type_signature) {
 513     name-&gt;decrement_refcount();
 514   }
 515 
 516   if (!HAS_PENDING_EXCEPTION) {
 517     // preserve the resolved klass from unloading
 518     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 519     // Do access check for klasses
 520     verify_constant_pool_resolve(this_cp, k, THREAD);
 521   }
 522 
 523   if (!HAS_PENDING_EXCEPTION &amp;&amp; value_type_signature) {
 524     check_is_value_type(k, THREAD);
 525   }
 526 
 527   if (!HAS_PENDING_EXCEPTION) {
 528     Klass* bottom_klass = NULL;
 529     if (k-&gt;is_objArray_klass()) {
 530       bottom_klass = ObjArrayKlass::cast(k)-&gt;bottom_klass();
 531       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 532       assert(bottom_klass-&gt;is_instance_klass() || bottom_klass-&gt;is_typeArray_klass(), &quot;Sanity check&quot;);
 533     } else if (k-&gt;is_valueArray_klass()) {
 534       bottom_klass = ValueArrayKlass::cast(k)-&gt;element_klass();
 535       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 536     }
 537   }
 538 
 539   // Failed to resolve class. We must record the errors so that subsequent attempts
 540   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 541   if (HAS_PENDING_EXCEPTION) {
 542     if (save_resolution_error) {
 543       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 544       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 545       // some other thread has beaten us and has resolved the class.
 546       // To preserve old behavior, we return the resolved class.
 547       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 548       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 549       return klass;
 550     } else {
 551       return NULL;  // return the pending exception
 552     }
 553   }
 554 
 555   // logging for class+resolve.
 556   if (log_is_enabled(Debug, class, resolve)){
 557     trace_class_resolution(this_cp, k);
 558   }
 559   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 560   Atomic::release_store(adr, k);
 561   // The interpreter assumes when the tag is stored, the klass is resolved
 562   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 563   // hardware store ordering here.
 564   jbyte tag = JVM_CONSTANT_Class;
 565   if (this_cp-&gt;tag_at(which).is_Qdescriptor_klass()) {
 566     tag |= JVM_CONSTANT_QDescBit;
 567   }
 568   this_cp-&gt;release_tag_at_put(which, tag);
 569   return k;
 570 }
 571 
 572 
 573 // Does not update ConstantPool* - to avoid any exception throwing. Used
 574 // by compiler and exception handling.  Also used to avoid classloads for
 575 // instanceof operations. Returns NULL if the class has not been loaded or
 576 // if the verification of constant pool failed
 577 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 578   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 579   int resolved_klass_index = kslot.resolved_klass_index();
 580   int name_index = kslot.name_index();
 581   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 582 
 583   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 584   if (k != NULL) {
 585     return k;
 586   } else {
 587     Thread *thread = Thread::current();
 588     Symbol* name = this_cp-&gt;symbol_at(name_index);
 589     oop loader = this_cp-&gt;pool_holder()-&gt;class_loader();
 590     oop protection_domain = this_cp-&gt;pool_holder()-&gt;protection_domain();
 591     Handle h_prot (thread, protection_domain);
 592     Handle h_loader (thread, loader);
 593     Klass* k = SystemDictionary::find(name, h_loader, h_prot, thread);
 594 
 595     // Avoid constant pool verification at a safepoint, which takes the Module_lock.
 596     if (k != NULL &amp;&amp; !SafepointSynchronize::is_at_safepoint()) {
 597       // Make sure that resolving is legal
 598       EXCEPTION_MARK;
 599       // return NULL if verification fails
 600       verify_constant_pool_resolve(this_cp, k, THREAD);
 601       if (HAS_PENDING_EXCEPTION) {
 602         CLEAR_PENDING_EXCEPTION;
 603         return NULL;
 604       }
 605       return k;
 606     } else {
 607       return k;
 608     }
 609   }
 610 }
 611 
 612 Method* ConstantPool::method_at_if_loaded(const constantPoolHandle&amp; cpool,
 613                                                    int which) {
 614   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 615   int cache_index = decode_cpcache_index(which, true);
 616   if (!(cache_index &gt;= 0 &amp;&amp; cache_index &lt; cpool-&gt;cache()-&gt;length())) {
 617     // FIXME: should be an assert
 618     log_debug(class, resolve)(&quot;bad operand %d in:&quot;, which); cpool-&gt;print();
 619     return NULL;
 620   }
 621   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 622   return e-&gt;method_if_resolved(cpool);
 623 }
 624 
 625 
 626 bool ConstantPool::has_appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 627   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 628   int cache_index = decode_cpcache_index(which, true);
 629   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 630   return e-&gt;has_appendix();
 631 }
 632 
 633 oop ConstantPool::appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 634   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 635   int cache_index = decode_cpcache_index(which, true);
 636   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 637   return e-&gt;appendix_if_resolved(cpool);
 638 }
 639 
 640 
 641 bool ConstantPool::has_local_signature_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 642   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 643   int cache_index = decode_cpcache_index(which, true);
 644   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 645   return e-&gt;has_local_signature();
 646 }
 647 
 648 Symbol* ConstantPool::impl_name_ref_at(int which, bool uncached) {
 649   int name_index = name_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 650   return symbol_at(name_index);
 651 }
 652 
 653 
 654 Symbol* ConstantPool::impl_signature_ref_at(int which, bool uncached) {
 655   int signature_index = signature_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 656   return symbol_at(signature_index);
 657 }
 658 
 659 int ConstantPool::impl_name_and_type_ref_index_at(int which, bool uncached) {
 660   int i = which;
 661   if (!uncached &amp;&amp; cache() != NULL) {
 662     if (ConstantPool::is_invokedynamic_index(which)) {
 663       // Invokedynamic index is index into the constant pool cache
 664       int pool_index = invokedynamic_bootstrap_ref_index_at(which);
 665       pool_index = bootstrap_name_and_type_ref_index_at(pool_index);
 666       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 667       return pool_index;
 668     }
 669     // change byte-ordering and go via cache
 670     i = remap_instruction_operand_from_cache(which);
 671   } else {
 672     if (tag_at(which).has_bootstrap()) {
 673       int pool_index = bootstrap_name_and_type_ref_index_at(which);
 674       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 675       return pool_index;
 676     }
 677   }
 678   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 679   assert(!tag_at(i).has_bootstrap(), &quot;Must be handled above&quot;);
 680   jint ref_index = *int_at_addr(i);
 681   return extract_high_short_from_int(ref_index);
 682 }
 683 
 684 constantTag ConstantPool::impl_tag_ref_at(int which, bool uncached) {
 685   int pool_index = which;
 686   if (!uncached &amp;&amp; cache() != NULL) {
 687     if (ConstantPool::is_invokedynamic_index(which)) {
 688       // Invokedynamic index is index into resolved_references
 689       pool_index = invokedynamic_bootstrap_ref_index_at(which);
 690     } else {
 691       // change byte-ordering and go via cache
 692       pool_index = remap_instruction_operand_from_cache(which);
 693     }
 694   }
 695   return tag_at(pool_index);
 696 }
 697 
 698 int ConstantPool::impl_klass_ref_index_at(int which, bool uncached) {
 699   guarantee(!ConstantPool::is_invokedynamic_index(which),
 700             &quot;an invokedynamic instruction does not have a klass&quot;);
 701   int i = which;
 702   if (!uncached &amp;&amp; cache() != NULL) {
 703     // change byte-ordering and go via cache
 704     i = remap_instruction_operand_from_cache(which);
 705   }
 706   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 707   jint ref_index = *int_at_addr(i);
 708   return extract_low_short_from_int(ref_index);
 709 }
 710 
 711 
 712 
 713 int ConstantPool::remap_instruction_operand_from_cache(int operand) {
 714   int cpc_index = operand;
 715   DEBUG_ONLY(cpc_index -= CPCACHE_INDEX_TAG);
 716   assert((int)(u2)cpc_index == cpc_index, &quot;clean u2&quot;);
 717   int member_index = cache()-&gt;entry_at(cpc_index)-&gt;constant_pool_index();
 718   return member_index;
 719 }
 720 
 721 
 722 void ConstantPool::verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* k, TRAPS) {
 723   if (!(k-&gt;is_instance_klass() || k-&gt;is_objArray_klass())) {
 724     return;  // short cut, typeArray klass is always accessible
 725   }
 726   Klass* holder = this_cp-&gt;pool_holder();
 727   bool fold_type_to_class = true;
 728   LinkResolver::check_klass_accessability(holder, k, fold_type_to_class, CHECK);
 729 }
 730 
 731 
 732 int ConstantPool::name_ref_index_at(int which_nt) {
 733   jint ref_index = name_and_type_at(which_nt);
 734   return extract_low_short_from_int(ref_index);
 735 }
 736 
 737 
 738 int ConstantPool::signature_ref_index_at(int which_nt) {
 739   jint ref_index = name_and_type_at(which_nt);
 740   return extract_high_short_from_int(ref_index);
 741 }
 742 
 743 
 744 Klass* ConstantPool::klass_ref_at(int which, TRAPS) {
 745   return klass_at(klass_ref_index_at(which), THREAD);
 746 }
 747 
 748 Symbol* ConstantPool::klass_name_at(int which) const {
 749   return symbol_at(klass_slot_at(which).name_index());
 750 }
 751 
 752 Symbol* ConstantPool::klass_ref_at_noresolve(int which) {
 753   jint ref_index = klass_ref_index_at(which);
 754   return klass_at_noresolve(ref_index);
 755 }
 756 
 757 Symbol* ConstantPool::uncached_klass_ref_at_noresolve(int which) {
 758   jint ref_index = uncached_klass_ref_index_at(which);
 759   return klass_at_noresolve(ref_index);
 760 }
 761 
 762 char* ConstantPool::string_at_noresolve(int which) {
 763   return unresolved_string_at(which)-&gt;as_C_string();
 764 }
 765 
 766 BasicType ConstantPool::basic_type_for_signature_at(int which) const {
 767   return Signature::basic_type(symbol_at(which));
 768 }
 769 
 770 
 771 void ConstantPool::resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS) {
 772   for (int index = 1; index &lt; this_cp-&gt;length(); index++) { // Index 0 is unused
 773     if (this_cp-&gt;tag_at(index).is_string()) {
 774       this_cp-&gt;string_at(index, CHECK);
 775     }
 776   }
 777 }
 778 
 779 Symbol* ConstantPool::exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception) {
 780   // Dig out the detailed message to reuse if possible
 781   Symbol* message = java_lang_Throwable::detail_message(pending_exception);
 782   if (message != NULL) {
 783     return message;
 784   }
 785 
 786   // Return specific message for the tag
 787   switch (tag.value()) {
 788   case JVM_CONSTANT_UnresolvedClass:
 789     // return the class name in the error message
 790     message = this_cp-&gt;klass_name_at(which);
 791     break;
 792   case JVM_CONSTANT_MethodHandle:
 793     // return the method handle name in the error message
 794     message = this_cp-&gt;method_handle_name_ref_at(which);
 795     break;
 796   case JVM_CONSTANT_MethodType:
 797     // return the method type signature in the error message
 798     message = this_cp-&gt;method_type_signature_at(which);
 799     break;
 800   case JVM_CONSTANT_Dynamic:
 801     // return the name of the condy in the error message
 802     message = this_cp-&gt;uncached_name_ref_at(which);
 803     break;
 804   default:
 805     ShouldNotReachHere();
 806   }
 807 
 808   return message;
 809 }
 810 
 811 void ConstantPool::throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS) {
 812   Symbol* message = NULL;
 813   Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &amp;message);
 814   assert(error != NULL, &quot;checking&quot;);
 815   CLEAR_PENDING_EXCEPTION;
 816   if (message != NULL) {
 817     ResourceMark rm;
 818     THROW_MSG(error, message-&gt;as_C_string());
 819   } else {
 820     THROW(error);
 821   }
 822 }
 823 
 824 // If resolution for Class, Dynamic constant, MethodHandle or MethodType fails, save the
 825 // exception in the resolution error table, so that the same exception is thrown again.
 826 void ConstantPool::save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which,
 827                                             constantTag tag, TRAPS) {
 828   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 829 
 830   int error_tag = tag.error_value();
 831 
 832   if (!PENDING_EXCEPTION-&gt;
 833     is_a(SystemDictionary::LinkageError_klass())) {
 834     // Just throw the exception and don&#39;t prevent these classes from
 835     // being loaded due to virtual machine errors like StackOverflow
 836     // and OutOfMemoryError, etc, or if the thread was hit by stop()
 837     // Needs clarification to section 5.4.3 of the VM spec (see 6308271)
 838   } else if (this_cp-&gt;tag_at(which).value() != error_tag) {
 839     Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);
 840     SystemDictionary::add_resolution_error(this_cp, which, error, message);
 841     // CAS in the tag.  If a thread beat us to registering this error that&#39;s fine.
 842     // If another thread resolved the reference, this is a race condition. This
 843     // thread may have had a security manager or something temporary.
 844     // This doesn&#39;t deterministically get an error.   So why do we save this?
 845     // We save this because jvmti can add classes to the bootclass path after
 846     // this error, so it needs to get the same error if the error is first.
 847     jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp-&gt;tag_addr_at(which),
 848                                     (jbyte)tag.value(),
 849                                     (jbyte)error_tag);
 850     if (old_tag != error_tag &amp;&amp; old_tag != tag.value()) {
 851       // MethodHandles and MethodType doesn&#39;t change to resolved version.
 852       assert(this_cp-&gt;tag_at(which).is_klass(), &quot;Wrong tag value&quot;);
 853       // Forget the exception and use the resolved class.
 854       CLEAR_PENDING_EXCEPTION;
 855     }
 856   } else {
 857     // some other thread put this in error state
 858     throw_resolution_error(this_cp, which, CHECK);
 859   }
 860 }
 861 
 862 constantTag ConstantPool::constant_tag_at(int which) {
 863   constantTag tag = tag_at(which);
 864   if (tag.is_dynamic_constant() ||
 865       tag.is_dynamic_constant_in_error()) {
 866     BasicType bt = basic_type_for_constant_at(which);
 867     // dynamic constant could return an array, treat as object
 868     return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);
 869   }
 870   return tag;
 871 }
 872 
 873 BasicType ConstantPool::basic_type_for_constant_at(int which) {
 874   constantTag tag = tag_at(which);
 875   if (tag.is_dynamic_constant() ||
 876       tag.is_dynamic_constant_in_error()) {
 877     // have to look at the signature for this one
 878     Symbol* constant_type = uncached_signature_ref_at(which);
 879     return Signature::basic_type(constant_type);
 880   }
 881   return tag.basic_type();
 882 }
 883 
 884 // Called to resolve constants in the constant pool and return an oop.
 885 // Some constant pool entries cache their resolved oop. This is also
 886 // called to create oops from constants to use in arguments for invokedynamic
 887 oop ConstantPool::resolve_constant_at_impl(const constantPoolHandle&amp; this_cp,
 888                                            int index, int cache_index,
 889                                            bool* status_return, TRAPS) {
 890   oop result_oop = NULL;
 891   Handle throw_exception;
 892 
 893   if (cache_index == _possible_index_sentinel) {
 894     // It is possible that this constant is one which is cached in the objects.
 895     // We&#39;ll do a linear search.  This should be OK because this usage is rare.
 896     // FIXME: If bootstrap specifiers stress this code, consider putting in
 897     // a reverse index.  Binary search over a short array should do it.
 898     assert(index &gt; 0, &quot;valid index&quot;);
 899     cache_index = this_cp-&gt;cp_to_object_index(index);
 900   }
 901   assert(cache_index == _no_index_sentinel || cache_index &gt;= 0, &quot;&quot;);
 902   assert(index == _no_index_sentinel || index &gt;= 0, &quot;&quot;);
 903 
 904   if (cache_index &gt;= 0) {
 905     result_oop = this_cp-&gt;resolved_references()-&gt;obj_at(cache_index);
 906     if (result_oop != NULL) {
 907       if (result_oop == Universe::the_null_sentinel()) {
 908         DEBUG_ONLY(int temp_index = (index &gt;= 0 ? index : this_cp-&gt;object_to_cp_index(cache_index)));
 909         assert(this_cp-&gt;tag_at(temp_index).is_dynamic_constant(), &quot;only condy uses the null sentinel&quot;);
 910         result_oop = NULL;
 911       }
 912       if (status_return != NULL)  (*status_return) = true;
 913       return result_oop;
 914       // That was easy...
 915     }
 916     index = this_cp-&gt;object_to_cp_index(cache_index);
 917   }
 918 
 919   jvalue prim_value;  // temp used only in a few cases below
 920 
 921   constantTag tag = this_cp-&gt;tag_at(index);
 922 
 923   if (status_return != NULL) {
 924     // don&#39;t trigger resolution if the constant might need it
 925     switch (tag.value()) {
 926     case JVM_CONSTANT_Class:
 927     {
 928       CPKlassSlot kslot = this_cp-&gt;klass_slot_at(index);
 929       int resolved_klass_index = kslot.resolved_klass_index();
 930       if (this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index) == NULL) {
 931         (*status_return) = false;
 932         return NULL;
 933       }
 934       // the klass is waiting in the CP; go get it
 935       break;
 936     }
 937     case JVM_CONSTANT_String:
 938     case JVM_CONSTANT_Integer:
 939     case JVM_CONSTANT_Float:
 940     case JVM_CONSTANT_Long:
 941     case JVM_CONSTANT_Double:
 942       // these guys trigger OOM at worst
 943       break;
 944     default:
 945       (*status_return) = false;
 946       return NULL;
 947     }
 948     // from now on there is either success or an OOME
 949     (*status_return) = true;
 950   }
 951 
 952   switch (tag.value()) {
 953 
 954   case JVM_CONSTANT_UnresolvedClass:
 955   case JVM_CONSTANT_UnresolvedClassInError:
 956   case JVM_CONSTANT_Class:
 957     {
 958       assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
 959       Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);
 960       // ldc wants the java mirror.
 961       result_oop = resolved-&gt;java_mirror();
 962       break;
 963     }
 964 
 965   case JVM_CONSTANT_Dynamic:
 966     {
 967       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.
 968       BootstrapInfo bootstrap_specifier(this_cp, index);
 969 
 970       // The initial step in resolving an unresolved symbolic reference to a
 971       // dynamically-computed constant is to resolve the symbolic reference to a
 972       // method handle which will be the bootstrap method for the dynamically-computed
 973       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 974       // method fails, then a MethodHandleInError is stored at the corresponding
 975       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 976       // set a DynamicConstantInError here since any subsequent use of this
 977       // bootstrap method will encounter the resolution of MethodHandleInError.
 978       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
 979       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
 980       // for the bootstrap_specifier created above.
 981       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
 982       Exceptions::wrap_dynamic_exception(THREAD);
 983       if (HAS_PENDING_EXCEPTION) {
 984         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 985         // will check for a LinkageError and store a DynamicConstantInError.
 986         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 987       }
 988       result_oop = bootstrap_specifier.resolved_value()();
 989       BasicType type = Signature::basic_type(bootstrap_specifier.signature());
 990       if (!is_reference_type(type)) {
 991         // Make sure the primitive value is properly boxed.
 992         // This is a JDK responsibility.
 993         const char* fail = NULL;
 994         if (result_oop == NULL) {
 995           fail = &quot;null result instead of box&quot;;
 996         } else if (!is_java_primitive(type)) {
 997           // FIXME: support value types via unboxing
 998           fail = &quot;can only handle references and primitives&quot;;
 999         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
1000           fail = &quot;primitive is not properly boxed&quot;;
1001         }
1002         if (fail != NULL) {
1003           // Since this exception is not a LinkageError, throw exception
1004           // but do not save a DynamicInError resolution result.
1005           // See section 5.4.3 of the VM spec.
1006           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
1007         }
1008       }
1009 
1010       if (TraceMethodHandles) {
1011         bootstrap_specifier.print_msg_on(tty, &quot;resolve_constant_at_impl&quot;);
1012       }
1013       break;
1014     }
1015 
1016   case JVM_CONSTANT_String:
1017     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
1018     if (this_cp-&gt;is_pseudo_string_at(index)) {
1019       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
1020       break;
1021     }
1022     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
1023     break;
1024 
1025   case JVM_CONSTANT_DynamicInError:
1026   case JVM_CONSTANT_MethodHandleInError:
1027   case JVM_CONSTANT_MethodTypeInError:
1028     {
1029       throw_resolution_error(this_cp, index, CHECK_NULL);
1030       break;
1031     }
1032 
1033   case JVM_CONSTANT_MethodHandle:
1034     {
1035       int ref_kind                 = this_cp-&gt;method_handle_ref_kind_at(index);
1036       int callee_index             = this_cp-&gt;method_handle_klass_index_at(index);
1037       Symbol*  name =      this_cp-&gt;method_handle_name_ref_at(index);
1038       Symbol*  signature = this_cp-&gt;method_handle_signature_ref_at(index);
1039       constantTag m_tag  = this_cp-&gt;tag_at(this_cp-&gt;method_handle_index_at(index));
1040       { ResourceMark rm(THREAD);
1041         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodHandle:%d [%d/%d/%d] %s.%s&quot;,
1042                               ref_kind, index, this_cp-&gt;method_handle_index_at(index),
1043                               callee_index, name-&gt;as_C_string(), signature-&gt;as_C_string());
1044       }
1045 
1046       Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);
1047 
1048       // Check constant pool method consistency
1049       if ((callee-&gt;is_interface() &amp;&amp; m_tag.is_method()) ||
1050           ((!callee-&gt;is_interface() &amp;&amp; m_tag.is_interface_method()))) {
1051         ResourceMark rm(THREAD);
1052         stringStream ss;
1053         ss.print(&quot;Inconsistent constant pool data in classfile for class %s. &quot;
1054                  &quot;Method &#39;&quot;, callee-&gt;name()-&gt;as_C_string());
1055         signature-&gt;print_as_signature_external_return_type(&amp;ss);
1056         ss.print(&quot; %s(&quot;, name-&gt;as_C_string());
1057         signature-&gt;print_as_signature_external_parameters(&amp;ss);
1058         ss.print(&quot;)&#39; at index %d is %s and should be %s&quot;,
1059                  index,
1060                  callee-&gt;is_interface() ? &quot;CONSTANT_MethodRef&quot; : &quot;CONSTANT_InterfaceMethodRef&quot;,
1061                  callee-&gt;is_interface() ? &quot;CONSTANT_InterfaceMethodRef&quot; : &quot;CONSTANT_MethodRef&quot;);
1062         THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1063       }
1064 
1065       Klass* klass = this_cp-&gt;pool_holder();
1066       Handle value = SystemDictionary::link_method_handle_constant(klass, ref_kind,
1067                                                                    callee, name, signature,
1068                                                                    THREAD);
1069       result_oop = value();
1070       if (HAS_PENDING_EXCEPTION) {
1071         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1072       }
1073       break;
1074     }
1075 
1076   case JVM_CONSTANT_MethodType:
1077     {
1078       Symbol*  signature = this_cp-&gt;method_type_signature_at(index);
1079       { ResourceMark rm(THREAD);
1080         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodType [%d/%d] %s&quot;,
1081                               index, this_cp-&gt;method_type_index_at(index),
1082                               signature-&gt;as_C_string());
1083       }
1084       Klass* klass = this_cp-&gt;pool_holder();
1085       Handle value = SystemDictionary::find_method_handle_type(signature, klass, THREAD);
1086       result_oop = value();
1087       if (HAS_PENDING_EXCEPTION) {
1088         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1089       }
1090       break;
1091     }
1092 
1093   case JVM_CONSTANT_Integer:
1094     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1095     prim_value.i = this_cp-&gt;int_at(index);
1096     result_oop = java_lang_boxing_object::create(T_INT, &amp;prim_value, CHECK_NULL);
1097     break;
1098 
1099   case JVM_CONSTANT_Float:
1100     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1101     prim_value.f = this_cp-&gt;float_at(index);
1102     result_oop = java_lang_boxing_object::create(T_FLOAT, &amp;prim_value, CHECK_NULL);
1103     break;
1104 
1105   case JVM_CONSTANT_Long:
1106     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1107     prim_value.j = this_cp-&gt;long_at(index);
1108     result_oop = java_lang_boxing_object::create(T_LONG, &amp;prim_value, CHECK_NULL);
1109     break;
1110 
1111   case JVM_CONSTANT_Double:
1112     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1113     prim_value.d = this_cp-&gt;double_at(index);
1114     result_oop = java_lang_boxing_object::create(T_DOUBLE, &amp;prim_value, CHECK_NULL);
1115     break;
1116 
1117   default:
1118     DEBUG_ONLY( tty-&gt;print_cr(&quot;*** %p: tag at CP[%d/%d] = %d&quot;,
1119                               this_cp(), index, cache_index, tag.value()));
1120     assert(false, &quot;unexpected constant tag&quot;);
1121     break;
1122   }
1123 
1124   if (cache_index &gt;= 0) {
1125     // Benign race condition:  resolved_references may already be filled in.
1126     // The important thing here is that all threads pick up the same result.
1127     // It doesn&#39;t matter which racing thread wins, as long as only one
1128     // result is used by all threads, and all future queries.
1129     oop new_result = (result_oop == NULL ? Universe::the_null_sentinel() : result_oop);
1130     oop old_result = this_cp-&gt;resolved_references()
1131       -&gt;atomic_compare_exchange_oop(cache_index, new_result, NULL);
1132     if (old_result == NULL) {
1133       return result_oop;  // was installed
1134     } else {
1135       // Return the winning thread&#39;s result.  This can be different than
1136       // the result here for MethodHandles.
1137       if (old_result == Universe::the_null_sentinel())
1138         old_result = NULL;
1139       return old_result;
1140     }
1141   } else {
1142     assert(result_oop != Universe::the_null_sentinel(), &quot;&quot;);
1143     return result_oop;
1144   }
1145 }
1146 
1147 oop ConstantPool::uncached_string_at(int which, TRAPS) {
1148   Symbol* sym = unresolved_string_at(which);
1149   oop str = StringTable::intern(sym, CHECK_(NULL));
1150   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1151   return str;
1152 }
1153 
1154 void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
1155                                                     int start_arg, int end_arg,
1156                                                     objArrayHandle info, int pos,
1157                                                     bool must_resolve, Handle if_not_available,
1158                                                     TRAPS) {
1159   int argc;
1160   int limit = pos + end_arg - start_arg;
1161   // checks: index in range [0..this_cp-&gt;length),
1162   // tag at index, start..end in range [0..argc],
1163   // info array non-null, pos..limit in [0..info.length]
1164   if ((0 &gt;= index    || index &gt;= this_cp-&gt;length())  ||
1165       !(this_cp-&gt;tag_at(index).is_invoke_dynamic()    ||
1166         this_cp-&gt;tag_at(index).is_dynamic_constant()) ||
1167       (0 &gt; start_arg || start_arg &gt; end_arg) ||
1168       (end_arg &gt; (argc = this_cp-&gt;bootstrap_argument_count_at(index))) ||
1169       (0 &gt; pos       || pos &gt; limit)         ||
1170       (info.is_null() || limit &gt; info-&gt;length())) {
1171     // An index or something else went wrong; throw an error.
1172     // Since this is an internal API, we don&#39;t expect this,
1173     // so we don&#39;t bother to craft a nice message.
1174     THROW_MSG(vmSymbols::java_lang_LinkageError(), &quot;bad BSM argument access&quot;);
1175   }
1176   // now we can loop safely
1177   int info_i = pos;
1178   for (int i = start_arg; i &lt; end_arg; i++) {
1179     int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);
1180     oop arg_oop;
1181     if (must_resolve) {
1182       arg_oop = this_cp-&gt;resolve_possibly_cached_constant_at(arg_index, CHECK);
1183     } else {
1184       bool found_it = false;
1185       arg_oop = this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK);
1186       if (!found_it)  arg_oop = if_not_available();
1187     }
1188     info-&gt;obj_at_put(info_i++, arg_oop);
1189   }
1190 }
1191 
1192 oop ConstantPool::string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS) {
1193   // If the string has already been interned, this entry will be non-null
1194   oop str = this_cp-&gt;resolved_references()-&gt;obj_at(obj_index);
1195   assert(str != Universe::the_null_sentinel(), &quot;&quot;);
1196   if (str != NULL) return str;
1197   Symbol* sym = this_cp-&gt;unresolved_string_at(which);
1198   str = StringTable::intern(sym, CHECK_(NULL));
1199   this_cp-&gt;string_at_put(which, obj_index, str);
1200   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1201   return str;
1202 }
1203 
1204 
1205 bool ConstantPool::klass_name_at_matches(const InstanceKlass* k, int which) {
1206   // Names are interned, so we can compare Symbol*s directly
1207   Symbol* cp_name = klass_name_at(which);
1208   return (cp_name == k-&gt;name());
1209 }
1210 
1211 
1212 // Iterate over symbols and decrement ones which are Symbol*s
1213 // This is done during GC.
1214 // Only decrement the UTF8 symbols. Strings point to
1215 // these symbols but didn&#39;t increment the reference count.
1216 void ConstantPool::unreference_symbols() {
1217   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
1218     constantTag tag = tag_at(index);
1219     if (tag.is_symbol()) {
1220       symbol_at(index)-&gt;decrement_refcount();
1221     }
1222   }
1223 }
1224 
1225 
1226 // Compare this constant pool&#39;s entry at index1 to the constant pool
1227 // cp2&#39;s entry at index2.
1228 bool ConstantPool::compare_entry_to(int index1, const constantPoolHandle&amp; cp2,
1229        int index2, TRAPS) {
1230 
1231   // The error tags are equivalent to non-error tags when comparing
1232   jbyte t1 = tag_at(index1).non_error_value();
1233   jbyte t2 = cp2-&gt;tag_at(index2).non_error_value();
1234 
1235   if (t1 != t2) {
1236     // Not the same entry type so there is nothing else to check. Note
1237     // that this style of checking will consider resolved/unresolved
1238     // class pairs as different.
1239     // From the ConstantPool* API point of view, this is correct
1240     // behavior. See VM_RedefineClasses::merge_constant_pools() to see how this
1241     // plays out in the context of ConstantPool* merging.
1242     return false;
1243   }
1244 
1245   switch (t1) {
1246   case JVM_CONSTANT_Class:
1247   {
1248     Klass* k1 = klass_at(index1, CHECK_false);
1249     Klass* k2 = cp2-&gt;klass_at(index2, CHECK_false);
1250     if (k1 == k2) {
1251       return true;
1252     }
1253   } break;
1254 
1255   case JVM_CONSTANT_ClassIndex:
1256   {
1257     int recur1 = klass_index_at(index1);
1258     int recur2 = cp2-&gt;klass_index_at(index2);
1259     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1260     if (match) {
1261       return true;
1262     }
1263   } break;
1264 
1265   case JVM_CONSTANT_Double:
1266   {
1267     jdouble d1 = double_at(index1);
1268     jdouble d2 = cp2-&gt;double_at(index2);
1269     if (d1 == d2) {
1270       return true;
1271     }
1272   } break;
1273 
1274   case JVM_CONSTANT_Fieldref:
1275   case JVM_CONSTANT_InterfaceMethodref:
1276   case JVM_CONSTANT_Methodref:
1277   {
1278     int recur1 = uncached_klass_ref_index_at(index1);
1279     int recur2 = cp2-&gt;uncached_klass_ref_index_at(index2);
1280     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1281     if (match) {
1282       recur1 = uncached_name_and_type_ref_index_at(index1);
1283       recur2 = cp2-&gt;uncached_name_and_type_ref_index_at(index2);
1284       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1285       if (match) {
1286         return true;
1287       }
1288     }
1289   } break;
1290 
1291   case JVM_CONSTANT_Float:
1292   {
1293     jfloat f1 = float_at(index1);
1294     jfloat f2 = cp2-&gt;float_at(index2);
1295     if (f1 == f2) {
1296       return true;
1297     }
1298   } break;
1299 
1300   case JVM_CONSTANT_Integer:
1301   {
1302     jint i1 = int_at(index1);
1303     jint i2 = cp2-&gt;int_at(index2);
1304     if (i1 == i2) {
1305       return true;
1306     }
1307   } break;
1308 
1309   case JVM_CONSTANT_Long:
1310   {
1311     jlong l1 = long_at(index1);
1312     jlong l2 = cp2-&gt;long_at(index2);
1313     if (l1 == l2) {
1314       return true;
1315     }
1316   } break;
1317 
1318   case JVM_CONSTANT_NameAndType:
1319   {
1320     int recur1 = name_ref_index_at(index1);
1321     int recur2 = cp2-&gt;name_ref_index_at(index2);
1322     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1323     if (match) {
1324       recur1 = signature_ref_index_at(index1);
1325       recur2 = cp2-&gt;signature_ref_index_at(index2);
1326       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1327       if (match) {
1328         return true;
1329       }
1330     }
1331   } break;
1332 
1333   case JVM_CONSTANT_StringIndex:
1334   {
1335     int recur1 = string_index_at(index1);
1336     int recur2 = cp2-&gt;string_index_at(index2);
1337     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1338     if (match) {
1339       return true;
1340     }
1341   } break;
1342 
1343   case JVM_CONSTANT_UnresolvedClass:
1344   {
1345     Symbol* k1 = klass_name_at(index1);
1346     Symbol* k2 = cp2-&gt;klass_name_at(index2);
1347     if (k1 == k2) {
1348       return true;
1349     }
1350   } break;
1351 
1352   case JVM_CONSTANT_MethodType:
1353   {
1354     int k1 = method_type_index_at(index1);
1355     int k2 = cp2-&gt;method_type_index_at(index2);
1356     bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1357     if (match) {
1358       return true;
1359     }
1360   } break;
1361 
1362   case JVM_CONSTANT_MethodHandle:
1363   {
1364     int k1 = method_handle_ref_kind_at(index1);
1365     int k2 = cp2-&gt;method_handle_ref_kind_at(index2);
1366     if (k1 == k2) {
1367       int i1 = method_handle_index_at(index1);
1368       int i2 = cp2-&gt;method_handle_index_at(index2);
1369       bool match = compare_entry_to(i1, cp2, i2, CHECK_false);
1370       if (match) {
1371         return true;
1372       }
1373     }
1374   } break;
1375 
1376   case JVM_CONSTANT_Dynamic:
1377   {
1378     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1379     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1380     int i1 = bootstrap_methods_attribute_index(index1);
1381     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1382     // separate statements and variables because CHECK_false is used
1383     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1384     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1385     return (match_entry &amp;&amp; match_operand);
1386   } break;
1387 
1388   case JVM_CONSTANT_InvokeDynamic:
1389   {
1390     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1391     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1392     int i1 = bootstrap_methods_attribute_index(index1);
1393     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1394     // separate statements and variables because CHECK_false is used
1395     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1396     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1397     return (match_entry &amp;&amp; match_operand);
1398   } break;
1399 
1400   case JVM_CONSTANT_String:
1401   {
1402     Symbol* s1 = unresolved_string_at(index1);
1403     Symbol* s2 = cp2-&gt;unresolved_string_at(index2);
1404     if (s1 == s2) {
1405       return true;
1406     }
1407   } break;
1408 
1409   case JVM_CONSTANT_Utf8:
1410   {
1411     Symbol* s1 = symbol_at(index1);
1412     Symbol* s2 = cp2-&gt;symbol_at(index2);
1413     if (s1 == s2) {
1414       return true;
1415     }
1416   } break;
1417 
1418   // Invalid is used as the tag for the second constant pool entry
1419   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1420   // not be seen by itself.
1421   case JVM_CONSTANT_Invalid: // fall through
1422 
1423   default:
1424     ShouldNotReachHere();
1425     break;
1426   }
1427 
1428   return false;
1429 } // end compare_entry_to()
1430 
1431 
1432 // Resize the operands array with delta_len and delta_size.
1433 // Used in RedefineClasses for CP merge.
1434 void ConstantPool::resize_operands(int delta_len, int delta_size, TRAPS) {
1435   int old_len  = operand_array_length(operands());
1436   int new_len  = old_len + delta_len;
1437   int min_len  = (delta_len &gt; 0) ? old_len : new_len;
1438 
1439   int old_size = operands()-&gt;length();
1440   int new_size = old_size + delta_size;
1441   int min_size = (delta_size &gt; 0) ? old_size : new_size;
1442 
1443   ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1444   Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, new_size, CHECK);
1445 
1446   // Set index in the resized array for existing elements only
1447   for (int idx = 0; idx &lt; min_len; idx++) {
1448     int offset = operand_offset_at(idx);                       // offset in original array
1449     operand_offset_at_put(new_ops, idx, offset + 2*delta_len); // offset in resized array
1450   }
1451   // Copy the bootstrap specifiers only
1452   Copy::conjoint_memory_atomic(operands()-&gt;adr_at(2*old_len),
1453                                new_ops-&gt;adr_at(2*new_len),
1454                                (min_size - 2*min_len) * sizeof(u2));
1455   // Explicitly deallocate old operands array.
1456   // Note, it is not needed for 7u backport.
1457   if ( operands() != NULL) { // the safety check
1458     MetadataFactory::free_array&lt;u2&gt;(loader_data, operands());
1459   }
1460   set_operands(new_ops);
1461 } // end resize_operands()
1462 
1463 
1464 // Extend the operands array with the length and size of the ext_cp operands.
1465 // Used in RedefineClasses for CP merge.
1466 void ConstantPool::extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS) {
1467   int delta_len = operand_array_length(ext_cp-&gt;operands());
1468   if (delta_len == 0) {
1469     return; // nothing to do
1470   }
1471   int delta_size = ext_cp-&gt;operands()-&gt;length();
1472 
1473   assert(delta_len  &gt; 0 &amp;&amp; delta_size &gt; 0, &quot;extended operands array must be bigger&quot;);
1474 
1475   if (operand_array_length(operands()) == 0) {
1476     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1477     Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, delta_size, CHECK);
1478     // The first element index defines the offset of second part
1479     operand_offset_at_put(new_ops, 0, 2*delta_len); // offset in new array
1480     set_operands(new_ops);
1481   } else {
1482     resize_operands(delta_len, delta_size, CHECK);
1483   }
1484 
1485 } // end extend_operands()
1486 
1487 
1488 // Shrink the operands array to a smaller array with new_len length.
1489 // Used in RedefineClasses for CP merge.
1490 void ConstantPool::shrink_operands(int new_len, TRAPS) {
1491   int old_len = operand_array_length(operands());
1492   if (new_len == old_len) {
1493     return; // nothing to do
1494   }
1495   assert(new_len &lt; old_len, &quot;shrunken operands array must be smaller&quot;);
1496 
1497   int free_base  = operand_next_offset_at(new_len - 1);
1498   int delta_len  = new_len - old_len;
1499   int delta_size = 2*delta_len + free_base - operands()-&gt;length();
1500 
1501   resize_operands(delta_len, delta_size, CHECK);
1502 
1503 } // end shrink_operands()
1504 
1505 
1506 void ConstantPool::copy_operands(const constantPoolHandle&amp; from_cp,
1507                                  const constantPoolHandle&amp; to_cp,
1508                                  TRAPS) {
1509 
1510   int from_oplen = operand_array_length(from_cp-&gt;operands());
1511   int old_oplen  = operand_array_length(to_cp-&gt;operands());
1512   if (from_oplen != 0) {
1513     ClassLoaderData* loader_data = to_cp-&gt;pool_holder()-&gt;class_loader_data();
1514     // append my operands to the target&#39;s operands array
1515     if (old_oplen == 0) {
1516       // Can&#39;t just reuse from_cp&#39;s operand list because of deallocation issues
1517       int len = from_cp-&gt;operands()-&gt;length();
1518       Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, len, CHECK);
1519       Copy::conjoint_memory_atomic(
1520           from_cp-&gt;operands()-&gt;adr_at(0), new_ops-&gt;adr_at(0), len * sizeof(u2));
1521       to_cp-&gt;set_operands(new_ops);
1522     } else {
1523       int old_len  = to_cp-&gt;operands()-&gt;length();
1524       int from_len = from_cp-&gt;operands()-&gt;length();
1525       int old_off  = old_oplen * sizeof(u2);
1526       int from_off = from_oplen * sizeof(u2);
1527       // Use the metaspace for the destination constant pool
1528       Array&lt;u2&gt;* new_operands = MetadataFactory::new_array&lt;u2&gt;(loader_data, old_len + from_len, CHECK);
1529       int fillp = 0, len = 0;
1530       // first part of dest
1531       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(0),
1532                                    new_operands-&gt;adr_at(fillp),
1533                                    (len = old_off) * sizeof(u2));
1534       fillp += len;
1535       // first part of src
1536       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(0),
1537                                    new_operands-&gt;adr_at(fillp),
1538                                    (len = from_off) * sizeof(u2));
1539       fillp += len;
1540       // second part of dest
1541       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(old_off),
1542                                    new_operands-&gt;adr_at(fillp),
1543                                    (len = old_len - old_off) * sizeof(u2));
1544       fillp += len;
1545       // second part of src
1546       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(from_off),
1547                                    new_operands-&gt;adr_at(fillp),
1548                                    (len = from_len - from_off) * sizeof(u2));
1549       fillp += len;
1550       assert(fillp == new_operands-&gt;length(), &quot;&quot;);
1551 
1552       // Adjust indexes in the first part of the copied operands array.
1553       for (int j = 0; j &lt; from_oplen; j++) {
1554         int offset = operand_offset_at(new_operands, old_oplen + j);
1555         assert(offset == operand_offset_at(from_cp-&gt;operands(), j), &quot;correct copy&quot;);
1556         offset += old_len;  // every new tuple is preceded by old_len extra u2&#39;s
1557         operand_offset_at_put(new_operands, old_oplen + j, offset);
1558       }
1559 
1560       // replace target operands array with combined array
1561       to_cp-&gt;set_operands(new_operands);
1562     }
1563   }
1564 } // end copy_operands()
1565 
1566 
1567 // Copy this constant pool&#39;s entries at start_i to end_i (inclusive)
1568 // to the constant pool to_cp&#39;s entries starting at to_i. A total of
1569 // (end_i - start_i) + 1 entries are copied.
1570 void ConstantPool::copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i,
1571        const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
1572 
1573 
1574   int dest_i = to_i;  // leave original alone for debug purposes
1575 
1576   for (int src_i = start_i; src_i &lt;= end_i; /* see loop bottom */ ) {
1577     copy_entry_to(from_cp, src_i, to_cp, dest_i, CHECK);
1578 
1579     switch (from_cp-&gt;tag_at(src_i).value()) {
1580     case JVM_CONSTANT_Double:
1581     case JVM_CONSTANT_Long:
1582       // double and long take two constant pool entries
1583       src_i += 2;
1584       dest_i += 2;
1585       break;
1586 
1587     default:
1588       // all others take one constant pool entry
1589       src_i++;
1590       dest_i++;
1591       break;
1592     }
1593   }
1594   copy_operands(from_cp, to_cp, CHECK);
1595 
1596 } // end copy_cp_to_impl()
1597 
1598 
1599 // Copy this constant pool&#39;s entry at from_i to the constant pool
1600 // to_cp&#39;s entry at to_i.
1601 void ConstantPool::copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i,
1602                                         const constantPoolHandle&amp; to_cp, int to_i,
1603                                         TRAPS) {
1604 
1605   int tag = from_cp-&gt;tag_at(from_i).value();
1606   switch (tag) {
1607   case JVM_CONSTANT_ClassIndex:
1608   {
1609     jint ki = from_cp-&gt;klass_index_at(from_i);
1610     to_cp-&gt;klass_index_at_put(to_i, ki);
1611   } break;
1612 
1613   case JVM_CONSTANT_Double:
1614   {
1615     jdouble d = from_cp-&gt;double_at(from_i);
1616     to_cp-&gt;double_at_put(to_i, d);
1617     // double takes two constant pool entries so init second entry&#39;s tag
1618     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1619   } break;
1620 
1621   case JVM_CONSTANT_Fieldref:
1622   {
1623     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1624     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1625     to_cp-&gt;field_at_put(to_i, class_index, name_and_type_index);
1626   } break;
1627 
1628   case JVM_CONSTANT_Float:
1629   {
1630     jfloat f = from_cp-&gt;float_at(from_i);
1631     to_cp-&gt;float_at_put(to_i, f);
1632   } break;
1633 
1634   case JVM_CONSTANT_Integer:
1635   {
1636     jint i = from_cp-&gt;int_at(from_i);
1637     to_cp-&gt;int_at_put(to_i, i);
1638   } break;
1639 
1640   case JVM_CONSTANT_InterfaceMethodref:
1641   {
1642     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1643     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1644     to_cp-&gt;interface_method_at_put(to_i, class_index, name_and_type_index);
1645   } break;
1646 
1647   case JVM_CONSTANT_Long:
1648   {
1649     jlong l = from_cp-&gt;long_at(from_i);
1650     to_cp-&gt;long_at_put(to_i, l);
1651     // long takes two constant pool entries so init second entry&#39;s tag
1652     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1653   } break;
1654 
1655   case JVM_CONSTANT_Methodref:
1656   {
1657     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1658     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1659     to_cp-&gt;method_at_put(to_i, class_index, name_and_type_index);
1660   } break;
1661 
1662   case JVM_CONSTANT_NameAndType:
1663   {
1664     int name_ref_index = from_cp-&gt;name_ref_index_at(from_i);
1665     int signature_ref_index = from_cp-&gt;signature_ref_index_at(from_i);
1666     to_cp-&gt;name_and_type_at_put(to_i, name_ref_index, signature_ref_index);
1667   } break;
1668 
1669   case JVM_CONSTANT_StringIndex:
1670   {
1671     jint si = from_cp-&gt;string_index_at(from_i);
1672     to_cp-&gt;string_index_at_put(to_i, si);
1673   } break;
1674 
1675   case JVM_CONSTANT_Class:
1676   case JVM_CONSTANT_UnresolvedClass:
1677   case JVM_CONSTANT_UnresolvedClassInError:
1678   {
1679     // Revert to JVM_CONSTANT_ClassIndex
1680     int name_index = from_cp-&gt;klass_slot_at(from_i).name_index();
1681     assert(from_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
1682     to_cp-&gt;klass_index_at_put(to_i, name_index);
1683   } break;
1684 
1685   case JVM_CONSTANT_String:
1686   {
1687     Symbol* s = from_cp-&gt;unresolved_string_at(from_i);
1688     to_cp-&gt;unresolved_string_at_put(to_i, s);
1689   } break;
1690 
1691   case JVM_CONSTANT_Utf8:
1692   {
1693     Symbol* s = from_cp-&gt;symbol_at(from_i);
1694     // Need to increase refcount, the old one will be thrown away and deferenced
1695     s-&gt;increment_refcount();
1696     to_cp-&gt;symbol_at_put(to_i, s);
1697   } break;
1698 
1699   case JVM_CONSTANT_MethodType:
1700   case JVM_CONSTANT_MethodTypeInError:
1701   {
1702     jint k = from_cp-&gt;method_type_index_at(from_i);
1703     to_cp-&gt;method_type_index_at_put(to_i, k);
1704   } break;
1705 
1706   case JVM_CONSTANT_MethodHandle:
1707   case JVM_CONSTANT_MethodHandleInError:
1708   {
1709     int k1 = from_cp-&gt;method_handle_ref_kind_at(from_i);
1710     int k2 = from_cp-&gt;method_handle_index_at(from_i);
1711     to_cp-&gt;method_handle_index_at_put(to_i, k1, k2);
1712   } break;
1713 
1714   case JVM_CONSTANT_Dynamic:
1715   case JVM_CONSTANT_DynamicInError:
1716   {
1717     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1718     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1719     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1720     to_cp-&gt;dynamic_constant_at_put(to_i, k1, k2);
1721   } break;
1722 
1723   case JVM_CONSTANT_InvokeDynamic:
1724   {
1725     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1726     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1727     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1728     to_cp-&gt;invoke_dynamic_at_put(to_i, k1, k2);
1729   } break;
1730 
1731   // Invalid is used as the tag for the second constant pool entry
1732   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1733   // not be seen by itself.
1734   case JVM_CONSTANT_Invalid: // fall through
1735 
1736   default:
1737   {
1738     ShouldNotReachHere();
1739   } break;
1740   }
1741 } // end copy_entry_to()
1742 
1743 // Search constant pool search_cp for an entry that matches this
1744 // constant pool&#39;s entry at pattern_i. Returns the index of a
1745 // matching entry or zero (0) if there is no matching entry.
1746 int ConstantPool::find_matching_entry(int pattern_i,
1747       const constantPoolHandle&amp; search_cp, TRAPS) {
1748 
1749   // index zero (0) is not used
1750   for (int i = 1; i &lt; search_cp-&gt;length(); i++) {
1751     bool found = compare_entry_to(pattern_i, search_cp, i, CHECK_0);
1752     if (found) {
1753       return i;
1754     }
1755   }
1756 
1757   return 0;  // entry not found; return unused index zero (0)
1758 } // end find_matching_entry()
1759 
1760 
1761 // Compare this constant pool&#39;s bootstrap specifier at idx1 to the constant pool
1762 // cp2&#39;s bootstrap specifier at idx2.
1763 bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle&amp; cp2, int idx2, TRAPS) {
1764   int k1 = operand_bootstrap_method_ref_index_at(idx1);
1765   int k2 = cp2-&gt;operand_bootstrap_method_ref_index_at(idx2);
1766   bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1767 
1768   if (!match) {
1769     return false;
1770   }
1771   int argc = operand_argument_count_at(idx1);
1772   if (argc == cp2-&gt;operand_argument_count_at(idx2)) {
1773     for (int j = 0; j &lt; argc; j++) {
1774       k1 = operand_argument_index_at(idx1, j);
1775       k2 = cp2-&gt;operand_argument_index_at(idx2, j);
1776       match = compare_entry_to(k1, cp2, k2, CHECK_false);
1777       if (!match) {
1778         return false;
1779       }
1780     }
1781     return true;           // got through loop; all elements equal
1782   }
1783   return false;
1784 } // end compare_operand_to()
1785 
1786 // Search constant pool search_cp for a bootstrap specifier that matches
1787 // this constant pool&#39;s bootstrap specifier data at pattern_i index.
1788 // Return the index of a matching bootstrap attribute record or (-1) if there is no match.
1789 int ConstantPool::find_matching_operand(int pattern_i,
1790                     const constantPoolHandle&amp; search_cp, int search_len, TRAPS) {
1791   for (int i = 0; i &lt; search_len; i++) {
1792     bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));
1793     if (found) {
1794       return i;
1795     }
1796   }
1797   return -1;  // bootstrap specifier data not found; return unused index (-1)
1798 } // end find_matching_operand()
1799 
1800 
1801 #ifndef PRODUCT
1802 
1803 const char* ConstantPool::printable_name_at(int which) {
1804 
1805   constantTag tag = tag_at(which);
1806 
1807   if (tag.is_string()) {
1808     return string_at_noresolve(which);
1809   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
1810     return klass_name_at(which)-&gt;as_C_string();
1811   } else if (tag.is_symbol()) {
1812     return symbol_at(which)-&gt;as_C_string();
1813   }
1814   return &quot;&quot;;
1815 }
1816 
1817 #endif // PRODUCT
1818 
1819 
1820 // JVMTI GetConstantPool support
1821 
1822 // For debugging of constant pool
1823 const bool debug_cpool = false;
1824 
1825 #define DBG(code) do { if (debug_cpool) { (code); } } while(0)
1826 
1827 static void print_cpool_bytes(jint cnt, u1 *bytes) {
1828   const char* WARN_MSG = &quot;Must not be such entry!&quot;;
1829   jint size = 0;
1830   u2   idx1, idx2;
1831 
1832   for (jint idx = 1; idx &lt; cnt; idx++) {
1833     jint ent_size = 0;
1834     u1   tag  = *bytes++;
1835     size++;                       // count tag
1836 
1837     printf(&quot;const #%03d, tag: %02d &quot;, idx, tag);
1838     switch(tag) {
1839       case JVM_CONSTANT_Invalid: {
1840         printf(&quot;Invalid&quot;);
1841         break;
1842       }
1843       case JVM_CONSTANT_Unicode: {
1844         printf(&quot;Unicode      %s&quot;, WARN_MSG);
1845         break;
1846       }
1847       case JVM_CONSTANT_Utf8: {
1848         u2 len = Bytes::get_Java_u2(bytes);
1849         char str[128];
1850         if (len &gt; 127) {
1851            len = 127;
1852         }
1853         strncpy(str, (char *) (bytes+2), len);
1854         str[len] = &#39;\0&#39;;
1855         printf(&quot;Utf8          \&quot;%s\&quot;&quot;, str);
1856         ent_size = 2 + len;
1857         break;
1858       }
1859       case JVM_CONSTANT_Integer: {
1860         u4 val = Bytes::get_Java_u4(bytes);
1861         printf(&quot;int          %d&quot;, *(int *) &amp;val);
1862         ent_size = 4;
1863         break;
1864       }
1865       case JVM_CONSTANT_Float: {
1866         u4 val = Bytes::get_Java_u4(bytes);
1867         printf(&quot;float        %5.3ff&quot;, *(float *) &amp;val);
1868         ent_size = 4;
1869         break;
1870       }
1871       case JVM_CONSTANT_Long: {
1872         u8 val = Bytes::get_Java_u8(bytes);
1873         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1874         ent_size = 8;
1875         idx++; // Long takes two cpool slots
1876         break;
1877       }
1878       case JVM_CONSTANT_Double: {
1879         u8 val = Bytes::get_Java_u8(bytes);
1880         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1881         ent_size = 8;
1882         idx++; // Double takes two cpool slots
1883         break;
1884       }
1885       case JVM_CONSTANT_Class: {
1886         idx1 = Bytes::get_Java_u2(bytes);
1887         printf(&quot;class        #%03d&quot;, idx1);
1888         ent_size = 2;
1889         break;
1890       }
1891       case (JVM_CONSTANT_Class | JVM_CONSTANT_QDescBit): {
1892         idx1 = Bytes::get_Java_u2(bytes);
1893         printf(&quot;qclass        #%03d&quot;, idx1);
1894         ent_size = 2;
1895         break;
1896       }
1897       case JVM_CONSTANT_String: {
1898         idx1 = Bytes::get_Java_u2(bytes);
1899         printf(&quot;String       #%03d&quot;, idx1);
1900         ent_size = 2;
1901         break;
1902       }
1903       case JVM_CONSTANT_Fieldref: {
1904         idx1 = Bytes::get_Java_u2(bytes);
1905         idx2 = Bytes::get_Java_u2(bytes+2);
1906         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1907         ent_size = 4;
1908         break;
1909       }
1910       case JVM_CONSTANT_Methodref: {
1911         idx1 = Bytes::get_Java_u2(bytes);
1912         idx2 = Bytes::get_Java_u2(bytes+2);
1913         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1914         ent_size = 4;
1915         break;
1916       }
1917       case JVM_CONSTANT_InterfaceMethodref: {
1918         idx1 = Bytes::get_Java_u2(bytes);
1919         idx2 = Bytes::get_Java_u2(bytes+2);
1920         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1921         ent_size = 4;
1922         break;
1923       }
1924       case JVM_CONSTANT_NameAndType: {
1925         idx1 = Bytes::get_Java_u2(bytes);
1926         idx2 = Bytes::get_Java_u2(bytes+2);
1927         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1928         ent_size = 4;
1929         break;
1930       }
1931       case JVM_CONSTANT_ClassIndex: {
1932         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1933         break;
1934       }
1935       case JVM_CONSTANT_UnresolvedClass: {
1936         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1937         break;
1938       }
1939       case (JVM_CONSTANT_UnresolvedClass | JVM_CONSTANT_QDescBit): {
1940         printf(&quot;UnresolvedQClass: %s&quot;, WARN_MSG);
1941         break;
1942       }
1943       case JVM_CONSTANT_UnresolvedClassInError: {
1944         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1945         break;
1946       }
1947       case JVM_CONSTANT_StringIndex: {
1948         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1949         break;
1950       }
1951     }
1952     printf(&quot;;\n&quot;);
1953     bytes += ent_size;
1954     size  += ent_size;
1955   }
1956   printf(&quot;Cpool size: %d\n&quot;, size);
1957   fflush(0);
1958   return;
1959 } /* end print_cpool_bytes */
1960 
1961 
1962 // Returns size of constant pool entry.
1963 jint ConstantPool::cpool_entry_size(jint idx) {
1964   switch(tag_at(idx).value()) {
1965     case JVM_CONSTANT_Invalid:
1966     case JVM_CONSTANT_Unicode:
1967       return 1;
1968 
1969     case JVM_CONSTANT_Utf8:
1970       return 3 + symbol_at(idx)-&gt;utf8_length();
1971 
1972     case JVM_CONSTANT_Class:
1973     case JVM_CONSTANT_String:
1974     case JVM_CONSTANT_ClassIndex:
1975     case JVM_CONSTANT_UnresolvedClass:
1976     case JVM_CONSTANT_UnresolvedClassInError:
1977     case JVM_CONSTANT_StringIndex:
1978     case JVM_CONSTANT_MethodType:
1979     case JVM_CONSTANT_MethodTypeInError:
1980       return 3;
1981 
1982     case JVM_CONSTANT_MethodHandle:
1983     case JVM_CONSTANT_MethodHandleInError:
1984       return 4; //tag, ref_kind, ref_index
1985 
1986     case JVM_CONSTANT_Integer:
1987     case JVM_CONSTANT_Float:
1988     case JVM_CONSTANT_Fieldref:
1989     case JVM_CONSTANT_Methodref:
1990     case JVM_CONSTANT_InterfaceMethodref:
1991     case JVM_CONSTANT_NameAndType:
1992       return 5;
1993 
1994     case JVM_CONSTANT_Dynamic:
1995     case JVM_CONSTANT_DynamicInError:
1996     case JVM_CONSTANT_InvokeDynamic:
1997       // u1 tag, u2 bsm, u2 nt
1998       return 5;
1999 
2000     case JVM_CONSTANT_Long:
2001     case JVM_CONSTANT_Double:
2002       return 9;
2003   }
2004   assert(false, &quot;cpool_entry_size: Invalid constant pool entry tag&quot;);
2005   return 1;
2006 } /* end cpool_entry_size */
2007 
2008 
2009 // SymbolHashMap is used to find a constant pool index from a string.
2010 // This function fills in SymbolHashMaps, one for utf8s and one for
2011 // class names, returns size of the cpool raw bytes.
2012 jint ConstantPool::hash_entries_to(SymbolHashMap *symmap,
2013                                           SymbolHashMap *classmap) {
2014   jint size = 0;
2015 
2016   for (u2 idx = 1; idx &lt; length(); idx++) {
2017     u2 tag = tag_at(idx).value();
2018     size += cpool_entry_size(idx);
2019 
2020     switch(tag) {
2021       case JVM_CONSTANT_Utf8: {
2022         Symbol* sym = symbol_at(idx);
2023         symmap-&gt;add_entry(sym, idx);
2024         DBG(printf(&quot;adding symbol entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
2025         break;
2026       }
2027       case JVM_CONSTANT_Class:
2028       case JVM_CONSTANT_UnresolvedClass:
2029       case JVM_CONSTANT_UnresolvedClassInError: {
2030         Symbol* sym = klass_name_at(idx);
2031         classmap-&gt;add_entry(sym, idx);
2032         DBG(printf(&quot;adding class entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
2033         break;
2034       }
2035       case JVM_CONSTANT_Long:
2036       case JVM_CONSTANT_Double: {
2037         idx++; // Both Long and Double take two cpool slots
2038         break;
2039       }
2040     }
2041   }
2042   return size;
2043 } /* end hash_utf8_entries_to */
2044 
2045 
2046 // Copy cpool bytes.
2047 // Returns:
2048 //    0, in case of OutOfMemoryError
2049 //   -1, in case of internal error
2050 //  &gt; 0, count of the raw cpool bytes that have been copied
2051 int ConstantPool::copy_cpool_bytes(int cpool_size,
2052                                           SymbolHashMap* tbl,
2053                                           unsigned char *bytes) {
2054   u2   idx1, idx2;
2055   jint size  = 0;
2056   jint cnt   = length();
2057   unsigned char *start_bytes = bytes;
2058 
2059   for (jint idx = 1; idx &lt; cnt; idx++) {
2060     u1   tag      = tag_at(idx).value();
2061     jint ent_size = cpool_entry_size(idx);
2062 
2063     assert(size + ent_size &lt;= cpool_size, &quot;Size mismatch&quot;);
2064 
2065     *bytes = tag;
2066     DBG(printf(&quot;#%03hd tag=%03hd, &quot;, (short)idx, (short)tag));
2067     switch(tag) {
2068       case JVM_CONSTANT_Invalid: {
2069         DBG(printf(&quot;JVM_CONSTANT_Invalid&quot;));
2070         break;
2071       }
2072       case JVM_CONSTANT_Unicode: {
2073         assert(false, &quot;Wrong constant pool tag: JVM_CONSTANT_Unicode&quot;);
2074         DBG(printf(&quot;JVM_CONSTANT_Unicode&quot;));
2075         break;
2076       }
2077       case JVM_CONSTANT_Utf8: {
2078         Symbol* sym = symbol_at(idx);
2079         char*     str = sym-&gt;as_utf8();
2080         // Warning! It&#39;s crashing on x86 with len = sym-&gt;utf8_length()
2081         int       len = (int) strlen(str);
2082         Bytes::put_Java_u2((address) (bytes+1), (u2) len);
2083         for (int i = 0; i &lt; len; i++) {
2084             bytes[3+i] = (u1) str[i];
2085         }
2086         DBG(printf(&quot;JVM_CONSTANT_Utf8: %s &quot;, str));
2087         break;
2088       }
2089       case JVM_CONSTANT_Integer: {
2090         jint val = int_at(idx);
2091         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2092         break;
2093       }
2094       case JVM_CONSTANT_Float: {
2095         jfloat val = float_at(idx);
2096         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2097         break;
2098       }
2099       case JVM_CONSTANT_Long: {
2100         jlong val = long_at(idx);
2101         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2102         idx++;             // Long takes two cpool slots
2103         break;
2104       }
2105       case JVM_CONSTANT_Double: {
2106         jdouble val = double_at(idx);
2107         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2108         idx++;             // Double takes two cpool slots
2109         break;
2110       }
2111       case JVM_CONSTANT_Class:
2112       case JVM_CONSTANT_UnresolvedClass:
2113       case JVM_CONSTANT_UnresolvedClassInError: {
2114         assert(!tag_at(idx).is_Qdescriptor_klass(), &quot;Failed to encode QDesc&quot;);
2115         *bytes = JVM_CONSTANT_Class;
2116         Symbol* sym = klass_name_at(idx);
2117         idx1 = tbl-&gt;symbol_to_value(sym);
2118         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2119         Bytes::put_Java_u2((address) (bytes+1), idx1);
2120         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2121         break;
2122       }
2123       case JVM_CONSTANT_String: {
2124         *bytes = JVM_CONSTANT_String;
2125         Symbol* sym = unresolved_string_at(idx);
2126         idx1 = tbl-&gt;symbol_to_value(sym);
2127         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2128         Bytes::put_Java_u2((address) (bytes+1), idx1);
2129         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2130         break;
2131       }
2132       case JVM_CONSTANT_Fieldref:
2133       case JVM_CONSTANT_Methodref:
2134       case JVM_CONSTANT_InterfaceMethodref: {
2135         idx1 = uncached_klass_ref_index_at(idx);
2136         idx2 = uncached_name_and_type_ref_index_at(idx);
2137         Bytes::put_Java_u2((address) (bytes+1), idx1);
2138         Bytes::put_Java_u2((address) (bytes+3), idx2);
2139         DBG(printf(&quot;JVM_CONSTANT_Methodref: %hd %hd&quot;, idx1, idx2));
2140         break;
2141       }
2142       case JVM_CONSTANT_NameAndType: {
2143         idx1 = name_ref_index_at(idx);
2144         idx2 = signature_ref_index_at(idx);
2145         Bytes::put_Java_u2((address) (bytes+1), idx1);
2146         Bytes::put_Java_u2((address) (bytes+3), idx2);
2147         DBG(printf(&quot;JVM_CONSTANT_NameAndType: %hd %hd&quot;, idx1, idx2));
2148         break;
2149       }
2150       case JVM_CONSTANT_ClassIndex: {
2151         *bytes = JVM_CONSTANT_Class;
2152         idx1 = klass_index_at(idx);
2153         Bytes::put_Java_u2((address) (bytes+1), idx1);
2154         DBG(printf(&quot;JVM_CONSTANT_ClassIndex: %hd&quot;, idx1));
2155         break;
2156       }
2157       case JVM_CONSTANT_StringIndex: {
2158         *bytes = JVM_CONSTANT_String;
2159         idx1 = string_index_at(idx);
2160         Bytes::put_Java_u2((address) (bytes+1), idx1);
2161         DBG(printf(&quot;JVM_CONSTANT_StringIndex: %hd&quot;, idx1));
2162         break;
2163       }
2164       case JVM_CONSTANT_MethodHandle:
2165       case JVM_CONSTANT_MethodHandleInError: {
2166         *bytes = JVM_CONSTANT_MethodHandle;
2167         int kind = method_handle_ref_kind_at(idx);
2168         idx1 = method_handle_index_at(idx);
2169         *(bytes+1) = (unsigned char) kind;
2170         Bytes::put_Java_u2((address) (bytes+2), idx1);
2171         DBG(printf(&quot;JVM_CONSTANT_MethodHandle: %d %hd&quot;, kind, idx1));
2172         break;
2173       }
2174       case JVM_CONSTANT_MethodType:
2175       case JVM_CONSTANT_MethodTypeInError: {
2176         *bytes = JVM_CONSTANT_MethodType;
2177         idx1 = method_type_index_at(idx);
2178         Bytes::put_Java_u2((address) (bytes+1), idx1);
2179         DBG(printf(&quot;JVM_CONSTANT_MethodType: %hd&quot;, idx1));
2180         break;
2181       }
2182       case JVM_CONSTANT_Dynamic:
2183       case JVM_CONSTANT_DynamicInError: {
2184         *bytes = tag;
2185         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2186         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2187         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2188         Bytes::put_Java_u2((address) (bytes+1), idx1);
2189         Bytes::put_Java_u2((address) (bytes+3), idx2);
2190         DBG(printf(&quot;JVM_CONSTANT_Dynamic: %hd %hd&quot;, idx1, idx2));
2191         break;
2192       }
2193       case JVM_CONSTANT_InvokeDynamic: {
2194         *bytes = tag;
2195         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2196         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2197         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2198         Bytes::put_Java_u2((address) (bytes+1), idx1);
2199         Bytes::put_Java_u2((address) (bytes+3), idx2);
2200         DBG(printf(&quot;JVM_CONSTANT_InvokeDynamic: %hd %hd&quot;, idx1, idx2));
2201         break;
2202       }
2203     }
2204     DBG(printf(&quot;\n&quot;));
2205     bytes += ent_size;
2206     size  += ent_size;
2207   }
2208   assert(size == cpool_size, &quot;Size mismatch&quot;);
2209 
2210   // Keep temorarily for debugging until it&#39;s stable.
2211   DBG(print_cpool_bytes(cnt, start_bytes));
2212   return (int)(bytes - start_bytes);
2213 } /* end copy_cpool_bytes */
2214 
2215 #undef DBG
2216 
2217 
2218 void ConstantPool::set_on_stack(const bool value) {
2219   if (value) {
2220     // Only record if it&#39;s not already set.
2221     if (!on_stack()) {
2222       assert(!is_shared(), &quot;should always be set for shared constant pools&quot;);
2223       _flags |= _on_stack;
2224       MetadataOnStackMark::record(this);
2225     }
2226   } else {
2227     // Clearing is done single-threadedly.
2228     if (!is_shared()) {
2229       _flags &amp;= ~_on_stack;
2230     }
2231   }
2232 }
2233 
2234 // JSR 292 support for patching constant pool oops after the class is linked and
2235 // the oop array for resolved references are created.
2236 // We can&#39;t do this during classfile parsing, which is how the other indexes are
2237 // patched.  The other patches are applied early for some error checking
2238 // so only defer the pseudo_strings.
2239 void ConstantPool::patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches) {
2240   for (int index = 1; index &lt; cp_patches-&gt;length(); index++) { // Index 0 is unused
2241     Handle patch = cp_patches-&gt;at(index);
2242     if (patch.not_null()) {
2243       assert (tag_at(index).is_string(), &quot;should only be string left&quot;);
2244       // Patching a string means pre-resolving it.
2245       // The spelling in the constant pool is ignored.
2246       // The constant reference may be any object whatever.
2247       // If it is not a real interned string, the constant is referred
2248       // to as a &quot;pseudo-string&quot;, and must be presented to the CP
2249       // explicitly, because it may require scavenging.
2250       int obj_index = cp_to_object_index(index);
2251       pseudo_string_at_put(index, obj_index, patch());
2252      DEBUG_ONLY(cp_patches-&gt;at_put(index, Handle());)
2253     }
2254   }
2255 #ifdef ASSERT
2256   // Ensure that all the patches have been used.
2257   for (int index = 0; index &lt; cp_patches-&gt;length(); index++) {
2258     assert(cp_patches-&gt;at(index).is_null(),
2259            &quot;Unused constant pool patch at %d in class file %s&quot;,
2260            index,
2261            pool_holder()-&gt;external_name());
2262   }
2263 #endif // ASSERT
2264 }
2265 
2266 // Printing
2267 
2268 void ConstantPool::print_on(outputStream* st) const {
2269   assert(is_constantPool(), &quot;must be constantPool&quot;);
2270   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2271   if (flags() != 0) {
2272     st-&gt;print(&quot; - flags: 0x%x&quot;, flags());
2273     if (has_preresolution()) st-&gt;print(&quot; has_preresolution&quot;);
2274     if (on_stack()) st-&gt;print(&quot; on_stack&quot;);
2275     st-&gt;cr();
2276   }
2277   if (pool_holder() != NULL) {
2278     st-&gt;print_cr(&quot; - holder: &quot; INTPTR_FORMAT, p2i(pool_holder()));
2279   }
2280   st-&gt;print_cr(&quot; - cache: &quot; INTPTR_FORMAT, p2i(cache()));
2281   st-&gt;print_cr(&quot; - resolved_references: &quot; INTPTR_FORMAT, p2i(resolved_references()));
2282   st-&gt;print_cr(&quot; - reference_map: &quot; INTPTR_FORMAT, p2i(reference_map()));
2283   st-&gt;print_cr(&quot; - resolved_klasses: &quot; INTPTR_FORMAT, p2i(resolved_klasses()));
2284 
2285   for (int index = 1; index &lt; length(); index++) {      // Index 0 is unused
2286     ((ConstantPool*)this)-&gt;print_entry_on(index, st);
2287     switch (tag_at(index).value()) {
2288       case JVM_CONSTANT_Long :
2289       case JVM_CONSTANT_Double :
2290         index++;   // Skip entry following eigth-byte constant
2291     }
2292 
2293   }
2294   st-&gt;cr();
2295 }
2296 
2297 // Print one constant pool entry
2298 void ConstantPool::print_entry_on(const int index, outputStream* st) {
2299   EXCEPTION_MARK;
2300   st-&gt;print(&quot; - %3d : &quot;, index);
2301   tag_at(index).print_on(st);
2302   st-&gt;print(&quot; : &quot;);
2303   switch (tag_at(index).value()) {
2304     case JVM_CONSTANT_Class :
2305       { Klass* k = klass_at(index, CATCH);
2306         guarantee(k != NULL, &quot;need klass&quot;);
2307         k-&gt;print_value_on(st);
2308         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(k));
2309       }
2310       break;
2311     case JVM_CONSTANT_Fieldref :
2312     case JVM_CONSTANT_Methodref :
2313     case JVM_CONSTANT_InterfaceMethodref :
2314       st-&gt;print(&quot;klass_index=%d&quot;, uncached_klass_ref_index_at(index));
2315       st-&gt;print(&quot; name_and_type_index=%d&quot;, uncached_name_and_type_ref_index_at(index));
2316       break;
2317     case JVM_CONSTANT_String :
2318       if (is_pseudo_string_at(index)) {
2319         oop anObj = pseudo_string_at(index);
2320         anObj-&gt;print_value_on(st);
2321         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(anObj));
2322       } else {
2323         unresolved_string_at(index)-&gt;print_value_on(st);
2324       }
2325       break;
2326     case JVM_CONSTANT_Integer :
2327       st-&gt;print(&quot;%d&quot;, int_at(index));
2328       break;
2329     case JVM_CONSTANT_Float :
2330       st-&gt;print(&quot;%f&quot;, float_at(index));
2331       break;
2332     case JVM_CONSTANT_Long :
2333       st-&gt;print_jlong(long_at(index));
2334       break;
2335     case JVM_CONSTANT_Double :
2336       st-&gt;print(&quot;%lf&quot;, double_at(index));
2337       break;
2338     case JVM_CONSTANT_NameAndType :
2339       st-&gt;print(&quot;name_index=%d&quot;, name_ref_index_at(index));
2340       st-&gt;print(&quot; signature_index=%d&quot;, signature_ref_index_at(index));
2341       break;
2342     case JVM_CONSTANT_Utf8 :
2343       symbol_at(index)-&gt;print_value_on(st);
2344       break;
2345     case JVM_CONSTANT_ClassIndex: {
2346         int name_index = *int_at_addr(index);
2347         st-&gt;print(&quot;klass_index=%d &quot;, name_index);
2348         symbol_at(name_index)-&gt;print_value_on(st);
2349       }
2350       break;
2351     case JVM_CONSTANT_UnresolvedClass :               // fall-through
2352     case JVM_CONSTANT_UnresolvedClassInError: {
2353         CPKlassSlot kslot = klass_slot_at(index);
2354         int resolved_klass_index = kslot.resolved_klass_index();
2355         int name_index = kslot.name_index();
2356         assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
2357 
2358         Klass* klass = resolved_klasses()-&gt;at(resolved_klass_index);
2359         if (klass != NULL) {
2360           klass-&gt;print_value_on(st);
2361         } else {
2362           symbol_at(name_index)-&gt;print_value_on(st);
2363         }
2364       }
2365       break;
2366     case JVM_CONSTANT_MethodHandle :
2367     case JVM_CONSTANT_MethodHandleInError :
2368       st-&gt;print(&quot;ref_kind=%d&quot;, method_handle_ref_kind_at(index));
2369       st-&gt;print(&quot; ref_index=%d&quot;, method_handle_index_at(index));
2370       break;
2371     case JVM_CONSTANT_MethodType :
2372     case JVM_CONSTANT_MethodTypeInError :
2373       st-&gt;print(&quot;signature_index=%d&quot;, method_type_index_at(index));
2374       break;
2375     case JVM_CONSTANT_Dynamic :
2376     case JVM_CONSTANT_DynamicInError :
2377       {
2378         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2379         st-&gt;print(&quot; type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2380         int argc = bootstrap_argument_count_at(index);
2381         if (argc &gt; 0) {
2382           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2383             int arg = bootstrap_argument_index_at(index, arg_i);
2384             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2385           }
2386           st-&gt;print(&quot;}&quot;);
2387         }
2388       }
2389       break;
2390     case JVM_CONSTANT_InvokeDynamic :
2391       {
2392         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2393         st-&gt;print(&quot; name_and_type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2394         int argc = bootstrap_argument_count_at(index);
2395         if (argc &gt; 0) {
2396           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2397             int arg = bootstrap_argument_index_at(index, arg_i);
2398             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2399           }
2400           st-&gt;print(&quot;}&quot;);
2401         }
2402       }
2403       break;
2404     default:
2405       ShouldNotReachHere();
2406       break;
2407   }
2408   st-&gt;cr();
2409 }
2410 
2411 void ConstantPool::print_value_on(outputStream* st) const {
2412   assert(is_constantPool(), &quot;must be constantPool&quot;);
2413   st-&gt;print(&quot;constant pool [%d]&quot;, length());
2414   if (has_preresolution()) st-&gt;print(&quot;/preresolution&quot;);
2415   if (operands() != NULL)  st-&gt;print(&quot;/operands[%d]&quot;, operands()-&gt;length());
2416   print_address_on(st);
2417   if (pool_holder() != NULL) {
2418     st-&gt;print(&quot; for &quot;);
2419     pool_holder()-&gt;print_value_on(st);
2420     bool extra = (pool_holder()-&gt;constants() != this);
2421     if (extra)  st-&gt;print(&quot; (extra)&quot;);
2422   }
2423   if (cache() != NULL) {
2424     st-&gt;print(&quot; cache=&quot; PTR_FORMAT, p2i(cache()));
2425   }
2426 }
2427 
2428 // Verification
2429 
2430 void ConstantPool::verify_on(outputStream* st) {
2431   guarantee(is_constantPool(), &quot;object must be constant pool&quot;);
2432   for (int i = 0; i&lt; length();  i++) {
2433     constantTag tag = tag_at(i);
2434     if (tag.is_klass() || tag.is_unresolved_klass()) {
2435       guarantee(klass_name_at(i)-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2436     } else if (tag.is_symbol()) {
2437       CPSlot entry = slot_at(i);
2438       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2439     } else if (tag.is_string()) {
2440       CPSlot entry = slot_at(i);
2441       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2442     }
2443   }
2444   if (pool_holder() != NULL) {
2445     // Note: pool_holder() can be NULL in temporary constant pools
2446     // used during constant pool merging
2447     guarantee(pool_holder()-&gt;is_klass(),    &quot;should be klass&quot;);
2448   }
2449 }
2450 
2451 
2452 SymbolHashMap::~SymbolHashMap() {
2453   SymbolHashMapEntry* next;
2454   for (int i = 0; i &lt; _table_size; i++) {
2455     for (SymbolHashMapEntry* cur = bucket(i); cur != NULL; cur = next) {
2456       next = cur-&gt;next();
2457       delete(cur);
2458     }
2459   }
2460   FREE_C_HEAP_ARRAY(SymbolHashMapBucket, _buckets);
2461 }
2462 
2463 void SymbolHashMap::add_entry(Symbol* sym, u2 value) {
2464   char *str = sym-&gt;as_utf8();
2465   unsigned int hash = compute_hash(str, sym-&gt;utf8_length());
2466   unsigned int index = hash % table_size();
2467 
2468   // check if already in map
2469   // we prefer the first entry since it is more likely to be what was used in
2470   // the class file
2471   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2472     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2473     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2474         return;  // already there
2475     }
2476   }
2477 
2478   SymbolHashMapEntry* entry = new SymbolHashMapEntry(hash, sym, value);
2479   entry-&gt;set_next(bucket(index));
2480   _buckets[index].set_entry(entry);
2481   assert(entry-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2482 }
2483 
2484 SymbolHashMapEntry* SymbolHashMap::find_entry(Symbol* sym) {
2485   assert(sym != NULL, &quot;SymbolHashMap::find_entry - symbol is NULL&quot;);
2486   char *str = sym-&gt;as_utf8();
2487   int   len = sym-&gt;utf8_length();
2488   unsigned int hash = SymbolHashMap::compute_hash(str, len);
2489   unsigned int index = hash % table_size();
2490   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2491     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2492     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2493       return en;
2494     }
2495   }
2496   return NULL;
2497 }
2498 
2499 void SymbolHashMap::initialize_table(int table_size) {
2500   _table_size = table_size;
2501   _buckets = NEW_C_HEAP_ARRAY(SymbolHashMapBucket, table_size, mtSymbol);
2502   for (int index = 0; index &lt; table_size; index++) {
2503     _buckets[index].clear();
2504   }
2505 }
    </pre>
  </body>
</html>
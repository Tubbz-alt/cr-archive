<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 695   }
 696 
 697  public:
 698   // Used by fast lock support
 699   virtual bool is_lock_owned(address adr) const;
 700 
 701   // Check if address is within the given range of this thread&#39;s
 702   // stack:  stack_base() &gt; adr &gt;= limit
 703   bool is_in_stack_range_incl(address adr, address limit) const {
 704     return is_in_stack_range(adr, limit, true);
 705   }
 706 
 707   // Check if address is within the given range of this thread&#39;s
 708   // stack:  stack_base() &gt; adr &gt; limit
 709   bool is_in_stack_range_excl(address adr, address limit) const {
 710     return is_in_stack_range(adr, limit, false);
 711   }
 712 
 713   // Check if address is in the stack mapped to this thread. Used mainly in
 714   // error reporting (so has to include guard zone) and frame printing.
<span class="line-modified"> 715   bool is_in_full_stack(address adr) const {</span>

 716     return is_in_stack_range_incl(adr, stack_end());
 717   }
 718 







 719   // Check if address is in the live stack of this thread (not just for locks).
 720   // Warning: can only be called by the current thread on itself.
 721   bool is_in_live_stack(address adr) const {
 722     assert(Thread::current() == this, &quot;is_in_live_stack can only be called from current thread&quot;);
 723     return is_in_stack_range_incl(adr, os::current_stack_pointer());
 724   }
 725 
 726   // Sets this thread as starting thread. Returns failure if thread
 727   // creation fails due to lack of memory, too many threads etc.
 728   bool set_as_starting_thread();
 729 
 730 protected:
 731   // OS data associated with the thread
 732   OSThread* _osthread;  // Platform-specific thread information
 733 
 734   // Thread local resource area for temporary allocation within the VM
 735   ResourceArea* _resource_area;
 736 
 737   DEBUG_ONLY(ResourceMark* _current_resource_mark;)
 738 
 739   // Thread local handle area for allocation of handles within the VM
 740   HandleArea* _handle_area;
 741   GrowableArray&lt;Metadata*&gt;* _metadata_handles;
 742 
 743   // Support for stack overflow handling, get_thread, etc.
 744   address          _stack_base;
 745   size_t           _stack_size;
 746   int              _lgrp_id;
 747 
 748   volatile void** polling_page_addr() { return &amp;_polling_page; }
 749 
 750  public:
 751   // Stack overflow support
<span class="line-modified"> 752   address stack_base() const           { assert(_stack_base != NULL,&quot;Sanity check failed for %s&quot;, name()); return _stack_base; }</span>
 753   void    set_stack_base(address base) { _stack_base = base; }
 754   size_t  stack_size() const           { return _stack_size; }
 755   void    set_stack_size(size_t size)  { _stack_size = size; }
 756   address stack_end()  const           { return stack_base() - stack_size(); }
 757   void    record_stack_base_and_size();
 758   void    register_thread_stack_with_NMT() NOT_NMT_RETURN;
 759 
 760   int     lgrp_id() const        { return _lgrp_id; }
 761   void    set_lgrp_id(int value) { _lgrp_id = value; }
 762 
 763   // Printing
 764   void print_on(outputStream* st, bool print_extended_info) const;
 765   virtual void print_on(outputStream* st) const { print_on(st, false); }
 766   void print() const;
 767   virtual void print_on_error(outputStream* st, char* buf, int buflen) const;
 768   void print_value_on(outputStream* st) const;
 769 
 770   // Debug-only code
 771 #ifdef ASSERT
 772  private:
</pre>
<hr />
<pre>
1326   void set_terminated(TerminatedTypes t);
1327   // special for Threads::remove() which is static:
1328   void set_terminated_value();
1329   void block_if_vm_exited();
1330 
1331   bool doing_unsafe_access()                     { return _doing_unsafe_access; }
1332   void set_doing_unsafe_access(bool val)         { _doing_unsafe_access = val; }
1333 
1334   bool do_not_unlock_if_synchronized()             { return _do_not_unlock_if_synchronized; }
1335   void set_do_not_unlock_if_synchronized(bool val) { _do_not_unlock_if_synchronized = val; }
1336 
1337   inline void set_polling_page_release(void* poll_value);
1338   inline void set_polling_page(void* poll_value);
1339   inline volatile void* get_polling_page();
1340 
1341  private:
1342   // Support for thread handshake operations
1343   HandshakeState _handshake;
1344  public:
1345   void set_handshake_operation(HandshakeOperation* op) {
<span class="line-modified">1346     _handshake.set_operation(this, op);</span>
1347   }
1348 
1349   bool has_handshake() const {
1350     return _handshake.has_operation();
1351   }
1352 
1353   void handshake_process_by_self() {
<span class="line-modified">1354     _handshake.process_by_self(this);</span>
1355   }
1356 
<span class="line-modified">1357   bool handshake_try_process_by_vmThread() {</span>
<span class="line-modified">1358     return _handshake.try_process_by_vmThread(this);</span>
1359   }
1360 
1361 #ifdef ASSERT
<span class="line-modified">1362   bool is_vmthread_processing_handshake() const {</span>
<span class="line-modified">1363     return _handshake.is_vmthread_processing_handshake();</span>
1364   }
1365 #endif
1366 
1367   // Suspend/resume support for JavaThread
1368  private:
1369   inline void set_ext_suspended();
1370   inline void clear_ext_suspended();
1371 
1372  public:
1373   void java_suspend(); // higher-level suspension logic called by the public APIs
1374   void java_resume();  // higher-level resume logic called by the public APIs
1375   int  java_suspend_self(); // low-level self-suspension mechanics
1376 
1377  private:
1378   // mid-level wrapper around java_suspend_self to set up correct state and
1379   // check for a pending safepoint at the end
1380   void java_suspend_self_with_safepoint_check();
1381 
1382  public:
1383   void check_and_wait_while_suspended() {
</pre>
</td>
<td>
<hr />
<pre>
 695   }
 696 
 697  public:
 698   // Used by fast lock support
 699   virtual bool is_lock_owned(address adr) const;
 700 
 701   // Check if address is within the given range of this thread&#39;s
 702   // stack:  stack_base() &gt; adr &gt;= limit
 703   bool is_in_stack_range_incl(address adr, address limit) const {
 704     return is_in_stack_range(adr, limit, true);
 705   }
 706 
 707   // Check if address is within the given range of this thread&#39;s
 708   // stack:  stack_base() &gt; adr &gt; limit
 709   bool is_in_stack_range_excl(address adr, address limit) const {
 710     return is_in_stack_range(adr, limit, false);
 711   }
 712 
 713   // Check if address is in the stack mapped to this thread. Used mainly in
 714   // error reporting (so has to include guard zone) and frame printing.
<span class="line-modified"> 715   // Expects _stack_base to be initialized - checked with assert.</span>
<span class="line-added"> 716   bool is_in_full_stack_checked(address adr) const {</span>
 717     return is_in_stack_range_incl(adr, stack_end());
 718   }
 719 
<span class="line-added"> 720   // Like is_in_full_stack_checked but without the assertions as this</span>
<span class="line-added"> 721   // may be called in a thread before _stack_base is initialized.</span>
<span class="line-added"> 722   bool is_in_full_stack(address adr) const {</span>
<span class="line-added"> 723     address stack_end = _stack_base - _stack_size;</span>
<span class="line-added"> 724     return _stack_base &gt; adr &amp;&amp; adr &gt;= stack_end;</span>
<span class="line-added"> 725   }</span>
<span class="line-added"> 726 </span>
 727   // Check if address is in the live stack of this thread (not just for locks).
 728   // Warning: can only be called by the current thread on itself.
 729   bool is_in_live_stack(address adr) const {
 730     assert(Thread::current() == this, &quot;is_in_live_stack can only be called from current thread&quot;);
 731     return is_in_stack_range_incl(adr, os::current_stack_pointer());
 732   }
 733 
 734   // Sets this thread as starting thread. Returns failure if thread
 735   // creation fails due to lack of memory, too many threads etc.
 736   bool set_as_starting_thread();
 737 
 738 protected:
 739   // OS data associated with the thread
 740   OSThread* _osthread;  // Platform-specific thread information
 741 
 742   // Thread local resource area for temporary allocation within the VM
 743   ResourceArea* _resource_area;
 744 
 745   DEBUG_ONLY(ResourceMark* _current_resource_mark;)
 746 
 747   // Thread local handle area for allocation of handles within the VM
 748   HandleArea* _handle_area;
 749   GrowableArray&lt;Metadata*&gt;* _metadata_handles;
 750 
 751   // Support for stack overflow handling, get_thread, etc.
 752   address          _stack_base;
 753   size_t           _stack_size;
 754   int              _lgrp_id;
 755 
 756   volatile void** polling_page_addr() { return &amp;_polling_page; }
 757 
 758  public:
 759   // Stack overflow support
<span class="line-modified"> 760   address stack_base() const           { assert(_stack_base != NULL,&quot;Sanity check&quot;); return _stack_base; }</span>
 761   void    set_stack_base(address base) { _stack_base = base; }
 762   size_t  stack_size() const           { return _stack_size; }
 763   void    set_stack_size(size_t size)  { _stack_size = size; }
 764   address stack_end()  const           { return stack_base() - stack_size(); }
 765   void    record_stack_base_and_size();
 766   void    register_thread_stack_with_NMT() NOT_NMT_RETURN;
 767 
 768   int     lgrp_id() const        { return _lgrp_id; }
 769   void    set_lgrp_id(int value) { _lgrp_id = value; }
 770 
 771   // Printing
 772   void print_on(outputStream* st, bool print_extended_info) const;
 773   virtual void print_on(outputStream* st) const { print_on(st, false); }
 774   void print() const;
 775   virtual void print_on_error(outputStream* st, char* buf, int buflen) const;
 776   void print_value_on(outputStream* st) const;
 777 
 778   // Debug-only code
 779 #ifdef ASSERT
 780  private:
</pre>
<hr />
<pre>
1334   void set_terminated(TerminatedTypes t);
1335   // special for Threads::remove() which is static:
1336   void set_terminated_value();
1337   void block_if_vm_exited();
1338 
1339   bool doing_unsafe_access()                     { return _doing_unsafe_access; }
1340   void set_doing_unsafe_access(bool val)         { _doing_unsafe_access = val; }
1341 
1342   bool do_not_unlock_if_synchronized()             { return _do_not_unlock_if_synchronized; }
1343   void set_do_not_unlock_if_synchronized(bool val) { _do_not_unlock_if_synchronized = val; }
1344 
1345   inline void set_polling_page_release(void* poll_value);
1346   inline void set_polling_page(void* poll_value);
1347   inline volatile void* get_polling_page();
1348 
1349  private:
1350   // Support for thread handshake operations
1351   HandshakeState _handshake;
1352  public:
1353   void set_handshake_operation(HandshakeOperation* op) {
<span class="line-modified">1354     _handshake.set_operation(op);</span>
1355   }
1356 
1357   bool has_handshake() const {
1358     return _handshake.has_operation();
1359   }
1360 
1361   void handshake_process_by_self() {
<span class="line-modified">1362     _handshake.process_by_self();</span>
1363   }
1364 
<span class="line-modified">1365   bool handshake_try_process(HandshakeOperation* op) {</span>
<span class="line-modified">1366     return _handshake.try_process(op);</span>
1367   }
1368 
1369 #ifdef ASSERT
<span class="line-modified">1370   Thread* active_handshaker() const {</span>
<span class="line-modified">1371     return _handshake.active_handshaker();</span>
1372   }
1373 #endif
1374 
1375   // Suspend/resume support for JavaThread
1376  private:
1377   inline void set_ext_suspended();
1378   inline void clear_ext_suspended();
1379 
1380  public:
1381   void java_suspend(); // higher-level suspension logic called by the public APIs
1382   void java_resume();  // higher-level resume logic called by the public APIs
1383   int  java_suspend_self(); // low-level self-suspension mechanics
1384 
1385  private:
1386   // mid-level wrapper around java_suspend_self to set up correct state and
1387   // check for a pending safepoint at the end
1388   void java_suspend_self_with_safepoint_check();
1389 
1390  public:
1391   void check_and_wait_while_suspended() {
</pre>
</td>
</tr>
</table>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
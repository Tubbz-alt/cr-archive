<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/biasedLocking.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/biasedLocking.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
607   assert(op != NULL, &quot;invariant&quot;);
608   assert(event-&gt;should_commit(), &quot;invariant&quot;);
609   event-&gt;set_revokedClass(k);
610   event-&gt;set_disableBiasing(!op-&gt;is_bulk_rebias());
611   event-&gt;set_safepointId(op-&gt;safepoint_id());
612   event-&gt;commit();
613 }
614 
615 
616 BiasedLocking::Condition BiasedLocking::single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser) {
617 
618   EventBiasedLockRevocation event;
619   if (PrintBiasedLockingStatistics) {
620     Atomic::inc(handshakes_count_addr());
621   }
622   log_info(biasedlocking, handshake)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; handshaking JavaThread &quot;
623                                      INTPTR_FORMAT &quot; to revoke object &quot; INTPTR_FORMAT, p2i(requester),
624                                      p2i(biaser), p2i(obj()));
625 
626   RevokeOneBias revoke(obj, requester, biaser);
<span class="line-modified">627   bool executed = Handshake::execute(&amp;revoke, biaser);</span>
628   if (revoke.status_code() == NOT_REVOKED) {
629     return NOT_REVOKED;
630   }
631   if (executed) {
632     log_info(biasedlocking, handshake)(&quot;Handshake revocation for object &quot; INTPTR_FORMAT &quot; succeeded. Bias was %srevoked&quot;,
633                                        p2i(obj()), (revoke.status_code() == BIAS_REVOKED ? &quot;&quot; : &quot;already &quot;));
634     if (event.should_commit() &amp;&amp; revoke.status_code() == BIAS_REVOKED) {
635       post_revocation_event(&amp;event, obj-&gt;klass(), &amp;revoke);
636     }
637     assert(!obj-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);
638     return revoke.status_code();
639   } else {
640     // Thread was not alive.
641     // Grab Threads_lock before manually trying to revoke bias. This avoids race with a newly
642     // created JavaThread (that happens to get the same memory address as biaser) synchronizing
643     // on this object.
644     {
645       MutexLocker ml(Threads_lock);
646       markWord mark = obj-&gt;mark();
647       // Check if somebody else was able to revoke it before biased thread exited.
</pre>
<hr />
<pre>
651       ThreadsListHandle tlh;
652       markWord prototype = obj-&gt;klass()-&gt;prototype_header();
653       if (!prototype.has_bias_pattern() || (!tlh.includes(biaser) &amp;&amp; biaser == mark.biased_locker() &amp;&amp;
654                                             prototype.bias_epoch() == mark.bias_epoch())) {
655         obj-&gt;cas_set_mark(markWord::prototype().set_age(mark.age()), mark);
656         if (event.should_commit()) {
657           post_revocation_event(&amp;event, obj-&gt;klass(), &amp;revoke);
658         }
659         assert(!obj-&gt;mark().has_bias_pattern(), &quot;bias should be revoked by now&quot;);
660         return BIAS_REVOKED;
661       }
662     }
663   }
664 
665   return NOT_REVOKED;
666 }
667 
668 
669 // Caller should have instantiated a ResourceMark object before calling this method
670 void BiasedLocking::walk_stack_and_revoke(oop obj, JavaThread* biased_locker) {
<span class="line-modified">671   assert(!SafepointSynchronize::is_at_safepoint() || !SafepointMechanism::uses_thread_local_poll(),</span>
<span class="line-modified">672          &quot;if SafepointMechanism::uses_thread_local_poll() is enabled this should always be executed outside safepoints&quot;);</span>
<span class="line-modified">673   assert(Thread::current() == biased_locker || Thread::current()-&gt;is_VM_thread(), &quot;wrong thread&quot;);</span>
674 
675   markWord mark = obj-&gt;mark();
676   assert(mark.biased_locker() == biased_locker &amp;&amp;
677          obj-&gt;klass()-&gt;prototype_header().bias_epoch() == mark.bias_epoch(), &quot;invariant&quot;);
678 
<span class="line-modified">679   log_trace(biasedlocking)(&quot;%s(&quot; INTPTR_FORMAT &quot;) revoking object &quot; INTPTR_FORMAT &quot;, mark &quot;</span>
680                            INTPTR_FORMAT &quot;, type %s, prototype header &quot; INTPTR_FORMAT
681                            &quot;, biaser &quot; INTPTR_FORMAT &quot; %s&quot;,
<span class="line-modified">682                            Thread::current()-&gt;is_VM_thread() ? &quot;VMThread&quot; : &quot;JavaThread&quot;,</span>
<span class="line-removed">683                            p2i(Thread::current()),</span>
684                            p2i(obj),
685                            mark.value(),
686                            obj-&gt;klass()-&gt;external_name(),
687                            obj-&gt;klass()-&gt;prototype_header().value(),
688                            p2i(biased_locker),
<span class="line-modified">689                            Thread::current()-&gt;is_VM_thread() ? &quot;&quot; : &quot;(walking own stack)&quot;);</span>
690 
691   markWord unbiased_prototype = markWord::prototype().set_age(obj-&gt;mark().age());
692 
693   GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_locker);
694   BasicLock* highest_lock = NULL;
695   for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
696     MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
697     if (mon_info-&gt;owner() == obj) {
698       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) == obj (&quot; PTR_FORMAT &quot;)&quot;,
699                                p2i(mon_info-&gt;owner()),
700                                p2i(obj));
701       // Assume recursive case and fix up highest lock below
702       markWord mark = markWord::encode((BasicLock*) NULL);
703       highest_lock = mon_info-&gt;lock();
704       highest_lock-&gt;set_displaced_header(mark);
705     } else {
706       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) != obj (&quot; PTR_FORMAT &quot;)&quot;,
707                                p2i(mon_info-&gt;owner()),
708                                p2i(obj));
709     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
607   assert(op != NULL, &quot;invariant&quot;);
608   assert(event-&gt;should_commit(), &quot;invariant&quot;);
609   event-&gt;set_revokedClass(k);
610   event-&gt;set_disableBiasing(!op-&gt;is_bulk_rebias());
611   event-&gt;set_safepointId(op-&gt;safepoint_id());
612   event-&gt;commit();
613 }
614 
615 
616 BiasedLocking::Condition BiasedLocking::single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser) {
617 
618   EventBiasedLockRevocation event;
619   if (PrintBiasedLockingStatistics) {
620     Atomic::inc(handshakes_count_addr());
621   }
622   log_info(biasedlocking, handshake)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; handshaking JavaThread &quot;
623                                      INTPTR_FORMAT &quot; to revoke object &quot; INTPTR_FORMAT, p2i(requester),
624                                      p2i(biaser), p2i(obj()));
625 
626   RevokeOneBias revoke(obj, requester, biaser);
<span class="line-modified">627   bool executed = Handshake::execute_direct(&amp;revoke, biaser);</span>
628   if (revoke.status_code() == NOT_REVOKED) {
629     return NOT_REVOKED;
630   }
631   if (executed) {
632     log_info(biasedlocking, handshake)(&quot;Handshake revocation for object &quot; INTPTR_FORMAT &quot; succeeded. Bias was %srevoked&quot;,
633                                        p2i(obj()), (revoke.status_code() == BIAS_REVOKED ? &quot;&quot; : &quot;already &quot;));
634     if (event.should_commit() &amp;&amp; revoke.status_code() == BIAS_REVOKED) {
635       post_revocation_event(&amp;event, obj-&gt;klass(), &amp;revoke);
636     }
637     assert(!obj-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);
638     return revoke.status_code();
639   } else {
640     // Thread was not alive.
641     // Grab Threads_lock before manually trying to revoke bias. This avoids race with a newly
642     // created JavaThread (that happens to get the same memory address as biaser) synchronizing
643     // on this object.
644     {
645       MutexLocker ml(Threads_lock);
646       markWord mark = obj-&gt;mark();
647       // Check if somebody else was able to revoke it before biased thread exited.
</pre>
<hr />
<pre>
651       ThreadsListHandle tlh;
652       markWord prototype = obj-&gt;klass()-&gt;prototype_header();
653       if (!prototype.has_bias_pattern() || (!tlh.includes(biaser) &amp;&amp; biaser == mark.biased_locker() &amp;&amp;
654                                             prototype.bias_epoch() == mark.bias_epoch())) {
655         obj-&gt;cas_set_mark(markWord::prototype().set_age(mark.age()), mark);
656         if (event.should_commit()) {
657           post_revocation_event(&amp;event, obj-&gt;klass(), &amp;revoke);
658         }
659         assert(!obj-&gt;mark().has_bias_pattern(), &quot;bias should be revoked by now&quot;);
660         return BIAS_REVOKED;
661       }
662     }
663   }
664 
665   return NOT_REVOKED;
666 }
667 
668 
669 // Caller should have instantiated a ResourceMark object before calling this method
670 void BiasedLocking::walk_stack_and_revoke(oop obj, JavaThread* biased_locker) {
<span class="line-modified">671   Thread* cur = Thread::current();</span>
<span class="line-modified">672   assert(!SafepointSynchronize::is_at_safepoint(), &quot;this should always be executed outside safepoints&quot;);</span>
<span class="line-modified">673   assert(cur == biased_locker || cur == biased_locker-&gt;active_handshaker(), &quot;wrong thread&quot;);</span>
674 
675   markWord mark = obj-&gt;mark();
676   assert(mark.biased_locker() == biased_locker &amp;&amp;
677          obj-&gt;klass()-&gt;prototype_header().bias_epoch() == mark.bias_epoch(), &quot;invariant&quot;);
678 
<span class="line-modified">679   log_trace(biasedlocking)(&quot;JavaThread(&quot; INTPTR_FORMAT &quot;) revoking object &quot; INTPTR_FORMAT &quot;, mark &quot;</span>
680                            INTPTR_FORMAT &quot;, type %s, prototype header &quot; INTPTR_FORMAT
681                            &quot;, biaser &quot; INTPTR_FORMAT &quot; %s&quot;,
<span class="line-modified">682                            p2i(cur),</span>

683                            p2i(obj),
684                            mark.value(),
685                            obj-&gt;klass()-&gt;external_name(),
686                            obj-&gt;klass()-&gt;prototype_header().value(),
687                            p2i(biased_locker),
<span class="line-modified">688                            cur != biased_locker ? &quot;&quot; : &quot;(walking own stack)&quot;);</span>
689 
690   markWord unbiased_prototype = markWord::prototype().set_age(obj-&gt;mark().age());
691 
692   GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_locker);
693   BasicLock* highest_lock = NULL;
694   for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
695     MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
696     if (mon_info-&gt;owner() == obj) {
697       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) == obj (&quot; PTR_FORMAT &quot;)&quot;,
698                                p2i(mon_info-&gt;owner()),
699                                p2i(obj));
700       // Assume recursive case and fix up highest lock below
701       markWord mark = markWord::encode((BasicLock*) NULL);
702       highest_lock = mon_info-&gt;lock();
703       highest_lock-&gt;set_displaced_header(mark);
704     } else {
705       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) != obj (&quot; PTR_FORMAT &quot;)&quot;,
706                                p2i(mon_info-&gt;owner()),
707                                p2i(obj));
708     }
</pre>
</td>
</tr>
</table>
<center><a href="../opto/subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/runtime/thread.hpp b/src/hotspot/share/runtime/thread.hpp
--- a/src/hotspot/share/runtime/thread.hpp
+++ b/src/hotspot/share/runtime/thread.hpp
@@ -710,14 +710,22 @@
     return is_in_stack_range(adr, limit, false);
   }
 
   // Check if address is in the stack mapped to this thread. Used mainly in
   // error reporting (so has to include guard zone) and frame printing.
-  bool is_in_full_stack(address adr) const {
+  // Expects _stack_base to be initialized - checked with assert.
+  bool is_in_full_stack_checked(address adr) const {
     return is_in_stack_range_incl(adr, stack_end());
   }
 
+  // Like is_in_full_stack_checked but without the assertions as this
+  // may be called in a thread before _stack_base is initialized.
+  bool is_in_full_stack(address adr) const {
+    address stack_end = _stack_base - _stack_size;
+    return _stack_base > adr && adr >= stack_end;
+  }
+
   // Check if address is in the live stack of this thread (not just for locks).
   // Warning: can only be called by the current thread on itself.
   bool is_in_live_stack(address adr) const {
     assert(Thread::current() == this, "is_in_live_stack can only be called from current thread");
     return is_in_stack_range_incl(adr, os::current_stack_pointer());
@@ -747,11 +755,11 @@
 
   volatile void** polling_page_addr() { return &_polling_page; }
 
  public:
   // Stack overflow support
-  address stack_base() const           { assert(_stack_base != NULL,"Sanity check failed for %s", name()); return _stack_base; }
+  address stack_base() const           { assert(_stack_base != NULL,"Sanity check"); return _stack_base; }
   void    set_stack_base(address base) { _stack_base = base; }
   size_t  stack_size() const           { return _stack_size; }
   void    set_stack_size(size_t size)  { _stack_size = size; }
   address stack_end()  const           { return stack_base() - stack_size(); }
   void    record_stack_base_and_size();
@@ -1341,28 +1349,28 @@
  private:
   // Support for thread handshake operations
   HandshakeState _handshake;
  public:
   void set_handshake_operation(HandshakeOperation* op) {
-    _handshake.set_operation(this, op);
+    _handshake.set_operation(op);
   }
 
   bool has_handshake() const {
     return _handshake.has_operation();
   }
 
   void handshake_process_by_self() {
-    _handshake.process_by_self(this);
+    _handshake.process_by_self();
   }
 
-  bool handshake_try_process_by_vmThread() {
-    return _handshake.try_process_by_vmThread(this);
+  bool handshake_try_process(HandshakeOperation* op) {
+    return _handshake.try_process(op);
   }
 
 #ifdef ASSERT
-  bool is_vmthread_processing_handshake() const {
-    return _handshake.is_vmthread_processing_handshake();
+  Thread* active_handshaker() const {
+    return _handshake.active_handshaker();
   }
 #endif
 
   // Suspend/resume support for JavaThread
  private:

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="synchronizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 333 #endif
 334   assert(ThreadLocalStorage::thread() == NULL, &quot;ThreadLocalStorage::thread already initialized&quot;);
 335   ThreadLocalStorage::set_thread(this);
 336   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 337 }
 338 
 339 void Thread::clear_thread_current() {
 340   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 341 #ifndef USE_LIBRARY_BASED_TLS_ONLY
 342   _thr_current = NULL;
 343 #endif
 344   ThreadLocalStorage::set_thread(NULL);
 345 }
 346 
 347 void Thread::record_stack_base_and_size() {
 348   // Note: at this point, Thread object is not yet initialized. Do not rely on
 349   // any members being initialized. Do not rely on Thread::current() being set.
 350   // If possible, refrain from doing anything which may crash or assert since
 351   // quite probably those crash dumps will be useless.
 352   set_stack_base(os::current_stack_base());
<span class="line-removed"> 353   assert(_stack_base != NULL, &quot;current_stack_base failed for %s&quot;, name());</span>
 354   set_stack_size(os::current_stack_size());
 355 
 356 #ifdef SOLARIS
 357   if (os::is_primordial_thread()) {
 358     os::Solaris::correct_stack_boundaries_for_primordial_thread(this);
 359   }
 360 #endif
 361 
 362   // Set stack limits after thread is initialized.
 363   if (is_Java_thread()) {
 364     ((JavaThread*) this)-&gt;set_stack_overflow_limit();
 365     ((JavaThread*) this)-&gt;set_reserved_stack_activation(stack_base());
 366   }
 367 }
 368 
 369 #if INCLUDE_NMT
 370 void Thread::register_thread_stack_with_NMT() {
 371   MemTracker::record_thread_stack(stack_end(), stack_size());
 372 }
 373 #endif // INCLUDE_NMT
</pre>
<hr />
<pre>
1676   _reserved_stack_activation = NULL;  // stack base not known yet
1677   (void)const_cast&lt;oop&amp;&gt;(_exception_oop = oop(NULL));
1678   _exception_pc  = 0;
1679   _exception_handler_pc = 0;
1680   _is_method_handle_return = 0;
1681   _jvmti_thread_state= NULL;
1682   _should_post_on_exceptions_flag = JNI_FALSE;
1683   _interp_only_mode    = 0;
1684   _special_runtime_exit_condition = _no_async_condition;
1685   _pending_async_exception = NULL;
1686   _thread_stat = NULL;
1687   _thread_stat = new ThreadStatistics();
1688   _jni_active_critical = 0;
1689   _pending_jni_exception_check_fn = NULL;
1690   _do_not_unlock_if_synchronized = false;
1691   _cached_monitor_info = NULL;
1692   _parker = Parker::Allocate(this);
1693   _SleepEvent = ParkEvent::Allocate(this);
1694   // Setup safepoint state info for this thread
1695   ThreadSafepointState::create(this);

1696 
1697   debug_only(_java_call_counter = 0);
1698 
1699   // JVMTI PopFrame support
1700   _popframe_condition = popframe_inactive;
1701   _popframe_preserved_args = NULL;
1702   _popframe_preserved_args_size = 0;
1703   _frames_to_pop_failed_realloc = 0;
1704 
<span class="line-modified">1705   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed">1706     SafepointMechanism::initialize_header(this);</span>
<span class="line-removed">1707   }</span>
1708 
1709   _class_to_be_initialized = NULL;
1710 
1711   pd_initialize();
1712 }
1713 
1714 JavaThread::JavaThread(bool is_attaching_via_jni) :
1715                        Thread() {
1716   initialize();
1717   if (is_attaching_via_jni) {
1718     _jni_attach_state = _attaching_via_jni;
1719   } else {
1720     _jni_attach_state = _not_attaching_via_jni;
1721   }
1722   assert(deferred_card_mark().is_empty(), &quot;Default MemRegion ctor&quot;);
1723 }
1724 
1725 
1726 // interrupt support
1727 
</pre>
<hr />
<pre>
4456   // will be stopped at native=&gt;Java/VM barriers. Note that we can&#39;t
4457   // simply kill or suspend them, as it is inherently deadlock-prone.
4458 
4459   VM_Exit::set_vm_exited();
4460 
4461   // Clean up ideal graph printers after the VMThread has started
4462   // the final safepoint which will block all the Compiler threads.
4463   // Note that this Thread has already logically exited so the
4464   // clean_up() function&#39;s use of a JavaThreadIteratorWithHandle
4465   // would be a problem except set_vm_exited() has remembered the
4466   // shutdown thread which is granted a policy exception.
4467 #if defined(COMPILER2) &amp;&amp; !defined(PRODUCT)
4468   IdealGraphPrinter::clean_up();
4469 #endif
4470 
4471   notify_vm_shutdown();
4472 
4473   // exit_globals() will delete tty
4474   exit_globals();
4475 
<span class="line-modified">4476   // We are after VM_Exit::set_vm_exited() so we can&#39;t call</span>
<span class="line-modified">4477   // thread-&gt;smr_delete() or we will block on the Threads_lock.</span>
<span class="line-modified">4478   // Deleting the shutdown thread here is safe because another</span>
<span class="line-modified">4479   // JavaThread cannot have an active ThreadsListHandle for</span>
<span class="line-modified">4480   // this JavaThread.</span>
<span class="line-modified">4481   delete thread;</span>









4482 
4483 #if INCLUDE_JVMCI
4484   if (JVMCICounterSize &gt; 0) {
4485     FREE_C_HEAP_ARRAY(jlong, JavaThread::_jvmci_old_thread_counters);
4486   }
4487 #endif
4488 
4489   LogConfiguration::finalize();
4490 
4491   return true;
4492 }
4493 
4494 
4495 jboolean Threads::is_supported_jni_version_including_1_1(jint version) {
4496   if (version == JNI_VERSION_1_1) return JNI_TRUE;
4497   return is_supported_jni_version(version);
4498 }
4499 
4500 
4501 jboolean Threads::is_supported_jni_version(jint version) {
</pre>
</td>
<td>
<hr />
<pre>
 333 #endif
 334   assert(ThreadLocalStorage::thread() == NULL, &quot;ThreadLocalStorage::thread already initialized&quot;);
 335   ThreadLocalStorage::set_thread(this);
 336   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 337 }
 338 
 339 void Thread::clear_thread_current() {
 340   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 341 #ifndef USE_LIBRARY_BASED_TLS_ONLY
 342   _thr_current = NULL;
 343 #endif
 344   ThreadLocalStorage::set_thread(NULL);
 345 }
 346 
 347 void Thread::record_stack_base_and_size() {
 348   // Note: at this point, Thread object is not yet initialized. Do not rely on
 349   // any members being initialized. Do not rely on Thread::current() being set.
 350   // If possible, refrain from doing anything which may crash or assert since
 351   // quite probably those crash dumps will be useless.
 352   set_stack_base(os::current_stack_base());

 353   set_stack_size(os::current_stack_size());
 354 
 355 #ifdef SOLARIS
 356   if (os::is_primordial_thread()) {
 357     os::Solaris::correct_stack_boundaries_for_primordial_thread(this);
 358   }
 359 #endif
 360 
 361   // Set stack limits after thread is initialized.
 362   if (is_Java_thread()) {
 363     ((JavaThread*) this)-&gt;set_stack_overflow_limit();
 364     ((JavaThread*) this)-&gt;set_reserved_stack_activation(stack_base());
 365   }
 366 }
 367 
 368 #if INCLUDE_NMT
 369 void Thread::register_thread_stack_with_NMT() {
 370   MemTracker::record_thread_stack(stack_end(), stack_size());
 371 }
 372 #endif // INCLUDE_NMT
</pre>
<hr />
<pre>
1675   _reserved_stack_activation = NULL;  // stack base not known yet
1676   (void)const_cast&lt;oop&amp;&gt;(_exception_oop = oop(NULL));
1677   _exception_pc  = 0;
1678   _exception_handler_pc = 0;
1679   _is_method_handle_return = 0;
1680   _jvmti_thread_state= NULL;
1681   _should_post_on_exceptions_flag = JNI_FALSE;
1682   _interp_only_mode    = 0;
1683   _special_runtime_exit_condition = _no_async_condition;
1684   _pending_async_exception = NULL;
1685   _thread_stat = NULL;
1686   _thread_stat = new ThreadStatistics();
1687   _jni_active_critical = 0;
1688   _pending_jni_exception_check_fn = NULL;
1689   _do_not_unlock_if_synchronized = false;
1690   _cached_monitor_info = NULL;
1691   _parker = Parker::Allocate(this);
1692   _SleepEvent = ParkEvent::Allocate(this);
1693   // Setup safepoint state info for this thread
1694   ThreadSafepointState::create(this);
<span class="line-added">1695   _handshake.set_handshakee(this);</span>
1696 
1697   debug_only(_java_call_counter = 0);
1698 
1699   // JVMTI PopFrame support
1700   _popframe_condition = popframe_inactive;
1701   _popframe_preserved_args = NULL;
1702   _popframe_preserved_args_size = 0;
1703   _frames_to_pop_failed_realloc = 0;
1704 
<span class="line-modified">1705   SafepointMechanism::initialize_header(this);</span>


1706 
1707   _class_to_be_initialized = NULL;
1708 
1709   pd_initialize();
1710 }
1711 
1712 JavaThread::JavaThread(bool is_attaching_via_jni) :
1713                        Thread() {
1714   initialize();
1715   if (is_attaching_via_jni) {
1716     _jni_attach_state = _attaching_via_jni;
1717   } else {
1718     _jni_attach_state = _not_attaching_via_jni;
1719   }
1720   assert(deferred_card_mark().is_empty(), &quot;Default MemRegion ctor&quot;);
1721 }
1722 
1723 
1724 // interrupt support
1725 
</pre>
<hr />
<pre>
4454   // will be stopped at native=&gt;Java/VM barriers. Note that we can&#39;t
4455   // simply kill or suspend them, as it is inherently deadlock-prone.
4456 
4457   VM_Exit::set_vm_exited();
4458 
4459   // Clean up ideal graph printers after the VMThread has started
4460   // the final safepoint which will block all the Compiler threads.
4461   // Note that this Thread has already logically exited so the
4462   // clean_up() function&#39;s use of a JavaThreadIteratorWithHandle
4463   // would be a problem except set_vm_exited() has remembered the
4464   // shutdown thread which is granted a policy exception.
4465 #if defined(COMPILER2) &amp;&amp; !defined(PRODUCT)
4466   IdealGraphPrinter::clean_up();
4467 #endif
4468 
4469   notify_vm_shutdown();
4470 
4471   // exit_globals() will delete tty
4472   exit_globals();
4473 
<span class="line-modified">4474   // We are here after VM_Exit::set_vm_exited() so we can&#39;t call</span>
<span class="line-modified">4475   // thread-&gt;smr_delete() or we will block on the Threads_lock. We</span>
<span class="line-modified">4476   // must check that there are no active references to this thread</span>
<span class="line-modified">4477   // before attempting to delete it. A thread could be waiting on</span>
<span class="line-modified">4478   // _handshake_turn_sem trying to execute a direct handshake with</span>
<span class="line-modified">4479   // this thread.</span>
<span class="line-added">4480   if (!ThreadsSMRSupport::is_a_protected_JavaThread(thread)) {</span>
<span class="line-added">4481     delete thread;</span>
<span class="line-added">4482   } else {</span>
<span class="line-added">4483     // Clear value for _thread_key in TLS to prevent, depending</span>
<span class="line-added">4484     // on pthreads implementation, possible execution of</span>
<span class="line-added">4485     // thread-specific destructor in infinite loop at thread</span>
<span class="line-added">4486     // exit.</span>
<span class="line-added">4487     Thread::clear_thread_current();</span>
<span class="line-added">4488   }</span>
4489 
4490 #if INCLUDE_JVMCI
4491   if (JVMCICounterSize &gt; 0) {
4492     FREE_C_HEAP_ARRAY(jlong, JavaThread::_jvmci_old_thread_counters);
4493   }
4494 #endif
4495 
4496   LogConfiguration::finalize();
4497 
4498   return true;
4499 }
4500 
4501 
4502 jboolean Threads::is_supported_jni_version_including_1_1(jint version) {
4503   if (version == JNI_VERSION_1_1) return JNI_TRUE;
4504   return is_supported_jni_version(version);
4505 }
4506 
4507 
4508 jboolean Threads::is_supported_jni_version(jint version) {
</pre>
</td>
</tr>
</table>
<center><a href="synchronizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
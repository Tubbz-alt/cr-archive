<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.jdi;
  27 
  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.SoftReference;
  31 import java.text.MessageFormat;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Set;
  41 import java.util.function.Consumer;
  42 
  43 import com.sun.jdi.BooleanType;
  44 import com.sun.jdi.BooleanValue;
  45 import com.sun.jdi.ByteType;
  46 import com.sun.jdi.ByteValue;
  47 import com.sun.jdi.CharType;
  48 import com.sun.jdi.CharValue;
  49 import com.sun.jdi.ClassLoaderReference;
  50 import com.sun.jdi.ClassNotLoadedException;
  51 import com.sun.jdi.DoubleType;
  52 import com.sun.jdi.DoubleValue;
  53 import com.sun.jdi.FloatType;
  54 import com.sun.jdi.FloatValue;
  55 import com.sun.jdi.IntegerType;
  56 import com.sun.jdi.IntegerValue;
  57 import com.sun.jdi.InternalException;
  58 import com.sun.jdi.LongType;
  59 import com.sun.jdi.LongValue;
  60 import com.sun.jdi.ModuleReference;
  61 import com.sun.jdi.ObjectCollectedException;
  62 import com.sun.jdi.PathSearchingVirtualMachine;
  63 import com.sun.jdi.PrimitiveType;
  64 import com.sun.jdi.ReferenceType;
  65 import com.sun.jdi.ShortType;
  66 import com.sun.jdi.ShortValue;
  67 import com.sun.jdi.StringReference;
  68 import com.sun.jdi.ThreadGroupReference;
  69 import com.sun.jdi.ThreadReference;
  70 import com.sun.jdi.Type;
  71 import com.sun.jdi.VMDisconnectedException;
  72 import com.sun.jdi.VirtualMachine;
  73 import com.sun.jdi.VirtualMachineManager;
  74 import com.sun.jdi.VoidType;
  75 import com.sun.jdi.VoidValue;
  76 import com.sun.jdi.connect.spi.Connection;
  77 import com.sun.jdi.event.EventQueue;
  78 import com.sun.jdi.request.BreakpointRequest;
  79 import com.sun.jdi.request.EventRequest;
  80 import com.sun.jdi.request.EventRequestManager;
  81 
  82 class VirtualMachineImpl extends MirrorImpl
  83              implements PathSearchingVirtualMachine, ThreadListener {
  84     // VM Level exported variables, these
  85     // are unique to a given vm
  86     public final int sizeofFieldRef;
  87     public final int sizeofMethodRef;
  88     public final int sizeofObjectRef;
  89     public final int sizeofClassRef;
  90     public final int sizeofFrameRef;
  91     public final int sizeofModuleRef;
  92 
  93     final int sequenceNumber;
  94 
  95     private final TargetVM target;
  96     private final EventQueueImpl eventQueue;
  97     private final EventRequestManagerImpl internalEventRequestManager;
  98     private final EventRequestManagerImpl eventRequestManager;
  99     final VirtualMachineManagerImpl vmManager;
 100     private final ThreadGroup threadGroupForJDI;
 101 
 102     // Allow direct access to this field so that that tracing code slows down
 103     // JDI as little as possible when not enabled.
 104     int traceFlags = TRACE_NONE;
 105 
 106     static int TRACE_RAW_SENDS     = 0x01000000;
 107     static int TRACE_RAW_RECEIVES  = 0x02000000;
 108 
 109     boolean traceReceives = false;   // pre-compute because of frequency
 110 
 111     // ReferenceType access - updated with class prepare and unload events
 112     // Protected by &quot;synchronized(this)&quot;. &quot;retrievedAllTypes&quot; may be
 113     // tested unsynchronized (since once true, it stays true), but must
 114     // be set synchronously
 115     private Map&lt;Long, ReferenceType&gt; typesByID;
 116     private Set&lt;ReferenceType&gt; typesBySignature;
 117     private boolean retrievedAllTypes = false;
 118 
 119     private Map&lt;Long, ModuleReference&gt; modulesByID;
 120 
 121     // For other languages support
 122     private String defaultStratum = null;
 123 
 124     // ObjectReference cache
 125     // &quot;objectsByID&quot; protected by &quot;synchronized(this)&quot;.
 126     private final Map&lt;Long, SoftObjectReference&gt; objectsByID = new HashMap&lt;&gt;();
 127     private final ReferenceQueue&lt;ObjectReferenceImpl&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
 128     static private final int DISPOSE_THRESHOLD = 50;
 129     private final List&lt;SoftObjectReference&gt; batchedDisposeRequests =
 130             Collections.synchronizedList(new ArrayList&lt;&gt;(DISPOSE_THRESHOLD + 10));
 131 
 132     // These are cached once for the life of the VM
 133     private JDWP.VirtualMachine.Version versionInfo;
 134     private JDWP.VirtualMachine.ClassPaths pathInfo;
 135     private JDWP.VirtualMachine.Capabilities capabilities = null;
 136     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew = null;
 137 
 138     // Per-vm singletons for primitive types and for void.
 139     // singleton-ness protected by &quot;synchronized(this)&quot;.
 140     private BooleanType theBooleanType;
 141     private ByteType    theByteType;
 142     private CharType    theCharType;
 143     private ShortType   theShortType;
 144     private IntegerType theIntegerType;
 145     private LongType    theLongType;
 146     private FloatType   theFloatType;
 147     private DoubleType  theDoubleType;
 148 
 149     private VoidType    theVoidType;
 150 
 151     private VoidValue voidVal;
 152 
 153     // Launched debuggee process
 154     private Process process;
 155 
 156     // coordinates state changes and corresponding listener notifications
 157     private VMState state = new VMState(this);
 158 
 159     private Object initMonitor = new Object();
 160     private boolean initComplete = false;
 161     private boolean shutdown = false;
 162 
 163     private void notifyInitCompletion() {
 164         synchronized(initMonitor) {
 165             initComplete = true;
 166             initMonitor.notifyAll();
 167         }
 168     }
 169 
 170     void waitInitCompletion() {
 171         synchronized(initMonitor) {
 172             while (!initComplete) {
 173                 try {
 174                     initMonitor.wait();
 175                 } catch (InterruptedException e) {
 176                     // ignore
 177                 }
 178             }
 179         }
 180     }
 181 
 182     VMState state() {
 183         return state;
 184     }
 185 
 186     /*
 187      * ThreadListener implementation
 188      */
 189     public boolean threadResumable(ThreadAction action) {
 190         /*
 191          * If any thread is resumed, the VM is considered not suspended.
 192          * Just one thread is being resumed so pass it to thaw.
 193          */
 194         state.thaw(action.thread());
 195         return true;
 196     }
 197 
 198     VirtualMachineImpl(VirtualMachineManager manager,
 199                        Connection connection, Process process,
 200                        int sequenceNumber) {
 201         super(null);  // Can&#39;t use super(this)
 202         vm = this;
 203 
 204         this.vmManager = (VirtualMachineManagerImpl)manager;
 205         this.process = process;
 206         this.sequenceNumber = sequenceNumber;
 207 
 208         /* Create ThreadGroup to be used by all threads servicing
 209          * this VM.
 210          */
 211         threadGroupForJDI = new ThreadGroup(vmManager.mainGroupForJDI(),
 212                                             &quot;JDI [&quot; +
 213                                             this.hashCode() + &quot;]&quot;);
 214 
 215         /*
 216          * Set up a thread to communicate with the target VM over
 217          * the specified transport.
 218          */
 219         target = new TargetVM(this, connection);
 220 
 221         /*
 222          * Set up a thread to handle events processed internally
 223          * the JDI implementation.
 224          */
 225         EventQueueImpl internalEventQueue = new EventQueueImpl(this, target);
 226         new InternalEventHandler(this, internalEventQueue);
 227         /*
 228          * Initialize client access to event setting and handling
 229          */
 230         eventQueue = new EventQueueImpl(this, target);
 231         eventRequestManager = new EventRequestManagerImpl(this);
 232 
 233         target.start();
 234 
 235         /*
 236          * Many ids are variably sized, depending on target VM.
 237          * Find out the sizes right away.
 238          */
 239         JDWP.VirtualMachine.IDSizes idSizes;
 240         try {
 241             idSizes = JDWP.VirtualMachine.IDSizes.process(vm);
 242         } catch (JDWPException exc) {
 243             throw exc.toJDIException();
 244         }
 245         sizeofFieldRef  = idSizes.fieldIDSize;
 246         sizeofMethodRef = idSizes.methodIDSize;
 247         sizeofObjectRef = idSizes.objectIDSize;
 248         sizeofClassRef = idSizes.referenceTypeIDSize;
 249         sizeofFrameRef  = idSizes.frameIDSize;
 250         sizeofModuleRef = idSizes.objectIDSize;
 251 
 252         /**
 253          * Set up requests needed by internal event handler.
 254          * Make sure they are distinguished by creating them with
 255          * an internal event request manager.
 256          *
 257          * Warning: create events only with SUSPEND_NONE policy.
 258          * In the current implementation other policies will not
 259          * be handled correctly when the event comes in. (notfiySuspend()
 260          * will not be properly called, and if the event is combined
 261          * with external events in the same set, suspend policy is not
 262          * correctly determined for the internal vs. external event sets)
 263          */
 264         internalEventRequestManager = new EventRequestManagerImpl(this);
 265         EventRequest er = internalEventRequestManager.createClassPrepareRequest();
 266         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 267         er.enable();
 268         er = internalEventRequestManager.createClassUnloadRequest();
 269         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 270         er.enable();
 271 
 272         /*
 273          * Tell other threads, notably TargetVM, that initialization
 274          * is complete.
 275          */
 276         notifyInitCompletion();
 277     }
 278 
 279     EventRequestManagerImpl getInternalEventRequestManager() {
 280         return internalEventRequestManager;
 281     }
 282 
 283     void validateVM() {
 284         /*
 285          * We no longer need to do this.  The spec now says
 286          * that a VMDisconnected _may_ be thrown in these
 287          * cases, not that it _will_ be thrown.
 288          * So, to simplify things we will just let the
 289          * caller&#39;s of this method proceed with their business.
 290          * If the debuggee is disconnected, either because it
 291          * crashed or finished or something, or because the
 292          * debugger called exit() or dispose(), then if
 293          * we end up trying to communicate with the debuggee,
 294          * code in TargetVM will throw a VMDisconnectedException.
 295          * This means that if we can satisfy a request without
 296          * talking to the debuggee, (eg, with cached data) then
 297          * VMDisconnectedException will _not_ be thrown.
 298          * if (shutdown) {
 299          *    throw new VMDisconnectedException();
 300          * }
 301          */
 302     }
 303 
 304     public boolean equals(Object obj) {
 305         return this == obj;
 306     }
 307 
 308     public int hashCode() {
 309         return System.identityHashCode(this);
 310     }
 311 
 312     public List&lt;ModuleReference&gt; allModules() {
 313         validateVM();
 314         List&lt;ModuleReference&gt; modules = retrieveAllModules();
 315         return Collections.unmodifiableList(modules);
 316     }
 317 
<a name="2" id="anc2"></a><span class="line-removed"> 318      List&lt;ReferenceType&gt; classesBySignature(String signature) {</span>
<span class="line-removed"> 319         validateVM();</span>
<span class="line-removed"> 320         List&lt;ReferenceType&gt; list;</span>
<span class="line-removed"> 321         if (retrievedAllTypes) {</span>
<span class="line-removed"> 322             list = findReferenceTypes(signature);</span>
<span class="line-removed"> 323         } else {</span>
<span class="line-removed"> 324             list = retrieveClassesBySignature(signature);</span>
<span class="line-removed"> 325         }</span>
<span class="line-removed"> 326         return Collections.unmodifiableList(list);</span>
<span class="line-removed"> 327     }</span>
<span class="line-removed"> 328 </span>
 329     private static boolean isReferenceArray(String signature) {
 330         int i = signature.lastIndexOf(&#39;[&#39;);
 331         if (i &gt; -1 &amp;&amp; signature.charAt(i+1) == &#39;L&#39;) {
 332             return true;
 333         }
 334         return false;
 335     }
 336 
 337     public List&lt;ReferenceType&gt; classesByName(String className) {
 338         validateVM();
<a name="3" id="anc3"></a><span class="line-modified"> 339         String signature = JNITypeParser.typeNameToSignature(className);</span>




 340         List&lt;ReferenceType&gt; list;
 341         if (retrievedAllTypes) {
<a name="4" id="anc4"></a><span class="line-modified"> 342            list = findReferenceTypes(signature);</span>
 343         } else {
<a name="5" id="anc5"></a><span class="line-modified"> 344            list = retrieveClassesBySignature(signature);</span>
 345         }
 346         // HACK: add second request to cover the case where className
 347         // is the name of an inline type. This is done only if the
 348         // first signature is either a reference type or an array
 349         // of a reference type.
 350         if (signature.length() &gt; 1 &amp;&amp;
 351                 (signature.charAt(0) == &#39;L&#39; || isReferenceArray((signature)))) {
 352             List&lt;ReferenceType&gt; listInlineTypes;
<a name="6" id="anc6"></a><span class="line-modified"> 353             signature = JNITypeParser.inlineTypeNameToSignature(className);</span>
 354             if (retrievedAllTypes) {
 355                 listInlineTypes = findReferenceTypes(signature);
 356             } else {
 357                 listInlineTypes = retrieveClassesBySignature(signature);
 358             }
 359             if (!listInlineTypes.isEmpty()) {
 360                 list.addAll(listInlineTypes);
 361             }
 362         }
 363 
 364         return Collections.unmodifiableList(list);
 365     }
 366 
 367     public List&lt;ReferenceType&gt; allClasses() {
 368         validateVM();
 369 
 370         if (!retrievedAllTypes) {
 371             retrieveAllClasses();
 372         }
 373         ArrayList&lt;ReferenceType&gt; a;
 374         synchronized (this) {
 375             a = new ArrayList&lt;&gt;(typesBySignature);
 376         }
 377         return Collections.unmodifiableList(a);
 378     }
 379 
 380     /**
 381      * Performs an action for each loaded type.
 382      */
 383     public void forEachClass(Consumer&lt;ReferenceType&gt; action) {
 384         for (ReferenceType type : allClasses()) {
 385             try {
 386                 action.accept(type);
 387             } catch (ObjectCollectedException ex) {
 388                 // Some classes might be unloaded and garbage collected since
 389                 // we retrieved the copy of all loaded classes and started
 390                 // iterating over them. In this case calling methods on such types
 391                 // might result in com.sun.jdi.ObjectCollectedException
 392                 // being thrown. We ignore such classes and keep iterating.
 393                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {
 394                     vm.printTrace(&quot;ObjectCollectedException was thrown while &quot; +
 395                             &quot;accessing unloaded class &quot; + type.name());
 396                 }
 397             }
 398         }
 399     }
 400 
 401     public void
 402         redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes)
 403     {
 404         int cnt = classToBytes.size();
 405         JDWP.VirtualMachine.RedefineClasses.ClassDef[] defs =
 406             new JDWP.VirtualMachine.RedefineClasses.ClassDef[cnt];
 407         validateVM();
 408         if (!canRedefineClasses()) {
 409             throw new UnsupportedOperationException();
 410         }
 411         Iterator&lt;?&gt; it = classToBytes.entrySet().iterator();
 412         for (int i = 0; it.hasNext(); i++) {
 413             @SuppressWarnings(&quot;rawtypes&quot;)
 414             Map.Entry&lt;?, ?&gt; entry = (Map.Entry)it.next();
 415             ReferenceTypeImpl refType = (ReferenceTypeImpl)entry.getKey();
 416             validateMirror(refType);
 417             defs[i] = new JDWP.VirtualMachine.RedefineClasses
 418                        .ClassDef(refType, (byte[])entry.getValue());
 419         }
 420 
 421         // flush caches and disable caching until the next suspend
 422         vm.state().thaw();
 423 
 424         try {
 425             JDWP.VirtualMachine.RedefineClasses.
 426                 process(vm, defs);
 427         } catch (JDWPException exc) {
 428             switch (exc.errorCode()) {
 429             case JDWP.Error.INVALID_CLASS_FORMAT :
 430                 throw new ClassFormatError(
 431                     &quot;class not in class file format&quot;);
 432             case JDWP.Error.CIRCULAR_CLASS_DEFINITION :
 433                 throw new ClassCircularityError(
 434                     &quot;circularity has been detected while initializing a class&quot;);
 435             case JDWP.Error.FAILS_VERIFICATION :
 436                 throw new VerifyError(
 437                     &quot;verifier detected internal inconsistency or security problem&quot;);
 438             case JDWP.Error.UNSUPPORTED_VERSION :
 439                 throw new UnsupportedClassVersionError(
 440                     &quot;version numbers of class are not supported&quot;);
 441             case JDWP.Error.ADD_METHOD_NOT_IMPLEMENTED:
 442                 throw new UnsupportedOperationException(
 443                     &quot;add method not implemented&quot;);
 444             case JDWP.Error.SCHEMA_CHANGE_NOT_IMPLEMENTED :
 445                 throw new UnsupportedOperationException(
 446                     &quot;schema change not implemented&quot;);
 447             case JDWP.Error.HIERARCHY_CHANGE_NOT_IMPLEMENTED:
 448                 throw new UnsupportedOperationException(
 449                     &quot;hierarchy change not implemented&quot;);
 450             case JDWP.Error.DELETE_METHOD_NOT_IMPLEMENTED :
 451                 throw new UnsupportedOperationException(
 452                     &quot;delete method not implemented&quot;);
 453             case JDWP.Error.CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED:
 454                 throw new UnsupportedOperationException(
 455                     &quot;changes to class modifiers not implemented&quot;);
 456             case JDWP.Error.METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED :
 457                 throw new UnsupportedOperationException(
 458                     &quot;changes to method modifiers not implemented&quot;);
 459             case JDWP.Error.CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED :
 460                 throw new UnsupportedOperationException(
 461                     &quot;changes to class attribute not implemented&quot;);
 462             case JDWP.Error.NAMES_DONT_MATCH :
 463                 throw new NoClassDefFoundError(
 464                     &quot;class names do not match&quot;);
 465             default:
 466                 throw exc.toJDIException();
 467             }
 468         }
 469 
 470         // Delete any record of the breakpoints
 471         List&lt;BreakpointRequest&gt; toDelete = new ArrayList&lt;&gt;();
 472         EventRequestManager erm = eventRequestManager();
 473         it = erm.breakpointRequests().iterator();
 474         while (it.hasNext()) {
 475             BreakpointRequest req = (BreakpointRequest)it.next();
 476             if (classToBytes.containsKey(req.location().declaringType())) {
 477                 toDelete.add(req);
 478             }
 479         }
 480         erm.deleteEventRequests(toDelete);
 481 
 482         // Invalidate any information cached for the classes just redefined.
 483         it = classToBytes.keySet().iterator();
 484         while (it.hasNext()) {
 485             ReferenceTypeImpl rti = (ReferenceTypeImpl)it.next();
 486             rti.noticeRedefineClass();
 487         }
 488     }
 489 
 490     public List&lt;ThreadReference&gt; allThreads() {
 491         validateVM();
 492         return state.allThreads();
 493     }
 494 
 495     public List&lt;ThreadGroupReference&gt; topLevelThreadGroups() {
 496         validateVM();
 497         return state.topLevelThreadGroups();
 498     }
 499 
 500     /*
 501      * Sends a command to the back end which is defined to do an
 502      * implicit vm-wide resume. The VM can no longer be considered
 503      * suspended, so certain cached data must be invalidated.
 504      */
 505     PacketStream sendResumingCommand(CommandSender sender) {
 506         return state.thawCommand(sender);
 507     }
 508 
 509     /*
 510      * The VM has been suspended. Additional caching can be done
 511      * as long as there are no pending resumes.
 512      */
 513     void notifySuspend() {
 514         state.freeze();
 515     }
 516 
 517     public void suspend() {
 518         validateVM();
 519         try {
 520             JDWP.VirtualMachine.Suspend.process(vm);
 521         } catch (JDWPException exc) {
 522             throw exc.toJDIException();
 523         }
 524         notifySuspend();
 525     }
 526 
 527     public void resume() {
 528         validateVM();
 529         CommandSender sender =
 530             new CommandSender() {
 531                 public PacketStream send() {
 532                     return JDWP.VirtualMachine.Resume.enqueueCommand(vm);
 533                 }
 534         };
 535         try {
 536             PacketStream stream = state.thawCommand(sender);
 537             JDWP.VirtualMachine.Resume.waitForReply(vm, stream);
 538         } catch (VMDisconnectedException exc) {
 539             /*
 540              * If the debugger makes a VMDeathRequest with SUSPEND_ALL,
 541              * then when it does an EventSet.resume after getting the
 542              * VMDeathEvent, the normal flow of events is that the
 543              * BE shuts down, but the waitForReply comes back ok.  In this
 544              * case, the run loop in TargetVM that is waiting for a packet
 545              * gets an EOF because the socket closes. It generates a
 546              * VMDisconnectedEvent and everyone is happy.
 547              * However, sometimes, the BE gets shutdown before this
 548              * waitForReply completes.  In this case, TargetVM.waitForReply
 549              * gets awakened with no reply and so gens a VMDisconnectedException
 550              * which is not what we want.  It might be possible to fix this
 551              * in the BE, but it is ok to just ignore the VMDisconnectedException
 552              * here.  This will allow the VMDisconnectedEvent to be generated
 553              * correctly.  And, if the debugger should happen to make another
 554              * request, it will get a VMDisconnectedException at that time.
 555              */
 556         } catch (JDWPException exc) {
 557             switch (exc.errorCode()) {
 558                 case JDWP.Error.VM_DEAD:
 559                     return;
 560                 default:
 561                     throw exc.toJDIException();
 562             }
 563         }
 564     }
 565 
 566     public EventQueue eventQueue() {
 567         /*
 568          * No VM validation here. We allow access to the event queue
 569          * after disconnection, so that there is access to the terminating
 570          * events.
 571          */
 572         return eventQueue;
 573     }
 574 
 575     public EventRequestManager eventRequestManager() {
 576         validateVM();
 577         return eventRequestManager;
 578     }
 579 
 580     EventRequestManagerImpl eventRequestManagerImpl() {
 581         return eventRequestManager;
 582     }
 583 
 584     public BooleanValue mirrorOf(boolean value) {
 585         validateVM();
 586         return new BooleanValueImpl(this,value);
 587     }
 588 
 589     public ByteValue mirrorOf(byte value) {
 590         validateVM();
 591         return new ByteValueImpl(this,value);
 592     }
 593 
 594     public CharValue mirrorOf(char value) {
 595         validateVM();
 596         return new CharValueImpl(this,value);
 597     }
 598 
 599     public ShortValue mirrorOf(short value) {
 600         validateVM();
 601         return new ShortValueImpl(this,value);
 602     }
 603 
 604     public IntegerValue mirrorOf(int value) {
 605         validateVM();
 606         return new IntegerValueImpl(this,value);
 607     }
 608 
 609     public LongValue mirrorOf(long value) {
 610         validateVM();
 611         return new LongValueImpl(this,value);
 612     }
 613 
 614     public FloatValue mirrorOf(float value) {
 615         validateVM();
 616         return new FloatValueImpl(this,value);
 617     }
 618 
 619     public DoubleValue mirrorOf(double value) {
 620         validateVM();
 621         return new DoubleValueImpl(this,value);
 622     }
 623 
 624     public StringReference mirrorOf(String value) {
 625         validateVM();
 626         try {
 627             return JDWP.VirtualMachine.CreateString.
 628                 process(vm, value).stringObject;
 629         } catch (JDWPException exc) {
 630             throw exc.toJDIException();
 631         }
 632     }
 633 
 634     public VoidValue mirrorOfVoid() {
 635         if (voidVal == null) {
 636             voidVal = new VoidValueImpl(this);
 637         }
 638         return voidVal;
 639     }
 640 
 641     public long[] instanceCounts(List&lt;? extends ReferenceType&gt; classes) {
 642         if (!canGetInstanceInfo()) {
 643             throw new UnsupportedOperationException(
 644                 &quot;target does not support getting instances&quot;);
 645         }
 646         long[] retValue ;
 647         ReferenceTypeImpl[] rtArray = new ReferenceTypeImpl[classes.size()];
 648         int ii = 0;
 649         for (ReferenceType rti: classes) {
 650             validateMirror(rti);
 651             rtArray[ii++] = (ReferenceTypeImpl)rti;
 652         }
 653         try {
 654             retValue = JDWP.VirtualMachine.InstanceCounts.
 655                                 process(vm, rtArray).counts;
 656         } catch (JDWPException exc) {
 657             throw exc.toJDIException();
 658         }
 659 
 660         return retValue;
 661     }
 662 
 663     public void dispose() {
 664         validateVM();
 665         shutdown = true;
 666         try {
 667             JDWP.VirtualMachine.Dispose.process(vm);
 668         } catch (JDWPException exc) {
 669             throw exc.toJDIException();
 670         }
 671         target.stopListening();
 672     }
 673 
 674     public void exit(int exitCode) {
 675         validateVM();
 676         shutdown = true;
 677         try {
 678             JDWP.VirtualMachine.Exit.process(vm, exitCode);
 679         } catch (JDWPException exc) {
 680             throw exc.toJDIException();
 681         }
 682         target.stopListening();
 683     }
 684 
 685     public Process process() {
 686         validateVM();
 687         return process;
 688     }
 689 
 690     private JDWP.VirtualMachine.Version versionInfo() {
 691        try {
 692            if (versionInfo == null) {
 693                // Need not be synchronized since it is static information
 694                versionInfo = JDWP.VirtualMachine.Version.process(vm);
 695            }
 696            return versionInfo;
 697        } catch (JDWPException exc) {
 698            throw exc.toJDIException();
 699        }
 700     }
 701 
 702     public String description() {
 703         validateVM();
 704 
 705         return MessageFormat.format(vmManager.getString(&quot;version_format&quot;),
 706                                     &quot;&quot; + vmManager.majorInterfaceVersion(),
 707                                     &quot;&quot; + vmManager.minorInterfaceVersion(),
 708                                      versionInfo().description);
 709     }
 710 
 711     public String version() {
 712         validateVM();
 713         return versionInfo().vmVersion;
 714     }
 715 
 716     public String name() {
 717         validateVM();
 718         return versionInfo().vmName;
 719     }
 720 
 721     public boolean canWatchFieldModification() {
 722         validateVM();
 723         return capabilities().canWatchFieldModification;
 724     }
 725 
 726     public boolean canWatchFieldAccess() {
 727         validateVM();
 728         return capabilities().canWatchFieldAccess;
 729     }
 730 
 731     public boolean canGetBytecodes() {
 732         validateVM();
 733         return capabilities().canGetBytecodes;
 734     }
 735 
 736     public boolean canGetSyntheticAttribute() {
 737         validateVM();
 738         return capabilities().canGetSyntheticAttribute;
 739     }
 740 
 741     public boolean canGetOwnedMonitorInfo() {
 742         validateVM();
 743         return capabilities().canGetOwnedMonitorInfo;
 744     }
 745 
 746     public boolean canGetCurrentContendedMonitor() {
 747         validateVM();
 748         return capabilities().canGetCurrentContendedMonitor;
 749     }
 750 
 751     public boolean canGetMonitorInfo() {
 752         validateVM();
 753         return capabilities().canGetMonitorInfo;
 754     }
 755 
 756     private boolean hasNewCapabilities() {
 757         return versionInfo().jdwpMajor &gt; 1 ||
 758             versionInfo().jdwpMinor &gt;= 4;
 759     }
 760 
 761     boolean canGet1_5LanguageFeatures() {
 762         return versionInfo().jdwpMajor &gt; 1 ||
 763             versionInfo().jdwpMinor &gt;= 5;
 764     }
 765 
 766     public boolean canUseInstanceFilters() {
 767         validateVM();
 768         return hasNewCapabilities() &amp;&amp;
 769             capabilitiesNew().canUseInstanceFilters;
 770     }
 771 
 772     public boolean canRedefineClasses() {
 773         validateVM();
 774         return hasNewCapabilities() &amp;&amp;
 775             capabilitiesNew().canRedefineClasses;
 776     }
 777 
 778     public boolean canAddMethod() {
 779         validateVM();
 780         return hasNewCapabilities() &amp;&amp;
 781             capabilitiesNew().canAddMethod;
 782     }
 783 
 784     public boolean canUnrestrictedlyRedefineClasses() {
 785         validateVM();
 786         return hasNewCapabilities() &amp;&amp;
 787             capabilitiesNew().canUnrestrictedlyRedefineClasses;
 788     }
 789 
 790     public boolean canPopFrames() {
 791         validateVM();
 792         return hasNewCapabilities() &amp;&amp;
 793             capabilitiesNew().canPopFrames;
 794     }
 795 
 796     public boolean canGetMethodReturnValues() {
 797         return versionInfo().jdwpMajor &gt; 1 ||
 798             versionInfo().jdwpMinor &gt;= 6;
 799     }
 800 
 801     public boolean canGetInstanceInfo() {
 802         if (versionInfo().jdwpMajor &gt; 1 ||
 803             versionInfo().jdwpMinor &gt;= 6) {
 804             validateVM();
 805             return hasNewCapabilities() &amp;&amp;
 806                 capabilitiesNew().canGetInstanceInfo;
 807         } else {
 808             return false;
 809         }
 810     }
 811 
 812     public boolean canUseSourceNameFilters() {
 813         return versionInfo().jdwpMajor &gt; 1 ||
 814             versionInfo().jdwpMinor &gt;= 6;
 815     }
 816 
 817     public boolean canForceEarlyReturn() {
 818         validateVM();
 819         return hasNewCapabilities() &amp;&amp;
 820             capabilitiesNew().canForceEarlyReturn;
 821     }
 822 
 823     public boolean canBeModified() {
 824         return true;
 825     }
 826 
 827     public boolean canGetSourceDebugExtension() {
 828         validateVM();
 829         return hasNewCapabilities() &amp;&amp;
 830             capabilitiesNew().canGetSourceDebugExtension;
 831     }
 832 
 833     public boolean canGetClassFileVersion() {
 834         return versionInfo().jdwpMajor &gt; 1 ||
 835             versionInfo().jdwpMinor &gt;= 6;
 836     }
 837 
 838     public boolean canGetConstantPool() {
 839         validateVM();
 840         return hasNewCapabilities() &amp;&amp;
 841             capabilitiesNew().canGetConstantPool;
 842     }
 843 
 844     public boolean canRequestVMDeathEvent() {
 845         validateVM();
 846         return hasNewCapabilities() &amp;&amp;
 847             capabilitiesNew().canRequestVMDeathEvent;
 848     }
 849 
 850     public boolean canRequestMonitorEvents() {
 851         validateVM();
 852         return hasNewCapabilities() &amp;&amp;
 853             capabilitiesNew().canRequestMonitorEvents;
 854     }
 855 
 856     public boolean canGetMonitorFrameInfo() {
 857         validateVM();
 858         return hasNewCapabilities() &amp;&amp;
 859             capabilitiesNew().canGetMonitorFrameInfo;
 860     }
 861 
 862     public boolean canGetModuleInfo() {
 863         validateVM();
 864         return versionInfo().jdwpMajor &gt;= 9;
 865     }
 866 
 867     public void setDebugTraceMode(int traceFlags) {
 868         validateVM();
 869         this.traceFlags = traceFlags;
 870         this.traceReceives = (traceFlags &amp; TRACE_RECEIVES) != 0;
 871     }
 872 
 873     void printTrace(String string) {
 874         System.err.println(&quot;[JDI: &quot; + string + &quot;]&quot;);
 875     }
 876 
 877     void printReceiveTrace(int depth, String string) {
 878         StringBuilder sb = new StringBuilder(&quot;Receiving:&quot;);
 879         for (int i = depth; i &gt; 0; --i) {
 880             sb.append(&quot;    &quot;);
 881         }
 882         sb.append(string);
 883         printTrace(sb.toString());
 884     }
 885 
 886     private synchronized ReferenceTypeImpl addReferenceType(long id,
 887                                                             int tag,
 888                                                             String signature) {
 889         if (typesByID == null) {
 890             initReferenceTypes();
 891         }
 892         ReferenceTypeImpl type = null;
 893         switch(tag) {
 894             case JDWP.TypeTag.CLASS:
 895                 type = new ClassTypeImpl(vm, id);
 896                 break;
 897             case JDWP.TypeTag.INTERFACE:
 898                 type = new InterfaceTypeImpl(vm, id);
 899                 break;
 900             case JDWP.TypeTag.ARRAY:
 901                 type = new ArrayTypeImpl(vm, id);
 902                 break;
 903             default:
 904                 throw new InternalException(&quot;Invalid reference type tag&quot;);
 905         }
 906 
 907         if (signature == null &amp;&amp; retrievedAllTypes) {
 908             // do not cache if signature is not provided
 909             return type;
 910         }
 911 
 912         typesByID.put(id, type);
 913         typesBySignature.add(type);
 914 
 915         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 916            vm.printTrace(&quot;Caching new ReferenceType, sig=&quot; + signature +
 917                          &quot;, id=&quot; + id);
 918         }
 919 
 920         return type;
 921     }
 922 
 923     synchronized void removeReferenceType(String signature) {
 924         if (typesByID == null) {
 925             return;
 926         }
 927         /*
 928          * There can be multiple classes with the same name. Since
 929          * we can&#39;t differentiate here, we first remove all
 930          * matching classes from our cache...
 931          */
 932         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 933         int matches = 0;
 934         while (iter.hasNext()) {
 935             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 936             int comp = signature.compareTo(type.signature());
 937             if (comp == 0) {
 938                 matches++;
 939                 iter.remove();
 940                 typesByID.remove(type.ref());
 941                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 942                    vm.printTrace(&quot;Uncaching ReferenceType, sig=&quot; + signature +
 943                                  &quot;, id=&quot; + type.ref());
 944                 }
 945                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 946                 // in the order we think
 947             }
 948         }
 949 
 950         /*
 951          * ...and if there was more than one, re-retrieve the classes
 952          * with that name
 953          */
 954         if (matches &gt; 1) {
 955             retrieveClassesBySignature(signature);
 956         }
 957     }
 958 
 959     private synchronized List&lt;ReferenceType&gt; findReferenceTypes(String signature) {
 960         if (typesByID == null) {
 961             return new ArrayList&lt;&gt;(0);
 962         }
 963         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 964         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;();
 965         while (iter.hasNext()) {
 966             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 967             int comp = signature.compareTo(type.signature());
 968             if (comp == 0) {
 969                 list.add(type);
 970                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 971                 // in the order we think
 972             }
 973         }
 974         return list;
 975     }
 976 
 977     private void initReferenceTypes() {
 978         typesByID = new HashMap&lt;&gt;(300);
 979         typesBySignature = new HashSet&lt;&gt;();
 980     }
 981 
 982     ReferenceTypeImpl referenceType(long ref, byte tag) {
 983         return referenceType(ref, tag, null);
 984     }
 985 
 986     ClassTypeImpl classType(long ref) {
 987         return (ClassTypeImpl)referenceType(ref, JDWP.TypeTag.CLASS, null);
 988     }
 989 
 990     InterfaceTypeImpl interfaceType(long ref) {
 991         return (InterfaceTypeImpl)referenceType(ref, JDWP.TypeTag.INTERFACE, null);
 992     }
 993 
 994     ArrayTypeImpl arrayType(long ref) {
 995         return (ArrayTypeImpl)referenceType(ref, JDWP.TypeTag.ARRAY, null);
 996     }
 997 
 998     ReferenceTypeImpl referenceType(long id, int tag, String signature) {
 999         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1000             StringBuilder sb = new StringBuilder();
1001             sb.append(&quot;Looking up &quot;);
1002             if (tag == JDWP.TypeTag.CLASS) {
1003                 sb.append(&quot;Class&quot;);
1004             } else if (tag == JDWP.TypeTag.INTERFACE) {
1005                 sb.append(&quot;Interface&quot;);
1006             } else if (tag == JDWP.TypeTag.ARRAY) {
1007                 sb.append(&quot;ArrayType&quot;);
1008             } else {
1009                 sb.append(&quot;UNKNOWN TAG: &quot;).append(tag);
1010             }
1011             if (signature != null) {
1012                 sb.append(&quot;, signature=&#39;&quot;).append(signature).append(&#39;\&#39;&#39;);
1013             }
1014             sb.append(&quot;, id=&quot;).append(id);
1015             vm.printTrace(sb.toString());
1016         }
1017         if (id == 0) {
1018             return null;
1019         } else {
1020             ReferenceTypeImpl retType = null;
1021             synchronized (this) {
1022                 if (typesByID != null) {
1023                     retType = (ReferenceTypeImpl)typesByID.get(id);
1024                 }
1025                 if (retType == null) {
1026                     retType = addReferenceType(id, tag, signature);
1027                 }
1028                 if (signature != null) {
1029                     retType.setSignature(signature);
1030                 }
1031             }
1032             return retType;
1033         }
1034     }
1035 
1036     private JDWP.VirtualMachine.Capabilities capabilities() {
1037         if (capabilities == null) {
1038             try {
1039                 capabilities = JDWP.VirtualMachine
1040                                  .Capabilities.process(vm);
1041             } catch (JDWPException exc) {
1042                 throw exc.toJDIException();
1043             }
1044         }
1045         return capabilities;
1046     }
1047 
1048     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew() {
1049         if (capabilitiesNew == null) {
1050             try {
1051                 capabilitiesNew = JDWP.VirtualMachine
1052                                  .CapabilitiesNew.process(vm);
1053             } catch (JDWPException exc) {
1054                 throw exc.toJDIException();
1055             }
1056         }
1057         return capabilitiesNew;
1058     }
1059 
1060     private synchronized ModuleReference addModule(long id) {
1061         if (modulesByID == null) {
1062             modulesByID = new HashMap&lt;&gt;(77);
1063         }
1064         ModuleReference module = new ModuleReferenceImpl(vm, id);
1065         modulesByID.put(id, module);
1066         return module;
1067     }
1068 
1069     ModuleReference getModule(long id) {
1070         if (id == 0) {
1071             return null;
1072         } else {
1073             ModuleReference module = null;
1074             synchronized (this) {
1075                 if (modulesByID != null) {
1076                     module = modulesByID.get(id);
1077                 }
1078                 if (module == null) {
1079                     module = addModule(id);
1080                 }
1081             }
1082             return module;
1083         }
1084     }
1085 
1086     private synchronized List&lt;ModuleReference&gt; retrieveAllModules() {
1087         ModuleReferenceImpl[] reqModules;
1088         try {
1089             reqModules = JDWP.VirtualMachine.AllModules.process(vm).modules;
1090         } catch (JDWPException exc) {
1091             throw exc.toJDIException();
1092         }
1093         ArrayList&lt;ModuleReference&gt; modules = new ArrayList&lt;&gt;();
1094         for (int i = 0; i &lt; reqModules.length; i++) {
1095             long moduleRef = reqModules[i].ref();
1096             ModuleReference module = getModule(moduleRef);
1097             modules.add(module);
1098         }
1099         return modules;
1100     }
1101 
1102     private List&lt;ReferenceType&gt; retrieveClassesBySignature(String signature) {
1103         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1104             vm.printTrace(&quot;Retrieving matching ReferenceTypes, sig=&quot; + signature);
1105         }
1106         JDWP.VirtualMachine.ClassesBySignature.ClassInfo[] cinfos;
1107         try {
1108             cinfos = JDWP.VirtualMachine.ClassesBySignature.
1109                                       process(vm, signature).classes;
1110         } catch (JDWPException exc) {
1111             throw exc.toJDIException();
1112         }
1113 
1114         int count = cinfos.length;
1115         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;(count);
1116 
1117         // Hold lock during processing to improve performance
1118         synchronized (this) {
1119             for (int i = 0; i &lt; count; i++) {
1120                 JDWP.VirtualMachine.ClassesBySignature.ClassInfo ci =
1121                                                                cinfos[i];
1122                 ReferenceTypeImpl type = referenceType(ci.typeID,
1123                                                        ci.refTypeTag,
1124                                                        signature);
1125                 type.setStatus(ci.status);
1126                 list.add(type);
1127             }
1128         }
1129         return list;
1130     }
1131 
1132     private void retrieveAllClasses1_4() {
1133         JDWP.VirtualMachine.AllClasses.ClassInfo[] cinfos;
1134         try {
1135             cinfos = JDWP.VirtualMachine.AllClasses.process(vm).classes;
1136         } catch (JDWPException exc) {
1137             throw exc.toJDIException();
1138         }
1139 
1140         // Hold lock during processing to improve performance
1141         // and to have safe check/set of retrievedAllTypes
1142         synchronized (this) {
1143             if (!retrievedAllTypes) {
1144                 // Number of classes
1145                 int count = cinfos.length;
1146                 for (int i = 0; i &lt; count; i++) {
1147                     JDWP.VirtualMachine.AllClasses.ClassInfo ci = cinfos[i];
1148                     ReferenceTypeImpl type = referenceType(ci.typeID,
1149                                                            ci.refTypeTag,
1150                                                            ci.signature);
1151                     type.setStatus(ci.status);
1152                 }
1153                 retrievedAllTypes = true;
1154             }
1155         }
1156     }
1157 
1158     private void retrieveAllClasses() {
1159         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1160             vm.printTrace(&quot;Retrieving all ReferenceTypes&quot;);
1161         }
1162 
1163         if (!vm.canGet1_5LanguageFeatures()) {
1164             retrieveAllClasses1_4();
1165             return;
1166         }
1167 
1168         /*
1169          * To save time (assuming the caller will be
1170          * using then) we will get the generic sigs too.
1171          */
1172         JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo[] cinfos;
1173         try {
1174             cinfos = JDWP.VirtualMachine.AllClassesWithGeneric.process(vm).classes;
1175         } catch (JDWPException exc) {
1176             throw exc.toJDIException();
1177         }
1178 
1179         // Hold lock during processing to improve performance
1180         // and to have safe check/set of retrievedAllTypes
1181         synchronized (this) {
1182             if (!retrievedAllTypes) {
1183                 // Number of classes
1184                 int count = cinfos.length;
1185                 for (int i = 0; i &lt; count; i++) {
1186                     JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo ci =
1187                                                                cinfos[i];
1188                     ReferenceTypeImpl type = referenceType(ci.typeID,
1189                                                            ci.refTypeTag,
1190                                                            ci.signature);
1191                     type.setGenericSignature(ci.genericSignature);
1192                     type.setStatus(ci.status);
1193                 }
1194                 retrievedAllTypes = true;
1195             }
1196         }
1197     }
1198 
1199     void sendToTarget(Packet packet) {
1200         target.send(packet);
1201     }
1202 
1203     void waitForTargetReply(Packet packet) {
1204         target.waitForReply(packet);
1205         /*
1206          * If any object disposes have been batched up, send them now.
1207          */
1208         processBatchedDisposes();
1209     }
1210 
1211     Type findBootType(String signature) throws ClassNotLoadedException {
1212         List&lt;ReferenceType&gt; types = retrieveClassesBySignature(signature);
1213         Iterator&lt;ReferenceType&gt; iter = types.iterator();
1214         while (iter.hasNext()) {
1215             ReferenceType type = iter.next();
1216             if (type.classLoader() == null) {
1217                 return type;
1218             }
1219         }
1220         JNITypeParser parser = new JNITypeParser(signature);
1221         throw new ClassNotLoadedException(parser.typeName(),
1222                                          &quot;Type &quot; + parser.typeName() + &quot; not loaded&quot;);
1223     }
1224 
1225     BooleanType theBooleanType() {
1226         if (theBooleanType == null) {
1227             synchronized(this) {
1228                 if (theBooleanType == null) {
1229                     theBooleanType = new BooleanTypeImpl(this);
1230                 }
1231             }
1232         }
1233         return theBooleanType;
1234     }
1235 
1236     ByteType theByteType() {
1237         if (theByteType == null) {
1238             synchronized(this) {
1239                 if (theByteType == null) {
1240                     theByteType = new ByteTypeImpl(this);
1241                 }
1242             }
1243         }
1244         return theByteType;
1245     }
1246 
1247     CharType theCharType() {
1248         if (theCharType == null) {
1249             synchronized(this) {
1250                 if (theCharType == null) {
1251                     theCharType = new CharTypeImpl(this);
1252                 }
1253             }
1254         }
1255         return theCharType;
1256     }
1257 
1258     ShortType theShortType() {
1259         if (theShortType == null) {
1260             synchronized(this) {
1261                 if (theShortType == null) {
1262                     theShortType = new ShortTypeImpl(this);
1263                 }
1264             }
1265         }
1266         return theShortType;
1267     }
1268 
1269     IntegerType theIntegerType() {
1270         if (theIntegerType == null) {
1271             synchronized(this) {
1272                 if (theIntegerType == null) {
1273                     theIntegerType = new IntegerTypeImpl(this);
1274                 }
1275             }
1276         }
1277         return theIntegerType;
1278     }
1279 
1280     LongType theLongType() {
1281         if (theLongType == null) {
1282             synchronized(this) {
1283                 if (theLongType == null) {
1284                     theLongType = new LongTypeImpl(this);
1285                 }
1286             }
1287         }
1288         return theLongType;
1289     }
1290 
1291     FloatType theFloatType() {
1292         if (theFloatType == null) {
1293             synchronized(this) {
1294                 if (theFloatType == null) {
1295                     theFloatType = new FloatTypeImpl(this);
1296                 }
1297             }
1298         }
1299         return theFloatType;
1300     }
1301 
1302     DoubleType theDoubleType() {
1303         if (theDoubleType == null) {
1304             synchronized(this) {
1305                 if (theDoubleType == null) {
1306                     theDoubleType = new DoubleTypeImpl(this);
1307                 }
1308             }
1309         }
1310         return theDoubleType;
1311     }
1312 
1313     VoidType theVoidType() {
1314         if (theVoidType == null) {
1315             synchronized(this) {
1316                 if (theVoidType == null) {
1317                     theVoidType = new VoidTypeImpl(this);
1318                 }
1319             }
1320         }
1321         return theVoidType;
1322     }
1323 
1324     PrimitiveType primitiveTypeMirror(byte tag) {
1325         switch (tag) {
1326             case JDWP.Tag.BOOLEAN:
1327                 return theBooleanType();
1328             case JDWP.Tag.BYTE:
1329                 return theByteType();
1330             case JDWP.Tag.CHAR:
1331                 return theCharType();
1332             case JDWP.Tag.SHORT:
1333                 return theShortType();
1334             case JDWP.Tag.INT:
1335                 return theIntegerType();
1336             case JDWP.Tag.LONG:
1337                 return theLongType();
1338             case JDWP.Tag.FLOAT:
1339                 return theFloatType();
1340             case JDWP.Tag.DOUBLE:
1341                 return theDoubleType();
1342             default:
1343                 throw new IllegalArgumentException(&quot;Unrecognized primitive tag &quot; + tag);
1344         }
1345     }
1346 
1347     private void processBatchedDisposes() {
1348         if (shutdown) {
1349             return;
1350         }
1351 
1352         JDWP.VirtualMachine.DisposeObjects.Request[] requests = null;
1353         synchronized(batchedDisposeRequests) {
1354             int size = batchedDisposeRequests.size();
1355             if (size &gt;= DISPOSE_THRESHOLD) {
1356                 if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1357                     printTrace(&quot;Dispose threashold reached. Will dispose &quot;
1358                                + size + &quot; object references...&quot;);
1359                 }
1360                 requests = new JDWP.VirtualMachine.DisposeObjects.Request[size];
1361                 for (int i = 0; i &lt; requests.length; i++) {
1362                     SoftObjectReference ref = batchedDisposeRequests.get(i);
1363                     if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1364                         printTrace(&quot;Disposing object &quot; + ref.key().longValue() +
1365                                    &quot; (ref count = &quot; + ref.count() + &quot;)&quot;);
1366                     }
1367 
1368                     // This is kludgy. We temporarily re-create an object
1369                     // reference so that we can correctly pass its id to the
1370                     // JDWP command.
1371                     requests[i] =
1372                         new JDWP.VirtualMachine.DisposeObjects.Request(
1373                             new ObjectReferenceImpl(this, ref.key().longValue()),
1374                             ref.count());
1375                 }
1376                 batchedDisposeRequests.clear();
1377             }
1378         }
1379         if (requests != null) {
1380             try {
1381                 JDWP.VirtualMachine.DisposeObjects.process(vm, requests);
1382             } catch (JDWPException exc) {
1383                 throw exc.toJDIException();
1384             }
1385         }
1386     }
1387 
1388     private void batchForDispose(SoftObjectReference ref) {
1389         if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1390             printTrace(&quot;Batching object &quot; + ref.key().longValue() +
1391                        &quot; for dispose (ref count = &quot; + ref.count() + &quot;)&quot;);
1392         }
1393         batchedDisposeRequests.add(ref);
1394     }
1395 
1396     private void processQueue() {
1397         Reference&lt;?&gt; ref;
1398         //if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1399         //    printTrace(&quot;Checking for softly reachable objects&quot;);
1400         //}
1401         while ((ref = referenceQueue.poll()) != null) {
1402             SoftObjectReference softRef = (SoftObjectReference)ref;
1403             removeObjectMirror(softRef);
1404             batchForDispose(softRef);
1405         }
1406     }
1407 
1408     synchronized ObjectReferenceImpl objectMirror(long id, int tag) {
1409 
1410         // Handle any queue elements that are not strongly reachable
1411         processQueue();
1412 
1413         if (id == 0) {
1414             return null;
1415         }
1416         ObjectReferenceImpl object = null;
1417         Long key = id;
1418 
1419         /*
1420          * Attempt to retrieve an existing object reference
1421          */
1422         SoftObjectReference ref = objectsByID.get(key);
1423         if (ref != null) {
1424             object = ref.object();
1425         }
1426 
1427         /*
1428          * If the object wasn&#39;t in the table, or it&#39;s soft reference was
1429          * cleared, create a new instance.
1430          */
1431         if (object == null) {
1432             switch (tag) {
1433                 case JDWP.Tag.OBJECT:
1434                 case JDWP.Tag.INLINE_OBJECT:
1435                     object = new ObjectReferenceImpl(vm, id);
1436                     break;
1437                 case JDWP.Tag.STRING:
1438                     object = new StringReferenceImpl(vm, id);
1439                     break;
1440                 case JDWP.Tag.ARRAY:
1441                     object = new ArrayReferenceImpl(vm, id);
1442                     break;
1443                 case JDWP.Tag.THREAD:
1444                     ThreadReferenceImpl thread =
1445                         new ThreadReferenceImpl(vm, id);
1446                     thread.addListener(this);
1447                     object = thread;
1448                     break;
1449                 case JDWP.Tag.THREAD_GROUP:
1450                     object = new ThreadGroupReferenceImpl(vm, id);
1451                     break;
1452                 case JDWP.Tag.CLASS_LOADER:
1453                     object = new ClassLoaderReferenceImpl(vm, id);
1454                     break;
1455                 case JDWP.Tag.CLASS_OBJECT:
1456                     object = new ClassObjectReferenceImpl(vm, id);
1457                     break;
1458                 default:
1459                     throw new IllegalArgumentException(&quot;Invalid object tag: &quot; + tag);
1460             }
1461             ref = new SoftObjectReference(key, object, referenceQueue);
1462 
1463             /*
1464              * If there was no previous entry in the table, we add one here
1465              * If the previous entry was cleared, we replace it here.
1466              */
1467             objectsByID.put(key, ref);
1468             if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1469                 printTrace(&quot;Creating new &quot; +
1470                            object.getClass().getName() + &quot; (id = &quot; + id + &quot;)&quot;);
1471             }
1472         } else {
1473             ref.incrementCount();
1474         }
1475 
1476         return object;
1477     }
1478 
1479     synchronized void removeObjectMirror(ObjectReferenceImpl object) {
1480         // Handle any queue elements that are not strongly reachable
1481         processQueue();
1482 
1483         SoftObjectReference ref = objectsByID.remove(object.ref());
1484         if (ref != null) {
1485             batchForDispose(ref);
1486         } else {
1487             /*
1488              * If there&#39;s a live ObjectReference about, it better be part
1489              * of the cache.
1490              */
1491             throw new InternalException(&quot;ObjectReference &quot; + object.ref() +
1492                                         &quot; not found in object cache&quot;);
1493         }
1494     }
1495 
1496     synchronized void removeObjectMirror(SoftObjectReference ref) {
1497         /*
1498          * This will remove the soft reference if it has not been
1499          * replaced in the cache.
1500          */
1501         objectsByID.remove(ref.key());
1502     }
1503 
1504     ObjectReferenceImpl objectMirror(long id) {
1505         return objectMirror(id, JDWP.Tag.OBJECT);
1506     }
1507 
1508     StringReferenceImpl stringMirror(long id) {
1509         return (StringReferenceImpl)objectMirror(id, JDWP.Tag.STRING);
1510     }
1511 
1512     ArrayReferenceImpl arrayMirror(long id) {
1513        return (ArrayReferenceImpl)objectMirror(id, JDWP.Tag.ARRAY);
1514     }
1515 
1516     ThreadReferenceImpl threadMirror(long id) {
1517         return (ThreadReferenceImpl)objectMirror(id, JDWP.Tag.THREAD);
1518     }
1519 
1520     ThreadGroupReferenceImpl threadGroupMirror(long id) {
1521         return (ThreadGroupReferenceImpl)objectMirror(id,
1522                                                       JDWP.Tag.THREAD_GROUP);
1523     }
1524 
1525     ClassLoaderReferenceImpl classLoaderMirror(long id) {
1526         return (ClassLoaderReferenceImpl)objectMirror(id,
1527                                                       JDWP.Tag.CLASS_LOADER);
1528     }
1529 
1530     ClassObjectReferenceImpl classObjectMirror(long id) {
1531         return (ClassObjectReferenceImpl)objectMirror(id,
1532                                                       JDWP.Tag.CLASS_OBJECT);
1533     }
1534 
1535     ModuleReferenceImpl moduleMirror(long id) {
1536         return (ModuleReferenceImpl)getModule(id);
1537     }
1538 
1539     /*
1540      * Implementation of PathSearchingVirtualMachine
1541      */
1542     private JDWP.VirtualMachine.ClassPaths getClasspath() {
1543         if (pathInfo == null) {
1544             try {
1545                 pathInfo = JDWP.VirtualMachine.ClassPaths.process(vm);
1546             } catch (JDWPException exc) {
1547                 throw exc.toJDIException();
1548             }
1549         }
1550         return pathInfo;
1551     }
1552 
1553    public List&lt;String&gt; classPath() {
1554        return Arrays.asList(getClasspath().classpaths);
1555    }
1556 
1557    public List&lt;String&gt; bootClassPath() {
1558        return Collections.emptyList();
1559    }
1560 
1561    public String baseDirectory() {
1562        return getClasspath().baseDir;
1563    }
1564 
1565     public void setDefaultStratum(String stratum) {
1566         defaultStratum = stratum;
1567         if (stratum == null) {
1568             stratum = &quot;&quot;;
1569         }
1570         try {
1571             JDWP.VirtualMachine.SetDefaultStratum.process(vm,
1572                                                           stratum);
1573         } catch (JDWPException exc) {
1574             throw exc.toJDIException();
1575         }
1576     }
1577 
1578     public String getDefaultStratum() {
1579         return defaultStratum;
1580     }
1581 
1582     ThreadGroup threadGroupForJDI() {
1583         return threadGroupForJDI;
1584     }
1585 
1586    static private class SoftObjectReference extends SoftReference&lt;ObjectReferenceImpl&gt; {
1587        int count;
1588        Long key;
1589 
1590        SoftObjectReference(Long key, ObjectReferenceImpl mirror,
1591                            ReferenceQueue&lt;ObjectReferenceImpl&gt; queue) {
1592            super(mirror, queue);
1593            this.count = 1;
1594            this.key = key;
1595        }
1596 
1597        int count() {
1598            return count;
1599        }
1600 
1601        void incrementCount() {
1602            count++;
1603        }
1604 
1605        Long key() {
1606            return key;
1607        }
1608 
1609        ObjectReferenceImpl object() {
1610            return get();
1611        }
1612    }
1613 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.ArrayDeque;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;
<a name="1" id="anc1"></a><span class="line-removed">  40 import java.util.Comparator;</span>
  41 import java.util.Deque;
  42 import java.util.EnumSet;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.Iterator;
  46 import java.util.LinkedHashMap;
  47 import java.util.LinkedHashSet;
  48 import java.util.List;
  49 import java.util.Locale;
  50 import java.util.Map;
  51 import java.util.Map.Entry;
  52 import java.util.Objects;
  53 import java.util.Set;
  54 import java.util.SortedSet;
  55 import java.util.TreeMap;
  56 import java.util.TreeSet;
  57 import java.util.function.Predicate;
  58 import java.util.stream.Collectors;
  59 
  60 import javax.lang.model.SourceVersion;
  61 import javax.lang.model.element.AnnotationMirror;
  62 import javax.lang.model.element.AnnotationValue;
  63 import javax.lang.model.element.Element;
  64 import javax.lang.model.element.ElementKind;
  65 import javax.lang.model.element.ExecutableElement;
  66 import javax.lang.model.element.Modifier;
  67 import javax.lang.model.element.ModuleElement;
  68 import javax.lang.model.element.ModuleElement.RequiresDirective;
  69 import javax.lang.model.element.PackageElement;
  70 import javax.lang.model.element.RecordComponentElement;
  71 import javax.lang.model.element.TypeElement;
  72 import javax.lang.model.element.TypeParameterElement;
  73 import javax.lang.model.element.VariableElement;
  74 import javax.lang.model.type.ArrayType;
  75 import javax.lang.model.type.DeclaredType;
  76 import javax.lang.model.type.ErrorType;
  77 import javax.lang.model.type.ExecutableType;
  78 import javax.lang.model.type.NoType;
  79 import javax.lang.model.type.PrimitiveType;
  80 import javax.lang.model.type.TypeMirror;
  81 import javax.lang.model.type.TypeVariable;
  82 import javax.lang.model.type.WildcardType;
  83 import javax.lang.model.util.ElementFilter;
  84 import javax.lang.model.util.ElementKindVisitor14;
  85 import javax.lang.model.util.Elements;
  86 import javax.lang.model.util.SimpleElementVisitor14;
  87 import javax.lang.model.util.SimpleTypeVisitor9;
  88 import javax.lang.model.util.TypeKindVisitor9;
  89 import javax.lang.model.util.Types;
  90 import javax.tools.FileObject;
  91 import javax.tools.JavaFileManager;
  92 import javax.tools.JavaFileManager.Location;
  93 import javax.tools.StandardLocation;
  94 
  95 import com.sun.source.doctree.DocCommentTree;
  96 import com.sun.source.doctree.DocTree;
  97 import com.sun.source.doctree.DocTree.Kind;
  98 import com.sun.source.doctree.EndElementTree;
  99 import com.sun.source.doctree.ParamTree;
<a name="2" id="anc2"></a><span class="line-removed"> 100 import com.sun.source.doctree.SerialFieldTree;</span>
 101 import com.sun.source.doctree.StartElementTree;
 102 import com.sun.source.doctree.TextTree;
 103 import com.sun.source.doctree.UnknownBlockTagTree;
 104 import com.sun.source.tree.CompilationUnitTree;
 105 import com.sun.source.tree.LineMap;
 106 import com.sun.source.util.DocSourcePositions;
 107 import com.sun.source.util.DocTrees;
 108 import com.sun.source.util.TreePath;
 109 import com.sun.tools.javac.model.JavacTypes;
<a name="3" id="anc3"></a><span class="line-removed"> 110 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;</span>
 111 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 112 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 113 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
<a name="4" id="anc4"></a><span class="line-removed"> 114 import jdk.javadoc.internal.doclets.toolkit.Messages;</span>
 115 import jdk.javadoc.internal.doclets.toolkit.Resources;
 116 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 117 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 118 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 119 import jdk.javadoc.internal.tool.DocEnvImpl;
 120 
 121 import static javax.lang.model.element.ElementKind.*;
 122 import static javax.lang.model.element.Modifier.*;
 123 import static javax.lang.model.type.TypeKind.*;
 124 
 125 import static com.sun.source.doctree.DocTree.Kind.*;
 126 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 127 
 128 /**
 129  * Utilities Class for Doclets.
 130  *
 131  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 132  *  If you write code that depends on this, you do so at your own risk.
 133  *  This code and its internal interfaces are subject to change or
 134  *  deletion without notice.&lt;/b&gt;
 135  */
 136 public class Utils {
 137     public final BaseConfiguration configuration;
 138     private final BaseOptions options;
<a name="5" id="anc5"></a><span class="line-removed"> 139     private final Messages messages;</span>
 140     private final Resources resources;
 141     public final DocTrees docTrees;
 142     public final Elements elementUtils;
 143     public final Types typeUtils;
<a name="6" id="anc6"></a>
 144     private final JavaScriptScanner javaScriptScanner;
 145 
 146     public Utils(BaseConfiguration c) {
 147         configuration = c;
 148         options = configuration.getOptions();
<a name="7" id="anc7"></a><span class="line-removed"> 149         messages = configuration.getMessages();</span>
 150         resources = configuration.getDocResources();
 151         elementUtils = c.docEnv.getElementUtils();
 152         typeUtils = c.docEnv.getTypeUtils();
 153         docTrees = c.docEnv.getDocTrees();
 154         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
<a name="8" id="anc8"></a>
 155     }
 156 
 157     // our own little symbol table
 158     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 159 
 160     public TypeMirror getSymbol(String signature) {
 161         TypeMirror type = symtab.get(signature);
 162         if (type == null) {
 163             TypeElement typeElement = elementUtils.getTypeElement(signature);
 164             if (typeElement == null)
 165                 return null;
 166             type = typeElement.asType();
 167             if (type == null)
 168                 return null;
 169             symtab.put(signature, type);
 170         }
 171         return type;
 172     }
 173 
 174     public TypeMirror getObjectType() {
 175         return getSymbol(&quot;java.lang.Object&quot;);
 176     }
 177 
 178     public TypeMirror getExceptionType() {
 179         return getSymbol(&quot;java.lang.Exception&quot;);
 180     }
 181 
 182     public TypeMirror getErrorType() {
 183         return getSymbol(&quot;java.lang.Error&quot;);
 184     }
 185 
 186     public TypeMirror getSerializableType() {
 187         return getSymbol(&quot;java.io.Serializable&quot;);
 188     }
 189 
 190     public TypeMirror getExternalizableType() {
 191         return getSymbol(&quot;java.io.Externalizable&quot;);
 192     }
 193 
 194     public TypeMirror getIllegalArgumentExceptionType() {
 195         return getSymbol(&quot;java.lang.IllegalArgumentException&quot;);
 196     }
 197 
 198     public TypeMirror getNullPointerExceptionType() {
 199         return getSymbol(&quot;java.lang.NullPointerException&quot;);
 200     }
 201 
 202     public TypeMirror getDeprecatedType() {
 203         return getSymbol(&quot;java.lang.Deprecated&quot;);
 204     }
 205 
 206     public TypeMirror getFunctionalInterface() {
 207         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 208     }
 209 
 210     /**
 211      * Return array of class members whose documentation is to be generated.
 212      * If the member is deprecated do not include such a member in the
 213      * returned array.
 214      *
 215      * @param  members    Array of members to choose from.
 216      * @return List       List of eligible members for whom
 217      *                    documentation is getting generated.
 218      */
 219     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
 220         return members.stream()
 221                       .filter(member -&gt; !isDeprecated(member))
<a name="9" id="anc9"></a><span class="line-modified"> 222                       .sorted(makeGeneralPurposeComparator())</span>
 223                       .collect(Collectors.toCollection(ArrayList::new));
 224     }
 225 
 226     /**
 227      * Search for the given method in the given class.
 228      *
 229      * @param  te        Class to search into.
 230      * @param  method    Method to be searched.
 231      * @return ExecutableElement Method found, null otherwise.
 232      */
 233     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 234         for (Element m : getMethods(te)) {
 235             if (executableMembersEqual(method, (ExecutableElement) m)) {
 236                 return (ExecutableElement) m;
 237             }
 238         }
 239         return null;
 240     }
 241 
 242     /**
 243      * Test whether a class is a subclass of another class.
 244      *
 245      * @param t1 the candidate superclass.
 246      * @param t2 the target
 247      * @return true if t1 is a superclass of t2.
 248      */
 249     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 250         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 251     }
 252 
 253     /**
 254      * @param e1 the first method to compare.
 255      * @param e2 the second method to compare.
 256      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 257      */
 258     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 259         // TODO: investigate if Elements.hides(..) will work here.
 260         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 261             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 262             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 263             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 264                     parameters1.size() == parameters2.size()) {
 265                 int j;
 266                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 267                     VariableElement v1 = parameters1.get(j);
 268                     VariableElement v2 = parameters2.get(j);
 269                     String t1 = getTypeName(v1.asType(), true);
 270                     String t2 = getTypeName(v2.asType(), true);
 271                     if (!(t1.equals(t2) ||
 272                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 273                         break;
 274                     }
 275                 }
 276                 if (j == parameters1.size()) {
 277                     return true;
 278                 }
 279             }
 280             return false;
 281         } else {
 282             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 283                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 284                     e1.equals(e2);
 285         }
 286     }
 287 
 288     /**
 289      * According to
 290      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 291      * all the outer classes and static inner classes are core classes.
 292      */
 293     public boolean isCoreClass(TypeElement e) {
 294         return getEnclosingTypeElement(e) == null || isStatic(e);
 295     }
 296 
 297     public Location getLocationForPackage(PackageElement pd) {
 298         ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(pd);
 299 
 300         if (mdle == null)
 301             return defaultLocation();
 302 
 303         return getLocationForModule(mdle);
 304     }
 305 
 306     public Location getLocationForModule(ModuleElement mdle) {
 307         Location loc = configuration.workArounds.getLocationForModule(mdle);
 308         if (loc != null)
 309             return loc;
 310 
 311         return defaultLocation();
 312     }
 313 
 314     private Location defaultLocation() {
 315         JavaFileManager fm = configuration.docEnv.getJavaFileManager();
 316         return fm.hasLocation(StandardLocation.SOURCE_PATH)
 317                 ? StandardLocation.SOURCE_PATH
 318                 : StandardLocation.CLASS_PATH;
 319     }
 320 
 321     public boolean isAnnotated(TypeMirror e) {
 322         return !e.getAnnotationMirrors().isEmpty();
 323     }
 324 
 325     public boolean isAnnotated(Element e) {
 326         return !e.getAnnotationMirrors().isEmpty();
 327     }
 328 
 329     @SuppressWarnings(&quot;preview&quot;)
 330     public boolean isAnnotationType(Element e) {
 331         return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
 332             @Override
 333             public Boolean visitExecutable(ExecutableElement e, Void p) {
 334                 return visit(e.getEnclosingElement());
 335             }
 336 
 337             @Override
 338             public Boolean visitUnknown(Element e, Void p) {
 339                 return false;
 340             }
 341 
 342             @Override
 343             protected Boolean defaultAction(Element e, Void p) {
 344                 return e.getKind() == ANNOTATION_TYPE;
 345             }
 346         }.visit(e);
 347     }
 348 
 349     /**
 350      * An Enum implementation is almost identical, thus this method returns if
 351      * this element represents a CLASS or an ENUM
 352      * @param e element
 353      * @return true if class or enum
 354      */
 355     public boolean isClass(Element e) {
 356         return e.getKind().isClass();
 357     }
 358 
 359     public boolean isConstructor(Element e) {
 360          return e.getKind() == CONSTRUCTOR;
 361     }
 362 
 363     public boolean isEnum(Element e) {
 364         return e.getKind() == ENUM;
 365     }
 366 
 367     boolean isEnumConstant(Element e) {
 368         return e.getKind() == ENUM_CONSTANT;
 369     }
 370 
 371     public boolean isField(Element e) {
 372         return e.getKind() == FIELD;
 373     }
 374 
 375     public boolean isInterface(Element e) {
 376         return e.getKind() == INTERFACE;
 377     }
 378 
 379     public boolean isMethod(Element e) {
 380         return e.getKind() == METHOD;
 381     }
 382 
 383     public boolean isModule(Element e) {
 384         return e.getKind() == ElementKind.MODULE;
 385     }
 386 
 387     public boolean isPackage(Element e) {
 388         return e.getKind() == ElementKind.PACKAGE;
 389     }
 390 
 391     public boolean isAbstract(Element e) {
 392         return e.getModifiers().contains(Modifier.ABSTRACT);
 393     }
 394 
 395     public boolean isDefault(Element e) {
 396         return e.getModifiers().contains(Modifier.DEFAULT);
 397     }
 398 
 399     public boolean isPackagePrivate(Element e) {
 400         return !(isPublic(e) || isPrivate(e) || isProtected(e));
 401     }
 402 
 403     public boolean isPrivate(Element e) {
 404         return e.getModifiers().contains(Modifier.PRIVATE);
 405     }
 406 
 407     public boolean isProtected(Element e) {
 408         return e.getModifiers().contains(Modifier.PROTECTED);
 409     }
 410 
 411     public boolean isPublic(Element e) {
 412         return e.getModifiers().contains(Modifier.PUBLIC);
 413     }
 414 
 415     public boolean isProperty(String name) {
 416         return options.javafx() &amp;&amp; name.endsWith(&quot;Property&quot;);
 417     }
 418 
 419     public String getPropertyName(String name) {
 420         return isProperty(name)
 421                 ? name.substring(0, name.length() - &quot;Property&quot;.length())
 422                 : name;
 423     }
 424 
 425     public String getPropertyLabel(String name) {
 426         return name.substring(0, name.lastIndexOf(&quot;Property&quot;));
 427     }
 428 
 429     public boolean isOverviewElement(Element e) {
 430         return e.getKind() == ElementKind.OTHER;
 431     }
 432 
 433     public boolean isStatic(Element e) {
 434         return e.getModifiers().contains(Modifier.STATIC);
 435     }
 436 
 437     public boolean isSerializable(TypeElement e) {
 438         return typeUtils.isSubtype(e.asType(), getSerializableType());
 439     }
 440 
 441     public boolean isExternalizable(TypeElement e) {
 442         return typeUtils.isSubtype(e.asType(), getExternalizableType());
 443     }
 444 
 445     @SuppressWarnings(&quot;preview&quot;)
 446     public boolean isRecord(TypeElement e) {
 447         return e.getKind() == ElementKind.RECORD;
 448     }
 449 
 450     @SuppressWarnings(&quot;preview&quot;)
 451     public boolean isCanonicalRecordConstructor(ExecutableElement ee) {
 452         TypeElement te = (TypeElement) ee.getEnclosingElement();
 453         List&lt;? extends RecordComponentElement&gt; stateComps = te.getRecordComponents();
 454         List&lt;? extends VariableElement&gt; params = ee.getParameters();
 455         if (stateComps.size() != params.size()) {
 456             return false;
 457         }
 458 
 459         Iterator&lt;? extends RecordComponentElement&gt; stateIter = stateComps.iterator();
 460         Iterator&lt;? extends VariableElement&gt; paramIter = params.iterator();
 461         while (paramIter.hasNext() &amp;&amp; stateIter.hasNext()) {
 462             VariableElement param = paramIter.next();
 463             RecordComponentElement comp = stateIter.next();
 464             if (!Objects.equals(param.getSimpleName(), comp.getSimpleName())
 465                     || !typeUtils.isSameType(param.asType(), comp.asType())) {
 466                 return false;
 467             }
 468         }
 469 
 470         return true;
 471     }
 472 
 473     public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
 474         return configuration.workArounds.getSerializableFields(aclass);
 475     }
 476 
 477     public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
 478         return configuration.workArounds.getSerializationMethods(aclass);
 479     }
 480 
 481     public boolean definesSerializableFields(TypeElement aclass) {
 482         return configuration.workArounds.definesSerializableFields( aclass);
 483     }
 484 
 485     @SuppressWarnings(&quot;preview&quot;)
 486     public String modifiersToString(Element e, boolean trailingSpace) {
 487         SortedSet&lt;Modifier&gt; modifiers = new TreeSet&lt;&gt;(e.getModifiers());
 488         modifiers.remove(NATIVE);
 489         modifiers.remove(STRICTFP);
 490         modifiers.remove(SYNCHRONIZED);
 491 
 492         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 493             final StringBuilder sb = new StringBuilder();
 494 
 495             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 496                 if (modifiers.contains(PUBLIC)) {
 497                     append(&quot;public&quot;);
 498                 } else if (modifiers.contains(PROTECTED)) {
 499                     append(&quot;protected&quot;);
 500                 } else if (modifiers.contains(PRIVATE)) {
 501                     append(&quot;private&quot;);
 502                 }
 503             }
 504 
 505             void addStatic(Set&lt;Modifier&gt; modifiers) {
 506                 if (modifiers.contains(STATIC)) {
 507                     append(&quot;static&quot;);
 508                 }
 509             }
 510 
 511             void addModifiers(Set&lt;Modifier&gt; modifiers) {
 512                 modifiers.stream().map(Modifier::toString).forEachOrdered(this::append);
 513             }
 514 
 515             void append(String s) {
 516                 if (sb.length() &gt; 0) {
 517                     sb.append(&quot; &quot;);
 518                 }
 519                 sb.append(s);
 520             }
 521 
 522             String finalString(String s) {
 523                 append(s);
 524                 if (trailingSpace) {
 525                     sb.append(&quot; &quot;);
 526                 }
 527                 return sb.toString();
 528             }
 529 
 530             @Override
 531             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 532                 addVisibilityModifier(mods);
 533                 addStatic(mods);
 534                 return finalString(&quot;interface&quot;);
 535             }
 536 
 537             @Override
 538             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 539                 addVisibilityModifier(mods);
 540                 addStatic(mods);
 541                 return finalString(&quot;enum&quot;);
 542             }
 543 
 544             @Override
 545             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 546                 addVisibilityModifier(mods);
 547                 addStatic(mods);
 548                 return finalString(&quot;@interface&quot;);
 549             }
 550 
 551             @Override
 552             public String visitTypeAsRecord(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 553                 mods.remove(FINAL); // suppress the implicit `final`
 554                 return visitTypeAsClass(e, mods);
 555             }
 556 
 557             @Override
 558             @SuppressWarnings(&quot;preview&quot;)
 559             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 560                 addModifiers(mods);
 561                 String keyword = e.getKind() == ElementKind.RECORD ? &quot;record&quot; : &quot;class&quot;;
 562                 return finalString(keyword);
 563             }
 564 
 565             @Override
 566             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; mods) {
 567                 addModifiers(mods);
 568                 return sb.toString().trim();
 569             }
 570 
 571         }.visit(e, modifiers);
 572     }
 573 
 574     public boolean isFunctionalInterface(AnnotationMirror amirror) {
 575         return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
 576                 configuration.docEnv.getSourceVersion()
 577                         .compareTo(SourceVersion.RELEASE_8) &gt;= 0;
 578     }
 579 
 580     public boolean isNoType(TypeMirror t) {
 581         return t.getKind() == NONE;
 582     }
 583 
 584     public boolean isOrdinaryClass(TypeElement te) {
 585         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 586             return false;
 587         }
 588         if (isError(te) || isException(te)) {
 589             return false;
 590         }
 591         return true;
 592     }
 593 
 594     public boolean isUndocumentedEnclosure(TypeElement enclosingTypeElement) {
 595         return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))
 596                 &amp;&amp; !isLinkable(enclosingTypeElement);
 597     }
 598 
 599     public boolean isError(TypeElement te) {
 600         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 601             return false;
 602         }
 603         return typeUtils.isSubtype(te.asType(), getErrorType());
 604     }
 605 
 606     public boolean isException(TypeElement te) {
 607         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 608             return false;
 609         }
 610         return typeUtils.isSubtype(te.asType(), getExceptionType());
 611     }
 612 
 613     public boolean isPrimitive(TypeMirror t) {
 614         return new SimpleTypeVisitor9&lt;Boolean, Void&gt;() {
 615 
 616             @Override
 617             public Boolean visitNoType(NoType t, Void p) {
 618                 return t.getKind() == VOID;
 619             }
 620             @Override
 621             public Boolean visitPrimitive(PrimitiveType t, Void p) {
 622                 return true;
 623             }
 624             @Override
 625             public Boolean visitArray(ArrayType t, Void p) {
 626                 return visit(t.getComponentType());
 627             }
 628             @Override
 629             protected Boolean defaultAction(TypeMirror e, Void p) {
 630                 return false;
 631             }
 632         }.visit(t);
 633     }
 634 
 635     public boolean isExecutableElement(Element e) {
 636         ElementKind kind = e.getKind();
 637         switch (kind) {
 638             case CONSTRUCTOR: case METHOD: case INSTANCE_INIT:
 639                 return true;
 640             default:
 641                 return false;
 642         }
 643     }
 644 
 645     public boolean isVariableElement(Element e) {
 646         ElementKind kind = e.getKind();
 647         switch(kind) {
 648               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 649               case LOCAL_VARIABLE: case PARAMETER:
 650               case RESOURCE_VARIABLE:
 651                   return true;
 652               default:
 653                   return false;
 654         }
 655     }
 656 
 657     public boolean isTypeElement(Element e) {
 658         switch (e.getKind()) {
 659             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 660                 return true;
 661             default:
 662                 return false;
 663         }
 664     }
 665 
 666     /**
<a name="10" id="anc10"></a><span class="line-modified"> 667      * Get the signature. It is the parameter list, type is qualified.</span>

 668      * For instance, for a method {@code mymethod(String x, int y)},
 669      * it will return {@code (java.lang.String,int)}.
 670      *
<a name="11" id="anc11"></a><span class="line-modified"> 671      * @param e</span>
<span class="line-modified"> 672      * @return String</span>

 673      */
<a name="12" id="anc12"></a><span class="line-modified"> 674     public String signature(ExecutableElement e) {</span>
<span class="line-modified"> 675         return makeSignature(e, true);</span>
 676     }
 677 
 678     /**
<a name="13" id="anc13"></a><span class="line-modified"> 679      * Get flat signature.  All types are not qualified.</span>
<span class="line-modified"> 680      * Return a String, which is the flat signature of this member.</span>
<span class="line-removed"> 681      * It is the parameter list, type is not qualified.</span>
 682      * For instance, for a method {@code mymethod(String x, int y)},
 683      * it will return {@code (String, int)}.
<a name="14" id="anc14"></a>



 684      */
<a name="15" id="anc15"></a><span class="line-modified"> 685     public String flatSignature(ExecutableElement e) {</span>
<span class="line-modified"> 686         return makeSignature(e, false);</span>
 687     }
 688 
<a name="16" id="anc16"></a><span class="line-modified"> 689     public String makeSignature(ExecutableElement e, boolean full) {</span>
<span class="line-modified"> 690         return makeSignature(e, full, false);</span>
 691     }
 692 
<a name="17" id="anc17"></a><span class="line-modified"> 693     public String makeSignature(ExecutableElement e, boolean full, boolean ignoreTypeParameters) {</span>
 694         StringBuilder result = new StringBuilder();
 695         result.append(&quot;(&quot;);
<a name="18" id="anc18"></a><span class="line-modified"> 696         Iterator&lt;? extends VariableElement&gt; iterator = e.getParameters().iterator();</span>

 697         while (iterator.hasNext()) {
<a name="19" id="anc19"></a><span class="line-modified"> 698             VariableElement next = iterator.next();</span>
<span class="line-removed"> 699             TypeMirror type = next.asType();</span>
 700             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 701             if (iterator.hasNext()) {
 702                 result.append(&quot;, &quot;);
 703             }
 704         }
 705         if (e.isVarArgs()) {
 706             int len = result.length();
 707             result.replace(len - 2, len, &quot;...&quot;);
 708         }
 709         result.append(&quot;)&quot;);
 710         return result.toString();
 711     }
 712 
 713     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 714         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 715             final StringBuilder sb = new StringBuilder();
 716 
 717             @Override
 718             public StringBuilder visitArray(ArrayType t, Void p) {
 719                 TypeMirror componentType = t.getComponentType();
 720                 visit(componentType);
 721                 sb.append(&quot;[]&quot;);
 722                 return sb;
 723             }
 724 
 725             @Override
 726             public StringBuilder visitDeclared(DeclaredType t, Void p) {
 727                 Element e = t.asElement();
 728                 sb.append(qualifiedName ? getFullyQualifiedName(e) : getSimpleName(e));
 729                 List&lt;? extends TypeMirror&gt; typeArguments = t.getTypeArguments();
 730                 if (typeArguments.isEmpty() || noTypeParameters) {
 731                     return sb;
 732                 }
 733                 sb.append(&quot;&lt;&quot;);
 734                 Iterator&lt;? extends TypeMirror&gt; iterator = typeArguments.iterator();
 735                 while (iterator.hasNext()) {
 736                     TypeMirror ta = iterator.next();
 737                     visit(ta);
 738                     if (iterator.hasNext()) {
 739                         sb.append(&quot;, &quot;);
 740                     }
 741                 }
 742                 sb.append(&quot;&gt;&quot;);
 743                 return sb;
 744             }
 745 
 746             @Override
 747             public StringBuilder visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
 748                 Element e = t.asElement();
 749                 sb.append(qualifiedName ? getFullyQualifiedName(e, false) : getSimpleName(e));
 750                 return sb;
 751             }
 752 
 753             @Override
 754             public StringBuilder visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
 755                 sb.append(&quot;?&quot;);
 756                 TypeMirror upperBound = t.getExtendsBound();
 757                 if (upperBound != null) {
 758                     sb.append(&quot; extends &quot;);
 759                     visit(upperBound);
 760                 }
 761                 TypeMirror superBound = t.getSuperBound();
 762                 if (superBound != null) {
 763                     sb.append(&quot; super &quot;);
 764                     visit(superBound);
 765                 }
 766                 return sb;
 767             }
 768 
 769             @Override
 770             protected StringBuilder defaultAction(TypeMirror e, Void p) {
 771                 return sb.append(e);
 772             }
 773         }.visit(t).toString();
 774     }
 775 
 776     public boolean isArrayType(TypeMirror t) {
 777         return t.getKind() == ARRAY;
 778     }
 779 
 780     public boolean isDeclaredType(TypeMirror t) {
 781         return t.getKind() == DECLARED;
 782     }
 783 
 784     public boolean isErrorType(TypeMirror t) {
 785         return t.getKind() == ERROR;
 786     }
 787 
 788     public boolean isIntersectionType(TypeMirror t) {
 789         return t.getKind() == INTERSECTION;
 790     }
 791 
 792     public boolean isTypeParameterElement(Element e) {
 793         return e.getKind() == TYPE_PARAMETER;
 794     }
 795 
 796     public boolean isTypeVariable(TypeMirror t) {
 797         return t.getKind() == TYPEVAR;
 798     }
 799 
 800     public boolean isVoid(TypeMirror t) {
 801         return t.getKind() == VOID;
 802     }
 803 
 804     public boolean isWildCard(TypeMirror t) {
 805         return t.getKind() == WILDCARD;
 806     }
 807 
 808     public boolean ignoreBounds(TypeMirror bound) {
 809         return bound.equals(getObjectType()) &amp;&amp; !isAnnotated(bound);
 810     }
 811 
 812     /*
 813      * a direct port of TypeVariable.getBounds
 814      */
 815     public List&lt;? extends TypeMirror&gt; getBounds(TypeParameterElement tpe) {
 816         List&lt;? extends TypeMirror&gt; bounds = tpe.getBounds();
 817         if (!bounds.isEmpty()) {
 818             TypeMirror upperBound = bounds.get(bounds.size() - 1);
 819             if (ignoreBounds(upperBound)) {
 820                 return Collections.emptyList();
 821             }
 822         }
 823         return bounds;
 824     }
 825 
 826     /**
 827      * Returns the TypeMirror of the ExecutableElement if it is a method, or null
 828      * if it is a constructor.
 829      * @param site the contextual type
 830      * @param ee the ExecutableElement
 831      * @return the return type
 832      */
 833     public TypeMirror getReturnType(TypeElement site, ExecutableElement ee) {
 834         return ee.getKind() == CONSTRUCTOR ? null : asInstantiatedMethodType(site, ee).getReturnType();
 835     }
 836 
 837     /**
 838      * Returns the ExecutableType corresponding to the type of the method declaration seen as a
 839      * member of a given declared type. This might cause type-variable substitution to kick in.
 840      * @param site the contextual type.
 841      * @param ee the method declaration.
 842      * @return the instantiated method type.
 843      */
 844     public ExecutableType asInstantiatedMethodType(TypeElement site, ExecutableElement ee) {
 845         return shouldInstantiate(site, ee) ?
 846                 (ExecutableType)typeUtils.asMemberOf((DeclaredType)site.asType(), ee) :
 847                 (ExecutableType)ee.asType();
 848     }
 849 
 850     /**
 851      * Returns the TypeMirror corresponding to the type of the field declaration seen as a
 852      * member of a given declared type. This might cause type-variable substitution to kick in.
 853      * @param site the contextual type.
 854      * @param ve the field declaration.
 855      * @return the instantiated field type.
 856      */
 857     public TypeMirror asInstantiatedFieldType(TypeElement site, VariableElement ve) {
 858         return shouldInstantiate(site, ve) ?
 859                 typeUtils.asMemberOf((DeclaredType)site.asType(), ve) :
 860                 ve.asType();
 861     }
 862 
 863     /*
 864      * We should not instantiate if (i) there&#39;s no contextual type declaration, (ii) the declaration
 865      * to which the member belongs to is the same as the one under consideration, (iii) if the
 866      * delcaration to which the member belongs to is not generic.
 867      */
 868     private boolean shouldInstantiate(TypeElement site, Element e) {
 869         return site != null &amp;&amp;
 870                 site != e.getEnclosingElement() &amp;&amp;
 871                !((DeclaredType)e.getEnclosingElement().asType()).getTypeArguments().isEmpty();
 872     }
 873 
 874     /**
 875      * Return the type containing the method that this method overrides.
 876      * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
 877      */
 878     public TypeMirror overriddenType(ExecutableElement method) {
 879         return configuration.workArounds.overriddenType(method);
 880     }
 881 
 882     private  TypeMirror getType(TypeMirror t) {
 883         return (isNoType(t)) ? getObjectType() : t;
 884     }
 885 
 886     public TypeMirror getSuperType(TypeElement te) {
 887         TypeMirror t = te.getSuperclass();
 888         return getType(t);
 889     }
 890 
 891     /**
 892      * Return the class that originally defined the method that
 893      * is overridden by the current definition, or null if no
 894      * such class exists.
 895      *
 896      * @return a TypeElement representing the superclass that
 897      * originally defined this method, null if this method does
 898      * not override a definition in a superclass.
 899      */
 900     public TypeElement overriddenClass(ExecutableElement ee) {
 901         TypeMirror type = overriddenType(ee);
 902         return (type != null) ? asTypeElement(type) : null;
 903     }
 904 
 905     public ExecutableElement overriddenMethod(ExecutableElement method) {
 906         if (isStatic(method)) {
 907             return null;
 908         }
 909         final TypeElement origin = getEnclosingTypeElement(method);
 910         for (TypeMirror t = getSuperType(origin);
 911                 t.getKind() == DECLARED;
 912                 t = getSuperType(asTypeElement(t))) {
 913             TypeElement te = asTypeElement(t);
 914             if (te == null) {
 915                 return null;
 916             }
 917             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 918             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 919                 ExecutableElement ee = (ExecutableElement)e;
 920                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 921                         !isSimpleOverride(ee)) {
 922                     return ee;
 923                 }
 924             }
 925             if (t.equals(getObjectType()))
 926                 return null;
 927         }
 928         return null;
 929     }
 930 
 931     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
<a name="20" id="anc20"></a><span class="line-modified"> 932         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
 933         typeElements.forEach(set::add);
 934         return set;
 935     }
 936 
 937     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 938         return getBlockTags(member, SERIAL_DATA);
 939     }
 940 
 941     public FileObject getFileObject(TypeElement te) {
 942         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 943     }
 944 
 945     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 946         return getDeclaredType(Collections.emptyList(), enclosing, target);
 947     }
 948 
 949     /**
 950      * Finds the declaration of the enclosing&#39;s type parameter.
 951      *
 952      * @param values
 953      * @param enclosing a TypeElement whose type arguments  we desire
 954      * @param target the TypeMirror of the type as described by the enclosing
 955      * @return
 956      */
 957     public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
 958                                       TypeElement enclosing, TypeMirror target) {
 959         TypeElement targetElement = asTypeElement(target);
 960         List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
 961         if (targetTypeArgs.isEmpty()) {
 962             return target;
 963         }
 964 
 965         List&lt;? extends TypeParameterElement&gt; enclosingTypeArgs = enclosing.getTypeParameters();
 966         List&lt;TypeMirror&gt; targetTypeArgTypes = new ArrayList&lt;&gt;(targetTypeArgs.size());
 967 
 968         if (enclosingTypeArgs.isEmpty()) {
 969             for (TypeMirror te : values) {
 970                 List&lt;? extends TypeMirror&gt; typeArguments = ((DeclaredType)te).getTypeArguments();
 971                 if (typeArguments.size() &gt;= targetTypeArgs.size()) {
 972                     for (int i = 0 ; i &lt; targetTypeArgs.size(); i++) {
 973                         targetTypeArgTypes.add(typeArguments.get(i));
 974                     }
 975                     break;
 976                 }
 977             }
 978             // we found no matches in the hierarchy
 979             if (targetTypeArgTypes.isEmpty()) {
 980                 return target;
 981             }
 982         } else {
 983             if (targetTypeArgs.size() &gt; enclosingTypeArgs.size()) {
 984                 return target;
 985             }
 986             for (int i = 0; i &lt; targetTypeArgs.size(); i++) {
 987                 TypeParameterElement tpe = enclosingTypeArgs.get(i);
 988                 targetTypeArgTypes.add(tpe.asType());
 989             }
 990         }
 991         TypeMirror dt = typeUtils.getDeclaredType(targetElement,
 992                 targetTypeArgTypes.toArray(new TypeMirror[targetTypeArgTypes.size()]));
 993         return dt;
 994     }
 995 
 996     /**
 997      * Returns all the implemented super-interfaces of a given type,
 998      * in the case of classes, include all the super-interfaces of
 999      * the supertype. The super-interfaces are collected before the
1000      * super-interfaces of the supertype.
1001      *
1002      * @param  te the type element to get the super-interfaces for.
1003      * @return the list of super-interfaces.
1004      */
1005     public Set&lt;TypeMirror&gt; getAllInterfaces(TypeElement te) {
1006         Set&lt;TypeMirror&gt; results = new LinkedHashSet&lt;&gt;();
1007         getAllInterfaces(te.asType(), results);
1008         return results;
1009     }
1010 
1011     private void getAllInterfaces(TypeMirror type, Set&lt;TypeMirror&gt; results) {
1012         List&lt;? extends TypeMirror&gt; intfacs = typeUtils.directSupertypes(type);
1013         TypeMirror superType = null;
1014         for (TypeMirror intfac : intfacs) {
1015             if (intfac == getObjectType())
1016                 continue;
1017             TypeElement e = asTypeElement(intfac);
1018             if (isInterface(e)) {
1019                 if (isPublic(e) || isLinkable(e))
1020                     results.add(intfac);
1021 
1022                 getAllInterfaces(intfac, results);
1023             } else {
1024                 // Save the supertype for later.
1025                 superType = intfac;
1026             }
1027         }
1028         // Collect the super-interfaces of the supertype.
1029         if (superType != null)
1030             getAllInterfaces(superType, results);
1031     }
1032 
1033     /**
1034      * Lookup for a class within this package.
1035      *
1036      * @return TypeElement of found class, or null if not found.
1037      */
1038     public TypeElement findClassInPackageElement(PackageElement pkg, String className) {
1039         for (TypeElement c : getAllClasses(pkg)) {
1040             if (getSimpleName(c).equals(className)) {
1041                 return c;
1042             }
1043         }
1044         return null;
1045     }
1046 
1047     /**
1048      * TODO: FIXME: port to javax.lang.model
1049      * Find a class within the context of this class. Search order: qualified name, in this class
1050      * (inner), in this package, in the class imports, in the package imports. Return the
1051      * TypeElement if found, null if not found.
1052      */
1053     //### The specified search order is not the normal rule the
1054     //### compiler would use.  Leave as specified or change it?
1055     public TypeElement findClass(Element element, String className) {
1056         TypeElement encl = getEnclosingTypeElement(element);
1057         TypeElement searchResult = configuration.workArounds.searchClass(encl, className);
1058         if (searchResult == null) {
1059             encl = getEnclosingTypeElement(encl);
1060             //Expand search space to include enclosing class.
1061             while (encl != null &amp;&amp; getEnclosingTypeElement(encl) != null) {
1062                 encl = getEnclosingTypeElement(encl);
1063             }
1064             searchResult = encl == null
1065                     ? null
1066                     : configuration.workArounds.searchClass(encl, className);
1067         }
1068         return searchResult;
1069     }
1070 
1071     /**
1072      * Enclose in quotes, used for paths and filenames that contains spaces
1073      */
1074     public String quote(String filepath) {
1075         return (&quot;\&quot;&quot; + filepath + &quot;\&quot;&quot;);
1076     }
1077 
1078     /**
1079      * Parse the package name.  We only want to display package name up to
1080      * 2 levels.
1081      */
1082     public String parsePackageName(PackageElement p) {
1083         String pkgname = p.isUnnamed() ? &quot;&quot; : getPackageName(p);
1084         int index = -1;
1085         for (int j = 0; j &lt; MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {
1086             index = pkgname.indexOf(&quot;.&quot;, index + 1);
1087         }
1088         if (index != -1) {
1089             pkgname = pkgname.substring(0, index);
1090         }
1091         return pkgname;
1092     }
1093 
1094     /**
1095      * Given a string, replace all occurrences of &#39;newStr&#39; with &#39;oldStr&#39;.
1096      * @param originalStr the string to modify.
1097      * @param oldStr the string to replace.
1098      * @param newStr the string to insert in place of the old string.
1099      */
1100     public String replaceText(String originalStr, String oldStr,
1101             String newStr) {
1102         if (oldStr == null || newStr == null || oldStr.equals(newStr)) {
1103             return originalStr;
1104         }
1105         return originalStr.replace(oldStr, newStr);
1106     }
1107 
1108     /**
1109      * Given an annotation, return true if it should be documented and false
1110      * otherwise.
1111      *
1112      * @param annotation the annotation to check.
1113      *
1114      * @return true return true if it should be documented and false otherwise.
1115      */
1116     public boolean isDocumentedAnnotation(TypeElement annotation) {
1117         for (AnnotationMirror anno : annotation.getAnnotationMirrors()) {
1118             if (getFullyQualifiedName(anno.getAnnotationType().asElement()).equals(
1119                     Documented.class.getName())) {
1120                 return true;
1121             }
1122         }
1123         return false;
1124     }
1125 
1126     /**
1127      * Returns true if this class is linkable and false if we can&#39;t link to it.
1128      *
1129      * &lt;p&gt;
1130      * &lt;b&gt;NOTE:&lt;/b&gt;  You can only link to external classes if they are public or
1131      * protected.
1132      *
1133      * @return true if this class is linkable and false if we can&#39;t link to the
1134      * desired class.
1135      */
1136     public boolean isLinkable(TypeElement typeElem) {
1137         return
1138             (typeElem != null &amp;&amp;
1139                 (isIncluded(typeElem) &amp;&amp; configuration.isGeneratedDoc(typeElem))) ||
1140             (configuration.extern.isExternal(typeElem) &amp;&amp;
1141                 (isPublic(typeElem) || isProtected(typeElem)));
1142     }
1143 
1144     /**
1145      * Returns true if an element is linkable in the context of a given type element.
1146      *
1147      * If the element is a type element, it delegates to {@link #isLinkable(TypeElement)}.
1148      * Otherwise, the element is linkable if any of the following are true:
1149      * &lt;ul&gt;
1150      * &lt;li&gt;it is &quot;included&quot; (see {@link jdk.javadoc.doclet})
1151      * &lt;li&gt;it is inherited from an undocumented supertype
1152      * &lt;li&gt;it is a public or protected member of an external API
1153      * &lt;/ul&gt;
1154      *
1155      * @param typeElem the type element
1156      * @param elem the element
1157      * @return whether or not the element is linkable
1158      */
1159     public boolean isLinkable(TypeElement typeElem, Element elem) {
1160         if (isTypeElement(elem)) {
1161             return isLinkable((TypeElement) elem); // defer to existing behavior
1162         }
1163 
1164         if (isIncluded(elem)) {
1165             return true;
1166         }
1167 
1168         // Allow for the behavior that members of undocumented supertypes
1169         // may be included in documented types
1170         if (isUndocumentedEnclosure(getEnclosingTypeElement(elem))) {
1171             return true;
1172         }
1173 
1174         // Allow for external members
1175         return isLinkable(typeElem)
1176                     &amp;&amp; configuration.extern.isExternal(typeElem)
1177                     &amp;&amp; (isPublic(elem) || isProtected(elem));
1178     }
1179 
1180     /**
1181      * Return this type as a {@code TypeElement} if it represents a class
1182      * interface or annotation.  Array dimensions are ignored.
1183      * If this type {@code ParameterizedType} or {@code WildcardType}, return
1184      * the {@code TypeElement} of the type&#39;s erasure.  If this is an
1185      * annotation, return this as a {@code TypeElement}.
1186      * If this is a primitive type, return null.
1187      *
1188      * @return the {@code TypeElement} of this type,
1189      *         or null if it is a primitive type.
1190      */
1191     public TypeElement asTypeElement(TypeMirror t) {
1192         return new SimpleTypeVisitor9&lt;TypeElement, Void&gt;() {
1193 
1194             @Override
1195             public TypeElement visitDeclared(DeclaredType t, Void p) {
1196                 return (TypeElement) t.asElement();
1197             }
1198 
1199             @Override
1200             public TypeElement visitArray(ArrayType t, Void p) {
1201                 return visit(t.getComponentType());
1202             }
1203 
1204             @Override
1205             public TypeElement visitTypeVariable(TypeVariable t, Void p) {
1206                /* TODO, this may not be an optimal fix.
1207                 * if we have an annotated type @DA T, then erasure returns a
1208                 * none, in this case we use asElement instead.
1209                 */
1210                 if (isAnnotated(t)) {
1211                     return visit(typeUtils.asElement(t).asType());
1212                 }
1213                 return visit(typeUtils.erasure(t));
1214             }
1215 
1216             @Override
1217             public TypeElement visitWildcard(WildcardType t, Void p) {
1218                 return visit(typeUtils.erasure(t));
1219             }
1220 
1221             @Override
1222             public TypeElement visitError(ErrorType t, Void p) {
1223                 return (TypeElement)t.asElement();
1224             }
1225 
1226             @Override
1227             protected TypeElement defaultAction(TypeMirror e, Void p) {
1228                 return super.defaultAction(e, p);
1229             }
1230         }.visit(t);
1231     }
1232 
1233     public TypeMirror getComponentType(TypeMirror t) {
1234         while (isArrayType(t)) {
1235             t = ((ArrayType) t).getComponentType();
1236         }
1237         return t;
1238     }
1239 
1240     /**
1241      * Return the type&#39;s dimension information, as a string.
1242      * &lt;p&gt;
1243      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1244      *
1245      * @return the type&#39;s dimension information as a string.
1246      */
1247     public String getDimension(TypeMirror t) {
1248         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1249             StringBuilder dimension = new StringBuilder();
1250             @Override
1251             public String visitArray(ArrayType t, Void p) {
1252                 dimension.append(&quot;[]&quot;);
1253                 return visit(t.getComponentType());
1254             }
1255 
1256             @Override
1257             protected String defaultAction(TypeMirror e, Void p) {
1258                 return dimension.toString();
1259             }
1260 
1261         }.visit(t);
1262     }
1263 
1264     public TypeElement getSuperClass(TypeElement te) {
1265         if (isInterface(te) || isAnnotationType(te) ||
1266                 te.asType().equals(getObjectType())) {
1267             return null;
1268         }
1269         TypeMirror superclass = te.getSuperclass();
1270         if (isNoType(superclass) &amp;&amp; isClass(te)) {
1271             superclass = getObjectType();
1272         }
1273         return asTypeElement(superclass);
1274     }
1275 
1276     public TypeElement getFirstVisibleSuperClassAsTypeElement(TypeElement te) {
1277         if (isAnnotationType(te) || isInterface(te) ||
1278                 te.asType().equals(getObjectType())) {
1279             return null;
1280         }
1281         TypeMirror firstVisibleSuperClass = getFirstVisibleSuperClass(te);
1282         return firstVisibleSuperClass == null ? null : asTypeElement(firstVisibleSuperClass);
1283     }
1284 
1285     /**
1286      * Given a class, return the closest visible super class.
1287      * @param type the TypeMirror to be interrogated
1288      * @return  the closest visible super class.  Return null if it cannot
1289      *          be found.
1290      */
1291 
1292     public TypeMirror getFirstVisibleSuperClass(TypeMirror type) {
1293         return getFirstVisibleSuperClass(asTypeElement(type));
1294     }
1295 
1296 
1297     /**
1298      * Given a class, return the closest visible super class.
1299      *
1300      * @param te the TypeElement to be interrogated
1301      * @return the closest visible super class.  Return null if it cannot
1302      *         be found..
1303      */
1304     public TypeMirror getFirstVisibleSuperClass(TypeElement te) {
1305         TypeMirror superType = te.getSuperclass();
1306         if (isNoType(superType)) {
1307             superType = getObjectType();
1308         }
1309         TypeElement superClass = asTypeElement(superType);
1310         // skip &quot;hidden&quot; classes
1311         while ((superClass != null &amp;&amp; hasHiddenTag(superClass))
1312                 || (superClass != null &amp;&amp;  !isPublic(superClass) &amp;&amp; !isLinkable(superClass))) {
1313             TypeMirror supersuperType = superClass.getSuperclass();
1314             TypeElement supersuperClass = asTypeElement(supersuperType);
1315             if (supersuperClass == null
1316                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1317                 break;
1318             }
1319             superType = supersuperType;
1320             superClass = supersuperClass;
1321         }
1322         if (te.asType().equals(superType)) {
1323             return null;
1324         }
1325         return superType;
1326     }
1327 
1328     /**
1329      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1330      *
1331      * @param te the TypeElement to check.
1332      * @param lowerCaseOnly true if you want the name returned in lower case.
1333      *                      If false, the first letter of the name is capitalized.
1334      * @return
1335      */
1336     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1337         String typeName = &quot;&quot;;
1338         if (isInterface(te)) {
1339             typeName = &quot;doclet.Interface&quot;;
1340         } else if (isException(te)) {
1341             typeName = &quot;doclet.Exception&quot;;
1342         } else if (isError(te)) {
1343             typeName = &quot;doclet.Error&quot;;
1344         } else if (isAnnotationType(te)) {
1345             typeName = &quot;doclet.AnnotationType&quot;;
1346         } else if (isEnum(te)) {
1347             typeName = &quot;doclet.Enum&quot;;
1348         } else if (isOrdinaryClass(te)) {
1349             typeName = &quot;doclet.Class&quot;;
1350         }
1351         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1352         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1353     }
1354 
1355     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
1356 
1357     public String getTypeName(TypeMirror t, boolean fullyQualified) {
1358         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1359 
1360             @Override
1361             public String visitArray(ArrayType t, Void p) {
1362                 return visit(t.getComponentType());
1363             }
1364 
1365             @Override
1366             public String visitDeclared(DeclaredType t, Void p) {
1367                 TypeElement te = asTypeElement(t);
1368                 return fullyQualified
1369                         ? te.getQualifiedName().toString()
1370                         : getSimpleName(te);
1371             }
1372 
1373             @Override
1374             public String visitExecutable(ExecutableType t, Void p) {
1375                 return t.toString();
1376             }
1377 
1378             @Override
1379             public String visitPrimitive(PrimitiveType t, Void p) {
1380                 return t.toString();
1381             }
1382 
1383             @Override
1384             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1385                 return getSimpleName(t.asElement());
1386             }
1387 
1388             @Override
1389             public String visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
1390                 return t.toString();
1391             }
1392 
1393             @Override
1394             protected String defaultAction(TypeMirror e, Void p) {
1395                 return e.toString();
1396             }
1397         }.visit(t);
1398     }
1399 
1400     /**
1401      * Replace all tabs in a string with the appropriate number of spaces.
1402      * The string may be a multi-line string.
1403      * @param text the text for which the tabs should be expanded
1404      * @return the text with all tabs expanded
1405      */
1406     public String replaceTabs(String text) {
1407         if (!text.contains(&quot;\t&quot;))
1408             return text;
1409 
1410         final int tabLength = options.sourceTabSize();
1411         final String whitespace = &quot; &quot;.repeat(tabLength);
1412         final int textLength = text.length();
1413         StringBuilder result = new StringBuilder(textLength);
1414         int pos = 0;
1415         int lineLength = 0;
1416         for (int i = 0; i &lt; textLength; i++) {
1417             char ch = text.charAt(i);
1418             switch (ch) {
1419                 case &#39;\n&#39;: case &#39;\r&#39;:
1420                     lineLength = 0;
1421                     break;
1422                 case &#39;\t&#39;:
1423                     result.append(text, pos, i);
1424                     int spaceCount = tabLength - lineLength % tabLength;
1425                     result.append(whitespace, 0, spaceCount);
1426                     lineLength += spaceCount;
1427                     pos = i + 1;
1428                     break;
1429                 default:
1430                     lineLength++;
1431             }
1432         }
1433         result.append(text, pos, textLength);
1434         return result.toString();
1435     }
1436 
1437     public CharSequence normalizeNewlines(CharSequence text) {
1438         StringBuilder sb = new StringBuilder();
1439         final int textLength = text.length();
1440         final String NL = DocletConstants.NL;
1441         int pos = 0;
1442         for (int i = 0; i &lt; textLength; i++) {
1443             char ch = text.charAt(i);
1444             switch (ch) {
1445                 case &#39;\n&#39;:
1446                     sb.append(text, pos, i);
1447                     sb.append(NL);
1448                     pos = i + 1;
1449                     break;
1450                 case &#39;\r&#39;:
1451                     sb.append(text, pos, i);
1452                     sb.append(NL);
1453                     if (i + 1 &lt; textLength &amp;&amp; text.charAt(i + 1) == &#39;\n&#39;)
1454                         i++;
1455                     pos = i + 1;
1456                     break;
1457             }
1458         }
1459         sb.append(text, pos, textLength);
1460         return sb;
1461     }
1462 
1463     /**
1464      * Returns a locale independent lower cased String. That is, it
1465      * always uses US locale, this is a clone of the one in StringUtils.
1466      * @param s to convert
1467      * @return converted String
1468      */
1469     public static String toLowerCase(String s) {
1470         return s.toLowerCase(Locale.US);
1471     }
1472 
1473     /**
1474      * Return true if the given Element is deprecated.
1475      *
1476      * @param e the Element to check.
1477      * @return true if the given Element is deprecated.
1478      */
1479     public boolean isDeprecated(Element e) {
1480         if (isPackage(e)) {
1481             return configuration.workArounds.isDeprecated0(e);
1482         }
1483         return elementUtils.isDeprecated(e);
1484     }
1485 
1486     /**
1487      * Return true if the given Element is deprecated for removal.
1488      *
1489      * @param e the Element to check.
1490      * @return true if the given Element is deprecated for removal.
1491      */
1492     public boolean isDeprecatedForRemoval(Element e) {
1493         List&lt;? extends AnnotationMirror&gt; annotationList = e.getAnnotationMirrors();
1494         JavacTypes jctypes = ((DocEnvImpl) configuration.docEnv).toolEnv.typeutils;
1495         for (AnnotationMirror anno : annotationList) {
1496             if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), getDeprecatedType())) {
1497                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = anno.getElementValues();
1498                 if (!pairs.isEmpty()) {
1499                     for (ExecutableElement element : pairs.keySet()) {
1500                         if (element.getSimpleName().contentEquals(&quot;forRemoval&quot;)) {
1501                             return Boolean.parseBoolean((pairs.get(element)).toString());
1502                         }
1503                     }
1504                 }
1505             }
1506         }
1507         return false;
1508     }
1509 
1510     /**
1511      * A convenience method to get property name from the name of the
1512      * getter or setter method.
1513      * @param e the input method.
1514      * @return the name of the property of the given setter of getter.
1515      */
1516     public String propertyName(ExecutableElement e) {
1517         String name = getSimpleName(e);
1518         String propertyName = null;
1519         if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {
1520             propertyName = name.substring(3);
1521         } else if (name.startsWith(&quot;is&quot;)) {
1522             propertyName = name.substring(2);
1523         }
1524         if ((propertyName == null) || propertyName.isEmpty()){
1525             return &quot;&quot;;
1526         }
1527         return propertyName.substring(0, 1).toLowerCase(configuration.getLocale())
1528                 + propertyName.substring(1);
1529     }
1530 
1531     /**
1532      * Returns true if the element is included, contains &amp;#64;hidden tag,
1533      * or if javafx flag is present and element contains &amp;#64;treatAsPrivate
1534      * tag.
1535      * @param e the queried element
1536      * @return true if it exists, false otherwise
1537      */
1538     public boolean hasHiddenTag(Element e) {
1539         // prevent needless tests on elements which are not included
1540         if (!isIncluded(e)) {
1541             return false;
1542         }
1543         if (options.javafx() &amp;&amp;
1544                 hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
1545             return true;
1546         }
1547         return hasBlockTag(e, DocTree.Kind.HIDDEN);
1548     }
1549 
1550     /**
1551      * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
1552      * @param m a method
1553      * @return true if there are no comments, false otherwise
1554      */
1555     public boolean isSimpleOverride(ExecutableElement m) {
1556         if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {
1557             return false;
1558         }
1559 
1560         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1561             return false;
1562 
1563         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1564         return fullBody.isEmpty() ||
1565                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1566     }
1567 
1568     /**
1569      * In case of JavaFX mode on, filters out classes that are private,
1570      * package private, these are not documented in JavaFX mode, also
1571      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1572      *
1573      * @param classlist a collection of TypeElements
1574      * @param javafx set to true if in JavaFX mode.
1575      * @return list of filtered classes.
1576      */
1577     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1578             boolean javafx) {
1579         SortedSet&lt;TypeElement&gt; filteredOutClasses =
<a name="21" id="anc21"></a><span class="line-modified">1580                 new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
1581         if (!javafx) {
1582             for (Element te : classlist) {
1583                 if (!hasHiddenTag(te)) {
1584                     filteredOutClasses.add((TypeElement)te);
1585                 }
1586             }
1587             return filteredOutClasses;
1588         }
1589         for (Element e : classlist) {
1590             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1591                 continue;
1592             }
1593             filteredOutClasses.add((TypeElement)e);
1594         }
1595         return filteredOutClasses;
1596     }
1597 
1598     /**
1599      * Compares two elements.
1600      * @param e1 first Element
1601      * @param e2 second Element
1602      * @return a true if they are the same, false otherwise.
1603      */
1604     public boolean elementsEqual(Element e1, Element e2) {
1605         if (e1.getKind() != e2.getKind()) {
1606             return false;
1607         }
1608         String s1 = getSimpleName(e1);
1609         String s2 = getSimpleName(e2);
1610         if (compareStrings(s1, s2) == 0) {
1611             String f1 = getFullyQualifiedName(e1, true);
1612             String f2 = getFullyQualifiedName(e2, true);
1613             return compareStrings(f1, f2) == 0;
1614         }
1615         return false;
1616     }
1617 
1618     /**
1619      * A general purpose case insensitive String comparator, which compares
1620      * two Strings using a Collator strength of &quot;TERTIARY&quot;.
1621      *
1622      * @param s1 first String to compare.
1623      * @param s2 second String to compare.
1624      * @return a negative integer, zero, or a positive integer as the first
1625      *         argument is less than, equal to, or greater than the second.
1626      */
1627     public int compareStrings(String s1, String s2) {
1628         return compareStrings(true, s1, s2);
1629     }
1630 
1631     /**
1632      * A general purpose case sensitive String comparator, which
1633      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1634      *
1635      * @param s1 first String to compare.
1636      * @param s2 second String to compare.
1637      * @return a negative integer, zero, or a positive integer as the first
1638      *         argument is less than, equal to, or greater than the second.
1639      */
1640     public int compareCaseCompare(String s1, String s2) {
1641         return compareStrings(false, s1, s2);
1642     }
1643 
1644     private DocCollator tertiaryCollator = null;
1645     private DocCollator secondaryCollator = null;
1646 
<a name="22" id="anc22"></a><span class="line-modified">1647     private int compareStrings(boolean caseSensitive, String s1, String s2) {</span>
1648         if (caseSensitive) {
1649             if (tertiaryCollator == null) {
1650                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1651             }
1652             return tertiaryCollator.compare(s1, s2);
1653         }
1654         if (secondaryCollator == null) {
1655             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1656         }
1657         return secondaryCollator.compare(s1, s2);
1658     }
1659 
1660     public String getHTMLTitle(Element element) {
1661         List&lt;? extends DocTree&gt; preamble = getPreamble(element);
1662         StringBuilder sb = new StringBuilder();
1663         boolean titleFound = false;
1664         loop:
1665         for (DocTree dt : preamble) {
1666             switch (dt.getKind()) {
1667                 case START_ELEMENT:
1668                     StartElementTree nodeStart = (StartElementTree)dt;
1669                     if (Utils.toLowerCase(nodeStart.getName().toString()).equals(&quot;title&quot;)) {
1670                         titleFound = true;
1671                     }
1672                     break;
1673 
1674                 case END_ELEMENT:
1675                     EndElementTree nodeEnd = (EndElementTree)dt;
1676                     if (Utils.toLowerCase(nodeEnd.getName().toString()).equals(&quot;title&quot;)) {
1677                         break loop;
1678                     }
1679                     break;
1680 
1681                 case TEXT:
1682                     TextTree nodeText = (TextTree)dt;
1683                     if (titleFound)
1684                         sb.append(nodeText.getBody());
1685                     break;
1686 
1687                 default:
1688                     // do nothing
1689             }
1690         }
1691         return sb.toString().trim();
1692     }
1693 
1694     private static class DocCollator {
1695         private final Map&lt;String, CollationKey&gt; keys;
1696         private final Collator instance;
1697         private final int MAX_SIZE = 1000;
1698         private DocCollator(Locale locale, int strength) {
1699             instance = createCollator(locale);
1700             instance.setStrength(strength);
1701 
1702             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1703                 private static final long serialVersionUID = 1L;
1704                 @Override
1705                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1706                     return size() &gt; MAX_SIZE;
1707                 }
1708             };
1709         }
1710 
1711         CollationKey getKey(String s) {
1712             return keys.computeIfAbsent(s, instance :: getCollationKey);
1713         }
1714 
1715         public int compare(String s1, String s2) {
1716             return getKey(s1).compareTo(getKey(s2));
1717         }
1718 
1719         private Collator createCollator(Locale locale) {
1720             Collator baseCollator = Collator.getInstance(locale);
1721             if (baseCollator instanceof RuleBasedCollator) {
1722                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1723                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1724                 try {
1725                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1726                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1727                 } catch (ParseException e) {
1728                     throw new RuntimeException(e);
1729                 }
1730             }
1731             return baseCollator;
1732         }
1733     }
1734 
<a name="23" id="anc23"></a><span class="line-removed">1735     private Comparator&lt;Element&gt; moduleComparator = null;</span>
<span class="line-removed">1736     /**</span>
<span class="line-removed">1737      * Comparator for ModuleElements, simply compares the fully qualified names</span>
<span class="line-removed">1738      * @return a Comparator</span>
<span class="line-removed">1739      */</span>
<span class="line-removed">1740     public Comparator&lt;Element&gt; makeModuleComparator() {</span>
<span class="line-removed">1741         if (moduleComparator == null) {</span>
<span class="line-removed">1742             moduleComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1743                 @Override</span>
<span class="line-removed">1744                 public int compare(Element mod1, Element mod2) {</span>
<span class="line-removed">1745                     return compareFullyQualifiedNames(mod1, mod2);</span>
<span class="line-removed">1746                 }</span>
<span class="line-removed">1747             };</span>
<span class="line-removed">1748         }</span>
<span class="line-removed">1749         return moduleComparator;</span>
<span class="line-removed">1750     }</span>
<span class="line-removed">1751 </span>
<span class="line-removed">1752     private Comparator&lt;Element&gt; allClassesComparator = null;</span>
<span class="line-removed">1753     /**</span>
<span class="line-removed">1754      * Returns a Comparator for all classes, compares the simple names of</span>
<span class="line-removed">1755      * TypeElement, if equal then the fully qualified names.</span>
<span class="line-removed">1756      *</span>
<span class="line-removed">1757      * @return Comparator</span>
<span class="line-removed">1758      */</span>
<span class="line-removed">1759     public Comparator&lt;Element&gt; makeAllClassesComparator() {</span>
<span class="line-removed">1760         if (allClassesComparator == null) {</span>
<span class="line-removed">1761             allClassesComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1762                 @Override</span>
<span class="line-removed">1763                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">1764                     int result = compareNames(e1, e2);</span>
<span class="line-removed">1765                     if (result == 0)</span>
<span class="line-removed">1766                         result = compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1767 </span>
<span class="line-removed">1768                     return result;</span>
<span class="line-removed">1769                 }</span>
<span class="line-removed">1770             };</span>
<span class="line-removed">1771         }</span>
<span class="line-removed">1772         return allClassesComparator;</span>
<span class="line-removed">1773     }</span>
<span class="line-removed">1774 </span>
<span class="line-removed">1775     private Comparator&lt;Element&gt; packageComparator = null;</span>
<span class="line-removed">1776     /**</span>
<span class="line-removed">1777      * Returns a Comparator for packages, by comparing the fully qualified names.</span>
<span class="line-removed">1778      *</span>
<span class="line-removed">1779      * @return a Comparator</span>
<span class="line-removed">1780      */</span>
<span class="line-removed">1781     public Comparator&lt;Element&gt; makePackageComparator() {</span>
<span class="line-removed">1782         if (packageComparator == null) {</span>
<span class="line-removed">1783             packageComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1784                 @Override</span>
<span class="line-removed">1785                 public int compare(Element pkg1, Element pkg2) {</span>
<span class="line-removed">1786                     return compareFullyQualifiedNames(pkg1, pkg2);</span>
<span class="line-removed">1787                 }</span>
<span class="line-removed">1788             };</span>
<span class="line-removed">1789         }</span>
<span class="line-removed">1790         return packageComparator;</span>
<span class="line-removed">1791     }</span>
<span class="line-removed">1792 </span>
<span class="line-removed">1793     private Comparator&lt;Element&gt; deprecatedComparator = null;</span>
<span class="line-removed">1794     /**</span>
<span class="line-removed">1795      * Returns a Comparator for deprecated items listed on deprecated list page, by comparing the</span>
<span class="line-removed">1796      * fully qualified names.</span>
<span class="line-removed">1797      *</span>
<span class="line-removed">1798      * @return a Comparator</span>
<span class="line-removed">1799      */</span>
<span class="line-removed">1800     public Comparator&lt;Element&gt; makeDeprecatedComparator() {</span>
<span class="line-removed">1801         if (deprecatedComparator == null) {</span>
<span class="line-removed">1802             deprecatedComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1803                 @Override</span>
<span class="line-removed">1804                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">1805                     return compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1806                 }</span>
<span class="line-removed">1807             };</span>
<span class="line-removed">1808         }</span>
<span class="line-removed">1809         return deprecatedComparator;</span>
<span class="line-removed">1810     }</span>
<span class="line-removed">1811 </span>
<span class="line-removed">1812     private Comparator&lt;SerialFieldTree&gt; serialFieldTreeComparator = null;</span>
<span class="line-removed">1813     /**</span>
<span class="line-removed">1814      * Returns a Comparator for SerialFieldTree.</span>
<span class="line-removed">1815      * @return a Comparator</span>
<span class="line-removed">1816      */</span>
<span class="line-removed">1817     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {</span>
<span class="line-removed">1818         if (serialFieldTreeComparator == null) {</span>
<span class="line-removed">1819             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {</span>
<span class="line-removed">1820                 String s1 = o1.getName().toString();</span>
<span class="line-removed">1821                 String s2 = o2.getName().toString();</span>
<span class="line-removed">1822                 return s1.compareTo(s2);</span>
<span class="line-removed">1823             };</span>
<span class="line-removed">1824         }</span>
<span class="line-removed">1825         return serialFieldTreeComparator;</span>
<span class="line-removed">1826     }</span>
<span class="line-removed">1827 </span>
<span class="line-removed">1828     /**</span>
<span class="line-removed">1829      * Returns a general purpose comparator.</span>
<span class="line-removed">1830      * @return a Comparator</span>
<span class="line-removed">1831      */</span>
<span class="line-removed">1832     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {</span>
<span class="line-removed">1833         return makeClassUseComparator();</span>
<span class="line-removed">1834     }</span>
<span class="line-removed">1835 </span>
<span class="line-removed">1836     private Comparator&lt;Element&gt; overrideUseComparator = null;</span>
<span class="line-removed">1837 </span>
<span class="line-removed">1838     /**</span>
<span class="line-removed">1839      * Returns a Comparator for overrides and implements,</span>
<span class="line-removed">1840      * used primarily on methods, compares the name first,</span>
<span class="line-removed">1841      * then compares the simple names of the enclosing</span>
<span class="line-removed">1842      * TypeElement and the fully qualified name of the enclosing TypeElement.</span>
<span class="line-removed">1843      * @return a Comparator</span>
<span class="line-removed">1844      */</span>
<span class="line-removed">1845     public Comparator&lt;Element&gt; makeOverrideUseComparator() {</span>
<span class="line-removed">1846         if (overrideUseComparator == null) {</span>
<span class="line-removed">1847             overrideUseComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1848                 @Override</span>
<span class="line-removed">1849                 public int compare(Element o1, Element o2) {</span>
<span class="line-removed">1850                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));</span>
<span class="line-removed">1851                     if (result != 0) {</span>
<span class="line-removed">1852                         return result;</span>
<span class="line-removed">1853                     }</span>
<span class="line-removed">1854                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {</span>
<span class="line-removed">1855                         TypeElement t1 = getEnclosingTypeElement(o1);</span>
<span class="line-removed">1856                         TypeElement t2 = getEnclosingTypeElement(o2);</span>
<span class="line-removed">1857                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));</span>
<span class="line-removed">1858                         if (result != 0)</span>
<span class="line-removed">1859                             return result;</span>
<span class="line-removed">1860                     }</span>
<span class="line-removed">1861                     result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));</span>
<span class="line-removed">1862                     if (result != 0)</span>
<span class="line-removed">1863                         return result;</span>
<span class="line-removed">1864                     return compareElementKinds(o1, o2);</span>
<span class="line-removed">1865                 }</span>
<span class="line-removed">1866             };</span>
<span class="line-removed">1867         }</span>
<span class="line-removed">1868         return overrideUseComparator;</span>
<span class="line-removed">1869     }</span>
<span class="line-removed">1870 </span>
<span class="line-removed">1871     private Comparator&lt;Element&gt; indexUseComparator = null;</span>
<span class="line-removed">1872     /**</span>
<span class="line-removed">1873      *  Returns a Comparator for index file presentations, and are sorted as follows.</span>
<span class="line-removed">1874      *  If comparing modules and/or packages then simply compare the qualified names,</span>
<span class="line-removed">1875      *  if comparing a module or a package with a type/member then compare the</span>
<span class="line-removed">1876      *  FullyQualifiedName of the module or a package with the SimpleName of the entity,</span>
<span class="line-removed">1877      *  otherwise:</span>
<span class="line-removed">1878      *  1. compare the ElementKind ex: Module, Package, Interface etc.</span>
<span class="line-removed">1879      *  2a. if equal and if the type is of ExecutableElement(Constructor, Methods),</span>
<span class="line-removed">1880      *      a case insensitive comparison of parameter the type signatures</span>
<span class="line-removed">1881      *  2b. if equal, case sensitive comparison of the type signatures</span>
<span class="line-removed">1882      *  3. finally, if equal, compare the FQNs of the entities</span>
<span class="line-removed">1883      * @return a comparator for index file use</span>
<span class="line-removed">1884      */</span>
<span class="line-removed">1885     public Comparator&lt;Element&gt; makeIndexUseComparator() {</span>
<span class="line-removed">1886         if (indexUseComparator == null) {</span>
<span class="line-removed">1887             indexUseComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1888                 /**</span>
<span class="line-removed">1889                  * Compares two elements.</span>
<span class="line-removed">1890                  *</span>
<span class="line-removed">1891                  * @param e1 - an element.</span>
<span class="line-removed">1892                  * @param e2 - an element.</span>
<span class="line-removed">1893                  * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">1894                  * argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">1895                  */</span>
<span class="line-removed">1896                 @Override</span>
<span class="line-removed">1897                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">1898                     int result;</span>
<span class="line-removed">1899                     // first, compare names as appropriate</span>
<span class="line-removed">1900                     if ((isModule(e1) || isPackage(e1)) &amp;&amp; (isModule(e2) || isPackage(e2))) {</span>
<span class="line-removed">1901                         result = compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1902                     } else if (isModule(e1) || isPackage(e1)) {</span>
<span class="line-removed">1903                         result = compareStrings(getFullyQualifiedName(e1), getSimpleName(e2));</span>
<span class="line-removed">1904                     } else if (isModule(e2) || isPackage(e2)) {</span>
<span class="line-removed">1905                         result = compareStrings(getSimpleName(e1), getFullyQualifiedName(e2));</span>
<span class="line-removed">1906                     } else {</span>
<span class="line-removed">1907                         result = compareNames(e1, e2);</span>
<span class="line-removed">1908                     }</span>
<span class="line-removed">1909                     if (result != 0) {</span>
<span class="line-removed">1910                         return result;</span>
<span class="line-removed">1911                     }</span>
<span class="line-removed">1912                     // if names are the same, compare element kinds</span>
<span class="line-removed">1913                     result = compareElementKinds(e1, e2);</span>
<span class="line-removed">1914                     if (result != 0) {</span>
<span class="line-removed">1915                         return result;</span>
<span class="line-removed">1916                     }</span>
<span class="line-removed">1917                     // if element kinds are the same, and are methods,</span>
<span class="line-removed">1918                     // compare the method parameters</span>
<span class="line-removed">1919                     if (hasParameters(e1)) {</span>
<span class="line-removed">1920                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();</span>
<span class="line-removed">1921                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();</span>
<span class="line-removed">1922                         result = compareParameters(false, parameters1, parameters2);</span>
<span class="line-removed">1923                         if (result != 0) {</span>
<span class="line-removed">1924                             return result;</span>
<span class="line-removed">1925                         }</span>
<span class="line-removed">1926                         result = compareParameters(true, parameters1, parameters2);</span>
<span class="line-removed">1927                         if (result != 0) {</span>
<span class="line-removed">1928                             return result;</span>
<span class="line-removed">1929                         }</span>
<span class="line-removed">1930                     }</span>
<span class="line-removed">1931                     // else fall back on fully qualified names</span>
<span class="line-removed">1932                     return compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1933                 }</span>
<span class="line-removed">1934             };</span>
<span class="line-removed">1935         }</span>
<span class="line-removed">1936         return indexUseComparator;</span>
<span class="line-removed">1937     }</span>
<span class="line-removed">1938 </span>
<span class="line-removed">1939     private Comparator&lt;TypeMirror&gt; typeMirrorClassUseComparator = null;</span>
<span class="line-removed">1940     /**</span>
<span class="line-removed">1941      * Compares the FullyQualifiedNames of two TypeMirrors</span>
<span class="line-removed">1942      * @return</span>
<span class="line-removed">1943      */</span>
<span class="line-removed">1944     public Comparator&lt;TypeMirror&gt; makeTypeMirrorClassUseComparator() {</span>
<span class="line-removed">1945         if (typeMirrorClassUseComparator == null) {</span>
<span class="line-removed">1946             typeMirrorClassUseComparator = (TypeMirror type1, TypeMirror type2) -&gt; {</span>
<span class="line-removed">1947                 String s1 = getQualifiedTypeName(type1);</span>
<span class="line-removed">1948                 String s2 = getQualifiedTypeName(type2);</span>
<span class="line-removed">1949                 return compareStrings(s1, s2);</span>
<span class="line-removed">1950             };</span>
<span class="line-removed">1951         }</span>
<span class="line-removed">1952         return typeMirrorClassUseComparator;</span>
<span class="line-removed">1953     }</span>
<span class="line-removed">1954 </span>
<span class="line-removed">1955     private Comparator&lt;TypeMirror&gt; typeMirrorIndexUseComparator = null;</span>
<span class="line-removed">1956     /**</span>
<span class="line-removed">1957      * Compares the SimpleNames of TypeMirrors if equal then the</span>
<span class="line-removed">1958      * FullyQualifiedNames of TypeMirrors.</span>
<span class="line-removed">1959      *</span>
<span class="line-removed">1960      * @return</span>
<span class="line-removed">1961      */</span>
<span class="line-removed">1962     public Comparator&lt;TypeMirror&gt; makeTypeMirrorIndexUseComparator() {</span>
<span class="line-removed">1963         if (typeMirrorIndexUseComparator == null) {</span>
<span class="line-removed">1964             typeMirrorIndexUseComparator = (TypeMirror t1, TypeMirror t2) -&gt; {</span>
<span class="line-removed">1965                 int result = compareStrings(getTypeName(t1, false), getTypeName(t2, false));</span>
<span class="line-removed">1966                 if (result != 0)</span>
<span class="line-removed">1967                     return result;</span>
<span class="line-removed">1968                 return compareStrings(getQualifiedTypeName(t1), getQualifiedTypeName(t2));</span>
<span class="line-removed">1969             };</span>
<span class="line-removed">1970         }</span>
<span class="line-removed">1971         return typeMirrorIndexUseComparator;</span>
<span class="line-removed">1972     }</span>
<span class="line-removed">1973 </span>
1974     /**
1975      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1976      * getQualified name, returns  the qualified name of the Reference type
1977      * otherwise the primitive name.
1978      * @param t the type whose name is to be obtained.
1979      * @return the fully qualified name of Reference type or the primitive name
1980      */
1981     public String getQualifiedTypeName(TypeMirror t) {
1982         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1983             @Override
1984             public String visitDeclared(DeclaredType t, Void p) {
1985                 return getFullyQualifiedName(t.asElement());
1986             }
1987 
1988             @Override
1989             public String visitArray(ArrayType t, Void p) {
1990                return visit(t.getComponentType());
1991             }
1992 
1993             @Override
1994             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1995                 // The knee jerk reaction is to do this but don&#39;t!, as we would like
1996                 // it to be compatible with the old world, now if we decide to do so
1997                 // care must be taken to avoid collisions.
1998                 // return getFullyQualifiedName(t.asElement());
1999                 return t.toString();
2000             }
2001 
2002             @Override
2003             protected String defaultAction(TypeMirror t, Void p) {
2004                 return t.toString();
2005             }
2006 
2007         }.visit(t);
2008     }
2009 
2010     /**
2011      * A generic utility which returns the fully qualified names of an entity,
2012      * if the entity is not qualifiable then its enclosing entity, it is upto
2013      * the caller to add the elements name as required.
2014      * @param e the element to get FQN for.
2015      * @return the name
2016      */
2017     public String getFullyQualifiedName(Element e) {
2018         return getFullyQualifiedName(e, true);
2019     }
2020 
2021     @SuppressWarnings(&quot;preview&quot;)
2022     public String getFullyQualifiedName(Element e, final boolean outer) {
2023         return new SimpleElementVisitor14&lt;String, Void&gt;() {
2024             @Override
2025             public String visitModule(ModuleElement e, Void p) {
2026                 return e.getQualifiedName().toString();
2027             }
2028 
2029             @Override
2030             public String visitPackage(PackageElement e, Void p) {
2031                 return e.getQualifiedName().toString();
2032             }
2033 
2034             @Override
2035             public String visitType(TypeElement e, Void p) {
2036                 return e.getQualifiedName().toString();
2037             }
2038 
2039             @Override
2040             protected String defaultAction(Element e, Void p) {
2041                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2042             }
2043         }.visit(e);
2044     }
2045 
<a name="24" id="anc24"></a><span class="line-removed">2046     private Comparator&lt;Element&gt; classUseComparator = null;</span>
<span class="line-removed">2047 </span>
<span class="line-removed">2048     /**</span>
<span class="line-removed">2049      * Comparator for ClassUse presentations, and sorts as follows:</span>
<span class="line-removed">2050      * 1. member names</span>
<span class="line-removed">2051      * 2. then fully qualified member names</span>
<span class="line-removed">2052      * 3. then parameter types if applicable</span>
<span class="line-removed">2053      * 4. finally the element kinds ie. package, class, interface etc.</span>
<span class="line-removed">2054      * @return a comparator to sort classes and members for class use</span>
<span class="line-removed">2055      */</span>
<span class="line-removed">2056     public Comparator&lt;Element&gt; makeClassUseComparator() {</span>
<span class="line-removed">2057         if (classUseComparator == null) {</span>
<span class="line-removed">2058             classUseComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">2059                 /**</span>
<span class="line-removed">2060                  * Compares two Elements.</span>
<span class="line-removed">2061                  *</span>
<span class="line-removed">2062                  * @param e1 - an element.</span>
<span class="line-removed">2063                  * @param e2 - an element.</span>
<span class="line-removed">2064                  * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2065                  * argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2066                  */</span>
<span class="line-removed">2067                 @Override</span>
<span class="line-removed">2068                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">2069                     int result = compareNames(e1, e2);</span>
<span class="line-removed">2070                     if (result != 0) {</span>
<span class="line-removed">2071                         return result;</span>
<span class="line-removed">2072                     }</span>
<span class="line-removed">2073                     result = compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">2074                     if (result != 0) {</span>
<span class="line-removed">2075                         return result;</span>
<span class="line-removed">2076                     }</span>
<span class="line-removed">2077                     if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {</span>
<span class="line-removed">2078                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();</span>
<span class="line-removed">2079                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();</span>
<span class="line-removed">2080                         result = compareParameters(false, parameters1, parameters2);</span>
<span class="line-removed">2081                         if (result != 0) {</span>
<span class="line-removed">2082                             return result;</span>
<span class="line-removed">2083                         }</span>
<span class="line-removed">2084                         result = compareParameters(true, parameters1, parameters2);</span>
<span class="line-removed">2085                     }</span>
<span class="line-removed">2086                     if (result != 0) {</span>
<span class="line-removed">2087                         return result;</span>
<span class="line-removed">2088                     }</span>
<span class="line-removed">2089                     return compareElementKinds(e1, e2);</span>
<span class="line-removed">2090                 }</span>
<span class="line-removed">2091             };</span>
<span class="line-removed">2092         }</span>
<span class="line-removed">2093         return classUseComparator;</span>
<span class="line-removed">2094     }</span>
<span class="line-removed">2095 </span>
<span class="line-removed">2096     /**</span>
<span class="line-removed">2097      * A general purpose comparator to sort Element entities, basically provides the building blocks</span>
<span class="line-removed">2098      * for creating specific comparators for an use-case.</span>
<span class="line-removed">2099      */</span>
<span class="line-removed">2100     private abstract class ElementComparator implements Comparator&lt;Element&gt; {</span>
<span class="line-removed">2101         public ElementComparator() { }</span>
<span class="line-removed">2102 </span>
<span class="line-removed">2103         /**</span>
<span class="line-removed">2104          * compares two parameter arrays by first comparing the length of the arrays, and</span>
<span class="line-removed">2105          * then each Type of the parameter in the array.</span>
<span class="line-removed">2106          * @param params1 the first parameter array.</span>
<span class="line-removed">2107          * @param params2 the first parameter array.</span>
<span class="line-removed">2108          * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2109          *         argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2110          */</span>
<span class="line-removed">2111         protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,</span>
<span class="line-removed">2112                                                                List&lt;? extends VariableElement&gt; params2) {</span>
<span class="line-removed">2113 </span>
<span class="line-removed">2114             return compareStrings(caseSensitive, getParametersAsString(params1),</span>
<span class="line-removed">2115                                                  getParametersAsString(params2));</span>
<span class="line-removed">2116         }</span>
<span class="line-removed">2117 </span>
<span class="line-removed">2118         String getParametersAsString(List&lt;? extends VariableElement&gt; params) {</span>
<span class="line-removed">2119             StringBuilder sb = new StringBuilder();</span>
<span class="line-removed">2120             for (VariableElement param : params) {</span>
<span class="line-removed">2121                 TypeMirror t = param.asType();</span>
<span class="line-removed">2122                 // prefix P for primitive and R for reference types, thus items will</span>
<span class="line-removed">2123                 // be ordered lexically and correctly.</span>
<span class="line-removed">2124                 sb.append(getTypeCode(t)).append(&quot;-&quot;).append(t).append(&quot;-&quot;);</span>
<span class="line-removed">2125             }</span>
<span class="line-removed">2126             return sb.toString();</span>
<span class="line-removed">2127         }</span>
<span class="line-removed">2128 </span>
<span class="line-removed">2129         private String getTypeCode(TypeMirror t) {</span>
<span class="line-removed">2130             return new SimpleTypeVisitor9&lt;String, Void&gt;() {</span>
<span class="line-removed">2131 </span>
<span class="line-removed">2132                 @Override</span>
<span class="line-removed">2133                 public String visitPrimitive(PrimitiveType t, Void p) {</span>
<span class="line-removed">2134                     return &quot;P&quot;;</span>
<span class="line-removed">2135                 }</span>
<span class="line-removed">2136                 @Override</span>
<span class="line-removed">2137                 public String visitArray(ArrayType t, Void p) {</span>
<span class="line-removed">2138                     return visit(t.getComponentType());</span>
<span class="line-removed">2139                 }</span>
<span class="line-removed">2140                 @Override</span>
<span class="line-removed">2141                 protected String defaultAction(TypeMirror e, Void p) {</span>
<span class="line-removed">2142                     return &quot;R&quot;;</span>
<span class="line-removed">2143                 }</span>
<span class="line-removed">2144 </span>
<span class="line-removed">2145             }.visit(t);</span>
<span class="line-removed">2146         }</span>
<span class="line-removed">2147 </span>
<span class="line-removed">2148         /**</span>
<span class="line-removed">2149          * Compares two Elements, typically the name of a method,</span>
<span class="line-removed">2150          * field or constructor.</span>
<span class="line-removed">2151          * @param e1 the first Element.</span>
<span class="line-removed">2152          * @param e2 the second Element.</span>
<span class="line-removed">2153          * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2154          *         argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2155          */</span>
<span class="line-removed">2156         protected int compareNames(Element e1, Element e2) {</span>
<span class="line-removed">2157             return compareStrings(getSimpleName(e1), getSimpleName(e2));</span>
<span class="line-removed">2158         }</span>
<span class="line-removed">2159 </span>
<span class="line-removed">2160         /**</span>
<span class="line-removed">2161          * Compares the fully qualified names of the entities</span>
<span class="line-removed">2162          * @param e1 the first Element.</span>
<span class="line-removed">2163          * @param e2 the first Element.</span>
<span class="line-removed">2164          * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2165          *         argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2166          */</span>
<span class="line-removed">2167         protected int compareFullyQualifiedNames(Element e1, Element e2) {</span>
<span class="line-removed">2168             // add simplename to be compatible</span>
<span class="line-removed">2169             String thisElement = getFullyQualifiedName(e1);</span>
<span class="line-removed">2170             String thatElement = getFullyQualifiedName(e2);</span>
<span class="line-removed">2171             return compareStrings(thisElement, thatElement);</span>
<span class="line-removed">2172         }</span>
<span class="line-removed">2173 </span>
<span class="line-removed">2174         protected int compareElementKinds(Element e1, Element e2) {</span>
<span class="line-removed">2175             return Integer.compare(getKindIndex(e1), getKindIndex(e2));</span>
<span class="line-removed">2176         }</span>
<span class="line-removed">2177 </span>
<span class="line-removed">2178         private int getKindIndex(Element e) {</span>
<span class="line-removed">2179             switch (e.getKind()) {</span>
<span class="line-removed">2180                 case MODULE:            return 0;</span>
<span class="line-removed">2181                 case PACKAGE:           return 1;</span>
<span class="line-removed">2182                 case CLASS:             return 2;</span>
<span class="line-removed">2183                 case ENUM:              return 3;</span>
<span class="line-removed">2184                 case ENUM_CONSTANT:     return 4;</span>
<span class="line-removed">2185                 case RECORD:            return 5;</span>
<span class="line-removed">2186                 case INTERFACE:         return 6;</span>
<span class="line-removed">2187                 case ANNOTATION_TYPE:   return 7;</span>
<span class="line-removed">2188                 case FIELD:             return 8;</span>
<span class="line-removed">2189                 case CONSTRUCTOR:       return 9;</span>
<span class="line-removed">2190                 case METHOD:            return 10;</span>
<span class="line-removed">2191                 default: throw new IllegalArgumentException(e.getKind().toString());</span>
<span class="line-removed">2192             }</span>
<span class="line-removed">2193         }</span>
<span class="line-removed">2194 </span>
<span class="line-removed">2195         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-removed">2196         boolean hasParameters(Element e) {</span>
<span class="line-removed">2197             return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
<span class="line-removed">2198                 @Override</span>
<span class="line-removed">2199                 public Boolean visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-removed">2200                     return true;</span>
<span class="line-removed">2201                 }</span>
<span class="line-removed">2202 </span>
<span class="line-removed">2203                 @Override</span>
<span class="line-removed">2204                 protected Boolean defaultAction(Element e, Void p) {</span>
<span class="line-removed">2205                     return false;</span>
<span class="line-removed">2206                 }</span>
<span class="line-removed">2207 </span>
<span class="line-removed">2208             }.visit(e);</span>
<span class="line-removed">2209         }</span>
<span class="line-removed">2210 </span>
<span class="line-removed">2211         /**</span>
<span class="line-removed">2212          * The fully qualified names of the entities, used solely by the comparator.</span>
<span class="line-removed">2213          *</span>
<span class="line-removed">2214          * @return a negative integer, zero, or a positive integer as the first argument is less</span>
<span class="line-removed">2215          * than, equal to, or greater than the second.</span>
<span class="line-removed">2216          */</span>
<span class="line-removed">2217         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-removed">2218         private String getFullyQualifiedName(Element e) {</span>
<span class="line-removed">2219             return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
<span class="line-removed">2220                 @Override</span>
<span class="line-removed">2221                 public String visitModule(ModuleElement e, Void p) {</span>
<span class="line-removed">2222                     return e.getQualifiedName().toString();</span>
<span class="line-removed">2223                 }</span>
<span class="line-removed">2224 </span>
<span class="line-removed">2225                 @Override</span>
<span class="line-removed">2226                 public String visitPackage(PackageElement e, Void p) {</span>
<span class="line-removed">2227                     return e.getQualifiedName().toString();</span>
<span class="line-removed">2228                 }</span>
<span class="line-removed">2229 </span>
<span class="line-removed">2230                 @Override</span>
<span class="line-removed">2231                 public String visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-removed">2232                     // For backward compatibility</span>
<span class="line-removed">2233                     return getFullyQualifiedName(e.getEnclosingElement())</span>
<span class="line-removed">2234                             + &quot;.&quot; + e.getSimpleName().toString();</span>
<span class="line-removed">2235                 }</span>
<span class="line-removed">2236 </span>
<span class="line-removed">2237                 @Override</span>
<span class="line-removed">2238                 public String visitType(TypeElement e, Void p) {</span>
<span class="line-removed">2239                     return e.getQualifiedName().toString();</span>
<span class="line-removed">2240                 }</span>
<span class="line-removed">2241 </span>
<span class="line-removed">2242                 @Override</span>
<span class="line-removed">2243                 protected String defaultAction(Element e, Void p) {</span>
<span class="line-removed">2244                     return getEnclosingTypeElement(e).getQualifiedName().toString()</span>
<span class="line-removed">2245                             + &quot;.&quot; + e.getSimpleName().toString();</span>
<span class="line-removed">2246                 }</span>
<span class="line-removed">2247             }.visit(e);</span>
<span class="line-removed">2248         }</span>
<span class="line-removed">2249     }</span>
<span class="line-removed">2250 </span>
<span class="line-removed">2251     /**</span>
<span class="line-removed">2252      * Returns a Comparator for SearchIndexItems representing types. Items are</span>
<span class="line-removed">2253      * compared by short name, or full string representation if names are equal.</span>
<span class="line-removed">2254      *</span>
<span class="line-removed">2255      * @return a Comparator</span>
<span class="line-removed">2256      */</span>
<span class="line-removed">2257     public Comparator&lt;SearchIndexItem&gt; makeTypeSearchIndexComparator() {</span>
<span class="line-removed">2258         return (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {</span>
<span class="line-removed">2259             int result = compareStrings(sii1.getSimpleName(), sii2.getSimpleName());</span>
<span class="line-removed">2260             if (result == 0) {</span>
<span class="line-removed">2261                 // TreeSet needs this to be consistent with equal so we do</span>
<span class="line-removed">2262                 // a plain comparison of string representations as fallback.</span>
<span class="line-removed">2263                 result = sii1.toString().compareTo(sii2.toString());</span>
<span class="line-removed">2264             }</span>
<span class="line-removed">2265             return result;</span>
<span class="line-removed">2266         };</span>
<span class="line-removed">2267     }</span>
<span class="line-removed">2268 </span>
<span class="line-removed">2269     private Comparator&lt;SearchIndexItem&gt; genericSearchIndexComparator = null;</span>
<span class="line-removed">2270     /**</span>
<span class="line-removed">2271      * Returns a Comparator for SearchIndexItems representing modules, packages, or members.</span>
<span class="line-removed">2272      * Items are compared by label (member name plus signature for members, package name for</span>
<span class="line-removed">2273      * packages, and module name for modules). If labels are equal then full string</span>
<span class="line-removed">2274      * representation is compared.</span>
<span class="line-removed">2275      *</span>
<span class="line-removed">2276      * @return a Comparator</span>
<span class="line-removed">2277      */</span>
<span class="line-removed">2278     public Comparator&lt;SearchIndexItem&gt; makeGenericSearchIndexComparator() {</span>
<span class="line-removed">2279         if (genericSearchIndexComparator == null) {</span>
<span class="line-removed">2280             genericSearchIndexComparator = (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {</span>
<span class="line-removed">2281                 int result = compareStrings(sii1.getLabel(), sii2.getLabel());</span>
<span class="line-removed">2282                 if (result == 0) {</span>
<span class="line-removed">2283                     // TreeSet needs this to be consistent with equal so we do</span>
<span class="line-removed">2284                     // a plain comparison of string representations as fallback.</span>
<span class="line-removed">2285                     result = sii1.toString().compareTo(sii2.toString());</span>
<span class="line-removed">2286                 }</span>
<span class="line-removed">2287                 return result;</span>
<span class="line-removed">2288             };</span>
<span class="line-removed">2289         }</span>
<span class="line-removed">2290         return genericSearchIndexComparator;</span>
<span class="line-removed">2291     }</span>
2292 
2293     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
2294         List&lt;TypeElement&gt; out = getInterfaces(pkg);
2295         out.addAll(getClasses(pkg));
2296         out.addAll(getEnums(pkg));
2297         out.addAll(getAnnotationTypes(pkg));
2298         out.addAll(getRecords(pkg));
2299         return out;
2300     }
2301 
2302     // Element related methods
2303     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
2304         List&lt;Element&gt; members = getAnnotationFields(aClass);
2305         members.addAll(getAnnotationMethods(aClass));
2306         return members;
2307     }
2308 
2309     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
2310         return getItems0(aClass, true, FIELD);
2311     }
2312 
2313     List&lt;Element&gt; getAnnotationFieldsUnfiltered(TypeElement aClass) {
2314         return getItems0(aClass, true, FIELD);
2315     }
2316 
2317     public List&lt;Element&gt; getAnnotationMethods(TypeElement aClass) {
2318         return getItems0(aClass, true, METHOD);
2319     }
2320 
2321     public List&lt;TypeElement&gt; getAnnotationTypes(Element e) {
2322         return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));
2323     }
2324 
2325     public List&lt;TypeElement&gt; getAnnotationTypesUnfiltered(Element e) {
2326         return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
2327     }
2328 
2329     @SuppressWarnings(&quot;preview&quot;)
2330     public List&lt;TypeElement&gt; getRecords(Element e) {
2331         return convertToTypeElement(getItems(e, true, RECORD));
2332     }
2333 
2334     @SuppressWarnings(&quot;preview&quot;)
2335     public List&lt;TypeElement&gt; getRecordsUnfiltered(Element e) {
2336         return convertToTypeElement(getItems(e, false, RECORD));
2337     }
2338 
2339     public List&lt;VariableElement&gt; getFields(Element e) {
2340         return convertToVariableElement(getItems(e, true, FIELD));
2341     }
2342 
2343     public List&lt;VariableElement&gt; getFieldsUnfiltered(Element e) {
2344         return convertToVariableElement(getItems(e, false, FIELD));
2345     }
2346 
2347     public List&lt;TypeElement&gt; getClasses(Element e) {
2348        return convertToTypeElement(getItems(e, true, CLASS));
2349     }
2350 
2351     public List&lt;TypeElement&gt; getClassesUnfiltered(Element e) {
2352        return convertToTypeElement(getItems(e, false, CLASS));
2353     }
2354 
2355     public List&lt;ExecutableElement&gt; getConstructors(Element e) {
2356         return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));
2357     }
2358 
2359     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2360         return convertToExecutableElement(getItems(e, true, METHOD));
2361     }
2362 
2363     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2364         return convertToExecutableElement(getItems(e, false, METHOD));
2365     }
2366 
2367     public int getOrdinalValue(VariableElement member) {
2368         if (member == null || member.getKind() != ENUM_CONSTANT) {
2369             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2370         }
2371         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2372     }
2373 
2374     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2375     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2376         if (modulePackageMap == null) {
2377             modulePackageMap = new HashMap&lt;&gt;();
2378             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
2379             pkgs.forEach(pkg -&gt; {
2380                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2381                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2382             });
2383         }
2384         return modulePackageMap;
2385     }
2386 
2387     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
<a name="25" id="anc25"></a><span class="line-modified">2388         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());</span>
2389         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2390         // get all the requires for the element in question
2391         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2392             ModuleElement dep = rd.getDependency();
2393             // add the dependency to work queue
2394             if (!result.containsKey(dep)) {
2395                 if (rd.isTransitive()) {
2396                     queue.addLast(dep);
2397                 }
2398             }
2399             // add all exports for the primary module
2400             result.put(rd.getDependency(), getModifiers(rd));
2401         }
2402 
2403         // add only requires public for subsequent module dependencies
2404         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2405             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2406                 ModuleElement dep = rd.getDependency();
2407                 if (!result.containsKey(dep)) {
2408                     if (rd.isTransitive()) {
2409                         result.put(dep, getModifiers(rd));
2410                         queue.addLast(dep);
2411                     }
2412                 }
2413             }
2414         }
2415         return result;
2416     }
2417 
2418     public String getModifiers(RequiresDirective rd) {
2419         StringBuilder modifiers = new StringBuilder();
2420         String sep = &quot;&quot;;
2421         if (rd.isTransitive()) {
2422             modifiers.append(&quot;transitive&quot;);
2423             sep = &quot; &quot;;
2424         }
2425         if (rd.isStatic()) {
2426             modifiers.append(sep);
2427             modifiers.append(&quot;static&quot;);
2428         }
2429         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2430     }
2431 
2432     public long getLineNumber(Element e) {
2433         TreePath path = getTreePath(e);
2434         if (path == null) { // maybe null if synthesized
2435             TypeElement encl = getEnclosingTypeElement(e);
2436             path = getTreePath(encl);
2437         }
2438         CompilationUnitTree cu = path.getCompilationUnit();
2439         LineMap lineMap = cu.getLineMap();
2440         DocSourcePositions spos = docTrees.getSourcePositions();
2441         long pos = spos.getStartPosition(cu, path.getLeaf());
2442         return lineMap.getLineNumber(pos);
2443     }
2444 
2445     public List&lt;ExecutableElement&gt; convertToExecutableElement(List&lt;Element&gt; list) {
2446         List&lt;ExecutableElement&gt; out = new ArrayList&lt;&gt;(list.size());
2447         for (Element e : list) {
2448             out.add((ExecutableElement)e);
2449         }
2450         return out;
2451     }
2452 
2453     public List&lt;TypeElement&gt; convertToTypeElement(List&lt;Element&gt; list) {
2454         List&lt;TypeElement&gt; out = new ArrayList&lt;&gt;(list.size());
2455         for (Element e : list) {
2456             out.add((TypeElement)e);
2457         }
2458         return out;
2459     }
2460 
2461     public List&lt;VariableElement&gt; convertToVariableElement(List&lt;Element&gt; list) {
2462         List&lt;VariableElement&gt; out = new ArrayList&lt;&gt;(list.size());
2463         for (Element e : list) {
2464             out.add((VariableElement) e);
2465         }
2466         return out;
2467     }
2468 
2469     public List&lt;TypeElement&gt; getInterfaces(Element e)  {
2470         return convertToTypeElement(getItems(e, true, INTERFACE));
2471     }
2472 
2473     public List&lt;TypeElement&gt; getInterfacesUnfiltered(Element e)  {
2474         return convertToTypeElement(getItems(e, false, INTERFACE));
2475     }
2476 
2477     public List&lt;Element&gt; getEnumConstants(Element e) {
2478         return getItems(e, true, ENUM_CONSTANT);
2479     }
2480 
2481     public List&lt;TypeElement&gt; getEnums(Element e) {
2482         return convertToTypeElement(getItems(e, true, ENUM));
2483     }
2484 
2485     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2486         return convertToTypeElement(getItems(e, false, ENUM));
2487     }
2488 
2489     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2490         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2491         clist.addAll(getInterfacesUnfiltered(e));
2492         clist.addAll(getAnnotationTypesUnfiltered(e));
2493         clist.addAll(getRecordsUnfiltered(e));
<a name="26" id="anc26"></a><span class="line-modified">2494         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
2495         oset.addAll(clist);
2496         return oset;
2497     }
2498 
2499     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2500     /**
2501      * Returns a list containing classes and interfaces,
2502      * including annotation types.
2503      * @param e Element
2504      * @return List
2505      */
2506     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2507         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2508         if (oset != null)
2509             return oset;
2510         List&lt;TypeElement&gt; clist = getClasses(e);
2511         clist.addAll(getInterfaces(e));
2512         clist.addAll(getAnnotationTypes(e));
2513         clist.addAll(getEnums(e));
2514         clist.addAll(getRecords(e));
<a name="27" id="anc27"></a><span class="line-modified">2515         oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
2516         oset.addAll(clist);
2517         cachedClasses.put(e, oset);
2518         return oset;
2519     }
2520 
2521     /*
2522      * Get all the elements unfiltered and filter them finally based
2523      * on its visibility, this works differently from the other getters.
2524      */
2525     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2526         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2527         for (TypeElement te : getClassesUnfiltered(e)) {
2528             if (!filter || configuration.docEnv.isSelected(te)) {
2529                 olist.add(te);
2530             }
2531         }
2532         for (TypeElement te : getInterfacesUnfiltered(e)) {
2533             if (!filter || configuration.docEnv.isSelected(te)) {
2534                 olist.add(te);
2535             }
2536         }
2537         for (TypeElement te : getAnnotationTypesUnfiltered(e)) {
2538             if (!filter || configuration.docEnv.isSelected(te)) {
2539                 olist.add(te);
2540             }
2541         }
2542         for (TypeElement te : getEnumsUnfiltered(e)) {
2543             if (!filter || configuration.docEnv.isSelected(te)) {
2544                 olist.add(te);
2545             }
2546         }
2547         return olist;
2548     }
2549 
2550     public List&lt;TypeElement&gt; getInnerClasses(Element e) {
2551         return getInnerClasses(e, true);
2552     }
2553 
2554     public List&lt;TypeElement&gt; getInnerClassesUnfiltered(Element e) {
2555         return getInnerClasses(e, false);
2556     }
2557 
2558     /**
2559      * Returns a list of classes that are not errors or exceptions
2560      * @param e Element
2561      * @return List
2562      */
2563     public List&lt;TypeElement&gt; getOrdinaryClasses(Element e) {
2564         return getClasses(e).stream()
2565                 .filter(te -&gt; (!isException(te) &amp;&amp; !isError(te)))
2566                 .collect(Collectors.toList());
2567     }
2568 
2569     public List&lt;TypeElement&gt; getErrors(Element e) {
2570         return getClasses(e)
2571                 .stream()
2572                 .filter(this::isError)
2573                 .collect(Collectors.toList());
2574     }
2575 
2576     public List&lt;TypeElement&gt; getExceptions(Element e) {
2577         return getClasses(e)
2578                 .stream()
2579                 .filter(this::isException)
2580                 .collect(Collectors.toList());
2581     }
2582 
2583     @SuppressWarnings(&quot;preview&quot;)
2584     List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
2585         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2586         return new SimpleElementVisitor14&lt;List&lt;Element&gt;, Void&gt;() {
2587 
2588             @Override
2589             public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
2590                 recursiveGetItems(elements, e, filter, select);
2591                 return elements;
2592             }
2593 
2594             @Override
2595             protected List&lt;Element&gt; defaultAction(Element e0, Void p) {
2596                 return getItems0(e0, filter, select);
2597             }
2598 
2599         }.visit(e);
2600     }
2601 
2602     Set&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);
2603     void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
2604         list.addAll(getItems0(e, filter, select));
2605         List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
2606         for (Element c : classes) {
2607             list.addAll(getItems0(c, filter, select));
2608             if (isTypeElement(c)) {
2609                 recursiveGetItems(list, c, filter, select);
2610             }
2611         }
2612     }
2613 
2614     private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
2615         Set&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));
2616         return getItems0(te, filter, kinds);
2617     }
2618 
2619     private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
2620         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2621         for (Element e : te.getEnclosedElements()) {
2622             if (kinds.contains(e.getKind())) {
2623                 if (!filter || shouldDocument(e)) {
2624                     elements.add(e);
2625                 }
2626             }
2627         }
2628         return elements;
2629     }
2630 
2631     @SuppressWarnings(&quot;preview&quot;)
2632     private SimpleElementVisitor14&lt;Boolean, Void&gt; shouldDocumentVisitor = null;
2633 
2634     @SuppressWarnings(&quot;preview&quot;)
2635     public boolean shouldDocument(Element e) {
2636         if (shouldDocumentVisitor == null) {
2637             shouldDocumentVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2638                 private boolean hasSource(TypeElement e) {
2639                     return configuration.docEnv.getFileKind(e) ==
2640                             javax.tools.JavaFileObject.Kind.SOURCE;
2641                 }
2642 
2643                 // handle types
2644                 @Override
2645                 public Boolean visitType(TypeElement e, Void p) {
2646                     // treat inner classes etc as members
2647                     if (e.getNestingKind().isNested()) {
2648                         return defaultAction(e, p);
2649                     }
2650                     return configuration.docEnv.isSelected(e) &amp;&amp; hasSource(e);
2651                 }
2652 
2653                 // handle everything else
2654                 @Override
2655                 protected Boolean defaultAction(Element e, Void p) {
2656                     return configuration.docEnv.isSelected(e);
2657                 }
2658 
2659                 @Override
2660                 public Boolean visitUnknown(Element e, Void p) {
2661                     throw new AssertionError(&quot;unknown element: &quot; + e);
2662                 }
2663             };
2664         }
2665         return shouldDocumentVisitor.visit(e);
2666     }
2667 
2668     /*
2669      * nameCache is maintained for improving the comparator
2670      * performance, noting that the Collator used by the comparators
2671      * use Strings, as of this writing.
2672      * TODO: when those APIs handle charSequences, the use of
2673      * this nameCache must be re-investigated and removed.
2674      */
2675     private final Map&lt;Element, String&gt; nameCache = new LinkedHashMap&lt;&gt;();
2676 
2677     /**
2678      * Returns the name of the element after the last dot of the package name.
2679      * This emulates the behavior of the old doclet.
2680      * @param e an element whose name is required
2681      * @return the name
2682      */
2683     public String getSimpleName(Element e) {
2684         return nameCache.computeIfAbsent(e, this::getSimpleName0);
2685     }
2686 
2687     @SuppressWarnings(&quot;preview&quot;)
2688     private SimpleElementVisitor14&lt;String, Void&gt; snvisitor = null;
2689 
2690     @SuppressWarnings(&quot;preview&quot;)
2691     private String getSimpleName0(Element e) {
2692         if (snvisitor == null) {
2693             snvisitor = new SimpleElementVisitor14&lt;String, Void&gt;() {
2694                 @Override
2695                 public String visitModule(ModuleElement e, Void p) {
2696                     return e.getQualifiedName().toString();  // temp fix for 8182736
2697                 }
2698 
2699                 @Override
2700                 public String visitType(TypeElement e, Void p) {
2701                     StringBuilder sb = new StringBuilder(e.getSimpleName());
2702                     Element enclosed = e.getEnclosingElement();
2703                     while (enclosed != null
2704                             &amp;&amp; (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {
2705                         sb.insert(0, enclosed.getSimpleName() + &quot;.&quot;);
2706                         enclosed = enclosed.getEnclosingElement();
2707                     }
2708                     return sb.toString();
2709                 }
2710 
2711                 @Override
2712                 public String visitExecutable(ExecutableElement e, Void p) {
2713                     if (e.getKind() == CONSTRUCTOR || e.getKind() == STATIC_INIT) {
2714                         return e.getEnclosingElement().getSimpleName().toString();
2715                     }
2716                     return e.getSimpleName().toString();
2717                 }
2718 
2719                 @Override
2720                 protected String defaultAction(Element e, Void p) {
2721                     return e.getSimpleName().toString();
2722                 }
2723             };
2724         }
2725         return snvisitor.visit(e);
2726     }
2727 
2728     public TypeElement getEnclosingTypeElement(Element e) {
2729         if (e.getKind() == ElementKind.PACKAGE)
2730             return null;
2731         Element encl = e.getEnclosingElement();
2732         ElementKind kind = encl.getKind();
2733         if (kind == ElementKind.PACKAGE)
2734             return null;
2735         while (!(kind.isClass() || kind.isInterface())) {
2736             encl = encl.getEnclosingElement();
2737             kind = encl.getKind();
2738         }
2739         return (TypeElement)encl;
2740     }
2741 
2742     private ConstantValueExpression cve = null;
2743 
2744     public String constantValueExpresion(VariableElement ve) {
2745         if (cve == null)
2746             cve = new ConstantValueExpression();
2747         return cve.constantValueExpression(configuration.workArounds, ve);
2748     }
2749 
2750     private static class ConstantValueExpression {
2751         public String constantValueExpression(WorkArounds workArounds, VariableElement ve) {
2752             return new TypeKindVisitor9&lt;String, Object&gt;() {
2753                 /* TODO: we need to fix this correctly.
2754                  * we have a discrepancy here, note the use of getConstValue
2755                  * vs. getConstantValue, at some point we need to use
2756                  * getConstantValue.
2757                  * In the legacy world byte and char primitives appear as Integer values,
2758                  * thus a byte value of 127 will appear as 127, but in the new world,
2759                  * a byte value appears as Byte thus 0x7f will be printed, similarly
2760                  * chars will be  translated to \n, \r etc. however, in the new world,
2761                  * they will be printed as decimal values. The new world is correct,
2762                  * and we should fix this by using getConstantValue and the visitor to
2763                  * address this in the future.
2764                  */
2765                 @Override
2766                 public String visitPrimitiveAsBoolean(PrimitiveType t, Object val) {
2767                     return (int)val == 0 ? &quot;false&quot; : &quot;true&quot;;
2768                 }
2769 
2770                 @Override
2771                 public String visitPrimitiveAsDouble(PrimitiveType t, Object val) {
2772                     return sourceForm(((Double)val), &#39;d&#39;);
2773                 }
2774 
2775                 @Override
2776                 public String visitPrimitiveAsFloat(PrimitiveType t, Object val) {
2777                     return sourceForm(((Float)val).doubleValue(), &#39;f&#39;);
2778                 }
2779 
2780                 @Override
2781                 public String visitPrimitiveAsLong(PrimitiveType t, Object val) {
2782                     return val + &quot;L&quot;;
2783                 }
2784 
2785                 @Override
2786                 protected String defaultAction(TypeMirror e, Object val) {
2787                     if (val == null)
2788                         return null;
2789                     else if (val instanceof Character)
2790                         return sourceForm(((Character)val));
2791                     else if (val instanceof Byte)
2792                         return sourceForm(((Byte)val));
2793                     else if (val instanceof String)
2794                         return sourceForm((String)val);
2795                     return val.toString(); // covers int, short
2796                 }
2797             }.visit(ve.asType(), workArounds.getConstValue(ve));
2798         }
2799 
2800         // where
2801         private String sourceForm(double v, char suffix) {
2802             if (Double.isNaN(v))
2803                 return &quot;0&quot; + suffix + &quot;/0&quot; + suffix;
2804             if (v == Double.POSITIVE_INFINITY)
2805                 return &quot;1&quot; + suffix + &quot;/0&quot; + suffix;
2806             if (v == Double.NEGATIVE_INFINITY)
2807                 return &quot;-1&quot; + suffix + &quot;/0&quot; + suffix;
2808             return v + (suffix == &#39;f&#39; || suffix == &#39;F&#39; ? &quot;&quot; + suffix : &quot;&quot;);
2809         }
2810 
2811         private  String sourceForm(char c) {
2812             StringBuilder buf = new StringBuilder(8);
2813             buf.append(&#39;\&#39;&#39;);
2814             sourceChar(c, buf);
2815             buf.append(&#39;\&#39;&#39;);
2816             return buf.toString();
2817         }
2818 
2819         private String sourceForm(byte c) {
2820             return &quot;0x&quot; + Integer.toString(c &amp; 0xff, 16);
2821         }
2822 
2823         private String sourceForm(String s) {
2824             StringBuilder buf = new StringBuilder(s.length() + 5);
2825             buf.append(&#39;\&quot;&#39;);
2826             for (int i=0; i&lt;s.length(); i++) {
2827                 char c = s.charAt(i);
2828                 sourceChar(c, buf);
2829             }
2830             buf.append(&#39;\&quot;&#39;);
2831             return buf.toString();
2832         }
2833 
2834         private void sourceChar(char c, StringBuilder buf) {
2835             switch (c) {
2836             case &#39;\b&#39;: buf.append(&quot;\\b&quot;); return;
2837             case &#39;\t&#39;: buf.append(&quot;\\t&quot;); return;
2838             case &#39;\n&#39;: buf.append(&quot;\\n&quot;); return;
2839             case &#39;\f&#39;: buf.append(&quot;\\f&quot;); return;
2840             case &#39;\r&#39;: buf.append(&quot;\\r&quot;); return;
2841             case &#39;\&quot;&#39;: buf.append(&quot;\\\&quot;&quot;); return;
2842             case &#39;\&#39;&#39;: buf.append(&quot;\\\&#39;&quot;); return;
2843             case &#39;\\&#39;: buf.append(&quot;\\\\&quot;); return;
2844             default:
2845                 if (isPrintableAscii(c)) {
2846                     buf.append(c); return;
2847                 }
2848                 unicodeEscape(c, buf);
2849                 return;
2850             }
2851         }
2852 
2853         private void unicodeEscape(char c, StringBuilder buf) {
2854             final String chars = &quot;0123456789abcdef&quot;;
2855             buf.append(&quot;\\u&quot;);
2856             buf.append(chars.charAt(15 &amp; (c&gt;&gt;12)));
2857             buf.append(chars.charAt(15 &amp; (c&gt;&gt;8)));
2858             buf.append(chars.charAt(15 &amp; (c&gt;&gt;4)));
2859             buf.append(chars.charAt(15 &amp; (c&gt;&gt;0)));
2860         }
2861         private boolean isPrintableAscii(char c) {
2862             return c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;;
2863         }
2864     }
2865 
2866     public boolean isEnclosingPackageIncluded(TypeElement te) {
2867         return isIncluded(containingPackage(te));
2868     }
2869 
2870     public boolean isIncluded(Element e) {
2871         return configuration.docEnv.isIncluded(e);
2872     }
2873 
2874     @SuppressWarnings(&quot;preview&quot;)
2875     private SimpleElementVisitor14&lt;Boolean, Void&gt; specifiedVisitor = null;
2876     @SuppressWarnings(&quot;preview&quot;)
2877     public boolean isSpecified(Element e) {
2878         if (specifiedVisitor == null) {
2879             specifiedVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2880                 @Override
2881                 public Boolean visitModule(ModuleElement e, Void p) {
2882                     return configuration.getSpecifiedModuleElements().contains(e);
2883                 }
2884 
2885                 @Override
2886                 public Boolean visitPackage(PackageElement e, Void p) {
2887                     return configuration.getSpecifiedPackageElements().contains(e);
2888                 }
2889 
2890                 @Override
2891                 public Boolean visitType(TypeElement e, Void p) {
2892                     return configuration.getSpecifiedTypeElements().contains(e);
2893                 }
2894 
2895                 @Override
2896                 protected Boolean defaultAction(Element e, Void p) {
2897                     return false;
2898                 }
2899             };
2900         }
2901         return specifiedVisitor.visit(e);
2902     }
2903 
2904     /**
2905      * Get the package name for a given package element. An unnamed package is returned as &amp;lt;Unnamed&amp;gt;
2906      *
2907      * @param pkg
2908      * @return
2909      */
2910     public String getPackageName(PackageElement pkg) {
2911         if (pkg == null || pkg.isUnnamed()) {
2912             return DocletConstants.DEFAULT_PACKAGE_NAME;
2913         }
2914         return pkg.getQualifiedName().toString();
2915     }
2916 
2917     /**
2918      * Get the module name for a given module element. An unnamed module is returned as &amp;lt;Unnamed&amp;gt;
2919      *
2920      * @param mdle a ModuleElement
2921      * @return
2922      */
2923     public String getModuleName(ModuleElement mdle) {
2924         if (mdle == null || mdle.isUnnamed()) {
2925             return DocletConstants.DEFAULT_ELEMENT_NAME;
2926         }
2927         return mdle.getQualifiedName().toString();
2928     }
2929 
2930     public boolean isAttribute(DocTree doctree) {
2931         return isKind(doctree, ATTRIBUTE);
2932     }
2933 
2934     public boolean isAuthor(DocTree doctree) {
2935         return isKind(doctree, AUTHOR);
2936     }
2937 
2938     public boolean isComment(DocTree doctree) {
2939         return isKind(doctree, COMMENT);
2940     }
2941 
2942     public boolean isDeprecated(DocTree doctree) {
2943         return isKind(doctree, DEPRECATED);
2944     }
2945 
2946     public boolean isDocComment(DocTree doctree) {
2947         return isKind(doctree, DOC_COMMENT);
2948     }
2949 
2950     public boolean isDocRoot(DocTree doctree) {
2951         return isKind(doctree, DOC_ROOT);
2952     }
2953 
2954     public boolean isEndElement(DocTree doctree) {
2955         return isKind(doctree, END_ELEMENT);
2956     }
2957 
2958     public boolean isEntity(DocTree doctree) {
2959         return isKind(doctree, ENTITY);
2960     }
2961 
2962     public boolean isErroneous(DocTree doctree) {
2963         return isKind(doctree, ERRONEOUS);
2964     }
2965 
2966     public boolean isException(DocTree doctree) {
2967         return isKind(doctree, EXCEPTION);
2968     }
2969 
2970     public boolean isIdentifier(DocTree doctree) {
2971         return isKind(doctree, IDENTIFIER);
2972     }
2973 
2974     public boolean isInheritDoc(DocTree doctree) {
2975         return isKind(doctree, INHERIT_DOC);
2976     }
2977 
2978     public boolean isLink(DocTree doctree) {
2979         return isKind(doctree, LINK);
2980     }
2981 
2982     public boolean isLinkPlain(DocTree doctree) {
2983         return isKind(doctree, LINK_PLAIN);
2984     }
2985 
2986     public boolean isLiteral(DocTree doctree) {
2987         return isKind(doctree, LITERAL);
2988     }
2989 
2990     public boolean isOther(DocTree doctree) {
2991         return doctree.getKind() == DocTree.Kind.OTHER;
2992     }
2993 
2994     public boolean isParam(DocTree doctree) {
2995         return isKind(doctree, PARAM);
2996     }
2997 
2998     public boolean isReference(DocTree doctree) {
2999         return isKind(doctree, REFERENCE);
3000     }
3001 
3002     public boolean isReturn(DocTree doctree) {
3003         return isKind(doctree, RETURN);
3004     }
3005 
3006     public boolean isSee(DocTree doctree) {
3007         return isKind(doctree, SEE);
3008     }
3009 
3010     public boolean isSerial(DocTree doctree) {
3011         return isKind(doctree, SERIAL);
3012     }
3013 
3014     public boolean isSerialData(DocTree doctree) {
3015         return isKind(doctree, SERIAL_DATA);
3016     }
3017 
3018     public boolean isSerialField(DocTree doctree) {
3019         return isKind(doctree, SERIAL_FIELD);
3020     }
3021 
3022     public boolean isSince(DocTree doctree) {
3023         return isKind(doctree, SINCE);
3024     }
3025 
3026     public boolean isStartElement(DocTree doctree) {
3027         return isKind(doctree, START_ELEMENT);
3028     }
3029 
3030     public boolean isText(DocTree doctree) {
3031         return isKind(doctree, TEXT);
3032     }
3033 
3034     public boolean isThrows(DocTree doctree) {
3035         return isKind(doctree, THROWS);
3036     }
3037 
3038     public boolean isUnknownBlockTag(DocTree doctree) {
3039         return isKind(doctree, UNKNOWN_BLOCK_TAG);
3040     }
3041 
3042     public boolean isUnknownInlineTag(DocTree doctree) {
3043         return isKind(doctree, UNKNOWN_INLINE_TAG);
3044     }
3045 
3046     public boolean isValue(DocTree doctree) {
3047         return isKind(doctree, Kind.VALUE);
3048     }
3049 
3050     public boolean isVersion(DocTree doctree) {
3051         return isKind(doctree, VERSION);
3052     }
3053 
3054     private boolean isKind(DocTree doctree, DocTree.Kind match) {
3055         return  doctree.getKind() == match;
3056     }
3057 
3058     private final CommentHelperCache commentHelperCache = new CommentHelperCache(this);
3059 
3060     public CommentHelper getCommentHelper(Element element) {
3061         return commentHelperCache.computeIfAbsent(element);
3062     }
3063 
3064     public void removeCommentHelper(Element element) {
3065         commentHelperCache.remove(element);
3066     }
3067 
3068     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {
3069         DocCommentTree dcTree = getDocCommentTree(element);
3070         return dcTree == null ? Collections.emptyList() : dcTree.getBlockTags();
3071     }
3072 
3073     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Predicate&lt;DocTree&gt; filter) {
3074         return getBlockTags(element).stream()
3075                 .filter(t -&gt; t.getKind() != ERRONEOUS)
3076                 .filter(filter)
3077                 .collect(Collectors.toList());
3078     }
3079 
3080     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind) {
3081         return getBlockTags(element, t -&gt; t.getKind() == kind);
3082     }
3083 
3084     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {
3085         return getBlockTags(element, t -&gt; t.getKind() == kind || t.getKind() == altKind);
3086     }
3087 
3088     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Taglet taglet) {
3089         return getBlockTags(element, t -&gt; {
3090             if (taglet instanceof BaseTaglet) {
3091                 return ((BaseTaglet) taglet).accepts(t);
3092             } else if (t instanceof UnknownBlockTagTree) {
3093                 return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());
3094             } else {
3095                 return false;
3096             }
3097         });
3098     }
3099 
3100     public boolean hasBlockTag(Element element, DocTree.Kind kind) {
3101         return hasBlockTag(element, kind, null);
3102     }
3103 
3104     public boolean hasBlockTag(Element element, DocTree.Kind kind, final String tagName) {
3105         CommentHelper ch = getCommentHelper(element);
3106         String tname = tagName != null &amp;&amp; tagName.startsWith(&quot;@&quot;)
3107                 ? tagName.substring(1)
3108                 : tagName;
3109         for (DocTree dt : getBlockTags(element, kind)) {
3110             if (dt.getKind() == kind) {
3111                 if (tname == null || ch.getTagName(dt).equals(tname)) {
3112                     return true;
3113                 }
3114             }
3115         }
3116         return false;
3117     }
3118 
3119     /**
3120      * Gets a TreePath for an Element. Note this method is called very
3121      * frequently, care must be taken to ensure this method is lithe
3122      * and efficient.
3123      * @param e an Element
3124      * @return TreePath
3125      */
3126     public TreePath getTreePath(Element e) {
3127         DocCommentDuo duo = dcTreeCache.get(e);
3128         if (duo != null &amp;&amp; duo.treePath != null) {
3129             return duo.treePath;
3130         }
3131         duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
3132         if (duo != null &amp;&amp; duo.treePath != null) {
3133             return duo.treePath;
3134         }
3135         Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
3136         TreePath path = elementToTreePath.get(e);
3137         if (path != null || elementToTreePath.containsKey(e)) {
3138             // expedite the path and one that is a null
3139             return path;
3140         }
3141         return elementToTreePath.computeIfAbsent(e, docTrees::getPath);
3142     }
3143 
3144     private final Map&lt;Element, DocCommentDuo&gt; dcTreeCache = new LinkedHashMap&lt;&gt;();
3145 
3146     /**
3147      * Retrieves the doc comments for a given element.
3148      * @param element
3149      * @return DocCommentTree for the Element
3150      */
3151     public DocCommentTree getDocCommentTree0(Element element) {
3152 
3153         DocCommentDuo duo = null;
3154 
3155         ElementKind kind = element.getKind();
3156         if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
3157             duo = dcTreeCache.get(element); // local cache
3158             if (duo == null &amp;&amp; kind == ElementKind.PACKAGE) {
3159                 // package-info.java
3160                 duo = getDocCommentTuple(element);
3161             }
3162             if (duo == null) {
3163                 // package.html or overview.html
3164                 duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
3165             }
3166         } else {
3167             duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
3168             if (duo == null) {
3169                 duo = dcTreeCache.get(element); // local cache
3170             }
3171             if (duo == null) {
3172                 duo = getDocCommentTuple(element); // get the real mccoy
3173             }
3174         }
3175 
3176         DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
3177         TreePath path = isValidDuo(duo) ? duo.treePath : null;
3178         if (!dcTreeCache.containsKey(element)) {
3179             if (docCommentTree != null &amp;&amp; path != null) {
3180                 if (!configuration.isAllowScriptInComments()) {
3181                     try {
3182                         javaScriptScanner.scan(docCommentTree, path, p -&gt; {
3183                             throw new JavaScriptScanner.Fault();
3184                         });
3185                     } catch (JavaScriptScanner.Fault jsf) {
3186                         String text = resources.getText(&quot;doclet.JavaScript_in_comment&quot;);
3187                         throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3188                     }
3189                 }
3190                 configuration.workArounds.runDocLint(path);
3191             }
3192             dcTreeCache.put(element, duo);
3193         }
3194         return docCommentTree;
3195     }
3196 
3197     private DocCommentDuo getDocCommentTuple(Element element) {
3198         // prevent nasty things downstream with overview element
3199         if (element.getKind() != ElementKind.OTHER) {
3200             TreePath path = getTreePath(element);
3201             if (path != null) {
3202                 DocCommentTree docCommentTree = docTrees.getDocCommentTree(path);
3203                 return new DocCommentDuo(path, docCommentTree);
3204             }
3205         }
3206         return null;
3207     }
3208 
3209     public void checkJavaScriptInOption(String name, String value) {
3210         if (!configuration.isAllowScriptInComments()) {
3211             DocCommentTree dct = configuration.cmtUtils.parse(
3212                     URI.create(&quot;option://&quot; + name.replace(&quot;-&quot;, &quot;&quot;)), &quot;&lt;body&gt;&quot; + value + &quot;&lt;/body&gt;&quot;);
3213 
3214             if (dct == null)
3215                 return;
3216 
3217             try {
3218                 javaScriptScanner.scan(dct, null, p -&gt; {
3219                     throw new JavaScriptScanner.Fault();
3220                 });
3221             } catch (JavaScriptScanner.Fault jsf) {
3222                 String text = resources.getText(&quot;doclet.JavaScript_in_option&quot;, name);
3223                 throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3224             }
3225         }
3226     }
3227 
3228     boolean isValidDuo(DocCommentDuo duo) {
3229         return duo != null &amp;&amp; duo.dcTree != null;
3230     }
3231 
3232     public DocCommentTree getDocCommentTree(Element element) {
3233         CommentHelper ch = commentHelperCache.get(element);
3234         if (ch != null) {
3235             return ch.dcTree;
3236         }
3237         DocCommentTree dcTree = getDocCommentTree0(element);
3238         if (dcTree != null) {
3239             commentHelperCache.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));
3240         }
3241         return dcTree;
3242     }
3243 
3244     public List&lt;? extends DocTree&gt; getPreamble(Element element) {
3245         DocCommentTree docCommentTree = getDocCommentTree(element);
3246         return docCommentTree == null
3247                 ? Collections.emptyList()
3248                 : docCommentTree.getPreamble();
3249     }
3250 
3251     public List&lt;? extends DocTree&gt; getFullBody(Element element) {
3252         DocCommentTree docCommentTree = getDocCommentTree(element);
3253             return (docCommentTree == null)
3254                     ? Collections.emptyList()
3255                     : docCommentTree.getFullBody();
3256     }
3257 
3258     public List&lt;? extends DocTree&gt; getBody(Element element) {
3259         DocCommentTree docCommentTree = getDocCommentTree(element);
3260         return (docCommentTree == null)
3261                 ? Collections.emptyList()
3262                 : docCommentTree.getFullBody();
3263     }
3264 
3265     public List&lt;? extends DocTree&gt; getDeprecatedTrees(Element element) {
3266         return getBlockTags(element, DEPRECATED);
3267     }
3268 
3269     public List&lt;? extends DocTree&gt; getProvidesTrees(Element element) {
3270         return getBlockTags(element, PROVIDES);
3271     }
3272 
3273     public List&lt;? extends DocTree&gt; getSeeTrees(Element element) {
3274         return getBlockTags(element, SEE);
3275     }
3276 
3277     public List&lt;? extends DocTree&gt; getSerialTrees(Element element) {
3278         return getBlockTags(element, SERIAL);
3279     }
3280 
3281     public List&lt;? extends DocTree&gt; getSerialFieldTrees(VariableElement field) {
3282         return getBlockTags(field, DocTree.Kind.SERIAL_FIELD);
3283     }
3284 
3285     public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
3286         return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
3287     }
3288 
3289     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
3290         return getParamTrees(element, true);
3291     }
3292 
3293     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
3294         return getParamTrees(element, false);
3295     }
3296 
3297     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
3298         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
3299         for (DocTree dt : getBlockTags(element, PARAM)) {
3300             ParamTree pt = (ParamTree) dt;
3301             if (pt.isTypeParameter() == isTypeParameters) {
3302                 out.add(pt);
3303             }
3304         }
3305         return out;
3306     }
3307 
3308     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
3309         return new ArrayList&lt;&gt;(getBlockTags(element, RETURN));
3310     }
3311 
3312     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3313         return getBlockTags(element, USES);
3314     }
3315 
3316     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3317         DocCommentTree dcTree = getDocCommentTree(element);
3318         if (dcTree == null) {
3319             return Collections.emptyList();
3320         }
3321         return new ArrayList&lt;&gt;(dcTree.getFirstSentence());
3322     }
3323 
3324     public ModuleElement containingModule(Element e) {
3325         return elementUtils.getModuleOf(e);
3326     }
3327 
3328     public PackageElement containingPackage(Element e) {
3329         return elementUtils.getPackageOf(e);
3330     }
3331 
3332     public TypeElement getTopMostContainingTypeElement(Element e) {
3333         if (isPackage(e)) {
3334             return null;
3335         }
3336         TypeElement outer = getEnclosingTypeElement(e);
3337         if (outer == null)
3338             return (TypeElement)e;
3339         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3340             outer = getEnclosingTypeElement(outer);
3341         }
3342         return outer;
3343     }
3344 
3345     /**
3346      * A memory-sensitive cache for {@link CommentHelper} objects,
3347      * which are expensive to compute.
3348      */
3349     private static class CommentHelperCache {
3350 
3351         private final Map&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; map;
3352         private final Utils utils;
3353 
3354         public CommentHelperCache(Utils utils) {
3355             map = new HashMap&lt;&gt;();
3356             this.utils = utils;
3357         }
3358 
3359         public CommentHelper remove(Element key) {
3360             SoftReference&lt;CommentHelper&gt; value = map.remove(key);
3361             return value == null ? null : value.get();
3362         }
3363 
3364         public CommentHelper put(Element key, CommentHelper value) {
3365             SoftReference&lt;CommentHelper&gt; prev = map.put(key, new SoftReference&lt;&gt;(value));
3366             return prev == null ? null : prev.get();
3367         }
3368 
3369         public CommentHelper get(Object key) {
3370             SoftReference&lt;CommentHelper&gt; value = map.get(key);
3371             return value == null ? null : value.get();
3372         }
3373 
3374         public CommentHelper computeIfAbsent(Element key) {
3375             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);
3376             if (refValue != null) {
3377                 CommentHelper value = refValue.get();
3378                 if (value != null) {
3379                     return value;
3380                 }
3381             }
3382             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3383                     utils.getDocCommentTree(key));
3384             map.put(key, new SoftReference&lt;&gt;(newValue));
3385             return newValue;
3386         }
3387     }
3388 
3389     /**
3390      * A container holding a pair of values (tuple).
3391      *
3392      * @param &lt;K&gt; the type of the first value
3393      * @param &lt;L&gt; the type of the second value
3394      */
3395     public static class Pair&lt;K, L&gt; {
3396         public final K first;
3397         public final L second;
3398 
3399         public Pair(K first, L second) {
3400             this.first = first;
3401             this.second = second;
3402         }
3403 
3404         @Override
3405         public String toString() {
3406             return first + &quot;:&quot; + second;
3407         }
3408     }
3409 }
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
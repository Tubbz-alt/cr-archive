<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../../java.base/share/classes/java/lang/System.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.ArrayDeque;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;
<span class="line-removed">  40 import java.util.Comparator;</span>
  41 import java.util.Deque;
  42 import java.util.EnumSet;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.Iterator;
  46 import java.util.LinkedHashMap;
  47 import java.util.LinkedHashSet;
  48 import java.util.List;
  49 import java.util.Locale;
  50 import java.util.Map;
  51 import java.util.Map.Entry;
  52 import java.util.Objects;
  53 import java.util.Set;
  54 import java.util.SortedSet;
  55 import java.util.TreeMap;
  56 import java.util.TreeSet;
  57 import java.util.function.Predicate;
  58 import java.util.stream.Collectors;
  59 
  60 import javax.lang.model.SourceVersion;
</pre>
<hr />
<pre>
  80 import javax.lang.model.type.TypeMirror;
  81 import javax.lang.model.type.TypeVariable;
  82 import javax.lang.model.type.WildcardType;
  83 import javax.lang.model.util.ElementFilter;
  84 import javax.lang.model.util.ElementKindVisitor14;
  85 import javax.lang.model.util.Elements;
  86 import javax.lang.model.util.SimpleElementVisitor14;
  87 import javax.lang.model.util.SimpleTypeVisitor9;
  88 import javax.lang.model.util.TypeKindVisitor9;
  89 import javax.lang.model.util.Types;
  90 import javax.tools.FileObject;
  91 import javax.tools.JavaFileManager;
  92 import javax.tools.JavaFileManager.Location;
  93 import javax.tools.StandardLocation;
  94 
  95 import com.sun.source.doctree.DocCommentTree;
  96 import com.sun.source.doctree.DocTree;
  97 import com.sun.source.doctree.DocTree.Kind;
  98 import com.sun.source.doctree.EndElementTree;
  99 import com.sun.source.doctree.ParamTree;
<span class="line-removed"> 100 import com.sun.source.doctree.SerialFieldTree;</span>
 101 import com.sun.source.doctree.StartElementTree;
 102 import com.sun.source.doctree.TextTree;
 103 import com.sun.source.doctree.UnknownBlockTagTree;
 104 import com.sun.source.tree.CompilationUnitTree;
 105 import com.sun.source.tree.LineMap;
 106 import com.sun.source.util.DocSourcePositions;
 107 import com.sun.source.util.DocTrees;
 108 import com.sun.source.util.TreePath;
 109 import com.sun.tools.javac.model.JavacTypes;
<span class="line-removed"> 110 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;</span>
 111 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 112 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 113 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
<span class="line-removed"> 114 import jdk.javadoc.internal.doclets.toolkit.Messages;</span>
 115 import jdk.javadoc.internal.doclets.toolkit.Resources;
 116 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 117 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 118 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 119 import jdk.javadoc.internal.tool.DocEnvImpl;
 120 
 121 import static javax.lang.model.element.ElementKind.*;
 122 import static javax.lang.model.element.Modifier.*;
 123 import static javax.lang.model.type.TypeKind.*;
 124 
 125 import static com.sun.source.doctree.DocTree.Kind.*;
 126 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 127 
 128 /**
 129  * Utilities Class for Doclets.
 130  *
 131  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 132  *  If you write code that depends on this, you do so at your own risk.
 133  *  This code and its internal interfaces are subject to change or
 134  *  deletion without notice.&lt;/b&gt;
 135  */
 136 public class Utils {
 137     public final BaseConfiguration configuration;
 138     private final BaseOptions options;
<span class="line-removed"> 139     private final Messages messages;</span>
 140     private final Resources resources;
 141     public final DocTrees docTrees;
 142     public final Elements elementUtils;
 143     public final Types typeUtils;

 144     private final JavaScriptScanner javaScriptScanner;
 145 
 146     public Utils(BaseConfiguration c) {
 147         configuration = c;
 148         options = configuration.getOptions();
<span class="line-removed"> 149         messages = configuration.getMessages();</span>
 150         resources = configuration.getDocResources();
 151         elementUtils = c.docEnv.getElementUtils();
 152         typeUtils = c.docEnv.getTypeUtils();
 153         docTrees = c.docEnv.getDocTrees();
 154         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();

 155     }
 156 
 157     // our own little symbol table
 158     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 159 
 160     public TypeMirror getSymbol(String signature) {
 161         TypeMirror type = symtab.get(signature);
 162         if (type == null) {
 163             TypeElement typeElement = elementUtils.getTypeElement(signature);
 164             if (typeElement == null)
 165                 return null;
 166             type = typeElement.asType();
 167             if (type == null)
 168                 return null;
 169             symtab.put(signature, type);
 170         }
 171         return type;
 172     }
 173 
 174     public TypeMirror getObjectType() {
</pre>
<hr />
<pre>
 202     public TypeMirror getDeprecatedType() {
 203         return getSymbol(&quot;java.lang.Deprecated&quot;);
 204     }
 205 
 206     public TypeMirror getFunctionalInterface() {
 207         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 208     }
 209 
 210     /**
 211      * Return array of class members whose documentation is to be generated.
 212      * If the member is deprecated do not include such a member in the
 213      * returned array.
 214      *
 215      * @param  members    Array of members to choose from.
 216      * @return List       List of eligible members for whom
 217      *                    documentation is getting generated.
 218      */
 219     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
 220         return members.stream()
 221                       .filter(member -&gt; !isDeprecated(member))
<span class="line-modified"> 222                       .sorted(makeGeneralPurposeComparator())</span>
 223                       .collect(Collectors.toCollection(ArrayList::new));
 224     }
 225 
 226     /**
 227      * Search for the given method in the given class.
 228      *
 229      * @param  te        Class to search into.
 230      * @param  method    Method to be searched.
 231      * @return ExecutableElement Method found, null otherwise.
 232      */
 233     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 234         for (Element m : getMethods(te)) {
 235             if (executableMembersEqual(method, (ExecutableElement) m)) {
 236                 return (ExecutableElement) m;
 237             }
 238         }
 239         return null;
 240     }
 241 
 242     /**
</pre>
<hr />
<pre>
 647         switch(kind) {
 648               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 649               case LOCAL_VARIABLE: case PARAMETER:
 650               case RESOURCE_VARIABLE:
 651                   return true;
 652               default:
 653                   return false;
 654         }
 655     }
 656 
 657     public boolean isTypeElement(Element e) {
 658         switch (e.getKind()) {
 659             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 660                 return true;
 661             default:
 662                 return false;
 663         }
 664     }
 665 
 666     /**
<span class="line-modified"> 667      * Get the signature. It is the parameter list, type is qualified.</span>

 668      * For instance, for a method {@code mymethod(String x, int y)},
 669      * it will return {@code (java.lang.String,int)}.
 670      *
<span class="line-modified"> 671      * @param e</span>
<span class="line-modified"> 672      * @return String</span>

 673      */
<span class="line-modified"> 674     public String signature(ExecutableElement e) {</span>
<span class="line-modified"> 675         return makeSignature(e, true);</span>
 676     }
 677 
 678     /**
<span class="line-modified"> 679      * Get flat signature.  All types are not qualified.</span>
<span class="line-modified"> 680      * Return a String, which is the flat signature of this member.</span>
<span class="line-removed"> 681      * It is the parameter list, type is not qualified.</span>
 682      * For instance, for a method {@code mymethod(String x, int y)},
 683      * it will return {@code (String, int)}.




 684      */
<span class="line-modified"> 685     public String flatSignature(ExecutableElement e) {</span>
<span class="line-modified"> 686         return makeSignature(e, false);</span>
 687     }
 688 
<span class="line-modified"> 689     public String makeSignature(ExecutableElement e, boolean full) {</span>
<span class="line-modified"> 690         return makeSignature(e, full, false);</span>
 691     }
 692 
<span class="line-modified"> 693     public String makeSignature(ExecutableElement e, boolean full, boolean ignoreTypeParameters) {</span>
 694         StringBuilder result = new StringBuilder();
 695         result.append(&quot;(&quot;);
<span class="line-modified"> 696         Iterator&lt;? extends VariableElement&gt; iterator = e.getParameters().iterator();</span>

 697         while (iterator.hasNext()) {
<span class="line-modified"> 698             VariableElement next = iterator.next();</span>
<span class="line-removed"> 699             TypeMirror type = next.asType();</span>
 700             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 701             if (iterator.hasNext()) {
 702                 result.append(&quot;, &quot;);
 703             }
 704         }
 705         if (e.isVarArgs()) {
 706             int len = result.length();
 707             result.replace(len - 2, len, &quot;...&quot;);
 708         }
 709         result.append(&quot;)&quot;);
 710         return result.toString();
 711     }
 712 
 713     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 714         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 715             final StringBuilder sb = new StringBuilder();
 716 
 717             @Override
 718             public StringBuilder visitArray(ArrayType t, Void p) {
 719                 TypeMirror componentType = t.getComponentType();
</pre>
<hr />
<pre>
 912                 t = getSuperType(asTypeElement(t))) {
 913             TypeElement te = asTypeElement(t);
 914             if (te == null) {
 915                 return null;
 916             }
 917             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 918             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 919                 ExecutableElement ee = (ExecutableElement)e;
 920                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 921                         !isSimpleOverride(ee)) {
 922                     return ee;
 923                 }
 924             }
 925             if (t.equals(getObjectType()))
 926                 return null;
 927         }
 928         return null;
 929     }
 930 
 931     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
<span class="line-modified"> 932         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
 933         typeElements.forEach(set::add);
 934         return set;
 935     }
 936 
 937     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 938         return getBlockTags(member, SERIAL_DATA);
 939     }
 940 
 941     public FileObject getFileObject(TypeElement te) {
 942         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 943     }
 944 
 945     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 946         return getDeclaredType(Collections.emptyList(), enclosing, target);
 947     }
 948 
 949     /**
 950      * Finds the declaration of the enclosing&#39;s type parameter.
 951      *
 952      * @param values
</pre>
<hr />
<pre>
1560         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1561             return false;
1562 
1563         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1564         return fullBody.isEmpty() ||
1565                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1566     }
1567 
1568     /**
1569      * In case of JavaFX mode on, filters out classes that are private,
1570      * package private, these are not documented in JavaFX mode, also
1571      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1572      *
1573      * @param classlist a collection of TypeElements
1574      * @param javafx set to true if in JavaFX mode.
1575      * @return list of filtered classes.
1576      */
1577     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1578             boolean javafx) {
1579         SortedSet&lt;TypeElement&gt; filteredOutClasses =
<span class="line-modified">1580                 new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
1581         if (!javafx) {
1582             for (Element te : classlist) {
1583                 if (!hasHiddenTag(te)) {
1584                     filteredOutClasses.add((TypeElement)te);
1585                 }
1586             }
1587             return filteredOutClasses;
1588         }
1589         for (Element e : classlist) {
1590             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1591                 continue;
1592             }
1593             filteredOutClasses.add((TypeElement)e);
1594         }
1595         return filteredOutClasses;
1596     }
1597 
1598     /**
1599      * Compares two elements.
1600      * @param e1 first Element
</pre>
<hr />
<pre>
1627     public int compareStrings(String s1, String s2) {
1628         return compareStrings(true, s1, s2);
1629     }
1630 
1631     /**
1632      * A general purpose case sensitive String comparator, which
1633      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1634      *
1635      * @param s1 first String to compare.
1636      * @param s2 second String to compare.
1637      * @return a negative integer, zero, or a positive integer as the first
1638      *         argument is less than, equal to, or greater than the second.
1639      */
1640     public int compareCaseCompare(String s1, String s2) {
1641         return compareStrings(false, s1, s2);
1642     }
1643 
1644     private DocCollator tertiaryCollator = null;
1645     private DocCollator secondaryCollator = null;
1646 
<span class="line-modified">1647     private int compareStrings(boolean caseSensitive, String s1, String s2) {</span>
1648         if (caseSensitive) {
1649             if (tertiaryCollator == null) {
1650                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1651             }
1652             return tertiaryCollator.compare(s1, s2);
1653         }
1654         if (secondaryCollator == null) {
1655             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1656         }
1657         return secondaryCollator.compare(s1, s2);
1658     }
1659 
1660     public String getHTMLTitle(Element element) {
1661         List&lt;? extends DocTree&gt; preamble = getPreamble(element);
1662         StringBuilder sb = new StringBuilder();
1663         boolean titleFound = false;
1664         loop:
1665         for (DocTree dt : preamble) {
1666             switch (dt.getKind()) {
1667                 case START_ELEMENT:
</pre>
<hr />
<pre>
1715         public int compare(String s1, String s2) {
1716             return getKey(s1).compareTo(getKey(s2));
1717         }
1718 
1719         private Collator createCollator(Locale locale) {
1720             Collator baseCollator = Collator.getInstance(locale);
1721             if (baseCollator instanceof RuleBasedCollator) {
1722                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1723                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1724                 try {
1725                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1726                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1727                 } catch (ParseException e) {
1728                     throw new RuntimeException(e);
1729                 }
1730             }
1731             return baseCollator;
1732         }
1733     }
1734 
<span class="line-removed">1735     private Comparator&lt;Element&gt; moduleComparator = null;</span>
<span class="line-removed">1736     /**</span>
<span class="line-removed">1737      * Comparator for ModuleElements, simply compares the fully qualified names</span>
<span class="line-removed">1738      * @return a Comparator</span>
<span class="line-removed">1739      */</span>
<span class="line-removed">1740     public Comparator&lt;Element&gt; makeModuleComparator() {</span>
<span class="line-removed">1741         if (moduleComparator == null) {</span>
<span class="line-removed">1742             moduleComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1743                 @Override</span>
<span class="line-removed">1744                 public int compare(Element mod1, Element mod2) {</span>
<span class="line-removed">1745                     return compareFullyQualifiedNames(mod1, mod2);</span>
<span class="line-removed">1746                 }</span>
<span class="line-removed">1747             };</span>
<span class="line-removed">1748         }</span>
<span class="line-removed">1749         return moduleComparator;</span>
<span class="line-removed">1750     }</span>
<span class="line-removed">1751 </span>
<span class="line-removed">1752     private Comparator&lt;Element&gt; allClassesComparator = null;</span>
<span class="line-removed">1753     /**</span>
<span class="line-removed">1754      * Returns a Comparator for all classes, compares the simple names of</span>
<span class="line-removed">1755      * TypeElement, if equal then the fully qualified names.</span>
<span class="line-removed">1756      *</span>
<span class="line-removed">1757      * @return Comparator</span>
<span class="line-removed">1758      */</span>
<span class="line-removed">1759     public Comparator&lt;Element&gt; makeAllClassesComparator() {</span>
<span class="line-removed">1760         if (allClassesComparator == null) {</span>
<span class="line-removed">1761             allClassesComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1762                 @Override</span>
<span class="line-removed">1763                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">1764                     int result = compareNames(e1, e2);</span>
<span class="line-removed">1765                     if (result == 0)</span>
<span class="line-removed">1766                         result = compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1767 </span>
<span class="line-removed">1768                     return result;</span>
<span class="line-removed">1769                 }</span>
<span class="line-removed">1770             };</span>
<span class="line-removed">1771         }</span>
<span class="line-removed">1772         return allClassesComparator;</span>
<span class="line-removed">1773     }</span>
<span class="line-removed">1774 </span>
<span class="line-removed">1775     private Comparator&lt;Element&gt; packageComparator = null;</span>
<span class="line-removed">1776     /**</span>
<span class="line-removed">1777      * Returns a Comparator for packages, by comparing the fully qualified names.</span>
<span class="line-removed">1778      *</span>
<span class="line-removed">1779      * @return a Comparator</span>
<span class="line-removed">1780      */</span>
<span class="line-removed">1781     public Comparator&lt;Element&gt; makePackageComparator() {</span>
<span class="line-removed">1782         if (packageComparator == null) {</span>
<span class="line-removed">1783             packageComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1784                 @Override</span>
<span class="line-removed">1785                 public int compare(Element pkg1, Element pkg2) {</span>
<span class="line-removed">1786                     return compareFullyQualifiedNames(pkg1, pkg2);</span>
<span class="line-removed">1787                 }</span>
<span class="line-removed">1788             };</span>
<span class="line-removed">1789         }</span>
<span class="line-removed">1790         return packageComparator;</span>
<span class="line-removed">1791     }</span>
<span class="line-removed">1792 </span>
<span class="line-removed">1793     private Comparator&lt;Element&gt; deprecatedComparator = null;</span>
<span class="line-removed">1794     /**</span>
<span class="line-removed">1795      * Returns a Comparator for deprecated items listed on deprecated list page, by comparing the</span>
<span class="line-removed">1796      * fully qualified names.</span>
<span class="line-removed">1797      *</span>
<span class="line-removed">1798      * @return a Comparator</span>
<span class="line-removed">1799      */</span>
<span class="line-removed">1800     public Comparator&lt;Element&gt; makeDeprecatedComparator() {</span>
<span class="line-removed">1801         if (deprecatedComparator == null) {</span>
<span class="line-removed">1802             deprecatedComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1803                 @Override</span>
<span class="line-removed">1804                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">1805                     return compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1806                 }</span>
<span class="line-removed">1807             };</span>
<span class="line-removed">1808         }</span>
<span class="line-removed">1809         return deprecatedComparator;</span>
<span class="line-removed">1810     }</span>
<span class="line-removed">1811 </span>
<span class="line-removed">1812     private Comparator&lt;SerialFieldTree&gt; serialFieldTreeComparator = null;</span>
<span class="line-removed">1813     /**</span>
<span class="line-removed">1814      * Returns a Comparator for SerialFieldTree.</span>
<span class="line-removed">1815      * @return a Comparator</span>
<span class="line-removed">1816      */</span>
<span class="line-removed">1817     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {</span>
<span class="line-removed">1818         if (serialFieldTreeComparator == null) {</span>
<span class="line-removed">1819             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {</span>
<span class="line-removed">1820                 String s1 = o1.getName().toString();</span>
<span class="line-removed">1821                 String s2 = o2.getName().toString();</span>
<span class="line-removed">1822                 return s1.compareTo(s2);</span>
<span class="line-removed">1823             };</span>
<span class="line-removed">1824         }</span>
<span class="line-removed">1825         return serialFieldTreeComparator;</span>
<span class="line-removed">1826     }</span>
<span class="line-removed">1827 </span>
<span class="line-removed">1828     /**</span>
<span class="line-removed">1829      * Returns a general purpose comparator.</span>
<span class="line-removed">1830      * @return a Comparator</span>
<span class="line-removed">1831      */</span>
<span class="line-removed">1832     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {</span>
<span class="line-removed">1833         return makeClassUseComparator();</span>
<span class="line-removed">1834     }</span>
<span class="line-removed">1835 </span>
<span class="line-removed">1836     private Comparator&lt;Element&gt; overrideUseComparator = null;</span>
<span class="line-removed">1837 </span>
<span class="line-removed">1838     /**</span>
<span class="line-removed">1839      * Returns a Comparator for overrides and implements,</span>
<span class="line-removed">1840      * used primarily on methods, compares the name first,</span>
<span class="line-removed">1841      * then compares the simple names of the enclosing</span>
<span class="line-removed">1842      * TypeElement and the fully qualified name of the enclosing TypeElement.</span>
<span class="line-removed">1843      * @return a Comparator</span>
<span class="line-removed">1844      */</span>
<span class="line-removed">1845     public Comparator&lt;Element&gt; makeOverrideUseComparator() {</span>
<span class="line-removed">1846         if (overrideUseComparator == null) {</span>
<span class="line-removed">1847             overrideUseComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1848                 @Override</span>
<span class="line-removed">1849                 public int compare(Element o1, Element o2) {</span>
<span class="line-removed">1850                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));</span>
<span class="line-removed">1851                     if (result != 0) {</span>
<span class="line-removed">1852                         return result;</span>
<span class="line-removed">1853                     }</span>
<span class="line-removed">1854                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {</span>
<span class="line-removed">1855                         TypeElement t1 = getEnclosingTypeElement(o1);</span>
<span class="line-removed">1856                         TypeElement t2 = getEnclosingTypeElement(o2);</span>
<span class="line-removed">1857                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));</span>
<span class="line-removed">1858                         if (result != 0)</span>
<span class="line-removed">1859                             return result;</span>
<span class="line-removed">1860                     }</span>
<span class="line-removed">1861                     result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));</span>
<span class="line-removed">1862                     if (result != 0)</span>
<span class="line-removed">1863                         return result;</span>
<span class="line-removed">1864                     return compareElementKinds(o1, o2);</span>
<span class="line-removed">1865                 }</span>
<span class="line-removed">1866             };</span>
<span class="line-removed">1867         }</span>
<span class="line-removed">1868         return overrideUseComparator;</span>
<span class="line-removed">1869     }</span>
<span class="line-removed">1870 </span>
<span class="line-removed">1871     private Comparator&lt;Element&gt; indexUseComparator = null;</span>
<span class="line-removed">1872     /**</span>
<span class="line-removed">1873      *  Returns a Comparator for index file presentations, and are sorted as follows.</span>
<span class="line-removed">1874      *  If comparing modules and/or packages then simply compare the qualified names,</span>
<span class="line-removed">1875      *  if comparing a module or a package with a type/member then compare the</span>
<span class="line-removed">1876      *  FullyQualifiedName of the module or a package with the SimpleName of the entity,</span>
<span class="line-removed">1877      *  otherwise:</span>
<span class="line-removed">1878      *  1. compare the ElementKind ex: Module, Package, Interface etc.</span>
<span class="line-removed">1879      *  2a. if equal and if the type is of ExecutableElement(Constructor, Methods),</span>
<span class="line-removed">1880      *      a case insensitive comparison of parameter the type signatures</span>
<span class="line-removed">1881      *  2b. if equal, case sensitive comparison of the type signatures</span>
<span class="line-removed">1882      *  3. finally, if equal, compare the FQNs of the entities</span>
<span class="line-removed">1883      * @return a comparator for index file use</span>
<span class="line-removed">1884      */</span>
<span class="line-removed">1885     public Comparator&lt;Element&gt; makeIndexUseComparator() {</span>
<span class="line-removed">1886         if (indexUseComparator == null) {</span>
<span class="line-removed">1887             indexUseComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1888                 /**</span>
<span class="line-removed">1889                  * Compares two elements.</span>
<span class="line-removed">1890                  *</span>
<span class="line-removed">1891                  * @param e1 - an element.</span>
<span class="line-removed">1892                  * @param e2 - an element.</span>
<span class="line-removed">1893                  * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">1894                  * argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">1895                  */</span>
<span class="line-removed">1896                 @Override</span>
<span class="line-removed">1897                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">1898                     int result;</span>
<span class="line-removed">1899                     // first, compare names as appropriate</span>
<span class="line-removed">1900                     if ((isModule(e1) || isPackage(e1)) &amp;&amp; (isModule(e2) || isPackage(e2))) {</span>
<span class="line-removed">1901                         result = compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1902                     } else if (isModule(e1) || isPackage(e1)) {</span>
<span class="line-removed">1903                         result = compareStrings(getFullyQualifiedName(e1), getSimpleName(e2));</span>
<span class="line-removed">1904                     } else if (isModule(e2) || isPackage(e2)) {</span>
<span class="line-removed">1905                         result = compareStrings(getSimpleName(e1), getFullyQualifiedName(e2));</span>
<span class="line-removed">1906                     } else {</span>
<span class="line-removed">1907                         result = compareNames(e1, e2);</span>
<span class="line-removed">1908                     }</span>
<span class="line-removed">1909                     if (result != 0) {</span>
<span class="line-removed">1910                         return result;</span>
<span class="line-removed">1911                     }</span>
<span class="line-removed">1912                     // if names are the same, compare element kinds</span>
<span class="line-removed">1913                     result = compareElementKinds(e1, e2);</span>
<span class="line-removed">1914                     if (result != 0) {</span>
<span class="line-removed">1915                         return result;</span>
<span class="line-removed">1916                     }</span>
<span class="line-removed">1917                     // if element kinds are the same, and are methods,</span>
<span class="line-removed">1918                     // compare the method parameters</span>
<span class="line-removed">1919                     if (hasParameters(e1)) {</span>
<span class="line-removed">1920                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();</span>
<span class="line-removed">1921                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();</span>
<span class="line-removed">1922                         result = compareParameters(false, parameters1, parameters2);</span>
<span class="line-removed">1923                         if (result != 0) {</span>
<span class="line-removed">1924                             return result;</span>
<span class="line-removed">1925                         }</span>
<span class="line-removed">1926                         result = compareParameters(true, parameters1, parameters2);</span>
<span class="line-removed">1927                         if (result != 0) {</span>
<span class="line-removed">1928                             return result;</span>
<span class="line-removed">1929                         }</span>
<span class="line-removed">1930                     }</span>
<span class="line-removed">1931                     // else fall back on fully qualified names</span>
<span class="line-removed">1932                     return compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1933                 }</span>
<span class="line-removed">1934             };</span>
<span class="line-removed">1935         }</span>
<span class="line-removed">1936         return indexUseComparator;</span>
<span class="line-removed">1937     }</span>
<span class="line-removed">1938 </span>
<span class="line-removed">1939     private Comparator&lt;TypeMirror&gt; typeMirrorClassUseComparator = null;</span>
<span class="line-removed">1940     /**</span>
<span class="line-removed">1941      * Compares the FullyQualifiedNames of two TypeMirrors</span>
<span class="line-removed">1942      * @return</span>
<span class="line-removed">1943      */</span>
<span class="line-removed">1944     public Comparator&lt;TypeMirror&gt; makeTypeMirrorClassUseComparator() {</span>
<span class="line-removed">1945         if (typeMirrorClassUseComparator == null) {</span>
<span class="line-removed">1946             typeMirrorClassUseComparator = (TypeMirror type1, TypeMirror type2) -&gt; {</span>
<span class="line-removed">1947                 String s1 = getQualifiedTypeName(type1);</span>
<span class="line-removed">1948                 String s2 = getQualifiedTypeName(type2);</span>
<span class="line-removed">1949                 return compareStrings(s1, s2);</span>
<span class="line-removed">1950             };</span>
<span class="line-removed">1951         }</span>
<span class="line-removed">1952         return typeMirrorClassUseComparator;</span>
<span class="line-removed">1953     }</span>
<span class="line-removed">1954 </span>
<span class="line-removed">1955     private Comparator&lt;TypeMirror&gt; typeMirrorIndexUseComparator = null;</span>
<span class="line-removed">1956     /**</span>
<span class="line-removed">1957      * Compares the SimpleNames of TypeMirrors if equal then the</span>
<span class="line-removed">1958      * FullyQualifiedNames of TypeMirrors.</span>
<span class="line-removed">1959      *</span>
<span class="line-removed">1960      * @return</span>
<span class="line-removed">1961      */</span>
<span class="line-removed">1962     public Comparator&lt;TypeMirror&gt; makeTypeMirrorIndexUseComparator() {</span>
<span class="line-removed">1963         if (typeMirrorIndexUseComparator == null) {</span>
<span class="line-removed">1964             typeMirrorIndexUseComparator = (TypeMirror t1, TypeMirror t2) -&gt; {</span>
<span class="line-removed">1965                 int result = compareStrings(getTypeName(t1, false), getTypeName(t2, false));</span>
<span class="line-removed">1966                 if (result != 0)</span>
<span class="line-removed">1967                     return result;</span>
<span class="line-removed">1968                 return compareStrings(getQualifiedTypeName(t1), getQualifiedTypeName(t2));</span>
<span class="line-removed">1969             };</span>
<span class="line-removed">1970         }</span>
<span class="line-removed">1971         return typeMirrorIndexUseComparator;</span>
<span class="line-removed">1972     }</span>
<span class="line-removed">1973 </span>
1974     /**
1975      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1976      * getQualified name, returns  the qualified name of the Reference type
1977      * otherwise the primitive name.
1978      * @param t the type whose name is to be obtained.
1979      * @return the fully qualified name of Reference type or the primitive name
1980      */
1981     public String getQualifiedTypeName(TypeMirror t) {
1982         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1983             @Override
1984             public String visitDeclared(DeclaredType t, Void p) {
1985                 return getFullyQualifiedName(t.asElement());
1986             }
1987 
1988             @Override
1989             public String visitArray(ArrayType t, Void p) {
1990                return visit(t.getComponentType());
1991             }
1992 
1993             @Override
</pre>
<hr />
<pre>
2026                 return e.getQualifiedName().toString();
2027             }
2028 
2029             @Override
2030             public String visitPackage(PackageElement e, Void p) {
2031                 return e.getQualifiedName().toString();
2032             }
2033 
2034             @Override
2035             public String visitType(TypeElement e, Void p) {
2036                 return e.getQualifiedName().toString();
2037             }
2038 
2039             @Override
2040             protected String defaultAction(Element e, Void p) {
2041                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2042             }
2043         }.visit(e);
2044     }
2045 
<span class="line-removed">2046     private Comparator&lt;Element&gt; classUseComparator = null;</span>
<span class="line-removed">2047 </span>
<span class="line-removed">2048     /**</span>
<span class="line-removed">2049      * Comparator for ClassUse presentations, and sorts as follows:</span>
<span class="line-removed">2050      * 1. member names</span>
<span class="line-removed">2051      * 2. then fully qualified member names</span>
<span class="line-removed">2052      * 3. then parameter types if applicable</span>
<span class="line-removed">2053      * 4. finally the element kinds ie. package, class, interface etc.</span>
<span class="line-removed">2054      * @return a comparator to sort classes and members for class use</span>
<span class="line-removed">2055      */</span>
<span class="line-removed">2056     public Comparator&lt;Element&gt; makeClassUseComparator() {</span>
<span class="line-removed">2057         if (classUseComparator == null) {</span>
<span class="line-removed">2058             classUseComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">2059                 /**</span>
<span class="line-removed">2060                  * Compares two Elements.</span>
<span class="line-removed">2061                  *</span>
<span class="line-removed">2062                  * @param e1 - an element.</span>
<span class="line-removed">2063                  * @param e2 - an element.</span>
<span class="line-removed">2064                  * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2065                  * argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2066                  */</span>
<span class="line-removed">2067                 @Override</span>
<span class="line-removed">2068                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">2069                     int result = compareNames(e1, e2);</span>
<span class="line-removed">2070                     if (result != 0) {</span>
<span class="line-removed">2071                         return result;</span>
<span class="line-removed">2072                     }</span>
<span class="line-removed">2073                     result = compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">2074                     if (result != 0) {</span>
<span class="line-removed">2075                         return result;</span>
<span class="line-removed">2076                     }</span>
<span class="line-removed">2077                     if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {</span>
<span class="line-removed">2078                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();</span>
<span class="line-removed">2079                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();</span>
<span class="line-removed">2080                         result = compareParameters(false, parameters1, parameters2);</span>
<span class="line-removed">2081                         if (result != 0) {</span>
<span class="line-removed">2082                             return result;</span>
<span class="line-removed">2083                         }</span>
<span class="line-removed">2084                         result = compareParameters(true, parameters1, parameters2);</span>
<span class="line-removed">2085                     }</span>
<span class="line-removed">2086                     if (result != 0) {</span>
<span class="line-removed">2087                         return result;</span>
<span class="line-removed">2088                     }</span>
<span class="line-removed">2089                     return compareElementKinds(e1, e2);</span>
<span class="line-removed">2090                 }</span>
<span class="line-removed">2091             };</span>
<span class="line-removed">2092         }</span>
<span class="line-removed">2093         return classUseComparator;</span>
<span class="line-removed">2094     }</span>
<span class="line-removed">2095 </span>
<span class="line-removed">2096     /**</span>
<span class="line-removed">2097      * A general purpose comparator to sort Element entities, basically provides the building blocks</span>
<span class="line-removed">2098      * for creating specific comparators for an use-case.</span>
<span class="line-removed">2099      */</span>
<span class="line-removed">2100     private abstract class ElementComparator implements Comparator&lt;Element&gt; {</span>
<span class="line-removed">2101         public ElementComparator() { }</span>
<span class="line-removed">2102 </span>
<span class="line-removed">2103         /**</span>
<span class="line-removed">2104          * compares two parameter arrays by first comparing the length of the arrays, and</span>
<span class="line-removed">2105          * then each Type of the parameter in the array.</span>
<span class="line-removed">2106          * @param params1 the first parameter array.</span>
<span class="line-removed">2107          * @param params2 the first parameter array.</span>
<span class="line-removed">2108          * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2109          *         argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2110          */</span>
<span class="line-removed">2111         protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,</span>
<span class="line-removed">2112                                                                List&lt;? extends VariableElement&gt; params2) {</span>
<span class="line-removed">2113 </span>
<span class="line-removed">2114             return compareStrings(caseSensitive, getParametersAsString(params1),</span>
<span class="line-removed">2115                                                  getParametersAsString(params2));</span>
<span class="line-removed">2116         }</span>
<span class="line-removed">2117 </span>
<span class="line-removed">2118         String getParametersAsString(List&lt;? extends VariableElement&gt; params) {</span>
<span class="line-removed">2119             StringBuilder sb = new StringBuilder();</span>
<span class="line-removed">2120             for (VariableElement param : params) {</span>
<span class="line-removed">2121                 TypeMirror t = param.asType();</span>
<span class="line-removed">2122                 // prefix P for primitive and R for reference types, thus items will</span>
<span class="line-removed">2123                 // be ordered lexically and correctly.</span>
<span class="line-removed">2124                 sb.append(getTypeCode(t)).append(&quot;-&quot;).append(t).append(&quot;-&quot;);</span>
<span class="line-removed">2125             }</span>
<span class="line-removed">2126             return sb.toString();</span>
<span class="line-removed">2127         }</span>
<span class="line-removed">2128 </span>
<span class="line-removed">2129         private String getTypeCode(TypeMirror t) {</span>
<span class="line-removed">2130             return new SimpleTypeVisitor9&lt;String, Void&gt;() {</span>
<span class="line-removed">2131 </span>
<span class="line-removed">2132                 @Override</span>
<span class="line-removed">2133                 public String visitPrimitive(PrimitiveType t, Void p) {</span>
<span class="line-removed">2134                     return &quot;P&quot;;</span>
<span class="line-removed">2135                 }</span>
<span class="line-removed">2136                 @Override</span>
<span class="line-removed">2137                 public String visitArray(ArrayType t, Void p) {</span>
<span class="line-removed">2138                     return visit(t.getComponentType());</span>
<span class="line-removed">2139                 }</span>
<span class="line-removed">2140                 @Override</span>
<span class="line-removed">2141                 protected String defaultAction(TypeMirror e, Void p) {</span>
<span class="line-removed">2142                     return &quot;R&quot;;</span>
<span class="line-removed">2143                 }</span>
<span class="line-removed">2144 </span>
<span class="line-removed">2145             }.visit(t);</span>
<span class="line-removed">2146         }</span>
<span class="line-removed">2147 </span>
<span class="line-removed">2148         /**</span>
<span class="line-removed">2149          * Compares two Elements, typically the name of a method,</span>
<span class="line-removed">2150          * field or constructor.</span>
<span class="line-removed">2151          * @param e1 the first Element.</span>
<span class="line-removed">2152          * @param e2 the second Element.</span>
<span class="line-removed">2153          * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2154          *         argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2155          */</span>
<span class="line-removed">2156         protected int compareNames(Element e1, Element e2) {</span>
<span class="line-removed">2157             return compareStrings(getSimpleName(e1), getSimpleName(e2));</span>
<span class="line-removed">2158         }</span>
<span class="line-removed">2159 </span>
<span class="line-removed">2160         /**</span>
<span class="line-removed">2161          * Compares the fully qualified names of the entities</span>
<span class="line-removed">2162          * @param e1 the first Element.</span>
<span class="line-removed">2163          * @param e2 the first Element.</span>
<span class="line-removed">2164          * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2165          *         argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2166          */</span>
<span class="line-removed">2167         protected int compareFullyQualifiedNames(Element e1, Element e2) {</span>
<span class="line-removed">2168             // add simplename to be compatible</span>
<span class="line-removed">2169             String thisElement = getFullyQualifiedName(e1);</span>
<span class="line-removed">2170             String thatElement = getFullyQualifiedName(e2);</span>
<span class="line-removed">2171             return compareStrings(thisElement, thatElement);</span>
<span class="line-removed">2172         }</span>
<span class="line-removed">2173 </span>
<span class="line-removed">2174         protected int compareElementKinds(Element e1, Element e2) {</span>
<span class="line-removed">2175             return Integer.compare(getKindIndex(e1), getKindIndex(e2));</span>
<span class="line-removed">2176         }</span>
<span class="line-removed">2177 </span>
<span class="line-removed">2178         private int getKindIndex(Element e) {</span>
<span class="line-removed">2179             switch (e.getKind()) {</span>
<span class="line-removed">2180                 case MODULE:            return 0;</span>
<span class="line-removed">2181                 case PACKAGE:           return 1;</span>
<span class="line-removed">2182                 case CLASS:             return 2;</span>
<span class="line-removed">2183                 case ENUM:              return 3;</span>
<span class="line-removed">2184                 case ENUM_CONSTANT:     return 4;</span>
<span class="line-removed">2185                 case RECORD:            return 5;</span>
<span class="line-removed">2186                 case INTERFACE:         return 6;</span>
<span class="line-removed">2187                 case ANNOTATION_TYPE:   return 7;</span>
<span class="line-removed">2188                 case FIELD:             return 8;</span>
<span class="line-removed">2189                 case CONSTRUCTOR:       return 9;</span>
<span class="line-removed">2190                 case METHOD:            return 10;</span>
<span class="line-removed">2191                 default: throw new IllegalArgumentException(e.getKind().toString());</span>
<span class="line-removed">2192             }</span>
<span class="line-removed">2193         }</span>
<span class="line-removed">2194 </span>
<span class="line-removed">2195         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-removed">2196         boolean hasParameters(Element e) {</span>
<span class="line-removed">2197             return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
<span class="line-removed">2198                 @Override</span>
<span class="line-removed">2199                 public Boolean visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-removed">2200                     return true;</span>
<span class="line-removed">2201                 }</span>
<span class="line-removed">2202 </span>
<span class="line-removed">2203                 @Override</span>
<span class="line-removed">2204                 protected Boolean defaultAction(Element e, Void p) {</span>
<span class="line-removed">2205                     return false;</span>
<span class="line-removed">2206                 }</span>
<span class="line-removed">2207 </span>
<span class="line-removed">2208             }.visit(e);</span>
<span class="line-removed">2209         }</span>
<span class="line-removed">2210 </span>
<span class="line-removed">2211         /**</span>
<span class="line-removed">2212          * The fully qualified names of the entities, used solely by the comparator.</span>
<span class="line-removed">2213          *</span>
<span class="line-removed">2214          * @return a negative integer, zero, or a positive integer as the first argument is less</span>
<span class="line-removed">2215          * than, equal to, or greater than the second.</span>
<span class="line-removed">2216          */</span>
<span class="line-removed">2217         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-removed">2218         private String getFullyQualifiedName(Element e) {</span>
<span class="line-removed">2219             return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
<span class="line-removed">2220                 @Override</span>
<span class="line-removed">2221                 public String visitModule(ModuleElement e, Void p) {</span>
<span class="line-removed">2222                     return e.getQualifiedName().toString();</span>
<span class="line-removed">2223                 }</span>
<span class="line-removed">2224 </span>
<span class="line-removed">2225                 @Override</span>
<span class="line-removed">2226                 public String visitPackage(PackageElement e, Void p) {</span>
<span class="line-removed">2227                     return e.getQualifiedName().toString();</span>
<span class="line-removed">2228                 }</span>
<span class="line-removed">2229 </span>
<span class="line-removed">2230                 @Override</span>
<span class="line-removed">2231                 public String visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-removed">2232                     // For backward compatibility</span>
<span class="line-removed">2233                     return getFullyQualifiedName(e.getEnclosingElement())</span>
<span class="line-removed">2234                             + &quot;.&quot; + e.getSimpleName().toString();</span>
<span class="line-removed">2235                 }</span>
<span class="line-removed">2236 </span>
<span class="line-removed">2237                 @Override</span>
<span class="line-removed">2238                 public String visitType(TypeElement e, Void p) {</span>
<span class="line-removed">2239                     return e.getQualifiedName().toString();</span>
<span class="line-removed">2240                 }</span>
<span class="line-removed">2241 </span>
<span class="line-removed">2242                 @Override</span>
<span class="line-removed">2243                 protected String defaultAction(Element e, Void p) {</span>
<span class="line-removed">2244                     return getEnclosingTypeElement(e).getQualifiedName().toString()</span>
<span class="line-removed">2245                             + &quot;.&quot; + e.getSimpleName().toString();</span>
<span class="line-removed">2246                 }</span>
<span class="line-removed">2247             }.visit(e);</span>
<span class="line-removed">2248         }</span>
<span class="line-removed">2249     }</span>
<span class="line-removed">2250 </span>
<span class="line-removed">2251     /**</span>
<span class="line-removed">2252      * Returns a Comparator for SearchIndexItems representing types. Items are</span>
<span class="line-removed">2253      * compared by short name, or full string representation if names are equal.</span>
<span class="line-removed">2254      *</span>
<span class="line-removed">2255      * @return a Comparator</span>
<span class="line-removed">2256      */</span>
<span class="line-removed">2257     public Comparator&lt;SearchIndexItem&gt; makeTypeSearchIndexComparator() {</span>
<span class="line-removed">2258         return (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {</span>
<span class="line-removed">2259             int result = compareStrings(sii1.getSimpleName(), sii2.getSimpleName());</span>
<span class="line-removed">2260             if (result == 0) {</span>
<span class="line-removed">2261                 // TreeSet needs this to be consistent with equal so we do</span>
<span class="line-removed">2262                 // a plain comparison of string representations as fallback.</span>
<span class="line-removed">2263                 result = sii1.toString().compareTo(sii2.toString());</span>
<span class="line-removed">2264             }</span>
<span class="line-removed">2265             return result;</span>
<span class="line-removed">2266         };</span>
<span class="line-removed">2267     }</span>
<span class="line-removed">2268 </span>
<span class="line-removed">2269     private Comparator&lt;SearchIndexItem&gt; genericSearchIndexComparator = null;</span>
<span class="line-removed">2270     /**</span>
<span class="line-removed">2271      * Returns a Comparator for SearchIndexItems representing modules, packages, or members.</span>
<span class="line-removed">2272      * Items are compared by label (member name plus signature for members, package name for</span>
<span class="line-removed">2273      * packages, and module name for modules). If labels are equal then full string</span>
<span class="line-removed">2274      * representation is compared.</span>
<span class="line-removed">2275      *</span>
<span class="line-removed">2276      * @return a Comparator</span>
<span class="line-removed">2277      */</span>
<span class="line-removed">2278     public Comparator&lt;SearchIndexItem&gt; makeGenericSearchIndexComparator() {</span>
<span class="line-removed">2279         if (genericSearchIndexComparator == null) {</span>
<span class="line-removed">2280             genericSearchIndexComparator = (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {</span>
<span class="line-removed">2281                 int result = compareStrings(sii1.getLabel(), sii2.getLabel());</span>
<span class="line-removed">2282                 if (result == 0) {</span>
<span class="line-removed">2283                     // TreeSet needs this to be consistent with equal so we do</span>
<span class="line-removed">2284                     // a plain comparison of string representations as fallback.</span>
<span class="line-removed">2285                     result = sii1.toString().compareTo(sii2.toString());</span>
<span class="line-removed">2286                 }</span>
<span class="line-removed">2287                 return result;</span>
<span class="line-removed">2288             };</span>
<span class="line-removed">2289         }</span>
<span class="line-removed">2290         return genericSearchIndexComparator;</span>
<span class="line-removed">2291     }</span>
2292 
2293     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
2294         List&lt;TypeElement&gt; out = getInterfaces(pkg);
2295         out.addAll(getClasses(pkg));
2296         out.addAll(getEnums(pkg));
2297         out.addAll(getAnnotationTypes(pkg));
2298         out.addAll(getRecords(pkg));
2299         return out;
2300     }
2301 
2302     // Element related methods
2303     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
2304         List&lt;Element&gt; members = getAnnotationFields(aClass);
2305         members.addAll(getAnnotationMethods(aClass));
2306         return members;
2307     }
2308 
2309     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
2310         return getItems0(aClass, true, FIELD);
2311     }
</pre>
<hr />
<pre>
2368         if (member == null || member.getKind() != ENUM_CONSTANT) {
2369             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2370         }
2371         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2372     }
2373 
2374     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2375     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2376         if (modulePackageMap == null) {
2377             modulePackageMap = new HashMap&lt;&gt;();
2378             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
2379             pkgs.forEach(pkg -&gt; {
2380                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2381                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2382             });
2383         }
2384         return modulePackageMap;
2385     }
2386 
2387     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
<span class="line-modified">2388         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());</span>
2389         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2390         // get all the requires for the element in question
2391         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2392             ModuleElement dep = rd.getDependency();
2393             // add the dependency to work queue
2394             if (!result.containsKey(dep)) {
2395                 if (rd.isTransitive()) {
2396                     queue.addLast(dep);
2397                 }
2398             }
2399             // add all exports for the primary module
2400             result.put(rd.getDependency(), getModifiers(rd));
2401         }
2402 
2403         // add only requires public for subsequent module dependencies
2404         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2405             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2406                 ModuleElement dep = rd.getDependency();
2407                 if (!result.containsKey(dep)) {
2408                     if (rd.isTransitive()) {
</pre>
<hr />
<pre>
2474         return convertToTypeElement(getItems(e, false, INTERFACE));
2475     }
2476 
2477     public List&lt;Element&gt; getEnumConstants(Element e) {
2478         return getItems(e, true, ENUM_CONSTANT);
2479     }
2480 
2481     public List&lt;TypeElement&gt; getEnums(Element e) {
2482         return convertToTypeElement(getItems(e, true, ENUM));
2483     }
2484 
2485     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2486         return convertToTypeElement(getItems(e, false, ENUM));
2487     }
2488 
2489     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2490         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2491         clist.addAll(getInterfacesUnfiltered(e));
2492         clist.addAll(getAnnotationTypesUnfiltered(e));
2493         clist.addAll(getRecordsUnfiltered(e));
<span class="line-modified">2494         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
2495         oset.addAll(clist);
2496         return oset;
2497     }
2498 
2499     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2500     /**
2501      * Returns a list containing classes and interfaces,
2502      * including annotation types.
2503      * @param e Element
2504      * @return List
2505      */
2506     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2507         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2508         if (oset != null)
2509             return oset;
2510         List&lt;TypeElement&gt; clist = getClasses(e);
2511         clist.addAll(getInterfaces(e));
2512         clist.addAll(getAnnotationTypes(e));
2513         clist.addAll(getEnums(e));
2514         clist.addAll(getRecords(e));
<span class="line-modified">2515         oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
2516         oset.addAll(clist);
2517         cachedClasses.put(e, oset);
2518         return oset;
2519     }
2520 
2521     /*
2522      * Get all the elements unfiltered and filter them finally based
2523      * on its visibility, this works differently from the other getters.
2524      */
2525     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2526         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2527         for (TypeElement te : getClassesUnfiltered(e)) {
2528             if (!filter || configuration.docEnv.isSelected(te)) {
2529                 olist.add(te);
2530             }
2531         }
2532         for (TypeElement te : getInterfacesUnfiltered(e)) {
2533             if (!filter || configuration.docEnv.isSelected(te)) {
2534                 olist.add(te);
2535             }
</pre>
</td>
<td>
<hr />
<pre>
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.ArrayDeque;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;

  40 import java.util.Deque;
  41 import java.util.EnumSet;
  42 import java.util.HashMap;
  43 import java.util.HashSet;
  44 import java.util.Iterator;
  45 import java.util.LinkedHashMap;
  46 import java.util.LinkedHashSet;
  47 import java.util.List;
  48 import java.util.Locale;
  49 import java.util.Map;
  50 import java.util.Map.Entry;
  51 import java.util.Objects;
  52 import java.util.Set;
  53 import java.util.SortedSet;
  54 import java.util.TreeMap;
  55 import java.util.TreeSet;
  56 import java.util.function.Predicate;
  57 import java.util.stream.Collectors;
  58 
  59 import javax.lang.model.SourceVersion;
</pre>
<hr />
<pre>
  79 import javax.lang.model.type.TypeMirror;
  80 import javax.lang.model.type.TypeVariable;
  81 import javax.lang.model.type.WildcardType;
  82 import javax.lang.model.util.ElementFilter;
  83 import javax.lang.model.util.ElementKindVisitor14;
  84 import javax.lang.model.util.Elements;
  85 import javax.lang.model.util.SimpleElementVisitor14;
  86 import javax.lang.model.util.SimpleTypeVisitor9;
  87 import javax.lang.model.util.TypeKindVisitor9;
  88 import javax.lang.model.util.Types;
  89 import javax.tools.FileObject;
  90 import javax.tools.JavaFileManager;
  91 import javax.tools.JavaFileManager.Location;
  92 import javax.tools.StandardLocation;
  93 
  94 import com.sun.source.doctree.DocCommentTree;
  95 import com.sun.source.doctree.DocTree;
  96 import com.sun.source.doctree.DocTree.Kind;
  97 import com.sun.source.doctree.EndElementTree;
  98 import com.sun.source.doctree.ParamTree;

  99 import com.sun.source.doctree.StartElementTree;
 100 import com.sun.source.doctree.TextTree;
 101 import com.sun.source.doctree.UnknownBlockTagTree;
 102 import com.sun.source.tree.CompilationUnitTree;
 103 import com.sun.source.tree.LineMap;
 104 import com.sun.source.util.DocSourcePositions;
 105 import com.sun.source.util.DocTrees;
 106 import com.sun.source.util.TreePath;
 107 import com.sun.tools.javac.model.JavacTypes;

 108 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 109 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 110 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;

 111 import jdk.javadoc.internal.doclets.toolkit.Resources;
 112 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 113 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 114 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 115 import jdk.javadoc.internal.tool.DocEnvImpl;
 116 
 117 import static javax.lang.model.element.ElementKind.*;
 118 import static javax.lang.model.element.Modifier.*;
 119 import static javax.lang.model.type.TypeKind.*;
 120 
 121 import static com.sun.source.doctree.DocTree.Kind.*;
 122 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 123 
 124 /**
 125  * Utilities Class for Doclets.
 126  *
 127  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 128  *  If you write code that depends on this, you do so at your own risk.
 129  *  This code and its internal interfaces are subject to change or
 130  *  deletion without notice.&lt;/b&gt;
 131  */
 132 public class Utils {
 133     public final BaseConfiguration configuration;
 134     private final BaseOptions options;

 135     private final Resources resources;
 136     public final DocTrees docTrees;
 137     public final Elements elementUtils;
 138     public final Types typeUtils;
<span class="line-added"> 139     public final Comparators comparators;</span>
 140     private final JavaScriptScanner javaScriptScanner;
 141 
 142     public Utils(BaseConfiguration c) {
 143         configuration = c;
 144         options = configuration.getOptions();

 145         resources = configuration.getDocResources();
 146         elementUtils = c.docEnv.getElementUtils();
 147         typeUtils = c.docEnv.getTypeUtils();
 148         docTrees = c.docEnv.getDocTrees();
 149         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
<span class="line-added"> 150         comparators = new Comparators(this);</span>
 151     }
 152 
 153     // our own little symbol table
 154     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 155 
 156     public TypeMirror getSymbol(String signature) {
 157         TypeMirror type = symtab.get(signature);
 158         if (type == null) {
 159             TypeElement typeElement = elementUtils.getTypeElement(signature);
 160             if (typeElement == null)
 161                 return null;
 162             type = typeElement.asType();
 163             if (type == null)
 164                 return null;
 165             symtab.put(signature, type);
 166         }
 167         return type;
 168     }
 169 
 170     public TypeMirror getObjectType() {
</pre>
<hr />
<pre>
 198     public TypeMirror getDeprecatedType() {
 199         return getSymbol(&quot;java.lang.Deprecated&quot;);
 200     }
 201 
 202     public TypeMirror getFunctionalInterface() {
 203         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 204     }
 205 
 206     /**
 207      * Return array of class members whose documentation is to be generated.
 208      * If the member is deprecated do not include such a member in the
 209      * returned array.
 210      *
 211      * @param  members    Array of members to choose from.
 212      * @return List       List of eligible members for whom
 213      *                    documentation is getting generated.
 214      */
 215     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
 216         return members.stream()
 217                       .filter(member -&gt; !isDeprecated(member))
<span class="line-modified"> 218                       .sorted(comparators.makeGeneralPurposeComparator())</span>
 219                       .collect(Collectors.toCollection(ArrayList::new));
 220     }
 221 
 222     /**
 223      * Search for the given method in the given class.
 224      *
 225      * @param  te        Class to search into.
 226      * @param  method    Method to be searched.
 227      * @return ExecutableElement Method found, null otherwise.
 228      */
 229     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 230         for (Element m : getMethods(te)) {
 231             if (executableMembersEqual(method, (ExecutableElement) m)) {
 232                 return (ExecutableElement) m;
 233             }
 234         }
 235         return null;
 236     }
 237 
 238     /**
</pre>
<hr />
<pre>
 643         switch(kind) {
 644               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 645               case LOCAL_VARIABLE: case PARAMETER:
 646               case RESOURCE_VARIABLE:
 647                   return true;
 648               default:
 649                   return false;
 650         }
 651     }
 652 
 653     public boolean isTypeElement(Element e) {
 654         switch (e.getKind()) {
 655             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 656                 return true;
 657             default:
 658                 return false;
 659         }
 660     }
 661 
 662     /**
<span class="line-modified"> 663      * Get the signature of an executable element with qualified parameter types</span>
<span class="line-added"> 664      * in the context of type element {@code site}.</span>
 665      * For instance, for a method {@code mymethod(String x, int y)},
 666      * it will return {@code (java.lang.String,int)}.
 667      *
<span class="line-modified"> 668      * @param e the executable element</span>
<span class="line-modified"> 669      * @param site the contextual site</span>
<span class="line-added"> 670      * @return String signature with qualified parameter types</span>
 671      */
<span class="line-modified"> 672     public String signature(ExecutableElement e, TypeElement site) {</span>
<span class="line-modified"> 673         return makeSignature(e, site, true);</span>
 674     }
 675 
 676     /**
<span class="line-modified"> 677      * Get the flat signature of an executable element with simple (unqualified)</span>
<span class="line-modified"> 678      * parameter types in the context of type element {@code site}.</span>

 679      * For instance, for a method {@code mymethod(String x, int y)},
 680      * it will return {@code (String, int)}.
<span class="line-added"> 681      *</span>
<span class="line-added"> 682      * @param e the executable element</span>
<span class="line-added"> 683      * @param site the contextual site</span>
<span class="line-added"> 684      * @return String signature with simple (unqualified) parameter types</span>
 685      */
<span class="line-modified"> 686     public String flatSignature(ExecutableElement e, TypeElement site) {</span>
<span class="line-modified"> 687         return makeSignature(e, site, false);</span>
 688     }
 689 
<span class="line-modified"> 690     public String makeSignature(ExecutableElement e, TypeElement site, boolean full) {</span>
<span class="line-modified"> 691         return makeSignature(e, site, full, false);</span>
 692     }
 693 
<span class="line-modified"> 694     public String makeSignature(ExecutableElement e, TypeElement site, boolean full, boolean ignoreTypeParameters) {</span>
 695         StringBuilder result = new StringBuilder();
 696         result.append(&quot;(&quot;);
<span class="line-modified"> 697         ExecutableType executableType = asInstantiatedMethodType(site, e);</span>
<span class="line-added"> 698         Iterator&lt;? extends TypeMirror&gt; iterator = executableType.getParameterTypes().iterator();</span>
 699         while (iterator.hasNext()) {
<span class="line-modified"> 700             TypeMirror type = iterator.next();</span>

 701             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 702             if (iterator.hasNext()) {
 703                 result.append(&quot;, &quot;);
 704             }
 705         }
 706         if (e.isVarArgs()) {
 707             int len = result.length();
 708             result.replace(len - 2, len, &quot;...&quot;);
 709         }
 710         result.append(&quot;)&quot;);
 711         return result.toString();
 712     }
 713 
 714     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 715         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 716             final StringBuilder sb = new StringBuilder();
 717 
 718             @Override
 719             public StringBuilder visitArray(ArrayType t, Void p) {
 720                 TypeMirror componentType = t.getComponentType();
</pre>
<hr />
<pre>
 913                 t = getSuperType(asTypeElement(t))) {
 914             TypeElement te = asTypeElement(t);
 915             if (te == null) {
 916                 return null;
 917             }
 918             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 919             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 920                 ExecutableElement ee = (ExecutableElement)e;
 921                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 922                         !isSimpleOverride(ee)) {
 923                     return ee;
 924                 }
 925             }
 926             if (t.equals(getObjectType()))
 927                 return null;
 928         }
 929         return null;
 930     }
 931 
 932     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
<span class="line-modified"> 933         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());</span>
 934         typeElements.forEach(set::add);
 935         return set;
 936     }
 937 
 938     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 939         return getBlockTags(member, SERIAL_DATA);
 940     }
 941 
 942     public FileObject getFileObject(TypeElement te) {
 943         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 944     }
 945 
 946     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 947         return getDeclaredType(Collections.emptyList(), enclosing, target);
 948     }
 949 
 950     /**
 951      * Finds the declaration of the enclosing&#39;s type parameter.
 952      *
 953      * @param values
</pre>
<hr />
<pre>
1561         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1562             return false;
1563 
1564         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1565         return fullBody.isEmpty() ||
1566                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1567     }
1568 
1569     /**
1570      * In case of JavaFX mode on, filters out classes that are private,
1571      * package private, these are not documented in JavaFX mode, also
1572      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1573      *
1574      * @param classlist a collection of TypeElements
1575      * @param javafx set to true if in JavaFX mode.
1576      * @return list of filtered classes.
1577      */
1578     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1579             boolean javafx) {
1580         SortedSet&lt;TypeElement&gt; filteredOutClasses =
<span class="line-modified">1581                 new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());</span>
1582         if (!javafx) {
1583             for (Element te : classlist) {
1584                 if (!hasHiddenTag(te)) {
1585                     filteredOutClasses.add((TypeElement)te);
1586                 }
1587             }
1588             return filteredOutClasses;
1589         }
1590         for (Element e : classlist) {
1591             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1592                 continue;
1593             }
1594             filteredOutClasses.add((TypeElement)e);
1595         }
1596         return filteredOutClasses;
1597     }
1598 
1599     /**
1600      * Compares two elements.
1601      * @param e1 first Element
</pre>
<hr />
<pre>
1628     public int compareStrings(String s1, String s2) {
1629         return compareStrings(true, s1, s2);
1630     }
1631 
1632     /**
1633      * A general purpose case sensitive String comparator, which
1634      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1635      *
1636      * @param s1 first String to compare.
1637      * @param s2 second String to compare.
1638      * @return a negative integer, zero, or a positive integer as the first
1639      *         argument is less than, equal to, or greater than the second.
1640      */
1641     public int compareCaseCompare(String s1, String s2) {
1642         return compareStrings(false, s1, s2);
1643     }
1644 
1645     private DocCollator tertiaryCollator = null;
1646     private DocCollator secondaryCollator = null;
1647 
<span class="line-modified">1648     int compareStrings(boolean caseSensitive, String s1, String s2) {</span>
1649         if (caseSensitive) {
1650             if (tertiaryCollator == null) {
1651                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1652             }
1653             return tertiaryCollator.compare(s1, s2);
1654         }
1655         if (secondaryCollator == null) {
1656             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1657         }
1658         return secondaryCollator.compare(s1, s2);
1659     }
1660 
1661     public String getHTMLTitle(Element element) {
1662         List&lt;? extends DocTree&gt; preamble = getPreamble(element);
1663         StringBuilder sb = new StringBuilder();
1664         boolean titleFound = false;
1665         loop:
1666         for (DocTree dt : preamble) {
1667             switch (dt.getKind()) {
1668                 case START_ELEMENT:
</pre>
<hr />
<pre>
1716         public int compare(String s1, String s2) {
1717             return getKey(s1).compareTo(getKey(s2));
1718         }
1719 
1720         private Collator createCollator(Locale locale) {
1721             Collator baseCollator = Collator.getInstance(locale);
1722             if (baseCollator instanceof RuleBasedCollator) {
1723                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1724                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1725                 try {
1726                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1727                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1728                 } catch (ParseException e) {
1729                     throw new RuntimeException(e);
1730                 }
1731             }
1732             return baseCollator;
1733         }
1734     }
1735 















































































































































































































































1736     /**
1737      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1738      * getQualified name, returns  the qualified name of the Reference type
1739      * otherwise the primitive name.
1740      * @param t the type whose name is to be obtained.
1741      * @return the fully qualified name of Reference type or the primitive name
1742      */
1743     public String getQualifiedTypeName(TypeMirror t) {
1744         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1745             @Override
1746             public String visitDeclared(DeclaredType t, Void p) {
1747                 return getFullyQualifiedName(t.asElement());
1748             }
1749 
1750             @Override
1751             public String visitArray(ArrayType t, Void p) {
1752                return visit(t.getComponentType());
1753             }
1754 
1755             @Override
</pre>
<hr />
<pre>
1788                 return e.getQualifiedName().toString();
1789             }
1790 
1791             @Override
1792             public String visitPackage(PackageElement e, Void p) {
1793                 return e.getQualifiedName().toString();
1794             }
1795 
1796             @Override
1797             public String visitType(TypeElement e, Void p) {
1798                 return e.getQualifiedName().toString();
1799             }
1800 
1801             @Override
1802             protected String defaultAction(Element e, Void p) {
1803                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
1804             }
1805         }.visit(e);
1806     }
1807 






















































































































































































































































1808 
1809     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
1810         List&lt;TypeElement&gt; out = getInterfaces(pkg);
1811         out.addAll(getClasses(pkg));
1812         out.addAll(getEnums(pkg));
1813         out.addAll(getAnnotationTypes(pkg));
1814         out.addAll(getRecords(pkg));
1815         return out;
1816     }
1817 
1818     // Element related methods
1819     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
1820         List&lt;Element&gt; members = getAnnotationFields(aClass);
1821         members.addAll(getAnnotationMethods(aClass));
1822         return members;
1823     }
1824 
1825     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
1826         return getItems0(aClass, true, FIELD);
1827     }
</pre>
<hr />
<pre>
1884         if (member == null || member.getKind() != ENUM_CONSTANT) {
1885             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
1886         }
1887         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
1888     }
1889 
1890     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
1891     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
1892         if (modulePackageMap == null) {
1893             modulePackageMap = new HashMap&lt;&gt;();
1894             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
1895             pkgs.forEach(pkg -&gt; {
1896                 ModuleElement mod = elementUtils.getModuleOf(pkg);
1897                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
1898             });
1899         }
1900         return modulePackageMap;
1901     }
1902 
1903     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
<span class="line-modified">1904         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(comparators.makeModuleComparator());</span>
1905         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
1906         // get all the requires for the element in question
1907         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
1908             ModuleElement dep = rd.getDependency();
1909             // add the dependency to work queue
1910             if (!result.containsKey(dep)) {
1911                 if (rd.isTransitive()) {
1912                     queue.addLast(dep);
1913                 }
1914             }
1915             // add all exports for the primary module
1916             result.put(rd.getDependency(), getModifiers(rd));
1917         }
1918 
1919         // add only requires public for subsequent module dependencies
1920         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
1921             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
1922                 ModuleElement dep = rd.getDependency();
1923                 if (!result.containsKey(dep)) {
1924                     if (rd.isTransitive()) {
</pre>
<hr />
<pre>
1990         return convertToTypeElement(getItems(e, false, INTERFACE));
1991     }
1992 
1993     public List&lt;Element&gt; getEnumConstants(Element e) {
1994         return getItems(e, true, ENUM_CONSTANT);
1995     }
1996 
1997     public List&lt;TypeElement&gt; getEnums(Element e) {
1998         return convertToTypeElement(getItems(e, true, ENUM));
1999     }
2000 
2001     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2002         return convertToTypeElement(getItems(e, false, ENUM));
2003     }
2004 
2005     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2006         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2007         clist.addAll(getInterfacesUnfiltered(e));
2008         clist.addAll(getAnnotationTypesUnfiltered(e));
2009         clist.addAll(getRecordsUnfiltered(e));
<span class="line-modified">2010         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());</span>
2011         oset.addAll(clist);
2012         return oset;
2013     }
2014 
2015     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2016     /**
2017      * Returns a list containing classes and interfaces,
2018      * including annotation types.
2019      * @param e Element
2020      * @return List
2021      */
2022     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2023         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2024         if (oset != null)
2025             return oset;
2026         List&lt;TypeElement&gt; clist = getClasses(e);
2027         clist.addAll(getInterfaces(e));
2028         clist.addAll(getAnnotationTypes(e));
2029         clist.addAll(getEnums(e));
2030         clist.addAll(getRecords(e));
<span class="line-modified">2031         oset = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());</span>
2032         oset.addAll(clist);
2033         cachedClasses.put(e, oset);
2034         return oset;
2035     }
2036 
2037     /*
2038      * Get all the elements unfiltered and filter them finally based
2039      * on its visibility, this works differently from the other getters.
2040      */
2041     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2042         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2043         for (TypeElement te : getClassesUnfiltered(e)) {
2044             if (!filter || configuration.docEnv.isSelected(te)) {
2045                 olist.add(te);
2046             }
2047         }
2048         for (TypeElement te : getInterfacesUnfiltered(e)) {
2049             if (!filter || configuration.docEnv.isSelected(te)) {
2050                 olist.add(te);
2051             }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../../java.base/share/classes/java/lang/System.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
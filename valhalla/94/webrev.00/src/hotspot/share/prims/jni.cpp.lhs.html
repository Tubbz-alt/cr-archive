<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/modules.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  41 #include &quot;interpreter/linkResolver.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.inline.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  62 #include &quot;oops/valueArrayOop.inline.hpp&quot;
  63 #include &quot;oops/valueKlass.inline.hpp&quot;
  64 #include &quot;prims/jniCheck.hpp&quot;
  65 #include &quot;prims/jniExport.hpp&quot;
  66 #include &quot;prims/jniFastGetField.hpp&quot;
  67 #include &quot;prims/jvm_misc.hpp&quot;
  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiThreadState.hpp&quot;
  70 #include &quot;runtime/atomic.hpp&quot;
  71 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  72 #include &quot;runtime/handles.inline.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/java.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  77 #include &quot;runtime/jniHandles.inline.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/safepointVerifiers.hpp&quot;
  80 #include &quot;runtime/sharedRuntime.hpp&quot;
  81 #include &quot;runtime/signature.hpp&quot;
  82 #include &quot;runtime/thread.inline.hpp&quot;
  83 #include &quot;runtime/vmOperations.hpp&quot;
  84 #include &quot;services/memTracker.hpp&quot;
  85 #include &quot;services/runtimeService.hpp&quot;
  86 #include &quot;utilities/defaultStream.hpp&quot;
  87 #include &quot;utilities/dtrace.hpp&quot;
  88 #include &quot;utilities/events.hpp&quot;
  89 #include &quot;utilities/histogram.hpp&quot;
  90 #include &quot;utilities/macros.hpp&quot;
  91 #include &quot;utilities/vmError.hpp&quot;
  92 #if INCLUDE_JVMCI
  93 #include &quot;jvmci/jvmciCompiler.hpp&quot;
  94 #endif
  95 
  96 static jint CurrentVersion = JNI_VERSION_10;
  97 
  98 #ifdef _WIN32
  99 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
 100 #endif
 101 
 102 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 103 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
 104 // Methods that have multiple return paths use this to avoid having to
 105 // instrument each return path.  Methods that use CHECK or THROW must use this
 106 // since those macros can cause an immedate uninstrumented return.
 107 //
 108 // In order to get the return value, a reference to the variable containing
 109 // the return value must be passed to the contructor of the object, and
 110 // the return value must be set before return (since the mark object has
 111 // a reference to it).
 112 //
 113 // Example:
 114 // DT_RETURN_MARK_DECL(SomeFunc, int);
 115 // JNI_ENTRY(int, SomeFunc, ...)
 116 //   int return_value = 0;
 117 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 118 //   foo(CHECK_0)
 119 //   return_value = 5;
 120 //   return return_value;
 121 // JNI_END
 122 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 123   DTRACE_ONLY(                                                             \
 124     class DTraceReturnProbeMark_##name {                                   \
 125      public:                                                               \
 126       const type&amp; _ret_ref;                                                \
 127       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 128       ~DTraceReturnProbeMark_##name() {                                    \
 129         probe;                                                             \
 130       }                                                                    \
 131     }                                                                      \
 132   )
 133 // Void functions are simpler since there&#39;s no return value
 134 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 135   DTRACE_ONLY(                                                             \
 136     class DTraceReturnProbeMark_##name {                                   \
 137      public:                                                               \
 138       ~DTraceReturnProbeMark_##name() {                                    \
 139         probe;                                                             \
 140       }                                                                    \
 141     }                                                                      \
 142   )
 143 
 144 // Place these macros in the function to mark the return.  Non-void
 145 // functions need the type and address of the return value.
 146 #define DT_RETURN_MARK(name, type, ref) \
 147   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 148 #define DT_VOID_RETURN_MARK(name) \
 149   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 150 
 151 
 152 // Use these to select distinct code for floating-point vs. non-floating point
 153 // situations.  Used from within common macros where we need slightly
 154 // different behavior for Float/Double
 155 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 156 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 157 #define FP_SELECT_Char(intcode, fpcode)    intcode
 158 #define FP_SELECT_Short(intcode, fpcode)   intcode
 159 #define FP_SELECT_Object(intcode, fpcode)  intcode
 160 #define FP_SELECT_Int(intcode, fpcode)     intcode
 161 #define FP_SELECT_Long(intcode, fpcode)    intcode
 162 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 163 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 164 #define FP_SELECT(TypeName, intcode, fpcode) \
 165   FP_SELECT_##TypeName(intcode, fpcode)
 166 
 167 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 168 // (dtrace doesn&#39;t do FP yet)
 169 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 170   FP_SELECT(TypeName, \
 171     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 172 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 173   FP_SELECT(TypeName, \
 174     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 175 
 176 
 177 // out-of-line helpers for class jfieldIDWorkaround:
 178 
 179 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 180   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 181     uintptr_t as_uint = (uintptr_t) id;
 182     intptr_t offset = raw_instance_offset(id);
 183     if (is_checked_jfieldID(id)) {
 184       if (!klass_hash_ok(k, id)) {
 185         return false;
 186       }
 187     }
 188     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 189   } else {
 190     JNIid* result = (JNIid*) id;
 191 #ifdef ASSERT
 192     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 193 #else
 194     return result != NULL;
 195 #endif
 196   }
 197 }
 198 
 199 
 200 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 201   if (offset &lt;= small_offset_mask) {
 202     Klass* field_klass = k;
 203     Klass* super_klass = field_klass-&gt;super();
 204     // With compressed oops the most super class with nonstatic fields would
 205     // be the owner of fields embedded in the header.
 206     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 207            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 208       field_klass = super_klass;   // super contains the field also
 209       super_klass = field_klass-&gt;super();
 210     }
 211     debug_only(NoSafepointVerifier nosafepoint;)
 212     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 213     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 214   } else {
 215 #if 0
 216     #ifndef PRODUCT
 217     {
 218       ResourceMark rm;
 219       warning(&quot;VerifyJNIFields: long offset %d in %s&quot;, offset, k-&gt;external_name());
 220     }
 221     #endif
 222 #endif
 223     return 0;
 224   }
 225 }
 226 
 227 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 228   uintptr_t as_uint = (uintptr_t) id;
 229   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 230   do {
 231     debug_only(NoSafepointVerifier nosafepoint;)
 232     // Could use a non-blocking query for identity_hash here...
 233     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 234       return true;
 235     k = k-&gt;super();
 236   } while (k != NULL);
 237   return false;
 238 }
 239 
 240 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 241   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), &quot;must be an instance field&quot; );
 242   uintptr_t as_uint = (uintptr_t) id;
 243   intptr_t offset = raw_instance_offset(id);
 244   if (VerifyJNIFields) {
 245     if (is_checked_jfieldID(id)) {
 246       guarantee(klass_hash_ok(k, id),
 247     &quot;Bug in native code: jfieldID class must match object&quot;);
 248     } else {
 249 #if 0
 250       #ifndef PRODUCT
 251       if (Verbose) {
 252   ResourceMark rm;
 253   warning(&quot;VerifyJNIFields: unverified offset %d for %s&quot;, offset, k-&gt;external_name());
 254       }
 255       #endif
 256 #endif
 257     }
 258   }
 259   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 260       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 261 }
 262 
 263 // Wrapper to trace JNI functions
 264 
 265 #ifdef ASSERT
 266   Histogram* JNIHistogram;
 267   static volatile int JNIHistogram_lock = 0;
 268 
 269   class JNIHistogramElement : public HistogramElement {
 270     public:
 271      JNIHistogramElement(const char* name);
 272   };
 273 
 274   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 275     _name = elementName;
 276     uintx count = 0;
 277 
 278     while (Atomic::cmpxchg(&amp;JNIHistogram_lock, 0, 1) != 0) {
 279       while (Atomic::load_acquire(&amp;JNIHistogram_lock) != 0) {
 280         count +=1;
 281         if ( (WarnOnStalledSpinLock &gt; 0)
 282           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 283           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 284         }
 285       }
 286      }
 287 
 288 
 289     if(JNIHistogram == NULL)
 290       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 291 
 292     JNIHistogram-&gt;add_element(this);
 293     Atomic::dec(&amp;JNIHistogram_lock);
 294   }
 295 
 296   #define JNICountWrapper(arg)                                     \
 297      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 298       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 299      if (e != NULL) e-&gt;increment_count()
 300   #define JNIWrapper(arg) JNICountWrapper(arg);
 301 #else
 302   #define JNIWrapper(arg)
 303 #endif
 304 
 305 
 306 // Implementation of JNI entries
 307 
 308 DT_RETURN_MARK_DECL(DefineClass, jclass
 309                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 310 
 311 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 312                                   const jbyte *buf, jsize bufLen))
 313   JNIWrapper(&quot;DefineClass&quot;);
 314 
 315   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 316     env, (char*) name, loaderRef, (char*) buf, bufLen);
 317 
 318   jclass cls = NULL;
 319   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 320 
 321   // Class resolution will get the class name from the .class stream if the name is null.
 322   TempNewSymbol class_name = name == NULL ? NULL :
 323     SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
 324                                         CHECK_NULL);
 325 
 326   ResourceMark rm(THREAD);
 327   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 328   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 329 
 330   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 331     // check whether the current caller thread holds the lock or not.
 332     // If not, increment the corresponding counter
 333     if (ObjectSynchronizer::
 334         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 335         ObjectSynchronizer::owner_self) {
 336       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 337     }
 338   }
 339   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 340                                                    class_loader,
 341                                                    Handle(),
 342                                                    &amp;st,
 343                                                    CHECK_NULL);
 344 
 345   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 346     trace_class_resolution(k);
 347   }
 348 
 349   cls = (jclass)JNIHandles::make_local(
 350     env, k-&gt;java_mirror());
 351   return cls;
 352 JNI_END
 353 
 354 
 355 
 356 DT_RETURN_MARK_DECL(FindClass, jclass
 357                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 358 
 359 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 360   JNIWrapper(&quot;FindClass&quot;);
 361 
 362   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 363 
 364   jclass result = NULL;
 365   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 366 
 367   // This should be ClassNotFoundException imo.
 368   TempNewSymbol class_name =
 369     SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
 370                                         CHECK_NULL);
 371 
 372   //%note jni_3
 373   Handle protection_domain;
 374   // Find calling class
 375   Klass* k = thread-&gt;security_get_caller_class(0);
 376   // default to the system loader when no context
 377   Handle loader(THREAD, SystemDictionary::java_system_loader());
 378   if (k != NULL) {
 379     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 380     // in the correct class context.
 381     if (k-&gt;class_loader() == NULL &amp;&amp;
 382         k-&gt;name() == vmSymbols::jdk_internal_loader_NativeLibraries()) {
 383       JavaValue result(T_OBJECT);
 384       JavaCalls::call_static(&amp;result, k,
 385                              vmSymbols::getFromClass_name(),
 386                              vmSymbols::void_class_signature(),
 387                              CHECK_NULL);
 388       // When invoked from JNI_OnLoad, NativeLibraries::getFromClass returns
 389       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 390       // it will return NULL to indicate no context.
 391       oop mirror = (oop) result.get_jobject();
 392       if (mirror != NULL) {
 393         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 394         loader = Handle(THREAD, fromClass-&gt;class_loader());
 395         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 396       }
 397     } else {
 398       loader = Handle(THREAD, k-&gt;class_loader());
 399     }
 400   }
 401 
 402   result = find_class_from_class_loader(env, class_name, true, loader,
 403                                         protection_domain, true, thread);
 404 
 405   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 406     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 407   }
 408 
 409   return result;
 410 JNI_END
 411 
 412 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 413                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 414 
 415 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 416   JNIWrapper(&quot;FromReflectedMethod&quot;);
 417 
 418   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 419 
 420   jmethodID ret = NULL;
 421   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 422 
 423   // method is a handle to a java.lang.reflect.Method object
 424   oop reflected  = JNIHandles::resolve_non_null(method);
 425   oop mirror     = NULL;
 426   int slot       = 0;
 427 
 428   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 429     mirror = java_lang_reflect_Constructor::clazz(reflected);
 430     slot   = java_lang_reflect_Constructor::slot(reflected);
 431   } else {
 432     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 433     mirror = java_lang_reflect_Method::clazz(reflected);
 434     slot   = java_lang_reflect_Method::slot(reflected);
 435   }
 436   Klass* k1 = java_lang_Class::as_Klass(mirror);
 437 
 438   // Make sure class is initialized before handing id&#39;s out to methods
 439   k1-&gt;initialize(CHECK_NULL);
 440   Method* m = InstanceKlass::cast(k1)-&gt;method_with_idnum(slot);
 441   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 442   return ret;
 443 JNI_END
 444 
 445 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 446                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 447 
 448 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 449   JNIWrapper(&quot;FromReflectedField&quot;);
 450 
 451   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 452 
 453   jfieldID ret = NULL;
 454   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 455 
 456   // field is a handle to a java.lang.reflect.Field object
 457   oop reflected   = JNIHandles::resolve_non_null(field);
 458   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 459   Klass* k1       = java_lang_Class::as_Klass(mirror);
 460   int slot        = java_lang_reflect_Field::slot(reflected);
 461   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 462 
 463   // Make sure class is initialized before handing id&#39;s out to fields
 464   k1-&gt;initialize(CHECK_NULL);
 465 
 466   // First check if this is a static field
 467   if (modifiers &amp; JVM_ACC_STATIC) {
 468     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 469     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 470     assert(id != NULL, &quot;corrupt Field object&quot;);
 471     debug_only(id-&gt;set_is_static_field_id();)
 472     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 473     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 474     return ret;
 475   }
 476 
 477   // The slot is the index of the field description in the field-array
 478   // The jfieldID is the offset of the field within the object
 479   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 480   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 481   bool is_inlined = InstanceKlass::cast(k1)-&gt;field_is_inlined(slot);
 482   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
 483   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_inlined);
 484   return ret;
 485 JNI_END
 486 
 487 
 488 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 489                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 490 
 491 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 492   JNIWrapper(&quot;ToReflectedMethod&quot;);
 493 
 494   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 495 
 496   jobject ret = NULL;
 497   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 498 
 499   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 500   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 501   oop reflection_method;
<a name="1" id="anc1"></a><span class="line-modified"> 502   if (m-&gt;is_object_constructor()) {</span>
 503     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 504   } else {
 505     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 506   }
 507   ret = JNIHandles::make_local(env, reflection_method);
 508   return ret;
 509 JNI_END
 510 
 511 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 512                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 513 
 514 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 515   JNIWrapper(&quot;GetSuperclass&quot;);
 516 
 517   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 518 
 519   jclass obj = NULL;
 520   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 521 
 522   oop mirror = JNIHandles::resolve_non_null(sub);
 523   // primitive classes return NULL
 524   if (java_lang_Class::is_primitive(mirror)) return NULL;
 525 
 526   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 527   // arrays return Object
 528   // interfaces return NULL
 529   // proper classes return Klass::super()
 530   Klass* k = java_lang_Class::as_Klass(mirror);
 531   if (k-&gt;is_interface()) return NULL;
 532 
 533   // return mirror for superclass
 534   Klass* super = k-&gt;java_super();
 535   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 536   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 537                                  ? SystemDictionary::Object_klass()
 538                                  : k-&gt;super() ) );
 539   assert(super == super2,
 540          &quot;java_super computation depends on interface, array, other super&quot;);
 541   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 542   return obj;
 543 JNI_END
 544 
 545 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 546   JNIWrapper(&quot;IsSubclassOf&quot;);
 547 
 548   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 549 
 550   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 551   oop super_mirror = JNIHandles::resolve_non_null(super);
 552   if (java_lang_Class::is_primitive(sub_mirror) ||
 553       java_lang_Class::is_primitive(super_mirror)) {
 554     jboolean ret = (sub_mirror == super_mirror);
 555 
 556     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 557     return ret;
 558   }
 559   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 560   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 561   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 562   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 563                    JNI_TRUE : JNI_FALSE;
 564   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 565   return ret;
 566 JNI_END
 567 
 568 
 569 DT_RETURN_MARK_DECL(Throw, jint
 570                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 571 
 572 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 573   JNIWrapper(&quot;Throw&quot;);
 574 
 575   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 576 
 577   jint ret = JNI_OK;
 578   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 579 
 580   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 581   ShouldNotReachHere();
 582   return 0;  // Mute compiler.
 583 JNI_END
 584 
 585 
 586 DT_RETURN_MARK_DECL(ThrowNew, jint
 587                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 588 
 589 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 590   JNIWrapper(&quot;ThrowNew&quot;);
 591 
 592   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 593 
 594   jint ret = JNI_OK;
 595   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 596 
 597   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 598   Symbol*  name = k-&gt;name();
 599   Handle class_loader (THREAD,  k-&gt;class_loader());
 600   Handle protection_domain (THREAD, k-&gt;protection_domain());
 601   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 602   ShouldNotReachHere();
 603   return 0;  // Mute compiler.
 604 JNI_END
 605 
 606 
 607 // JNI functions only transform a pending async exception to a synchronous
 608 // exception in ExceptionOccurred and ExceptionCheck calls, since
 609 // delivering an async exception in other places won&#39;t change the native
 610 // code&#39;s control flow and would be harmful when native code further calls
 611 // JNI functions with a pending exception. Async exception is also checked
 612 // during the call, so ExceptionOccurred/ExceptionCheck won&#39;t return
 613 // false but deliver the async exception at the very end during
 614 // state transition.
 615 
 616 static void jni_check_async_exceptions(JavaThread *thread) {
 617   assert(thread == Thread::current(), &quot;must be itself&quot;);
 618   thread-&gt;check_and_handle_async_exceptions();
 619 }
 620 
 621 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 622   JNIWrapper(&quot;ExceptionOccurred&quot;);
 623 
 624   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 625 
 626   jni_check_async_exceptions(thread);
 627   oop exception = thread-&gt;pending_exception();
 628   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 629 
 630   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 631   return ret;
 632 JNI_END
 633 
 634 
 635 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 636   JNIWrapper(&quot;ExceptionDescribe&quot;);
 637 
 638   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 639 
 640   if (thread-&gt;has_pending_exception()) {
 641     Handle ex(thread, thread-&gt;pending_exception());
 642     thread-&gt;clear_pending_exception();
 643     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 644       // Don&#39;t print anything if we are being killed.
 645     } else {
 646       jio_fprintf(defaultStream::error_stream(), &quot;Exception &quot;);
 647       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 648         ResourceMark rm(THREAD);
 649         jio_fprintf(defaultStream::error_stream(),
 650         &quot;in thread \&quot;%s\&quot; &quot;, thread-&gt;get_thread_name());
 651       }
 652       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 653         JavaValue result(T_VOID);
 654         JavaCalls::call_virtual(&amp;result,
 655                                 ex,
 656                                 SystemDictionary::Throwable_klass(),
 657                                 vmSymbols::printStackTrace_name(),
 658                                 vmSymbols::void_method_signature(),
 659                                 THREAD);
 660         // If an exception is thrown in the call it gets thrown away. Not much
 661         // we can do with it. The native code that calls this, does not check
 662         // for the exception - hence, it might still be in the thread when DestroyVM gets
 663         // called, potentially causing a few asserts to trigger - since no pending exception
 664         // is expected.
 665         CLEAR_PENDING_EXCEPTION;
 666       } else {
 667         ResourceMark rm(THREAD);
 668         jio_fprintf(defaultStream::error_stream(),
 669         &quot;. Uncaught exception of type %s.&quot;,
 670         ex-&gt;klass()-&gt;external_name());
 671       }
 672     }
 673   }
 674 
 675   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 676 JNI_END
 677 
 678 
 679 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))
 680   JNIWrapper(&quot;ExceptionClear&quot;);
 681 
 682   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 683 
 684   // The jni code might be using this API to clear java thrown exception.
 685   // So just mark jvmti thread exception state as exception caught.
 686   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 687   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 688     state-&gt;set_exception_caught();
 689   }
 690   thread-&gt;clear_pending_exception();
 691 
 692   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 693 JNI_END
 694 
 695 
 696 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 697   JNIWrapper(&quot;FatalError&quot;);
 698 
 699   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 700 
 701   tty-&gt;print_cr(&quot;FATAL ERROR in native method: %s&quot;, msg);
 702   thread-&gt;print_stack();
 703   os::abort(); // Dump core and abort
 704 JNI_END
 705 
 706 
 707 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 708   JNIWrapper(&quot;PushLocalFrame&quot;);
 709 
 710   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 711 
 712   //%note jni_11
 713   if (capacity &lt; 0 ||
 714       ((MaxJNILocalCapacity &gt; 0) &amp;&amp; (capacity &gt; MaxJNILocalCapacity))) {
 715     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 716     return JNI_ERR;
 717   }
 718   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 719   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 720   assert(new_handles != NULL, &quot;should not be NULL&quot;);
 721   new_handles-&gt;set_pop_frame_link(old_handles);
 722   thread-&gt;set_active_handles(new_handles);
 723   jint ret = JNI_OK;
 724   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 725   return ret;
 726 JNI_END
 727 
 728 
 729 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 730   JNIWrapper(&quot;PopLocalFrame&quot;);
 731 
 732   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 733 
 734   //%note jni_11
 735   Handle result_handle(thread, JNIHandles::resolve(result));
 736   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 737   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 738   if (new_handles != NULL) {
 739     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 740     // This way code will still work if PopLocalFrame is called without a corresponding
 741     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 742     // the release_block call will release the blocks.
 743     thread-&gt;set_active_handles(new_handles);
 744     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won&#39;t release new_handles below
 745     JNIHandleBlock::release_block(old_handles, thread); // may block
 746     result = JNIHandles::make_local(thread, result_handle());
 747   }
 748   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 749   return result;
 750 JNI_END
 751 
 752 
 753 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 754   JNIWrapper(&quot;NewGlobalRef&quot;);
 755 
 756   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 757 
 758   Handle ref_handle(thread, JNIHandles::resolve(ref));
 759   jobject ret = JNIHandles::make_global(ref_handle);
 760 
 761   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 762   return ret;
 763 JNI_END
 764 
 765 // Must be JNI_ENTRY (with HandleMark)
 766 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 767   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 768 
 769   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 770 
 771   JNIHandles::destroy_global(ref);
 772 
 773   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 774 JNI_END
 775 
 776 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 777   JNIWrapper(&quot;DeleteLocalRef&quot;);
 778 
 779   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 780 
 781   JNIHandles::destroy_local(obj);
 782 
 783   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 784 JNI_END
 785 
 786 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 787   JNIWrapper(&quot;IsSameObject&quot;);
 788 
 789   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 790 
 791   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 792 
 793   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 794   return ret;
 795 JNI_END
 796 
 797 
 798 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 799   JNIWrapper(&quot;NewLocalRef&quot;);
 800 
 801   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 802 
 803   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 804 
 805   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 806   return ret;
 807 JNI_END
 808 
 809 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 810   JNIWrapper(&quot;EnsureLocalCapacity&quot;);
 811 
 812   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 813 
 814   jint ret;
 815   if (capacity &gt;= 0 &amp;&amp;
 816       ((MaxJNILocalCapacity &lt;= 0) || (capacity &lt;= MaxJNILocalCapacity))) {
 817     ret = JNI_OK;
 818   } else {
 819     ret = JNI_ERR;
 820   }
 821 
 822   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 823   return ret;
 824 JNI_END
 825 
 826 // Return the Handle Type
 827 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 828   JNIWrapper(&quot;GetObjectRefType&quot;);
 829 
 830   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 831 
 832   jobjectRefType ret = JNIInvalidRefType;
 833   if (obj != NULL) {
 834     ret = JNIHandles::handle_type(thread, obj);
 835   }
 836 
 837   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 838   return ret;
 839 JNI_END
 840 
 841 
 842 class JNI_ArgumentPusher : public SignatureIterator {
 843  protected:
 844   JavaCallArguments*  _arguments;
 845 
 846   void push_int(jint x)         { _arguments-&gt;push_int(x); }
 847   void push_long(jlong x)       { _arguments-&gt;push_long(x); }
 848   void push_float(jfloat x)     { _arguments-&gt;push_float(x); }
 849   void push_double(jdouble x)   { _arguments-&gt;push_double(x); }
 850   void push_object(jobject x)   { _arguments-&gt;push_jobject(x); }
 851 
 852   void push_boolean(jboolean b) {
 853     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
 854     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
 855     // TemplateInterpreterGenerator::generate_result_handler_for and
 856     // SharedRuntime::generate_native_wrapper.
 857     push_int(b == 0 ? JNI_FALSE : JNI_TRUE);
 858   }
 859 
 860   JNI_ArgumentPusher(Method* method)
 861     : SignatureIterator(method-&gt;signature(),
 862                         Fingerprinter(methodHandle(Thread::current(), method)).fingerprint())
 863   {
 864     _arguments = NULL;
 865   }
 866 
 867  public:
 868   virtual void push_arguments_on(JavaCallArguments* arguments) = 0;
 869 };
 870 
 871 
 872 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 873  protected:
 874   va_list _ap;
 875 
 876   void set_ap(va_list rap) {
 877     va_copy(_ap, rap);
 878   }
 879 
 880   friend class SignatureIterator;  // so do_parameters_on can call do_type
 881   void do_type(BasicType type) {
 882     switch (type) {
 883     // these are coerced to int when using va_arg
 884     case T_BYTE:
 885     case T_CHAR:
 886     case T_SHORT:
 887     case T_INT:         push_int(va_arg(_ap, jint)); break;
 888     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;
 889 
 890     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 891 
 892     case T_LONG:        push_long(va_arg(_ap, jlong)); break;
 893     // float is coerced to double w/ va_arg
 894     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
 895     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 896 
 897     case T_ARRAY:
 898     case T_OBJECT:
 899     case T_VALUETYPE:   push_object(va_arg(_ap, jobject)); break;
 900     default:            ShouldNotReachHere();
 901     }
 902   }
 903 
 904  public:
 905   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 906       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 907     set_ap(rap);
 908   }
 909 
 910   virtual void push_arguments_on(JavaCallArguments* arguments) {
 911     _arguments = arguments;
 912     do_parameters_on(this);
 913   }
 914 };
 915 
 916 
 917 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 918  protected:
 919   const jvalue *_ap;
 920 
 921   inline void set_ap(const jvalue *rap) { _ap = rap; }
 922 
 923   friend class SignatureIterator;  // so do_parameters_on can call do_type
 924   void do_type(BasicType type) {
 925     switch (type) {
 926     case T_CHAR:        push_int((_ap++)-&gt;c); break;
 927     case T_SHORT:       push_int((_ap++)-&gt;s); break;
 928     case T_BYTE:        push_int((_ap++)-&gt;b); break;
 929     case T_INT:         push_int((_ap++)-&gt;i); break;
 930     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
 931     case T_LONG:        push_long((_ap++)-&gt;j); break;
 932     case T_FLOAT:       push_float((_ap++)-&gt;f); break;
 933     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
 934     case T_ARRAY:
 935     case T_OBJECT:
 936     case T_VALUETYPE:   push_object((_ap++)-&gt;l); break;
 937     default:            ShouldNotReachHere();
 938     }
 939   }
 940 
 941  public:
 942   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
 943       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 944     set_ap(rap);
 945   }
 946 
 947   virtual void push_arguments_on(JavaCallArguments* arguments) {
 948     _arguments = arguments;
 949     do_parameters_on(this);
 950   }
 951 };
 952 
 953 
 954 enum JNICallType {
 955   JNI_STATIC,
 956   JNI_VIRTUAL,
 957   JNI_NONVIRTUAL
 958 };
 959 
 960 
 961 
 962 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
 963   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
 964 
 965   // Create object to hold arguments for the JavaCall, and associate it with
 966   // the jni parser
 967   ResourceMark rm(THREAD);
 968   int number_of_parameters = method-&gt;size_of_parameters();
 969   JavaCallArguments java_args(number_of_parameters);
 970 
 971   assert(method-&gt;is_static(), &quot;method should be static&quot;);
 972 
 973   // Fill out JavaCallArguments object
 974   args-&gt;push_arguments_on(&amp;java_args);
 975   // Initialize result type
 976   result-&gt;set_type(args-&gt;return_type());
 977 
 978   // Invoke the method. Result is returned as oop.
 979   JavaCalls::call(result, method, &amp;java_args, CHECK);
 980 
 981   // Convert result
 982   if (is_reference_type(result-&gt;get_type())) {
 983     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
 984   }
 985 }
 986 
 987 
 988 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
 989   oop recv = JNIHandles::resolve(receiver);
 990   if (recv == NULL) {
 991     THROW(vmSymbols::java_lang_NullPointerException());
 992   }
 993   Handle h_recv(THREAD, recv);
 994 
 995   int number_of_parameters;
 996   Method* selected_method;
 997   {
 998     Method* m = Method::resolve_jmethod_id(method_id);
 999     number_of_parameters = m-&gt;size_of_parameters();
1000     Klass* holder = m-&gt;method_holder();
1001     if (call_type != JNI_VIRTUAL) {
1002         selected_method = m;
1003     } else if (!m-&gt;has_itable_index()) {
1004       // non-interface call -- for that little speed boost, don&#39;t handlize
1005       debug_only(NoSafepointVerifier nosafepoint;)
1006       // jni_GetMethodID makes sure class is linked and initialized
1007       // so m should have a valid vtable index.
1008       assert(m-&gt;valid_vtable_index(), &quot;no valid vtable index&quot;);
1009       int vtbl_index = m-&gt;vtable_index();
1010       if (vtbl_index != Method::nonvirtual_vtable_index) {
1011         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1012       } else {
1013         // final method
1014         selected_method = m;
1015       }
1016     } else {
1017       // interface call
1018       int itbl_index = m-&gt;itable_index();
1019       Klass* k = h_recv-&gt;klass();
1020       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1021     }
1022   }
1023 
1024   methodHandle method(THREAD, selected_method);
1025 
1026   // Create object to hold arguments for the JavaCall, and associate it with
1027   // the jni parser
1028   ResourceMark rm(THREAD);
1029   JavaCallArguments java_args(number_of_parameters);
1030 
1031   // handle arguments
1032   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
1033   java_args.push_oop(h_recv); // Push jobject handle
1034 
1035   // Fill out JavaCallArguments object
1036   args-&gt;push_arguments_on(&amp;java_args);
1037   // Initialize result type
1038   result-&gt;set_type(args-&gt;return_type());
1039 
1040   // Invoke the method. Result is returned as oop.
1041   JavaCalls::call(result, method, &amp;java_args, CHECK);
1042 
1043   // Convert result
1044   if (is_reference_type(result-&gt;get_type())) {
1045     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1046   }
1047 }
1048 
1049 DT_RETURN_MARK_DECL(AllocObject, jobject
1050                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1051 
1052 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1053   JNIWrapper(&quot;AllocObject&quot;);
1054 
1055   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1056 
1057   jobject ret = NULL;
1058   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1059 
1060   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
1061   ret = JNIHandles::make_local(env, i);
1062   return ret;
1063 JNI_END
1064 
1065 DT_RETURN_MARK_DECL(NewObjectA, jobject
1066                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1067 
1068 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1069   JNIWrapper(&quot;NewObjectA&quot;);
1070 
1071   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1072 
1073   jobject obj = NULL;
1074   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1075 
1076   oop clazzoop = JNIHandles::resolve_non_null(clazz);
1077   Klass* k = java_lang_Class::as_Klass(clazzoop);
1078   if (k == NULL) {
1079     ResourceMark rm(THREAD);
1080     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1081   }
1082 
1083   if (!k-&gt;is_inline_klass()) {
1084     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
1085     obj = JNIHandles::make_local(env, i);
1086     JavaValue jvalue(T_VOID);
1087     JNI_ArgumentPusherArray ap(methodID, args);
1088     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1089   } else {
1090     JavaValue jvalue(T_VALUETYPE);
1091     JNI_ArgumentPusherArray ap(methodID, args);
1092     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1093     obj = jvalue.get_jobject();
1094   }
1095   return obj;
1096   JNI_END
1097 
1098 
1099 DT_RETURN_MARK_DECL(NewObjectV, jobject
1100                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1101 
1102 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1103   JNIWrapper(&quot;NewObjectV&quot;);
1104 
1105   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1106 
1107   jobject obj = NULL;
1108   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1109 
1110   oop clazzoop = JNIHandles::resolve_non_null(clazz);
1111   Klass* k = java_lang_Class::as_Klass(clazzoop);
1112   if (k == NULL) {
1113     ResourceMark rm(THREAD);
1114     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1115   }
1116 
1117   if (!k-&gt;is_inline_klass()) {
1118     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
1119     obj = JNIHandles::make_local(env, i);
1120     JavaValue jvalue(T_VOID);
1121     JNI_ArgumentPusherVaArg ap(methodID, args);
1122     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1123   } else {
1124     JavaValue jvalue(T_VALUETYPE);
1125     JNI_ArgumentPusherVaArg ap(methodID, args);
1126     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1127     obj = jvalue.get_jobject();
1128   }
1129   return obj;
1130 JNI_END
1131 
1132 
1133 DT_RETURN_MARK_DECL(NewObject, jobject
1134                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1135 
1136 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1137   JNIWrapper(&quot;NewObject&quot;);
1138 
1139   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1140 
1141   jobject obj = NULL;
1142   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1143 
1144   oop clazzoop = JNIHandles::resolve_non_null(clazz);
1145   Klass* k = java_lang_Class::as_Klass(clazzoop);
1146   if (k == NULL) {
1147     ResourceMark rm(THREAD);
1148     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1149   }
1150 
1151   if (!k-&gt;is_inline_klass()) {
1152     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
1153     obj = JNIHandles::make_local(env, i);
1154     va_list args;
1155     va_start(args, methodID);
1156     JavaValue jvalue(T_VOID);
1157     JNI_ArgumentPusherVaArg ap(methodID, args);
1158     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1159     va_end(args);
1160   } else {
1161     va_list args;
1162     va_start(args, methodID);
1163     JavaValue jvalue(T_VALUETYPE);
1164     JNI_ArgumentPusherVaArg ap(methodID, args);
1165     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1166     va_end(args);
1167     obj = jvalue.get_jobject();
1168   }
1169   return obj;
1170 JNI_END
1171 
1172 
1173 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1174   JNIWrapper(&quot;GetObjectClass&quot;);
1175 
1176   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1177 
1178   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1179   jclass ret =
1180     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1181 
1182   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1183   return ret;
1184 JNI_END
1185 
1186 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1187   JNIWrapper(&quot;IsInstanceOf&quot;);
1188 
1189   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1190 
1191   jboolean ret = JNI_TRUE;
1192   if (obj != NULL) {
1193     ret = JNI_FALSE;
1194     Klass* k = java_lang_Class::as_Klass(
1195       JNIHandles::resolve_non_null(clazz));
1196     if (k != NULL) {
1197       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1198     }
1199   }
1200 
1201   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1202   return ret;
1203 JNI_END
1204 
1205 
1206 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1207                                const char *sig, bool is_static, TRAPS) {
1208   // %%%% This code should probably just call into a method in the LinkResolver
1209   //
1210   // The class should have been loaded (we have an instance of the class
1211   // passed in) so the method and signature should already be in the symbol
1212   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1213   const char *name_to_probe = (name_str == NULL)
1214                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1215                         : name_str;
1216   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1217   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1218 
1219   if (name == NULL || signature == NULL) {
1220     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1221   }
1222 
1223   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1224 
1225   // Throw a NoSuchMethodError exception if we have an instance of a
1226   // primitive java.lang.Class
1227   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1228     ResourceMark rm;
1229     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1230   }
1231 
1232   // Make sure class is linked and initialized before handing id&#39;s out to
1233   // Method*s.
1234   klass-&gt;initialize(CHECK_NULL);
1235 
1236   Method* m;
1237   if (name == vmSymbols::object_initializer_name() ||
1238       name == vmSymbols::class_initializer_name()) {
1239     // Never search superclasses for constructors
1240     if (klass-&gt;is_instance_klass()) {
1241       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1242     } else {
1243       m = NULL;
1244     }
1245   } else {
1246     m = klass-&gt;lookup_method(name, signature);
1247     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1248       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1249     }
1250   }
1251   if (m == NULL || (m-&gt;is_static() != is_static)) {
1252     ResourceMark rm;
1253     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1254   }
1255   return m-&gt;jmethod_id();
1256 }
1257 
1258 
1259 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1260           const char *name, const char *sig))
1261   JNIWrapper(&quot;GetMethodID&quot;);
1262   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1263   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1264   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1265   return ret;
1266 JNI_END
1267 
1268 
1269 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1270           const char *name, const char *sig))
1271   JNIWrapper(&quot;GetStaticMethodID&quot;);
1272   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1273   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1274   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1275   return ret;
1276 JNI_END
1277 
1278 
1279 
1280 //
1281 // Calling Methods
1282 //
1283 
1284 
1285 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1286                           , EntryProbe, ReturnProbe)    \
1287 \
1288   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1289                           , ReturnProbe);                          \
1290 \
1291 JNI_ENTRY(ResultType, \
1292           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1293   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;Method&quot;); \
1294 \
1295   EntryProbe; \
1296   ResultType ret = 0;\
1297   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1298                      (const ResultType&amp;)ret);\
1299 \
1300   va_list args; \
1301   va_start(args, methodID); \
1302   JavaValue jvalue(Tag); \
1303   JNI_ArgumentPusherVaArg ap(methodID, args); \
1304   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1305   va_end(args); \
1306   ret = jvalue.get_##ResultType(); \
1307   return ret;\
1308 JNI_END
1309 
1310 // the runtime type of subword integral basic types is integer
1311 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1312                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1313                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1314 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1315                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1316                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1317 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1318                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1319                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1320 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1321                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1322                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1323 
1324 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1325                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1326                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1327 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1328                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1329                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1330 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1331                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1332                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1333 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1334 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1335                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1336                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1337 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1338                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1339                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1340 
1341 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1342                           , EntryProbe, ReturnProbe)    \
1343 \
1344   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1345                           , ReturnProbe);                          \
1346 \
1347 JNI_ENTRY(ResultType, \
1348           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1349   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodV&quot;); \
1350 \
1351   EntryProbe;\
1352   ResultType ret = 0;\
1353   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1354                      (const ResultType&amp;)ret);\
1355 \
1356   JavaValue jvalue(Tag); \
1357   JNI_ArgumentPusherVaArg ap(methodID, args); \
1358   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1359   ret = jvalue.get_##ResultType(); \
1360   return ret;\
1361 JNI_END
1362 
1363 // the runtime type of subword integral basic types is integer
1364 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1365                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1366                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1367 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1368                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1369                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1370 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1371                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1372                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1373 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1374                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1375                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1376 
1377 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1378                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1379                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1380 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1381                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1382                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1383 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1384                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1385                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1386 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1387 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1388                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1389                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1390 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1391                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1392                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1393 
1394 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1395                           , EntryProbe, ReturnProbe)    \
1396 \
1397   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1398                           , ReturnProbe);                          \
1399 \
1400 JNI_ENTRY(ResultType, \
1401           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1402   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodA&quot;); \
1403   EntryProbe; \
1404   ResultType ret = 0;\
1405   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1406                      (const ResultType&amp;)ret);\
1407 \
1408   JavaValue jvalue(Tag); \
1409   JNI_ArgumentPusherArray ap(methodID, args); \
1410   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1411   ret = jvalue.get_##ResultType(); \
1412   return ret;\
1413 JNI_END
1414 
1415 // the runtime type of subword integral basic types is integer
1416 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1417                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1418                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1419 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1420                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1421                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1422 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1423                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1424                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1425 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1426                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1427                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1428 
1429 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1430                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1431                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1432 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1433                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1434                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1435 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1436                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1437                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1438 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1439 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1440                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1441                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1442 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1443                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1444                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1445 
1446 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1447 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1448 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1449 
1450 
1451 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1452   JNIWrapper(&quot;CallVoidMethod&quot;);
1453   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1454   DT_VOID_RETURN_MARK(CallVoidMethod);
1455 
1456   va_list args;
1457   va_start(args, methodID);
1458   JavaValue jvalue(T_VOID);
1459   JNI_ArgumentPusherVaArg ap(methodID, args);
1460   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1461   va_end(args);
1462 JNI_END
1463 
1464 
1465 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1466   JNIWrapper(&quot;CallVoidMethodV&quot;);
1467   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1468   DT_VOID_RETURN_MARK(CallVoidMethodV);
1469 
1470   JavaValue jvalue(T_VOID);
1471   JNI_ArgumentPusherVaArg ap(methodID, args);
1472   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1473 JNI_END
1474 
1475 
1476 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1477   JNIWrapper(&quot;CallVoidMethodA&quot;);
1478   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1479   DT_VOID_RETURN_MARK(CallVoidMethodA);
1480 
1481   JavaValue jvalue(T_VOID);
1482   JNI_ArgumentPusherArray ap(methodID, args);
1483   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1484 JNI_END
1485 
1486 
1487 
1488 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1489                                     , EntryProbe, ReturnProbe)      \
1490 \
1491   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1492                           , ReturnProbe);\
1493 \
1494 JNI_ENTRY(ResultType, \
1495           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1496   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;Method&quot;); \
1497 \
1498   EntryProbe;\
1499   ResultType ret;\
1500   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1501                      (const ResultType&amp;)ret);\
1502 \
1503   va_list args; \
1504   va_start(args, methodID); \
1505   JavaValue jvalue(Tag); \
1506   JNI_ArgumentPusherVaArg ap(methodID, args); \
1507   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1508   va_end(args); \
1509   ret = jvalue.get_##ResultType(); \
1510   return ret;\
1511 JNI_END
1512 
1513 // the runtime type of subword integral basic types is integer
1514 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1515                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1516                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1517 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1518                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1519                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1520 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1521                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1522                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1523 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1524                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1525                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1526 
1527 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1528                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1529                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1530 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1531                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1532                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1533 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1534                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1535 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1536                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1537 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1538                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1539                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1540 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1541                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1542                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1543 
1544 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1545                                     , EntryProbe, ReturnProbe)      \
1546 \
1547   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1548                           , ReturnProbe);\
1549 \
1550 JNI_ENTRY(ResultType, \
1551           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1552   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodV&quot;); \
1553 \
1554   EntryProbe;\
1555   ResultType ret;\
1556   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1557                      (const ResultType&amp;)ret);\
1558 \
1559   JavaValue jvalue(Tag); \
1560   JNI_ArgumentPusherVaArg ap(methodID, args); \
1561   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1562   ret = jvalue.get_##ResultType(); \
1563   return ret;\
1564 JNI_END
1565 
1566 // the runtime type of subword integral basic types is integer
1567 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1568                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1569                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1570 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1571                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1572                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1573 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1574                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1575                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1576 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1577                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1578                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1579 
1580 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1581                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1582                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1583 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1584                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1585                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1586 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1587                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1588 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1589                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1590 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1591                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1592                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1593 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1594                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1595                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1596 
1597 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1598                                     , EntryProbe, ReturnProbe)      \
1599 \
1600   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1601                           , ReturnProbe);\
1602 \
1603 JNI_ENTRY(ResultType, \
1604           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1605   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodA&quot;); \
1606 \
1607   EntryProbe;\
1608   ResultType ret;\
1609   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1610                      (const ResultType&amp;)ret);\
1611 \
1612   JavaValue jvalue(Tag); \
1613   JNI_ArgumentPusherArray ap(methodID, args); \
1614   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1615   ret = jvalue.get_##ResultType(); \
1616   return ret;\
1617 JNI_END
1618 
1619 // the runtime type of subword integral basic types is integer
1620 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1621                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1622                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1623 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1624                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1625                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1626 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1627                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1628                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1629 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1630                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1631                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1632 
1633 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1634                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1635                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1636 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1637                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1638                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1639 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1640                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1641 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1642                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1643 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1644                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1645                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1646 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1647                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1648                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1649 
1650 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1651                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1652 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1653                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1654 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1655                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1656 
1657 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1658   JNIWrapper(&quot;CallNonvirtualVoidMethod&quot;);
1659 
1660   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1661   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1662 
1663   va_list args;
1664   va_start(args, methodID);
1665   JavaValue jvalue(T_VOID);
1666   JNI_ArgumentPusherVaArg ap(methodID, args);
1667   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1668   va_end(args);
1669 JNI_END
1670 
1671 
1672 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1673   JNIWrapper(&quot;CallNonvirtualVoidMethodV&quot;);
1674 
1675   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1676                env, obj, cls, (uintptr_t) methodID);
1677   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1678 
1679   JavaValue jvalue(T_VOID);
1680   JNI_ArgumentPusherVaArg ap(methodID, args);
1681   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1682 JNI_END
1683 
1684 
1685 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1686   JNIWrapper(&quot;CallNonvirtualVoidMethodA&quot;);
1687   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1688                 env, obj, cls, (uintptr_t) methodID);
1689   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1690   JavaValue jvalue(T_VOID);
1691   JNI_ArgumentPusherArray ap(methodID, args);
1692   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1693 JNI_END
1694 
1695 
1696 
1697 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1698                                 , EntryProbe, ResultProbe) \
1699 \
1700   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1701                           , ResultProbe);                               \
1702 \
1703 JNI_ENTRY(ResultType, \
1704           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1705   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;Method&quot;); \
1706 \
1707   EntryProbe; \
1708   ResultType ret = 0;\
1709   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1710                      (const ResultType&amp;)ret);\
1711 \
1712   va_list args; \
1713   va_start(args, methodID); \
1714   JavaValue jvalue(Tag); \
1715   JNI_ArgumentPusherVaArg ap(methodID, args); \
1716   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1717   va_end(args); \
1718   ret = jvalue.get_##ResultType(); \
1719   return ret;\
1720 JNI_END
1721 
1722 // the runtime type of subword integral basic types is integer
1723 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1724                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1725                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1726 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1727                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1728                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1729 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1730                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1731                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1732 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1733                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1734                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1735 
1736 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1737                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1738                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1739 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1740                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1741                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1742 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1743                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1744                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1745 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1746 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1747                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1748                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1749 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1750                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1751                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1752 
1753 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1754                                 , EntryProbe, ResultProbe) \
1755 \
1756   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1757                           , ResultProbe);                               \
1758 \
1759 JNI_ENTRY(ResultType, \
1760           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1761   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodV&quot;); \
1762 \
1763   EntryProbe; \
1764   ResultType ret = 0;\
1765   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1766                      (const ResultType&amp;)ret);\
1767 \
1768   JavaValue jvalue(Tag); \
1769   JNI_ArgumentPusherVaArg ap(methodID, args); \
1770   /* Make sure class is initialized before trying to invoke its method */ \
1771   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
1772   k-&gt;initialize(CHECK_0); \
1773   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1774   va_end(args); \
1775   ret = jvalue.get_##ResultType(); \
1776   return ret;\
1777 JNI_END
1778 
1779 // the runtime type of subword integral basic types is integer
1780 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1781                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1782                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1783 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1784                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1785                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1786 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1787                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1788                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1789 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1790                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1791                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1792 
1793 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1794                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1795                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1796 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1797                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1798                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1799 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1800                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1801                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1802 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1803 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1804                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1805                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1806 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1807                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1808                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1809 
1810 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1811                                 , EntryProbe, ResultProbe) \
1812 \
1813   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1814                           , ResultProbe);                               \
1815 \
1816 JNI_ENTRY(ResultType, \
1817           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1818   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodA&quot;); \
1819 \
1820   EntryProbe; \
1821   ResultType ret = 0;\
1822   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1823                      (const ResultType&amp;)ret);\
1824 \
1825   JavaValue jvalue(Tag); \
1826   JNI_ArgumentPusherArray ap(methodID, args); \
1827   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1828   ret = jvalue.get_##ResultType(); \
1829   return ret;\
1830 JNI_END
1831 
1832 // the runtime type of subword integral basic types is integer
1833 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1834                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1835                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1836 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1837                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1838                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1839 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1840                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1841                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1842 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1843                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1844                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1845 
1846 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1847                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1848                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1849 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1850                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1851                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1852 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1853                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1854                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1855 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1856 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1857                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1858                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1859 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1860                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1861                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1862 
1863 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1864                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1865 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1866                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1867 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1868                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1869 
1870 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1871   JNIWrapper(&quot;CallStaticVoidMethod&quot;);
1872   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1873   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1874 
1875   va_list args;
1876   va_start(args, methodID);
1877   JavaValue jvalue(T_VOID);
1878   JNI_ArgumentPusherVaArg ap(methodID, args);
1879   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1880   va_end(args);
1881 JNI_END
1882 
1883 
1884 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
1885   JNIWrapper(&quot;CallStaticVoidMethodV&quot;);
1886   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
1887   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
1888 
1889   JavaValue jvalue(T_VOID);
1890   JNI_ArgumentPusherVaArg ap(methodID, args);
1891   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1892 JNI_END
1893 
1894 
1895 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
1896   JNIWrapper(&quot;CallStaticVoidMethodA&quot;);
1897   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
1898   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
1899 
1900   JavaValue jvalue(T_VOID);
1901   JNI_ArgumentPusherArray ap(methodID, args);
1902   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1903 JNI_END
1904 
1905 
1906 //
1907 // Accessing Fields
1908 //
1909 
1910 
1911 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
1912                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
1913 
1914 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
1915           const char *name, const char *sig))
1916   JNIWrapper(&quot;GetFieldID&quot;);
1917   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
1918   jfieldID ret = 0;
1919   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
1920 
1921   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1922 
1923   // The class should have been loaded (we have an instance of the class
1924   // passed in) so the field and signature should already be in the symbol
1925   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1926   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1927   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1928   if (fieldname == NULL || signame == NULL) {
1929     ResourceMark rm;
1930     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1931   }
1932 
1933   // Make sure class is initialized before handing id&#39;s out to fields
1934   k-&gt;initialize(CHECK_NULL);
1935 
1936   fieldDescriptor fd;
1937   if (!k-&gt;is_instance_klass() ||
1938       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
1939     ResourceMark rm;
1940     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1941   }
1942 
1943   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1944   // It may also have hash bits for k, if VerifyJNIFields is turned on.
1945   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_inlined());
1946   return ret;
1947 JNI_END
1948 
1949 
1950 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1951   JNIWrapper(&quot;GetObjectField&quot;);
1952   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1953   oop o = JNIHandles::resolve_non_null(obj);
1954   Klass* k = o-&gt;klass();
1955   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
1956   oop res = NULL;
1957   // Keep JVMTI addition small and only check enabled flag here.
1958   // jni_GetField_probe() assumes that is okay to create handles.
1959   if (JvmtiExport::should_post_field_access()) {
1960     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
1961   }
1962   if (!jfieldIDWorkaround::is_inlined_jfieldID(fieldID)) {
1963     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
1964   } else {
1965     assert(k-&gt;is_instance_klass(), &quot;Only instance can have inlined fields&quot;);
1966     InstanceKlass* ik = InstanceKlass::cast(k);
1967     fieldDescriptor fd;
1968     ik-&gt;find_field_from_offset(offset, false, &amp;fd);  // performance bottleneck
1969     InstanceKlass* holder = fd.field_holder();
1970     ValueKlass* field_vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));
1971     res = field_vklass-&gt;read_inlined_field(o, ik-&gt;field_offset(fd.index()), CHECK_NULL);
1972   }
1973   jobject ret = JNIHandles::make_local(env, res);
1974   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
1975   return ret;
1976 JNI_END
1977 
1978 
1979 
1980 #define DEFINE_GETFIELD(Return,Fieldname,Result \
1981   , EntryProbe, ReturnProbe) \
1982 \
1983   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
1984   , ReturnProbe); \
1985 \
1986 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
1987   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
1988 \
1989   EntryProbe; \
1990   Return ret = 0;\
1991   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
1992 \
1993   oop o = JNIHandles::resolve_non_null(obj); \
1994   Klass* k = o-&gt;klass(); \
1995   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
1996   /* Keep JVMTI addition small and only check enabled flag here.       */ \
1997   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
1998   /* and creates a ResetNoHandleMark.                                   */ \
1999   if (JvmtiExport::should_post_field_access()) { \
2000     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2001   } \
2002   ret = o-&gt;Fieldname##_field(offset); \
2003   return ret; \
2004 JNI_END
2005 
2006 DEFINE_GETFIELD(jboolean, bool,   Boolean
2007                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2008                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
2009 DEFINE_GETFIELD(jbyte,    byte,   Byte
2010                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2011                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
2012 DEFINE_GETFIELD(jchar,    char,   Char
2013                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2014                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
2015 DEFINE_GETFIELD(jshort,   short,  Short
2016                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2017                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
2018 DEFINE_GETFIELD(jint,     int,    Int
2019                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2020                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
2021 DEFINE_GETFIELD(jlong,    long,   Long
2022                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2023                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
2024 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2025 DEFINE_GETFIELD(jfloat,   float,  Float
2026                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2027                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2028 DEFINE_GETFIELD(jdouble,  double, Double
2029                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2030                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2031 
2032 address jni_GetBooleanField_addr() {
2033   return (address)jni_GetBooleanField;
2034 }
2035 address jni_GetByteField_addr() {
2036   return (address)jni_GetByteField;
2037 }
2038 address jni_GetCharField_addr() {
2039   return (address)jni_GetCharField;
2040 }
2041 address jni_GetShortField_addr() {
2042   return (address)jni_GetShortField;
2043 }
2044 address jni_GetIntField_addr() {
2045   return (address)jni_GetIntField;
2046 }
2047 address jni_GetLongField_addr() {
2048   return (address)jni_GetLongField;
2049 }
2050 address jni_GetFloatField_addr() {
2051   return (address)jni_GetFloatField;
2052 }
2053 address jni_GetDoubleField_addr() {
2054   return (address)jni_GetDoubleField;
2055 }
2056 
2057 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2058   JNIWrapper(&quot;SetObjectField&quot;);
2059   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2060   oop o = JNIHandles::resolve_non_null(obj);
2061   Klass* k = o-&gt;klass();
2062   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2063   // Keep JVMTI addition small and only check enabled flag here.
2064   // jni_SetField_probe_nh() assumes that is not okay to create handles
2065   // and creates a ResetNoHandleMark.
2066   if (JvmtiExport::should_post_field_modification()) {
2067     jvalue field_value;
2068     field_value.l = value;
2069     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2070   }
2071   if (!jfieldIDWorkaround::is_inlined_jfieldID(fieldID)) {
2072     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2073   } else {
2074     assert(k-&gt;is_instance_klass(), &quot;Only instances can have inlined fields&quot;);
2075     InstanceKlass* ik = InstanceKlass::cast(k);
2076     fieldDescriptor fd;
2077     ik-&gt;find_field_from_offset(offset, false, &amp;fd);
2078     InstanceKlass* holder = fd.field_holder();
2079     ValueKlass* vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));
2080     oop v = JNIHandles::resolve_non_null(value);
2081     vklass-&gt;write_inlined_field(o, offset, v, CHECK);
2082   }
2083   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2084 JNI_END
2085 
2086 
2087 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2088                         , EntryProbe, ReturnProbe) \
2089 \
2090 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2091   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2092 \
2093   EntryProbe; \
2094 \
2095   oop o = JNIHandles::resolve_non_null(obj); \
2096   Klass* k = o-&gt;klass(); \
2097   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2098   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2099   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2100   /* and creates a ResetNoHandleMark.                                   */ \
2101   if (JvmtiExport::should_post_field_modification()) { \
2102     jvalue field_value; \
2103     field_value.unionType = value; \
2104     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2105   } \
2106   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2107   o-&gt;Fieldname##_field_put(offset, value); \
2108   ReturnProbe; \
2109 JNI_END
2110 
2111 DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2112                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2113                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2114 DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2115                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2116                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2117 DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2118                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2119                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2120 DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2121                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2122                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2123 DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2124                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2125                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2126 DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2127                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2128                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2129 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2130 DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2131                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2132                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2133 DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2134                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2135                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2136 
2137 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2138                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2139 
2140 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2141   JNIWrapper(&quot;ToReflectedField&quot;);
2142   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2143   jobject ret = NULL;
2144   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2145 
2146   fieldDescriptor fd;
2147   bool found = false;
2148   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2149 
2150   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2151 
2152   if (isStatic) {
2153     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2154     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2155     assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2156     found = id-&gt;find_local_field(&amp;fd);
2157   } else {
2158     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2159     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2160     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2161   }
2162   assert(found, &quot;bad fieldID passed into jni_ToReflectedField&quot;);
2163   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2164   ret = JNIHandles::make_local(env, reflected);
2165   return ret;
2166 JNI_END
2167 
2168 
2169 //
2170 // Accessing Static Fields
2171 //
2172 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2173                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2174 
2175 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2176           const char *name, const char *sig))
2177   JNIWrapper(&quot;GetStaticFieldID&quot;);
2178   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2179   jfieldID ret = NULL;
2180   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2181 
2182   // The class should have been loaded (we have an instance of the class
2183   // passed in) so the field and signature should already be in the symbol
2184   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2185   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2186   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2187   if (fieldname == NULL || signame == NULL) {
2188     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2189   }
2190   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2191   // Make sure class is initialized before handing id&#39;s out to static fields
2192   k-&gt;initialize(CHECK_NULL);
2193 
2194   fieldDescriptor fd;
2195   if (!k-&gt;is_instance_klass() ||
2196       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2197     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2198   }
2199 
2200   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2201   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2202   debug_only(id-&gt;set_is_static_field_id();)
2203 
2204   debug_only(id-&gt;verify(fd.field_holder()));
2205 
2206   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2207   return ret;
2208 JNI_END
2209 
2210 
2211 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2212   JNIWrapper(&quot;GetStaticObjectField&quot;);
2213   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2214 #if INCLUDE_JNI_CHECK
2215   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2216 #endif // INCLUDE_JNI_CHECK
2217   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2218   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2219   // Keep JVMTI addition small and only check enabled flag here.
2220   // jni_GetField_probe() assumes that is okay to create handles.
2221   if (JvmtiExport::should_post_field_access()) {
2222     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2223   }
2224   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2225   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2226   return ret;
2227 JNI_END
2228 
2229 
2230 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2231                               , EntryProbe, ReturnProbe) \
2232 \
2233   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2234                           , ReturnProbe);                                          \
2235 \
2236 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2237   JNIWrapper(&quot;GetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2238   EntryProbe; \
2239   Return ret = 0;\
2240   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2241                      (const Return&amp;)ret);\
2242   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2243   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2244   /* Keep JVMTI addition small and only check enabled flag here. */ \
2245   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2246   if (JvmtiExport::should_post_field_access()) { \
2247     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2248   } \
2249   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2250   return ret;\
2251 JNI_END
2252 
2253 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2254                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2255 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2256                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2257 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2258                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2259 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2260                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2261 DEFINE_GETSTATICFIELD(jint,     int,    Int
2262                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2263 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2264                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2265 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2266 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2267                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2268 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2269                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2270 
2271 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2272   JNIWrapper(&quot;SetStaticObjectField&quot;);
2273  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2274   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2275   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2276   // Keep JVMTI addition small and only check enabled flag here.
2277   // jni_SetField_probe() assumes that is okay to create handles.
2278   if (JvmtiExport::should_post_field_modification()) {
2279     jvalue field_value;
2280     field_value.l = value;
2281     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2282   }
2283   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2284   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2285 JNI_END
2286 
2287 
2288 
2289 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2290                               , EntryProbe, ReturnProbe) \
2291 \
2292 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2293   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2294   EntryProbe; \
2295 \
2296   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2297   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2298   /* Keep JVMTI addition small and only check enabled flag here. */ \
2299   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2300   if (JvmtiExport::should_post_field_modification()) { \
2301     jvalue field_value; \
2302     field_value.unionType = value; \
2303     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2304   } \
2305   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2306   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2307   ReturnProbe;\
2308 JNI_END
2309 
2310 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2311                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2312                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2313 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2314                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2315                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2316 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2317                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2318                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2319 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2320                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2321                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2322 DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2323                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2324                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2325 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2326                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2327                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2328 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2329 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2330                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2331                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2332 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2333                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2334                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2335 
2336 //
2337 // String Operations
2338 //
2339 
2340 // Unicode Interface
2341 
2342 DT_RETURN_MARK_DECL(NewString, jstring
2343                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2344 
2345 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2346   JNIWrapper(&quot;NewString&quot;);
2347  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2348   jstring ret = NULL;
2349   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2350   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2351   ret = (jstring) JNIHandles::make_local(env, string);
2352   return ret;
2353 JNI_END
2354 
2355 
2356 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2357   JNIWrapper(&quot;GetStringLength&quot;);
2358   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2359   jsize ret = 0;
2360   oop s = JNIHandles::resolve_non_null(string);
2361   ret = java_lang_String::length(s);
2362  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2363   return ret;
2364 JNI_END
2365 
2366 
2367 JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(
2368   JNIEnv *env, jstring string, jboolean *isCopy))
2369   JNIWrapper(&quot;GetStringChars&quot;);
2370  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2371   jchar* buf = NULL;
2372   oop s = JNIHandles::resolve_non_null(string);
2373   typeArrayOop s_value = java_lang_String::value(s);
2374   if (s_value != NULL) {
2375     int s_len = java_lang_String::length(s, s_value);
2376     bool is_latin1 = java_lang_String::is_latin1(s);
2377     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2378     /* JNI Specification states return NULL on OOM */
2379     if (buf != NULL) {
2380       if (s_len &gt; 0) {
2381         if (!is_latin1) {
2382           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2383                                              buf, s_len);
2384         } else {
2385           for (int i = 0; i &lt; s_len; i++) {
2386             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2387           }
2388         }
2389       }
2390       buf[s_len] = 0;
2391       //%note jni_5
2392       if (isCopy != NULL) {
2393         *isCopy = JNI_TRUE;
2394       }
2395     }
2396   }
2397   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2398   return buf;
2399 JNI_END
2400 
2401 
2402 JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2403   JNIWrapper(&quot;ReleaseStringChars&quot;);
2404   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2405   //%note jni_6
2406   if (chars != NULL) {
2407     // Since String objects are supposed to be immutable, don&#39;t copy any
2408     // new data back.  A bad user will have to go after the char array.
2409     FreeHeap((void*) chars);
2410   }
2411   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2412 JNI_END
2413 
2414 
2415 // UTF Interface
2416 
2417 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2418                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2419 
2420 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2421   JNIWrapper(&quot;NewStringUTF&quot;);
2422   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2423   jstring ret;
2424   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2425 
2426   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2427   ret = (jstring) JNIHandles::make_local(env, result);
2428   return ret;
2429 JNI_END
2430 
2431 
2432 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2433   JNIWrapper(&quot;GetStringUTFLength&quot;);
2434  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2435   oop java_string = JNIHandles::resolve_non_null(string);
2436   jsize ret = java_lang_String::utf8_length(java_string);
2437   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2438   return ret;
2439 JNI_END
2440 
2441 
2442 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2443   JNIWrapper(&quot;GetStringUTFChars&quot;);
2444  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2445   char* result = NULL;
2446   oop java_string = JNIHandles::resolve_non_null(string);
2447   typeArrayOop s_value = java_lang_String::value(java_string);
2448   if (s_value != NULL) {
2449     size_t length = java_lang_String::utf8_length(java_string, s_value);
2450     /* JNI Specification states return NULL on OOM */
2451     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2452     if (result != NULL) {
2453       java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);
2454       if (isCopy != NULL) {
2455         *isCopy = JNI_TRUE;
2456       }
2457     }
2458   }
2459  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2460   return result;
2461 JNI_END
2462 
2463 
2464 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2465   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2466  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2467   if (chars != NULL) {
2468     FreeHeap((char*) chars);
2469   }
2470 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2471 JNI_END
2472 
2473 
2474 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2475   JNIWrapper(&quot;GetArrayLength&quot;);
2476  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2477   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2478   assert(a-&gt;is_array(), &quot;must be array&quot;);
2479   jsize ret = a-&gt;length();
2480  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2481   return ret;
2482 JNI_END
2483 
2484 
2485 //
2486 // Object Array Operations
2487 //
2488 
2489 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2490                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2491 
2492 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2493   JNIWrapper(&quot;NewObjectArray&quot;);
2494  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2495   jobjectArray ret = NULL;
2496   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2497   Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
2498   Klass* ak = ek-&gt;array_klass(CHECK_NULL);
2499   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2500   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2501   oop initial_value = JNIHandles::resolve(initialElement);
2502   if (initial_value != NULL) {  // array already initialized with NULL
2503     for (int index = 0; index &lt; length; index++) {
2504       result-&gt;obj_at_put(index, initial_value);
2505     }
2506   }
2507   ret = (jobjectArray) JNIHandles::make_local(env, result);
2508   return ret;
2509 JNI_END
2510 
2511 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2512                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2513 
2514 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2515   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2516  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2517   jobject ret = NULL;
2518   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2519   oop res = NULL;
2520   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2521   if (arr-&gt;is_within_bounds(index)) {
2522     if (arr-&gt;is_valueArray()) {
2523       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
2524       arrayHandle ah(THREAD, a);
2525       valueArrayHandle vah(thread, a);
2526       res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);
2527       assert(res != NULL, &quot;Must be set in one of two paths above&quot;);
2528     } else {
2529       assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2530       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2531       res = a-&gt;obj_at(index);
2532     }
2533   } else {
2534     ResourceMark rm(THREAD);
2535     stringStream ss;
2536     ss.print(&quot;Index %d out of bounds for length %d&quot;, index,arr-&gt;length());
2537     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2538   }
2539   ret = JNIHandles::make_local(env, res);
2540   return ret;
2541 JNI_END
2542 
2543 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2544                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2545 
2546 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2547   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2548   HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2549   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2550 
2551    bool oob = false;
2552    int length = -1;
2553    oop res = NULL;
2554    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2555    if (arr-&gt;is_within_bounds(index)) {
2556      if (arr-&gt;is_valueArray()) {
2557        valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
2558        oop v = JNIHandles::resolve(value);
2559        ValueArrayKlass* vaklass = ValueArrayKlass::cast(a-&gt;klass());
2560        ValueKlass* element_vklass = vaklass-&gt;element_klass();
2561        if (v != NULL &amp;&amp; v-&gt;is_a(element_vklass)) {
2562          a-&gt;value_copy_to_index(v, index);
2563        } else {
2564          ResourceMark rm(THREAD);
2565          stringStream ss;
2566          Klass *kl = ValueArrayKlass::cast(a-&gt;klass());
2567          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2568              v-&gt;klass()-&gt;external_name(),
2569              kl-&gt;external_name(),
2570              index);
2571          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2572            ss.print(&quot;[]&quot;);
2573          }
2574          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2575        }
2576      } else {
2577        assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2578        objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2579        oop v = JNIHandles::resolve(value);
2580        if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2581          a-&gt;obj_at_put(index, v);
2582        } else {
2583          ResourceMark rm(THREAD);
2584          stringStream ss;
2585          Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2586          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2587              v-&gt;klass()-&gt;external_name(),
2588              bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),
2589                  index);
2590          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2591            ss.print(&quot;[]&quot;);
2592          }
2593          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2594        }
2595      }
2596    } else {
2597      ResourceMark rm(THREAD);
2598      stringStream ss;
2599      ss.print(&quot;Index %d out of bounds for length %d&quot;, index, arr-&gt;length());
2600      THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2601    }
2602 JNI_END
2603 
2604 
2605 
2606 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2607                               ,EntryProbe,ReturnProbe)  \
2608 \
2609   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2610                       , ReturnProbe); \
2611 \
2612 JNI_ENTRY(Return, \
2613           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2614   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2615   EntryProbe; \
2616   Return ret = NULL;\
2617   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2618 \
2619   oop obj= oopFactory::Allocator(len, CHECK_NULL); \
2620   ret = (Return) JNIHandles::make_local(env, obj); \
2621   return ret;\
2622 JNI_END
2623 
2624 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2625                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2626                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2627 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2628                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2629                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2630 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2631                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2632                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2633 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2634                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2635                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2636 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2637                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2638                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2639 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2640                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2641                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2642 DEFINE_NEWSCALARARRAY(jfloatArray,   new_floatArray,  Float,
2643                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2644                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2645 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2646                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2647                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2648 
2649 // Return an address which will fault if the caller writes to it.
2650 
2651 static char* get_bad_address() {
2652   static char* bad_address = NULL;
2653   if (bad_address == NULL) {
2654     size_t size = os::vm_allocation_granularity();
2655     bad_address = os::reserve_memory(size);
2656     if (bad_address != NULL) {
2657       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2658                          /*is_committed*/false);
2659       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2660     }
2661   }
2662   return bad_address;
2663 }
2664 
2665 
2666 
2667 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2668                                       , EntryProbe, ReturnProbe) \
2669 \
2670 JNI_ENTRY_NO_PRESERVE(ElementType*, \
2671           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2672   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2673   EntryProbe; \
2674   /* allocate an chunk of memory in c land */ \
2675   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2676   ElementType* result; \
2677   int len = a-&gt;length(); \
2678   if (len == 0) { \
2679     if (isCopy != NULL) { \
2680       *isCopy = JNI_FALSE; \
2681     } \
2682     /* Empty array: legal but useless, can&#39;t return NULL. \
2683      * Return a pointer to something useless. \
2684      * Avoid asserts in typeArrayOop. */ \
2685     result = (ElementType*)get_bad_address(); \
2686   } else { \
2687     /* JNI Specification states return NULL on OOM */                    \
2688     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2689     if (result != NULL) {                                                \
2690       /* copy the array to the c chunk */                                \
2691       ArrayAccess&lt;&gt;::arraycopy_to_native(a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), \
2692                                          result, len);                   \
2693       if (isCopy) {                                                      \
2694         *isCopy = JNI_TRUE;                                              \
2695       }                                                                  \
2696     }                                                                    \
2697   } \
2698   ReturnProbe; \
2699   return result; \
2700 JNI_END
2701 
2702 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2703                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2704                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2705 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2706                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2707                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2708 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2709                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2710                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2711 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2712                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2713                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2714 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2715                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2716                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2717 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2718                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2719                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2720 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2721 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2722                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2723                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2724 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2725                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2726                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2727 
2728 
2729 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2730                                           , EntryProbe, ReturnProbe);\
2731 \
2732 JNI_ENTRY_NO_PRESERVE(void, \
2733           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2734                                              ElementType *buf, jint mode)) \
2735   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2736   EntryProbe; \
2737   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2738   int len = a-&gt;length(); \
2739   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2740     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2741       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2742     } \
2743     if ((mode == 0) || (mode == JNI_ABORT)) { \
2744       FreeHeap(buf); \
2745     } \
2746   } \
2747   ReturnProbe; \
2748 JNI_END
2749 
2750 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2751                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2752                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2753 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2754                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2755                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2756 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2757                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2758                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2759 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2760                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2761                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2762 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2763                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2764                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2765 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2766                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2767                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2768 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2769                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2770                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2771 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2772                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2773                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2774 
2775 static void check_bounds(jsize start, jsize copy_len, jsize array_len, TRAPS) {
2776   ResourceMark rm(THREAD);
2777   if (copy_len &lt; 0) {
2778     stringStream ss;
2779     ss.print(&quot;Length %d is negative&quot;, copy_len);
2780     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2781   } else if (start &lt; 0 || (start &gt; array_len - copy_len)) {
2782     stringStream ss;
2783     ss.print(&quot;Array region %d..&quot; INT64_FORMAT &quot; out of bounds for length %d&quot;,
2784              start, (int64_t)start+(int64_t)copy_len, array_len);
2785     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2786   }
2787 }
2788 
2789 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2790                                     , EntryProbe, ReturnProbe); \
2791   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2792                            , ReturnProbe); \
2793 \
2794 JNI_ENTRY(void, \
2795 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2796              jsize len, ElementType *buf)) \
2797   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2798   EntryProbe; \
2799   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2800   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2801   check_bounds(start, len, src-&gt;length(), CHECK); \
2802   if (len &gt; 0) {    \
2803     ArrayAccess&lt;&gt;::arraycopy_to_native(src, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), buf, len); \
2804   } \
2805 JNI_END
2806 
2807 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2808                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2809                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2810 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2811                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2812                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2813 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2814                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2815                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2816 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2817                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2818                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2819 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2820                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2821                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2822 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2823                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2824                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2825 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2826                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2827                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2828 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2829                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2830                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2831 
2832 
2833 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2834                                     , EntryProbe, ReturnProbe); \
2835   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2836                            ,ReturnProbe);           \
2837 \
2838 JNI_ENTRY(void, \
2839 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2840              jsize len, const ElementType *buf)) \
2841   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2842   EntryProbe; \
2843   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2844   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2845   check_bounds(start, len, dst-&gt;length(), CHECK); \
2846   if (len &gt; 0) { \
2847     ArrayAccess&lt;&gt;::arraycopy_from_native(buf, dst, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), len); \
2848   } \
2849 JNI_END
2850 
2851 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2852                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2853                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2854 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2855                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2856                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2857 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2858                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2859                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2860 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2861                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2862                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2863 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2864                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2865                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2866 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2867                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2868                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2869 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2870                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2871                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2872 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2873                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2874                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2875 
2876 
2877 DT_RETURN_MARK_DECL(RegisterNatives, jint
2878                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2879 
2880 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2881                                     const JNINativeMethod *methods,
2882                                     jint nMethods))
2883   JNIWrapper(&quot;RegisterNatives&quot;);
2884   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2885   jint ret = 0;
2886   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2887 
2888   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2889 
2890   // There are no restrictions on native code registering native methods,
2891   // which allows agents to redefine the bindings to native methods, however
2892   // we issue a warning if any code running outside of the boot/platform
2893   // loader is rebinding any native methods in classes loaded by the
2894   // boot/platform loader that are in named modules. That will catch changes
2895   // to platform classes while excluding classes added to the bootclasspath.
2896   bool do_warning = false;
2897 
2898   // Only instanceKlasses can have native methods
2899   if (k-&gt;is_instance_klass()) {
2900     oop cl = k-&gt;class_loader();
2901     InstanceKlass* ik = InstanceKlass::cast(k);
2902     // Check for a platform class
2903     if ((cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) &amp;&amp;
2904         ik-&gt;module()-&gt;is_named()) {
2905       Klass* caller = thread-&gt;security_get_caller_class(1);
2906       // If no caller class, or caller class has a different loader, then
2907       // issue a warning below.
2908       do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;
2909     }
2910   }
2911 
2912 
2913   for (int index = 0; index &lt; nMethods; index++) {
2914     const char* meth_name = methods[index].name;
2915     const char* meth_sig = methods[index].signature;
2916     int meth_name_len = (int)strlen(meth_name);
2917 
2918     // The class should have been loaded (we have an instance of the class
2919     // passed in) so the method and signature should already be in the symbol
2920     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2921     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2922     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2923 
2924     if (name == NULL || signature == NULL) {
2925       ResourceMark rm(THREAD);
2926       stringStream st;
2927       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2928       // Must return negative value on failure
2929       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2930     }
2931 
2932     if (do_warning) {
2933       ResourceMark rm(THREAD);
2934       log_warning(jni, resolve)(&quot;Re-registering of platform native method: %s.%s%s &quot;
2935               &quot;from code in a different classloader&quot;, k-&gt;external_name(), meth_name, meth_sig);
2936     }
2937 
2938     bool res = Method::register_native(k, name, signature,
2939                                        (address) methods[index].fnPtr, THREAD);
2940     if (!res) {
2941       ret = -1;
2942       break;
2943     }
2944   }
2945   return ret;
2946 JNI_END
2947 
2948 
2949 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2950   JNIWrapper(&quot;UnregisterNatives&quot;);
2951  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2952   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2953   //%note jni_2
2954   if (k-&gt;is_instance_klass()) {
2955     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2956       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2957       if (m-&gt;is_native()) {
2958         m-&gt;clear_native_function();
2959         m-&gt;set_signature_handler(NULL);
2960       }
2961     }
2962   }
2963  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
2964   return 0;
2965 JNI_END
2966 
2967 //
2968 // Monitor functions
2969 //
2970 
2971 DT_RETURN_MARK_DECL(MonitorEnter, jint
2972                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
2973 
2974 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
2975  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
2976   jint ret = JNI_ERR;
2977   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
2978 
2979   // If the object is null, we can&#39;t do anything with it
2980   if (jobj == NULL) {
2981     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
2982   }
2983 
2984   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
2985   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
2986   ret = JNI_OK;
2987   return ret;
2988 JNI_END
2989 
2990 DT_RETURN_MARK_DECL(MonitorExit, jint
2991                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
2992 
2993 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
2994  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
2995   jint ret = JNI_ERR;
2996   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
2997 
2998   // Don&#39;t do anything with a null object
2999   if (jobj == NULL) {
3000     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3001   }
3002 
3003   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
3004   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
3005 
3006   ret = JNI_OK;
3007   return ret;
3008 JNI_END
3009 
3010 //
3011 // Extensions
3012 //
3013 
3014 DT_VOID_RETURN_MARK_DECL(GetStringRegion
3015                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
3016 
3017 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
3018   JNIWrapper(&quot;GetStringRegion&quot;);
3019  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
3020   DT_VOID_RETURN_MARK(GetStringRegion);
3021   oop s = JNIHandles::resolve_non_null(string);
3022   typeArrayOop s_value = java_lang_String::value(s);
3023   int s_len = java_lang_String::length(s, s_value);
3024   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3025     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3026   } else {
3027     if (len &gt; 0) {
3028       bool is_latin1 = java_lang_String::is_latin1(s);
3029       if (!is_latin1) {
3030         ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, typeArrayOopDesc::element_offset&lt;jchar&gt;(start),
3031                                            buf, len);
3032       } else {
3033         for (int i = 0; i &lt; len; i++) {
3034           buf[i] = ((jchar) s_value-&gt;byte_at(i + start)) &amp; 0xff;
3035         }
3036       }
3037     }
3038   }
3039 JNI_END
3040 
3041 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
3042                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
3043 
3044 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
3045   JNIWrapper(&quot;GetStringUTFRegion&quot;);
3046  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
3047   DT_VOID_RETURN_MARK(GetStringUTFRegion);
3048   oop s = JNIHandles::resolve_non_null(string);
3049   typeArrayOop s_value = java_lang_String::value(s);
3050   int s_len = java_lang_String::length(s, s_value);
3051   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3052     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3053   } else {
3054     //%note jni_7
3055     if (len &gt; 0) {
3056       // Assume the buffer is large enough as the JNI spec. does not require user error checking
3057       java_lang_String::as_utf8_string(s, s_value, start, len, buf, INT_MAX);
3058       // as_utf8_string null-terminates the result string
3059     } else {
3060       // JDK null-terminates the buffer even in len is zero
3061       if (buf != NULL) {
3062         buf[0] = 0;
3063       }
3064     }
3065   }
3066 JNI_END
3067 
3068 static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {
3069   if (Universe::heap()-&gt;supports_object_pinning()) {
3070     const oop o = JNIHandles::resolve_non_null(obj);
3071     return Universe::heap()-&gt;pin_object(thread, o);
3072   } else {
3073     GCLocker::lock_critical(thread);
3074     return JNIHandles::resolve_non_null(obj);
3075   }
3076 }
3077 
3078 static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {
3079   if (Universe::heap()-&gt;supports_object_pinning()) {
3080     const oop o = JNIHandles::resolve_non_null(obj);
3081     return Universe::heap()-&gt;unpin_object(thread, o);
3082   } else {
3083     GCLocker::unlock_critical(thread);
3084   }
3085 }
3086 
3087 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3088   JNIWrapper(&quot;GetPrimitiveArrayCritical&quot;);
3089  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3090   if (isCopy != NULL) {
3091     *isCopy = JNI_FALSE;
3092   }
3093   oop a = lock_gc_or_pin_object(thread, array);
3094   assert(a-&gt;is_array(), &quot;just checking&quot;);
3095   BasicType type;
3096   if (a-&gt;is_objArray()) {
3097     type = T_OBJECT;
3098   } else {
3099     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3100   }
3101   void* ret = arrayOop(a)-&gt;base(type);
3102  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3103   return ret;
3104 JNI_END
3105 
3106 
3107 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3108   JNIWrapper(&quot;ReleasePrimitiveArrayCritical&quot;);
3109   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3110   unlock_gc_or_unpin_object(thread, array);
3111 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3112 JNI_END
3113 
3114 
3115 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3116   JNIWrapper(&quot;GetStringCritical&quot;);
3117   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3118   oop s = lock_gc_or_pin_object(thread, string);
3119   typeArrayOop s_value = java_lang_String::value(s);
3120   bool is_latin1 = java_lang_String::is_latin1(s);
3121   if (isCopy != NULL) {
3122     *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;
3123   }
3124   jchar* ret;
3125   if (!is_latin1) {
3126     ret = (jchar*) s_value-&gt;base(T_CHAR);
3127   } else {
3128     // Inflate latin1 encoded string to UTF16
3129     int s_len = java_lang_String::length(s, s_value);
3130     ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
3131     /* JNI Specification states return NULL on OOM */
3132     if (ret != NULL) {
3133       for (int i = 0; i &lt; s_len; i++) {
3134         ret[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
3135       }
3136       ret[s_len] = 0;
3137     }
3138   }
3139  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3140   return ret;
3141 JNI_END
3142 
3143 
3144 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3145   JNIWrapper(&quot;ReleaseStringCritical&quot;);
3146   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3147   // The str and chars arguments are ignored for UTF16 strings
3148   oop s = JNIHandles::resolve_non_null(str);
3149   bool is_latin1 = java_lang_String::is_latin1(s);
3150   if (is_latin1) {
3151     // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
3152     // This assumes that ReleaseStringCritical bookends GetStringCritical.
3153     FREE_C_HEAP_ARRAY(jchar, chars);
3154   }
3155   unlock_gc_or_unpin_object(thread, str);
3156 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3157 JNI_END
3158 
3159 
3160 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3161   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3162  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3163   Handle ref_handle(thread, JNIHandles::resolve(ref));
3164   jweak ret = JNIHandles::make_weak_global(ref_handle);
3165  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3166   return ret;
3167 JNI_END
3168 
3169 // Must be JNI_ENTRY (with HandleMark)
3170 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3171   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3172   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3173   JNIHandles::destroy_weak_global(ref);
3174   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3175 JNI_END
3176 
3177 
3178 JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv *env))
3179   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3180  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3181   jni_check_async_exceptions(thread);
3182   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3183  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3184   return ret;
3185 JNI_END
3186 
3187 
3188 // Initialization state for three routines below relating to
3189 // java.nio.DirectBuffers
3190 static          int directBufferSupportInitializeStarted = 0;
3191 static volatile int directBufferSupportInitializeEnded   = 0;
3192 static volatile int directBufferSupportInitializeFailed  = 0;
3193 static jclass    bufferClass                 = NULL;
3194 static jclass    directBufferClass           = NULL;
3195 static jclass    directByteBufferClass       = NULL;
3196 static jmethodID directByteBufferConstructor = NULL;
3197 static jfieldID  directBufferAddressField    = NULL;
3198 static jfieldID  bufferCapacityField         = NULL;
3199 
3200 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3201   Handle loader;            // null (bootstrap) loader
3202   Handle protection_domain; // null protection domain
3203 
3204   TempNewSymbol sym = SymbolTable::new_symbol(name);
3205   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3206 
3207   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3208     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3209   }
3210   return result;
3211 }
3212 
3213 // These lookups are done with the NULL (bootstrap) ClassLoader to
3214 // circumvent any security checks that would be done by jni_FindClass.
3215 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3216 {
3217   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3218   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3219   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3220   return true;
3221 }
3222 JNI_END
3223 
3224 
3225 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3226   if (directBufferSupportInitializeFailed) {
3227     return false;
3228   }
3229 
3230   if (Atomic::cmpxchg(&amp;directBufferSupportInitializeStarted, 0, 1) == 0) {
3231     if (!lookupDirectBufferClasses(env)) {
3232       directBufferSupportInitializeFailed = 1;
3233       return false;
3234     }
3235 
3236     // Make global references for these
3237     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3238     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3239     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3240 
3241     // Get needed field and method IDs
3242     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3243     if (env-&gt;ExceptionCheck()) {
3244       env-&gt;ExceptionClear();
3245       directBufferSupportInitializeFailed = 1;
3246       return false;
3247     }
3248     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3249     if (env-&gt;ExceptionCheck()) {
3250       env-&gt;ExceptionClear();
3251       directBufferSupportInitializeFailed = 1;
3252       return false;
3253     }
3254     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, &quot;capacity&quot;, &quot;I&quot;);
3255     if (env-&gt;ExceptionCheck()) {
3256       env-&gt;ExceptionClear();
3257       directBufferSupportInitializeFailed = 1;
3258       return false;
3259     }
3260 
3261     if ((directByteBufferConstructor == NULL) ||
3262         (directBufferAddressField    == NULL) ||
3263         (bufferCapacityField         == NULL)) {
3264       directBufferSupportInitializeFailed = 1;
3265       return false;
3266     }
3267 
3268     directBufferSupportInitializeEnded = 1;
3269   } else {
3270     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3271       os::naked_yield();
3272     }
3273   }
3274 
3275   return !directBufferSupportInitializeFailed;
3276 }
3277 
3278 extern &quot;C&quot; jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3279 {
3280   // thread_from_jni_environment() will block if VM is gone.
3281   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3282 
3283   JNIWrapper(&quot;jni_NewDirectByteBuffer&quot;);
3284  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3285 
3286   if (!directBufferSupportInitializeEnded) {
3287     if (!initializeDirectBufferSupport(env, thread)) {
3288       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3289       return NULL;
3290     }
3291   }
3292 
3293   // Being paranoid about accidental sign extension on address
3294   jlong addr = (jlong) ((uintptr_t) address);
3295   // NOTE that package-private DirectByteBuffer constructor currently
3296   // takes int capacity
3297   jint  cap  = (jint)  capacity;
3298   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3299   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3300   return ret;
3301 }
3302 
3303 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3304                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3305 
3306 extern &quot;C&quot; void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3307 {
3308   // thread_from_jni_environment() will block if VM is gone.
3309   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3310 
3311   JNIWrapper(&quot;jni_GetDirectBufferAddress&quot;);
3312   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3313   void* ret = NULL;
3314   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3315 
3316   if (!directBufferSupportInitializeEnded) {
3317     if (!initializeDirectBufferSupport(env, thread)) {
3318       return 0;
3319     }
3320   }
3321 
3322   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3323     return 0;
3324   }
3325 
3326   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3327   return ret;
3328 }
3329 
3330 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3331                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3332 
3333 extern &quot;C&quot; jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3334 {
3335   // thread_from_jni_environment() will block if VM is gone.
3336   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3337 
3338   JNIWrapper(&quot;jni_GetDirectBufferCapacity&quot;);
3339   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3340   jlong ret = -1;
3341   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3342 
3343   if (!directBufferSupportInitializeEnded) {
3344     if (!initializeDirectBufferSupport(env, thread)) {
3345       ret = 0;
3346       return ret;
3347     }
3348   }
3349 
3350   if (buf == NULL) {
3351     return -1;
3352   }
3353 
3354   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3355     return -1;
3356   }
3357 
3358   // NOTE that capacity is currently an int in the implementation
3359   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3360   return ret;
3361 }
3362 
3363 
3364 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3365   JNIWrapper(&quot;GetVersion&quot;);
3366   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3367   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3368   return CurrentVersion;
3369 JNI_END
3370 
3371 extern struct JavaVM_ main_vm;
3372 
3373 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3374   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3375   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3376   *vm  = (JavaVM *)(&amp;main_vm);
3377   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3378   return JNI_OK;
3379 JNI_END
3380 
3381 
3382 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3383   JNIWrapper(&quot;GetModule&quot;);
3384   return Modules::get_module(clazz, THREAD);
3385 JNI_END
3386 
3387 
3388 JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))
3389   JNIWrapper(&quot;jni_GetFlattenedArrayElements&quot;);
3390   if (isCopy != NULL) {
3391     *isCopy = JNI_FALSE;
3392   }
3393   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3394   if (!ar-&gt;is_array()) {
3395     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3396   }
3397   if (!ar-&gt;is_valueArray()) {
3398     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3399   }
3400   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3401   if (vak-&gt;contains_oops()) {
3402     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Flattened array contains oops&quot;);
3403   }
3404   oop a = lock_gc_or_pin_object(thread, array);
3405   valueArrayOop vap = valueArrayOop(a);
3406   void* ret = vap-&gt;value_at_addr(0, vak-&gt;layout_helper());
3407   return ret;
3408 JNI_END
3409 
3410 JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
3411   JNIWrapper(&quot;jni_ReleaseFlattenedArrayElements&quot;);
3412   unlock_gc_or_unpin_object(thread, array);
3413 JNI_END
3414 
3415 JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {
3416   JNIWrapper(&quot;jni_GetFlattenedElementSize&quot;);
3417   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3418   if (!a-&gt;is_array()) {
3419     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3420   }
3421   if (!a-&gt;is_valueArray()) {
3422     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3423   }
3424   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());
3425   jsize ret = vak-&gt;element_byte_size();
3426   return ret;
3427 }
3428 JNI_END
3429 
3430 JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))
3431   JNIWrapper(&quot;jni_GetArrayElementClass&quot;);
3432   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3433   if (!a-&gt;is_array()) {
3434     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3435   }
3436   if (!a-&gt;is_valueArray()) {
3437     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3438   }
3439   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());
3440   ValueKlass* vk = vak-&gt;element_klass();
3441   return (jclass) JNIHandles::make_local(vk-&gt;java_mirror());
3442 JNI_END
3443 
3444 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* is_inlined))
3445   JNIWrapper(&quot;jni_GetFieldOffsetInFlattenedLayout&quot;);
3446 
3447   oop mirror = JNIHandles::resolve_non_null(clazz);
3448   Klass* k = java_lang_Class::as_Klass(mirror);
3449   if (!k-&gt;is_inline_klass()) {
3450     ResourceMark rm;
3451         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s has not flattened layout&quot;, k-&gt;external_name()));
3452   }
3453   ValueKlass* vk = ValueKlass::cast(k);
3454 
3455   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
3456   TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));
3457   if (fieldname == NULL || signame == NULL) {
3458     ResourceMark rm;
3459     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3460   }
3461 
3462   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);
3463 
3464   fieldDescriptor fd;
3465   if (!vk-&gt;is_instance_klass() ||
3466       !InstanceKlass::cast(vk)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
3467     ResourceMark rm;
3468     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3469   }
3470 
3471   int offset = fd.offset() - vk-&gt;first_field_offset();
3472   if (is_inlined != NULL) {
3473     *is_inlined = fd.is_inlined();
3474   }
3475   return (jsize)offset;
3476 JNI_END
3477 
3478 JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))
3479   JNIWrapper(&quot;jni_CreateSubElementSelector&quot;);
3480 
3481   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3482   if (!ar-&gt;is_array()) {
3483     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3484   }
3485   if (!ar-&gt;is_valueArray()) {
3486     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3487   }
3488   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),
3489         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);
3490   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);
3491   ses_ik-&gt;initialize(CHECK_NULL);
3492   Klass* elementKlass = ArrayKlass::cast(ar-&gt;klass())-&gt;element_klass();
3493   oop ses = ses_ik-&gt;allocate_instance(CHECK_NULL);
3494   Handle ses_h(THREAD, ses);
3495   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass-&gt;java_mirror());
3496   jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass-&gt;java_mirror());
3497   jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);
3498   jdk_internal_vm_jni_SubElementSelector::setIsInlined(ses_h(), true);   // by definition, top element of a flattened array is inlined
3499   jdk_internal_vm_jni_SubElementSelector::setIsInlineType(ses_h(), true); // by definition, top element of a flattened array is an inline type
3500   return JNIHandles::make_local(ses_h());
3501 JNI_END
3502 
3503 JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))
3504   JNIWrapper(&quot;jni_GetSubElementSelector&quot;);
3505 
3506   oop slct = JNIHandles::resolve_non_null(selector);
3507   if (slct-&gt;klass()-&gt;name() != vmSymbols::jdk_internal_vm_jni_SubElementSelector()) {
3508     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a SubElementSelector&quot;);
3509   }
3510   jboolean is_inlined = jdk_internal_vm_jni_SubElementSelector::getIsInlined(slct);
3511   if (!is_inlined) {
3512     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;SubElement is not inlined&quot;);
3513   }
3514   oop semirror = jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct);
3515   Klass* k = java_lang_Class::as_Klass(semirror);
3516   if (!k-&gt;is_inline_klass()) {
3517     ResourceMark rm;
3518         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s is not an inline type&quot;, k-&gt;external_name()));
3519   }
3520   ValueKlass* vk = ValueKlass::cast(k);
3521   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);
3522   int field_offset = jfieldIDWorkaround::from_instance_jfieldID(vk, fieldID);
3523   fieldDescriptor fd;
3524   if (!vk-&gt;find_field_from_offset(field_offset, false, &amp;fd)) {
3525     THROW_NULL(vmSymbols::java_lang_NoSuchFieldError());
3526   }
3527   Handle arrayElementMirror(THREAD, jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct));
3528   // offset of the SubElement is offset of the original SubElement plus the offset of the field inside the element
3529   int offset = fd.offset() - vk-&gt;first_field_offset() + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3530   InstanceKlass* sesklass = InstanceKlass::cast(JNIHandles::resolve_non_null(selector)-&gt;klass());
3531   oop res = sesklass-&gt;allocate_instance(CHECK_NULL);
3532   Handle res_h(THREAD, res);
3533   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());
3534   InstanceKlass* holder = fd.field_holder();
3535   BasicType bt = Signature::basic_type(fd.signature());
3536   if (is_java_primitive(bt)) {
3537     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));
3538   } else {
3539     Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder-&gt;class_loader()),
3540         Handle(THREAD, holder-&gt;protection_domain()), true, CHECK_NULL);
3541     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass-&gt;java_mirror());
3542   }
3543   jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);
3544   jdk_internal_vm_jni_SubElementSelector::setIsInlined(res_h(), fd.is_inlined());
3545   jdk_internal_vm_jni_SubElementSelector::setIsInlineType(res_h(), fd.is_inline_type());
3546   return JNIHandles::make_local(res_h());
3547 JNI_END
3548 
3549 JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
3550   JNIWrapper(&quot;jni_GetObjectSubElement&quot;);
3551 
3552   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3553   oop slct = JNIHandles::resolve_non_null(selector);
3554   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3555   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3556     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3557   }
3558   oop res = NULL;
3559   if (!jdk_internal_vm_jni_SubElementSelector::getIsInlined(slct)) {
3560     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3561                       + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3562     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(ar, offset);
3563   } else {
3564     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3565     res = fieldKlass-&gt;allocate_instance(CHECK_NULL);
3566     // The array might have been moved by the GC, refreshing the arrayOop
3567     ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3568     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3569               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3570     fieldKlass-&gt;value_copy_payload_to_new_oop(addr, res);
3571   }
3572   return JNIHandles::make_local(res);
3573 JNI_END
3574 
3575 JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
3576   JNIWrapper(&quot;jni_SetObjectSubElement&quot;);
3577 
3578   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3579   oop slct = JNIHandles::resolve_non_null(selector);
3580   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3581   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3582     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3583   }
3584   oop val = JNIHandles::resolve(value);
3585   if (val == NULL) {
3586     if (jdk_internal_vm_jni_SubElementSelector::getIsInlineType(slct)) {
3587       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;null cannot be stored in a flattened array&quot;);
3588     }
3589   } else {
3590     if (!val-&gt;is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {
3591       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;type mismatch&quot;);
3592     }
3593   }
3594   if (!jdk_internal_vm_jni_SubElementSelector::getIsInlined(slct)) {
3595     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3596                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3597     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(ar, offset, JNIHandles::resolve(value));
3598   } else {
3599     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3600     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3601                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3602     fieldKlass-&gt;value_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);
3603   }
3604 JNI_END
3605 
3606 #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \
3607 \
3608 JNI_ENTRY(ElementType, \
3609           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \
3610   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
3611   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
3612   oop slct = JNIHandles::resolve_non_null(selector); \
3613   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \
3614   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3615     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3616   } \
3617   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3618     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3619   } \
3620   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3621                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3622   ElementType result = *(ElementType*)addr; \
3623   return result; \
3624 JNI_END
3625 
3626 DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3627 DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)
3628 DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)
3629 DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)
3630 DEFINE_GETSUBELEMENT(jint, Int,T_INT)
3631 DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)
3632 DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)
3633 DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)
3634 
3635 #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \
3636 \
3637 JNI_ENTRY(void, \
3638           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \
3639   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
3640   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
3641   oop slct = JNIHandles::resolve_non_null(selector); \
3642   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \
3643   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3644     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3645   } \
3646   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3647     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3648   } \
3649   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3650                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3651   *(ElementType*)addr = value; \
3652 JNI_END
3653 
3654 DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3655 DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)
3656 DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)
3657 DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)
3658 DEFINE_SETSUBELEMENT(jint, Int,T_INT)
3659 DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)
3660 DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)
3661 DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)
3662 
3663 // Structure containing all jni functions
3664 struct JNINativeInterface_ jni_NativeInterface = {
3665     NULL,
3666     NULL,
3667     NULL,
3668 
3669     NULL,
3670 
3671     jni_GetVersion,
3672 
3673     jni_DefineClass,
3674     jni_FindClass,
3675 
3676     jni_FromReflectedMethod,
3677     jni_FromReflectedField,
3678 
3679     jni_ToReflectedMethod,
3680 
3681     jni_GetSuperclass,
3682     jni_IsAssignableFrom,
3683 
3684     jni_ToReflectedField,
3685 
3686     jni_Throw,
3687     jni_ThrowNew,
3688     jni_ExceptionOccurred,
3689     jni_ExceptionDescribe,
3690     jni_ExceptionClear,
3691     jni_FatalError,
3692 
3693     jni_PushLocalFrame,
3694     jni_PopLocalFrame,
3695 
3696     jni_NewGlobalRef,
3697     jni_DeleteGlobalRef,
3698     jni_DeleteLocalRef,
3699     jni_IsSameObject,
3700 
3701     jni_NewLocalRef,
3702     jni_EnsureLocalCapacity,
3703 
3704     jni_AllocObject,
3705     jni_NewObject,
3706     jni_NewObjectV,
3707     jni_NewObjectA,
3708 
3709     jni_GetObjectClass,
3710     jni_IsInstanceOf,
3711 
3712     jni_GetMethodID,
3713 
3714     jni_CallObjectMethod,
3715     jni_CallObjectMethodV,
3716     jni_CallObjectMethodA,
3717     jni_CallBooleanMethod,
3718     jni_CallBooleanMethodV,
3719     jni_CallBooleanMethodA,
3720     jni_CallByteMethod,
3721     jni_CallByteMethodV,
3722     jni_CallByteMethodA,
3723     jni_CallCharMethod,
3724     jni_CallCharMethodV,
3725     jni_CallCharMethodA,
3726     jni_CallShortMethod,
3727     jni_CallShortMethodV,
3728     jni_CallShortMethodA,
3729     jni_CallIntMethod,
3730     jni_CallIntMethodV,
3731     jni_CallIntMethodA,
3732     jni_CallLongMethod,
3733     jni_CallLongMethodV,
3734     jni_CallLongMethodA,
3735     jni_CallFloatMethod,
3736     jni_CallFloatMethodV,
3737     jni_CallFloatMethodA,
3738     jni_CallDoubleMethod,
3739     jni_CallDoubleMethodV,
3740     jni_CallDoubleMethodA,
3741     jni_CallVoidMethod,
3742     jni_CallVoidMethodV,
3743     jni_CallVoidMethodA,
3744 
3745     jni_CallNonvirtualObjectMethod,
3746     jni_CallNonvirtualObjectMethodV,
3747     jni_CallNonvirtualObjectMethodA,
3748     jni_CallNonvirtualBooleanMethod,
3749     jni_CallNonvirtualBooleanMethodV,
3750     jni_CallNonvirtualBooleanMethodA,
3751     jni_CallNonvirtualByteMethod,
3752     jni_CallNonvirtualByteMethodV,
3753     jni_CallNonvirtualByteMethodA,
3754     jni_CallNonvirtualCharMethod,
3755     jni_CallNonvirtualCharMethodV,
3756     jni_CallNonvirtualCharMethodA,
3757     jni_CallNonvirtualShortMethod,
3758     jni_CallNonvirtualShortMethodV,
3759     jni_CallNonvirtualShortMethodA,
3760     jni_CallNonvirtualIntMethod,
3761     jni_CallNonvirtualIntMethodV,
3762     jni_CallNonvirtualIntMethodA,
3763     jni_CallNonvirtualLongMethod,
3764     jni_CallNonvirtualLongMethodV,
3765     jni_CallNonvirtualLongMethodA,
3766     jni_CallNonvirtualFloatMethod,
3767     jni_CallNonvirtualFloatMethodV,
3768     jni_CallNonvirtualFloatMethodA,
3769     jni_CallNonvirtualDoubleMethod,
3770     jni_CallNonvirtualDoubleMethodV,
3771     jni_CallNonvirtualDoubleMethodA,
3772     jni_CallNonvirtualVoidMethod,
3773     jni_CallNonvirtualVoidMethodV,
3774     jni_CallNonvirtualVoidMethodA,
3775 
3776     jni_GetFieldID,
3777 
3778     jni_GetObjectField,
3779     jni_GetBooleanField,
3780     jni_GetByteField,
3781     jni_GetCharField,
3782     jni_GetShortField,
3783     jni_GetIntField,
3784     jni_GetLongField,
3785     jni_GetFloatField,
3786     jni_GetDoubleField,
3787 
3788     jni_SetObjectField,
3789     jni_SetBooleanField,
3790     jni_SetByteField,
3791     jni_SetCharField,
3792     jni_SetShortField,
3793     jni_SetIntField,
3794     jni_SetLongField,
3795     jni_SetFloatField,
3796     jni_SetDoubleField,
3797 
3798     jni_GetStaticMethodID,
3799 
3800     jni_CallStaticObjectMethod,
3801     jni_CallStaticObjectMethodV,
3802     jni_CallStaticObjectMethodA,
3803     jni_CallStaticBooleanMethod,
3804     jni_CallStaticBooleanMethodV,
3805     jni_CallStaticBooleanMethodA,
3806     jni_CallStaticByteMethod,
3807     jni_CallStaticByteMethodV,
3808     jni_CallStaticByteMethodA,
3809     jni_CallStaticCharMethod,
3810     jni_CallStaticCharMethodV,
3811     jni_CallStaticCharMethodA,
3812     jni_CallStaticShortMethod,
3813     jni_CallStaticShortMethodV,
3814     jni_CallStaticShortMethodA,
3815     jni_CallStaticIntMethod,
3816     jni_CallStaticIntMethodV,
3817     jni_CallStaticIntMethodA,
3818     jni_CallStaticLongMethod,
3819     jni_CallStaticLongMethodV,
3820     jni_CallStaticLongMethodA,
3821     jni_CallStaticFloatMethod,
3822     jni_CallStaticFloatMethodV,
3823     jni_CallStaticFloatMethodA,
3824     jni_CallStaticDoubleMethod,
3825     jni_CallStaticDoubleMethodV,
3826     jni_CallStaticDoubleMethodA,
3827     jni_CallStaticVoidMethod,
3828     jni_CallStaticVoidMethodV,
3829     jni_CallStaticVoidMethodA,
3830 
3831     jni_GetStaticFieldID,
3832 
3833     jni_GetStaticObjectField,
3834     jni_GetStaticBooleanField,
3835     jni_GetStaticByteField,
3836     jni_GetStaticCharField,
3837     jni_GetStaticShortField,
3838     jni_GetStaticIntField,
3839     jni_GetStaticLongField,
3840     jni_GetStaticFloatField,
3841     jni_GetStaticDoubleField,
3842 
3843     jni_SetStaticObjectField,
3844     jni_SetStaticBooleanField,
3845     jni_SetStaticByteField,
3846     jni_SetStaticCharField,
3847     jni_SetStaticShortField,
3848     jni_SetStaticIntField,
3849     jni_SetStaticLongField,
3850     jni_SetStaticFloatField,
3851     jni_SetStaticDoubleField,
3852 
3853     jni_NewString,
3854     jni_GetStringLength,
3855     jni_GetStringChars,
3856     jni_ReleaseStringChars,
3857 
3858     jni_NewStringUTF,
3859     jni_GetStringUTFLength,
3860     jni_GetStringUTFChars,
3861     jni_ReleaseStringUTFChars,
3862 
3863     jni_GetArrayLength,
3864 
3865     jni_NewObjectArray,
3866     jni_GetObjectArrayElement,
3867     jni_SetObjectArrayElement,
3868 
3869     jni_NewBooleanArray,
3870     jni_NewByteArray,
3871     jni_NewCharArray,
3872     jni_NewShortArray,
3873     jni_NewIntArray,
3874     jni_NewLongArray,
3875     jni_NewFloatArray,
3876     jni_NewDoubleArray,
3877 
3878     jni_GetBooleanArrayElements,
3879     jni_GetByteArrayElements,
3880     jni_GetCharArrayElements,
3881     jni_GetShortArrayElements,
3882     jni_GetIntArrayElements,
3883     jni_GetLongArrayElements,
3884     jni_GetFloatArrayElements,
3885     jni_GetDoubleArrayElements,
3886 
3887     jni_ReleaseBooleanArrayElements,
3888     jni_ReleaseByteArrayElements,
3889     jni_ReleaseCharArrayElements,
3890     jni_ReleaseShortArrayElements,
3891     jni_ReleaseIntArrayElements,
3892     jni_ReleaseLongArrayElements,
3893     jni_ReleaseFloatArrayElements,
3894     jni_ReleaseDoubleArrayElements,
3895 
3896     jni_GetBooleanArrayRegion,
3897     jni_GetByteArrayRegion,
3898     jni_GetCharArrayRegion,
3899     jni_GetShortArrayRegion,
3900     jni_GetIntArrayRegion,
3901     jni_GetLongArrayRegion,
3902     jni_GetFloatArrayRegion,
3903     jni_GetDoubleArrayRegion,
3904 
3905     jni_SetBooleanArrayRegion,
3906     jni_SetByteArrayRegion,
3907     jni_SetCharArrayRegion,
3908     jni_SetShortArrayRegion,
3909     jni_SetIntArrayRegion,
3910     jni_SetLongArrayRegion,
3911     jni_SetFloatArrayRegion,
3912     jni_SetDoubleArrayRegion,
3913 
3914     jni_RegisterNatives,
3915     jni_UnregisterNatives,
3916 
3917     jni_MonitorEnter,
3918     jni_MonitorExit,
3919 
3920     jni_GetJavaVM,
3921 
3922     jni_GetStringRegion,
3923     jni_GetStringUTFRegion,
3924 
3925     jni_GetPrimitiveArrayCritical,
3926     jni_ReleasePrimitiveArrayCritical,
3927 
3928     jni_GetStringCritical,
3929     jni_ReleaseStringCritical,
3930 
3931     jni_NewWeakGlobalRef,
3932     jni_DeleteWeakGlobalRef,
3933 
3934     jni_ExceptionCheck,
3935 
3936     jni_NewDirectByteBuffer,
3937     jni_GetDirectBufferAddress,
3938     jni_GetDirectBufferCapacity,
3939 
3940     // New 1_6 features
3941 
3942     jni_GetObjectRefType,
3943 
3944     // Module features
3945 
3946     jni_GetModule,
3947 
3948     // Flattened arrays features
3949 
3950     jni_GetFlattenedArrayElements,
3951     jni_ReleaseFlattenedArrayElements,
3952     jni_GetFlattenedArrayElementClass,
3953     jni_GetFlattenedArrayElementSize,
3954     jni_GetFieldOffsetInFlattenedLayout,
3955 
3956     jni_CreateSubElementSelector,
3957     jni_GetSubElementSelector,
3958     jni_GetObjectSubElement,
3959     jni_SetObjectSubElement,
3960 
3961     jni_GetBooleanSubElement,
3962     jni_GetByteSubElement,
3963     jni_GetShortSubElement,
3964     jni_GetCharSubElement,
3965     jni_GetIntSubElement,
3966     jni_GetLongSubElement,
3967     jni_GetFloatSubElement,
3968     jni_GetDoubleSubElement,
3969 
3970     jni_SetBooleanSubElement,
3971     jni_SetByteSubElement,
3972     jni_SetShortSubElement,
3973     jni_SetCharSubElement,
3974     jni_SetIntSubElement,
3975     jni_SetLongSubElement,
3976     jni_SetFloatSubElement,
3977     jni_SetDoubleSubElement
3978 };
3979 
3980 
3981 // For jvmti use to modify jni function table.
3982 // Java threads in native contiues to run until it is transitioned
3983 // to VM at safepoint. Before the transition or before it is blocked
3984 // for safepoint it may access jni function table. VM could crash if
3985 // any java thread access the jni function table in the middle of memcpy.
3986 // To avoid this each function pointers are copied automically.
3987 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3988   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3989   intptr_t *a = (intptr_t *) jni_functions();
3990   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3991   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3992     Atomic::store(a++, *b++);
3993   }
3994 }
3995 
3996 void quicken_jni_functions() {
3997   // Replace Get&lt;Primitive&gt;Field with fast versions
3998   if (UseFastJNIAccessors &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {
3999     address func;
4000     func = JNI_FastGetField::generate_fast_get_boolean_field();
4001     if (func != (address)-1) {
4002       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
4003     }
4004     func = JNI_FastGetField::generate_fast_get_byte_field();
4005     if (func != (address)-1) {
4006       jni_NativeInterface.GetByteField = (GetByteField_t)func;
4007     }
4008     func = JNI_FastGetField::generate_fast_get_char_field();
4009     if (func != (address)-1) {
4010       jni_NativeInterface.GetCharField = (GetCharField_t)func;
4011     }
4012     func = JNI_FastGetField::generate_fast_get_short_field();
4013     if (func != (address)-1) {
4014       jni_NativeInterface.GetShortField = (GetShortField_t)func;
4015     }
4016     func = JNI_FastGetField::generate_fast_get_int_field();
4017     if (func != (address)-1) {
4018       jni_NativeInterface.GetIntField = (GetIntField_t)func;
4019     }
4020     func = JNI_FastGetField::generate_fast_get_long_field();
4021     if (func != (address)-1) {
4022       jni_NativeInterface.GetLongField = (GetLongField_t)func;
4023     }
4024     func = JNI_FastGetField::generate_fast_get_float_field();
4025     if (func != (address)-1) {
4026       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
4027     }
4028     func = JNI_FastGetField::generate_fast_get_double_field();
4029     if (func != (address)-1) {
4030       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
4031     }
4032   }
4033 }
4034 
4035 // Returns the function structure
4036 struct JNINativeInterface_* jni_functions() {
4037 #if INCLUDE_JNI_CHECK
4038   if (CheckJNICalls) return jni_functions_check();
4039 #endif // INCLUDE_JNI_CHECK
4040   return &amp;jni_NativeInterface;
4041 }
4042 
4043 // Returns the function structure
4044 struct JNINativeInterface_* jni_functions_nocheck() {
4045   return &amp;jni_NativeInterface;
4046 }
4047 
4048 static void post_thread_start_event(const JavaThread* jt) {
4049   assert(jt != NULL, &quot;invariant&quot;);
4050   EventThreadStart event;
4051   if (event.should_commit()) {
4052     event.set_thread(JFR_THREAD_ID(jt));
4053     event.set_parentThread((traceid)0);
4054 #if INCLUDE_JFR
4055     if (EventThreadStart::is_stacktrace_enabled()) {
4056       jt-&gt;jfr_thread_local()-&gt;set_cached_stack_trace_id((traceid)0);
4057       event.commit();
4058       jt-&gt;jfr_thread_local()-&gt;clear_cached_stack_trace();
4059     } else
4060 #endif
4061     {
4062       event.commit();
4063     }
4064   }
4065 }
4066 
4067 // Invocation API
4068 
4069 
4070 // Forward declaration
4071 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
4072 
4073 // Global invocation API vars
4074 volatile int vm_created = 0;
4075 // Indicate whether it is safe to recreate VM. Recreation is only
4076 // possible after a failed initial creation attempt in some cases.
4077 volatile int safe_to_recreate_vm = 1;
4078 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
4079 
4080 
4081 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
4082 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
4083 
4084 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
4085                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
4086 
4087 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
4088   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
4089   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
4090   jint ret = JNI_ERR;
4091   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
4092 
4093   if (Threads::is_supported_jni_version(args-&gt;version)) {
4094     ret = JNI_OK;
4095   }
4096   // 1.1 style no longer supported in hotspot.
4097   // According the JNI spec, we should update args-&gt;version on return.
4098   // We also use the structure to communicate with launcher about default
4099   // stack size.
4100   if (args-&gt;version == JNI_VERSION_1_1) {
4101     args-&gt;version = JNI_VERSION_1_2;
4102     // javaStackSize is int in arguments structure
4103     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, &quot;integer overflow&quot;);
4104     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
4105   }
4106   return ret;
4107 }
4108 
4109 DT_RETURN_MARK_DECL(CreateJavaVM, jint
4110                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
4111 
4112 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
4113   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
4114 
4115   jint result = JNI_ERR;
4116   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
4117 
4118   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
4119   // platforms use the GCC builtin __sync_lock_test_and_set for this,
4120   // but __sync_lock_test_and_set is not guaranteed to do what we want
4121   // on all architectures.  So we check it works before relying on it.
4122 #if defined(ZERO) &amp;&amp; defined(ASSERT)
4123   {
4124     jint a = 0xcafebabe;
4125     jint b = Atomic::xchg(&amp;a, (jint) 0xdeadbeef);
4126     void *c = &amp;a;
4127     void *d = Atomic::xchg(&amp;c, &amp;b);
4128     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
4129     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
4130   }
4131 #endif // ZERO &amp;&amp; ASSERT
4132 
4133   // At the moment it&#39;s only possible to have one Java VM,
4134   // since some of the runtime state is in global variables.
4135 
4136   // We cannot use our mutex locks here, since they only work on
4137   // Threads. We do an atomic compare and exchange to ensure only
4138   // one thread can call this method at a time
4139 
4140   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
4141   // the add/dec implementations are dependent on whether we are running
4142   // on a multiprocessor Atomic::xchg does not have this problem.
4143   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
4144     return JNI_EEXIST;   // already created, or create attempt in progress
4145   }
4146 
4147   // If a previous creation attempt failed but can be retried safely,
4148   // then safe_to_recreate_vm will have been reset to 1 after being
4149   // cleared here. If a previous creation attempt succeeded and we then
4150   // destroyed that VM, we will be prevented from trying to recreate
4151   // the VM in the same process, as the value will still be 0.
4152   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
4153     return JNI_ERR;
4154   }
4155 
4156   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
4157 
4158   /**
4159    * Certain errors during initialization are recoverable and do not
4160    * prevent this method from being called again at a later time
4161    * (perhaps with different arguments).  However, at a certain
4162    * point during initialization if an error occurs we cannot allow
4163    * this function to be called again (or it will crash).  In those
4164    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
4165    * sets safe_to_recreate_vm to 1, such that any new call to
4166    * JNI_CreateJavaVM will immediately fail using the above logic.
4167    */
4168   bool can_try_again = true;
4169 
4170   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
4171   if (result == JNI_OK) {
4172     JavaThread *thread = JavaThread::current();
4173     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
4174     /* thread is thread_in_vm here */
4175     *vm = (JavaVM *)(&amp;main_vm);
4176     *(JNIEnv**)penv = thread-&gt;jni_environment();
4177 
4178 #if INCLUDE_JVMCI
4179     if (EnableJVMCI) {
4180       if (UseJVMCICompiler) {
4181         // JVMCI is initialized on a CompilerThread
4182         if (BootstrapJVMCI) {
4183           JavaThread* THREAD = thread;
4184           JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
4185           compiler-&gt;bootstrap(THREAD);
4186           if (HAS_PENDING_EXCEPTION) {
4187             HandleMark hm;
4188             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4189           }
4190         }
4191       }
4192     }
4193 #endif
4194 
4195     // Notify JVMTI
4196     if (JvmtiExport::should_post_thread_life()) {
4197        JvmtiExport::post_thread_start(thread);
4198     }
4199 
4200     post_thread_start_event(thread);
4201 
4202 #ifndef PRODUCT
4203     if (ReplayCompiles) ciReplay::replay(thread);
4204 
4205     // Some platforms (like Win*) need a wrapper around these test
4206     // functions in order to properly handle error conditions.
4207     VMError::test_error_handler();
4208 #endif
4209 
4210     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
4211     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4212   } else {
4213     // If create_vm exits because of a pending exception, exit with that
4214     // exception.  In the future when we figure out how to reclaim memory,
4215     // we may be able to exit with JNI_ERR and allow the calling application
4216     // to continue.
4217     if (Universe::is_fully_initialized()) {
4218       // otherwise no pending exception possible - VM will already have aborted
4219       JavaThread* THREAD = JavaThread::current();
4220       if (HAS_PENDING_EXCEPTION) {
4221         HandleMark hm;
4222         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4223       }
4224     }
4225 
4226     if (can_try_again) {
4227       // reset safe_to_recreate_vm to 1 so that retrial would be possible
4228       safe_to_recreate_vm = 1;
4229     }
4230 
4231     // Creation failed. We must reset vm_created
4232     *vm = 0;
4233     *(JNIEnv**)penv = 0;
4234     // reset vm_created last to avoid race condition. Use OrderAccess to
4235     // control both compiler and architectural-based reordering.
4236     Atomic::release_store(&amp;vm_created, 0);
4237   }
4238 
4239   // Flush stdout and stderr before exit.
4240   fflush(stdout);
4241   fflush(stderr);
4242 
4243   return result;
4244 
4245 }
4246 
4247 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
4248   jint result = JNI_ERR;
4249   // On Windows, let CreateJavaVM run with SEH protection
4250 #ifdef _WIN32
4251   __try {
4252 #endif
4253     result = JNI_CreateJavaVM_inner(vm, penv, args);
4254 #ifdef _WIN32
4255   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4256     // Nothing to do.
4257   }
4258 #endif
4259   return result;
4260 }
4261 
4262 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
4263   // See bug 4367188, the wrapper can sometimes cause VM crashes
4264   // JNIWrapper(&quot;GetCreatedJavaVMs&quot;);
4265 
4266   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
4267 
4268   if (vm_created == 1) {
4269     if (numVMs != NULL) *numVMs = 1;
4270     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
4271   } else {
4272     if (numVMs != NULL) *numVMs = 0;
4273   }
4274   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
4275   return JNI_OK;
4276 }
4277 
4278 extern &quot;C&quot; {
4279 
4280 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
4281                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
4282 
4283 static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
4284   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
4285   jint res = JNI_ERR;
4286   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
4287 
4288   if (vm_created == 0) {
4289     res = JNI_ERR;
4290     return res;
4291   }
4292 
4293   JNIWrapper(&quot;DestroyJavaVM&quot;);
4294   JNIEnv *env;
4295   JavaVMAttachArgs destroyargs;
4296   destroyargs.version = CurrentVersion;
4297   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
4298   destroyargs.group = NULL;
4299   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
4300   if (res != JNI_OK) {
4301     return res;
4302   }
4303 
4304   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
4305   JavaThread* thread = JavaThread::current();
4306   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4307   if (Threads::destroy_vm()) {
4308     // Should not change thread state, VM is gone
4309     vm_created = 0;
4310     res = JNI_OK;
4311     return res;
4312   } else {
4313     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4314     res = JNI_ERR;
4315     return res;
4316   }
4317 }
4318 
4319 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
4320   jint result = JNI_ERR;
4321   // On Windows, we need SEH protection
4322 #ifdef _WIN32
4323   __try {
4324 #endif
4325     result = jni_DestroyJavaVM_inner(vm);
4326 #ifdef _WIN32
4327   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4328     // Nothing to do.
4329   }
4330 #endif
4331   return result;
4332 }
4333 
4334 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4335   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4336 
4337   // Check below commented out from JDK1.2fcs as well
4338   /*
4339   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4340     return JNI_EVERSION;
4341   }
4342   */
4343 
4344   Thread* t = Thread::current_or_null();
4345   if (t != NULL) {
4346     // If executing from an atexit hook we may be in the VMThread.
4347     if (t-&gt;is_Java_thread()) {
4348       // If the thread has been attached this operation is a no-op
4349       *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();
4350       return JNI_OK;
4351     } else {
4352       return JNI_ERR;
4353     }
4354   }
4355 
4356   // Create a thread and mark it as attaching so it will be skipped by the
4357   // ThreadsListEnumerator - see CR 6404306
4358   JavaThread* thread = new JavaThread(true);
4359 
4360   // Set correct safepoint info. The thread is going to call into Java when
4361   // initializing the Java level thread object. Hence, the correct state must
4362   // be set in order for the Safepoint code to deal with it correctly.
4363   thread-&gt;set_thread_state(_thread_in_vm);
4364   thread-&gt;record_stack_base_and_size();
4365   thread-&gt;register_thread_stack_with_NMT();
4366   thread-&gt;initialize_thread_current();
4367 
4368   if (!os::create_attached_thread(thread)) {
4369     thread-&gt;smr_delete();
4370     return JNI_ERR;
4371   }
4372   // Enable stack overflow checks
4373   thread-&gt;create_stack_guard_pages();
4374 
4375   thread-&gt;initialize_tlab();
4376 
4377   thread-&gt;cache_global_variables();
4378 
4379   // This thread will not do a safepoint check, since it has
4380   // not been added to the Thread list yet.
4381   { MutexLocker ml(Threads_lock);
4382     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4383     // avoid this thread trying to do a GC before it is added to the thread-list
4384     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4385     Threads::add(thread, daemon);
4386   }
4387   // Create thread group and name info from attach arguments
4388   oop group = NULL;
4389   char* thread_name = NULL;
4390   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4391     group = JNIHandles::resolve(args-&gt;group);
4392     thread_name = args-&gt;name; // may be NULL
4393   }
4394   if (group == NULL) group = Universe::main_thread_group();
4395 
4396   // Create Java level thread object and attach it to this thread
4397   bool attach_failed = false;
4398   {
4399     EXCEPTION_MARK;
4400     HandleMark hm(THREAD);
4401     Handle thread_group(THREAD, group);
4402     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4403     if (HAS_PENDING_EXCEPTION) {
4404       CLEAR_PENDING_EXCEPTION;
4405       // cleanup outside the handle mark.
4406       attach_failed = true;
4407     }
4408   }
4409 
4410   if (attach_failed) {
4411     // Added missing cleanup
4412     thread-&gt;cleanup_failed_attach_current_thread(daemon);
4413     return JNI_ERR;
4414   }
4415 
4416   // mark the thread as no longer attaching
4417   // this uses a fence to push the change through so we don&#39;t have
4418   // to regrab the threads_lock
4419   thread-&gt;set_done_attaching_via_jni();
4420 
4421   // Set java thread status.
4422   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4423               java_lang_Thread::RUNNABLE);
4424 
4425   // Notify the debugger
4426   if (JvmtiExport::should_post_thread_life()) {
4427     JvmtiExport::post_thread_start(thread);
4428   }
4429 
4430   post_thread_start_event(thread);
4431 
4432   *(JNIEnv**)penv = thread-&gt;jni_environment();
4433 
4434   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4435   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4436   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4437   // needed.
4438 
4439   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4440 
4441   // Perform any platform dependent FPU setup
4442   os::setup_fpu();
4443 
4444   return JNI_OK;
4445 }
4446 
4447 
4448 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4449   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4450   if (vm_created == 0) {
4451     HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4452     return JNI_ERR;
4453   }
4454 
4455   JNIWrapper(&quot;AttachCurrentThread&quot;);
4456   jint ret = attach_current_thread(vm, penv, _args, false);
4457   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4458   return ret;
4459 }
4460 
4461 
4462 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4463   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
4464   if (vm_created == 0) {
4465     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_ERR);
4466     return JNI_ERR;
4467   }
4468 
4469   JNIWrapper(&quot;DetachCurrentThread&quot;);
4470 
4471   Thread* current = Thread::current_or_null();
4472 
4473   // If the thread has already been detached the operation is a no-op
4474   if (current == NULL) {
4475     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4476     return JNI_OK;
4477   }
4478 
4479   // If executing from an atexit hook we may be in the VMThread.
4480   if (!current-&gt;is_Java_thread()) {
4481     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4482     return JNI_ERR;
4483   }
4484 
4485   VM_Exit::block_if_vm_exited();
4486 
4487   JavaThread* thread = (JavaThread*) current;
4488   if (thread-&gt;has_last_Java_frame()) {
4489     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4490     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4491     return JNI_ERR;
4492   }
4493 
4494   // Safepoint support. Have to do call-back to safepoint code, if in the
4495   // middle of a safepoint operation
4496   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4497 
4498   // XXX: Note that JavaThread::exit() call below removes the guards on the
4499   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4500   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4501   // of the guards is visible in jni_AttachCurrentThread above,
4502   // the removal of the guards is buried below in JavaThread::exit()
4503   // here. The abstraction should be more symmetrically either exposed
4504   // or hidden (e.g. it could probably be hidden in the same
4505   // (platform-dependent) methods where we do alternate stack
4506   // maintenance work?)
4507   thread-&gt;exit(false, JavaThread::jni_detach);
4508   thread-&gt;smr_delete();
4509 
4510   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4511   return JNI_OK;
4512 }
4513 
4514 DT_RETURN_MARK_DECL(GetEnv, jint
4515                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4516 
4517 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4518   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4519   jint ret = JNI_ERR;
4520   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4521 
4522   if (vm_created == 0) {
4523     *penv = NULL;
4524     ret = JNI_EDETACHED;
4525     return ret;
4526   }
4527 
4528   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4529     return ret;
4530   }
4531 
4532 #ifndef JVMPI_VERSION_1
4533 // need these in order to be polite about older agents
4534 #define JVMPI_VERSION_1   ((jint)0x10000001)
4535 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4536 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4537 #endif // !JVMPI_VERSION_1
4538 
4539   Thread* thread = Thread::current_or_null();
4540   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4541     if (Threads::is_supported_jni_version_including_1_1(version)) {
4542       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4543       ret = JNI_OK;
4544       return ret;
4545 
4546     } else if (version == JVMPI_VERSION_1 ||
4547                version == JVMPI_VERSION_1_1 ||
4548                version == JVMPI_VERSION_1_2) {
4549       tty-&gt;print_cr(&quot;ERROR: JVMPI, an experimental interface, is no longer supported.&quot;);
4550       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4551       ret = JNI_EVERSION;
4552       return ret;
4553     } else if (JvmtiExport::is_jvmdi_version(version)) {
4554       tty-&gt;print_cr(&quot;FATAL ERROR: JVMDI is no longer supported.&quot;);
4555       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4556       ret = JNI_EVERSION;
4557       return ret;
4558     } else {
4559       *penv = NULL;
4560       ret = JNI_EVERSION;
4561       return ret;
4562     }
4563   } else {
4564     *penv = NULL;
4565     ret = JNI_EDETACHED;
4566     return ret;
4567   }
4568 }
4569 
4570 
4571 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4572   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4573   if (vm_created == 0) {
4574   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4575     return JNI_ERR;
4576   }
4577 
4578   JNIWrapper(&quot;AttachCurrentThreadAsDaemon&quot;);
4579   jint ret = attach_current_thread(vm, penv, _args, true);
4580   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4581   return ret;
4582 }
4583 
4584 
4585 } // End extern &quot;C&quot;
4586 
4587 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4588     NULL,
4589     NULL,
4590     NULL,
4591 
4592     jni_DestroyJavaVM,
4593     jni_AttachCurrentThread,
4594     jni_DetachCurrentThread,
4595     jni_GetEnv,
4596     jni_AttachCurrentThreadAsDaemon
4597 };
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
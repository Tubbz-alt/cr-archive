<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.code;
 27 
 28 import java.util.Collection;
 29 import java.util.Collections;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.LinkedHashMap;
 33 import java.util.Map;
 34 
 35 import javax.lang.model.element.ElementVisitor;
 36 
 37 import com.sun.tools.javac.code.Scope.WriteableScope;
 38 import com.sun.tools.javac.code.Source.Feature;
 39 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 40 import com.sun.tools.javac.code.Symbol.Completer;
 41 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 42 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 43 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 44 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 45 import com.sun.tools.javac.code.Symbol.RootPackageSymbol;
 46 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 47 import com.sun.tools.javac.code.Symbol.VarSymbol;
 48 import com.sun.tools.javac.code.Type.BottomType;
 49 import com.sun.tools.javac.code.Type.ClassType;
 50 import com.sun.tools.javac.code.Type.ErrorType;
 51 import com.sun.tools.javac.code.Type.JCPrimitiveType;
 52 import com.sun.tools.javac.code.Type.JCVoidType;
 53 import com.sun.tools.javac.code.Type.MethodType;
 54 import com.sun.tools.javac.code.Type.UnknownType;
 55 import com.sun.tools.javac.code.Type.WildcardType;
 56 import com.sun.tools.javac.code.Types.UniqueType;
 57 import com.sun.tools.javac.comp.Modules;
 58 import com.sun.tools.javac.jvm.Target;
 59 import com.sun.tools.javac.util.Assert;
 60 import com.sun.tools.javac.util.Context;
 61 import com.sun.tools.javac.util.Convert;
 62 import com.sun.tools.javac.util.DefinedBy;
 63 import com.sun.tools.javac.util.DefinedBy.Api;
 64 import com.sun.tools.javac.util.Iterators;
 65 import com.sun.tools.javac.util.JavacMessages;
 66 import com.sun.tools.javac.util.List;
 67 import com.sun.tools.javac.util.Name;
 68 import com.sun.tools.javac.util.Names;
 69 import com.sun.tools.javac.util.Options;
 70 
 71 import static com.sun.tools.javac.code.Flags.*;
 72 import static com.sun.tools.javac.code.Kinds.Kind.*;
 73 import static com.sun.tools.javac.code.TypeTag.*;
 74 
 75 /** A class that defines all predefined constants and operators
 76  *  as well as special classes such as java.lang.Object, which need
 77  *  to be known to the compiler. All symbols are held in instance
 78  *  fields. This makes it possible to work in multiple concurrent
 79  *  projects, which might use different class files for library classes.
 80  *
 81  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 82  *  If you write code that depends on this, you do so at your own risk.
 83  *  This code and its internal interfaces are subject to change or
 84  *  deletion without notice.&lt;/b&gt;
 85  */
 86 public class Symtab {
 87     /** The context key for the symbol table. */
 88     protected static final Context.Key&lt;Symtab&gt; symtabKey = new Context.Key&lt;&gt;();
 89 
 90     /** Get the symbol table instance. */
 91     public static Symtab instance(Context context) {
 92         Symtab instance = context.get(symtabKey);
 93         if (instance == null)
 94             instance = new Symtab(context);
 95         return instance;
 96     }
 97 
 98     /** Builtin types.
 99      */
100     public final JCPrimitiveType byteType = new JCPrimitiveType(BYTE, null);
101     public final JCPrimitiveType charType = new JCPrimitiveType(CHAR, null);
102     public final JCPrimitiveType shortType = new JCPrimitiveType(SHORT, null);
103     public final JCPrimitiveType intType = new JCPrimitiveType(INT, null);
104     public final JCPrimitiveType longType = new JCPrimitiveType(LONG, null);
105     public final JCPrimitiveType floatType = new JCPrimitiveType(FLOAT, null);
106     public final JCPrimitiveType doubleType = new JCPrimitiveType(DOUBLE, null);
107     public final JCPrimitiveType booleanType = new JCPrimitiveType(BOOLEAN, null);
108     public final Type botType = new BottomType();
109     public final JCVoidType voidType = new JCVoidType();
110 
111     private final Names names;
112     private final JavacMessages messages;
113     private final Completer initialCompleter;
114     private final Completer moduleCompleter;
115 
116     /** A symbol for the unnamed module.
117      */
118     public final ModuleSymbol unnamedModule;
119 
120     /** The error module.
121      */
122     public final ModuleSymbol errModule;
123 
124     /** A symbol for no module, for use with -source 8 or less
125      */
126     public final ModuleSymbol noModule;
127 
128     /** A symbol for the root package.
129      */
130     public final PackageSymbol rootPackage;
131 
132     /** A symbol that stands for a missing symbol.
133      */
134     public final TypeSymbol noSymbol;
135 
136     /** The error symbol.
137      */
138     public final ClassSymbol errSymbol;
139 
140     /** The unknown symbol.
141      */
142     public final ClassSymbol unknownSymbol;
143 
144     /** A value for the errType, with a originalType of noType */
145     public final Type errType;
146 
147     /** A value for the unknown type. */
148     public final Type unknownType;
149 
150     /** The builtin type of all arrays. */
151     public final ClassSymbol arrayClass;
152     public final MethodSymbol arrayCloneMethod;
153 
154     /** VGJ: The (singleton) type of all bound types. */
155     public final ClassSymbol boundClass;
156 
157     /** The builtin type of all methods. */
158     public final ClassSymbol methodClass;
159 
160     /** A symbol for the java.base module.
161      */
162     public final ModuleSymbol java_base;
163 
164     /** Predefined types.
165      */
166     public final Type objectType;
167     public final Type objectMethodsType;
168     public final Type objectsType;
169     public final Type classType;
170     public final Type classLoaderType;
171     public final Type stringType;
172     public final Type stringBufferType;
173     public final Type stringBuilderType;
174     public final Type cloneableType;
175     public final Type serializableType;
176     public final Type serializedLambdaType;
177     public final Type varHandleType;
178     public final Type methodHandleType;
179     public final Type methodHandleLookupType;
180     public final Type methodTypeType;
181     public final Type nativeHeaderType;
182     public final Type throwableType;
183     public final Type errorType;
184     public final Type interruptedExceptionType;
185     public final Type illegalArgumentExceptionType;
186     public final Type exceptionType;
187     public final Type runtimeExceptionType;
188     public final Type classNotFoundExceptionType;
189     public final Type noClassDefFoundErrorType;
190     public final Type noSuchFieldErrorType;
191     public final Type assertionErrorType;
192     public final Type incompatibleClassChangeErrorType;
193     public final Type cloneNotSupportedExceptionType;
194     public final Type annotationType;
195     public final TypeSymbol enumSym;
196     public final Type listType;
197     public final Type collectionsType;
198     public final Type comparableType;
199     public final Type comparatorType;
200     public final Type arraysType;
201     public final Type iterableType;
202     public final Type iteratorType;
203     public final Type annotationTargetType;
204     public final Type overrideType;
205     public final Type retentionType;
206     public final Type deprecatedType;
207     public final Type suppressWarningsType;
208     public final Type supplierType;
209     public final Type inheritedType;
210     public final Type profileType;
211     public final Type proprietaryType;
212     public final Type systemType;
213     public final Type autoCloseableType;
214     public final Type trustMeType;
215     public final Type lambdaMetafactory;
216     public final Type stringConcatFactory;
217     public final Type valueBootstrapMethods;
218     public final Type repeatableType;
219     public final Type documentedType;
220     public final Type elementTypeType;
221     public final Type functionalInterfaceType;
222     public final Type previewFeatureType;
223     public final Type typeDescriptorType;
224     public final Type recordType;
225     public final Type valueBasedType;
226     public final Type inlineObjectType;
227     public final Type identityObjectType;
228 
229     public final boolean injectTopInterfaceTypes;
230 
231     /** The symbol representing the length field of an array.
232      */
233     public final VarSymbol lengthVar;
234 
235     /** The symbol representing the final finalize method on enums */
236     public final MethodSymbol enumFinalFinalize;
237 
238     /** The symbol representing the close method on TWR AutoCloseable type */
239     public final MethodSymbol autoCloseableClose;
240 
241     /** The predefined type that belongs to a tag.
242      */
243     public final Type[] typeOfTag = new Type[TypeTag.getTypeTagCount()];
244 
245     /** The name of the class that belongs to a basic type tag.
246      */
247     public final Name[] boxedName = new Name[TypeTag.getTypeTagCount()];
248 
249     /** A hashtable containing the encountered top-level and member classes,
250      *  indexed by flat names. The table does not contain local classes.
251      *  It should be updated from the outside to reflect classes defined
252      *  by compiled source files.
253      */
254     private final Map&lt;Name, Map&lt;ModuleSymbol,ClassSymbol&gt;&gt; classes = new HashMap&lt;&gt;();
255 
256     /** A hashtable containing the encountered packages.
257      *  the table should be updated from outside to reflect packages defined
258      *  by compiled source files.
259      */
260     private final Map&lt;Name, Map&lt;ModuleSymbol,PackageSymbol&gt;&gt; packages = new HashMap&lt;&gt;();
261 
262     /** A hashtable giving the encountered modules.
263      */
264     private final Map&lt;Name, ModuleSymbol&gt; modules = new LinkedHashMap&lt;&gt;();
265 
266     private final Map&lt;Types.UniqueType, VarSymbol&gt; classFields = new HashMap&lt;&gt;();
267 
268     public VarSymbol getClassField(Type type, Types types) {
269         return classFields.computeIfAbsent(
270             new UniqueType(type, types), k -&gt; {
271                 Type arg = null;
272                 if (type.getTag() == ARRAY || type.getTag() == CLASS) {
273                     /* Temporary treatment for inline class: Given an inline class V that implements
274                        I1, I2, ... In, V.class is typed to be Class&lt;? extends Object &amp; I1 &amp; I2 .. &amp; In&gt;
275                     */
276                     if (type.isValue()) {
277                         Type it = types.makeIntersectionType(((ClassType)type).interfaces_field, true);
278                         arg = new WildcardType(it, BoundKind.EXTENDS, boundClass);
279                     } else {
280                         arg = types.erasure(type);
281                     }
282                 }
283                 else if (type.isPrimitiveOrVoid())
284                     arg = types.boxedClass(type).type;
285                 else
286                     throw new AssertionError(type);
287 
288                 Type t = new ClassType(
289                     classType.getEnclosingType(), List.of(arg), classType.tsym);
290                 return new VarSymbol(
291                     STATIC | PUBLIC | FINAL, names._class, t, type.tsym);
292             });
293     }
294 
295     public void initType(Type type, ClassSymbol c) {
296         type.tsym = c;
297         typeOfTag[type.getTag().ordinal()] = type;
298     }
299 
300     public void initType(Type type, String name) {
301         initType(
302             type,
303             new ClassSymbol(
304                 PUBLIC, names.fromString(name), type, rootPackage));
305     }
306 
307     public void initType(Type type, String name, String bname) {
308         initType(type, name);
309         boxedName[type.getTag().ordinal()] = names.fromString(&quot;java.lang.&quot; + bname);
310     }
311 
312     /** The class symbol that owns all predefined symbols.
313      */
314     public final ClassSymbol predefClass;
315 
316     /** Enter a class into symbol table.
317      *  @param s The name of the class.
318      */
319     private Type enterClass(String s) {
320         return enterClass(java_base, names.fromString(s)).type;
321     }
322 
323     public void synthesizeEmptyInterfaceIfMissing(final Type type) {
324         final Completer completer = type.tsym.completer;
325         type.tsym.completer = new Completer() {
326             @Override
327             public void complete(Symbol sym) throws CompletionFailure {
328                 try {
329                     completer.complete(sym);
330                 } catch (CompletionFailure e) {
331                     sym.flags_field |= (PUBLIC | INTERFACE);
332                     ((ClassType) sym.type).supertype_field = objectType;
333                 }
334             }
335 
336             @Override
337             public boolean isTerminal() {
338                 return completer.isTerminal();
339             }
340         };
341     }
342 
343     public void synthesizeBoxTypeIfMissing(final Type type) {
344         ClassSymbol sym = enterClass(java_base, boxedName[type.getTag().ordinal()]);
345         final Completer completer = sym.completer;
346         sym.completer = new Completer() {
347             @Override
348             public void complete(Symbol sym) throws CompletionFailure {
349                 try {
350                     completer.complete(sym);
351                 } catch (CompletionFailure e) {
352                     sym.flags_field |= PUBLIC;
353                     ((ClassType) sym.type).supertype_field = objectType;
354                     MethodSymbol boxMethod =
355                         new MethodSymbol(PUBLIC | STATIC, names.valueOf,
356                                          new MethodType(List.of(type), sym.type,
357                                 List.nil(), methodClass),
358                             sym);
359                     sym.members().enter(boxMethod);
360                     MethodSymbol unboxMethod =
361                         new MethodSymbol(PUBLIC,
362                             type.tsym.name.append(names.Value), // x.intValue()
363                             new MethodType(List.nil(), type,
364                                 List.nil(), methodClass),
365                             sym);
366                     sym.members().enter(unboxMethod);
367                 }
368             }
369 
370             @Override
371             public boolean isTerminal() {
372                 return completer.isTerminal();
373             }
374         };
375     }
376 
377     // Enter a synthetic class that is used to mark classes in ct.sym.
378     // This class does not have a class file.
379     private Type enterSyntheticAnnotation(String name) {
380         // for now, leave the module null, to prevent problems from synthesizing the
381         // existence of a class in any specific module, including noModule
382         ClassType type = (ClassType)enterClass(java_base, names.fromString(name)).type;
383         ClassSymbol sym = (ClassSymbol)type.tsym;
384         sym.completer = Completer.NULL_COMPLETER;
385         sym.flags_field = PUBLIC|ACYCLIC|ANNOTATION|INTERFACE;
386         sym.erasure_field = type;
387         sym.members_field = WriteableScope.create(sym);
388         type.typarams_field = List.nil();
389         type.allparams_field = List.nil();
390         type.supertype_field = annotationType;
391         type.interfaces_field = List.nil();
392         return type;
393     }
394 
395     /** Constructor; enters all predefined identifiers and operators
396      *  into symbol table.
397      */
398     protected Symtab(Context context) throws CompletionFailure {
399         context.put(symtabKey, this);
400 
401         names = Names.instance(context);
402 
403         // Create the unknown type
404         unknownType = new UnknownType();
405 
406         messages = JavacMessages.instance(context);
407 
408         MissingInfoHandler missingInfoHandler = MissingInfoHandler.instance(context);
409 
410         rootPackage = new RootPackageSymbol(names.empty, null, missingInfoHandler);
411 
412         // create the basic builtin symbols
413         unnamedModule = new ModuleSymbol(names.empty, null) {
414                 {
415                     directives = List.nil();
416                     exports = List.nil();
417                     provides = List.nil();
418                     uses = List.nil();
419                     ModuleSymbol java_base = enterModule(names.java_base);
420                     com.sun.tools.javac.code.Directive.RequiresDirective d =
421                             new com.sun.tools.javac.code.Directive.RequiresDirective(java_base,
422                                     EnumSet.of(com.sun.tools.javac.code.Directive.RequiresFlag.MANDATED));
423                     requires = List.of(d);
424                 }
425                 @Override
426                 public String toString() {
427                     return messages.getLocalizedString(&quot;compiler.misc.unnamed.module&quot;);
428                 }
429             };
430         addRootPackageFor(unnamedModule);
431         unnamedModule.enclosedPackages = unnamedModule.enclosedPackages.prepend(unnamedModule.unnamedPackage);
432 
433         errModule = new ModuleSymbol(names.empty, null) {
434                 {
435                     directives = List.nil();
436                     exports = List.nil();
437                     provides = List.nil();
438                     uses = List.nil();
439                     ModuleSymbol java_base = enterModule(names.java_base);
440                     com.sun.tools.javac.code.Directive.RequiresDirective d =
441                             new com.sun.tools.javac.code.Directive.RequiresDirective(java_base,
442                                     EnumSet.of(com.sun.tools.javac.code.Directive.RequiresFlag.MANDATED));
443                     requires = List.of(d);
444                 }
445             };
446         addRootPackageFor(errModule);
447 
448         noModule = new ModuleSymbol(names.empty, null) {
449             @Override public boolean isNoModule() {
450                 return true;
451             }
452         };
453         addRootPackageFor(noModule);
454 
455         noSymbol = new TypeSymbol(NIL, 0, names.empty, Type.noType, rootPackage) {
456             @Override @DefinedBy(Api.LANGUAGE_MODEL)
457             public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
458                 return v.visitUnknown(this, p);
459             }
460         };
461 
462         // create the error symbols
463         errSymbol = new ClassSymbol(PUBLIC|STATIC|ACYCLIC, names.any, null, rootPackage);
464         errType = new ErrorType(errSymbol, Type.noType);
465 
466         unknownSymbol = new ClassSymbol(PUBLIC|STATIC|ACYCLIC, names.fromString(&quot;&lt;any?&gt;&quot;), null, rootPackage);
467         unknownSymbol.members_field = new Scope.ErrorScope(unknownSymbol);
468         unknownSymbol.type = unknownType;
469 
470         // initialize builtin types
471         initType(byteType, &quot;byte&quot;, &quot;Byte&quot;);
472         initType(shortType, &quot;short&quot;, &quot;Short&quot;);
473         initType(charType, &quot;char&quot;, &quot;Character&quot;);
474         initType(intType, &quot;int&quot;, &quot;Integer&quot;);
475         initType(longType, &quot;long&quot;, &quot;Long&quot;);
476         initType(floatType, &quot;float&quot;, &quot;Float&quot;);
477         initType(doubleType, &quot;double&quot;, &quot;Double&quot;);
478         initType(booleanType, &quot;boolean&quot;, &quot;Boolean&quot;);
479         initType(voidType, &quot;void&quot;, &quot;Void&quot;);
480         initType(botType, &quot;&lt;nulltype&gt;&quot;);
481         initType(errType, errSymbol);
482         initType(unknownType, unknownSymbol);
483 
484         // the builtin class of all arrays
485         arrayClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Array, noSymbol);
486 
487         // VGJ
488         boundClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Bound, noSymbol);
489         boundClass.members_field = new Scope.ErrorScope(boundClass);
490 
491         // the builtin class of all methods
492         methodClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Method, noSymbol);
493         methodClass.members_field = new Scope.ErrorScope(boundClass);
494 
495         // Create class to hold all predefined constants and operations.
496         predefClass = new ClassSymbol(PUBLIC|ACYCLIC, names.empty, rootPackage);
497         WriteableScope scope = WriteableScope.create(predefClass);
498         predefClass.members_field = scope;
499 
500         // Get the initial completer for Symbols from the ClassFinder
501         initialCompleter = ClassFinder.instance(context).getCompleter();
502         rootPackage.members_field = WriteableScope.create(rootPackage);
503 
504         // Enter symbols for basic types.
505         scope.enter(byteType.tsym);
506         scope.enter(shortType.tsym);
507         scope.enter(charType.tsym);
508         scope.enter(intType.tsym);
509         scope.enter(longType.tsym);
510         scope.enter(floatType.tsym);
511         scope.enter(doubleType.tsym);
512         scope.enter(booleanType.tsym);
513         scope.enter(errType.tsym);
514 
515         // Enter symbol for the errSymbol
516         scope.enter(errSymbol);
517 
518         Source source = Source.instance(context);
519         if (Feature.MODULES.allowedInSource(source)) {
520             java_base = enterModule(names.java_base);
521             //avoid completing java.base during the Symtab initialization
522             java_base.completer = Completer.NULL_COMPLETER;
523             java_base.visiblePackages = Collections.emptyMap();
524         } else {
525             java_base = noModule;
526         }
527 
528         // Get the initial completer for ModuleSymbols from Modules
529         moduleCompleter = Modules.instance(context).getCompleter();
530 
531         // Enter predefined classes. All are assumed to be in the java.base module.
532         objectType = enterClass(&quot;java.lang.Object&quot;);
533         objectMethodsType = enterClass(&quot;java.lang.runtime.ObjectMethods&quot;);
534         objectsType = enterClass(&quot;java.util.Objects&quot;);
535         classType = enterClass(&quot;java.lang.Class&quot;);
536         stringType = enterClass(&quot;java.lang.String&quot;);
537         stringBufferType = enterClass(&quot;java.lang.StringBuffer&quot;);
538         stringBuilderType = enterClass(&quot;java.lang.StringBuilder&quot;);
539         cloneableType = enterClass(&quot;java.lang.Cloneable&quot;);
540         throwableType = enterClass(&quot;java.lang.Throwable&quot;);
541         serializableType = enterClass(&quot;java.io.Serializable&quot;);
542         serializedLambdaType = enterClass(&quot;java.lang.invoke.SerializedLambda&quot;);
543         varHandleType = enterClass(&quot;java.lang.invoke.VarHandle&quot;);
544         methodHandleType = enterClass(&quot;java.lang.invoke.MethodHandle&quot;);
545         methodHandleLookupType = enterClass(&quot;java.lang.invoke.MethodHandles$Lookup&quot;);
546         methodTypeType = enterClass(&quot;java.lang.invoke.MethodType&quot;);
547         errorType = enterClass(&quot;java.lang.Error&quot;);
548         illegalArgumentExceptionType = enterClass(&quot;java.lang.IllegalArgumentException&quot;);
549         interruptedExceptionType = enterClass(&quot;java.lang.InterruptedException&quot;);
550         exceptionType = enterClass(&quot;java.lang.Exception&quot;);
551         runtimeExceptionType = enterClass(&quot;java.lang.RuntimeException&quot;);
552         classNotFoundExceptionType = enterClass(&quot;java.lang.ClassNotFoundException&quot;);
553         noClassDefFoundErrorType = enterClass(&quot;java.lang.NoClassDefFoundError&quot;);
554         noSuchFieldErrorType = enterClass(&quot;java.lang.NoSuchFieldError&quot;);
555         assertionErrorType = enterClass(&quot;java.lang.AssertionError&quot;);
556         incompatibleClassChangeErrorType = enterClass(&quot;java.lang.IncompatibleClassChangeError&quot;);
557         cloneNotSupportedExceptionType = enterClass(&quot;java.lang.CloneNotSupportedException&quot;);
558         annotationType = enterClass(&quot;java.lang.annotation.Annotation&quot;);
559         classLoaderType = enterClass(&quot;java.lang.ClassLoader&quot;);
560         enumSym = enterClass(java_base, names.java_lang_Enum);
561         enumFinalFinalize =
562             new MethodSymbol(PROTECTED|FINAL|HYPOTHETICAL,
563                              names.finalize,
564                              new MethodType(List.nil(), voidType,
565                                             List.nil(), methodClass),
566                              enumSym);
567         listType = enterClass(&quot;java.util.List&quot;);
568         collectionsType = enterClass(&quot;java.util.Collections&quot;);
569         comparableType = enterClass(&quot;java.lang.Comparable&quot;);
570         comparatorType = enterClass(&quot;java.util.Comparator&quot;);
571         arraysType = enterClass(&quot;java.util.Arrays&quot;);
572         iterableType = enterClass(&quot;java.lang.Iterable&quot;);
573         iteratorType = enterClass(&quot;java.util.Iterator&quot;);
574         annotationTargetType = enterClass(&quot;java.lang.annotation.Target&quot;);
575         overrideType = enterClass(&quot;java.lang.Override&quot;);
576         retentionType = enterClass(&quot;java.lang.annotation.Retention&quot;);
577         deprecatedType = enterClass(&quot;java.lang.Deprecated&quot;);
578         suppressWarningsType = enterClass(&quot;java.lang.SuppressWarnings&quot;);
579         supplierType = enterClass(&quot;java.util.function.Supplier&quot;);
580         inheritedType = enterClass(&quot;java.lang.annotation.Inherited&quot;);
581         repeatableType = enterClass(&quot;java.lang.annotation.Repeatable&quot;);
582         documentedType = enterClass(&quot;java.lang.annotation.Documented&quot;);
583         elementTypeType = enterClass(&quot;java.lang.annotation.ElementType&quot;);
584         systemType = enterClass(&quot;java.lang.System&quot;);
585         autoCloseableType = enterClass(&quot;java.lang.AutoCloseable&quot;);
586         autoCloseableClose = new MethodSymbol(PUBLIC,
587                              names.close,
588                              new MethodType(List.nil(), voidType,
589                                             List.of(exceptionType), methodClass),
590                              autoCloseableType.tsym);
591         trustMeType = enterClass(&quot;java.lang.SafeVarargs&quot;);
592         nativeHeaderType = enterClass(&quot;java.lang.annotation.Native&quot;);
593         lambdaMetafactory = enterClass(&quot;java.lang.invoke.LambdaMetafactory&quot;);
594         stringConcatFactory = enterClass(&quot;java.lang.invoke.StringConcatFactory&quot;);
595         valueBootstrapMethods = enterClass(&quot;java.lang.invoke.ValueBootstrapMethods&quot;);
596         functionalInterfaceType = enterClass(&quot;java.lang.FunctionalInterface&quot;);
597         previewFeatureType = enterClass(&quot;jdk.internal.PreviewFeature&quot;);
598         typeDescriptorType = enterClass(&quot;java.lang.invoke.TypeDescriptor&quot;);
599         recordType = enterClass(&quot;java.lang.Record&quot;);
600         valueBasedType = enterClass(&quot;java.lang.ValueBased&quot;);
601         identityObjectType = enterClass(&quot;java.lang.IdentityObject&quot;);
602         inlineObjectType = enterClass(&quot;java.lang.InlineObject&quot;);
603 
604         synthesizeEmptyInterfaceIfMissing(autoCloseableType);
605         synthesizeEmptyInterfaceIfMissing(cloneableType);
606         synthesizeEmptyInterfaceIfMissing(serializableType);
607         synthesizeEmptyInterfaceIfMissing(lambdaMetafactory);
608         synthesizeEmptyInterfaceIfMissing(serializedLambdaType);
609         synthesizeEmptyInterfaceIfMissing(stringConcatFactory);
610         synthesizeEmptyInterfaceIfMissing(inlineObjectType);
611         synthesizeEmptyInterfaceIfMissing(identityObjectType);
612         synthesizeBoxTypeIfMissing(doubleType);
613         synthesizeBoxTypeIfMissing(floatType);
614         synthesizeBoxTypeIfMissing(voidType);
615 
616         // Enter a synthetic class that is used to mark internal
617         // proprietary classes in ct.sym.  This class does not have a
618         // class file.
619         proprietaryType = enterSyntheticAnnotation(&quot;sun.Proprietary+Annotation&quot;);
620 
621         // Enter a synthetic class that is used to provide profile info for
622         // classes in ct.sym.  This class does not have a class file.
623         profileType = enterSyntheticAnnotation(&quot;jdk.Profile+Annotation&quot;);
624         MethodSymbol m = new MethodSymbol(PUBLIC | ABSTRACT, names.value, intType, profileType.tsym);
625         profileType.tsym.members().enter(m);
626 
627         injectTopInterfaceTypes = Options.instance(context).isUnset(&quot;noTopInterfaceInjection&quot;) &amp;&amp;
628                 Feature.INLINE_TYPES.allowedInSource(source) &amp;&amp;
629                 Target.instance(context).hasTopInterfaces();
630 
631         // Enter a class for arrays.
632         // The class implements java.lang.Cloneable and java.io.Serializable.
633         // It has a final length field and a clone method.
634         ClassType arrayClassType = (ClassType)arrayClass.type;
635         arrayClassType.supertype_field = objectType;
636         arrayClassType.interfaces_field = injectTopInterfaceTypes ?
637                 List.of(cloneableType, serializableType, identityObjectType):
638                 List.of(cloneableType, serializableType);
639 
640         arrayClass.members_field = WriteableScope.create(arrayClass);
641         lengthVar = new VarSymbol(
642             PUBLIC | FINAL,
643             names.length,
644             intType,
645             arrayClass);
646         arrayClass.members().enter(lengthVar);
647         arrayCloneMethod = new MethodSymbol(
648             PUBLIC,
649             names.clone,
650             new MethodType(List.nil(), objectType,
651                            List.nil(), methodClass),
652             arrayClass);
653         arrayClass.members().enter(arrayCloneMethod);
654 
655         if (java_base != noModule)
656             java_base.completer = moduleCompleter::complete; //bootstrap issues
657 
658     }
659 
660     /** Define a new class given its name and owner.
661      */
662     public ClassSymbol defineClass(Name name, Symbol owner) {
663         ClassSymbol c = new ClassSymbol(0, name, owner);
664         c.completer = initialCompleter;
665         return c;
666     }
667 
668     /** Create a new toplevel or member class symbol with given name
669      *  and owner and enter in `classes&#39; unless already there.
670      */
671     public ClassSymbol enterClass(ModuleSymbol msym, Name name, TypeSymbol owner) {
672         Assert.checkNonNull(msym);
673         Name flatname = TypeSymbol.formFlatName(name, owner);
674         ClassSymbol c = getClass(msym, flatname);
675         if (c == null) {
676             c = defineClass(name, owner);
677             doEnterClass(msym, c);
678         } else if ((c.name != name || c.owner != owner) &amp;&amp; owner.kind == TYP &amp;&amp; c.owner.kind == PCK) {
679             // reassign fields of classes that might have been loaded with
680             // their flat names.
681             c.owner.members().remove(c);
682             c.name = name;
683             c.owner = owner;
684             c.fullname = ClassSymbol.formFullName(name, owner);
685         }
686         return c;
687     }
688 
689     public ClassSymbol getClass(ModuleSymbol msym, Name flatName) {
690         Assert.checkNonNull(msym, flatName::toString);
691         return classes.getOrDefault(flatName, Collections.emptyMap()).get(msym);
692     }
693 
694     public PackageSymbol lookupPackage(ModuleSymbol msym, Name flatName) {
695         Assert.checkNonNull(msym);
696 
697         if (flatName.isEmpty()) {
698             //unnamed packages only from the current module - visiblePackages contains *root* package, not unnamed package!
699             return msym.unnamedPackage;
700         }
701 
702         if (msym == noModule) {
703             return enterPackage(msym, flatName);
704         }
705 
706         msym.complete();
707 
708         PackageSymbol pack;
709 
710         pack = msym.visiblePackages.get(flatName);
711 
712         if (pack != null)
713             return pack;
714 
715         pack = getPackage(msym, flatName);
716 
717         if (pack != null &amp;&amp; pack.exists())
718             return pack;
719 
720         boolean dependsOnUnnamed = msym.requires != null &amp;&amp;
721                                    msym.requires.stream()
722                                                 .map(rd -&gt; rd.module)
723                                                 .anyMatch(mod -&gt; mod == unnamedModule);
724 
725         if (dependsOnUnnamed) {
726             //msyms depends on the unnamed module, for which we generally don&#39;t know
727             //the list of packages it &quot;exports&quot; ahead of time. So try to lookup the package in the
728             //current module, and in the unnamed module and see if it exists in one of them
729             PackageSymbol unnamedPack = getPackage(unnamedModule, flatName);
730 
731             if (unnamedPack != null &amp;&amp; unnamedPack.exists()) {
732                 msym.visiblePackages.put(unnamedPack.fullname, unnamedPack);
733                 return unnamedPack;
734             }
735 
736             pack = enterPackage(msym, flatName);
737             pack.complete();
738             if (pack.exists())
739                 return pack;
740 
741             unnamedPack = enterPackage(unnamedModule, flatName);
742             unnamedPack.complete();
743             if (unnamedPack.exists()) {
744                 msym.visiblePackages.put(unnamedPack.fullname, unnamedPack);
745                 return unnamedPack;
746             }
747 
748             return pack;
749         }
750 
751         return enterPackage(msym, flatName);
752     }
753 
754     private static final Map&lt;ModuleSymbol, ClassSymbol&gt; EMPTY = new HashMap&lt;&gt;();
755 
756     public void removeClass(ModuleSymbol msym, Name flatName) {
757         classes.getOrDefault(flatName, EMPTY).remove(msym);
758     }
759 
760     public Iterable&lt;ClassSymbol&gt; getAllClasses() {
761         return () -&gt; Iterators.createCompoundIterator(classes.values(), v -&gt; v.values().iterator());
762     }
763 
764     private void doEnterClass(ModuleSymbol msym, ClassSymbol cs) {
765         classes.computeIfAbsent(cs.flatname, n -&gt; new HashMap&lt;&gt;()).put(msym, cs);
766     }
767 
768     /** Create a new member or toplevel class symbol with given flat name
769      *  and enter in `classes&#39; unless already there.
770      */
771     public ClassSymbol enterClass(ModuleSymbol msym, Name flatname) {
772         Assert.checkNonNull(msym);
773         PackageSymbol ps = lookupPackage(msym, Convert.packagePart(flatname));
774         Assert.checkNonNull(ps);
775         Assert.checkNonNull(ps.modle);
776         ClassSymbol c = getClass(ps.modle, flatname);
777         if (c == null) {
778             c = defineClass(Convert.shortName(flatname), ps);
779             doEnterClass(ps.modle, c);
780             return c;
781         } else
782             return c;
783     }
784 
785     /** Check to see if a package exists, given its fully qualified name.
786      */
787     public boolean packageExists(ModuleSymbol msym, Name fullname) {
788         Assert.checkNonNull(msym);
789         return lookupPackage(msym, fullname).exists();
790     }
791 
792     /** Make a package, given its fully qualified name.
793      */
794     public PackageSymbol enterPackage(ModuleSymbol currModule, Name fullname) {
795         Assert.checkNonNull(currModule);
796         PackageSymbol p = getPackage(currModule, fullname);
797         if (p == null) {
798             Assert.check(!fullname.isEmpty(), () -&gt; &quot;rootPackage missing!; currModule: &quot; + currModule);
799             p = new PackageSymbol(
800                     Convert.shortName(fullname),
801                     enterPackage(currModule, Convert.packagePart(fullname)));
802             p.completer = initialCompleter;
803             p.modle = currModule;
804             doEnterPackage(currModule, p);
805         }
806         return p;
807     }
808 
809     private void doEnterPackage(ModuleSymbol msym, PackageSymbol pack) {
810         packages.computeIfAbsent(pack.fullname, n -&gt; new HashMap&lt;&gt;()).put(msym, pack);
811         msym.enclosedPackages = msym.enclosedPackages.prepend(pack);
812     }
813 
814     private void addRootPackageFor(ModuleSymbol module) {
815         doEnterPackage(module, rootPackage);
816         PackageSymbol unnamedPackage = new PackageSymbol(names.empty, rootPackage) {
817                 @Override
818                 public String toString() {
819                     return messages.getLocalizedString(&quot;compiler.misc.unnamed.package&quot;);
820                 }
821             };
822         unnamedPackage.modle = module;
823         //we cannot use a method reference below, as initialCompleter might be null now
824         unnamedPackage.completer = s -&gt; initialCompleter.complete(s);
825         unnamedPackage.flags_field |= EXISTS;
826         module.unnamedPackage = unnamedPackage;
827     }
828 
829     public PackageSymbol getPackage(ModuleSymbol module, Name fullname) {
830         return packages.getOrDefault(fullname, Collections.emptyMap()).get(module);
831     }
832 
833     public ModuleSymbol enterModule(Name name) {
834         ModuleSymbol msym = modules.get(name);
835         if (msym == null) {
836             msym = ModuleSymbol.create(name, names.module_info);
837             addRootPackageFor(msym);
838             msym.completer = s -&gt; moduleCompleter.complete(s); //bootstrap issues
839             modules.put(name, msym);
840         }
841         return msym;
842     }
843 
844     public ModuleSymbol getModule(Name name) {
845         return modules.get(name);
846     }
847 
848     //temporary:
849     public ModuleSymbol inferModule(Name packageName) {
850         if (packageName.isEmpty())
851             return java_base == noModule ? noModule : unnamedModule;//!
852 
853         ModuleSymbol msym = null;
854         Map&lt;ModuleSymbol,PackageSymbol&gt; map = packages.get(packageName);
855         if (map == null)
856             return null;
857         for (Map.Entry&lt;ModuleSymbol,PackageSymbol&gt; e: map.entrySet()) {
858             if (!e.getValue().members().isEmpty()) {
859                 if (msym == null) {
860                     msym = e.getKey();
861                 } else {
862                     return null;
863                 }
864             }
865         }
866         return msym;
867     }
868 
869     public List&lt;ModuleSymbol&gt; listPackageModules(Name packageName) {
870         if (packageName.isEmpty())
871             return List.nil();
872 
873         List&lt;ModuleSymbol&gt; result = List.nil();
874         Map&lt;ModuleSymbol,PackageSymbol&gt; map = packages.get(packageName);
875         if (map != null) {
876             for (Map.Entry&lt;ModuleSymbol, PackageSymbol&gt; e: map.entrySet()) {
877                 if (!e.getValue().members().isEmpty()) {
878                     result = result.prepend(e.getKey());
879                 }
880             }
881         }
882         return result;
883     }
884 
885     public Collection&lt;ModuleSymbol&gt; getAllModules() {
886         return modules.values();
887     }
888 
889     public Iterable&lt;ClassSymbol&gt; getClassesForName(Name candidate) {
890         return classes.getOrDefault(candidate, Collections.emptyMap()).values();
891     }
892 
893     public Iterable&lt;PackageSymbol&gt; getPackagesForName(Name candidate) {
894         return packages.getOrDefault(candidate, Collections.emptyMap()).values();
895     }
896 }
    </pre>
  </body>
</html>
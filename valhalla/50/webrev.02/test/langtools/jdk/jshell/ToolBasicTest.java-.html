<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/jdk/jshell/ToolBasicTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @ignore
 26  * @test
 27  * @bug 8143037 8142447 8144095 8140265 8144906 8146138 8147887 8147886 8148316 8148317 8143955 8157953 8080347 8154714 8166649 8167643 8170162 8172102 8165405 8174796 8174797 8175304 8167554 8180508 8166232 8196133 8199912 8211694 8223688
 28  * @summary Tests for Basic tests for REPL tool
 29  * @modules jdk.compiler/com.sun.tools.javac.api
 30  *          jdk.compiler/com.sun.tools.javac.main
 31  *          jdk.jdeps/com.sun.tools.javap
 32  *          jdk.jshell/jdk.internal.jshell.tool
 33  * @library /tools/lib
 34  * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask
 35  * @build KullaTesting TestingInputStream Compiler
 36  * @run testng/timeout=600 ToolBasicTest
 37  * @key intermittent
 38  */
 39 
 40 import java.io.File;
 41 import java.io.IOException;
 42 import java.io.PrintWriter;
 43 import java.io.StringWriter;
 44 import java.net.InetAddress;
 45 import java.net.InetSocketAddress;
 46 import java.nio.file.Files;
 47 import java.nio.file.Path;
 48 import java.nio.file.Paths;
 49 import java.util.ArrayList;
 50 import java.util.Arrays;
 51 import java.util.List;
 52 import java.util.Scanner;
 53 import java.util.function.BiFunction;
 54 import java.util.function.Consumer;
 55 import java.util.function.Function;
 56 import java.util.stream.Collectors;
 57 import java.util.stream.Stream;
 58 
 59 import com.sun.net.httpserver.HttpServer;
 60 import org.testng.annotations.Test;
 61 
 62 import static org.testng.Assert.assertEquals;
 63 import static org.testng.Assert.assertTrue;
 64 import static org.testng.Assert.assertFalse;
 65 import static org.testng.Assert.fail;
 66 
 67 @Test
 68 public class ToolBasicTest extends ReplToolTesting {
 69 
 70     public void elideStartUpFromList() {
 71         test(
 72                 (a) -&gt; assertCommandOutputContains(a, &quot;123&quot;, &quot;==&gt; 123&quot;),
 73                 (a) -&gt; assertCommandCheckOutput(a, &quot;/list&quot;, (s) -&gt; {
 74                     int cnt;
 75                     try (Scanner scanner = new Scanner(s)) {
 76                         cnt = 0;
 77                         while (scanner.hasNextLine()) {
 78                             String line = scanner.nextLine();
 79                             if (!line.trim().isEmpty()) {
 80                                 ++cnt;
 81                             }
 82                         }
 83                     }
 84                     assertEquals(cnt, 1, &quot;Expected only one listed line&quot;);
 85                 })
 86         );
 87     }
 88 
 89     public void elideStartUpFromSave() throws IOException {
 90         Compiler compiler = new Compiler();
 91         Path path = compiler.getPath(&quot;myfile&quot;);
 92         test(
 93                 (a) -&gt; assertCommandOutputContains(a, &quot;123&quot;, &quot;==&gt; 123&quot;),
 94                 (a) -&gt; assertCommand(a, &quot;/save &quot; + path.toString(), &quot;&quot;)
 95         );
 96         try (Stream&lt;String&gt; lines = Files.lines(path)) {
 97             assertEquals(lines.count(), 1, &quot;Expected only one saved line&quot;);
 98         }
 99     }
100 
101     public void testInterrupt() {
102         ReplTest interrupt = (a) -&gt; assertCommand(a, &quot;\u0003&quot;, &quot;&quot;);
103         for (String s : new String[] { &quot;&quot;, &quot;\u0003&quot; }) {
104             test(false, new String[]{&quot;--no-startup&quot;},
105                     (a) -&gt; assertCommand(a, &quot;int a = 2 +&quot; + s, &quot;&quot;),
106                     interrupt,
107                     (a) -&gt; assertCommand(a, &quot;int a\u0003&quot;, &quot;&quot;),
108                     (a) -&gt; assertCommand(a, &quot;int a = 2 + 2\u0003&quot;, &quot;&quot;),
109                     (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
110                     (a) -&gt; evaluateExpression(a, &quot;int&quot;, &quot;2&quot;, &quot;2&quot;),
111                     (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
112                     (a) -&gt; assertCommand(a, &quot;void f() {&quot;, &quot;&quot;),
113                     (a) -&gt; assertCommand(a, &quot;int q = 10;&quot; + s, &quot;&quot;),
114                     interrupt,
115                     (a) -&gt; assertCommand(a, &quot;void f() {}\u0003&quot;, &quot;&quot;),
116                     (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
117                     (a) -&gt; assertMethod(a, &quot;int f() { return 0; }&quot;, &quot;()int&quot;, &quot;f&quot;),
118                     (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
119                     (a) -&gt; assertCommand(a, &quot;class A {&quot; + s, &quot;&quot;),
120                     interrupt,
121                     (a) -&gt; assertCommand(a, &quot;class A {}\u0003&quot;, &quot;&quot;),
122                     (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
123                     (a) -&gt; assertClass(a, &quot;interface A {}&quot;, &quot;interface&quot;, &quot;A&quot;),
124                     (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
125                     (a) -&gt; assertCommand(a, &quot;import java.util.stream.&quot; + s, &quot;&quot;),
126                     interrupt,
127                     (a) -&gt; assertCommand(a, &quot;import java.util.stream.\u0003&quot;, &quot;&quot;),
128                     (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports()),
129                     (a) -&gt; assertImport(a, &quot;import java.util.stream.Stream&quot;, &quot;&quot;, &quot;java.util.stream.Stream&quot;),
130                     (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
131             );
132         }
133     }
134 
135     public void testCtrlD() {
136         test(false, new String[]{&quot;--no-startup&quot;},
137                 a -&gt; {
138                     if (!a) {
139                         closeCommandInput();
140                     } else {
141                         throw new IllegalStateException();
142                     }
143                 }
144         );
145     }
146 
147     private final Object lock = new Object();
148     private PrintWriter out;
149     private boolean isStopped;
150     private Thread t;
151     private void assertStop(boolean after, String cmd, String output) {
152         if (!after) {
153             isStopped = false;
154             StringWriter writer = new StringWriter();
155             out = new PrintWriter(writer);
156             setCommandInput(cmd + &quot;\n&quot;);
157             t = new Thread(() -&gt; {
158                 try {
159                     // no chance to know whether cmd is being evaluated
160                     Thread.sleep(5000);
161                 } catch (InterruptedException ignored) {
162                 }
163                 int i = 1;
164                 int n = 30;
165                 synchronized (lock) {
166                     do {
167                         setCommandInput(&quot;\u0003&quot;);
168                         if (!isStopped) {
169                             out.println(&quot;Not stopped. Try again: &quot; + i);
170                             try {
171                                 lock.wait(1000);
172                             } catch (InterruptedException ignored) {
173                             }
174                         }
175                     } while (i++ &lt; n &amp;&amp; !isStopped);
176                     if (!isStopped) {
177                         System.err.println(writer.toString());
178                         fail(&quot;Evaluation was not stopped: &#39;&quot; + cmd + &quot;&#39;&quot;);
179                     }
180                 }
181             });
182             t.start();
183         } else {
184             synchronized (lock)  {
185                 out.println(&quot;Evaluation was stopped successfully: &#39;&quot; + cmd + &quot;&#39;&quot;);
186                 isStopped = true;
187                 lock.notify();
188             }
189             try {
190                 t.join();
191                 t = null;
192             } catch (InterruptedException ignored) {
193             }
194             assertOutput(getCommandOutput(), &quot;&quot;, &quot;command&quot;);
195             assertOutput(getCommandErrorOutput(), &quot;&quot;, &quot;command error&quot;);
196             assertOutput(getUserOutput().trim(), output, &quot;user&quot;);
197             assertOutput(getUserErrorOutput(), &quot;&quot;, &quot;user error&quot;);
198         }
199     }
200 
201     public void testStop() {
202         test(
203                 (a) -&gt; assertStop(a, &quot;while (true) {}&quot;, &quot;&quot;),
204                 (a) -&gt; assertStop(a, &quot;while (true) { try { Thread.sleep(100); } catch (InterruptedException ex) { } }&quot;, &quot;&quot;)
205         );
206     }
207 
208     public void testRerun() {
209         test(false, new String[] {&quot;--no-startup&quot;},
210                 (a) -&gt; assertCommand(a, &quot;/0&quot;, &quot;|  No snippet with ID: 0&quot;),
211                 (a) -&gt; assertCommand(a, &quot;/5&quot;, &quot;|  No snippet with ID: 5&quot;)
212         );
213         String[] codes = new String[] {
214                 &quot;int a = 0;&quot;, // var
215                 &quot;class A {}&quot;, // class
216                 &quot;void f() {}&quot;, // method
217                 &quot;bool b;&quot;, // active failed
218                 &quot;void g() { h(); }&quot;, // active corralled
219         };
220         List&lt;ReplTest&gt; tests = new ArrayList&lt;&gt;();
221         for (String s : codes) {
222             tests.add((a) -&gt; assertCommand(a, s, null));
223         }
224         // Test /1 through /5 -- assure references are correct
225         for (int i = 0; i &lt; codes.length; ++i) {
226             final int finalI = i;
227             Consumer&lt;String&gt; check = (s) -&gt; {
228                 String[] ss = s.split(&quot;\n&quot;);
229                 assertEquals(ss[0], codes[finalI]);
230                 assertTrue(ss.length &gt; 1, s);
231             };
232             tests.add((a) -&gt; assertCommandCheckOutput(a, &quot;/&quot; + (finalI + 1), check));
233         }
234         // Test /-1 ... note that the snippets added by history must be stepped over
235         for (int i = 0; i &lt; codes.length; ++i) {
236             final int finalI = i;
237             Consumer&lt;String&gt; check = (s) -&gt; {
238                 String[] ss = s.split(&quot;\n&quot;);
239                 assertEquals(ss[0], codes[codes.length - finalI - 1]);
240                 assertTrue(ss.length &gt; 1, s);
241             };
242             tests.add((a) -&gt; assertCommandCheckOutput(a, &quot;/-&quot; + (2 * finalI + 1), check));
243         }
244         tests.add((a) -&gt; assertCommandCheckOutput(a, &quot;/!&quot;, assertStartsWith(&quot;int a = 0;&quot;)));
245         test(false, new String[]{&quot;--no-startup&quot;},
246                 tests.toArray(new ReplTest[tests.size()]));
247     }
248 
249     public void test8142447() {
250         Function&lt;String, BiFunction&lt;String, Integer, ReplTest&gt;&gt; assertRerun = cmd -&gt; (code, assertionCount) -&gt;
251                 (a) -&gt; assertCommandCheckOutput(a, cmd, s -&gt; {
252                             String[] ss = s.split(&quot;\n&quot;);
253                             assertEquals(ss[0], code);
254                             loadVariable(a, &quot;int&quot;, &quot;assertionCount&quot;, Integer.toString(assertionCount), Integer.toString(assertionCount));
255                         });
256         ReplTest assertVariables = (a) -&gt; assertCommandCheckOutput(a, &quot;/v&quot;, assertVariables());
257 
258         Compiler compiler = new Compiler();
259         Path startup = compiler.getPath(&quot;StartupFileOption/startup.txt&quot;);
260         compiler.writeToFile(startup, &quot;int assertionCount = 0;\n&quot; + // id: s1
261                 &quot;void add(int n) { assertionCount += n; }&quot;);
262         test(new String[]{&quot;--startup&quot;, startup.toString()},
263                 (a) -&gt; assertCommand(a, &quot;add(1)&quot;, &quot;&quot;), // id: 1
264                 (a) -&gt; assertCommandCheckOutput(a, &quot;add(ONE)&quot;, s -&gt; assertEquals(s.split(&quot;\n&quot;)[0], &quot;|  Error:&quot;)), // id: e1
265                 (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;ONE&quot;, &quot;1&quot;, &quot;1&quot;),
266                 assertRerun.apply(&quot;/1&quot;).apply(&quot;add(1)&quot;, 2), assertVariables,
267                 assertRerun.apply(&quot;/e1&quot;).apply(&quot;add(ONE)&quot;, 3), assertVariables,
268                 assertRerun.apply(&quot;/s1&quot;).apply(&quot;int assertionCount = 0;&quot;, 0), assertVariables
269         );
270 
271         test(false, new String[] {&quot;--no-startup&quot;},
272                 (a) -&gt; assertCommand(a, &quot;/s1&quot;, &quot;|  No snippet with ID: s1&quot;),
273                 (a) -&gt; assertCommand(a, &quot;/1&quot;, &quot;|  No snippet with ID: 1&quot;),
274                 (a) -&gt; assertCommand(a, &quot;/e1&quot;, &quot;|  No snippet with ID: e1&quot;)
275         );
276     }
277 
278     public void testClasspathDirectory() {
279         Compiler compiler = new Compiler();
280         Path outDir = Paths.get(&quot;testClasspathDirectory&quot;);
281         compiler.compile(outDir, &quot;package pkg; public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
282         Path classpath = compiler.getPath(outDir);
283         test(
284                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + classpath,
285                         &quot;|  Setting new options and restoring state.&quot;),
286                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
287         );
288         test(new String[] { &quot;--class-path&quot;, classpath.toString() },
289                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
290         );
291     }
292 
293     public void testEnvInStartUp() {
294         Compiler compiler = new Compiler();
295         Path outDir = Paths.get(&quot;testClasspathDirectory&quot;);
296         compiler.compile(outDir, &quot;package pkg; public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
297         Path classpath = compiler.getPath(outDir);
298         Path sup = compiler.getPath(&quot;startup.jsh&quot;);
299         compiler.writeToFile(sup,
300                 &quot;int xxx;\n&quot; +
301                 &quot;/env -class-path &quot; + classpath + &quot;\n&quot; +
302                 &quot;int aaa = 735;\n&quot;
303         );
304         test(
305                 (a) -&gt; assertCommand(a, &quot;/set start -retain &quot; + sup, &quot;&quot;),
306                 (a) -&gt; assertCommand(a, &quot;/reset&quot;,
307                         &quot;|  Resetting state.&quot;),
308                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;),
309                 (a) -&gt; assertCommand(a, &quot;aaa&quot;, &quot;aaa ==&gt; 735&quot;)
310         );
311         test(
312                 (a) -&gt; assertCommandOutputContains(a, &quot;/env&quot;, &quot;--class-path&quot;),
313                 (a) -&gt; assertCommandOutputContains(a, &quot;xxx&quot;, &quot;cannot find symbol&quot;, &quot;variable xxx&quot;),
314                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;),
315                 (a) -&gt; assertCommand(a, &quot;aaa&quot;, &quot;aaa ==&gt; 735&quot;)
316         );
317     }
318 
319     private String makeSimpleJar() {
320         Compiler compiler = new Compiler();
321         Path outDir = Paths.get(&quot;testClasspathJar&quot;);
322         compiler.compile(outDir, &quot;package pkg; public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
323         String jarName = &quot;test.jar&quot;;
324         compiler.jar(outDir, jarName, &quot;pkg/A.class&quot;);
325         return compiler.getPath(outDir).resolve(jarName).toString();
326     }
327 
328     public void testClasspathJar() {
329         String jarPath = makeSimpleJar();
330         test(
331                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath,
332                         &quot;|  Setting new options and restoring state.&quot;),
333                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
334         );
335         test(new String[] { &quot;--class-path&quot;, jarPath },
336                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
337         );
338     }
339 
340     public void testClasspathUserHomeExpansion() {
341         String jarPath = makeSimpleJar();
342         String tilde = &quot;~&quot; + File.separator;
343         test(
344                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + tilde + &quot;forblato&quot;,
345                         &quot;|  File &#39;&quot; + Paths.get(System.getProperty(&quot;user.home&quot;), &quot;forblato&quot;).toString()
346                                 + &quot;&#39; for &#39;--class-path&#39; is not found.&quot;),
347                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath + File.pathSeparator
348                                                             + tilde + &quot;forblato&quot;,
349                         &quot;|  File &#39;&quot; + Paths.get(System.getProperty(&quot;user.home&quot;), &quot;forblato&quot;).toString()
350                                 + &quot;&#39; for &#39;--class-path&#39; is not found.&quot;)
351         );
352     }
353 
354     public void testBadClasspath() {
355         String jarPath = makeSimpleJar();
356         Compiler compiler = new Compiler();
357         Path t1 = compiler.getPath(&quot;whatever/thing.zip&quot;);
358         compiler.writeToFile(t1, &quot;&quot;);
359         Path t2 = compiler.getPath(&quot;whatever/thing.jmod&quot;);
360         compiler.writeToFile(t2, &quot;&quot;);
361         test(
362                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + t1.toString(),
363                         &quot;|  Invalid &#39;--class-path&#39; argument: &quot; + t1.toString()),
364                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath + File.pathSeparator + t1.toString(),
365                         &quot;|  Invalid &#39;--class-path&#39; argument: &quot; + t1.toString()),
366                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + t2.toString(),
367                         &quot;|  Invalid &#39;--class-path&#39; argument: &quot; + t2.toString())
368         );
369     }
370 
371     private String makeBadSourceJar() {
372         Compiler compiler = new Compiler();
373         Path outDir = Paths.get(&quot;testClasspathJar&quot;);
374         Path src = compiler.getPath(outDir.resolve(&quot;pkg/A.java&quot;));
375         compiler.writeToFile(src, &quot;package pkg; /** \u0086 */public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
376         String jarName = &quot;test.jar&quot;;
377         compiler.jar(outDir, jarName, &quot;pkg/A.java&quot;);
378         return compiler.getPath(outDir).resolve(jarName).toString();
379     }
380 
381     public void testBadSourceJarClasspath() {
382         String jarPath = makeBadSourceJar();
383         test(
384                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath,
385                         &quot;|  Setting new options and restoring state.&quot;),
386                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;new pkg.A();&quot;,
387                         &quot;|  Error:\n&quot;
388                         + &quot;|  cannot find symbol\n&quot;
389                         + &quot;|    symbol:   class A&quot;)
390         );
391         test(new String[]{&quot;--class-path&quot;, jarPath},
392                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;new pkg.A();&quot;,
393                         &quot;|  Error:\n&quot;
394                         + &quot;|  cannot find symbol\n&quot;
395                         + &quot;|    symbol:   class A&quot;)
396         );
397     }
398 
399     public void testModulePath() {
400         Compiler compiler = new Compiler();
401         Path modsDir = Paths.get(&quot;mods&quot;);
402         Path outDir = Paths.get(&quot;mods&quot;, &quot;org.astro&quot;);
403         compiler.compile(outDir, &quot;package org.astro; public class World { public static String name() { return \&quot;world\&quot;; } }&quot;);
404         compiler.compile(outDir, &quot;module org.astro { exports org.astro; }&quot;);
405         Path modsPath = compiler.getPath(modsDir);
406         test(new String[] { &quot;--module-path&quot;, modsPath.toString(), &quot;--add-modules&quot;, &quot;org.astro&quot; },
407                 (a) -&gt; assertCommand(a, &quot;import org.astro.World;&quot;, &quot;&quot;),
408                 (a) -&gt; evaluateExpression(a, &quot;String&quot;,
409                         &quot;String.format(\&quot;Greetings %s!\&quot;, World.name());&quot;,
410                         &quot;\&quot;Greetings world!\&quot;&quot;)
411         );
412     }
413 
414     public void testModulePathUserHomeExpansion() {
415         String tilde = &quot;~&quot; + File.separatorChar;
416         test(
417                 (a) -&gt; assertCommand(a, &quot;/env --module-path &quot; + tilde + &quot;snardugol&quot;,
418                         &quot;|  File &#39;&quot; + Paths.get(System.getProperty(&quot;user.home&quot;), &quot;snardugol&quot;).toString()
419                                 + &quot;&#39; for &#39;--module-path&#39; is not found.&quot;)
420         );
421     }
422 
423     public void testBadModulePath() {
424         Compiler compiler = new Compiler();
425         Path t1 = compiler.getPath(&quot;whatever/thing.zip&quot;);
426         compiler.writeToFile(t1, &quot;&quot;);
427         test(
428                 (a) -&gt; assertCommand(a, &quot;/env --module-path &quot; + t1.toString(),
429                         &quot;|  Invalid &#39;--module-path&#39; argument: &quot; + t1.toString())
430         );
431     }
432 
433     public void testStartupFileOption() {
434         Compiler compiler = new Compiler();
435         Path startup = compiler.getPath(&quot;StartupFileOption/startup.txt&quot;);
436         compiler.writeToFile(startup, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
437         test(new String[]{&quot;--startup&quot;, startup.toString()},
438                 (a) -&gt; evaluateExpression(a, &quot;A&quot;, &quot;new A()&quot;, &quot;A&quot;)
439         );
440         test(new String[]{&quot;--no-startup&quot;},
441                 (a) -&gt; assertCommandCheckOutput(a, &quot;Pattern.compile(\&quot;x+\&quot;)&quot;, assertStartsWith(&quot;|  Error:\n|  cannot find symbol&quot;))
442         );
443         test(
444                 (a) -&gt; assertCommand(a, &quot;Pattern.compile(\&quot;x+\&quot;)&quot;, &quot;$1 ==&gt; x+&quot;, &quot;&quot;, null, &quot;&quot;, &quot;&quot;)
445         );
446     }
447 
448     public void testLoadingFromArgs() {
449         Compiler compiler = new Compiler();
450         Path path = compiler.getPath(&quot;loading.repl&quot;);
451         compiler.writeToFile(path, &quot;int a = 10; double x = 20; double a = 10;&quot;);
452         test(new String[] { path.toString() },
453                 (a) -&gt; assertCommand(a, &quot;x&quot;, &quot;x ==&gt; 20.0&quot;),
454                 (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10.0&quot;)
455         );
456     }
457 
458     public void testReset() {
459         test(
460                 (a) -&gt; assertReset(a, &quot;/res&quot;),
461                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
462                 (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;x&quot;),
463                 (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
464                 (a) -&gt; assertMethod(a, &quot;void f() { }&quot;, &quot;()void&quot;, &quot;f&quot;),
465                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
466                 (a) -&gt; assertClass(a, &quot;class A { }&quot;, &quot;class&quot;, &quot;A&quot;),
467                 (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
468                 (a) -&gt; assertImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;),
469                 (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports()),
470                 (a) -&gt; assertReset(a, &quot;/reset&quot;),
471                 (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
472                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
473                 (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
474                 (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
475         );
476     }
477 
478     public void testOpen() {
479         Compiler compiler = new Compiler();
480         Path path = compiler.getPath(&quot;testOpen.repl&quot;);
481         compiler.writeToFile(path,
482                 &quot;int a = 10;\ndouble x = 20;\ndouble a = 10;\n&quot; +
483                         &quot;class A { public String toString() { return \&quot;A\&quot;; } }\nimport java.util.stream.*;&quot;);
484         for (String s : new String[]{&quot;/o&quot;, &quot;/open&quot;}) {
485             test(
486                     (a) -&gt; assertCommand(a, s + &quot; &quot; + path.toString(), &quot;&quot;),
487                     (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10.0&quot;),
488                     (a) -&gt; evaluateExpression(a, &quot;A&quot;, &quot;new A();&quot;, &quot;A&quot;),
489                     (a) -&gt; evaluateExpression(a, &quot;long&quot;, &quot;Stream.of(\&quot;A\&quot;).count();&quot;, &quot;1&quot;),
490                     (a) -&gt; {
491                         loadVariable(a, &quot;double&quot;, &quot;x&quot;, &quot;20.0&quot;, &quot;20.0&quot;);
492                         loadVariable(a, &quot;double&quot;, &quot;a&quot;, &quot;10.0&quot;, &quot;10.0&quot;);
493                         loadVariable(a, &quot;A&quot;, &quot;$7&quot;, &quot;new A();&quot;, &quot;A&quot;);
494                         loadVariable(a, &quot;long&quot;, &quot;$8&quot;, &quot;Stream.of(\&quot;A\&quot;).count();&quot;, &quot;1&quot;);
495                         loadClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;,
496                                 &quot;class&quot;, &quot;A&quot;);
497                         loadImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;);
498                         assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses());
499                     },
500                     (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
501                     (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
502                     (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
503             );
504             Path unknown = compiler.getPath(&quot;UNKNOWN.repl&quot;);
505             test(
506                     (a) -&gt; assertCommand(a, s + &quot; &quot; + unknown,
507                             &quot;|  File &#39;&quot; + unknown + &quot;&#39; for &#39;/open&#39; is not found.&quot;)
508             );
509         }
510     }
511 
512     public void testOpenLocalFileUrl() {
513         Compiler compiler = new Compiler();
514         Path path = compiler.getPath(&quot;testOpen.repl&quot;);
515         compiler.writeToFile(path, &quot;int a = 10;int b = 20;int c = a + b;\n&quot;);
516         for (String s : new String[]{&quot;/o&quot;, &quot;/open&quot;}) {
517             test(
518                     (a) -&gt; assertCommand(a, s + &quot; &quot; + path.toUri(), &quot;&quot;),
519                     (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10&quot;),
520                     (a) -&gt; assertCommand(a, &quot;b&quot;, &quot;b ==&gt; 20&quot;),
521                     (a) -&gt; assertCommand(a, &quot;c&quot;, &quot;c ==&gt; 30&quot;)
522             );
523         }
524     }
525 
526     public void testOpenFileOverHttp() throws IOException {
527         var script = &quot;int a = 10;int b = 20;int c = a + b;&quot;;
528 
529         var localhostAddress = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), 0);
530         var httpServer = HttpServer.create(localhostAddress, 0);
531         try {
532             httpServer.createContext(&quot;/script&quot;, exchange -&gt; {
533                 exchange.sendResponseHeaders(200, script.length());
534                 try (var output = exchange.getResponseBody()) {
535                     output.write(script.getBytes());
536                 }
537             });
538             httpServer.setExecutor(null);
539             httpServer.start();
540 
541             var urlAddress = &quot;http:/&quot; + httpServer.getAddress().toString() + &quot;/script&quot;;
542             for (String s : new String[]{&quot;/o&quot;, &quot;/open&quot;}) {
543                 test(
544                         (a) -&gt; assertCommand(a, s + &quot; &quot; + urlAddress, &quot;&quot;),
545                         (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10&quot;),
546                         (a) -&gt; assertCommand(a, &quot;b&quot;, &quot;b ==&gt; 20&quot;),
547                         (a) -&gt; assertCommand(a, &quot;c&quot;, &quot;c ==&gt; 30&quot;)
548                 );
549             }
550         } finally {
551             httpServer.stop(0);
552         }
553     }
554 
555     public void testOpenResource() {
556         test(
557                 (a) -&gt; assertCommand(a, &quot;/open PRINTING&quot;, &quot;&quot;),
558                 (a) -&gt; assertCommandOutputContains(a, &quot;/list&quot;,
559                         &quot;void println&quot;, &quot;System.out.printf&quot;),
560                 (a) -&gt; assertCommand(a, &quot;printf(\&quot;%4.2f\&quot;, Math.PI)&quot;,
561                         &quot;&quot;, &quot;&quot;, null, &quot;3.14&quot;, &quot;&quot;)
562         );
563     }
564 
565     public void testSave() throws IOException {
566         Compiler compiler = new Compiler();
567         Path path = compiler.getPath(&quot;testSave.repl&quot;);
568         {
569             List&lt;String&gt; list = Arrays.asList(
570                     &quot;int a;&quot;,
571                     &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;
572             );
573             test(
574                     (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;a&quot;),
575                     (a) -&gt; assertCommand(a, &quot;()&quot;, null, null, null, &quot;&quot;, &quot;&quot;),
576                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
577                     (a) -&gt; assertCommand(a, &quot;/save &quot; + path.toString(), &quot;&quot;)
578             );
579             assertEquals(Files.readAllLines(path), list);
580         }
581         {
582             List&lt;String&gt; output = new ArrayList&lt;&gt;();
583             test(
584                     (a) -&gt; assertCommand(a, &quot;int a;&quot;, null),
585                     (a) -&gt; assertCommand(a, &quot;()&quot;, null, null, null, &quot;&quot;, &quot;&quot;),
586                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
587                     (a) -&gt; assertCommandCheckOutput(a, &quot;/list -all&quot;, (out) -&gt;
588                                     output.addAll(Stream.of(out.split(&quot;\n&quot;))
589                             .filter(str -&gt; !str.isEmpty())
590                             .map(str -&gt; str.substring(str.indexOf(&#39;:&#39;) + 2))
591                             .filter(str -&gt; !str.startsWith(&quot;/&quot;))
592                             .collect(Collectors.toList()))),
593                     (a) -&gt; assertCommand(a, &quot;/save -all &quot; + path.toString(), &quot;&quot;)
594             );
595             assertEquals(Files.readAllLines(path), output);
596         }
597         {
598             List&lt;String&gt; output = new ArrayList&lt;&gt;();
599             test(
600                     (a) -&gt; assertCommand(a, &quot;int a;&quot;, null),
601                     (a) -&gt; assertCommand(a, &quot;int b;&quot;, null),
602                     (a) -&gt; assertCommand(a, &quot;int c;&quot;, null),
603                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
604                     (a) -&gt; assertCommandCheckOutput(a, &quot;/list b c a A&quot;, (out) -&gt;
605                                     output.addAll(Stream.of(out.split(&quot;\n&quot;))
606                             .filter(str -&gt; !str.isEmpty())
607                             .map(str -&gt; str.substring(str.indexOf(&#39;:&#39;) + 2))
608                             .filter(str -&gt; !str.startsWith(&quot;/&quot;))
609                             .collect(Collectors.toList()))),
610                     (a) -&gt; assertCommand(a, &quot;/save 2-3 1 4 &quot; + path.toString(), &quot;&quot;)
611             );
612             assertEquals(Files.readAllLines(path), output);
613         }
614         {
615             List&lt;String&gt; output = new ArrayList&lt;&gt;();
616             test(
617                     (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;a&quot;),
618                     (a) -&gt; assertCommand(a, &quot;()&quot;, null, null, null, &quot;&quot;, &quot;&quot;),
619                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
620                     (a) -&gt; assertCommandCheckOutput(a, &quot;/history&quot;, (out) -&gt;
621                                 output.addAll(Stream.of(out.split(&quot;\n&quot;))
622                             .filter(str -&gt; !str.isEmpty())
623                             .collect(Collectors.toList()))),
624                     (a) -&gt; assertCommand(a, &quot;/save -history &quot; + path.toString(), &quot;&quot;)
625             );
626             output.add(&quot;/save -history &quot; + path.toString());
627             assertEquals(Files.readAllLines(path), output);
628         }
629     }
630 
631     public void testStartRetain() {
632         Compiler compiler = new Compiler();
633         Path startUpFile = compiler.getPath(&quot;startUp.txt&quot;);
634         test(
635                 (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;a&quot;),
636                 (a) -&gt; assertVariable(a, &quot;double&quot;, &quot;b&quot;, &quot;10&quot;, &quot;10.0&quot;),
637                 (a) -&gt; assertMethod(a, &quot;void f() {}&quot;, &quot;()V&quot;, &quot;f&quot;),
638                 (a) -&gt; assertImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;),
639                 (a) -&gt; assertCommand(a, &quot;/save &quot; + startUpFile.toString(), null),
640                 (a) -&gt; assertCommand(a, &quot;/set start -retain &quot; + startUpFile.toString(), null)
641         );
642         Path unknown = compiler.getPath(&quot;UNKNOWN&quot;);
643         test(
644                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;/set start -retain &quot; + unknown.toString(),
645                         &quot;|  File &#39;&quot; + unknown + &quot;&#39; for &#39;/set start&#39; is not found.&quot;)
646         );
647         test(false, new String[0],
648                 (a) -&gt; {
649                     loadVariable(a, &quot;int&quot;, &quot;a&quot;);
650                     loadVariable(a, &quot;double&quot;, &quot;b&quot;, &quot;10.0&quot;, &quot;10.0&quot;);
651                     loadMethod(a, &quot;void f() {}&quot;, &quot;()void&quot;, &quot;f&quot;);
652                     loadImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;);
653                     assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses());
654                 },
655                 (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
656                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
657                 (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
658         );
659     }
660 
661     public void testStartSave() throws IOException {
662         Compiler compiler = new Compiler();
663         Path startSave = compiler.getPath(&quot;startSave.txt&quot;);
664         test(a -&gt; assertCommand(a, &quot;/save -start &quot; + startSave.toString(), null));
665         List&lt;String&gt; lines = Files.lines(startSave)
666                 .filter(s -&gt; !s.isEmpty())
667                 .collect(Collectors.toList());
668         assertEquals(lines, START_UP);
669     }
670 
671     public void testConstrainedUpdates() {
672         test(
673                 a -&gt; assertClass(a, &quot;class XYZZY { }&quot;, &quot;class&quot;, &quot;XYZZY&quot;),
674                 a -&gt; assertVariable(a, &quot;XYZZY&quot;, &quot;xyzzy&quot;),
675                 a -&gt; assertCommandCheckOutput(a, &quot;import java.util.stream.*&quot;,
676                         (out) -&gt; assertTrue(out.trim().isEmpty(), &quot;Expected no output, got: &quot; + out))
677         );
678     }
679 
680     public void testRemoteExit() {
681         test(
682                 a -&gt; assertVariable(a, &quot;int&quot;, &quot;x&quot;),
683                 a -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
684                 a -&gt; assertCommandOutputContains(a, &quot;System.exit(5);&quot;, &quot;terminated&quot;),
685                 a -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, s -&gt;
686                         assertTrue(s.trim().isEmpty(), s)),
687                 a -&gt; assertMethod(a, &quot;void f() { }&quot;, &quot;()void&quot;, &quot;f&quot;),
688                 a -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods())
689         );
690     }
691 
692     public void testFeedbackNegative() {
693         test(a -&gt; assertCommandCheckOutput(a, &quot;/set feedback aaaa&quot;,
694                 assertStartsWith(&quot;|  Does not match any current feedback mode&quot;)));
695     }
696 
697     public void testFeedbackSilent() {
698         for (String off : new String[]{&quot;s&quot;, &quot;silent&quot;}) {
699             test(
700                     a -&gt; assertCommand(a, &quot;/set feedback &quot; + off, &quot;&quot;),
701                     a -&gt; assertCommand(a, &quot;int a&quot;, &quot;&quot;),
702                     a -&gt; assertCommand(a, &quot;void f() {}&quot;, &quot;&quot;),
703                     a -&gt; assertCommandCheckOutput(a, &quot;aaaa&quot;, assertStartsWith(&quot;|  Error:&quot;)),
704                     a -&gt; assertCommandCheckOutput(a, &quot;static void f() {}&quot;, assertStartsWith(&quot;|  Warning:&quot;))
705             );
706         }
707     }
708 
709     public void testFeedbackNormal() {
710         Compiler compiler = new Compiler();
711         Path testNormalFile = compiler.getPath(&quot;testConciseNormal&quot;);
712         String[] sources = new String[] {&quot;int a&quot;, &quot;void f() {}&quot;, &quot;class A {}&quot;, &quot;a = 10&quot;};
713         String[] sources2 = new String[] {&quot;int a //again&quot;, &quot;void f() {int y = 4;}&quot;, &quot;class A {} //again&quot;, &quot;a = 10&quot;};
714         String[] output = new String[] {
715                 &quot;a ==&gt; 0&quot;,
716                 &quot;|  created method f()&quot;,
717                 &quot;|  created class A&quot;,
718                 &quot;a ==&gt; 10&quot;
719         };
720         compiler.writeToFile(testNormalFile, sources2);
721         for (String feedback : new String[]{&quot;/set fe&quot;, &quot;/set feedback&quot;}) {
722             for (String feedbackState : new String[]{&quot;n&quot;, &quot;normal&quot;}) {
723                 test(
724                         a -&gt; assertCommand(a, feedback + &quot; &quot; + feedbackState, &quot;|  Feedback mode: normal&quot;),
725                         a -&gt; assertCommand(a, sources[0], output[0]),
726                         a -&gt; assertCommand(a, sources[1], output[1]),
727                         a -&gt; assertCommand(a, sources[2], output[2]),
728                         a -&gt; assertCommand(a, sources[3], output[3]),
729                         a -&gt; assertCommand(a, &quot;/o &quot; + testNormalFile.toString(), &quot;&quot;)
730                 );
731             }
732         }
733     }
734 
735     public void testVarsWithNotActive() {
736         test(
737                 a -&gt; assertVariable(a, &quot;Blath&quot;, &quot;x&quot;),
738                 a -&gt; assertCommandOutputContains(a, &quot;/var -all&quot;, &quot;(not-active)&quot;)
739         );
740     }
741 
742     public void testHistoryReference() {
743         test(false, new String[]{&quot;--no-startup&quot;},
744                 a -&gt; assertCommand(a, &quot;System.err.println(99)&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;99\n&quot;),
745                 a -&gt; assertCommand(a, &quot;/exit&quot;, &quot;&quot;)
746         );
747         test(false, new String[]{&quot;--no-startup&quot;},
748                 a -&gt; assertCommand(a, &quot;System.err.println(1)&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;1\n&quot;),
749                 a -&gt; assertCommand(a, &quot;System.err.println(2)&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
750                 a -&gt; assertCommand(a, &quot;/-2&quot;, &quot;System.err.println(1)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;1\n&quot;),
751                 a -&gt; assertCommand(a, &quot;/history&quot;,
752                                                     &quot;/debug 0\n&quot; +
753                                                     &quot;System.err.println(1)\n&quot; +
754                                                     &quot;System.err.println(2)\n&quot; +
755                                                     &quot;System.err.println(1)\n&quot; +
756                                                     &quot;/history\n&quot;),
757                 a -&gt; assertCommand(a, &quot;/history -all&quot;,
758                                                     &quot;/debug 0\n&quot; +
759                                                     &quot;System.err.println(99)\n&quot; +
760                                                     &quot;/exit\n&quot; +
761                                                     &quot;/debug 0\n&quot; +
762                                                     &quot;System.err.println(1)\n&quot; +
763                                                     &quot;System.err.println(2)\n&quot; +
764                                                     &quot;System.err.println(1)\n&quot; +
765                                                     &quot;/history\n&quot; +
766                                                     &quot;/history -all\n&quot;),
767                 a -&gt; assertCommand(a, &quot;/-2&quot;, &quot;System.err.println(2)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
768                 a -&gt; assertCommand(a, &quot;/!&quot;, &quot;System.err.println(2)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
769                 a -&gt; assertCommand(a, &quot;/2&quot;, &quot;System.err.println(2)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
770                 a -&gt; assertCommand(a, &quot;/1&quot;, &quot;System.err.println(1)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;1\n&quot;)
771         );
772     }
773 
774     public void testRerunIdRange() {
775         Compiler compiler = new Compiler();
776         Path startup = compiler.getPath(&quot;rangeStartup&quot;);
777         String[] startupSources = new String[] {
778             &quot;boolean go = false&quot;,
779             &quot;void println(String s) { if (go) System.out.println(s); }&quot;,
780             &quot;void println(int i) { if (go) System.out.println(i); }&quot;,
781             &quot;println(\&quot;s4\&quot;)&quot;,
782             &quot;println(\&quot;s5\&quot;)&quot;,
783             &quot;println(\&quot;s6\&quot;)&quot;
784         };
785         String[] sources = new String[] {
786             &quot;frog&quot;,
787             &quot;go = true&quot;,
788             &quot;println(2)&quot;,
789             &quot;println(3)&quot;,
790             &quot;println(4)&quot;,
791             &quot;querty&quot;
792         };
793         compiler.writeToFile(startup, startupSources);
794         test(false, new String[]{&quot;--startup&quot;, startup.toString()},
795                 a -&gt; assertCommandOutputStartsWith(a, sources[0], &quot;|  Error:&quot;),
796                 a -&gt; assertCommand(a, sources[1], &quot;go ==&gt; true&quot;, &quot;&quot;, null, &quot;&quot;, &quot;&quot;),
797                 a -&gt; assertCommand(a, sources[2], &quot;&quot;, &quot;&quot;, null, &quot;2\n&quot;, &quot;&quot;),
798                 a -&gt; assertCommand(a, sources[3], &quot;&quot;, &quot;&quot;, null, &quot;3\n&quot;, &quot;&quot;),
799                 a -&gt; assertCommand(a, sources[4], &quot;&quot;, &quot;&quot;, null, &quot;4\n&quot;, &quot;&quot;),
800                 a -&gt; assertCommandOutputStartsWith(a, sources[5], &quot;|  Error:&quot;),
801                 a -&gt; assertCommand(a, &quot;/3&quot;, &quot;println(3)&quot;, &quot;&quot;, null, &quot;3\n&quot;, &quot;&quot;),
802                 a -&gt; assertCommand(a, &quot;/s4&quot;, &quot;println(\&quot;s4\&quot;)&quot;, &quot;&quot;, null, &quot;s4\n&quot;, &quot;&quot;),
803                 a -&gt; assertCommandOutputStartsWith(a, &quot;/e1&quot;, &quot;frog\n|  Error:&quot;),
804                 a -&gt; assertCommand(a, &quot;/2-4&quot;,
805                         &quot;println(2)\nprintln(3)\nprintln(4)&quot;,
806                         &quot;&quot;, null, &quot;2\n3\n4\n&quot;, &quot;&quot;),
807                 a -&gt; assertCommand(a, &quot;/s4-s6&quot;,
808                         startupSources[3] + &quot;\n&quot; +startupSources[4] + &quot;\n&quot; +startupSources[5],
809                         &quot;&quot;, null, &quot;s4\ns5\ns6\n&quot;, &quot;&quot;),
810                 a -&gt; assertCommand(a, &quot;/s4-4&quot;, null,
811                         &quot;&quot;, null, &quot;s4\ns5\ns6\n2\n3\n4\n&quot;, &quot;&quot;),
812                 a -&gt; assertCommandCheckOutput(a, &quot;/e1-e2&quot;,
813                         s -&gt; {
814                             assertTrue(s.trim().startsWith(&quot;frog\n|  Error:&quot;),
815                                     &quot;Output: \&#39;&quot; + s + &quot;&#39; does not start with: &quot; + &quot;|  Error:&quot;);
816                             assertTrue(s.trim().lastIndexOf(&quot;|  Error:&quot;) &gt; 10,
817                                     &quot;Output: \&#39;&quot; + s + &quot;&#39; does not have second: &quot; + &quot;|  Error:&quot;);
818                         }),
819                 a -&gt; assertCommand(a, &quot;/4  s4 2&quot;,
820                         &quot;println(4)\nprintln(\&quot;s4\&quot;)\nprintln(2)&quot;,
821                         &quot;&quot;, null, &quot;4\ns4\n2\n&quot;, &quot;&quot;),
822                 a -&gt; assertCommand(a, &quot;/s5 2-4 3&quot;,
823                         &quot;println(\&quot;s5\&quot;)\nprintln(2)\nprintln(3)\nprintln(4)\nprintln(3)&quot;,
824                         &quot;&quot;, null, &quot;s5\n2\n3\n4\n3\n&quot;, &quot;&quot;),
825                 a -&gt; assertCommand(a, &quot;/2 ff&quot;, &quot;|  No such snippet: ff&quot;),
826                 a -&gt; assertCommand(a, &quot;/4-2&quot;, &quot;|  End of snippet range less than start: 4 - 2&quot;),
827                 a -&gt; assertCommand(a, &quot;/s5-s3&quot;, &quot;|  End of snippet range less than start: s5 - s3&quot;),
828                 a -&gt; assertCommand(a, &quot;/4-s5&quot;, &quot;|  End of snippet range less than start: 4 - s5&quot;)
829         );
830     }
831 
832     @Test(enabled = false) // TODO 8158197
833     public void testHeadlessEditPad() {
834         String prevHeadless = System.getProperty(&quot;java.awt.headless&quot;);
835         try {
836             System.setProperty(&quot;java.awt.headless&quot;, &quot;true&quot;);
837             test(
838                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;/edit printf&quot;, &quot;|  Cannot launch editor -- unexpected exception:&quot;)
839             );
840         } finally {
841             System.setProperty(&quot;java.awt.headless&quot;, prevHeadless==null? &quot;false&quot; : prevHeadless);
842         }
843     }
844 
845     public void testAddExports() {
846         test(false, new String[]{&quot;--no-startup&quot;},
847                 a -&gt; assertCommandOutputStartsWith(a, &quot;import jdk.internal.misc.VM;&quot;, &quot;|  Error:&quot;)
848         );
849         test(false, new String[]{&quot;--no-startup&quot;,
850                         &quot;-R--add-exports&quot;, &quot;-Rjava.base/jdk.internal.misc=ALL-UNNAMED&quot;,
851                         &quot;-C--add-exports&quot;, &quot;-Cjava.base/jdk.internal.misc=ALL-UNNAMED&quot;},
852                 a -&gt; assertImport(a, &quot;import jdk.internal.misc.VM;&quot;, &quot;&quot;, &quot;jdk.internal.misc.VM&quot;),
853                 a -&gt; assertCommand(a, &quot;System.err.println(VM.isBooted())&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;true\n&quot;)
854         );
855         test(false, new String[]{&quot;--no-startup&quot;, &quot;--add-exports&quot;, &quot;java.base/jdk.internal.misc&quot;},
856                 a -&gt; assertImport(a, &quot;import jdk.internal.misc.VM;&quot;, &quot;&quot;, &quot;jdk.internal.misc.VM&quot;),
857                 a -&gt; assertCommand(a, &quot;System.err.println(VM.isBooted())&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;true\n&quot;)
858         );
859     }
860 
861     public void testRedeclareVariableNoInit() {
862         test(
863                 a -&gt; assertCommand(a, &quot;Integer a;&quot;, &quot;a ==&gt; null&quot;),
864                 a -&gt; assertCommand(a, &quot;a instanceof Integer;&quot;, &quot;$2 ==&gt; false&quot;),
865                 a -&gt; assertCommand(a, &quot;a = 1;&quot;, &quot;a ==&gt; 1&quot;),
866                 a -&gt; assertCommand(a, &quot;Integer a;&quot;, &quot;a ==&gt; null&quot;),
867                 a -&gt; assertCommand(a, &quot;a instanceof Integer;&quot;, &quot;$5 ==&gt; false&quot;),
868                 a -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; null&quot;)
869         );
870      }
871 
872     public void testWarningUnchecked() { //8223688
873         test(false, new String[]{&quot;--no-startup&quot;},
874                 a -&gt; assertCommand(a, &quot;abstract class A&lt;T&gt; { A(T t){} }&quot;, &quot;|  created class A&quot;),
875                 a -&gt; assertCommandCheckOutput(a, &quot;new A(\&quot;\&quot;) {}&quot;, s -&gt; {
876                             assertStartsWith(&quot;|  Warning:&quot;);
877                             assertTrue(s.contains(&quot;unchecked call&quot;));
878                             assertFalse(s.contains(&quot;Exception&quot;));
879                         })
880         );
881     }
882 
883 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/jdk/jshell/ToolBasicTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8143037 8142447 8144095 8140265 8144906 8146138 8147887 8147886 8148316 8148317 8143955 8157953 8080347 8154714 8166649 8167643 8170162 8172102 8165405 8174796 8174797 8175304 8167554 8180508 8166232 8196133 8199912 8211694 8223688
 27  * @summary Tests for Basic tests for REPL tool
 28  * @modules jdk.compiler/com.sun.tools.javac.api
 29  *          jdk.compiler/com.sun.tools.javac.main
 30  *          jdk.jdeps/com.sun.tools.javap
 31  *          jdk.jshell/jdk.internal.jshell.tool
 32  * @library /tools/lib
 33  * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask
 34  * @build KullaTesting TestingInputStream Compiler
 35  * @run testng/timeout=600 ToolBasicTest
 36  * @key intermittent
 37  */
 38 
 39 import java.io.File;
 40 import java.io.IOException;
 41 import java.io.PrintWriter;
 42 import java.io.StringWriter;
 43 import java.net.InetAddress;
 44 import java.net.InetSocketAddress;
 45 import java.nio.file.Files;
 46 import java.nio.file.Path;
 47 import java.nio.file.Paths;
 48 import java.util.ArrayList;
 49 import java.util.Arrays;
 50 import java.util.List;
 51 import java.util.Scanner;
 52 import java.util.function.BiFunction;
 53 import java.util.function.Consumer;
 54 import java.util.function.Function;
 55 import java.util.stream.Collectors;
 56 import java.util.stream.Stream;
 57 
 58 import com.sun.net.httpserver.HttpServer;
 59 import org.testng.annotations.Test;
 60 
 61 import static org.testng.Assert.assertEquals;
 62 import static org.testng.Assert.assertTrue;
 63 import static org.testng.Assert.assertFalse;
 64 import static org.testng.Assert.fail;
 65 
 66 @Test
 67 public class ToolBasicTest extends ReplToolTesting {
 68 
 69     public void elideStartUpFromList() {
 70         test(
 71                 (a) -&gt; assertCommandOutputContains(a, &quot;123&quot;, &quot;==&gt; 123&quot;),
 72                 (a) -&gt; assertCommandCheckOutput(a, &quot;/list&quot;, (s) -&gt; {
 73                     int cnt;
 74                     try (Scanner scanner = new Scanner(s)) {
 75                         cnt = 0;
 76                         while (scanner.hasNextLine()) {
 77                             String line = scanner.nextLine();
 78                             if (!line.trim().isEmpty()) {
 79                                 ++cnt;
 80                             }
 81                         }
 82                     }
 83                     assertEquals(cnt, 1, &quot;Expected only one listed line&quot;);
 84                 })
 85         );
 86     }
 87 
 88     public void elideStartUpFromSave() throws IOException {
 89         Compiler compiler = new Compiler();
 90         Path path = compiler.getPath(&quot;myfile&quot;);
 91         test(
 92                 (a) -&gt; assertCommandOutputContains(a, &quot;123&quot;, &quot;==&gt; 123&quot;),
 93                 (a) -&gt; assertCommand(a, &quot;/save &quot; + path.toString(), &quot;&quot;)
 94         );
 95         try (Stream&lt;String&gt; lines = Files.lines(path)) {
 96             assertEquals(lines.count(), 1, &quot;Expected only one saved line&quot;);
 97         }
 98     }
 99 
100     public void testInterrupt() {
101         ReplTest interrupt = (a) -&gt; assertCommand(a, &quot;\u0003&quot;, &quot;&quot;);
102         for (String s : new String[] { &quot;&quot;, &quot;\u0003&quot; }) {
103             test(false, new String[]{&quot;--no-startup&quot;},
104                     (a) -&gt; assertCommand(a, &quot;int a = 2 +&quot; + s, &quot;&quot;),
105                     interrupt,
106                     (a) -&gt; assertCommand(a, &quot;int a\u0003&quot;, &quot;&quot;),
107                     (a) -&gt; assertCommand(a, &quot;int a = 2 + 2\u0003&quot;, &quot;&quot;),
108                     (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
109                     (a) -&gt; evaluateExpression(a, &quot;int&quot;, &quot;2&quot;, &quot;2&quot;),
110                     (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
111                     (a) -&gt; assertCommand(a, &quot;void f() {&quot;, &quot;&quot;),
112                     (a) -&gt; assertCommand(a, &quot;int q = 10;&quot; + s, &quot;&quot;),
113                     interrupt,
114                     (a) -&gt; assertCommand(a, &quot;void f() {}\u0003&quot;, &quot;&quot;),
115                     (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
116                     (a) -&gt; assertMethod(a, &quot;int f() { return 0; }&quot;, &quot;()int&quot;, &quot;f&quot;),
117                     (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
118                     (a) -&gt; assertCommand(a, &quot;class A {&quot; + s, &quot;&quot;),
119                     interrupt,
120                     (a) -&gt; assertCommand(a, &quot;class A {}\u0003&quot;, &quot;&quot;),
121                     (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
122                     (a) -&gt; assertClass(a, &quot;interface A {}&quot;, &quot;interface&quot;, &quot;A&quot;),
123                     (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
124                     (a) -&gt; assertCommand(a, &quot;import java.util.stream.&quot; + s, &quot;&quot;),
125                     interrupt,
126                     (a) -&gt; assertCommand(a, &quot;import java.util.stream.\u0003&quot;, &quot;&quot;),
127                     (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports()),
128                     (a) -&gt; assertImport(a, &quot;import java.util.stream.Stream&quot;, &quot;&quot;, &quot;java.util.stream.Stream&quot;),
129                     (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
130             );
131         }
132     }
133 
134     public void testCtrlD() {
135         test(false, new String[]{&quot;--no-startup&quot;},
136                 a -&gt; {
137                     if (!a) {
138                         closeCommandInput();
139                     } else {
140                         throw new IllegalStateException();
141                     }
142                 }
143         );
144     }
145 
146     private final Object lock = new Object();
147     private PrintWriter out;
148     private boolean isStopped;
149     private Thread t;
150     private void assertStop(boolean after, String cmd, String output) {
151         if (!after) {
152             isStopped = false;
153             StringWriter writer = new StringWriter();
154             out = new PrintWriter(writer);
155             setCommandInput(cmd + &quot;\n&quot;);
156             t = new Thread(() -&gt; {
157                 try {
158                     // no chance to know whether cmd is being evaluated
159                     Thread.sleep(5000);
160                 } catch (InterruptedException ignored) {
161                 }
162                 int i = 1;
163                 int n = 30;
164                 synchronized (lock) {
165                     do {
166                         setCommandInput(&quot;\u0003&quot;);
167                         if (!isStopped) {
168                             out.println(&quot;Not stopped. Try again: &quot; + i);
169                             try {
170                                 lock.wait(1000);
171                             } catch (InterruptedException ignored) {
172                             }
173                         }
174                     } while (i++ &lt; n &amp;&amp; !isStopped);
175                     if (!isStopped) {
176                         System.err.println(writer.toString());
177                         fail(&quot;Evaluation was not stopped: &#39;&quot; + cmd + &quot;&#39;&quot;);
178                     }
179                 }
180             });
181             t.start();
182         } else {
183             synchronized (lock)  {
184                 out.println(&quot;Evaluation was stopped successfully: &#39;&quot; + cmd + &quot;&#39;&quot;);
185                 isStopped = true;
186                 lock.notify();
187             }
188             try {
189                 t.join();
190                 t = null;
191             } catch (InterruptedException ignored) {
192             }
193             assertOutput(getCommandOutput(), &quot;&quot;, &quot;command&quot;);
194             assertOutput(getCommandErrorOutput(), &quot;&quot;, &quot;command error&quot;);
195             assertOutput(getUserOutput().trim(), output, &quot;user&quot;);
196             assertOutput(getUserErrorOutput(), &quot;&quot;, &quot;user error&quot;);
197         }
198     }
199 
200     public void testStop() {
201         test(
202                 (a) -&gt; assertStop(a, &quot;while (true) {}&quot;, &quot;&quot;),
203                 (a) -&gt; assertStop(a, &quot;while (true) { try { Thread.sleep(100); } catch (InterruptedException ex) { } }&quot;, &quot;&quot;)
204         );
205     }
206 
207     public void testRerun() {
208         test(false, new String[] {&quot;--no-startup&quot;},
209                 (a) -&gt; assertCommand(a, &quot;/0&quot;, &quot;|  No snippet with ID: 0&quot;),
210                 (a) -&gt; assertCommand(a, &quot;/5&quot;, &quot;|  No snippet with ID: 5&quot;)
211         );
212         String[] codes = new String[] {
213                 &quot;int a = 0;&quot;, // var
214                 &quot;class A {}&quot;, // class
215                 &quot;void f() {}&quot;, // method
216                 &quot;bool b;&quot;, // active failed
217                 &quot;void g() { h(); }&quot;, // active corralled
218         };
219         List&lt;ReplTest&gt; tests = new ArrayList&lt;&gt;();
220         for (String s : codes) {
221             tests.add((a) -&gt; assertCommand(a, s, null));
222         }
223         // Test /1 through /5 -- assure references are correct
224         for (int i = 0; i &lt; codes.length; ++i) {
225             final int finalI = i;
226             Consumer&lt;String&gt; check = (s) -&gt; {
227                 String[] ss = s.split(&quot;\n&quot;);
228                 assertEquals(ss[0], codes[finalI]);
229                 assertTrue(ss.length &gt; 1, s);
230             };
231             tests.add((a) -&gt; assertCommandCheckOutput(a, &quot;/&quot; + (finalI + 1), check));
232         }
233         // Test /-1 ... note that the snippets added by history must be stepped over
234         for (int i = 0; i &lt; codes.length; ++i) {
235             final int finalI = i;
236             Consumer&lt;String&gt; check = (s) -&gt; {
237                 String[] ss = s.split(&quot;\n&quot;);
238                 assertEquals(ss[0], codes[codes.length - finalI - 1]);
239                 assertTrue(ss.length &gt; 1, s);
240             };
241             tests.add((a) -&gt; assertCommandCheckOutput(a, &quot;/-&quot; + (2 * finalI + 1), check));
242         }
243         tests.add((a) -&gt; assertCommandCheckOutput(a, &quot;/!&quot;, assertStartsWith(&quot;int a = 0;&quot;)));
244         test(false, new String[]{&quot;--no-startup&quot;},
245                 tests.toArray(new ReplTest[tests.size()]));
246     }
247 
248     public void test8142447() {
249         Function&lt;String, BiFunction&lt;String, Integer, ReplTest&gt;&gt; assertRerun = cmd -&gt; (code, assertionCount) -&gt;
250                 (a) -&gt; assertCommandCheckOutput(a, cmd, s -&gt; {
251                             String[] ss = s.split(&quot;\n&quot;);
252                             assertEquals(ss[0], code);
253                             loadVariable(a, &quot;int&quot;, &quot;assertionCount&quot;, Integer.toString(assertionCount), Integer.toString(assertionCount));
254                         });
255         ReplTest assertVariables = (a) -&gt; assertCommandCheckOutput(a, &quot;/v&quot;, assertVariables());
256 
257         Compiler compiler = new Compiler();
258         Path startup = compiler.getPath(&quot;StartupFileOption/startup.txt&quot;);
259         compiler.writeToFile(startup, &quot;int assertionCount = 0;\n&quot; + // id: s1
260                 &quot;void add(int n) { assertionCount += n; }&quot;);
261         test(new String[]{&quot;--startup&quot;, startup.toString()},
262                 (a) -&gt; assertCommand(a, &quot;add(1)&quot;, &quot;&quot;), // id: 1
263                 (a) -&gt; assertCommandCheckOutput(a, &quot;add(ONE)&quot;, s -&gt; assertEquals(s.split(&quot;\n&quot;)[0], &quot;|  Error:&quot;)), // id: e1
264                 (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;ONE&quot;, &quot;1&quot;, &quot;1&quot;),
265                 assertRerun.apply(&quot;/1&quot;).apply(&quot;add(1)&quot;, 2), assertVariables,
266                 assertRerun.apply(&quot;/e1&quot;).apply(&quot;add(ONE)&quot;, 3), assertVariables,
267                 assertRerun.apply(&quot;/s1&quot;).apply(&quot;int assertionCount = 0;&quot;, 0), assertVariables
268         );
269 
270         test(false, new String[] {&quot;--no-startup&quot;},
271                 (a) -&gt; assertCommand(a, &quot;/s1&quot;, &quot;|  No snippet with ID: s1&quot;),
272                 (a) -&gt; assertCommand(a, &quot;/1&quot;, &quot;|  No snippet with ID: 1&quot;),
273                 (a) -&gt; assertCommand(a, &quot;/e1&quot;, &quot;|  No snippet with ID: e1&quot;)
274         );
275     }
276 
277     public void testClasspathDirectory() {
278         Compiler compiler = new Compiler();
279         Path outDir = Paths.get(&quot;testClasspathDirectory&quot;);
280         compiler.compile(outDir, &quot;package pkg; public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
281         Path classpath = compiler.getPath(outDir);
282         test(
283                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + classpath,
284                         &quot;|  Setting new options and restoring state.&quot;),
285                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
286         );
287         test(new String[] { &quot;--class-path&quot;, classpath.toString() },
288                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
289         );
290     }
291 
292     public void testEnvInStartUp() {
293         Compiler compiler = new Compiler();
294         Path outDir = Paths.get(&quot;testClasspathDirectory&quot;);
295         compiler.compile(outDir, &quot;package pkg; public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
296         Path classpath = compiler.getPath(outDir);
297         Path sup = compiler.getPath(&quot;startup.jsh&quot;);
298         compiler.writeToFile(sup,
299                 &quot;int xxx;\n&quot; +
300                 &quot;/env -class-path &quot; + classpath + &quot;\n&quot; +
301                 &quot;int aaa = 735;\n&quot;
302         );
303         test(
304                 (a) -&gt; assertCommand(a, &quot;/set start -retain &quot; + sup, &quot;&quot;),
305                 (a) -&gt; assertCommand(a, &quot;/reset&quot;,
306                         &quot;|  Resetting state.&quot;),
307                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;),
308                 (a) -&gt; assertCommand(a, &quot;aaa&quot;, &quot;aaa ==&gt; 735&quot;)
309         );
310         test(
311                 (a) -&gt; assertCommandOutputContains(a, &quot;/env&quot;, &quot;--class-path&quot;),
312                 (a) -&gt; assertCommandOutputContains(a, &quot;xxx&quot;, &quot;cannot find symbol&quot;, &quot;variable xxx&quot;),
313                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;),
314                 (a) -&gt; assertCommand(a, &quot;aaa&quot;, &quot;aaa ==&gt; 735&quot;)
315         );
316     }
317 
318     private String makeSimpleJar() {
319         Compiler compiler = new Compiler();
320         Path outDir = Paths.get(&quot;testClasspathJar&quot;);
321         compiler.compile(outDir, &quot;package pkg; public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
322         String jarName = &quot;test.jar&quot;;
323         compiler.jar(outDir, jarName, &quot;pkg/A.class&quot;);
324         return compiler.getPath(outDir).resolve(jarName).toString();
325     }
326 
327     public void testClasspathJar() {
328         String jarPath = makeSimpleJar();
329         test(
330                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath,
331                         &quot;|  Setting new options and restoring state.&quot;),
332                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
333         );
334         test(new String[] { &quot;--class-path&quot;, jarPath },
335                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
336         );
337     }
338 
339     public void testClasspathUserHomeExpansion() {
340         String jarPath = makeSimpleJar();
341         String tilde = &quot;~&quot; + File.separator;
342         test(
343                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + tilde + &quot;forblato&quot;,
344                         &quot;|  File &#39;&quot; + Paths.get(System.getProperty(&quot;user.home&quot;), &quot;forblato&quot;).toString()
345                                 + &quot;&#39; for &#39;--class-path&#39; is not found.&quot;),
346                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath + File.pathSeparator
347                                                             + tilde + &quot;forblato&quot;,
348                         &quot;|  File &#39;&quot; + Paths.get(System.getProperty(&quot;user.home&quot;), &quot;forblato&quot;).toString()
349                                 + &quot;&#39; for &#39;--class-path&#39; is not found.&quot;)
350         );
351     }
352 
353     public void testBadClasspath() {
354         String jarPath = makeSimpleJar();
355         Compiler compiler = new Compiler();
356         Path t1 = compiler.getPath(&quot;whatever/thing.zip&quot;);
357         compiler.writeToFile(t1, &quot;&quot;);
358         Path t2 = compiler.getPath(&quot;whatever/thing.jmod&quot;);
359         compiler.writeToFile(t2, &quot;&quot;);
360         test(
361                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + t1.toString(),
362                         &quot;|  Invalid &#39;--class-path&#39; argument: &quot; + t1.toString()),
363                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath + File.pathSeparator + t1.toString(),
364                         &quot;|  Invalid &#39;--class-path&#39; argument: &quot; + t1.toString()),
365                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + t2.toString(),
366                         &quot;|  Invalid &#39;--class-path&#39; argument: &quot; + t2.toString())
367         );
368     }
369 
370     private String makeBadSourceJar() {
371         Compiler compiler = new Compiler();
372         Path outDir = Paths.get(&quot;testClasspathJar&quot;);
373         Path src = compiler.getPath(outDir.resolve(&quot;pkg/A.java&quot;));
374         compiler.writeToFile(src, &quot;package pkg; /** \u0086 */public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
375         String jarName = &quot;test.jar&quot;;
376         compiler.jar(outDir, jarName, &quot;pkg/A.java&quot;);
377         return compiler.getPath(outDir).resolve(jarName).toString();
378     }
379 
380     public void testBadSourceJarClasspath() {
381         String jarPath = makeBadSourceJar();
382         test(
383                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath,
384                         &quot;|  Setting new options and restoring state.&quot;),
385                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;new pkg.A();&quot;,
386                         &quot;|  Error:\n&quot;
387                         + &quot;|  cannot find symbol\n&quot;
388                         + &quot;|    symbol:   class A&quot;)
389         );
390         test(new String[]{&quot;--class-path&quot;, jarPath},
391                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;new pkg.A();&quot;,
392                         &quot;|  Error:\n&quot;
393                         + &quot;|  cannot find symbol\n&quot;
394                         + &quot;|    symbol:   class A&quot;)
395         );
396     }
397 
398     public void testModulePath() {
399         Compiler compiler = new Compiler();
400         Path modsDir = Paths.get(&quot;mods&quot;);
401         Path outDir = Paths.get(&quot;mods&quot;, &quot;org.astro&quot;);
402         compiler.compile(outDir, &quot;package org.astro; public class World { public static String name() { return \&quot;world\&quot;; } }&quot;);
403         compiler.compile(outDir, &quot;module org.astro { exports org.astro; }&quot;);
404         Path modsPath = compiler.getPath(modsDir);
405         test(new String[] { &quot;--module-path&quot;, modsPath.toString(), &quot;--add-modules&quot;, &quot;org.astro&quot; },
406                 (a) -&gt; assertCommand(a, &quot;import org.astro.World;&quot;, &quot;&quot;),
407                 (a) -&gt; evaluateExpression(a, &quot;String&quot;,
408                         &quot;String.format(\&quot;Greetings %s!\&quot;, World.name());&quot;,
409                         &quot;\&quot;Greetings world!\&quot;&quot;)
410         );
411     }
412 
413     public void testModulePathUserHomeExpansion() {
414         String tilde = &quot;~&quot; + File.separatorChar;
415         test(
416                 (a) -&gt; assertCommand(a, &quot;/env --module-path &quot; + tilde + &quot;snardugol&quot;,
417                         &quot;|  File &#39;&quot; + Paths.get(System.getProperty(&quot;user.home&quot;), &quot;snardugol&quot;).toString()
418                                 + &quot;&#39; for &#39;--module-path&#39; is not found.&quot;)
419         );
420     }
421 
422     public void testBadModulePath() {
423         Compiler compiler = new Compiler();
424         Path t1 = compiler.getPath(&quot;whatever/thing.zip&quot;);
425         compiler.writeToFile(t1, &quot;&quot;);
426         test(
427                 (a) -&gt; assertCommand(a, &quot;/env --module-path &quot; + t1.toString(),
428                         &quot;|  Invalid &#39;--module-path&#39; argument: &quot; + t1.toString())
429         );
430     }
431 
432     public void testStartupFileOption() {
433         Compiler compiler = new Compiler();
434         Path startup = compiler.getPath(&quot;StartupFileOption/startup.txt&quot;);
435         compiler.writeToFile(startup, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
436         test(new String[]{&quot;--startup&quot;, startup.toString()},
437                 (a) -&gt; evaluateExpression(a, &quot;A&quot;, &quot;new A()&quot;, &quot;A&quot;)
438         );
439         test(new String[]{&quot;--no-startup&quot;},
440                 (a) -&gt; assertCommandCheckOutput(a, &quot;Pattern.compile(\&quot;x+\&quot;)&quot;, assertStartsWith(&quot;|  Error:\n|  cannot find symbol&quot;))
441         );
442         test(
443                 (a) -&gt; assertCommand(a, &quot;Pattern.compile(\&quot;x+\&quot;)&quot;, &quot;$1 ==&gt; x+&quot;, &quot;&quot;, null, &quot;&quot;, &quot;&quot;)
444         );
445     }
446 
447     public void testLoadingFromArgs() {
448         Compiler compiler = new Compiler();
449         Path path = compiler.getPath(&quot;loading.repl&quot;);
450         compiler.writeToFile(path, &quot;int a = 10; double x = 20; double a = 10;&quot;);
451         test(new String[] { path.toString() },
452                 (a) -&gt; assertCommand(a, &quot;x&quot;, &quot;x ==&gt; 20.0&quot;),
453                 (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10.0&quot;)
454         );
455     }
456 
457     public void testReset() {
458         test(
459                 (a) -&gt; assertReset(a, &quot;/res&quot;),
460                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
461                 (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;x&quot;),
462                 (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
463                 (a) -&gt; assertMethod(a, &quot;void f() { }&quot;, &quot;()void&quot;, &quot;f&quot;),
464                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
465                 (a) -&gt; assertClass(a, &quot;class A { }&quot;, &quot;class&quot;, &quot;A&quot;),
466                 (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
467                 (a) -&gt; assertImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;),
468                 (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports()),
469                 (a) -&gt; assertReset(a, &quot;/reset&quot;),
470                 (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
471                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
472                 (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
473                 (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
474         );
475     }
476 
477     public void testOpen() {
478         Compiler compiler = new Compiler();
479         Path path = compiler.getPath(&quot;testOpen.repl&quot;);
480         compiler.writeToFile(path,
481                 &quot;int a = 10;\ndouble x = 20;\ndouble a = 10;\n&quot; +
482                         &quot;class A { public String toString() { return \&quot;A\&quot;; } }\nimport java.util.stream.*;&quot;);
483         for (String s : new String[]{&quot;/o&quot;, &quot;/open&quot;}) {
484             test(
485                     (a) -&gt; assertCommand(a, s + &quot; &quot; + path.toString(), &quot;&quot;),
486                     (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10.0&quot;),
487                     (a) -&gt; evaluateExpression(a, &quot;A&quot;, &quot;new A();&quot;, &quot;A&quot;),
488                     (a) -&gt; evaluateExpression(a, &quot;long&quot;, &quot;Stream.of(\&quot;A\&quot;).count();&quot;, &quot;1&quot;),
489                     (a) -&gt; {
490                         loadVariable(a, &quot;double&quot;, &quot;x&quot;, &quot;20.0&quot;, &quot;20.0&quot;);
491                         loadVariable(a, &quot;double&quot;, &quot;a&quot;, &quot;10.0&quot;, &quot;10.0&quot;);
492                         loadVariable(a, &quot;A&quot;, &quot;$7&quot;, &quot;new A();&quot;, &quot;A&quot;);
493                         loadVariable(a, &quot;long&quot;, &quot;$8&quot;, &quot;Stream.of(\&quot;A\&quot;).count();&quot;, &quot;1&quot;);
494                         loadClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;,
495                                 &quot;class&quot;, &quot;A&quot;);
496                         loadImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;);
497                         assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses());
498                     },
499                     (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
500                     (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
501                     (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
502             );
503             Path unknown = compiler.getPath(&quot;UNKNOWN.repl&quot;);
504             test(
505                     (a) -&gt; assertCommand(a, s + &quot; &quot; + unknown,
506                             &quot;|  File &#39;&quot; + unknown + &quot;&#39; for &#39;/open&#39; is not found.&quot;)
507             );
508         }
509     }
510 
511     public void testOpenLocalFileUrl() {
512         Compiler compiler = new Compiler();
513         Path path = compiler.getPath(&quot;testOpen.repl&quot;);
514         compiler.writeToFile(path, &quot;int a = 10;int b = 20;int c = a + b;\n&quot;);
515         for (String s : new String[]{&quot;/o&quot;, &quot;/open&quot;}) {
516             test(
517                     (a) -&gt; assertCommand(a, s + &quot; &quot; + path.toUri(), &quot;&quot;),
518                     (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10&quot;),
519                     (a) -&gt; assertCommand(a, &quot;b&quot;, &quot;b ==&gt; 20&quot;),
520                     (a) -&gt; assertCommand(a, &quot;c&quot;, &quot;c ==&gt; 30&quot;)
521             );
522         }
523     }
524 
525     public void testOpenFileOverHttp() throws IOException {
526         var script = &quot;int a = 10;int b = 20;int c = a + b;&quot;;
527 
528         var localhostAddress = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), 0);
529         var httpServer = HttpServer.create(localhostAddress, 0);
530         try {
531             httpServer.createContext(&quot;/script&quot;, exchange -&gt; {
532                 exchange.sendResponseHeaders(200, script.length());
533                 try (var output = exchange.getResponseBody()) {
534                     output.write(script.getBytes());
535                 }
536             });
537             httpServer.setExecutor(null);
538             httpServer.start();
539 
540             var urlAddress = &quot;http:/&quot; + httpServer.getAddress().toString() + &quot;/script&quot;;
541             for (String s : new String[]{&quot;/o&quot;, &quot;/open&quot;}) {
542                 test(
543                         (a) -&gt; assertCommand(a, s + &quot; &quot; + urlAddress, &quot;&quot;),
544                         (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10&quot;),
545                         (a) -&gt; assertCommand(a, &quot;b&quot;, &quot;b ==&gt; 20&quot;),
546                         (a) -&gt; assertCommand(a, &quot;c&quot;, &quot;c ==&gt; 30&quot;)
547                 );
548             }
549         } finally {
550             httpServer.stop(0);
551         }
552     }
553 
554     public void testOpenResource() {
555         test(
556                 (a) -&gt; assertCommand(a, &quot;/open PRINTING&quot;, &quot;&quot;),
557                 (a) -&gt; assertCommandOutputContains(a, &quot;/list&quot;,
558                         &quot;void println&quot;, &quot;System.out.printf&quot;),
559                 (a) -&gt; assertCommand(a, &quot;printf(\&quot;%4.2f\&quot;, Math.PI)&quot;,
560                         &quot;&quot;, &quot;&quot;, null, &quot;3.14&quot;, &quot;&quot;)
561         );
562     }
563 
564     public void testSave() throws IOException {
565         Compiler compiler = new Compiler();
566         Path path = compiler.getPath(&quot;testSave.repl&quot;);
567         {
568             List&lt;String&gt; list = Arrays.asList(
569                     &quot;int a;&quot;,
570                     &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;
571             );
572             test(
573                     (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;a&quot;),
574                     (a) -&gt; assertCommand(a, &quot;()&quot;, null, null, null, &quot;&quot;, &quot;&quot;),
575                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
576                     (a) -&gt; assertCommand(a, &quot;/save &quot; + path.toString(), &quot;&quot;)
577             );
578             assertEquals(Files.readAllLines(path), list);
579         }
580         {
581             List&lt;String&gt; output = new ArrayList&lt;&gt;();
582             test(
583                     (a) -&gt; assertCommand(a, &quot;int a;&quot;, null),
584                     (a) -&gt; assertCommand(a, &quot;()&quot;, null, null, null, &quot;&quot;, &quot;&quot;),
585                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
586                     (a) -&gt; assertCommandCheckOutput(a, &quot;/list -all&quot;, (out) -&gt;
587                                     output.addAll(Stream.of(out.split(&quot;\n&quot;))
588                             .filter(str -&gt; !str.isEmpty())
589                             .map(str -&gt; str.substring(str.indexOf(&#39;:&#39;) + 2))
590                             .filter(str -&gt; !str.startsWith(&quot;/&quot;))
591                             .collect(Collectors.toList()))),
592                     (a) -&gt; assertCommand(a, &quot;/save -all &quot; + path.toString(), &quot;&quot;)
593             );
594             assertEquals(Files.readAllLines(path), output);
595         }
596         {
597             List&lt;String&gt; output = new ArrayList&lt;&gt;();
598             test(
599                     (a) -&gt; assertCommand(a, &quot;int a;&quot;, null),
600                     (a) -&gt; assertCommand(a, &quot;int b;&quot;, null),
601                     (a) -&gt; assertCommand(a, &quot;int c;&quot;, null),
602                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
603                     (a) -&gt; assertCommandCheckOutput(a, &quot;/list b c a A&quot;, (out) -&gt;
604                                     output.addAll(Stream.of(out.split(&quot;\n&quot;))
605                             .filter(str -&gt; !str.isEmpty())
606                             .map(str -&gt; str.substring(str.indexOf(&#39;:&#39;) + 2))
607                             .filter(str -&gt; !str.startsWith(&quot;/&quot;))
608                             .collect(Collectors.toList()))),
609                     (a) -&gt; assertCommand(a, &quot;/save 2-3 1 4 &quot; + path.toString(), &quot;&quot;)
610             );
611             assertEquals(Files.readAllLines(path), output);
612         }
613         {
614             List&lt;String&gt; output = new ArrayList&lt;&gt;();
615             test(
616                     (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;a&quot;),
617                     (a) -&gt; assertCommand(a, &quot;()&quot;, null, null, null, &quot;&quot;, &quot;&quot;),
618                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
619                     (a) -&gt; assertCommandCheckOutput(a, &quot;/history&quot;, (out) -&gt;
620                                 output.addAll(Stream.of(out.split(&quot;\n&quot;))
621                             .filter(str -&gt; !str.isEmpty())
622                             .collect(Collectors.toList()))),
623                     (a) -&gt; assertCommand(a, &quot;/save -history &quot; + path.toString(), &quot;&quot;)
624             );
625             output.add(&quot;/save -history &quot; + path.toString());
626             assertEquals(Files.readAllLines(path), output);
627         }
628     }
629 
630     public void testStartRetain() {
631         Compiler compiler = new Compiler();
632         Path startUpFile = compiler.getPath(&quot;startUp.txt&quot;);
633         test(
634                 (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;a&quot;),
635                 (a) -&gt; assertVariable(a, &quot;double&quot;, &quot;b&quot;, &quot;10&quot;, &quot;10.0&quot;),
636                 (a) -&gt; assertMethod(a, &quot;void f() {}&quot;, &quot;()V&quot;, &quot;f&quot;),
637                 (a) -&gt; assertImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;),
638                 (a) -&gt; assertCommand(a, &quot;/save &quot; + startUpFile.toString(), null),
639                 (a) -&gt; assertCommand(a, &quot;/set start -retain &quot; + startUpFile.toString(), null)
640         );
641         Path unknown = compiler.getPath(&quot;UNKNOWN&quot;);
642         test(
643                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;/set start -retain &quot; + unknown.toString(),
644                         &quot;|  File &#39;&quot; + unknown + &quot;&#39; for &#39;/set start&#39; is not found.&quot;)
645         );
646         test(false, new String[0],
647                 (a) -&gt; {
648                     loadVariable(a, &quot;int&quot;, &quot;a&quot;);
649                     loadVariable(a, &quot;double&quot;, &quot;b&quot;, &quot;10.0&quot;, &quot;10.0&quot;);
650                     loadMethod(a, &quot;void f() {}&quot;, &quot;()void&quot;, &quot;f&quot;);
651                     loadImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;);
652                     assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses());
653                 },
654                 (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
655                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
656                 (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
657         );
658     }
659 
660     public void testStartSave() throws IOException {
661         Compiler compiler = new Compiler();
662         Path startSave = compiler.getPath(&quot;startSave.txt&quot;);
663         test(a -&gt; assertCommand(a, &quot;/save -start &quot; + startSave.toString(), null));
664         List&lt;String&gt; lines = Files.lines(startSave)
665                 .filter(s -&gt; !s.isEmpty())
666                 .collect(Collectors.toList());
667         assertEquals(lines, START_UP);
668     }
669 
670     public void testConstrainedUpdates() {
671         test(
672                 a -&gt; assertClass(a, &quot;class XYZZY { }&quot;, &quot;class&quot;, &quot;XYZZY&quot;),
673                 a -&gt; assertVariable(a, &quot;XYZZY&quot;, &quot;xyzzy&quot;),
674                 a -&gt; assertCommandCheckOutput(a, &quot;import java.util.stream.*&quot;,
675                         (out) -&gt; assertTrue(out.trim().isEmpty(), &quot;Expected no output, got: &quot; + out))
676         );
677     }
678 
679     public void testRemoteExit() {
680         test(
681                 a -&gt; assertVariable(a, &quot;int&quot;, &quot;x&quot;),
682                 a -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
683                 a -&gt; assertCommandOutputContains(a, &quot;System.exit(5);&quot;, &quot;terminated&quot;),
684                 a -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, s -&gt;
685                         assertTrue(s.trim().isEmpty(), s)),
686                 a -&gt; assertMethod(a, &quot;void f() { }&quot;, &quot;()void&quot;, &quot;f&quot;),
687                 a -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods())
688         );
689     }
690 
691     public void testFeedbackNegative() {
692         test(a -&gt; assertCommandCheckOutput(a, &quot;/set feedback aaaa&quot;,
693                 assertStartsWith(&quot;|  Does not match any current feedback mode&quot;)));
694     }
695 
696     public void testFeedbackSilent() {
697         for (String off : new String[]{&quot;s&quot;, &quot;silent&quot;}) {
698             test(
699                     a -&gt; assertCommand(a, &quot;/set feedback &quot; + off, &quot;&quot;),
700                     a -&gt; assertCommand(a, &quot;int a&quot;, &quot;&quot;),
701                     a -&gt; assertCommand(a, &quot;void f() {}&quot;, &quot;&quot;),
702                     a -&gt; assertCommandCheckOutput(a, &quot;aaaa&quot;, assertStartsWith(&quot;|  Error:&quot;)),
703                     a -&gt; assertCommandCheckOutput(a, &quot;static void f() {}&quot;, assertStartsWith(&quot;|  Warning:&quot;))
704             );
705         }
706     }
707 
708     public void testFeedbackNormal() {
709         Compiler compiler = new Compiler();
710         Path testNormalFile = compiler.getPath(&quot;testConciseNormal&quot;);
711         String[] sources = new String[] {&quot;int a&quot;, &quot;void f() {}&quot;, &quot;class A {}&quot;, &quot;a = 10&quot;};
712         String[] sources2 = new String[] {&quot;int a //again&quot;, &quot;void f() {int y = 4;}&quot;, &quot;class A {} //again&quot;, &quot;a = 10&quot;};
713         String[] output = new String[] {
714                 &quot;a ==&gt; 0&quot;,
715                 &quot;|  created method f()&quot;,
716                 &quot;|  created class A&quot;,
717                 &quot;a ==&gt; 10&quot;
718         };
719         compiler.writeToFile(testNormalFile, sources2);
720         for (String feedback : new String[]{&quot;/set fe&quot;, &quot;/set feedback&quot;}) {
721             for (String feedbackState : new String[]{&quot;n&quot;, &quot;normal&quot;}) {
722                 test(
723                         a -&gt; assertCommand(a, feedback + &quot; &quot; + feedbackState, &quot;|  Feedback mode: normal&quot;),
724                         a -&gt; assertCommand(a, sources[0], output[0]),
725                         a -&gt; assertCommand(a, sources[1], output[1]),
726                         a -&gt; assertCommand(a, sources[2], output[2]),
727                         a -&gt; assertCommand(a, sources[3], output[3]),
728                         a -&gt; assertCommand(a, &quot;/o &quot; + testNormalFile.toString(), &quot;&quot;)
729                 );
730             }
731         }
732     }
733 
734     public void testVarsWithNotActive() {
735         test(
736                 a -&gt; assertVariable(a, &quot;Blath&quot;, &quot;x&quot;),
737                 a -&gt; assertCommandOutputContains(a, &quot;/var -all&quot;, &quot;(not-active)&quot;)
738         );
739     }
740 
741     public void testHistoryReference() {
742         test(false, new String[]{&quot;--no-startup&quot;},
743                 a -&gt; assertCommand(a, &quot;System.err.println(99)&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;99\n&quot;),
744                 a -&gt; assertCommand(a, &quot;/exit&quot;, &quot;&quot;)
745         );
746         test(false, new String[]{&quot;--no-startup&quot;},
747                 a -&gt; assertCommand(a, &quot;System.err.println(1)&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;1\n&quot;),
748                 a -&gt; assertCommand(a, &quot;System.err.println(2)&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
749                 a -&gt; assertCommand(a, &quot;/-2&quot;, &quot;System.err.println(1)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;1\n&quot;),
750                 a -&gt; assertCommand(a, &quot;/history&quot;,
751                                                     &quot;/debug 0\n&quot; +
752                                                     &quot;System.err.println(1)\n&quot; +
753                                                     &quot;System.err.println(2)\n&quot; +
754                                                     &quot;System.err.println(1)\n&quot; +
755                                                     &quot;/history\n&quot;),
756                 a -&gt; assertCommand(a, &quot;/history -all&quot;,
757                                                     &quot;/debug 0\n&quot; +
758                                                     &quot;System.err.println(99)\n&quot; +
759                                                     &quot;/exit\n&quot; +
760                                                     &quot;/debug 0\n&quot; +
761                                                     &quot;System.err.println(1)\n&quot; +
762                                                     &quot;System.err.println(2)\n&quot; +
763                                                     &quot;System.err.println(1)\n&quot; +
764                                                     &quot;/history\n&quot; +
765                                                     &quot;/history -all\n&quot;),
766                 a -&gt; assertCommand(a, &quot;/-2&quot;, &quot;System.err.println(2)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
767                 a -&gt; assertCommand(a, &quot;/!&quot;, &quot;System.err.println(2)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
768                 a -&gt; assertCommand(a, &quot;/2&quot;, &quot;System.err.println(2)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
769                 a -&gt; assertCommand(a, &quot;/1&quot;, &quot;System.err.println(1)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;1\n&quot;)
770         );
771     }
772 
773     public void testRerunIdRange() {
774         Compiler compiler = new Compiler();
775         Path startup = compiler.getPath(&quot;rangeStartup&quot;);
776         String[] startupSources = new String[] {
777             &quot;boolean go = false&quot;,
778             &quot;void println(String s) { if (go) System.out.println(s); }&quot;,
779             &quot;void println(int i) { if (go) System.out.println(i); }&quot;,
780             &quot;println(\&quot;s4\&quot;)&quot;,
781             &quot;println(\&quot;s5\&quot;)&quot;,
782             &quot;println(\&quot;s6\&quot;)&quot;
783         };
784         String[] sources = new String[] {
785             &quot;frog&quot;,
786             &quot;go = true&quot;,
787             &quot;println(2)&quot;,
788             &quot;println(3)&quot;,
789             &quot;println(4)&quot;,
790             &quot;querty&quot;
791         };
792         compiler.writeToFile(startup, startupSources);
793         test(false, new String[]{&quot;--startup&quot;, startup.toString()},
794                 a -&gt; assertCommandOutputStartsWith(a, sources[0], &quot;|  Error:&quot;),
795                 a -&gt; assertCommand(a, sources[1], &quot;go ==&gt; true&quot;, &quot;&quot;, null, &quot;&quot;, &quot;&quot;),
796                 a -&gt; assertCommand(a, sources[2], &quot;&quot;, &quot;&quot;, null, &quot;2\n&quot;, &quot;&quot;),
797                 a -&gt; assertCommand(a, sources[3], &quot;&quot;, &quot;&quot;, null, &quot;3\n&quot;, &quot;&quot;),
798                 a -&gt; assertCommand(a, sources[4], &quot;&quot;, &quot;&quot;, null, &quot;4\n&quot;, &quot;&quot;),
799                 a -&gt; assertCommandOutputStartsWith(a, sources[5], &quot;|  Error:&quot;),
800                 a -&gt; assertCommand(a, &quot;/3&quot;, &quot;println(3)&quot;, &quot;&quot;, null, &quot;3\n&quot;, &quot;&quot;),
801                 a -&gt; assertCommand(a, &quot;/s4&quot;, &quot;println(\&quot;s4\&quot;)&quot;, &quot;&quot;, null, &quot;s4\n&quot;, &quot;&quot;),
802                 a -&gt; assertCommandOutputStartsWith(a, &quot;/e1&quot;, &quot;frog\n|  Error:&quot;),
803                 a -&gt; assertCommand(a, &quot;/2-4&quot;,
804                         &quot;println(2)\nprintln(3)\nprintln(4)&quot;,
805                         &quot;&quot;, null, &quot;2\n3\n4\n&quot;, &quot;&quot;),
806                 a -&gt; assertCommand(a, &quot;/s4-s6&quot;,
807                         startupSources[3] + &quot;\n&quot; +startupSources[4] + &quot;\n&quot; +startupSources[5],
808                         &quot;&quot;, null, &quot;s4\ns5\ns6\n&quot;, &quot;&quot;),
809                 a -&gt; assertCommand(a, &quot;/s4-4&quot;, null,
810                         &quot;&quot;, null, &quot;s4\ns5\ns6\n2\n3\n4\n&quot;, &quot;&quot;),
811                 a -&gt; assertCommandCheckOutput(a, &quot;/e1-e2&quot;,
812                         s -&gt; {
813                             assertTrue(s.trim().startsWith(&quot;frog\n|  Error:&quot;),
814                                     &quot;Output: \&#39;&quot; + s + &quot;&#39; does not start with: &quot; + &quot;|  Error:&quot;);
815                             assertTrue(s.trim().lastIndexOf(&quot;|  Error:&quot;) &gt; 10,
816                                     &quot;Output: \&#39;&quot; + s + &quot;&#39; does not have second: &quot; + &quot;|  Error:&quot;);
817                         }),
818                 a -&gt; assertCommand(a, &quot;/4  s4 2&quot;,
819                         &quot;println(4)\nprintln(\&quot;s4\&quot;)\nprintln(2)&quot;,
820                         &quot;&quot;, null, &quot;4\ns4\n2\n&quot;, &quot;&quot;),
821                 a -&gt; assertCommand(a, &quot;/s5 2-4 3&quot;,
822                         &quot;println(\&quot;s5\&quot;)\nprintln(2)\nprintln(3)\nprintln(4)\nprintln(3)&quot;,
823                         &quot;&quot;, null, &quot;s5\n2\n3\n4\n3\n&quot;, &quot;&quot;),
824                 a -&gt; assertCommand(a, &quot;/2 ff&quot;, &quot;|  No such snippet: ff&quot;),
825                 a -&gt; assertCommand(a, &quot;/4-2&quot;, &quot;|  End of snippet range less than start: 4 - 2&quot;),
826                 a -&gt; assertCommand(a, &quot;/s5-s3&quot;, &quot;|  End of snippet range less than start: s5 - s3&quot;),
827                 a -&gt; assertCommand(a, &quot;/4-s5&quot;, &quot;|  End of snippet range less than start: 4 - s5&quot;)
828         );
829     }
830 
831     @Test(enabled = false) // TODO 8158197
832     public void testHeadlessEditPad() {
833         String prevHeadless = System.getProperty(&quot;java.awt.headless&quot;);
834         try {
835             System.setProperty(&quot;java.awt.headless&quot;, &quot;true&quot;);
836             test(
837                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;/edit printf&quot;, &quot;|  Cannot launch editor -- unexpected exception:&quot;)
838             );
839         } finally {
840             System.setProperty(&quot;java.awt.headless&quot;, prevHeadless==null? &quot;false&quot; : prevHeadless);
841         }
842     }
843 
844     public void testAddExports() {
845         test(false, new String[]{&quot;--no-startup&quot;},
846                 a -&gt; assertCommandOutputStartsWith(a, &quot;import jdk.internal.misc.VM;&quot;, &quot;|  Error:&quot;)
847         );
848         test(false, new String[]{&quot;--no-startup&quot;,
849                         &quot;-R--add-exports&quot;, &quot;-Rjava.base/jdk.internal.misc=ALL-UNNAMED&quot;,
850                         &quot;-C--add-exports&quot;, &quot;-Cjava.base/jdk.internal.misc=ALL-UNNAMED&quot;},
851                 a -&gt; assertImport(a, &quot;import jdk.internal.misc.VM;&quot;, &quot;&quot;, &quot;jdk.internal.misc.VM&quot;),
852                 a -&gt; assertCommand(a, &quot;System.err.println(VM.isBooted())&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;true\n&quot;)
853         );
854         test(false, new String[]{&quot;--no-startup&quot;, &quot;--add-exports&quot;, &quot;java.base/jdk.internal.misc&quot;},
855                 a -&gt; assertImport(a, &quot;import jdk.internal.misc.VM;&quot;, &quot;&quot;, &quot;jdk.internal.misc.VM&quot;),
856                 a -&gt; assertCommand(a, &quot;System.err.println(VM.isBooted())&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;true\n&quot;)
857         );
858     }
859 
860     public void testRedeclareVariableNoInit() {
861         test(
862                 a -&gt; assertCommand(a, &quot;Integer a;&quot;, &quot;a ==&gt; null&quot;),
863                 a -&gt; assertCommand(a, &quot;a instanceof Integer;&quot;, &quot;$2 ==&gt; false&quot;),
864                 a -&gt; assertCommand(a, &quot;a = 1;&quot;, &quot;a ==&gt; 1&quot;),
865                 a -&gt; assertCommand(a, &quot;Integer a;&quot;, &quot;a ==&gt; null&quot;),
866                 a -&gt; assertCommand(a, &quot;a instanceof Integer;&quot;, &quot;$5 ==&gt; false&quot;),
867                 a -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; null&quot;)
868         );
869      }
870 
871     public void testWarningUnchecked() { //8223688
872         test(false, new String[]{&quot;--no-startup&quot;},
873                 a -&gt; assertCommand(a, &quot;abstract class A&lt;T&gt; { A(T t){} }&quot;, &quot;|  created class A&quot;),
874                 a -&gt; assertCommandCheckOutput(a, &quot;new A(\&quot;\&quot;) {}&quot;, s -&gt; {
875                             assertStartsWith(&quot;|  Warning:&quot;);
876                             assertTrue(s.contains(&quot;unchecked call&quot;));
877                             assertFalse(s.contains(&quot;Exception&quot;));
878                         })
879         );
880     }
881 
882 }
    </pre>
  </body>
</html>
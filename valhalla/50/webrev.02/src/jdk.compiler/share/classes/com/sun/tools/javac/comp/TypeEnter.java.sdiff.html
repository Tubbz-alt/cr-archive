<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../jvm/ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 127         names = Names.instance(context);
 128         enter = Enter.instance(context);
 129         memberEnter = MemberEnter.instance(context);
 130         log = Log.instance(context);
 131         chk = Check.instance(context);
 132         attr = Attr.instance(context);
 133         syms = Symtab.instance(context);
 134         make = TreeMaker.instance(context);
 135         todo = Todo.instance(context);
 136         annotate = Annotate.instance(context);
 137         typeAnnotations = TypeAnnotations.instance(context);
 138         types = Types.instance(context);
 139         diags = JCDiagnostic.Factory.instance(context);
 140         deferredLintHandler = DeferredLintHandler.instance(context);
 141         lint = Lint.instance(context);
 142         typeEnvs = TypeEnvs.instance(context);
 143         dependencies = Dependencies.instance(context);
 144         Source source = Source.instance(context);
 145         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 146         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);
<span class="line-removed"> 147         injectTopInterfaceTypes = Options.instance(context).isUnset(&quot;noTopInterfaceInjection&quot;) &amp;&amp;</span>
<span class="line-removed"> 148                                         Feature.INLINE_TYPES.allowedInSource(source) &amp;&amp;</span>
<span class="line-removed"> 149                                             Target.instance(context).hasTopInterfaces();</span>
 150     }
 151 
 152     /** Switch: support type annotations.
 153      */
 154     boolean allowTypeAnnos;
 155 
 156     /**
 157      * Switch: should deprecation warnings be issued on import
 158      */
 159     boolean allowDeprecationOnImport;
 160 
<span class="line-removed"> 161     /** Switch: inject top interface types.</span>
<span class="line-removed"> 162      */</span>
<span class="line-removed"> 163     boolean injectTopInterfaceTypes;</span>
<span class="line-removed"> 164 </span>
 165     /** A flag to disable completion from time to time during member
 166      *  enter, as we only need to look up types.  This avoids
 167      *  unnecessarily deep recursion.
 168      */
 169     boolean completionEnabled = true;
 170 
 171     /* Verify Imports:
 172      */
 173     protected void ensureImportsChecked(List&lt;JCCompilationUnit&gt; trees) {
 174         // if there remain any unimported toplevels (these must have
 175         // no classes at all), process their import statements as well.
 176         for (JCCompilationUnit tree : trees) {
 177             if (!tree.starImportScope.isFilled()) {
 178                 Env&lt;AttrContext&gt; topEnv = enter.topLevelEnv(tree);
 179                 finishImports(tree, () -&gt; { completeClass.resolveImports(tree, topEnv); });
 180             }
 181         }
 182     }
 183 
 184 /* ********************************************************************
</pre>
<hr />
<pre>
 687             JCExpression extending;
 688             final boolean isValueType = (tree.mods.flags &amp; Flags.VALUE) != 0;
 689 
 690             if (tree.extending != null) {
 691                 extending = clearTypeParams(tree.extending);
 692                 supertype = attr.attribBase(extending, baseEnv, true, false, true);
 693                 if (supertype == syms.recordType) {
 694                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));
 695                 }
 696             } else {
 697                 extending = null;
 698                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 699                 ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
 700                                   true, false, false)
 701                 : (sym.fullname == names.java_lang_Object)
 702                 ? Type.noType
 703                 : sym.isRecord() ? syms.recordType : syms.objectType;
 704             }
 705             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 706 
<span class="line-removed"> 707             Type interfaceToInject = Type.noType;</span>
<span class="line-removed"> 708             if (injectTopInterfaceTypes) {</span>
<span class="line-removed"> 709                 if (isValueType || types.isValue(supertype)) {</span>
<span class="line-removed"> 710                     interfaceToInject = syms.inlineObjectType;</span>
<span class="line-removed"> 711                 } else if ((sym.flags_field &amp; (INTERFACE | ABSTRACT)) == 0) { // skip interfaces, abstract classes and annotations.</span>
<span class="line-removed"> 712                     if (sym.fullname != names.java_lang_Object) {</span>
<span class="line-removed"> 713                         interfaceToInject = syms.identityObjectType;</span>
<span class="line-removed"> 714                     }</span>
<span class="line-removed"> 715                 }</span>
<span class="line-removed"> 716             }</span>
<span class="line-removed"> 717 </span>
 718             // Determine interfaces.
 719             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 720             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 721             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 722             for (JCExpression iface : interfaceTrees) {
 723                 iface = clearTypeParams(iface);
 724                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
<span class="line-removed"> 725                 if (it.tsym == interfaceToInject.tsym) {</span>
<span class="line-removed"> 726                     interfaceToInject = Type.noType;</span>
<span class="line-removed"> 727                 }</span>
 728                 if (it.hasTag(CLASS)) {
 729                     interfaces.append(it);
 730                     if (all_interfaces != null) all_interfaces.append(it);
 731                 } else {
 732                     if (all_interfaces == null)
 733                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 734                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 735                 }
 736             }
 737 
 738             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 739                 ct.interfaces_field = List.of(syms.annotationType);
 740                 ct.all_interfaces_field = ct.interfaces_field;
 741             }  else {
<span class="line-removed"> 742                 if (interfaceToInject != Type.noType) {</span>
<span class="line-removed"> 743                     interfaces.append(interfaceToInject);</span>
<span class="line-removed"> 744                 }</span>
 745                 ct.interfaces_field = interfaces.toList();
 746                 ct.all_interfaces_field = (all_interfaces == null)
 747                         ? ct.interfaces_field : all_interfaces.toList();
 748             }
 749             if (ct.isValue()) {
 750                 ClassSymbol cSym = (ClassSymbol) ct.tsym;
 751                 if (cSym.projection != null) {
 752                     ClassType projectedType = (ClassType) cSym.projection.type;
 753                     projectedType.supertype_field = ct.supertype_field;
 754                     projectedType.interfaces_field = ct.interfaces_field;
 755                     projectedType.all_interfaces_field = ct.all_interfaces_field;
 756                 }
 757             }
 758         }
 759             //where:
 760             protected JCExpression clearTypeParams(JCExpression superType) {
 761                 return superType;
 762             }
 763     }
 764 
</pre>
</td>
<td>
<hr />
<pre>
 127         names = Names.instance(context);
 128         enter = Enter.instance(context);
 129         memberEnter = MemberEnter.instance(context);
 130         log = Log.instance(context);
 131         chk = Check.instance(context);
 132         attr = Attr.instance(context);
 133         syms = Symtab.instance(context);
 134         make = TreeMaker.instance(context);
 135         todo = Todo.instance(context);
 136         annotate = Annotate.instance(context);
 137         typeAnnotations = TypeAnnotations.instance(context);
 138         types = Types.instance(context);
 139         diags = JCDiagnostic.Factory.instance(context);
 140         deferredLintHandler = DeferredLintHandler.instance(context);
 141         lint = Lint.instance(context);
 142         typeEnvs = TypeEnvs.instance(context);
 143         dependencies = Dependencies.instance(context);
 144         Source source = Source.instance(context);
 145         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 146         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);



 147     }
 148 
 149     /** Switch: support type annotations.
 150      */
 151     boolean allowTypeAnnos;
 152 
 153     /**
 154      * Switch: should deprecation warnings be issued on import
 155      */
 156     boolean allowDeprecationOnImport;
 157 




 158     /** A flag to disable completion from time to time during member
 159      *  enter, as we only need to look up types.  This avoids
 160      *  unnecessarily deep recursion.
 161      */
 162     boolean completionEnabled = true;
 163 
 164     /* Verify Imports:
 165      */
 166     protected void ensureImportsChecked(List&lt;JCCompilationUnit&gt; trees) {
 167         // if there remain any unimported toplevels (these must have
 168         // no classes at all), process their import statements as well.
 169         for (JCCompilationUnit tree : trees) {
 170             if (!tree.starImportScope.isFilled()) {
 171                 Env&lt;AttrContext&gt; topEnv = enter.topLevelEnv(tree);
 172                 finishImports(tree, () -&gt; { completeClass.resolveImports(tree, topEnv); });
 173             }
 174         }
 175     }
 176 
 177 /* ********************************************************************
</pre>
<hr />
<pre>
 680             JCExpression extending;
 681             final boolean isValueType = (tree.mods.flags &amp; Flags.VALUE) != 0;
 682 
 683             if (tree.extending != null) {
 684                 extending = clearTypeParams(tree.extending);
 685                 supertype = attr.attribBase(extending, baseEnv, true, false, true);
 686                 if (supertype == syms.recordType) {
 687                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));
 688                 }
 689             } else {
 690                 extending = null;
 691                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 692                 ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
 693                                   true, false, false)
 694                 : (sym.fullname == names.java_lang_Object)
 695                 ? Type.noType
 696                 : sym.isRecord() ? syms.recordType : syms.objectType;
 697             }
 698             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 699 











 700             // Determine interfaces.
 701             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 702             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 703             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 704             for (JCExpression iface : interfaceTrees) {
 705                 iface = clearTypeParams(iface);
 706                 Type it = attr.attribBase(iface, baseEnv, false, true, true);



 707                 if (it.hasTag(CLASS)) {
 708                     interfaces.append(it);
 709                     if (all_interfaces != null) all_interfaces.append(it);
 710                 } else {
 711                     if (all_interfaces == null)
 712                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 713                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 714                 }
 715             }
 716 
 717             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 718                 ct.interfaces_field = List.of(syms.annotationType);
 719                 ct.all_interfaces_field = ct.interfaces_field;
 720             }  else {



 721                 ct.interfaces_field = interfaces.toList();
 722                 ct.all_interfaces_field = (all_interfaces == null)
 723                         ? ct.interfaces_field : all_interfaces.toList();
 724             }
 725             if (ct.isValue()) {
 726                 ClassSymbol cSym = (ClassSymbol) ct.tsym;
 727                 if (cSym.projection != null) {
 728                     ClassType projectedType = (ClassType) cSym.projection.type;
 729                     projectedType.supertype_field = ct.supertype_field;
 730                     projectedType.interfaces_field = ct.interfaces_field;
 731                     projectedType.all_interfaces_field = ct.all_interfaces_field;
 732                 }
 733             }
 734         }
 735             //where:
 736             protected JCExpression clearTypeParams(JCExpression superType) {
 737                 return superType;
 738             }
 739     }
 740 
</pre>
</td>
</tr>
</table>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../jvm/ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
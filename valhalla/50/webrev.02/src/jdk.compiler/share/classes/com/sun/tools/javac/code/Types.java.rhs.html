<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.ref.SoftReference;
  29 import java.util.HashSet;
  30 import java.util.HashMap;
  31 import java.util.Locale;
  32 import java.util.Map;
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;
  53 import com.sun.tools.javac.jvm.Target;
  54 import com.sun.tools.javac.util.*;
  55 
  56 import static com.sun.tools.javac.code.BoundKind.*;
  57 import static com.sun.tools.javac.code.Flags.*;
  58 import static com.sun.tools.javac.code.Kinds.Kind.*;
  59 import static com.sun.tools.javac.code.Scope.*;
  60 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  61 import static com.sun.tools.javac.code.Symbol.*;
  62 import static com.sun.tools.javac.code.Type.*;
  63 import static com.sun.tools.javac.code.TypeTag.*;
  64 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  65 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  66 
  67 /**
  68  * Utility class containing various operations on types.
  69  *
  70  * &lt;p&gt;Unless other names are more illustrative, the following naming
  71  * conventions should be observed in this file:
  72  *
  73  * &lt;dl&gt;
  74  * &lt;dt&gt;t&lt;/dt&gt;
  75  * &lt;dd&gt;If the first argument to an operation is a type, it should be named t.&lt;/dd&gt;
  76  * &lt;dt&gt;s&lt;/dt&gt;
  77  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  78  * &lt;dt&gt;ts&lt;/dt&gt;
  79  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  80  * &lt;dt&gt;ss&lt;/dt&gt;
  81  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  82  * &lt;/dl&gt;
  83  *
  84  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  * If you write code that depends on this, you do so at your own risk.
  86  * This code and its internal interfaces are subject to change or
  87  * deletion without notice.&lt;/b&gt;
  88  */
  89 public class Types {
  90     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  91 
  92     final Symtab syms;
  93     final JavacMessages messages;
  94     final Names names;
  95     final boolean allowDefaultMethods;
  96     final boolean mapCapturesToBounds;
  97     final boolean allowValueBasedClasses;
<a name="1" id="anc1"></a>
  98     final Check chk;
  99     final Enter enter;
 100     JCDiagnostic.Factory diags;
 101     List&lt;Warner&gt; warnStack = List.nil();
 102     final Name capturedName;
 103 
 104     public final Warner noWarnings;
 105 
 106     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 107     public static Types instance(Context context) {
 108         Types instance = context.get(typesKey);
 109         if (instance == null)
 110             instance = new Types(context);
 111         return instance;
 112     }
 113 
 114     protected Types(Context context) {
 115         context.put(typesKey, this);
 116         syms = Symtab.instance(context);
 117         names = Names.instance(context);
 118         Source source = Source.instance(context);
 119         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 120         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 121         chk = Check.instance(context);
 122         enter = Enter.instance(context);
 123         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 124         messages = JavacMessages.instance(context);
 125         diags = JCDiagnostic.Factory.instance(context);
 126         noWarnings = new Warner(null);
 127         Options options = Options.instance(context);
 128         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
<a name="2" id="anc2"></a>


 129     }
 130     // &lt;/editor-fold&gt;
 131 
 132     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 133     /**
 134      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 135      * @param t a type argument, either a wildcard or a type
 136      */
 137     public Type wildUpperBound(Type t) {
 138         if (t.hasTag(WILDCARD)) {
 139             WildcardType w = (WildcardType) t;
 140             if (w.isSuperBound())
 141                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 142             else
 143                 return wildUpperBound(w.type);
 144         }
 145         else return t;
 146     }
 147 
 148     /**
 149      * Get a capture variable&#39;s upper bound, returning other types unchanged.
 150      * @param t a type
 151      */
 152     public Type cvarUpperBound(Type t) {
 153         if (t.hasTag(TYPEVAR)) {
 154             TypeVar v = (TypeVar) t;
 155             return v.isCaptured() ? cvarUpperBound(v.getUpperBound()) : v;
 156         }
 157         else return t;
 158     }
 159 
 160     /**
 161      * Get a wildcard&#39;s lower bound, returning non-wildcards unchanged.
 162      * @param t a type argument, either a wildcard or a type
 163      */
 164     public Type wildLowerBound(Type t) {
 165         if (t.hasTag(WILDCARD)) {
 166             WildcardType w = (WildcardType) t;
 167             return w.isExtendsBound() ? syms.botType : wildLowerBound(w.type);
 168         }
 169         else return t;
 170     }
 171 
 172     /**
 173      * Get a capture variable&#39;s lower bound, returning other types unchanged.
 174      * @param t a type
 175      */
 176     public Type cvarLowerBound(Type t) {
 177         if (t.hasTag(TYPEVAR) &amp;&amp; ((TypeVar) t).isCaptured()) {
 178             return cvarLowerBound(t.getLowerBound());
 179         }
 180         else return t;
 181     }
 182 
 183     /**
 184      * Recursively skip type-variables until a class/array type is found; capture conversion is then
 185      * (optionally) applied to the resulting type. This is useful for i.e. computing a site that is
 186      * suitable for a method lookup.
 187      */
 188     public Type skipTypeVars(Type site, boolean capture) {
 189         while (site.hasTag(TYPEVAR)) {
 190             site = site.getUpperBound();
 191         }
 192         return capture ? capture(site) : site;
 193     }
 194     // &lt;/editor-fold&gt;
 195 
 196     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;projections&quot;&gt;
 197 
 198     /**
 199      * A projection kind. See {@link TypeProjection}
 200      */
 201     enum ProjectionKind {
 202         UPWARDS() {
 203             @Override
 204             ProjectionKind complement() {
 205                 return DOWNWARDS;
 206             }
 207         },
 208         DOWNWARDS() {
 209             @Override
 210             ProjectionKind complement() {
 211                 return UPWARDS;
 212             }
 213         };
 214 
 215         abstract ProjectionKind complement();
 216     }
 217 
 218     /**
 219      * This visitor performs upwards and downwards projections on types.
 220      *
 221      * A projection is defined as a function that takes a type T, a set of type variables V and that
 222      * produces another type S.
 223      *
 224      * An upwards projection maps a type T into a type S such that (i) T has no variables in V,
 225      * and (ii) S is an upper bound of T.
 226      *
 227      * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
 228      * and (ii) S is a lower bound of T.
 229      *
 230      * Note that projections are only allowed to touch variables in V. Therefore, it is possible for
 231      * a projection to leave its input type unchanged if it does not contain any variables in V.
 232      *
 233      * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
 234      * a downwards projection is not always defined.
 235      *
 236      * Examples:
 237      *
 238      * {@code upwards(List&lt;#CAP1&gt;, [#CAP1]) = List&lt;? extends String&gt;, where #CAP1 &lt;: String }
 239      * {@code downwards(List&lt;#CAP2&gt;, [#CAP2]) = List&lt;? super String&gt;, where #CAP2 :&gt; String }
 240      * {@code upwards(List&lt;#CAP1&gt;, [#CAP2]) = List&lt;#CAP1&gt; }
 241      * {@code downwards(List&lt;#CAP1&gt;, [#CAP1]) = not defined }
 242      */
 243     class TypeProjection extends TypeMapping&lt;ProjectionKind&gt; {
 244 
 245         List&lt;Type&gt; vars;
 246         Set&lt;Type&gt; seen = new HashSet&lt;&gt;();
 247 
 248         public TypeProjection(List&lt;Type&gt; vars) {
 249             this.vars = vars;
 250         }
 251 
 252         @Override
 253         public Type visitClassType(ClassType t, ProjectionKind pkind) {
 254             if (t.isCompound()) {
 255                 List&lt;Type&gt; components = directSupertypes(t);
 256                 List&lt;Type&gt; components1 = components.map(c -&gt; c.map(this, pkind));
 257                 if (components == components1) return t;
 258                 else return makeIntersectionType(components1);
 259             } else {
 260                 Type outer = t.getEnclosingType();
 261                 Type outer1 = visit(outer, pkind);
 262                 List&lt;Type&gt; typarams = t.getTypeArguments();
 263                 List&lt;Type&gt; formals = t.tsym.type.getTypeArguments();
 264                 ListBuffer&lt;Type&gt; typarams1 = new ListBuffer&lt;&gt;();
 265                 boolean changed = false;
 266                 for (Type actual : typarams) {
 267                     Type t2 = mapTypeArgument(t, formals.head.getUpperBound(), actual, pkind);
 268                     if (t2.hasTag(BOT)) {
 269                         //not defined
 270                         return syms.botType;
 271                     }
 272                     typarams1.add(t2);
 273                     changed |= actual != t2;
 274                     formals = formals.tail;
 275                 }
 276                 if (outer1 == outer &amp;&amp; !changed) return t;
 277                 else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {
 278                     @Override
 279                     protected boolean needsStripping() {
 280                         return true;
 281                     }
 282                 };
 283             }
 284         }
 285 
 286         @Override
 287         public Type visitArrayType(ArrayType t, ProjectionKind s) {
 288             Type elemtype = t.elemtype;
 289             Type elemtype1 = visit(elemtype, s);
 290             if (elemtype1 == elemtype) {
 291                 return t;
 292             } else if (elemtype1.hasTag(BOT)) {
 293                 //undefined
 294                 return syms.botType;
 295             } else {
 296                 return new ArrayType(elemtype1, t.tsym, t.metadata) {
 297                     @Override
 298                     protected boolean needsStripping() {
 299                         return true;
 300                     }
 301                 };
 302             }
 303         }
 304 
 305         @Override
 306         public Type visitTypeVar(TypeVar t, ProjectionKind pkind) {
 307             if (vars.contains(t)) {
 308                 if (seen.add(t)) {
 309                     try {
 310                         final Type bound;
 311                         switch (pkind) {
 312                             case UPWARDS:
 313                                 bound = t.getUpperBound();
 314                                 break;
 315                             case DOWNWARDS:
 316                                 bound = (t.getLowerBound() == null) ?
 317                                         syms.botType :
 318                                         t.getLowerBound();
 319                                 break;
 320                             default:
 321                                 Assert.error();
 322                                 return null;
 323                         }
 324                         return bound.map(this, pkind);
 325                     } finally {
 326                         seen.remove(t);
 327                     }
 328                 } else {
 329                     //cycle
 330                     return pkind == ProjectionKind.UPWARDS ?
 331                             syms.objectType : syms.botType;
 332                 }
 333             } else {
 334                 return t;
 335             }
 336         }
 337 
 338         private Type mapTypeArgument(Type site, Type declaredBound, Type t, ProjectionKind pkind) {
 339             return t.containsAny(vars) ?
 340                     t.map(new TypeArgumentProjection(site, declaredBound), pkind) :
 341                     t;
 342         }
 343 
 344         class TypeArgumentProjection extends TypeMapping&lt;ProjectionKind&gt; {
 345 
 346             Type site;
 347             Type declaredBound;
 348 
 349             TypeArgumentProjection(Type site, Type declaredBound) {
 350                 this.site = site;
 351                 this.declaredBound = declaredBound;
 352             }
 353 
 354             @Override
 355             public Type visitType(Type t, ProjectionKind pkind) {
 356                 //type argument is some type containing restricted vars
 357                 if (pkind == ProjectionKind.DOWNWARDS) {
 358                     //not defined
 359                     return syms.botType;
 360                 }
 361                 Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);
 362                 Type lower = t.map(TypeProjection.this, ProjectionKind.DOWNWARDS);
 363                 List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 364                 BoundKind bk;
 365                 Type bound;
 366                 if (!isSameType(upper, syms.objectType) &amp;&amp;
 367                         (declaredBound.containsAny(formals) ||
 368                          !isSubtype(declaredBound, upper))) {
 369                     bound = upper;
 370                     bk = EXTENDS;
 371                 } else if (!lower.hasTag(BOT)) {
 372                     bound = lower;
 373                     bk = SUPER;
 374                 } else {
 375                     bound = syms.objectType;
 376                     bk = UNBOUND;
 377                 }
 378                 return makeWildcard(bound, bk);
 379             }
 380 
 381             @Override
 382             public Type visitWildcardType(WildcardType wt, ProjectionKind pkind) {
 383                 //type argument is some wildcard whose bound contains restricted vars
 384                 Type bound = syms.botType;
 385                 BoundKind bk = wt.kind;
 386                 switch (wt.kind) {
 387                     case EXTENDS:
 388                         bound = wt.type.map(TypeProjection.this, pkind);
 389                         if (bound.hasTag(BOT)) {
 390                             return syms.botType;
 391                         }
 392                         break;
 393                     case SUPER:
 394                         bound = wt.type.map(TypeProjection.this, pkind.complement());
 395                         if (bound.hasTag(BOT)) {
 396                             bound = syms.objectType;
 397                             bk = UNBOUND;
 398                         }
 399                         break;
 400                 }
 401                 return makeWildcard(bound, bk);
 402             }
 403 
 404             private Type makeWildcard(Type bound, BoundKind bk) {
 405                 return new WildcardType(bound, bk, syms.boundClass) {
 406                     @Override
 407                     protected boolean needsStripping() {
 408                         return true;
 409                     }
 410                 };
 411             }
 412         }
 413     }
 414 
 415     /**
 416      * Computes an upward projection of given type, and vars. See {@link TypeProjection}.
 417      *
 418      * @param t the type to be projected
 419      * @param vars the set of type variables to be mapped
 420      * @return the type obtained as result of the projection
 421      */
 422     public Type upward(Type t, List&lt;Type&gt; vars) {
 423         return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);
 424     }
 425 
 426     /**
 427      * Computes the set of captured variables mentioned in a given type. See {@link CaptureScanner}.
 428      * This routine is typically used to computed the input set of variables to be used during
 429      * an upwards projection (see {@link Types#upward(Type, List)}).
 430      *
 431      * @param t the type where occurrences of captured variables have to be found
 432      * @return the set of captured variables found in t
 433      */
 434     public List&lt;Type&gt; captures(Type t) {
 435         CaptureScanner cs = new CaptureScanner();
 436         Set&lt;Type&gt; captures = new HashSet&lt;&gt;();
 437         cs.visit(t, captures);
 438         return List.from(captures);
 439     }
 440 
 441     /**
 442      * This visitor scans a type recursively looking for occurrences of captured type variables.
 443      */
 444     class CaptureScanner extends SimpleVisitor&lt;Void, Set&lt;Type&gt;&gt; {
 445 
 446         @Override
 447         public Void visitType(Type t, Set&lt;Type&gt; types) {
 448             return null;
 449         }
 450 
 451         @Override
 452         public Void visitClassType(ClassType t, Set&lt;Type&gt; seen) {
 453             if (t.isCompound()) {
 454                 directSupertypes(t).forEach(s -&gt; visit(s, seen));
 455             } else {
 456                 t.allparams().forEach(ta -&gt; visit(ta, seen));
 457             }
 458             return null;
 459         }
 460 
 461         @Override
 462         public Void visitArrayType(ArrayType t, Set&lt;Type&gt; seen) {
 463             return visit(t.elemtype, seen);
 464         }
 465 
 466         @Override
 467         public Void visitWildcardType(WildcardType t, Set&lt;Type&gt; seen) {
 468             visit(t.type, seen);
 469             return null;
 470         }
 471 
 472         @Override
 473         public Void visitTypeVar(TypeVar t, Set&lt;Type&gt; seen) {
 474             if ((t.tsym.flags() &amp; Flags.SYNTHETIC) != 0 &amp;&amp; seen.add(t)) {
 475                 visit(t.getUpperBound(), seen);
 476             }
 477             return null;
 478         }
 479 
 480         @Override
 481         public Void visitCapturedType(CapturedType t, Set&lt;Type&gt; seen) {
 482             if (seen.add(t)) {
 483                 visit(t.getUpperBound(), seen);
 484                 visit(t.getLowerBound(), seen);
 485             }
 486             return null;
 487         }
 488     }
 489 
 490     // &lt;/editor-fold&gt;
 491 
 492     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isUnbounded&quot;&gt;
 493     /**
 494      * Checks that all the arguments to a class are unbounded
 495      * wildcards or something else that doesn&#39;t make any restrictions
 496      * on the arguments. If a class isUnbounded, a raw super- or
 497      * subclass can be cast to it without a warning.
 498      * @param t a type
 499      * @return true iff the given type is unbounded or raw
 500      */
 501     public boolean isUnbounded(Type t) {
 502         return isUnbounded.visit(t);
 503     }
 504     // where
 505         private final UnaryVisitor&lt;Boolean&gt; isUnbounded = new UnaryVisitor&lt;Boolean&gt;() {
 506 
 507             public Boolean visitType(Type t, Void ignored) {
 508                 return true;
 509             }
 510 
 511             @Override
 512             public Boolean visitClassType(ClassType t, Void ignored) {
 513                 List&lt;Type&gt; parms = t.tsym.type.allparams();
 514                 List&lt;Type&gt; args = t.allparams();
 515                 while (parms.nonEmpty()) {
 516                     WildcardType unb = new WildcardType(syms.objectType,
 517                                                         BoundKind.UNBOUND,
 518                                                         syms.boundClass,
 519                                                         (TypeVar)parms.head);
 520                     if (!containsType(args.head, unb))
 521                         return false;
 522                     parms = parms.tail;
 523                     args = args.tail;
 524                 }
 525                 return true;
 526             }
 527         };
 528     // &lt;/editor-fold&gt;
 529 
 530     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSub&quot;&gt;
 531     /**
 532      * Return the least specific subtype of t that starts with symbol
 533      * sym.  If none exists, return null.  The least specific subtype
 534      * is determined as follows:
 535      *
 536      * &lt;p&gt;If there is exactly one parameterized instance of sym that is a
 537      * subtype of t, that parameterized instance is returned.&lt;br&gt;
 538      * Otherwise, if the plain type or raw type `sym&#39; is a subtype of
 539      * type t, the type `sym&#39; itself is returned.  Otherwise, null is
 540      * returned.
 541      */
 542     public Type asSub(Type t, Symbol sym) {
 543         return asSub.visit(t, sym);
 544     }
 545     // where
 546         private final SimpleVisitor&lt;Type,Symbol&gt; asSub = new SimpleVisitor&lt;Type,Symbol&gt;() {
 547 
 548             public Type visitType(Type t, Symbol sym) {
 549                 return null;
 550             }
 551 
 552             @Override
 553             public Type visitClassType(ClassType t, Symbol sym) {
 554                 if (t.tsym == sym)
 555                     return t;
 556                 Type base = asSuper(sym.type, t.tsym);
 557                 if (base == null)
 558                     return null;
 559                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
 560                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
 561                 try {
 562                     adapt(base, t, from, to);
 563                 } catch (AdaptFailure ex) {
 564                     return null;
 565                 }
 566                 Type res = subst(sym.type, from.toList(), to.toList());
 567                 if (!isSubtype(res, t))
 568                     return null;
 569                 ListBuffer&lt;Type&gt; openVars = new ListBuffer&lt;&gt;();
 570                 for (List&lt;Type&gt; l = sym.type.allparams();
 571                      l.nonEmpty(); l = l.tail)
 572                     if (res.contains(l.head) &amp;&amp; !t.contains(l.head))
 573                         openVars.append(l.head);
 574                 if (openVars.nonEmpty()) {
 575                     if (t.isRaw()) {
 576                         // The subtype of a raw type is raw
 577                         res = erasure(res);
 578                     } else {
 579                         // Unbound type arguments default to ?
 580                         List&lt;Type&gt; opens = openVars.toList();
 581                         ListBuffer&lt;Type&gt; qs = new ListBuffer&lt;&gt;();
 582                         for (List&lt;Type&gt; iter = opens; iter.nonEmpty(); iter = iter.tail) {
 583                             qs.append(new WildcardType(syms.objectType, BoundKind.UNBOUND,
 584                                                        syms.boundClass, (TypeVar) iter.head));
 585                         }
 586                         res = subst(res, opens, qs.toList());
 587                     }
 588                 }
 589                 return res;
 590             }
 591 
 592             @Override
 593             public Type visitErrorType(ErrorType t, Symbol sym) {
 594                 return t;
 595             }
 596         };
 597     // &lt;/editor-fold&gt;
 598 
 599     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 600     /**
 601      * Is t a subtype of or convertible via boxing/unboxing
 602      * conversion to s?
 603      */
 604     public boolean isConvertible(Type t, Type s, Warner warn) {
 605         if (t.hasTag(ERROR)) {
 606             return true;
 607         }
 608 
 609         boolean tValue = t.isValue();
 610         boolean sValue = s.isValue();
 611         if (tValue != sValue) {
 612             return tValue ?
 613                     isSubtype(t.referenceProjection(), s) :
 614                     (!t.hasTag(BOT) || isValueBased(s)) &amp;&amp; isSubtype(t, s.referenceProjection());
 615         }
 616 
 617         boolean tPrimitive = t.isPrimitive();
 618         boolean sPrimitive = s.isPrimitive();
 619         if (tPrimitive == sPrimitive) {
 620             return isSubtypeUnchecked(t, s, warn);
 621         }
 622         boolean tUndet = t.hasTag(UNDETVAR);
 623         boolean sUndet = s.hasTag(UNDETVAR);
 624 
 625         if (tUndet || sUndet) {
 626             return tUndet ?
 627                     isSubtype(t, boxedTypeOrType(s)) :
 628                     isSubtype(boxedTypeOrType(t), s);
 629         }
 630 
 631         return tPrimitive
 632             ? isSubtype(boxedClass(t).type, s)
 633             : isSubtype(unboxedType(t), s);
 634     }
 635 
 636     /**
 637      * Is t a subtype of or convertible via boxing/unboxing
 638      * conversions to s?
 639      */
 640     public boolean isConvertible(Type t, Type s) {
 641         return isConvertible(t, s, noWarnings);
 642     }
 643     // &lt;/editor-fold&gt;
 644 
 645     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;findSam&quot;&gt;
 646 
 647     /**
 648      * Exception used to report a function descriptor lookup failure. The exception
 649      * wraps a diagnostic that can be used to generate more details error
 650      * messages.
 651      */
 652     public static class FunctionDescriptorLookupError extends RuntimeException {
 653         private static final long serialVersionUID = 0;
 654 
 655         transient JCDiagnostic diagnostic;
 656 
 657         FunctionDescriptorLookupError() {
 658             this.diagnostic = null;
 659         }
 660 
 661         FunctionDescriptorLookupError setMessage(JCDiagnostic diag) {
 662             this.diagnostic = diag;
 663             return this;
 664         }
 665 
 666         public JCDiagnostic getDiagnostic() {
 667             return diagnostic;
 668         }
 669     }
 670 
 671     /**
 672      * A cache that keeps track of function descriptors associated with given
 673      * functional interfaces.
 674      */
 675     class DescriptorCache {
 676 
 677         private WeakHashMap&lt;TypeSymbol, Entry&gt; _map = new WeakHashMap&lt;&gt;();
 678 
 679         class FunctionDescriptor {
 680             Symbol descSym;
 681 
 682             FunctionDescriptor(Symbol descSym) {
 683                 this.descSym = descSym;
 684             }
 685 
 686             public Symbol getSymbol() {
 687                 return descSym;
 688             }
 689 
 690             public Type getType(Type site) {
 691                 site = removeWildcards(site);
 692                 if (site.isIntersection()) {
 693                     IntersectionClassType ict = (IntersectionClassType)site;
 694                     for (Type component : ict.getExplicitComponents()) {
 695                         if (!chk.checkValidGenericType(component)) {
 696                             //if the inferred functional interface type is not well-formed,
 697                             //or if it&#39;s not a subtype of the original target, issue an error
 698                             throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 699                         }
 700                     }
 701                 } else {
 702                     if (!chk.checkValidGenericType(site)) {
 703                         //if the inferred functional interface type is not well-formed,
 704                         //or if it&#39;s not a subtype of the original target, issue an error
 705                         throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 706                     }
 707                 }
 708                 return memberType(site, descSym);
 709             }
 710         }
 711 
 712         class Entry {
 713             final FunctionDescriptor cachedDescRes;
 714             final int prevMark;
 715 
 716             public Entry(FunctionDescriptor cachedDescRes,
 717                     int prevMark) {
 718                 this.cachedDescRes = cachedDescRes;
 719                 this.prevMark = prevMark;
 720             }
 721 
 722             boolean matches(int mark) {
 723                 return  this.prevMark == mark;
 724             }
 725         }
 726 
 727         FunctionDescriptor get(TypeSymbol origin) throws FunctionDescriptorLookupError {
 728             Entry e = _map.get(origin);
 729             CompoundScope members = membersClosure(origin.type, false);
 730             if (e == null ||
 731                     !e.matches(members.getMark())) {
 732                 FunctionDescriptor descRes = findDescriptorInternal(origin, members);
 733                 _map.put(origin, new Entry(descRes, members.getMark()));
 734                 return descRes;
 735             }
 736             else {
 737                 return e.cachedDescRes;
 738             }
 739         }
 740 
 741         /**
 742          * Compute the function descriptor associated with a given functional interface
 743          */
 744         public FunctionDescriptor findDescriptorInternal(TypeSymbol origin,
 745                 CompoundScope membersCache) throws FunctionDescriptorLookupError {
 746             if (!origin.isInterface() || (origin.flags() &amp; ANNOTATION) != 0) {
 747                 //t must be an interface
 748                 throw failure(&quot;not.a.functional.intf&quot;, origin);
 749             }
 750 
 751             final ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
 752             for (Symbol sym : membersCache.getSymbols(new DescriptorFilter(origin))) {
 753                 Type mtype = memberType(origin.type, sym);
 754                 if (abstracts.isEmpty()) {
 755                     abstracts.append(sym);
 756                 } else if ((sym.name == abstracts.first().name &amp;&amp;
 757                         overrideEquivalent(mtype, memberType(origin.type, abstracts.first())))) {
 758                     if (!abstracts.stream().filter(msym -&gt; msym.owner.isSubClass(sym.enclClass(), Types.this))
 759                             .map(msym -&gt; memberType(origin.type, msym))
 760                             .anyMatch(abstractMType -&gt; isSubSignature(abstractMType, mtype))) {
 761                         abstracts.append(sym);
 762                     }
 763                 } else {
 764                     //the target method(s) should be the only abstract members of t
 765                     throw failure(&quot;not.a.functional.intf.1&quot;,  origin,
 766                             diags.fragment(Fragments.IncompatibleAbstracts(Kinds.kindName(origin), origin)));
 767                 }
 768             }
 769             if (abstracts.isEmpty()) {
 770                 //t must define a suitable non-generic method
 771                 throw failure(&quot;not.a.functional.intf.1&quot;, origin,
 772                             diags.fragment(Fragments.NoAbstracts(Kinds.kindName(origin), origin)));
 773             } else if (abstracts.size() == 1) {
 774                 return new FunctionDescriptor(abstracts.first());
 775             } else { // size &gt; 1
 776                 FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());
 777                 if (descRes == null) {
 778                     //we can get here if the functional interface is ill-formed
 779                     ListBuffer&lt;JCDiagnostic&gt; descriptors = new ListBuffer&lt;&gt;();
 780                     for (Symbol desc : abstracts) {
 781                         String key = desc.type.getThrownTypes().nonEmpty() ?
 782                                 &quot;descriptor.throws&quot; : &quot;descriptor&quot;;
 783                         descriptors.append(diags.fragment(key, desc.name,
 784                                 desc.type.getParameterTypes(),
 785                                 desc.type.getReturnType(),
 786                                 desc.type.getThrownTypes()));
 787                     }
 788                     JCDiagnostic msg =
 789                             diags.fragment(Fragments.IncompatibleDescsInFunctionalIntf(Kinds.kindName(origin),
 790                                                                                        origin));
 791                     JCDiagnostic.MultilineDiagnostic incompatibleDescriptors =
 792                             new JCDiagnostic.MultilineDiagnostic(msg, descriptors.toList());
 793                     throw failure(incompatibleDescriptors);
 794                 }
 795                 return descRes;
 796             }
 797         }
 798 
 799         /**
 800          * Compute a synthetic type for the target descriptor given a list
 801          * of override-equivalent methods in the functional interface type.
 802          * The resulting method type is a method type that is override-equivalent
 803          * and return-type substitutable with each method in the original list.
 804          */
 805         private FunctionDescriptor mergeDescriptors(TypeSymbol origin, List&lt;Symbol&gt; methodSyms) {
 806             return mergeAbstracts(methodSyms, origin.type, false)
 807                     .map(bestSoFar -&gt; new FunctionDescriptor(bestSoFar.baseSymbol()) {
 808                         @Override
 809                         public Type getType(Type origin) {
 810                             Type mt = memberType(origin, getSymbol());
 811                             return createMethodTypeWithThrown(mt, bestSoFar.type.getThrownTypes());
 812                         }
 813                     }).orElse(null);
 814         }
 815 
 816         FunctionDescriptorLookupError failure(String msg, Object... args) {
 817             return failure(diags.fragment(msg, args));
 818         }
 819 
 820         FunctionDescriptorLookupError failure(JCDiagnostic diag) {
 821             return new FunctionDescriptorLookupError().setMessage(diag);
 822         }
 823     }
 824 
 825     private DescriptorCache descCache = new DescriptorCache();
 826 
 827     /**
 828      * Find the method descriptor associated to this class symbol - if the
 829      * symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 830      */
 831     public Symbol findDescriptorSymbol(TypeSymbol origin) throws FunctionDescriptorLookupError {
 832         return descCache.get(origin).getSymbol();
 833     }
 834 
 835     /**
 836      * Find the type of the method descriptor associated to this class symbol -
 837      * if the symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 838      */
 839     public Type findDescriptorType(Type origin) throws FunctionDescriptorLookupError {
 840         return descCache.get(origin.tsym).getType(origin);
 841     }
 842 
 843     /**
 844      * Is given type a functional interface?
 845      */
 846     public boolean isFunctionalInterface(TypeSymbol tsym) {
 847         try {
 848             findDescriptorSymbol(tsym);
 849             return true;
 850         } catch (FunctionDescriptorLookupError ex) {
 851             return false;
 852         }
 853     }
 854 
 855     public boolean isFunctionalInterface(Type site) {
 856         try {
 857             findDescriptorType(site);
 858             return true;
 859         } catch (FunctionDescriptorLookupError ex) {
 860             return false;
 861         }
 862     }
 863 
 864     public Type removeWildcards(Type site) {
 865         if (site.getTypeArguments().stream().anyMatch(t -&gt; t.hasTag(WILDCARD))) {
 866             //compute non-wildcard parameterization - JLS 9.9
 867             List&lt;Type&gt; actuals = site.getTypeArguments();
 868             List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 869             ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
 870             for (Type formal : formals) {
 871                 Type actual = actuals.head;
 872                 Type bound = formal.getUpperBound();
 873                 if (actuals.head.hasTag(WILDCARD)) {
 874                     WildcardType wt = (WildcardType)actual;
 875                     //check that bound does not contain other formals
 876                     if (bound.containsAny(formals)) {
 877                         targs.add(wt.type);
 878                     } else {
 879                         //compute new type-argument based on declared bound and wildcard bound
 880                         switch (wt.kind) {
 881                             case UNBOUND:
 882                                 targs.add(bound);
 883                                 break;
 884                             case EXTENDS:
 885                                 targs.add(glb(bound, wt.type));
 886                                 break;
 887                             case SUPER:
 888                                 targs.add(wt.type);
 889                                 break;
 890                             default:
 891                                 Assert.error(&quot;Cannot get here!&quot;);
 892                         }
 893                     }
 894                 } else {
 895                     //not a wildcard - the new type argument remains unchanged
 896                     targs.add(actual);
 897                 }
 898                 actuals = actuals.tail;
 899             }
 900             return subst(site.tsym.type, formals, targs.toList());
 901         } else {
 902             return site;
 903         }
 904     }
 905 
 906     /**
 907      * Create a symbol for a class that implements a given functional interface
 908      * and overrides its functional descriptor. This routine is used for two
 909      * main purposes: (i) checking well-formedness of a functional interface;
 910      * (ii) perform functional interface bridge calculation.
 911      */
 912     public ClassSymbol makeFunctionalInterfaceClass(Env&lt;AttrContext&gt; env, Name name, Type target, long cflags) {
 913         if (target == null || target == syms.unknownType) {
 914             return null;
 915         }
 916         Symbol descSym = findDescriptorSymbol(target.tsym);
 917         Type descType = findDescriptorType(target);
 918         ClassSymbol csym = new ClassSymbol(cflags, name, env.enclClass.sym.outermostClass());
 919         csym.completer = Completer.NULL_COMPLETER;
 920         csym.members_field = WriteableScope.create(csym);
 921         MethodSymbol instDescSym = new MethodSymbol(descSym.flags(), descSym.name, descType, csym);
 922         csym.members_field.enter(instDescSym);
 923         Type.ClassType ctype = new Type.ClassType(Type.noType, List.nil(), csym);
 924         ctype.supertype_field = syms.objectType;
 925         ctype.interfaces_field = target.isIntersection() ?
 926                 directSupertypes(target) :
 927                 List.of(target);
 928         csym.type = ctype;
 929         csym.sourcefile = ((ClassSymbol)csym.owner).sourcefile;
 930         return csym;
 931     }
 932 
 933     /**
 934      * Find the minimal set of methods that are overridden by the functional
 935      * descriptor in &#39;origin&#39;. All returned methods are assumed to have different
 936      * erased signatures.
 937      */
 938     public List&lt;Symbol&gt; functionalInterfaceBridges(TypeSymbol origin) {
 939         Assert.check(isFunctionalInterface(origin));
 940         Symbol descSym = findDescriptorSymbol(origin);
 941         CompoundScope members = membersClosure(origin.type, false);
 942         ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
 943         outer: for (Symbol m2 : members.getSymbolsByName(descSym.name, bridgeFilter)) {
 944             if (m2 == descSym) continue;
 945             else if (descSym.overrides(m2, origin, Types.this, false)) {
 946                 for (Symbol m3 : overridden) {
 947                     if (isSameType(m3.erasure(Types.this), m2.erasure(Types.this)) ||
 948                             (m3.overrides(m2, origin, Types.this, false) &amp;&amp;
 949                             (pendingBridges((ClassSymbol)origin, m3.enclClass()) ||
 950                             (((MethodSymbol)m2).binaryImplementation((ClassSymbol)m3.owner, Types.this) != null)))) {
 951                         continue outer;
 952                     }
 953                 }
 954                 overridden.add(m2);
 955             }
 956         }
 957         return overridden.toList();
 958     }
 959     //where
 960         private Filter&lt;Symbol&gt; bridgeFilter = new Filter&lt;Symbol&gt;() {
 961             public boolean accepts(Symbol t) {
 962                 return t.kind == MTH &amp;&amp;
 963                         t.name != names.init &amp;&amp;
 964                         t.name != names.clinit &amp;&amp;
 965                         (t.flags() &amp; SYNTHETIC) == 0;
 966             }
 967         };
 968         private boolean pendingBridges(ClassSymbol origin, TypeSymbol s) {
 969             //a symbol will be completed from a classfile if (a) symbol has
 970             //an associated file object with CLASS kind and (b) the symbol has
 971             //not been entered
 972             if (origin.classfile != null &amp;&amp;
 973                     origin.classfile.getKind() == JavaFileObject.Kind.CLASS &amp;&amp;
 974                     enter.getEnv(origin) == null) {
 975                 return false;
 976             }
 977             if (origin == s) {
 978                 return true;
 979             }
 980             for (Type t : interfaces(origin.type)) {
 981                 if (pendingBridges((ClassSymbol)t.tsym, s)) {
 982                     return true;
 983                 }
 984             }
 985             return false;
 986         }
 987     // &lt;/editor-fold&gt;
 988 
 989    /**
 990     * Scope filter used to skip methods that should be ignored (such as methods
 991     * overridden by j.l.Object) during function interface conversion interface check
 992     */
 993     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 994 
 995        TypeSymbol origin;
 996 
 997        DescriptorFilter(TypeSymbol origin) {
 998            this.origin = origin;
 999        }
1000 
1001        @Override
1002        public boolean accepts(Symbol sym) {
1003            return sym.kind == MTH &amp;&amp;
1004                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
1005                    !overridesObjectMethod(origin, sym) &amp;&amp;
1006                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
1007        }
1008     }
1009 
1010     public boolean isValue(Type t) {
1011         return t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags_field &amp; Flags.VALUE) != 0;
1012     }
1013 
1014     public boolean isValueBased(Type t) {
1015         return allowValueBasedClasses &amp;&amp; t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags() &amp; Flags.VALUEBASED) != 0;
1016     }
1017 
1018     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
1019     /**
1020      * Is t an unchecked subtype of s?
1021      */
1022     public boolean isSubtypeUnchecked(Type t, Type s) {
1023         return isSubtypeUnchecked(t, s, noWarnings);
1024     }
1025     /**
1026      * Is t an unchecked subtype of s?
1027      */
1028     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1029         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1030         if (result) {
1031             checkUnsafeVarargsConversion(t, s, warn);
1032         }
1033         return result;
1034     }
1035     //where
1036         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1037             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1038                 if (((ArrayType)t).elemtype.isPrimitive()) {
1039                     return isSameType(elemtype(t), elemtype(s));
1040                 } else {
1041                     // if T.ref &lt;: S, then T[] &lt;: S[]
1042                     Type es = elemtype(s);
1043                     Type et = elemtype(t);
1044                     if (isValue(et)) {
1045                         et = et.referenceProjection();
1046                         if (isValue(es))
1047                             es = es.referenceProjection();  // V &lt;: V, surely
1048                     }
1049                     if (!isSubtypeUncheckedInternal(et, es, false, warn))
1050                         return false;
1051                     return true;
1052                 }
1053             } else if (isSubtype(t, s, capture)) {
1054                 return true;
1055             } else if (t.hasTag(TYPEVAR)) {
1056                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1057             } else if (!s.isRaw()) {
1058                 Type t2 = asSuper(t, s.tsym);
1059                 if (t2 != null &amp;&amp; t2.isRaw()) {
1060                     if (isReifiable(s)) {
1061                         warn.silentWarn(LintCategory.UNCHECKED);
1062                     } else {
1063                         warn.warn(LintCategory.UNCHECKED);
1064                     }
1065                     return true;
1066                 }
1067             }
1068             return false;
1069         }
1070 
1071         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
1072             if (!t.hasTag(ARRAY) || isReifiable(t)) {
1073                 return;
1074             }
1075             ArrayType from = (ArrayType)t;
1076             boolean shouldWarn = false;
1077             switch (s.getTag()) {
1078                 case ARRAY:
1079                     ArrayType to = (ArrayType)s;
1080                     shouldWarn = from.isVarargs() &amp;&amp;
1081                             !to.isVarargs() &amp;&amp;
1082                             !isReifiable(from);
1083                     break;
1084                 case CLASS:
1085                     shouldWarn = from.isVarargs();
1086                     break;
1087             }
1088             if (shouldWarn) {
1089                 warn.warn(LintCategory.VARARGS);
1090             }
1091         }
1092 
1093     /**
1094      * Is t a subtype of s?&lt;br&gt;
1095      * (not defined for Method and ForAll types)
1096      */
1097     final public boolean isSubtype(Type t, Type s) {
1098         return isSubtype(t, s, true);
1099     }
1100     final public boolean isSubtypeNoCapture(Type t, Type s) {
1101         return isSubtype(t, s, false);
1102     }
1103     public boolean isSubtype(Type t, Type s, boolean capture) {
1104         if (t.equalsIgnoreMetadata(s))
1105             return true;
1106         if (s.isPartial())
1107             return isSuperType(s, t);
1108 
1109         if (s.isCompound()) {
1110             for (Type s2 : interfaces(s).prepend(supertype(s))) {
1111                 if (!isSubtype(t, s2, capture))
1112                     return false;
1113             }
1114             return true;
1115         }
1116 
1117         // Generally, if &#39;s&#39; is a lower-bounded type variable, recur on lower bound; but
1118         // for inference variables and intersections, we need to keep &#39;s&#39;
1119         // (see JLS 4.10.2 for intersections and 18.2.3 for inference vars)
1120         if (!t.hasTag(UNDETVAR) &amp;&amp; !t.isCompound()) {
1121             // TODO: JDK-8039198, bounds checking sometimes passes in a wildcard as s
1122             Type lower = cvarLowerBound(wildLowerBound(s));
1123             if (s != lower &amp;&amp; !lower.hasTag(BOT))
1124                 return isSubtype(capture ? capture(t) : t, lower, false);
1125         }
1126 
1127         return isSubtype.visit(capture ? capture(t) : t, s);
1128     }
1129     // where
1130         private TypeRelation isSubtype = new TypeRelation()
1131         {
1132             @Override
1133             public Boolean visitType(Type t, Type s) {
1134                 switch (t.getTag()) {
1135                  case BYTE:
1136                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1137                  case CHAR:
1138                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1139                  case SHORT: case INT: case LONG:
1140                  case FLOAT: case DOUBLE:
1141                      return t.getTag().isSubRangeOf(s.getTag());
1142                  case BOOLEAN: case VOID:
1143                      return t.hasTag(s.getTag());
1144                  case TYPEVAR:
1145                      return isSubtypeNoCapture(t.getUpperBound(), s);
1146                  case BOT:
1147                      return
1148                          s.hasTag(BOT) || (s.hasTag(CLASS) &amp;&amp; (!isValue(s) || isValueBased(s))) ||
1149                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1150                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1151                  case NONE:
1152                      return false;
1153                  default:
1154                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1155                  }
1156             }
1157 
1158             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1159 
1160             private boolean containsTypeRecursive(Type t, Type s) {
1161                 TypePair pair = new TypePair(t, s);
1162                 if (cache.add(pair)) {
1163                     try {
1164                         return containsType(t.getTypeArguments(),
1165                                             s.getTypeArguments());
1166                     } finally {
1167                         cache.remove(pair);
1168                     }
1169                 } else {
1170                     return containsType(t.getTypeArguments(),
1171                                         rewriteSupers(s).getTypeArguments());
1172                 }
1173             }
1174 
1175             private Type rewriteSupers(Type t) {
1176                 if (!t.isParameterized())
1177                     return t;
1178                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
1179                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
1180                 adaptSelf(t, from, to);
1181                 if (from.isEmpty())
1182                     return t;
1183                 ListBuffer&lt;Type&gt; rewrite = new ListBuffer&lt;&gt;();
1184                 boolean changed = false;
1185                 for (Type orig : to.toList()) {
1186                     Type s = rewriteSupers(orig);
1187                     if (s.isSuperBound() &amp;&amp; !s.isExtendsBound()) {
1188                         s = new WildcardType(syms.objectType,
1189                                              BoundKind.UNBOUND,
1190                                              syms.boundClass,
1191                                              s.getMetadata());
1192                         changed = true;
1193                     } else if (s != orig) {
1194                         s = new WildcardType(wildUpperBound(s),
1195                                              BoundKind.EXTENDS,
1196                                              syms.boundClass,
1197                                              s.getMetadata());
1198                         changed = true;
1199                     }
1200                     rewrite.append(s);
1201                 }
1202                 if (changed)
1203                     return subst(t.tsym.type, from.toList(), rewrite.toList());
1204                 else
1205                     return t;
1206             }
1207 
1208             @Override
1209             public Boolean visitClassType(ClassType t, Type s) {
1210                 Type sup = asSuper(t, s.tsym);
1211                 if (sup == null) return false;
1212                 // If t is an intersection, sup might not be a class type
1213                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1214                 return sup.tsym == s.tsym
1215                      // Check type variable containment
1216                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1217                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1218                                           s.getEnclosingType());
1219             }
1220 
1221             @Override
1222             public Boolean visitArrayType(ArrayType t, Type s) {
1223                 if (s.hasTag(ARRAY)) {
1224                     if (t.elemtype.isPrimitive())
1225                         return isSameType(t.elemtype, elemtype(s));
1226                     else {
1227                         // if T.ref &lt;: S, then T[] &lt;: S[]
1228                         Type es = elemtype(s);
1229                         Type et = elemtype(t);
1230                         if (isValue(et)) {
1231                             et = et.referenceProjection();
1232                             if (isValue(es))
1233                                 es = es.referenceProjection();  // V &lt;: V, surely
1234                         }
1235                         return isSubtypeNoCapture(et, es);
1236                     }
1237                 }
1238 
1239                 if (s.hasTag(CLASS)) {
1240                     Name sname = s.tsym.getQualifiedName();
1241                     return sname == names.java_lang_Object
1242                         || sname == names.java_lang_Cloneable
1243                         || sname == names.java_io_Serializable
<a name="3" id="anc3"></a><span class="line-modified">1244                         || sname == names.java_lang_IdentityObject;</span>
1245                 }
1246 
1247                 return false;
1248             }
1249 
1250             @Override
1251             public Boolean visitUndetVar(UndetVar t, Type s) {
1252                 //todo: test against origin needed? or replace with substitution?
1253                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1254                     return true;
1255                 } else if (s.hasTag(BOT)) {
1256                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1257                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1258                     return false;
1259                 }
1260 
1261                 t.addBound(InferenceBound.UPPER, s, Types.this);
1262                 return true;
1263             }
1264 
1265             @Override
1266             public Boolean visitErrorType(ErrorType t, Type s) {
1267                 return true;
1268             }
1269         };
1270 
1271     /**
1272      * Is t a subtype of every type in given list `ts&#39;?&lt;br&gt;
1273      * (not defined for Method and ForAll types)&lt;br&gt;
1274      * Allows unchecked conversions.
1275      */
1276     public boolean isSubtypeUnchecked(Type t, List&lt;Type&gt; ts, Warner warn) {
1277         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1278             if (!isSubtypeUnchecked(t, l.head, warn))
1279                 return false;
1280         return true;
1281     }
1282 
1283     /**
1284      * Are corresponding elements of ts subtypes of ss?  If lists are
1285      * of different length, return false.
1286      */
1287     public boolean isSubtypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1288         while (ts.tail != null &amp;&amp; ss.tail != null
1289                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1290                isSubtype(ts.head, ss.head)) {
1291             ts = ts.tail;
1292             ss = ss.tail;
1293         }
1294         return ts.tail == null &amp;&amp; ss.tail == null;
1295         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1296     }
1297 
1298     /**
1299      * Are corresponding elements of ts subtypes of ss, allowing
1300      * unchecked conversions?  If lists are of different length,
1301      * return false.
1302      **/
1303     public boolean isSubtypesUnchecked(List&lt;Type&gt; ts, List&lt;Type&gt; ss, Warner warn) {
1304         while (ts.tail != null &amp;&amp; ss.tail != null
1305                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1306                isSubtypeUnchecked(ts.head, ss.head, warn)) {
1307             ts = ts.tail;
1308             ss = ss.tail;
1309         }
1310         return ts.tail == null &amp;&amp; ss.tail == null;
1311         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1312     }
1313     // &lt;/editor-fold&gt;
1314 
1315     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSuperType&quot;&gt;
1316     /**
1317      * Is t a supertype of s?
1318      */
1319     public boolean isSuperType(Type t, Type s) {
1320         switch (t.getTag()) {
1321         case ERROR:
1322             return true;
1323         case UNDETVAR: {
1324             UndetVar undet = (UndetVar)t;
1325             if (t == s ||
1326                 undet.qtype == s ||
1327                 s.hasTag(ERROR) ||
1328                 s.hasTag(BOT)) {
1329                 return true;
1330             }
1331             undet.addBound(InferenceBound.LOWER, s, this);
1332             return true;
1333         }
1334         default:
1335             return isSubtype(s, t);
1336         }
1337     }
1338     // &lt;/editor-fold&gt;
1339 
1340     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSameType&quot;&gt;
1341     /**
1342      * Are corresponding elements of the lists the same type?  If
1343      * lists are of different length, return false.
1344      */
1345     public boolean isSameTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1346         while (ts.tail != null &amp;&amp; ss.tail != null
1347                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1348                isSameType(ts.head, ss.head)) {
1349             ts = ts.tail;
1350             ss = ss.tail;
1351         }
1352         return ts.tail == null &amp;&amp; ss.tail == null;
1353         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1354     }
1355 
1356     /**
1357      * A polymorphic signature method (JLS 15.12.3) is a method that
1358      *   (i) is declared in the java.lang.invoke.MethodHandle/VarHandle classes;
1359      *  (ii) takes a single variable arity parameter;
1360      * (iii) whose declared type is Object[];
1361      *  (iv) has any return type, Object signifying a polymorphic return type; and
1362      *   (v) is native.
1363     */
1364    public boolean isSignaturePolymorphic(MethodSymbol msym) {
1365        List&lt;Type&gt; argtypes = msym.type.getParameterTypes();
1366        return (msym.flags_field &amp; NATIVE) != 0 &amp;&amp;
1367               (msym.owner == syms.methodHandleType.tsym || msym.owner == syms.varHandleType.tsym) &amp;&amp;
1368                argtypes.length() == 1 &amp;&amp;
1369                argtypes.head.hasTag(TypeTag.ARRAY) &amp;&amp;
1370                ((ArrayType)argtypes.head).elemtype.tsym == syms.objectType.tsym;
1371    }
1372 
1373     /**
1374      * Is t the same type as s?
1375      */
1376     public boolean isSameType(Type t, Type s) {
1377         return isSameTypeVisitor.visit(t, s);
1378     }
1379     // where
1380 
1381         /**
1382          * Type-equality relation - type variables are considered
1383          * equals if they share the same object identity.
1384          */
1385         TypeRelation isSameTypeVisitor = new TypeRelation() {
1386 
1387             public Boolean visitType(Type t, Type s) {
1388                 if (t.equalsIgnoreMetadata(s))
1389                     return true;
1390 
1391                 if (s.isPartial())
1392                     return visit(s, t);
1393 
1394                 switch (t.getTag()) {
1395                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1396                 case DOUBLE: case BOOLEAN: case VOID: case BOT: case NONE:
1397                     return t.hasTag(s.getTag());
1398                 case TYPEVAR: {
1399                     if (s.hasTag(TYPEVAR)) {
1400                         //type-substitution does not preserve type-var types
1401                         //check that type var symbols and bounds are indeed the same
1402                         return t == s;
1403                     }
1404                     else {
1405                         //special case for s == ? super X, where upper(s) = u
1406                         //check that u == t, where u has been set by Type.withTypeVar
1407                         return s.isSuperBound() &amp;&amp;
1408                                 !s.isExtendsBound() &amp;&amp;
1409                                 visit(t, wildUpperBound(s));
1410                     }
1411                 }
1412                 default:
1413                     throw new AssertionError(&quot;isSameType &quot; + t.getTag());
1414                 }
1415             }
1416 
1417             @Override
1418             public Boolean visitWildcardType(WildcardType t, Type s) {
1419                 if (!s.hasTag(WILDCARD)) {
1420                     return false;
1421                 } else {
1422                     WildcardType t2 = (WildcardType)s;
1423                     return (t.kind == t2.kind || (t.isExtendsBound() &amp;&amp; s.isExtendsBound())) &amp;&amp;
1424                             isSameType(t.type, t2.type);
1425                 }
1426             }
1427 
1428             @Override
1429             public Boolean visitClassType(ClassType t, Type s) {
1430                 if (t == s)
1431                     return true;
1432 
1433                 if (s.isPartial())
1434                     return visit(s, t);
1435 
1436                 if (s.isSuperBound() &amp;&amp; !s.isExtendsBound())
1437                     return visit(t, wildUpperBound(s)) &amp;&amp; visit(t, wildLowerBound(s));
1438 
1439                 if (t.isCompound() &amp;&amp; s.isCompound()) {
1440                     if (!visit(supertype(t), supertype(s)))
1441                         return false;
1442 
1443                     Map&lt;Symbol,Type&gt; tMap = new HashMap&lt;&gt;();
1444                     for (Type ti : interfaces(t)) {
1445                         if (tMap.containsKey(ti)) {
1446                             throw new AssertionError(&quot;Malformed intersection&quot;);
1447                         }
1448                         tMap.put(ti.tsym, ti);
1449                     }
1450                     for (Type si : interfaces(s)) {
1451                         if (!tMap.containsKey(si.tsym))
1452                             return false;
1453                         Type ti = tMap.remove(si.tsym);
1454                         if (!visit(ti, si))
1455                             return false;
1456                     }
1457                     return tMap.isEmpty();
1458                 }
1459                 return t.tsym == s.tsym
1460                     &amp;&amp; visit(t.getEnclosingType(), s.getEnclosingType())
1461                     &amp;&amp; containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());
1462             }
1463 
1464             @Override
1465             public Boolean visitArrayType(ArrayType t, Type s) {
1466                 if (t == s)
1467                     return true;
1468 
1469                 if (s.isPartial())
1470                     return visit(s, t);
1471 
1472                 return s.hasTag(ARRAY)
1473                     &amp;&amp; containsTypeEquivalent(t.elemtype, elemtype(s));
1474             }
1475 
1476             @Override
1477             public Boolean visitMethodType(MethodType t, Type s) {
1478                 // isSameType for methods does not take thrown
1479                 // exceptions into account!
1480                 return hasSameArgs(t, s) &amp;&amp; visit(t.getReturnType(), s.getReturnType());
1481             }
1482 
1483             @Override
1484             public Boolean visitPackageType(PackageType t, Type s) {
1485                 return t == s;
1486             }
1487 
1488             @Override
1489             public Boolean visitForAll(ForAll t, Type s) {
1490                 if (!s.hasTag(FORALL)) {
1491                     return false;
1492                 }
1493 
1494                 ForAll forAll = (ForAll)s;
1495                 return hasSameBounds(t, forAll)
1496                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
1497             }
1498 
1499             @Override
1500             public Boolean visitUndetVar(UndetVar t, Type s) {
1501                 if (s.hasTag(WILDCARD)) {
1502                     // FIXME, this might be leftovers from before capture conversion
1503                     return false;
1504                 }
1505 
1506                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1507                     return true;
1508                 }
1509 
1510                 t.addBound(InferenceBound.EQ, s, Types.this);
1511 
1512                 return true;
1513             }
1514 
1515             @Override
1516             public Boolean visitErrorType(ErrorType t, Type s) {
1517                 return true;
1518             }
1519         };
1520 
1521     // &lt;/editor-fold&gt;
1522 
1523     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Contains Type&quot;&gt;
1524     public boolean containedBy(Type t, Type s) {
1525         switch (t.getTag()) {
1526         case UNDETVAR:
1527             if (s.hasTag(WILDCARD)) {
1528                 UndetVar undetvar = (UndetVar)t;
1529                 WildcardType wt = (WildcardType)s;
1530                 switch(wt.kind) {
1531                     case UNBOUND:
1532                         break;
1533                     case EXTENDS: {
1534                         Type bound = wildUpperBound(s);
1535                         undetvar.addBound(InferenceBound.UPPER, bound, this);
1536                         break;
1537                     }
1538                     case SUPER: {
1539                         Type bound = wildLowerBound(s);
1540                         undetvar.addBound(InferenceBound.LOWER, bound, this);
1541                         break;
1542                     }
1543                 }
1544                 return true;
1545             } else {
1546                 return isSameType(t, s);
1547             }
1548         case ERROR:
1549             return true;
1550         default:
1551             return containsType(s, t);
1552         }
1553     }
1554 
1555     boolean containsType(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1556         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1557                &amp;&amp; containsType(ts.head, ss.head)) {
1558             ts = ts.tail;
1559             ss = ss.tail;
1560         }
1561         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1562     }
1563 
1564     /**
1565      * Check if t contains s.
1566      *
1567      * &lt;p&gt;T contains S if:
1568      *
1569      * &lt;p&gt;{@code L(T) &lt;: L(S) &amp;&amp; U(S) &lt;: U(T)}
1570      *
1571      * &lt;p&gt;This relation is only used by ClassType.isSubtype(), that
1572      * is,
1573      *
1574      * &lt;p&gt;{@code C&lt;S&gt; &lt;: C&lt;T&gt; if T contains S.}
1575      *
1576      * &lt;p&gt;Because of F-bounds, this relation can lead to infinite
1577      * recursion.  Thus we must somehow break that recursion.  Notice
1578      * that containsType() is only called from ClassType.isSubtype().
1579      * Since the arguments have already been checked against their
1580      * bounds, we know:
1581      *
1582      * &lt;p&gt;{@code U(S) &lt;: U(T) if T is &quot;super&quot; bound (U(T) *is* the bound)}
1583      *
1584      * &lt;p&gt;{@code L(T) &lt;: L(S) if T is &quot;extends&quot; bound (L(T) is bottom)}
1585      *
1586      * @param t a type
1587      * @param s a type
1588      */
1589     public boolean containsType(Type t, Type s) {
1590         return containsType.visit(t, s);
1591     }
1592     // where
1593         private TypeRelation containsType = new TypeRelation() {
1594 
1595             public Boolean visitType(Type t, Type s) {
1596                 if (s.isPartial())
1597                     return containedBy(s, t);
1598                 else
1599                     return isSameType(t, s);
1600             }
1601 
1602 //            void debugContainsType(WildcardType t, Type s) {
1603 //                System.err.println();
1604 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1605 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1606 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1607 //                                  t.isSuperBound()
1608 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1609 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1610 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1611 //                                  t.isExtendsBound()
1612 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1613 //                System.err.println();
1614 //            }
1615 
1616             @Override
1617             public Boolean visitWildcardType(WildcardType t, Type s) {
1618                 if (s.isPartial())
1619                     return containedBy(s, t);
1620                 else {
1621 //                    debugContainsType(t, s);
1622 
1623                     // -----------------------------------  Unspecified behavior ----------------
1624 
1625                     /* If a value class V implements an interface I, then does &quot;? extends I&quot; contain V?
1626                        It seems widening must be applied here to answer yes to compile some common code
1627                        patterns.
1628                     */
1629 
1630                     // ---------------------------------------------------------------------------
1631                     return isSameWildcard(t, s)
1632                         || isCaptureOf(s, t)
1633                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1634                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1635                 }
1636             }
1637 
1638             @Override
1639             public Boolean visitUndetVar(UndetVar t, Type s) {
1640                 if (!s.hasTag(WILDCARD)) {
1641                     return isSameType(t, s);
1642                 } else {
1643                     return false;
1644                 }
1645             }
1646 
1647             @Override
1648             public Boolean visitErrorType(ErrorType t, Type s) {
1649                 return true;
1650             }
1651         };
1652 
1653     public boolean isCaptureOf(Type s, WildcardType t) {
1654         if (!s.hasTag(TYPEVAR) || !((TypeVar)s).isCaptured())
1655             return false;
1656         return isSameWildcard(t, ((CapturedType)s).wildcard);
1657     }
1658 
1659     public boolean isSameWildcard(WildcardType t, Type s) {
1660         if (!s.hasTag(WILDCARD))
1661             return false;
1662         WildcardType w = (WildcardType)s;
1663         return w.kind == t.kind &amp;&amp; w.type == t.type;
1664     }
1665 
1666     public boolean containsTypeEquivalent(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1667         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1668                &amp;&amp; containsTypeEquivalent(ts.head, ss.head)) {
1669             ts = ts.tail;
1670             ss = ss.tail;
1671         }
1672         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1673     }
1674     // &lt;/editor-fold&gt;
1675 
1676     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isCastable&quot;&gt;
1677     public boolean isCastable(Type t, Type s) {
1678         return isCastable(t, s, noWarnings);
1679     }
1680 
1681     /**
1682      * Is t is castable to s?&lt;br&gt;
1683      * s is assumed to be an erased type.&lt;br&gt;
1684      * (not defined for Method and ForAll types).
1685      */
1686     public boolean isCastable(Type t, Type s, Warner warn) {
1687         if (t == s)
1688             return true;
1689         if (t.isPrimitive() != s.isPrimitive()) {
1690             t = skipTypeVars(t, false);
1691             return (isConvertible(t, s, warn)
1692                     || (s.isPrimitive() &amp;&amp;
1693                         isSubtype(boxedClass(s).type, t)));
1694         }
1695         if (warn != warnStack.head) {
1696             try {
1697                 warnStack = warnStack.prepend(warn);
1698                 checkUnsafeVarargsConversion(t, s, warn);
1699                 return isCastable.visit(t,s);
1700             } finally {
1701                 warnStack = warnStack.tail;
1702             }
1703         } else {
1704             return isCastable.visit(t,s);
1705         }
1706     }
1707     // where
1708         private TypeRelation isCastable = new TypeRelation() {
1709 
1710             public Boolean visitType(Type t, Type s) {
1711                 if (s.hasTag(ERROR) || t.hasTag(NONE))
1712                     return true;
1713 
1714                 switch (t.getTag()) {
1715                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1716                 case DOUBLE:
1717                     return s.isNumeric();
1718                 case BOOLEAN:
1719                     return s.hasTag(BOOLEAN);
1720                 case VOID:
1721                     return false;
1722                 case BOT:
1723                     return isSubtype(t, s);
1724                 default:
1725                     throw new AssertionError();
1726                 }
1727             }
1728 
1729             @Override
1730             public Boolean visitWildcardType(WildcardType t, Type s) {
1731                 return isCastable(wildUpperBound(t), s, warnStack.head);
1732             }
1733 
1734             @Override
1735             public Boolean visitClassType(ClassType t, Type s) {
1736                 if (s.hasTag(ERROR) || (s.hasTag(BOT) &amp;&amp; !isValue(t)))
1737                     return true;
1738 
1739                 if (s.hasTag(TYPEVAR)) {
1740                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1741                         warnStack.head.warn(LintCategory.UNCHECKED);
1742                         return true;
1743                     } else {
1744                         return false;
1745                     }
1746                 }
1747 
1748                 if (t.isCompound() || s.isCompound()) {
1749                     return !t.isCompound() ?
1750                             visitCompoundType((ClassType)s, t, true) :
1751                             visitCompoundType(t, s, false);
1752                 }
1753 
1754                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
1755                     if (isValue(t)) {
1756                         // (s) Value ? == (s) Value.ref
1757                         t = t.referenceProjection();
1758                     }
1759                     if (isValue(s)) {
1760                         // (Value) t ? == (Value.ref) t
1761                         s = s.referenceProjection();
1762                     }
1763                     boolean upcast;
1764                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1765                         || isSubtype(erasure(s), erasure(t))) {
1766                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1767                             if (!isReifiable(s))
1768                                 warnStack.head.warn(LintCategory.UNCHECKED);
1769                             return true;
1770                         } else if (s.isRaw()) {
1771                             return true;
1772                         } else if (t.isRaw()) {
1773                             if (!isUnbounded(s))
1774                                 warnStack.head.warn(LintCategory.UNCHECKED);
1775                             return true;
1776                         }
1777                         // Assume |a| &lt;: |b|
1778                         final Type a = upcast ? t : s;
1779                         final Type b = upcast ? s : t;
1780                         final boolean HIGH = true;
1781                         final boolean LOW = false;
1782                         final boolean DONT_REWRITE_TYPEVARS = false;
1783                         Type aHigh = rewriteQuantifiers(a, HIGH, DONT_REWRITE_TYPEVARS);
1784                         Type aLow  = rewriteQuantifiers(a, LOW,  DONT_REWRITE_TYPEVARS);
1785                         Type bHigh = rewriteQuantifiers(b, HIGH, DONT_REWRITE_TYPEVARS);
1786                         Type bLow  = rewriteQuantifiers(b, LOW,  DONT_REWRITE_TYPEVARS);
1787                         Type lowSub = asSub(bLow, aLow.tsym);
1788                         Type highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1789                         if (highSub == null) {
1790                             final boolean REWRITE_TYPEVARS = true;
1791                             aHigh = rewriteQuantifiers(a, HIGH, REWRITE_TYPEVARS);
1792                             aLow  = rewriteQuantifiers(a, LOW,  REWRITE_TYPEVARS);
1793                             bHigh = rewriteQuantifiers(b, HIGH, REWRITE_TYPEVARS);
1794                             bLow  = rewriteQuantifiers(b, LOW,  REWRITE_TYPEVARS);
1795                             lowSub = asSub(bLow, aLow.tsym);
1796                             highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1797                         }
1798                         if (highSub != null) {
1799                             if (!(a.tsym == highSub.tsym &amp;&amp; a.tsym == lowSub.tsym)) {
1800                                 Assert.error(a.tsym + &quot; != &quot; + highSub.tsym + &quot; != &quot; + lowSub.tsym);
1801                             }
1802                             if (!disjointTypes(aHigh.allparams(), highSub.allparams())
1803                                 &amp;&amp; !disjointTypes(aHigh.allparams(), lowSub.allparams())
1804                                 &amp;&amp; !disjointTypes(aLow.allparams(), highSub.allparams())
1805                                 &amp;&amp; !disjointTypes(aLow.allparams(), lowSub.allparams())) {
1806                                 if (upcast ? giveWarning(a, b) :
1807                                     giveWarning(b, a))
1808                                     warnStack.head.warn(LintCategory.UNCHECKED);
1809                                 return true;
1810                             }
1811                         }
1812                         if (isReifiable(s))
1813                             return isSubtypeUnchecked(a, b);
1814                         else
1815                             return isSubtypeUnchecked(a, b, warnStack.head);
1816                     }
1817 
1818                     // Sidecast
1819                     if (s.hasTag(CLASS)) {
1820                         if ((s.tsym.flags() &amp; INTERFACE) != 0) {
1821                             return ((t.tsym.flags() &amp; FINAL) == 0)
1822                                 ? sideCast(t, s, warnStack.head)
1823                                 : sideCastFinal(t, s, warnStack.head);
1824                         } else if ((t.tsym.flags() &amp; INTERFACE) != 0) {
1825                             return ((s.tsym.flags() &amp; FINAL) == 0)
1826                                 ? sideCast(t, s, warnStack.head)
1827                                 : sideCastFinal(t, s, warnStack.head);
1828                         } else {
1829                             // unrelated class types
1830                             return false;
1831                         }
1832                     }
1833                 }
1834                 return false;
1835             }
1836 
1837             boolean visitCompoundType(ClassType ct, Type s, boolean reverse) {
1838                 Warner warn = noWarnings;
1839                 for (Type c : directSupertypes(ct)) {
1840                     warn.clear();
1841                     if (reverse ? !isCastable(s, c, warn) : !isCastable(c, s, warn))
1842                         return false;
1843                 }
1844                 if (warn.hasLint(LintCategory.UNCHECKED))
1845                     warnStack.head.warn(LintCategory.UNCHECKED);
1846                 return true;
1847             }
1848 
1849             @Override
1850             public Boolean visitArrayType(ArrayType t, Type s) {
1851                 switch (s.getTag()) {
1852                 case ERROR:
1853                 case BOT:
1854                     return true;
1855                 case TYPEVAR:
1856                     if (isCastable(s, t, noWarnings)) {
1857                         warnStack.head.warn(LintCategory.UNCHECKED);
1858                         return true;
1859                     } else {
1860                         return false;
1861                     }
1862                 case CLASS:
1863                     return isSubtype(t, s);
1864                 case ARRAY:
1865                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1866                         return elemtype(t).hasTag(elemtype(s).getTag());
1867                     } else {
1868                         Type et = elemtype(t);
1869                         Type es = elemtype(s);
1870                         if (!visit(et, es))
1871                             return false;
1872                         return true;
1873                     }
1874                 default:
1875                     return false;
1876                 }
1877             }
1878 
1879             @Override
1880             public Boolean visitTypeVar(TypeVar t, Type s) {
1881                 switch (s.getTag()) {
1882                 case ERROR:
1883                 case BOT:
1884                     return true;
1885                 case TYPEVAR:
1886                     if (isSubtype(t, s)) {
1887                         return true;
1888                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1889                         warnStack.head.warn(LintCategory.UNCHECKED);
1890                         return true;
1891                     } else {
1892                         return false;
1893                     }
1894                 default:
1895                     return isCastable(t.getUpperBound(), s, warnStack.head);
1896                 }
1897             }
1898 
1899             @Override
1900             public Boolean visitErrorType(ErrorType t, Type s) {
1901                 return true;
1902             }
1903         };
1904     // &lt;/editor-fold&gt;
1905 
1906     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;disjointTypes&quot;&gt;
1907     public boolean disjointTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1908         while (ts.tail != null &amp;&amp; ss.tail != null) {
1909             if (disjointType(ts.head, ss.head)) return true;
1910             ts = ts.tail;
1911             ss = ss.tail;
1912         }
1913         return false;
1914     }
1915 
1916     /**
1917      * Two types or wildcards are considered disjoint if it can be
1918      * proven that no type can be contained in both. It is
1919      * conservative in that it is allowed to say that two types are
1920      * not disjoint, even though they actually are.
1921      *
1922      * The type {@code C&lt;X&gt;} is castable to {@code C&lt;Y&gt;} exactly if
1923      * {@code X} and {@code Y} are not disjoint.
1924      */
1925     public boolean disjointType(Type t, Type s) {
1926         return disjointType.visit(t, s);
1927     }
1928     // where
1929         private TypeRelation disjointType = new TypeRelation() {
1930 
1931             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1932 
1933             @Override
1934             public Boolean visitType(Type t, Type s) {
1935                 if (s.hasTag(WILDCARD))
1936                     return visit(s, t);
1937                 else
1938                     return notSoftSubtypeRecursive(t, s) || notSoftSubtypeRecursive(s, t);
1939             }
1940 
1941             private boolean isCastableRecursive(Type t, Type s) {
1942                 TypePair pair = new TypePair(t, s);
1943                 if (cache.add(pair)) {
1944                     try {
1945                         return Types.this.isCastable(t, s);
1946                     } finally {
1947                         cache.remove(pair);
1948                     }
1949                 } else {
1950                     return true;
1951                 }
1952             }
1953 
1954             private boolean notSoftSubtypeRecursive(Type t, Type s) {
1955                 TypePair pair = new TypePair(t, s);
1956                 if (cache.add(pair)) {
1957                     try {
1958                         return Types.this.notSoftSubtype(t, s);
1959                     } finally {
1960                         cache.remove(pair);
1961                     }
1962                 } else {
1963                     return false;
1964                 }
1965             }
1966 
1967             @Override
1968             public Boolean visitWildcardType(WildcardType t, Type s) {
1969                 if (t.isUnbound())
1970                     return false;
1971 
1972                 if (!s.hasTag(WILDCARD)) {
1973                     if (t.isExtendsBound())
1974                         return notSoftSubtypeRecursive(s, t.type);
1975                     else
1976                         return notSoftSubtypeRecursive(t.type, s);
1977                 }
1978 
1979                 if (s.isUnbound())
1980                     return false;
1981 
1982                 if (t.isExtendsBound()) {
1983                     if (s.isExtendsBound())
1984                         return !isCastableRecursive(t.type, wildUpperBound(s));
1985                     else if (s.isSuperBound())
1986                         return notSoftSubtypeRecursive(wildLowerBound(s), t.type);
1987                 } else if (t.isSuperBound()) {
1988                     if (s.isExtendsBound())
1989                         return notSoftSubtypeRecursive(t.type, wildUpperBound(s));
1990                 }
1991                 return false;
1992             }
1993         };
1994     // &lt;/editor-fold&gt;
1995 
1996     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;cvarLowerBounds&quot;&gt;
1997     public List&lt;Type&gt; cvarLowerBounds(List&lt;Type&gt; ts) {
1998         return ts.map(cvarLowerBoundMapping);
1999     }
2000         private final TypeMapping&lt;Void&gt; cvarLowerBoundMapping = new TypeMapping&lt;Void&gt;() {
2001             @Override
2002             public Type visitCapturedType(CapturedType t, Void _unused) {
2003                 return cvarLowerBound(t);
2004             }
2005         };
2006     // &lt;/editor-fold&gt;
2007 
2008     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;notSoftSubtype&quot;&gt;
2009     /**
2010      * This relation answers the question: is impossible that
2011      * something of type `t&#39; can be a subtype of `s&#39;? This is
2012      * different from the question &quot;is `t&#39; not a subtype of `s&#39;?&quot;
2013      * when type variables are involved: Integer is not a subtype of T
2014      * where {@code &lt;T extends Number&gt;} but it is not true that Integer cannot
2015      * possibly be a subtype of T.
2016      */
2017     public boolean notSoftSubtype(Type t, Type s) {
2018         if (t == s) return false;
2019         if (t.hasTag(TYPEVAR)) {
2020             TypeVar tv = (TypeVar) t;
2021             return !isCastable(tv.getUpperBound(),
2022                                relaxBound(s),
2023                                noWarnings);
2024         }
2025         if (!s.hasTag(WILDCARD))
2026             s = cvarUpperBound(s);
2027 
2028         return !isSubtype(t, relaxBound(s));
2029     }
2030 
2031     private Type relaxBound(Type t) {
2032         return (t.hasTag(TYPEVAR)) ?
2033                 rewriteQuantifiers(skipTypeVars(t, false), true, true) :
2034                 t;
2035     }
2036     // &lt;/editor-fold&gt;
2037 
2038     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isReifiable&quot;&gt;
2039     public boolean isReifiable(Type t) {
2040         return isReifiable.visit(t);
2041     }
2042     // where
2043         private UnaryVisitor&lt;Boolean&gt; isReifiable = new UnaryVisitor&lt;Boolean&gt;() {
2044 
2045             public Boolean visitType(Type t, Void ignored) {
2046                 return true;
2047             }
2048 
2049             @Override
2050             public Boolean visitClassType(ClassType t, Void ignored) {
2051                 if (t.isCompound())
2052                     return false;
2053                 else {
2054                     if (!t.isParameterized())
2055                         return true;
2056 
2057                     for (Type param : t.allparams()) {
2058                         if (!param.isUnbound())
2059                             return false;
2060                     }
2061                     return true;
2062                 }
2063             }
2064 
2065             @Override
2066             public Boolean visitArrayType(ArrayType t, Void ignored) {
2067                 return visit(t.elemtype);
2068             }
2069 
2070             @Override
2071             public Boolean visitTypeVar(TypeVar t, Void ignored) {
2072                 return false;
2073             }
2074         };
2075     // &lt;/editor-fold&gt;
2076 
2077     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Array Utils&quot;&gt;
2078     public boolean isArray(Type t) {
2079         while (t.hasTag(WILDCARD))
2080             t = wildUpperBound(t);
2081         return t.hasTag(ARRAY);
2082     }
2083 
2084     /**
2085      * The element type of an array.
2086      */
2087     public Type elemtype(Type t) {
2088         switch (t.getTag()) {
2089         case WILDCARD:
2090             return elemtype(wildUpperBound(t));
2091         case ARRAY:
2092             return ((ArrayType)t).elemtype;
2093         case FORALL:
2094             return elemtype(((ForAll)t).qtype);
2095         case ERROR:
2096             return t;
2097         default:
2098             return null;
2099         }
2100     }
2101 
2102     public Type elemtypeOrType(Type t) {
2103         Type elemtype = elemtype(t);
2104         return elemtype != null ?
2105             elemtype :
2106             t;
2107     }
2108 
2109     /**
2110      * Mapping to take element type of an arraytype
2111      */
2112     private TypeMapping&lt;Void&gt; elemTypeFun = new TypeMapping&lt;Void&gt;() {
2113         @Override
2114         public Type visitArrayType(ArrayType t, Void _unused) {
2115             return t.elemtype;
2116         }
2117 
2118         @Override
2119         public Type visitTypeVar(TypeVar t, Void _unused) {
2120             return visit(skipTypeVars(t, false));
2121         }
2122     };
2123 
2124     /**
2125      * The number of dimensions of an array type.
2126      */
2127     public int dimensions(Type t) {
2128         int result = 0;
2129         while (t.hasTag(ARRAY)) {
2130             result++;
2131             t = elemtype(t);
2132         }
2133         return result;
2134     }
2135 
2136     /**
2137      * Returns an ArrayType with the component type t
2138      *
2139      * @param t The component type of the ArrayType
2140      * @return the ArrayType for the given component
2141      */
2142     public ArrayType makeArrayType(Type t) {
2143         if (t.hasTag(VOID) || t.hasTag(PACKAGE)) {
2144             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2145         }
2146         return new ArrayType(t, syms.arrayClass);
2147     }
2148     // &lt;/editor-fold&gt;
2149 
2150     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2151     /**
2152      * Return the (most specific) base type of t that starts with the
2153      * given symbol.  If none exists, return null.
2154      *
2155      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2156      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2157      * this method could yield surprising answers when invoked on arrays. For example when
2158      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2159      *
2160      * @param t a type
2161      * @param sym a symbol
2162      */
2163     public Type asSuper(Type t, Symbol sym) {
2164         return asSuper(t, sym, false);
2165     }
2166 
2167     /**
2168      * Return the (most specific) base type of t that starts with the
2169      * given symbol.  If none exists, return null.
2170      *
2171      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2172      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2173      * this method could yield surprising answers when invoked on arrays. For example when
2174      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2175      *
2176      * @param t a type
2177      * @param sym a symbol
2178      * @param checkReferenceProjection if true, first compute reference projection of t
2179      */
2180     public Type asSuper(Type t, Symbol sym, boolean checkReferenceProjection) {
2181         /* Some examples:
2182          *
2183          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2184          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2185          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2186          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2187          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2188          */
2189 
2190         /* For a (value or identity) class V, whether it implements an interface I, boils down to whether
2191            V.ref is a subtype of I. OIOW, whether asSuper(V.ref, sym) != null. (Likewise for an abstract
2192            superclass)
2193         */
2194         if (checkReferenceProjection)
2195             t = t.isValue() ? t.referenceProjection() : t;
2196 
2197         if (sym.type == syms.objectType) { //optimization
2198             if (!isValue(t))
2199                 return syms.objectType;
2200         }
<a name="4" id="anc4"></a><span class="line-added">2201         if (sym.type == syms.identityObjectType) {</span>
<span class="line-added">2202             // IdentityObject is super interface of every concrete identity class other than jlO</span>
<span class="line-added">2203             if (t.isValue() || t.tsym == syms.objectType.tsym)</span>
<span class="line-added">2204                 return null;</span>
<span class="line-added">2205             if (t.hasTag(ARRAY))</span>
<span class="line-added">2206                 return syms.identityObjectType;</span>
<span class="line-added">2207             if (t.hasTag(CLASS) &amp;&amp; !t.isReferenceProjection() &amp;&amp; !t.tsym.isInterface() &amp;&amp; !t.tsym.isAbstract()) {</span>
<span class="line-added">2208                 return syms.identityObjectType;</span>
<span class="line-added">2209             } // else fall through and look for explicit coded super interface</span>
<span class="line-added">2210         }</span>
2211         return asSuper.visit(t, sym);
2212     }
2213     // where
2214         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2215 
2216             public Type visitType(Type t, Symbol sym) {
2217                 return null;
2218             }
2219 
2220             @Override
2221             public Type visitClassType(ClassType t, Symbol sym) {
2222                 if (t.tsym == sym)
2223                     return t;
2224 
2225                 // No man may be an island, but the bell tolls for a value.
2226                 if (isValue(t))
2227                     return null;
2228 
2229                 Type st = supertype(t);
2230                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2231                     Type x = asSuper(st, sym);
2232                     if (x != null)
2233                         return x;
2234                 }
2235                 if ((sym.flags() &amp; INTERFACE) != 0) {
2236                     for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2237                         if (!l.head.hasTag(ERROR)) {
2238                             Type x = asSuper(l.head, sym);
2239                             if (x != null)
2240                                 return x;
2241                         }
2242                     }
2243                 }
2244                 return null;
2245             }
2246 
2247             @Override
2248             public Type visitArrayType(ArrayType t, Symbol sym) {
2249                 return isSubtype(t, sym.type) ? sym.type : null;
2250             }
2251 
2252             @Override
2253             public Type visitTypeVar(TypeVar t, Symbol sym) {
2254                 if (t.tsym == sym)
2255                     return t;
2256                 else
2257                     return asSuper(t.getUpperBound(), sym);
2258             }
2259 
2260             @Override
2261             public Type visitErrorType(ErrorType t, Symbol sym) {
2262                 return t;
2263             }
2264         };
2265 
2266     /**
2267      * Return the base type of t or any of its outer types that starts
2268      * with the given symbol.  If none exists, return null.
2269      *
2270      * @param t a type
2271      * @param sym a symbol
2272      */
2273     public Type asOuterSuper(Type t, Symbol sym) {
2274         switch (t.getTag()) {
2275         case CLASS:
2276             do {
2277                 Type s = asSuper(t, sym);
2278                 if (s != null) return s;
2279                 t = t.getEnclosingType();
2280             } while (t.hasTag(CLASS));
2281             return null;
2282         case ARRAY:
2283             return isSubtype(t, sym.type) ? sym.type : null;
2284         case TYPEVAR:
2285             return asSuper(t, sym);
2286         case ERROR:
2287             return t;
2288         default:
2289             return null;
2290         }
2291     }
2292 
2293     /**
2294      * Return the base type of t or any of its enclosing types that
2295      * starts with the given symbol.  If none exists, return null.
2296      *
2297      * @param t a type
2298      * @param sym a symbol
2299      */
2300     public Type asEnclosingSuper(Type t, Symbol sym) {
2301         switch (t.getTag()) {
2302         case CLASS:
2303             do {
2304                 Type s = asSuper(t, sym);
2305                 if (s != null) return s;
2306                 Type outer = t.getEnclosingType();
2307                 t = (outer.hasTag(CLASS)) ? outer :
2308                     (t.tsym.owner.enclClass() != null) ? t.tsym.owner.enclClass().type :
2309                     Type.noType;
2310             } while (t.hasTag(CLASS));
2311             return null;
2312         case ARRAY:
2313             return isSubtype(t, sym.type) ? sym.type : null;
2314         case TYPEVAR:
2315             return asSuper(t, sym);
2316         case ERROR:
2317             return t;
2318         default:
2319             return null;
2320         }
2321     }
2322     // &lt;/editor-fold&gt;
2323 
2324     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2325     /**
2326      * The type of given symbol, seen as a member of t.
2327      *
2328      * @param t a type
2329      * @param sym a symbol
2330      */
2331     public Type memberType(Type t, Symbol sym) {
2332 
2333         if ((sym.flags() &amp; STATIC) != 0)
2334             return sym.type;
2335 
2336         /* If any inline types are involved, switch over to the reference universe,
2337            where the hierarchy is navigable. V and V.ref have identical membership
2338            with no bridging needs.
2339         */
2340         if (t.isValue())
2341             t = t.referenceProjection();
2342 
2343         if (sym.owner.isValue())
2344             sym = sym.referenceProjection();
2345 
2346         return memberType.visit(t, sym);
2347         }
2348     // where
2349         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2350 
2351             public Type visitType(Type t, Symbol sym) {
2352                 return sym.type;
2353             }
2354 
2355             @Override
2356             public Type visitWildcardType(WildcardType t, Symbol sym) {
2357                 return memberType(wildUpperBound(t), sym);
2358             }
2359 
2360             @Override
2361             public Type visitClassType(ClassType t, Symbol sym) {
2362                 Symbol owner = sym.owner;
2363                 long flags = sym.flags();
2364                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2365                     Type base = asOuterSuper(t, owner);
2366                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
2367                     //its supertypes CT, I1, ... In might contain wildcards
2368                     //so we need to go through capture conversion
2369                     base = t.isCompound() ? capture(base) : base;
2370                     if (base != null) {
2371                         List&lt;Type&gt; ownerParams = owner.type.allparams();
2372                         List&lt;Type&gt; baseParams = base.allparams();
2373                         if (ownerParams.nonEmpty()) {
2374                             if (baseParams.isEmpty()) {
2375                                 // then base is a raw type
2376                                 return erasure(sym.type);
2377                             } else {
2378                                 return subst(sym.type, ownerParams, baseParams);
2379                             }
2380                         }
2381                     }
2382                 }
2383                 return sym.type;
2384             }
2385 
2386             @Override
2387             public Type visitTypeVar(TypeVar t, Symbol sym) {
2388                 return memberType(t.getUpperBound(), sym);
2389             }
2390 
2391             @Override
2392             public Type visitErrorType(ErrorType t, Symbol sym) {
2393                 return t;
2394             }
2395         };
2396     // &lt;/editor-fold&gt;
2397 
2398     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isAssignable&quot;&gt;
2399     public boolean isAssignable(Type t, Type s) {
2400         return isAssignable(t, s, noWarnings);
2401     }
2402 
2403     /**
2404      * Is t assignable to s?&lt;br&gt;
2405      * Equivalent to subtype except for constant values and raw
2406      * types.&lt;br&gt;
2407      * (not defined for Method and ForAll types)
2408      */
2409     public boolean isAssignable(Type t, Type s, Warner warn) {
2410         if (t.hasTag(ERROR))
2411             return true;
2412         if (t.getTag().isSubRangeOf(INT) &amp;&amp; t.constValue() != null) {
2413             int value = ((Number)t.constValue()).intValue();
2414             switch (s.getTag()) {
2415             case BYTE:
2416             case CHAR:
2417             case SHORT:
2418             case INT:
2419                 if (s.getTag().checkRange(value))
2420                     return true;
2421                 break;
2422             case CLASS:
2423                 switch (unboxedType(s).getTag()) {
2424                 case BYTE:
2425                 case CHAR:
2426                 case SHORT:
2427                     return isAssignable(t, unboxedType(s), warn);
2428                 }
2429                 break;
2430             }
2431         }
2432         return isConvertible(t, s, warn);
2433     }
2434     // &lt;/editor-fold&gt;
2435 
2436     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;erasure&quot;&gt;
2437     /**
2438      * The erasure of t {@code |t|} -- the type that results when all
2439      * type parameters in t are deleted.
2440      */
2441     public Type erasure(Type t) {
2442         return eraseNotNeeded(t) ? t : erasure(t, false);
2443     }
2444     //where
2445     private boolean eraseNotNeeded(Type t) {
2446         // We don&#39;t want to erase primitive types and String type as that
2447         // operation is idempotent. Also, erasing these could result in loss
2448         // of information such as constant values attached to such types.
2449         return (t.isPrimitive()) || (syms.stringType.tsym == t.tsym);
2450     }
2451 
2452     private Type erasure(Type t, boolean recurse) {
2453         if (t.isPrimitive()) {
2454             return t; /* fast special case */
2455         } else {
2456             Type out = erasure.visit(t, recurse);
2457             return out;
2458         }
2459     }
2460     // where
2461         private TypeMapping&lt;Boolean&gt; erasure = new StructuralTypeMapping&lt;Boolean&gt;() {
2462             private Type combineMetadata(final Type s,
2463                                          final Type t) {
2464                 if (t.getMetadata() != TypeMetadata.EMPTY) {
2465                     switch (s.getKind()) {
2466                         case OTHER:
2467                         case UNION:
2468                         case INTERSECTION:
2469                         case PACKAGE:
2470                         case EXECUTABLE:
2471                         case NONE:
2472                         case VOID:
2473                         case ERROR:
2474                             return s;
2475                         default: return s.cloneWithMetadata(s.getMetadata().without(Kind.ANNOTATIONS));
2476                     }
2477                 } else {
2478                     return s;
2479                 }
2480             }
2481 
2482             public Type visitType(Type t, Boolean recurse) {
2483                 if (t.isPrimitive())
2484                     return t; /*fast special case*/
2485                 else {
2486                     //other cases already handled
2487                     return combineMetadata(t, t);
2488                 }
2489             }
2490 
2491             @Override
2492             public Type visitWildcardType(WildcardType t, Boolean recurse) {
2493                 Type erased = erasure(wildUpperBound(t), recurse);
2494                 return combineMetadata(erased, t);
2495             }
2496 
2497             @Override
2498             public Type visitClassType(ClassType t, Boolean recurse) {
2499                 Type erased = t.tsym.erasure(Types.this);
2500                 if (recurse) {
2501                     erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,
2502                             t.getMetadata().without(Kind.ANNOTATIONS));
2503                     return erased;
2504                 } else {
2505                     return combineMetadata(erased, t);
2506                 }
2507             }
2508 
2509             @Override
2510             public Type visitTypeVar(TypeVar t, Boolean recurse) {
2511                 Type erased = erasure(t.getUpperBound(), recurse);
2512                 return combineMetadata(erased, t);
2513             }
2514         };
2515 
2516     public List&lt;Type&gt; erasure(List&lt;Type&gt; ts) {
2517         return erasure.visit(ts, false);
2518     }
2519 
2520     public Type erasureRecursive(Type t) {
2521         return erasure(t, true);
2522     }
2523 
2524     public List&lt;Type&gt; erasureRecursive(List&lt;Type&gt; ts) {
2525         return erasure.visit(ts, true);
2526     }
2527     // &lt;/editor-fold&gt;
2528 
2529     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;makeIntersectionType&quot;&gt;
2530     /**
2531      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2532      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. Note that this might cause a symbol completion.
2533      * Hence, this version of makeIntersectionType may not be called during a classfile read.
2534      *
2535      * @param bounds    the types from which the intersection type is formed
2536      */
2537     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2538         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2539     }
2540 
2541     /**
2542      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2543      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2544      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2545      * supertype is implicitly assumed to be &#39;Object&#39;.
2546      *
2547      * @param bounds        the types from which the intersection type is formed
2548      * @param allInterfaces are all bounds interface types?
2549      */
2550     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2551         Assert.check(bounds.nonEmpty());
2552         Type firstExplicitBound = bounds.head;
2553         if (allInterfaces) {
2554             bounds = bounds.prepend(syms.objectType);
2555         }
2556         long flags = ABSTRACT | PUBLIC | SYNTHETIC | COMPOUND | ACYCLIC;
2557         if (isValue(bounds.head))
2558             flags |= VALUE;
2559         ClassSymbol bc =
2560             new ClassSymbol(flags,
2561                             Type.moreInfo
2562                                 ? names.fromString(bounds.toString())
2563                                 : names.empty,
2564                             null,
2565                             syms.noSymbol);
2566         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2567         bc.type = intersectionType;
2568         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2569                 syms.objectType : // error condition, recover
2570                 erasure(firstExplicitBound);
2571         bc.members_field = WriteableScope.create(bc);
2572         return intersectionType;
2573     }
2574     // &lt;/editor-fold&gt;
2575 
2576     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2577     public Type supertype(Type t) {
2578         return supertype.visit(t);
2579     }
2580     // where
2581         private UnaryVisitor&lt;Type&gt; supertype = new UnaryVisitor&lt;Type&gt;() {
2582 
2583             public Type visitType(Type t, Void ignored) {
2584                 // A note on wildcards: there is no good way to
2585                 // determine a supertype for a super bounded wildcard.
2586                 return Type.noType;
2587             }
2588 
2589             @Override
2590             public Type visitClassType(ClassType t, Void ignored) {
2591                 if (t.supertype_field == null) {
2592                     Type supertype = ((ClassSymbol)t.tsym).getSuperclass();
2593                     // An interface has no superclass; its supertype is Object.
2594                     if (t.isInterface())
2595                         supertype = ((ClassType)t.tsym.type).supertype_field;
2596                     if (t.supertype_field == null) {
2597                         List&lt;Type&gt; actuals = classBound(t).allparams();
2598                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2599                         if (t.hasErasedSupertypes()) {
2600                             t.supertype_field = erasureRecursive(supertype);
2601                         } else if (formals.nonEmpty()) {
2602                             t.supertype_field = subst(supertype, formals, actuals);
2603                         }
2604                         else {
2605                             t.supertype_field = supertype;
2606                         }
2607                     }
2608                 }
2609                 return t.supertype_field;
2610             }
2611 
2612             /**
2613              * The supertype is always a class type. If the type
2614              * variable&#39;s bounds start with a class type, this is also
2615              * the supertype.  Otherwise, the supertype is
2616              * java.lang.Object.
2617              */
2618             @Override
2619             public Type visitTypeVar(TypeVar t, Void ignored) {
2620                 if (t.getUpperBound().hasTag(TYPEVAR) ||
2621                     (!t.getUpperBound().isCompound() &amp;&amp; !t.getUpperBound().isInterface())) {
2622                     return t.getUpperBound();
2623                 } else {
2624                     return supertype(t.getUpperBound());
2625                 }
2626             }
2627 
2628             @Override
2629             public Type visitArrayType(ArrayType t, Void ignored) {
2630                 if (t.elemtype.isPrimitive() || isSameType(t.elemtype, syms.objectType))
2631                     return arraySuperType();
2632                 else
2633                     return new ArrayType(supertype(t.elemtype), t.tsym);
2634             }
2635 
2636             @Override
2637             public Type visitErrorType(ErrorType t, Void ignored) {
2638                 return Type.noType;
2639             }
2640         };
2641     // &lt;/editor-fold&gt;
2642 
2643     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;interfaces&quot;&gt;
2644     /**
2645      * Return the interfaces implemented by this class.
2646      */
2647     public List&lt;Type&gt; interfaces(Type t) {
2648         return interfaces.visit(t);
2649     }
2650     // where
2651         private UnaryVisitor&lt;List&lt;Type&gt;&gt; interfaces = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2652 
2653             public List&lt;Type&gt; visitType(Type t, Void ignored) {
2654                 return List.nil();
2655             }
2656 
2657             @Override
2658             public List&lt;Type&gt; visitClassType(ClassType t, Void ignored) {
2659                 if (t.interfaces_field == null) {
2660                     List&lt;Type&gt; interfaces = ((ClassSymbol)t.tsym).getInterfaces();
2661                     if (t.interfaces_field == null) {
2662                         // If t.interfaces_field is null, then t must
2663                         // be a parameterized type (not to be confused
2664                         // with a generic type declaration).
2665                         // Terminology:
2666                         //    Parameterized type: List&lt;String&gt;
2667                         //    Generic type declaration: class List&lt;E&gt; { ... }
2668                         // So t corresponds to List&lt;String&gt; and
2669                         // t.tsym.type corresponds to List&lt;E&gt;.
2670                         // The reason t must be parameterized type is
2671                         // that completion will happen as a side
2672                         // effect of calling
2673                         // ClassSymbol.getInterfaces.  Since
2674                         // t.interfaces_field is null after
2675                         // completion, we can assume that t is not the
2676                         // type of a class/interface declaration.
2677                         Assert.check(t != t.tsym.type, t);
2678                         List&lt;Type&gt; actuals = t.allparams();
2679                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2680                         if (t.hasErasedSupertypes()) {
2681                             t.interfaces_field = erasureRecursive(interfaces);
2682                         } else if (formals.nonEmpty()) {
2683                             t.interfaces_field = subst(interfaces, formals, actuals);
2684                         }
2685                         else {
2686                             t.interfaces_field = interfaces;
2687                         }
2688                     }
2689                 }
2690                 return t.interfaces_field;
2691             }
2692 
2693             @Override
2694             public List&lt;Type&gt; visitTypeVar(TypeVar t, Void ignored) {
2695                 if (t.getUpperBound().isCompound())
2696                     return interfaces(t.getUpperBound());
2697 
2698                 if (t.getUpperBound().isInterface())
2699                     return List.of(t.getUpperBound());
2700 
2701                 return List.nil();
2702             }
2703         };
2704 
2705     public List&lt;Type&gt; directSupertypes(Type t) {
2706         return directSupertypes.visit(t);
2707     }
2708     // where
2709         private final UnaryVisitor&lt;List&lt;Type&gt;&gt; directSupertypes = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2710 
2711             public List&lt;Type&gt; visitType(final Type type, final Void ignored) {
2712                 if (!type.isIntersection()) {
2713                     final Type sup = supertype(type);
2714                     return (sup == Type.noType || sup == type || sup == null)
2715                         ? interfaces(type)
2716                         : interfaces(type).prepend(sup);
2717                 } else {
2718                     return ((IntersectionClassType)type).getExplicitComponents();
2719                 }
2720             }
2721         };
2722 
2723     public boolean isDirectSuperInterface(TypeSymbol isym, TypeSymbol origin) {
2724         for (Type i2 : interfaces(origin.type)) {
2725             if (isym == i2.tsym) return true;
2726         }
2727         return false;
2728     }
2729     // &lt;/editor-fold&gt;
2730 
2731     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isDerivedRaw&quot;&gt;
2732     Map&lt;Type,Boolean&gt; isDerivedRawCache = new HashMap&lt;&gt;();
2733 
2734     public boolean isDerivedRaw(Type t) {
2735         Boolean result = isDerivedRawCache.get(t);
2736         if (result == null) {
2737             result = isDerivedRawInternal(t);
2738             isDerivedRawCache.put(t, result);
2739         }
2740         return result;
2741     }
2742 
2743     public boolean isDerivedRawInternal(Type t) {
2744         if (t.isErroneous())
2745             return false;
2746         return
2747             t.isRaw() ||
2748             supertype(t) != Type.noType &amp;&amp; isDerivedRaw(supertype(t)) ||
2749             isDerivedRaw(interfaces(t));
2750     }
2751 
2752     public boolean isDerivedRaw(List&lt;Type&gt; ts) {
2753         List&lt;Type&gt; l = ts;
2754         while (l.nonEmpty() &amp;&amp; !isDerivedRaw(l.head)) l = l.tail;
2755         return l.nonEmpty();
2756     }
2757     // &lt;/editor-fold&gt;
2758 
2759     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;setBounds&quot;&gt;
2760     /**
2761      * Same as {@link Types#setBounds(TypeVar, List, boolean)}, except that third parameter is computed directly,
2762      * as follows: if all all bounds are interface types, the computed supertype is Object,otherwise
2763      * the supertype is simply left null (in this case, the supertype is assumed to be the head of
2764      * the bound list passed as second argument). Note that this check might cause a symbol completion.
2765      * Hence, this version of setBounds may not be called during a classfile read.
2766      *
2767      * @param t         a type variable
2768      * @param bounds    the bounds, must be nonempty
2769      */
2770     public void setBounds(TypeVar t, List&lt;Type&gt; bounds) {
2771         setBounds(t, bounds, bounds.head.tsym.isInterface());
2772     }
2773 
2774     /**
2775      * Set the bounds field of the given type variable to reflect a (possibly multiple) list of bounds.
2776      * This does not cause symbol completion as an extra parameter indicates as to whether all bounds
2777      * are interfaces - in which case the supertype is implicitly assumed to be &#39;Object&#39;.
2778      *
2779      * @param t             a type variable
2780      * @param bounds        the bounds, must be nonempty
2781      * @param allInterfaces are all bounds interface types?
2782      */
2783     public void setBounds(TypeVar t, List&lt;Type&gt; bounds, boolean allInterfaces) {
2784         t.setUpperBound( bounds.tail.isEmpty() ?
2785                 bounds.head :
2786                 makeIntersectionType(bounds, allInterfaces) );
2787         t.rank_field = -1;
2788     }
2789     // &lt;/editor-fold&gt;
2790 
2791     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;getBounds&quot;&gt;
2792     /**
2793      * Return list of bounds of the given type variable.
2794      */
2795     public List&lt;Type&gt; getBounds(TypeVar t) {
2796         if (t.getUpperBound().hasTag(NONE))
2797             return List.nil();
2798         else if (t.getUpperBound().isErroneous() || !t.getUpperBound().isCompound())
2799             return List.of(t.getUpperBound());
2800         else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0)
2801             return interfaces(t).prepend(supertype(t));
2802         else
2803             // No superclass was given in bounds.
2804             // In this case, supertype is Object, erasure is first interface.
2805             return interfaces(t);
2806     }
2807     // &lt;/editor-fold&gt;
2808 
2809     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;classBound&quot;&gt;
2810     /**
2811      * If the given type is a (possibly selected) type variable,
2812      * return the bounding class of this type, otherwise return the
2813      * type itself.
2814      */
2815     public Type classBound(Type t) {
2816         return classBound.visit(t);
2817     }
2818     // where
2819         private UnaryVisitor&lt;Type&gt; classBound = new UnaryVisitor&lt;Type&gt;() {
2820 
2821             public Type visitType(Type t, Void ignored) {
2822                 return t;
2823             }
2824 
2825             @Override
2826             public Type visitClassType(ClassType t, Void ignored) {
2827                 Type outer1 = classBound(t.getEnclosingType());
2828                 if (outer1 != t.getEnclosingType())
2829                     return new ClassType(outer1, t.getTypeArguments(), t.tsym,
2830                                          t.getMetadata());
2831                 else
2832                     return t;
2833             }
2834 
2835             @Override
2836             public Type visitTypeVar(TypeVar t, Void ignored) {
2837                 return classBound(supertype(t));
2838             }
2839 
2840             @Override
2841             public Type visitErrorType(ErrorType t, Void ignored) {
2842                 return t;
2843             }
2844         };
2845     // &lt;/editor-fold&gt;
2846 
2847     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;sub signature / override equivalence&quot;&gt;
2848     /**
2849      * Returns true iff the first signature is a &lt;em&gt;sub
2850      * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
2851      * relation.
2852      *
2853      * @jls 8.4.2 Method Signature
2854      * @see #overrideEquivalent(Type t, Type s)
2855      * @param t first signature (possibly raw).
2856      * @param s second signature (could be subjected to erasure).
2857      * @return true if t is a sub signature of s.
2858      */
2859     public boolean isSubSignature(Type t, Type s) {
2860         return isSubSignature(t, s, true);
2861     }
2862 
2863     public boolean isSubSignature(Type t, Type s, boolean strict) {
2864         return hasSameArgs(t, s, strict) || hasSameArgs(t, erasure(s), strict);
2865     }
2866 
2867     /**
2868      * Returns true iff these signatures are related by &lt;em&gt;override
2869      * equivalence&lt;/em&gt;.  This is the natural extension of
2870      * isSubSignature to an equivalence relation.
2871      *
2872      * @jls 8.4.2 Method Signature
2873      * @see #isSubSignature(Type t, Type s)
2874      * @param t a signature (possible raw, could be subjected to
2875      * erasure).
2876      * @param s a signature (possible raw, could be subjected to
2877      * erasure).
2878      * @return true if either argument is a sub signature of the other.
2879      */
2880     public boolean overrideEquivalent(Type t, Type s) {
2881         return hasSameArgs(t, s) ||
2882             hasSameArgs(t, erasure(s)) || hasSameArgs(erasure(t), s);
2883     }
2884 
2885     public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {
2886         for (Symbol sym : syms.objectType.tsym.members().getSymbolsByName(msym.name)) {
2887             if (msym.overrides(sym, origin, Types.this, true)) {
2888                 return true;
2889             }
2890         }
2891         return false;
2892     }
2893 
2894     /**
2895      * This enum defines the strategy for implementing most specific return type check
2896      * during the most specific and functional interface checks.
2897      */
2898     public enum MostSpecificReturnCheck {
2899         /**
2900          * Return r1 is more specific than r2 if {@code r1 &lt;: r2}. Extra care required for (i) handling
2901          * method type variables (if either method is generic) and (ii) subtyping should be replaced
2902          * by type-equivalence for primitives. This is essentially an inlined version of
2903          * {@link Types#resultSubtype(Type, Type, Warner)}, where the assignability check has been
2904          * replaced with a strict subtyping check.
2905          */
2906         BASIC() {
2907             @Override
2908             public boolean test(Type mt1, Type mt2, Types types) {
2909                 List&lt;Type&gt; tvars = mt1.getTypeArguments();
2910                 List&lt;Type&gt; svars = mt2.getTypeArguments();
2911                 Type t = mt1.getReturnType();
2912                 Type s = types.subst(mt2.getReturnType(), svars, tvars);
2913                 return types.isSameType(t, s) ||
2914                     !t.isPrimitive() &amp;&amp;
2915                     !s.isPrimitive() &amp;&amp;
2916                     types.isSubtype(t, s);
2917             }
2918         },
2919         /**
2920          * Return r1 is more specific than r2 if r1 is return-type-substitutable for r2.
2921          */
2922         RTS() {
2923             @Override
2924             public boolean test(Type mt1, Type mt2, Types types) {
2925                 return types.returnTypeSubstitutable(mt1, mt2);
2926             }
2927         };
2928 
2929         public abstract boolean test(Type mt1, Type mt2, Types types);
2930     }
2931 
2932     /**
2933      * Merge multiple abstract methods. The preferred method is a method that is a subsignature
2934      * of all the other signatures and whose return type is more specific {@see MostSpecificReturnCheck}.
2935      * The resulting preferred method has a thrown clause that is the intersection of the merged
2936      * methods&#39; clauses.
2937      */
2938     public Optional&lt;Symbol&gt; mergeAbstracts(List&lt;Symbol&gt; ambiguousInOrder, Type site, boolean sigCheck) {
2939         //first check for preconditions
2940         boolean shouldErase = false;
2941         List&lt;Type&gt; erasedParams = ambiguousInOrder.head.erasure(this).getParameterTypes();
2942         for (Symbol s : ambiguousInOrder) {
2943             if ((s.flags() &amp; ABSTRACT) == 0 ||
2944                     (sigCheck &amp;&amp; !isSameTypes(erasedParams, s.erasure(this).getParameterTypes()))) {
2945                 return Optional.empty();
2946             } else if (s.type.hasTag(FORALL)) {
2947                 shouldErase = true;
2948             }
2949         }
2950         //then merge abstracts
2951         for (MostSpecificReturnCheck mostSpecificReturnCheck : MostSpecificReturnCheck.values()) {
2952             outer: for (Symbol s : ambiguousInOrder) {
2953                 Type mt = memberType(site, s);
2954                 List&lt;Type&gt; allThrown = mt.getThrownTypes();
2955                 for (Symbol s2 : ambiguousInOrder) {
2956                     if (s != s2) {
2957                         Type mt2 = memberType(site, s2);
2958                         if (!isSubSignature(mt, mt2) ||
2959                                 !mostSpecificReturnCheck.test(mt, mt2, this)) {
2960                             //ambiguity cannot be resolved
2961                             continue outer;
2962                         } else {
2963                             List&lt;Type&gt; thrownTypes2 = mt2.getThrownTypes();
2964                             if (!mt.hasTag(FORALL) &amp;&amp; shouldErase) {
2965                                 thrownTypes2 = erasure(thrownTypes2);
2966                             } else if (mt.hasTag(FORALL)) {
2967                                 //subsignature implies that if most specific is generic, then all other
2968                                 //methods are too
2969                                 Assert.check(mt2.hasTag(FORALL));
2970                                 // if both are generic methods, adjust thrown types ahead of intersection computation
2971                                 thrownTypes2 = subst(thrownTypes2, mt2.getTypeArguments(), mt.getTypeArguments());
2972                             }
2973                             allThrown = chk.intersect(allThrown, thrownTypes2);
2974                         }
2975                     }
2976                 }
2977                 return (allThrown == mt.getThrownTypes()) ?
2978                         Optional.of(s) :
2979                         Optional.of(new MethodSymbol(
2980                                 s.flags(),
2981                                 s.name,
2982                                 createMethodTypeWithThrown(s.type, allThrown),
2983                                 s.owner) {
2984                             @Override
2985                             public Symbol baseSymbol() {
2986                                 return s;
2987                             }
2988                         });
2989             }
2990         }
2991         return Optional.empty();
2992     }
2993 
2994     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining method implementation in given site&quot;&gt;
2995     class ImplementationCache {
2996 
2997         private WeakHashMap&lt;MethodSymbol, SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt;&gt; _map = new WeakHashMap&lt;&gt;();
2998 
2999         class Entry {
3000             final MethodSymbol cachedImpl;
3001             final Filter&lt;Symbol&gt; implFilter;
3002             final boolean checkResult;
3003             final int prevMark;
3004 
3005             public Entry(MethodSymbol cachedImpl,
3006                     Filter&lt;Symbol&gt; scopeFilter,
3007                     boolean checkResult,
3008                     int prevMark) {
3009                 this.cachedImpl = cachedImpl;
3010                 this.implFilter = scopeFilter;
3011                 this.checkResult = checkResult;
3012                 this.prevMark = prevMark;
3013             }
3014 
3015             boolean matches(Filter&lt;Symbol&gt; scopeFilter, boolean checkResult, int mark) {
3016                 return this.implFilter == scopeFilter &amp;&amp;
3017                         this.checkResult == checkResult &amp;&amp;
3018                         this.prevMark == mark;
3019             }
3020         }
3021 
3022         MethodSymbol get(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3023             SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt; ref_cache = _map.get(ms);
3024             Map&lt;TypeSymbol, Entry&gt; cache = ref_cache != null ? ref_cache.get() : null;
3025             if (cache == null) {
3026                 cache = new HashMap&lt;&gt;();
3027                 _map.put(ms, new SoftReference&lt;&gt;(cache));
3028             }
3029             Entry e = cache.get(origin);
3030             CompoundScope members = membersClosure(origin.type, true);
3031             if (e == null ||
3032                     !e.matches(implFilter, checkResult, members.getMark())) {
3033                 MethodSymbol impl = implementationInternal(ms, origin, checkResult, implFilter);
3034                 cache.put(origin, new Entry(impl, implFilter, checkResult, members.getMark()));
3035                 return impl;
3036             }
3037             else {
3038                 return e.cachedImpl;
3039             }
3040         }
3041 
3042         private MethodSymbol implementationInternal(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3043             for (Type t = origin.type; t.hasTag(CLASS) || t.hasTag(TYPEVAR); t = supertype(t)) {
3044                 t = skipTypeVars(t, false);
3045                 TypeSymbol c = t.tsym;
3046                 Symbol bestSoFar = null;
3047                 for (Symbol sym : c.members().getSymbolsByName(ms.name, implFilter)) {
3048                     if (sym != null &amp;&amp; sym.overrides(ms, origin, Types.this, checkResult)) {
3049                         bestSoFar = sym;
3050                         if ((sym.flags() &amp; ABSTRACT) == 0) {
3051                             //if concrete impl is found, exit immediately
3052                             break;
3053                         }
3054                     }
3055                 }
3056                 if (bestSoFar != null) {
3057                     //return either the (only) concrete implementation or the first abstract one
3058                     return (MethodSymbol)bestSoFar;
3059                 }
3060             }
3061             return null;
3062         }
3063     }
3064 
3065     private ImplementationCache implCache = new ImplementationCache();
3066 
3067     public MethodSymbol implementation(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3068         return implCache.get(ms, origin, checkResult, implFilter);
3069     }
3070     // &lt;/editor-fold&gt;
3071 
3072     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;compute transitive closure of all members in given site&quot;&gt;
3073     class MembersClosureCache extends SimpleVisitor&lt;Scope.CompoundScope, Void&gt; {
3074 
3075         private Map&lt;TypeSymbol, CompoundScope&gt; _map = new HashMap&lt;&gt;();
3076 
3077         Set&lt;TypeSymbol&gt; seenTypes = new HashSet&lt;&gt;();
3078 
3079         class MembersScope extends CompoundScope {
3080 
3081             CompoundScope scope;
3082 
3083             public MembersScope(CompoundScope scope) {
3084                 super(scope.owner);
3085                 this.scope = scope;
3086             }
3087 
3088             Filter&lt;Symbol&gt; combine(Filter&lt;Symbol&gt; sf) {
3089                 return s -&gt; !s.owner.isInterface() &amp;&amp; (sf == null || sf.accepts(s));
3090             }
3091 
3092             @Override
3093             public Iterable&lt;Symbol&gt; getSymbols(Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3094                 return scope.getSymbols(combine(sf), lookupKind);
3095             }
3096 
3097             @Override
3098             public Iterable&lt;Symbol&gt; getSymbolsByName(Name name, Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3099                 return scope.getSymbolsByName(name, combine(sf), lookupKind);
3100             }
3101 
3102             @Override
3103             public int getMark() {
3104                 return scope.getMark();
3105             }
3106         }
3107 
3108         CompoundScope nilScope;
3109 
3110         /** members closure visitor methods **/
3111 
3112         public CompoundScope visitType(Type t, Void _unused) {
3113             if (nilScope == null) {
3114                 nilScope = new CompoundScope(syms.noSymbol);
3115             }
3116             return nilScope;
3117         }
3118 
3119         @Override
3120         public CompoundScope visitClassType(ClassType t, Void _unused) {
3121             if (!seenTypes.add(t.tsym)) {
3122                 //this is possible when an interface is implemented in multiple
3123                 //superclasses, or when a class hierarchy is circular - in such
3124                 //cases we don&#39;t need to recurse (empty scope is returned)
3125                 return new CompoundScope(t.tsym);
3126             }
3127             try {
3128                 seenTypes.add(t.tsym);
3129                 ClassSymbol csym = (ClassSymbol)t.tsym;
3130                 CompoundScope membersClosure = _map.get(csym);
3131                 if (membersClosure == null) {
3132                     membersClosure = new CompoundScope(csym);
3133                     for (Type i : interfaces(t)) {
3134                         membersClosure.prependSubScope(visit(i, null));
3135                     }
3136                     membersClosure.prependSubScope(visit(supertype(t), null));
3137                     membersClosure.prependSubScope(csym.members());
3138                     _map.put(csym, membersClosure);
3139                 }
3140                 return membersClosure;
3141             }
3142             finally {
3143                 seenTypes.remove(t.tsym);
3144             }
3145         }
3146 
3147         @Override
3148         public CompoundScope visitTypeVar(TypeVar t, Void _unused) {
3149             return visit(t.getUpperBound(), null);
3150         }
3151     }
3152 
3153     private MembersClosureCache membersCache = new MembersClosureCache();
3154 
3155     public CompoundScope membersClosure(Type site, boolean skipInterface) {
3156         CompoundScope cs = membersCache.visit(site, null);
3157         Assert.checkNonNull(cs, () -&gt; &quot;type &quot; + site);
3158         return skipInterface ? membersCache.new MembersScope(cs) : cs;
3159     }
3160     // &lt;/editor-fold&gt;
3161 
3162 
3163     /** Return first abstract member of class `sym&#39;.
3164      */
3165     public MethodSymbol firstUnimplementedAbstract(ClassSymbol sym) {
3166         try {
3167             return firstUnimplementedAbstractImpl(sym, sym);
3168         } catch (CompletionFailure ex) {
3169             chk.completionError(enter.getEnv(sym).tree.pos(), ex);
3170             return null;
3171         }
3172     }
3173         //where:
3174         private MethodSymbol firstUnimplementedAbstractImpl(ClassSymbol impl, ClassSymbol c) {
3175             MethodSymbol undef = null;
3176             // Do not bother to search in classes that are not abstract,
3177             // since they cannot have abstract members.
3178             if (c == impl || (c.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
3179                 Scope s = c.members();
3180                 for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
3181                     if (sym.kind == MTH &amp;&amp;
3182                         (sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
3183                         MethodSymbol absmeth = (MethodSymbol)sym;
3184                         MethodSymbol implmeth = absmeth.implementation(impl, this, true);
3185                         if (implmeth == null || implmeth == absmeth) {
3186                             //look for default implementations
3187                             if (allowDefaultMethods) {
3188                                 MethodSymbol prov = interfaceCandidates(impl.type, absmeth).head;
3189                                 if (prov != null &amp;&amp; prov.overrides(absmeth, impl, this, true)) {
3190                                     implmeth = prov;
3191                                 }
3192                             }
3193                         }
3194                         if (implmeth == null || implmeth == absmeth) {
3195                             undef = absmeth;
3196                             break;
3197                         }
3198                     }
3199                 }
3200                 if (undef == null) {
3201                     Type st = supertype(c.type);
3202                     if (st.hasTag(CLASS))
3203                         undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)st.tsym);
3204                 }
3205                 for (List&lt;Type&gt; l = interfaces(c.type);
3206                      undef == null &amp;&amp; l.nonEmpty();
3207                      l = l.tail) {
3208                     undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)l.head.tsym);
3209                 }
3210             }
3211             return undef;
3212         }
3213 
3214     public class CandidatesCache {
3215         public Map&lt;Entry, List&lt;MethodSymbol&gt;&gt; cache = new WeakHashMap&lt;&gt;();
3216 
3217         class Entry {
3218             Type site;
3219             MethodSymbol msym;
3220 
3221             Entry(Type site, MethodSymbol msym) {
3222                 this.site = site;
3223                 this.msym = msym;
3224             }
3225 
3226             @Override
3227             public boolean equals(Object obj) {
3228                 if (obj instanceof Entry) {
3229                     Entry e = (Entry)obj;
3230                     return e.msym == msym &amp;&amp; isSameType(site, e.site);
3231                 } else {
3232                     return false;
3233                 }
3234             }
3235 
3236             @Override
3237             public int hashCode() {
3238                 return Types.this.hashCode(site) &amp; ~msym.hashCode();
3239             }
3240         }
3241 
3242         public List&lt;MethodSymbol&gt; get(Entry e) {
3243             return cache.get(e);
3244         }
3245 
3246         public void put(Entry e, List&lt;MethodSymbol&gt; msymbols) {
3247             cache.put(e, msymbols);
3248         }
3249     }
3250 
3251     public CandidatesCache candidatesCache = new CandidatesCache();
3252 
3253     //where
3254     public List&lt;MethodSymbol&gt; interfaceCandidates(Type site, MethodSymbol ms) {
3255         CandidatesCache.Entry e = candidatesCache.new Entry(site, ms);
3256         List&lt;MethodSymbol&gt; candidates = candidatesCache.get(e);
3257         if (candidates == null) {
3258             Filter&lt;Symbol&gt; filter = new MethodFilter(ms, site);
3259             List&lt;MethodSymbol&gt; candidates2 = List.nil();
3260             for (Symbol s : membersClosure(site, false).getSymbols(filter)) {
3261                 if (!site.tsym.isInterface() &amp;&amp; !s.owner.isInterface()) {
3262                     return List.of((MethodSymbol)s);
3263                 } else if (!candidates2.contains(s)) {
3264                     candidates2 = candidates2.prepend((MethodSymbol)s);
3265                 }
3266             }
3267             candidates = prune(candidates2);
3268             candidatesCache.put(e, candidates);
3269         }
3270         return candidates;
3271     }
3272 
3273     public List&lt;MethodSymbol&gt; prune(List&lt;MethodSymbol&gt; methods) {
3274         ListBuffer&lt;MethodSymbol&gt; methodsMin = new ListBuffer&lt;&gt;();
3275         for (MethodSymbol m1 : methods) {
3276             boolean isMin_m1 = true;
3277             for (MethodSymbol m2 : methods) {
3278                 if (m1 == m2) continue;
3279                 if (m2.owner != m1.owner &amp;&amp;
3280                         asSuper(m2.owner.type, m1.owner) != null) {
3281                     isMin_m1 = false;
3282                     break;
3283                 }
3284             }
3285             if (isMin_m1)
3286                 methodsMin.append(m1);
3287         }
3288         return methodsMin.toList();
3289     }
3290     // where
3291             private class MethodFilter implements Filter&lt;Symbol&gt; {
3292 
3293                 Symbol msym;
3294                 Type site;
3295 
3296                 MethodFilter(Symbol msym, Type site) {
3297                     this.msym = msym;
3298                     this.site = site;
3299                 }
3300 
3301                 public boolean accepts(Symbol s) {
3302                     return s.kind == MTH &amp;&amp;
3303                             s.name == msym.name &amp;&amp;
3304                             (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
3305                             s.isInheritedIn(site.tsym, Types.this) &amp;&amp;
3306                             overrideEquivalent(memberType(site, s), memberType(site, msym));
3307                 }
3308             }
3309     // &lt;/editor-fold&gt;
3310 
3311     /**
3312      * Does t have the same arguments as s?  It is assumed that both
3313      * types are (possibly polymorphic) method types.  Monomorphic
3314      * method types &quot;have the same arguments&quot;, if their argument lists
3315      * are equal.  Polymorphic method types &quot;have the same arguments&quot;,
3316      * if they have the same arguments after renaming all type
3317      * variables of one to corresponding type variables in the other,
3318      * where correspondence is by position in the type parameter list.
3319      */
3320     public boolean hasSameArgs(Type t, Type s) {
3321         return hasSameArgs(t, s, true);
3322     }
3323 
3324     public boolean hasSameArgs(Type t, Type s, boolean strict) {
3325         return hasSameArgs(t, s, strict ? hasSameArgs_strict : hasSameArgs_nonstrict);
3326     }
3327 
3328     private boolean hasSameArgs(Type t, Type s, TypeRelation hasSameArgs) {
3329         return hasSameArgs.visit(t, s);
3330     }
3331     // where
3332         private class HasSameArgs extends TypeRelation {
3333 
3334             boolean strict;
3335 
3336             public HasSameArgs(boolean strict) {
3337                 this.strict = strict;
3338             }
3339 
3340             public Boolean visitType(Type t, Type s) {
3341                 throw new AssertionError();
3342             }
3343 
3344             @Override
3345             public Boolean visitMethodType(MethodType t, Type s) {
3346                 return s.hasTag(METHOD)
3347                     &amp;&amp; containsTypeEquivalent(t.argtypes, s.getParameterTypes());
3348             }
3349 
3350             @Override
3351             public Boolean visitForAll(ForAll t, Type s) {
3352                 if (!s.hasTag(FORALL))
3353                     return strict ? false : visitMethodType(t.asMethodType(), s);
3354 
3355                 ForAll forAll = (ForAll)s;
3356                 return hasSameBounds(t, forAll)
3357                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
3358             }
3359 
3360             @Override
3361             public Boolean visitErrorType(ErrorType t, Type s) {
3362                 return false;
3363             }
3364         }
3365 
3366     TypeRelation hasSameArgs_strict = new HasSameArgs(true);
3367         TypeRelation hasSameArgs_nonstrict = new HasSameArgs(false);
3368 
3369     // &lt;/editor-fold&gt;
3370 
3371     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;subst&quot;&gt;
3372     public List&lt;Type&gt; subst(List&lt;Type&gt; ts,
3373                             List&lt;Type&gt; from,
3374                             List&lt;Type&gt; to) {
3375         return ts.map(new Subst(from, to));
3376     }
3377 
3378     /**
3379      * Substitute all occurrences of a type in `from&#39; with the
3380      * corresponding type in `to&#39; in &#39;t&#39;. Match lists `from&#39; and `to&#39;
3381      * from the right: If lists have different length, discard leading
3382      * elements of the longer list.
3383      */
3384     public Type subst(Type t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3385         return t.map(new Subst(from, to));
3386     }
3387 
3388     private class Subst extends StructuralTypeMapping&lt;Void&gt; {
3389         List&lt;Type&gt; from;
3390         List&lt;Type&gt; to;
3391 
3392         public Subst(List&lt;Type&gt; from, List&lt;Type&gt; to) {
3393             int fromLength = from.length();
3394             int toLength = to.length();
3395             while (fromLength &gt; toLength) {
3396                 fromLength--;
3397                 from = from.tail;
3398             }
3399             while (fromLength &lt; toLength) {
3400                 toLength--;
3401                 to = to.tail;
3402             }
3403             this.from = from;
3404             this.to = to;
3405         }
3406 
3407         @Override
3408         public Type visitTypeVar(TypeVar t, Void ignored) {
3409             for (List&lt;Type&gt; from = this.from, to = this.to;
3410                  from.nonEmpty();
3411                  from = from.tail, to = to.tail) {
3412                 if (t.equalsIgnoreMetadata(from.head)) {
3413                     return to.head.withTypeVar(t);
3414                 }
3415             }
3416             return t;
3417         }
3418 
3419         @Override
3420         public Type visitClassType(ClassType t, Void ignored) {
3421             if (!t.isCompound()) {
3422                 return super.visitClassType(t, ignored);
3423             } else {
3424                 Type st = visit(supertype(t));
3425                 List&lt;Type&gt; is = visit(interfaces(t), ignored);
3426                 if (st == supertype(t) &amp;&amp; is == interfaces(t))
3427                     return t;
3428                 else
3429                     return makeIntersectionType(is.prepend(st));
3430             }
3431         }
3432 
3433         @Override
3434         public Type visitWildcardType(WildcardType t, Void ignored) {
3435             WildcardType t2 = (WildcardType)super.visitWildcardType(t, ignored);
3436             if (t2 != t &amp;&amp; t.isExtendsBound() &amp;&amp; t2.type.isExtendsBound()) {
3437                 t2.type = wildUpperBound(t2.type);
3438             }
3439             return t2;
3440         }
3441 
3442         @Override
3443         public Type visitForAll(ForAll t, Void ignored) {
3444             if (Type.containsAny(to, t.tvars)) {
3445                 //perform alpha-renaming of free-variables in &#39;t&#39;
3446                 //if &#39;to&#39; types contain variables that are free in &#39;t&#39;
3447                 List&lt;Type&gt; freevars = newInstances(t.tvars);
3448                 t = new ForAll(freevars,
3449                                Types.this.subst(t.qtype, t.tvars, freevars));
3450             }
3451             List&lt;Type&gt; tvars1 = substBounds(t.tvars, from, to);
3452             Type qtype1 = visit(t.qtype);
3453             if (tvars1 == t.tvars &amp;&amp; qtype1 == t.qtype) {
3454                 return t;
3455             } else if (tvars1 == t.tvars) {
3456                 return new ForAll(tvars1, qtype1) {
3457                     @Override
3458                     public boolean needsStripping() {
3459                         return true;
3460                     }
3461                 };
3462             } else {
3463                 return new ForAll(tvars1, Types.this.subst(qtype1, t.tvars, tvars1)) {
3464                     @Override
3465                     public boolean needsStripping() {
3466                         return true;
3467                     }
3468                 };
3469             }
3470         }
3471     }
3472 
3473     public List&lt;Type&gt; substBounds(List&lt;Type&gt; tvars,
3474                                   List&lt;Type&gt; from,
3475                                   List&lt;Type&gt; to) {
3476         if (tvars.isEmpty())
3477             return tvars;
3478         ListBuffer&lt;Type&gt; newBoundsBuf = new ListBuffer&lt;&gt;();
3479         boolean changed = false;
3480         // calculate new bounds
3481         for (Type t : tvars) {
3482             TypeVar tv = (TypeVar) t;
3483             Type bound = subst(tv.getUpperBound(), from, to);
3484             if (bound != tv.getUpperBound())
3485                 changed = true;
3486             newBoundsBuf.append(bound);
3487         }
3488         if (!changed)
3489             return tvars;
3490         ListBuffer&lt;Type&gt; newTvars = new ListBuffer&lt;&gt;();
3491         // create new type variables without bounds
3492         for (Type t : tvars) {
3493             newTvars.append(new TypeVar(t.tsym, null, syms.botType,
3494                                         t.getMetadata()));
3495         }
3496         // the new bounds should use the new type variables in place
3497         // of the old
3498         List&lt;Type&gt; newBounds = newBoundsBuf.toList();
3499         from = tvars;
3500         to = newTvars.toList();
3501         for (; !newBounds.isEmpty(); newBounds = newBounds.tail) {
3502             newBounds.head = subst(newBounds.head, from, to);
3503         }
3504         newBounds = newBoundsBuf.toList();
3505         // set the bounds of new type variables to the new bounds
3506         for (Type t : newTvars.toList()) {
3507             TypeVar tv = (TypeVar) t;
3508             tv.setUpperBound( newBounds.head );
3509             newBounds = newBounds.tail;
3510         }
3511         return newTvars.toList();
3512     }
3513 
3514     public TypeVar substBound(TypeVar t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3515         Type bound1 = subst(t.getUpperBound(), from, to);
3516         if (bound1 == t.getUpperBound())
3517             return t;
3518         else {
3519             // create new type variable without bounds
3520             TypeVar tv = new TypeVar(t.tsym, null, syms.botType,
3521                                      t.getMetadata());
3522             // the new bound should use the new type variable in place
3523             // of the old
3524             tv.setUpperBound( subst(bound1, List.of(t), List.of(tv)) );
3525             return tv;
3526         }
3527     }
3528     // &lt;/editor-fold&gt;
3529 
3530     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hasSameBounds&quot;&gt;
3531     /**
3532      * Does t have the same bounds for quantified variables as s?
3533      */
3534     public boolean hasSameBounds(ForAll t, ForAll s) {
3535         List&lt;Type&gt; l1 = t.tvars;
3536         List&lt;Type&gt; l2 = s.tvars;
3537         while (l1.nonEmpty() &amp;&amp; l2.nonEmpty() &amp;&amp;
3538                isSameType(l1.head.getUpperBound(),
3539                           subst(l2.head.getUpperBound(),
3540                                 s.tvars,
3541                                 t.tvars))) {
3542             l1 = l1.tail;
3543             l2 = l2.tail;
3544         }
3545         return l1.isEmpty() &amp;&amp; l2.isEmpty();
3546     }
3547     // &lt;/editor-fold&gt;
3548 
3549     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;newInstances&quot;&gt;
3550     /** Create new vector of type variables from list of variables
3551      *  changing all recursive bounds from old to new list.
3552      */
3553     public List&lt;Type&gt; newInstances(List&lt;Type&gt; tvars) {
3554         List&lt;Type&gt; tvars1 = tvars.map(newInstanceFun);
3555         for (List&lt;Type&gt; l = tvars1; l.nonEmpty(); l = l.tail) {
3556             TypeVar tv = (TypeVar) l.head;
3557             tv.setUpperBound( subst(tv.getUpperBound(), tvars, tvars1) );
3558         }
3559         return tvars1;
3560     }
3561         private static final TypeMapping&lt;Void&gt; newInstanceFun = new TypeMapping&lt;Void&gt;() {
3562             @Override
3563             public TypeVar visitTypeVar(TypeVar t, Void _unused) {
3564                 return new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata());
3565             }
3566         };
3567     // &lt;/editor-fold&gt;
3568 
3569     public Type createMethodTypeWithParameters(Type original, List&lt;Type&gt; newParams) {
3570         return original.accept(methodWithParameters, newParams);
3571     }
3572     // where
3573         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithParameters = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3574             public Type visitType(Type t, List&lt;Type&gt; newParams) {
3575                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3576             }
3577             public Type visitMethodType(MethodType t, List&lt;Type&gt; newParams) {
3578                 return new MethodType(newParams, t.restype, t.thrown, t.tsym);
3579             }
3580             public Type visitForAll(ForAll t, List&lt;Type&gt; newParams) {
3581                 return new ForAll(t.tvars, t.qtype.accept(this, newParams));
3582             }
3583         };
3584 
3585     public Type createMethodTypeWithThrown(Type original, List&lt;Type&gt; newThrown) {
3586         return original.accept(methodWithThrown, newThrown);
3587     }
3588     // where
3589         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithThrown = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3590             public Type visitType(Type t, List&lt;Type&gt; newThrown) {
3591                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3592             }
3593             public Type visitMethodType(MethodType t, List&lt;Type&gt; newThrown) {
3594                 return new MethodType(t.argtypes, t.restype, newThrown, t.tsym);
3595             }
3596             public Type visitForAll(ForAll t, List&lt;Type&gt; newThrown) {
3597                 return new ForAll(t.tvars, t.qtype.accept(this, newThrown));
3598             }
3599         };
3600 
3601     public Type createMethodTypeWithReturn(Type original, Type newReturn) {
3602         return original.accept(methodWithReturn, newReturn);
3603     }
3604     // where
3605         private final MapVisitor&lt;Type&gt; methodWithReturn = new MapVisitor&lt;Type&gt;() {
3606             public Type visitType(Type t, Type newReturn) {
3607                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3608             }
3609             public Type visitMethodType(MethodType t, Type newReturn) {
3610                 return new MethodType(t.argtypes, newReturn, t.thrown, t.tsym) {
3611                     @Override
3612                     public Type baseType() {
3613                         return t;
3614                     }
3615                 };
3616             }
3617             public Type visitForAll(ForAll t, Type newReturn) {
3618                 return new ForAll(t.tvars, t.qtype.accept(this, newReturn)) {
3619                     @Override
3620                     public Type baseType() {
3621                         return t;
3622                     }
3623                 };
3624             }
3625         };
3626 
3627     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;createErrorType&quot;&gt;
3628     public Type createErrorType(Type originalType) {
3629         return new ErrorType(originalType, syms.errSymbol);
3630     }
3631 
3632     public Type createErrorType(ClassSymbol c, Type originalType) {
3633         return new ErrorType(c, originalType);
3634     }
3635 
3636     public Type createErrorType(Name name, TypeSymbol container, Type originalType) {
3637         return new ErrorType(name, container, originalType);
3638     }
3639     // &lt;/editor-fold&gt;
3640 
3641     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;rank&quot;&gt;
3642     /**
3643      * The rank of a class is the length of the longest path between
3644      * the class and java.lang.Object in the class inheritance
3645      * graph. Undefined for all but reference types.
3646      */
3647     public int rank(Type t) {
3648         switch(t.getTag()) {
3649         case CLASS: {
3650             ClassType cls = (ClassType)t;
3651             if (cls.rank_field &lt; 0) {
3652                 Name fullname = cls.tsym.getQualifiedName();
3653                 if (fullname == names.java_lang_Object)
3654                     cls.rank_field = 0;
3655                 else {
3656                     int r = rank(supertype(cls));
3657                     for (List&lt;Type&gt; l = interfaces(cls);
3658                          l.nonEmpty();
3659                          l = l.tail) {
3660                         if (rank(l.head) &gt; r)
3661                             r = rank(l.head);
3662                     }
3663                     cls.rank_field = r + 1;
3664                 }
3665             }
3666             return cls.rank_field;
3667         }
3668         case TYPEVAR: {
3669             TypeVar tvar = (TypeVar)t;
3670             if (tvar.rank_field &lt; 0) {
3671                 int r = rank(supertype(tvar));
3672                 for (List&lt;Type&gt; l = interfaces(tvar);
3673                      l.nonEmpty();
3674                      l = l.tail) {
3675                     if (rank(l.head) &gt; r) r = rank(l.head);
3676                 }
3677                 tvar.rank_field = r + 1;
3678             }
3679             return tvar.rank_field;
3680         }
3681         case ERROR:
3682         case NONE:
3683             return 0;
3684         default:
3685             throw new AssertionError();
3686         }
3687     }
3688     // &lt;/editor-fold&gt;
3689 
3690     /**
3691      * Helper method for generating a string representation of a given type
3692      * accordingly to a given locale
3693      */
3694     public String toString(Type t, Locale locale) {
3695         return Printer.createStandardPrinter(messages).visit(t, locale);
3696     }
3697 
3698     /**
3699      * Helper method for generating a string representation of a given type
3700      * accordingly to a given locale
3701      */
3702     public String toString(Symbol t, Locale locale) {
3703         return Printer.createStandardPrinter(messages).visit(t, locale);
3704     }
3705 
3706     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;toString&quot;&gt;
3707     /**
3708      * This toString is slightly more descriptive than the one on Type.
3709      *
3710      * @deprecated Types.toString(Type t, Locale l) provides better support
3711      * for localization
3712      */
3713     @Deprecated
3714     public String toString(Type t) {
3715         if (t.hasTag(FORALL)) {
3716             ForAll forAll = (ForAll)t;
3717             return typaramsString(forAll.tvars) + forAll.qtype;
3718         }
3719         return &quot;&quot; + t;
3720     }
3721     // where
3722         private String typaramsString(List&lt;Type&gt; tvars) {
3723             StringBuilder s = new StringBuilder();
3724             s.append(&#39;&lt;&#39;);
3725             boolean first = true;
3726             for (Type t : tvars) {
3727                 if (!first) s.append(&quot;, &quot;);
3728                 first = false;
3729                 appendTyparamString(((TypeVar)t), s);
3730             }
3731             s.append(&#39;&gt;&#39;);
3732             return s.toString();
3733         }
3734         private void appendTyparamString(TypeVar t, StringBuilder buf) {
3735             buf.append(t);
3736             if (t.getUpperBound() == null ||
3737                 t.getUpperBound().tsym.getQualifiedName() == names.java_lang_Object)
3738                 return;
3739             buf.append(&quot; extends &quot;); // Java syntax; no need for i18n
3740             Type bound = t.getUpperBound();
3741             if (!bound.isCompound()) {
3742                 buf.append(bound);
3743             } else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0) {
3744                 buf.append(supertype(t));
3745                 for (Type intf : interfaces(t)) {
3746                     buf.append(&#39;&amp;&#39;);
3747                     buf.append(intf);
3748                 }
3749             } else {
3750                 // No superclass was given in bounds.
3751                 // In this case, supertype is Object, erasure is first interface.
3752                 boolean first = true;
3753                 for (Type intf : interfaces(t)) {
3754                     if (!first) buf.append(&#39;&amp;&#39;);
3755                     first = false;
3756                     buf.append(intf);
3757                 }
3758             }
3759         }
3760     // &lt;/editor-fold&gt;
3761 
3762     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining least upper bounds of types&quot;&gt;
3763     /**
3764      * A cache for closures.
3765      *
3766      * &lt;p&gt;A closure is a list of all the supertypes and interfaces of
3767      * a class or interface type, ordered by ClassSymbol.precedes
3768      * (that is, subclasses come first, arbitrary but fixed
3769      * otherwise).
3770      */
3771     private Map&lt;Type,List&lt;Type&gt;&gt; closureCache = new HashMap&lt;&gt;();
3772 
3773     /**
3774      * Returns the closure of a class or interface type.
3775      */
3776     public List&lt;Type&gt; closure(Type t) {
3777         List&lt;Type&gt; cl = closureCache.get(t);
3778         if (cl == null) {
3779             Type st = supertype(t);
3780             if (!t.isCompound()) {
3781                 if (st.hasTag(CLASS)) {
3782                     cl = insert(closure(st), t);
3783                 } else if (st.hasTag(TYPEVAR)) {
3784                     cl = closure(st).prepend(t);
3785                 } else {
3786                     cl = List.of(t);
3787                 }
3788             } else {
3789                 cl = closure(supertype(t));
3790             }
3791             for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail)
3792                 cl = union(cl, closure(l.head));
3793             closureCache.put(t, cl);
3794         }
3795         return cl;
3796     }
3797 
3798     /**
3799      * Collect types into a new closure (using a @code{ClosureHolder})
3800      */
3801     public Collector&lt;Type, ClosureHolder, List&lt;Type&gt;&gt; closureCollector(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3802         return Collector.of(() -&gt; new ClosureHolder(minClosure, shouldSkip),
3803                 ClosureHolder::add,
3804                 ClosureHolder::merge,
3805                 ClosureHolder::closure);
3806     }
3807     //where
3808         class ClosureHolder {
3809             List&lt;Type&gt; closure;
3810             final boolean minClosure;
3811             final BiPredicate&lt;Type, Type&gt; shouldSkip;
3812 
3813             ClosureHolder(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3814                 this.closure = List.nil();
3815                 this.minClosure = minClosure;
3816                 this.shouldSkip = shouldSkip;
3817             }
3818 
3819             void add(Type type) {
3820                 closure = insert(closure, type, shouldSkip);
3821             }
3822 
3823             ClosureHolder merge(ClosureHolder other) {
3824                 closure = union(closure, other.closure, shouldSkip);
3825                 return this;
3826             }
3827 
3828             List&lt;Type&gt; closure() {
3829                 return minClosure ? closureMin(closure) : closure;
3830             }
3831         }
3832 
3833     BiPredicate&lt;Type, Type&gt; basicClosureSkip = (t1, t2) -&gt; t1.tsym == t2.tsym;
3834 
3835     /**
3836      * Insert a type in a closure
3837      */
3838     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3839         if (cl.isEmpty()) {
3840             return cl.prepend(t);
3841         } else if (shouldSkip.test(t, cl.head)) {
3842             return cl;
3843         } else if (t.tsym.precedes(cl.head.tsym, this)) {
3844             return cl.prepend(t);
3845         } else {
3846             // t comes after head, or the two are unrelated
3847             return insert(cl.tail, t, shouldSkip).prepend(cl.head);
3848         }
3849     }
3850 
3851     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t) {
3852         return insert(cl, t, basicClosureSkip);
3853     }
3854 
3855     /**
3856      * Form the union of two closures
3857      */
3858     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3859         if (cl1.isEmpty()) {
3860             return cl2;
3861         } else if (cl2.isEmpty()) {
3862             return cl1;
3863         } else if (shouldSkip.test(cl1.head, cl2.head)) {
3864             return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);
3865         } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
3866             return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
3867         } else {
3868             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
3869         }
3870     }
3871 
3872     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3873         return union(cl1, cl2, basicClosureSkip);
3874     }
3875 
3876     /**
3877      * Intersect two closures
3878      */
3879     public List&lt;Type&gt; intersect(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3880         if (cl1 == cl2)
3881             return cl1;
3882         if (cl1.isEmpty() || cl2.isEmpty())
3883             return List.nil();
3884         if (cl1.head.tsym.precedes(cl2.head.tsym, this))
3885             return intersect(cl1.tail, cl2);
3886         if (cl2.head.tsym.precedes(cl1.head.tsym, this))
3887             return intersect(cl1, cl2.tail);
3888         if (isSameType(cl1.head, cl2.head))
3889             return intersect(cl1.tail, cl2.tail).prepend(cl1.head);
3890         if (cl1.head.tsym == cl2.head.tsym &amp;&amp;
3891             cl1.head.hasTag(CLASS) &amp;&amp; cl2.head.hasTag(CLASS)) {
3892             if (cl1.head.isParameterized() &amp;&amp; cl2.head.isParameterized()) {
3893                 Type merge = merge(cl1.head,cl2.head);
3894                 return intersect(cl1.tail, cl2.tail).prepend(merge);
3895             }
3896             if (cl1.head.isRaw() || cl2.head.isRaw())
3897                 return intersect(cl1.tail, cl2.tail).prepend(erasure(cl1.head));
3898         }
3899         return intersect(cl1.tail, cl2.tail);
3900     }
3901     // where
3902         class TypePair {
3903             final Type t1;
3904             final Type t2;;
3905 
3906             TypePair(Type t1, Type t2) {
3907                 this.t1 = t1;
3908                 this.t2 = t2;
3909             }
3910             @Override
3911             public int hashCode() {
3912                 return 127 * Types.this.hashCode(t1) + Types.this.hashCode(t2);
3913             }
3914             @Override
3915             public boolean equals(Object obj) {
3916                 if (!(obj instanceof TypePair))
3917                     return false;
3918                 TypePair typePair = (TypePair)obj;
3919                 return isSameType(t1, typePair.t1)
3920                     &amp;&amp; isSameType(t2, typePair.t2);
3921             }
3922         }
3923         Set&lt;TypePair&gt; mergeCache = new HashSet&lt;&gt;();
3924         private Type merge(Type c1, Type c2) {
3925             ClassType class1 = (ClassType) c1;
3926             List&lt;Type&gt; act1 = class1.getTypeArguments();
3927             ClassType class2 = (ClassType) c2;
3928             List&lt;Type&gt; act2 = class2.getTypeArguments();
3929             ListBuffer&lt;Type&gt; merged = new ListBuffer&lt;&gt;();
3930             List&lt;Type&gt; typarams = class1.tsym.type.getTypeArguments();
3931 
3932             while (act1.nonEmpty() &amp;&amp; act2.nonEmpty() &amp;&amp; typarams.nonEmpty()) {
3933                 if (containsType(act1.head, act2.head)) {
3934                     merged.append(act1.head);
3935                 } else if (containsType(act2.head, act1.head)) {
3936                     merged.append(act2.head);
3937                 } else {
3938                     TypePair pair = new TypePair(c1, c2);
3939                     Type m;
3940                     if (mergeCache.add(pair)) {
3941                         m = new WildcardType(lub(wildUpperBound(act1.head),
3942                                                  wildUpperBound(act2.head)),
3943                                              BoundKind.EXTENDS,
3944                                              syms.boundClass);
3945                         mergeCache.remove(pair);
3946                     } else {
3947                         m = new WildcardType(syms.objectType,
3948                                              BoundKind.UNBOUND,
3949                                              syms.boundClass);
3950                     }
3951                     merged.append(m.withTypeVar(typarams.head));
3952                 }
3953                 act1 = act1.tail;
3954                 act2 = act2.tail;
3955                 typarams = typarams.tail;
3956             }
3957             Assert.check(act1.isEmpty() &amp;&amp; act2.isEmpty() &amp;&amp; typarams.isEmpty());
3958             // There is no spec detailing how type annotations are to
3959             // be inherited.  So set it to noAnnotations for now
3960             return new ClassType(class1.getEnclosingType(), merged.toList(),
3961                                  class1.tsym);
3962         }
3963 
3964     /**
3965      * Return the minimum type of a closure, a compound type if no
3966      * unique minimum exists.
3967      */
3968     private Type compoundMin(List&lt;Type&gt; cl) {
3969         if (cl.isEmpty()) return syms.objectType;
3970         List&lt;Type&gt; compound = closureMin(cl);
3971         if (compound.isEmpty())
3972             return null;
3973         else if (compound.tail.isEmpty())
3974             return compound.head;
3975         else
3976             return makeIntersectionType(compound);
3977     }
3978 
3979     /**
3980      * Return the minimum types of a closure, suitable for computing
3981      * compoundMin or glb.
3982      */
3983     private List&lt;Type&gt; closureMin(List&lt;Type&gt; cl) {
3984         ListBuffer&lt;Type&gt; classes = new ListBuffer&lt;&gt;();
3985         ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
3986         Set&lt;Type&gt; toSkip = new HashSet&lt;&gt;();
3987         while (!cl.isEmpty()) {
3988             Type current = cl.head;
3989             boolean keep = !toSkip.contains(current);
3990             if (keep &amp;&amp; current.hasTag(TYPEVAR)) {
3991                 // skip lower-bounded variables with a subtype in cl.tail
3992                 for (Type t : cl.tail) {
3993                     if (isSubtypeNoCapture(t, current)) {
3994                         keep = false;
3995                         break;
3996                     }
3997                 }
3998             }
3999             if (keep) {
4000                 if (current.isInterface())
4001                     interfaces.append(current);
4002                 else
4003                     classes.append(current);
4004                 for (Type t : cl.tail) {
4005                     // skip supertypes of &#39;current&#39; in cl.tail
4006                     if (isSubtypeNoCapture(current, t))
4007                         toSkip.add(t);
4008                 }
4009             }
4010             cl = cl.tail;
4011         }
4012         return classes.appendList(interfaces).toList();
4013     }
4014 
4015     /**
4016      * Return the least upper bound of list of types.  if the lub does
4017      * not exist return null.
4018      */
4019     public Type lub(List&lt;Type&gt; ts) {
4020         return lub(ts.toArray(new Type[ts.length()]));
4021     }
4022 
4023     /**
4024      * Return the least upper bound (lub) of set of types.  If the lub
4025      * does not exist return the type of null (bottom).
4026      */
4027     public Type lub(Type... ts) {
4028         final int UNKNOWN_BOUND = 0;
4029         final int ARRAY_BOUND = 1;
4030         final int CLASS_BOUND = 2;
4031 
4032         int[] kinds = new int[ts.length];
4033 
4034         boolean haveValues = false;
4035         boolean haveRefs = false;
4036         for (int i = 0 ; i &lt; ts.length ; i++) {
4037             if (ts[i].isValue())
4038                 haveValues = true;
4039             else
4040                 haveRefs = true;
4041         }
4042         if (haveRefs &amp;&amp; haveValues) {
4043             System.arraycopy(ts, 0, ts = new Type[ts.length], 0, ts.length);
4044             for (int i = 0; i &lt; ts.length; i++) {
4045                 if (ts[i].isValue())
4046                     ts[i] = ts[i].referenceProjection();
4047             }
4048         }
4049 
4050         int boundkind = UNKNOWN_BOUND;
4051         for (int i = 0 ; i &lt; ts.length ; i++) {
4052             Type t = ts[i];
4053             switch (t.getTag()) {
4054             case CLASS:
4055                 boundkind |= kinds[i] = CLASS_BOUND;
4056                 break;
4057             case ARRAY:
4058                 boundkind |= kinds[i] = ARRAY_BOUND;
4059                 break;
4060             case  TYPEVAR:
4061                 do {
4062                     t = t.getUpperBound();
4063                 } while (t.hasTag(TYPEVAR));
4064                 if (t.hasTag(ARRAY)) {
4065                     boundkind |= kinds[i] = ARRAY_BOUND;
4066                 } else {
4067                     boundkind |= kinds[i] = CLASS_BOUND;
4068                 }
4069                 break;
4070             default:
4071                 kinds[i] = UNKNOWN_BOUND;
4072                 if (t.isPrimitive())
4073                     return syms.errType;
4074             }
4075         }
4076         switch (boundkind) {
4077         case 0:
4078             return syms.botType;
4079 
4080         case ARRAY_BOUND:
4081             // calculate lub(A[], B[])
4082             Type[] elements = new Type[ts.length];
4083             for (int i = 0 ; i &lt; ts.length ; i++) {
4084                 Type elem = elements[i] = elemTypeFun.apply(ts[i]);
4085                 if (elem.isPrimitive()) {
4086                     // if a primitive type is found, then return
4087                     // arraySuperType unless all the types are the
4088                     // same
4089                     Type first = ts[0];
4090                     for (int j = 1 ; j &lt; ts.length ; j++) {
4091                         if (!isSameType(first, ts[j])) {
4092                              // lub(int[], B[]) is Cloneable &amp; Serializable
4093                             return arraySuperType();
4094                         }
4095                     }
4096                     // all the array types are the same, return one
4097                     // lub(int[], int[]) is int[]
4098                     return first;
4099                 }
4100             }
4101             // lub(A[], B[]) is lub(A, B)[]
4102             return new ArrayType(lub(elements), syms.arrayClass);
4103 
4104         case CLASS_BOUND:
4105             // calculate lub(A, B)
4106             int startIdx = 0;
4107             for (int i = 0; i &lt; ts.length ; i++) {
4108                 Type t = ts[i];
4109                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR)) {
4110                     break;
4111                 } else {
4112                     startIdx++;
4113                 }
4114             }
4115             Assert.check(startIdx &lt; ts.length);
4116             //step 1 - compute erased candidate set (EC)
4117             List&lt;Type&gt; cl = erasedSupertypes(ts[startIdx]);
4118             for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4119                 Type t = ts[i];
4120                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR))
4121                     cl = intersect(cl, erasedSupertypes(t));
4122             }
4123             //step 2 - compute minimal erased candidate set (MEC)
4124             List&lt;Type&gt; mec = closureMin(cl);
4125             //step 3 - for each element G in MEC, compute lci(Inv(G))
4126             List&lt;Type&gt; candidates = List.nil();
4127             for (Type erasedSupertype : mec) {
4128                 List&lt;Type&gt; lci = List.of(asSuper(ts[startIdx], erasedSupertype.tsym));
4129                 for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4130                     Type superType = asSuper(ts[i], erasedSupertype.tsym);
4131                     lci = intersect(lci, superType != null ? List.of(superType) : List.nil());
4132                 }
4133                 candidates = candidates.appendList(lci);
4134             }
4135             //step 4 - let MEC be { G1, G2 ... Gn }, then we have that
4136             //lub = lci(Inv(G1)) &amp; lci(Inv(G2)) &amp; ... &amp; lci(Inv(Gn))
4137             return compoundMin(candidates);
4138 
4139         default:
4140             // calculate lub(A, B[])
4141             List&lt;Type&gt; classes = List.of(arraySuperType());
4142             for (int i = 0 ; i &lt; ts.length ; i++) {
4143                 if (kinds[i] != ARRAY_BOUND) // Filter out any arrays
4144                     classes = classes.prepend(ts[i]);
4145             }
4146             // lub(A, B[]) is lub(A, arraySuperType)
4147             return lub(classes);
4148         }
4149     }
4150     // where
4151         List&lt;Type&gt; erasedSupertypes(Type t) {
4152             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4153             for (Type sup : closure(t)) {
4154                 if (sup.hasTag(TYPEVAR)) {
4155                     buf.append(sup);
4156                 } else {
4157                     buf.append(erasure(sup));
4158                 }
4159             }
4160             return buf.toList();
4161         }
4162 
4163         private Type arraySuperType = null;
4164         private Type arraySuperType() {
4165             // initialized lazily to avoid problems during compiler startup
4166             if (arraySuperType == null) {
4167                 synchronized (this) {
4168                     if (arraySuperType == null) {
4169                         // JLS 10.8: all arrays implement Cloneable and Serializable.
<a name="5" id="anc5"></a><span class="line-modified">4170                         List&lt;Type&gt; ifaces =</span>
<span class="line-modified">4171                                 List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType);</span>

4172                         arraySuperType = makeIntersectionType(ifaces, true);
4173                     }
4174                 }
4175             }
4176             return arraySuperType;
4177         }
4178     // &lt;/editor-fold&gt;
4179 
4180     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4181     public Type glb(List&lt;Type&gt; ts) {
4182         Type t1 = ts.head;
4183         for (Type t2 : ts.tail) {
4184             if (t1.isErroneous())
4185                 return t1;
4186             t1 = glb(t1, t2);
4187         }
4188         return t1;
4189     }
4190     //where
4191     public Type glb(Type t, Type s) {
4192         if (s == null)
4193             return t;
4194         else if (t.isPrimitive() || s.isPrimitive())
4195             return syms.errType;
4196         else if (isSubtypeNoCapture(t, s))
4197             return t;
4198         else if (isSubtypeNoCapture(s, t))
4199             return s;
4200 
4201         List&lt;Type&gt; closure = union(closure(t), closure(s));
4202         return glbFlattened(closure, t);
4203     }
4204     //where
4205     /**
4206      * Perform glb for a list of non-primitive, non-error, non-compound types;
4207      * redundant elements are removed.  Bounds should be ordered according to
4208      * {@link Symbol#precedes(TypeSymbol,Types)}.
4209      *
4210      * @param flatBounds List of type to glb
4211      * @param errT Original type to use if the result is an error type
4212      */
4213     private Type glbFlattened(List&lt;Type&gt; flatBounds, Type errT) {
4214         List&lt;Type&gt; bounds = closureMin(flatBounds);
4215 
4216         if (bounds.isEmpty()) {             // length == 0
4217             return syms.objectType;
4218         } else if (bounds.tail.isEmpty()) { // length == 1
4219             return bounds.head;
4220         } else {                            // length &gt; 1
4221             int classCount = 0;
4222             List&lt;Type&gt; cvars = List.nil();
4223             List&lt;Type&gt; lowers = List.nil();
4224             for (Type bound : bounds) {
4225                 if (!bound.isInterface()) {
4226                     classCount++;
4227                     Type lower = cvarLowerBound(bound);
4228                     if (bound != lower &amp;&amp; !lower.hasTag(BOT)) {
4229                         cvars = cvars.append(bound);
4230                         lowers = lowers.append(lower);
4231                     }
4232                 }
4233             }
4234             if (classCount &gt; 1) {
4235                 if (lowers.isEmpty()) {
4236                     return createErrorType(errT);
4237                 } else {
4238                     // try again with lower bounds included instead of capture variables
4239                     List&lt;Type&gt; newBounds = bounds.diff(cvars).appendList(lowers);
4240                     return glb(newBounds);
4241                 }
4242             }
4243         }
4244         return makeIntersectionType(bounds);
4245     }
4246     // &lt;/editor-fold&gt;
4247 
4248     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hashCode&quot;&gt;
4249     /**
4250      * Compute a hash code on a type.
4251      */
4252     public int hashCode(Type t) {
4253         return hashCode(t, false);
4254     }
4255 
4256     public int hashCode(Type t, boolean strict) {
4257         return strict ?
4258                 hashCodeStrictVisitor.visit(t) :
4259                 hashCodeVisitor.visit(t);
4260     }
4261     // where
4262         private static final HashCodeVisitor hashCodeVisitor = new HashCodeVisitor();
4263         private static final HashCodeVisitor hashCodeStrictVisitor = new HashCodeVisitor() {
4264             @Override
4265             public Integer visitTypeVar(TypeVar t, Void ignored) {
4266                 return System.identityHashCode(t);
4267             }
4268         };
4269 
4270         private static class HashCodeVisitor extends UnaryVisitor&lt;Integer&gt; {
4271             public Integer visitType(Type t, Void ignored) {
4272                 return t.getTag().ordinal();
4273             }
4274 
4275             @Override
4276             public Integer visitClassType(ClassType t, Void ignored) {
4277                 int result = visit(t.getEnclosingType());
4278                 result *= 127;
4279                 result += t.tsym.flatName().hashCode();
4280                 for (Type s : t.getTypeArguments()) {
4281                     result *= 127;
4282                     result += visit(s);
4283                 }
4284                 return result;
4285             }
4286 
4287             @Override
4288             public Integer visitMethodType(MethodType t, Void ignored) {
4289                 int h = METHOD.ordinal();
4290                 for (List&lt;Type&gt; thisargs = t.argtypes;
4291                      thisargs.tail != null;
4292                      thisargs = thisargs.tail)
4293                     h = (h &lt;&lt; 5) + visit(thisargs.head);
4294                 return (h &lt;&lt; 5) + visit(t.restype);
4295             }
4296 
4297             @Override
4298             public Integer visitWildcardType(WildcardType t, Void ignored) {
4299                 int result = t.kind.hashCode();
4300                 if (t.type != null) {
4301                     result *= 127;
4302                     result += visit(t.type);
4303                 }
4304                 return result;
4305             }
4306 
4307             @Override
4308             public Integer visitArrayType(ArrayType t, Void ignored) {
4309                 return visit(t.elemtype) + 12;
4310             }
4311 
4312             @Override
4313             public Integer visitTypeVar(TypeVar t, Void ignored) {
4314                 return System.identityHashCode(t);
4315             }
4316 
4317             @Override
4318             public Integer visitUndetVar(UndetVar t, Void ignored) {
4319                 return System.identityHashCode(t);
4320             }
4321 
4322             @Override
4323             public Integer visitErrorType(ErrorType t, Void ignored) {
4324                 return 0;
4325             }
4326         }
4327     // &lt;/editor-fold&gt;
4328 
4329     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Return-Type-Substitutable&quot;&gt;
4330     /**
4331      * Does t have a result that is a subtype of the result type of s,
4332      * suitable for covariant returns?  It is assumed that both types
4333      * are (possibly polymorphic) method types.  Monomorphic method
4334      * types are handled in the obvious way.  Polymorphic method types
4335      * require renaming all type variables of one to corresponding
4336      * type variables in the other, where correspondence is by
4337      * position in the type parameter list. */
4338     public boolean resultSubtype(Type t, Type s, Warner warner) {
4339         List&lt;Type&gt; tvars = t.getTypeArguments();
4340         List&lt;Type&gt; svars = s.getTypeArguments();
4341         Type tres = t.getReturnType();
4342         Type sres = subst(s.getReturnType(), svars, tvars);
4343         return covariantReturnType(tres, sres, warner);
4344     }
4345 
4346     /**
4347      * Return-Type-Substitutable.
4348      * @jls 8.4.5 Method Result
4349      */
4350     public boolean returnTypeSubstitutable(Type r1, Type r2) {
4351         if (hasSameArgs(r1, r2))
4352             return resultSubtype(r1, r2, noWarnings);
4353         else
4354             return covariantReturnType(r1.getReturnType(),
4355                                        erasure(r2.getReturnType()),
4356                                        noWarnings);
4357     }
4358 
4359     public boolean returnTypeSubstitutable(Type r1,
4360                                            Type r2, Type r2res,
4361                                            Warner warner) {
4362         if (isSameType(r1.getReturnType(), r2res))
4363             return true;
4364         if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())
4365             return false;
4366 
4367         if (hasSameArgs(r1, r2))
4368             return covariantReturnType(r1.getReturnType(), r2res, warner);
4369         if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))
4370             return true;
4371         if (!isSubtype(r1.getReturnType(), erasure(r2res)))
4372             return false;
4373         warner.warn(LintCategory.UNCHECKED);
4374         return true;
4375     }
4376 
4377     /**
4378      * Is t an appropriate return type in an overrider for a
4379      * method that returns s?
4380      */
4381     public boolean covariantReturnType(Type t, Type s, Warner warner) {
4382         return
4383             isSameType(t, s) ||
4384             !t.isPrimitive() &amp;&amp;
4385             !s.isPrimitive() &amp;&amp;
4386             isAssignable(t, s, warner);
4387     }
4388     // &lt;/editor-fold&gt;
4389 
4390     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Box/unbox support&quot;&gt;
4391     /**
4392      * Return the class that boxes the given primitive.
4393      */
4394     public ClassSymbol boxedClass(Type t) {
4395         return syms.enterClass(syms.java_base, syms.boxedName[t.getTag().ordinal()]);
4396     }
4397 
4398     /**
4399      * Return the boxed type if &#39;t&#39; is primitive, otherwise return &#39;t&#39; itself.
4400      */
4401     public Type boxedTypeOrType(Type t) {
4402         return t.isPrimitive() ?
4403             boxedClass(t).type :
4404             t;
4405     }
4406 
4407     /**
4408      * Return the primitive type corresponding to a boxed type.
4409      */
4410     public Type unboxedType(Type t) {
4411         for (int i=0; i&lt;syms.boxedName.length; i++) {
4412             Name box = syms.boxedName[i];
4413             if (box != null &amp;&amp;
4414                 asSuper(t, syms.enterClass(syms.java_base, box)) != null)
4415                 return syms.typeOfTag[i];
4416         }
4417         return Type.noType;
4418     }
4419 
4420     /**
4421      * Return the unboxed type if &#39;t&#39; is a boxed class, otherwise return &#39;t&#39; itself.
4422      */
4423     public Type unboxedTypeOrType(Type t) {
4424         Type unboxedType = unboxedType(t);
4425         return unboxedType.hasTag(NONE) ? t : unboxedType;
4426     }
4427     // &lt;/editor-fold&gt;
4428 
4429     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Capture conversion&quot;&gt;
4430     /*
4431      * JLS 5.1.10 Capture Conversion:
4432      *
4433      * Let G name a generic type declaration with n formal type
4434      * parameters A1 ... An with corresponding bounds U1 ... Un. There
4435      * exists a capture conversion from G&lt;T1 ... Tn&gt; to G&lt;S1 ... Sn&gt;,
4436      * where, for 1 &lt;= i &lt;= n:
4437      *
4438      * + If Ti is a wildcard type argument (4.5.1) of the form ? then
4439      *   Si is a fresh type variable whose upper bound is
4440      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is the null
4441      *   type.
4442      *
4443      * + If Ti is a wildcard type argument of the form ? extends Bi,
4444      *   then Si is a fresh type variable whose upper bound is
4445      *   glb(Bi, Ui[A1 := S1, ..., An := Sn]) and whose lower bound is
4446      *   the null type, where glb(V1,... ,Vm) is V1 &amp; ... &amp; Vm. It is
4447      *   a compile-time error if for any two classes (not interfaces)
4448      *   Vi and Vj,Vi is not a subclass of Vj or vice versa.
4449      *
4450      * + If Ti is a wildcard type argument of the form ? super Bi,
4451      *   then Si is a fresh type variable whose upper bound is
4452      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is Bi.
4453      *
4454      * + Otherwise, Si = Ti.
4455      *
4456      * Capture conversion on any type other than a parameterized type
4457      * (4.5) acts as an identity conversion (5.1.1). Capture
4458      * conversions never require a special action at run time and
4459      * therefore never throw an exception at run time.
4460      *
4461      * Capture conversion is not applied recursively.
4462      */
4463     /**
4464      * Capture conversion as specified by the JLS.
4465      */
4466 
4467     public List&lt;Type&gt; capture(List&lt;Type&gt; ts) {
4468         List&lt;Type&gt; buf = List.nil();
4469         for (Type t : ts) {
4470             buf = buf.prepend(capture(t));
4471         }
4472         return buf.reverse();
4473     }
4474 
4475     public Type capture(Type t) {
4476         if (!t.hasTag(CLASS)) {
4477             return t;
4478         }
4479         if (t.getEnclosingType() != Type.noType) {
4480             Type capturedEncl = capture(t.getEnclosingType());
4481             if (capturedEncl != t.getEnclosingType()) {
4482                 Type type1 = memberType(capturedEncl, t.tsym);
4483                 t = subst(type1, t.tsym.type.getTypeArguments(), t.getTypeArguments());
4484             }
4485         }
4486         ClassType cls = (ClassType)t;
4487         if (cls.isRaw() || !cls.isParameterized())
4488             return cls;
4489 
4490         ClassType G = (ClassType)cls.asElement().asType();
4491         List&lt;Type&gt; A = G.getTypeArguments();
4492         List&lt;Type&gt; T = cls.getTypeArguments();
4493         List&lt;Type&gt; S = freshTypeVariables(T);
4494 
4495         List&lt;Type&gt; currentA = A;
4496         List&lt;Type&gt; currentT = T;
4497         List&lt;Type&gt; currentS = S;
4498         boolean captured = false;
4499         while (!currentA.isEmpty() &amp;&amp;
4500                !currentT.isEmpty() &amp;&amp;
4501                !currentS.isEmpty()) {
4502             if (currentS.head != currentT.head) {
4503                 captured = true;
4504                 WildcardType Ti = (WildcardType)currentT.head;
4505                 Type Ui = currentA.head.getUpperBound();
4506                 CapturedType Si = (CapturedType)currentS.head;
4507                 if (Ui == null)
4508                     Ui = syms.objectType;
4509                 switch (Ti.kind) {
4510                 case UNBOUND:
4511                     Si.setUpperBound( subst(Ui, A, S) );
4512                     Si.lower = syms.botType;
4513                     break;
4514                 case EXTENDS:
4515                     Si.setUpperBound( glb(Ti.getExtendsBound(), subst(Ui, A, S)) );
4516                     Si.lower = syms.botType;
4517                     break;
4518                 case SUPER:
4519                     Si.setUpperBound( subst(Ui, A, S) );
4520                     Si.lower = Ti.getSuperBound();
4521                     break;
4522                 }
4523                 Type tmpBound = Si.getUpperBound().hasTag(UNDETVAR) ? ((UndetVar)Si.getUpperBound()).qtype : Si.getUpperBound();
4524                 Type tmpLower = Si.lower.hasTag(UNDETVAR) ? ((UndetVar)Si.lower).qtype : Si.lower;
4525                 if (!Si.getUpperBound().hasTag(ERROR) &amp;&amp;
4526                     !Si.lower.hasTag(ERROR) &amp;&amp;
4527                     isSameType(tmpBound, tmpLower)) {
4528                     currentS.head = Si.getUpperBound();
4529                 }
4530             }
4531             currentA = currentA.tail;
4532             currentT = currentT.tail;
4533             currentS = currentS.tail;
4534         }
4535         if (!currentA.isEmpty() || !currentT.isEmpty() || !currentS.isEmpty())
4536             return erasure(t); // some &quot;rare&quot; type involved
4537 
4538         if (captured)
4539             return new ClassType(cls.getEnclosingType(), S, cls.tsym,
4540                                  cls.getMetadata());
4541         else
4542             return t;
4543     }
4544     // where
4545         public List&lt;Type&gt; freshTypeVariables(List&lt;Type&gt; types) {
4546             ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
4547             for (Type t : types) {
4548                 if (t.hasTag(WILDCARD)) {
4549                     Type bound = ((WildcardType)t).getExtendsBound();
4550                     if (bound == null)
4551                         bound = syms.objectType;
4552                     result.append(new CapturedType(capturedName,
4553                                                    syms.noSymbol,
4554                                                    bound,
4555                                                    syms.botType,
4556                                                    (WildcardType)t));
4557                 } else {
4558                     result.append(t);
4559                 }
4560             }
4561             return result.toList();
4562         }
4563     // &lt;/editor-fold&gt;
4564 
4565     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Internal utility methods&quot;&gt;
4566     private boolean sideCast(Type from, Type to, Warner warn) {
4567         // We are casting from type $from$ to type $to$, which are
4568         // non-final unrelated types.  This method
4569         // tries to reject a cast by transferring type parameters
4570         // from $to$ to $from$ by common superinterfaces.
4571         boolean reverse = false;
4572         Type target = to;
4573         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4574             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4575             reverse = true;
4576             to = from;
4577             from = target;
4578         }
4579         List&lt;Type&gt; commonSupers = superClosure(to, erasure(from));
4580         boolean giveWarning = commonSupers.isEmpty();
4581         // The arguments to the supers could be unified here to
4582         // get a more accurate analysis
4583         while (commonSupers.nonEmpty()) {
4584             Type t1 = asSuper(from, commonSupers.head.tsym);
4585             Type t2 = commonSupers.head; // same as asSuper(to, commonSupers.head.tsym);
4586             if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4587                 return false;
4588             giveWarning = giveWarning || (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2));
4589             commonSupers = commonSupers.tail;
4590         }
4591         if (giveWarning &amp;&amp; !isReifiable(reverse ? from : to))
4592             warn.warn(LintCategory.UNCHECKED);
4593         return true;
4594     }
4595 
4596     private boolean sideCastFinal(Type from, Type to, Warner warn) {
4597         // We are casting from type $from$ to type $to$, which are
4598         // unrelated types one of which is final and the other of
4599         // which is an interface.  This method
4600         // tries to reject a cast by transferring type parameters
4601         // from the final class to the interface.
4602         boolean reverse = false;
4603         Type target = to;
4604         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4605             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4606             reverse = true;
4607             to = from;
4608             from = target;
4609         }
4610         Assert.check((from.tsym.flags() &amp; FINAL) != 0);
4611         Type t1 = asSuper(from, to.tsym);
4612         if (t1 == null) return false;
4613         Type t2 = to;
4614         if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4615             return false;
4616         if (!isReifiable(target) &amp;&amp;
4617             (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2)))
4618             warn.warn(LintCategory.UNCHECKED);
4619         return true;
4620     }
4621 
4622     private boolean giveWarning(Type from, Type to) {
4623         List&lt;Type&gt; bounds = to.isCompound() ?
4624                 directSupertypes(to) : List.of(to);
4625         for (Type b : bounds) {
4626             Type subFrom = asSub(from, b.tsym);
4627             if (b.isParameterized() &amp;&amp;
4628                     (!(isUnbounded(b) ||
4629                     isSubtype(from, b) ||
4630                     ((subFrom != null) &amp;&amp; containsType(b.allparams(), subFrom.allparams()))))) {
4631                 return true;
4632             }
4633         }
4634         return false;
4635     }
4636 
4637     private List&lt;Type&gt; superClosure(Type t, Type s) {
4638         List&lt;Type&gt; cl = List.nil();
4639         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
4640             if (isSubtype(s, erasure(l.head))) {
4641                 cl = insert(cl, l.head);
4642             } else {
4643                 cl = union(cl, superClosure(l.head, s));
4644             }
4645         }
4646         return cl;
4647     }
4648 
4649     private boolean containsTypeEquivalent(Type t, Type s) {
4650         return isSameType(t, s) || // shortcut
4651             containsType(t, s) &amp;&amp; containsType(s, t);
4652     }
4653 
4654     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;adapt&quot;&gt;
4655     /**
4656      * Adapt a type by computing a substitution which maps a source
4657      * type to a target type.
4658      *
4659      * @param source    the source type
4660      * @param target    the target type
4661      * @param from      the type variables of the computed substitution
4662      * @param to        the types of the computed substitution.
4663      */
4664     public void adapt(Type source,
4665                        Type target,
4666                        ListBuffer&lt;Type&gt; from,
4667                        ListBuffer&lt;Type&gt; to) throws AdaptFailure {
4668         new Adapter(from, to).adapt(source, target);
4669     }
4670 
4671     class Adapter extends SimpleVisitor&lt;Void, Type&gt; {
4672 
4673         ListBuffer&lt;Type&gt; from;
4674         ListBuffer&lt;Type&gt; to;
4675         Map&lt;Symbol,Type&gt; mapping;
4676 
4677         Adapter(ListBuffer&lt;Type&gt; from, ListBuffer&lt;Type&gt; to) {
4678             this.from = from;
4679             this.to = to;
4680             mapping = new HashMap&lt;&gt;();
4681         }
4682 
4683         public void adapt(Type source, Type target) throws AdaptFailure {
4684             visit(source, target);
4685             List&lt;Type&gt; fromList = from.toList();
4686             List&lt;Type&gt; toList = to.toList();
4687             while (!fromList.isEmpty()) {
4688                 Type val = mapping.get(fromList.head.tsym);
4689                 if (toList.head != val)
4690                     toList.head = val;
4691                 fromList = fromList.tail;
4692                 toList = toList.tail;
4693             }
4694         }
4695 
4696         @Override
4697         public Void visitClassType(ClassType source, Type target) throws AdaptFailure {
4698             if (target.hasTag(CLASS))
4699                 adaptRecursive(source.allparams(), target.allparams());
4700             return null;
4701         }
4702 
4703         @Override
4704         public Void visitArrayType(ArrayType source, Type target) throws AdaptFailure {
4705             if (target.hasTag(ARRAY))
4706                 adaptRecursive(elemtype(source), elemtype(target));
4707             return null;
4708         }
4709 
4710         @Override
4711         public Void visitWildcardType(WildcardType source, Type target) throws AdaptFailure {
4712             if (source.isExtendsBound())
4713                 adaptRecursive(wildUpperBound(source), wildUpperBound(target));
4714             else if (source.isSuperBound())
4715                 adaptRecursive(wildLowerBound(source), wildLowerBound(target));
4716             return null;
4717         }
4718 
4719         @Override
4720         public Void visitTypeVar(TypeVar source, Type target) throws AdaptFailure {
4721             // Check to see if there is
4722             // already a mapping for $source$, in which case
4723             // the old mapping will be merged with the new
4724             Type val = mapping.get(source.tsym);
4725             if (val != null) {
4726                 if (val.isSuperBound() &amp;&amp; target.isSuperBound()) {
4727                     val = isSubtype(wildLowerBound(val), wildLowerBound(target))
4728                         ? target : val;
4729                 } else if (val.isExtendsBound() &amp;&amp; target.isExtendsBound()) {
4730                     val = isSubtype(wildUpperBound(val), wildUpperBound(target))
4731                         ? val : target;
4732                 } else if (!isSameType(val, target)) {
4733                     throw new AdaptFailure();
4734                 }
4735             } else {
4736                 val = target;
4737                 from.append(source);
4738                 to.append(target);
4739             }
4740             mapping.put(source.tsym, val);
4741             return null;
4742         }
4743 
4744         @Override
4745         public Void visitType(Type source, Type target) {
4746             return null;
4747         }
4748 
4749         private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
4750 
4751         private void adaptRecursive(Type source, Type target) {
4752             TypePair pair = new TypePair(source, target);
4753             if (cache.add(pair)) {
4754                 try {
4755                     visit(source, target);
4756                 } finally {
4757                     cache.remove(pair);
4758                 }
4759             }
4760         }
4761 
4762         private void adaptRecursive(List&lt;Type&gt; source, List&lt;Type&gt; target) {
4763             if (source.length() == target.length()) {
4764                 while (source.nonEmpty()) {
4765                     adaptRecursive(source.head, target.head);
4766                     source = source.tail;
4767                     target = target.tail;
4768                 }
4769             }
4770         }
4771     }
4772 
4773     public static class AdaptFailure extends RuntimeException {
4774         static final long serialVersionUID = -7490231548272701566L;
4775     }
4776 
4777     private void adaptSelf(Type t,
4778                            ListBuffer&lt;Type&gt; from,
4779                            ListBuffer&lt;Type&gt; to) {
4780         try {
4781             //if (t.tsym.type != t)
4782                 adapt(t.tsym.type, t, from, to);
4783         } catch (AdaptFailure ex) {
4784             // Adapt should never fail calculating a mapping from
4785             // t.tsym.type to t as there can be no merge problem.
4786             throw new AssertionError(ex);
4787         }
4788     }
4789     // &lt;/editor-fold&gt;
4790 
4791     /**
4792      * Rewrite all type variables (universal quantifiers) in the given
4793      * type to wildcards (existential quantifiers).  This is used to
4794      * determine if a cast is allowed.  For example, if high is true
4795      * and {@code T &lt;: Number}, then {@code List&lt;T&gt;} is rewritten to
4796      * {@code List&lt;?  extends Number&gt;}.  Since {@code List&lt;Integer&gt; &lt;:
4797      * List&lt;? extends Number&gt;} a {@code List&lt;T&gt;} can be cast to {@code
4798      * List&lt;Integer&gt;} with a warning.
4799      * @param t a type
4800      * @param high if true return an upper bound; otherwise a lower
4801      * bound
4802      * @param rewriteTypeVars only rewrite captured wildcards if false;
4803      * otherwise rewrite all type variables
4804      * @return the type rewritten with wildcards (existential
4805      * quantifiers) only
4806      */
4807     private Type rewriteQuantifiers(Type t, boolean high, boolean rewriteTypeVars) {
4808         return new Rewriter(high, rewriteTypeVars).visit(t);
4809     }
4810 
4811     class Rewriter extends UnaryVisitor&lt;Type&gt; {
4812 
4813         boolean high;
4814         boolean rewriteTypeVars;
4815 
4816         Rewriter(boolean high, boolean rewriteTypeVars) {
4817             this.high = high;
4818             this.rewriteTypeVars = rewriteTypeVars;
4819         }
4820 
4821         @Override
4822         public Type visitClassType(ClassType t, Void s) {
4823             ListBuffer&lt;Type&gt; rewritten = new ListBuffer&lt;&gt;();
4824             boolean changed = false;
4825             for (Type arg : t.allparams()) {
4826                 Type bound = visit(arg);
4827                 if (arg != bound) {
4828                     changed = true;
4829                 }
4830                 rewritten.append(bound);
4831             }
4832             if (changed)
4833                 return subst(t.tsym.type,
4834                         t.tsym.type.allparams(),
4835                         rewritten.toList());
4836             else
4837                 return t;
4838         }
4839 
4840         public Type visitType(Type t, Void s) {
4841             return t;
4842         }
4843 
4844         @Override
4845         public Type visitCapturedType(CapturedType t, Void s) {
4846             Type w_bound = t.wildcard.type;
4847             Type bound = w_bound.contains(t) ?
4848                         erasure(w_bound) :
4849                         visit(w_bound);
4850             return rewriteAsWildcardType(visit(bound), t.wildcard.bound, t.wildcard.kind);
4851         }
4852 
4853         @Override
4854         public Type visitTypeVar(TypeVar t, Void s) {
4855             if (rewriteTypeVars) {
4856                 Type bound = t.getUpperBound().contains(t) ?
4857                         erasure(t.getUpperBound()) :
4858                         visit(t.getUpperBound());
4859                 return rewriteAsWildcardType(bound, t, EXTENDS);
4860             } else {
4861                 return t;
4862             }
4863         }
4864 
4865         @Override
4866         public Type visitWildcardType(WildcardType t, Void s) {
4867             Type bound2 = visit(t.type);
4868             return t.type == bound2 ? t : rewriteAsWildcardType(bound2, t.bound, t.kind);
4869         }
4870 
4871         private Type rewriteAsWildcardType(Type bound, TypeVar formal, BoundKind bk) {
4872             switch (bk) {
4873                case EXTENDS: return high ?
4874                        makeExtendsWildcard(B(bound), formal) :
4875                        makeExtendsWildcard(syms.objectType, formal);
4876                case SUPER: return high ?
4877                        makeSuperWildcard(syms.botType, formal) :
4878                        makeSuperWildcard(B(bound), formal);
4879                case UNBOUND: return makeExtendsWildcard(syms.objectType, formal);
4880                default:
4881                    Assert.error(&quot;Invalid bound kind &quot; + bk);
4882                    return null;
4883             }
4884         }
4885 
4886         Type B(Type t) {
4887             while (t.hasTag(WILDCARD)) {
4888                 WildcardType w = (WildcardType)t;
4889                 t = high ?
4890                     w.getExtendsBound() :
4891                     w.getSuperBound();
4892                 if (t == null) {
4893                     t = high ? syms.objectType : syms.botType;
4894                 }
4895             }
4896             return t;
4897         }
4898     }
4899 
4900 
4901     /**
4902      * Create a wildcard with the given upper (extends) bound; create
4903      * an unbounded wildcard if bound is Object.
4904      *
4905      * @param bound the upper bound
4906      * @param formal the formal type parameter that will be
4907      * substituted by the wildcard
4908      */
4909     private WildcardType makeExtendsWildcard(Type bound, TypeVar formal) {
4910         if (bound == syms.objectType) {
4911             return new WildcardType(syms.objectType,
4912                                     BoundKind.UNBOUND,
4913                                     syms.boundClass,
4914                                     formal);
4915         } else {
4916             return new WildcardType(bound,
4917                                     BoundKind.EXTENDS,
4918                                     syms.boundClass,
4919                                     formal);
4920         }
4921     }
4922 
4923     /**
4924      * Create a wildcard with the given lower (super) bound; create an
4925      * unbounded wildcard if bound is bottom (type of {@code null}).
4926      *
4927      * @param bound the lower bound
4928      * @param formal the formal type parameter that will be
4929      * substituted by the wildcard
4930      */
4931     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4932         if (bound.hasTag(BOT)) {
4933             return new WildcardType(syms.objectType,
4934                                     BoundKind.UNBOUND,
4935                                     syms.boundClass,
4936                                     formal);
4937         } else {
4938             return new WildcardType(bound,
4939                                     BoundKind.SUPER,
4940                                     syms.boundClass,
4941                                     formal);
4942         }
4943     }
4944 
4945     /**
4946      * A wrapper for a type that allows use in sets.
4947      */
4948     public static class UniqueType {
4949         public final Type type;
4950         final Types types;
4951         private boolean encodeTypeSig;
4952 
4953         public UniqueType(Type type, Types types, boolean encodeTypeSig) {
4954             this.type = type;
4955             this.types = types;
4956             this.encodeTypeSig = encodeTypeSig;
4957         }
4958 
4959         public UniqueType(Type type, Types types) {
4960             this(type, types, true);
4961         }
4962 
4963         public int hashCode() {
4964             return types.hashCode(type);
4965         }
4966 
4967         public boolean equals(Object obj) {
4968             return (obj instanceof UniqueType) &amp;&amp;
4969                 types.isSameType(type, ((UniqueType)obj).type);
4970         }
4971 
4972         public boolean encodeTypeSig() {
4973             return encodeTypeSig;
4974         }
4975 
4976         public String toString() {
4977             return type.toString();
4978         }
4979 
4980     }
4981     // &lt;/editor-fold&gt;
4982 
4983     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4984     /**
4985      * A default visitor for types.  All visitor methods except
4986      * visitType are implemented by delegating to visitType.  Concrete
4987      * subclasses must provide an implementation of visitType and can
4988      * override other methods as needed.
4989      *
4990      * @param &lt;R&gt; the return type of the operation implemented by this
4991      * visitor; use Void if no return type is needed.
4992      * @param &lt;S&gt; the type of the second argument (the first being the
4993      * type itself) of the operation implemented by this visitor; use
4994      * Void if a second argument is not needed.
4995      */
4996     public static abstract class DefaultTypeVisitor&lt;R,S&gt; implements Type.Visitor&lt;R,S&gt; {
4997         final public R visit(Type t, S s)               { return t.accept(this, s); }
4998         public R visitClassType(ClassType t, S s)       { return visitType(t, s); }
4999         public R visitWildcardType(WildcardType t, S s) { return visitType(t, s); }
5000         public R visitArrayType(ArrayType t, S s)       { return visitType(t, s); }
5001         public R visitMethodType(MethodType t, S s)     { return visitType(t, s); }
5002         public R visitPackageType(PackageType t, S s)   { return visitType(t, s); }
5003         public R visitModuleType(ModuleType t, S s)     { return visitType(t, s); }
5004         public R visitTypeVar(TypeVar t, S s)           { return visitType(t, s); }
5005         public R visitCapturedType(CapturedType t, S s) { return visitType(t, s); }
5006         public R visitForAll(ForAll t, S s)             { return visitType(t, s); }
5007         public R visitUndetVar(UndetVar t, S s)         { return visitType(t, s); }
5008         public R visitErrorType(ErrorType t, S s)       { return visitType(t, s); }
5009     }
5010 
5011     /**
5012      * A default visitor for symbols.  All visitor methods except
5013      * visitSymbol are implemented by delegating to visitSymbol.  Concrete
5014      * subclasses must provide an implementation of visitSymbol and can
5015      * override other methods as needed.
5016      *
5017      * @param &lt;R&gt; the return type of the operation implemented by this
5018      * visitor; use Void if no return type is needed.
5019      * @param &lt;S&gt; the type of the second argument (the first being the
5020      * symbol itself) of the operation implemented by this visitor; use
5021      * Void if a second argument is not needed.
5022      */
5023     public static abstract class DefaultSymbolVisitor&lt;R,S&gt; implements Symbol.Visitor&lt;R,S&gt; {
5024         final public R visit(Symbol s, S arg)                   { return s.accept(this, arg); }
5025         public R visitClassSymbol(ClassSymbol s, S arg)         { return visitSymbol(s, arg); }
5026         public R visitMethodSymbol(MethodSymbol s, S arg)       { return visitSymbol(s, arg); }
5027         public R visitOperatorSymbol(OperatorSymbol s, S arg)   { return visitSymbol(s, arg); }
5028         public R visitPackageSymbol(PackageSymbol s, S arg)     { return visitSymbol(s, arg); }
5029         public R visitTypeSymbol(TypeSymbol s, S arg)           { return visitSymbol(s, arg); }
5030         public R visitVarSymbol(VarSymbol s, S arg)             { return visitSymbol(s, arg); }
5031     }
5032 
5033     /**
5034      * A &lt;em&gt;simple&lt;/em&gt; visitor for types.  This visitor is simple as
5035      * captured wildcards, for-all types (generic methods), and
5036      * undetermined type variables (part of inference) are hidden.
5037      * Captured wildcards are hidden by treating them as type
5038      * variables and the rest are hidden by visiting their qtypes.
5039      *
5040      * @param &lt;R&gt; the return type of the operation implemented by this
5041      * visitor; use Void if no return type is needed.
5042      * @param &lt;S&gt; the type of the second argument (the first being the
5043      * type itself) of the operation implemented by this visitor; use
5044      * Void if a second argument is not needed.
5045      */
5046     public static abstract class SimpleVisitor&lt;R,S&gt; extends DefaultTypeVisitor&lt;R,S&gt; {
5047         @Override
5048         public R visitCapturedType(CapturedType t, S s) {
5049             return visitTypeVar(t, s);
5050         }
5051         @Override
5052         public R visitForAll(ForAll t, S s) {
5053             return visit(t.qtype, s);
5054         }
5055         @Override
5056         public R visitUndetVar(UndetVar t, S s) {
5057             return visit(t.qtype, s);
5058         }
5059     }
5060 
5061     /**
5062      * A plain relation on types.  That is a 2-ary function on the
5063      * form Type&amp;nbsp;&amp;times;&amp;nbsp;Type&amp;nbsp;&amp;rarr;&amp;nbsp;Boolean.
5064      * &lt;!-- In plain text: Type x Type -&gt; Boolean --&gt;
5065      */
5066     public static abstract class TypeRelation extends SimpleVisitor&lt;Boolean,Type&gt; {}
5067 
5068     /**
5069      * A convenience visitor for implementing operations that only
5070      * require one argument (the type itself), that is, unary
5071      * operations.
5072      *
5073      * @param &lt;R&gt; the return type of the operation implemented by this
5074      * visitor; use Void if no return type is needed.
5075      */
5076     public static abstract class UnaryVisitor&lt;R&gt; extends SimpleVisitor&lt;R,Void&gt; {
5077         final public R visit(Type t) { return t.accept(this, null); }
5078     }
5079 
5080     /**
5081      * A visitor for implementing a mapping from types to types.  The
5082      * default behavior of this class is to implement the identity
5083      * mapping (mapping a type to itself).  This can be overridden in
5084      * subclasses.
5085      *
5086      * @param &lt;S&gt; the type of the second argument (the first being the
5087      * type itself) of this mapping; use Void if a second argument is
5088      * not needed.
5089      */
5090     public static class MapVisitor&lt;S&gt; extends DefaultTypeVisitor&lt;Type,S&gt; {
5091         final public Type visit(Type t) { return t.accept(this, null); }
5092         public Type visitType(Type t, S s) { return t; }
5093     }
5094 
5095     /**
5096      * An abstract class for mappings from types to types (see {@link Type#map(TypeMapping)}.
5097      * This class implements the functional interface {@code Function}, that allows it to be used
5098      * fluently in stream-like processing.
5099      */
5100     public static class TypeMapping&lt;S&gt; extends MapVisitor&lt;S&gt; implements Function&lt;Type, Type&gt; {
5101         @Override
5102         public Type apply(Type type) { return visit(type); }
5103 
5104         List&lt;Type&gt; visit(List&lt;Type&gt; ts, S s) {
5105             return ts.map(t -&gt; visit(t, s));
5106         }
5107 
5108         @Override
5109         public Type visitCapturedType(CapturedType t, S s) {
5110             return visitTypeVar(t, s);
5111         }
5112     }
5113     // &lt;/editor-fold&gt;
5114 
5115 
5116     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Annotation support&quot;&gt;
5117 
5118     public RetentionPolicy getRetention(Attribute.Compound a) {
5119         return getRetention(a.type.tsym);
5120     }
5121 
5122     public RetentionPolicy getRetention(TypeSymbol sym) {
5123         RetentionPolicy vis = RetentionPolicy.CLASS; // the default
5124         Attribute.Compound c = sym.attribute(syms.retentionType.tsym);
5125         if (c != null) {
5126             Attribute value = c.member(names.value);
5127             if (value != null &amp;&amp; value instanceof Attribute.Enum) {
5128                 Name levelName = ((Attribute.Enum)value).value.name;
5129                 if (levelName == names.SOURCE) vis = RetentionPolicy.SOURCE;
5130                 else if (levelName == names.CLASS) vis = RetentionPolicy.CLASS;
5131                 else if (levelName == names.RUNTIME) vis = RetentionPolicy.RUNTIME;
5132                 else ;// /* fail soft */ throw new AssertionError(levelName);
5133             }
5134         }
5135         return vis;
5136     }
5137     // &lt;/editor-fold&gt;
5138 
5139     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Signature Generation&quot;&gt;
5140 
5141     public static abstract class SignatureGenerator {
5142 
5143         public static class InvalidSignatureException extends RuntimeException {
5144             private static final long serialVersionUID = 0;
5145 
5146             private final transient Type type;
5147 
5148             InvalidSignatureException(Type type) {
5149                 this.type = type;
5150             }
5151 
5152             public Type type() {
5153                 return type;
5154             }
5155         }
5156 
5157         private final Types types;
5158 
5159         protected abstract void append(char ch);
5160         protected abstract void append(byte[] ba);
5161         protected abstract void append(Name name);
5162         protected void classReference(ClassSymbol c) { /* by default: no-op */ }
5163 
5164         protected SignatureGenerator(Types types) {
5165             this.types = types;
5166         }
5167 
5168         protected void reportIllegalSignature(Type t) {
5169             throw new InvalidSignatureException(t);
5170         }
5171 
5172         /**
5173          * Assemble signature of given type in string buffer.
5174          */
5175         public void assembleSig(Type type) {
5176             switch (type.getTag()) {
5177                 case BYTE:
5178                     append(&#39;B&#39;);
5179                     break;
5180                 case SHORT:
5181                     append(&#39;S&#39;);
5182                     break;
5183                 case CHAR:
5184                     append(&#39;C&#39;);
5185                     break;
5186                 case INT:
5187                     append(&#39;I&#39;);
5188                     break;
5189                 case LONG:
5190                     append(&#39;J&#39;);
5191                     break;
5192                 case FLOAT:
5193                     append(&#39;F&#39;);
5194                     break;
5195                 case DOUBLE:
5196                     append(&#39;D&#39;);
5197                     break;
5198                 case BOOLEAN:
5199                     append(&#39;Z&#39;);
5200                     break;
5201                 case VOID:
5202                     append(&#39;V&#39;);
5203                     break;
5204                 case CLASS:
5205                     if (type.isCompound()) {
5206                         reportIllegalSignature(type);
5207                     }
5208                     if (types.isValue(type))
5209                         append(&#39;Q&#39;);
5210                     else
5211                         append(&#39;L&#39;);
5212                     assembleClassSig(type);
5213                     append(&#39;;&#39;);
5214                     break;
5215                 case ARRAY:
5216                     ArrayType at = (ArrayType) type;
5217                     append(&#39;[&#39;);
5218                     assembleSig(at.elemtype);
5219                     break;
5220                 case METHOD:
5221                     MethodType mt = (MethodType) type;
5222                     append(&#39;(&#39;);
5223                     assembleSig(mt.argtypes);
5224                     append(&#39;)&#39;);
5225                     assembleSig(mt.restype);
5226                     if (hasTypeVar(mt.thrown)) {
5227                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5228                             append(&#39;^&#39;);
5229                             assembleSig(l.head);
5230                         }
5231                     }
5232                     break;
5233                 case WILDCARD: {
5234                     Type.WildcardType ta = (Type.WildcardType) type;
5235                     switch (ta.kind) {
5236                         case SUPER:
5237                             append(&#39;-&#39;);
5238                             assembleSig(ta.type);
5239                             break;
5240                         case EXTENDS:
5241                             append(&#39;+&#39;);
5242                             assembleSig(ta.type);
5243                             break;
5244                         case UNBOUND:
5245                             append(&#39;*&#39;);
5246                             break;
5247                         default:
5248                             throw new AssertionError(ta.kind);
5249                     }
5250                     break;
5251                 }
5252                 case TYPEVAR:
5253                     if (((TypeVar)type).isCaptured()) {
5254                         reportIllegalSignature(type);
5255                     }
5256                     append(&#39;T&#39;);
5257                     append(type.tsym.name);
5258                     append(&#39;;&#39;);
5259                     break;
5260                 case FORALL:
5261                     Type.ForAll ft = (Type.ForAll) type;
5262                     assembleParamsSig(ft.tvars);
5263                     assembleSig(ft.qtype);
5264                     break;
5265                 default:
5266                     throw new AssertionError(&quot;typeSig &quot; + type.getTag());
5267             }
5268         }
5269 
5270         public boolean hasTypeVar(List&lt;Type&gt; l) {
5271             while (l.nonEmpty()) {
5272                 if (l.head.hasTag(TypeTag.TYPEVAR)) {
5273                     return true;
5274                 }
5275                 l = l.tail;
5276             }
5277             return false;
5278         }
5279 
5280         public void assembleClassSig(Type type) {
5281             ClassType ct = (ClassType) type;
5282             ClassSymbol c = (ClassSymbol) ct.tsym;
5283             classReference(c);
5284             Type outer = ct.getEnclosingType();
5285             if (outer.allparams().nonEmpty()) {
5286                 boolean rawOuter =
5287                         c.owner.kind == MTH || // either a local class
5288                         c.name == types.names.empty; // or anonymous
5289                 assembleClassSig(rawOuter
5290                         ? types.erasure(outer)
5291                         : outer);
5292                 append(rawOuter ? &#39;$&#39; : &#39;.&#39;);
5293                 Assert.check(c.flatname.startsWith(c.owner.enclClass().flatname));
5294                 append(rawOuter
5295                         ? c.flatname.subName(c.owner.enclClass().flatname.getByteLength() + 1, c.flatname.getByteLength())
5296                         : c.name);
5297             } else {
5298                 append(externalize(c.flatname));
5299             }
5300             if (ct.getTypeArguments().nonEmpty()) {
5301                 append(&#39;&lt;&#39;);
5302                 assembleSig(ct.getTypeArguments());
5303                 append(&#39;&gt;&#39;);
5304             }
5305         }
5306 
5307         public void assembleParamsSig(List&lt;Type&gt; typarams) {
5308             append(&#39;&lt;&#39;);
5309             for (List&lt;Type&gt; ts = typarams; ts.nonEmpty(); ts = ts.tail) {
5310                 Type.TypeVar tvar = (Type.TypeVar) ts.head;
5311                 append(tvar.tsym.name);
5312                 List&lt;Type&gt; bounds = types.getBounds(tvar);
5313                 if ((bounds.head.tsym.flags() &amp; INTERFACE) != 0) {
5314                     append(&#39;:&#39;);
5315                 }
5316                 for (List&lt;Type&gt; l = bounds; l.nonEmpty(); l = l.tail) {
5317                     append(&#39;:&#39;);
5318                     assembleSig(l.head);
5319                 }
5320             }
5321             append(&#39;&gt;&#39;);
5322         }
5323 
5324         public void assembleSig(List&lt;Type&gt; types) {
5325             for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
5326                 assembleSig(ts.head);
5327             }
5328         }
5329     }
5330 
5331     public Type constantType(LoadableConstant c) {
5332         switch (c.poolTag()) {
5333             case ClassFile.CONSTANT_Class:
5334                 return syms.classType;
5335             case ClassFile.CONSTANT_String:
5336                 return syms.stringType;
5337             case ClassFile.CONSTANT_Integer:
5338                 return syms.intType;
5339             case ClassFile.CONSTANT_Float:
5340                 return syms.floatType;
5341             case ClassFile.CONSTANT_Long:
5342                 return syms.longType;
5343             case ClassFile.CONSTANT_Double:
5344                 return syms.doubleType;
5345             case ClassFile.CONSTANT_MethodHandle:
5346                 return syms.methodHandleType;
5347             case ClassFile.CONSTANT_MethodType:
5348                 return syms.methodTypeType;
5349             case ClassFile.CONSTANT_Dynamic:
5350                 return ((DynamicVarSymbol)c).type;
5351             default:
5352                 throw new AssertionError(&quot;Not a loadable constant: &quot; + c.poolTag());
5353         }
5354     }
5355     // &lt;/editor-fold&gt;
5356 
5357     public void newRound() {
5358         descCache._map.clear();
5359         isDerivedRawCache.clear();
5360         implCache._map.clear();
5361         membersCache._map.clear();
5362         closureCache.clear();
5363     }
5364 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
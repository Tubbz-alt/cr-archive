diff a/make/CompileJavaModules.gmk b/make/CompileJavaModules.gmk
--- a/make/CompileJavaModules.gmk
+++ b/make/CompileJavaModules.gmk
@@ -230,11 +230,11 @@
 
 java.management_ADD_JAVAC_FLAGS += -Xdoclint:all/protected,-reference,-accessibility '-Xdoclint/package:java.*,javax.*'
 
 ################################################################################
 
-java.management.rmi_ADD_JAVAC_FLAGS += -Xdoclint:all/protected '-Xdoclint/package:javax.*' -XDnoTopInterfaceInjection
+java.management.rmi_ADD_JAVAC_FLAGS += -Xdoclint:all/protected '-Xdoclint/package:javax.*'
 
 ################################################################################
 
 java.prefs_ADD_JAVAC_FLAGS += -Xdoclint:all/protected '-Xdoclint/package:java.*,javax.*'
 
@@ -253,11 +253,11 @@
     $(TOPDIR)/src/java.sql.rowset/share/classes/com/sun/rowset/*.properties \
     $(TOPDIR)/src/java.sql.rowset/share/classes/javax/sql/rowset/*.properties)
 
 ################################################################################
 
-java.rmi_ADD_JAVAC_FLAGS += -Xdoclint:all/protected '-Xdoclint/package:java.*,javax.*' -XDnoTopInterfaceInjection
+java.rmi_ADD_JAVAC_FLAGS += -Xdoclint:all/protected '-Xdoclint/package:java.*,javax.*'
 java.rmi_CLEAN_FILES += $(wildcard \
     $(TOPDIR)/src/java.rmi/share/classes/sun/rmi/registry/resources/*.properties \
     $(TOPDIR)/src/java.rmi/share/classes/sun/rmi/server/resources/*.properties)
 
 ################################################################################
@@ -276,14 +276,10 @@
 
 java.security.jgss_ADD_JAVAC_FLAGS += -Xdoclint:all/protected '-Xdoclint/package:java.*,javax.*'
 
 ################################################################################
 
-jdk.naming.rmi_ADD_JAVAC_FLAGS += -XDnoTopInterfaceInjection
-
-################################################################################
-
 java.smartcardio_ADD_JAVAC_FLAGS += -Xdoclint:all/protected,-accessibility '-Xdoclint/package:java.*,javax.*'
 
 ################################################################################
 
 java.xml.crypto_ADD_JAVAC_FLAGS += -Xdoclint:all/protected '-Xdoclint/package:java.*,javax.*'
diff a/src/java.base/share/classes/java/lang/InlineObject.java b/src/java.base/share/classes/java/lang/InlineObject.java
--- a/src/java.base/share/classes/java/lang/InlineObject.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.lang;
-
-/**
- * A restricted interface implemented by all inline objects.
- * @since 1.14
- */
-public interface InlineObject {
-}
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java
@@ -221,15 +221,12 @@
     public final Type functionalInterfaceType;
     public final Type previewFeatureType;
     public final Type typeDescriptorType;
     public final Type recordType;
     public final Type valueBasedType;
-    public final Type inlineObjectType;
     public final Type identityObjectType;
 
-    public final boolean injectTopInterfaceTypes;
-
     /** The symbol representing the length field of an array.
      */
     public final VarSymbol lengthVar;
 
     /** The symbol representing the final finalize method on enums */
@@ -272,12 +269,12 @@
                 if (type.getTag() == ARRAY || type.getTag() == CLASS) {
                     /* Temporary treatment for inline class: Given an inline class V that implements
                        I1, I2, ... In, V.class is typed to be Class<? extends Object & I1 & I2 .. & In>
                     */
                     if (type.isValue()) {
-                        Type it = types.makeIntersectionType(((ClassType)type).interfaces_field, true);
-                        arg = new WildcardType(it, BoundKind.EXTENDS, boundClass);
+                        List<Type> bounds = List.of(objectType).appendList(((ClassSymbol) type.tsym).getInterfaces());
+                        arg = new WildcardType(types.makeIntersectionType(bounds), BoundKind.EXTENDS, boundClass);
                     } else {
                         arg = types.erasure(type);
                     }
                 }
                 else if (type.isPrimitiveOrVoid())
@@ -597,19 +594,17 @@
         previewFeatureType = enterClass("jdk.internal.PreviewFeature");
         typeDescriptorType = enterClass("java.lang.invoke.TypeDescriptor");
         recordType = enterClass("java.lang.Record");
         valueBasedType = enterClass("java.lang.ValueBased");
         identityObjectType = enterClass("java.lang.IdentityObject");
-        inlineObjectType = enterClass("java.lang.InlineObject");
 
         synthesizeEmptyInterfaceIfMissing(autoCloseableType);
         synthesizeEmptyInterfaceIfMissing(cloneableType);
         synthesizeEmptyInterfaceIfMissing(serializableType);
         synthesizeEmptyInterfaceIfMissing(lambdaMetafactory);
         synthesizeEmptyInterfaceIfMissing(serializedLambdaType);
         synthesizeEmptyInterfaceIfMissing(stringConcatFactory);
-        synthesizeEmptyInterfaceIfMissing(inlineObjectType);
         synthesizeEmptyInterfaceIfMissing(identityObjectType);
         synthesizeBoxTypeIfMissing(doubleType);
         synthesizeBoxTypeIfMissing(floatType);
         synthesizeBoxTypeIfMissing(voidType);
 
@@ -622,22 +617,17 @@
         // classes in ct.sym.  This class does not have a class file.
         profileType = enterSyntheticAnnotation("jdk.Profile+Annotation");
         MethodSymbol m = new MethodSymbol(PUBLIC | ABSTRACT, names.value, intType, profileType.tsym);
         profileType.tsym.members().enter(m);
 
-        injectTopInterfaceTypes = Options.instance(context).isUnset("noTopInterfaceInjection") &&
-                Feature.INLINE_TYPES.allowedInSource(source) &&
-                Target.instance(context).hasTopInterfaces();
-
         // Enter a class for arrays.
         // The class implements java.lang.Cloneable and java.io.Serializable.
         // It has a final length field and a clone method.
         ClassType arrayClassType = (ClassType)arrayClass.type;
         arrayClassType.supertype_field = objectType;
-        arrayClassType.interfaces_field = injectTopInterfaceTypes ?
-                List.of(cloneableType, serializableType, identityObjectType):
-                List.of(cloneableType, serializableType);
+        arrayClassType.interfaces_field =
+                List.of(cloneableType, serializableType, identityObjectType);
 
         arrayClass.members_field = WriteableScope.create(arrayClass);
         lengthVar = new VarSymbol(
             PUBLIC | FINAL,
             names.length,
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
@@ -93,11 +93,10 @@
     final JavacMessages messages;
     final Names names;
     final boolean allowDefaultMethods;
     final boolean mapCapturesToBounds;
     final boolean allowValueBasedClasses;
-    final boolean injectTopInterfaceTypes;
     final Check chk;
     final Enter enter;
     JCDiagnostic.Factory diags;
     List<Warner> warnStack = List.nil();
     final Name capturedName;
@@ -125,13 +124,10 @@
         messages = JavacMessages.instance(context);
         diags = JCDiagnostic.Factory.instance(context);
         noWarnings = new Warner(null);
         Options options = Options.instance(context);
         allowValueBasedClasses = options.isSet("allowValueBasedClasses");
-        injectTopInterfaceTypes = Options.instance(context).isUnset("noTopInterfaceInjection") &&
-                Feature.INLINE_TYPES.allowedInSource(source) &&
-                Target.instance(context).hasTopInterfaces();
     }
     // </editor-fold>
 
     // <editor-fold defaultstate="collapsed" desc="bounds">
     /**
@@ -1243,11 +1239,11 @@
                 if (s.hasTag(CLASS)) {
                     Name sname = s.tsym.getQualifiedName();
                     return sname == names.java_lang_Object
                         || sname == names.java_lang_Cloneable
                         || sname == names.java_io_Serializable
-                        || (injectTopInterfaceTypes && sname == names.java_lang_IdentityObject);
+                        || sname == names.java_lang_IdentityObject;
                 }
 
                 return false;
             }
 
@@ -2200,10 +2196,20 @@
 
         if (sym.type == syms.objectType) { //optimization
             if (!isValue(t))
                 return syms.objectType;
         }
+        if (sym.type == syms.identityObjectType) {
+            // IdentityObject is super interface of every concrete identity class other than jlO
+            if (t.isValue() || t.tsym == syms.objectType.tsym)
+                return null;
+            if (t.hasTag(ARRAY))
+                return syms.identityObjectType;
+            if (t.hasTag(CLASS) && !t.isReferenceProjection() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {
+                return syms.identityObjectType;
+            } // else fall through and look for explicit coded super interface
+        }
         return asSuper.visit(t, sym);
     }
     // where
         private SimpleVisitor<Type,Symbol> asSuper = new SimpleVisitor<Type,Symbol>() {
 
@@ -4159,13 +4165,12 @@
             // initialized lazily to avoid problems during compiler startup
             if (arraySuperType == null) {
                 synchronized (this) {
                     if (arraySuperType == null) {
                         // JLS 10.8: all arrays implement Cloneable and Serializable.
-                        List<Type> ifaces = injectTopInterfaceTypes ?
-                                List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType):
-                                List.of(syms.serializableType, syms.cloneableType);
+                        List<Type> ifaces =
+                                List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType);
                         arraySuperType = makeIntersectionType(ifaces, true);
                     }
                 }
             }
             return arraySuperType;
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
@@ -2518,13 +2518,17 @@
                     methodName == names.getClass &&
                     argtypes.isEmpty()) {
                 // as a special case, x.getClass() has type Class<? extends |X|>
                 // Temporary treatment for inline class: Given an inline class V that implements
                 // I1, I2, ... In, v.getClass() is typed to be Class<? extends Object & I1 & I2 .. & In>
-                Type wcb = qualifierType.isValue()
-                              ? types.makeIntersectionType(((ClassType) qualifierType).interfaces_field, true)
-                              : types.erasure(qualifierType);
+                Type wcb;
+                if (qualifierType.isValue()) {
+                    List<Type> bounds = List.of(syms.objectType).appendList(((ClassSymbol) qualifierType.tsym).getInterfaces());
+                    wcb = types.makeIntersectionType(bounds);
+                } else {
+                    wcb = types.erasure(qualifierType);
+                }
                 return new ClassType(restype.getEnclosingType(),
                         List.of(new WildcardType(wcb,
                                 BoundKind.EXTENDS,
                                 syms.boundClass)),
                         restype.tsym,
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
@@ -2673,18 +2673,12 @@
                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
                     return;
         }
         checkCompatibleConcretes(pos, c);
 
-        boolean isIdentityObject = types.asSuper(c, syms.identityObjectType.tsym, true) != null;
-        boolean isInlineObject = types.asSuper(c, syms.inlineObjectType.tsym, true) != null;
-        if (c.isValue() && isIdentityObject) {
+        if (c.isValue() && types.asSuper(c, syms.identityObjectType.tsym, true) != null) {
             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));
-        } else if (!c.isInterface() && !c.tsym.isAbstract() && !c.isValue() && isInlineObject) {
-            log.error(pos, Errors.IdentityTypeMustNotImplementInlineObject(c));
-        } else if (isIdentityObject && isInlineObject) {
-            log.error(pos, Errors.MutuallyIncompatibleInterfaces(c));
         }
     }
 
     /** Check that all non-override equivalent methods accessible from 'site'
      *  are mutually compatible (JLS 8.4.8/9.4.1).
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
@@ -142,13 +142,10 @@
         typeEnvs = TypeEnvs.instance(context);
         dependencies = Dependencies.instance(context);
         Source source = Source.instance(context);
         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);
-        injectTopInterfaceTypes = Options.instance(context).isUnset("noTopInterfaceInjection") &&
-                                        Feature.INLINE_TYPES.allowedInSource(source) &&
-                                            Target.instance(context).hasTopInterfaces();
     }
 
     /** Switch: support type annotations.
      */
     boolean allowTypeAnnos;
@@ -156,14 +153,10 @@
     /**
      * Switch: should deprecation warnings be issued on import
      */
     boolean allowDeprecationOnImport;
 
-    /** Switch: inject top interface types.
-     */
-    boolean injectTopInterfaceTypes;
-
     /** A flag to disable completion from time to time during member
      *  enter, as we only need to look up types.  This avoids
      *  unnecessarily deep recursion.
      */
     boolean completionEnabled = true;
@@ -702,31 +695,17 @@
                 ? Type.noType
                 : sym.isRecord() ? syms.recordType : syms.objectType;
             }
             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 
-            Type interfaceToInject = Type.noType;
-            if (injectTopInterfaceTypes) {
-                if (isValueType || types.isValue(supertype)) {
-                    interfaceToInject = syms.inlineObjectType;
-                } else if ((sym.flags_field & (INTERFACE | ABSTRACT)) == 0) { // skip interfaces, abstract classes and annotations.
-                    if (sym.fullname != names.java_lang_Object) {
-                        interfaceToInject = syms.identityObjectType;
-                    }
-                }
-            }
-
             // Determine interfaces.
             ListBuffer<Type> interfaces = new ListBuffer<>();
             ListBuffer<Type> all_interfaces = null; // lazy init
             List<JCExpression> interfaceTrees = tree.implementing;
             for (JCExpression iface : interfaceTrees) {
                 iface = clearTypeParams(iface);
                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
-                if (it.tsym == interfaceToInject.tsym) {
-                    interfaceToInject = Type.noType;
-                }
                 if (it.hasTag(CLASS)) {
                     interfaces.append(it);
                     if (all_interfaces != null) all_interfaces.append(it);
                 } else {
                     if (all_interfaces == null)
@@ -737,13 +716,10 @@
 
             if ((sym.flags_field & ANNOTATION) != 0) {
                 ct.interfaces_field = List.of(syms.annotationType);
                 ct.all_interfaces_field = ct.interfaces_field;
             }  else {
-                if (interfaceToInject != Type.noType) {
-                    interfaces.append(interfaceToInject);
-                }
                 ct.interfaces_field = interfaces.toList();
                 ct.all_interfaces_field = (all_interfaces == null)
                         ? ct.interfaces_field : all_interfaces.toList();
             }
             if (ct.isValue()) {
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java
@@ -1533,11 +1533,11 @@
         Assert.check((c.flags() & COMPOUND) == 0);
         databuf.reset();
         poolbuf.reset();
 
         Type supertype = c.isValue() ? c.type.referenceProjection() : types.supertype(c.type);
-        List<Type> interfaces = c.isValue() ? List.of(syms.inlineObjectType) : types.interfaces(c.type);
+        List<Type> interfaces = c.isValue() ? List.nil() : types.interfaces(c.type);
         List<Type> typarams = c.type.getTypeArguments();
 
         int flags;
         if (c.owner.kind == MDL) {
             flags = ACC_MODULE;
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java
@@ -172,13 +172,6 @@
     /** Does the target VM support virtual private invocations?
      */
     public boolean hasVirtualPrivateInvoke() {
         return compareTo(JDK1_11) >= 0;
     }
-
-    /** Does the target VM support new top interfaces?
-     */
-    public boolean hasTopInterfaces() {
-        return compareTo(JDK1_14) >= 0;
-    }
-
 }
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties b/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties
@@ -3705,18 +3705,10 @@
 
 # 0: type
 compiler.err.inline.type.must.not.implement.identity.object=\
     The inline type {0} attempts to implement the incompatible interface IdentityObject
 
-# 0: type
-compiler.err.identity.type.must.not.implement.inline.object=\
-    The identity type {0} attempts to implement the incompatible interface InlineObject
-
-# 0: type
-compiler.err.mutually.incompatible.interfaces=\
-    The interfaces IdentityObject and InlineObject are mutually exclusive. The type {0} cannot implement both 
-
 # 0: symbol, 1: type
 compiler.err.concrete.supertype.for.inline.class=\
     The concrete class {1} is not allowed to be a super class of the inline class {0} either directly or indirectly
 
 # 0: symbol, 1: symbol, 2: type
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java
@@ -116,11 +116,10 @@
     public final Name java_lang_Object;
     public final Name java_lang_System;
     public final Name __inline__;
     public final Name java_lang___inline__;
     public final Name java_lang_IdentityObject;
-    public final Name java_lang_InlineObject;
 
     // names of builtin classes
     public final Name Array;
     public final Name Bound;
     public final Name Method;
@@ -297,11 +296,10 @@
         java_lang_Object = fromString("java.lang.Object");
         java_lang_System = fromString("java.lang.System");
         __inline__ = fromString("__inline__");
         java_lang___inline__ = fromString("java.lang.__inline__");
         java_lang_IdentityObject = fromString("java.lang.IdentityObject");
-        java_lang_InlineObject = fromString("java.lang.InlineObject");
 
         // names of builtin classes
         Array = fromString("Array");
         Bound = fromString("Bound");
         Method = fromString("Method");
diff a/test/hotspot/jtreg/serviceability/jvmti/RedefineClasses/RedefineCondy.jasm b/test/hotspot/jtreg/serviceability/jvmti/RedefineClasses/RedefineCondy.jasm
--- a/test/hotspot/jtreg/serviceability/jvmti/RedefineClasses/RedefineCondy.jasm
+++ b/test/hotspot/jtreg/serviceability/jvmti/RedefineClasses/RedefineCondy.jasm
@@ -19,11 +19,11 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-super public class RedefineCondy implements java/lang/IdentityObject version 55:0 {
+super public class RedefineCondy version 55:0 {
 
     public Method "<init>":"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/Class;)V"
     stack 3 locals 4 {
         aload_0;
         invokespecial   Method java/lang/Object."<init>":"()V";
diff a/test/langtools/jdk/javadoc/doclet/testClassTree/TestClassTree.java b/test/langtools/jdk/javadoc/doclet/testClassTree/TestClassTree.java
--- a/test/langtools/jdk/javadoc/doclet/testClassTree/TestClassTree.java
+++ b/test/langtools/jdk/javadoc/doclet/testClassTree/TestClassTree.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug      4632553 4973607 8026567
  * @summary  No need to include type name (class, interface, etc.) before
  *           every single type in class tree.
  *           Make sure class tree includes heirarchy for enums and annotation
diff a/test/langtools/jdk/javadoc/doclet/testDeprecatedDocs/TestDeprecatedDocs.java b/test/langtools/jdk/javadoc/doclet/testDeprecatedDocs/TestDeprecatedDocs.java
--- a/test/langtools/jdk/javadoc/doclet/testDeprecatedDocs/TestDeprecatedDocs.java
+++ b/test/langtools/jdk/javadoc/doclet/testDeprecatedDocs/TestDeprecatedDocs.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug      4927552 8026567 8071982 8162674 8175200 8175218 8183511 8186332
  *           8169819 8074407 8191030 8182765 8184205
  * @summary  test generated docs for deprecated items
  * @library  ../../lib
diff a/test/langtools/jdk/javadoc/doclet/testHiddenTag/TestHiddenTag.java b/test/langtools/jdk/javadoc/doclet/testHiddenTag/TestHiddenTag.java
--- a/test/langtools/jdk/javadoc/doclet/testHiddenTag/TestHiddenTag.java
+++ b/test/langtools/jdk/javadoc/doclet/testHiddenTag/TestHiddenTag.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8073100 8182765 8196202
  * @summary ensure the hidden tag works as intended
  * @library ../../lib
  * @modules jdk.javadoc/jdk.javadoc.internal.tool
diff a/test/langtools/jdk/javadoc/doclet/testHtmlDefinitionListTag/TestHtmlDefinitionListTag.java b/test/langtools/jdk/javadoc/doclet/testHtmlDefinitionListTag/TestHtmlDefinitionListTag.java
--- a/test/langtools/jdk/javadoc/doclet/testHtmlDefinitionListTag/TestHtmlDefinitionListTag.java
+++ b/test/langtools/jdk/javadoc/doclet/testHtmlDefinitionListTag/TestHtmlDefinitionListTag.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 6786690 6820360 8025633 8026567 8175200 8183511 8186332 8074407 8182765
  *      8230136
  * @summary This test verifies the nesting of definition list tags.
  * @library ../../lib
diff a/test/langtools/jdk/javadoc/doclet/testHtmlTag/TestHtmlTag.java b/test/langtools/jdk/javadoc/doclet/testHtmlTag/TestHtmlTag.java
--- a/test/langtools/jdk/javadoc/doclet/testHtmlTag/TestHtmlTag.java
+++ b/test/langtools/jdk/javadoc/doclet/testHtmlTag/TestHtmlTag.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 6786682 4649116 8182765
  * @summary This test verifies the use of lang attribute by <HTML>.
  * @library ../../lib
  * @modules jdk.javadoc/jdk.javadoc.internal.tool
diff a/test/langtools/jdk/javadoc/doclet/testInterface/TestInterface.java b/test/langtools/jdk/javadoc/doclet/testInterface/TestInterface.java
--- a/test/langtools/jdk/javadoc/doclet/testInterface/TestInterface.java
+++ b/test/langtools/jdk/javadoc/doclet/testInterface/TestInterface.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug      4682448 4947464 5029946 8025633 8026567 8035473 8139101 8175200
              8186332 8186703 8182765 8187288
  * @summary  Verify that the public modifier does not show up in the
  *           documentation for public methods, as recommended by the JLS.
diff a/test/langtools/jdk/javadoc/doclet/testLinkOption/TestLinkOption.java b/test/langtools/jdk/javadoc/doclet/testLinkOption/TestLinkOption.java
--- a/test/langtools/jdk/javadoc/doclet/testLinkOption/TestLinkOption.java
+++ b/test/langtools/jdk/javadoc/doclet/testLinkOption/TestLinkOption.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 4720957 5020118 8026567 8038976 8184969 8164407 8182765 8205593
  * @summary Test to make sure that -link and -linkoffline link to
  * right files, and URLs with and without trailing slash are accepted.
  * @library ../../lib
diff a/test/langtools/jdk/javadoc/doclet/testMemberInheritance/TestMemberInheritance.java b/test/langtools/jdk/javadoc/doclet/testMemberInheritance/TestMemberInheritance.java
--- a/test/langtools/jdk/javadoc/doclet/testMemberInheritance/TestMemberInheritance.java
+++ b/test/langtools/jdk/javadoc/doclet/testMemberInheritance/TestMemberInheritance.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 4638588 4635809 6256068 6270645 8025633 8026567 8162363 8175200
  *      8192850 8182765 8220217 8224052 8237383
  * @summary Test to make sure that members are inherited properly in the Javadoc.
  *          Verify that inheritance labels are correct.
@@ -107,12 +106,11 @@
 
         checkOutput("pkg2/DocumentedNonGenericChild.html", true,
                 "<section class=\"description\">\n<hr>\n"
                 + "<pre>public abstract class <span class=\"type-name-label\">"
                 + "DocumentedNonGenericChild</span>\n"
-                + "extends java.lang.Object\n"
-                + "implements java.lang.IdentityObject</pre>\n"
+                + "extends java.lang.Object</pre>\n"
                 + "</section>");
 
         checkOutput("pkg2/DocumentedNonGenericChild.html", true,
                 "<td class=\"col-first\"><code>protected abstract java.lang.String</code></td>\n"
                 + "<th class=\"col-second\" scope=\"row\"><code><span class=\"member-name-link\">"
diff a/test/langtools/jdk/javadoc/doclet/testModules/TestModules.java b/test/langtools/jdk/javadoc/doclet/testModules/TestModules.java
--- a/test/langtools/jdk/javadoc/doclet/testModules/TestModules.java
+++ b/test/langtools/jdk/javadoc/doclet/testModules/TestModules.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8154119 8154262 8156077 8157987 8154261 8154817 8135291 8155995 8162363
  *      8168766 8168688 8162674 8160196 8175799 8174974 8176778 8177562 8175218
  *      8175823 8166306 8178043 8181622 8183511 8169819 8074407 8183037 8191464
  *      8164407 8192007 8182765 8196200 8196201 8196202 8196202 8205593 8202462
diff a/test/langtools/jdk/javadoc/doclet/testNewLanguageFeatures/TestNewLanguageFeatures.java b/test/langtools/jdk/javadoc/doclet/testNewLanguageFeatures/TestNewLanguageFeatures.java
--- a/test/langtools/jdk/javadoc/doclet/testNewLanguageFeatures/TestNewLanguageFeatures.java
+++ b/test/langtools/jdk/javadoc/doclet/testNewLanguageFeatures/TestNewLanguageFeatures.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug      4789689 4905985 4927164 4827184 4993906 5004549 7025314 7010344 8025633 8026567 8162363
  *           8175200 8186332 8182765 8196202 8187288 8173730 8215307
  * @summary  Run Javadoc on a set of source files that demonstrate new
  *           language features.  Check the output to ensure that the new
diff a/test/langtools/jdk/javadoc/doclet/testOptions/TestOptions.java b/test/langtools/jdk/javadoc/doclet/testOptions/TestOptions.java
--- a/test/langtools/jdk/javadoc/doclet/testOptions/TestOptions.java
+++ b/test/langtools/jdk/javadoc/doclet/testOptions/TestOptions.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug      4749567 8071982 8175200 8186332 8185371 8182765 8217034
  * @summary  Test the output for -header, -footer, -nooverview, -nodeprecatedlist, -nonavbar, -notree,
  *           -stylesheetfile, --main-stylesheet, --add-stylesheet options.
  * @library  ../../lib
diff a/test/langtools/jdk/javadoc/doclet/testPrivateClasses/TestPrivateClasses.java b/test/langtools/jdk/javadoc/doclet/testPrivateClasses/TestPrivateClasses.java
--- a/test/langtools/jdk/javadoc/doclet/testPrivateClasses/TestPrivateClasses.java
+++ b/test/langtools/jdk/javadoc/doclet/testPrivateClasses/TestPrivateClasses.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug      4780441 4874845 4978816 8014017 8016328 8025633 8026567 8175200 8182765
  * @summary  Make sure that when the -private flag is not used, members
  *           inherited from package private class are documented in the child.
  *
diff a/test/langtools/jdk/javadoc/doclet/testRecordTypes/TestRecordTypes.java b/test/langtools/jdk/javadoc/doclet/testRecordTypes/TestRecordTypes.java
--- a/test/langtools/jdk/javadoc/doclet/testRecordTypes/TestRecordTypes.java
+++ b/test/langtools/jdk/javadoc/doclet/testRecordTypes/TestRecordTypes.java
@@ -428,12 +428,11 @@
 
         checkOutput("p/R.html", true,
                 "<pre>public record <span class=\"type-name-label\">R</span>("
                         + rcAnno
                         + "int&nbsp;i)\n" +
-                        "extends java.lang.Record\n" +
-                        "implements java.lang.IdentityObject</pre>",
+                        "extends java.lang.Record</pre>",
                 "<div class=\"member-signature\">"
                         + fAnno
                         + "<span class=\"modifiers\">private final</span>&nbsp;<span class=\"return-type\">int</span>"
                         + "&nbsp;<span class=\"member-name\">i</span></div>",
                 "<div class=\"member-signature\"><span class=\"modifiers\">public</span>&nbsp;<span class=\"member-name\">R</span>"
diff a/test/langtools/jdk/javadoc/doclet/testTypeAnnotations/TestTypeAnnotations.java b/test/langtools/jdk/javadoc/doclet/testTypeAnnotations/TestTypeAnnotations.java
--- a/test/langtools/jdk/javadoc/doclet/testTypeAnnotations/TestTypeAnnotations.java
+++ b/test/langtools/jdk/javadoc/doclet/testTypeAnnotations/TestTypeAnnotations.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug      8005091 8009686 8025633 8026567 6469562 8071982 8071984 8162363 8175200 8186332 8182765
  *           8187288
  * @summary  Make sure that type annotations are displayed correctly
  * @library  ../../lib
diff a/test/langtools/jdk/javadoc/doclet/testUserTaglet/TestUserTaglet.java b/test/langtools/jdk/javadoc/doclet/testUserTaglet/TestUserTaglet.java
--- a/test/langtools/jdk/javadoc/doclet/testUserTaglet/TestUserTaglet.java
+++ b/test/langtools/jdk/javadoc/doclet/testUserTaglet/TestUserTaglet.java
@@ -51,10 +51,10 @@
 
         // The following checks verify that information was successfully
         // derived from the context information available to the taglet.
         checkOutput("pkg/C.html", true,
             "<li>Element: CLASS C",
-            "<li>Element supertypes: [java.lang.Object, java.lang.IdentityObject]",
+            "<li>Element supertypes: [java.lang.Object]",
             "<li>Doclet: class jdk.javadoc.doclet.StandardDoclet"
         );
     }
 }
diff a/test/langtools/jdk/jshell/InaccessibleExpressionTest.java b/test/langtools/jdk/jshell/InaccessibleExpressionTest.java
--- a/test/langtools/jdk/jshell/InaccessibleExpressionTest.java
+++ b/test/langtools/jdk/jshell/InaccessibleExpressionTest.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test 8190939 8191842
  * @summary test expressions whose type is inaccessible
  * @modules jdk.compiler/com.sun.tools.javac.api
  *          jdk.compiler/com.sun.tools.javac.main
  *          jdk.jdeps/com.sun.tools.javap
diff a/test/langtools/jdk/jshell/ToolBasicTest.java b/test/langtools/jdk/jshell/ToolBasicTest.java
--- a/test/langtools/jdk/jshell/ToolBasicTest.java
+++ b/test/langtools/jdk/jshell/ToolBasicTest.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8143037 8142447 8144095 8140265 8144906 8146138 8147887 8147886 8148316 8148317 8143955 8157953 8080347 8154714 8166649 8167643 8170162 8172102 8165405 8174796 8174797 8175304 8167554 8180508 8166232 8196133 8199912 8211694 8223688
  * @summary Tests for Basic tests for REPL tool
  * @modules jdk.compiler/com.sun.tools.javac.api
  *          jdk.compiler/com.sun.tools.javac.main
diff a/test/langtools/jdk/jshell/ToolLocalSimpleTest.java b/test/langtools/jdk/jshell/ToolLocalSimpleTest.java
--- a/test/langtools/jdk/jshell/ToolLocalSimpleTest.java
+++ b/test/langtools/jdk/jshell/ToolLocalSimpleTest.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8168615 8172102
  * @summary Test all the ToolSimpleTest tests, but in local execution. Verify --execution flag
  * @modules jdk.compiler/com.sun.tools.javac.api
  *          jdk.compiler/com.sun.tools.javac.main
diff a/test/langtools/jdk/jshell/ToolSimpleTest.java b/test/langtools/jdk/jshell/ToolSimpleTest.java
--- a/test/langtools/jdk/jshell/ToolSimpleTest.java
+++ b/test/langtools/jdk/jshell/ToolSimpleTest.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8153716 8143955 8151754 8150382 8153920 8156910 8131024 8160089 8153897 8167128 8154513 8170015 8170368 8172102 8172103  8165405 8173073 8173848 8174041 8173916 8174028 8174262 8174797 8177079 8180508 8177466 8172154 8192979 8191842 8198573 8198801 8210596 8210959 8215099 8199623 8236715 8239536
  * @summary Simple jshell tool tests
  * @modules jdk.compiler/com.sun.tools.javac.api
  *          jdk.compiler/com.sun.tools.javac.main
diff a/test/langtools/jdk/jshell/TypeNameTest.java b/test/langtools/jdk/jshell/TypeNameTest.java
--- a/test/langtools/jdk/jshell/TypeNameTest.java
+++ b/test/langtools/jdk/jshell/TypeNameTest.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8144903 8171981 8191802 8191842
  * @summary Tests for determining the type from the expression
  * @build KullaTesting TestingInputStream
  * @run testng TypeNameTest
diff a/test/langtools/jdk/jshell/VariablesTest.java b/test/langtools/jdk/jshell/VariablesTest.java
--- a/test/langtools/jdk/jshell/VariablesTest.java
+++ b/test/langtools/jdk/jshell/VariablesTest.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8144903 8177466 8191842 8211694 8213725 8239536
  * @summary Tests for EvaluationState.variables
  * @library /tools/lib
  * @modules jdk.compiler/com.sun.tools.javac.api
diff a/test/langtools/tools/javac/T8187978/FilterOutCandidatesForDiagnosticsTest.out b/test/langtools/tools/javac/T8187978/FilterOutCandidatesForDiagnosticsTest.out
--- a/test/langtools/tools/javac/T8187978/FilterOutCandidatesForDiagnosticsTest.out
+++ b/test/langtools/tools/javac/T8187978/FilterOutCandidatesForDiagnosticsTest.out
@@ -1,2 +1,2 @@
-FilterOutCandidatesForDiagnosticsTest.java:12:64: compiler.err.cant.apply.symbols: kindname.method, add, java.lang.String,{(compiler.misc.inapplicable.method: kindname.method, java.util.ArrayList, add(compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc,java.lang.Object[],int), (compiler.misc.arg.length.mismatch)),(compiler.misc.inapplicable.method: kindname.method, java.util.ArrayList, add(compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: java.lang.String, compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc))),(compiler.misc.inapplicable.method: kindname.method, java.util.ArrayList, add(int,compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc), (compiler.misc.arg.length.mismatch))}
+FilterOutCandidatesForDiagnosticsTest.java:12:64: compiler.err.cant.apply.symbols: kindname.method, add, java.lang.String,{(compiler.misc.inapplicable.method: kindname.method, java.util.ArrayList, add(compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc,java.lang.Object[],int), (compiler.misc.arg.length.mismatch)),(compiler.misc.inapplicable.method: kindname.method, java.util.ArrayList, add(compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: java.lang.String, compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc))),(compiler.misc.inapplicable.method: kindname.method, java.util.ArrayList, add(int,compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc), (compiler.misc.arg.length.mismatch))}
 1 error
diff a/test/langtools/tools/javac/annotations/typeAnnotations/classfile/AnnotatedExtendsTest.java b/test/langtools/tools/javac/annotations/typeAnnotations/classfile/AnnotatedExtendsTest.java
--- a/test/langtools/tools/javac/annotations/typeAnnotations/classfile/AnnotatedExtendsTest.java
+++ b/test/langtools/tools/javac/annotations/typeAnnotations/classfile/AnnotatedExtendsTest.java
@@ -57,10 +57,9 @@
         String javapOut = new JavapTask(tb)
                 .options("-v", "-p")
                 .classes(classPath.toString())
                 .run()
                 .getOutput(Task.OutputKind.DIRECT);
-        if (!javapOut.contains("0: #24(): CLASS_EXTENDS, type_index=65535") ||
-            !javapOut.contains("#24 = Utf8               LAnnotatedExtendsTest$TA;"))
+        if (!javapOut.contains("0: #22(): CLASS_EXTENDS, type_index=65535"))
             throw new AssertionError("Expected output missing: " + javapOut);
     }
 }
diff a/test/langtools/tools/javac/annotations/typeAnnotations/classfile/BridgeShouldHaveNoInteriorAnnotationsTest.java b/test/langtools/tools/javac/annotations/typeAnnotations/classfile/BridgeShouldHaveNoInteriorAnnotationsTest.java
--- a/test/langtools/tools/javac/annotations/typeAnnotations/classfile/BridgeShouldHaveNoInteriorAnnotationsTest.java
+++ b/test/langtools/tools/javac/annotations/typeAnnotations/classfile/BridgeShouldHaveNoInteriorAnnotationsTest.java
@@ -72,19 +72,18 @@
 
 
     // Expected output can't be directly encoded into NestedLambdasCastedTest !!!
     static class OutputExpectedOnceHolder {
         public String[] outputs = {
-            "0: #123(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]",
-            "1: #123(): LOCAL_VARIABLE, {start_pc=5, length=2, index=1}, location=[TYPE_ARGUMENT(0)]",
-            "#123 = Utf8               LBridgeShouldHaveNoInteriorAnnotationsTest$NonNull;",
+            "0: #120(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]",
+            "1: #120(): LOCAL_VARIABLE, {start_pc=5, length=2, index=1}, location=[TYPE_ARGUMENT(0)]",
         };
     }
 
     static class OutputExpectedTwiceHolder {
         public String[] outputs = {
-            "0: #123(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]",
+            "0: #120(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]",
         };
     }
 
     public static strictfp void main(String args[]) throws Exception {
         ToolBox tb = new ToolBox();
@@ -97,15 +96,15 @@
 
         OutputExpectedOnceHolder holder = new OutputExpectedOnceHolder();
         for (String s : holder.outputs) {
             String newOutput = javapOut.replace(s, "");
             if (((javapOut.length() - newOutput.length()) / s.length()) != 1)
-                throw new AssertionError("Interior annotations carried over to bridge ?" + javapOut);
+                throw new AssertionError("Interior annotations carried over to bridge ?");
         }
         OutputExpectedTwiceHolder holder2 = new OutputExpectedTwiceHolder();
         for (String s : holder2.outputs) {
             String newOutput = javapOut.replace(s, "");
             if (((javapOut.length() - newOutput.length()) / s.length()) != 2)
-                throw new AssertionError("Exterior annotations not properly carried over to bridge" + javapOut);
+                throw new AssertionError("Exterior annotations not properly carried over to bridge");
         }
     }
 }
diff a/test/langtools/tools/javac/annotations/typeAnnotations/classfile/NestedLambdasCastedTest.java b/test/langtools/tools/javac/annotations/typeAnnotations/classfile/NestedLambdasCastedTest.java
--- a/test/langtools/tools/javac/annotations/typeAnnotations/classfile/NestedLambdasCastedTest.java
+++ b/test/langtools/tools/javac/annotations/typeAnnotations/classfile/NestedLambdasCastedTest.java
@@ -51,18 +51,14 @@
                       "public static strictfp void main(java.lang.String[])",
                       "private static strictfp void lambda$main$3();",
                       "private static strictfp void lambda$main$2();",
                       "private static strictfp void lambda$main$1();",
                       "private static strictfp void lambda$main$0();",
-                      "0: #115(#116=s#117): CAST, offset=5, type_index=0",
-                      "0: #115(#116=s#123): CAST, offset=5, type_index=0",
-                      "0: #115(#116=s#126): CAST, offset=5, type_index=0",
-                      "0: #115(#116=s#129): CAST, offset=5, type_index=0",
-                      "#117 = Utf8               1",
-                      "#123 = Utf8               2",
-                      "#126 = Utf8               3",
-                      "#129 = Utf8               4"
+                      "0: #111(#112=s#113): CAST, offset=5, type_index=0",
+                      "0: #111(#112=s#119): CAST, offset=5, type_index=0",
+                      "0: #111(#112=s#122): CAST, offset=5, type_index=0",
+                      "0: #111(#112=s#125): CAST, offset=5, type_index=0"
         };
     }
 
     @Target(ElementType.TYPE_USE)
     public @interface TA {
@@ -86,9 +82,9 @@
                 .run()
                 .getOutput(Task.OutputKind.DIRECT);
         ExpectedOutputHolder holder = new ExpectedOutputHolder();
         for (String s : holder.outputs) {
             if (!javapOut.contains(s))
-                throw new AssertionError("Expected type annotation on LOCAL_VARIABLE missing" + javapOut);
+                throw new AssertionError("Expected type annotation on LOCAL_VARIABLE missing");
         }
     }
 }
diff a/test/langtools/tools/javac/classfiles/attributes/Signature/ConstructorTest.java b/test/langtools/tools/javac/classfiles/attributes/Signature/ConstructorTest.java
--- a/test/langtools/tools/javac/classfiles/attributes/Signature/ConstructorTest.java
+++ b/test/langtools/tools/javac/classfiles/attributes/Signature/ConstructorTest.java
@@ -35,11 +35,11 @@
  */
 
 import java.lang.ref.ReferenceQueue;
 import java.util.*;
 
-@ExpectedSignature(descriptor = "ConstructorTest", signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+@ExpectedSignature(descriptor = "ConstructorTest", signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;")
 public class ConstructorTest<T> {
 
     @ExpectedSignature(descriptor = "<init>(java.lang.Object, boolean)", signature = "(TT;Z)V")
     ConstructorTest(T a, boolean b) {
     }
diff a/test/langtools/tools/javac/classfiles/attributes/Signature/EnumTest.java b/test/langtools/tools/javac/classfiles/attributes/Signature/EnumTest.java
--- a/test/langtools/tools/javac/classfiles/attributes/Signature/EnumTest.java
+++ b/test/langtools/tools/javac/classfiles/attributes/Signature/EnumTest.java
@@ -32,11 +32,11 @@
  * @build toolbox.ToolBox InMemoryFileManager TestResult TestBase
  * @build EnumTest Driver ExpectedSignature ExpectedSignatureContainer
  * @run main Driver EnumTest
  */
 
-@ExpectedSignature(descriptor = "EnumTest", signature = "Ljava/lang/Enum<LEnumTest;>;Ljava/lang/IdentityObject;")
+@ExpectedSignature(descriptor = "EnumTest", signature = "Ljava/lang/Enum<LEnumTest;>;")
 public enum EnumTest {;
     // see 8026480
     @ExpectedSignature(descriptor = "<init>(java.lang.String, int)", signature = "()V")
     private EnumTest() {}
 }
diff a/test/langtools/tools/javac/classfiles/attributes/Signature/ExceptionTest.java b/test/langtools/tools/javac/classfiles/attributes/Signature/ExceptionTest.java
--- a/test/langtools/tools/javac/classfiles/attributes/Signature/ExceptionTest.java
+++ b/test/langtools/tools/javac/classfiles/attributes/Signature/ExceptionTest.java
@@ -36,11 +36,11 @@
 
 import java.io.IOError;
 import java.io.IOException;
 
 @ExpectedSignature(descriptor = "ExceptionTest",
-        signature = "<Exc:Ljava/lang/RuntimeException;:Ljava/lang/Runnable;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+        signature = "<Exc:Ljava/lang/RuntimeException;:Ljava/lang/Runnable;>Ljava/lang/Object;")
 public class ExceptionTest<Exc extends RuntimeException & Runnable> {
 
     @ExpectedSignature(descriptor = "<init>()", signature = "<E:Ljava/lang/Exception;>()V^TE;")
     <E extends Exception> ExceptionTest() throws E {
     }
diff a/test/langtools/tools/javac/classfiles/attributes/Signature/FieldTest.java b/test/langtools/tools/javac/classfiles/attributes/Signature/FieldTest.java
--- a/test/langtools/tools/javac/classfiles/attributes/Signature/FieldTest.java
+++ b/test/langtools/tools/javac/classfiles/attributes/Signature/FieldTest.java
@@ -36,11 +36,11 @@
 
 import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
 
-@ExpectedSignature(descriptor = "FieldTest", signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+@ExpectedSignature(descriptor = "FieldTest", signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;")
 public class FieldTest<T> {
 
     @ExpectedSignature(descriptor = "typeInList", signature = "Ljava/util/List<TT;>;")
     List<T> typeInList;
 
diff a/test/langtools/tools/javac/classfiles/attributes/Signature/InnerClassTest.java b/test/langtools/tools/javac/classfiles/attributes/Signature/InnerClassTest.java
--- a/test/langtools/tools/javac/classfiles/attributes/Signature/InnerClassTest.java
+++ b/test/langtools/tools/javac/classfiles/attributes/Signature/InnerClassTest.java
@@ -39,16 +39,16 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Callable;
 
 @ExpectedSignature(descriptor = "InnerClassTest",
-        signature = "<T:Ljava/util/ArrayList<TT;>;:Ljava/lang/Runnable;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+        signature = "<T:Ljava/util/ArrayList<TT;>;:Ljava/lang/Runnable;>Ljava/lang/Object;")
 @ExpectedSignature(descriptor = "InnerClassTest$1",
-        signature = "LInnerClassTest$1Local1;Ljava/lang/IdentityObject;", isAnonymous = true)
+        signature = "LInnerClassTest$1Local1;", isAnonymous = true)
 @ExpectedSignature(descriptor = "InnerClassTest$2",
         signature = "LInnerClassTest$1Local2<Ljava/util/ArrayList<TT;>;" +
-                "Ljava/util/Map<Ljava/util/ArrayList<TT;>;Ljava/util/ArrayList<TT;>;>;>;Ljava/lang/IdentityObject;", isAnonymous = true)
+                "Ljava/util/Map<Ljava/util/ArrayList<TT;>;Ljava/util/ArrayList<TT;>;>;>;", isAnonymous = true)
 public class InnerClassTest<T extends ArrayList<T> & Runnable> {
 
     {
         class Local1 {
             // no Signature attribute
@@ -61,11 +61,11 @@
             @ExpectedSignature(descriptor = "genericTypeArray", signature = "[TT;")
             T[] genericTypeArray;
         }
 
         @ExpectedSignature(descriptor = "InnerClassTest$1Local2",
-                signature = "<T:Ljava/lang/Object;U::Ljava/util/Map<+TT;-TT;>;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+                signature = "<T:Ljava/lang/Object;U::Ljava/util/Map<+TT;-TT;>;>Ljava/lang/Object;")
         class Local2<T, U extends Map<? extends T, ? super T>> {
             // no Signature attribute
             Local2() {
             }
 
@@ -81,11 +81,11 @@
             }
         }
 
         @ExpectedSignature(descriptor = "InnerClassTest$1Local3",
                 signature = "LInnerClassTest$1Local2<Ljava/util/ArrayList<TT;>;" +
-                        "Ljava/util/Map<Ljava/util/ArrayList<TT;>;Ljava/util/ArrayList<TT;>;>;>;Ljava/lang/IdentityObject;")
+                        "Ljava/util/Map<Ljava/util/ArrayList<TT;>;Ljava/util/ArrayList<TT;>;>;>;")
         class Local3 extends Local2<ArrayList<T>, Map<ArrayList<T>, ArrayList<T>>> {
         }
 
         new Local1() {
             @ExpectedSignature(descriptor = "genericType", signature = "TT;")
@@ -98,11 +98,11 @@
         new Local2<ArrayList<T>, Map<ArrayList<T>, ArrayList<T>>>() {
         };
     }
 
     @ExpectedSignature(descriptor = "InnerClassTest$InnerClass1",
-            signature = "<E:TT;U::Ljava/util/Set<-TE;>;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+            signature = "<E:TT;U::Ljava/util/Set<-TE;>;>Ljava/lang/Object;")
     class InnerClass1<E extends T, U extends Set<? super E>> {
         @ExpectedSignature(descriptor = "genericTypeArray", signature = "[TT;")
         T[] genericTypeArray;
 
         @ExpectedSignature(descriptor = "genericListExtendsBound", signature = "Ljava/util/List<+TT;>;")
@@ -189,11 +189,11 @@
 
         static List staticNoSignatureAttributeMethod(List list1, List list2, Map list3) { return null; }
     }
 
     @ExpectedSignature(descriptor = "InnerClassTest$InnerClass2",
-            signature = "LInnerClassTest<TT;>.InnerClass1<TT;Ljava/util/Set<TT;>;>;LInnerClassTest$InnerInterface<TT;>;Ljava/lang/IdentityObject;")
+            signature = "LInnerClassTest<TT;>.InnerClass1<TT;Ljava/util/Set<TT;>;>;LInnerClassTest$InnerInterface<TT;>;")
     class InnerClass2 extends InnerClass1<T, Set<T>> implements InnerInterface<T> {
 
         // no Signature attribute
         InnerClass2() {
             super(null);
@@ -239,11 +239,11 @@
         }
     }
 
     @ExpectedSignature(descriptor = "InnerClassTest$StaticInnerClass",
             signature = "<T:Ljava/lang/String;E::Ljava/util/Set<TT;>;>" +
-                    "Ljava/lang/Object;LInnerClassTest$InnerInterface<TE;>;Ljava/lang/IdentityObject;")
+                    "Ljava/lang/Object;LInnerClassTest$InnerInterface<TE;>;")
     static class StaticInnerClass<T extends String, E extends Set<T>> implements InnerInterface<E> {
         // no Signature attribute
         StaticInnerClass(List a) {
         }
 
@@ -329,11 +329,11 @@
         }
     }
 
     @ExpectedSignature(descriptor = "InnerClassTest$InnerClass3",
             signature = "Ljava/lang/Object;LInnerClassTest$ExceptionHolder" +
-                    "<Ljava/lang/RuntimeException;>;Ljava/util/concurrent/Callable<Ljava/util/Map<**>;>;Ljava/lang/IdentityObject;")
+                    "<Ljava/lang/RuntimeException;>;Ljava/util/concurrent/Callable<Ljava/util/Map<**>;>;")
     public static class InnerClass3 implements  ExceptionHolder<RuntimeException>, Callable<Map<?, ?>> {
         @ExpectedSignature(descriptor = "call()", signature = "()Ljava/util/Map<**>;")
         @Override
         public Map<?, ?> call() throws Exception {
             return null;
diff a/test/langtools/tools/javac/classfiles/attributes/Signature/MethodParameterTest.java b/test/langtools/tools/javac/classfiles/attributes/Signature/MethodParameterTest.java
--- a/test/langtools/tools/javac/classfiles/attributes/Signature/MethodParameterTest.java
+++ b/test/langtools/tools/javac/classfiles/attributes/Signature/MethodParameterTest.java
@@ -37,11 +37,11 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-@ExpectedSignature(descriptor = "MethodParameterTest", signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+@ExpectedSignature(descriptor = "MethodParameterTest", signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;")
 public class MethodParameterTest<T> {
 
     @ExpectedSignature(descriptor = "<init>(java.lang.Object, java.util.Set, java.util.ArrayList)",
             signature = "<E:TT;U::Ljava/util/List<TE;>;:Ljava/lang/Runnable;>" +
                     "(TT;Ljava/util/Set<-TE;>;Ljava/util/ArrayList<+Ljava/util/Set<TU;>;>;)V")
diff a/test/langtools/tools/javac/classfiles/attributes/Signature/MethodTypeBoundTest.java b/test/langtools/tools/javac/classfiles/attributes/Signature/MethodTypeBoundTest.java
--- a/test/langtools/tools/javac/classfiles/attributes/Signature/MethodTypeBoundTest.java
+++ b/test/langtools/tools/javac/classfiles/attributes/Signature/MethodTypeBoundTest.java
@@ -34,11 +34,11 @@
  * @run main Driver MethodTypeBoundTest
  */
 
 import java.util.*;
 
-@ExpectedSignature(descriptor = "MethodTypeBoundTest", signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+@ExpectedSignature(descriptor = "MethodTypeBoundTest", signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;")
 public class MethodTypeBoundTest<T> {
 
     @ExpectedSignature(descriptor = "method1(java.lang.String)",
             signature = "<E:Ljava/lang/String;:Ljava/lang/Runnable;:Ljava/util/Collection<+TT;>;>(TE;)TE;")
     <E extends String & Runnable & Collection<? extends T>> E method1(E a) {
@@ -74,9 +74,9 @@
             signature = "<E:Ljava/util/LinkedList<TT;>;U:TE;>()V")
     <E extends LinkedList<T>, U extends E> void method6() {
     }
 
     @ExpectedSignature(descriptor = "MethodTypeBoundTest$InnerClass",
-            signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+            signature = "<T:Ljava/lang/Object;>Ljava/lang/Object;")
     class InnerClass<T> {
     }
 }
diff a/test/langtools/tools/javac/classfiles/attributes/Signature/ReturnTypeTest.java b/test/langtools/tools/javac/classfiles/attributes/Signature/ReturnTypeTest.java
--- a/test/langtools/tools/javac/classfiles/attributes/Signature/ReturnTypeTest.java
+++ b/test/langtools/tools/javac/classfiles/attributes/Signature/ReturnTypeTest.java
@@ -39,11 +39,11 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Callable;
 
 @ExpectedSignature(descriptor = "ReturnTypeTest",
-        signature = "<T:Ljava/awt/Frame;:Ljava/lang/Runnable;:Ljava/util/concurrent/Callable<[TT;>;>Ljava/lang/Object;Ljava/lang/IdentityObject;")
+        signature = "<T:Ljava/awt/Frame;:Ljava/lang/Runnable;:Ljava/util/concurrent/Callable<[TT;>;>Ljava/lang/Object;")
 public class ReturnTypeTest<T extends Frame & Runnable & Callable<T[]>> {
 
     @ExpectedSignature(descriptor = "byteArrayReturnType(java.awt.Frame)",
             signature = "(TT;)[B")
     byte[] byteArrayReturnType(T a) {
diff a/test/langtools/tools/javac/diags/examples.not-yet.txt b/test/langtools/tools/javac/diags/examples.not-yet.txt
--- a/test/langtools/tools/javac/diags/examples.not-yet.txt
+++ b/test/langtools/tools/javac/diags/examples.not-yet.txt
@@ -206,13 +206,11 @@
 compiler.err.value.may.not.extend
 compiler.warn.potential.null.pollution
 compiler.err.empty.value.not.yet
 compiler.err.this.exposed.prematurely
 compiler.warn.this.exposed.prematurely
-compiler.err.identity.type.must.not.implement.inline.object
 compiler.err.inline.type.must.not.implement.identity.object
-compiler.err.mutually.incompatible.interfaces
 compiler.err.concrete.supertype.for.inline.class
 compiler.err.super.class.cannot.be.inner
 compiler.err.super.class.declares.init.block
 compiler.err.super.constructor.cannot.take.arguments
 compiler.err.super.field.not.allowed
diff a/test/langtools/tools/javac/generics/inference/EagerReturnTypeResolution/EagerReturnTypeResolutionTestb.out b/test/langtools/tools/javac/generics/inference/EagerReturnTypeResolution/EagerReturnTypeResolutionTestb.out
--- a/test/langtools/tools/javac/generics/inference/EagerReturnTypeResolution/EagerReturnTypeResolutionTestb.out
+++ b/test/langtools/tools/javac/generics/inference/EagerReturnTypeResolution/EagerReturnTypeResolutionTestb.out
@@ -2,38 +2,38 @@
 EagerReturnTypeResolutionTestb.java:43:9: compiler.err.cant.apply.symbol: kindname.method, takeIString, EagerReturnTypeResolutionTestb.I<java.lang.String>, EagerReturnTypeResolutionTestb.I<compiler.misc.type.captureof: 1, ?>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<?>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object))
 EagerReturnTypeResolutionTestb.java:44:29: compiler.err.prob.found.req: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<?>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
 EagerReturnTypeResolutionTestb.java:45:26: compiler.err.prob.found.req: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<?>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
 EagerReturnTypeResolutionTestb.java:74:15: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.I<java.lang.Integer>,EagerReturnTypeResolutionTestb.I<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:75:15: compiler.err.cant.apply.symbol: kindname.method, upper2, java.util.List<? super T>,java.util.List<? super T>, java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.upper.bounds: T, EagerReturnTypeResolutionTestb.I<java.lang.Integer>,EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
-EagerReturnTypeResolutionTestb.java:77:9: compiler.err.cant.apply.symbol: kindname.method, takeIString, EagerReturnTypeResolutionTestb.I<java.lang.String>, EagerReturnTypeResolutionTestb.I<compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object))
+EagerReturnTypeResolutionTestb.java:77:9: compiler.err.cant.apply.symbol: kindname.method, takeIString, EagerReturnTypeResolutionTestb.I<java.lang.String>, EagerReturnTypeResolutionTestb.I<compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object))
 EagerReturnTypeResolutionTestb.java:78:21: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.I<java.lang.Integer>,EagerReturnTypeResolutionTestb.I<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:79:21: compiler.err.cant.apply.symbol: kindname.method, upper2, java.util.List<? super T>,java.util.List<? super T>, java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.upper.bounds: T, EagerReturnTypeResolutionTestb.I<java.lang.Integer>,EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
-EagerReturnTypeResolutionTestb.java:81:30: compiler.err.prob.found.req: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
+EagerReturnTypeResolutionTestb.java:81:30: compiler.err.prob.found.req: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
 EagerReturnTypeResolutionTestb.java:82:24: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.I<java.lang.Integer>,EagerReturnTypeResolutionTestb.I<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:83:24: compiler.err.cant.apply.symbol: kindname.method, upper2, java.util.List<? super T>,java.util.List<? super T>, java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.upper.bounds: T, EagerReturnTypeResolutionTestb.I<java.lang.Integer>,EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
 EagerReturnTypeResolutionTestb.java:85:15: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.I<?>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.I<?>,EagerReturnTypeResolutionTestb.I<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:86:9: compiler.err.cant.apply.symbol: kindname.method, takeIString, EagerReturnTypeResolutionTestb.I<java.lang.String>, EagerReturnTypeResolutionTestb.I<compiler.misc.type.captureof: 1, ?>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<?>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object))
 EagerReturnTypeResolutionTestb.java:87:21: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.I<?>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.I<?>,EagerReturnTypeResolutionTestb.I<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:89:30: compiler.err.prob.found.req: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<?>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
 EagerReturnTypeResolutionTestb.java:90:24: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.I<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.I<?>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.I<?>,EagerReturnTypeResolutionTestb.I<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:91:15: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.J<java.lang.Integer>,EagerReturnTypeResolutionTestb.J<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:92:15: compiler.err.cant.apply.symbol: kindname.method, upper2, java.util.List<? super T>,java.util.List<? super T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.upper.bounds: T, EagerReturnTypeResolutionTestb.J<java.lang.Integer>,EagerReturnTypeResolutionTestb.J<java.lang.String>,java.lang.Object)
-EagerReturnTypeResolutionTestb.java:94:9: compiler.err.cant.apply.symbol: kindname.method, takeIString, EagerReturnTypeResolutionTestb.I<java.lang.String>, EagerReturnTypeResolutionTestb.J<compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.J<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object))
+EagerReturnTypeResolutionTestb.java:94:9: compiler.err.cant.apply.symbol: kindname.method, takeIString, EagerReturnTypeResolutionTestb.I<java.lang.String>, EagerReturnTypeResolutionTestb.J<compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.J<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object))
 EagerReturnTypeResolutionTestb.java:95:21: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.J<java.lang.Integer>,EagerReturnTypeResolutionTestb.J<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:96:21: compiler.err.cant.apply.symbol: kindname.method, upper2, java.util.List<? super T>,java.util.List<? super T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.upper.bounds: T, EagerReturnTypeResolutionTestb.J<java.lang.Integer>,EagerReturnTypeResolutionTestb.J<java.lang.String>,java.lang.Object)
-EagerReturnTypeResolutionTestb.java:98:30: compiler.err.prob.found.req: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.J<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
+EagerReturnTypeResolutionTestb.java:98:30: compiler.err.prob.found.req: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.J<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
 EagerReturnTypeResolutionTestb.java:99:24: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.J<java.lang.Integer>,EagerReturnTypeResolutionTestb.J<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:100:24: compiler.err.cant.apply.symbol: kindname.method, upper2, java.util.List<? super T>,java.util.List<? super T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.upper.bounds: T, EagerReturnTypeResolutionTestb.J<java.lang.Integer>,EagerReturnTypeResolutionTestb.J<java.lang.String>,java.lang.Object)
 EagerReturnTypeResolutionTestb.java:102:15: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.K>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.K,EagerReturnTypeResolutionTestb.J<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:103:21: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.K>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.K,EagerReturnTypeResolutionTestb.J<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:104:24: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.String>>,java.util.List<EagerReturnTypeResolutionTestb.K>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.K,EagerReturnTypeResolutionTestb.J<java.lang.String>)
 EagerReturnTypeResolutionTestb.java:105:15: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>,java.util.List<EagerReturnTypeResolutionTestb.K>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.K,EagerReturnTypeResolutionTestb.J<java.lang.Integer>)
 EagerReturnTypeResolutionTestb.java:106:15: compiler.err.cant.apply.symbol: kindname.method, upper2, java.util.List<? super T>,java.util.List<? super T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>,java.util.List<EagerReturnTypeResolutionTestb.K>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.upper.bounds: T, EagerReturnTypeResolutionTestb.K,EagerReturnTypeResolutionTestb.J<java.lang.Integer>,java.lang.Object)
-EagerReturnTypeResolutionTestb.java:108:9: compiler.err.cant.apply.symbol: kindname.method, takeIString, EagerReturnTypeResolutionTestb.I<java.lang.String>, EagerReturnTypeResolutionTestb.I<compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object))
+EagerReturnTypeResolutionTestb.java:108:9: compiler.err.cant.apply.symbol: kindname.method, takeIString, EagerReturnTypeResolutionTestb.I<java.lang.String>, EagerReturnTypeResolutionTestb.I<compiler.misc.type.captureof: 1, ? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object))
 EagerReturnTypeResolutionTestb.java:109:21: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>,java.util.List<EagerReturnTypeResolutionTestb.K>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.K,EagerReturnTypeResolutionTestb.J<java.lang.Integer>)
 EagerReturnTypeResolutionTestb.java:110:21: compiler.err.cant.apply.symbol: kindname.method, upper2, java.util.List<? super T>,java.util.List<? super T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>,java.util.List<EagerReturnTypeResolutionTestb.K>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.upper.bounds: T, EagerReturnTypeResolutionTestb.K,EagerReturnTypeResolutionTestb.J<java.lang.Integer>,java.lang.Object)
-EagerReturnTypeResolutionTestb.java:112:30: compiler.err.prob.found.req: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
+EagerReturnTypeResolutionTestb.java:112:30: compiler.err.prob.found.req: (compiler.misc.inferred.do.not.conform.to.upper.bounds: EagerReturnTypeResolutionTestb.I<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>, EagerReturnTypeResolutionTestb.I<java.lang.String>,java.lang.Object)
 EagerReturnTypeResolutionTestb.java:113:24: compiler.err.cant.apply.symbol: kindname.method, eq2, java.util.List<T>,java.util.List<T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>,java.util.List<EagerReturnTypeResolutionTestb.K>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.eq.bounds: T, EagerReturnTypeResolutionTestb.K,EagerReturnTypeResolutionTestb.J<java.lang.Integer>)
 EagerReturnTypeResolutionTestb.java:114:24: compiler.err.cant.apply.symbol: kindname.method, upper2, java.util.List<? super T>,java.util.List<? super T>, java.util.List<EagerReturnTypeResolutionTestb.J<java.lang.Integer>>,java.util.List<EagerReturnTypeResolutionTestb.K>, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.incompatible.upper.bounds: T, EagerReturnTypeResolutionTestb.K,EagerReturnTypeResolutionTestb.J<java.lang.Integer>,java.lang.Object)
 EagerReturnTypeResolutionTestb.java:174:9: compiler.err.cant.apply.symbol: kindname.method, takeLong, long, java.lang.Double, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: java.lang.Double, java.lang.Long,java.lang.Object))
 EagerReturnTypeResolutionTestb.java:175:9: compiler.err.cant.apply.symbol: kindname.method, takeLong, long, java.lang.Double, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: java.lang.Double, java.lang.Long,java.lang.Object))
 EagerReturnTypeResolutionTestb.java:176:9: compiler.err.cant.apply.symbol: kindname.method, takeLong, long, java.lang.Double, kindname.class, EagerReturnTypeResolutionTestb, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inferred.do.not.conform.to.upper.bounds: java.lang.Double, java.lang.Long,java.lang.Double,java.lang.Object))
diff a/test/langtools/tools/javac/processing/model/element/TestMissingElement/TestMissingElement.java b/test/langtools/tools/javac/processing/model/element/TestMissingElement/TestMissingElement.java
--- a/test/langtools/tools/javac/processing/model/element/TestMissingElement/TestMissingElement.java
+++ b/test/langtools/tools/javac/processing/model/element/TestMissingElement/TestMissingElement.java
@@ -27,11 +27,11 @@
  * @summary Modeling type implementing missing interfaces
  * @library /tools/javac/lib
  * @modules jdk.compiler/com.sun.tools.javac.processing
  *          jdk.compiler/com.sun.tools.javac.util
  * @build JavacTestingAbstractProcessor TestMissingElement
- * @compile/fail/ref=TestMissingElement.ref -XDnoTopInterfaceInjection -XDaccessInternalAPI -proc:only -XprintRounds -XDrawDiagnostics -processor TestMissingElement InvalidSource.java
+ * @compile/fail/ref=TestMissingElement.ref -XDaccessInternalAPI -proc:only -XprintRounds -XDrawDiagnostics -processor TestMissingElement InvalidSource.java
  */
 
 import java.io.PrintWriter;
 import java.util.*;
 import javax.annotation.processing.*;
diff a/test/langtools/tools/javac/processing/model/util/printing/module-info.out b/test/langtools/tools/javac/processing/model/util/printing/module-info.out
--- a/test/langtools/tools/javac/processing/model/util/printing/module-info.out
+++ b/test/langtools/tools/javac/processing/model/util/printing/module-info.out
@@ -1,15 +1,15 @@
 package p;
 
-public class P implements java.lang.IdentityObject {
+public class P {
 
-  public static class P1 extends p.P implements java.lang.IdentityObject {
+  public static class P1 extends p.P {
 
     public P1();
   }
 
-  public static class P2 extends p.P implements java.lang.IdentityObject {
+  public static class P2 extends p.P {
 
     public P2();
   }
 
   public P();
diff a/test/langtools/tools/javac/processing/options/XprintDocComments.out b/test/langtools/tools/javac/processing/options/XprintDocComments.out
--- a/test/langtools/tools/javac/processing/options/XprintDocComments.out
+++ b/test/langtools/tools/javac/processing/options/XprintDocComments.out
@@ -1,10 +1,10 @@
 
 /**
  * CLASS XprintDocComments
  */
-class XPrintDocComments implements java.lang.IdentityObject {
+class XPrintDocComments {
 
   XPrintDocComments();
   /**
    * FIELD i;
    */
diff a/test/langtools/tools/javac/processing/rounds/GenerateAnonymousClass.out b/test/langtools/tools/javac/processing/rounds/GenerateAnonymousClass.out
--- a/test/langtools/tools/javac/processing/rounds/GenerateAnonymousClass.out
+++ b/test/langtools/tools/javac/processing/rounds/GenerateAnonymousClass.out
@@ -1,17 +1,17 @@
 round: 1
 round: 2
 
-public class T implements java.lang.IdentityObject {
+public class T {
 
   public T();
 
   public void test();
 }
 round: 3
 
-public class T implements java.lang.IdentityObject {
+public class T {
 
   public T();
 
   public void test();
 }
diff a/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_1.out b/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_1.out
--- a/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_1.out
+++ b/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_1.out
@@ -1,41 +1,41 @@
 round: 1
 round: 2
 
 @java.lang.Deprecated
-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedSource();
 
   public void test(int a);
 
   public void run();
 }
 
 @java.lang.Deprecated
-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedClass();
 
   public void test(int a);
 
   public void run();
 }
 round: 3
 
 @java.lang.Deprecated
-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedSource();
 
   public void test(int a);
 
   public void run();
 }
 
 @java.lang.Deprecated
-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedClass();
 
   public void test(int a);
 
diff a/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_2.out b/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_2.out
--- a/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_2.out
+++ b/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_2.out
@@ -1,19 +1,19 @@
 round: 1
 
 @java.lang.Deprecated
-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedSource();
 
   public void test(int a);
 
   public void run();
 }
 
 @java.lang.Deprecated
-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedClass();
 
   public void test(int a);
 
diff a/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_3.out b/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_3.out
--- a/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_3.out
+++ b/test/langtools/tools/javac/processing/rounds/OverwriteBetweenCompilations_3.out
@@ -16,42 +16,42 @@
   public void test(long a);
 }
 round: 2
 
 @java.lang.Deprecated
-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedSource();
 
   public void test(int a);
 
   public void run();
 }
 
 @java.lang.Deprecated
-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedClass();
 
   public void test(int a);
 
   public void run();
 }
 round: 3
 
 @java.lang.Deprecated
-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedSource();
 
   public void test(int a);
 
   public void run();
 }
 
 @java.lang.Deprecated
-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable, java.lang.IdentityObject {
+public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {
 
   public GeneratedClass();
 
   public void test(int a);
 
diff a/test/langtools/tools/javac/valhalla/lworld-values/CheckFinal.out b/test/langtools/tools/javac/valhalla/lworld-values/CheckFinal.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/CheckFinal.out
+++ b/test/langtools/tools/javac/valhalla/lworld-values/CheckFinal.out
@@ -1,7 +1,7 @@
 CheckFinal.java:14:13: compiler.err.cant.assign.val.to.final.var: fi
 CheckFinal.java:15:13: compiler.err.cant.assign.val.to.final.var: fe
 CheckFinal.java:17:13: compiler.err.cant.assign.val.to.final.var: xsf
 CheckFinal.java:19:29: compiler.err.cant.inherit.from.final: CheckFinal
 CheckFinal.java:19:42: compiler.err.empty.value.not.yet
-CheckFinal.java:19:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.anonymous.class: java.lang.InlineObject, CheckFinal)
+CheckFinal.java:19:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.anonymous.class: CheckFinal, CheckFinal)
 6 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/IllegalByValueTest2.out b/test/langtools/tools/javac/valhalla/lworld-values/IllegalByValueTest2.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/IllegalByValueTest2.out
+++ b/test/langtools/tools/javac/valhalla/lworld-values/IllegalByValueTest2.out
@@ -1,3 +1,3 @@
 IllegalByValueTest2.java:19:27: compiler.err.duplicate.annotation.missing.container: IllegalByValueTest2.Annot
-IllegalByValueTest2.java:19:56: compiler.err.inline.type.must.not.implement.identity.object: compiler.misc.anonymous.class: java.lang.InlineObject
+IllegalByValueTest2.java:19:56: compiler.err.inline.type.must.not.implement.identity.object: compiler.misc.anonymous.class: IllegalByValueTest2
 2 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/InstanceOfTopTypeTest.java b/test/langtools/tools/javac/valhalla/lworld-values/InstanceOfTopTypeTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/InstanceOfTopTypeTest.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/InstanceOfTopTypeTest.java
@@ -27,13 +27,15 @@
  * @summary Identity types that have no declaration sites fail to be IdentityObjects
  * @run main/othervm InstanceOfTopTypeTest
  */
 
 public class InstanceOfTopTypeTest {
-    static inline class V {
+    interface InlineObject {}
+    static inline class V implements InlineObject {
         int x = 42;
     }
+
     public static void main(String [] args) {
         int points = 0;
         Object o = new InstanceOfTopTypeTest();
         if (o instanceof IdentityObject)
             points++;     // 1
diff a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.java b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.java
@@ -8,30 +8,30 @@
 public class TopInterfaceNegativeTest  {
 
     interface ID extends IdentityObject {}
     interface II extends InlineObject {}
 
-    interface IID0 extends IdentityObject, IdentityObject {} // Error.
-    interface IID1 extends IdentityObject, InlineObject {} // Error.
-    interface IID2 extends IdentityObject, II {} // Error.
-    interface IID3 extends IdentityObject, ID {} // OK.
-    interface IID4 extends InlineObject, II {} // OK.
-    interface IID5 extends ID, II {} // Error
+    interface IID0 extends IdentityObject, IdentityObject {}
+    interface IID1 extends IdentityObject, InlineObject {}
+    interface IID2 extends IdentityObject, II {}
+    interface IID3 extends IdentityObject, ID {}
+    interface IID4 extends InlineObject, II {}
+    interface IID5 extends ID, II {}
 
-    static class C1 implements InlineObject {} // Error
-    static class C2 implements II {} // Error
-    static class C3 implements IdentityObject {} // Ok
-    static class C4 implements ID {} // Ok
-    static class C5 implements IdentityObject, IdentityObject {} // Error.
-    static class C6 implements IdentityObject, ID {} // OK
-    static class C7 implements II, ID {} // Error
+    static class C1 implements InlineObject {}
+    static class C2 implements II {}
+    static class C3 implements IdentityObject {}
+    static class C4 implements ID {}
+    static class C5 implements IdentityObject, IdentityObject {}
+    static class C6 implements IdentityObject, ID {}
+    static class C7 implements II, ID {}
 
-    static inline class V1 implements IdentityObject {} // error.
-    static inline class V2 implements InlineObject {} // Ok.
-    static inline class V3 implements InlineObject, InlineObject  {} // error.
+    static inline class V1 implements IdentityObject { int x = 0; }
+    static inline class V2 implements InlineObject {}
+    static inline class V3 implements InlineObject, InlineObject  {}
 
     void foo(V2 v) {
         if (v instanceof IdentityObject)
             throw new AssertionError("Expected inline object but found identity object");
     }
-    abstract class abs implements IdentityObject {} // OK
+    abstract class abs implements IdentityObject {}
 }
diff a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.out b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.out
+++ b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.out
@@ -1,14 +1,14 @@
+TopInterfaceNegativeTest.java:29:39: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)
+TopInterfaceNegativeTest.java:11:26: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)
 TopInterfaceNegativeTest.java:13:44: compiler.err.repeated.interface
+TopInterfaceNegativeTest.java:14:44: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)
+TopInterfaceNegativeTest.java:17:28: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)
+TopInterfaceNegativeTest.java:20:32: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)
 TopInterfaceNegativeTest.java:24:48: compiler.err.repeated.interface
-TopInterfaceNegativeTest.java:30:53: compiler.err.repeated.interface
-TopInterfaceNegativeTest.java:14:5: compiler.err.mutually.incompatible.interfaces: TopInterfaceNegativeTest.IID1
-TopInterfaceNegativeTest.java:15:5: compiler.err.mutually.incompatible.interfaces: TopInterfaceNegativeTest.IID2
-TopInterfaceNegativeTest.java:18:5: compiler.err.mutually.incompatible.interfaces: TopInterfaceNegativeTest.IID5
-TopInterfaceNegativeTest.java:20:12: compiler.err.identity.type.must.not.implement.inline.object: TopInterfaceNegativeTest.C1
-TopInterfaceNegativeTest.java:21:12: compiler.err.identity.type.must.not.implement.inline.object: TopInterfaceNegativeTest.C2
-TopInterfaceNegativeTest.java:26:12: compiler.err.identity.type.must.not.implement.inline.object: TopInterfaceNegativeTest.C7
+TopInterfaceNegativeTest.java:30:39: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)
+TopInterfaceNegativeTest.java:30:53: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)
 TopInterfaceNegativeTest.java:28:19: compiler.err.inline.type.must.not.implement.identity.object: TopInterfaceNegativeTest.V1
 TopInterfaceNegativeTest.java:29:19: compiler.err.empty.value.not.yet
 TopInterfaceNegativeTest.java:30:19: compiler.err.empty.value.not.yet
 TopInterfaceNegativeTest.java:33:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TopInterfaceNegativeTest.V2, java.lang.IdentityObject)
 13 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceTest.java b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceTest.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceTest.java
@@ -45,18 +45,18 @@
     public static void main(String args[]) {
 
         V inln_o = new V();
         C id_o = new C();
 
-        // Check that InlineObject is injected as a super interface for inline types.
+
         Class<?> [] ca = inln_o.getClass().getInterfaces();
-        if (ca.length != 1)
-            throw new AssertionError("Found wrong super interfaces");
-        if (!ca[0].getCanonicalName().equals("java.lang.InlineObject"))
+        if (ca.length != 0)
             throw new AssertionError("Found wrong super interfaces");
-        if (!(inln_o instanceof InlineObject)) // really really make sure...
-            throw new AssertionError("Expected inline Object");
+
+
+
+
 
         // Check that V's super class is V.ref in class file.
         Class<?> vrefCls = inln_o.getClass().getSuperclass();
         if (!vrefCls.getCanonicalName().equals("TopInterfaceTest.V$ref"))
             throw new AssertionError("Wrong super type for value type");
@@ -68,12 +68,12 @@
         if (jlo.getInterfaces().length != 0)
             throw new AssertionError("Wrong number of super interfaces for jlO");
 
         if (!(id_o instanceof IdentityObject))
             throw new AssertionError("Expected identity Object");
-        if (id_o instanceof InlineObject)
-            throw new AssertionError("Expected identity object, found inline object");
+
+
 
         // Check that no super interface injection has happened for interfaces.
         if (I.class.getInterfaces().length != 0)
             throw new AssertionError("Found extraneous super interfaces");
 
diff a/test/langtools/tools/javac/valhalla/lworld-values/UndeclaredIdentityObjectsTest.java b/test/langtools/tools/javac/valhalla/lworld-values/UndeclaredIdentityObjectsTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/UndeclaredIdentityObjectsTest.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/UndeclaredIdentityObjectsTest.java
@@ -1,10 +1,10 @@
 /*
  * @test /nodynamiccopyright/
  * @bug 8237955
  * @summary Identity types that have no declaration sites fail to be IdentityObjects
- * @compile/fail/ref=UndeclaredIdentityObjectsTest.out -XDrawDiagnostics UndeclaredIdentityObjectsTest.java
+ * @compile -XDrawDiagnostics UndeclaredIdentityObjectsTest.java
  */
 
 public class UndeclaredIdentityObjectsTest {
     static class G<T> {}
     public static void main(String [] args) {
@@ -16,11 +16,7 @@
         Object o = new G<String>();
         if (!(o instanceof IdentityObject))
             throw new AssertionError("Parameterized type are broken");
         if (!(oa[0] instanceof IdentityObject)) // can only be determined at runtime
             System.out.println("Arrays are broken!");
-        if (oa[0] instanceof InlineObject) // can only be determined at runtime
-            System.out.println("Arrays are broken!");
-        if (oa instanceof InlineObject) // compile error.
-            throw new AssertionError("Arrays are broken");
     }
 }
diff a/test/langtools/tools/javac/valhalla/lworld-values/UndeclaredIdentityObjectsTest.out b/test/langtools/tools/javac/valhalla/lworld-values/UndeclaredIdentityObjectsTest.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/UndeclaredIdentityObjectsTest.out
+++ /dev/null
@@ -1,2 +0,0 @@
-UndeclaredIdentityObjectsTest.java:23:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], java.lang.InlineObject)
-1 error
diff a/test/langtools/tools/javac/varargs/6806876/T6806876.out b/test/langtools/tools/javac/varargs/6806876/T6806876.out
--- a/test/langtools/tools/javac/varargs/6806876/T6806876.out
+++ b/test/langtools/tools/javac/varargs/6806876/T6806876.out
@@ -1,5 +1,5 @@
-T6806876.java:11:32: compiler.warn.unchecked.generic.array.creation: java.lang.Number&java.lang.IdentityObject&java.lang.Comparable<? extends java.lang.Number&java.lang.IdentityObject&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc[]
+T6806876.java:11:32: compiler.warn.unchecked.generic.array.creation: java.lang.Number&java.lang.Comparable<? extends java.lang.Number&java.lang.Comparable<?>&java.lang.constant.Constable&java.lang.constant.ConstantDesc>&java.lang.constant.Constable&java.lang.constant.ConstantDesc[]
 T6806876.java:14:19: compiler.warn.unchecked.varargs.non.reifiable.type: T
 - compiler.err.warnings.and.werror
 1 error
 2 warnings
diff a/test/langtools/tools/javap/8006334/JavapTaskCtorFailWithNPE.java b/test/langtools/tools/javap/8006334/JavapTaskCtorFailWithNPE.java
--- a/test/langtools/tools/javap/8006334/JavapTaskCtorFailWithNPE.java
+++ b/test/langtools/tools/javap/8006334/JavapTaskCtorFailWithNPE.java
@@ -45,11 +45,11 @@
 public class JavapTaskCtorFailWithNPE {
 
     //we will also check the output just to confirm that we get the expected one
     private static final String expOutput =
         "Compiled from \"JavapTaskCtorFailWithNPE.java\"\n" +
-        "public class JavapTaskCtorFailWithNPE implements java.lang.IdentityObject {\n" +
+        "public class JavapTaskCtorFailWithNPE {\n" +
         "  public JavapTaskCtorFailWithNPE();\n" +
         "  public static void main(java.lang.String[]);\n" +
         "}\n";
 
     public static void main(String[] args) {
diff a/test/langtools/tools/javap/T4880663.java b/test/langtools/tools/javap/T4880663.java
--- a/test/langtools/tools/javap/T4880663.java
+++ b/test/langtools/tools/javap/T4880663.java
@@ -38,11 +38,11 @@
     }
 
     public void run() throws IOException {
         File javaFile = writeTestFile();
         File classFile = compileTestFile(javaFile);
-        verify(classFile, "class Test implements java.lang.IdentityObject {");
+        verify(classFile, "class Test {");
 
         if (errors > 0)
             throw new Error(errors + " found.");
     }
 
diff a/test/langtools/tools/javap/TestSuperclass.java b/test/langtools/tools/javap/TestSuperclass.java
--- a/test/langtools/tools/javap/TestSuperclass.java
+++ b/test/langtools/tools/javap/TestSuperclass.java
@@ -32,11 +32,10 @@
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.net.URI;
 import java.util.Arrays;
-import java.util.List;
 import javax.tools.JavaCompiler;
 import javax.tools.JavaCompiler.CompilationTask;
 import javax.tools.JavaFileObject;
 import javax.tools.SimpleJavaFileObject;
 import javax.tools.StandardJavaFileManager;
@@ -111,11 +110,11 @@
         testDir.mkdirs();
         fm.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(testDir));
 
         JavaSource js = new JavaSource();
         System.err.println(js.getCharContent(false));
-        CompilationTask t = comp.getTask(null, fm, null, List.of("-XDnoTopInterfaceInjection"), null, Arrays.asList(js));
+        CompilationTask t = comp.getTask(null, fm, null, null, null, Arrays.asList(js));
         if (!t.call())
             throw new Error("compilation failed");
 
         File testClass = new File(testDir, "Test.class");
         String out = javap(testClass);
diff a/test/langtools/tools/javap/classfile/6888367/T6888367.java b/test/langtools/tools/javap/classfile/6888367/T6888367.java
--- a/test/langtools/tools/javap/classfile/6888367/T6888367.java
+++ b/test/langtools/tools/javap/classfile/6888367/T6888367.java
@@ -37,12 +37,10 @@
 /*
  * @test
  * @bug 6888367
  * @summary classfile library parses signature attributes incorrectly
  * @modules jdk.jdeps/com.sun.tools.classfile
- * @compile -XDnoTopInterfaceInjection T6888367.java
- * @run main T6888367
  */
 
 /*
  * This test is a pretty detailed test both of javac signature generation and classfile
  * signature parsing.  The first part of the test tests all the examples given in the
diff a/test/langtools/tools/javap/classfile/T6887895.java b/test/langtools/tools/javap/classfile/T6887895.java
--- a/test/langtools/tools/javap/classfile/T6887895.java
+++ b/test/langtools/tools/javap/classfile/T6887895.java
@@ -55,11 +55,10 @@
         }
 
         String[] expectNames = {
             "java/lang/Object",
             "java/lang/String",
-            "java/lang/IdentityObject",
             "T6887895",
             "T6887895$Test"
         };
 
         Set<String> expect = new TreeSet<String>(Arrays.asList(expectNames));
diff a/test/langtools/tools/javap/classfile/deps/T6907575.out b/test/langtools/tools/javap/classfile/deps/T6907575.out
--- a/test/langtools/tools/javap/classfile/deps/T6907575.out
+++ b/test/langtools/tools/javap/classfile/deps/T6907575.out
@@ -1,11 +1,8 @@
 p/C1
-    java/lang/IdentityObject
     java/lang/Object
     p/C2
 p/C2
-    java/lang/IdentityObject
     java/lang/Object
     p/C3
 p/C3
-    java/lang/IdentityObject
     java/lang/Object
diff a/test/langtools/tools/javap/typeAnnotations/InvisibleParameterAnnotationsTest.java b/test/langtools/tools/javap/typeAnnotations/InvisibleParameterAnnotationsTest.java
--- a/test/langtools/tools/javap/typeAnnotations/InvisibleParameterAnnotationsTest.java
+++ b/test/langtools/tools/javap/typeAnnotations/InvisibleParameterAnnotationsTest.java
@@ -60,15 +60,15 @@
 
     private static final String ExpectedSubstring =
             "    RuntimeVisibleParameterAnnotations:\n" +
             "      parameter 0:\n" +
             "      parameter 1:\n" +
-            "        0: #16()\n" +
+            "        0: #14()\n" +
             "          Sample$VisAnno\n" +
             "    RuntimeInvisibleParameterAnnotations:\n" +
             "      parameter 0:\n" +
-            "        0: #18()\n" +
+            "        0: #16()\n" +
             "          Sample$InvisAnno\n" +
             "      parameter 1:";
 
     public static void main(String[] args) throws Exception {
         ToolBox tb = new ToolBox();
diff a/test/langtools/tools/jdeps/APIDeps.java b/test/langtools/tools/jdeps/APIDeps.java
--- a/test/langtools/tools/jdeps/APIDeps.java
+++ b/test/langtools/tools/jdeps/APIDeps.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8015912 8029216 8048063 8050804
  * @summary Test -apionly and -jdkinternals options
  * @library lib
  * @modules java.base/sun.security.x509
diff a/test/langtools/tools/jdeps/Basic.java b/test/langtools/tools/jdeps/Basic.java
--- a/test/langtools/tools/jdeps/Basic.java
+++ b/test/langtools/tools/jdeps/Basic.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8003562 8005428 8015912 8027481 8048063 8068937
  * @summary Basic tests for jdeps tool
  * @modules java.management
  *          jdk.jdeps/com.sun.tools.jdeps
diff a/test/langtools/tools/jdeps/DotFileTest.java b/test/langtools/tools/jdeps/DotFileTest.java
--- a/test/langtools/tools/jdeps/DotFileTest.java
+++ b/test/langtools/tools/jdeps/DotFileTest.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8003562
  * @summary Basic tests for jdeps -dotoutput option
  * @modules java.management
  *          jdk.jdeps/com.sun.tools.jdeps
diff a/test/langtools/tools/jdeps/MultiReleaseJar.java b/test/langtools/tools/jdeps/MultiReleaseJar.java
--- a/test/langtools/tools/jdeps/MultiReleaseJar.java
+++ b/test/langtools/tools/jdeps/MultiReleaseJar.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8153654 8176333
  * @summary Tests for jdeps tool with multi-release jar files
  * @modules jdk.jdeps/com.sun.tools.jdeps
  * @library mrjar mrjar/base mrjar/9 mrjar/10 mrjar/v9 mrjar/v10
diff a/test/langtools/tools/jdeps/jdkinternals/RemovedJDKInternals.java b/test/langtools/tools/jdeps/jdkinternals/RemovedJDKInternals.java
--- a/test/langtools/tools/jdeps/jdkinternals/RemovedJDKInternals.java
+++ b/test/langtools/tools/jdeps/jdkinternals/RemovedJDKInternals.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * @ignore
  * @test
  * @bug 8153042
  * @summary Tests JDK internal APIs that have been removed.
  * @library ../lib
  * @build CompilerUtils JdepsRunner JdepsUtil ModuleMetaData

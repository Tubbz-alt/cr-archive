<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.HashSet;
  29 import java.util.Set;
  30 import java.util.function.BiConsumer;
  31 
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Lint.LintCategory;
  36 import com.sun.tools.javac.code.Scope.ImportFilter;
  37 import com.sun.tools.javac.code.Scope.NamedImportScope;
  38 import com.sun.tools.javac.code.Scope.StarImportScope;
  39 import com.sun.tools.javac.code.Scope.WriteableScope;
  40 import com.sun.tools.javac.code.Source.Feature;
  41 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  42 import com.sun.tools.javac.jvm.Target;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.util.*;
  45 import com.sun.tools.javac.util.DefinedBy.Api;
  46 
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.code.Type.*;
  49 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  50 import com.sun.tools.javac.tree.JCTree.*;
  51 
  52 import static com.sun.tools.javac.code.Flags.*;
  53 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  54 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  55 import static com.sun.tools.javac.code.Kinds.Kind.*;
  56 import static com.sun.tools.javac.code.TypeTag.CLASS;
  57 import static com.sun.tools.javac.code.TypeTag.ERROR;
  58 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  59 
  60 import static com.sun.tools.javac.code.TypeTag.*;
  61 import static com.sun.tools.javac.code.TypeTag.BOT;
  62 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  63 
  64 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  65 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 /** This is the second phase of Enter, in which classes are completed
  69  *  by resolving their headers and entering their members in the into
  70  *  the class scope. See Enter for an overall overview.
  71  *
  72  *  This class uses internal phases to process the classes. When a phase
  73  *  processes classes, the lower phases are not invoked until all classes
  74  *  pass through the current phase. Note that it is possible that upper phases
  75  *  are run due to recursive completion. The internal phases are:
  76  *  - ImportPhase: shallow pass through imports, adds information about imports
  77  *                 the NamedImportScope and StarImportScope, but avoids queries
  78  *                 about class hierarchy.
  79  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  80  *                    type parameters of the class or type argument of the supertypes.
  81  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
  82  *                 type parameters, attributing supertypes including type arguments
  83  *                 and scheduling full annotation attribution. This phase also adds
  84  *                 a synthetic default constructor if needed and synthetic &quot;this&quot; field.
  85  *  - MembersPhase: resolves headers for fields, methods and constructors in the given class.
  86  *                  Also generates synthetic enum members.
  87  *
  88  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  89  *  If you write code that depends on this, you do so at your own risk.
  90  *  This code and its internal interfaces are subject to change or
  91  *  deletion without notice.&lt;/b&gt;
  92  */
  93 public class TypeEnter implements Completer {
  94     protected static final Context.Key&lt;TypeEnter&gt; typeEnterKey = new Context.Key&lt;&gt;();
  95 
  96     /** A switch to determine whether we check for package/class conflicts
  97      */
  98     final static boolean checkClash = true;
  99 
 100     private final Names names;
 101     private final Enter enter;
 102     private final MemberEnter memberEnter;
 103     private final Log log;
 104     private final Check chk;
 105     private final Attr attr;
 106     private final Symtab syms;
 107     private final TreeMaker make;
 108     private final Todo todo;
 109     private final Annotate annotate;
 110     private final TypeAnnotations typeAnnotations;
 111     private final Types types;
 112     private final JCDiagnostic.Factory diags;
 113     private final DeferredLintHandler deferredLintHandler;
 114     private final Lint lint;
 115     private final TypeEnvs typeEnvs;
 116     private final Dependencies dependencies;
 117 
 118     public static TypeEnter instance(Context context) {
 119         TypeEnter instance = context.get(typeEnterKey);
 120         if (instance == null)
 121             instance = new TypeEnter(context);
 122         return instance;
 123     }
 124 
 125     protected TypeEnter(Context context) {
 126         context.put(typeEnterKey, this);
 127         names = Names.instance(context);
 128         enter = Enter.instance(context);
 129         memberEnter = MemberEnter.instance(context);
 130         log = Log.instance(context);
 131         chk = Check.instance(context);
 132         attr = Attr.instance(context);
 133         syms = Symtab.instance(context);
 134         make = TreeMaker.instance(context);
 135         todo = Todo.instance(context);
 136         annotate = Annotate.instance(context);
 137         typeAnnotations = TypeAnnotations.instance(context);
 138         types = Types.instance(context);
 139         diags = JCDiagnostic.Factory.instance(context);
 140         deferredLintHandler = DeferredLintHandler.instance(context);
 141         lint = Lint.instance(context);
 142         typeEnvs = TypeEnvs.instance(context);
 143         dependencies = Dependencies.instance(context);
 144         Source source = Source.instance(context);
 145         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 146         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);
<a name="1" id="anc1"></a><span class="line-removed"> 147         injectTopInterfaceTypes = Options.instance(context).isUnset(&quot;noTopInterfaceInjection&quot;) &amp;&amp;</span>
<span class="line-removed"> 148                                         Feature.INLINE_TYPES.allowedInSource(source) &amp;&amp;</span>
<span class="line-removed"> 149                                             Target.instance(context).hasTopInterfaces();</span>
 150     }
 151 
 152     /** Switch: support type annotations.
 153      */
 154     boolean allowTypeAnnos;
 155 
 156     /**
 157      * Switch: should deprecation warnings be issued on import
 158      */
 159     boolean allowDeprecationOnImport;
 160 
<a name="2" id="anc2"></a><span class="line-removed"> 161     /** Switch: inject top interface types.</span>
<span class="line-removed"> 162      */</span>
<span class="line-removed"> 163     boolean injectTopInterfaceTypes;</span>
<span class="line-removed"> 164 </span>
 165     /** A flag to disable completion from time to time during member
 166      *  enter, as we only need to look up types.  This avoids
 167      *  unnecessarily deep recursion.
 168      */
 169     boolean completionEnabled = true;
 170 
 171     /* Verify Imports:
 172      */
 173     protected void ensureImportsChecked(List&lt;JCCompilationUnit&gt; trees) {
 174         // if there remain any unimported toplevels (these must have
 175         // no classes at all), process their import statements as well.
 176         for (JCCompilationUnit tree : trees) {
 177             if (!tree.starImportScope.isFilled()) {
 178                 Env&lt;AttrContext&gt; topEnv = enter.topLevelEnv(tree);
 179                 finishImports(tree, () -&gt; { completeClass.resolveImports(tree, topEnv); });
 180             }
 181         }
 182     }
 183 
 184 /* ********************************************************************
 185  * Source completer
 186  *********************************************************************/
 187 
 188     /** Complete entering a class.
 189      *  @param sym         The symbol of the class to be completed.
 190      */
 191     @Override
 192     public void complete(Symbol sym) throws CompletionFailure {
 193         // Suppress some (recursive) MemberEnter invocations
 194         if (!completionEnabled) {
 195             // Re-install same completer for next time around and return.
 196             Assert.check((sym.flags() &amp; Flags.COMPOUND) == 0);
 197             sym.completer = this;
 198             return;
 199         }
 200 
 201         try {
 202             annotate.blockAnnotations();
 203             sym.flags_field |= UNATTRIBUTED;
 204 
 205             List&lt;Env&lt;AttrContext&gt;&gt; queue;
 206 
 207             dependencies.push((ClassSymbol) sym, CompletionCause.MEMBER_ENTER);
 208             try {
 209                 queue = completeClass.completeEnvs(List.of(typeEnvs.get((ClassSymbol) sym)));
 210             } finally {
 211                 dependencies.pop();
 212             }
 213 
 214             if (!queue.isEmpty()) {
 215                 Set&lt;JCCompilationUnit&gt; seen = new HashSet&lt;&gt;();
 216 
 217                 for (Env&lt;AttrContext&gt; env : queue) {
 218                     if (env.toplevel.defs.contains(env.enclClass) &amp;&amp; seen.add(env.toplevel)) {
 219                         finishImports(env.toplevel, () -&gt; {});
 220                     }
 221                 }
 222             }
 223         } finally {
 224             annotate.unblockAnnotations();
 225         }
 226     }
 227 
 228     void finishImports(JCCompilationUnit toplevel, Runnable resolve) {
 229         JavaFileObject prev = log.useSource(toplevel.sourcefile);
 230         try {
 231             resolve.run();
 232             chk.checkImportsUnique(toplevel);
 233             chk.checkImportsResolvable(toplevel);
 234             chk.checkImportedPackagesObservable(toplevel);
 235             toplevel.namedImportScope.finalizeScope();
 236             toplevel.starImportScope.finalizeScope();
 237         } catch (CompletionFailure cf) {
 238             chk.completionError(toplevel.pos(), cf);
 239         } finally {
 240             log.useSource(prev);
 241         }
 242     }
 243 
 244     abstract class Phase {
 245         private final ListBuffer&lt;Env&lt;AttrContext&gt;&gt; queue = new ListBuffer&lt;&gt;();
 246         private final Phase next;
 247         private final CompletionCause phaseName;
 248 
 249         Phase(CompletionCause phaseName, Phase next) {
 250             this.phaseName = phaseName;
 251             this.next = next;
 252         }
 253 
 254         public final List&lt;Env&lt;AttrContext&gt;&gt; completeEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 255             boolean firstToComplete = queue.isEmpty();
 256 
 257             Phase prevTopLevelPhase = topLevelPhase;
 258             boolean success = false;
 259 
 260             try {
 261                 topLevelPhase = this;
 262                 doCompleteEnvs(envs);
 263                 success = true;
 264             } finally {
 265                 topLevelPhase = prevTopLevelPhase;
 266                 if (!success &amp;&amp; firstToComplete) {
 267                     //an exception was thrown, e.g. BreakAttr:
 268                     //the queue would become stale, clear it:
 269                     queue.clear();
 270                 }
 271             }
 272 
 273             if (firstToComplete) {
 274                 List&lt;Env&lt;AttrContext&gt;&gt; out = queue.toList();
 275 
 276                 queue.clear();
 277                 return next != null ? next.completeEnvs(out) : out;
 278             } else {
 279                 return List.nil();
 280             }
 281         }
 282 
 283         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 284             for (Env&lt;AttrContext&gt; env : envs) {
 285                 JCClassDecl tree = (JCClassDecl)env.tree;
 286 
 287                 queue.add(env);
 288 
 289                 JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 290                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());
 291                 try {
 292                     dependencies.push(env.enclClass.sym, phaseName);
 293                     runPhase(env);
 294                 } catch (CompletionFailure ex) {
 295                     chk.completionError(tree.pos(), ex);
 296                 } finally {
 297                     dependencies.pop();
 298                     deferredLintHandler.setPos(prevLintPos);
 299                     log.useSource(prev);
 300                 }
 301             }
 302         }
 303 
 304         protected abstract void runPhase(Env&lt;AttrContext&gt; env);
 305     }
 306 
 307     private final ImportsPhase completeClass = new ImportsPhase();
 308     private Phase topLevelPhase;
 309 
 310     /**Analyze import clauses.
 311      */
 312     private final class ImportsPhase extends Phase {
 313 
 314         public ImportsPhase() {
 315             super(CompletionCause.IMPORTS_PHASE, new HierarchyPhase());
 316         }
 317 
 318         Env&lt;AttrContext&gt; env;
 319         ImportFilter staticImportFilter;
 320         ImportFilter typeImportFilter;
 321         BiConsumer&lt;JCImport, CompletionFailure&gt; cfHandler =
 322                 (imp, cf) -&gt; chk.completionError(imp.pos(), cf);
 323 
 324         @Override
 325         protected void runPhase(Env&lt;AttrContext&gt; env) {
 326             JCClassDecl tree = env.enclClass;
 327             ClassSymbol sym = tree.sym;
 328 
 329             // If sym is a toplevel-class, make sure any import
 330             // clauses in its source file have been seen.
 331             if (sym.owner.kind == PCK) {
 332                 resolveImports(env.toplevel, env.enclosing(TOPLEVEL));
 333                 todo.append(env);
 334             }
 335 
 336             if (sym.owner.kind == TYP)
 337                 sym.owner.complete();
 338         }
 339 
 340         private void resolveImports(JCCompilationUnit tree, Env&lt;AttrContext&gt; env) {
 341             if (tree.starImportScope.isFilled()) {
 342                 // we must have already processed this toplevel
 343                 return;
 344             }
 345 
 346             ImportFilter prevStaticImportFilter = staticImportFilter;
 347             ImportFilter prevTypeImportFilter = typeImportFilter;
 348             DiagnosticPosition prevLintPos = deferredLintHandler.immediate();
 349             Lint prevLint = chk.setLint(lint);
 350             Env&lt;AttrContext&gt; prevEnv = this.env;
 351             try {
 352                 this.env = env;
 353                 final PackageSymbol packge = env.toplevel.packge;
 354                 this.staticImportFilter =
 355                         (origin, sym) -&gt; sym.isStatic() &amp;&amp;
 356                                          chk.importAccessible(sym, packge) &amp;&amp;
 357                                          sym.isMemberOf((TypeSymbol) origin.owner, types);
 358                 this.typeImportFilter =
 359                         (origin, sym) -&gt; sym.kind == TYP &amp;&amp;
 360                                          chk.importAccessible(sym, packge);
 361 
 362                 // Import-on-demand java.lang.
 363                 PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);
 364                 if (javaLang.members().isEmpty() &amp;&amp; !javaLang.exists())
 365                     throw new FatalError(diags.fragment(Fragments.FatalErrNoJavaLang));
 366                 importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env);
 367 
 368                 JCModuleDecl decl = tree.getModuleDecl();
 369 
 370                 // Process the package def and all import clauses.
 371                 if (tree.getPackage() != null &amp;&amp; decl == null)
 372                     checkClassPackageClash(tree.getPackage());
 373 
 374                 for (JCImport imp : tree.getImports()) {
 375                     doImport(imp);
 376                 }
 377 
 378                 if (decl != null) {
 379                     //check @Deprecated:
 380                     markDeprecated(decl.sym, decl.mods.annotations, env);
 381                     // process module annotations
 382                     annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, null);
 383                 }
 384             } finally {
 385                 this.env = prevEnv;
 386                 chk.setLint(prevLint);
 387                 deferredLintHandler.setPos(prevLintPos);
 388                 this.staticImportFilter = prevStaticImportFilter;
 389                 this.typeImportFilter = prevTypeImportFilter;
 390             }
 391         }
 392 
 393         private void checkClassPackageClash(JCPackageDecl tree) {
 394             // check that no class exists with same fully qualified name as
 395             // toplevel package
 396             if (checkClash &amp;&amp; tree.pid != null) {
 397                 Symbol p = env.toplevel.packge;
 398                 while (p.owner != syms.rootPackage) {
 399                     p.owner.complete(); // enter all class members of p
 400                     //need to lookup the owning module/package:
 401                     PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, p.owner.getQualifiedName());
 402                     if (syms.getClass(pack.modle, p.getQualifiedName()) != null) {
 403                         log.error(tree.pos,
 404                                   Errors.PkgClashesWithClassOfSameName(p));
 405                     }
 406                     p = p.owner;
 407                 }
 408             }
 409             // process package annotations
 410             annotate.annotateLater(tree.annotations, env, env.toplevel.packge, null);
 411         }
 412 
 413         private void doImport(JCImport tree) {
 414             JCFieldAccess imp = (JCFieldAccess)tree.qualid;
 415             Name name = TreeInfo.name(imp);
 416 
 417             // Create a local environment pointing to this tree to disable
 418             // effects of other imports in Resolve.findGlobalType
 419             Env&lt;AttrContext&gt; localEnv = env.dup(tree);
 420 
 421             TypeSymbol p = attr.attribImportQualifier(tree, localEnv).tsym;
 422             if (name == names.asterisk) {
 423                 // Import on demand.
 424                 chk.checkCanonical(imp.selected);
 425                 if (tree.staticImport)
 426                     importStaticAll(tree, p, env);
 427                 else
 428                     importAll(tree, p, env);
 429             } else {
 430                 // Named type import.
 431                 if (tree.staticImport) {
 432                     importNamedStatic(tree, p, name, localEnv);
 433                     chk.checkCanonical(imp.selected);
 434                 } else {
 435                     Type importedType = attribImportType(imp, localEnv);
 436                     Type originalType = importedType.getOriginalType();
 437                     TypeSymbol c = originalType.hasTag(CLASS) ? originalType.tsym : importedType.tsym;
 438                     chk.checkCanonical(imp);
 439                     importNamed(tree.pos(), c, env, tree);
 440                 }
 441             }
 442         }
 443 
 444         Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
 445             Assert.check(completionEnabled);
 446             Lint prevLint = chk.setLint(allowDeprecationOnImport ?
 447                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));
 448             try {
 449                 // To prevent deep recursion, suppress completion of some
 450                 // types.
 451                 completionEnabled = false;
 452                 return attr.attribType(tree, env);
 453             } finally {
 454                 completionEnabled = true;
 455                 chk.setLint(prevLint);
 456             }
 457         }
 458 
 459         /** Import all classes of a class or package on demand.
 460          *  @param imp           The import that is being handled.
 461          *  @param tsym          The class or package the members of which are imported.
 462          *  @param env           The env in which the imported classes will be entered.
 463          */
 464         private void importAll(JCImport imp,
 465                                final TypeSymbol tsym,
 466                                Env&lt;AttrContext&gt; env) {
 467             env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);
 468         }
 469 
 470         /** Import all static members of a class or package on demand.
 471          *  @param imp           The import that is being handled.
 472          *  @param tsym          The class or package the members of which are imported.
 473          *  @param env           The env in which the imported classes will be entered.
 474          */
 475         private void importStaticAll(JCImport imp,
 476                                      final TypeSymbol tsym,
 477                                      Env&lt;AttrContext&gt; env) {
 478             final StarImportScope toScope = env.toplevel.starImportScope;
 479             final TypeSymbol origin = tsym;
 480 
 481             toScope.importAll(types, origin.members(), staticImportFilter, imp, cfHandler);
 482         }
 483 
 484         /** Import statics types of a given name.  Non-types are handled in Attr.
 485          *  @param imp           The import that is being handled.
 486          *  @param tsym          The class from which the name is imported.
 487          *  @param name          The (simple) name being imported.
 488          *  @param env           The environment containing the named import
 489          *                  scope to add to.
 490          */
 491         private void importNamedStatic(final JCImport imp,
 492                                        final TypeSymbol tsym,
 493                                        final Name name,
 494                                        final Env&lt;AttrContext&gt; env) {
 495             if (tsym.kind != TYP) {
 496                 log.error(DiagnosticFlag.RECOVERABLE, imp.pos(), Errors.StaticImpOnlyClassesAndInterfaces);
 497                 return;
 498             }
 499 
 500             final NamedImportScope toScope = env.toplevel.namedImportScope;
 501             final Scope originMembers = tsym.members();
 502 
 503             imp.importScope = toScope.importByName(types, originMembers, name, staticImportFilter, imp, cfHandler);
 504         }
 505 
 506         /** Import given class.
 507          *  @param pos           Position to be used for error reporting.
 508          *  @param tsym          The class to be imported.
 509          *  @param env           The environment containing the named import
 510          *                  scope to add to.
 511          */
 512         private void importNamed(DiagnosticPosition pos, final Symbol tsym, Env&lt;AttrContext&gt; env, JCImport imp) {
 513             if (tsym.kind == TYP)
 514                 imp.importScope = env.toplevel.namedImportScope.importType(tsym.owner.members(), tsym.owner.members(), tsym);
 515         }
 516 
 517     }
 518 
 519     /**Defines common utility methods used by the HierarchyPhase and HeaderPhase.
 520      */
 521     private abstract class AbstractHeaderPhase extends Phase {
 522 
 523         public AbstractHeaderPhase(CompletionCause phaseName, Phase next) {
 524             super(phaseName, next);
 525         }
 526 
 527         protected Env&lt;AttrContext&gt; baseEnv(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 528             WriteableScope baseScope = WriteableScope.create(tree.sym);
 529             //import already entered local classes into base scope
 530             for (Symbol sym : env.outer.info.scope.getSymbols(NON_RECURSIVE)) {
 531                 if (sym.isLocal()) {
 532                     baseScope.enter(sym);
 533                 }
 534             }
 535             //import current type-parameters into base scope
 536             if (tree.typarams != null)
 537                 for (List&lt;JCTypeParameter&gt; typarams = tree.typarams;
 538                      typarams.nonEmpty();
 539                      typarams = typarams.tail)
 540                     baseScope.enter(typarams.head.type.tsym);
 541             Env&lt;AttrContext&gt; outer = env.outer; // the base clause can&#39;t see members of this class
 542             Env&lt;AttrContext&gt; localEnv = outer.dup(tree, outer.info.dup(baseScope));
 543             localEnv.baseClause = true;
 544             localEnv.outer = outer;
 545             localEnv.info.isSelfCall = false;
 546             return localEnv;
 547         }
 548 
 549         /** Generate a base clause for an enum type.
 550          *  @param pos              The position for trees and diagnostics, if any
 551          *  @param c                The class symbol of the enum
 552          */
 553         protected  JCExpression enumBase(int pos, ClassSymbol c) {
 554             JCExpression result = make.at(pos).
 555                 TypeApply(make.QualIdent(syms.enumSym),
 556                           List.of(make.Type(c.type)));
 557             return result;
 558         }
 559 
 560         protected Type modelMissingTypes(Env&lt;AttrContext&gt; env, Type t, final JCExpression tree, final boolean interfaceExpected) {
 561             if (!t.hasTag(ERROR))
 562                 return t;
 563 
 564             return new ErrorType(t.getOriginalType(), t.tsym) {
 565                 private Type modelType;
 566 
 567                 @Override
 568                 public Type getModelType() {
 569                     if (modelType == null)
 570                         modelType = new Synthesizer(env.toplevel.modle, getOriginalType(), interfaceExpected).visit(tree);
 571                     return modelType;
 572                 }
 573             };
 574         }
 575             // where:
 576             private class Synthesizer extends JCTree.Visitor {
 577                 ModuleSymbol msym;
 578                 Type originalType;
 579                 boolean interfaceExpected;
 580                 List&lt;ClassSymbol&gt; synthesizedSymbols = List.nil();
 581                 Type result;
 582 
 583                 Synthesizer(ModuleSymbol msym, Type originalType, boolean interfaceExpected) {
 584                     this.msym = msym;
 585                     this.originalType = originalType;
 586                     this.interfaceExpected = interfaceExpected;
 587                 }
 588 
 589                 Type visit(JCTree tree) {
 590                     tree.accept(this);
 591                     return result;
 592                 }
 593 
 594                 List&lt;Type&gt; visit(List&lt;? extends JCTree&gt; trees) {
 595                     ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 596                     for (JCTree t: trees)
 597                         lb.append(visit(t));
 598                     return lb.toList();
 599                 }
 600 
 601                 @Override
 602                 public void visitTree(JCTree tree) {
 603                     result = syms.errType;
 604                 }
 605 
 606                 @Override
 607                 public void visitIdent(JCIdent tree) {
 608                     if (!tree.type.hasTag(ERROR)) {
 609                         result = tree.type;
 610                     } else {
 611                         result = synthesizeClass(tree.name, msym.unnamedPackage).type;
 612                     }
 613                 }
 614 
 615                 @Override
 616                 public void visitSelect(JCFieldAccess tree) {
 617                     if (!tree.type.hasTag(ERROR)) {
 618                         result = tree.type;
 619                     } else {
 620                         Type selectedType;
 621                         boolean prev = interfaceExpected;
 622                         try {
 623                             interfaceExpected = false;
 624                             selectedType = visit(tree.selected);
 625                         } finally {
 626                             interfaceExpected = prev;
 627                         }
 628                         ClassSymbol c = synthesizeClass(tree.name, selectedType.tsym);
 629                         result = c.type;
 630                     }
 631                 }
 632 
 633                 @Override
 634                 public void visitTypeApply(JCTypeApply tree) {
 635                     if (!tree.type.hasTag(ERROR)) {
 636                         result = tree.type;
 637                     } else {
 638                         ClassType clazzType = (ClassType) visit(tree.clazz);
 639                         if (synthesizedSymbols.contains(clazzType.tsym))
 640                             synthesizeTyparams((ClassSymbol) clazzType.tsym, tree.arguments.size());
 641                         final List&lt;Type&gt; actuals = visit(tree.arguments);
 642                         result = new ErrorType(tree.type, clazzType.tsym) {
 643                             @Override @DefinedBy(Api.LANGUAGE_MODEL)
 644                             public List&lt;Type&gt; getTypeArguments() {
 645                                 return actuals;
 646                             }
 647                         };
 648                     }
 649                 }
 650 
 651                 ClassSymbol synthesizeClass(Name name, Symbol owner) {
 652                     int flags = interfaceExpected ? INTERFACE : 0;
 653                     ClassSymbol c = new ClassSymbol(flags, name, owner);
 654                     c.members_field = new Scope.ErrorScope(c);
 655                     c.type = new ErrorType(originalType, c) {
 656                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 657                         public List&lt;Type&gt; getTypeArguments() {
 658                             return typarams_field;
 659                         }
 660                     };
 661                     synthesizedSymbols = synthesizedSymbols.prepend(c);
 662                     return c;
 663                 }
 664 
 665                 void synthesizeTyparams(ClassSymbol sym, int n) {
 666                     ClassType ct = (ClassType) sym.type;
 667                     Assert.check(ct.typarams_field.isEmpty());
 668                     if (n == 1) {
 669                         TypeVar v = new TypeVar(names.fromString(&quot;T&quot;), sym, syms.botType);
 670                         ct.typarams_field = ct.typarams_field.prepend(v);
 671                     } else {
 672                         for (int i = n; i &gt; 0; i--) {
 673                             TypeVar v = new TypeVar(names.fromString(&quot;T&quot; + i), sym,
 674                                                     syms.botType);
 675                             ct.typarams_field = ct.typarams_field.prepend(v);
 676                         }
 677                     }
 678                 }
 679             }
 680 
 681         protected void attribSuperTypes(Env&lt;AttrContext&gt; env, Env&lt;AttrContext&gt; baseEnv) {
 682             JCClassDecl tree = env.enclClass;
 683             ClassSymbol sym = tree.sym;
 684             ClassType ct = (ClassType)sym.type;
 685             // Determine supertype.
 686             Type supertype;
 687             JCExpression extending;
 688             final boolean isValueType = (tree.mods.flags &amp; Flags.VALUE) != 0;
 689 
 690             if (tree.extending != null) {
 691                 extending = clearTypeParams(tree.extending);
 692                 supertype = attr.attribBase(extending, baseEnv, true, false, true);
 693                 if (supertype == syms.recordType) {
 694                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));
 695                 }
 696             } else {
 697                 extending = null;
 698                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 699                 ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
 700                                   true, false, false)
 701                 : (sym.fullname == names.java_lang_Object)
 702                 ? Type.noType
 703                 : sym.isRecord() ? syms.recordType : syms.objectType;
 704             }
 705             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 706 
<a name="3" id="anc3"></a><span class="line-removed"> 707             Type interfaceToInject = Type.noType;</span>
<span class="line-removed"> 708             if (injectTopInterfaceTypes) {</span>
<span class="line-removed"> 709                 if (isValueType || types.isValue(supertype)) {</span>
<span class="line-removed"> 710                     interfaceToInject = syms.inlineObjectType;</span>
<span class="line-removed"> 711                 } else if ((sym.flags_field &amp; (INTERFACE | ABSTRACT)) == 0) { // skip interfaces, abstract classes and annotations.</span>
<span class="line-removed"> 712                     if (sym.fullname != names.java_lang_Object) {</span>
<span class="line-removed"> 713                         interfaceToInject = syms.identityObjectType;</span>
<span class="line-removed"> 714                     }</span>
<span class="line-removed"> 715                 }</span>
<span class="line-removed"> 716             }</span>
<span class="line-removed"> 717 </span>
 718             // Determine interfaces.
 719             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 720             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 721             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 722             for (JCExpression iface : interfaceTrees) {
 723                 iface = clearTypeParams(iface);
 724                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
<a name="4" id="anc4"></a><span class="line-removed"> 725                 if (it.tsym == interfaceToInject.tsym) {</span>
<span class="line-removed"> 726                     interfaceToInject = Type.noType;</span>
<span class="line-removed"> 727                 }</span>
 728                 if (it.hasTag(CLASS)) {
 729                     interfaces.append(it);
 730                     if (all_interfaces != null) all_interfaces.append(it);
 731                 } else {
 732                     if (all_interfaces == null)
 733                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 734                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 735                 }
 736             }
 737 
 738             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 739                 ct.interfaces_field = List.of(syms.annotationType);
 740                 ct.all_interfaces_field = ct.interfaces_field;
 741             }  else {
<a name="5" id="anc5"></a><span class="line-removed"> 742                 if (interfaceToInject != Type.noType) {</span>
<span class="line-removed"> 743                     interfaces.append(interfaceToInject);</span>
<span class="line-removed"> 744                 }</span>
 745                 ct.interfaces_field = interfaces.toList();
 746                 ct.all_interfaces_field = (all_interfaces == null)
 747                         ? ct.interfaces_field : all_interfaces.toList();
 748             }
 749             if (ct.isValue()) {
 750                 ClassSymbol cSym = (ClassSymbol) ct.tsym;
 751                 if (cSym.projection != null) {
 752                     ClassType projectedType = (ClassType) cSym.projection.type;
 753                     projectedType.supertype_field = ct.supertype_field;
 754                     projectedType.interfaces_field = ct.interfaces_field;
 755                     projectedType.all_interfaces_field = ct.all_interfaces_field;
 756                 }
 757             }
 758         }
 759             //where:
 760             protected JCExpression clearTypeParams(JCExpression superType) {
 761                 return superType;
 762             }
 763     }
 764 
 765     private final class HierarchyPhase extends AbstractHeaderPhase implements Completer {
 766 
 767         public HierarchyPhase() {
 768             super(CompletionCause.HIERARCHY_PHASE, new HeaderPhase());
 769         }
 770 
 771         @Override
 772         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 773             //The ClassSymbols in the envs list may not be in the dependency order.
 774             //To get proper results, for every class or interface C, the supertypes of
 775             //C must be processed by the HierarchyPhase phase before C.
 776             //To achieve that, the HierarchyPhase is registered as the Completer for
 777             //all the classes first, and then all the classes are completed.
 778             for (Env&lt;AttrContext&gt; env : envs) {
 779                 env.enclClass.sym.completer = this;
 780             }
 781             for (Env&lt;AttrContext&gt; env : envs) {
 782                 env.enclClass.sym.complete();
 783             }
 784         }
 785 
 786         @Override
 787         protected void runPhase(Env&lt;AttrContext&gt; env) {
 788             JCClassDecl tree = env.enclClass;
 789             ClassSymbol sym = tree.sym;
 790             ClassType ct = (ClassType)sym.type;
 791 
 792             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 793 
 794             attribSuperTypes(env, baseEnv);
 795 
 796             if (sym.fullname == names.java_lang_Object) {
 797                 if (tree.extending != null) {
 798                     chk.checkNonCyclic(tree.extending.pos(),
 799                                        ct.supertype_field);
 800                     ct.supertype_field = Type.noType;
 801                 }
 802                 else if (tree.implementing.nonEmpty()) {
 803                     chk.checkNonCyclic(tree.implementing.head.pos(),
 804                                        ct.interfaces_field.head);
 805                     ct.interfaces_field = List.nil();
 806                 }
 807             }
 808 
 809             markDeprecated(sym, tree.mods.annotations, baseEnv);
 810 
 811             chk.checkNonCyclicDecl(tree);
 812         }
 813             //where:
 814             @Override
 815             protected JCExpression clearTypeParams(JCExpression superType) {
 816                 switch (superType.getTag()) {
 817                     case TYPEAPPLY:
 818                         return ((JCTypeApply) superType).clazz;
 819                 }
 820 
 821                 return superType;
 822             }
 823 
 824         @Override
 825         public void complete(Symbol sym) throws CompletionFailure {
 826             Assert.check((topLevelPhase instanceof ImportsPhase) ||
 827                          (topLevelPhase == this));
 828 
 829             if (topLevelPhase != this) {
 830                 //only do the processing based on dependencies in the HierarchyPhase:
 831                 sym.completer = this;
 832                 return ;
 833             }
 834 
 835             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 836 
 837             super.doCompleteEnvs(List.of(env));
 838         }
 839 
 840     }
 841 
 842     private final class HeaderPhase extends AbstractHeaderPhase {
 843 
 844         public HeaderPhase() {
 845             super(CompletionCause.HEADER_PHASE, new RecordPhase());
 846         }
 847 
 848         @Override
 849         protected void runPhase(Env&lt;AttrContext&gt; env) {
 850             JCClassDecl tree = env.enclClass;
 851             ClassSymbol sym = tree.sym;
 852             ClassType ct = (ClassType)sym.type;
 853 
 854             // create an environment for evaluating the base clauses
 855             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 856 
 857             if (tree.extending != null)
 858                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 859             for (JCExpression impl : tree.implementing)
 860                 annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());
 861             annotate.flush();
 862 
 863             attribSuperTypes(env, baseEnv);
 864 
 865             Set&lt;Type&gt; interfaceSet = new HashSet&lt;&gt;();
 866 
 867             for (JCExpression iface : tree.implementing) {
 868                 Type it = iface.type;
 869                 if (it.hasTag(CLASS))
 870                     chk.checkNotRepeated(iface.pos(), types.erasure(it), interfaceSet);
 871             }
 872 
 873             annotate.annotateLater(tree.mods.annotations, baseEnv,
 874                         sym, tree.pos());
 875             attr.attribTypeVariables(tree.typarams, baseEnv, false);
 876 
 877             for (JCTypeParameter tp : tree.typarams)
 878                 annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());
 879 
 880             // check that no package exists with same fully qualified name,
 881             // but admit classes in the unnamed package which have the same
 882             // name as a top-level package.
 883             if (checkClash &amp;&amp;
 884                 sym.owner.kind == PCK &amp;&amp; sym.owner != env.toplevel.modle.unnamedPackage &amp;&amp;
 885                 syms.packageExists(env.toplevel.modle, sym.fullname)) {
 886                 log.error(tree.pos, Errors.ClashWithPkgOfSameName(Kinds.kindName(sym),sym));
 887             }
 888             if (sym.owner.kind == PCK &amp;&amp; (sym.flags_field &amp; PUBLIC) == 0 &amp;&amp;
 889                 !env.toplevel.sourcefile.isNameCompatible(sym.name.toString(),JavaFileObject.Kind.SOURCE)) {
 890                 sym.flags_field |= AUXILIARY;
 891             }
 892         }
 893     }
 894 
 895     private abstract class AbstractMembersPhase extends Phase {
 896 
 897         public AbstractMembersPhase(CompletionCause completionCause, Phase next) {
 898             super(completionCause, next);
 899         }
 900 
 901         private boolean completing;
 902         private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
 903 
 904         @Override
 905         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 906             todo = todo.prependList(envs);
 907             if (completing) {
 908                 return ; //the top-level invocation will handle all envs
 909             }
 910             boolean prevCompleting = completing;
 911             completing = true;
 912             try {
 913                 while (todo.nonEmpty()) {
 914                     Env&lt;AttrContext&gt; head = todo.head;
 915                     todo = todo.tail;
 916                     super.doCompleteEnvs(List.of(head));
 917                 }
 918             } finally {
 919                 completing = prevCompleting;
 920             }
 921         }
 922 
 923         void enterThisAndSuper(ClassSymbol sym, Env&lt;AttrContext&gt; env) {
 924             ClassType ct = (ClassType)sym.type;
 925             // enter symbols for &#39;this&#39; into current scope.
 926             VarSymbol thisSym =
 927                     new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);
 928             thisSym.pos = Position.FIRSTPOS;
 929             env.info.scope.enter(thisSym);
 930             // if this is a class, enter symbol for &#39;super&#39; into current scope.
 931             if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
 932                     ct.supertype_field.hasTag(CLASS)) {
 933                 VarSymbol superSym =
 934                         new VarSymbol(FINAL | HASINIT, names._super,
 935                                 ct.supertype_field, sym);
 936                 superSym.pos = Position.FIRSTPOS;
 937                 env.info.scope.enter(superSym);
 938             }
 939         }
 940     }
 941 
 942     private final class RecordPhase extends AbstractMembersPhase {
 943 
 944         public RecordPhase() {
 945             super(CompletionCause.RECORD_PHASE, new MembersPhase());
 946         }
 947 
 948         @Override
 949         protected void runPhase(Env&lt;AttrContext&gt; env) {
 950             JCClassDecl tree = env.enclClass;
 951             ClassSymbol sym = tree.sym;
 952             if ((sym.flags_field &amp; RECORD) != 0) {
 953                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
 954                 memberEnter.memberEnter(fields, env);
 955                 for (JCVariableDecl field : fields) {
 956                     sym.getRecordComponent(field, true,
 957                             field.mods.annotations.isEmpty() ?
 958                                     List.nil() :
 959                                     new TreeCopier&lt;JCTree&gt;(make.at(field.pos)).copy(field.mods.annotations));
 960                 }
 961 
 962                 enterThisAndSuper(sym, env);
 963 
 964                 // lets enter all constructors
 965                 for (JCTree def : tree.defs) {
 966                     if (TreeInfo.isConstructor(def)) {
 967                         memberEnter.memberEnter(def, env);
 968                     }
 969                 }
 970             }
 971         }
 972     }
 973 
 974     /** Enter member fields and methods of a class
 975      */
 976     private final class MembersPhase extends AbstractMembersPhase {
 977 
 978         public MembersPhase() {
 979             super(CompletionCause.MEMBERS_PHASE, null);
 980         }
 981 
 982         @Override
 983         protected void runPhase(Env&lt;AttrContext&gt; env) {
 984             JCClassDecl tree = env.enclClass;
 985             ClassSymbol sym = tree.sym;
 986             ClassType ct = (ClassType)sym.type;
 987 
 988             // Add default constructor if needed.
 989             DefaultConstructorHelper helper = getDefaultConstructorHelper(env);
 990             if (helper != null) {
 991                 JCTree constrDef = defaultConstructor(make.at(tree.pos), helper);
 992                 tree.defs = tree.defs.prepend(constrDef);
 993             }
 994             if (!sym.isRecord()) {
 995                 enterThisAndSuper(sym, env);
 996             }
 997 
 998             if (!tree.typarams.isEmpty()) {
 999                 for (JCTypeParameter tvar : tree.typarams) {
1000                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
1001                 }
1002             }
1003 
1004             finishClass(tree, env);
1005 
1006             if (allowTypeAnnos) {
1007                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
1008                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
1009             }
1010         }
1011 
1012         DefaultConstructorHelper getDefaultConstructorHelper(Env&lt;AttrContext&gt; env) {
1013             JCClassDecl tree = env.enclClass;
1014             ClassSymbol sym = tree.sym;
1015             DefaultConstructorHelper helper = null;
1016             boolean isClassWithoutInit = (sym.flags() &amp; INTERFACE) == 0 &amp;&amp; !TreeInfo.hasConstructors(tree.defs);
1017             boolean isRecord = sym.isRecord();
1018             if (isClassWithoutInit &amp;&amp; !isRecord) {
1019                 helper = new BasicConstructorHelper(sym);
1020                 if (sym.name.isEmpty()) {
1021                     JCNewClass nc = (JCNewClass)env.next.tree;
1022                     if (nc.constructor != null) {
1023                         if (nc.constructor.kind != ERR) {
1024                             helper = new AnonClassConstructorHelper(sym, (MethodSymbol)nc.constructor, nc.encl);
1025                         } else {
1026                             helper = null;
1027                         }
1028                     }
1029                 }
1030             }
1031             if (isRecord) {
1032                 JCMethodDecl canonicalInit = null;
1033                 if (isClassWithoutInit || (canonicalInit = getCanonicalConstructorDecl(env.enclClass)) == null) {
1034                     helper = new RecordConstructorHelper(sym, TreeInfo.recordFields(tree));
1035                 }
1036                 if (canonicalInit != null) {
1037                     canonicalInit.sym.flags_field |= Flags.RECORD;
1038                 }
1039             }
1040             return helper;
1041         }
1042 
1043         /** Enter members for a class.
1044          */
1045         void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1046             if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
1047                 !tree.sym.type.hasTag(ERROR) &amp;&amp;
1048                 (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
1049                 addEnumMembers(tree, env);
1050             }
1051             boolean isRecord = (tree.sym.flags_field &amp; RECORD) != 0;
1052             List&lt;JCTree&gt; alreadyEntered = null;
1053             if (isRecord) {
1054                 alreadyEntered = List.convert(JCTree.class, TreeInfo.recordFields(tree));
1055                 alreadyEntered = alreadyEntered.prependList(tree.defs.stream()
1056                         .filter(t -&gt; TreeInfo.isConstructor(t) &amp;&amp;
1057                                 ((JCMethodDecl)t).sym != null &amp;&amp;
1058                                 (((JCMethodDecl)t).sym.flags_field &amp; Flags.GENERATEDCONSTR) == 0).collect(List.collector()));
1059             }
1060             List&lt;JCTree&gt; defsToEnter = isRecord ?
1061                     tree.defs.diff(alreadyEntered) : tree.defs;
1062             memberEnter.memberEnter(defsToEnter, env);
1063             List&lt;JCTree&gt; defsBeforeAddingNewMembers = tree.defs;
1064             if (isRecord) {
1065                 addRecordMembersIfNeeded(tree, env);
1066             }
1067             if ((tree.mods.flags &amp; (Flags.VALUE | Flags.INTERFACE)) == Flags.VALUE &amp;&amp; !tree.sym.type.hasTag(ERROR)) {
1068                 addValueMembers(tree, env);
1069             }
1070             if (tree.sym.isAnnotationType()) {
1071                 Assert.check(tree.sym.isCompleted());
1072                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
1073             }
1074         }
1075 
1076         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {
1077             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());
1078             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);
1079             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {
1080                 /* here we are pushing the annotations present in the corresponding field down to the accessor
1081                  * it could be that some of those annotations are not applicable to the accessor, they will be striped
1082                  * away later at Check::validateAnnotation
1083                  */
1084                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos().isEmpty() ?
1085                         rec.getOriginalAnnos() :
1086                         new TreeCopier&lt;JCTree&gt;(make.at(tree.pos)).copy(rec.getOriginalAnnos());
1087                 JCMethodDecl getter = make.at(tree.pos).
1088                         MethodDef(
1089                                 make.Modifiers(Flags.PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),
1090                           tree.sym.name,
1091                           /* we need to special case for the case when the user declared the type as an ident
1092                            * if we don&#39;t do that then we can have issues if type annotations are applied to the
1093                            * return type: javac issues an error if a type annotation is applied to java.lang.String
1094                            * but applying a type annotation to String is kosher
1095                            */
1096                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),
1097                           List.nil(),
1098                           List.nil(),
1099                           List.nil(), // thrown
1100                           null,
1101                           null);
1102                 memberEnter.memberEnter(getter, env);
1103                 rec.accessor = getter.sym;
1104                 rec.accessorMeth = getter;
1105             } else if (implSym != null) {
1106                 rec.accessor = implSym;
1107             }
1108         }
1109 
1110         /** Add the implicit members for an enum type
1111          *  to the symbol table.
1112          */
1113         private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1114             JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
1115 
1116             JCMethodDecl values = make.
1117                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1118                           names.values,
1119                           valuesType,
1120                           List.nil(),
1121                           List.nil(),
1122                           List.nil(),
1123                           null,
1124                           null);
1125             memberEnter.memberEnter(values, env);
1126 
1127             JCMethodDecl valueOf = make.
1128                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1129                           names.valueOf,
1130                           make.Type(tree.sym.type),
1131                           List.nil(),
1132                           List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
1133                                                              Flags.MANDATED),
1134                                                 names.fromString(&quot;name&quot;),
1135                                                 make.Type(syms.stringType), null)),
1136                           List.nil(),
1137                           null,
1138                           null);
1139             memberEnter.memberEnter(valueOf, env);
1140         }
1141 
1142         /** Add the implicit members for a value type to the parse tree and the symbol table.
1143          */
1144         private void addValueMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1145 
1146             boolean requireHashCode = true, requireEquals = true, requireToString = true;
1147 
1148             for (JCTree def : tree.defs) {
1149                 if (def.getTag() == METHODDEF) {
1150                     JCMethodDecl methodDecl = (JCMethodDecl)def;
1151                     if (methodDecl.sym != null
1152                             &amp;&amp; methodDecl.sym.type != null
1153                             &amp;&amp; !methodDecl.sym.type.isErroneous()
1154                             &amp;&amp; (methodDecl.sym.flags() &amp; STATIC) == 0) {
1155                         final List&lt;Type&gt; parameterTypes = methodDecl.sym.type.getParameterTypes();
1156                         switch (parameterTypes.size()) {
1157                             case 0:
1158                                 String name = methodDecl.name.toString();
1159                                 if (name.equals(&quot;hashCode&quot;))
1160                                     requireHashCode = false;
1161                                 else if (name.equals(&quot;toString&quot;))
1162                                     requireToString = false;
1163                                 break;
1164                             case 1:
1165                                 name = methodDecl.name.toString();
1166                                 if (name.equals(&quot;equals&quot;) &amp;&amp; parameterTypes.head.tsym == syms.objectType.tsym)
1167                                     requireEquals = false;
1168                                 break;
1169                         }
1170                     }
1171                 }
1172             }
1173 
1174             make.at(tree.pos);
1175             // Make a body comprising { throw new RuntimeException(&quot;&quot;Internal error: This method must have been replaced by javac&quot;); }
1176             JCBlock body = make.Block(Flags.SYNTHETIC, List.of(make.Throw(
1177                     make.NewClass(null,
1178                             null,
1179                             make.Ident(names.fromString(&quot;RuntimeException&quot;)),
1180                             List.of(make.Literal(CLASS, &quot;Internal error: This method must have been replaced by javac&quot;)),
1181                             null))));
1182 
1183             if (requireHashCode) {
1184                 // public int hashCode() { throw new RuntimeException(message); }
1185                 JCMethodDecl hashCode = make.
1186                         MethodDef(make.Modifiers(Flags.PUBLIC | Flags.FINAL),
1187                                 names.hashCode,
1188                                 make.TypeIdent(TypeTag.INT),
1189                                 List.nil(),
1190                                 List.nil(),
1191                                 List.nil(), // thrown
1192                                 body,
1193                                 null);
1194                 memberEnter.memberEnter(hashCode, env);
1195                 tree.defs = tree.defs.append(hashCode);
1196             }
1197 
1198             if (requireEquals) {
1199                 // public boolean equals(Object o) { throw new RuntimeException(message); }
1200                 JCMethodDecl equals = make.
1201                         MethodDef(make.Modifiers(Flags.PUBLIC | Flags.FINAL),
1202                                 names.equals,
1203                                 make.TypeIdent(TypeTag.BOOLEAN),
1204                                 List.nil(),
1205                                 List.of(make.VarDef(make.Modifiers(PARAMETER), names.fromString(&quot;o&quot;), make.Ident(names.fromString(&quot;Object&quot;)), null )),
1206                                 List.nil(), // thrown
1207                                 body,
1208                                 null);
1209                 memberEnter.memberEnter(equals, env);
1210                 tree.defs = tree.defs.append(equals);
1211             }
1212 
1213             if (requireToString) {
1214                 // public String toString() { throw new RuntimeException(message); }
1215                 JCMethodDecl toString = make.
1216                         MethodDef(make.Modifiers(Flags.PUBLIC | Flags.FINAL),
1217                                 names.toString,
1218                                 make.Ident(names.fromString(&quot;String&quot;)),
1219                                 List.nil(),
1220                                 List.nil(),
1221                                 List.nil(), // thrown
1222                                 body,
1223                                 null);
1224                 memberEnter.memberEnter(toString, env);
1225                 tree.defs = tree.defs.append(toString);
1226             }
1227 
1228         }
1229 
1230         JCMethodDecl getCanonicalConstructorDecl(JCClassDecl tree) {
1231             // let&#39;s check if there is a constructor with exactly the same arguments as the record components
1232             List&lt;Type&gt; recordComponentErasedTypes = types.erasure(TreeInfo.recordFields(tree).map(vd -&gt; vd.sym.type));
1233             JCMethodDecl canonicalDecl = null;
1234             for (JCTree def : tree.defs) {
1235                 if (TreeInfo.isConstructor(def)) {
1236                     JCMethodDecl mdecl = (JCMethodDecl)def;
1237                     if (types.isSameTypes(types.erasure(mdecl.params.stream().map(v -&gt; v.sym.type).collect(List.collector())), recordComponentErasedTypes)) {
1238                         canonicalDecl = mdecl;
1239                         break;
1240                     }
1241                 }
1242             }
1243             return canonicalDecl;
1244         }
1245 
1246         /** Add the implicit members for a record
1247          *  to the symbol table.
1248          */
1249         private void addRecordMembersIfNeeded(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1250             if (lookupMethod(tree.sym, names.toString, List.nil()) == null) {
1251                 JCMethodDecl toString = make.
1252                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.GENERATED_MEMBER),
1253                               names.toString,
1254                               make.Type(syms.stringType),
1255                               List.nil(),
1256                               List.nil(),
1257                               List.nil(),
1258                               null,
1259                               null);
1260                 memberEnter.memberEnter(toString, env);
1261             }
1262 
1263             if (lookupMethod(tree.sym, names.hashCode, List.nil()) == null) {
1264                 JCMethodDecl hashCode = make.
1265                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1266                               names.hashCode,
1267                               make.Type(syms.intType),
1268                               List.nil(),
1269                               List.nil(),
1270                               List.nil(),
1271                               null,
1272                               null);
1273                 memberEnter.memberEnter(hashCode, env);
1274             }
1275 
1276             if (lookupMethod(tree.sym, names.equals, List.of(syms.objectType)) == null) {
1277                 JCMethodDecl equals = make.
1278                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1279                               names.equals,
1280                               make.Type(syms.booleanType),
1281                               List.nil(),
1282                               List.of(make.VarDef(make.Modifiers(Flags.PARAMETER),
1283                                                 names.fromString(&quot;o&quot;),
1284                                                 make.Type(syms.objectType), null)),
1285                               List.nil(),
1286                               null,
1287                               null);
1288                 memberEnter.memberEnter(equals, env);
1289             }
1290 
1291             // fields can&#39;t be varargs, lets remove the flag
1292             List&lt;JCVariableDecl&gt; recordFields = TreeInfo.recordFields(tree);
1293             for (JCVariableDecl field: recordFields) {
1294                 field.mods.flags &amp;= ~Flags.VARARGS;
1295                 field.sym.flags_field &amp;= ~Flags.VARARGS;
1296             }
1297             // now lets add the accessors
1298             recordFields.stream()
1299                     .filter(vd -&gt; (lookupMethod(syms.objectType.tsym, vd.name, List.nil()) == null))
1300                     .forEach(vd -&gt; addAccessor(vd, env));
1301         }
1302     }
1303 
1304     private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List&lt;Type&gt; argtypes) {
1305         for (Symbol s : tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1306             if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {
1307                 return (MethodSymbol) s;
1308             }
1309         }
1310         return null;
1311     }
1312 
1313 /* ***************************************************************************
1314  * tree building
1315  ****************************************************************************/
1316 
1317     interface DefaultConstructorHelper {
1318        Type constructorType();
1319        MethodSymbol constructorSymbol();
1320        Type enclosingType();
1321        TypeSymbol owner();
1322        List&lt;Name&gt; superArgs();
1323        default JCMethodDecl finalAdjustment(JCMethodDecl md) { return md; }
1324     }
1325 
1326     class BasicConstructorHelper implements DefaultConstructorHelper {
1327 
1328         TypeSymbol owner;
1329         Type constructorType;
1330         MethodSymbol constructorSymbol;
1331 
1332         BasicConstructorHelper(TypeSymbol owner) {
1333             this.owner = owner;
1334         }
1335 
1336         @Override
1337         public Type constructorType() {
1338             if (constructorType == null) {
1339                 constructorType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);
1340             }
1341             return constructorType;
1342         }
1343 
1344         @Override
1345         public MethodSymbol constructorSymbol() {
1346             if (constructorSymbol == null) {
1347                 long flags;
1348                 if ((owner().flags() &amp; ENUM) != 0 &amp;&amp;
1349                     (types.supertype(owner().type).tsym == syms.enumSym)) {
1350                     // constructors of true enums are private
1351                     flags = PRIVATE | GENERATEDCONSTR;
1352                 } else if ((owner().flags_field &amp; RECORD) != 0) {
1353                     // record constructors are public
1354                     flags = PUBLIC | GENERATEDCONSTR;
1355                 } else {
1356                     flags = (owner().flags() &amp; AccessFlags) | GENERATEDCONSTR;
1357                 }
1358                 constructorSymbol = new MethodSymbol(flags, names.init,
1359                     constructorType(), owner());
1360             }
1361             return constructorSymbol;
1362         }
1363 
1364         @Override
1365         public Type enclosingType() {
1366             return Type.noType;
1367     }
1368 
1369         @Override
1370         public TypeSymbol owner() {
1371             return owner;
1372         }
1373 
1374         @Override
1375         public List&lt;Name&gt; superArgs() {
1376             return List.nil();
1377             }
1378     }
1379 
1380     class AnonClassConstructorHelper extends BasicConstructorHelper {
1381 
1382         MethodSymbol constr;
1383         Type encl;
1384         boolean based = false;
1385 
1386         AnonClassConstructorHelper(TypeSymbol owner, MethodSymbol constr, JCExpression encl) {
1387             super(owner);
1388             this.constr = constr;
1389             this.encl = encl != null ? encl.type : Type.noType;
1390         }
1391 
1392         @Override
1393         public Type constructorType() {
1394             if (constructorType == null) {
1395                 Type ctype = types.memberType(owner.type, constr);
1396                 if (!enclosingType().hasTag(NONE)) {
1397                     ctype = types.createMethodTypeWithParameters(ctype, ctype.getParameterTypes().prepend(enclosingType()));
1398                     based = true;
1399                 }
1400                 constructorType = ctype;
1401             }
1402             return constructorType;
1403         }
1404 
1405         @Override
1406         public MethodSymbol constructorSymbol() {
1407             MethodSymbol csym = super.constructorSymbol();
1408             csym.flags_field |= ANONCONSTR | (constr.flags() &amp; VARARGS);
1409             csym.flags_field |= based ? ANONCONSTR_BASED : 0;
1410             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1411             List&lt;Type&gt; argtypes = constructorType().getParameterTypes();
1412             if (!enclosingType().hasTag(NONE)) {
1413                 argtypes = argtypes.tail;
1414                 params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));
1415             }
1416             if (constr.params != null) {
1417                 for (VarSymbol p : constr.params) {
1418                     params.add(new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym));
1419                     argtypes = argtypes.tail;
1420                 }
1421             }
1422             csym.params = params.toList();
1423             return csym;
1424         }
1425 
1426         @Override
1427         public Type enclosingType() {
1428             return encl;
1429         }
1430 
1431         @Override
1432         public List&lt;Name&gt; superArgs() {
1433             List&lt;JCVariableDecl&gt; params = make.Params(constructorType().getParameterTypes(), constructorSymbol());
1434             if (!enclosingType().hasTag(NONE)) {
1435                 params = params.tail;
1436             }
1437             return params.map(vd -&gt; vd.name);
1438         }
1439     }
1440 
1441     class RecordConstructorHelper extends BasicConstructorHelper {
1442 
1443         List&lt;VarSymbol&gt; recordFieldSymbols;
1444         List&lt;JCVariableDecl&gt; recordFieldDecls;
1445 
1446         RecordConstructorHelper(TypeSymbol owner, List&lt;JCVariableDecl&gt; recordFieldDecls) {
1447             super(owner);
1448             this.recordFieldDecls = recordFieldDecls;
1449             this.recordFieldSymbols = recordFieldDecls.map(vd -&gt; vd.sym);
1450         }
1451 
1452         @Override
1453         public Type constructorType() {
1454             if (constructorType == null) {
1455                 List&lt;Type&gt; argtypes = recordFieldSymbols.map(v -&gt; (v.flags_field &amp; Flags.VARARGS) != 0 ? types.elemtype(v.type) : v.type);
1456                 constructorType = new MethodType(argtypes, syms.voidType, List.nil(), syms.methodClass);
1457             }
1458             return constructorType;
1459         }
1460 
1461         @Override
1462         public MethodSymbol constructorSymbol() {
1463             MethodSymbol csym = super.constructorSymbol();
1464             /* if we have to generate a default constructor for records we will treat it as the compact one
1465              * to trigger field initialization later on
1466              */
1467             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;
1468             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1469             for (VarSymbol p : recordFieldSymbols) {
1470                 params.add(new VarSymbol(GENERATED_MEMBER | PARAMETER | RECORD | ((p.flags_field &amp; Flags.VARARGS) != 0 ? Flags.VARARGS : 0), p.name, p.type, csym));
1471             }
1472             csym.params = params.toList();
1473             csym.flags_field |= RECORD | PUBLIC;
1474             return csym;
1475         }
1476 
1477         @Override
1478         public JCMethodDecl finalAdjustment(JCMethodDecl md) {
1479             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;
1480             for (JCVariableDecl arg : md.params) {
1481                 /* at this point we are passing all the annotations in the field to the corresponding
1482                  * parameter in the constructor.
1483                  */
1484                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);
1485                 arg.mods.annotations = rc.getOriginalAnnos().isEmpty() ?
1486                         List.nil() :
1487                         new TreeCopier&lt;JCTree&gt;(make.at(arg.pos)).copy(rc.getOriginalAnnos());
1488                 arg.vartype = tmpRecordFieldDecls.head.vartype;
1489                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;
1490             }
1491             return md;
1492         }
1493     }
1494 
1495     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {
1496         Type initType = helper.constructorType();
1497         MethodSymbol initSym = helper.constructorSymbol();
1498         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1499         if (helper.owner().type != syms.objectType) {
1500             JCExpression meth;
1501             if (!helper.enclosingType().hasTag(NONE)) {
1502                 meth = make.Select(make.Ident(initSym.params.head), names._super);
1503             } else {
1504                 meth = make.Ident(names._super);
1505             }
1506             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?
1507                     make.Types(initType.getTypeArguments()) : null;
1508             JCStatement superCall = make.Exec(make.Apply(typeargs, meth, helper.superArgs().map(make::Ident)));
1509             stats.add(superCall);
1510         }
1511         JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));
1512         return helper.finalAdjustment(result);
1513     }
1514 
1515     /**
1516      * Mark sym deprecated if annotations contain @Deprecated annotation.
1517      */
1518     public void markDeprecated(Symbol sym, List&lt;JCAnnotation&gt; annotations, Env&lt;AttrContext&gt; env) {
1519         // In general, we cannot fully process annotations yet,  but we
1520         // can attribute the annotation types and then check to see if the
1521         // @Deprecated annotation is present.
1522         attr.attribAnnotationTypes(annotations, env);
1523         handleDeprecatedAnnotations(annotations, sym);
1524     }
1525 
1526     /**
1527      * If a list of annotations contains a reference to java.lang.Deprecated,
1528      * set the DEPRECATED flag.
1529      * If the annotation is marked forRemoval=true, also set DEPRECATED_REMOVAL.
1530      **/
1531     private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
1532         for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
1533             JCAnnotation a = al.head;
1534             if (a.annotationType.type == syms.deprecatedType) {
1535                 sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
1536                 setFlagIfAttributeTrue(a, sym, names.forRemoval, DEPRECATED_REMOVAL);
1537             } else if (a.annotationType.type == syms.previewFeatureType) {
1538                 sym.flags_field |= Flags.PREVIEW_API;
1539                 setFlagIfAttributeTrue(a, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1540             }
1541         }
1542     }
1543     //where:
1544         private void setFlagIfAttributeTrue(JCAnnotation a, Symbol sym, Name attribute, long flag) {
1545             a.args.stream()
1546                     .filter(e -&gt; e.hasTag(ASSIGN))
1547                     .map(e -&gt; (JCAssign) e)
1548                     .filter(assign -&gt; TreeInfo.name(assign.lhs) == attribute)
1549                     .findFirst()
1550                     .ifPresent(assign -&gt; {
1551                         JCExpression rhs = TreeInfo.skipParens(assign.rhs);
1552                         if (rhs.hasTag(LITERAL)
1553                                 &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {
1554                             sym.flags_field |= flag;
1555                         }
1556                     });
1557         }
1558 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
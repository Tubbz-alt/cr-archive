<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.valuetypes;
  25 
  26 import jdk.test.lib.Asserts;
  27 import java.lang.invoke.*;
  28 import java.lang.reflect.Method;
  29 import java.util.Arrays;
  30 
  31 /*
  32  * @test
  33  * @summary Test value type arrays
  34  * @library /testlibrary /test/lib /compiler/whitebox /
  35  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  36  * @compile TestArrays.java
  37  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  38  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  39  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  40  *                               compiler.valhalla.valuetypes.ValueTypeTest
  41  *                               compiler.valhalla.valuetypes.TestArrays
  42  */
  43 public class TestArrays extends ValueTypeTest {
  44     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  45     // a normal method invocation when encountering flattened arrays.
  46     private static void assertDeoptimizedByC2(Method m) {
  47         int CompLevel_none              = 0,         // Interpreter
  48             CompLevel_simple            = 1,         // C1
  49             CompLevel_limited_profile   = 2,         // C1, invocation &amp; backedge counters
  50             CompLevel_full_profile      = 3,         // C1, invocation &amp; backedge counters + mdo
  51             CompLevel_full_optimization = 4;         // C2 or JVMCI
  52 
  53         if (USE_COMPILER &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC &amp;&amp; WHITE_BOX.isMethodCompiled(m, false) &amp;&amp;
  54             WHITE_BOX.getMethodCompilationLevel(m, false) &gt;= CompLevel_full_optimization) {
  55             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  56         }
  57     }
  58 
  59     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
  60     @Override
  61     public String[] getExtraVMParameters(int scenario) {
  62         switch (scenario) {
  63         case 2: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  64         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:FlatArrayElemMaxFlatSize=-1&quot;, &quot;-XX:-UncommonNullCast&quot;};
  65         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  66         case 5: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  67         }
  68         return null;
  69     }
  70 
  71     public static void main(String[] args) throws Throwable {
  72         TestArrays test = new TestArrays();
  73         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  74     }
  75 
  76     // Helper methods
  77 
  78     protected long hash() {
  79         return hash(rI, rL);
  80     }
  81 
  82     protected long hash(int x, long y) {
  83         return MyValue1.createWithFieldsInline(x, y).hash();
  84     }
  85 
  86     // Test inline type array creation and initialization
  87     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
  88     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
  89     public MyValue1[] test1(int len) {
  90         MyValue1[] va = new MyValue1[len];
  91         for (int i = 0; i &lt; len; ++i) {
  92             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  93         }
  94         return va;
  95     }
  96 
  97     @DontCompile
  98     public void test1_verifier(boolean warmup) {
  99         int len = Math.abs(rI % 10);
 100         MyValue1[] va = test1(len);
 101         for (int i = 0; i &lt; len; ++i) {
 102             Asserts.assertEQ(va[i].hash(), hash());
 103         }
 104     }
 105 
 106     // Test creation of an inline type array and element access
 107     // TODO 8227588
 108     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 109     @Test(valid = InlineTypeArrayFlattenOff)
 110     public long test2() {
 111         MyValue1[] va = new MyValue1[1];
 112         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 113         return va[0].hash();
 114     }
 115 
 116     @DontCompile
 117     public void test2_verifier(boolean warmup) {
 118         long result = test2();
 119         Asserts.assertEQ(result, hash());
 120     }
 121 
 122     // Test receiving a value type array from the interpreter,
 123     // updating its elements in a loop and computing a hash.
 124     @Test(failOn = ALLOCA)
 125     public long test3(MyValue1[] va) {
 126         long result = 0;
 127         for (int i = 0; i &lt; 10; ++i) {
 128             result += va[i].hash();
 129             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 130         }
 131         return result;
 132     }
 133 
 134     @DontCompile
 135     public void test3_verifier(boolean warmup) {
 136         MyValue1[] va = new MyValue1[10];
 137         long expected = 0;
 138         for (int i = 0; i &lt; 10; ++i) {
 139             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 140             expected += va[i].hash();
 141         }
 142         long result = test3(va);
 143         Asserts.assertEQ(expected, result);
 144         for (int i = 0; i &lt; 10; ++i) {
 145             if (va[i].hash() != hash(rI + 1, rL + 1)) {
 146                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
 147             }
 148         }
 149     }
 150 
 151     // Test returning a value type array received from the interpreter
 152     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
 153     public MyValue1[] test4(MyValue1[] va) {
 154         return va;
 155     }
 156 
 157     @DontCompile
 158     public void test4_verifier(boolean warmup) {
 159         MyValue1[] va = new MyValue1[10];
 160         for (int i = 0; i &lt; 10; ++i) {
 161             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 162         }
 163         va = test4(va);
 164         for (int i = 0; i &lt; 10; ++i) {
 165             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 166         }
 167     }
 168 
 169     // Merge value type arrays created from two branches
 170     @Test
 171     public MyValue1[] test5(boolean b) {
 172         MyValue1[] va;
 173         if (b) {
 174             va = new MyValue1[5];
 175             for (int i = 0; i &lt; 5; ++i) {
 176                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
 177             }
 178         } else {
 179             va = new MyValue1[10];
 180             for (int i = 0; i &lt; 10; ++i) {
 181                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
 182             }
 183         }
 184         long sum = va[0].hashInterpreted();
 185         if (b) {
 186             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
 187         } else {
 188             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
 189         }
 190         return va;
 191     }
 192 
 193     @DontCompile
 194     public void test5_verifier(boolean warmup) {
 195         MyValue1[] va = test5(true);
 196         Asserts.assertEQ(va.length, 5);
 197         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
 198         for (int i = 1; i &lt; 5; ++i) {
 199             Asserts.assertEQ(va[i].hash(), hash());
 200         }
 201         va = test5(false);
 202         Asserts.assertEQ(va.length, 10);
 203         Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));
 204         for (int i = 1; i &lt; 10; ++i) {
 205             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 206         }
 207     }
 208 
 209     // Test creation of value type array with single element
 210     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 211     public MyValue1 test6() {
 212         MyValue1[] va = new MyValue1[1];
 213         return va[0];
 214     }
 215 
 216     @DontCompile
 217     public void test6_verifier(boolean warmup) {
 218         MyValue1[] va = new MyValue1[1];
 219         MyValue1 v = test6();
 220         Asserts.assertEQ(v.hashPrimitive(), va[0].hashPrimitive());
 221     }
 222 
 223     // Test default initialization of value type arrays
 224     @Test(failOn = LOAD)
 225     public MyValue1[] test7(int len) {
 226         return new MyValue1[len];
 227     }
 228 
 229     @DontCompile
 230     public void test7_verifier(boolean warmup) {
 231         int len = Math.abs(rI % 10);
 232         MyValue1[] va = new MyValue1[len];
 233         MyValue1[] var = test7(len);
 234         for (int i = 0; i &lt; len; ++i) {
 235             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
 236         }
 237     }
 238 
 239     // Test creation of value type array with zero length
 240     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
 241     public MyValue1[] test8() {
 242         return new MyValue1[0];
 243     }
 244 
 245     @DontCompile
 246     public void test8_verifier(boolean warmup) {
 247         MyValue1[] va = test8();
 248         Asserts.assertEQ(va.length, 0);
 249     }
 250 
 251     static MyValue1[] test9_va;
 252 
 253     // Test that value type array loaded from field has correct type
 254     @Test(failOn = LOOP)
 255     public long test9() {
 256         return test9_va[0].hash();
 257     }
 258 
 259     @DontCompile
 260     public void test9_verifier(boolean warmup) {
 261         test9_va = new MyValue1[1];
 262         test9_va[0] = MyValue1.createWithFieldsInline(rI, rL);
 263         long result = test9();
 264         Asserts.assertEQ(result, hash());
 265     }
 266 
 267     // Multi-dimensional arrays
 268     @Test
 269     public MyValue1[][][] test10(int len1, int len2, int len3) {
 270         MyValue1[][][] arr = new MyValue1[len1][len2][len3];
 271         for (int i = 0; i &lt; len1; i++) {
 272             for (int j = 0; j &lt; len2; j++) {
 273                 for (int k = 0; k &lt; len3; k++) {
 274                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
 275                 }
 276             }
 277         }
 278         return arr;
 279     }
 280 
 281     @DontCompile
 282     public void test10_verifier(boolean warmup) {
 283         MyValue1[][][] arr = test10(2, 3, 4);
 284         for (int i = 0; i &lt; 2; i++) {
 285             for (int j = 0; j &lt; 3; j++) {
 286                 for (int k = 0; k &lt; 4; k++) {
 287                     Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());
 288                 }
 289             }
 290         }
 291     }
 292 
 293     @Test
 294     public void test11(MyValue1[][][] arr, long[] res) {
 295         int l = 0;
 296         for (int i = 0; i &lt; arr.length; i++) {
 297             for (int j = 0; j &lt; arr[i].length; j++) {
 298                 for (int k = 0; k &lt; arr[i][j].length; k++) {
 299                     res[l] = arr[i][j][k].hash();
 300                     l++;
 301                 }
 302             }
 303         }
 304     }
 305 
 306     @DontCompile
 307     public void test11_verifier(boolean warmup) {
 308         MyValue1[][][] arr = new MyValue1[2][3][4];
 309         long[] res = new long[2*3*4];
 310         long[] verif = new long[2*3*4];
 311         int l = 0;
 312         for (int i = 0; i &lt; 2; i++) {
 313             for (int j = 0; j &lt; 3; j++) {
 314                 for (int k = 0; k &lt; 4; k++) {
 315                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);
 316                     verif[l] = arr[i][j][k].hash();
 317                     l++;
 318                 }
 319             }
 320         }
 321         test11(arr, res);
 322         for (int i = 0; i &lt; verif.length; i++) {
 323             Asserts.assertEQ(res[i], verif[i]);
 324         }
 325     }
 326 
 327     // Array load out of bounds (upper bound) at compile time
 328     @Test
 329     public int test12() {
 330         int arraySize = Math.abs(rI) % 10;;
 331         MyValue1[] va = new MyValue1[arraySize];
 332 
 333         for (int i = 0; i &lt; arraySize; i++) {
 334             va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 335         }
 336 
 337         try {
 338             return va[arraySize + 1].x;
 339         } catch (ArrayIndexOutOfBoundsException e) {
 340             return rI;
 341         }
 342     }
 343 
 344     public void test12_verifier(boolean warmup) {
 345         Asserts.assertEQ(test12(), rI);
 346     }
 347 
 348     // Array load  out of bounds (lower bound) at compile time
 349     @Test
 350     public int test13() {
 351         int arraySize = Math.abs(rI) % 10;;
 352         MyValue1[] va = new MyValue1[arraySize];
 353 
 354         for (int i = 0; i &lt; arraySize; i++) {
 355             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
 356         }
 357 
 358         try {
 359             return va[-arraySize].x;
 360         } catch (ArrayIndexOutOfBoundsException e) {
 361             return rI;
 362         }
 363     }
 364 
 365     public void test13_verifier(boolean warmup) {
 366         Asserts.assertEQ(test13(), rI);
 367     }
 368 
 369     // Array load out of bound not known to compiler (both lower and upper bound)
 370     @Test
 371     public int test14(MyValue1[] va, int index)  {
 372         return va[index].x;
 373     }
 374 
 375     public void test14_verifier(boolean warmup) {
 376         int arraySize = Math.abs(rI) % 10;
 377         MyValue1[] va = new MyValue1[arraySize];
 378 
 379         for (int i = 0; i &lt; arraySize; i++) {
 380             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 381         }
 382 
 383         int result;
 384         for (int i = -20; i &lt; 20; i++) {
 385             try {
 386                 result = test14(va, i);
 387             } catch (ArrayIndexOutOfBoundsException e) {
 388                 result = rI;
 389             }
 390             Asserts.assertEQ(result, rI);
 391         }
 392     }
 393 
 394     // Array store out of bounds (upper bound) at compile time
 395     @Test
 396     public int test15() {
 397         int arraySize = Math.abs(rI) % 10;;
 398         MyValue1[] va = new MyValue1[arraySize];
 399 
 400         try {
 401             for (int i = 0; i &lt;= arraySize; i++) {
 402                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 403             }
 404             return rI - 1;
 405         } catch (ArrayIndexOutOfBoundsException e) {
 406             return rI;
 407         }
 408     }
 409 
 410     public void test15_verifier(boolean warmup) {
 411         Asserts.assertEQ(test15(), rI);
 412     }
 413 
 414     // Array store out of bounds (lower bound) at compile time
 415     @Test
 416     public int test16() {
 417         int arraySize = Math.abs(rI) % 10;;
 418         MyValue1[] va = new MyValue1[arraySize];
 419 
 420         try {
 421             for (int i = -1; i &lt;= arraySize; i++) {
 422                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 423             }
 424             return rI - 1;
 425         } catch (ArrayIndexOutOfBoundsException e) {
 426             return rI;
 427         }
 428     }
 429 
 430     public void test16_verifier(boolean warmup) {
 431         Asserts.assertEQ(test16(), rI);
 432     }
 433 
 434     // Array store out of bound not known to compiler (both lower and upper bound)
 435     @Test
 436     public int test17(MyValue1[] va, int index, MyValue1 vt)  {
 437         va[index] = vt;
 438         return va[index].x;
 439     }
 440 
 441     @DontCompile
 442     public void test17_verifier(boolean warmup) {
 443         int arraySize = Math.abs(rI) % 10;
 444         MyValue1[] va = new MyValue1[arraySize];
 445 
 446         for (int i = 0; i &lt; arraySize; i++) {
 447             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 448         }
 449 
 450         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 451         int result;
 452         for (int i = -20; i &lt; 20; i++) {
 453             try {
 454                 result = test17(va, i, vt);
 455             } catch (ArrayIndexOutOfBoundsException e) {
 456                 result = rI + 1;
 457             }
 458             Asserts.assertEQ(result, rI + 1);
 459         }
 460 
 461         for (int i = 0; i &lt; arraySize; i++) {
 462             Asserts.assertEQ(va[i].x, rI + 1);
 463         }
 464     }
 465 
 466     // clone() as stub call
 467     @Test
 468     public MyValue1[] test18(MyValue1[] va) {
 469         return va.clone();
 470     }
 471 
 472     @DontCompile
 473     public void test18_verifier(boolean warmup) {
 474         int len = Math.abs(rI) % 10;
 475         MyValue1[] va = new MyValue1[len];
 476         for (int i = 0; i &lt; len; ++i) {
 477             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 478         }
 479         MyValue1[] result = test18(va);
 480         for (int i = 0; i &lt; len; ++i) {
 481             Asserts.assertEQ(result[i].hash(), va[i].hash());
 482         }
 483     }
 484 
 485     // clone() as series of loads/stores
 486     static MyValue1[] test19_orig = null;
 487 
 488     @Test
 489     public MyValue1[] test19() {
 490         MyValue1[] va = new MyValue1[8];
 491         for (int i = 0; i &lt; va.length; ++i) {
 492             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 493         }
 494         test19_orig = va;
 495 
 496         return va.clone();
 497     }
 498 
 499     @DontCompile
 500     public void test19_verifier(boolean warmup) {
 501         MyValue1[] result = test19();
 502         for (int i = 0; i &lt; test19_orig.length; ++i) {
 503             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
 504         }
 505     }
 506 
 507     // arraycopy() of value type array with oop fields
 508     @Test
 509     public void test20(MyValue1[] src, MyValue1[] dst) {
 510         System.arraycopy(src, 0, dst, 0, src.length);
 511     }
 512 
 513     @DontCompile
 514     public void test20_verifier(boolean warmup) {
 515         int len = Math.abs(rI) % 10;
 516         MyValue1[] src = new MyValue1[len];
 517         MyValue1[] dst = new MyValue1[len];
 518         for (int i = 0; i &lt; len; ++i) {
 519             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 520         }
 521         test20(src, dst);
 522         for (int i = 0; i &lt; len; ++i) {
 523             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 524         }
 525     }
 526 
 527     // arraycopy() of value type array with no oop field
 528     @Test
 529     public void test21(MyValue2[] src, MyValue2[] dst) {
 530         System.arraycopy(src, 0, dst, 0, src.length);
 531     }
 532 
 533     @DontCompile
 534     public void test21_verifier(boolean warmup) {
 535         int len = Math.abs(rI) % 10;
 536         MyValue2[] src = new MyValue2[len];
 537         MyValue2[] dst = new MyValue2[len];
 538         for (int i = 0; i &lt; len; ++i) {
 539             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 540         }
 541         test21(src, dst);
 542         for (int i = 0; i &lt; len; ++i) {
 543             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 544         }
 545     }
 546 
 547     // arraycopy() of value type array with oop field and tightly
 548     // coupled allocation as dest
 549     @Test
 550     public MyValue1[] test22(MyValue1[] src) {
 551         MyValue1[] dst = new MyValue1[src.length];
 552         System.arraycopy(src, 0, dst, 0, src.length);
 553         return dst;
 554     }
 555 
 556     @DontCompile
 557     public void test22_verifier(boolean warmup) {
 558         int len = Math.abs(rI) % 10;
 559         MyValue1[] src = new MyValue1[len];
 560         for (int i = 0; i &lt; len; ++i) {
 561             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 562         }
 563         MyValue1[] dst = test22(src);
 564         for (int i = 0; i &lt; len; ++i) {
 565             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 566         }
 567     }
 568 
 569     // arraycopy() of value type array with oop fields and tightly
 570     // coupled allocation as dest
 571     @Test
 572     public MyValue1[] test23(MyValue1[] src) {
 573         MyValue1[] dst = new MyValue1[src.length + 10];
 574         System.arraycopy(src, 0, dst, 5, src.length);
 575         return dst;
 576     }
 577 
 578     @DontCompile
 579     public void test23_verifier(boolean warmup) {
 580         int len = Math.abs(rI) % 10;
 581         MyValue1[] src = new MyValue1[len];
 582         for (int i = 0; i &lt; len; ++i) {
 583             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 584         }
 585         MyValue1[] dst = test23(src);
 586         for (int i = 5; i &lt; len; ++i) {
 587             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 588         }
 589     }
 590 
 591     // arraycopy() of value type array passed as Object
 592     @Test
 593     public void test24(MyValue1[] src, Object dst) {
 594         System.arraycopy(src, 0, dst, 0, src.length);
 595     }
 596 
 597     @DontCompile
 598     public void test24_verifier(boolean warmup) {
 599         int len = Math.abs(rI) % 10;
 600         MyValue1[] src = new MyValue1[len];
 601         MyValue1[] dst = new MyValue1[len];
 602         for (int i = 0; i &lt; len; ++i) {
 603             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 604         }
 605         test24(src, dst);
 606         for (int i = 0; i &lt; len; ++i) {
 607             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 608         }
 609     }
 610 
 611     // short arraycopy() with no oop field
 612     @Test
 613     public void test25(MyValue2[] src, MyValue2[] dst) {
 614         System.arraycopy(src, 0, dst, 0, 8);
 615     }
 616 
 617     @DontCompile
 618     public void test25_verifier(boolean warmup) {
 619         MyValue2[] src = new MyValue2[8];
 620         MyValue2[] dst = new MyValue2[8];
 621         for (int i = 0; i &lt; 8; ++i) {
 622             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 623         }
 624         test25(src, dst);
 625         for (int i = 0; i &lt; 8; ++i) {
 626             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 627         }
 628     }
 629 
 630     // short arraycopy() with oop fields
 631     @Test
 632     public void test26(MyValue1[] src, MyValue1[] dst) {
 633         System.arraycopy(src, 0, dst, 0, 8);
 634     }
 635 
 636     @DontCompile
 637     public void test26_verifier(boolean warmup) {
 638         MyValue1[] src = new MyValue1[8];
 639         MyValue1[] dst = new MyValue1[8];
 640         for (int i = 0; i &lt; 8; ++i) {
 641             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 642         }
 643         test26(src, dst);
 644         for (int i = 0; i &lt; 8; ++i) {
 645             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 646         }
 647     }
 648 
 649     // short arraycopy() with oop fields and offsets
 650     @Test
 651     public void test27(MyValue1[] src, MyValue1[] dst) {
 652         System.arraycopy(src, 1, dst, 2, 6);
 653     }
 654 
 655     @DontCompile
 656     public void test27_verifier(boolean warmup) {
 657         MyValue1[] src = new MyValue1[8];
 658         MyValue1[] dst = new MyValue1[8];
 659         for (int i = 0; i &lt; 8; ++i) {
 660             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 661         }
 662         test27(src, dst);
 663         for (int i = 2; i &lt; 8; ++i) {
 664             Asserts.assertEQ(src[i-1].hash(), dst[i].hash());
 665         }
 666     }
 667 
 668     // non escaping allocations
 669     // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed
 670     @Test(valid = ZGCOff, failOn = ALLOCA + LOOP + LOAD + TRAP)
 671     @Test(valid = ZGCOn)
 672     public MyValue2 test28() {
 673         MyValue2[] src = new MyValue2[10];
 674         src[0] = MyValue2.createWithFieldsInline(rI, false);
 675         MyValue2[] dst = (MyValue2[])src.clone();
 676         return dst[0];
 677     }
 678 
 679     @DontCompile
 680     public void test28_verifier(boolean warmup) {
 681         MyValue2 v = MyValue2.createWithFieldsInline(rI, false);
 682         MyValue2 result = test28();
 683         Asserts.assertEQ(result.hash(), v.hash());
 684     }
 685 
 686     // non escaping allocations
 687     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
 688     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOCA + LOOP + LOAD + TRAP)
 689     @Test(valid = InlineTypeArrayFlattenOff)
 690     public MyValue2 test29(MyValue2[] src) {
 691         MyValue2[] dst = new MyValue2[10];
 692         System.arraycopy(src, 0, dst, 0, 10);
 693         return dst[0];
 694     }
 695 
 696     @DontCompile
 697     public void test29_verifier(boolean warmup) {
 698         MyValue2[] src = new MyValue2[10];
 699         for (int i = 0; i &lt; 10; ++i) {
 700             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 701         }
 702         MyValue2 v = test29(src);
 703         Asserts.assertEQ(src[0].hash(), v.hash());
 704     }
 705 
 706     // non escaping allocation with uncommon trap that needs
 707     // eliminated value type array element as debug info
 708     @Test
 709     @Warmup(10000)
 710     public MyValue2 test30(MyValue2[] src, boolean flag) {
 711         MyValue2[] dst = new MyValue2[10];
 712         System.arraycopy(src, 0, dst, 0, 10);
 713         if (flag) { }
 714         return dst[0];
 715     }
 716 
 717     @DontCompile
 718     public void test30_verifier(boolean warmup) {
 719         MyValue2[] src = new MyValue2[10];
 720         for (int i = 0; i &lt; 10; ++i) {
 721             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 722         }
 723         MyValue2 v = test30(src, !warmup);
 724         Asserts.assertEQ(src[0].hash(), v.hash());
 725     }
 726 
 727     // non escaping allocation with memory phi
 728     // TODO 8227588
 729     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 730     @Test(valid = InlineTypeArrayFlattenOff)
 731     public long test31(boolean b, boolean deopt) {
 732         MyValue2[] src = new MyValue2[1];
 733         if (b) {
 734             src[0] = MyValue2.createWithFieldsInline(rI, true);
 735         } else {
 736             src[0] = MyValue2.createWithFieldsInline(rI, false);
 737         }
 738         if (deopt) {
 739             // uncommon trap
 740             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 741         }
 742         return src[0].hash();
 743     }
 744 
 745     @DontCompile
 746     public void test31_verifier(boolean warmup) {
 747         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, true);
 748         long result1 = test31(true, !warmup);
 749         Asserts.assertEQ(result1, v1.hash());
 750         MyValue2 v2 = MyValue2.createWithFieldsInline(rI, false);
 751         long result2 = test31(false, !warmup);
 752         Asserts.assertEQ(result2, v2.hash());
 753     }
 754 
 755     // Tests with Object arrays and clone/arraycopy
 756     // clone() as stub call
 757     @Test
 758     public Object[] test32(Object[] va) {
 759         return va.clone();
 760     }
 761 
 762     @DontCompile
 763     public void test32_verifier(boolean warmup) {
 764         int len = Math.abs(rI) % 10;
 765         MyValue1[] va = new MyValue1[len];
 766         for (int i = 0; i &lt; len; ++i) {
 767             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 768         }
 769         MyValue1[] result = (MyValue1[])test32(va);
 770         for (int i = 0; i &lt; len; ++i) {
 771             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
 772         }
 773     }
 774 
 775     @Test
 776     public Object[] test33(Object[] va) {
 777         return va.clone();
 778     }
 779 
 780     @DontCompile
 781     public void test33_verifier(boolean warmup) {
 782         int len = Math.abs(rI) % 10;
 783         Object[] va = new Object[len];
 784         for (int i = 0; i &lt; len; ++i) {
 785             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 786         }
 787         Object[] result = test33(va);
 788         for (int i = 0; i &lt; len; ++i) {
 789             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
 790             // Check that array has correct properties (null-ok)
 791             result[i] = null;
 792         }
 793     }
 794 
 795     // clone() as series of loads/stores
 796     static Object[] test34_orig = null;
 797 
 798     @ForceInline
 799     public Object[] test34_helper(boolean flag) {
 800         Object[] va = null;
 801         if (flag) {
 802             va = new MyValue1[8];
 803             for (int i = 0; i &lt; va.length; ++i) {
 804                 va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 805             }
 806         } else {
 807             va = new Object[8];
 808         }
 809         return va;
 810     }
 811 
 812     @Test
 813     public Object[] test34(boolean flag) {
 814         Object[] va = test34_helper(flag);
 815         test34_orig = va;
 816         return va.clone();
 817     }
 818 
 819     @DontCompile
 820     public void test34_verifier(boolean warmup) {
 821         test34(false);
 822         for (int i = 0; i &lt; 10; i++) { // make sure we do deopt
 823             Object[] result = test34(true);
 824             verify(test34_orig, result);
 825             // Check that array has correct properties (null-free)
 826             try {
 827                 result[0] = null;
 828                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
 829             } catch (NullPointerException e) {
 830                 // Expected
 831             }
 832         }
 833         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test34&quot;)) {
 834             Object[] result = test34(true);
 835             verify(test34_orig, result);
 836             // Check that array has correct properties (null-free)
 837             try {
 838                 result[0] = null;
 839                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
 840             } catch (NullPointerException e) {
 841                 // Expected
 842             }
 843         }
 844     }
 845 
 846     static void verify(Object[] src, Object[] dst) {
 847         for (int i = 0; i &lt; src.length; ++i) {
 848             Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());
 849         }
 850     }
 851 
 852     static void verify(MyValue1[] src, MyValue1[] dst) {
 853         for (int i = 0; i &lt; src.length; ++i) {
 854             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 855         }
 856     }
 857 
 858     static void verify(MyValue1[] src, Object[] dst) {
 859         for (int i = 0; i &lt; src.length; ++i) {
 860             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 861         }
 862     }
 863 
 864     static void verify(MyValue2[] src, MyValue2[] dst) {
 865         for (int i = 0; i &lt; src.length; ++i) {
 866             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 867         }
 868     }
 869 
 870     static void verify(MyValue2[] src, Object[] dst) {
 871         for (int i = 0; i &lt; src.length; ++i) {
 872             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 873         }
 874     }
 875 
 876     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
 877         if (!warmup) {
 878             Method m = tests.get(test);
 879             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false)) {
 880                 if (!InlineTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
 881                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
 882                 }
 883                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 884                 return true;
 885             }
 886         }
 887         return false;
 888     }
 889 
 890     // arraycopy() of value type array of unknown size
 891     @Test
 892     public void test35(Object src, Object dst, int len) {
 893         System.arraycopy(src, 0, dst, 0, len);
 894     }
 895 
 896     @DontCompile
 897     public void test35_verifier(boolean warmup) {
 898         int len = Math.abs(rI) % 10;
 899         MyValue1[] src = new MyValue1[len];
 900         MyValue1[] dst = new MyValue1[len];
 901         for (int i = 0; i &lt; len; ++i) {
 902             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 903         }
 904         test35(src, dst, src.length);
 905         verify(src, dst);
 906         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test35&quot;)) {
 907             test35(src, dst, src.length);
 908             verify(src, dst);
 909         }
 910     }
 911 
 912     @Test
 913     public void test36(Object src, MyValue2[] dst) {
 914         System.arraycopy(src, 0, dst, 0, dst.length);
 915     }
 916 
 917     @DontCompile
 918     public void test36_verifier(boolean warmup) {
 919         int len = Math.abs(rI) % 10;
 920         MyValue2[] src = new MyValue2[len];
 921         MyValue2[] dst = new MyValue2[len];
 922         for (int i = 0; i &lt; len; ++i) {
 923             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 924         }
 925         test36(src, dst);
 926         verify(src, dst);
 927         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test36&quot;)) {
 928             test36(src, dst);
 929             verify(src, dst);
 930         }
 931     }
 932 
 933     @Test
 934     public void test37(MyValue2[] src, Object dst) {
 935         System.arraycopy(src, 0, dst, 0, src.length);
 936     }
 937 
 938     @DontCompile
 939     public void test37_verifier(boolean warmup) {
 940         int len = Math.abs(rI) % 10;
 941         MyValue2[] src = new MyValue2[len];
 942         MyValue2[] dst = new MyValue2[len];
 943         for (int i = 0; i &lt; len; ++i) {
 944             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 945         }
 946         test37(src, dst);
 947         verify(src, dst);
 948         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test37&quot;)) {
 949             test37(src, dst);
 950             verify(src, dst);
 951         }
 952     }
 953 
 954     @Test
 955     @Warmup(1) // Avoid early compilation
 956     public void test38(Object src, MyValue2[] dst) {
 957         System.arraycopy(src, 0, dst, 0, dst.length);
 958     }
 959 
 960     @DontCompile
 961     public void test38_verifier(boolean warmup) {
 962         int len = Math.abs(rI) % 10;
 963         Object[] src = new Object[len];
 964         MyValue2[] dst = new MyValue2[len];
 965         for (int i = 0; i &lt; len; ++i) {
 966             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 967         }
 968         test38(src, dst);
 969         verify(dst, src);
 970         if (!warmup) {
 971             Method m = tests.get(&quot;TestArrays::test38&quot;);
 972             assertDeoptimizedByC2(m);
 973             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 974             test38(src, dst);
 975             verify(dst, src);
 976             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
 977                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
 978             }
 979         }
 980     }
 981 
 982     @Test
 983     public void test39(MyValue2[] src, Object dst) {
 984         System.arraycopy(src, 0, dst, 0, src.length);
 985     }
 986 
 987     @DontCompile
 988     public void test39_verifier(boolean warmup) {
 989         int len = Math.abs(rI) % 10;
 990         MyValue2[] src = new MyValue2[len];
 991         Object[] dst = new Object[len];
 992         for (int i = 0; i &lt; len; ++i) {
 993             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 994         }
 995         test39(src, dst);
 996         verify(src, dst);
 997         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test39&quot;)) {
 998             test39(src, dst);
 999             verify(src, dst);
1000         }
1001     }
1002 
1003     @Test
1004     @Warmup(1) // Avoid early compilation
1005     public void test40(Object[] src, Object dst) {
1006         System.arraycopy(src, 0, dst, 0, src.length);
1007     }
1008 
1009     @DontCompile
1010     public void test40_verifier(boolean warmup) {
1011         int len = Math.abs(rI) % 10;
1012         Object[] src = new Object[len];
1013         MyValue2[] dst = new MyValue2[len];
1014         for (int i = 0; i &lt; len; ++i) {
1015             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1016         }
1017         test40(src, dst);
1018         verify(dst, src);
1019         if (!warmup) {
1020             Method m = tests.get(&quot;TestArrays::test40&quot;);
1021             assertDeoptimizedByC2(m);
1022             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1023             test40(src, dst);
1024             verify(dst, src);
1025             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1026                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1027             }
1028         }
1029     }
1030 
1031     @Test
1032     public void test41(Object src, Object[] dst) {
1033         System.arraycopy(src, 0, dst, 0, dst.length);
1034     }
1035 
1036     @DontCompile
1037     public void test41_verifier(boolean warmup) {
1038         int len = Math.abs(rI) % 10;
1039         MyValue2[] src = new MyValue2[len];
1040         Object[] dst = new Object[len];
1041         for (int i = 0; i &lt; len; ++i) {
1042             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1043         }
1044         test41(src, dst);
1045         verify(src, dst);
1046         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test41&quot;)) {
1047             test41(src, dst);
1048             verify(src, dst);
1049         }
1050     }
1051 
1052     @Test
1053     public void test42(Object[] src, Object[] dst) {
1054         System.arraycopy(src, 0, dst, 0, src.length);
1055     }
1056 
1057     @DontCompile
1058     public void test42_verifier(boolean warmup) {
1059         int len = Math.abs(rI) % 10;
1060         Object[] src = new Object[len];
1061         Object[] dst = new Object[len];
1062         for (int i = 0; i &lt; len; ++i) {
1063             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1064         }
1065         test42(src, dst);
1066         verify(src, dst);
1067         if (!warmup) {
1068             Method m = tests.get(&quot;TestArrays::test42&quot;);
1069             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1070                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1071             }
1072         }
1073     }
1074 
1075     // short arraycopy()&#39;s
1076     @Test
1077     public void test43(Object src, Object dst) {
1078         System.arraycopy(src, 0, dst, 0, 8);
1079     }
1080 
1081     @DontCompile
1082     public void test43_verifier(boolean warmup) {
1083         MyValue1[] src = new MyValue1[8];
1084         MyValue1[] dst = new MyValue1[8];
1085         for (int i = 0; i &lt; 8; ++i) {
1086             src[i] = MyValue1.createWithFieldsInline(rI, rL);
1087         }
1088         test43(src, dst);
1089         verify(src, dst);
1090         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test43&quot;)) {
1091             test43(src, dst);
1092             verify(src, dst);
1093         }
1094     }
1095 
1096     @Test
1097     public void test44(Object src, MyValue2[] dst) {
1098         System.arraycopy(src, 0, dst, 0, 8);
1099     }
1100 
1101     @DontCompile
1102     public void test44_verifier(boolean warmup) {
1103         MyValue2[] src = new MyValue2[8];
1104         MyValue2[] dst = new MyValue2[8];
1105         for (int i = 0; i &lt; 8; ++i) {
1106             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1107         }
1108         test44(src, dst);
1109         verify(src, dst);
1110         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test44&quot;)) {
1111             test44(src, dst);
1112             verify(src, dst);
1113         }
1114     }
1115 
1116     @Test
1117     public void test45(MyValue2[] src, Object dst) {
1118         System.arraycopy(src, 0, dst, 0, 8);
1119     }
1120 
1121     @DontCompile
1122     public void test45_verifier(boolean warmup) {
1123         MyValue2[] src = new MyValue2[8];
1124         MyValue2[] dst = new MyValue2[8];
1125         for (int i = 0; i &lt; 8; ++i) {
1126             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1127         }
1128         test45(src, dst);
1129         verify(src, dst);
1130         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test45&quot;)) {
1131             test45(src, dst);
1132             verify(src, dst);
1133         }
1134     }
1135 
1136     @Test
1137     @Warmup(1) // Avoid early compilation
1138     public void test46(Object[] src, MyValue2[] dst) {
1139         System.arraycopy(src, 0, dst, 0, 8);
1140     }
1141 
1142     @DontCompile
1143     public void test46_verifier(boolean warmup) {
1144         Object[] src = new Object[8];
1145         MyValue2[] dst = new MyValue2[8];
1146         for (int i = 0; i &lt; 8; ++i) {
1147             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1148         }
1149         test46(src, dst);
1150         verify(dst, src);
1151         if (!warmup) {
1152             Method m = tests.get(&quot;TestArrays::test46&quot;);
1153             assertDeoptimizedByC2(m);
1154             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1155             test46(src, dst);
1156             verify(dst, src);
1157             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1158                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1159             }
1160         }
1161     }
1162 
1163     @Test
1164     public void test47(MyValue2[] src, Object[] dst) {
1165         System.arraycopy(src, 0, dst, 0, 8);
1166     }
1167 
1168     @DontCompile
1169     public void test47_verifier(boolean warmup) {
1170         MyValue2[] src = new MyValue2[8];
1171         Object[] dst = new Object[8];
1172         for (int i = 0; i &lt; 8; ++i) {
1173             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1174         }
1175         test47(src, dst);
1176         verify(src, dst);
1177         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test47&quot;)) {
1178             test47(src, dst);
1179             verify(src, dst);
1180         }
1181     }
1182 
1183     @Test
1184     @Warmup(1) // Avoid early compilation
1185     public void test48(Object[] src, Object dst) {
1186         System.arraycopy(src, 0, dst, 0, 8);
1187     }
1188 
1189     @DontCompile
1190     public void test48_verifier(boolean warmup) {
1191         Object[] src = new Object[8];
1192         MyValue2[] dst = new MyValue2[8];
1193         for (int i = 0; i &lt; 8; ++i) {
1194             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1195         }
1196         test48(src, dst);
1197         verify(dst, src);
1198         if (!warmup) {
1199             Method m = tests.get(&quot;TestArrays::test48&quot;);
1200             assertDeoptimizedByC2(m);
1201             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1202             test48(src, dst);
1203             verify(dst, src);
1204             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1205                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1206             }
1207         }
1208     }
1209 
1210     @Test
1211     public void test49(Object src, Object[] dst) {
1212         System.arraycopy(src, 0, dst, 0, 8);
1213     }
1214 
1215     @DontCompile
1216     public void test49_verifier(boolean warmup) {
1217         MyValue2[] src = new MyValue2[8];
1218         Object[] dst = new Object[8];
1219         for (int i = 0; i &lt; 8; ++i) {
1220             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1221         }
1222         test49(src, dst);
1223         verify(src, dst);
1224         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test49&quot;)) {
1225             test49(src, dst);
1226             verify(src, dst);
1227         }
1228     }
1229 
1230     @Test
1231     public void test50(Object[] src, Object[] dst) {
1232         System.arraycopy(src, 0, dst, 0, 8);
1233     }
1234 
1235     @DontCompile
1236     public void test50_verifier(boolean warmup) {
1237         Object[] src = new Object[8];
1238         Object[] dst = new Object[8];
1239         for (int i = 0; i &lt; 8; ++i) {
1240             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1241         }
1242         test50(src, dst);
1243         verify(src, dst);
1244         if (!warmup) {
1245             Method m = tests.get(&quot;TestArrays::test50&quot;);
1246             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1247                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1248             }
1249         }
1250     }
1251 
1252     @Test
1253     public MyValue1[] test51(MyValue1[] va) {
1254         // TODO Remove cast as workaround once javac is fixed
1255         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1256     }
1257 
1258     @DontCompile
1259     public void test51_verifier(boolean warmup) {
1260         int len = Math.abs(rI) % 10;
1261         MyValue1[] va = new MyValue1[len];
1262         for (int i = 0; i &lt; len; ++i) {
1263             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1264         }
1265         MyValue1[] result = test51(va);
1266         verify(va, result);
1267     }
1268 
1269     static final MyValue1[] test52_va = new MyValue1[8];
1270 
1271     @Test
1272     public MyValue1[] test52() {
1273         // TODO Remove cast as workaround once javac is fixed
1274         return (MyValue1[])Arrays.copyOf(test52_va, 8, MyValue1[].class);
1275     }
1276 
1277     @DontCompile
1278     public void test52_verifier(boolean warmup) {
1279         for (int i = 0; i &lt; 8; ++i) {
1280             test52_va[i] = MyValue1.createWithFieldsInline(rI, rL);
1281         }
1282         MyValue1[] result = test52();
1283         verify(test52_va, result);
1284     }
1285 
1286     @Test
1287     public MyValue1[] test53(Object[] va) {
1288         // TODO Remove cast as workaround once javac is fixed
1289         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1290     }
1291 
1292     @DontCompile
1293     public void test53_verifier(boolean warmup) {
1294         int len = Math.abs(rI) % 10;
1295         MyValue1[] va = new MyValue1[len];
1296         for (int i = 0; i &lt; len; ++i) {
1297             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1298         }
1299         MyValue1[] result = test53(va);
1300         verify(result, va);
1301     }
1302 
1303     @Test
1304     public Object[] test54(MyValue1[] va) {
1305         return Arrays.copyOf(va, va.length, Object[].class);
1306     }
1307 
1308     @DontCompile
1309     public void test54_verifier(boolean warmup) {
1310         int len = Math.abs(rI) % 10;
1311         MyValue1[] va = new MyValue1[len];
1312         for (int i = 0; i &lt; len; ++i) {
1313             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1314         }
1315         Object[] result = test54(va);
1316         verify(va, result);
1317     }
1318 
1319     @Test
1320     public Object[] test55(Object[] va) {
1321         return Arrays.copyOf(va, va.length, Object[].class);
1322     }
1323 
1324     @DontCompile
1325     public void test55_verifier(boolean warmup) {
1326         int len = Math.abs(rI) % 10;
1327         MyValue1[] va = new MyValue1[len];
1328         for (int i = 0; i &lt; len; ++i) {
1329             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1330         }
1331         Object[] result = test55(va);
1332         verify(va, result);
1333     }
1334 
1335     @Test
1336     public MyValue1[] test56(Object[] va) {
1337         // TODO Remove cast as workaround once javac is fixed
1338         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1339     }
1340 
1341     @DontCompile
1342     public void test56_verifier(boolean warmup) {
1343         int len = Math.abs(rI) % 10;
1344         Object[] va = new Object[len];
1345         for (int i = 0; i &lt; len; ++i) {
1346             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1347         }
1348         MyValue1[] result = test56(va);
1349         verify(result, va);
1350     }
1351 
1352    @Test
1353     public Object[] test57(Object[] va, Class klass) {
1354         return Arrays.copyOf(va, va.length, klass);
1355     }
1356 
1357     @DontCompile
1358     public void test57_verifier(boolean warmup) {
1359         int len = Math.abs(rI) % 10;
1360         Object[] va = new MyValue1[len];
1361         for (int i = 0; i &lt; len; ++i) {
1362             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1363         }
1364         Object[] result = test57(va, MyValue1[].class);
1365         verify(va, result);
1366     }
1367 
1368     @Test
1369     public Object[] test58(MyValue1[] va, Class klass) {
1370         return Arrays.copyOf(va, va.length, klass);
1371     }
1372 
1373     @DontCompile
1374     public void test58_verifier(boolean warmup) {
1375         int len = Math.abs(rI) % 10;
1376         MyValue1[] va = new MyValue1[len];
1377         for (int i = 0; i &lt; len; ++i) {
1378             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1379         }
1380         for (int i = 0; i &lt; 10; i++) {
1381             Object[] result = test58(va, MyValue1[].class);
1382             verify(va, result);
1383         }
1384         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test58&quot;)) {
1385             Object[] result = test58(va, MyValue1[].class);
1386             verify(va, result);
1387         }
1388     }
1389 
1390     @Test
1391     public Object[] test59(MyValue1[] va) {
1392         return Arrays.copyOf(va, va.length+1, MyValue1[].class);
1393     }
1394 
1395     @DontCompile
1396     public void test59_verifier(boolean warmup) {
1397         int len = Math.abs(rI) % 10;
1398         MyValue1[] va = new MyValue1[len];
1399         MyValue1[] verif = new MyValue1[len+1];
1400         for (int i = 0; i &lt; len; ++i) {
1401             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1402             verif[i] = va[i];
1403         }
1404         Object[] result = test59(va);
1405         verify(verif, result);
1406     }
1407 
1408     @Test
1409     public Object[] test60(Object[] va, Class klass) {
1410         return Arrays.copyOf(va, va.length+1, klass);
1411     }
1412 
1413     @DontCompile
1414     public void test60_verifier(boolean warmup) {
1415         int len = Math.abs(rI) % 10;
1416         MyValue1[] va = new MyValue1[len];
1417         MyValue1[] verif = new MyValue1[len+1];
1418         for (int i = 0; i &lt; len; ++i) {
1419             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1420             verif[i] = (MyValue1)va[i];
1421         }
1422         Object[] result = test60(va, MyValue1[].class);
1423         verify(verif, result);
1424     }
1425 
1426     @Test
1427     public Object[] test61(Object[] va, Class klass) {
1428         return Arrays.copyOf(va, va.length+1, klass);
1429     }
1430 
1431     @DontCompile
1432     public void test61_verifier(boolean warmup) {
1433         int len = Math.abs(rI) % 10;
1434         Object[] va = new Integer[len];
1435         for (int i = 0; i &lt; len; ++i) {
1436             va[i] = new Integer(rI);
1437         }
1438         Object[] result = test61(va, Integer[].class);
1439         for (int i = 0; i &lt; va.length; ++i) {
1440             Asserts.assertEQ(va[i], result[i]);
1441         }
1442     }
1443 
1444     @ForceInline
1445     public Object[] test62_helper(int i, MyValue1[] va, Integer[] oa) {
1446         Object[] arr = null;
1447         if (i == 10) {
1448             arr = oa;
1449         } else {
1450             arr = va;
1451         }
1452         return arr;
1453     }
1454 
1455     @Test
1456     public Object[] test62(MyValue1[] va, Integer[] oa) {
1457         int i = 0;
1458         for (; i &lt; 10; i++);
1459 
1460         Object[] arr = test62_helper(i, va, oa);
1461 
1462         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1463     }
1464 
1465     @DontCompile
1466     public void test62_verifier(boolean warmup) {
1467         int len = Math.abs(rI) % 10;
1468         MyValue1[] va = new MyValue1[len];
1469         Integer[] oa = new Integer[len];
1470         for (int i = 0; i &lt; len; ++i) {
1471             oa[i] = new Integer(rI);
1472         }
1473         test62_helper(42, va, oa);
1474         Object[] result = test62(va, oa);
1475         for (int i = 0; i &lt; va.length; ++i) {
1476             Asserts.assertEQ(oa[i], result[i]);
1477         }
1478     }
1479 
1480     @ForceInline
1481     public Object[] test63_helper(int i, MyValue1[] va, Integer[] oa) {
1482         Object[] arr = null;
1483         if (i == 10) {
1484             arr = va;
1485         } else {
1486             arr = oa;
1487         }
1488         return arr;
1489     }
1490 
1491     @Test
1492     public Object[] test63(MyValue1[] va, Integer[] oa) {
1493         int i = 0;
1494         for (; i &lt; 10; i++);
1495 
1496         Object[] arr = test63_helper(i, va, oa);
1497 
1498         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1499     }
1500 
1501     @DontCompile
1502     public void test63_verifier(boolean warmup) {
1503         int len = Math.abs(rI) % 10;
1504         MyValue1[] va = new MyValue1[len];
1505         MyValue1[] verif = new MyValue1[len+1];
1506         for (int i = 0; i &lt; len; ++i) {
1507             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1508             verif[i] = va[i];
1509         }
1510         Integer[] oa = new Integer[len];
1511         test63_helper(42, va, oa);
1512         Object[] result = test63(va, oa);
1513         verify(verif, result);
1514     }
1515 
1516     // Test default initialization of value type arrays: small array
1517     @Test
1518     public MyValue1[] test64() {
1519         return new MyValue1[8];
1520     }
1521 
1522     @DontCompile
1523     public void test64_verifier(boolean warmup) {
1524         MyValue1[] va = new MyValue1[8];
1525         MyValue1[] var = test64();
1526         for (int i = 0; i &lt; 8; ++i) {
1527             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1528         }
1529     }
1530 
1531     // Test default initialization of value type arrays: large array
1532     @Test
1533     public MyValue1[] test65() {
1534         return new MyValue1[32];
1535     }
1536 
1537     @DontCompile
1538     public void test65_verifier(boolean warmup) {
1539         MyValue1[] va = new MyValue1[32];
1540         MyValue1[] var = test65();
1541         for (int i = 0; i &lt; 32; ++i) {
1542             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1543         }
1544     }
1545 
1546     // Check init store elimination
1547     @Test(match = { ALLOCA }, matchCount = { 1 })
1548     public MyValue1[] test66(MyValue1 vt) {
1549         MyValue1[] va = new MyValue1[1];
1550         va[0] = vt;
1551         return va;
1552     }
1553 
1554     @DontCompile
1555     public void test66_verifier(boolean warmup) {
1556         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);
1557         MyValue1[] va = test66(vt);
1558         Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
1559     }
1560 
1561     // Zeroing elimination and arraycopy
1562     @Test
1563     public MyValue1[] test67(MyValue1[] src) {
1564         MyValue1[] dst = new MyValue1[16];
1565         System.arraycopy(src, 0, dst, 0, 13);
1566         return dst;
1567     }
1568 
1569     @DontCompile
1570     public void test67_verifier(boolean warmup) {
1571         MyValue1[] va = new MyValue1[16];
1572         MyValue1[] var = test67(va);
1573         for (int i = 0; i &lt; 16; ++i) {
1574             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1575         }
1576     }
1577 
1578     // A store with a default value can be eliminated
1579     @Test
1580     public MyValue1[] test68() {
1581         MyValue1[] va = new MyValue1[2];
1582         va[0] = va[1];
1583         return va;
1584     }
1585 
1586     @DontCompile
1587     public void test68_verifier(boolean warmup) {
1588         MyValue1[] va = new MyValue1[2];
1589         MyValue1[] var = test68();
1590         for (int i = 0; i &lt; 2; ++i) {
1591             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1592         }
1593     }
1594 
1595     // Requires individual stores to init array
1596     @Test
1597     public MyValue1[] test69(MyValue1 vt) {
1598         MyValue1[] va = new MyValue1[4];
1599         va[0] = vt;
1600         va[3] = vt;
1601         return va;
1602     }
1603 
1604     @DontCompile
1605     public void test69_verifier(boolean warmup) {
1606         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);
1607         MyValue1[] va = new MyValue1[4];
1608         va[0] = vt;
1609         va[3] = vt;
1610         MyValue1[] var = test69(vt);
1611         for (int i = 0; i &lt; va.length; ++i) {
1612             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1613         }
1614     }
1615 
1616     // A store with a default value can be eliminated: same as test68
1617     // but store is farther away from allocation
1618     @Test
1619     public MyValue1[] test70(MyValue1[] other) {
1620         other[1] = other[0];
1621         MyValue1[] va = new MyValue1[2];
1622         other[0] = va[1];
1623         va[0] = va[1];
1624         return va;
1625     }
1626 
1627     @DontCompile
1628     public void test70_verifier(boolean warmup) {
1629         MyValue1[] va = new MyValue1[2];
1630         MyValue1[] var = test70(va);
1631         for (int i = 0; i &lt; 2; ++i) {
1632             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1633         }
1634     }
1635 
1636     // EA needs to consider oop fields in flattened arrays
1637     @Test
1638     public void test71() {
1639         int len = 10;
1640         MyValue2[] src = new MyValue2[len];
1641         MyValue2[] dst = new MyValue2[len];
1642         for (int i = 0; i &lt; len; ++i) {
1643             src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);
1644         }
1645         System.arraycopy(src, 0, dst, 0, src.length);
1646         for (int i = 0; i &lt; len; ++i) {
1647             Asserts.assertEQ(src[i].hash(), dst[i].hash());
1648         }
1649     }
1650 
1651     @DontCompile
1652     public void test71_verifier(boolean warmup) {
1653         test71();
1654     }
1655 
1656     // Test EA with leaf call to &#39;store_unknown_value&#39;
1657     @Test
1658     public void test72(Object[] o, boolean b, Object element) {
1659         Object[] arr1 = new Object[10];
1660         Object[] arr2 = new Object[10];
1661         if (b) {
1662             arr1 = o;
1663         }
1664         arr1[0] = element;
1665         arr2[0] = element;
1666     }
1667 
1668     @DontCompile
1669     public void test72_verifier(boolean warmup) {
1670         Object[] arr = new Object[1];
1671         Object elem = new Object();
1672         test72(arr, true, elem);
1673         test72(arr, false, elem);
1674     }
1675 
1676     @Test
1677     public void test73(Object[] oa, MyValue1 v, Object o) {
1678         // TestLWorld.test38 use a C1 Phi node for the array. This test
1679         // adds the case where the stored value is a C1 Phi node.
1680         Object o2 = (o == null) ? v : o;
1681         oa[0] = v;  // The stored value is known to be flattenable
1682         oa[1] = o;  // The stored value may be flattenable
1683         oa[2] = o2; // The stored value may be flattenable (a C1 Phi node)
1684         oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
1685     }
1686 
1687     @DontCompile
1688     public void test73_verifier(boolean warmup) {
1689         MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1690         MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1691         MyValue1[] arr = new MyValue1[3];
1692         try {
1693             test73(arr, v0, v1);
1694             throw new RuntimeException(&quot;ArrayStoreException expected&quot;);
1695         } catch (ArrayStoreException t) {
1696             // expected
1697         }
1698         Asserts.assertEQ(arr[0].hash(), v0.hash());
1699         Asserts.assertEQ(arr[1].hash(), v1.hash());
1700         Asserts.assertEQ(arr[2].hash(), v1.hash());
1701     }
1702 
1703     public static void test74Callee(MyValue1[] va) { }
1704 
1705     // Tests invoking unloaded method with value array in signature
1706     @Test
1707     @Warmup(0)
1708     public void test74(MethodHandle m, MyValue1[] va) throws Throwable {
1709         m.invoke(va);
1710     }
1711 
1712     @DontCompile
1713     public void test74_verifier(boolean warmup) throws Throwable {
1714         MethodHandle m = MethodHandles.lookup().findStatic(TestArrays.class, &quot;test74Callee&quot;, MethodType.methodType(void.class, MyValue1[].class));
1715         MyValue1[] va = new MyValue1[0];
1716         test74(m, va);
1717     }
1718 
1719     // Some more array clone tests
1720     @ForceInline
1721     public Object[] test75_helper(int i, MyValue1[] va, Integer[] oa) {
1722         Object[] arr = null;
1723         if (i == 10) {
1724             arr = oa;
1725         } else {
1726             arr = va;
1727         }
1728         return arr;
1729     }
1730 
1731     @Test
1732     public Object[] test75(MyValue1[] va, Integer[] oa) {
1733         int i = 0;
1734         for (; i &lt; 10; i++);
1735 
1736         Object[] arr = test75_helper(i, va, oa);
1737         return arr.clone();
1738     }
1739 
1740     @DontCompile
1741     public void test75_verifier(boolean warmup) {
1742         int len = Math.abs(rI) % 10;
1743         MyValue1[] va = new MyValue1[len];
1744         Integer[] oa = new Integer[len];
1745         for (int i = 0; i &lt; len; ++i) {
1746             oa[i] = new Integer(rI);
1747         }
1748         test75_helper(42, va, oa);
1749         Object[] result = test75(va, oa);
1750 
1751         for (int i = 0; i &lt; va.length; ++i) {
1752             Asserts.assertEQ(oa[i], result[i]);
1753             // Check that array has correct properties (null-ok)
1754             result[i] = null;
1755         }
1756     }
1757 
1758     @ForceInline
1759     public Object[] test76_helper(int i, MyValue1[] va, Integer[] oa) {
1760         Object[] arr = null;
1761         if (i == 10) {
1762             arr = va;
1763         } else {
1764             arr = oa;
1765         }
1766         return arr;
1767     }
1768 
1769     @Test
1770     public Object[] test76(MyValue1[] va, Integer[] oa) {
1771         int i = 0;
1772         for (; i &lt; 10; i++);
1773 
1774         Object[] arr = test76_helper(i, va, oa);
1775         return arr.clone();
1776     }
1777 
1778     @DontCompile
1779     public void test76_verifier(boolean warmup) {
1780         int len = Math.abs(rI) % 10;
1781         MyValue1[] va = new MyValue1[len];
1782         MyValue1[] verif = new MyValue1[len];
1783         for (int i = 0; i &lt; len; ++i) {
1784             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1785             verif[i] = va[i];
1786         }
1787         Integer[] oa = new Integer[len];
1788         test76_helper(42, va, oa);
1789         Object[] result = test76(va, oa);
1790         verify(verif, result);
1791         // Check that array has correct properties (null-free)
1792         if (len &gt; 0) {
1793             try {
1794                 result[0] = null;
1795                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
1796             } catch (NullPointerException e) {
1797                 // Expected
1798             }
1799         }
1800     }
1801 
1802     @Test
1803     public void test77() {
1804         MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1805         MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1806         MyValue1[] arr = new MyValue1[1];
1807 
1808         Object[] oa = arr;
1809         Object o1 = v1;
1810         Object o = (o1 == null) ? v0 : o1;
1811 
1812         oa[0] = o; // For C1, due to IfOp optimization, the declared_type of o becomes NULL.
1813 
1814         Asserts.assertEQ(arr[0].hash(), v1.hash());
1815     }
1816 
1817 
1818     @DontCompile
1819     public void test77_verifier(boolean warmup) {
1820         test77();
1821     }
1822 
1823     @Test
1824     public long test78(MyValue1 v, int n) {
1825         long x = 0;
1826         for (int i = 0; i&lt;n; i++) {
1827         }
1828 
1829         MyValue1[] a = new MyValue1[n];
1830         a[0] = v;
1831         for (int i = 0; i&lt;n; i++) {
1832             x += a[i].hash(); // C1 PhiSimplifier changes &quot;a&quot; from a Phi node to a NewObjectArray node
1833         }
1834 
1835         return x;
1836     }
1837 
1838     @DontCompile
1839     public void test78_verifier(boolean warmup) {
1840         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
1841         Asserts.assertEQ(test78(v, 1), v.hash());
1842     }
1843 
1844     // Verify that casting an array element to a non-flattenable type marks the array as not-flat
1845     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_VALUE }, matchCount = { 1, 1 })
1846     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE)
1847     public Object test79(Object[] array, int i) {
1848         Integer i1 = (Integer)array[0];
1849         Object o = array[1];
1850         return array[i];
1851     }
1852 
1853     @DontCompile
1854     public void test79_verifier(boolean warmup) {
1855         Integer i = new Integer(rI);
1856         Integer[] array = new Integer[2];
1857         array[1] = i;
1858         Object result = test79(array, 1);
1859         Asserts.assertEquals(result, i);
1860     }
1861 
1862     inline static class NotFlattenable {
1863         private final Object o1 = null;
1864         private final Object o2 = null;
1865         private final Object o3 = null;
1866         private final Object o4 = null;
1867         private final Object o5 = null;
1868         private final Object o6 = null;
1869     }
1870 
1871     // Same as test79 but with not-flattenable inline type
1872     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_VALUE }, matchCount = { 1, 1 })
1873     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE)
1874     public Object test80(Object[] array, int i) {
1875         NotFlattenable vt = (NotFlattenable)array[0];
1876         Object o = array[1];
1877         return array[i];
1878     }
1879 
1880     @DontCompile
1881     public void test80_verifier(boolean warmup) {
1882         NotFlattenable vt = new NotFlattenable();
1883         NotFlattenable[] array = new NotFlattenable[2];
1884         array[1] = vt;
1885         Object result = test80(array, 1);
1886         Asserts.assertEquals(result, vt);
1887     }
1888 
1889     // Verify that writing an object of a non-inline, non-null type to an array marks the array as not-null-free and not-flat
1890     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
1891     public Object test81(Object[] array, Integer v, Object o, int i) {
1892         if (v == null) {
1893           return null;
1894         }
1895         array[0] = v;
1896         array[1] = array[0];
1897         array[2] = o;
1898         return array[i];
1899     }
1900 
1901     @DontCompile
1902     public void test81_verifier(boolean warmup) {
1903         Integer i = new Integer(rI);
1904         Integer[] array1 = new Integer[3];
1905         Object[] array2 = new Object[3];
1906         Object result = test81(array1, i, i, 0);
1907         Asserts.assertEquals(array1[0], i);
1908         Asserts.assertEquals(array1[1], i);
1909         Asserts.assertEquals(array1[2], i);
1910         Asserts.assertEquals(result, i);
1911         result = test81(array2, i, i, 1);
1912         Asserts.assertEquals(array2[0], i);
1913         Asserts.assertEquals(array2[1], i);
1914         Asserts.assertEquals(array2[2], i);
1915         Asserts.assertEquals(result, i);
1916     }
1917 
1918     // Verify that writing an object of a non-flattenable inline type to an array marks the array as not-flat
1919     @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE)
1920     @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE)
1921     public Object test82(Object[] array, NotFlattenable vt, Object o, int i) {
1922         array[0] = vt;
1923         array[1] = array[0];
1924         array[2] = o;
1925         return array[i];
1926     }
1927 
1928     @DontCompile
1929     public void test82_verifier(boolean warmup) {
1930         NotFlattenable vt = new NotFlattenable();
1931         NotFlattenable[] array1 = new NotFlattenable[3];
1932         Object[] array2 = new Object[3];
1933         Object result = test82(array1, vt, vt, 0);
1934         Asserts.assertEquals(array1[0], vt);
1935         Asserts.assertEquals(array1[1], vt);
1936         Asserts.assertEquals(array1[2], vt);
1937         Asserts.assertEquals(result, vt);
1938         result = test82(array2, vt, vt, 1);
1939         Asserts.assertEquals(array2[0], vt);
1940         Asserts.assertEquals(array2[1], vt);
1941         Asserts.assertEquals(array2[2], vt);
1942         Asserts.assertEquals(result, vt);
1943     }
1944 
1945     // Verify that casting an array element to a non-inline type type marks the array as not-null-free and not-flat
1946     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_VALUE }, matchCount = { 1, 1 }, failOn = ALLOCA_G + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
1947     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
1948     public void test83(Object[] array, Object o) {
1949         Integer i = (Integer)array[0];
1950         array[1] = o;
1951     }
1952 
1953     @DontCompile
1954     public void test83_verifier(boolean warmup) {
1955         Integer i = new Integer(rI);
1956         Integer[] array1 = new Integer[2];
1957         Object[] array2 = new Object[2];
1958         test83(array1, i);
1959         Asserts.assertEquals(array1[1], i);
1960         test83(array2, null);
1961         Asserts.assertEquals(array2[1], null);
1962     }
1963 
1964     // Verify that writing constant null into an array marks the array as not-null-free and not-flat
1965     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 1 })
1966     public Object test84(Object[] array, int i) {
1967         array[0] = null;
1968         array[1] = null;
1969         return array[i];
1970     }
1971 
1972     @DontCompile
1973     public void test84_verifier(boolean warmup) {
1974         NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];
1975         Object[] array2 = new Object[2];
1976         Object result = test84(array1, 0);
1977         Asserts.assertEquals(array1[0], null);
1978         Asserts.assertEquals(result, null);
1979         result = test84(array2, 1);
1980         Asserts.assertEquals(array2[0], null);
1981         Asserts.assertEquals(result, null);
1982         if (!warmup) {
1983             NotFlattenable[] array3 = new NotFlattenable[2];
1984             try {
1985                 test84(array3, 1);
1986                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
1987             } catch (NullPointerException e) {
1988                 // Expected
1989             }
1990         }
1991     }
1992 
1993     // Same as test84 but with branches
1994     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
1995     public void test85(Object[] array, Object o, boolean b) {
1996         if (b) {
1997             array[0] = null;
1998         } else {
1999             array[1] = null;
2000         }
2001         array[1] = o;
2002     }
2003 
2004     @DontCompile
2005     public void test85_verifier(boolean warmup) {
2006         Integer i = new Integer(rI);
2007         Integer[] array1 = new Integer[2];
2008         Object[] array2 = new Object[2];
2009         test85(array1, i, true);
2010         Asserts.assertEquals(array1[1], i);
2011         test85(array1, null, false);
2012         Asserts.assertEquals(array1[1], null);
2013         test85(array2, i, true);
2014         Asserts.assertEquals(array2[1], i);
2015         test85(array2, null, false);
2016         Asserts.assertEquals(array2[1], null);
2017         if (!warmup) {
2018             NotFlattenable[] array3 = new NotFlattenable[2];
2019             try {
2020                 test85(array3, null, true);
2021                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2022             } catch (NullPointerException e) {
2023                 // Expected
2024             }
2025         }
2026     }
2027 
2028     // Same as test85 but with not-flattenable inline type array
2029     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
2030     public void test86(NotFlattenable.ref[] array, NotFlattenable.ref o, boolean b) {
2031         if (b) {
2032             array[0] = null;
2033         } else {
2034             array[1] = null;
2035         }
2036         array[1] = o;
2037     }
2038 
2039     @DontCompile
2040     public void test86_verifier(boolean warmup) {
2041         NotFlattenable vt = new NotFlattenable();
2042         NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];
2043         test86(array1, vt, true);
2044         Asserts.assertEquals(array1[1], vt);
2045         test86(array1, null, false);
2046         Asserts.assertEquals(array1[1], null);
2047         if (!warmup) {
2048             NotFlattenable[] array2 = new NotFlattenable[2];
2049             try {
2050                 test86(array2, null, true);
2051                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2052             } catch (NullPointerException e) {
2053                 // Expected
2054             }
2055         }
2056     }
2057 
2058     // Same as test85 but with inline type array
2059     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
2060     public void test87(MyValue1.ref[] array, MyValue1.ref o, boolean b) {
2061         if (b) {
2062             array[0] = null;
2063         } else {
2064             array[1] = null;
2065         }
2066         array[1] = o;
2067     }
2068 
2069     @DontCompile
2070     public void test87_verifier(boolean warmup) {
2071         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
2072         MyValue1.ref[] array1 = new MyValue1.ref[2];
2073         test87(array1, vt, true);
2074         Asserts.assertEquals(array1[1], vt);
2075         test87(array1, null, false);
2076         Asserts.assertEquals(array1[1], null);
2077         if (!warmup) {
2078             MyValue1[] array2 = new MyValue1[2];
2079             try {
2080                 test87(array2, null, true);
2081                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2082             } catch (NullPointerException e) {
2083                 // Expected
2084             }
2085         }
2086     }
2087 
2088     // Additional correctness tests to make sure we have the required null checks
2089     @Test()
2090     public void test88(Object[] array, Integer v) {
2091         array[0] = v;
2092     }
2093 
2094     @DontCompile
2095     public void test88_verifier(boolean warmup) {
2096         Integer[] array1 = new Integer[1];
2097         Object[] array2 = new Object[1];
2098         test88(array1, null);
2099         Asserts.assertEquals(array1[0], null);
2100         test88(array2, null);
2101         Asserts.assertEquals(array2[0], null);
2102         if (!warmup) {
2103             MyValue1[] array3 = new MyValue1[1];
2104             try {
2105                 test88(array3, null);
2106                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2107             } catch (NullPointerException e) {
2108                 // Expected
2109             }
2110         }
2111     }
2112 
2113     @Test()
2114     public void test89(MyValue1.ref[] array, Integer v) {
2115         Object o = v;
2116         array[0] = (MyValue1.ref)o;
2117     }
2118 
2119     @DontCompile
2120     public void test89_verifier(boolean warmup) {
2121         MyValue1.ref[] array1 = new MyValue1.ref[1];
2122         test89(array1, null);
2123         Asserts.assertEquals(array1[0], null);
2124         if (!warmup) {
2125             MyValue1[] array2 = new MyValue1[1];
2126             try {
2127                 test89(array2, null);
2128                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2129             } catch (NullPointerException e) {
2130                 // Expected
2131             }
2132         }
2133     }
2134 
2135     @Test
2136     public boolean test90() {
2137         boolean b = true;
2138 
2139         MyValue1[] qArray = new MyValue1[0];
2140         MyValue1.ref[] lArray = new MyValue1.ref[0];
2141 
2142         b = b &amp;&amp; (qArray instanceof MyValue1[]);
2143         b = b &amp;&amp; (lArray instanceof MyValue1.ref[]);
2144 
2145         MyValue1[][] qArray2 = new MyValue1[0][0];
2146         MyValue1.ref[][] lArray2 = new MyValue1.ref[0][0];
2147 
2148         b = b &amp;&amp; (qArray2 instanceof MyValue1[][]);
2149         b = b &amp;&amp; (lArray2 instanceof MyValue1.ref[][]);
2150 
2151         return b;
2152     }
2153 
2154     @DontCompile
2155     public void test90_verifier(boolean warmup) {
2156         Asserts.assertEQ(test90(), true);
2157     }
2158 
2159     inline static final class Test91Value {
2160         public final int f0;
2161         public final int f1;
2162         public final int f2;
2163         public final int f3;
2164         public final int f4;
2165         public final int f5;
2166 
2167         public Test91Value(int i) {
2168             this.f0 = i;
2169             this.f1 = i;
2170             this.f2 = i;
2171             this.f3 = i;
2172             this.f4 = i;
2173             this.f5 = i;
2174         }
2175 
2176         public void verify() {
2177             if ((f0 != f1) || (f1 != f2) || (f2 != f3) || (f3 != f4) || (f4 != f5)) {
2178                 throw new RuntimeException(&quot;test91 failed&quot;);
2179             }
2180         }
2181     }
2182 
2183     // Test anti-dependencies between loads and stores from flattened array
2184     @Test
2185     @Warmup(0)
2186     public int test91(Test91Value[] array, int lo, int val) {
2187         int i = 3;
2188         while (lo &lt; i) {
2189             Test91Value tmp = array[lo];
2190             array[lo++] = array[i];
2191             array[i--] = tmp;
2192         }
2193         return val;
2194     }
2195 
2196     @DontCompile
2197     public void test91_verifier(boolean warmup) {
2198         Test91Value[] array = new Test91Value[5];
2199         for (int i = 0; i &lt; 5; ++i) {
2200             array[i] = new Test91Value(i);
2201             array[i].verify();
2202         }
2203         Asserts.assertEQ(test91(array, 0, 5), 5);
2204         for (int i = 0; i &lt; 5; ++i) {
2205             array[i].verify();
2206         }
2207     }
2208 
2209     @Test
2210     public void test92(Object[] src, Object[] dst) {
2211         System.arraycopy(src, 0, dst, 0, src.length);
2212     }
2213 
2214     @DontCompile
2215     public void test92_verifier(boolean warmup) {
2216         MyValue1[] a = new MyValue1[1];
2217         MyValue1[] b = new MyValue1[1];
2218         try {
2219             test92(a, null);
2220             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2221         } catch (NullPointerException expected) {}
2222 
2223         try {
2224             test92(null, b);
2225             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2226         } catch (NullPointerException expected) {}
2227 
2228         a[0] = MyValue1.createWithFieldsInline(rI, rL);
2229         test92(a, b);
2230         verify(a, b);
2231     }
2232 
2233     // Same as test30 but accessing all elements of the non-escaping array
2234     @Test
2235     public long test93(MyValue2[] src, boolean flag) {
2236         MyValue2[] dst = new MyValue2[10];
2237         System.arraycopy(src, 0, dst, 0, 10);
2238         if (flag) {  }
2239         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2240                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2241     }
2242 
2243     @DontCompile
2244     public void test93_verifier(boolean warmup) {
2245         MyValue2[] src = new MyValue2[10];
2246         for (int i = 0; i &lt; 10; ++i) {
2247             src[i] = MyValue2.createWithFieldsInline(rI, (rI % 2) == 0);
2248         }
2249         long res = test93(src, !warmup);
2250         long expected = 0;
2251         for (int i = 0; i &lt; 10; ++i) {
2252             expected += src[i].hash();
2253         }
2254         Asserts.assertEQ(res, expected);
2255     }
2256 
2257     // Same as test93 but with variable source array offset
2258     @Test
2259     public long test94(MyValue2[] src, int i, boolean flag) {
2260         MyValue2[] dst = new MyValue2[10];
2261         System.arraycopy(src, i, dst, 0, 1);
2262         if (flag) {  }
2263         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2264                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2265     }
2266 
2267     @DontCompile
2268     public void test94_verifier(boolean warmup) {
2269         MyValue2[] src = new MyValue2[10];
2270         for (int i = 0; i &lt; 10; ++i) {
2271             src[i] = MyValue2.createWithFieldsInline(i, (i % 2) == 0);
2272         }
2273         for (int i = 0; i &lt; 10; ++i) {
2274             long res = test94(src, i, !warmup);
2275             long expected = src[i].hash() + 9*MyValue2.default.hash();
2276             Asserts.assertEQ(res, expected);
2277         }
2278     }
2279 }
    </pre>
  </body>
</html>
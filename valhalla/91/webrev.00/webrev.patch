diff a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -639,11 +639,10 @@
 46bca5e5e6fb26efd07245d26fe96a9c3260f51e jdk-15+20
 12b55fad80f30d24b1f8fdb3b947ea6465ef9518 jdk-15+21
 7223c6d610343fd8323af9d07d501e01fa1a7696 jdk-15+22
 f143729ca00ec14a98ea5c7f73acba88da97746e jdk-15+23
 497fd9f9129c4928fd5a876dd55e0daf6298b511 jdk-15+24
-58833044988772ca06c97ab2f142474a8627af80 jdk-15+25
-58833044988772ca06c97ab2f142474a8627af80 jdk-15+25
 90b266a84c06f1b3dc0ed8767856793e8c1c357e jdk-15+25
 0a32396f7a690015d22ca3328ac441a358295d90 jdk-15+26
-506abc554caeb275928c02bf3a16e95d1978749f jdk-15+27
 93813843680bbe1b7efbca56c03fd137f20a2c31 jdk-16+0
+93813843680bbe1b7efbca56c03fd137f20a2c31 jdk-15+27
+4a485c89d5a08b495961835f5308a96038678aeb jdk-16+1
diff a/make/Main.gmk b/make/Main.gmk
--- a/make/Main.gmk
+++ b/make/Main.gmk
@@ -638,10 +638,22 @@
     MAKEFILE := test/JtregNativeJdk, \
     TARGET := test-image-jdk-jtreg-native, \
     DEPS := build-test-jdk-jtreg-native, \
 ))
 
+$(eval $(call SetupTarget, build-test-libtest-jtreg-native, \
+    MAKEFILE := test/JtregNativeLibTest, \
+    TARGET := build-test-libtest-jtreg-native, \
+    DEPS := buildtools-jdk, \
+))
+
+$(eval $(call SetupTarget, test-image-libtest-jtreg-native, \
+    MAKEFILE := test/JtregNativeLibTest, \
+    TARGET := test-image-libtest-jtreg-native, \
+    DEPS := build-test-libtest-jtreg-native, \
+))
+
 $(eval $(call SetupTarget, build-test-hotspot-jtreg-graal, \
     MAKEFILE := test/JtregGraalUnit, \
     TARGET := build-test-hotspot-jtreg-graal, \
     DEPS := exploded-image, \
 ))
@@ -980,10 +992,11 @@
   $(foreach t, $(ALL_EXPLODED_TEST_TARGETS), $(eval $t: exploded-image test-image))
 
   interim-image: $(INTERIM_JMOD_TARGETS)
 
   build-test-hotspot-jtreg-native: hotspot-$(JVM_VARIANT_MAIN)-libs
+  build-test-libtest-jtreg-native: hotspot-$(JVM_VARIANT_MAIN)-libs
 
 endif
 
 ################################################################################
 # Virtual targets without recipes
@@ -1103,11 +1116,11 @@
 
 # This target builds the documentation image
 docs-image: docs-jdk
 
 # This target builds the test image
-test-image: prepare-test-image test-image-jdk-jtreg-native test-image-demos-jdk
+test-image: prepare-test-image test-image-jdk-jtreg-native test-image-demos-jdk test-image-libtest-jtreg-native
 
 ifneq ($(JVM_TEST_IMAGE_TARGETS), )
   # If JVM_TEST_IMAGE_TARGETS is externally defined, use it instead of the
   # standard hotspot set of tests.
   test-image: $(JVM_TEST_IMAGE_TARGETS)
diff a/make/RunTests.gmk b/make/RunTests.gmk
--- a/make/RunTests.gmk
+++ b/make/RunTests.gmk
@@ -340,15 +340,17 @@
 
 hotspot_JTREG_MAX_MEM := 0
 hotspot_JTREG_ASSERT := false
 hotspot_JTREG_NATIVEPATH := $(TEST_IMAGE_DIR)/hotspot/jtreg/native
 jdk_JTREG_NATIVEPATH := $(TEST_IMAGE_DIR)/jdk/jtreg/native
+lib-test_JTREG_NATIVEPATH := $(TEST_IMAGE_DIR)/lib-test/jtreg/native
 
 jdk_JTREG_PROBLEM_LIST += $(TOPDIR)/test/jdk/ProblemList.txt
 jaxp_JTREG_PROBLEM_LIST += $(TOPDIR)/test/jaxp/ProblemList.txt
 langtools_JTREG_PROBLEM_LIST += $(TOPDIR)/test/langtools/ProblemList.txt
 hotspot_JTREG_PROBLEM_LIST += $(TOPDIR)/test/hotspot/jtreg/ProblemList.txt
+lib-test_JTREG_PROBLEM_LIST += $(TOPDIR)/test/lib-test/ProblemList.txt
 
 langtools_JTREG_MAX_MEM := 768m
 
 ################################################################################
 # Parse test selection
diff a/make/autoconf/flags-ldflags.m4 b/make/autoconf/flags-ldflags.m4
--- a/make/autoconf/flags-ldflags.m4
+++ b/make/autoconf/flags-ldflags.m4
@@ -60,21 +60,14 @@
 # CPU independent LDFLAGS setup, used for both target and build toolchain.
 AC_DEFUN([FLAGS_SETUP_LDFLAGS_HELPER],
 [
   # Setup basic LDFLAGS
   if test "x$TOOLCHAIN_TYPE" = xgcc; then
-    # If this is a --hash-style=gnu system, use --hash-style=both, why?
-    # We have previously set HAS_GNU_HASH if this is the case
-    if test -n "$HAS_GNU_HASH"; then
-      BASIC_LDFLAGS="-Wl,--hash-style=both"
-      LIBJSIG_HASHSTYLE_LDFLAGS="-Wl,--hash-style=both"
-    fi
-
     # Add -z,defs, to forbid undefined symbols in object files.
     # add -z,relro (mark relocations read only) for all libs
     # add -z,now ("full relro" - more of the Global Offset Table GOT is marked read only)
-    BASIC_LDFLAGS="$BASIC_LDFLAGS -Wl,-z,defs -Wl,-z,relro -Wl,-z,now"
+    BASIC_LDFLAGS="-Wl,--hash-style=gnu -Wl,-z,defs -Wl,-z,relro -Wl,-z,now"
     # Linux : remove unused code+data in link step
     if test "x$ENABLE_LINKTIME_GC" = xtrue; then
       if test "x$OPENJDK_TARGET_CPU" = xs390x; then
         BASIC_LDFLAGS="$BASIC_LDFLAGS -Wl,--gc-sections -Wl,--print-gc-sections"
       else
@@ -150,12 +143,10 @@
   fi
 
   # Export some intermediate variables for compatibility
   LDFLAGS_CXX_JDK="$BASIC_LDFLAGS_ONLYCXX $BASIC_LDFLAGS_ONLYCXX_JDK_ONLY $DEBUGLEVEL_LDFLAGS_JDK_ONLY"
   AC_SUBST(LDFLAGS_CXX_JDK)
-  AC_SUBST(LIBJSIG_HASHSTYLE_LDFLAGS)
-  AC_SUBST(LIBJSIG_NOEXECSTACK_LDFLAGS)
 ])
 
 ################################################################################
 # $1 - Either BUILD or TARGET to pick the correct OS/CPU variables to check
 #      conditionals against.
diff a/make/autoconf/jdk-version.m4 b/make/autoconf/jdk-version.m4
--- a/make/autoconf/jdk-version.m4
+++ b/make/autoconf/jdk-version.m4
@@ -177,22 +177,22 @@
       [Set version string @<:@calculated@:>@])])
   if test "x$with_version_string" = xyes; then
     AC_MSG_ERROR([--with-version-string must have a value])
   elif test "x$with_version_string" != x; then
     # Additional [] needed to keep m4 from mangling shell constructs.
-    if [ [[ $with_version_string =~ ^([0-9]+)(\.([0-9]+))?(\.([0-9]+))?(\.([0-9]+))?(\.([0-9]+))?(\.([0-9]+))?(\.([0-9]+))?(-([a-zA-Z]+))?((\+)([0-9]+)?(-([-a-zA-Z0-9.]+))?)?$ ]] ]; then
+    if [ [[ $with_version_string =~ ^([0-9]+)(\.([0-9]+))?(\.([0-9]+))?(\.([0-9]+))?(\.([0-9]+))?(\.([0-9]+))?(\.([0-9]+))?(-([a-zA-Z0-9]+))?(((\+)([0-9]*))?(-([-a-zA-Z0-9.]+))?)?$ ]] ]; then
       VERSION_FEATURE=${BASH_REMATCH[[1]]}
       VERSION_INTERIM=${BASH_REMATCH[[3]]}
       VERSION_UPDATE=${BASH_REMATCH[[5]]}
       VERSION_PATCH=${BASH_REMATCH[[7]]}
       VERSION_EXTRA1=${BASH_REMATCH[[9]]}
       VERSION_EXTRA2=${BASH_REMATCH[[11]]}
       VERSION_EXTRA3=${BASH_REMATCH[[13]]}
       VERSION_PRE=${BASH_REMATCH[[15]]}
-      version_plus_separator=${BASH_REMATCH[[17]]}
-      VERSION_BUILD=${BASH_REMATCH[[18]]}
-      VERSION_OPT=${BASH_REMATCH[[20]]}
+      version_plus_separator=${BASH_REMATCH[[18]]}
+      VERSION_BUILD=${BASH_REMATCH[[19]]}
+      VERSION_OPT=${BASH_REMATCH[[21]]}
       # Unspecified numerical fields are interpreted as 0.
       if test "x$VERSION_INTERIM" = x; then
         VERSION_INTERIM=0
       fi
       if test "x$VERSION_UPDATE" = x; then
@@ -231,12 +231,12 @@
       AC_MSG_ERROR([--with-version-pre must have a value])
     elif test "x$with_version_pre" = xno; then
       # Interpret --without-* as empty string instead of the literal "no"
       VERSION_PRE=
     else
-      # Only [a-zA-Z] is allowed in the VERSION_PRE. Outer [ ] to quote m4.
-      [ VERSION_PRE=`$ECHO "$with_version_pre" | $TR -c -d '[a-z][A-Z]'` ]
+      # Only [a-zA-Z0-9] is allowed in the VERSION_PRE. Outer [ ] to quote m4.
+      [ VERSION_PRE=`$ECHO "$with_version_pre" | $TR -c -d '[a-zA-Z0-9]'` ]
       if test "x$VERSION_PRE" != "x$with_version_pre"; then
         AC_MSG_WARN([--with-version-pre value has been sanitized from '$with_version_pre' to '$VERSION_PRE'])
       fi
     fi
   else
diff a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -487,13 +487,10 @@
 
 # CFLAGS used to compile the jdk native launchers (C-code)
 CFLAGS_JDKEXE:=@CFLAGS_JDKEXE@
 CXXFLAGS_JDKEXE:=@CXXFLAGS_JDKEXE@
 
-LIBJSIG_HASHSTYLE_LDFLAGS := @LIBJSIG_HASHSTYLE_LDFLAGS@
-LIBJSIG_NOEXECSTACK_LDFLAGS := @LIBJSIG_NOEXECSTACK_LDFLAGS@
-
 FDLIBM_CFLAGS := @FDLIBM_CFLAGS@
 JVM_CFLAGS := @JVM_CFLAGS@
 JVM_LDFLAGS := @JVM_LDFLAGS@
 JVM_ASFLAGS := @JVM_ASFLAGS@
 JVM_LIBS := @JVM_LIBS@
diff a/make/autoconf/toolchain.m4 b/make/autoconf/toolchain.m4
--- a/make/autoconf/toolchain.m4
+++ b/make/autoconf/toolchain.m4
@@ -970,16 +970,10 @@
         AC_MSG_ERROR([Target CPU mismatch. We are building for $OPENJDK_TARGET_CPU but CL is for "$COMPILER_CPU_TEST"; expected "x64".])
       fi
     fi
   fi
 
-  if test "x$TOOLCHAIN_TYPE" = xgcc; then
-    # If this is a --hash-style=gnu system, use --hash-style=both, why?
-    HAS_GNU_HASH=`$CC -dumpspecs 2>/dev/null | $GREP 'hash-style=gnu'`
-    # This is later checked when setting flags.
-  fi
-
   if test "x$TOOLCHAIN_TYPE" = xgcc || test "x$TOOLCHAIN_TYPE" = xclang; then
     # Check if linker has -z noexecstack.
     HAS_NOEXECSTACK=`$CC -Wl,--help 2>/dev/null | $GREP 'z noexecstack'`
     # This is later checked when setting flags.
   fi
@@ -1003,12 +997,31 @@
   if test "x$with_jtreg" = xno; then
     # jtreg disabled
     AC_MSG_CHECKING([for jtreg test harness])
     AC_MSG_RESULT([no, disabled])
   elif test "x$with_jtreg" != xyes && test "x$with_jtreg" != x; then
-    # An explicit path is specified, use it.
-    JT_HOME="$with_jtreg"
+    if test -d "$with_jtreg"; then
+      # An explicit path is specified, use it.
+      JT_HOME="$with_jtreg"
+    else
+      case "$with_jtreg" in
+        *.zip )
+          JTREG_SUPPORT_DIR=$CONFIGURESUPPORT_OUTPUTDIR/jtreg
+          $RM -rf $JTREG_SUPPORT_DIR
+          $MKDIR -p $JTREG_SUPPORT_DIR
+          $UNZIP -qq -d $JTREG_SUPPORT_DIR $with_jtreg
+
+          # Try to find jtreg to determine JT_HOME path
+          JTREG_PATH=`$FIND $JTREG_SUPPORT_DIR | $GREP "/bin/jtreg"`
+          if test "x$JTREG_PATH" != x; then
+            JT_HOME=$($DIRNAME $($DIRNAME $JTREG_PATH))
+          fi
+          ;;
+        * )
+          ;;
+      esac
+    fi
     UTIL_FIXUP_PATH([JT_HOME])
     if test ! -d "$JT_HOME"; then
       AC_MSG_ERROR([jtreg home directory from --with-jtreg=$with_jtreg does not exist])
     fi
 
diff a/make/autoconf/version-numbers b/make/autoconf/version-numbers
--- a/make/autoconf/version-numbers
+++ b/make/autoconf/version-numbers
@@ -36,11 +36,11 @@
 DEFAULT_VERSION_DATE=2021-03-16
 DEFAULT_VERSION_CLASSFILE_MAJOR=60  # "`$EXPR $DEFAULT_VERSION_FEATURE + 44`"
 DEFAULT_VERSION_CLASSFILE_MINOR=0
 DEFAULT_ACCEPTABLE_BOOT_VERSIONS="14 15 16"
 DEFAULT_JDK_SOURCE_TARGET_VERSION=16
-DEFAULT_PROMOTED_VERSION_PRE=ea
+DEFAULT_PROMOTED_VERSION_PRE=lworld3ea
 
 LAUNCHER_NAME=openjdk
 PRODUCT_NAME=OpenJDK
 PRODUCT_SUFFIX="Runtime Environment"
 JDK_RC_PLATFORM_NAME=Platform
diff a/make/common/FindTests.gmk b/make/common/FindTests.gmk
--- a/make/common/FindTests.gmk
+++ b/make/common/FindTests.gmk
@@ -41,11 +41,11 @@
 
 # TEST_BASEDIRS might have been set by a custom extension
 TEST_BASEDIRS += $(TOPDIR)/test $(TOPDIR)
 
 # JTREG_TESTROOTS might have been set by a custom extension
-JTREG_TESTROOTS += $(addprefix $(TOPDIR)/test/, hotspot/jtreg jdk langtools jaxp)
+JTREG_TESTROOTS += $(addprefix $(TOPDIR)/test/, hotspot/jtreg jdk langtools jaxp lib-test)
 
 # Extract the names of the Jtreg group files from the TEST.ROOT files. The
 # TEST.ROOT files being properties files can be interpreted as makefiles so
 # use include to get at the contents instead of expensive shell calls. We are
 # looking for the "groups" property in each file.
diff a/make/conf/jib-profiles.js b/make/conf/jib-profiles.js
--- a/make/conf/jib-profiles.js
+++ b/make/conf/jib-profiles.js
@@ -1345,11 +1345,11 @@
             preString = version_numbers.get("DEFAULT_PROMOTED_VERSION_PRE");
         }
         args = concat(args, "--with-version-pre=" + preString,
                      "--with-version-opt=" + optString);
     } else {
-        args = concat(args, "--with-version-pre=lworld2ea");
+        args = concat(args, "--with-version-pre=" + version_numbers.get("DEFAULT_PROMOTED_VERSION_PRE"));
         args = concat(args, "--with-version-opt=" + common.build_id);
     }
     return args;
 }
 
diff a/make/hotspot/lib/JvmOverrideFiles.gmk b/make/hotspot/lib/JvmOverrideFiles.gmk
--- a/make/hotspot/lib/JvmOverrideFiles.gmk
+++ b/make/hotspot/lib/JvmOverrideFiles.gmk
@@ -60,10 +60,11 @@
 
   ifeq ($(TOOLCHAIN_TYPE), clang)
     JVM_PRECOMPILED_HEADER_EXCLUDE := \
 	sharedRuntimeTrig.cpp \
 	sharedRuntimeTrans.cpp \
+        $(OPT_SPEED_SRC) \
 	#
   endif
 
   ifeq ($(call isTargetCpu, x86), true)
     # Performance measurements show that by compiling GC related code, we could
@@ -109,10 +110,11 @@
         sharedRuntimeTrig.cpp \
         sharedRuntimeTrans.cpp \
         loopTransform.cpp \
         unsafe.cpp \
         jvmciCompilerToVM.cpp \
+        $(OPT_SPEED_SRC) \
         #
   endif
 
 else ifeq ($(call isTargetOs, aix), true)
   BUILD_LIBJVM_synchronizer.cpp_CXXFLAGS := -qnoinline
diff a/make/test/JtregNativeHotspot.gmk b/make/test/JtregNativeHotspot.gmk
--- a/make/test/JtregNativeHotspot.gmk
+++ b/make/test/JtregNativeHotspot.gmk
@@ -870,14 +870,12 @@
 BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exesigtest := -ljvm
 
 ifeq ($(call isTargetOs, windows), true)
     BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS_exeFPRegs := -MT
     BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c
-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exejvm-test-launcher := jvm.lib
     BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit := jvm.lib
 else
-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exejvm-test-launcher := -ljvm
     BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbootclssearch_agent += -lpthread
     BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsystemclssearch_agent += -lpthread
     BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop001 += -lpthread
     BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop002 += -lpthread
     BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal001 += -lpthread
diff a/make/test/JtregNativeLibTest.gmk b/make/test/JtregNativeLibTest.gmk
--- /dev/null
+++ b/make/test/JtregNativeLibTest.gmk
@@ -0,0 +1,94 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+################################################################################
+# This file builds the native component of the JTReg tests for testlibrary.
+# It also covers the test-image part, where the built files are copied to the
+# test image.
+################################################################################
+
+default: all
+
+include $(SPEC)
+include MakeBase.gmk
+include TestFilesCompilation.gmk
+
+$(eval $(call IncludeCustomExtension, test/JtregNativeLibTest.gmk))
+
+################################################################################
+# Targets for building the native tests themselves.
+################################################################################
+
+# This might have been added to by a custom extension.
+BUILD_LIBTEST_JTREG_NATIVE_SRC += $(TOPDIR)/test/lib-test
+
+BUILD_LIBTEST_JTREG_OUTPUT_DIR := $(OUTPUTDIR)/support/test/lib-test/jtreg/native
+
+BUILD_LIBTEST_JTREG_IMAGE_DIR := $(TEST_IMAGE_DIR)/lib-test/jtreg
+
+ifeq ($(call isTargetOs, windows), true)
+    BUILD_LIBTEST_JTREG_EXECUTABLES_LIBS_exejvm-test-launcher := jvm.lib
+else
+    BUILD_LIBTEST_JTREG_EXECUTABLES_LIBS_exejvm-test-launcher := -ljvm
+endif
+
+# This evaluation is expensive and should only be done if this target was
+# explicitly called.
+ifneq ($(filter build-test-libtest-jtreg-native, $(MAKECMDGOALS)), )
+  $(eval $(call SetupTestFilesCompilation, BUILD_LIBTEST_JTREG_LIBRARIES, \
+      TYPE := LIBRARY, \
+      SOURCE_DIRS := $(BUILD_LIBTEST_JTREG_NATIVE_SRC), \
+      OUTPUT_DIR := $(BUILD_LIBTEST_JTREG_OUTPUT_DIR), \
+      EXCLUDE := $(BUILD_LIBTEST_JTREG_EXCLUDE), \
+  ))
+
+  $(eval $(call SetupTestFilesCompilation, BUILD_LIBTEST_JTREG_EXECUTABLES, \
+      TYPE := PROGRAM, \
+      SOURCE_DIRS := $(BUILD_LIBTEST_JTREG_NATIVE_SRC), \
+      OUTPUT_DIR := $(BUILD_LIBTEST_JTREG_OUTPUT_DIR), \
+      EXCLUDE := $(BUILD_LIBTEST_JTREG_EXCLUDE), \
+  ))
+endif
+
+build-test-libtest-jtreg-native: $(BUILD_LIBTEST_JTREG_LIBRARIES) $(BUILD_LIBTEST_JTREG_EXECUTABLES)
+
+################################################################################
+# Targets for building test-image.
+################################################################################
+
+# Copy to lib-test jtreg test image
+$(eval $(call SetupCopyFiles, COPY_LIBTEST_JTREG_NATIVE, \
+    SRC := $(BUILD_LIBTEST_JTREG_OUTPUT_DIR), \
+    DEST := $(TEST_IMAGE_DIR)/lib-test/jtreg/native, \
+    FILES := $(wildcard $(addprefix $(BUILD_LIBTEST_JTREG_OUTPUT_DIR), /bin/* /lib/*)), \
+    FLATTEN := true, \
+))
+
+test-image-libtest-jtreg-native: $(COPY_LIBTEST_JTREG_NATIVE)
+
+all: build-test-libtest-jtreg-native
+test-image: test-image-libtest-jtreg-native
+
+.PHONY: default all build-test-libtest-jtreg-native test-image-libtest-jtreg-native test-image
diff a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -1333,11 +1333,11 @@
 
   stp(r0, rscratch1, Address(pre(sp, -2 * wordSize)));
   stp(rscratch2, lr, Address(pre(sp, -2 * wordSize)));
 
   mov(r0, reg);
-  mov(rscratch1, (address)b);
+  movptr(rscratch1, (uintptr_t)(address)b);
 
   // call indirectly to solve generation ordering problem
   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
   ldr(rscratch2, Address(rscratch2));
   blr(rscratch2);
@@ -1373,11 +1373,11 @@
     lea(r0, addr);
     ldr(r0, Address(r0, 4 * wordSize));
   } else {
     ldr(r0, addr);
   }
-  mov(rscratch1, (address)b);
+  movptr(rscratch1, (uintptr_t)(address)b);
 
   // call indirectly to solve generation ordering problem
   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
   ldr(rscratch2, Address(rscratch2));
   blr(rscratch2);
diff a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
@@ -1403,17 +1403,15 @@
   // can be walked in order to produce the proper set of loads
   GrowableArray<MoveOperation*>* get_store_order(VMRegPair temp_register) { Unimplemented(); return 0; }
 };
 
 
-static void rt_call(MacroAssembler* masm, address dest, int gpargs, int fpargs, int type) {
+static void rt_call(MacroAssembler* masm, address dest) {
   CodeBlob *cb = CodeCache::find_blob(dest);
   if (cb) {
     __ far_call(RuntimeAddress(dest));
   } else {
-    assert((unsigned)gpargs < 256, "eek!");
-    assert((unsigned)fpargs < 32, "eek!");
     __ lea(rscratch1, RuntimeAddress(dest));
     __ blr(rscratch1);
     __ maybe_isb();
   }
 }
@@ -2078,38 +2076,11 @@
   // Now set thread in native
   __ mov(rscratch1, _thread_in_native);
   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
   __ stlrw(rscratch1, rscratch2);
 
-  {
-    int return_type = 0;
-    switch (ret_type) {
-    case T_VOID: break;
-      return_type = 0; break;
-    case T_CHAR:
-    case T_BYTE:
-    case T_SHORT:
-    case T_INT:
-    case T_BOOLEAN:
-    case T_LONG:
-      return_type = 1; break;
-    case T_ARRAY:
-    case T_VALUETYPE:
-    case T_OBJECT:
-      return_type = 1; break;
-    case T_FLOAT:
-      return_type = 2; break;
-    case T_DOUBLE:
-      return_type = 3; break;
-    default:
-      ShouldNotReachHere();
-    }
-    rt_call(masm, native_func,
-            int_args + 2, // AArch64 passes up to 8 args in int registers
-            float_args,   // and up to 8 float args
-            return_type);
-  }
+  rt_call(masm, native_func);
 
   __ bind(native_return);
 
   intptr_t return_pc = (intptr_t) __ pc();
   oop_maps->add_gc_map(return_pc - start, map);
@@ -2316,11 +2287,11 @@
     // Save pending exception around call to VM (which contains an EXCEPTION_MARK)
     // NOTE that obj_reg == r19 currently
     __ ldr(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
     __ str(zr, Address(rthread, in_bytes(Thread::pending_exception_offset())));
 
-    rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C), 3, 0, 1);
+    rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));
 
 #ifdef ASSERT
     {
       Label L;
       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
@@ -2343,11 +2314,11 @@
 
   // SLOW PATH Reguard the stack if needed
 
   __ bind(reguard);
   save_native_result(masm, ret_type, stack_slots);
-  rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), 0, 0, 0);
+  rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
   restore_native_result(masm, ret_type, stack_slots);
   // and continue
   __ b(reguard_done);
 
   // SLOW PATH safepoint
diff a/src/hotspot/os/bsd/globals_bsd.hpp b/src/hotspot/os/bsd/globals_bsd.hpp
--- a/src/hotspot/os/bsd/globals_bsd.hpp
+++ b/src/hotspot/os/bsd/globals_bsd.hpp
@@ -34,19 +34,11 @@
                          product_pd, \
                          diagnostic, \
                          diagnostic_pd, \
                          notproduct, \
                          range, \
-                         constraint) \
-                                                                                \
-  product(bool, UseOprofile, false,                                             \
-        "enable support for Oprofile profiler")                                 \
-                                                                                \
-  /*  NB: The default value of UseBsdPosixThreadCPUClocks may be  */            \
-  /*  overridden in Arguments::parse_each_vm_init_arg.            */            \
-  product(bool, UseBsdPosixThreadCPUClocks, true,                               \
-          "enable fast Bsd Posix clocks where available")                       \
+                         constraint)
 
 //
 // Defines Bsd-specific default values. The flags are available on all
 // platforms, but they may have different default values on other platforms.
 //
diff a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -1877,46 +1877,10 @@
 int os::vm_allocation_granularity() {
   assert(os::Bsd::page_size() != -1, "must call os::init");
   return os::Bsd::page_size();
 }
 
-// Rationale behind this function:
-//  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable
-//  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get
-//  samples for JITted code. Here we create private executable mapping over the code cache
-//  and then we can use standard (well, almost, as mapping can change) way to provide
-//  info for the reporting script by storing timestamp and location of symbol
-void bsd_wrap_code(char* base, size_t size) {
-  static volatile jint cnt = 0;
-
-  if (!UseOprofile) {
-    return;
-  }
-
-  char buf[PATH_MAX + 1];
-  int num = Atomic::add(&cnt, 1);
-
-  snprintf(buf, PATH_MAX + 1, "%s/hs-vm-%d-%d",
-           os::get_temp_directory(), os::current_process_id(), num);
-  unlink(buf);
-
-  int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);
-
-  if (fd != -1) {
-    off_t rv = ::lseek(fd, size-2, SEEK_SET);
-    if (rv != (off_t)-1) {
-      if (::write(fd, "", 1) == 1) {
-        mmap(base, size,
-             PROT_READ|PROT_WRITE|PROT_EXEC,
-             MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);
-      }
-    }
-    ::close(fd);
-    unlink(buf);
-  }
-}
-
 static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
                                     int err) {
   warning("INFO: os::commit_memory(" INTPTR_FORMAT ", " SIZE_FORMAT
           ", %d) failed; error='%s' (errno=%d)", (intptr_t)addr, size, exec,
            os::errno_name(err), err);
diff a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -3249,14 +3249,14 @@
         set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, "numa_all_nodes_ptr"));
         set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, "numa_nodes_ptr"));
         set_numa_interleave_bitmask(_numa_get_interleave_mask());
         set_numa_membind_bitmask(_numa_get_membind());
         // Create an index -> node mapping, since nodes are not always consecutive
-        _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);
+        _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, mtInternal);
         rebuild_nindex_to_node_map();
         // Create a cpu -> node mapping
-        _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);
+        _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, mtInternal);
         rebuild_cpu_to_node_map();
         return true;
       }
     }
   }
diff a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -69,22 +69,19 @@
 #include "services/runtimeService.hpp"
 #include "utilities/align.hpp"
 #include "utilities/decoder.hpp"
 #include "utilities/defaultStream.hpp"
 #include "utilities/events.hpp"
-#include "utilities/growableArray.hpp"
 #include "utilities/macros.hpp"
 #include "utilities/vmError.hpp"
 #include "symbolengine.hpp"
 #include "windbghelp.hpp"
 
-
 #ifdef _DEBUG
 #include <crtdbg.h>
 #endif
 
-
 #include <windows.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/timeb.h>
 #include <objidl.h>
diff a/src/hotspot/share/aot/aotLoader.cpp b/src/hotspot/share/aot/aotLoader.cpp
--- a/src/hotspot/share/aot/aotLoader.cpp
+++ b/src/hotspot/share/aot/aotLoader.cpp
@@ -32,12 +32,12 @@
 #include "oops/method.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/timerTrace.hpp"
 
-GrowableArray<AOTCodeHeap*>* AOTLoader::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<AOTCodeHeap*> (2, true);
-GrowableArray<AOTLib*>* AOTLoader::_libraries = new(ResourceObj::C_HEAP, mtCode) GrowableArray<AOTLib*> (2, true);
+GrowableArray<AOTCodeHeap*>* AOTLoader::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<AOTCodeHeap*> (2, mtCode);
+GrowableArray<AOTLib*>* AOTLoader::_libraries = new(ResourceObj::C_HEAP, mtCode) GrowableArray<AOTLib*> (2, mtCode);
 
 // Iterate over all AOT CodeHeaps
 #define FOR_ALL_AOT_HEAPS(heap) for (GrowableArrayIterator<AOTCodeHeap*> heap = heaps()->begin(); heap != heaps()->end(); ++heap)
 // Iterate over all AOT Libraries
 #define FOR_ALL_AOT_LIBRARIES(lib) for (GrowableArrayIterator<AOTLib*> lib = libraries()->begin(); lib != libraries()->end(); ++lib)
diff a/src/hotspot/share/ci/ciTypeFlow.cpp b/src/hotspot/share/ci/ciTypeFlow.cpp
--- a/src/hotspot/share/ci/ciTypeFlow.cpp
+++ b/src/hotspot/share/ci/ciTypeFlow.cpp
@@ -60,11 +60,11 @@
   if (arena != NULL) {
     // Allocate growable array in Arena.
     _set = new (arena) GrowableArray<JsrRecord*>(arena, default_len, 0, NULL);
   } else {
     // Allocate growable array in current ResourceArea.
-    _set = new GrowableArray<JsrRecord*>(4, 0, NULL, false);
+    _set = new GrowableArray<JsrRecord*>(4, 0, NULL);
   }
 }
 
 // ------------------------------------------------------------------
 // ciTypeFlow::JsrSet::copy_into
diff a/src/hotspot/share/classfile/classListParser.cpp b/src/hotspot/share/classfile/classListParser.cpp
--- a/src/hotspot/share/classfile/classListParser.cpp
+++ b/src/hotspot/share/classfile/classListParser.cpp
@@ -61,11 +61,11 @@
     char errmsg[JVM_MAXPATHLEN];
     os::lasterror(errmsg, JVM_MAXPATHLEN);
     vm_exit_during_initialization("Loading classlist failed", errmsg);
   }
   _line_no = 0;
-  _interfaces = new (ResourceObj::C_HEAP, mtClass) GrowableArray<int>(10, true);
+  _interfaces = new (ResourceObj::C_HEAP, mtClass) GrowableArray<int>(10, mtClass);
 }
 
 ClassListParser::~ClassListParser() {
   if (_file) {
     fclose(_file);
diff a/src/hotspot/share/classfile/classLoader.cpp b/src/hotspot/share/classfile/classLoader.cpp
--- a/src/hotspot/share/classfile/classLoader.cpp
+++ b/src/hotspot/share/classfile/classLoader.cpp
@@ -581,11 +581,11 @@
   Thread* THREAD = Thread::current();
   GrowableArray<ModulePatchPath*>* patch_mod_args = Arguments::get_patch_mod_prefix();
   int num_of_entries = patch_mod_args->length();
 
   // Set up the boot loader's _patch_mod_entries list
-  _patch_mod_entries = new (ResourceObj::C_HEAP, mtModule) GrowableArray<ModuleClassPathList*>(num_of_entries, true);
+  _patch_mod_entries = new (ResourceObj::C_HEAP, mtModule) GrowableArray<ModuleClassPathList*>(num_of_entries, mtModule);
 
   for (int i = 0; i < num_of_entries; i++) {
     const char* module_name = (patch_mod_args->at(i))->module_name();
     Symbol* const module_sym = SymbolTable::new_symbol(module_name);
     assert(module_sym != NULL, "Failed to obtain Symbol for module name");
@@ -1607,11 +1607,11 @@
     // Set up the boot loader's _exploded_entries list.  Note that this gets
     // done before loading any classes, by the same thread that will
     // subsequently do the first class load. So, no lock is needed for this.
     assert(_exploded_entries == NULL, "Should only get initialized once");
     _exploded_entries = new (ResourceObj::C_HEAP, mtModule)
-      GrowableArray<ModuleClassPathList*>(EXPLODED_ENTRY_SIZE, true);
+      GrowableArray<ModuleClassPathList*>(EXPLODED_ENTRY_SIZE, mtModule);
     add_to_exploded_build_list(vmSymbols::java_base(), CHECK);
   }
 }
 
 bool ClassLoader::get_canonical_path(const char* orig, char* out, int len) {
diff a/src/hotspot/share/classfile/classLoaderData.cpp b/src/hotspot/share/classfile/classLoaderData.cpp
--- a/src/hotspot/share/classfile/classLoaderData.cpp
+++ b/src/hotspot/share/classfile/classLoaderData.cpp
@@ -815,11 +815,11 @@
 void ClassLoaderData::add_to_deallocate_list(Metadata* m) {
   // Metadata in shared region isn't deleted.
   if (!m->is_shared()) {
     MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
     if (_deallocate_list == NULL) {
-      _deallocate_list = new (ResourceObj::C_HEAP, mtClass) GrowableArray<Metadata*>(100, true);
+      _deallocate_list = new (ResourceObj::C_HEAP, mtClass) GrowableArray<Metadata*>(100, mtClass);
     }
     _deallocate_list->append_if_missing(m);
     log_debug(class, loader, data)("deallocate added for %s", m->print_value_string());
     ClassLoaderDataGraph::set_should_clean_deallocate_lists();
   }
diff a/src/hotspot/share/classfile/classLoaderExt.cpp b/src/hotspot/share/classfile/classLoaderExt.cpp
--- a/src/hotspot/share/classfile/classLoaderExt.cpp
+++ b/src/hotspot/share/classfile/classLoaderExt.cpp
@@ -308,11 +308,11 @@
 
 ClassPathEntry* ClassLoaderExt::find_classpath_entry_from_cache(const char* path, TRAPS) {
   // This is called from dump time so it's single threaded and there's no need for a lock.
   assert(DumpSharedSpaces, "this function is only used with -Xshare:dump");
   if (cached_path_entries == NULL) {
-    cached_path_entries = new (ResourceObj::C_HEAP, mtClass) GrowableArray<CachedClassPathEntry>(20, /*c heap*/ true);
+    cached_path_entries = new (ResourceObj::C_HEAP, mtClass) GrowableArray<CachedClassPathEntry>(20, mtClass);
   }
   CachedClassPathEntry ccpe;
   for (int i=0; i<cached_path_entries->length(); i++) {
     ccpe = cached_path_entries->at(i);
     if (strcmp(ccpe._path, path) == 0) {
diff a/src/hotspot/share/classfile/compactHashtable.cpp b/src/hotspot/share/classfile/compactHashtable.cpp
--- a/src/hotspot/share/classfile/compactHashtable.cpp
+++ b/src/hotspot/share/classfile/compactHashtable.cpp
@@ -49,11 +49,11 @@
   assert(_num_buckets > 0, "no buckets");
 
   _num_entries_written = 0;
   _buckets = NEW_C_HEAP_ARRAY(GrowableArray<Entry>*, _num_buckets, mtSymbol);
   for (int i=0; i<_num_buckets; i++) {
-    _buckets[i] = new (ResourceObj::C_HEAP, mtSymbol) GrowableArray<Entry>(0, true, mtSymbol);
+    _buckets[i] = new (ResourceObj::C_HEAP, mtSymbol) GrowableArray<Entry>(0, mtSymbol);
   }
 
   _stats = stats;
   _compact_buckets = NULL;
   _compact_entries = NULL;
diff a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -967,15 +967,15 @@
 }
 
 // Statically allocate fixup lists because they always get created.
 void java_lang_Class::allocate_fixup_lists() {
   GrowableArray<Klass*>* mirror_list =
-    new (ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(40, true);
+    new (ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(40, mtClass);
   set_fixup_mirror_list(mirror_list);
 
   GrowableArray<Klass*>* module_list =
-    new (ResourceObj::C_HEAP, mtModule) GrowableArray<Klass*>(500, true);
+    new (ResourceObj::C_HEAP, mtModule) GrowableArray<Klass*>(500, mtModule);
   set_fixup_module_field_list(module_list);
 }
 
 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
                                     Handle module, Handle protection_domain,
diff a/src/hotspot/share/classfile/moduleEntry.cpp b/src/hotspot/share/classfile/moduleEntry.cpp
--- a/src/hotspot/share/classfile/moduleEntry.cpp
+++ b/src/hotspot/share/classfile/moduleEntry.cpp
@@ -159,11 +159,11 @@
   if (m == NULL) {
     set_can_read_all_unnamed();
   } else {
     if (_reads == NULL) {
       // Lazily create a module's reads list
-      _reads = new (ResourceObj::C_HEAP, mtModule)GrowableArray<ModuleEntry*>(MODULE_READS_SIZE, true);
+      _reads = new (ResourceObj::C_HEAP, mtModule) GrowableArray<ModuleEntry*>(MODULE_READS_SIZE, mtModule);
     }
 
     // Determine, based on this newly established read edge to module m,
     // if this module's read list should be walked at a GC safepoint.
     set_read_walk_required(m->loader_data());
diff a/src/hotspot/share/classfile/packageEntry.cpp b/src/hotspot/share/classfile/packageEntry.cpp
--- a/src/hotspot/share/classfile/packageEntry.cpp
+++ b/src/hotspot/share/classfile/packageEntry.cpp
@@ -51,11 +51,11 @@
 void PackageEntry::add_qexport(ModuleEntry* m) {
   assert(Module_lock->owned_by_self(), "should have the Module_lock");
   if (!has_qual_exports_list()) {
     // Lazily create a package's qualified exports list.
     // Initial size is small, do not anticipate export lists to be large.
-    _qualified_exports = new (ResourceObj::C_HEAP, mtModule) GrowableArray<ModuleEntry*>(QUAL_EXP_SIZE, true);
+    _qualified_exports = new (ResourceObj::C_HEAP, mtModule) GrowableArray<ModuleEntry*>(QUAL_EXP_SIZE, mtModule);
   }
 
   // Determine, based on this newly established export to module m,
   // if this package's export list should be walked at a GC safepoint.
   set_export_walk_required(m->loader_data());
diff a/src/hotspot/share/classfile/stringTable.cpp b/src/hotspot/share/classfile/stringTable.cpp
--- a/src/hotspot/share/classfile/stringTable.cpp
+++ b/src/hotspot/share/classfile/stringTable.cpp
@@ -621,11 +621,11 @@
 
 size_t StringTable::verify_and_compare_entries() {
   Thread* thr = Thread::current();
   GrowableArray<oop>* oops =
     new (ResourceObj::C_HEAP, mtInternal)
-      GrowableArray<oop>((int)_current_size, true);
+      GrowableArray<oop>((int)_current_size, mtInternal);
 
   VerifyCompStrings vcs(oops);
   if (!_local_table->try_scan(thr, vcs)) {
     log_info(stringtable)("verify unavailable at this moment");
   }
diff a/src/hotspot/share/classfile/systemDictionaryShared.cpp b/src/hotspot/share/classfile/systemDictionaryShared.cpp
--- a/src/hotspot/share/classfile/systemDictionaryShared.cpp
+++ b/src/hotspot/share/classfile/systemDictionaryShared.cpp
@@ -323,11 +323,11 @@
 public:
   GrowableArray<InstanceKlass*>* _proxy_klasses;
   DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}
   void add_proxy_klass(InstanceKlass* proxy_klass) {
     if (_proxy_klasses == NULL) {
-      _proxy_klasses = new (ResourceObj::C_HEAP, mtInternal)GrowableArray<InstanceKlass*>(5, true);
+      _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<InstanceKlass*>(5, mtClassShared);
     }
     assert(_proxy_klasses != NULL, "sanity");
     _proxy_klasses->append(proxy_klass);
   }
 };
@@ -1545,14 +1545,14 @@
 }
 
 void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,
          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
   if (_verifier_constraints == NULL) {
-    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, true, mtClass);
+    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);
   }
   if (_verifier_constraint_flags == NULL) {
-    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, true, mtClass);
+    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);
   }
   GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;
   for (int i = 0; i < vc_array->length(); i++) {
     DTVerifierConstraint* p = vc_array->adr_at(i);
     if (name == p->_name && from_name == p->_from_name) {
@@ -1728,11 +1728,11 @@
 
 void DumpTimeSharedClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {
   assert(loader1 != loader2, "sanity");
   LogTarget(Info, class, loader, constraints) log;
   if (_loader_constraints == NULL) {
-    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, true, mtClass);
+    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);
   }
   char lt1 = get_loader_type_by(loader1());
   char lt2 = get_loader_type_by(loader2());
   DTLoaderConstraint lc(name, lt1, lt2);
   for (int i = 0; i < _loader_constraints->length(); i++) {
diff a/src/hotspot/share/classfile/verifier.cpp b/src/hotspot/share/classfile/verifier.cpp
--- a/src/hotspot/share/classfile/verifier.cpp
+++ b/src/hotspot/share/classfile/verifier.cpp
@@ -133,12 +133,19 @@
 
 // Prints the end-verification message to the appropriate output.
 void Verifier::log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, TRAPS) {
   if (HAS_PENDING_EXCEPTION) {
     st->print("Verification for %s has", klassName);
-    st->print_cr(" exception pending %s ",
+    oop message = java_lang_Throwable::message(PENDING_EXCEPTION);
+    if (message != NULL) {
+      char* ex_msg = java_lang_String::as_utf8_string(message);
+      st->print_cr(" exception pending '%s %s'",
+                 PENDING_EXCEPTION->klass()->external_name(), ex_msg);
+    } else {
+      st->print_cr(" exception pending %s ",
                  PENDING_EXCEPTION->klass()->external_name());
+    }
   } else if (exception_name != NULL) {
     st->print_cr("Verification for %s failed", klassName);
   }
   st->print_cr("End class verification for: %s", klassName);
 }
diff a/src/hotspot/share/classfile/vmSymbols.hpp b/src/hotspot/share/classfile/vmSymbols.hpp
--- a/src/hotspot/share/classfile/vmSymbols.hpp
+++ b/src/hotspot/share/classfile/vmSymbols.hpp
@@ -602,16 +602,10 @@
   template(com_sun_management_GcInfo,                  "com/sun/management/GcInfo")                               \
   template(com_sun_management_GcInfo_constructor_signature, "(Lcom/sun/management/internal/GcInfoBuilder;JJJ[Ljava/lang/management/MemoryUsage;[Ljava/lang/management/MemoryUsage;[Ljava/lang/Object;)V") \
   template(createGCNotification_name,                  "createGCNotification")                                    \
   template(createGCNotification_signature,             "(JLjava/lang/String;Ljava/lang/String;Ljava/lang/String;Lcom/sun/management/GcInfo;)V") \
   template(createDiagnosticFrameworkNotification_name, "createDiagnosticFrameworkNotification")                   \
-  template(createMemoryPoolMBean_name,                 "createMemoryPoolMBean")                                   \
-  template(createMemoryManagerMBean_name,              "createMemoryManagerMBean")                                \
-  template(createGarbageCollectorMBean_name,           "createGarbageCollectorMBean")                             \
-  template(createMemoryPoolMBean_signature,            "(Ljava/lang/String;ZJJ)Ljava/lang/management/MemoryPoolMBean;") \
-  template(createMemoryManagerMBean_signature,         "(Ljava/lang/String;)Ljava/lang/management/MemoryManagerMBean;") \
-  template(createGarbageCollectorMBean_signature,      "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/management/GarbageCollectorMBean;") \
   template(trigger_name,                               "trigger")                                                 \
   template(clear_name,                                 "clear")                                                   \
   template(trigger_method_signature,                   "(ILjava/lang/management/MemoryUsage;)V")                  \
   template(startAgent_name,                            "startAgent")                                              \
   template(startRemoteAgent_name,                      "startRemoteManagementAgent")                              \
diff a/src/hotspot/share/code/codeCache.cpp b/src/hotspot/share/code/codeCache.cpp
--- a/src/hotspot/share/code/codeCache.cpp
+++ b/src/hotspot/share/code/codeCache.cpp
@@ -148,14 +148,14 @@
 address CodeCache::_high_bound = 0;
 int CodeCache::_number_of_nmethods_with_dependencies = 0;
 ExceptionCache* volatile CodeCache::_exception_cache_purge_list = NULL;
 
 // Initialize arrays of CodeHeap subsets
-GrowableArray<CodeHeap*>* CodeCache::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<CodeHeap*> (CodeBlobType::All, true);
-GrowableArray<CodeHeap*>* CodeCache::_compiled_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<CodeHeap*> (CodeBlobType::All, true);
-GrowableArray<CodeHeap*>* CodeCache::_nmethod_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<CodeHeap*> (CodeBlobType::All, true);
-GrowableArray<CodeHeap*>* CodeCache::_allocable_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<CodeHeap*> (CodeBlobType::All, true);
+GrowableArray<CodeHeap*>* CodeCache::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<CodeHeap*> (CodeBlobType::All, mtCode);
+GrowableArray<CodeHeap*>* CodeCache::_compiled_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<CodeHeap*> (CodeBlobType::All, mtCode);
+GrowableArray<CodeHeap*>* CodeCache::_nmethod_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<CodeHeap*> (CodeBlobType::All, mtCode);
+GrowableArray<CodeHeap*>* CodeCache::_allocable_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray<CodeHeap*> (CodeBlobType::All, mtCode);
 
 void CodeCache::check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set) {
   size_t total_size = non_nmethod_size + profiled_size + non_profiled_size;
   // Prepare error message
   const char* error = "Invalid code heap sizes";
@@ -1041,11 +1041,11 @@
 // We don't really expect this table to grow very large.  If it does, it can become a hashtable.
 static GrowableArray<CompiledMethod*>* old_compiled_method_table = NULL;
 
 static void add_to_old_table(CompiledMethod* c) {
   if (old_compiled_method_table == NULL) {
-    old_compiled_method_table = new (ResourceObj::C_HEAP, mtCode) GrowableArray<CompiledMethod*>(100, true);
+    old_compiled_method_table = new (ResourceObj::C_HEAP, mtCode) GrowableArray<CompiledMethod*>(100, mtCode);
   }
   old_compiled_method_table->push(c);
 }
 
 static void reset_old_method_table() {
diff a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -685,11 +685,11 @@
 #endif // INCLUDE_JVMCI
 
   // Start the compiler thread(s) and the sweeper thread
   init_compiler_sweeper_threads();
   // totalTime performance counter is always created as it is required
-  // by the implementation of java.lang.management.CompilationMBean.
+  // by the implementation of java.lang.management.CompilationMXBean.
   {
     // Ensure OOM leads to vm_exit_during_initialization.
     EXCEPTION_MARK;
     _perf_total_compilation =
                  PerfDataManager::create_counter(JAVA_CI, "totalTime",
@@ -2476,11 +2476,11 @@
     _t_invalidated_compilation.add(time);
   } else {
     // Compilation succeeded
 
     // update compilation ticks - used by the implementation of
-    // java.lang.management.CompilationMBean
+    // java.lang.management.CompilationMXBean
     _perf_total_compilation->inc(time.ticks());
     _peak_compilation_time = time.milliseconds() > _peak_compilation_time ? time.milliseconds() : _peak_compilation_time;
 
     if (CITime) {
       int bytes_compiled = method->code_size() + task->num_inlined_bytecodes();
diff a/src/hotspot/share/compiler/compilerDefinitions.cpp b/src/hotspot/share/compiler/compilerDefinitions.cpp
--- a/src/hotspot/share/compiler/compilerDefinitions.cpp
+++ b/src/hotspot/share/compiler/compilerDefinitions.cpp
@@ -505,12 +505,12 @@
   }
 #ifndef PRODUCT
   if (!IncrementalInline) {
     AlwaysIncrementalInline = false;
   }
-  if (PrintIdealGraphLevel > 0) {
-    FLAG_SET_ERGO(PrintIdealGraph, true);
+  if (FLAG_IS_CMDLINE(PrintIdealGraph) && !PrintIdealGraph) {
+    FLAG_SET_ERGO(PrintIdealGraphLevel, -1);
   }
 #endif
   if (!UseTypeSpeculation && FLAG_IS_DEFAULT(TypeProfileLevel)) {
     // nothing to use the profiling, turn if off
     FLAG_SET_DEFAULT(TypeProfileLevel, 0);
diff a/src/hotspot/share/compiler/compilerEvent.cpp b/src/hotspot/share/compiler/compilerEvent.cpp
--- a/src/hotspot/share/compiler/compilerEvent.cpp
+++ b/src/hotspot/share/compiler/compilerEvent.cpp
@@ -77,11 +77,11 @@
   }
   bool register_jfr_serializer = false;
   {
     PhaseTypeGuard guard;
     if (phase_names == NULL) {
-      phase_names = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char*>(100, true);
+      phase_names = new (ResourceObj::C_HEAP, mtCompiler) GrowableArray<const char*>(100, mtCompiler);
       register_jfr_serializer = true;
     }
     idx = phase_names->length();
     phase_names->appendAll(new_phases);
     guarantee(phase_names->length() < 256, "exceeds maximum supported phases");
diff a/src/hotspot/share/compiler/disassembler.cpp b/src/hotspot/share/compiler/disassembler.cpp
--- a/src/hotspot/share/compiler/disassembler.cpp
+++ b/src/hotspot/share/compiler/disassembler.cpp
@@ -264,11 +264,11 @@
           for (int i=0; i<_cached_src_lines->length(); i++) {
             os::free((void*)_cached_src_lines->at(i));
           }
           _cached_src_lines->clear();
         } else {
-          _cached_src_lines = new (ResourceObj::C_HEAP, mtCode)GrowableArray<const char*>(0, true);
+          _cached_src_lines = new (ResourceObj::C_HEAP, mtCode)GrowableArray<const char*>(0, mtCode);
         }
 
         if ((fp = fopen(file, "r")) == NULL) {
           _cached_src = NULL;
           return;
diff a/src/hotspot/share/gc/g1/g1Allocator.hpp b/src/hotspot/share/gc/g1/g1Allocator.hpp
--- a/src/hotspot/share/gc/g1/g1Allocator.hpp
+++ b/src/hotspot/share/gc/g1/g1Allocator.hpp
@@ -255,11 +255,11 @@
     _open(open),
     _g1h(g1h),
     _allocation_region(NULL),
     _allocated_regions((ResourceObj::set_allocation_type((address) &_allocated_regions,
                                                          ResourceObj::C_HEAP),
-                        2), true /* C_Heap */),
+                        2), mtGC),
     _summary_bytes_used(0),
     _bottom(NULL),
     _top(NULL),
     _max(NULL) { }
 
diff a/src/hotspot/share/gc/g1/g1FullGCCompactionPoint.cpp b/src/hotspot/share/gc/g1/g1FullGCCompactionPoint.cpp
--- a/src/hotspot/share/gc/g1/g1FullGCCompactionPoint.cpp
+++ b/src/hotspot/share/gc/g1/g1FullGCCompactionPoint.cpp
@@ -30,11 +30,11 @@
 
 G1FullGCCompactionPoint::G1FullGCCompactionPoint() :
     _current_region(NULL),
     _threshold(NULL),
     _compaction_top(NULL) {
-  _compaction_regions = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapRegion*>(32, true, mtGC);
+  _compaction_regions = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapRegion*>(32, mtGC);
   _compaction_region_iterator = _compaction_regions->begin();
 }
 
 G1FullGCCompactionPoint::~G1FullGCCompactionPoint() {
   delete _compaction_regions;
diff a/src/hotspot/share/gc/g1/g1HeapVerifier.cpp b/src/hotspot/share/gc/g1/g1HeapVerifier.cpp
--- a/src/hotspot/share/gc/g1/g1HeapVerifier.cpp
+++ b/src/hotspot/share/gc/g1/g1HeapVerifier.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -324,19 +324,18 @@
   VerifyReadyForArchivingRegionClosure cl;
   G1CollectedHeap::heap()->heap_region_iterate(&cl);
   if (cl.has_holes()) {
     log_warning(gc, verify)("All free regions should be at the top end of the heap, but"
                             " we found holes. This is probably caused by (unmovable) humongous"
-                            " allocations, and may lead to fragmentation while"
+                            " allocations or active GCLocker, and may lead to fragmentation while"
                             " writing archive heap memory regions.");
   }
   if (cl.has_humongous()) {
     log_warning(gc, verify)("(Unmovable) humongous regions have been found and"
                             " may lead to fragmentation while"
                             " writing archive heap memory regions.");
   }
-  assert(!cl.has_unexpected_holes(), "all holes should have been caused by humongous regions");
 }
 
 class VerifyArchivePointerRegionClosure: public HeapRegionClosure {
   virtual bool do_heap_region(HeapRegion* r) {
    if (r->is_archive()) {
diff a/src/hotspot/share/gc/g1/g1SurvivorRegions.cpp b/src/hotspot/share/gc/g1/g1SurvivorRegions.cpp
--- a/src/hotspot/share/gc/g1/g1SurvivorRegions.cpp
+++ b/src/hotspot/share/gc/g1/g1SurvivorRegions.cpp
@@ -27,11 +27,11 @@
 #include "gc/g1/heapRegion.hpp"
 #include "utilities/growableArray.hpp"
 #include "utilities/debug.hpp"
 
 G1SurvivorRegions::G1SurvivorRegions() :
-  _regions(new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapRegion*>(8, true, mtGC)),
+  _regions(new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapRegion*>(8, mtGC)),
   _used_bytes(0),
   _regions_on_node() {}
 
 uint G1SurvivorRegions::add(HeapRegion* hr) {
   assert(hr->is_survivor(), "should be flagged as survivor region");
diff a/src/hotspot/share/gc/parallel/mutableNUMASpace.cpp b/src/hotspot/share/gc/parallel/mutableNUMASpace.cpp
--- a/src/hotspot/share/gc/parallel/mutableNUMASpace.cpp
+++ b/src/hotspot/share/gc/parallel/mutableNUMASpace.cpp
@@ -32,11 +32,11 @@
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "utilities/align.hpp"
 
 MutableNUMASpace::MutableNUMASpace(size_t alignment) : MutableSpace(alignment), _must_use_large_pages(false) {
-  _lgrp_spaces = new (ResourceObj::C_HEAP, mtGC) GrowableArray<LGRPSpace*>(0, true);
+  _lgrp_spaces = new (ResourceObj::C_HEAP, mtGC) GrowableArray<LGRPSpace*>(0, mtGC);
   _page_size = os::vm_page_size();
   _adaptation_cycles = 0;
   _samples_count = 0;
 
 #ifdef LINUX
diff a/src/hotspot/share/gc/parallel/psCompactionManager.cpp b/src/hotspot/share/gc/parallel/psCompactionManager.cpp
--- a/src/hotspot/share/gc/parallel/psCompactionManager.cpp
+++ b/src/hotspot/share/gc/parallel/psCompactionManager.cpp
@@ -94,11 +94,11 @@
   // for work stealing.
   _manager_array[parallel_gc_threads] = new ParCompactionManager();
   assert(ParallelScavengeHeap::heap()->workers().total_workers() != 0,
     "Not initialized?");
 
-  _shadow_region_array = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<size_t >(10, true);
+  _shadow_region_array = new (ResourceObj::C_HEAP, mtGC) GrowableArray<size_t >(10, mtGC);
 
   _shadow_region_monitor = new Monitor(Mutex::barrier, "CompactionManager monitor",
                                        Mutex::_allow_vm_block_flag, Monitor::_safepoint_check_never);
 }
 
diff a/src/hotspot/share/gc/shared/collectedHeap.cpp b/src/hotspot/share/gc/shared/collectedHeap.cpp
--- a/src/hotspot/share/gc/shared/collectedHeap.cpp
+++ b/src/hotspot/share/gc/shared/collectedHeap.cpp
@@ -238,10 +238,11 @@
     case GCCause::_metadata_GC_threshold : {
       HandleMark hm;
       do_full_collection(false);        // don't clear all soft refs
       break;
     }
+    case GCCause::_archive_time_gc:
     case GCCause::_metadata_GC_clear_soft_refs: {
       HandleMark hm;
       do_full_collection(true);         // do clear all soft refs
       break;
     }
diff a/src/hotspot/share/gc/shared/gcTimer.cpp b/src/hotspot/share/gc/shared/gcTimer.cpp
--- a/src/hotspot/share/gc/shared/gcTimer.cpp
+++ b/src/hotspot/share/gc/shared/gcTimer.cpp
@@ -111,11 +111,11 @@
   GCPhase::PhaseType type = phase.type();
   return type;
 }
 
 TimePartitions::TimePartitions() {
-  _phases = new (ResourceObj::C_HEAP, mtGC) GrowableArray<GCPhase>(INITIAL_CAPACITY, true, mtGC);
+  _phases = new (ResourceObj::C_HEAP, mtGC) GrowableArray<GCPhase>(INITIAL_CAPACITY, mtGC);
   clear();
 }
 
 TimePartitions::~TimePartitions() {
   delete _phases;
diff a/src/hotspot/share/gc/shenandoah/shenandoahControlThread.cpp b/src/hotspot/share/gc/shenandoah/shenandoahControlThread.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahControlThread.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahControlThread.cpp
@@ -51,10 +51,13 @@
 
   reset_gc_id();
   create_and_start(ShenandoahCriticalControlThreadPriority ? CriticalPriority : NearMaxPriority);
   _periodic_task.enroll();
   _periodic_satb_flush_task.enroll();
+  if (ShenandoahPacing) {
+    _periodic_pacer_notify_task.enroll();
+  }
 }
 
 ShenandoahControlThread::~ShenandoahControlThread() {
   // This is here so that super is called.
 }
@@ -66,10 +69,15 @@
 
 void ShenandoahPeriodicSATBFlushTask::task() {
   ShenandoahHeap::heap()->force_satb_flush_all_threads();
 }
 
+void ShenandoahPeriodicPacerNotify::task() {
+  assert(ShenandoahPacing, "Should not be here otherwise");
+  ShenandoahHeap::heap()->pacer()->notify_waiters();
+}
+
 void ShenandoahControlThread::run_service() {
   ShenandoahHeap* heap = ShenandoahHeap::heap();
 
   GCMode default_mode = concurrent_normal;
   GCCause::Cause default_cause = GCCause::_shenandoah_concurrent_gc;
diff a/src/hotspot/share/gc/shenandoah/shenandoahControlThread.hpp b/src/hotspot/share/gc/shenandoah/shenandoahControlThread.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahControlThread.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahControlThread.hpp
@@ -50,10 +50,17 @@
 public:
   ShenandoahPeriodicSATBFlushTask() : PeriodicTask(ShenandoahSATBBufferFlushInterval) {}
   virtual void task();
 };
 
+// Periodic task to notify blocked paced waiters.
+class ShenandoahPeriodicPacerNotify : public PeriodicTask {
+public:
+  ShenandoahPeriodicPacerNotify() : PeriodicTask(PeriodicTask::min_interval) {}
+  virtual void task();
+};
+
 class ShenandoahControlThread: public ConcurrentGCThread {
   friend class VMStructs;
 
 private:
   typedef enum {
@@ -68,10 +75,11 @@
   // to make complete explicit cycle for for demanding customers.
   Monitor _alloc_failure_waiters_lock;
   Monitor _gc_waiters_lock;
   ShenandoahPeriodicTask _periodic_task;
   ShenandoahPeriodicSATBFlushTask _periodic_satb_flush_task;
+  ShenandoahPeriodicPacerNotify _periodic_pacer_notify_task;
 
 public:
   void run_service();
   void stop_service();
 
diff a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
@@ -1295,15 +1295,20 @@
   // Reset bitmap
   _aux_bit_map.clear();
 
   Stack<oop,mtGC> oop_stack;
 
-  // First, we process GC roots according to current GC cycle. This populates the work stack with initial objects.
-  ShenandoahHeapIterationRootScanner rp;
   ObjectIterateScanRootClosure oops(&_aux_bit_map, &oop_stack);
 
-  rp.roots_do(&oops);
+  {
+    // First, we process GC roots according to current GC cycle.
+    // This populates the work stack with initial objects.
+    // It is important to relinquish the associated locks before diving
+    // into heap dumper.
+    ShenandoahHeapIterationRootScanner rp;
+    rp.roots_do(&oops);
+  }
 
   // Work through the oop stack to traverse heap.
   while (! oop_stack.is_empty()) {
     oop obj = oop_stack.pop();
     assert(oopDesc::is_oop(obj), "must be a valid oop");
diff a/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp b/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
@@ -191,11 +191,11 @@
   Atomic::xchg(&_budget, (intptr_t)initial);
   Atomic::store(&_tax_rate, tax_rate);
   Atomic::inc(&_epoch);
 
   // Shake up stalled waiters after budget update.
-  notify_waiters();
+  _need_notify_waiters.try_set();
 }
 
 bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
@@ -220,12 +220,12 @@
   if (_epoch != epoch) {
     // Stale ticket, no need to unpace.
     return;
   }
 
-  intptr_t tax = MAX2<intptr_t>(1, words * Atomic::load(&_tax_rate));
-  Atomic::add(&_budget, tax);
+  size_t tax = MAX2<size_t>(1, words * Atomic::load(&_tax_rate));
+  add_budget(tax);
 }
 
 intptr_t ShenandoahPacer::epoch() {
   return Atomic::load(&_epoch);
 }
@@ -276,21 +276,24 @@
       break;
     }
   }
 }
 
-void ShenandoahPacer::wait(long time_ms) {
+void ShenandoahPacer::wait(size_t time_ms) {
   // Perform timed wait. It works like like sleep(), except without modifying
   // the thread interruptible status. MonitorLocker also checks for safepoints.
   assert(time_ms > 0, "Should not call this with zero argument, as it would stall until notify");
+  assert(time_ms <= LONG_MAX, "Sanity");
   MonitorLocker locker(_wait_monitor);
-  _wait_monitor->wait(time_ms);
+  _wait_monitor->wait((long)time_ms);
 }
 
 void ShenandoahPacer::notify_waiters() {
-  MonitorLocker locker(_wait_monitor);
-  _wait_monitor->notify_all();
+  if (_need_notify_waiters.try_unset()) {
+    MonitorLocker locker(_wait_monitor);
+    _wait_monitor->notify_all();
+  }
 }
 
 void ShenandoahPacer::print_on(outputStream* out) const {
   out->print_cr("ALLOCATION PACING:");
   out->cr();
diff a/src/hotspot/share/gc/shenandoah/shenandoahPacer.hpp b/src/hotspot/share/gc/shenandoah/shenandoahPacer.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahPacer.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahPacer.hpp
@@ -44,10 +44,11 @@
 private:
   ShenandoahHeap* _heap;
   BinaryMagnitudeSeq _delays;
   TruncatedSeq* _progress_history;
   Monitor* _wait_monitor;
+  ShenandoahSharedFlag _need_notify_waiters;
 
   // Set once per phase
   volatile intptr_t _epoch;
   volatile double _tax_rate;
 
@@ -87,22 +88,24 @@
 
   bool claim_for_alloc(size_t words, bool force);
   void pace_for_alloc(size_t words);
   void unpace_for_alloc(intptr_t epoch, size_t words);
 
+  void notify_waiters();
+
   intptr_t epoch();
 
   void print_on(outputStream* out) const;
 
 private:
   inline void report_internal(size_t words);
   inline void report_progress_internal(size_t words);
 
+  inline void add_budget(size_t words);
   void restart_with(size_t non_taxable_bytes, double tax_rate);
 
   size_t update_and_get_progress_history();
 
-  void wait(long time_ms);
-  void notify_waiters();
+  void wait(size_t time_ms);
 };
 
 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHPACER_HPP
diff a/src/hotspot/share/gc/shenandoah/shenandoahPacer.inline.hpp b/src/hotspot/share/gc/shenandoah/shenandoahPacer.inline.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahPacer.inline.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahPacer.inline.hpp
@@ -45,23 +45,28 @@
   report_internal(words);
 }
 
 inline void ShenandoahPacer::report_internal(size_t words) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
+  add_budget(words);
+}
+
+inline void ShenandoahPacer::report_progress_internal(size_t words) {
+  assert(ShenandoahPacing, "Only be here when pacing is enabled");
+  STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));
+  Atomic::add(&_progress, (intptr_t)words);
+}
+
+inline void ShenandoahPacer::add_budget(size_t words) {
   STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));
   intptr_t inc = (intptr_t) words;
   intptr_t new_budget = Atomic::add(&_budget, inc);
 
   // Was the budget replenished beyond zero? Then all pacing claims
-  // are satisfied, notify the waiters.
+  // are satisfied, notify the waiters. Avoid taking any locks here,
+  // as it can be called from hot paths and/or while holding other locks.
   if (new_budget >= 0 && (new_budget - inc) < 0) {
-    notify_waiters();
+    _need_notify_waiters.try_set();
   }
 }
 
-inline void ShenandoahPacer::report_progress_internal(size_t words) {
-  assert(ShenandoahPacing, "Only be here when pacing is enabled");
-  STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));
-  Atomic::add(&_progress, (intptr_t)words);
-}
-
 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHPACER_INLINE_HPP
diff a/src/hotspot/share/interpreter/interpreterRuntime.cpp b/src/hotspot/share/interpreter/interpreterRuntime.cpp
--- a/src/hotspot/share/interpreter/interpreterRuntime.cpp
+++ b/src/hotspot/share/interpreter/interpreterRuntime.cpp
@@ -1596,12 +1596,12 @@
 
   BufferBlob* bb = BufferBlob::create("Signature Handler Temp Buffer",
                                       SignatureHandlerLibrary::buffer_size);
   _buffer = bb->code_begin();
 
-  _fingerprints = new(ResourceObj::C_HEAP, mtCode)GrowableArray<uint64_t>(32, true);
-  _handlers     = new(ResourceObj::C_HEAP, mtCode)GrowableArray<address>(32, true);
+  _fingerprints = new(ResourceObj::C_HEAP, mtCode)GrowableArray<uint64_t>(32, mtCode);
+  _handlers     = new(ResourceObj::C_HEAP, mtCode)GrowableArray<address>(32, mtCode);
 }
 
 address SignatureHandlerLibrary::set_handler(CodeBuffer* buffer) {
   address handler   = _handler;
   int     insts_size = buffer->pure_insts_size();
diff a/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp b/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp
--- a/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp
+++ b/src/hotspot/share/jfr/jni/jfrJavaSupport.cpp
@@ -679,11 +679,11 @@
 #endif // ASSERT
 
 static int add_thread_to_exclusion_list(jobject thread) {
   ThreadExclusionListAccess lock;
   if (exclusion_list == NULL) {
-    exclusion_list = new (ResourceObj::C_HEAP, mtTracing) GrowableArray<jweak>(10, true, mtTracing);
+    exclusion_list = new (ResourceObj::C_HEAP, mtTracing) GrowableArray<jweak>(10, mtTracing);
   }
   assert(exclusion_list != NULL, "invariant");
   assert(thread_is_not_excluded(thread), "invariant");
   jweak ref = JfrJavaSupport::global_weak_jni_handle(thread, Thread::current());
   const int idx = exclusion_list->append(ref);
diff a/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp b/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp
--- a/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp
+++ b/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp
@@ -50,11 +50,11 @@
 
 const int initial_array_size = 64;
 
 template <typename T>
 static GrowableArray<T>* c_heap_allocate_array(int size = initial_array_size) {
-  return new (ResourceObj::C_HEAP, mtTracing) GrowableArray<T>(size, true, mtTracing);
+  return new (ResourceObj::C_HEAP, mtTracing) GrowableArray<T>(size, mtTracing);
 }
 
 static GrowableArray<traceid>* unloaded_thread_id_set = NULL;
 
 class ThreadIdExclusiveAccess : public StackObj {
diff a/src/hotspot/share/jfr/periodic/jfrNetworkUtilization.cpp b/src/hotspot/share/jfr/periodic/jfrNetworkUtilization.cpp
--- a/src/hotspot/share/jfr/periodic/jfrNetworkUtilization.cpp
+++ b/src/hotspot/share/jfr/periodic/jfrNetworkUtilization.cpp
@@ -75,11 +75,11 @@
   return _interfaces->at(_interfaces->append(entry));
 }
 
 static GrowableArray<InterfaceEntry>* get_interfaces() {
   if (_interfaces == NULL) {
-    _interfaces = new(ResourceObj::C_HEAP, mtTracing) GrowableArray<InterfaceEntry>(10, true, mtTracing);
+    _interfaces = new(ResourceObj::C_HEAP, mtTracing) GrowableArray<InterfaceEntry>(10, mtTracing);
   }
   return _interfaces;
 }
 
 static InterfaceEntry& get_entry(const NetworkInterface* iface) {
diff a/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp b/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
@@ -383,11 +383,10 @@
   JfrTypeManager::on_rotation();
   notify_threads();
 }
 
 void JfrCheckpointManager::clear_type_set() {
-  assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
   assert(!JfrRecorder::is_recording(), "invariant");
   Thread* t = Thread::current();
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(t));
   // can safepoint here
   ThreadInVMfromNative transition((JavaThread*)t);
@@ -396,11 +395,10 @@
   MutexLocker module_lock(Module_lock);
   JfrTypeSet::clear();
 }
 
 void JfrCheckpointManager::write_type_set() {
-  assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
   {
     Thread* const thread = Thread::current();
     DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread));
     // can safepoint here
     ThreadInVMfromNative transition((JavaThread*)thread);
diff a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadGroup.cpp b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadGroup.cpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadGroup.cpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadGroup.cpp
@@ -104,11 +104,11 @@
   bool is_valid() const;
   bool has_next() const;
 };
 
 JfrThreadGroupsHelper::JfrThreadGroupsHelper(const JavaThread* jt, Thread* current) {
-  _thread_group_hierarchy = new GrowableArray<JfrThreadGroupPointers*>(10, false, mtTracing);
+  _thread_group_hierarchy = new GrowableArray<JfrThreadGroupPointers*>(10);
   _current_iterator_pos = populate_thread_group_hierarchy(jt, current) - 1;
 }
 
 JfrThreadGroupsHelper::~JfrThreadGroupsHelper() {
   assert(_current_iterator_pos == invalid_iterator_pos, "invariant");
@@ -257,11 +257,11 @@
     _thread_group_oop = NULL;
   }
 }
 
 JfrThreadGroup::JfrThreadGroup() :
-  _list(new (ResourceObj::C_HEAP, mtTracing) GrowableArray<JfrThreadGroupEntry*>(initial_array_size, true, mtTracing)) {}
+  _list(new (ResourceObj::C_HEAP, mtTracing) GrowableArray<JfrThreadGroupEntry*>(initial_array_size, mtTracing)) {}
 
 JfrThreadGroup::~JfrThreadGroup() {
   if (_list != NULL) {
     for (int i = 0; i < _list->length(); i++) {
       JfrThreadGroupEntry* e = _list->at(i);
diff a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp
@@ -266,12 +266,12 @@
     _symbol_id->clear();
   }
   _symbol_id->set_class_unload(class_unload);
   _total_count = 0;
   // resource allocation
-  _klass_list = new GrowableArray<const Klass*>(initial_klass_list_size, false, mtTracing);
-  _klass_loader_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size, false, mtTracing);
+  _klass_list = new GrowableArray<const Klass*>(initial_klass_list_size);
+  _klass_loader_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);
 }
 
 JfrArtifactSet::~JfrArtifactSet() {
   _symbol_id->clear();
   delete _symbol_id;
diff a/src/hotspot/share/jfr/recorder/jfrRecorder.cpp b/src/hotspot/share/jfr/recorder/jfrRecorder.cpp
--- a/src/hotspot/share/jfr/recorder/jfrRecorder.cpp
+++ b/src/hotspot/share/jfr/recorder/jfrRecorder.cpp
@@ -120,11 +120,11 @@
     return true;
   }
   const int length = options->length();
   assert(length >= 1, "invariant");
   assert(dcmd_recordings_array == NULL, "invariant");
-  dcmd_recordings_array = new (ResourceObj::C_HEAP, mtTracing)GrowableArray<JfrStartFlightRecordingDCmd*>(length, true, mtTracing);
+  dcmd_recordings_array = new (ResourceObj::C_HEAP, mtTracing)GrowableArray<JfrStartFlightRecordingDCmd*>(length, mtTracing);
   assert(dcmd_recordings_array != NULL, "invariant");
   for (int i = 0; i < length; ++i) {
     JfrStartFlightRecordingDCmd* const dcmd_recording = new(ResourceObj::C_HEAP, mtTracing) JfrStartFlightRecordingDCmd(tty, true);
     assert(dcmd_recording != NULL, "invariant");
     dcmd_recordings_array->append(dcmd_recording);
diff a/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp b/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp
--- a/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp
+++ b/src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp
@@ -294,11 +294,11 @@
                                                  repository_path,
                                                  os::file_separator());
     if (_path_buffer_file_name_offset == -1) {
       return;
     }
-    _file_names = new (ResourceObj::C_HEAP, mtTracing) GrowableArray<const char*>(10, true, mtTracing);
+    _file_names = new (ResourceObj::C_HEAP, mtTracing) GrowableArray<const char*>(10, mtTracing);
     if (_file_names == NULL) {
       log_error(jfr, system)("Unable to malloc memory during jfr emergency dump");
       return;
     }
     // iterate files in the repository and append filtered file names to the files array
diff a/src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp b/src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp
--- a/src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp
+++ b/src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp
@@ -700,11 +700,11 @@
   }
   assert(value != NULL, "invariant");
   const size_t value_length = strlen(value);
 
   if (start_flight_recording_options_array == NULL) {
-    start_flight_recording_options_array = new (ResourceObj::C_HEAP, mtTracing) GrowableArray<const char*>(8, true, mtTracing);
+    start_flight_recording_options_array = new (ResourceObj::C_HEAP, mtTracing) GrowableArray<const char*>(8, mtTracing);
   }
   assert(start_flight_recording_options_array != NULL, "invariant");
   char* const startup_value = NEW_C_HEAP_ARRAY(char, value_length + 1, mtTracing);
   strncpy(startup_value, value, value_length + 1);
   assert(strncmp(startup_value, value, value_length) == 0, "invariant");
diff a/src/hotspot/share/jfr/support/jfrJdkJfrEvent.cpp b/src/hotspot/share/jfr/support/jfrJdkJfrEvent.cpp
--- a/src/hotspot/share/jfr/support/jfrJdkJfrEvent.cpp
+++ b/src/hotspot/share/jfr/support/jfrJdkJfrEvent.cpp
@@ -47,11 +47,11 @@
 
 static const int initial_array_size = 64;
 
 template <typename T>
 static GrowableArray<T>* c_heap_allocate_array(int size = initial_array_size) {
-  return new (ResourceObj::C_HEAP, mtTracing) GrowableArray<T>(size, true, mtTracing);
+  return new (ResourceObj::C_HEAP, mtTracing) GrowableArray<T>(size, mtTracing);
 }
 
 static bool initialize(TRAPS) {
   static bool initialized = false;
   if (!initialized) {
@@ -135,11 +135,11 @@
   if (klass->subklass() == NULL) {
     return empty_java_util_arraylist;
   }
 
   ResourceMark rm(THREAD);
-  GrowableArray<const void*> event_subklasses(THREAD, initial_array_size);
+  GrowableArray<const void*> event_subklasses(initial_array_size);
   fill_klasses(event_subklasses, klass, THREAD);
 
   if (event_subklasses.is_empty()) {
     return empty_java_util_arraylist;
   }
diff a/src/hotspot/share/jfr/support/jfrKlassUnloading.cpp b/src/hotspot/share/jfr/support/jfrKlassUnloading.cpp
--- a/src/hotspot/share/jfr/support/jfrKlassUnloading.cpp
+++ b/src/hotspot/share/jfr/support/jfrKlassUnloading.cpp
@@ -31,11 +31,11 @@
 
 static const int initial_array_size = 64;
 
 template <typename T>
 static GrowableArray<T>* c_heap_allocate_array(int size = initial_array_size) {
-  return new (ResourceObj::C_HEAP, mtTracing) GrowableArray<T>(size, true, mtTracing);
+  return new (ResourceObj::C_HEAP, mtTracing) GrowableArray<T>(size, mtTracing);
 }
 
 // Track the set of unloaded klasses during a chunk / epoch.
 static GrowableArray<traceid>* _unload_set_epoch_0 = NULL;
 static GrowableArray<traceid>* _unload_set_epoch_1 = NULL;
diff a/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp b/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp
--- a/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp
+++ b/src/hotspot/share/jfr/utilities/jfrConcurrentLinkedListHost.inline.hpp
@@ -61,12 +61,12 @@
 template <typename Node, typename VersionHandle, template <typename> class SearchPolicy>
 Node* find_adjacent(Node* head, const Node* tail, Node** predecessor, VersionHandle& version_handle, SearchPolicy<Node>& predicate) {
   assert(head != NULL, "invariant");
   assert(tail != NULL, "invariant");
   assert(head != tail, "invariant");
+  Node* predecessor_next = NULL;
   while (true) {
-    Node* predecessor_next;
     Node* current = head;
     version_handle.checkout();
     assert(version_handle.is_tracked(), "invariant");
     Node* next = Atomic::load_acquire(&current->_next);
     do {
diff a/src/hotspot/share/memory/allocation.hpp b/src/hotspot/share/memory/allocation.hpp
--- a/src/hotspot/share/memory/allocation.hpp
+++ b/src/hotspot/share/memory/allocation.hpp
@@ -112,37 +112,38 @@
   virtual void print_on(outputStream* st) const;
   virtual void print_value_on(outputStream* st) const;
 };
 #endif
 
-#define MEMORY_TYPES_DO(f) \
-  /* Memory type by sub systems. It occupies lower byte. */  \
-  f(mtJavaHeap,      "Java Heap")   /* Java heap                                 */ \
-  f(mtClass,         "Class")       /* Java classes                              */ \
-  f(mtThread,        "Thread")      /* thread objects                            */ \
-  f(mtThreadStack,   "Thread Stack")                                                \
-  f(mtCode,          "Code")        /* generated code                            */ \
-  f(mtGC,            "GC")                                                          \
-  f(mtCompiler,      "Compiler")                                                    \
-  f(mtJVMCI,         "JVMCI")                                                       \
-  f(mtInternal,      "Internal")    /* memory used by VM, but does not belong to */ \
-                                    /* any of above categories, and not used by  */ \
-                                    /* NMT                                       */ \
-  f(mtOther,         "Other")       /* memory not used by VM                     */ \
-  f(mtSymbol,        "Symbol")                                                      \
-  f(mtNMT,           "Native Memory Tracking")  /* memory used by NMT            */ \
-  f(mtClassShared,   "Shared class space")      /* class data sharing            */ \
-  f(mtChunk,         "Arena Chunk") /* chunk that holds content of arenas        */ \
-  f(mtTest,          "Test")        /* Test type for verifying NMT               */ \
-  f(mtTracing,       "Tracing")                                                     \
-  f(mtLogging,       "Logging")                                                     \
-  f(mtStatistics,    "Statistics")                                                  \
-  f(mtArguments,     "Arguments")                                                   \
-  f(mtModule,        "Module")                                                      \
-  f(mtSafepoint,     "Safepoint")                                                   \
-  f(mtSynchronizer,  "Synchronization")                                             \
-  f(mtNone,          "Unknown")                                                     \
+#define MEMORY_TYPES_DO(f)                                                           \
+  /* Memory type by sub systems. It occupies lower byte. */                          \
+  f(mtJavaHeap,       "Java Heap")   /* Java heap                                 */ \
+  f(mtClass,          "Class")       /* Java classes                              */ \
+  f(mtThread,         "Thread")      /* thread objects                            */ \
+  f(mtThreadStack,    "Thread Stack")                                                \
+  f(mtCode,           "Code")        /* generated code                            */ \
+  f(mtGC,             "GC")                                                          \
+  f(mtCompiler,       "Compiler")                                                    \
+  f(mtJVMCI,          "JVMCI")                                                       \
+  f(mtInternal,       "Internal")    /* memory used by VM, but does not belong to */ \
+                                     /* any of above categories, and not used by  */ \
+                                     /* NMT                                       */ \
+  f(mtOther,          "Other")       /* memory not used by VM                     */ \
+  f(mtSymbol,         "Symbol")                                                      \
+  f(mtNMT,            "Native Memory Tracking")  /* memory used by NMT            */ \
+  f(mtClassShared,    "Shared class space")      /* class data sharing            */ \
+  f(mtChunk,          "Arena Chunk") /* chunk that holds content of arenas        */ \
+  f(mtTest,           "Test")        /* Test type for verifying NMT               */ \
+  f(mtTracing,        "Tracing")                                                     \
+  f(mtLogging,        "Logging")                                                     \
+  f(mtStatistics,     "Statistics")                                                  \
+  f(mtArguments,      "Arguments")                                                   \
+  f(mtModule,         "Module")                                                      \
+  f(mtSafepoint,      "Safepoint")                                                   \
+  f(mtSynchronizer,   "Synchronization")                                             \
+  f(mtServiceability, "Serviceability")                                              \
+  f(mtNone,           "Unknown")                                                     \
   //end
 
 #define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \
   type,
 
diff a/src/hotspot/share/memory/binaryTreeDictionary.hpp b/src/hotspot/share/memory/binaryTreeDictionary.hpp
--- a/src/hotspot/share/memory/binaryTreeDictionary.hpp
+++ b/src/hotspot/share/memory/binaryTreeDictionary.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -156,11 +156,11 @@
   // a free list in the tree.
   void initialize() { embedded_list()->initialize(); }
 
   Chunk_t* next() const { return Chunk_t::next(); }
   Chunk_t* prev() const { return Chunk_t::prev(); }
-  size_t size() const volatile { return Chunk_t::size(); }
+  size_t size() const { return Chunk_t::size(); }
 
   static size_t min_size();
 
   // debugging
   void verify_tree_chunk_list() const;
diff a/src/hotspot/share/memory/dynamicArchive.cpp b/src/hotspot/share/memory/dynamicArchive.cpp
--- a/src/hotspot/share/memory/dynamicArchive.cpp
+++ b/src/hotspot/share/memory/dynamicArchive.cpp
@@ -533,12 +533,12 @@
     MetaspaceShared::misc_code_space_alloc(n);
   }
 
 public:
   DynamicArchiveBuilder() {
-    _klasses = new (ResourceObj::C_HEAP, mtClass) GrowableArray<InstanceKlass*>(100, true, mtInternal);
-    _symbols = new (ResourceObj::C_HEAP, mtClass) GrowableArray<Symbol*>(1000, true, mtInternal);
+    _klasses = new (ResourceObj::C_HEAP, mtClass) GrowableArray<InstanceKlass*>(100, mtClass);
+    _symbols = new (ResourceObj::C_HEAP, mtClass) GrowableArray<Symbol*>(1000, mtClass);
 
     _estimated_metsapceobj_bytes = 0;
     _estimated_hashtable_bytes = 0;
     _estimated_trampoline_bytes = 0;
 
diff a/src/hotspot/share/memory/filemap.cpp b/src/hotspot/share/memory/filemap.cpp
--- a/src/hotspot/share/memory/filemap.cpp
+++ b/src/hotspot/share/memory/filemap.cpp
@@ -497,11 +497,11 @@
 
 void FileMapInfo::record_non_existent_class_path_entry(const char* path) {
   Arguments::assert_is_dumping_archive();
   log_info(class, path)("non-existent Class-Path entry %s", path);
   if (_non_existent_class_paths == NULL) {
-    _non_existent_class_paths = new (ResourceObj::C_HEAP, mtInternal)GrowableArray<const char*>(10, true);
+    _non_existent_class_paths = new (ResourceObj::C_HEAP, mtClass)GrowableArray<const char*>(10, mtClass);
   }
   _non_existent_class_paths->append(os::strdup(path));
 }
 
 int FileMapInfo::num_non_existent_class_paths() {
@@ -624,12 +624,11 @@
   }
   return npaths;
 }
 
 GrowableArray<const char*>* FileMapInfo::create_path_array(const char* paths) {
-  GrowableArray<const char*>* path_array =  new(ResourceObj::RESOURCE_AREA, mtInternal)
-      GrowableArray<const char*>(10);
+  GrowableArray<const char*>* path_array = new GrowableArray<const char*>(10);
 
   ClasspathStream cp_stream(paths);
   while (cp_stream.has_next()) {
     const char* path = cp_stream.get_next();
     struct stat st;
diff a/src/hotspot/share/memory/heapInspection.cpp b/src/hotspot/share/memory/heapInspection.cpp
--- a/src/hotspot/share/memory/heapInspection.cpp
+++ b/src/hotspot/share/memory/heapInspection.cpp
@@ -50,11 +50,11 @@
   }
 }
 
 inline void KlassInfoEntry::add_subclass(KlassInfoEntry* cie) {
   if (_subclasses == NULL) {
-    _subclasses = new  (ResourceObj::C_HEAP, mtInternal) GrowableArray<KlassInfoEntry*>(4, true);
+    _subclasses = new  (ResourceObj::C_HEAP, mtServiceability) GrowableArray<KlassInfoEntry*>(4, mtServiceability);
   }
   _subclasses->append(cie);
 }
 
 int KlassInfoEntry::compare(KlassInfoEntry* e1, KlassInfoEntry* e2) {
@@ -243,11 +243,11 @@
   return (*e1)->compare(*e1,*e2);
 }
 
 KlassInfoHisto::KlassInfoHisto(KlassInfoTable* cit) :
   _cit(cit) {
-  _elements = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<KlassInfoEntry*>(_histo_initial_size, true);
+  _elements = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<KlassInfoEntry*>(_histo_initial_size, mtServiceability);
 }
 
 KlassInfoHisto::~KlassInfoHisto() {
   delete _elements;
 }
@@ -549,11 +549,11 @@
 }
 
 static void print_inlined_field(outputStream* st, int level, int offset, InstanceKlass* klass) {
   assert(klass->is_inline_klass(), "Only inline types can be inlined");
   ValueKlass* vklass = ValueKlass::cast(klass);
-  GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<FieldDesc>(100, true);
+  GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);
   for (FieldStream fd(klass, false, false); !fd.eos(); fd.next()) {
     if (!fd.access_flags().is_static()) {
       fields->append(FieldDesc(fd.field_descriptor()));
     }
   }
@@ -579,11 +579,11 @@
 
   Thread* THREAD = Thread::current();
 
   Symbol* classname = SymbolTable::probe(class_name, (int)strlen(class_name));
 
-  GrowableArray<Klass*>* klasses = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<Klass*>(100, true);
+  GrowableArray<Klass*>* klasses = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<Klass*>(100, mtServiceability);
 
   FindClassByNameClosure fbnc(klasses, classname);
   cit.iterate(&fbnc);
 
   for(int i = 0; i < klasses->length(); i++) {
@@ -592,11 +592,11 @@
     InstanceKlass* ik = InstanceKlass::cast(klass);
     int tab = 1;
     st->print_cr("Class %s [@%s]:", klass->name()->as_C_string(),
         klass->class_loader_data()->name()->as_C_string());
     ResourceMark rm;
-    GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<FieldDesc>(100, true);
+    GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);
     for (FieldStream fd(ik, false, false); !fd.eos(); fd.next()) {
       if (!fd.access_flags().is_static()) {
         fields->append(FieldDesc(fd.field_descriptor()));
       }
     }
diff a/src/hotspot/share/memory/heapShared.cpp b/src/hotspot/share/memory/heapShared.cpp
--- a/src/hotspot/share/memory/heapShared.cpp
+++ b/src/hotspot/share/memory/heapShared.cpp
@@ -26,10 +26,11 @@
 #include "classfile/javaClasses.inline.hpp"
 #include "classfile/stringTable.hpp"
 #include "classfile/symbolTable.hpp"
 #include "classfile/systemDictionaryShared.hpp"
 #include "classfile/vmSymbols.hpp"
+#include "gc/shared/gcLocker.hpp"
 #include "logging/log.hpp"
 #include "logging/logMessage.hpp"
 #include "logging/logStream.hpp"
 #include "memory/archiveUtils.hpp"
 #include "memory/filemap.hpp"
@@ -184,10 +185,29 @@
       ik->constants()->archive_resolved_references(THREAD);
     }
   }
 }
 
+void HeapShared::run_full_gc_in_vm_thread() {
+  if (is_heap_object_archiving_allowed()) {
+    // Avoid fragmentation while archiving heap objects.
+    // We do this inside a safepoint, so that no further allocation can happen after GC
+    // has finished.
+    if (GCLocker::is_active()) {
+      // Just checking for safety ...
+      // This should not happen during -Xshare:dump. If you see this, probably the Java core lib
+      // has been modified such that JNI code is executed in some clean up threads after
+      // we have finished class loading.
+      log_warning(cds)("GC locker is held, unable to start extra compacting GC. This may produce suboptimal results.");
+    } else {
+      log_info(cds)("Run GC ...");
+      Universe::heap()->collect_as_vm_thread(GCCause::_archive_time_gc);
+      log_info(cds)("Run GC done");
+    }
+  }
+}
+
 void HeapShared::archive_java_heap_objects(GrowableArray<MemRegion> *closed,
                                            GrowableArray<MemRegion> *open) {
   if (!is_heap_object_archiving_allowed()) {
     log_info(cds)(
       "Archived java heap is not supported as UseG1GC, "
@@ -287,11 +307,11 @@
 void KlassSubGraphInfo::add_subgraph_entry_field(
       int static_field_offset, oop v, bool is_closed_archive) {
   assert(DumpSharedSpaces, "dump time only");
   if (_subgraph_entry_fields == NULL) {
     _subgraph_entry_fields =
-      new(ResourceObj::C_HEAP, mtClass) GrowableArray<juint>(10, true);
+      new(ResourceObj::C_HEAP, mtClass) GrowableArray<juint>(10, mtClass);
   }
   _subgraph_entry_fields->append((juint)static_field_offset);
   _subgraph_entry_fields->append(CompressedOops::encode(v));
   _subgraph_entry_fields->append(is_closed_archive ? 1 : 0);
 }
@@ -303,11 +323,11 @@
   assert(relocated_k == MetaspaceShared::get_relocated_klass(orig_k),
          "must be the relocated Klass in the shared space");
 
   if (_subgraph_object_klasses == NULL) {
     _subgraph_object_klasses =
-      new(ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(50, true);
+      new(ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(50, mtClass);
   }
 
   assert(relocated_k->is_shared(), "must be a shared class");
 
   if (_k == relocated_k) {
diff a/src/hotspot/share/memory/heapShared.hpp b/src/hotspot/share/memory/heapShared.hpp
--- a/src/hotspot/share/memory/heapShared.hpp
+++ b/src/hotspot/share/memory/heapShared.hpp
@@ -275,10 +275,12 @@
 
   static ResourceBitMap calculate_oopmap(MemRegion region);
 #endif // INCLUDE_CDS_JAVA_HEAP
 
  public:
+  static void run_full_gc_in_vm_thread() NOT_CDS_JAVA_HEAP_RETURN;
+
   static bool is_heap_object_archiving_allowed() {
     CDS_JAVA_HEAP_ONLY(return (UseG1GC && UseCompressedOops && UseCompressedClassPointers);)
     NOT_CDS_JAVA_HEAP(return false;)
   }
 
diff a/src/hotspot/share/memory/metaspace/metabase.hpp b/src/hotspot/share/memory/metaspace/metabase.hpp
--- a/src/hotspot/share/memory/metaspace/metabase.hpp
+++ b/src/hotspot/share/memory/metaspace/metabase.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -46,12 +46,11 @@
   void set_next(T* v)     { _next = v; assert(v != this, "Boom");}
   void set_prev(T* v)     { _prev = v; assert(v != this, "Boom");}
   void clear_next()       { set_next(NULL); }
   void clear_prev()       { set_prev(NULL); }
 
-  size_t size() const volatile { return _word_size; }
-  void set_size(size_t v) { _word_size = v; }
+  size_t size() const     { return _word_size; }
 
   void link_next(T* ptr)  { set_next(ptr); }
   void link_prev(T* ptr)  { set_prev(ptr); }
   void link_after(T* ptr) {
     link_next(ptr);
diff a/src/hotspot/share/memory/metaspaceShared.cpp b/src/hotspot/share/memory/metaspaceShared.cpp
--- a/src/hotspot/share/memory/metaspaceShared.cpp
+++ b/src/hotspot/share/memory/metaspaceShared.cpp
@@ -459,11 +459,11 @@
 }
 
 static GrowableArray<Handle>* _extra_interned_strings = NULL;
 
 void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {
-  _extra_interned_strings = new (ResourceObj::C_HEAP, mtInternal)GrowableArray<Handle>(10000, true);
+  _extra_interned_strings = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<Handle>(10000, mtClassShared);
 
   HashtableTextDump reader(filename);
   reader.check_version("VERSION: 1.0");
 
   while (reader.remain() > 0) {
@@ -1656,10 +1656,11 @@
     ArchivePtrMarker::compact(patcher.max_non_null_offset());
   }
 }
 
 void VM_PopulateDumpSharedSpace::doit() {
+  HeapShared::run_full_gc_in_vm_thread();
   CHeapBitMap ptrmap;
   MetaspaceShared::initialize_ptr_marker(&ptrmap);
 
   // We should no longer allocate anything from the metaspace, so that:
   //
@@ -1974,18 +1975,13 @@
     // fails verification, all other interfaces that were not specified in the classlist but
     // are implemented by K are not verified.
     link_and_cleanup_shared_classes(CATCH);
     log_info(cds)("Rewriting and linking classes: done");
 
-    if (HeapShared::is_heap_object_archiving_allowed()) {
-      // Avoid fragmentation while archiving heap objects.
-      Universe::heap()->soft_ref_policy()->set_should_clear_all_soft_refs(true);
-      Universe::heap()->collect(GCCause::_archive_time_gc);
-      Universe::heap()->soft_ref_policy()->set_should_clear_all_soft_refs(false);
-    }
-
     VM_PopulateDumpSharedSpace op;
+    MutexLocker ml(THREAD, HeapShared::is_heap_object_archiving_allowed() ?
+                   Heap_lock : NULL);     // needed by HeapShared::run_gc()
     VMThread::execute(&op);
   }
 }
 
 
@@ -2520,12 +2516,12 @@
   assert(CompressedClassSpaceSize > 0 &&
          is_aligned(CompressedClassSpaceSize, class_space_alignment),
          "CompressedClassSpaceSize malformed: "
          SIZE_FORMAT, CompressedClassSpaceSize);
 
-  const size_t ccs_begin_offset = align_up(archive_space_size,
-                                           class_space_alignment);
+  const size_t ccs_begin_offset = align_up(base_address + archive_space_size,
+                                           class_space_alignment) - base_address;
   const size_t gap_size = ccs_begin_offset - archive_space_size;
 
   const size_t total_range_size =
       align_up(archive_space_size + gap_size + class_space_size,
                os::vm_allocation_granularity());
diff a/src/hotspot/share/oops/constantPool.hpp b/src/hotspot/share/oops/constantPool.hpp
--- a/src/hotspot/share/oops/constantPool.hpp
+++ b/src/hotspot/share/oops/constantPool.hpp
@@ -187,11 +187,11 @@
   ConstantPool(Array<u1>* tags);
   ConstantPool() { assert(DumpSharedSpaces || UseSharedSpaces, "only for CDS"); }
  public:
   static ConstantPool* allocate(ClassLoaderData* loader_data, int length, TRAPS);
 
-  bool is_constantPool() const volatile     { return true; }
+  virtual bool is_constantPool() const      { return true; }
 
   Array<u1>* tags() const                   { return _tags; }
   Array<u2>* operands() const               { return _operands; }
 
   bool has_preresolution() const            { return (_flags & _has_preresolution) != 0; }
diff a/src/hotspot/share/oops/klass.hpp b/src/hotspot/share/oops/klass.hpp
--- a/src/hotspot/share/oops/klass.hpp
+++ b/src/hotspot/share/oops/klass.hpp
@@ -200,11 +200,11 @@
   enum DefaultsLookupMode { find_defaults, skip_defaults };
   enum OverpassLookupMode { find_overpass, skip_overpass };
   enum StaticLookupMode   { find_static,   skip_static };
   enum PrivateLookupMode  { find_private,  skip_private };
 
-  bool is_klass() const volatile { return true; }
+  virtual bool is_klass() const { return true; }
 
   // super() cannot be InstanceKlass* -- Java arrays are covariant, and _super is used
   // to implement that. NB: the _super of "[Ljava/lang/Integer;" is "[Ljava/lang/Number;"
   // If this is not what your code expects, you're probably looking for Klass::java_super().
   Klass* super() const               { return _super; }
diff a/src/hotspot/share/oops/metadata.hpp b/src/hotspot/share/oops/metadata.hpp
--- a/src/hotspot/share/oops/metadata.hpp
+++ b/src/hotspot/share/oops/metadata.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -32,21 +32,21 @@
 // This is the base class for an internal Class related metadata
 class Metadata : public MetaspaceObj {
   // Debugging hook to check that the metadata has not been deleted.
   NOT_PRODUCT(int _valid;)
  public:
-  NOT_PRODUCT(Metadata()     { _valid = 0; })
-  NOT_PRODUCT(bool is_valid() const volatile { return _valid == 0; })
+  NOT_PRODUCT(Metadata() : _valid(0) {})
+  NOT_PRODUCT(bool is_valid() const { return _valid == 0; })
 
   int identity_hash()                { return (int)(uintptr_t)this; }
 
-  virtual bool is_metadata()           const volatile { return true; }
-  virtual bool is_klass()              const volatile { return false; }
-  virtual bool is_method()             const volatile { return false; }
-  virtual bool is_methodData()         const volatile { return false; }
-  virtual bool is_constantPool()       const volatile { return false; }
-  virtual bool is_methodCounters()     const volatile { return false; }
+  virtual bool is_metadata()           const { return true; }
+  virtual bool is_klass()              const { return false; }
+  virtual bool is_method()             const { return false; }
+  virtual bool is_methodData()         const { return false; }
+  virtual bool is_constantPool()       const { return false; }
+  virtual bool is_methodCounters()     const { return false; }
   virtual int  size()                  const = 0;
   virtual MetaspaceObj::Type type()    const = 0;
   virtual const char* internal_name()  const = 0;
   virtual void metaspace_pointers_do(MetaspaceClosure* iter) {}
 
diff a/src/hotspot/share/oops/method.hpp b/src/hotspot/share/oops/method.hpp
--- a/src/hotspot/share/oops/method.hpp
+++ b/src/hotspot/share/oops/method.hpp
@@ -134,11 +134,11 @@
                           TRAPS);
 
   // CDS and vtbl checking can create an empty Method to get vtbl pointer.
   Method(){}
 
-  bool is_method() const volatile { return true; }
+  virtual bool is_method() const { return true; }
 
   void restore_unshareable_info(TRAPS);
 
   // accessors for instance variables
 
diff a/src/hotspot/share/oops/methodCounters.hpp b/src/hotspot/share/oops/methodCounters.hpp
--- a/src/hotspot/share/oops/methodCounters.hpp
+++ b/src/hotspot/share/oops/methodCounters.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -111,11 +111,11 @@
     _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) << InvocationCounter::count_shift;
     _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) << InvocationCounter::count_shift;
   }
 
  public:
-  virtual bool is_methodCounters() const volatile { return true; }
+  virtual bool is_methodCounters() const { return true; }
 
   static MethodCounters* allocate(const methodHandle& mh, TRAPS);
 
   void deallocate_contents(ClassLoaderData* loader_data) {}
 
diff a/src/hotspot/share/oops/methodData.cpp b/src/hotspot/share/oops/methodData.cpp
--- a/src/hotspot/share/oops/methodData.cpp
+++ b/src/hotspot/share/oops/methodData.cpp
@@ -243,11 +243,11 @@
 
  public:
   ArgumentOffsetComputer(Symbol* signature, int max)
     : SignatureIterator(signature),
       _max(max), _offset(0),
-      _offsets(Thread::current(), max) {
+      _offsets(max) {
     do_parameters_on(this);  // non-virtual template execution
   }
 
   int off_at(int i) const { return _offsets.at(i); }
 };
diff a/src/hotspot/share/oops/methodData.hpp b/src/hotspot/share/oops/methodData.hpp
--- a/src/hotspot/share/oops/methodData.hpp
+++ b/src/hotspot/share/oops/methodData.hpp
@@ -2035,11 +2035,11 @@
   MethodData(const methodHandle& method, int size, TRAPS);
 public:
   static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle& method, TRAPS);
   MethodData() : _extra_data_lock(Mutex::leaf, "MDO extra data lock") {}; // For ciMethodData
 
-  bool is_methodData() const volatile { return true; }
+  virtual bool is_methodData() const { return true; }
   void initialize();
 
   // Whole-method sticky bits and flags
   enum {
     _trap_hist_limit    = 25 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT
diff a/src/hotspot/share/oops/oop.hpp b/src/hotspot/share/oops/oop.hpp
--- a/src/hotspot/share/oops/oop.hpp
+++ b/src/hotspot/share/oops/oop.hpp
@@ -86,12 +86,12 @@
   // objects during a GC) -- requires a valid klass pointer
   inline void init_mark();
   inline void init_mark_raw();
 
   inline Klass* klass() const;
-  inline Klass* klass_or_null() const volatile;
-  inline Klass* klass_or_null_acquire() const volatile;
+  inline Klass* klass_or_null() const;
+  inline Klass* klass_or_null_acquire() const;
   static inline Klass** klass_addr(HeapWord* mem);
   static inline narrowKlass* compressed_klass_addr(HeapWord* mem);
   inline Klass** klass_addr();
   inline narrowKlass* compressed_klass_addr();
 
diff a/src/hotspot/share/oops/oop.inline.hpp b/src/hotspot/share/oops/oop.inline.hpp
--- a/src/hotspot/share/oops/oop.inline.hpp
+++ b/src/hotspot/share/oops/oop.inline.hpp
@@ -94,24 +94,22 @@
   } else {
     return _metadata._klass;
   }
 }
 
-Klass* oopDesc::klass_or_null() const volatile {
+Klass* oopDesc::klass_or_null() const {
   if (UseCompressedClassPointers) {
     return CompressedKlassPointers::decode(_metadata._compressed_klass);
   } else {
     return _metadata._klass;
   }
 }
 
-Klass* oopDesc::klass_or_null_acquire() const volatile {
+Klass* oopDesc::klass_or_null_acquire() const {
   if (UseCompressedClassPointers) {
-    // Workaround for non-const load_acquire parameter.
-    const volatile narrowKlass* addr = &_metadata._compressed_klass;
-    volatile narrowKlass* xaddr = const_cast<volatile narrowKlass*>(addr);
-    return CompressedKlassPointers::decode(Atomic::load_acquire(xaddr));
+    narrowKlass nklass = Atomic::load_acquire(&_metadata._compressed_klass);
+    return CompressedKlassPointers::decode(nklass);
   } else {
     return Atomic::load_acquire(&_metadata._klass);
   }
 }
 
diff a/src/hotspot/share/opto/c2_globals.hpp b/src/hotspot/share/opto/c2_globals.hpp
--- a/src/hotspot/share/opto/c2_globals.hpp
+++ b/src/hotspot/share/opto/c2_globals.hpp
@@ -364,14 +364,16 @@
           "Print ideal graph to XML file / network interface. "             \
           "By default attempts to connect to the visualizer on a socket.")  \
                                                                             \
   notproduct(intx, PrintIdealGraphLevel, 0,                                 \
           "Level of detail of the ideal graph printout. "                   \
-          "System-wide value, 0=nothing is printed, 4=all details printed. "\
+          "System-wide value, -1=printing is disabled, "                    \
+          "0=print nothing except IGVPrintLevel directives, "               \
+          "4=all details printed. "                                         \
           "Level of detail of printouts can be set on a per-method level "  \
           "as well by using CompileCommand=option.")                        \
-          range(0, 4)                                                       \
+          range(-1, 4)                                                      \
                                                                             \
   notproduct(intx, PrintIdealGraphPort, 4444,                               \
           "Ideal graph printer to network port")                            \
           range(0, SHRT_MAX)                                                \
                                                                             \
diff a/src/hotspot/share/opto/cfgnode.cpp b/src/hotspot/share/opto/cfgnode.cpp
--- a/src/hotspot/share/opto/cfgnode.cpp
+++ b/src/hotspot/share/opto/cfgnode.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -1539,24 +1539,36 @@
   int false_path = 3 - true_path;
 
   // is_diamond_phi() has guaranteed the correctness of the nodes sequence:
   // phi->region->if_proj->ifnode->bool->cmp
   BoolNode *bol = phi_root->in(0)->in(1)->in(0)->in(1)->as_Bool();
+  Node *cmp = bol->in(1);
 
   // Check bool sense
-  switch( bol->_test._test ) {
-  case BoolTest::lt: cmp_zero_idx = 1; phi_x_idx = true_path;  break;
-  case BoolTest::le: cmp_zero_idx = 2; phi_x_idx = false_path; break;
-  case BoolTest::gt: cmp_zero_idx = 2; phi_x_idx = true_path;  break;
-  case BoolTest::ge: cmp_zero_idx = 1; phi_x_idx = false_path; break;
-  default:           return NULL;                              break;
+  if (cmp->Opcode() == Op_CmpF || cmp->Opcode() == Op_CmpD) {
+    switch (bol->_test._test) {
+    case BoolTest::lt: cmp_zero_idx = 1; phi_x_idx = true_path;  break;
+    case BoolTest::le: cmp_zero_idx = 2; phi_x_idx = false_path; break;
+    case BoolTest::gt: cmp_zero_idx = 2; phi_x_idx = true_path;  break;
+    case BoolTest::ge: cmp_zero_idx = 1; phi_x_idx = false_path; break;
+    default:           return NULL;                              break;
+    }
+  } else if (cmp->Opcode() == Op_CmpI || cmp->Opcode() == Op_CmpL) {
+    switch (bol->_test._test) {
+    case BoolTest::lt:
+    case BoolTest::le: cmp_zero_idx = 2; phi_x_idx = false_path; break;
+    case BoolTest::gt:
+    case BoolTest::ge: cmp_zero_idx = 2; phi_x_idx = true_path;  break;
+    default:           return NULL;                              break;
+    }
   }
 
   // Test is next
-  Node *cmp = bol->in(1);
   const Type *tzero = NULL;
-  switch( cmp->Opcode() ) {
+  switch (cmp->Opcode()) {
+  case Op_CmpI:    tzero = TypeInt::ZERO; break;  // Integer ABS
+  case Op_CmpL:    tzero = TypeLong::ZERO; break; // Long ABS
   case Op_CmpF:    tzero = TypeF::ZERO; break; // Float ABS
   case Op_CmpD:    tzero = TypeD::ZERO; break; // Double ABS
   default: return NULL;
   }
 
@@ -1587,18 +1599,34 @@
         phase->type(sub->in(1)) != tzero ) return NULL;
     x = new AbsFNode(x);
     if (flip) {
       x = new SubFNode(sub->in(1), phase->transform(x));
     }
-  } else {
+  } else if (tzero == TypeD::ZERO) {
     if( sub->Opcode() != Op_SubD ||
         sub->in(2) != x ||
         phase->type(sub->in(1)) != tzero ) return NULL;
     x = new AbsDNode(x);
     if (flip) {
       x = new SubDNode(sub->in(1), phase->transform(x));
     }
+  } else if (tzero == TypeInt::ZERO) {
+    if (sub->Opcode() != Op_SubI ||
+        sub->in(2) != x ||
+        phase->type(sub->in(1)) != tzero) return NULL;
+    x = new AbsINode(x);
+    if (flip) {
+      x = new SubINode(sub->in(1), phase->transform(x));
+    }
+  } else {
+    if (sub->Opcode() != Op_SubL ||
+        sub->in(2) != x ||
+        phase->type(sub->in(1)) != tzero) return NULL;
+    x = new AbsLNode(x);
+    if (flip) {
+      x = new SubLNode(sub->in(1), phase->transform(x));
+    }
   }
 
   return x;
 }
 
diff a/src/hotspot/share/opto/compile.cpp b/src/hotspot/share/opto/compile.cpp
--- a/src/hotspot/share/opto/compile.cpp
+++ b/src/hotspot/share/opto/compile.cpp
@@ -535,13 +535,11 @@
                   _env(ci_env),
                   _directive(directive),
                   _log(ci_env->log()),
                   _failure_reason(NULL),
                   _congraph(NULL),
-#ifndef PRODUCT
-                  _printer(IdealGraphPrinter::printer()),
-#endif
+                  NOT_PRODUCT(_printer(NULL) COMMA)
                   _dead_node_list(comp_arena()),
                   _dead_node_count(0),
                   _node_arena(mtCompiler),
                   _old_arena(mtCompiler),
                   _mach_constant_base_node(NULL),
@@ -565,15 +563,10 @@
 #ifndef PRODUCT
                   , _in_dump_cnt(0)
 #endif
 {
   C = this;
-#ifndef PRODUCT
-  if (_printer != NULL) {
-    _printer->set_compile(this);
-  }
-#endif
   CompileWrapper cw(this);
 
   if (CITimeVerbose) {
     tty->print(" ");
     target->holder()->name()->print();
@@ -729,11 +722,11 @@
   }
 
   // Drain the list.
   Finish_Warm();
 #ifndef PRODUCT
-  if (_printer && _printer->should_print(1)) {
+  if (should_print(1)) {
     _printer->print_inlining();
   }
 #endif
 
   if (failing())  return;
@@ -829,13 +822,11 @@
     _env(ci_env),
     _directive(directive),
     _log(ci_env->log()),
     _failure_reason(NULL),
     _congraph(NULL),
-#ifndef PRODUCT
-    _printer(NULL),
-#endif
+    NOT_PRODUCT(_printer(NULL) COMMA)
     _dead_node_list(comp_arena()),
     _dead_node_count(0),
     _node_arena(mtCompiler),
     _old_arena(mtCompiler),
     _mach_constant_base_node(NULL),
@@ -5039,11 +5030,11 @@
   if (event.should_commit()) {
     CompilerEvent::PhaseEvent::post(event, C->_latest_stage_start_counter, PHASE_END, C->_compile_id, level);
   }
 
 #ifndef PRODUCT
-  if (_printer && _printer->should_print(level)) {
+  if (_method != NULL && should_print(level)) {
     _printer->end_method();
   }
 #endif
 }
 
diff a/src/hotspot/share/opto/compile.hpp b/src/hotspot/share/opto/compile.hpp
--- a/src/hotspot/share/opto/compile.hpp
+++ b/src/hotspot/share/opto/compile.hpp
@@ -624,22 +624,32 @@
   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 
   Ticks _latest_stage_start_counter;
 
-  void begin_method() {
+  void begin_method(int level = 1) {
 #ifndef PRODUCT
-    if (_printer && _printer->should_print(1)) {
+    if (_method != NULL && should_print(level)) {
       _printer->begin_method();
     }
 #endif
     C->_latest_stage_start_counter.stamp();
   }
 
   bool should_print(int level = 1) {
 #ifndef PRODUCT
-    return (_printer && _printer->should_print(level));
+    if (PrintIdealGraphLevel < 0) { // disabled by the user
+      return false;
+    }
+
+    bool need = directive()->IGVPrintLevelOption >= level;
+    if (need && !_printer) {
+      _printer = IdealGraphPrinter::printer();
+      assert(_printer != NULL, "_printer is NULL when we need it!");
+      _printer->set_compile(this);
+    }
+    return need;
 #else
     return false;
 #endif
   }
 
diff a/src/hotspot/share/opto/idealGraphPrinter.cpp b/src/hotspot/share/opto/idealGraphPrinter.cpp
--- a/src/hotspot/share/opto/idealGraphPrinter.cpp
+++ b/src/hotspot/share/opto/idealGraphPrinter.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -73,14 +73,10 @@
 const char *IdealGraphPrinter::ASSEMBLY_ELEMENT = "assembly";
 
 int IdealGraphPrinter::_file_count = 0;
 
 IdealGraphPrinter *IdealGraphPrinter::printer() {
-  if (!PrintIdealGraph) {
-    return NULL;
-  }
-
   JavaThread *thread = JavaThread::current();
   if (!thread->is_Compiler_thread()) return NULL;
 
   CompilerThread *compiler_thread = (CompilerThread *)thread;
   if (compiler_thread->ideal_graph_printer() == NULL) {
@@ -631,11 +627,11 @@
     }
   }
 }
 
 void IdealGraphPrinter::print_method(const char *name, int level) {
-  if (should_print(level)) {
+  if (C->should_print(level)) {
     print(name, (Node *) C->root());
   }
 }
 
 // Print current ideal graph
@@ -689,15 +685,10 @@
   }
   tail(GRAPH_ELEMENT);
   _xml->flush();
 }
 
-// Should method be printed?
-bool IdealGraphPrinter::should_print(int level) {
-  return C->directive()->IGVPrintLevelOption >= level;
-}
-
 void IdealGraphPrinter::init_file_stream(const char* file_name, bool use_multiple_files, bool append) {
   ThreadCritical tc;
   if (use_multiple_files && _file_count != 0) {
     assert(!append, "append should only be used for debugging with a single file");
     ResourceMark rm;
diff a/src/hotspot/share/opto/idealGraphPrinter.hpp b/src/hotspot/share/opto/idealGraphPrinter.hpp
--- a/src/hotspot/share/opto/idealGraphPrinter.hpp
+++ b/src/hotspot/share/opto/idealGraphPrinter.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -124,11 +124,10 @@
   void print_inlining();
   void begin_method();
   void end_method();
   void print_method(const char *name, int level = 0);
   void print(const char *name, Node *root);
-  bool should_print(int level);
   void set_compile(Compile* compile) {C = compile; }
   void update_compiled_method(ciMethod* current_method);
 };
 
 #endif
diff a/src/hotspot/share/opto/macro.cpp b/src/hotspot/share/opto/macro.cpp
--- a/src/hotspot/share/opto/macro.cpp
+++ b/src/hotspot/share/opto/macro.cpp
@@ -406,11 +406,11 @@
   }
   Node *start_mem = C->start()->proj_out_or_null(TypeFunc::Memory);
   Node *alloc_mem = alloc->in(TypeFunc::Memory);
 
   uint length = mem->req();
-  GrowableArray <Node *> values(length, length, NULL, false);
+  GrowableArray <Node *> values(length, length, NULL);
 
   // create a new Phi for the value
   PhiNode *phi = new PhiNode(mem->in(0), phi_type, NULL, mem->_idx, instance_id, alias_idx, offset);
   transform_later(phi);
   value_phis->push(phi, mem->_idx);
diff a/src/hotspot/share/opto/node.cpp b/src/hotspot/share/opto/node.cpp
--- a/src/hotspot/share/opto/node.cpp
+++ b/src/hotspot/share/opto/node.cpp
@@ -2161,67 +2161,83 @@
     if( n != NULL )
       in(i)->verify_edges(visited);
   }
 }
 
-void Node::verify_recur(const Node *n, int verify_depth,
-                        VectorSet &old_space, VectorSet &new_space) {
-  if ( verify_depth == 0 )  return;
-  if (verify_depth > 0)  --verify_depth;
-
+// Verify all nodes if verify_depth is negative
+void Node::verify(Node* n, int verify_depth) {
+  assert(verify_depth != 0, "depth should not be 0");
+  ResourceMark rm;
+  ResourceArea* area = Thread::current()->resource_area();
+  VectorSet old_space(area);
+  VectorSet new_space(area);
+  Node_List worklist(area);
+  worklist.push(n);
   Compile* C = Compile::current();
+  uint last_index_on_current_depth = 0;
+  verify_depth--; // Visiting the first node on depth 1
+  // Only add nodes to worklist if verify_depth is negative (visit all nodes) or greater than 0
+  bool add_to_worklist = verify_depth != 0;
 
-  // Contained in new_space or old_space?
-  VectorSet *v = C->node_arena()->contains(n) ? &new_space : &old_space;
-  // Check for visited in the proper space.  Numberings are not unique
-  // across spaces so we need a separate VectorSet for each space.
-  if( v->test_set(n->_idx) ) return;
 
-  if (n->is_Con() && n->bottom_type() == Type::TOP) {
-    if (C->cached_top_node() == NULL)
-      C->set_cached_top_node((Node*)n);
-    assert(C->cached_top_node() == n, "TOP node must be unique");
-  }
+  for (uint list_index = 0; list_index < worklist.size(); list_index++) {
+    n = worklist[list_index];
+
+    if (n->is_Con() && n->bottom_type() == Type::TOP) {
+      if (C->cached_top_node() == NULL) {
+        C->set_cached_top_node((Node*)n);
+      }
+      assert(C->cached_top_node() == n, "TOP node must be unique");
+    }
 
-  for( uint i = 0; i < n->len(); i++ ) {
-    Node *x = n->in(i);
-    if (!x || x->is_top()) continue;
+    for (uint i = 0; i < n->len(); i++) {
+      Node* x = n->in(i);
+      if (!x || x->is_top()) {
+        continue;
+      }
 
-    // Verify my input has a def-use edge to me
-    if (true /*VerifyDefUse*/) {
+      // Verify my input has a def-use edge to me
       // Count use-def edges from n to x
       int cnt = 0;
-      for( uint j = 0; j < n->len(); j++ )
-        if( n->in(j) == x )
+      for (uint j = 0; j < n->len(); j++) {
+        if (n->in(j) == x) {
           cnt++;
+        }
+      }
+
       // Count def-use edges from x to n
       uint max = x->_outcnt;
-      for( uint k = 0; k < max; k++ )
-        if (x->_out[k] == n)
+      for (uint k = 0; k < max; k++) {
+        if (x->_out[k] == n) {
           cnt--;
-      assert( cnt == 0, "mismatched def-use edge counts" );
+        }
+      }
+      assert(cnt == 0, "mismatched def-use edge counts");
+
+      // Contained in new_space or old_space?
+      VectorSet* v = C->node_arena()->contains(x) ? &new_space : &old_space;
+      // Check for visited in the proper space. Numberings are not unique
+      // across spaces so we need a separate VectorSet for each space.
+      if (add_to_worklist && !v->test_set(x->_idx)) {
+        worklist.push(x);
+      }
     }
 
-    verify_recur(x, verify_depth, old_space, new_space);
+    if (verify_depth > 0 && list_index == last_index_on_current_depth) {
+      // All nodes on this depth were processed and its inputs are on the worklist. Decrement verify_depth and
+      // store the current last list index which is the last node in the list with the new depth. All nodes
+      // added afterwards will have a new depth again. Stop adding new nodes if depth limit is reached (=0).
+      verify_depth--;
+      if (verify_depth == 0) {
+        add_to_worklist = false;
+      }
+      last_index_on_current_depth = worklist.size() - 1;
+    }
   }
-
-}
-
-//------------------------------verify-----------------------------------------
-// Check Def-Use info for my subgraph
-void Node::verify() const {
-  Compile* C = Compile::current();
-  Node* old_top = C->cached_top_node();
-  ResourceMark rm;
-  ResourceArea *area = Thread::current()->resource_area();
-  VectorSet old_space(area), new_space(area);
-  verify_recur(this, -1, old_space, new_space);
-  C->set_cached_top_node(old_top);
 }
 #endif
 
-
 //------------------------------walk-------------------------------------------
 // Graph walk, with both pre-order and post-order functions
 void Node::walk(NFunc pre, NFunc post, void *env) {
   VectorSet visited(Thread::current()->resource_area()); // Setup for local walk
   walk_(pre, post, env, visited);
diff a/src/hotspot/share/opto/node.hpp b/src/hotspot/share/opto/node.hpp
--- a/src/hotspot/share/opto/node.hpp
+++ b/src/hotspot/share/opto/node.hpp
@@ -1163,12 +1163,11 @@
   void collect_nodes_in_all_ctrl(GrowableArray<Node*> *ns, bool data) const;
   // Collect the entire output graph until hitting and including control nodes.
   void collect_nodes_out_all_ctrl_boundary(GrowableArray<Node*> *ns) const;
 
   void verify_edges(Unique_Node_List &visited); // Verify bi-directional edges
-  void verify() const;               // Check Def-Use info for my subgraph
-  static void verify_recur(const Node *n, int verify_depth, VectorSet &old_space, VectorSet &new_space);
+  static void verify(Node* n, int verify_depth);
 
   // This call defines a class-unique string used to identify class instances
   virtual const char *Name() const;
 
   void dump_format(PhaseRegAlloc *ra) const; // debug access to MachNode::format(...)
diff a/src/hotspot/share/opto/output.cpp b/src/hotspot/share/opto/output.cpp
--- a/src/hotspot/share/opto/output.cpp
+++ b/src/hotspot/share/opto/output.cpp
@@ -28,10 +28,11 @@
 #include "code/compiledIC.hpp"
 #include "code/debugInfo.hpp"
 #include "code/debugInfoRec.hpp"
 #include "compiler/compileBroker.hpp"
 #include "compiler/compilerDirectives.hpp"
+#include "compiler/disassembler.hpp"
 #include "compiler/oopMap.hpp"
 #include "gc/shared/barrierSet.hpp"
 #include "gc/shared/c2/barrierSetC2.hpp"
 #include "memory/allocation.inline.hpp"
 #include "opto/ad.hpp"
@@ -1666,12 +1667,21 @@
       if (C->failing()) {
         return;
       }
 
 #ifdef ASSERT
-      if (n->size(C->regalloc()) < (current_offset-instr_offset)) {
+      uint n_size = n->size(C->regalloc());
+      if (n_size < (current_offset-instr_offset)) {
+        MachNode* mach = n->as_Mach();
         n->dump();
+        mach->dump_format(C->regalloc(), tty);
+        tty->print_cr(" n_size (%d), current_offset (%d), instr_offset (%d)", n_size, current_offset, instr_offset);
+        Disassembler::decode(cb->insts_begin() + instr_offset, cb->insts_begin() + current_offset + 1, tty);
+        tty->print_cr(" ------------------- ");
+        BufferBlob* blob = this->scratch_buffer_blob();
+        address blob_begin = blob->content_begin();
+        Disassembler::decode(blob_begin, blob_begin + n_size + 1, tty);
         assert(false, "wrong size of mach node");
       }
 #endif
       non_safepoints.observe_instruction(n, current_offset);
 
diff a/src/hotspot/share/opto/parse2.cpp b/src/hotspot/share/opto/parse2.cpp
--- a/src/hotspot/share/opto/parse2.cpp
+++ b/src/hotspot/share/opto/parse2.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -3473,12 +3473,12 @@
     tty->print("\nUnhandled bytecode %s\n", Bytecodes::name(bc()) );
     ShouldNotReachHere();
   }
 
 #ifndef PRODUCT
-  IdealGraphPrinter *printer = C->printer();
-  if (printer && printer->should_print(1)) {
+  if (C->should_print(1)) {
+    IdealGraphPrinter* printer = C->printer();
     char buffer[256];
     jio_snprintf(buffer, sizeof(buffer), "Bytecode %d: %s", bci(), Bytecodes::name(bc()));
     bool old = printer->traverse_outs();
     printer->set_traverse_outs(true);
     printer->print_method(buffer, 4);
diff a/src/hotspot/share/opto/phaseX.cpp b/src/hotspot/share/opto/phaseX.cpp
--- a/src/hotspot/share/opto/phaseX.cpp
+++ b/src/hotspot/share/opto/phaseX.cpp
@@ -1003,28 +1003,26 @@
 #ifndef PRODUCT
 void PhaseIterGVN::verify_step(Node* n) {
   if (VerifyIterativeGVN) {
     _verify_window[_verify_counter % _verify_window_size] = n;
     ++_verify_counter;
-    ResourceMark rm;
-    ResourceArea* area = Thread::current()->resource_area();
-    VectorSet old_space(area), new_space(area);
-    if (C->unique() < 1000 ||
-        0 == _verify_counter % (C->unique() < 10000 ? 10 : 100)) {
+    if (C->unique() < 1000 || 0 == _verify_counter % (C->unique() < 10000 ? 10 : 100)) {
       ++_verify_full_passes;
-      Node::verify_recur(C->root(), -1, old_space, new_space);
+      Node::verify(C->root(), -1);
     }
-    const int verify_depth = 4;
-    for ( int i = 0; i < _verify_window_size; i++ ) {
+    for (int i = 0; i < _verify_window_size; i++) {
       Node* n = _verify_window[i];
-      if ( n == NULL )  continue;
-      if( n->in(0) == NodeSentinel ) {  // xform_idom
+      if (n == NULL) {
+        continue;
+      }
+      if (n->in(0) == NodeSentinel) { // xform_idom
         _verify_window[i] = n->in(1);
-        --i; continue;
+        --i;
+        continue;
       }
       // Typical fanout is 1-2, so this call visits about 6 nodes.
-      Node::verify_recur(n, verify_depth, old_space, new_space);
+      Node::verify(n, 4);
     }
   }
 }
 
 void PhaseIterGVN::trace_PhaseIterGVN(Node* n, Node* nn, const Type* oldtype) {
diff a/src/hotspot/share/prims/jvmtiCodeBlobEvents.cpp b/src/hotspot/share/prims/jvmtiCodeBlobEvents.cpp
--- a/src/hotspot/share/prims/jvmtiCodeBlobEvents.cpp
+++ b/src/hotspot/share/prims/jvmtiCodeBlobEvents.cpp
@@ -170,11 +170,11 @@
 void CodeBlobCollector::collect() {
   assert_locked_or_safepoint(CodeCache_lock);
   assert(_global_code_blobs == NULL, "checking");
 
   // create the global list
-  _global_code_blobs = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<JvmtiCodeBlobDesc*>(50,true);
+  _global_code_blobs = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<JvmtiCodeBlobDesc*>(50, mtServiceability);
 
   // iterate over the stub code descriptors and put them in the list first.
   for (StubCodeDesc* desc = StubCodeDesc::first(); desc != NULL; desc = StubCodeDesc::next(desc)) {
     _global_code_blobs->append(new JvmtiCodeBlobDesc(desc->name(), desc->begin(), desc->end()));
   }
diff a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -1202,11 +1202,11 @@
   jvmtiError err = JVMTI_ERROR_NONE;
   JavaThread* calling_thread = JavaThread::current();
 
   // growable array of jvmti monitors info on the C-heap
   GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =
-      new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, true);
+      new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);
 
   // It is only safe to perform the direct operation on the current
   // thread. All other usage needs to use a direct handshake for safety.
   if (java_thread == calling_thread) {
     err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);
@@ -1247,11 +1247,11 @@
   jvmtiError err = JVMTI_ERROR_NONE;
   JavaThread* calling_thread = JavaThread::current();
 
   // growable array of jvmti monitors info on the C-heap
   GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =
-         new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, true);
+         new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);
 
   // It is only safe to perform the direct operation on the current
   // thread. All other usage needs to use a direct handshake for safety.
   if (java_thread == calling_thread) {
     err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);
diff a/src/hotspot/share/prims/jvmtiEnvBase.cpp b/src/hotspot/share/prims/jvmtiEnvBase.cpp
--- a/src/hotspot/share/prims/jvmtiEnvBase.cpp
+++ b/src/hotspot/share/prims/jvmtiEnvBase.cpp
@@ -1143,11 +1143,11 @@
   return JVMTI_ERROR_NONE;
 }
 
 ResourceTracker::ResourceTracker(JvmtiEnv* env) {
   _env = env;
-  _allocations = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<unsigned char*>(20, true);
+  _allocations = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<unsigned char*>(20, mtServiceability);
   _failed = false;
 }
 ResourceTracker::~ResourceTracker() {
   if (_failed) {
     for (int i=0; i<_allocations->length(); i++) {
diff a/src/hotspot/share/prims/jvmtiEnvThreadState.cpp b/src/hotspot/share/prims/jvmtiEnvThreadState.cpp
--- a/src/hotspot/share/prims/jvmtiEnvThreadState.cpp
+++ b/src/hotspot/share/prims/jvmtiEnvThreadState.cpp
@@ -94,11 +94,11 @@
 //
 // class JvmtiFramePops - public methods
 //
 
 JvmtiFramePops::JvmtiFramePops() {
-  _pops = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int> (2, true);
+  _pops = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<int> (2, mtServiceability);
 }
 
 JvmtiFramePops::~JvmtiFramePops() {
   // return memory to c_heap.
   delete _pops;
diff a/src/hotspot/share/prims/jvmtiExport.cpp b/src/hotspot/share/prims/jvmtiExport.cpp
--- a/src/hotspot/share/prims/jvmtiExport.cpp
+++ b/src/hotspot/share/prims/jvmtiExport.cpp
@@ -2810,11 +2810,11 @@
 }
 
 // register a stub
 void JvmtiDynamicCodeEventCollector::register_stub(const char* name, address start, address end) {
  if (_code_blobs == NULL) {
-   _code_blobs = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<JvmtiCodeBlobDesc*>(1,true);
+   _code_blobs = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<JvmtiCodeBlobDesc*>(1, mtServiceability);
  }
  _code_blobs->append(new JvmtiCodeBlobDesc(name, start, end));
 }
 
 // Setup current thread to record vm allocated objects.
@@ -2836,11 +2836,11 @@
 }
 
 void JvmtiObjectAllocEventCollector::record_allocation(oop obj) {
   assert(is_enabled(), "Object alloc event collector is not enabled");
   if (_allocated == NULL) {
-    _allocated = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<oop>(1, true);
+    _allocated = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(1, mtServiceability);
   }
   _allocated->push(obj);
 }
 
 // GC support.
diff a/src/hotspot/share/prims/jvmtiExtensions.cpp b/src/hotspot/share/prims/jvmtiExtensions.cpp
--- a/src/hotspot/share/prims/jvmtiExtensions.cpp
+++ b/src/hotspot/share/prims/jvmtiExtensions.cpp
@@ -47,12 +47,12 @@
 // unloading is enabled or disabled. We also have a single extension event
 // EXT_EVENT_CLASS_UNLOAD which is used to provide the JVMDI_EVENT_CLASS_UNLOAD
 // event. The function and the event are registered here.
 //
 void JvmtiExtensions::register_extensions() {
-  _ext_functions = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiExtensionFunctionInfo*>(1,true);
-  _ext_events = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiExtensionEventInfo*>(1,true);
+  _ext_functions = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiExtensionFunctionInfo*>(1, mtServiceability);
+  _ext_events = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiExtensionEventInfo*>(1, mtServiceability);
 
   // register our extension function
   static jvmtiParamInfo func_params[] = {
     { (char*)"IsClassUnloadingEnabled", JVMTI_KIND_OUT,  JVMTI_TYPE_JBOOLEAN, JNI_FALSE }
   };
diff a/src/hotspot/share/prims/jvmtiImpl.cpp b/src/hotspot/share/prims/jvmtiImpl.cpp
--- a/src/hotspot/share/prims/jvmtiImpl.cpp
+++ b/src/hotspot/share/prims/jvmtiImpl.cpp
@@ -144,11 +144,11 @@
 }
 
 void GrowableCache::initialize(void *this_obj, void listener_fun(void *, address*) ) {
   _this_obj       = this_obj;
   _listener_fun   = listener_fun;
-  _elements       = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<GrowableElement*>(5,true);
+  _elements       = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<GrowableElement*>(5, mtServiceability);
   recache();
 }
 
 // number of elements in the collection
 int GrowableCache::length() {
diff a/src/hotspot/share/prims/jvmtiRawMonitor.cpp b/src/hotspot/share/prims/jvmtiRawMonitor.cpp
--- a/src/hotspot/share/prims/jvmtiRawMonitor.cpp
+++ b/src/hotspot/share/prims/jvmtiRawMonitor.cpp
@@ -34,11 +34,11 @@
                                                 _event(thread->_ParkEvent),
                                                 _notified(0), _t_state(TS_RUN) {
 }
 
 GrowableArray<JvmtiRawMonitor*>* JvmtiPendingMonitors::_monitors =
-  new (ResourceObj::C_HEAP, mtInternal) GrowableArray<JvmtiRawMonitor*>(1, true);
+  new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<JvmtiRawMonitor*>(1, mtServiceability);
 
 void JvmtiPendingMonitors::transition_raw_monitors() {
   assert((Threads::number_of_threads()==1),
          "Java thread has not been created yet or more than one java thread "
          "is running. Raw monitor transition will not work");
diff a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
--- a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
@@ -1305,14 +1305,24 @@
     // Ensure class is linked before redefine
     if (!the_class->is_linked()) {
       the_class->link_class(THREAD);
       if (HAS_PENDING_EXCEPTION) {
         Symbol* ex_name = PENDING_EXCEPTION->klass()->name();
-        log_info(redefine, class, load, exceptions)("link_class exception: '%s'", ex_name->as_C_string());
+        oop message = java_lang_Throwable::message(PENDING_EXCEPTION);
+        if (message != NULL) {
+          char* ex_msg = java_lang_String::as_utf8_string(message);
+          log_info(redefine, class, load, exceptions)("link_class exception: '%s %s'",
+                   ex_name->as_C_string(), ex_msg);
+        } else {
+          log_info(redefine, class, load, exceptions)("link_class exception: '%s'",
+                   ex_name->as_C_string());
+        }
         CLEAR_PENDING_EXCEPTION;
         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
           return JVMTI_ERROR_OUT_OF_MEMORY;
+        } else if (ex_name == vmSymbols::java_lang_NoClassDefFoundError()) {
+          return JVMTI_ERROR_INVALID_CLASS;
         } else {
           return JVMTI_ERROR_INTERNAL;
         }
       }
     }
diff a/src/hotspot/share/prims/jvmtiTagMap.cpp b/src/hotspot/share/prims/jvmtiTagMap.cpp
--- a/src/hotspot/share/prims/jvmtiTagMap.cpp
+++ b/src/hotspot/share/prims/jvmtiTagMap.cpp
@@ -819,12 +819,12 @@
   static ClassFieldMap* create_map_of_static_fields(Klass* k);
   static ClassFieldMap* create_map_of_instance_fields(oop obj);
 };
 
 ClassFieldMap::ClassFieldMap() {
-  _fields = new (ResourceObj::C_HEAP, mtInternal)
-    GrowableArray<ClassFieldDescriptor*>(initial_field_count, true);
+  _fields = new (ResourceObj::C_HEAP, mtServiceability)
+    GrowableArray<ClassFieldDescriptor*>(initial_field_count, mtServiceability);
 }
 
 ClassFieldMap::~ClassFieldMap() {
   for (int i=0; i<_fields->length(); i++) {
     delete _fields->at(i);
@@ -956,12 +956,12 @@
 
 
 // record that the given InstanceKlass is caching a field map
 void JvmtiCachedClassFieldMap::add_to_class_list(InstanceKlass* ik) {
   if (_class_list == NULL) {
-    _class_list = new (ResourceObj::C_HEAP, mtInternal)
-      GrowableArray<InstanceKlass*>(initial_class_count, true);
+    _class_list = new (ResourceObj::C_HEAP, mtServiceability)
+      GrowableArray<InstanceKlass*>(initial_class_count, mtServiceability);
   }
   _class_list->push(ik);
 }
 
 // returns the instance field map for the given object
@@ -1529,12 +1529,12 @@
  public:
   TagObjectCollector(JvmtiEnv* env, const jlong* tags, jint tag_count) {
     _env = env;
     _tags = (jlong*)tags;
     _tag_count = tag_count;
-    _object_results = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jobject>(1,true);
-    _tag_results = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<uint64_t>(1,true);
+    _object_results = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jobject>(1, mtServiceability);
+    _tag_results = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<uint64_t>(1, mtServiceability);
   }
 
   ~TagObjectCollector() {
     delete _object_results;
     delete _tag_results;
@@ -1672,12 +1672,12 @@
 
   // prepare heap for iteration
   Universe::heap()->ensure_parsability(false);  // no need to retire TLABs
 
   // create stacks for interesting headers
-  _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markWord>(4000, true);
-  _saved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<oop>(4000, true);
+  _saved_mark_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<markWord>(4000, mtServiceability);
+  _saved_oop_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(4000, mtServiceability);
 
   if (UseBiasedLocking) {
     BiasedLocking::preserve_marks();
   }
 }
@@ -2661,11 +2661,11 @@
   bool _reporting_primitive_fields;                 // optional reporting
   bool _reporting_primitive_array_values;
   bool _reporting_string_values;
 
   GrowableArray<oop>* create_visit_stack() {
-    return new (ResourceObj::C_HEAP, mtInternal) GrowableArray<oop>(initial_visit_stack_size, true);
+    return new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(initial_visit_stack_size, mtServiceability);
   }
 
   // accessors
   bool is_advanced_heap_walk() const               { return _is_advanced_heap_walk; }
   JvmtiTagMap* tag_map() const                     { return _tag_map; }
diff a/src/hotspot/share/runtime/arguments.cpp b/src/hotspot/share/runtime/arguments.cpp
--- a/src/hotspot/share/runtime/arguments.cpp
+++ b/src/hotspot/share/runtime/arguments.cpp
@@ -546,28 +546,14 @@
   { "MaxPermSize",                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
   { "SharedReadWriteSize",           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
   { "SharedReadOnlySize",            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
   { "SharedMiscDataSize",            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
   { "SharedMiscCodeSize",            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
-  { "BindGCTaskThreadsToCPUs",       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
-  { "UseGCTaskAffinity",             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
-  { "GCTaskTimeStampEntries",        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
-  { "G1RSetScanBlockSize",           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
-  { "UseParallelOldGC",              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
-  { "CompactFields",                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
-  { "FieldsAllocationStyle",         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
-#ifndef X86
-  { "UseSSE",                        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
-#endif // !X86
-  { "UseAdaptiveGCBoundary",         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
-  { "MonitorBound",                  JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
-#ifdef AARCH64
-  { "UseBarriersForVolatile",        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
+#ifdef BSD
+  { "UseBsdPosixThreadCPUClocks",    JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },
+  { "UseOprofile",                   JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 #endif
-  { "UseLWPSynchronization",         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
-  { "BranchOnRegister",              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
-  { "LIRFillDelaySlots",             JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 
 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
   // These entries will generate build errors.  Their purpose is to test the macros.
   { "dep > obs",                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
   { "dep > exp ",                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
@@ -1465,15 +1451,17 @@
     key = tmp_key;
 
     value = &prop[key_len + 1];
   }
 
+#if INCLUDE_CDS
   if (is_internal_module_property(key) ||
       strcmp(key, "jdk.module.main") == 0) {
     MetaspaceShared::disable_optimized_module_handling();
     log_info(cds)("Using optimized module handling disabled due to incompatible property: %s=%s", key, value);
   }
+#endif
 
   if (strcmp(key, "java.compiler") == 0) {
     process_java_compiler_argument(value);
     // Record value in Arguments, but let it get passed to Java.
   } else if (strcmp(key, "sun.java.launcher.is_altjvm") == 0) {
@@ -2524,12 +2512,14 @@
           "-Xbootclasspath is no longer a supported option.\n");
         return JNI_EINVAL;
     // -bootclasspath/a:
     } else if (match_option(option, "-Xbootclasspath/a:", &tail)) {
       Arguments::append_sysclasspath(tail);
+#if INCLUDE_CDS
       MetaspaceShared::disable_optimized_module_handling();
       log_info(cds)("Using optimized module handling disabled due to bootclasspath was appended");
+#endif
     // -bootclasspath/p:
     } else if (match_option(option, "-Xbootclasspath/p:", &tail)) {
         jio_fprintf(defaultStream::output_stream(),
           "-Xbootclasspath/p is no longer a supported option.\n");
         return JNI_EINVAL;
@@ -3146,11 +3136,11 @@
     }
   }
 
   // Create GrowableArray lazily, only if --patch-module has been specified
   if (_patch_mod_prefix == NULL) {
-    _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<ModulePatchPath*>(10, true);
+    _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<ModulePatchPath*>(10, mtArguments);
   }
 
   _patch_mod_prefix->push(new ModulePatchPath(module_name, path));
 }
 
@@ -3402,11 +3392,11 @@
     assert(args_to_insert->nOptions != 0, "there should be args to insert");
     assert(vm_options_file_pos != -1, "vm_options_file_pos should be set");
 
     int length = args->nOptions + args_to_insert->nOptions - 1;
     GrowableArray<JavaVMOption> *options = new (ResourceObj::C_HEAP, mtArguments)
-              GrowableArray<JavaVMOption>(length, true);    // Construct new option array
+              GrowableArray<JavaVMOption>(length, mtArguments);    // Construct new option array
     for (int i = 0; i < args->nOptions; i++) {
       if (i == vm_options_file_pos) {
         // insert the new options starting at the same place as the
         // -XX:VMOptionsFile option
         for (int j = 0; j < args_to_insert->nOptions; j++) {
@@ -3514,11 +3504,11 @@
   FREE_C_HEAP_ARRAY(char, buf);
   return retcode;
 }
 
 jint Arguments::parse_options_buffer(const char* name, char* buffer, const size_t buf_len, ScopedVMInitArgs* vm_args) {
-  GrowableArray<JavaVMOption> *options = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JavaVMOption>(2, true);    // Construct option array
+  GrowableArray<JavaVMOption> *options = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JavaVMOption>(2, mtArguments);    // Construct option array
 
   // some pointers to help with parsing
   char *buffer_end = buffer + buf_len;
   char *opt_hd = buffer;
   char *wrt = buffer;
diff a/src/hotspot/share/runtime/biasedLocking.cpp b/src/hotspot/share/runtime/biasedLocking.cpp
--- a/src/hotspot/share/runtime/biasedLocking.cpp
+++ b/src/hotspot/share/runtime/biasedLocking.cpp
@@ -903,12 +903,12 @@
   // must not clobber a bias is when a biased object is currently
   // locked. To handle this case we iterate over the currently-locked
   // monitors in a prepass and, if they are biased, preserve their
   // mark words here. This should be a relatively small set of objects
   // especially compared to the number of objects in the heap.
-  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markWord>(10, true);
-  _preserved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<Handle>(10, true);
+  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<markWord>(10, mtGC);
+  _preserved_oop_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<Handle>(10, mtGC);
 
   ResourceMark rm;
   Thread* cur = Thread::current();
   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
     if (thread->has_last_Java_frame()) {
diff a/src/hotspot/share/runtime/flags/jvmFlagConstraintList.cpp b/src/hotspot/share/runtime/flags/jvmFlagConstraintList.cpp
--- a/src/hotspot/share/runtime/flags/jvmFlagConstraintList.cpp
+++ b/src/hotspot/share/runtime/flags/jvmFlagConstraintList.cpp
@@ -248,11 +248,11 @@
 GrowableArray<JVMFlagConstraint*>* JVMFlagConstraintList::_constraints = NULL;
 JVMFlagConstraint::ConstraintType JVMFlagConstraintList::_validating_type = JVMFlagConstraint::AtParse;
 
 // Check the ranges of all flags that have them or print them out and exit if requested
 void JVMFlagConstraintList::init(void) {
-  _constraints = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JVMFlagConstraint*>(INITIAL_CONSTRAINTS_SIZE, true);
+  _constraints = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JVMFlagConstraint*>(INITIAL_CONSTRAINTS_SIZE, mtArguments);
 
   EMIT_CONSTRAINT_START
 
   ALL_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,
             EMIT_CONSTRAINT_PD_DEVELOPER_FLAG,
diff a/src/hotspot/share/runtime/flags/jvmFlagRangeList.cpp b/src/hotspot/share/runtime/flags/jvmFlagRangeList.cpp
--- a/src/hotspot/share/runtime/flags/jvmFlagRangeList.cpp
+++ b/src/hotspot/share/runtime/flags/jvmFlagRangeList.cpp
@@ -313,11 +313,11 @@
 GrowableArray<JVMFlagRange*>* JVMFlagRangeList::_ranges = NULL;
 
 // Check the ranges of all flags that have them
 void JVMFlagRangeList::init(void) {
 
-  _ranges = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JVMFlagRange*>(INITIAL_RANGES_SIZE, true);
+  _ranges = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JVMFlagRange*>(INITIAL_RANGES_SIZE, mtArguments);
 
   EMIT_RANGE_START
 
   ALL_FLAGS(EMIT_RANGE_DEVELOPER_FLAG,
             EMIT_RANGE_PD_DEVELOPER_FLAG,
diff a/src/hotspot/share/runtime/perfData.cpp b/src/hotspot/share/runtime/perfData.cpp
--- a/src/hotspot/share/runtime/perfData.cpp
+++ b/src/hotspot/share/runtime/perfData.cpp
@@ -561,16 +561,16 @@
   return p;
 }
 
 PerfDataList::PerfDataList(int length) {
 
-  _set = new(ResourceObj::C_HEAP, mtInternal) PerfDataArray(length, true);
+  _set = new(ResourceObj::C_HEAP, mtInternal) PerfDataArray(length, mtInternal);
 }
 
 PerfDataList::PerfDataList(PerfDataList* p) {
 
-  _set = new(ResourceObj::C_HEAP, mtInternal) PerfDataArray(p->length(), true);
+  _set = new(ResourceObj::C_HEAP, mtInternal) PerfDataArray(p->length(), mtInternal);
 
   _set->appendAll(p->get_impl());
 }
 
 PerfDataList::~PerfDataList() {
diff a/src/hotspot/share/runtime/reflectionUtils.cpp b/src/hotspot/share/runtime/reflectionUtils.cpp
--- a/src/hotspot/share/runtime/reflectionUtils.cpp
+++ b/src/hotspot/share/runtime/reflectionUtils.cpp
@@ -67,11 +67,11 @@
   return eos();
 }
 
 
 GrowableArray<FilteredField*> *FilteredFieldsMap::_filtered_fields =
-  new (ResourceObj::C_HEAP, mtInternal) GrowableArray<FilteredField*>(3,true);
+  new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<FilteredField*>(3, mtServiceability);
 
 
 void FilteredFieldsMap::initialize() {
   int offset = reflect_ConstantPool::oop_offset();
   _filtered_fields->append(new FilteredField(SystemDictionary::reflect_ConstantPool_klass(), offset));
diff a/src/hotspot/share/runtime/sharedRuntime.cpp b/src/hotspot/share/runtime/sharedRuntime.cpp
--- a/src/hotspot/share/runtime/sharedRuntime.cpp
+++ b/src/hotspot/share/runtime/sharedRuntime.cpp
@@ -2969,11 +2969,11 @@
         address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
         entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),
                                                  StubRoutines::throw_AbstractMethodError_entry(),
                                                  wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,
                                                  wrong_method_abstract, wrong_method_abstract);
-        GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(sig_cc_ro.length(), true);
+        GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(sig_cc_ro.length(), mtInternal);
         heap_sig->appendAll(&sig_cc_ro);
         entry->set_sig_cc(heap_sig);
         return entry;
       } else {
         return _abstract_method_handler;
@@ -3025,11 +3025,11 @@
                                                      fingerprint,
                                                      new_adapter);
 
       if (ces.has_scalarized_args()) {
         // Save a C heap allocated version of the scalarized signature and store it in the adapter
-        GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(sig_cc.length(), true);
+        GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(sig_cc.length(), mtInternal);
         heap_sig->appendAll(&sig_cc);
         entry->set_sig_cc(heap_sig);
       }
 
 #ifdef ASSERT
diff a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -231,11 +231,11 @@
   // allocated data structures
   set_osthread(NULL);
   set_resource_area(new (mtThread)ResourceArea());
   DEBUG_ONLY(_current_resource_mark = NULL;)
   set_handle_area(new (mtThread) HandleArea(NULL));
-  set_metadata_handles(new (ResourceObj::C_HEAP, mtClass) GrowableArray<Metadata*>(30, true));
+  set_metadata_handles(new (ResourceObj::C_HEAP, mtClass) GrowableArray<Metadata*>(30, mtClass));
   set_active_handles(NULL);
   set_free_handle_block(NULL);
   set_last_handle_mark(NULL);
   DEBUG_ONLY(_missed_ic_stub_refill_verifier = NULL);
 
diff a/src/hotspot/share/runtime/unhandledOops.cpp b/src/hotspot/share/runtime/unhandledOops.cpp
--- a/src/hotspot/share/runtime/unhandledOops.cpp
+++ b/src/hotspot/share/runtime/unhandledOops.cpp
@@ -33,12 +33,12 @@
 const int free_list_size = 256;
 
 
 UnhandledOops::UnhandledOops(Thread* thread) {
   _thread = thread;
-  _oop_list = new (ResourceObj::C_HEAP, mtInternal)
-                    GrowableArray<UnhandledOopEntry>(free_list_size, true);
+  _oop_list = new (ResourceObj::C_HEAP, mtThread)
+                    GrowableArray<UnhandledOopEntry>(free_list_size, mtThread);
   _level = 0;
 }
 
 UnhandledOops::~UnhandledOops() {
   delete _oop_list;
diff a/src/hotspot/share/runtime/vframe_hp.cpp b/src/hotspot/share/runtime/vframe_hp.cpp
--- a/src/hotspot/share/runtime/vframe_hp.cpp
+++ b/src/hotspot/share/runtime/vframe_hp.cpp
@@ -115,11 +115,11 @@
     }
     // No matching vframe must push a new vframe
   } else {
     // No deferred updates pending for this thread.
     // allocate in C heap
-    deferred =  new(ResourceObj::C_HEAP, mtCompiler) GrowableArray<jvmtiDeferredLocalVariableSet*> (1, true);
+    deferred =  new(ResourceObj::C_HEAP, mtCompiler) GrowableArray<jvmtiDeferredLocalVariableSet*> (1, mtCompiler);
     thread()->set_deferred_locals(deferred);
   }
   if (locals == NULL) {
     locals = new jvmtiDeferredLocalVariableSet(method(), bci(), fr().id(), vframe_id());
     deferred->push(locals);
@@ -327,11 +327,11 @@
   _method = method;
   _bci = bci;
   _id = id;
   _vframe_id = vframe_id;
   // Alway will need at least one, must be on C heap
-  _locals = new(ResourceObj::C_HEAP, mtCompiler) GrowableArray<jvmtiDeferredLocalVariable*> (1, true);
+  _locals = new(ResourceObj::C_HEAP, mtCompiler) GrowableArray<jvmtiDeferredLocalVariable*> (1, mtCompiler);
 }
 
 jvmtiDeferredLocalVariableSet::~jvmtiDeferredLocalVariableSet() {
   for (int i = 0; i < _locals->length(); i++ ) {
     delete _locals->at(i);
diff a/src/hotspot/share/services/diagnosticArgument.cpp b/src/hotspot/share/services/diagnosticArgument.cpp
--- a/src/hotspot/share/services/diagnosticArgument.cpp
+++ b/src/hotspot/share/services/diagnosticArgument.cpp
@@ -28,11 +28,11 @@
 #include "memory/resourceArea.hpp"
 #include "runtime/thread.hpp"
 #include "services/diagnosticArgument.hpp"
 
 StringArrayArgument::StringArrayArgument() {
-  _array = new(ResourceObj::C_HEAP, mtInternal)GrowableArray<char *>(32, true);
+  _array = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<char *>(32, mtServiceability);
   assert(_array != NULL, "Sanity check");
 }
 
 StringArrayArgument::~StringArrayArgument() {
   for (int i=0; i<_array->length(); i++) {
diff a/src/hotspot/share/services/heapDumper.cpp b/src/hotspot/share/services/heapDumper.cpp
--- a/src/hotspot/share/services/heapDumper.cpp
+++ b/src/hotspot/share/services/heapDumper.cpp
@@ -1534,11 +1534,11 @@
                     0 /* total full collections, dummy, ignored */,
                     gc_before_heap_dump),
     AbstractGangTask("dump heap") {
     _local_writer = writer;
     _gc_before_heap_dump = gc_before_heap_dump;
-    _klass_map = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<Klass*>(INITIAL_CLASS_COUNT, true);
+    _klass_map = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<Klass*>(INITIAL_CLASS_COUNT, mtServiceability);
     _stack_traces = NULL;
     _num_threads = 0;
     if (oome) {
       assert(!Thread::current()->is_VM_thread(), "Dump from OutOfMemoryError cannot be called by the VMThread");
       // get OutOfMemoryError zero-parameter constructor
diff a/src/hotspot/share/services/memoryService.cpp b/src/hotspot/share/services/memoryService.cpp
--- a/src/hotspot/share/services/memoryService.cpp
+++ b/src/hotspot/share/services/memoryService.cpp
@@ -42,17 +42,17 @@
 #include "services/memoryService.hpp"
 #include "utilities/growableArray.hpp"
 #include "utilities/macros.hpp"
 
 GrowableArray<MemoryPool*>* MemoryService::_pools_list =
-  new (ResourceObj::C_HEAP, mtInternal) GrowableArray<MemoryPool*>(init_pools_list_size, true);
+  new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<MemoryPool*>(init_pools_list_size, mtServiceability);
 GrowableArray<MemoryManager*>* MemoryService::_managers_list =
-  new (ResourceObj::C_HEAP, mtInternal) GrowableArray<MemoryManager*>(init_managers_list_size, true);
+  new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<MemoryManager*>(init_managers_list_size, mtServiceability);
 
 MemoryManager*   MemoryService::_code_cache_manager    = NULL;
 GrowableArray<MemoryPool*>* MemoryService::_code_heap_pools =
-    new (ResourceObj::C_HEAP, mtInternal) GrowableArray<MemoryPool*>(init_code_heap_pools_size, true);
+    new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<MemoryPool*>(init_code_heap_pools_size, mtServiceability);
 MemoryPool*      MemoryService::_metaspace_pool        = NULL;
 MemoryPool*      MemoryService::_compressed_class_pool = NULL;
 
 class GcThreadCountClosure: public ThreadClosure {
  private:
diff a/src/hotspot/share/services/threadService.cpp b/src/hotspot/share/services/threadService.cpp
--- a/src/hotspot/share/services/threadService.cpp
+++ b/src/hotspot/share/services/threadService.cpp
@@ -587,11 +587,11 @@
   if (with_lock_info) {
     ResourceMark rm;
     GrowableArray<MonitorInfo*>* list = jvf->locked_monitors();
     int length = list->length();
     if (length > 0) {
-      _locked_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<oop>(length, true);
+      _locked_monitors = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(length, mtServiceability);
       for (int i = 0; i < length; i++) {
         MonitorInfo* monitor = list->at(i);
         assert(monitor->owner() != NULL, "This monitor must have an owning object");
         _locked_monitors->append(monitor->owner());
       }
@@ -644,15 +644,15 @@
   }
 };
 
 ThreadStackTrace::ThreadStackTrace(JavaThread* t, bool with_locked_monitors) {
   _thread = t;
-  _frames = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<StackFrameInfo*>(INITIAL_ARRAY_SIZE, true);
+  _frames = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<StackFrameInfo*>(INITIAL_ARRAY_SIZE, mtServiceability);
   _depth = 0;
   _with_locked_monitors = with_locked_monitors;
   if (_with_locked_monitors) {
-    _jni_locked_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<oop>(INITIAL_ARRAY_SIZE, true);
+    _jni_locked_monitors = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(INITIAL_ARRAY_SIZE, mtServiceability);
   } else {
     _jni_locked_monitors = NULL;
   }
 }
 
@@ -774,11 +774,11 @@
 
 void ConcurrentLocksDump::dump_at_safepoint() {
   // dump all locked concurrent locks
   assert(SafepointSynchronize::is_at_safepoint(), "all threads are stopped");
 
-  GrowableArray<oop>* aos_objects = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<oop>(INITIAL_ARRAY_SIZE, true /* C_heap */);
+  GrowableArray<oop>* aos_objects = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(INITIAL_ARRAY_SIZE, mtServiceability);
 
   // Find all instances of AbstractOwnableSynchronizer
   HeapInspection::find_instances_at_safepoint(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass(),
                                               aos_objects);
   // Build a map of thread to its owned AQS locks
@@ -848,11 +848,11 @@
   st->cr();
 }
 
 ThreadConcurrentLocks::ThreadConcurrentLocks(JavaThread* thread) {
   _thread = thread;
-  _owned_locks = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<instanceOop>(INITIAL_ARRAY_SIZE, true);
+  _owned_locks = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<instanceOop>(INITIAL_ARRAY_SIZE, mtServiceability);
   _next = NULL;
 }
 
 ThreadConcurrentLocks::~ThreadConcurrentLocks() {
   delete _owned_locks;
@@ -960,11 +960,11 @@
 }
 
 
 DeadlockCycle::DeadlockCycle() {
   _is_deadlock = false;
-  _threads = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<JavaThread*>(INITIAL_ARRAY_SIZE, true);
+  _threads = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<JavaThread*>(INITIAL_ARRAY_SIZE, mtServiceability);
   _next = NULL;
 }
 
 DeadlockCycle::~DeadlockCycle() {
   delete _threads;
diff a/src/hotspot/share/utilities/growableArray.hpp b/src/hotspot/share/utilities/growableArray.hpp
--- a/src/hotspot/share/utilities/growableArray.hpp
+++ b/src/hotspot/share/utilities/growableArray.hpp
@@ -105,19 +105,18 @@
   bool on_stack () { return _arena == NULL;      }
   bool on_arena () { return _arena >  (Arena*)1;  }
 
   // This GA will use the resource stack for storage if c_heap==false,
   // Else it will use the C heap.  Use clear_and_deallocate to avoid leaks.
-  GenericGrowableArray(int initial_size, int initial_len, bool c_heap, MEMFLAGS flags = mtNone) {
+  GenericGrowableArray(int initial_size, int initial_len, MEMFLAGS flags) {
     _len = initial_len;
     _max = initial_size;
     _memflags = flags;
 
-    // memory type has to be specified for C heap allocation
-    assert(!(c_heap && flags == mtNone), "memory type not specified for C heap object");
-
     assert(_len >= 0 && _len <= _max, "initial_len too big");
+
+    const bool c_heap = flags != mtNone;
     _arena = (c_heap ? (Arena*)1 : NULL);
     set_nesting();
     assert(!on_C_heap() || allocated_on_C_heap(), "growable array must be on C heap if elements are");
     assert(!on_stack() ||
            (allocated_on_res_area() || allocated_on_stack()),
@@ -140,16 +139,10 @@
            "growable array must be on arena or on stack if elements are on arena");
   }
 
   void* raw_allocate(int elementSize);
 
-  // some uses pass the Thread explicitly for speed (4990299 tuning)
-  void* raw_allocate(Thread* thread, int elementSize) {
-    assert(on_stack(), "fast ResourceObj path only");
-    return (void*)resource_allocate_bytes(thread, elementSize * _max);
-  }
-
   void free_C_heap(void* elements);
 };
 
 template<class E> class GrowableArrayIterator;
 template<class E, class UnaryPredicate> class GrowableArrayFilterIterator;
@@ -167,28 +160,24 @@
   E*     _data;         // data array
 
   void grow(int j);
   void raw_at_put_grow(int i, const E& p, const E& fill);
   void  clear_and_deallocate();
- public:
-  GrowableArray(Thread* thread, int initial_size) : GenericGrowableArray(initial_size, 0, false) {
-    _data = (E*)raw_allocate(thread, sizeof(E));
-    for (int i = 0; i < _max; i++) ::new ((void*)&_data[i]) E();
-  }
 
-  GrowableArray(int initial_size, bool C_heap = false, MEMFLAGS F = mtInternal)
-    : GenericGrowableArray(initial_size, 0, C_heap, F) {
+public:
+  GrowableArray(int initial_size, MEMFLAGS F = mtNone)
+    : GenericGrowableArray(initial_size, 0, F) {
     _data = (E*)raw_allocate(sizeof(E));
 // Needed for Visual Studio 2012 and older
 #ifdef _MSC_VER
 #pragma warning(suppress: 4345)
 #endif
     for (int i = 0; i < _max; i++) ::new ((void*)&_data[i]) E();
   }
 
-  GrowableArray(int initial_size, int initial_len, const E& filler, bool C_heap = false, MEMFLAGS memflags = mtInternal)
-    : GenericGrowableArray(initial_size, initial_len, C_heap, memflags) {
+  GrowableArray(int initial_size, int initial_len, const E& filler, MEMFLAGS memflags = mtNone)
+    : GenericGrowableArray(initial_size, initial_len, memflags) {
     _data = (E*)raw_allocate(sizeof(E));
     int i = 0;
     for (; i < _len; i++) ::new ((void*)&_data[i]) E(filler);
     for (; i < _max; i++) ::new ((void*)&_data[i]) E();
   }
@@ -202,11 +191,11 @@
     int i = 0;
     for (; i < _len; i++) ::new ((void*)&_data[i]) E(filler);
     for (; i < _max; i++) ::new ((void*)&_data[i]) E();
   }
 
-  GrowableArray() : GenericGrowableArray(2, 0, false) {
+  GrowableArray() : GenericGrowableArray(2, 0, mtNone) {
     _data = (E*)raw_allocate(sizeof(E));
     ::new ((void*)&_data[0]) E();
     ::new ((void*)&_data[1]) E();
   }
 
diff a/src/hotspot/share/utilities/hashtable.inline.hpp b/src/hotspot/share/utilities/hashtable.inline.hpp
--- a/src/hotspot/share/utilities/hashtable.inline.hpp
+++ b/src/hotspot/share/utilities/hashtable.inline.hpp
@@ -71,11 +71,11 @@
   _entry_size = entry_size;
   _free_list = NULL;
   _first_free_entry = NULL;
   _end_block = NULL;
   _number_of_entries = number_of_entries;
-  _entry_blocks = new(ResourceObj::C_HEAP, F) GrowableArray<char*>(4, true, F);
+  _entry_blocks = new(ResourceObj::C_HEAP, F) GrowableArray<char*>(4, F);
 }
 
 
 // The following method is MT-safe and may be used with caution.
 template <MEMFLAGS F> inline BasicHashtableEntry<F>* BasicHashtable<F>::bucket(int i) const {
diff a/src/hotspot/share/utilities/histogram.cpp b/src/hotspot/share/utilities/histogram.cpp
--- a/src/hotspot/share/utilities/histogram.cpp
+++ b/src/hotspot/share/utilities/histogram.cpp
@@ -68,11 +68,11 @@
   return (*e1)->compare(*e1,*e2);
 }
 
 Histogram::Histogram(const char* title,int estimatedCount) {
   _title = title;
-  _elements = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<HistogramElement*>(estimatedCount,true);
+  _elements = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<HistogramElement*>(estimatedCount, mtServiceability);
 }
 
 void Histogram::add_element(HistogramElement* element) {
   // Note, we need to add locking !
   elements()->append(element);
diff a/src/java.base/share/classes/com/sun/crypto/provider/HmacCore.java b/src/java.base/share/classes/com/sun/crypto/provider/HmacCore.java
--- a/src/java.base/share/classes/com/sun/crypto/provider/HmacCore.java
+++ b/src/java.base/share/classes/com/sun/crypto/provider/HmacCore.java
@@ -73,10 +73,11 @@
             if (sun != null) {
                 md = MessageDigest.getInstance(digestAlgo, sun);
             } else {
                 String noCloneProv = md.getProvider().getName();
                 // if no Sun provider, use provider list
+                md = null;
                 Provider[] provs = Security.getProviders();
                 for (Provider p : provs) {
                     try {
                         if (!p.getName().equals(noCloneProv)) {
                             MessageDigest md2 =
@@ -88,10 +89,14 @@
                         }
                     } catch (NoSuchAlgorithmException nsae) {
                         continue;
                     }
                 }
+                if (md == null) {
+                    throw new NoSuchAlgorithmException
+                            ("No Cloneable digest found for " + digestAlgo);
+                }
             }
         }
         this.md = md;
         this.blockLen = bl;
         this.k_ipad = new byte[blockLen];
diff a/src/java.base/share/classes/java/lang/Class.java b/src/java.base/share/classes/java/lang/Class.java
--- a/src/java.base/share/classes/java/lang/Class.java
+++ b/src/java.base/share/classes/java/lang/Class.java
@@ -4457,13 +4457,15 @@
      *           feature of the Java language. Preview features
      *           may be removed in a future release, or upgraded to permanent
      *           features of the Java language.}
      *
      * Returns an array containing {@code ClassDesc} objects representing all the
-     * direct subclasses or direct implementation classes permitted to extend or implement this class or interface
-     * if it is sealed. If this {@code Class} object represents a primitive type, {@code void}, an array type,
-     * or a class or interface that is not sealed, an empty array is returned.
+     * direct subclasses or direct implementation classes permitted to extend or
+     * implement this class or interface if it is sealed. The order of such elements
+     * is unspecified. If this {@code Class} object represents a primitive type,
+     * {@code void}, an array type, or a class or interface that is not sealed,
+     * an empty array is returned.
      *
      * @return an array of class descriptors of all the permitted subclasses of this class or interface
      *
      * @jls 8.1 Class Declarations
      * @jls 9.1 Interface Declarations
diff a/src/java.base/share/classes/java/lang/StringConcatHelper.java b/src/java.base/share/classes/java/lang/StringConcatHelper.java
--- a/src/java.base/share/classes/java/lang/StringConcatHelper.java
+++ b/src/java.base/share/classes/java/lang/StringConcatHelper.java
@@ -404,10 +404,18 @@
      */
     @ForceInline
     static String simpleConcat(Object first, Object second) {
         String s1 = stringOf(first);
         String s2 = stringOf(second);
+        if (s1.isEmpty()) {
+            // newly created string required, see JLS 15.18.1
+            return new String(s2);
+        }
+        if (s2.isEmpty()) {
+            // newly created string required, see JLS 15.18.1
+            return new String(s1);
+        }
         // start "mixing" in length and coder or arguments, order is not
         // important
         long indexCoder = mix(initialCoder(), s1);
         indexCoder = mix(indexCoder, s2);
         byte[] buf = newArray(indexCoder);
diff a/src/java.base/share/classes/java/security/KeyStore.java b/src/java.base/share/classes/java/security/KeyStore.java
--- a/src/java.base/share/classes/java/security/KeyStore.java
+++ b/src/java.base/share/classes/java/security/KeyStore.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -1760,39 +1760,37 @@
                     new FileInputStream(file)))) {
 
             dataStream.mark(Integer.MAX_VALUE);
 
             // Detect the keystore type
-            for (String type : Security.getAlgorithms("KeyStore")) {
-                Object[] objs = null;
-
-                try {
-                    objs = Security.getImpl(type, "KeyStore", (String)null);
-
-                    KeyStoreSpi impl = (KeyStoreSpi)objs[0];
-                    if (impl.engineProbe(dataStream)) {
-
-                        if (kdebug != null) {
-                            kdebug.println(type + " keystore detected: " +
-                                file);
+            for (Provider p : Security.getProviders()) {
+                for (Provider.Service s : p.getServices()) {
+                    if (s.getType().equals("KeyStore")) {
+                        try {
+                            KeyStoreSpi impl = (KeyStoreSpi) s.newInstance(null);
+                            if (impl.engineProbe(dataStream)) {
+                                if (kdebug != null) {
+                                    kdebug.println(s.getAlgorithm()
+                                            + " keystore detected: " + file);
+                                }
+                                keystore = new KeyStore(impl, p, s.getAlgorithm());
+                                break;
+                            }
+                        } catch (NoSuchAlgorithmException e) {
+                            // ignore
+                            if (kdebug != null) {
+                                kdebug.println("not found - " + e);
+                            }
+                        } catch (IOException e) {
+                            // ignore
+                            if (kdebug != null) {
+                                kdebug.println("I/O error in " + file + " - " + e);
+                            }
                         }
-
-                        keystore = new KeyStore(impl, (Provider)objs[1], type);
-                        break;
-                    }
-                } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
-                    // ignore
-                    if (kdebug != null) {
-                        kdebug.println(type + " not found - " + e);
-                    }
-                } catch (IOException e) {
-                    // ignore
-                    if (kdebug != null) {
-                        kdebug.println("I/O error in " + file + " - " + e);
+                        dataStream.reset(); // prepare the stream for the next probe
                     }
                 }
-                dataStream.reset(); // prepare the stream for the next probe
             }
 
             // Load the keystore data
             if (keystore != null) {
                 dataStream.reset(); // prepare the stream for loading
diff a/src/java.base/share/classes/java/security/MessageDigest.java b/src/java.base/share/classes/java/security/MessageDigest.java
--- a/src/java.base/share/classes/java/security/MessageDigest.java
+++ b/src/java.base/share/classes/java/security/MessageDigest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -129,10 +129,16 @@
      */
     protected MessageDigest(String algorithm) {
         this.algorithm = algorithm;
     }
 
+    // private constructor used only by Delegate class
+    private MessageDigest(String algorithm, Provider p) {
+        this.algorithm = algorithm;
+        this.provider = p;
+    }
+
     /**
      * Returns a MessageDigest object that implements the specified digest
      * algorithm.
      *
      * <p> This method traverses the list of registered security Providers,
@@ -176,14 +182,15 @@
             MessageDigest md;
             Object[] objs = Security.getImpl(algorithm, "MessageDigest",
                                              (String)null);
             if (objs[0] instanceof MessageDigest) {
                 md = (MessageDigest)objs[0];
+                md.provider = (Provider)objs[1];
             } else {
-                md = new Delegate((MessageDigestSpi)objs[0], algorithm);
+                md = Delegate.of((MessageDigestSpi)objs[0], algorithm,
+                    (Provider) objs[1]);
             }
-            md.provider = (Provider)objs[1];
 
             if (!skipDebug && pdebug != null) {
                 pdebug.println("MessageDigest." + algorithm +
                     " algorithm from: " + md.provider.getName());
             }
@@ -243,12 +250,12 @@
             MessageDigest md = (MessageDigest)objs[0];
             md.provider = (Provider)objs[1];
             return md;
         } else {
             MessageDigest delegate =
-                new Delegate((MessageDigestSpi)objs[0], algorithm);
-            delegate.provider = (Provider)objs[1];
+                    Delegate.of((MessageDigestSpi)objs[0], algorithm,
+                    (Provider)objs[1]);
             return delegate;
         }
     }
 
     /**
@@ -296,12 +303,12 @@
             MessageDigest md = (MessageDigest)objs[0];
             md.provider = (Provider)objs[1];
             return md;
         } else {
             MessageDigest delegate =
-                new Delegate((MessageDigestSpi)objs[0], algorithm);
-            delegate.provider = (Provider)objs[1];
+                    Delegate.of((MessageDigestSpi)objs[0], algorithm,
+                    (Provider)objs[1]);
             return delegate;
         }
     }
 
     /**
@@ -545,12 +552,10 @@
             throw new CloneNotSupportedException();
         }
     }
 
 
-
-
     /*
      * The following class allows providers to extend from MessageDigestSpi
      * rather than from MessageDigest. It represents a MessageDigest with an
      * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).
      * If the provider implementation is an instance of MessageDigestSpi,
@@ -561,18 +566,49 @@
      * moved up the hierarchy into a new class (MessageDigestSpi), which has
      * been interposed in the hierarchy between the API (MessageDigest)
      * and its original parent (Object).
      */
 
-    static class Delegate extends MessageDigest implements MessageDigestSpi2 {
+    private static class Delegate extends MessageDigest
+            implements MessageDigestSpi2 {
+        // use this class for spi objects which implements Cloneable
+        private static final class CloneableDelegate extends Delegate
+                implements Cloneable {
+
+            private CloneableDelegate(MessageDigestSpi digestSpi,
+                    String algorithm, Provider p) {
+                super(digestSpi, algorithm, p);
+            }
+        }
 
         // The provider implementation (delegate)
-        private MessageDigestSpi digestSpi;
+        private final MessageDigestSpi digestSpi;
+
+        // factory method used by MessageDigest class to create Delegate objs
+        static Delegate of(MessageDigestSpi digestSpi, String algo,
+                Provider p) {
+            Objects.requireNonNull(digestSpi);
+            boolean isCloneable = (digestSpi instanceof Cloneable);
+            // Spi impls from SunPKCS11 provider implement Cloneable but their
+            // clone() may throw CloneNotSupportException
+            if (isCloneable && p.getName().startsWith("SunPKCS11") &&
+                    p.getClass().getModule().getName().equals
+                    ("jdk.crypto.cryptoki")) {
+                try {
+                    digestSpi.clone();
+                } catch (CloneNotSupportedException cnse) {
+                    isCloneable = false;
+                }
+            }
+            return (isCloneable? new CloneableDelegate(digestSpi, algo, p) :
+                    new Delegate(digestSpi, algo, p));
+        }
 
-        // constructor
-        public Delegate(MessageDigestSpi digestSpi, String algorithm) {
-            super(algorithm);
+        // private constructor
+        private Delegate(MessageDigestSpi digestSpi, String algorithm,
+                Provider p) {
+            super(algorithm, p);
             this.digestSpi = digestSpi;
         }
 
         /**
          * Returns a clone if the delegate is cloneable.
@@ -580,61 +616,69 @@
          * @return a clone if the delegate is cloneable.
          *
          * @throws    CloneNotSupportedException if this is called on a
          * delegate that does not support {@code Cloneable}.
          */
+        @Override
         public Object clone() throws CloneNotSupportedException {
-            if (digestSpi instanceof Cloneable) {
-                MessageDigestSpi digestSpiClone =
-                    (MessageDigestSpi)digestSpi.clone();
+            if (this instanceof Cloneable) {
                 // Because 'algorithm', 'provider', and 'state' are private
                 // members of our supertype, we must perform a cast to
                 // access them.
-                MessageDigest that =
-                    new Delegate(digestSpiClone,
-                                 ((MessageDigest)this).algorithm);
-                that.provider = ((MessageDigest)this).provider;
+                MessageDigest that = new CloneableDelegate(
+                        (MessageDigestSpi)digestSpi.clone(),
+                        ((MessageDigest)this).algorithm,
+                        ((MessageDigest)this).provider);
                 that.state = ((MessageDigest)this).state;
                 return that;
             } else {
                 throw new CloneNotSupportedException();
             }
         }
 
+        @Override
         protected int engineGetDigestLength() {
             return digestSpi.engineGetDigestLength();
         }
 
+        @Override
         protected void engineUpdate(byte input) {
             digestSpi.engineUpdate(input);
         }
 
+        @Override
         protected void engineUpdate(byte[] input, int offset, int len) {
             digestSpi.engineUpdate(input, offset, len);
         }
 
+        @Override
         protected void engineUpdate(ByteBuffer input) {
             digestSpi.engineUpdate(input);
         }
 
+        @Override
         public void engineUpdate(SecretKey key) throws InvalidKeyException {
             if (digestSpi instanceof MessageDigestSpi2) {
                 ((MessageDigestSpi2)digestSpi).engineUpdate(key);
             } else {
                 throw new UnsupportedOperationException
                 ("Digest does not support update of SecretKey object");
             }
         }
+
+        @Override
         protected byte[] engineDigest() {
             return digestSpi.engineDigest();
         }
 
+        @Override
         protected int engineDigest(byte[] buf, int offset, int len)
             throws DigestException {
                 return digestSpi.engineDigest(buf, offset, len);
         }
 
+        @Override
         protected void engineReset() {
             digestSpi.engineReset();
         }
     }
 }
diff a/src/java.base/share/classes/java/security/Provider.java b/src/java.base/share/classes/java/security/Provider.java
--- a/src/java.base/share/classes/java/security/Provider.java
+++ b/src/java.base/share/classes/java/security/Provider.java
@@ -856,14 +856,22 @@
     // legacy properties changed since last call to any services method?
     private transient boolean legacyChanged;
     // serviceMap changed since last call to getServices()
     private volatile transient boolean servicesChanged;
 
+    // Map<String,String> used to keep track of legacy registration
+    private transient Map<String,String> legacyStrings;
+
     // Map<ServiceKey,Service>
     // used for services added via putService(), initialized on demand
     private transient Map<ServiceKey,Service> serviceMap;
 
+    // For backward compatibility, the registration ordering of
+    // SecureRandom (RNG) algorithms needs to be preserved for
+    // "new SecureRandom()" calls when this provider is used
+    private transient Set<Service> prngServices;
+
     // Map<ServiceKey,Service>
     // used for services added via legacy methods, init on demand
     private transient Map<ServiceKey,Service> legacyMap;
 
     // Set<Service>
@@ -911,16 +919,22 @@
         implClear();
         initialized = true;
         putAll(copy);
     }
 
-    private static boolean isProviderInfo(Object key) {
+    // check whether to update 'legacyString' with the specified key
+    private boolean checkLegacy(Object key) {
         String keyString = (String)key;
         if (keyString.startsWith("Provider.")) {
-            return true;
+            return false;
+        }
+
+        legacyChanged = true;
+        if (legacyStrings == null) {
+            legacyStrings = new LinkedHashMap<>();
         }
-        return false;
+        return true;
     }
 
     /**
      * Copies all of the mappings from the specified Map to this provider.
      * Internal method to be called AFTER the security check has been
@@ -932,132 +946,152 @@
         }
     }
 
     private Object implRemove(Object key) {
         if (key instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.remove((String)key);
         }
         return super.remove(key);
     }
 
     private boolean implRemove(Object key, Object value) {
         if (key instanceof String && value instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return false;
             }
-            legacyChanged = true;
+            legacyStrings.remove((String)key, (String)value);
         }
         return super.remove(key, value);
     }
 
     private boolean implReplace(Object key, Object oldValue, Object newValue) {
         if ((key instanceof String) && (oldValue instanceof String) &&
                 (newValue instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return false;
             }
-            legacyChanged = true;
+            legacyStrings.replace((String)key, (String)oldValue,
+                    (String)newValue);
         }
         return super.replace(key, oldValue, newValue);
     }
 
     private Object implReplace(Object key, Object value) {
         if ((key instanceof String) && (value instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.replace((String)key, (String)value);
         }
         return super.replace(key, value);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
     private void implReplaceAll(BiFunction<? super Object, ? super Object,
             ? extends Object> function) {
         legacyChanged = true;
+        if (legacyStrings == null) {
+            legacyStrings = new LinkedHashMap<>();
+        } else {
+            legacyStrings.replaceAll((BiFunction<? super String, ? super String,
+                    ? extends String>) function);
+        }
         super.replaceAll(function);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
-    private Object implMerge(Object key, Object value, BiFunction<? super Object,
-            ? super Object, ? extends Object> remappingFunction) {
+    private Object implMerge(Object key, Object value,
+            BiFunction<? super Object, ? super Object, ? extends Object>
+            remappingFunction) {
         if ((key instanceof String) && (value instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.merge((String)key, (String)value,
+                    (BiFunction<? super String, ? super String,
+                    ? extends String>) remappingFunction);
         }
         return super.merge(key, value, remappingFunction);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
     private Object implCompute(Object key, BiFunction<? super Object,
             ? super Object, ? extends Object> remappingFunction) {
         if (key instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.compute((String) key,
+                    (BiFunction<? super String,? super String,
+                    ? extends String>) remappingFunction);
         }
         return super.compute(key, remappingFunction);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
     private Object implComputeIfAbsent(Object key, Function<? super Object,
             ? extends Object> mappingFunction) {
         if (key instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.computeIfAbsent((String) key,
+                    (Function<? super String, ? extends String>)
+                    mappingFunction);
         }
         return super.computeIfAbsent(key, mappingFunction);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
     private Object implComputeIfPresent(Object key, BiFunction<? super Object,
             ? super Object, ? extends Object> remappingFunction) {
         if (key instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.computeIfPresent((String) key,
+                    (BiFunction<? super String, ? super String,
+                    ? extends String>) remappingFunction);
         }
         return super.computeIfPresent(key, remappingFunction);
     }
 
     private Object implPut(Object key, Object value) {
         if ((key instanceof String) && (value instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.put((String)key, (String)value);
         }
         return super.put(key, value);
     }
 
     private Object implPutIfAbsent(Object key, Object value) {
         if ((key instanceof String) && (value instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.putIfAbsent((String)key, (String)value);
         }
         return super.putIfAbsent(key, value);
     }
 
     private void implClear() {
+        if (legacyStrings != null) {
+            legacyStrings.clear();
+        }
         if (legacyMap != null) {
             legacyMap.clear();
         }
         serviceMap.clear();
         legacyChanged = false;
         servicesChanged = false;
         serviceSet = null;
+        prngServices = null;
         super.clear();
         putId();
     }
 
     // used as key in the serviceMap and legacyMap HashMaps
@@ -1093,20 +1127,20 @@
     /**
      * Ensure all the legacy String properties are fully parsed into
      * service objects.
      */
     private void ensureLegacyParsed() {
-        if (legacyChanged == false) {
+        if (legacyChanged == false || (legacyStrings == null)) {
             return;
         }
         serviceSet = null;
         if (legacyMap == null) {
             legacyMap = new ConcurrentHashMap<>();
         } else {
             legacyMap.clear();
         }
-        for (Map.Entry<?,?> entry : super.entrySet()) {
+        for (Map.Entry<String,String> entry : legacyStrings.entrySet()) {
             parseLegacyPut(entry.getKey(), entry.getValue());
         }
         removeInvalidServices(legacyMap);
         legacyChanged = false;
     }
@@ -1123,16 +1157,16 @@
                 t.remove();
             }
         }
     }
 
-    private String[] getTypeAndAlgorithm(String key) {
+    private static String[] getTypeAndAlgorithm(String key) {
         int i = key.indexOf('.');
         if (i < 1) {
             if (debug != null) {
-                debug.println("Ignoring invalid entry in provider "
-                        + name + ":" + key);
+                debug.println("Ignoring invalid entry in provider: "
+                        + key);
             }
             return null;
         }
         String type = key.substring(0, i);
         String alg = key.substring(i + 1);
@@ -1141,19 +1175,11 @@
 
     private static final String ALIAS_PREFIX = "Alg.Alias.";
     private static final String ALIAS_PREFIX_LOWER = "alg.alias.";
     private static final int ALIAS_LENGTH = ALIAS_PREFIX.length();
 
-    private void parseLegacyPut(Object k, Object v) {
-        if (!(k instanceof String) || !(v instanceof String)) {
-            return;
-        }
-        String name = (String) k;
-        String value = (String) v;
-        if (isProviderInfo(name)) {
-            return;
-        }
+    private void parseLegacyPut(String name, String value) {
         if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {
             // e.g. put("Alg.Alias.MessageDigest.SHA", "SHA-1");
             // aliasKey ~ MessageDigest.SHA
             String stdAlg = value;
             String aliasKey = name.substring(ALIAS_LENGTH);
@@ -1191,10 +1217,14 @@
                     s.type = type;
                     s.algorithm = stdAlg;
                     legacyMap.put(key, s);
                 }
                 s.className = className;
+
+                if (type.equals("SecureRandom")) {
+                    updateSecureRandomEntries(true, s);
+                }
             } else { // attribute
                 // e.g. put("MessageDigest.SHA-1 ImplementedIn", "Software");
                 String attributeValue = value;
                 String type = getEngineName(typeAndAlg[0]);
                 String attributeString = typeAndAlg[1];
@@ -1350,11 +1380,48 @@
             serviceMap.put(new ServiceKey(type, alias, true), s);
         }
         servicesChanged = true;
         synchronized (this) {
             putPropertyStrings(s);
+            if (type.equals("SecureRandom")) {
+                updateSecureRandomEntries(true, s);
+            }
+        }
+    }
+
+    private void updateSecureRandomEntries(boolean doAdd, Service s) {
+        Objects.requireNonNull(s);
+        if (doAdd) {
+            if (prngServices == null) {
+                prngServices = new LinkedHashSet<Service>();
+            }
+            prngServices.add(s);
+        } else {
+            prngServices.remove(s);
+        }
+
+        if (debug != null) {
+            debug.println((doAdd? "Add":"Remove") + " SecureRandom algo " +
+                s.getAlgorithm());
+        }
+    }
+
+    // used by new SecureRandom() to find out the default SecureRandom
+    // service for this provider
+    synchronized Service getDefaultSecureRandomService() {
+        checkInitialized();
+
+        if (legacyChanged) {
+            prngServices = null;
+            ensureLegacyParsed();
         }
+
+        if (prngServices != null && !prngServices.isEmpty()) {
+            return prngServices.iterator().next();
+        }
+
+        return null;
     }
 
     /**
      * Put the string properties for this Service in this Provider's
      * Hashtable.
@@ -1446,10 +1513,13 @@
         for (String alias : s.getAliases()) {
             serviceMap.remove(new ServiceKey(type, alias, false));
         }
         synchronized (this) {
             removePropertyStrings(s);
+            if (type.equals("SecureRandom")) {
+                updateSecureRandomEntries(false, s);
+            }
         }
     }
 
     // Wrapped String that behaves in a case insensitive way for equals/hashCode
     private static class UString {
diff a/src/java.base/share/classes/java/security/SecureRandom.java b/src/java.base/share/classes/java/security/SecureRandom.java
--- a/src/java.base/share/classes/java/security/SecureRandom.java
+++ b/src/java.base/share/classes/java/security/SecureRandom.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -257,39 +257,55 @@
         getDefaultPRNG(true, seed);
         this.threadSafe = getThreadSafe();
     }
 
     private void getDefaultPRNG(boolean setSeed, byte[] seed) {
-        String prng = getPrngAlgorithm();
-        if (prng == null) {
-            // bummer, get the SUN implementation
-            prng = "SHA1PRNG";
+        Service prngService = null;
+        String prngAlgorithm = null;
+        for (Provider p : Providers.getProviderList().providers()) {
+            // SUN provider uses the SunEntries.DEF_SECURE_RANDOM_ALGO
+            // as the default SecureRandom algorithm; for other providers,
+            // Provider.getDefaultSecureRandom() will use the 1st
+            // registered SecureRandom algorithm
+            if (p.getName().equals("SUN")) {
+                prngAlgorithm = SunEntries.DEF_SECURE_RANDOM_ALGO;
+                prngService = p.getService("SecureRandom", prngAlgorithm);
+                break;
+            } else {
+                prngService = p.getDefaultSecureRandomService();
+                if (prngService != null) {
+                    prngAlgorithm = prngService.getAlgorithm();
+                    break;
+                }
+            }
+        }
+        // per javadoc, if none of the Providers support a RNG algorithm,
+        // then an implementation-specific default is returned.
+        if (prngService == null) {
+            prngAlgorithm = "SHA1PRNG";
             this.secureRandomSpi = new sun.security.provider.SecureRandom();
             this.provider = Providers.getSunProvider();
-            if (setSeed) {
-                this.secureRandomSpi.engineSetSeed(seed);
-            }
         } else {
             try {
-                SecureRandom random = SecureRandom.getInstance(prng);
-                this.secureRandomSpi = random.getSecureRandomSpi();
-                this.provider = random.getProvider();
-                if (setSeed) {
-                    this.secureRandomSpi.engineSetSeed(seed);
-                }
+                this.secureRandomSpi = (SecureRandomSpi)
+                    prngService.newInstance(null);
+                this.provider = prngService.getProvider();
             } catch (NoSuchAlgorithmException nsae) {
-                // never happens, because we made sure the algorithm exists
+                // should not happen
                 throw new RuntimeException(nsae);
             }
         }
+        if (setSeed) {
+            this.secureRandomSpi.engineSetSeed(seed);
+        }
         // JDK 1.1 based implementations subclass SecureRandom instead of
         // SecureRandomSpi. They will also go through this code path because
         // they must call a SecureRandom constructor as it is their superclass.
         // If we are dealing with such an implementation, do not set the
         // algorithm value as it would be inaccurate.
         if (getClass() == SecureRandom.class) {
-            this.algorithm = prng;
+            this.algorithm = prngAlgorithm;
         }
     }
 
     /**
      * Creates a {@code SecureRandom} object.
@@ -618,17 +634,10 @@
                 SecureRandomSpi.class, algorithm, params, provider);
         return new SecureRandom((SecureRandomSpi)instance.impl,
                 instance.provider, algorithm);
     }
 
-    /**
-     * Returns the {@code SecureRandomSpi} of this {@code SecureRandom} object.
-     */
-    SecureRandomSpi getSecureRandomSpi() {
-        return secureRandomSpi;
-    }
-
     /**
      * Returns the provider of this {@code SecureRandom} object.
      *
      * @return the provider of this {@code SecureRandom} object.
      */
@@ -866,34 +875,10 @@
         }
 
         return retVal;
     }
 
-    /**
-     * Gets a default PRNG algorithm by looking through all registered
-     * providers. Returns the first PRNG algorithm of the first provider that
-     * has registered a {@code SecureRandom} implementation, or null if none of
-     * the registered providers supplies a {@code SecureRandom} implementation.
-     */
-    private static String getPrngAlgorithm() {
-        for (Provider p : Providers.getProviderList().providers()) {
-            // For SUN provider, we use SunEntries.DEFF_SECURE_RANDOM_ALGO
-            // as the default SecureRandom algorithm; for other providers,
-            // we continue to iterate through to the 1st SecureRandom
-            // service
-            if (p.getName().equals("SUN")) {
-                return SunEntries.DEF_SECURE_RANDOM_ALGO;
-            }
-            for (Service s : p.getServices()) {
-                if (s.getType().equals("SecureRandom")) {
-                    return s.getAlgorithm();
-                }
-            }
-        }
-        return null;
-    }
-
     /*
      * Lazily initialize since Pattern.compile() is heavy.
      * Effective Java (2nd Edition), Item 71.
      */
     private static final class StrongPatternHolder {
diff a/src/java.base/share/classes/java/security/Signature.java b/src/java.base/share/classes/java/security/Signature.java
--- a/src/java.base/share/classes/java/security/Signature.java
+++ b/src/java.base/share/classes/java/security/Signature.java
@@ -270,11 +270,11 @@
         }
         // try services until we find an Spi or a working Signature subclass
         NoSuchAlgorithmException failure;
         do {
             Service s = t.next();
-            if (isSpi(s)) {
+            if (isSpi(s)) { // delayed provider selection
                 return new Delegate(s, t, algorithm);
             } else {
                 // must be a subclass of Signature, disable dynamic selection
                 try {
                     Instance instance =
@@ -293,11 +293,11 @@
         if (instance.impl instanceof Signature) {
             sig = (Signature)instance.impl;
             sig.algorithm = algorithm;
         } else {
             SignatureSpi spi = (SignatureSpi)instance.impl;
-            sig = new Delegate(spi, algorithm);
+            sig = Delegate.of(spi, algorithm);
         }
         sig.provider = instance.provider;
         return sig;
     }
 
@@ -462,11 +462,11 @@
             return getInstance(instance, RSA_SIGNATURE);
         }
         // check Cipher
         try {
             Cipher c = Cipher.getInstance(RSA_CIPHER, p);
-            return new Delegate(new CipherAdapter(c), RSA_SIGNATURE);
+            return Delegate.of(new CipherAdapter(c), RSA_SIGNATURE);
         } catch (GeneralSecurityException e) {
             // throw Signature style exception message to avoid confusion,
             // but append Cipher exception as cause
             throw new NoSuchAlgorithmException("no such algorithm: "
                 + RSA_SIGNATURE + " for provider " + p.getName(), e);
@@ -1090,10 +1090,18 @@
      * and its original parent (Object).
      */
 
     @SuppressWarnings("deprecation")
     private static class Delegate extends Signature {
+        // use this class for spi objects which implements Cloneable
+        private static final class CloneableDelegate extends Delegate
+                implements Cloneable {
+            private CloneableDelegate(SignatureSpi digestSpi,
+                    String algorithm) {
+                super(digestSpi, algorithm);
+            }
+        }
 
         // The provider implementation (delegate)
         // filled in once the provider is selected
         private SignatureSpi sigSpi;
 
@@ -1106,19 +1114,28 @@
 
         // remaining services to try in provider selection
         // null once provider is selected
         private Iterator<Service> serviceIterator;
 
-        // constructor
-        Delegate(SignatureSpi sigSpi, String algorithm) {
+        // factory method used by Signature class to create Delegate objs
+        static Delegate of(SignatureSpi sigSpi, String algorithm) {
+            if (sigSpi instanceof Cloneable) {
+                return new CloneableDelegate(sigSpi, algorithm);
+            } else {
+                return new Delegate(sigSpi, algorithm);
+            }
+        }
+
+        // private constructor
+        private Delegate(SignatureSpi sigSpi, String algorithm) {
             super(algorithm);
             this.sigSpi = sigSpi;
             this.lock = null; // no lock needed
         }
 
-        // used with delayed provider selection
-        Delegate(Service service,
+        // constructor used with delayed provider selection
+        private Delegate(Service service,
                         Iterator<Service> iterator, String algorithm) {
             super(algorithm);
             this.firstService = service;
             this.serviceIterator = iterator;
             this.lock = new Object();
@@ -1130,19 +1147,20 @@
          * @return a clone if the delegate is cloneable.
          *
          * @throws    CloneNotSupportedException if this is called on a
          * delegate that does not support {@code Cloneable}.
          */
+        @Override
         public Object clone() throws CloneNotSupportedException {
             chooseFirstProvider();
             if (sigSpi instanceof Cloneable) {
-                SignatureSpi sigSpiClone = (SignatureSpi)sigSpi.clone();
                 // Because 'algorithm' and 'provider' are private
                 // members of our supertype, we must perform a cast to
                 // access them.
-                Signature that =
-                    new Delegate(sigSpiClone, ((Signature)this).algorithm);
+                Signature that = new CloneableDelegate(
+                   (SignatureSpi)sigSpi.clone(),
+                   ((Signature)this).algorithm);
                 that.provider = ((Signature)this).provider;
                 return that;
             } else {
                 throw new CloneNotSupportedException();
             }
diff a/src/java.base/share/classes/java/time/Year.java b/src/java.base/share/classes/java/time/Year.java
--- a/src/java.base/share/classes/java/time/Year.java
+++ b/src/java.base/share/classes/java/time/Year.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -151,11 +151,12 @@
     private static final long serialVersionUID = -23038383694477807L;
     /**
      * Parser.
      */
     private static final DateTimeFormatter PARSER = new DateTimeFormatterBuilder()
-        .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)
+        .parseLenient()
+        .appendValue(YEAR, 1, 10, SignStyle.NORMAL)
         .toFormatter();
 
     /**
      * The year being represented.
      */
@@ -266,11 +267,10 @@
     //-----------------------------------------------------------------------
     /**
      * Obtains an instance of {@code Year} from a text string such as {@code 2007}.
      * <p>
      * The string must represent a valid year.
-     * Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.
      *
      * @param text  the text to parse such as "2007", not null
      * @return the parsed year, not null
      * @throws DateTimeParseException if the text cannot be parsed
      */
diff a/src/java.base/share/classes/sun/security/provider/DigestBase.java b/src/java.base/share/classes/sun/security/provider/DigestBase.java
--- a/src/java.base/share/classes/sun/security/provider/DigestBase.java
+++ b/src/java.base/share/classes/sun/security/provider/DigestBase.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -231,10 +231,11 @@
     abstract void implReset();
 
     public Object clone() throws CloneNotSupportedException {
         DigestBase copy = (DigestBase) super.clone();
         copy.buffer = copy.buffer.clone();
+        copy.oneByte = null;
         return copy;
     }
 
     // padding used for the MD5, and SHA-* message digests
     static final byte[] padding;
diff a/src/java.base/share/classes/sun/security/provider/JavaKeyStore.java b/src/java.base/share/classes/sun/security/provider/JavaKeyStore.java
--- a/src/java.base/share/classes/sun/security/provider/JavaKeyStore.java
+++ b/src/java.base/share/classes/sun/security/provider/JavaKeyStore.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -73,10 +73,26 @@
     // special JKS that supports JKS and PKCS12 file formats
     public static final class DualFormatJKS extends KeyStoreDelegator {
         public DualFormatJKS() {
             super("JKS", JKS.class, "PKCS12", PKCS12KeyStore.class);
         }
+
+        /**
+         * Probe the first few bytes of the keystore data stream for a valid
+         * JKS keystore encoding.
+         */
+        @Override
+        public boolean engineProbe(InputStream stream) throws IOException {
+            DataInputStream dataStream;
+            if (stream instanceof DataInputStream) {
+                dataStream = (DataInputStream)stream;
+            } else {
+                dataStream = new DataInputStream(stream);
+            }
+
+            return MAGIC == dataStream.readInt();
+        }
     }
 
     private static final Debug debug = Debug.getInstance("keystore");
     private static final int MAGIC = 0xfeedfeed;
     private static final int VERSION_1 = 0x01;
@@ -826,22 +842,6 @@
             passwdBytes[j++] = (byte)(password[i] >> 8);
             passwdBytes[j++] = (byte)password[i];
         }
         return passwdBytes;
     }
-
-    /**
-     * Probe the first few bytes of the keystore data stream for a valid
-     * JKS keystore encoding.
-     */
-    @Override
-    public boolean engineProbe(InputStream stream) throws IOException {
-        DataInputStream dataStream;
-        if (stream instanceof DataInputStream) {
-            dataStream = (DataInputStream)stream;
-        } else {
-            dataStream = new DataInputStream(stream);
-        }
-
-        return MAGIC == dataStream.readInt();
-    }
 }
diff a/src/java.desktop/windows/native/libawt/java2d/windows/GDIBlitLoops.cpp b/src/java.desktop/windows/native/libawt/java2d/windows/GDIBlitLoops.cpp
--- a/src/java.desktop/windows/native/libawt/java2d/windows/GDIBlitLoops.cpp
+++ b/src/java.desktop/windows/native/libawt/java2d/windows/GDIBlitLoops.cpp
@@ -39,10 +39,72 @@
         DWORD           dwMasks[3];
         RGBQUAD         palette[256];
     } colors;
 } BmiType;
 
+/*
+ * Some GDI functions functions will fail if they operate on memory which spans
+ * virtual allocations as used by modern garbage collectors (ie ZGC).
+ * So if the call to SetDIBitsToDevice fails, we will re-try it on malloced
+ * memory rather than the pinned Java heap memory.
+ * Once Microsoft fix the GDI bug, the small performance penalty of this retry
+ * will be gone.
+ */
+static void retryingSetDIBitsToDevice(
+    HDC              hdc,
+    int              xDest,
+    int              yDest,
+    DWORD            w,
+    DWORD            h,
+    int              xSrc,
+    int              ySrc,
+    UINT             StartScan,
+    UINT             cLines,
+    const VOID       *lpvBits,
+    BITMAPINFO       *lpbmi,
+    UINT             ColorUse) {
+
+#ifdef DEBUG_PERF
+    LARGE_INTEGER    ts1, ts2;
+    QueryPerformanceCounter(&ts1);
+#endif
+
+    int ret =
+        SetDIBitsToDevice(hdc, xDest, yDest, w, h,
+                          xSrc, ySrc, StartScan, cLines, lpvBits,
+                          lpbmi, ColorUse);
+
+    if (ret != 0 || h == 0) {
+#ifdef DEBUG_PERF
+         QueryPerformanceCounter(&ts2);
+         printf("success time: %zd\n", (ts2.QuadPart-ts1.QuadPart));
+#endif
+        return;
+    }
+
+    size_t size = lpbmi->bmiHeader.biSizeImage;
+    void* imageData = NULL;
+    try {
+        imageData = safe_Malloc(size);
+    } catch (std::bad_alloc&) {
+    }
+    if (imageData == NULL) {
+        return;
+    }
+    memcpy(imageData, lpvBits, size); // this is the most expensive part.
+    SetDIBitsToDevice(hdc, xDest, yDest, w, h,
+                      xSrc, ySrc, StartScan, cLines, imageData,
+                      lpbmi, ColorUse);
+    free(imageData);
+
+#ifdef DEBUG_PERF
+    QueryPerformanceCounter(&ts2);
+    printf("with retry time: %zd\n", (ts2.QuadPart-ts1.QuadPart));
+#endif
+
+};
+
 /*
  * Class:     sun_java2d_windows_GDIBlitLoops
  * Method:    nativeBlit
  * Signature: (Lsun/java2d/SurfaceData;Lsun/java2d/SurfaceData;IIIIIIZ)V
  */
@@ -125,11 +187,10 @@
 
         // If scanlines are DWORD-aligned (scanStride is a multiple of 4),
         // then we can do the work much faster.  This is due to a constraint
         // in the way DIBs are structured and parsed by GDI
         jboolean fastBlt = ((srcInfo.scanStride & 0x03) == 0);
-
         bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
         bmi.bmiHeader.biWidth = srcInfo.scanStride/srcInfo.pixelStride;
         // fastBlt copies whole image in one call; else copy line-by-line
         LONG dwHeight = srcInfo.bounds.y2 - srcInfo.bounds.y1;
         bmi.bmiHeader.biHeight = (fastBlt) ? -dwHeight : -1;
@@ -188,19 +249,19 @@
             // from this GDI call, so make sure window still exists
             if (::IsWindowVisible(dstOps->window)) {
                 // Could also call StretchDIBits.  Testing showed slight
                 // performance advantage of SetDIBits instead, so since we
                 // have no need of scaling, might as well use SetDIBits.
-                SetDIBitsToDevice(hDC, dstx, dsty, width, height,
+                retryingSetDIBitsToDevice(hDC, dstx, dsty, width, height,
                     0, 0, 0, height, rasBase,
                     (BITMAPINFO*)&bmi, DIB_RGB_COLORS);
             }
         } else {
             // Source scanlines not DWORD-aligned - copy each scanline individually
             for (int i = 0; i < height; i += 1) {
                 if (::IsWindowVisible(dstOps->window)) {
-                    SetDIBitsToDevice(hDC, dstx, dsty+i, width, 1,
+                    retryingSetDIBitsToDevice(hDC, dstx, dsty+i, width, 1,
                         0, 0, 0, 1, rasBase,
                         (BITMAPINFO*)&bmi, DIB_RGB_COLORS);
                     rasBase = (void*)((char*)rasBase + srcInfo.scanStride);
                 } else {
                     break;
diff a/src/java.desktop/windows/native/libawt/windows/awt_Cursor.cpp b/src/java.desktop/windows/native/libawt/windows/awt_Cursor.cpp
--- a/src/java.desktop/windows/native/libawt/windows/awt_Cursor.cpp
+++ b/src/java.desktop/windows/native/libawt/windows/awt_Cursor.cpp
@@ -371,27 +371,25 @@
     HBITMAP hMask = ::CreateBitmap(nW, nH, 1, 1, (BYTE *)andMaskPtr);
     ::GdiFlush();
 
     int *cols = SAFE_SIZE_NEW_ARRAY2(int, nW, nH);
 
-    jint *intRasterDataPtr = NULL;
+    /* Copy the raster data because GDI may fail on some Java heap
+     * allocated memory.
+     */
+    length = env->GetArrayLength(intRasterData);
+    jint *intRasterDataPtr = new jint[length];
     HBITMAP hColor = NULL;
     try {
-        intRasterDataPtr =
-            (jint *)env->GetPrimitiveArrayCritical(intRasterData, 0);
+        env->GetIntArrayRegion(intRasterData, 0, length, intRasterDataPtr);
         hColor = create_BMP(NULL, (int *)intRasterDataPtr, nSS, nW, nH);
         memcpy(cols, intRasterDataPtr, nW*nH*sizeof(int));
     } catch (...) {
-        if (intRasterDataPtr != NULL) {
-            env->ReleasePrimitiveArrayCritical(intRasterData,
-                                               intRasterDataPtr, 0);
-        }
+        delete[] intRasterDataPtr;
         throw;
     }
-
-    env->ReleasePrimitiveArrayCritical(intRasterData, intRasterDataPtr, 0);
-    intRasterDataPtr = NULL;
+    delete[] intRasterDataPtr;
 
     HCURSOR hCursor = NULL;
 
     if (hMask && hColor) {
         ICONINFO icnInfo;
diff a/src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp b/src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp
--- a/src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp
+++ b/src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp
@@ -1737,15 +1737,22 @@
 //     HGDIOBJ oldBrush =
 //      ::SelectObject(hDC, AwtBrush::Get(RGB(0xff, 0xff, 0xff))->GetHandle());
 //     ::PatBlt(hDC, destX+1, destY+1, destWidth-2, destHeight-2, PATCOPY);
 //     ::SelectObject(hDC, oldBrush);
 
+    /* This code is rarely used now. It used to be invoked by Java plugin browser
+     * printing. Today embedded frames are used only when a toolkit such as SWT
+     * needs to embed
+     */
     TRY;
     jbyte *image = NULL;
     try {
-        image = (jbyte *)env->GetPrimitiveArrayCritical(imageArray, 0);
+        int length = env->GetArrayLength(imageArray);
+        image = new jbyte[length];
         CHECK_NULL(image);
+        env->GetByteArrayRegion(imageArray, 0, length, image);
+
         struct {
             BITMAPINFOHEADER bmiHeader;
             DWORD*                 bmiColors;
         } bitMapHeader;
 
@@ -1775,17 +1782,15 @@
      FILE *file = fopen("c:\\plog.txt", "a");
      fprintf(file,"sh=%d dh=%d sy=%d dy=%d result=%d\n", srcHeight, destHeight, srcY, destY, result);
      fclose(file);
 #endif //DEBUG_PRINTING
     } catch (...) {
-        if (image != NULL) {
-            env->ReleasePrimitiveArrayCritical(imageArray, image, 0);
-        }
+        delete[] image;
         throw;
     }
 
-    env->ReleasePrimitiveArrayCritical(imageArray, image, 0);
+    delete[] image;
 
     CATCH_BAD_ALLOC;
 }
 
 /*
@@ -2801,104 +2806,10 @@
         return alignedImage;
     }
     return NULL;
 }
 
-#if 0
-
-/*
- * Class:     sun_awt_windows_WPrinterJob
- * Method:    drawImageIntRGB
- * Signature: (J[IFFFFFFFFII)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_drawImageIntRGB
-  (JNIEnv *env, jobject self,
-   jlong printDC, jintArray image,
-   jfloat destX, jfloat destY,
-   jfloat destWidth, jfloat destHeight,
-   jfloat srcX, jfloat srcY,
-   jfloat srcWidth, jfloat srcHeight,
-   jint srcBitMapWidth, jint srcBitMapHeight) {
-
-    int result = 0;
-
-    assert(printDC != NULL);
-    assert(image != NULL);
-    assert(srcX >= 0);
-    assert(srcY >= 0);
-    assert(srcWidth > 0);
-    assert(srcHeight > 0);
-    assert(srcBitMapWidth > 0);
-    assert(srcBitMapHeight > 0);
-
-
-    static int alphaMask =  0xff000000;
-    static int redMask =    0x00ff0000;
-    static int greenMask =  0x0000ff00;
-    static int blueMask =   0x000000ff;
-
-    struct {
-        BITMAPV4HEADER header;
-        DWORD          masks[256];
-    } dib;
-
-
-
-    memset(&dib,0,sizeof(dib));
-    dib.header.bV4Size = sizeof(dib.header);
-    dib.header.bV4Width = srcBitMapWidth;
-    dib.header.bV4Height = -srcBitMapHeight;    // Top down DIB
-    dib.header.bV4Planes = 1;
-    dib.header.bV4BitCount = 32;
-    dib.header.bV4V4Compression = BI_BITFIELDS;
-    dib.header.bV4SizeImage = 0;        // It's the default size.
-    dib.header.bV4XPelsPerMeter = 0;
-    dib.header.bV4YPelsPerMeter = 0;
-    dib.header.bV4ClrUsed = 0;
-    dib.header.bV4ClrImportant = 0;
-    dib.header.bV4RedMask = redMask;
-    dib.header.bV4GreenMask = greenMask;
-    dib.header.bV4BlueMask = blueMask;
-    dib.header.bV4AlphaMask = alphaMask;
-    dib.masks[0] = redMask;
-    dib.masks[1] = greenMask;
-    dib.masks[2] = blueMask;
-    dib.masks[3] = alphaMask;
-
-    jint *imageBits = NULL;
-
-    try {
-        imageBits = (jint *)env->GetPrimitiveArrayCritical(image, 0);
-
-        if (printDC){
-            result = ::StretchDIBits( (HDC)printDC,
-                                      ROUND_TO_LONG(destX),
-                                      ROUND_TO_LONG(destY),
-                                      ROUND_TO_LONG(destWidth),
-                                      ROUND_TO_LONG(destHeight),
-                                      ROUND_TO_LONG(srcX),
-                                      ROUND_TO_LONG(srcY),
-                                      ROUND_TO_LONG(srcWidth),
-                                      ROUND_TO_LONG(srcHeight),
-                                      imageBits,
-                                      (BITMAPINFO *)&dib,
-                                      DIB_RGB_COLORS,
-                                      SRCCOPY);
-
-        }
-    } catch (...) {
-        if (imageBits != NULL) {
-            env->ReleasePrimitiveArrayCritical(image, imageBits, 0);
-        }
-        throw;
-    }
-
-    env->ReleasePrimitiveArrayCritical(image, imageBits, 0);
-
-}
-#else
-
 /*
  * Class:     sun_awt_windows_WPrinterJob
  * Method:    drawDIBImage
  * Signature: (J[BFFFFFFFFI[B)V
  */
@@ -2989,11 +2900,10 @@
         return;
     }
     env->ReleasePrimitiveArrayCritical(image, imageBits, 0);
 
 }
-#endif
 
 /*
  * An utility function to print passed image byte array to
  * the printDC.
  * browserPrinting flag controls whether the image array
@@ -3057,11 +2967,11 @@
     env->ReleasePrimitiveArrayCritical(imageArray, image, 0);
 
     CATCH_BAD_ALLOC;
 
 }
-static FILE* outfile = NULL;
+
 static int bitsToDevice(HDC printDC, jbyte *image, long destX, long destY,
                         long width, long height) {
     int result = 0;
 
     assert(printDC != NULL);
@@ -3070,10 +2980,13 @@
     assert(destY >= 0);
     assert(width > 0);
     /* height could be negative to indicate that this is a top-down DIB */
 //      assert(height > 0);
 
+    if (!printDC || height == 0) {
+        return result;
+    }
     struct {
         BITMAPINFOHEADER bmiHeader;
         DWORD*             bmiColors;
     } bitMapHeader;
 
@@ -3097,15 +3010,13 @@
     // Because we don't know if they support or not,
     // always send bottom-up DIBs
     if (bitMapHeader.bmiHeader.biHeight < 0) {
       jbyte *dibImage = reverseDIB(image, width, height, 24);
       if (dibImage != NULL) {
-        bitMapHeader.bmiHeader.biWidth = ROUND_TO_LONG(width);
-        bitMapHeader.bmiHeader.biHeight = ROUND_TO_LONG(height);
-
-        if (printDC){
-          result = ::SetDIBitsToDevice(printDC,
+            bitMapHeader.bmiHeader.biWidth = ROUND_TO_LONG(width);
+            bitMapHeader.bmiHeader.biHeight = ROUND_TO_LONG(height);
+            result = ::SetDIBitsToDevice(printDC,
                                 ROUND_TO_LONG(destX),   // left of dest rect
                                 ROUND_TO_LONG(destY),   // top of dest rect
                                 ROUND_TO_LONG(width),   // width of dest rect
                                 ROUND_TO_LONG(height),  // height of dest rect
                                 0,      // left of source rect
@@ -3113,16 +3024,13 @@
                                 0,      // line number of 1st source scan line
                                 ROUND_TO_LONG(height),  // number of scan lines
                                 dibImage,       // points to the DIB
                                 (BITMAPINFO *)&bitMapHeader,
                                 DIB_RGB_COLORS);
-        }
-
-        free (dibImage);
+            free (dibImage);
       }
     } else {
-      if (printDC){
           result = ::SetDIBitsToDevice(printDC,
                                 destX,  // left of dest rect
                                 destY,  // top of dest rect
                                 width,  // width of dest rect
                                 height, // height of dest rect
@@ -3131,13 +3039,34 @@
                                 0,      // line number of 1st source scan line
                                 height, // number of source scan lines
                                 image,  // points to the DIB
                                 (BITMAPINFO *)&bitMapHeader,
                                 DIB_RGB_COLORS);
-      }
+         if (result == 0) {
+             size_t size = width * height * 3; // Always 24bpp, also DWORD aligned.
+             void *imageData = NULL;
+             try {
+                  imageData = safe_Malloc(size);
+              } catch (std::bad_alloc&) {
+                  return result;
+              }
+              memcpy(imageData, image, size);
+              result = ::SetDIBitsToDevice(printDC,
+                                    destX,  // left of dest rect
+                                    destY,  // top of dest rect
+                                    width,  // width of dest rect
+                                    height, // height of dest rect
+                                    0,      // left of source rect
+                                    0,      // top of source rect
+                                    0,      // line number of 1st source scan line
+                                    height, // number of source scan lines
+                                    imageData,  // points to the DIB
+                                    (BITMAPINFO *)&bitMapHeader,
+                                    DIB_RGB_COLORS);
+              free(imageData);
+         }
     }
-
     return result;
 }
 
 LRESULT CALLBACK PageDialogWndProc(HWND hWnd, UINT message,
                                    WPARAM wParam, LPARAM lParam)
diff a/src/java.desktop/windows/native/libawt/windows/awt_TrayIcon.cpp b/src/java.desktop/windows/native/libawt/windows/awt_TrayIcon.cpp
--- a/src/java.desktop/windows/native/libawt/windows/awt_TrayIcon.cpp
+++ b/src/java.desktop/windows/native/libawt/windows/awt_TrayIcon.cpp
@@ -999,29 +999,25 @@
     HBITMAP hMask = ::CreateBitmap(nW, nH, 1, 1, (BYTE *)andMaskPtr);
 //    ::GdiFlush();
 
     delete[] andMaskPtr;
 
-    jint *intRasterDataPtr = NULL;
+    /* Copy the raster data because GDI may fail on some Java heap
+     * allocated memory.
+     */
+    length = env->GetArrayLength(intRasterData);
+    jint *intRasterDataPtr = new jint[length];
     HBITMAP hColor = NULL;
     try {
-        intRasterDataPtr = (jint *)env->GetPrimitiveArrayCritical(intRasterData, 0);
-        if (intRasterDataPtr == NULL) {
-            ::DeleteObject(hMask);
-            return;
-        }
+        env->GetIntArrayRegion(intRasterData, 0, length, intRasterDataPtr);
         hColor = AwtTrayIcon::CreateBMP(NULL, (int *)intRasterDataPtr, nSS, nW, nH);
     } catch (...) {
-        if (intRasterDataPtr != NULL) {
-            env->ReleasePrimitiveArrayCritical(intRasterData, intRasterDataPtr, 0);
-        }
+        delete[] intRasterDataPtr;
         ::DeleteObject(hMask);
         throw;
     }
-
-    env->ReleasePrimitiveArrayCritical(intRasterData, intRasterDataPtr, 0);
-    intRasterDataPtr = NULL;
+    delete[] intRasterDataPtr;
 
     HICON hIcon = NULL;
 
     if (hMask && hColor) {
         ICONINFO icnInfo;
diff a/src/java.management/share/classes/sun/management/HotspotThreadMBean.java b/src/java.management/share/classes/sun/management/HotspotThreadMBean.java
--- a/src/java.management/share/classes/sun/management/HotspotThreadMBean.java
+++ b/src/java.management/share/classes/sun/management/HotspotThreadMBean.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -48,11 +48,11 @@
      * to the thread CPU time in nanoseconds.
      *
      * @throws java.lang.UnsupportedOperationException if the Java virtual
      * machine does not support CPU time measurement.
      *
-     * @see java.lang.management.ThreadMBean#isThreadCpuTimeSupported
+     * @see java.lang.management.ThreadMXBean#isThreadCpuTimeSupported
      */
     public java.util.Map<String,Long> getInternalThreadCpuTimes();
 
     /**
      * Returns a list of internal counters maintained in the Java
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/Main.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/Main.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/Main.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/Main.java
@@ -36,10 +36,12 @@
 public class Main {
 
     /** Main entry point for the launcher.
      *  Note: This method calls System.exit.
      *  @param args command line arguments
+     *  @throws Exception only if an uncaught internal exception occurs;
+     *      just retained for historical compatibility
      */
     public static void main(String[] args) throws Exception {
         System.exit(compile(args));
     }
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
@@ -1004,15 +1004,17 @@
         protected void runPhase(Env<AttrContext> env) {
             JCClassDecl tree = env.enclClass;
             ClassSymbol sym = tree.sym;
             ClassType ct = (ClassType)sym.type;
 
+            JCTree defaultConstructor = null;
+
             // Add default constructor if needed.
             DefaultConstructorHelper helper = getDefaultConstructorHelper(env);
             if (helper != null) {
-                JCTree constrDef = defaultConstructor(make.at(tree.pos), helper);
-                tree.defs = tree.defs.prepend(constrDef);
+                defaultConstructor = defaultConstructor(make.at(tree.pos), helper);
+                tree.defs = tree.defs.prepend(defaultConstructor);
             }
             if (!sym.isRecord()) {
                 enterThisAndSuper(sym, env);
             }
 
@@ -1020,11 +1022,11 @@
                 for (JCTypeParameter tvar : tree.typarams) {
                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
                 }
             }
 
-            finishClass(tree, env);
+            finishClass(tree, defaultConstructor, env);
 
             if (allowTypeAnnos) {
                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
             }
@@ -1061,24 +1063,22 @@
             return helper;
         }
 
         /** Enter members for a class.
          */
-        void finishClass(JCClassDecl tree, Env<AttrContext> env) {
+        void finishClass(JCClassDecl tree, JCTree defaultConstructor, Env<AttrContext> env) {
             if ((tree.mods.flags & Flags.ENUM) != 0 &&
                 !tree.sym.type.hasTag(ERROR) &&
                 (types.supertype(tree.sym.type).tsym.flags() & Flags.ENUM) == 0) {
                 addEnumMembers(tree, env);
             }
             boolean isRecord = (tree.sym.flags_field & RECORD) != 0;
             List<JCTree> alreadyEntered = null;
             if (isRecord) {
                 alreadyEntered = List.convert(JCTree.class, TreeInfo.recordFields(tree));
                 alreadyEntered = alreadyEntered.prependList(tree.defs.stream()
-                        .filter(t -> TreeInfo.isConstructor(t) &&
-                                ((JCMethodDecl)t).sym != null &&
-                                (((JCMethodDecl)t).sym.flags_field & Flags.GENERATEDCONSTR) == 0).collect(List.collector()));
+                        .filter(t -> TreeInfo.isConstructor(t) && t != defaultConstructor).collect(List.collector()));
             }
             List<JCTree> defsToEnter = isRecord ?
                     tree.defs.diff(alreadyEntered) : tree.defs;
             memberEnter.memberEnter(defsToEnter, env);
             if (isRecord) {
diff a/src/jdk.httpserver/share/classes/sun/net/httpserver/ExchangeImpl.java b/src/jdk.httpserver/share/classes/sun/net/httpserver/ExchangeImpl.java
--- a/src/jdk.httpserver/share/classes/sun/net/httpserver/ExchangeImpl.java
+++ b/src/jdk.httpserver/share/classes/sun/net/httpserver/ExchangeImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,10 +30,13 @@
 import javax.net.ssl.*;
 import java.util.*;
 import java.lang.System.Logger;
 import java.lang.System.Logger.Level;
 import java.text.*;
+import java.time.Instant;
+import java.time.ZoneId;
+import java.time.format.DateTimeFormatter;
 import java.util.stream.Stream;
 import com.sun.net.httpserver.*;
 
 class ExchangeImpl {
 
@@ -53,20 +56,16 @@
     boolean close;
     boolean closed;
     boolean http10 = false;
 
     /* for formatting the Date: header */
-    private static final String pattern = "EEE, dd MMM yyyy HH:mm:ss zzz";
-    private static final TimeZone gmtTZ = TimeZone.getTimeZone("GMT");
-    private static final ThreadLocal<DateFormat> dateFormat =
-         new ThreadLocal<DateFormat>() {
-             @Override protected DateFormat initialValue() {
-                 DateFormat df = new SimpleDateFormat(pattern, Locale.US);
-                 df.setTimeZone(gmtTZ);
-                 return df;
-         }
-     };
+    private static final DateTimeFormatter FORMATTER;
+    static {
+        String pattern = "EEE, dd MMM yyyy HH:mm:ss zzz";
+        FORMATTER = DateTimeFormatter.ofPattern(pattern, Locale.US)
+                                     .withZone(ZoneId.of("GMT"));
+    }
 
     private static final String HEAD = "HEAD";
 
     /* streams which take care of the HTTP protocol framing
      * and are passed up to higher layers
@@ -210,11 +209,11 @@
         OutputStream tmpout = new BufferedOutputStream (ros);
         PlaceholderOutputStream o = getPlaceholderResponseBody();
         tmpout.write (bytes(statusLine, 0), 0, statusLine.length());
         boolean noContentToSend = false; // assume there is content
         boolean noContentLengthHeader = false; // must not send Content-length is set
-        rspHdrs.set ("Date", dateFormat.get().format (new Date()));
+        rspHdrs.set("Date", FORMATTER.format(Instant.now()));
 
         /* check for response type that is not allowed to send a body */
 
         if ((rCode>=100 && rCode <200) /* informational */
             ||(rCode == 204)           /* no content */
diff a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/StandardBundlerParam.java b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/StandardBundlerParam.java
--- a/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/StandardBundlerParam.java
+++ b/src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/StandardBundlerParam.java
@@ -482,10 +482,20 @@
                     MessageFormat.format(I18N.getString(
                     "message.runtime-image-dir-does-not-exist.advice"),
                     PREDEFINED_RUNTIME_IMAGE.getID()));
         }
 
+        if (Platform.isMac()) {
+            // On Mac topImage can be runtime root or runtime home.
+            Path runtimeHome = topImage.toPath().resolve("Contents/Home");
+            if (Files.isDirectory(runtimeHome)) {
+                // topImage references runtime root, adjust it to pick data from
+                // runtime home
+                topImage = runtimeHome.toFile();
+            }
+        }
+
         // copy whole runtime, need to skip jmods and src.zip
         final List<String> excludes = Arrays.asList("jmods", "src.zip");
         IOUtils.copyRecursive(topImage.toPath(),
                 appLayout.runtimeHomeDirectory(), excludes);
 
diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodHandleAccessProvider.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodHandleAccessProvider.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodHandleAccessProvider.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodHandleAccessProvider.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -52,10 +52,11 @@
     static final class Internals {
         final ResolvedJavaType lambdaFormType;
         final ResolvedJavaField methodHandleFormField;
         final ResolvedJavaField lambdaFormVmentryField;
         final HotSpotResolvedJavaField callSiteTargetField;
+        final HotSpotResolvedJavaField constantCallSiteFrozenField;
         final ResolvedJavaField methodField;
         final HotSpotResolvedJavaField vmtargetField;
 
         /**
          * Search for an instance field with the given name in a class.
@@ -92,10 +93,13 @@
                 methodField = findFieldInClass(memberNameType, "method", methodType);
                 vmtargetField = (HotSpotResolvedJavaField) findFieldInClass(methodType, "vmtarget", resolveType(Character.toString(HotSpotJVMCIRuntime.getHostWordKind().getTypeChar())));
 
                 ResolvedJavaType callSiteType = resolveType("Ljava/lang/invoke/CallSite;");
                 callSiteTargetField = (HotSpotResolvedJavaField) findFieldInClass(callSiteType, "target", methodHandleType);
+                ResolvedJavaType constantCallSiteType = resolveType("Ljava/lang/invoke/ConstantCallSite;");
+                ResolvedJavaType booleanType = resolveType("Z");
+                constantCallSiteFrozenField = (HotSpotResolvedJavaField) findFieldInClass(constantCallSiteType, "isFrozen", booleanType);
             } catch (Throwable ex) {
                 throw new JVMCIError(ex);
             }
         }
 
diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotObjectConstantImpl.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotObjectConstantImpl.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotObjectConstantImpl.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotObjectConstantImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -63,22 +63,43 @@
     }
 
     @Override
     public abstract int getIdentityHashCode();
 
+    static class Fields {
+        // Initializing these too early causes a hang, so do it here in a subclass
+        static final HotSpotResolvedJavaField callSiteTargetField         = HotSpotMethodHandleAccessProvider.Internals.instance().callSiteTargetField;
+        static final HotSpotResolvedJavaField constantCallSiteFrozenField = HotSpotMethodHandleAccessProvider.Internals.instance().constantCallSiteFrozenField;
+    }
+
+    private boolean isFullyInitializedConstantCallSite() {
+        if (!runtime().getConstantCallSite().isInstance(this)) {
+            return false;
+        }
+        // read ConstantCallSite.isFrozen as a volatile field
+        boolean isFrozen = readFieldValue(Fields.constantCallSiteFrozenField, true /* volatile */).asBoolean();
+        // isFrozen true implies fully-initialized
+        return isFrozen;
+    }
+
+    private HotSpotObjectConstantImpl readTarget() {
+        // read CallSite.target as a volatile field
+        return (HotSpotObjectConstantImpl) readFieldValue(Fields.callSiteTargetField, true /* volatile */);
+    }
+
     @Override
     public JavaConstant getCallSiteTarget(Assumptions assumptions) {
         if (runtime().getCallSite().isInstance(this)) {
-            HotSpotObjectConstantImpl target = (HotSpotObjectConstantImpl) runtime().getHostJVMCIBackend().getConstantReflection().readFieldValue(
-                            HotSpotMethodHandleAccessProvider.Internals.instance().callSiteTargetField, this);
-            if (!runtime().getConstantCallSite().isInstance(this)) {
+            // For ConstantCallSites, we need to read "isFrozen" before reading "target"
+            // isFullyInitializedConstantCallSite() reads "isFrozen"
+            if (!isFullyInitializedConstantCallSite()) {
                 if (assumptions == null) {
                     return null;
                 }
-                assumptions.record(new Assumptions.CallSiteTargetValue(this, target));
+                assumptions.record(new Assumptions.CallSiteTargetValue(this, readTarget()));
             }
-            return target;
+            return readTarget();
         }
         return null;
     }
 
     @Override
diff a/src/jdk.javadoc/share/classes/jdk/javadoc/doclet/DocletEnvironment.java b/src/jdk.javadoc/share/classes/jdk/javadoc/doclet/DocletEnvironment.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/doclet/DocletEnvironment.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/doclet/DocletEnvironment.java
@@ -136,10 +136,13 @@
      * @param type the type element
      * @return the file kind
      */
     Kind getFileKind(TypeElement type);
 
+    /**
+     * The mode specifying the level of detail of module documentation.
+     */
     enum ModuleMode {
         /** Indicate API level documentation is required */
         API,
         /** Indicate Detailed documentation is required */
         ALL
diff a/src/jdk.javadoc/share/classes/jdk/javadoc/doclet/StandardDoclet.java b/src/jdk.javadoc/share/classes/jdk/javadoc/doclet/StandardDoclet.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/doclet/StandardDoclet.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/doclet/StandardDoclet.java
@@ -68,10 +68,14 @@
  */
 public class StandardDoclet implements Doclet {
 
     private final HtmlDoclet htmlDoclet;
 
+    /**
+     * Creates an instance of the standard doclet, used to generate HTML-formatted
+     * documentation.
+     */
     public StandardDoclet() {
         htmlDoclet = new HtmlDoclet(this);
     }
 
     @Override
diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java
@@ -157,10 +157,11 @@
                 si.setCategory(Category.PACKAGES);
                 dt.add(" - ").add(contents.package_).add(" " + label);
                 break;
             case CLASS:
             case ENUM:
+            case RECORD:
             case ANNOTATION_TYPE:
             case INTERFACE:
                 dt = HtmlTree.DT(getLink(new LinkInfoImpl(configuration,
                         LinkInfoImpl.Kind.INDEX, (TypeElement)element).strong(true)));
                 si.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));
diff a/src/jdk.management.agent/share/conf/management.properties b/src/jdk.management.agent/share/conf/management.properties
--- a/src/jdk.management.agent/share/conf/management.properties
+++ b/src/jdk.management.agent/share/conf/management.properties
@@ -39,11 +39,11 @@
 #
 # com.sun.management.enableThreadContentionMonitoring
 #
 #      This option enables thread contention monitoring if the
 #      Java virtual machine supports such instrumentation.
-#      Refer to the specification for the java.lang.management.ThreadMBean
+#      Refer to the specification for the java.lang.management.ThreadMXBean
 #      interface - see isThreadContentionMonitoringSupported() method.
 #
 
 # To enable thread contention monitoring, uncomment the following line
 # com.sun.management.enableThreadContentionMonitoring
@@ -226,11 +226,11 @@
 #
 # ################# Hash passwords in password file ##############
 # com.sun.management.jmxremote.password.toHashes = true|false
 #      Default for this property is true.
 #      Specifies if passwords in the password file should be hashed or not.
-#      If this property is true, and if the password file is writable, and if the 
+#      If this property is true, and if the password file is writable, and if the
 #      system security policy allows writing into the password file,
 #      all the clear passwords in the password file will be replaced by
 #      their SHA3-512 hash when the file is read by the server
 #
 
@@ -265,11 +265,11 @@
 #
 
 # ################ Filter for ObjectInputStream #############################
 # com.sun.management.jmxremote.serial.filter.pattern=<filter-string>
 #   A filter, if configured, is used by java.io.ObjectInputStream during
-#   deserialization of parameters sent to the JMX default agent to validate the 
+#   deserialization of parameters sent to the JMX default agent to validate the
 #   contents of the stream.
 #   A filter is configured as a sequence of patterns, each pattern is either
 #   matched against the name of a class in the stream or defines a limit.
 #   Patterns are separated by ";" (semicolon).
 #   Whitespace is significant and is considered part of the pattern.
diff a/src/jdk.management/aix/native/libmanagement_ext/UnixOperatingSystem.c b/src/jdk.management/aix/native/libmanagement_ext/UnixOperatingSystem.c
--- a/src/jdk.management/aix/native/libmanagement_ext/UnixOperatingSystem.c
+++ b/src/jdk.management/aix/native/libmanagement_ext/UnixOperatingSystem.c
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2015 SAP SE. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -55,5 +55,12 @@
 Java_com_sun_management_internal_OperatingSystemImpl_getHostConfiguredCpuCount0
 (JNIEnv *env, jobject mbean)
 {
     return -1;
 }
+
+JNIEXPORT jint JNICALL
+Java_com_sun_management_internal_OperatingSystemImpl_getHostOnlineCpuCount0
+(JNIEnv *env, jobject mbean)
+{
+    return -1;
+}
diff a/src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c b/src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c
--- a/src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c
+++ b/src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c
@@ -360,5 +360,17 @@
         return counters.nProcs;
     } else {
        return -1;
     }
 }
+
+JNIEXPORT jint JNICALL
+Java_com_sun_management_internal_OperatingSystemImpl_getHostOnlineCpuCount0
+(JNIEnv *env, jobject mbean)
+{
+    int n = sysconf(_SC_NPROCESSORS_ONLN);
+    if (n <= 0) {
+        n = 1;
+    }
+    return n;
+}
+
diff a/src/jdk.management/macosx/native/libmanagement_ext/UnixOperatingSystem.c b/src/jdk.management/macosx/native/libmanagement_ext/UnixOperatingSystem.c
--- a/src/jdk.management/macosx/native/libmanagement_ext/UnixOperatingSystem.c
+++ b/src/jdk.management/macosx/native/libmanagement_ext/UnixOperatingSystem.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -171,5 +171,13 @@
 Java_com_sun_management_internal_OperatingSystemImpl_getHostConfiguredCpuCount0
 (JNIEnv *env, jobject mbean)
 {
     return -1;
 }
+
+JNIEXPORT jint JNICALL
+Java_com_sun_management_internal_OperatingSystemImpl_getHostOnlineCpuCount0
+(JNIEnv *env, jobject mbean)
+{
+    return -1;
+}
+
diff a/src/jdk.management/share/native/libmanagement_ext/GarbageCollectorExtImpl.c b/src/jdk.management/share/native/libmanagement_ext/GarbageCollectorExtImpl.c
--- a/src/jdk.management/share/native/libmanagement_ext/GarbageCollectorExtImpl.c
+++ b/src/jdk.management/share/native/libmanagement_ext/GarbageCollectorExtImpl.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -29,11 +29,11 @@
 
 JNIEXPORT void JNICALL Java_com_sun_management_internal_GarbageCollectorExtImpl_setNotificationEnabled
 (JNIEnv *env, jobject dummy, jobject gc,jboolean enabled) {
 
     if (gc == NULL) {
-        JNU_ThrowNullPointerException(env, "Invalid GarbageCollectorMBean");
+        JNU_ThrowNullPointerException(env, "Invalid GarbageCollectorMXBean");
         return;
     }
     if((jmm_version > JMM_VERSION_1_2)
        || (jmm_version == JMM_VERSION_1_2 && ((jmm_version&0xFF)>=1))) {
       jmm_interface->SetGCNotificationEnabled(env, gc, enabled);
diff a/src/jdk.management/share/native/libmanagement_ext/GcInfoBuilder.c b/src/jdk.management/share/native/libmanagement_ext/GcInfoBuilder.c
--- a/src/jdk.management/share/native/libmanagement_ext/GcInfoBuilder.c
+++ b/src/jdk.management/share/native/libmanagement_ext/GcInfoBuilder.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,11 +32,11 @@
 JNIEXPORT jint JNICALL Java_com_sun_management_internal_GcInfoBuilder_getNumGcExtAttributes
   (JNIEnv *env, jobject dummy, jobject gc) {
     jlong value;
 
     if (gc == NULL) {
-        JNU_ThrowNullPointerException(env, "Invalid GarbageCollectorMBean");
+        JNU_ThrowNullPointerException(env, "Invalid GarbageCollectorMXBean");
         return 0;
     }
     value = jmm_interface->GetLongAttribute(env, gc,
                                             JMM_GC_EXT_ATTRIBUTE_INFO_SIZE);
     return (jint) value;
@@ -53,11 +53,11 @@
     jstring desc = NULL;
     jint ret = 0;
     jint i;
 
     if (gc == NULL) {
-        JNU_ThrowNullPointerException(env, "Invalid GarbageCollectorMBean");
+        JNU_ThrowNullPointerException(env, "Invalid GarbageCollectorMXBean");
         return;
     }
 
     if (num_attributes <= 0) {
         JNU_ThrowIllegalArgumentException(env, "Invalid num_attributes");
@@ -205,11 +205,11 @@
     jchar*      nativeTypes;
     jsize       i;
     jvalue      v;
 
     if (gc == NULL) {
-        JNU_ThrowNullPointerException(env, "Invalid GarbageCollectorMBean");
+        JNU_ThrowNullPointerException(env, "Invalid GarbageCollectorMXBean");
         return 0;
     }
 
     if (ext_att_count <= 0) {
         JNU_ThrowIllegalArgumentException(env, "Invalid ext_att_count");
diff a/src/jdk.management/unix/classes/com/sun/management/internal/OperatingSystemImpl.java b/src/jdk.management/unix/classes/com/sun/management/internal/OperatingSystemImpl.java
--- a/src/jdk.management/unix/classes/com/sun/management/internal/OperatingSystemImpl.java
+++ b/src/jdk.management/unix/classes/com/sun/management/internal/OperatingSystemImpl.java
@@ -156,10 +156,14 @@
                 // If the cpuset is the same as the host's one there is no need to iterate over each CPU
                 if (isCpuSetSameAsHostCpuSet()) {
                     return getCpuLoad0();
                 } else {
                     int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();
+                    // in case the effectiveCPUSetCpus are not available, attempt to use just cpusets.cpus
+                    if (cpuSet == null || cpuSet.length <= 0) {
+                        cpuSet = containerMetrics.getCpuSetCpus();
+                    }
                     if (cpuSet != null && cpuSet.length > 0) {
                         double systemLoad = 0.0;
                         for (int cpu : cpuSet) {
                             double cpuLoad = getSingleCpuLoad0(cpu);
                             if (cpuLoad < 0) {
@@ -180,11 +184,11 @@
         return getProcessCpuLoad0();
     }
 
     private boolean isCpuSetSameAsHostCpuSet() {
         if (containerMetrics != null && containerMetrics.getCpuSetCpus() != null) {
-            return containerMetrics.getCpuSetCpus().length == getHostConfiguredCpuCount0();
+            return containerMetrics.getCpuSetCpus().length == getHostOnlineCpuCount0();
         }
         return false;
     }
 
     /* native methods */
@@ -198,10 +202,11 @@
     private native double getCpuLoad0();
     private native long getTotalMemorySize0();
     private native long getTotalSwapSpaceSize0();
     private native double getSingleCpuLoad0(int cpuNum);
     private native int getHostConfiguredCpuCount0();
+    private native int getHostOnlineCpuCount0();
 
     static {
         initialize0();
     }
 
diff a/test/hotspot/jtreg/ProblemList-Xcomp.txt b/test/hotspot/jtreg/ProblemList-Xcomp.txt
--- a/test/hotspot/jtreg/ProblemList-Xcomp.txt
+++ b/test/hotspot/jtreg/ProblemList-Xcomp.txt
@@ -25,5 +25,6 @@
 #
 # List of quarantined tests for testing in Xcomp mode.
 #
 #############################################################################
 
+vmTestbase/nsk/jvmti/SetFieldAccessWatch/setfldw001/TestDescription.java 8205957 generic-all
diff a/test/hotspot/jtreg/TEST.groups b/test/hotspot/jtreg/TEST.groups
--- a/test/hotspot/jtreg/TEST.groups
+++ b/test/hotspot/jtreg/TEST.groups
@@ -322,11 +322,10 @@
  -runtime/cds/SharedBaseAddress.java \
  -runtime/Thread/CancellableThreadTest.java \
  -runtime/Thread/TestThreadDumpMonitorContention.java \
  -runtime/Unsafe/RangeCheck.java \
   sanity/ \
-  testlibrary_tests/TestMutuallyExclusivePlatformPredicates.java \
  -:tier1_runtime_appcds_exclude \
  -runtime/signal
 
 tier1_runtime_no_valhalla = \
   :tier1_runtime \
diff a/test/hotspot/jtreg/compiler/codecache/stress/ReturnBlobToWrongHeapTest.java b/test/hotspot/jtreg/compiler/codecache/stress/ReturnBlobToWrongHeapTest.java
--- a/test/hotspot/jtreg/compiler/codecache/stress/ReturnBlobToWrongHeapTest.java
+++ b/test/hotspot/jtreg/compiler/codecache/stress/ReturnBlobToWrongHeapTest.java
@@ -61,17 +61,26 @@
         Helper.WHITE_BOX.freeCodeBlob(address);
     }
 
     public static void main(String[] args) {
         if (codeCacheMinBlockLength == 1) {
+            // start with allocating a small block
+            long firstSegmentSizedAddress = 0;
+            firstSegmentSizedAddress = allocate(0);
+            if (firstSegmentSizedAddress == 0) {
+                throw new RuntimeException("Test failed: Failed allocating first segment-sized blob");
+            }
+
             // Fill first code heap with large blobs until allocation fails.
             long address;
             while ((address = allocate((int)largeBlobSize)) != 0) {
             }
 
-            // Allocate segment-sized blocks in first code heap.
-            long lastSegmentSizedAddress = 0; // Address of the last segment-sized blob allocated
+            // Allocate segment-sized blocks in first code heap until it runs out
+            // Remember the last one
+            // Use the pre-allocated one as backup if the code cache is already completely full.
+            long lastSegmentSizedAddress = firstSegmentSizedAddress;
             while ((address = allocate(0)) != 0) {
                 lastSegmentSizedAddress = address;
             }
 
             if (lastSegmentSizedAddress == 0) {
diff a/test/hotspot/jtreg/compiler/loopopts/TestDeepGraphVerifyIterativeGVN.java b/test/hotspot/jtreg/compiler/loopopts/TestDeepGraphVerifyIterativeGVN.java
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/loopopts/TestDeepGraphVerifyIterativeGVN.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8246203
+ * @requires vm.debug == true & vm.flavor == "server"
+ * @summary Test which causes a stack overflow segmentation fault with -XX:+VerifyIterativeGVN due to a too deep recursion in Node::verify_recur().
+ *
+ * @run main/othervm/timeout=600 -Xcomp -XX:+VerifyIterativeGVN -XX:CompileCommand=compileonly,compiler.loopopts.TestDeepGraphVerifyIterativeGVN::*
+ *                               compiler.loopopts.TestDeepGraphVerifyIterativeGVN
+ */
+
+package compiler.loopopts;
+
+public class TestDeepGraphVerifyIterativeGVN
+{
+    static volatile int[] iArr;
+    static volatile int x;
+
+    public static void main(String[] arr) {
+        /*
+         * Just enough statements to create a deep enough graph (i.e. many nodes in one chain). The current recursive verification in Node::verify_recur() will follow this chain
+         * and call itself again for each newly discovered input node. The current implementation can only handle up to around 10000 recursive calls and will then crash with a
+         * stack overflow segementation fault. The iterative fix needs much less memory and does not result in a segementation fault anymore.
+         */
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+        iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 }; iArr = new int[] { x % 2 };
+    }
+}
diff a/test/hotspot/jtreg/runtime/cds/SharedBaseAddress.java b/test/hotspot/jtreg/runtime/cds/SharedBaseAddress.java
--- a/test/hotspot/jtreg/runtime/cds/SharedBaseAddress.java
+++ b/test/hotspot/jtreg/runtime/cds/SharedBaseAddress.java
@@ -39,10 +39,11 @@
     // shared base address test table
     private static final String[] testTable = {
         "1g", "8g", "64g","512g", "4t",
         "32t", "128t", "0",
         "1", "64k", "64M",
+        "0x800001000",        // Default base address + 1 page - probably valid but unaligned to metaspace alignment, see JDK 8247522
         "0xfffffffffff00000", // archive top wraps around 64-bit address space
         "0xfff80000",         // archive top wraps around 32-bit address space
         "0xffffffffffffffff", // archive bottom wraps around 64-bit address space -- due to align_up()
         "0xffffffff",         // archive bottom wraps around 32-bit address space -- due to align_up()
         "0x00007ffffff00000", // end of archive will go past the end of user space on linux/x64
diff a/test/hotspot/jtreg/runtime/cds/appcds/SharedBaseAddress.java b/test/hotspot/jtreg/runtime/cds/appcds/SharedBaseAddress.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/SharedBaseAddress.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/SharedBaseAddress.java
@@ -39,11 +39,12 @@
 
     // shared base address test table
     private static final String[] testTable = {
         "1g", "8g", "64g","512g", "4t",
         "32t", "128t", "0",
-        "1", "64k", "64M", "320g"
+        "1", "64k", "64M", "320g",
+        "0x800001000"  // Default base address + 1 page - probably valid but unaligned to metaspace alignment, see JDK 8247522
     };
 
     public static void main(String[] args) throws Exception {
         String appJar = JarBuilder.getOrCreateHelloJar();
 
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/AppendClasspath.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/AppendClasspath.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/AppendClasspath.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/AppendClasspath.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,11 +28,11 @@
  * @requires vm.cds
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds
  * @compile ../test-classes/Hello.java
  * @compile ../test-classes/HelloMore.java
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. AppendClasspath
  */
 
 import java.io.File;
 
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ArrayKlasses.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ArrayKlasses.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ArrayKlasses.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ArrayKlasses.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,11 +29,11 @@
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds
  *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
  * @build ArrayKlassesApp
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar ArrayKlasses.jar ArrayKlassesApp
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. ArrayKlasses
  */
 
 public class ArrayKlasses extends DynamicArchiveTestBase {
     public static void main(String[] args) throws Exception {
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ClassResolutionFailure.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ClassResolutionFailure.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ClassResolutionFailure.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ClassResolutionFailure.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,11 +31,11 @@
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
  * @build StrConcatApp
  * @build MissingDependent
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar missingDependent.jar MissingDependent
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. ClassResolutionFailure
  */
 
 public class ClassResolutionFailure extends DynamicArchiveTestBase {
 
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/DynamicArchiveRelocationTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/DynamicArchiveRelocationTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/DynamicArchiveRelocationTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/DynamicArchiveRelocationTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,11 +31,11 @@
  * @bug 8231610
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/test-classes
  * @build HelloRelocation
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar hello.jar HelloRelocation HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Point$ref
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. DynamicArchiveRelocationTest
  */
 
 import jdk.test.lib.process.OutputAnalyzer;
 import jtreg.SkippedException;
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/DynamicLotsOfClasses.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/DynamicLotsOfClasses.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/DynamicLotsOfClasses.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/DynamicLotsOfClasses.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -37,11 +37,11 @@
  * @requires vm.cds
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
  * @build LoadClasses
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar loadclasses.jar LoadClasses
- * @run driver ClassFileInstaller -jar whitebox.jar sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller -jar whitebox.jar sun.hotspot.WhiteBox
  * @run main/othervm/timeout=500 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:./whitebox.jar DynamicLotsOfClasses
  */
 
 public class DynamicLotsOfClasses extends DynamicArchiveTestBase {
 
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ExcludedClasses.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ExcludedClasses.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ExcludedClasses.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/ExcludedClasses.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -33,11 +33,11 @@
  * @run driver ClassFileInstaller -jar ExcludedClasses.jar
  *             ExcludedClassesApp
  *             ExcludedClassesApp$NotLinkedSuper
  *             ExcludedClassesApp$NotLinkedChild
  *             ExcludedClassesApp$NotLinkedInterface
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. ExcludedClasses
  */
 
 public class ExcludedClasses extends DynamicArchiveTestBase {
     public static void main(String[] args) throws Exception {
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamic.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamic.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamic.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamic.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,11 +28,11 @@
  * @requires vm.cds
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/test-classes
  * @build Hello
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar hello.jar Hello
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. HelloDynamic
  */
 
 public class HelloDynamic extends DynamicArchiveTestBase {
     public static void main(String[] args) throws Exception {
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamicCustom.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamicCustom.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamicCustom.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamicCustom.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,11 +29,11 @@
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/customLoader/test-classes /runtime/testlibrary
  * @build HelloUnload CustomLoadee ClassUnloadCommon
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar hello.jar HelloUnload ClassUnloadCommon ClassUnloadCommon$1 ClassUnloadCommon$TestFailure
  * @run driver ClassFileInstaller -jar hello_custom.jar CustomLoadee
- * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:./WhiteBox.jar HelloDynamicCustom
  */
 
 import java.io.File;
 import jdk.test.lib.process.OutputAnalyzer;
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamicCustomUnload.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamicCustomUnload.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamicCustomUnload.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/HelloDynamicCustomUnload.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -32,11 +32,11 @@
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/customLoader/test-classes /runtime/testlibrary
  * @build HelloUnload CustomLoadee ClassUnloadCommon
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar hello.jar HelloUnload ClassUnloadCommon ClassUnloadCommon$1 ClassUnloadCommon$TestFailure
  * @run driver ClassFileInstaller -jar hello_custom.jar CustomLoadee
- * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:./WhiteBox.jar HelloDynamicCustomUnload
  */
 
 import java.io.File;
 
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/JITInteraction.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/JITInteraction.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/JITInteraction.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/JITInteraction.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,11 +27,11 @@
  * @summary Test interaction with JIT threads during vm exit.
  * @requires vm.cds
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
  * @build TestJIT
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar testjit.jar TestJIT
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:./WhiteBox.jar JITInteraction
  */
 
 public class JITInteraction extends DynamicArchiveTestBase {
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/LambdaForClassInBaseArchive.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/LambdaForClassInBaseArchive.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/LambdaForClassInBaseArchive.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/LambdaForClassInBaseArchive.java
@@ -93,9 +93,9 @@
               "-cp", appJar,
               appClass, "lambda")
             .assertNormalExit(out -> {
                     out.shouldHaveExitValue(0)
                        .shouldContain("SimpleApp source: shared objects file")
-                       .shouldMatch(".class.load. SimpleApp[$][$]Lambda[$]1/0x.*source:.*shared.*objects.*file.*(top)");
+                       .shouldMatch(".class.load. SimpleApp[$][$]Lambda[$].*/0x.*source:.*shared.*objects.*file.*(top)");
                 });
     }
 }
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/LinkClassTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/LinkClassTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/LinkClassTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/LinkClassTest.java
@@ -30,11 +30,11 @@
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds
  *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
  * @build LinkClassApp
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar link_class_app.jar LinkClassApp Parent Child Parent2 Child2 MyShutdown
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. LinkClassTest
  */
 
 public class LinkClassTest extends DynamicArchiveTestBase {
     public static void main(String[] args) throws Exception {
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MethodSorting.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MethodSorting.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MethodSorting.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MethodSorting.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -43,11 +43,11 @@
  *             MethodSortingApp$InterfaceB
  *             MethodSortingApp$ImplementorA
  *             MethodSortingApp$ImplementorA1
  *             MethodSortingApp$ImplementorB
  *             MethodSortingApp$ImplementorB1
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodSorting
  */
 
 public class MethodSorting extends DynamicArchiveTestBase {
     public static void main(String[] args) throws Exception {
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MissingArchive.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MissingArchive.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MissingArchive.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/MissingArchive.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,11 +28,11 @@
  * @test
  * @summary error handling when either (or both) of the base/top archives are missing.
  * @requires vm.cds
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/test-classes
  * @build GenericTestApp sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar GenericTestApp.jar GenericTestApp
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:./WhiteBox.jar MissingArchive
  */
 
 public class MissingArchive extends DynamicArchiveTestBase {
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/NestTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/NestTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/NestTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/NestTest.java
@@ -65,10 +65,10 @@
             "-XX:+WhiteBoxAPI",
             use_whitebox_jar,
             "-Xlog:class+load=debug,class+resolve=debug,class+unload=info",
             "-cp", appJar, mainClass, "run")
             .assertNormalExit(output -> {
-                output.shouldMatch(".class.load.* NestApp[$]InnerA[$]InnerInnerA[$][$]Lambda[$]1/0x.*source:.*shared.*objects.*file.*(top)")
+                output.shouldMatch(".class.load.* NestApp[$]InnerA[$]InnerInnerA[$][$]Lambda[$].*/0x.*source:.*shared.*objects.*file.*(top)")
                       .shouldHaveExitValue(0);
             });
     }
 }
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/NoClassToArchive.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/NoClassToArchive.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/NoClassToArchive.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/NoClassToArchive.java
@@ -38,11 +38,11 @@
  *
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
  * @build StrConcatApp
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar strConcatApp.jar StrConcatApp
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. NoClassToArchive
  */
 
 import java.io.File;
 import jdk.test.lib.process.OutputAnalyzer;
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/RelativePath.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/RelativePath.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/RelativePath.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/RelativePath.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,11 +28,11 @@
  * @requires vm.cds
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds
  * @build sun.hotspot.WhiteBox
  * @compile ../test-classes/Hello.java
  * @compile ../test-classes/HelloMore.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. RelativePath
  */
 
 import java.io.File;
 
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/SharedArchiveFileOption.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/SharedArchiveFileOption.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/SharedArchiveFileOption.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/SharedArchiveFileOption.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,11 +28,11 @@
  * @requires vm.cds
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/test-classes
  * @build Hello
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller -jar hello.jar Hello
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. SharedArchiveFileOption
  */
 
 import java.io.File;
 
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/StaticInnerTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/StaticInnerTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/StaticInnerTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/StaticInnerTest.java
@@ -59,9 +59,9 @@
             "-Xlog:class+load=info",
             "-cp", appJar, mainClass, "run")
             .assertNormalExit(output -> {
                 output.shouldHaveExitValue(0)
                       .shouldContain("HelloStaticInner source: shared objects file (top)")
-                      .shouldMatch(".class.load. HelloStaticInner[$]InnerHello[$][$]Lambda[$]1/0x.*source:.*shared.*objects.*file.*(top)");
+                      .shouldMatch(".class.load. HelloStaticInner[$]InnerHello[$][$]Lambda[$].*/0x.*source:.*shared.*objects.*file.*(top)");
             });
     }
 }
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/UnsupportedBaseArchive.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/UnsupportedBaseArchive.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/UnsupportedBaseArchive.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/UnsupportedBaseArchive.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -32,11 +32,11 @@
  * @summary unsupported base archive tests
  * @requires vm.cds
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds /test/hotspot/jtreg/runtime/cds/appcds/test-classes
  * @compile ../test-classes/Hello.java
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:./WhiteBox.jar UnsupportedBaseArchive
  */
 
 public class UnsupportedBaseArchive extends DynamicArchiveTestBase {
     private static final Path USER_DIR = Paths.get(System.getProperty("user.dir"));
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/UnusedCPDuringDump.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/UnusedCPDuringDump.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/UnusedCPDuringDump.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/UnusedCPDuringDump.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,11 +29,11 @@
  *          defined to the PlatformClassLoader and AppClassLoader.
  * @requires vm.cds
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds
  * @build sun.hotspot.WhiteBox
  * @compile ../test-classes/Hello.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -Dtest.cds.copy.child.stdout=false -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. UnusedCPDuringDump
  */
 
 import java.io.File;
 
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/CDSMHTest_generate.sh b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/CDSMHTest_generate.sh
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/CDSMHTest_generate.sh
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/CDSMHTest_generate.sh
@@ -48,12 +48,12 @@
  *        ../../../../../../../jdk/java/lang/invoke/$fname
  *        ../../../../../../../jdk/java/lang/invoke/remote/RemoteExample.java
  *        ../../../../../../../jdk/java/lang/invoke/common/test/java/lang/invoke/lib/CodeCacheOverflowProcessor.java
  *        ../test-classes/TestMHApp.java
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox\$WhiteBoxPermission
- * @run junit/othervm/timeout=240 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. $i
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run junit/othervm/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. $i
  */
 
 import org.junit.Test;
 
 import java.io.File;
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesAsCollectorTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesAsCollectorTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesAsCollectorTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesAsCollectorTest.java
@@ -38,12 +38,12 @@
  *        ../../../../../../../jdk/java/lang/invoke/MethodHandlesAsCollectorTest.java
  *        ../../../../../../../jdk/java/lang/invoke/remote/RemoteExample.java
  *        ../../../../../../../jdk/java/lang/invoke/common/test/java/lang/invoke/lib/CodeCacheOverflowProcessor.java
  *        ../test-classes/TestMHApp.java
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run junit/othervm/timeout=240 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesAsCollectorTest
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run junit/othervm/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesAsCollectorTest
  */
 
 import org.junit.Test;
 
 import java.io.File;
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesCastFailureTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesCastFailureTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesCastFailureTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesCastFailureTest.java
@@ -38,12 +38,12 @@
  *        ../../../../../../../jdk/java/lang/invoke/MethodHandlesCastFailureTest.java
  *        ../../../../../../../jdk/java/lang/invoke/remote/RemoteExample.java
  *        ../../../../../../../jdk/java/lang/invoke/common/test/java/lang/invoke/lib/CodeCacheOverflowProcessor.java
  *        ../test-classes/TestMHApp.java
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run junit/othervm/timeout=240 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesCastFailureTest
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run junit/othervm/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesCastFailureTest
  */
 
 import org.junit.Test;
 
 import java.io.File;
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesGeneralTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesGeneralTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesGeneralTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesGeneralTest.java
@@ -38,12 +38,12 @@
  *        ../../../../../../../jdk/java/lang/invoke/MethodHandlesGeneralTest.java
  *        ../../../../../../../jdk/java/lang/invoke/remote/RemoteExample.java
  *        ../../../../../../../jdk/java/lang/invoke/common/test/java/lang/invoke/lib/CodeCacheOverflowProcessor.java
  *        ../test-classes/TestMHApp.java
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run junit/othervm/timeout=240 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesGeneralTest
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run junit/othervm/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesGeneralTest
  */
 
 import org.junit.Test;
 
 import java.io.File;
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesInvokersTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesInvokersTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesInvokersTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesInvokersTest.java
@@ -38,12 +38,12 @@
  *        ../../../../../../../jdk/java/lang/invoke/MethodHandlesInvokersTest.java
  *        ../../../../../../../jdk/java/lang/invoke/remote/RemoteExample.java
  *        ../../../../../../../jdk/java/lang/invoke/common/test/java/lang/invoke/lib/CodeCacheOverflowProcessor.java
  *        ../test-classes/TestMHApp.java
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run junit/othervm/timeout=240 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesInvokersTest
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run junit/othervm/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesInvokersTest
  */
 
 import org.junit.Test;
 
 import java.io.File;
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesPermuteArgumentsTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesPermuteArgumentsTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesPermuteArgumentsTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesPermuteArgumentsTest.java
@@ -38,12 +38,12 @@
  *        ../../../../../../../jdk/java/lang/invoke/MethodHandlesPermuteArgumentsTest.java
  *        ../../../../../../../jdk/java/lang/invoke/remote/RemoteExample.java
  *        ../../../../../../../jdk/java/lang/invoke/common/test/java/lang/invoke/lib/CodeCacheOverflowProcessor.java
  *        ../test-classes/TestMHApp.java
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run junit/othervm/timeout=240 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesPermuteArgumentsTest
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run junit/othervm/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesPermuteArgumentsTest
  */
 
 import org.junit.Test;
 
 import java.io.File;
diff a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesSpreadArgumentsTest.java b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesSpreadArgumentsTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesSpreadArgumentsTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/methodHandles/MethodHandlesSpreadArgumentsTest.java
@@ -38,12 +38,12 @@
  *        ../../../../../../../jdk/java/lang/invoke/MethodHandlesSpreadArgumentsTest.java
  *        ../../../../../../../jdk/java/lang/invoke/remote/RemoteExample.java
  *        ../../../../../../../jdk/java/lang/invoke/common/test/java/lang/invoke/lib/CodeCacheOverflowProcessor.java
  *        ../test-classes/TestMHApp.java
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run junit/othervm/timeout=240 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesSpreadArgumentsTest
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run junit/othervm/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MethodHandlesSpreadArgumentsTest
  */
 
 import org.junit.Test;
 
 import java.io.File;
diff a/test/hotspot/jtreg/runtime/cds/appcds/javaldr/GCDuringDump.java b/test/hotspot/jtreg/runtime/cds/appcds/javaldr/GCDuringDump.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/javaldr/GCDuringDump.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/javaldr/GCDuringDump.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -39,10 +39,11 @@
     public static String appClasses[] = {
         Hello.class.getName(),
     };
     public static String agentClasses[] = {
         GCDuringDumpTransformer.class.getName(),
+        GCDuringDumpTransformer.MyCleaner.class.getName(),
     };
 
     public static void main(String[] args) throws Throwable {
         String agentJar =
             ClassFileInstaller.writeJar("GCDuringDumpTransformer.jar",
@@ -53,19 +54,22 @@
             ClassFileInstaller.writeJar("GCDuringDumpApp.jar", appClasses);
 
         String gcLog = Boolean.getBoolean("test.cds.verbose.gc") ?
             "-Xlog:gc*=info,gc+region=trace,gc+alloc+region=debug" : "-showversion";
 
-        for (int i=0; i<2; i++) {
+        for (int i=0; i<3; i++) {
             // i = 0 -- run without agent = no extra GCs
             // i = 1 -- run with agent = cause extra GCs
+            // i = 2 -- run with agent = cause extra GCs + use java.lang.ref.Cleaner
 
             String extraArg = (i == 0) ? "-showversion" : "-javaagent:" + agentJar;
             String extraOption = (i == 0) ? "-showversion" : "-XX:+AllowArchivingWithJavaAgent";
+            String extraOption2 = (i != 2) ? "-showversion" : "-Dtest.with.cleaner=true";
 
             TestCommon.testDump(appJar, TestCommon.list(Hello.class.getName()),
-                                "-XX:+UnlockDiagnosticVMOptions", extraOption,
+                                "-XX:+UnlockDiagnosticVMOptions", extraOption, extraOption2,
+                                "-Xlog:exceptions=trace",
                                 extraArg, "-Xmx32m", gcLog);
 
             TestCommon.run(
                 "-cp", appJar,
                 "-Xmx32m",
diff a/test/hotspot/jtreg/runtime/cds/appcds/javaldr/GCDuringDumpTransformer.java b/test/hotspot/jtreg/runtime/cds/appcds/javaldr/GCDuringDumpTransformer.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/javaldr/GCDuringDumpTransformer.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/javaldr/GCDuringDumpTransformer.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,31 +23,53 @@
  */
 
 import java.lang.instrument.ClassFileTransformer;
 import java.lang.instrument.Instrumentation;
 import java.lang.instrument.IllegalClassFormatException;
+import java.lang.ref.Cleaner;
 import java.security.ProtectionDomain;
 
 public class GCDuringDumpTransformer implements ClassFileTransformer {
+    static boolean TEST_WITH_CLEANER = Boolean.getBoolean("test.with.cleaner");
+    static Cleaner cleaner;
+    static Thread thread;
+    static Object garbage;
+
+    static {
+        if (TEST_WITH_CLEANER) {
+            cleaner = Cleaner.create();
+            garbage = new Object();
+            cleaner.register(garbage, new MyCleaner());
+            System.out.println("Registered cleaner");
+        }
+    }
+
     public byte[] transform(ClassLoader loader, String name, Class<?> classBeingRedefined,
                             ProtectionDomain pd, byte[] buffer) throws IllegalClassFormatException {
-        try {
-            makeGarbage();
-        } catch (Throwable t) {
-            t.printStackTrace();
+        if (TEST_WITH_CLEANER) {
+            if (name.equals("Hello")) {
+                garbage = null;
+                System.out.println("Unreferenced GCDuringDumpTransformer.garbage");
+            }
+        } else {
             try {
-                Thread.sleep(200); // let GC to have a chance to run
-            } catch (Throwable t2) {}
+                makeGarbage();
+            } catch (Throwable t) {
+                t.printStackTrace();
+                try {
+                    Thread.sleep(200); // let GC to have a chance to run
+                } catch (Throwable t2) {}
+            }
         }
 
         return null;
     }
 
     private static Instrumentation savedInstrumentation;
 
     public static void premain(String agentArguments, Instrumentation instrumentation) {
-        System.out.println("ClassFileTransformer.premain() is called");
+        System.out.println("ClassFileTransformer.premain() is called: TEST_WITH_CLEANER = " + TEST_WITH_CLEANER);
         instrumentation.addTransformer(new GCDuringDumpTransformer(), /*canRetransform=*/true);
         savedInstrumentation = instrumentation;
     }
 
     public static Instrumentation getInstrumentation() {
@@ -61,6 +83,17 @@
     public static void makeGarbage() {
         for (int x=0; x<10; x++) {
             Object[] a = new Object[10000];
         }
     }
+
+    static class MyCleaner implements Runnable {
+        static int count = 0;
+        int i = count++;
+        public void run() {
+            // Allocate something. This will cause G1 to allocate an EDEN region.
+            // See JDK-8245925
+            Object o = new Object();
+            System.out.println("cleaning " + i);
+        }
+    }
 }
diff a/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/OptimizeModuleHandlingTest.java b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/OptimizeModuleHandlingTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/OptimizeModuleHandlingTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/jigsaw/modulepath/OptimizeModuleHandlingTest.java
@@ -22,11 +22,11 @@
  *
  */
 
 /**
  * @test
- * @requires vm.cds
+ * @requires vm.cds & !vm.jvmci
  * @library /test/lib /test/hotspot/jtreg/runtime/cds/appcds
  * @run driver OptimizeModuleHandlingTest
  * @summary test module path changes for optimization of
  *          module handling.
  *
diff a/test/hotspot/jtreg/runtime/cds/appcds/loaderConstraints/DynamicLoaderConstraintsTest.java b/test/hotspot/jtreg/runtime/cds/appcds/loaderConstraints/DynamicLoaderConstraintsTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/loaderConstraints/DynamicLoaderConstraintsTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/loaderConstraints/DynamicLoaderConstraintsTest.java
@@ -30,11 +30,11 @@
  *          /test/hotspot/jtreg/runtime/cds/appcds/test-classes
  *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive
  * @modules java.base/jdk.internal.misc
  *          jdk.httpserver
  * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. DynamicLoaderConstraintsTest
  */
 
 import com.sun.net.httpserver.HttpExchange;
 import com.sun.net.httpserver.HttpHandler;
diff a/test/hotspot/jtreg/serviceability/dcmd/gc/HeapDumpCompressedTest.java b/test/hotspot/jtreg/serviceability/dcmd/gc/HeapDumpCompressedTest.java
--- a/test/hotspot/jtreg/serviceability/dcmd/gc/HeapDumpCompressedTest.java
+++ b/test/hotspot/jtreg/serviceability/dcmd/gc/HeapDumpCompressedTest.java
@@ -77,11 +77,11 @@
  * @library /test/lib
  * @modules java.base/jdk.internal.misc
  *          java.compiler
  *          java.management
  *          jdk.internal.jvmstat/sun.jvmstat.monitor
- * @run main/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseZGC HeapDumpCompressedTest
+ * @run main/othervm -XX:+UseZGC HeapDumpCompressedTest
  */
 
 /*
  * @test
  * @requires vm.gc.Shenandoah
@@ -89,11 +89,11 @@
  * @library /test/lib
  * @modules java.base/jdk.internal.misc
  *          java.compiler
  *          java.management
  *          jdk.internal.jvmstat/sun.jvmstat.monitor
- * @run main/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC HeapDumpCompressedTest
+ * @run main/othervm -XX:+UseShenandoahGC HeapDumpCompressedTest
  */
 
 /*
  * @test
  * @requires vm.gc.Epsilon
diff a/test/hotspot/jtreg/testlibrary/jvmti/libSimpleClassFileLoadHook.c b/test/hotspot/jtreg/testlibrary/jvmti/libSimpleClassFileLoadHook.c
--- a/test/hotspot/jtreg/testlibrary/jvmti/libSimpleClassFileLoadHook.c
+++ b/test/hotspot/jtreg/testlibrary/jvmti/libSimpleClassFileLoadHook.c
@@ -20,11 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /*
- * A simple way to test JVMTI ClassFileLoadHook. See ../testlibrary_tests/SimpleClassFileLoadHookTest.java
+ * A simple way to test JVMTI ClassFileLoadHook. See ../testlibrary_tests/jvmti/SimpleClassFileLoadHookTest.java
  * for an example.
  */
 #include <stdio.h>
 #include <stdarg.h>
 #include <stdlib.h>
diff a/test/hotspot/jtreg/testlibrary_tests/AssertsTest.java b/test/hotspot/jtreg/testlibrary_tests/AssertsTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/AssertsTest.java
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-import static jdk.test.lib.Asserts.*;
-
-/* @test
- * @summary Tests the different assertions in the Assert class
- * @modules java.base/jdk.internal.misc
- * @library /test/lib
- */
-public class AssertsTest {
-    private static class Foo implements Comparable<Foo> {
-        final int id;
-        public Foo(int id) {
-            this.id = id;
-        }
-
-        public int compareTo(Foo f) {
-            return new Integer(id).compareTo(new Integer(f.id));
-        }
-    }
-
-    public static void main(String[] args) throws Exception {
-        testLessThan();
-        testLessThanOrEqual();
-        testEquals();
-        testGreaterThanOrEqual();
-        testGreaterThan();
-        testNotEquals();
-        testNull();
-        testNotNull();
-        testTrue();
-        testFalse();
-    }
-
-    private static void testLessThan() throws Exception {
-        expectPass(Assertion.LT, 1, 2);
-
-        expectFail(Assertion.LT, 2, 2);
-        expectFail(Assertion.LT, 2, 1);
-        expectFail(Assertion.LT, null, 2);
-        expectFail(Assertion.LT, 2, null);
-    }
-
-    private static void testLessThanOrEqual() throws Exception {
-        expectPass(Assertion.LTE, 1, 2);
-        expectPass(Assertion.LTE, 2, 2);
-
-        expectFail(Assertion.LTE, 3, 2);
-        expectFail(Assertion.LTE, null, 2);
-        expectFail(Assertion.LTE, 2, null);
-    }
-
-    private static void testEquals() throws Exception {
-        expectPass(Assertion.EQ, 1, 1);
-        expectPass(Assertion.EQ, null, null);
-
-        Foo f1 = new Foo(1);
-        expectPass(Assertion.EQ, f1, f1);
-
-        Foo f2 = new Foo(1);
-        expectFail(Assertion.EQ, f1, f2);
-        expectFail(Assertion.LTE, null, 2);
-        expectFail(Assertion.LTE, 2, null);
-    }
-
-    private static void testGreaterThanOrEqual() throws Exception {
-        expectPass(Assertion.GTE, 1, 1);
-        expectPass(Assertion.GTE, 2, 1);
-
-        expectFail(Assertion.GTE, 1, 2);
-        expectFail(Assertion.GTE, null, 2);
-        expectFail(Assertion.GTE, 2, null);
-    }
-
-    private static void testGreaterThan() throws Exception {
-        expectPass(Assertion.GT, 2, 1);
-
-        expectFail(Assertion.GT, 1, 1);
-        expectFail(Assertion.GT, 1, 2);
-        expectFail(Assertion.GT, null, 2);
-        expectFail(Assertion.GT, 2, null);
-    }
-
-    private static void testNotEquals() throws Exception {
-        expectPass(Assertion.NE, null, 1);
-        expectPass(Assertion.NE, 1, null);
-
-        Foo f1 = new Foo(1);
-        Foo f2 = new Foo(1);
-        expectPass(Assertion.NE, f1, f2);
-
-        expectFail(Assertion.NE, null, null);
-        expectFail(Assertion.NE, f1, f1);
-        expectFail(Assertion.NE, 1, 1);
-    }
-
-    private static void testNull() throws Exception {
-        expectPass(Assertion.NULL, null);
-
-        expectFail(Assertion.NULL, 1);
-    }
-
-    private static void testNotNull() throws Exception {
-        expectPass(Assertion.NOTNULL, 1);
-
-        expectFail(Assertion.NOTNULL, null);
-    }
-
-    private static void testTrue() throws Exception {
-        expectPass(Assertion.TRUE, true);
-
-        expectFail(Assertion.TRUE, false);
-    }
-
-    private static void testFalse() throws Exception {
-        expectPass(Assertion.FALSE, false);
-
-        expectFail(Assertion.FALSE, true);
-    }
-
-    private static <T extends Comparable<T>> void expectPass(Assertion assertion, T ... args)
-        throws Exception {
-        Assertion.run(assertion, args);
-    }
-
-    private static <T extends Comparable<T>> void expectFail(Assertion assertion, T ... args)
-        throws Exception {
-        try {
-            Assertion.run(assertion, args);
-        } catch (RuntimeException e) {
-            return;
-        }
-        throw new Exception("Expected " + Assertion.format(assertion, (Object[]) args) +
-                            " to throw a RuntimeException");
-    }
-
-}
-
-enum Assertion {
-    LT, LTE, EQ, GTE, GT, NE, NULL, NOTNULL, FALSE, TRUE;
-
-    public static <T extends Comparable<T>> void run(Assertion assertion, T ... args) {
-        String msg = "Expected " + format(assertion, args) + " to pass";
-        switch (assertion) {
-            case LT:
-                assertLessThan(args[0], args[1], msg);
-                break;
-            case LTE:
-                assertLessThanOrEqual(args[0], args[1], msg);
-                break;
-            case EQ:
-                assertEquals(args[0], args[1], msg);
-                break;
-            case GTE:
-                assertGreaterThanOrEqual(args[0], args[1], msg);
-                break;
-            case GT:
-                assertGreaterThan(args[0], args[1], msg);
-                break;
-            case NE:
-                assertNotEquals(args[0], args[1], msg);
-                break;
-            case NULL:
-                assertNull(args == null ? args : args[0], msg);
-                break;
-            case NOTNULL:
-                assertNotNull(args == null ? args : args[0], msg);
-                break;
-            case FALSE:
-                assertFalse((Boolean) args[0], msg);
-                break;
-            case TRUE:
-                assertTrue((Boolean) args[0], msg);
-                break;
-            default:
-                // do nothing
-        }
-    }
-
-    public static String format(Assertion assertion, Object ... args) {
-        switch (assertion) {
-            case LT:
-                return asString("assertLessThan", args);
-            case LTE:
-                return asString("assertLessThanOrEqual", args);
-            case EQ:
-                return asString("assertEquals", args);
-            case GTE:
-                return asString("assertGreaterThanOrEquals", args);
-            case GT:
-                return asString("assertGreaterThan", args);
-            case NE:
-                return asString("assertNotEquals", args);
-            case NULL:
-                return asString("assertNull", args);
-            case NOTNULL:
-                return asString("assertNotNull", args);
-            case FALSE:
-                return asString("assertFalse", args);
-            case TRUE:
-                return asString("assertTrue", args);
-            default:
-                return "";
-        }
-    }
-
-    private static String asString(String assertion, Object ... args) {
-        if (args == null) {
-            return String.format("%s(null)", assertion);
-        }
-        if (args.length == 1) {
-            return String.format("%s(%s)", assertion, args[0]);
-        } else {
-            return String.format("%s(%s, %s)", assertion, args[0], args[1]);
-        }
-    }
-}
diff a/test/hotspot/jtreg/testlibrary_tests/OutputAnalyzerReportingTest.java b/test/hotspot/jtreg/testlibrary_tests/OutputAnalyzerReportingTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/OutputAnalyzerReportingTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-
-/*
- * @test
- * @summary Test the OutputAnalyzer reporting functionality,
- *     such as printing additional diagnostic info
- *     (exit code, stdout, stderr, command line, etc.)
- * @library /test/lib
- * @modules java.base/jdk.internal.misc
- *          java.management
- */
-
-import java.io.ByteArrayOutputStream;
-import java.io.PrintStream;
-
-import jdk.test.lib.process.OutputAnalyzer;
-import jdk.test.lib.process.ProcessTools;
-
-
-public class OutputAnalyzerReportingTest {
-
-    public static void main(String[] args) throws Exception {
-        // Create the output analyzer under test
-        String stdout = "aaaaaa";
-        String stderr = "bbbbbb";
-        OutputAnalyzer output = new OutputAnalyzer(stdout, stderr);
-
-        // Expected summary values should be the same for all cases,
-        // since the outputAnalyzer object is the same
-        String expectedExitValue = "-1";
-        String expectedSummary =
-                " stdout: [" + stdout + "];\n" +
-                " stderr: [" + stderr + "]\n" +
-                " exitValue = " + expectedExitValue + "\n";
-
-
-        DiagnosticSummaryTestRunner testRunner =
-                new DiagnosticSummaryTestRunner();
-
-        // should have exit value
-        testRunner.init(expectedSummary);
-        int unexpectedExitValue = 2;
-        try {
-            output.shouldHaveExitValue(unexpectedExitValue);
-        } catch (RuntimeException e) { }
-        testRunner.closeAndCheckResults();
-
-        // should not contain
-        testRunner.init(expectedSummary);
-        try {
-            output.shouldNotContain(stdout);
-        } catch (RuntimeException e) { }
-        testRunner.closeAndCheckResults();
-
-        // should contain
-        testRunner.init(expectedSummary);
-        try {
-            output.shouldContain("unexpected-stuff");
-        } catch (RuntimeException e) { }
-        testRunner.closeAndCheckResults();
-
-        // should not match
-        testRunner.init(expectedSummary);
-        try {
-            output.shouldNotMatch("[a]");
-        } catch (RuntimeException e) { }
-        testRunner.closeAndCheckResults();
-
-        // should match
-        testRunner.init(expectedSummary);
-        try {
-            output.shouldMatch("[qwerty]");
-        } catch (RuntimeException e) { }
-        testRunner.closeAndCheckResults();
-
-    }
-
-    private static class DiagnosticSummaryTestRunner {
-        private ByteArrayOutputStream byteStream =
-                new ByteArrayOutputStream(10000);
-
-        private String expectedSummary = "";
-        private PrintStream errStream;
-
-
-        public void init(String expectedSummary) {
-            this.expectedSummary = expectedSummary;
-            byteStream.reset();
-            errStream = new PrintStream(byteStream);
-            System.setErr(errStream);
-        }
-
-        public void closeAndCheckResults() {
-            // check results
-            errStream.close();
-            String stdErrStr = byteStream.toString();
-            if (!stdErrStr.contains(expectedSummary)) {
-                throw new RuntimeException("The output does not contain "
-                    + "the diagnostic message, or the message is incorrect");
-            }
-        }
-    }
-
-}
diff a/test/hotspot/jtreg/testlibrary_tests/OutputAnalyzerTest.java b/test/hotspot/jtreg/testlibrary_tests/OutputAnalyzerTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/OutputAnalyzerTest.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @summary Test the OutputAnalyzer utility class
- * @library /test/lib
- * @modules java.base/jdk.internal.misc
- *          java.management
- */
-
-import jdk.test.lib.process.OutputAnalyzer;
-
-public class OutputAnalyzerTest {
-
-  public static void main(String args[]) throws Exception {
-
-    String stdout = "aaaaaa";
-    String stderr = "bbbbbb";
-
-    // Regexps used for testing pattern matching of the test input
-    String stdoutPattern = "[a]";
-    String stderrPattern = "[b]";
-    String nonExistingPattern = "[c]";
-
-    OutputAnalyzer output = new OutputAnalyzer(stdout, stderr);
-
-    if (!stdout.equals(output.getStdout())) {
-      throw new Exception("getStdout() returned '" + output.getStdout() + "', expected '" + stdout + "'");
-    }
-
-    if (!stderr.equals(output.getStderr())) {
-      throw new Exception("getStderr() returned '" + output.getStderr() + "', expected '" + stderr + "'");
-    }
-
-    try {
-      output.shouldContain(stdout);
-      output.stdoutShouldContain(stdout);
-      output.shouldContain(stderr);
-      output.stderrShouldContain(stderr);
-    } catch (RuntimeException e) {
-      throw new Exception("shouldContain() failed", e);
-    }
-
-    try {
-      output.shouldContain("cccc");
-      throw new Exception("shouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-      output.stdoutShouldContain(stderr);
-      throw new Exception("stdoutShouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-      output.stderrShouldContain(stdout);
-      throw new Exception("stdoutShouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-      output.shouldNotContain("cccc");
-      output.stdoutShouldNotContain("cccc");
-      output.stderrShouldNotContain("cccc");
-    } catch (RuntimeException e) {
-      throw new Exception("shouldNotContain() failed", e);
-    }
-
-    try {
-      output.shouldNotContain(stdout);
-      throw new Exception("shouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-      output.stdoutShouldNotContain(stdout);
-      throw new Exception("shouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-        output.stderrShouldNotContain(stderr);
-        throw new Exception("shouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    // Should match
-    try {
-        output.shouldMatch(stdoutPattern);
-        output.stdoutShouldMatch(stdoutPattern);
-        output.shouldMatch(stderrPattern);
-        output.stderrShouldMatch(stderrPattern);
-    } catch (RuntimeException e) {
-        throw new Exception("shouldMatch() failed", e);
-    }
-
-    try {
-        output.shouldMatch(nonExistingPattern);
-        throw new Exception("shouldMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    try {
-        output.stdoutShouldMatch(stderrPattern);
-        throw new Exception(
-                "stdoutShouldMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    try {
-        output.stderrShouldMatch(stdoutPattern);
-        throw new Exception(
-                "stderrShouldMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    // Should not match
-    try {
-        output.shouldNotMatch(nonExistingPattern);
-        output.stdoutShouldNotMatch(nonExistingPattern);
-        output.stderrShouldNotMatch(nonExistingPattern);
-    } catch (RuntimeException e) {
-        throw new Exception("shouldNotMatch() failed", e);
-    }
-
-    try {
-        output.shouldNotMatch(stdoutPattern);
-        throw new Exception("shouldNotMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    try {
-        output.stdoutShouldNotMatch(stdoutPattern);
-        throw new Exception("shouldNotMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    try {
-        output.stderrShouldNotMatch(stderrPattern);
-        throw new Exception("shouldNotMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    {
-      String aaaa = "aaaa";
-      String result = output.firstMatch(aaaa);
-      if (!aaaa.equals(result)) {
-        throw new Exception("firstMatch(String) faild to match. Expected: " + aaaa + " got: " + result);
-      }
-    }
-
-    {
-      String aa = "aa";
-      String aa_grouped_aa = aa + "(" + aa + ")";
-      String result = output.firstMatch(aa_grouped_aa, 1);
-      if (!aa.equals(result)) {
-        throw new Exception("firstMatch(String, int) failed to match. Expected: " + aa + " got: " + result);
-      }
-    }
-  }
-}
diff a/test/hotspot/jtreg/testlibrary_tests/TestPlatformIsTieredSupported.java b/test/hotspot/jtreg/testlibrary_tests/TestPlatformIsTieredSupported.java
--- a/test/hotspot/jtreg/testlibrary_tests/TestPlatformIsTieredSupported.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-import jdk.test.lib.Asserts;
-import jdk.test.lib.Platform;
-import sun.hotspot.WhiteBox;
-
-/**
- * @test
- * @summary Verifies that Platform::isTieredSupported returns correct value.
- * @requires vm.opt.final.TieredCompilation
- * @library /test/lib
- * @modules java.base/jdk.internal.misc
- *          java.management
- * @build sun.hotspot.WhiteBox
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
- *                   -XX:+WhiteBoxAPI -XX:+TieredCompilation
- *                   TestPlatformIsTieredSupported
- */
-public class TestPlatformIsTieredSupported {
-    public static void main(String args[]) {
-        WhiteBox whiteBox = WhiteBox.getWhiteBox();
-        boolean tieredCompilation = whiteBox.getBooleanVMFlag(
-                "TieredCompilation");
-        Asserts.assertEQ(Platform.isTieredSupported(), tieredCompilation,
-                "Platform::isTieredSupported should report the same value as "
-                        + "TieredCompilation flag's value when "
-                        + "+TieredCompilation was explicitly passed to JVM.");
-    }
-}
diff a/test/hotspot/jtreg/testlibrary_tests/SimpleClassFileLoadHookTest.java b/test/hotspot/jtreg/testlibrary_tests/jvmti/SimpleClassFileLoadHookTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/SimpleClassFileLoadHookTest.java
+++ b/test/hotspot/jtreg/testlibrary_tests/jvmti/SimpleClassFileLoadHookTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/process/Test.java b/test/hotspot/jtreg/testlibrary_tests/process/Test.java
--- a/test/hotspot/jtreg/testlibrary_tests/process/Test.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-public class Test {
-    public static void test() {
-        System.out.println ("Hello Test");
-    }
-}
diff a/test/hotspot/jtreg/testlibrary_tests/process/TestNativeProcessBuilder.java b/test/hotspot/jtreg/testlibrary_tests/process/TestNativeProcessBuilder.java
--- a/test/hotspot/jtreg/testlibrary_tests/process/TestNativeProcessBuilder.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @summary Test the native process builder API.
- * @library /test/lib
- * @build Test
- * @run main/native TestNativeProcessBuilder
- */
-
-
-import jdk.test.lib.Utils;
-import jdk.test.lib.process.ProcessTools;
-import jdk.test.lib.process.OutputAnalyzer;
-
-public class TestNativeProcessBuilder {
-    public static void main(String args[]) throws Exception {
-        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder("jvm-test-launcher");
-        pb.environment().put("CLASSPATH", Utils.TEST_CLASS_PATH);
-        new OutputAnalyzer(pb.start())
-            .shouldHaveExitValue(0);
-    }
-}
diff a/test/hotspot/jtreg/testlibrary_tests/process/exejvm-test-launcher.c b/test/hotspot/jtreg/testlibrary_tests/process/exejvm-test-launcher.c
--- a/test/hotspot/jtreg/testlibrary_tests/process/exejvm-test-launcher.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <jni.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-JNIEnv* create_vm(JavaVM **jvm)
-{
-    JNIEnv* env;
-    JavaVMInitArgs args;
-    JavaVMOption options[1];
-
-    char classpath[4096];
-    snprintf(classpath, sizeof classpath,
-             "-Djava.class.path=%s", getenv("CLASSPATH"));
-    options[0].optionString = classpath;
-
-    args.version = JNI_VERSION_1_8;
-    args.nOptions = 1;
-    args.options = &options[0];
-    args.ignoreUnrecognized = 0;
-
-    int ret = JNI_CreateJavaVM(jvm, (void**)&env, &args);
-    if (ret < 0)
-      exit(10);
-
-    return env;
-}
-
-
-void run(JNIEnv *env) {
-  jclass test_class;
-  jmethodID test_method;
-
-  test_class = (*env)->FindClass(env, "Test");
-  if (test_class == NULL)
-    exit(11);
-
-  test_method = (*env)->GetStaticMethodID(env, test_class, "test", "()V");
-  if (test_method == NULL)
-    exit(12);
-
-  (*env)->CallStaticVoidMethod(env, test_class, test_method);
-}
-
-
-int main(int argc, char **argv)
-{
-  JavaVM *jvm;
-  JNIEnv *env = create_vm(&jvm);
-
-  run(env);
-
-  return 0;
-}
diff a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon001/comptimemon001.java b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon001/comptimemon001.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon001/comptimemon001.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon001/comptimemon001.java
@@ -30,11 +30,11 @@
  * @summary converted from VM Testbase nsk/monitoring/CompilationMXBean/comptimemon001.
  * VM Testbase keywords: [quick, monitoring]
  * VM Testbase readme:
  * DESCRIPTION
  *     The test checks that
- *         CompilationMBean.isCompilationTimeMonitoringSupported()
+ *         CompilationMXBean.isCompilationTimeMonitoringSupported()
  *     method returns true. The test performs directly access to management
  *     metrics within the same JVM.
  *     Note, that the test is correct ONLY against Sun's Hotspot VM. This
  *     feature is optional and the method may return either true, or false.
  *     However, Sun's implementation must always return true.
diff a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon002/TestDescription.java b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon002/TestDescription.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon002/TestDescription.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon002/TestDescription.java
@@ -29,11 +29,11 @@
  * @summary converted from VM Testbase nsk/monitoring/CompilationMXBean/comptimemon002.
  * VM Testbase keywords: [quick, monitoring]
  * VM Testbase readme:
  * DESCRIPTION
  *     The test checks that
- *         CompilationMBean.isCompilationTimeMonitoringSupported()
+ *         CompilationMXBean.isCompilationTimeMonitoringSupported()
  *     method returns true. The test performs access to management metrics
  *     through default MBeanServer.
  *     Note, that the test is correct ONLY against Sun's Hotspot VM. This
  *     feature is optional and the method may return either true, or false.
  *     However, Sun's implementation must always return true.
@@ -48,6 +48,5 @@
  * @run driver jdk.test.lib.FileInstaller . .
  * @run main/othervm/timeout=300
  *      nsk.monitoring.CompilationMXBean.comptimemon001.comptimemon001
  *      -testMode=server
  */
-
diff a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon003/TestDescription.java b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon003/TestDescription.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon003/TestDescription.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon003/TestDescription.java
@@ -29,11 +29,11 @@
  * @summary converted from VM Testbase nsk/monitoring/CompilationMXBean/comptimemon003.
  * VM Testbase keywords: [quick, monitoring]
  * VM Testbase readme:
  * DESCRIPTION
  *     The test checks that
- *         CompilationMBean.isCompilationTimeMonitoringSupported()
+ *         CompilationMXBean.isCompilationTimeMonitoringSupported()
  *     method returns true. The test performs access to management metrics
  *     through custom MBeanServer (developed and saved in
  *     $TESTBASE/src/nsk/monitoring/share).
  *     Note, that the test is correct ONLY against Sun's Hotspot VM. This
  *     feature is optional and the method may return either true, or false.
@@ -50,6 +50,5 @@
  * @run main/othervm/timeout=300
  *      nsk.monitoring.CompilationMXBean.comptimemon001.comptimemon001
  *      -testMode=server
  *      -MBeanServer=custom
  */
-
diff a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon004/TestDescription.java b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon004/TestDescription.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon004/TestDescription.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon004/TestDescription.java
@@ -29,11 +29,11 @@
  * @summary converted from VM Testbase nsk/monitoring/CompilationMXBean/comptimemon004.
  * VM Testbase keywords: [quick, monitoring]
  * VM Testbase readme:
  * DESCRIPTION
  *     The test checks that
- *         CompilationMBean.isCompilationTimeMonitoringSupported()
+ *         CompilationMXBean.isCompilationTimeMonitoringSupported()
  *     method returns true. The test performs access to management metrics
  *     through default MBeanServer proxy.
  *     Note, that the test is correct ONLY against Sun's Hotspot VM. This
  *     feature is optional and the method may return either true, or false.
  *     However, Sun's implementation must always return true.
@@ -48,6 +48,5 @@
  * @run driver jdk.test.lib.FileInstaller . .
  * @run main/othervm/timeout=300
  *      nsk.monitoring.CompilationMXBean.comptimemon001.comptimemon001
  *      -testMode=proxy
  */
-
diff a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon005/TestDescription.java b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon005/TestDescription.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon005/TestDescription.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/monitoring/CompilationMXBean/comptimemon005/TestDescription.java
@@ -29,11 +29,11 @@
  * @summary converted from VM Testbase nsk/monitoring/CompilationMXBean/comptimemon005.
  * VM Testbase keywords: [quick, monitoring]
  * VM Testbase readme:
  * DESCRIPTION
  *     The test checks that
- *         CompilationMBean.isCompilationTimeMonitoringSupported()
+ *         CompilationMXBean.isCompilationTimeMonitoringSupported()
  *     method returns true. The test performs access to management metrics
  *     through custom MBeanServer proxy (developed and saved in
  *     $TESTBASE/src/nsk/monitoring/share).
  *     Note, that the test is correct ONLY against Sun's Hotspot VM. This
  *     feature is optional and the method may return either true, or false.
@@ -50,6 +50,5 @@
  * @run main/othervm/timeout=300
  *      nsk.monitoring.CompilationMXBean.comptimemon001.comptimemon001
  *      -testMode=proxy
  *      -MBeanServer=custom
  */
-
diff a/test/jdk/ProblemList.txt b/test/jdk/ProblemList.txt
--- a/test/jdk/ProblemList.txt
+++ b/test/jdk/ProblemList.txt
@@ -857,10 +857,11 @@
 ############################################################################
 
 # core_tools
 
 tools/jlink/JLinkReproducibleTest.java                          8217166 windows-all
+tools/jlink/plugins/CompressorPluginTest.java                   8247407 generic-all
 
 ############################################################################
 
 # jdk_jdi
 
diff a/test/jdk/com/sun/crypto/provider/Mac/DigestCloneabilityTest.java b/test/jdk/com/sun/crypto/provider/Mac/DigestCloneabilityTest.java
--- /dev/null
+++ b/test/jdk/com/sun/crypto/provider/Mac/DigestCloneabilityTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8246077
+ * @summary Ensure a cloneable digest can be accepted/used by HmacCore
+ */
+import java.security.*;
+import java.security.spec.AlgorithmParameterSpec;
+import javax.crypto.*;
+import javax.crypto.spec.*;
+
+public class DigestCloneabilityTest {
+
+    private static String ALGO = "HmacSHA512";
+
+    public static void main(String[] args) throws Exception {
+        Provider p = new SampleProvider();
+        // make SampleProvider the most preferred, so its digest impl is picked
+        int status = Security.insertProviderAt(p, 1);
+        try {
+            Mac mac = Mac.getInstance(ALGO, "SunJCE");
+            // do a complete mac generation and check if the supplied
+            // digest is used
+            mac.init(new SecretKeySpec(new byte[512>>3], ALGO));
+            mac.update((byte)0x12);
+            byte[] macBytes = mac.doFinal();
+            if (!SampleProvider.CloneableDigest.isUsed) {
+                throw new RuntimeException("Expected Digest impl not used");
+            }
+        } finally {
+            if (status != -1) {
+                Security.removeProvider(p.getName());
+            }
+        }
+        System.out.println("Test Passed");
+    }
+
+    public static class SampleProvider extends Provider {
+
+        public SampleProvider() {
+            super("Sample", "1.0", "test provider");
+            putService(new Provider.Service(this, "MessageDigest", "SHA-512",
+                    "DigestCloneabilityTest$SampleProvider$CloneableDigest",
+                    null, null));
+        }
+        public static class CloneableDigest extends MessageDigestSpi
+                implements Cloneable {
+            private MessageDigest md;
+            static boolean isUsed = false;
+
+            public CloneableDigest() throws NoSuchAlgorithmException {
+                try {
+                    md = MessageDigest.getInstance("SHA-512", "SUN");
+                } catch (NoSuchProviderException nspe) {
+                    // should never happen
+                }
+            }
+
+            public byte[] engineDigest() {
+                isUsed = true;
+                return md.digest();
+            }
+
+            public void engineReset() {
+                isUsed = true;
+                md.reset();
+            }
+
+            public void engineUpdate(byte input) {
+                isUsed = true;
+                md.update(input);
+            }
+
+            public void engineUpdate(byte[] b, int ofs, int len) {
+                isUsed = true;
+                md.update(b, ofs, len);
+            }
+
+            public Object clone() throws CloneNotSupportedException {
+                return this;
+            }
+        }
+    }
+}
diff a/test/jdk/com/sun/net/httpserver/DateFormatterTest.java b/test/jdk/com/sun/net/httpserver/DateFormatterTest.java
--- /dev/null
+++ b/test/jdk/com/sun/net/httpserver/DateFormatterTest.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import com.sun.net.httpserver.HttpExchange;
+import com.sun.net.httpserver.HttpHandler;
+import com.sun.net.httpserver.HttpServer;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpResponse;
+import java.util.concurrent.Executors;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import jdk.test.lib.net.URIBuilder;
+import org.testng.annotations.AfterTest;
+import org.testng.annotations.BeforeTest;
+import org.testng.annotations.Test;
+import static java.net.http.HttpResponse.BodyHandlers.ofString;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+/**
+ * @test
+ * @bug 8245307
+ * @summary Test for DateFormatter in ExchangeImpl
+ * @modules java.net.http
+ * @library /test/lib
+ * @build DateFormatterTest
+ * @run testng/othervm DateFormatterTest
+ */
+public class DateFormatterTest {
+
+    private HttpServer server;
+
+    static URI httpURI;
+    static final Integer ITERATIONS = 10;
+    static String format;
+    static Pattern pattern;
+
+    @BeforeTest
+    public void setUp() throws IOException, URISyntaxException {
+        String days = "(Mon|Tue|Wed|Thu|Fri|Sat|Sun)(,)";
+        String dayNo = "(\\s\\d\\d\\s)";
+        String month = "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)";
+        String hour = "(\\s\\d\\d\\d\\d\\s\\d\\d)(:)(\\d\\d)(:)(\\d\\d\\s)";
+        String zone = "(GMT)";
+        format = days + dayNo + month + hour + zone;
+        pattern = Pattern.compile(format);
+        server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 10);
+        server.createContext("/server", new DateFormatHandler());
+        server.setExecutor(Executors.newCachedThreadPool());
+        httpURI = URIBuilder.newBuilder()
+                            .host(server.getAddress().getAddress())
+                            .port(server.getAddress().getPort())
+                            .scheme("http")
+                            .path("/server")
+                            .build();
+        server.start();
+    }
+
+    @AfterTest
+    public void cleanUp() {
+        server.stop(1);
+    }
+
+    @Test
+    public void testDateFormat() throws Exception {
+        HttpClient client = HttpClient.newBuilder()
+                                      .build();
+        HttpRequest request = HttpRequest.newBuilder(httpURI)
+                                         .GET()
+                                         .build();
+        for (int i = 0; i < ITERATIONS; i++) {
+            HttpResponse<String> response = client.send(request, ofString());
+            String date = response.headers().firstValue("Date").orElse("null");
+            if (date.equals("null"))
+                fail("Date not present");
+            Matcher matcher = pattern.matcher(date);
+            assertTrue(matcher.matches());
+        }
+    }
+
+    public static class DateFormatHandler implements HttpHandler {
+
+        @Override
+        public void handle(HttpExchange exchange) throws IOException {
+            try (InputStream is = exchange.getRequestBody();
+                OutputStream os = exchange.getResponseBody()) {
+                byte[] bytes = is.readAllBytes();
+                exchange.sendResponseHeaders(200, bytes.length);
+                os.write(bytes);
+            }
+        }
+    }
+}
diff a/test/jdk/java/awt/Graphics2D/LargeWindowPaintTest.java b/test/jdk/java/awt/Graphics2D/LargeWindowPaintTest.java
--- /dev/null
+++ b/test/jdk/java/awt/Graphics2D/LargeWindowPaintTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8240654
+ * @summary Test painting a large window works
+ * @key headful
+ * @requires (os.family == "windows")
+ * @requires vm.gc.Z
+ * @run main/othervm -Dsun.java2d.uiScale=1 LargeWindowPaintTest
+ * @run main/othervm -Dsun.java2d.uiScale=1 -Dsun.java2d.d3d=false LargeWindowPaintTest
+ * @run main/othervm -XX:+UseZGC -Dsun.java2d.uiScale=1 LargeWindowPaintTest
+ * @run main/othervm -XX:+UseZGC -Dsun.java2d.uiScale=1 -Dsun.java2d.d3d=false LargeWindowPaintTest
+ */
+
+import java.awt.Color;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.Rectangle;
+import java.awt.Robot;
+
+import javax.swing.JFrame;
+import javax.swing.JPanel;
+import javax.swing.SwingUtilities;
+import javax.swing.WindowConstants;
+
+public class LargeWindowPaintTest extends JPanel {
+
+    static volatile JFrame frame = null;
+    static volatile LargeWindowPaintTest comp = null;
+    static Color color = Color.red;
+
+    public static void main(String[] args) throws Exception {
+
+        SwingUtilities.invokeAndWait(() -> {
+            frame = new JFrame("Large Window Paint Test");
+            frame.add(comp = new LargeWindowPaintTest());
+            frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
+            frame.setExtendedState(Frame.MAXIMIZED_BOTH);
+            frame.setVisible(true);
+        });
+
+        Thread.sleep(2000);
+        Robot robot = new Robot();
+        robot.setAutoDelay(500);
+        robot.waitForIdle();
+        Rectangle r = comp.getBounds();
+        System.out.println("Component bounds = " + r);
+        Color c = robot.getPixelColor((int)r.getWidth()-100, (int)r.getHeight()-100);
+
+        SwingUtilities.invokeAndWait(() -> frame.dispose());
+
+        if (!c.equals(color)) {
+            throw new RuntimeException("Color was " + c + " expected " + color);
+        }
+    }
+
+    @Override
+    protected void paintComponent(Graphics g) {
+        super.paintComponent(g);
+        g.setColor(color);
+        g.fillRect(0, 0, getSize().width, getSize().height);
+    };
+}
diff a/test/jdk/java/awt/print/PrinterJob/AlphaPrintTest.java b/test/jdk/java/awt/print/PrinterJob/AlphaPrintTest.java
--- /dev/null
+++ b/test/jdk/java/awt/print/PrinterJob/AlphaPrintTest.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8240654
+ * @summary Test printing alpha colors - banded printing works with ZGC.
+ * @key headful printer
+ * @requires (os.family == "windows")
+ * @requires vm.gc.Z
+ * @run main/manual/othervm -XX:+UseZGC -Dsun.java2d.d3d=false AlphaPrintTest
+ */
+
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GridLayout;
+
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import java.awt.print.PageFormat;
+import java.awt.print.Printable;
+import java.awt.print.PrinterException;
+import java.awt.print.PrinterJob;
+
+import javax.swing.JButton;
+import javax.swing.JFrame;
+import javax.swing.JPanel;
+import javax.swing.JTextArea;
+import javax.swing.SwingUtilities;
+import javax.swing.WindowConstants;
+
+public class AlphaPrintTest extends JPanel implements Printable {
+
+    static final int W=400, H=600;
+
+    static volatile JFrame frame = null;
+    static volatile AlphaPrintTest comp = null;
+    static Color color = Color.red;
+    static volatile boolean passed = false;
+    static volatile boolean printInvoked = false;
+    static volatile boolean done = false;
+
+    public static void main(String[] args) throws Exception {
+
+        SwingUtilities.invokeAndWait(() -> {
+            frame = new JFrame("Alpha Color Print Test");
+            frame.setLayout(new GridLayout(1, 2));
+            frame.add(comp = new AlphaPrintTest());
+            frame.add(new InstructionPanel());
+            frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
+            frame.pack();
+            frame.setVisible(true);
+        });
+
+        while (!done || !printInvoked) {
+            Thread.sleep(1000);
+        }
+
+        SwingUtilities.invokeAndWait(() -> frame.dispose());
+
+        if (!passed) {
+            throw new RuntimeException("Test failed.");
+        }
+    }
+
+    @Override
+    public Dimension getPreferredSize() {
+        return new Dimension(W, H);
+    }
+
+
+    @Override
+    public Dimension getMinimumSize() {
+        return getPreferredSize();
+    }
+
+    @Override
+    protected void paintComponent(Graphics g) {
+        super.paintComponent(g);
+        paintContent(g);
+    };
+
+    private void paintContent(Graphics g) {
+        Color c = new Color(255, 0, 0, 240); // not a solid color.
+        g.setColor(c);
+        g.drawLine(0, 0, W, H);
+        g.drawLine(W, 0, 0, H);
+
+        for (int i=10; i < 150; i+=10) {
+            g.drawRect(i, i, W-(i*2), H-(i*2));
+        }
+        g.drawString("Alpha Paint Test", W/2-30, H/2);
+    }
+
+    public int print(Graphics g, PageFormat pf, int pageIndex) {
+        if (pageIndex == 0) {
+            Graphics2D g2d = (Graphics2D)g;
+            g2d.translate(pf.getImageableX(), pf.getImageableY());
+            paintContent(g);
+            return Printable.PAGE_EXISTS;
+        }
+        return Printable.NO_SUCH_PAGE;
+    }
+
+    public void doPrint() {
+        printInvoked = true;
+        PrinterJob pj = PrinterJob.getPrinterJob();
+        pj.setPrintable(this);
+        if (pj.printDialog()) {
+            try {
+                pj.print();
+            } catch (PrinterException e) {
+                e.printStackTrace();
+                done = true;
+            }
+        }
+    }
+
+    public void doClose(boolean pass) {
+        if (printInvoked) {
+            passed = pass;
+            done = true;
+        }
+    }
+}
+
+class  InstructionPanel extends JPanel implements ActionListener {
+
+    static final String INSTRUCTIONS =
+            "You must have a printer to peform this test.\n" +
+                    "Press the print button which will bring up a print dialog." +
+                    "Select a suitable printer, and confirm to print. " +
+                    "Examine the printed output. It should closely resemble the rendering in" +
+                    " the panel to the left. If yes, press PASS, else press FAIL";
+
+    InstructionPanel() {
+        GridLayout gl1 = new GridLayout(2, 1);
+        setLayout(gl1);
+        JTextArea ta = new JTextArea(INSTRUCTIONS);
+        ta.setEditable(false);
+        ta.setLineWrap(true);
+        ta.setWrapStyleWord(true);
+        add(ta);
+        JPanel p = new JPanel();
+        JButton print = new JButton("Print");
+        JButton pass = new JButton("PASS");
+        JButton fail = new JButton("FAIL");
+        print.addActionListener(this);
+        pass.addActionListener(this);
+        fail.addActionListener(this);
+        p.add(print);
+        p.add(pass);
+        p.add(fail);
+        add(p);
+    }
+    @Override
+    public Dimension getPreferredSize() {
+        return new Dimension(200, 600);
+    }
+
+
+    @Override
+    public Dimension getMinimumSize() {
+        return getPreferredSize();
+    }
+    public void actionPerformed(ActionEvent e) {
+        String cmd = e.getActionCommand();
+        switch (cmd) {
+            case "Print" -> AlphaPrintTest.comp.doPrint();
+            case "PASS" -> AlphaPrintTest.comp.doClose(true);
+            case "FAIL" -> AlphaPrintTest.comp.doClose(false);
+        }
+
+    }
+
+}
diff a/test/jdk/java/net/DatagramSocket/UnreferencedDatagramSockets.java b/test/jdk/java/net/DatagramSocket/UnreferencedDatagramSockets.java
--- a/test/jdk/java/net/DatagramSocket/UnreferencedDatagramSockets.java
+++ b/test/jdk/java/net/DatagramSocket/UnreferencedDatagramSockets.java
@@ -23,11 +23,11 @@
 
 /**
  * @test
  * @library /test/lib
  * @modules java.management java.base/java.io:+open java.base/java.net:+open
- *          java.base/sun.net
+ *          java.base/sun.net java.base/sun.nio.ch:+open
  * @run main/othervm UnreferencedDatagramSockets
  * @run main/othervm -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets
  * @run main/othervm -Djdk.net.usePlainDatagramSocketImpl UnreferencedDatagramSockets
  * @summary Check that unreferenced datagram sockets are closed
  */
diff a/test/jdk/java/net/MulticastSocket/UnreferencedMulticastSockets.java b/test/jdk/java/net/MulticastSocket/UnreferencedMulticastSockets.java
--- a/test/jdk/java/net/MulticastSocket/UnreferencedMulticastSockets.java
+++ b/test/jdk/java/net/MulticastSocket/UnreferencedMulticastSockets.java
@@ -23,11 +23,11 @@
 
 /**
  * @test
  * @library /test/lib
  * @modules java.management java.base/java.io:+open java.base/java.net:+open
- *          java.base/sun.net
+ *          java.base/sun.net java.base/sun.nio.ch:+open
  * @run main/othervm -Djava.net.preferIPv4Stack=true UnreferencedMulticastSockets
  * @run main/othervm -Djdk.net.usePlainDatagramSocketImpl UnreferencedMulticastSockets
  * @run main/othervm UnreferencedMulticastSockets
  * @summary Check that unreferenced multicast sockets are closed
  */
diff a/test/jdk/java/nio/channels/etc/OpenAndConnect.java b/test/jdk/java/nio/channels/etc/OpenAndConnect.java
--- a/test/jdk/java/nio/channels/etc/OpenAndConnect.java
+++ b/test/jdk/java/nio/channels/etc/OpenAndConnect.java
@@ -92,16 +92,27 @@
     }
 
     @DataProvider(name = "openConnect")
     public Object[][] openConnect() {
         LinkedList<Object[]>  l = new LinkedList<>();
-        l.addAll(openConnectGenTests);
-        if (IA4LOCAL != null) {
-            l.addAll(openConnectV4LocalTests);
+        if (IPSupport.hasIPv4()) {
+            l.addAll(openConnectV4Tests);
+            if (IA4LOCAL != null) {
+                l.addAll(openConnectV4LocalTests);
+            }
         }
-        if (IA6LOCAL != null) {
-            l.addAll(openConnectV6LocalTests);
+        if (IPSupport.hasIPv6()) {
+            l.addAll(openConnectV6Tests);
+            if (IA6LOCAL != null) {
+                l.addAll(openConnectV6LocalTests);
+            }
+        }
+        if (IPSupport.hasIPv4() && IPSupport.hasIPv6()) {
+            l.addAll(openConnectV4AndV6Tests);
+            if (IA4LOCAL != null) {
+                l.addAll(openConnectV4LocalAndV6Tests);
+            }
         }
         return l.toArray(new Object[][]{});
     }
 
     //            +----- sfam is server/first socket family
@@ -120,76 +131,90 @@
     //            |       |              |        |
     //            |       |              |        |
     //            +       +              +        +
     //      {   sfam,   saddr,         cfam,    caddr,      }
 
-    public static List<Object[]> openConnectGenTests =
+    // Basic tests for when an IPv4 is available
+    public static List<Object[]> openConnectV4Tests =
         Arrays.asList(new Object[][] {
             {   INET,   IA4LOOPBACK,   INET,    IA4LOOPBACK },
             {   INET,   IA4LOOPBACK,   null,    IA4LOOPBACK },
             {   INET,   IA4ANYLOCAL,   null,    IA4LOOPBACK },
             {   INET,   IA4ANYLOCAL,   INET,    IA4LOOPBACK },
-            {   INET6,  IA6ANYLOCAL,   null,    IA6LOOPBACK },
-            {   INET6,  IA6ANYLOCAL,   INET6,   IA6LOOPBACK },
-            {   INET6,  IA6LOOPBACK,   INET6,   IA6LOOPBACK },
             {   null,   IA4LOOPBACK,   INET,    IA4ANYLOCAL },
             {   null,   IA4LOOPBACK,   INET,    IA4LOOPBACK },
             {   null,   IA4LOOPBACK,   INET,    null        },
-            {   null,   IA4LOOPBACK,   INET6,   IA6ANYLOCAL },
-            {   null,   IA6LOOPBACK,   INET6,   IA6ANYLOCAL },
-            {   null,   IA6LOOPBACK,   INET6,   IA6LOOPBACK },
-            {   null,   IA6LOOPBACK,   INET6,   DONT_BIND   },
-            {   null,   IA4LOOPBACK,   INET6,   DONT_BIND   },
-            {   null,   IA4LOOPBACK,   INET6,   null        },
-            {   null,   IA6LOOPBACK,   INET6,   null        },
-            {   null,   IA4LOOPBACK,   null,    IA6ANYLOCAL },
-            {   null,   IA6LOOPBACK,   null,    IA6ANYLOCAL },
-            {   null,   IA6LOOPBACK,   null,    IA6LOOPBACK },
-            {   null,   IA4LOOPBACK,   null,    null        },
-            {   null,   IA6LOOPBACK,   null,    null        },
-            {   null,   IA6ANYLOCAL,   null,    IA6LOCAL    },
-            {   null,   IA6ANYLOCAL,   null,    IA6LOOPBACK },
-            {   null,   IA6ANYLOCAL,   INET6,   IA6LOCAL    },
-            {   null,   IA6ANYLOCAL,   INET6,   IA6LOOPBACK },
-            {   INET6,  IA6LOOPBACK,   INET6,   IA6LOOPBACK }
+            {   null,   IA4LOOPBACK,   null,    null        }
         });
 
-    // Additional tests for when an IPv4 local address or V6
-    // local address is available
-
+    // Additional tests for when an IPv4 local address is available
     public List<Object[]>  openConnectV4LocalTests =
         Arrays.asList(new Object[][] {
             {   INET,   IA4LOCAL,      INET,    IA4LOCAL    },
             {   INET,   IA4LOCAL,      null,    IA4LOCAL    },
             {   INET,   IA4LOCAL,      null,    DONT_BIND   },
             {   INET,   IA4ANYLOCAL,   INET,    IA4LOCAL    },
             {   INET,   IA4ANYLOCAL,   null,    IA4LOCAL    },
             {   null,   IA4LOCAL,      INET,    IA4ANYLOCAL },
             {   null,   IA4LOCAL,      INET,    IA4LOCAL    },
             {   null,   IA4LOCAL,      INET,    null        },
-            {   null,   IA4LOCAL,      INET6,   IA6ANYLOCAL },
-            {   null,   IA4LOCAL,      INET6,   null        },
-            {   null,   IA4LOCAL,      null,    IA6ANYLOCAL }
+            {   null,   IA4LOCAL,      null,    null        }
+        });
+
+    // Basic tests for when an IPv6 is available
+    public List<Object[]> openConnectV6Tests =
+        Arrays.asList(new Object[][] {
+            {   INET6,  IA6ANYLOCAL,   null,    IA6LOOPBACK },
+            {   INET6,  IA6ANYLOCAL,   INET6,   IA6LOOPBACK },
+            {   INET6,  IA6LOOPBACK,   INET6,   IA6LOOPBACK },
+            {   INET6,  IA6LOOPBACK,   INET6,   IA6LOOPBACK },
+            {   null,   IA6ANYLOCAL,   null,    IA6LOOPBACK },
+            {   null,   IA6ANYLOCAL,   INET6,   IA6LOOPBACK },
+            {   null,   IA6LOOPBACK,   INET6,   IA6LOOPBACK },
+            {   null,   IA6LOOPBACK,   INET6,   DONT_BIND   },
+            {   null,   IA6LOOPBACK,   INET6,   null        },
+            {   null,   IA6LOOPBACK,   null,    IA6LOOPBACK },
+            {   null,   IA6LOOPBACK,   null,    null        },
+            {   null,   IA6LOOPBACK,   INET6,   IA6ANYLOCAL },
+            {   null,   IA6LOOPBACK,   null,    IA6ANYLOCAL }
         });
 
+    // Additional tests for when an IPv6 local address is available
     public List<Object[]> openConnectV6LocalTests =
         Arrays.asList(new Object[][] {
             {   INET6,  IA6ANYLOCAL,   null,    IA6LOCAL    },
             {   INET6,  IA6ANYLOCAL,   INET6,   IA6LOCAL    },
             {   INET6,  IA6LOCAL,      INET6,   IA6LOCAL    },
             {   INET6,  IA6LOCAL,      null,    IA6LOCAL    },
             {   INET6,  IA6LOCAL,      null,    DONT_BIND   },
+            {   INET6,  IA6LOCAL,      INET6,   IA6LOCAL    },
+            {   null,   IA6ANYLOCAL,   null,    IA6LOCAL    },
+            {   null,   IA6ANYLOCAL,   INET6,   IA6LOCAL    },
             {   null,   IA6LOCAL,      INET6,   IA6LOCAL    },
             {   null,   IA6LOCAL,      INET6,   IA6ANYLOCAL },
             {   null,   IA6LOCAL,      null,    IA6ANYLOCAL },
             {   null,   IA6LOCAL,      null,    IA6LOCAL    },
             {   null,   IA6LOCAL,      INET6,   null        },
-            {   null,   IA6LOCAL,      null,    null        },
-            {   null,   IA4LOCAL,      null,    null        },
-            {   INET6,  IA6LOCAL,      INET6,   IA6LOCAL    }
+            {   null,   IA6LOCAL,      null,    null        }
+        });
+
+    // Additional tests for when IPv4 and IPv6 are available
+     public List<Object[]> openConnectV4AndV6Tests =
+        Arrays.asList(new Object[][] {
+            {   null,   IA4LOOPBACK,   INET6,   IA6ANYLOCAL },
+            {   null,   IA4LOOPBACK,   null,    IA6ANYLOCAL },
+            {   null,   IA4LOOPBACK,   INET6,   DONT_BIND   },
+            {   null,   IA4LOOPBACK,   INET6,   null        }
         });
 
+    // Additional tests for when IPv4 local address and IPv6 are available
+    public List<Object[]> openConnectV4LocalAndV6Tests =
+        Arrays.asList(new Object[][] {
+            {   null,   IA4LOCAL,      INET6,   IA6ANYLOCAL },
+            {   null,   IA4LOCAL,      INET6,   null        },
+            {   null,   IA4LOCAL,      null,    IA6ANYLOCAL }
+        });
 
     /**
      * If the destination address is the wildcard, it is replaced by the alternate
      * using the port number from destination. Otherwise destination is returned.
      * Only used by dcOpenAndConnect
diff a/test/jdk/java/security/KeyStore/OneProbeOneNot.java b/test/jdk/java/security/KeyStore/OneProbeOneNot.java
--- /dev/null
+++ b/test/jdk/java/security/KeyStore/OneProbeOneNot.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8245679
+ * @summary KeyStore cannot probe PKCS12 keystore if BouncyCastle is the top security provider
+ * @run main/othervm OneProbeOneNot
+ */
+
+import java.io.File;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.security.*;
+import java.security.cert.Certificate;
+import java.util.Date;
+import java.util.Enumeration;
+
+public class OneProbeOneNot {
+    public static final void main(String[] args) throws Exception {
+        Files.write(Path.of("ks"), "".getBytes());
+        // 1st provider do not support probe
+        Security.insertProviderAt(new P1(), 1);
+        // 2nd provider support probe
+        Security.insertProviderAt(new P2(), 2);
+        KeyStore ks = KeyStore.getInstance(new File("ks"), (char[])null);
+        System.out.println(ks.getProvider().getName());
+        System.out.println(ks.getType());
+    }
+
+    public static class P1 extends Provider {
+        public P1() {
+            super("P1", "P1", "P1");
+            putService(new Service(this, "KeyStore", "Oops",
+                    K1.class.getName(), null, null));
+        }
+    }
+    public static class P2 extends Provider {
+        public P2() {
+            super("P2", "P2", "P2");
+            putService(new Service(this, "KeyStore", "Oops",
+                    K2.class.getName(), null, null));
+        }
+    }
+
+    public static class K1 extends KeyStoreSpi {
+        public Key engineGetKey(String a, char[] p) { return null; }
+        public Certificate[] engineGetCertificateChain(String a) { return null; }
+        public Certificate engineGetCertificate(String a) { return null; }
+        public Date engineGetCreationDate(String a) { return null; }
+        public void engineSetKeyEntry(String a, Key k, char[] p, Certificate[] c) { }
+        public void engineSetKeyEntry(String a, byte[] k, Certificate[] c) { }
+        public void engineSetCertificateEntry(String a, Certificate c) { }
+        public void engineDeleteEntry(String a) { }
+        public Enumeration<String> engineAliases() { return null; }
+        public boolean engineContainsAlias(String a) { return false; }
+        public int engineSize() { return 0; }
+        public boolean engineIsKeyEntry(String a) { return false; }
+        public boolean engineIsCertificateEntry(String a) { return false; }
+        public String engineGetCertificateAlias(Certificate c) { return null; }
+        public void engineStore(OutputStream stream, char[] password) { }
+        public void engineLoad(InputStream stream, char[] password) { }
+    }
+
+    public static class K2 extends K1 {
+        public boolean engineProbe(InputStream s) {
+            return true;
+        }
+    }
+}
diff a/test/jdk/java/security/MessageDigest/TestCloneable.java b/test/jdk/java/security/MessageDigest/TestCloneable.java
--- /dev/null
+++ b/test/jdk/java/security/MessageDigest/TestCloneable.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8246077
+ * @summary Make sure that digest spi and the resulting digest impl are
+ * consistent in the impl of Cloneable interface
+ * @run testng TestCloneable
+ */
+import java.security.*;
+import java.util.Objects;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+import org.testng.Assert;
+
+public class TestCloneable {
+
+    private static final Class<CloneNotSupportedException> CNSE =
+            CloneNotSupportedException.class;
+
+    @DataProvider
+    public Object[][] testData() {
+        return new Object[][] {
+            { "MD2", "SUN" }, { "MD5", "SUN" }, { "SHA-1", "SUN" },
+            { "SHA-224", "SUN" }, { "SHA-256", "SUN" },
+            { "SHA-384", "SUN" }, { "SHA-512", "SUN" },
+            { "SHA3-224", "SUN" }, { "SHA3-256", "SUN" },
+            { "SHA3-384", "SUN" }, { "SHA3-512", "SUN" }
+        };
+    }
+
+    @Test(dataProvider = "testData")
+    public void test(String algo, String provName)
+            throws NoSuchProviderException, NoSuchAlgorithmException,
+            CloneNotSupportedException {
+        System.out.print("Testing " + algo + " impl from " + provName);
+        Provider p = Security.getProvider(provName);
+        Provider.Service s = p.getService("MessageDigest", algo);
+        Objects.requireNonNull(s);
+        MessageDigestSpi spi = (MessageDigestSpi) s.newInstance(null);
+        MessageDigest md = MessageDigest.getInstance(algo, provName);
+        if (spi instanceof Cloneable) {
+            System.out.println(": Cloneable");
+            Assert.assertTrue(md instanceof Cloneable);
+            MessageDigest md2 = (MessageDigest) md.clone();
+            Assert.assertEquals(md2.getAlgorithm(), algo);
+            Assert.assertEquals(md2.getProvider().getName(), provName);
+            Assert.assertTrue(md2 instanceof Cloneable);
+        } else {
+            System.out.println(": NOT Cloneable");
+            Assert.assertThrows(CNSE, ()->md.clone());
+        }
+        System.out.println("Test Passed");
+    }
+}
diff a/test/jdk/java/security/SecureRandom/DefaultAlgo.java b/test/jdk/java/security/SecureRandom/DefaultAlgo.java
--- a/test/jdk/java/security/SecureRandom/DefaultAlgo.java
+++ b/test/jdk/java/security/SecureRandom/DefaultAlgo.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,35 +20,98 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 import static java.lang.System.out;
+import java.security.Provider;
+import java.security.Security;
 import java.security.SecureRandom;
+import java.security.Provider.Service;
+import java.util.Objects;
+import java.util.Arrays;
 import sun.security.provider.SunEntries;
 
 /**
  * @test
- * @bug 8228613
- * @summary Ensure that the default SecureRandom algo matches
- *     SunEntries.DEF_SECURE_RANDOM_ALGO when SUN provider is used
+ * @bug 8228613 8246613
+ * @summary Ensure that the default SecureRandom algo used is based
+ *     on the registration ordering, and falls to next provider
+ *     if none are found
  * @modules java.base/sun.security.provider
  */
 public class DefaultAlgo {
 
     public static void main(String[] args) throws Exception {
-        SecureRandom sr = new SecureRandom();
-        String actualAlg = sr.getAlgorithm();
-        out.println("Default SecureRandom algo: " + actualAlg);
-        if (sr.getProvider().getName().equals("SUN")) {
-            // when using Sun provider, compare and check if the algorithm
-            // matches SunEntries.DEF_SECURE_RANDOM_ALGO
-            if (actualAlg.equals(SunEntries.DEF_SECURE_RANDOM_ALGO)) {
-                out.println("Test Passed");
-            } else {
-                throw new RuntimeException("Failed: Expected " +
+        String[] algos = { "A", "B", "C" };
+        test3rdParty(algos);
+        // reverse the order and re-check
+        String[] algosReversed = { "C", "B", "A" };
+        test3rdParty(algosReversed);
+    }
+
+    private static void test3rdParty(String[] algos) {
+        Provider[] provs = {
+            new SampleLegacyProvider(algos),
+            new SampleServiceProvider(algos)
+        };
+        for (Provider p : provs) {
+            checkDefault(p, algos);
+        }
+    }
+
+    // validate the specified SecureRandom obj to be from the specified
+    // provider and matches the specified algorithm
+    private static void validate(SecureRandom sr, String pName, String algo) {
+        if (!sr.getProvider().getName().equals(pName)) {
+            throw new RuntimeException("Failed provider check, exp: " +
+                    pName + ", got " + sr.getProvider().getName());
+        }
+        if (!sr.getAlgorithm().equals(algo)) {
+            throw new RuntimeException("Failed algo check, exp: " +
+                    algo + ", got " + sr.getAlgorithm());
+        }
+    }
+
+    private static void checkDefault(Provider p, String ... algos) {
+        out.println(p.getName() + " with " + Arrays.toString(algos));
+        int pos = Security.insertProviderAt(p, 1);
+        String pName = p.getName();
+        boolean isLegacy = pName.equals("SampleLegacy");
+        try {
+            if (isLegacy) {
+                for (String s : algos) {
+                    validate(new SecureRandom(), pName, s);
+                    p.remove("SecureRandom." + s);
+                    out.println("removed "  + s);
+                }
+                validate(new SecureRandom(), "SUN",
                         SunEntries.DEF_SECURE_RANDOM_ALGO);
+            } else {
+                validate(new SecureRandom(), pName, algos[0]);
+            }
+            out.println("=> Test Passed");
+        } finally {
+            if (pos != -1) {
+                Security.removeProvider(p.getName());
+            }
+        }
+    }
+
+    private static class SampleLegacyProvider extends Provider {
+        SampleLegacyProvider(String[] listOfSupportedRNGs) {
+            super("SampleLegacy", "1.0", "test provider using legacy put");
+            for (String s : listOfSupportedRNGs) {
+                put("SecureRandom." + s, "sun.security.provider.SecureRandom");
+            }
+        }
+    }
+
+    private static class SampleServiceProvider extends Provider {
+        SampleServiceProvider(String[] listOfSupportedRNGs) {
+            super("SampleService", "1.0", "test provider using putService");
+            for (String s : listOfSupportedRNGs) {
+                putService(new Provider.Service(this, "SecureRandom", s,
+                        "sun.security.provider.SecureRandom", null, null));
             }
-        } else {
-            out.println("Skip test for non-Sun provider: " + sr.getProvider());
         }
     }
 }
diff a/test/jdk/java/security/Signature/TestCloneable.java b/test/jdk/java/security/Signature/TestCloneable.java
--- /dev/null
+++ b/test/jdk/java/security/Signature/TestCloneable.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8246077
+ * @summary Make sure that signature objects which are cloneable
+ *         implement the Cloneable interface
+ * @run testng TestCloneable
+ */
+import java.security.NoSuchProviderException;
+import java.security.NoSuchAlgorithmException;
+import java.security.Signature;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+import org.testng.Assert;
+
+public class TestCloneable {
+
+    private static final Class<CloneNotSupportedException> CNSE =
+            CloneNotSupportedException.class;
+
+    @DataProvider
+    public Object[][] testData() {
+        return new Object[][] {
+            { "SHA1withDSA", "SUN" }, { "NONEwithDSA", "SUN" },
+            { "SHA224withDSA", "SUN" }, { "SHA256withDSA", "SUN" },
+            { "EdDSA", "SunEC" }, { "Ed25519", "SunEC" }, { "Ed448", "SunEC" },
+            { "SHA1withECDSA", "SunEC" }, { "SHA224withECDSA", "SunEC" },
+            { "SHA256withECDSA", "SunEC" }, { "SHA384withECDSA", "SunEC" },
+            { "SHA512withECDSA", "SunEC" }, { "NONEwithECDSA", "SunEC" },
+            { "MD2withRSA", "SunRsaSign" }, { "MD5withRSA", "SunRsaSign" },
+            { "SHA1withRSA", "SunRsaSign" }, { "SHA224withRSA", "SunRsaSign" },
+            { "SHA256withRSA", "SunRsaSign" },
+            { "SHA384withRSA", "SunRsaSign" },
+            { "SHA512withRSA", "SunRsaSign" },
+            { "SHA512/224withRSA", "SunRsaSign" },
+            { "SHA512/256withRSA", "SunRsaSign" },
+            { "RSASSA-PSS", "SunRsaSign" },
+            { "NONEwithRSA", "SunMSCAPI" },
+            { "SHA1withRSA", "SunMSCAPI" }, { "SHA256withRSA", "SunMSCAPI" },
+            { "SHA384withRSA", "SunMSCAPI" }, { "SHA512withRSA", "SunMSCAPI" },
+            { "RSASSA-PSS", "SunMSCAPI" },
+            { "MD5withRSA", "SunMSCAPI" }, { "MD2withRSA", "SunMSCAPI" },
+            { "SHA1withECDSA", "SunMSCAPI" },
+            { "SHA224withECDSA", "SunMSCAPI" },
+            { "SHA256withECDSA", "SunMSCAPI" },
+            { "SHA384withECDSA", "SunMSCAPI" },
+            { "SHA512withECDSA", "SunMSCAPI" }
+        };
+    }
+
+    @Test(dataProvider = "testData")
+    public void test(String algo, String provName)
+            throws NoSuchAlgorithmException, CloneNotSupportedException {
+        System.out.print("Testing " + algo + " impl from " + provName);
+        try {
+            Signature sig = Signature.getInstance(algo, provName);
+            if (sig instanceof Cloneable) {
+                System.out.println(": Cloneable");
+                Signature sig2 = (Signature) sig.clone();
+                Assert.assertEquals(sig2.getAlgorithm(), algo);
+                Assert.assertEquals(sig2.getProvider().getName(), provName);
+                Assert.assertTrue(sig2 instanceof Cloneable);
+            } else {
+                System.out.println(": NOT Cloneable");
+                Assert.assertThrows(CNSE, ()->sig.clone());
+            }
+            System.out.println("Test Passed");
+        } catch (NoSuchProviderException nspe) {
+            // skip testing
+            System.out.println("Skip " + provName + " - not available");
+        }
+    }
+}
diff a/test/jdk/java/time/tck/java/time/TCKYear.java b/test/jdk/java/time/tck/java/time/TCKYear.java
--- a/test/jdk/java/time/tck/java/time/TCKYear.java
+++ b/test/jdk/java/time/tck/java/time/TCKYear.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -246,14 +246,36 @@
     // parse()
     //-----------------------------------------------------------------------
     @DataProvider(name="goodParseData")
     Object[][] provider_goodParseData() {
         return new Object[][] {
-                {"0000", Year.of(0)},
                 {"9999", Year.of(9999)},
                 {"2000", Year.of(2000)},
 
+                {"0", Year.of(0)},
+                {"00", Year.of(0)},
+                {"000", Year.of(0)},
+                {"0000", Year.of(0)},
+                {"00000", Year.of(0)},
+                {"+00000", Year.of(0)},
+                {"-0", Year.of(0)},
+                {"-00", Year.of(0)},
+                {"-000", Year.of(0)},
+                {"-0000", Year.of(0)},
+                {"-00000", Year.of(0)},
+                {"1", Year.of(1)},
+                {"01", Year.of(1)},
+                {"001", Year.of(1)},
+                {"0001", Year.of(1)},
+                {"00001", Year.of(1)},
+                {"+00001", Year.of(1)},
+                {"-1", Year.of(-1)},
+                {"-01", Year.of(-1)},
+                {"-001", Year.of(-1)},
+                {"-0001", Year.of(-1)},
+                {"-00001", Year.of(-1)},
+
                 {"+12345678", Year.of(12345678)},
                 {"+123456", Year.of(123456)},
                 {"-1234", Year.of(-1234)},
                 {"-12345678", Year.of(-12345678)},
 
@@ -270,24 +292,22 @@
 
     @DataProvider(name="badParseData")
     Object[][] provider_badParseData() {
         return new Object[][] {
                 {"", 0},
-                {"-00", 1},
                 {"--01-0", 1},
                 {"A01", 0},
-                {"200", 0},
                 {"2009/12", 4},
 
-                {"-0000-10", 0},
-                {"-12345678901-10", 11},
-                {"+1-10", 1},
-                {"+12-10", 1},
-                {"+123-10", 1},
-                {"+1234-10", 0},
-                {"12345-10", 0},
-                {"+12345678901-10", 11},
+                {"-0000-10", 5},
+                {"-12345678901-10", 10},
+                {"+1-10", 2},
+                {"+12-10", 3},
+                {"+123-10", 4},
+                {"+1234-10", 5},
+                {"12345-10", 5},
+                {"+12345678901-10", 10},
         };
     }
 
     @Test(dataProvider="badParseData", expectedExceptions=DateTimeParseException.class)
     public void factory_parse_fail(String text, int pos) {
diff a/test/jdk/javax/management/MBeanServer/OldMBeanServerTest.java b/test/jdk/javax/management/MBeanServer/OldMBeanServerTest.java
--- a/test/jdk/javax/management/MBeanServer/OldMBeanServerTest.java
+++ b/test/jdk/javax/management/MBeanServer/OldMBeanServerTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -90,15 +90,18 @@
 import javax.management.remote.JMXConnectorFactory;
 import javax.management.remote.JMXConnectorServer;
 import javax.management.remote.JMXConnectorServerFactory;
 import javax.management.remote.JMXServiceURL;
 
+import jdk.test.lib.Utils;
+
 /*
  * @test OldMBeanServerTest.java
  * @bug 5072268
  * @summary Test that nothing assumes a post-1.2 MBeanServer
  * @author Eamonn McManus
+ * @library /test/lib
  * @modules java.management.rmi
  * @run main/othervm -ea OldMBeanServerTest
  */
 
 /*
@@ -276,11 +279,11 @@
             if (h == null)
                 h = 1;
             count += (Integer) h;
         }
         void waitForCount(int expect) throws InterruptedException {
-            long deadline = System.currentTimeMillis() + 2000L;
+            long deadline = System.currentTimeMillis() + Utils.adjustTimeout(2000);
             while (count < expect && System.currentTimeMillis() < deadline)
                 Thread.sleep(1);
             assert count == expect;
         }
     }
diff a/test/jdk/javax/net/ssl/SSLEngine/IllegalHandshakeMessage.java b/test/jdk/javax/net/ssl/SSLEngine/IllegalHandshakeMessage.java
--- a/test/jdk/javax/net/ssl/SSLEngine/IllegalHandshakeMessage.java
+++ b/test/jdk/javax/net/ssl/SSLEngine/IllegalHandshakeMessage.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -68,11 +68,11 @@
         if (cliToSrv.limit() > 7) {
             cliToSrv.put(5, (byte)0xAB);    // use illegal handshake type
             cliToSrv.put(7, (byte)0x80);    // use illegal message length
         } else {
             // unlikely
-            throw new Exception("No handshage message generated.");
+            throw new Exception("No handshake message is generated.");
         }
 
         try {
             SSLEngineResult srvRes = srvEngine.unwrap(cliToSrv, srvIBuff);
             System.out.println("Server unwrap result: " + srvRes);
diff a/test/jdk/lib/testlibrary/OutputAnalyzerTest.java b/test/jdk/lib/testlibrary/OutputAnalyzerTest.java
--- a/test/jdk/lib/testlibrary/OutputAnalyzerTest.java
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @summary Test the OutputAnalyzer utility class
- * @modules java.management
- * @library /test/lib
- * @run main OutputAnalyzerTest
- */
-
-import jdk.test.lib.process.OutputAnalyzer;
-
-public class OutputAnalyzerTest {
-
-    public static void main(String args[]) throws Exception {
-
-        String stdout = "aaaaaa";
-        String stderr = "bbbbbb";
-        String nonExistingString = "cccc";
-
-        OutputAnalyzer output = new OutputAnalyzer(stdout, stderr);
-
-        if (!stdout.equals(output.getStdout())) {
-            throw new Exception("getStdout() returned '" + output.getStdout()
-                    + "', expected '" + stdout + "'");
-        }
-
-        if (!stderr.equals(output.getStderr())) {
-            throw new Exception("getStderr() returned '" + output.getStderr()
-                    + "', expected '" + stderr + "'");
-        }
-
-        try {
-            output.shouldContain(stdout);
-            output.stdoutShouldContain(stdout);
-            output.shouldContain(stderr);
-            output.stderrShouldContain(stderr);
-        } catch (RuntimeException e) {
-            throw new Exception("shouldContain() failed", e);
-        }
-
-        try {
-            output.shouldContain(nonExistingString);
-            throw new Exception("shouldContain() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.stdoutShouldContain(stderr);
-            throw new Exception(
-                    "stdoutShouldContain() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.stderrShouldContain(stdout);
-            throw new Exception(
-                    "stdoutShouldContain() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.shouldNotContain(nonExistingString);
-            output.stdoutShouldNotContain(nonExistingString);
-            output.stderrShouldNotContain(nonExistingString);
-        } catch (RuntimeException e) {
-            throw new Exception("shouldNotContain() failed", e);
-        }
-
-        try {
-            output.shouldNotContain(stdout);
-            throw new Exception("shouldContain() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.stdoutShouldNotContain(stdout);
-            throw new Exception("shouldContain() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.stderrShouldNotContain(stderr);
-            throw new Exception("shouldContain() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        String stdoutPattern = "[a]";
-        String stdoutByLinePattern = "a*";
-        String stderrPattern = "[b]";
-        String nonExistingPattern = "[c]";
-        String byLinePattern = "[ab]*";
-
-        // Should match
-        try {
-            output.shouldMatch(stdoutPattern);
-            output.stdoutShouldMatch(stdoutPattern);
-            output.shouldMatch(stderrPattern);
-            output.stderrShouldMatch(stderrPattern);
-        } catch (RuntimeException e) {
-            throw new Exception("shouldMatch() failed", e);
-        }
-
-        try {
-            output.shouldMatch(nonExistingPattern);
-            throw new Exception("shouldMatch() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.stdoutShouldMatch(stderrPattern);
-            throw new Exception(
-                    "stdoutShouldMatch() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.stderrShouldMatch(stdoutPattern);
-            throw new Exception(
-                    "stderrShouldMatch() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.shouldMatchByLine(byLinePattern);
-        } catch (RuntimeException e) {
-            throw new Exception("shouldMatchByLine() failed", e);
-        }
-
-        try {
-            output.shouldMatchByLine(nonExistingPattern);
-            throw new Exception("shouldMatchByLine() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.stdoutShouldMatchByLine(stdoutByLinePattern);
-        } catch (RuntimeException e) {
-            throw new Exception("stdoutShouldMatchByLine() failed", e);
-        }
-
-        // Should not match
-        try {
-            output.shouldNotMatch(nonExistingPattern);
-            output.stdoutShouldNotMatch(nonExistingPattern);
-            output.stderrShouldNotMatch(nonExistingPattern);
-        } catch (RuntimeException e) {
-            throw new Exception("shouldNotMatch() failed", e);
-        }
-
-        try {
-            output.shouldNotMatch(stdoutPattern);
-            throw new Exception("shouldNotMatch() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.stdoutShouldNotMatch(stdoutPattern);
-            throw new Exception("shouldNotMatch() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-
-        try {
-            output.stderrShouldNotMatch(stderrPattern);
-            throw new Exception("shouldNotMatch() failed to throw exception");
-        } catch (RuntimeException e) {
-            // expected
-        }
-    }
-
-}
diff a/test/jdk/sun/management/jmxremote/bootstrap/rmiregistry.properties b/test/jdk/sun/management/jmxremote/bootstrap/rmiregistry.properties
--- a/test/jdk/sun/management/jmxremote/bootstrap/rmiregistry.properties
+++ b/test/jdk/sun/management/jmxremote/bootstrap/rmiregistry.properties
@@ -37,11 +37,11 @@
 #
 # com.sun.management.enableThreadContentionMonitoring
 #
 #      This option enables thread contention monitoring if the
 #      Java virtual machine supports such instrumentation.
-#      Refer to the specification for the java.lang.management.ThreadMBean
+#      Refer to the specification for the java.lang.management.ThreadMXBean
 #      interface - see isThreadContentionMonitoringSupported() method.
 #
 
 # To enable thread contention monitoring, uncomment the following line
 # com.sun.management.enableThreadContentionMonitoring
diff a/test/jdk/sun/management/jmxremote/bootstrap/rmiregistryssl.properties b/test/jdk/sun/management/jmxremote/bootstrap/rmiregistryssl.properties
--- a/test/jdk/sun/management/jmxremote/bootstrap/rmiregistryssl.properties
+++ b/test/jdk/sun/management/jmxremote/bootstrap/rmiregistryssl.properties
@@ -37,11 +37,11 @@
 #
 # com.sun.management.enableThreadContentionMonitoring
 #
 #      This option enables thread contention monitoring if the
 #      Java virtual machine supports such instrumentation.
-#      Refer to the specification for the java.lang.management.ThreadMBean
+#      Refer to the specification for the java.lang.management.ThreadMXBean
 #      interface - see isThreadContentionMonitoringSupported() method.
 #
 
 # To enable thread contention monitoring, uncomment the following line
 # com.sun.management.enableThreadContentionMonitoring
diff a/test/jdk/tools/jpackage/macosx/base/SigningCheck.java b/test/jdk/tools/jpackage/macosx/base/SigningCheck.java
--- a/test/jdk/tools/jpackage/macosx/base/SigningCheck.java
+++ b/test/jdk/tools/jpackage/macosx/base/SigningCheck.java
@@ -82,18 +82,23 @@
 
         TKit.throwSkippedException("Cannot find required certifciates: " + key);
     }
 
     private static void validateCertificateTrust(String name) {
-        List<String> result = new Executor()
-                .setExecutable("security")
-                .addArguments("dump-trust-settings")
-                .executeWithoutExitCodeCheckAndGetOutput();
-        result.stream().forEachOrdered(TKit::trace);
-        TKit.assertTextStream(name)
-                .predicate((line, what) -> line.trim().endsWith(what))
-                .orElseThrow(() -> TKit.throwSkippedException(
-                        "Certifcate not trusted by current user: " + name))
-                .apply(result.stream());
+        // Certificates using the default user name must be trusted by user.
+        // User supplied certs whose trust is set to "Use System Defaults"
+        // will not be listed as trusted by dump-trust-settings
+        if (SigningBase.DEV_NAME.equals("jpackage.openjdk.java.net")) {
+            List<String> result = new Executor()
+                    .setExecutable("security")
+                    .addArguments("dump-trust-settings")
+                    .executeWithoutExitCodeCheckAndGetOutput();
+            result.stream().forEachOrdered(TKit::trace);
+            TKit.assertTextStream(name)
+                    .predicate((line, what) -> line.trim().endsWith(what))
+                    .orElseThrow(() -> TKit.throwSkippedException(
+                            "Certifcate not trusted by current user: " + name))
+                    .apply(result.stream());
+        }
     }
 
 }
diff a/test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java b/test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java
--- a/test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java
+++ b/test/jdk/tools/jpackage/share/jdk/jpackage/tests/BasicTest.java
@@ -301,63 +301,10 @@
         // Verify output of jpackage command.
         cmd.assertImageCreated();
         HelloApp.executeLauncherAndVerifyOutput(cmd);
     }
 
-    @Parameter("Hello")
-    @Parameter("com.foo/com.foo.main.Aloha")
-    @Test
-    public void testJLinkRuntime(String javaAppDesc) throws IOException {
-        JavaAppDesc appDesc = JavaAppDesc.parse(javaAppDesc);
-
-        JPackageCommand cmd = JPackageCommand.helloAppImage(appDesc);
-
-        final String moduleName = appDesc.moduleName();
-
-        if (moduleName != null) {
-            // Build module jar.
-            cmd.executePrerequisiteActions();
-        }
-
-        final Path runtimeDir = TKit.createTempDirectory("runtime").resolve("data");
-
-        // List of modules required for test app.
-        final var modules = new String[] {
-            "java.base",
-            "java.desktop"
-        };
-
-        Executor jlink = getToolProvider(JavaTool.JLINK)
-        .saveOutput(false)
-        .addArguments(
-                "--add-modules", String.join(",", modules),
-                "--output", runtimeDir.toString(),
-                "--strip-debug",
-                "--no-header-files",
-                "--no-man-pages");
-
-        TKit.trace("jlink output BEGIN");
-        try (Stream<Path> paths = Files.walk(runtimeDir)) {
-            paths.filter(Files::isRegularFile)
-                    .map(runtimeDir::relativize)
-                    .map(Path::toString)
-                    .forEach(TKit::trace);
-        }
-        TKit.trace("jlink output END");
-
-        if (moduleName != null) {
-            jlink.addArguments("--add-modules", moduleName, "--module-path",
-                    Path.of(cmd.getArgumentValue("--module-path")).resolve(
-                            "hello.jar").toString());
-        }
-
-        jlink.execute();
-
-        cmd.addArguments("--runtime-image", runtimeDir);
-        cmd.executeAndAssertHelloAppImageCreated();
-    }
-
     private static Executor getJPackageToolProvider() {
         return getToolProvider(JavaTool.JPACKAGE);
     }
 
     private static Executor getToolProvider(JavaTool tool) {
diff a/test/jdk/tools/jpackage/share/jdk/jpackage/tests/CookedRuntimeTest.java b/test/jdk/tools/jpackage/share/jdk/jpackage/tests/CookedRuntimeTest.java
--- /dev/null
+++ b/test/jdk/tools/jpackage/share/jdk/jpackage/tests/CookedRuntimeTest.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.jpackage.tests;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.Collection;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Stream;
+import java.nio.file.Path;
+import jdk.jpackage.test.Annotations.Parameters;
+import jdk.jpackage.test.Annotations.Test;
+import jdk.jpackage.test.Executor;
+import jdk.jpackage.test.JPackageCommand;
+import jdk.jpackage.test.JavaAppDesc;
+import jdk.jpackage.test.JavaTool;
+import jdk.jpackage.test.TKit;
+
+
+/*
+ * @test
+ * @summary test '--runtime-image' option of jpackage
+ * @library ../../../../helpers
+ * @build jdk.jpackage.test.*
+ * @modules jdk.incubator.jpackage/jdk.incubator.jpackage.internal
+ * @compile CookedRuntimeTest.java
+ * @run main/othervm/timeout=360 -Xmx512m jdk.jpackage.test.Main
+ *  --jpt-run=jdk.jpackage.tests.CookedRuntimeTest
+ */
+
+public final class CookedRuntimeTest {
+
+    public CookedRuntimeTest(String javaAppDesc, String jlinkOutputSubdir,
+            String runtimeSubdir) {
+        this.javaAppDesc = javaAppDesc;
+        this.jlinkOutputSubdir = Path.of(jlinkOutputSubdir);
+        this.runtimeSubdir = Path.of(runtimeSubdir);
+    }
+
+    @Test
+    public void test() throws IOException {
+        JavaAppDesc appDesc = JavaAppDesc.parse(javaAppDesc);
+
+        JPackageCommand cmd = JPackageCommand.helloAppImage(appDesc);
+
+        final String moduleName = appDesc.moduleName();
+
+        if (moduleName != null) {
+            // Build module jar.
+            cmd.executePrerequisiteActions();
+        }
+
+        final Path workDir = TKit.createTempDirectory("runtime").resolve("data");
+        final Path jlinkOutputDir = workDir.resolve(jlinkOutputSubdir);
+        Files.createDirectories(jlinkOutputDir.getParent());
+
+        // List of modules required for test app.
+        final var modules = new String[] {
+            "java.base",
+            "java.desktop"
+        };
+
+        Executor jlink = new Executor()
+        .setToolProvider(JavaTool.JLINK)
+        .dumpOutput()
+        .addArguments(
+                "--add-modules", String.join(",", modules),
+                "--output", jlinkOutputDir.toString(),
+                "--strip-debug",
+                "--no-header-files",
+                "--no-man-pages");
+
+        if (moduleName != null) {
+            jlink.addArguments("--add-modules", moduleName, "--module-path",
+                    Path.of(cmd.getArgumentValue("--module-path")).resolve(
+                            "hello.jar").toString());
+        }
+
+        jlink.execute();
+
+        TKit.trace("jlink output BEGIN");
+        try (Stream<Path> paths = Files.walk(jlinkOutputDir)) {
+            paths.filter(Files::isRegularFile)
+                    .map(jlinkOutputDir::relativize)
+                    .map(Path::toString)
+                    .forEach(TKit::trace);
+        }
+        TKit.trace("jlink output END");
+
+        cmd.setArgumentValue("--runtime-image", workDir.resolve(runtimeSubdir));
+        cmd.executeAndAssertHelloAppImageCreated();
+    }
+
+    @Parameters
+    public static Collection data() {
+        final List<String> javaAppDescs = List.of("Hello",
+                "com.foo/com.foo.main.Aloha");
+
+        final List<String[]> paths = new ArrayList<>();
+        paths.add(new String[] { "", "" });
+        if (TKit.isOSX()) {
+            // On OSX jpackage should accept both runtime root and runtime home
+            // directories.
+            paths.add(new String[] { "Contents/Home", "" });
+        }
+
+        List<Object[]> data = new ArrayList<>();
+        for (var javaAppDesc : javaAppDescs) {
+            for (var pathCfg : paths) {
+                data.add(new Object[] { javaAppDesc, pathCfg[0], pathCfg[1] });
+            }
+        }
+
+        return data;
+    }
+
+    private final String javaAppDesc;
+    private final Path jlinkOutputSubdir;
+    private final Path runtimeSubdir;
+}
diff a/test/langtools/ProblemList.txt b/test/langtools/ProblemList.txt
--- a/test/langtools/ProblemList.txt
+++ b/test/langtools/ProblemList.txt
@@ -24,13 +24,10 @@
 ###########################################################################
 
 ###########################################################################
 #
 # javadoc
-jdk/javadoc/tool/enum/docComments/Main.java                                     8152313    generic-all    convert to doclet test framework
-jdk/javadoc/tool/enum/enumType/Main.java                                        8152313    generic-all    convert to doclet test framework
-jdk/javadoc/tool/varArgs/Main.java                                              8152313    generic-all    convert to doclet test framework
 jdk/javadoc/doclet/testIOException/TestIOException.java                         8164597    windows-all
 
 ###########################################################################
 #
 # jshell
diff a/test/langtools/jdk/javadoc/doclet/testRecordLinks/TestRecordLinks.java b/test/langtools/jdk/javadoc/doclet/testRecordLinks/TestRecordLinks.java
--- /dev/null
+++ b/test/langtools/jdk/javadoc/doclet/testRecordLinks/TestRecordLinks.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug      8236539
+ * @summary  Relative link tags in record javadoc don't resolve
+ * @library  /tools/lib ../../lib
+ * @modules jdk.javadoc/jdk.javadoc.internal.tool
+ * @build    toolbox.ToolBox javadoc.tester.*
+ * @compile --enable-preview --source ${jdk.version} TestRecordLinks.java
+ * @run main/othervm --enable-preview TestRecordLinks
+ */
+
+import java.nio.file.Path;
+
+import javadoc.tester.JavadocTester;
+import toolbox.ToolBox;
+
+public class TestRecordLinks  extends JavadocTester {
+    public static void main(String... args) throws Exception {
+        TestRecordLinks tester = new TestRecordLinks();
+        tester.runTests(m -> new Object[] { Path.of(m.getName()) });
+    }
+
+    private final ToolBox tb = new ToolBox();
+
+    @Test
+    public void testCrash(Path base) throws Exception {
+        // from JDK-8236539
+        String example = """
+                package example;
+                public class JavadocTest {
+                  /**
+                   * {@link #foo()}
+                   * {@link Bar}
+                   */
+                  public static class Foo {
+                    public void foo() { }
+                  }
+
+                  /**
+                   * {@link #bar()}
+                   * {@link Foo}
+                   */
+                  public record Bar() {
+                    public void bar() { }
+                  }
+                }
+                """;
+
+        Path src = base.resolve("src");
+        tb.writeJavaFiles(src, example);
+
+        javadoc("-d", base.resolve("out").toString(),
+                "-sourcepath", src.toString(),
+                "--enable-preview", "--source", thisRelease,
+                "example");
+        checkExit(Exit.OK);
+
+        checkOutput("example/JavadocTest.Foo.html", true,
+                """
+                    <h1 title="Class JavadocTest.Foo" class="title">Class JavadocTest.Foo</h1>
+                    """,
+                """
+                    <div class="block"><a href="#foo()"><code>foo()</code></a>
+                     <a href="JavadocTest.Bar.html" title="class in example"><code>JavadocTest.Bar</code></a></div>
+                    """);
+
+        checkOutput("example/JavadocTest.Bar.html", true,
+                """
+                    <h1 title="Record JavadocTest.Bar" class="title">Record JavadocTest.Bar</h1>
+                    """,
+                """
+                    <div class="block"><a href="#bar()"><code>bar()</code></a>
+                     <a href="JavadocTest.Foo.html" title="class in example"><code>JavadocTest.Foo</code></a></div>
+                    """);
+    }
+}
diff a/test/langtools/jdk/javadoc/lib/javadoc/tester/TestDoclet.java b/test/langtools/jdk/javadoc/lib/javadoc/tester/TestDoclet.java
--- /dev/null
+++ b/test/langtools/jdk/javadoc/lib/javadoc/tester/TestDoclet.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package javadoc.tester;
+
+import java.util.Locale;
+import java.util.Set;
+import javax.lang.model.SourceVersion;
+
+import jdk.javadoc.doclet.Doclet;
+import jdk.javadoc.doclet.DocletEnvironment;
+import jdk.javadoc.doclet.Reporter;
+
+/**
+ * A minimal base class for test doclets.
+ *
+ * The {@link Doclet#run(DocletEnvironment) run} method must still be provided by subtypes.
+ */
+public abstract class TestDoclet implements Doclet {
+    protected Locale locale;
+    protected Reporter reporter;
+
+    @Override
+    public void init(Locale locale, Reporter reporter) {
+        this.locale = locale;
+        this.reporter = reporter;
+    }
+
+    @Override
+    public String getName() {
+        return getClass().getSimpleName();
+    }
+
+    @Override
+    public Set<? extends Option> getSupportedOptions() {
+        return Set.of();
+    }
+
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+        return SourceVersion.latestSupported();
+    }
+}
diff a/test/langtools/jdk/javadoc/tool/enum/docComments/EnumCommentTest.java b/test/langtools/jdk/javadoc/tool/enum/docComments/EnumCommentTest.java
--- /dev/null
+++ b/test/langtools/jdk/javadoc/tool/enum/docComments/EnumCommentTest.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4421066
+ * @summary Verify the comments in an enum type.
+ * @library ../../../lib
+ * @modules jdk.javadoc/jdk.javadoc.internal.tool
+ * @build javadoc.tester.*
+ * @run main EnumCommentTest
+ */
+
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+
+import javadoc.tester.JavadocTester;
+import javadoc.tester.TestDoclet;
+import jdk.javadoc.doclet.DocletEnvironment;
+
+public class EnumCommentTest extends JavadocTester {
+
+    public static void main(String[] args) throws Exception {
+        JavadocTester t = new EnumCommentTest();
+        t.runTests();
+    }
+
+    @Test
+    public void testEnumComments() {
+        javadoc("-sourcepath", testSrc,
+                "-docletpath", System.getProperty("test.class.path"),
+                "-doclet", "EnumCommentTest$ThisDoclet",
+                "pkg1");
+        checkExit(Exit.OK);
+    }
+
+    public static class ThisDoclet extends TestDoclet {
+        public boolean run(DocletEnvironment env) {
+            Elements elements = env.getElementUtils();
+
+            System.err.println("incl " + env.getIncludedElements());
+            TypeElement operation = env.getIncludedElements()
+                    .stream()
+                    .filter(e -> e.getKind() == ElementKind.ENUM)
+                    .map(e -> (TypeElement) e)
+                    .findFirst()
+                    .orElseThrow(() -> new Error("can't find enum Operation"));
+
+            boolean ok = checkComment(elements.getDocComment(operation).trim(),
+                    "Arithmetic operations.");
+
+            for (VariableElement f : ElementFilter.fieldsIn(operation.getEnclosedElements())) {
+                if (f.getSimpleName().contentEquals("plus")) {
+                    ok = checkComment(elements.getDocComment(f).trim(),
+                            "Addition")
+                            && ok;
+                    for (ExecutableElement m : ElementFilter.methodsIn(operation.getEnclosedElements())) {
+                        if (m.getSimpleName().contentEquals("eval")) {
+                            ok = checkComment(elements.getDocComment(m).trim(),
+                                    "Perform arithmetic operation represented by this constant.")
+                                    && ok;
+                            break;
+                        }
+                    }
+                    break;
+                }
+            }
+            if (!ok) {
+                throw new Error("Comments don't match expectations.");
+            } else {
+                return true;
+            }
+        }
+
+        private boolean checkComment(String found, String expected) {
+            System.out.println("expected: \"" + expected + "\"");
+            System.out.println("found:    \"" + found + "\"");
+            return expected.equals(found);
+        }
+    }
+}
diff a/test/langtools/jdk/javadoc/tool/enum/docComments/Main.java b/test/langtools/jdk/javadoc/tool/enum/docComments/Main.java
--- a/test/langtools/jdk/javadoc/tool/enum/docComments/Main.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 4421066
- * @summary Verify the comments in an enum type.
- * @ignore 8152313 convert to doclet test framework
- * @library ../../lib
- * @modules jdk.javadoc
- * @compile  ../../lib/Tester.java Main.java
- * @run main Main
- */
-
-import java.io.IOException;
-
-import com.sun.javadoc.*;
-import jdk.javadoc.doclet.DocletEnvironment;
-
-public class Main extends Tester.Doclet {
-
-    private static final Tester tester =
-            new Tester("Main", "-package", "pkg1");
-
-    public static void main(String[] args) throws IOException {
-        tester.run();
-    }
-
-    public static boolean run(DocletEnvironment root) {
-        ClassDoc operation = root.classes()[0];
-        boolean ok =
-            checkComment(operation.commentText(), "Arithmetic operations.");
-
-        for (FieldDoc f : operation.fields()) {
-            if (f.name().equals("plus")) {
-                ok = checkComment(f.commentText(), "Addition") && ok;
-                for (MethodDoc m : operation.methods()) {
-                    if (m.name().equals("eval")) {
-                        ok = checkComment(m.commentText(),
-                                          "Perform arithmetic operation " +
-                                          "represented by this constant.") &&
-                            ok;
-                        break;
-                    }
-                }
-                break;
-            }
-        }
-        if (!ok) {
-            throw new Error("Comments don't match expectations.");
-        } else {
-            return true;
-        }
-    }
-
-    private static boolean checkComment(String found, String expected) {
-        System.out.println("expected: \"" + expected + "\"");
-        System.out.println("found:    \"" + found + "\"");
-        return expected.equals(found);
-    }
-}
diff a/test/langtools/jdk/javadoc/tool/enum/docComments/pkg1/Operation.java b/test/langtools/jdk/javadoc/tool/enum/docComments/pkg1/Operation.java
--- a/test/langtools/jdk/javadoc/tool/enum/docComments/pkg1/Operation.java
+++ b/test/langtools/jdk/javadoc/tool/enum/docComments/pkg1/Operation.java
@@ -28,11 +28,11 @@
  */
 
 /**
  * Arithmetic operations.
  */
-public abstract enum Operation {
+public enum Operation {
     /** Addition */
     plus {
         /** Add 'em up. */
         double eval(double x, double y) { return x + y; }
     },
diff a/test/langtools/jdk/javadoc/tool/enum/enumType/EnumContentsTest.java b/test/langtools/jdk/javadoc/tool/enum/enumType/EnumContentsTest.java
--- /dev/null
+++ b/test/langtools/jdk/javadoc/tool/enum/enumType/EnumContentsTest.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4421066
+ * @summary Verify the contents of an enum type.
+ * @library ../../../lib
+ * @modules jdk.javadoc/jdk.javadoc.internal.tool
+ * @build javadoc.tester.*
+ * @run main EnumContentsTest
+ */
+
+import java.io.PrintStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.stream.Collectors;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+
+import jdk.javadoc.doclet.DocletEnvironment;
+
+import javadoc.tester.JavadocTester;
+import javadoc.tester.TestDoclet;
+
+public class EnumContentsTest extends JavadocTester {
+
+    public static void main(String[] args) throws Exception {
+        JavadocTester t = new EnumContentsTest();
+        t.runTests();
+    }
+
+    @Test
+    public void testEnumContents() throws Exception {
+        javadoc("-sourcepath", testSrc,
+                "-docletpath", System.getProperty("test.class.path"),
+                "-doclet", "EnumContentsTest$ThisDoclet",
+                "pkg1");
+        checkExit(Exit.OK);
+
+        String expect = Files.readAllLines(Path.of(testSrc).resolve("expected.out"))
+                .stream()
+                .collect(Collectors.joining("\n"));
+        checkOutput(Output.STDOUT, true, expect);
+    }
+
+
+    public static class ThisDoclet extends TestDoclet {
+        public boolean run(DocletEnvironment root) {
+            try {
+                for (Element e : root.getIncludedElements()) {
+                    if (e.getKind() == ElementKind.ENUM) {
+                        printClass((TypeElement) e);
+                    }
+                }
+
+                return true;
+            } catch (Exception e) {
+                return false;
+            }
+        }
+
+        // this method mimics the printClass method from the old
+        // tester framework
+        void printClass(TypeElement te) {
+            PrintStream out = System.out;
+            out.format("%s %s%n",
+                    te.getKind().toString().toLowerCase(),
+                    te.getQualifiedName());
+            out.format("  name: %s / %s / %s%n",
+                    te.getSimpleName(), te.asType(), te.getQualifiedName());
+            out.format("  superclass:%n    %s%n",
+                    te.getSuperclass());
+            out.format("  enum constants:%n");
+            te.getEnclosedElements().stream()
+                    .filter(e -> e.getKind() == ElementKind.ENUM_CONSTANT)
+                    .forEach(e -> out.format("    %s%n", e.getSimpleName()));
+            out.format("  methods:%n");
+            te.getEnclosedElements().stream()
+                    .filter(e -> e.getKind() == ElementKind.METHOD)
+                    .map(e -> (ExecutableElement) e)
+                    .forEach(e -> out.format("    %s %s(%s)%n",
+                            e.getReturnType(),
+                            e.getSimpleName(),
+                            e.getParameters().stream()
+                                .map(this::paramToString)
+                                .collect(Collectors.joining(", "))
+                    ));
+
+        }
+        private String paramToString(Element e) {
+            return ((DeclaredType) e.asType()).asElement().getSimpleName().toString();
+        }
+    }
+}
diff a/test/langtools/jdk/javadoc/tool/enum/enumType/Main.java b/test/langtools/jdk/javadoc/tool/enum/enumType/Main.java
--- a/test/langtools/jdk/javadoc/tool/enum/enumType/Main.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 4421066
- * @summary Verify the contents of an enum type.
- * @ignore 8152313 convert to doclet test framework
- * @library ../../lib
- * @modules jdk.javadoc
- * @compile  ../../lib/Tester.java Main.java
- * @run main Main
- */
-
-import java.io.IOException;
-import com.sun.javadoc.*;
-
-public class Main extends Tester.Doclet {
-
-    private static final Tester tester = new Tester("Main", "pkg1");
-
-    public static void main(String[] args) throws IOException {
-        tester.run();
-        tester.verify();
-    }
-
-    public static boolean run(DocletEnvironment root) {
-        try {
-            for (ClassDoc cd : root.classes()) {
-                tester.printClass(cd);
-            }
-
-            return true;
-        } catch (IOException e) {
-            return false;
-        }
-    }
-}
diff a/test/langtools/jdk/javadoc/tool/enum/enumType/expected.out b/test/langtools/jdk/javadoc/tool/enum/enumType/expected.out
--- a/test/langtools/jdk/javadoc/tool/enum/enumType/expected.out
+++ b/test/langtools/jdk/javadoc/tool/enum/enumType/expected.out
@@ -1,7 +1,7 @@
 enum pkg1.QuotablePerson
-  name: QuotablePerson / QuotablePerson / pkg1.QuotablePerson
+  name: QuotablePerson / pkg1.QuotablePerson / pkg1.QuotablePerson
   superclass:
     java.lang.Enum<pkg1.QuotablePerson>
   enum constants:
     Thoreau
     McLuhan
@@ -13,6 +13,6 @@
     Groening
     Juvenal
     Eco
   methods:
     pkg1.QuotablePerson[] values()
-    QuotablePerson valueOf(String)
+    pkg1.QuotablePerson valueOf(String)
diff a/test/langtools/jdk/javadoc/tool/varArgs/Main.java b/test/langtools/jdk/javadoc/tool/varArgs/Main.java
--- a/test/langtools/jdk/javadoc/tool/varArgs/Main.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 4421066 5006659
- * @summary Verify the contents of a ClassDoc containing a varArgs method.
- *          Verify that see/link tags can use "..." notation.
- * @ignore 8152313 convert to doclet test framework
- * @library ../lib
- * @modules jdk.javadoc
- * @compile  ../lib/Tester.java Main.java
- * @run main Main
- */
-
-import java.io.IOException;
-
-import com.sun.javadoc.*;
-import jdk.javadoc.doclet.DocletEnvironment;
-
-public class Main extends Tester.Doclet {
-
-    private static final Tester tester =
-            new Tester("Main", "-Xwerror", "pkg1");
-
-    public static void main(String[] args) throws IOException {
-        tester.run();
-        tester.verify();
-    }
-
-    public static boolean run(DocletEnvironment root) {
-        try {
-            for (ClassDoc cd : root.classes()) {
-                tester.printClass(cd);
-
-                for (SeeTag tag : cd.seeTags()) {
-                    if (tag.referencedMember() != cd.methods()[0]) {
-                        throw new Error("5006659: @see tag meets varArgs");
-                    }
-                }
-            }
-
-            return true;
-        } catch (IOException e) {
-            return false;
-        }
-    }
-}
diff a/test/langtools/jdk/javadoc/tool/varArgs/VarArgsTest.java b/test/langtools/jdk/javadoc/tool/varArgs/VarArgsTest.java
--- /dev/null
+++ b/test/langtools/jdk/javadoc/tool/varArgs/VarArgsTest.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4421066 5006659
+ * @summary Verify the contents of a ClassDoc containing a varArgs method.
+ *          Verify that see/link tags can use "..." notation.
+ * @library ../../lib
+ * @modules jdk.javadoc/jdk.javadoc.internal.tool
+ * @build javadoc.tester.*
+ * @run main VarArgsTest
+ */
+
+import java.io.IOException;
+import java.io.PrintStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.stream.Collectors;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+
+import com.sun.source.doctree.DocCommentTree;
+import com.sun.source.doctree.DocTree;
+import com.sun.source.doctree.SeeTree;
+import com.sun.source.util.DocTreePath;
+import com.sun.source.util.DocTrees;
+import com.sun.source.util.TreePath;
+import javadoc.tester.TestDoclet;
+import jdk.javadoc.doclet.DocletEnvironment;
+
+import javadoc.tester.JavadocTester;
+
+public class VarArgsTest extends JavadocTester {
+
+    public static void main(String[] args) throws Exception {
+        JavadocTester t = new VarArgsTest();
+        t.runTests();
+    }
+
+    @Test
+    public void testVarArgs() throws Exception {
+        javadoc("-sourcepath", testSrc,
+                "-docletpath", System.getProperty("test.class.path"),
+                "-doclet", "VarArgsTest$ThisDoclet",
+                "pkg1");
+        checkExit(Exit.OK);
+
+        String expect = Files.readAllLines(Path.of(testSrc).resolve("expected.out"))
+                .stream()
+                .collect(Collectors.joining("\n"));
+        checkOutput(Output.STDOUT, true, expect);
+    }
+
+
+    public static class ThisDoclet extends TestDoclet {
+        public boolean run(DocletEnvironment env) {
+            DocTrees trees = env.getDocTrees();
+            try {
+                for (Element e : env.getIncludedElements()) {
+                    if (e.getKind() == ElementKind.INTERFACE) {
+                        printClass((TypeElement) e);
+
+                        TreePath tp = trees.getPath(e);
+                        DocCommentTree dct = trees.getDocCommentTree(e);
+                        DocTreePath dtp = new DocTreePath(tp, dct);
+
+                        ExecutableElement m0 = ElementFilter.methodsIn(e.getEnclosedElements()).get(0);
+                        for (DocTree t : dct.getBlockTags()) {
+                            if (t.getKind() == DocTree.Kind.SEE) {
+                                SeeTree st = (SeeTree) t;
+                                DocTreePath sp = new DocTreePath(dtp, st.getReference().get(0));
+                                Element se = trees.getElement(sp);
+                                System.err.println("Expect: " + m0);
+                                System.err.println("Found:  " + se);
+                                if (se != m0) {
+                                    throw new Error("unexpected value for @see reference");
+                                }
+                            }
+                        }
+                    }
+                }
+
+                return true;
+            } catch (Exception e) {
+                return false;
+            }
+        }
+
+        // this method mimics the printClass method from the old
+        // tester framework
+        void printClass(TypeElement te) {
+            PrintStream out = System.out;
+            out.format("%s %s%n",
+                    te.getKind().toString().toLowerCase(),
+                    te.getQualifiedName());
+            out.format("  name: %s / %s / %s%n",
+                    te.getSimpleName(), te.asType(), te.getQualifiedName());
+            out.format("  methods:%n");
+            te.getEnclosedElements().stream()
+                    .filter(e -> e.getKind() == ElementKind.METHOD)
+                    .map(e -> (ExecutableElement) e)
+                    .forEach(e -> out.format("    %s %s(%s)%n",
+                            e.getReturnType(),
+                            e.getSimpleName(),
+                            e.getParameters().stream()
+                                    .map(this::paramToString)
+                                    .collect(Collectors.joining(", "))
+                    ));
+
+        }
+
+        private String paramToString(Element e) {
+            System.err.println("paramToString " + e);
+            ExecutableElement m = (ExecutableElement) e.getEnclosingElement();
+            return typeToString(m, e.asType());
+        }
+
+        private String typeToString(ExecutableElement method, TypeMirror t) {
+            System.err.println("typeToString " + method + " " + t + " " + t.getKind());
+            switch (t.getKind()) {
+                case INT:
+                    return t.getKind().toString().toLowerCase();
+
+                case DECLARED:
+                    return ((DeclaredType) t).asElement().getSimpleName().toString();
+
+                case ARRAY:
+                    String cs = typeToString(method, ((ArrayType) t).getComponentType());
+                    String suffix = method.isVarArgs() ? "..." : "[]";
+                    return cs + suffix;
+
+                default:
+                    throw new IllegalArgumentException(t.getKind() + " " + t);
+            }
+        }
+    }
+}
diff a/test/langtools/jdk/javadoc/tool/varArgs/expected.out b/test/langtools/jdk/javadoc/tool/varArgs/expected.out
--- a/test/langtools/jdk/javadoc/tool/varArgs/expected.out
+++ b/test/langtools/jdk/javadoc/tool/varArgs/expected.out
@@ -1,4 +1,4 @@
 interface pkg1.A
-  name: A / A / pkg1.A
+  name: A / pkg1.A / pkg1.A
   methods:
     void m1(int, String...)
diff a/test/langtools/tools/javac/api/T6395981.java b/test/langtools/tools/javac/api/T6395981.java
--- a/test/langtools/tools/javac/api/T6395981.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug     6395981 6458819 7025784 8028543 8028544 8193291 8193292 8193292 8205393 8245585 8245585
- * @summary JavaCompilerTool and Tool must specify version of JLS and JVMS
- * @author  Peter von der Ah\u00e9
- * @modules java.compiler
- *          jdk.compiler
- * @run main/fail T6395981
- * @run main/fail T6395981 RELEASE_3  RELEASE_5  RELEASE_6
- * @run main/fail T6395981 RELEASE_0  RELEASE_1  RELEASE_2  RELEASE_3  RELEASE_4
- *                         RELEASE_5  RELEASE_6
- * @run main T6395981      RELEASE_3  RELEASE_4  RELEASE_5  RELEASE_6  RELEASE_7
- *                         RELEASE_8  RELEASE_9  RELEASE_10 RELEASE_11 RELEASE_12
- *                         RELEASE_13 RELEASE_14 RELEASE_15 RELEASE_16
- */
-
-import java.util.EnumSet;
-import java.util.Set;
-import javax.lang.model.SourceVersion;
-import javax.tools.Tool;
-import javax.tools.ToolProvider;
-import static javax.lang.model.SourceVersion.*;
-
-public class T6395981 {
-    public static void main(String... args) {
-        Tool compiler = ToolProvider.getSystemJavaCompiler();
-        Set<SourceVersion> expected = EnumSet.noneOf(SourceVersion.class);
-        for (String arg : args)
-            expected.add(SourceVersion.valueOf(arg));
-        Set<SourceVersion> found = compiler.getSourceVersions();
-        Set<SourceVersion> notExpected = EnumSet.copyOf(found);
-        for (SourceVersion version : expected) {
-            if (!found.contains(version))
-                throw new AssertionError("Expected source version not found: " + version);
-            else
-                notExpected.remove(version);
-        }
-        if (!notExpected.isEmpty())
-            throw new AssertionError("Unexpected source versions: " + notExpected);
-    }
-}
diff a/test/langtools/tools/javac/api/TestGetScopeResult.java b/test/langtools/tools/javac/api/TestGetScopeResult.java
--- a/test/langtools/tools/javac/api/TestGetScopeResult.java
+++ b/test/langtools/tools/javac/api/TestGetScopeResult.java
@@ -21,11 +21,11 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 8205418 8207229 8207230 8230847 8245786
+ * @bug 8205418 8207229 8207230 8230847 8245786 8247334
  * @summary Test the outcomes from Trees.getScope
  * @modules jdk.compiler/com.sun.tools.javac.api
  *          jdk.compiler/com.sun.tools.javac.comp
  *          jdk.compiler/com.sun.tools.javac.tree
  *          jdk.compiler/com.sun.tools.javac.util
@@ -40,10 +40,11 @@
 import javax.tools.JavaCompiler;
 import javax.tools.SimpleJavaFileObject;
 import javax.tools.StandardJavaFileManager;
 import javax.tools.ToolProvider;
 
+import com.sun.source.tree.AnnotationTree;
 import com.sun.source.tree.BlockTree;
 import com.sun.source.tree.ClassTree;
 import com.sun.source.tree.CompilationUnitTree;
 import com.sun.source.tree.ConditionalExpressionTree;
 import com.sun.source.tree.IdentifierTree;
@@ -78,10 +79,11 @@
         new TestGetScopeResult().testMemberRefs();
         new TestGetScopeResult().testAnnotations();
         new TestGetScopeResult().testAnnotationsLazy();
         new TestGetScopeResult().testCircular();
         new TestGetScopeResult().testRecord();
+        new TestGetScopeResult().testLocalRecordAnnotation();
     }
 
     public void run() throws IOException {
         String[] simpleLambda = {
             "s:java.lang.String",
@@ -560,10 +562,82 @@
                 throw new AssertionError("Unexpected Scope content: " + actual);
             }
         }
     }
 
+    void testLocalRecordAnnotation() throws IOException {
+        JavacTool c = JavacTool.create();
+        try (StandardJavaFileManager fm = c.getStandardFileManager(null, null, null)) {
+            class Variant {
+                final String code;
+                final List<List<String>> expectedScopeContent;
+                public Variant(String code, List<List<String>> expectedScopeContent) {
+                    this.code = code;
+                    this.expectedScopeContent = expectedScopeContent;
+                }
+            }
+            Variant[] variants = new Variant[] {
+                new Variant("""
+                            class Test {
+                                void t() {
+                                    record R(@Annotation int i) {
+                                        void stop () {}
+                                    }
+                                }
+                            }
+                            @interface Annotation {}
+                            """,
+                            List.of(
+                                List.of("super:java.lang.Object", "this:Test"),
+                                List.of("super:java.lang.Object", "this:Test")
+                            )),
+                new Variant("""
+                            record Test(@Annotation int i) {}
+                            @interface Annotation {}
+                            """,
+                            List.of(
+                                List.of("i:int", "super:java.lang.Record", "this:Test"),
+                                List.of("super:java.lang.Record", "this:Test")
+                            ))
+            };
+            for (Variant currentVariant : variants) {
+                class MyFileObject extends SimpleJavaFileObject {
+                    MyFileObject() {
+                        super(URI.create("myfo:///Test.java"), SOURCE);
+                    }
+                    @Override
+                    public String getCharContent(boolean ignoreEncodingErrors) {
+                        return currentVariant.code;
+                    }
+                }
+                Context ctx = new Context();
+                TestAnalyzer.preRegister(ctx);
+                List<String> options = List.of("--enable-preview",
+                                               "-source", System.getProperty("java.specification.version"));
+                JavacTask t = (JavacTask) c.getTask(null, fm, null, options, null,
+                                                    List.of(new MyFileObject()), ctx);
+                CompilationUnitTree cut = t.parse().iterator().next();
+                t.analyze();
+
+                List<List<String>> actual = new ArrayList<>();
+
+                new TreePathScanner<Void, Void>() {
+                    @Override
+                    public Void visitAnnotation(AnnotationTree node, Void p) {
+                        Scope scope = Trees.instance(t).getScope(getCurrentPath());
+                        actual.add(dumpScope(scope));
+                        return super.visitAnnotation(node, p);
+                    }
+                }.scan(cut, null);
+
+                if (!currentVariant.expectedScopeContent.equals(actual)) {
+                    throw new AssertionError("Unexpected Scope content: " + actual);
+                }
+            }
+        }
+    }
+
     private List<String> dumpScope(Scope scope) {
         List<String> content = new ArrayList<>();
         while (scope.getEnclosingClass() != null) {
             for (Element el : scope.getLocalElements()) {
                 content.add(el.getSimpleName() + ":" +el.asType().toString());
diff a/test/langtools/tools/javac/api/TestGetSourceVersions.java b/test/langtools/tools/javac/api/TestGetSourceVersions.java
--- /dev/null
+++ b/test/langtools/tools/javac/api/TestGetSourceVersions.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug     6395981 6458819 7025784 8028543 8028544 8193291 8193292 8193292 8205393 8245585 8245585
+ * @summary JavaCompilerTool and Tool must specify version of JLS and JVMS
+ * @author  Peter von der Ah\u00e9
+ * @modules java.compiler
+ *          jdk.compiler
+ * @run main/fail TestGetSourceVersions
+ * @run main/fail TestGetSourceVersions RELEASE_3  RELEASE_5  RELEASE_6
+ * @run main/fail TestGetSourceVersions RELEASE_0  RELEASE_1  RELEASE_2  RELEASE_3  RELEASE_4
+ *                                      RELEASE_5  RELEASE_6
+ * @run main TestGetSourceVersions      RELEASE_3  RELEASE_4  RELEASE_5  RELEASE_6  RELEASE_7
+ *                                      RELEASE_8  RELEASE_9  RELEASE_10 RELEASE_11 RELEASE_12
+ *                                      RELEASE_13 RELEASE_14 RELEASE_15 RELEASE_16
+ */
+
+import java.util.EnumSet;
+import java.util.Set;
+import javax.lang.model.SourceVersion;
+import javax.tools.Tool;
+import javax.tools.ToolProvider;
+import static javax.lang.model.SourceVersion.*;
+
+public class TestGetSourceVersions {
+    public static void main(String... args) {
+        Tool compiler = ToolProvider.getSystemJavaCompiler();
+        Set<SourceVersion> expected = EnumSet.noneOf(SourceVersion.class);
+        for (String arg : args)
+            expected.add(SourceVersion.valueOf(arg));
+        Set<SourceVersion> found = compiler.getSourceVersions();
+        Set<SourceVersion> notExpected = EnumSet.copyOf(found);
+        for (SourceVersion version : expected) {
+            if (!found.contains(version))
+                throw new AssertionError("Expected source version not found: " + version);
+            else
+                notExpected.remove(version);
+        }
+        if (!notExpected.isEmpty())
+            throw new AssertionError("Unexpected source versions: " + notExpected);
+    }
+}
diff a/test/lib-test/ProblemList.txt b/test/lib-test/ProblemList.txt
--- /dev/null
+++ b/test/lib-test/ProblemList.txt
@@ -0,0 +1,40 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+#############################################################################
+#
+# List of quarantined tests -- tests that should not be run by default, because
+# they may fail due to known reason. The reason (CR#) must be mandatory specified.
+#
+# List items are testnames followed by labels, all MUST BE commented
+#   as to why they are here and use a label:
+#     generic-all   Problems on all platforms
+#     generic-ARCH  Where ARCH is one of: x64, i586, ppc64, ppc64le, s390x etc.
+#     OSNAME-all    Where OSNAME is one of: linux, windows, macosx, aix
+#     OSNAME-ARCH   Specific on to one OSNAME and ARCH, e.g. macosx-x64
+#     OSNAME-REV    Specific on to one OSNAME and REV, e.g. macosx-10.7.4
+#
+# More than one label is allowed but must be on the same line.
+#
+#############################################################################
+
diff a/test/hotspot/jtreg/testlibrary_tests/RedefineClassTest.java b/test/lib-test/RedefineClassTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/RedefineClassTest.java
+++ b/test/lib-test/RedefineClassTest.java
diff a/test/lib-test/TEST.ROOT b/test/lib-test/TEST.ROOT
--- a/test/lib-test/TEST.ROOT
+++ b/test/lib-test/TEST.ROOT
@@ -1,9 +1,38 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
 # This file identifies the root of the test-suite hierarchy.
 # It also contains test-suite configuration information.
 
+# The list of keywords supported in this test suite
+# randomness:           test uses randomness, test cases differ from run to run
+keys=randomness
+
 # Minimum jtreg version
 requiredVersion=5.1 b1
 
 # Path to libraries in the topmost test directory. This is needed so @library
 # does not need ../../ notation to reach them
 external.lib.roots = ../../
+
+groups=TEST.groups
diff a/test/lib-test/TEST.groups b/test/lib-test/TEST.groups
--- /dev/null
+++ b/test/lib-test/TEST.groups
@@ -0,0 +1,24 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+tier1 = .
diff a/test/jdk/lib/testlibrary/AssertsTest.java b/test/lib-test/jdk/test/lib/AssertsTest.java
--- a/test/jdk/lib/testlibrary/AssertsTest.java
+++ b/test/lib-test/jdk/test/lib/AssertsTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/RandomGeneratorTest.java b/test/lib-test/jdk/test/lib/RandomGeneratorTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/RandomGeneratorTest.java
+++ b/test/lib-test/jdk/test/lib/RandomGeneratorTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/TestMutuallyExclusivePlatformPredicates.java b/test/lib-test/jdk/test/lib/TestMutuallyExclusivePlatformPredicates.java
--- a/test/hotspot/jtreg/testlibrary_tests/TestMutuallyExclusivePlatformPredicates.java
+++ b/test/lib-test/jdk/test/lib/TestMutuallyExclusivePlatformPredicates.java
diff a/test/lib-test/jdk/test/lib/TestPlatformIsTieredSupported.java b/test/lib-test/jdk/test/lib/TestPlatformIsTieredSupported.java
--- /dev/null
+++ b/test/lib-test/jdk/test/lib/TestPlatformIsTieredSupported.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import jdk.test.lib.Asserts;
+import jdk.test.lib.Platform;
+import sun.hotspot.WhiteBox;
+
+/**
+ * @test
+ * @summary Verifies that Platform::isTieredSupported returns correct value.
+ * @library /test/lib
+ * @modules java.base/jdk.internal.misc
+ *          java.management
+ * @build sun.hotspot.WhiteBox
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
+ *                   -XX:+WhiteBoxAPI -XX:+TieredCompilation
+ *                   TestPlatformIsTieredSupported
+ */
+public class TestPlatformIsTieredSupported {
+    public static void main(String args[]) {
+        WhiteBox whiteBox = WhiteBox.getWhiteBox();
+        boolean tieredCompilation = whiteBox.getBooleanVMFlag(
+                "TieredCompilation");
+        Asserts.assertEQ(Platform.isTieredSupported(), tieredCompilation,
+                "Platform::isTieredSupported should report the same value as "
+                        + "TieredCompilation flag's value when "
+                        + "+TieredCompilation was explicitly passed to JVM.");
+    }
+}
diff a/test/lib-test/jdk/test/lib/apps/LingeredAppTest.java b/test/lib-test/jdk/test/lib/apps/LingeredAppTest.java
--- a/test/lib-test/jdk/test/lib/apps/LingeredAppTest.java
+++ b/test/lib-test/jdk/test/lib/apps/LingeredAppTest.java
@@ -22,13 +22,13 @@
  */
 
 /*
  * @test
  * @summary Unit test for LingeredApp
- * @compile LingeredAppTest.java
- * @compile LingeredApp.java
- * @run main LingeredAppTest
+ * @library /test/lib
+ * @build jdk.test.lib.apps.LingeredAppTest jdk.test.lib.apps.LingeredApp
+ * @run main jdk.test.lib.apps.LingeredAppTest
  */
 
 package jdk.test.lib.apps;
 
 import java.io.IOException;
@@ -50,17 +50,17 @@
                 }
             }
 
             cmd.add("-XX:+PrintFlagsFinal");
 
-            LingeredApp a = LingeredApp.startApp(cmd.toArray(new String[cmd.length]);
+            LingeredApp a = LingeredApp.startApp(cmd.toArray(new String[cmd.size()]));
             System.out.printf("App pid: %d\n", a.getPid());
             a.stopApp();
 
             System.out.println("App output:");
             int count = 0;
-            for (String line : a.getAppOutput()) {
+            for (String line : a.getOutput().getStdoutAsList()) {
                 count += 1;
             }
             System.out.println("Found " + count + " lines in VM output");
             System.out.println("Test PASSED");
         } catch (IOException ex) {
diff a/test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java b/test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java
--- a/test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java
+++ b/test/lib-test/jdk/test/lib/hexdump/HexPrinterTest.java
@@ -75,13 +75,13 @@
 
     @DataProvider(name = "BuiltinParams")
     Object[][] builtinParams() {
         return new Object[][]{
                 {"minimal", "", "%02x", 16, "", 64, HexPrinter.Formatters.NONE, ""},
-                {"canonical", "%08x  ", "%02x ", 16, "|", 31, HexPrinter.Formatters.PRINTABLE, "|\n"},
-                {"simple", "%5d: ", "%02x ", 16, " // ", 64, HexPrinter.Formatters.ASCII, "\n"},
-                {"source", "    ", "(byte)%3d, ", 8, " // ", 64, HexPrinter.Formatters.PRINTABLE, "\n"},
+                {"canonical", "%08x  ", "%02x ", 16, "|", 31, HexPrinter.Formatters.PRINTABLE, "|" + System.lineSeparator()},
+                {"simple", "%5d: ", "%02x ", 16, " // ", 64, HexPrinter.Formatters.ASCII,  System.lineSeparator()},
+                {"source", "    ", "(byte)%3d, ", 8, " // ", 64, HexPrinter.Formatters.PRINTABLE,  System.lineSeparator()},
         };
     }
 
     @Test(dataProvider = "BuiltinParams")
     public void testBuiltins(String name, String offsetFormat, String binFormat, int colWidth,
diff a/test/jdk/lib/testlibrary/OutputAnalyzerReportingTest.java b/test/lib-test/jdk/test/lib/process/OutputAnalyzerReportingTest.java
--- a/test/jdk/lib/testlibrary/OutputAnalyzerReportingTest.java
+++ b/test/lib-test/jdk/test/lib/process/OutputAnalyzerReportingTest.java
diff a/test/lib-test/jdk/test/lib/process/OutputAnalyzerTest.java b/test/lib-test/jdk/test/lib/process/OutputAnalyzerTest.java
--- /dev/null
+++ b/test/lib-test/jdk/test/lib/process/OutputAnalyzerTest.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @summary Test the OutputAnalyzer utility class
+ * @modules java.management
+ * @library /test/lib
+ * @run main OutputAnalyzerTest
+ */
+
+import jdk.test.lib.process.OutputAnalyzer;
+
+public class OutputAnalyzerTest {
+
+    public static void main(String args[]) throws Exception {
+
+        String stdout = "aaaaaa";
+        String stderr = "bbbbbb";
+        String nonExistingString = "cccc";
+
+        OutputAnalyzer output = new OutputAnalyzer(stdout, stderr);
+
+        if (!stdout.equals(output.getStdout())) {
+            throw new Exception("getStdout() returned '" + output.getStdout()
+                    + "', expected '" + stdout + "'");
+        }
+
+        if (!stderr.equals(output.getStderr())) {
+            throw new Exception("getStderr() returned '" + output.getStderr()
+                    + "', expected '" + stderr + "'");
+        }
+
+        try {
+            output.shouldContain(stdout);
+            output.stdoutShouldContain(stdout);
+            output.shouldContain(stderr);
+            output.stderrShouldContain(stderr);
+        } catch (RuntimeException e) {
+            throw new Exception("shouldContain() failed", e);
+        }
+
+        try {
+            output.shouldContain(nonExistingString);
+            throw new Exception("shouldContain() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.stdoutShouldContain(stderr);
+            throw new Exception(
+                    "stdoutShouldContain() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.stderrShouldContain(stdout);
+            throw new Exception(
+                    "stdoutShouldContain() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.shouldNotContain(nonExistingString);
+            output.stdoutShouldNotContain(nonExistingString);
+            output.stderrShouldNotContain(nonExistingString);
+        } catch (RuntimeException e) {
+            throw new Exception("shouldNotContain() failed", e);
+        }
+
+        try {
+            output.shouldNotContain(stdout);
+            throw new Exception("shouldContain() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.stdoutShouldNotContain(stdout);
+            throw new Exception("shouldContain() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.stderrShouldNotContain(stderr);
+            throw new Exception("shouldContain() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        String stdoutPattern = "[a]";
+        String stdoutByLinePattern = "a*";
+        String stderrPattern = "[b]";
+        String nonExistingPattern = "[c]";
+        String byLinePattern = "[ab]*";
+
+        // Should match
+        try {
+            output.shouldMatch(stdoutPattern);
+            output.stdoutShouldMatch(stdoutPattern);
+            output.shouldMatch(stderrPattern);
+            output.stderrShouldMatch(stderrPattern);
+        } catch (RuntimeException e) {
+            throw new Exception("shouldMatch() failed", e);
+        }
+
+        try {
+            output.shouldMatch(nonExistingPattern);
+            throw new Exception("shouldMatch() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.stdoutShouldMatch(stderrPattern);
+            throw new Exception(
+                    "stdoutShouldMatch() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.stderrShouldMatch(stdoutPattern);
+            throw new Exception(
+                    "stderrShouldMatch() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.shouldMatchByLine(byLinePattern);
+        } catch (RuntimeException e) {
+            throw new Exception("shouldMatchByLine() failed", e);
+        }
+
+        try {
+            output.shouldMatchByLine(nonExistingPattern);
+            throw new Exception("shouldMatchByLine() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.stdoutShouldMatchByLine(stdoutByLinePattern);
+        } catch (RuntimeException e) {
+            throw new Exception("stdoutShouldMatchByLine() failed", e);
+        }
+
+        // Should not match
+        try {
+            output.shouldNotMatch(nonExistingPattern);
+            output.stdoutShouldNotMatch(nonExistingPattern);
+            output.stderrShouldNotMatch(nonExistingPattern);
+        } catch (RuntimeException e) {
+            throw new Exception("shouldNotMatch() failed", e);
+        }
+
+        try {
+            output.shouldNotMatch(stdoutPattern);
+            throw new Exception("shouldNotMatch() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.stdoutShouldNotMatch(stdoutPattern);
+            throw new Exception("shouldNotMatch() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        try {
+            output.stderrShouldNotMatch(stderrPattern);
+            throw new Exception("shouldNotMatch() failed to throw exception");
+        } catch (RuntimeException e) {
+            // expected
+        }
+
+        {
+            String aaaa = "aaaa";
+            String result = output.firstMatch(aaaa);
+            if (!aaaa.equals(result)) {
+                throw new Exception("firstMatch(String) failed to match. Expected: " + aaaa + " got: " + result);
+            }
+        }
+
+        {
+            String aa = "aa";
+            String aa_grouped_aa = aa + "(" + aa + ")";
+            String result = output.firstMatch(aa_grouped_aa, 1);
+            if (!aa.equals(result)) {
+                throw new Exception("firstMatch(String, int) failed to match. Expected: " + aa + " got: " + result);
+            }
+        }
+    }
+
+}
diff a/test/lib-test/jdk/test/lib/process/TestNativeProcessBuilder.java b/test/lib-test/jdk/test/lib/process/TestNativeProcessBuilder.java
--- /dev/null
+++ b/test/lib-test/jdk/test/lib/process/TestNativeProcessBuilder.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @summary Test the native process builder API.
+ * @library /test/lib
+ * @run main/native TestNativeProcessBuilder
+ */
+
+
+import jdk.test.lib.Utils;
+import jdk.test.lib.process.ProcessTools;
+import jdk.test.lib.process.OutputAnalyzer;
+
+public class TestNativeProcessBuilder {
+    public static void main(String args[]) throws Exception {
+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder("jvm-test-launcher");
+        pb.environment().put("CLASSPATH", Utils.TEST_CLASS_PATH);
+        new OutputAnalyzer(pb.start())
+            .shouldHaveExitValue(0)
+            .stdoutShouldContain("Hello Test");
+    }
+
+    public static class Test {
+        public static void test() {
+            System.out.println("Hello Test");
+        }
+    }
+}
diff a/test/lib-test/jdk/test/lib/process/exejvm-test-launcher.c b/test/lib-test/jdk/test/lib/process/exejvm-test-launcher.c
--- /dev/null
+++ b/test/lib-test/jdk/test/lib/process/exejvm-test-launcher.c
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <jni.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+JNIEnv* create_vm(JavaVM **jvm)
+{
+    JNIEnv* env;
+    JavaVMInitArgs args;
+    JavaVMOption options[1];
+
+    char classpath[4096];
+    snprintf(classpath, sizeof classpath,
+             "-Djava.class.path=%s", getenv("CLASSPATH"));
+    options[0].optionString = classpath;
+
+    args.version = JNI_VERSION_1_8;
+    args.nOptions = 1;
+    args.options = &options[0];
+    args.ignoreUnrecognized = 0;
+
+    int ret = JNI_CreateJavaVM(jvm, (void**)&env, &args);
+    if (ret < 0) {
+      exit(10);
+    }
+
+    return env;
+}
+
+
+void run(JNIEnv *env) {
+  jclass test_class;
+  jmethodID test_method;
+
+  test_class = (*env)->FindClass(env, "TestNativeProcessBuilder$Test");
+  if (test_class == NULL) {
+    exit(11);
+  }
+
+  test_method = (*env)->GetStaticMethodID(env, test_class, "test", "()V");
+  if (test_method == NULL) {
+    exit(12);
+  }
+
+  (*env)->CallStaticVoidMethod(env, test_class, test_method);
+}
+
+
+int main(int argc, char **argv)
+{
+  JavaVM *jvm;
+  JNIEnv *env = create_vm(&jvm);
+
+  run(env);
+
+  return 0;
+}
diff a/test/hotspot/jtreg/testlibrary_tests/whitebox/BlobSanityTest.java b/test/lib-test/sun/hotspot/whitebox/BlobSanityTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/whitebox/BlobSanityTest.java
+++ b/test/lib-test/sun/hotspot/whitebox/BlobSanityTest.java
diff a/test/jdk/lib/testlibrary/CPUInfoTest.java b/test/lib-test/sun/hotspot/whitebox/CPUInfoTest.java
--- a/test/jdk/lib/testlibrary/CPUInfoTest.java
+++ b/test/lib-test/sun/hotspot/whitebox/CPUInfoTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/BooleanTest.java b/test/lib-test/sun/hotspot/whitebox/vm_flags/BooleanTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/BooleanTest.java
+++ b/test/lib-test/sun/hotspot/whitebox/vm_flags/BooleanTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/DoubleTest.java b/test/lib-test/sun/hotspot/whitebox/vm_flags/DoubleTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/DoubleTest.java
+++ b/test/lib-test/sun/hotspot/whitebox/vm_flags/DoubleTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/IntxTest.java b/test/lib-test/sun/hotspot/whitebox/vm_flags/IntxTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/IntxTest.java
+++ b/test/lib-test/sun/hotspot/whitebox/vm_flags/IntxTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/SizeTTest.java b/test/lib-test/sun/hotspot/whitebox/vm_flags/SizeTTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/SizeTTest.java
+++ b/test/lib-test/sun/hotspot/whitebox/vm_flags/SizeTTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/StringTest.java b/test/lib-test/sun/hotspot/whitebox/vm_flags/StringTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/StringTest.java
+++ b/test/lib-test/sun/hotspot/whitebox/vm_flags/StringTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/Uint64Test.java b/test/lib-test/sun/hotspot/whitebox/vm_flags/Uint64Test.java
--- a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/Uint64Test.java
+++ b/test/lib-test/sun/hotspot/whitebox/vm_flags/Uint64Test.java
diff a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/UintxTest.java b/test/lib-test/sun/hotspot/whitebox/vm_flags/UintxTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/UintxTest.java
+++ b/test/lib-test/sun/hotspot/whitebox/vm_flags/UintxTest.java
diff a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/VmFlagTest.java b/test/lib-test/sun/hotspot/whitebox/vm_flags/VmFlagTest.java
--- a/test/hotspot/jtreg/testlibrary_tests/whitebox/vm_flags/VmFlagTest.java
+++ b/test/lib-test/sun/hotspot/whitebox/vm_flags/VmFlagTest.java
diff a/test/micro/org/openjdk/bench/java/lang/StringConcat.java b/test/micro/org/openjdk/bench/java/lang/StringConcat.java
--- a/test/micro/org/openjdk/bench/java/lang/StringConcat.java
+++ b/test/micro/org/openjdk/bench/java/lang/StringConcat.java
@@ -26,15 +26,12 @@
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Mode;
 import org.openjdk.jmh.annotations.OutputTimeUnit;
 import org.openjdk.jmh.annotations.Param;
 import org.openjdk.jmh.annotations.Scope;
-import org.openjdk.jmh.annotations.Setup;
 import org.openjdk.jmh.annotations.State;
-import org.openjdk.jmh.infra.Blackhole;
 
-import java.util.Random;
 import java.util.concurrent.TimeUnit;
 
 /**
  * Trivial String concatenation benchmark.
  */
@@ -52,20 +49,32 @@
 
     public boolean boolValue = true;
 
     public byte byteValue = (byte)-128;
 
+    public String emptyString = "";
+
     @Benchmark
     public String concatConstInt() {
         return "string" + intValue;
     }
 
     @Benchmark
     public String concatConstString() {
         return "string" + stringValue;
     }
 
+    @Benchmark
+    public String concatEmptyRight() {
+        return stringValue + emptyString;
+    }
+
+    @Benchmark
+    public String concatEmptyLeft() {
+        return emptyString + stringValue;
+    }
+
     @Benchmark
     public String concatMethodConstString() {
         return "string".concat(stringValue);
     }
 

diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotObjectConstantImpl.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotObjectConstantImpl.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotObjectConstantImpl.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotObjectConstantImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -63,22 +63,43 @@
     }
 
     @Override
     public abstract int getIdentityHashCode();
 
+    static class Fields {
+        // Initializing these too early causes a hang, so do it here in a subclass
+        static final HotSpotResolvedJavaField callSiteTargetField         = HotSpotMethodHandleAccessProvider.Internals.instance().callSiteTargetField;
+        static final HotSpotResolvedJavaField constantCallSiteFrozenField = HotSpotMethodHandleAccessProvider.Internals.instance().constantCallSiteFrozenField;
+    }
+
+    private boolean isFullyInitializedConstantCallSite() {
+        if (!runtime().getConstantCallSite().isInstance(this)) {
+            return false;
+        }
+        // read ConstantCallSite.isFrozen as a volatile field
+        boolean isFrozen = readFieldValue(Fields.constantCallSiteFrozenField, true /* volatile */).asBoolean();
+        // isFrozen true implies fully-initialized
+        return isFrozen;
+    }
+
+    private HotSpotObjectConstantImpl readTarget() {
+        // read CallSite.target as a volatile field
+        return (HotSpotObjectConstantImpl) readFieldValue(Fields.callSiteTargetField, true /* volatile */);
+    }
+
     @Override
     public JavaConstant getCallSiteTarget(Assumptions assumptions) {
         if (runtime().getCallSite().isInstance(this)) {
-            HotSpotObjectConstantImpl target = (HotSpotObjectConstantImpl) runtime().getHostJVMCIBackend().getConstantReflection().readFieldValue(
-                            HotSpotMethodHandleAccessProvider.Internals.instance().callSiteTargetField, this);
-            if (!runtime().getConstantCallSite().isInstance(this)) {
+            // For ConstantCallSites, we need to read "isFrozen" before reading "target"
+            // isFullyInitializedConstantCallSite() reads "isFrozen"
+            if (!isFullyInitializedConstantCallSite()) {
                 if (assumptions == null) {
                     return null;
                 }
-                assumptions.record(new Assumptions.CallSiteTargetValue(this, target));
+                assumptions.record(new Assumptions.CallSiteTargetValue(this, readTarget()));
             }
-            return target;
+            return readTarget();
         }
         return null;
     }
 
     @Override

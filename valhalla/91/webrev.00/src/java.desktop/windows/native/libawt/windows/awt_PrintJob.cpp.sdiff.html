<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="awt_Cursor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_TrayIcon.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1722     }
1723 
1724     HDC hDC = (HDC)theHDC;
1725 
1726     /* The code below is commented out until its proven necessary. In its
1727      * original form of PatBlit(hDC, destX,destY,destWidth, destHeight ..)
1728      * it resulted in the PS driver showing a white fringe, perhaps because
1729      * the PS driver enclosed the specified area rather than filling its
1730      * interior. The code is believed to have been there to prevent such
1731      * artefacts rather than cause them. This may have been related to
1732      * the earlier implementation using findNonWhite(..) and breaking the
1733      * image blit up into multiple blit calls. This currently looks as if
1734      * its unnecessary as the driver performs adequate compression where
1735      * such all white spans exist
1736      */
1737 //     HGDIOBJ oldBrush =
1738 //      ::SelectObject(hDC, AwtBrush::Get(RGB(0xff, 0xff, 0xff))-&gt;GetHandle());
1739 //     ::PatBlt(hDC, destX+1, destY+1, destWidth-2, destHeight-2, PATCOPY);
1740 //     ::SelectObject(hDC, oldBrush);
1741 




1742     TRY;
1743     jbyte *image = NULL;
1744     try {
<span class="line-modified">1745         image = (jbyte *)env-&gt;GetPrimitiveArrayCritical(imageArray, 0);</span>

1746         CHECK_NULL(image);


1747         struct {
1748             BITMAPINFOHEADER bmiHeader;
1749             DWORD*                 bmiColors;
1750         } bitMapHeader;
1751 
1752         memset(&amp;bitMapHeader,0,sizeof(bitMapHeader));
1753         bitMapHeader.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
1754         bitMapHeader.bmiHeader.biWidth = srcWidth;
1755         bitMapHeader.bmiHeader.biHeight = srcHeight;
1756         bitMapHeader.bmiHeader.biPlanes = 1;
1757         bitMapHeader.bmiHeader.biBitCount = 24;
1758         bitMapHeader.bmiHeader.biCompression = BI_RGB;
1759 
1760         int result =
1761             ::StretchDIBits(hDC,
1762                             destX,         // left of dest rect
1763                             destY,         // top of dest rect
1764                             destWidth,     // width of dest rect
1765                             destHeight,    // height of dest rect
1766                             srcX,          // left of source rect
1767                             srcY,          // top of source rect
1768                             srcWidth,      // number of 1st source scan line
1769                             srcHeight,     // number of source scan lines
1770                             image+offset,  // points to the DIB
1771                             (BITMAPINFO *)&amp;bitMapHeader,
1772                             DIB_RGB_COLORS,
1773                             SRCCOPY);
1774 #if DEBUG_PRINTING
1775      FILE *file = fopen(&quot;c:\\plog.txt&quot;, &quot;a&quot;);
1776      fprintf(file,&quot;sh=%d dh=%d sy=%d dy=%d result=%d\n&quot;, srcHeight, destHeight, srcY, destY, result);
1777      fclose(file);
1778 #endif //DEBUG_PRINTING
1779     } catch (...) {
<span class="line-modified">1780         if (image != NULL) {</span>
<span class="line-removed">1781             env-&gt;ReleasePrimitiveArrayCritical(imageArray, image, 0);</span>
<span class="line-removed">1782         }</span>
1783         throw;
1784     }
1785 
<span class="line-modified">1786     env-&gt;ReleasePrimitiveArrayCritical(imageArray, image, 0);</span>
1787 
1788     CATCH_BAD_ALLOC;
1789 }
1790 
1791 /*
1792  * Class:     sun_awt_windows_WPrinterJob
1793  * Method:    printBand
1794  * Signature: ([BIIII)V
1795  */
1796 JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_printBand
1797   (JNIEnv *env, jobject self, jbyteArray imageArray, jint x, jint y,
1798    jint width, jint height) {
1799 
1800     HDC printDC = AwtPrintControl::getPrintDC(env, self);
1801     doPrintBand(env, JNI_FALSE, printDC, imageArray, x, y, width, height);
1802 }
1803 
1804 /*
1805  * Class:     sun_awt_windows_WPrinterJob
1806  * Method:    beginPath
</pre>
<hr />
<pre>
2786             imgWidthByteSz+padBytes, ROUND_TO_LONG(srcHeight));
2787     } catch (std::bad_alloc&amp;) {
2788     }
2789     long newImgSize = (imgWidthByteSz+padBytes) * ROUND_TO_LONG(srcHeight);
2790 
2791     if (alignedImage != NULL) {
2792         memset(alignedImage, 0xff, newImgSize);
2793 
2794         jbyte* imgLinePtr = alignedImage;
2795         for (long i=ROUND_TO_LONG(srcHeight)-1; i&gt;=0; i--) {
2796             memcpy(imgLinePtr, imageBits+(i*imgWidthByteSz),
2797                    imgWidthByteSz);
2798             imgLinePtr += (imgWidthByteSz + padBytes);
2799         }
2800 
2801         return alignedImage;
2802     }
2803     return NULL;
2804 }
2805 
<span class="line-removed">2806 #if 0</span>
<span class="line-removed">2807 </span>
<span class="line-removed">2808 /*</span>
<span class="line-removed">2809  * Class:     sun_awt_windows_WPrinterJob</span>
<span class="line-removed">2810  * Method:    drawImageIntRGB</span>
<span class="line-removed">2811  * Signature: (J[IFFFFFFFFII)V</span>
<span class="line-removed">2812  */</span>
<span class="line-removed">2813 JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_drawImageIntRGB</span>
<span class="line-removed">2814   (JNIEnv *env, jobject self,</span>
<span class="line-removed">2815    jlong printDC, jintArray image,</span>
<span class="line-removed">2816    jfloat destX, jfloat destY,</span>
<span class="line-removed">2817    jfloat destWidth, jfloat destHeight,</span>
<span class="line-removed">2818    jfloat srcX, jfloat srcY,</span>
<span class="line-removed">2819    jfloat srcWidth, jfloat srcHeight,</span>
<span class="line-removed">2820    jint srcBitMapWidth, jint srcBitMapHeight) {</span>
<span class="line-removed">2821 </span>
<span class="line-removed">2822     int result = 0;</span>
<span class="line-removed">2823 </span>
<span class="line-removed">2824     assert(printDC != NULL);</span>
<span class="line-removed">2825     assert(image != NULL);</span>
<span class="line-removed">2826     assert(srcX &gt;= 0);</span>
<span class="line-removed">2827     assert(srcY &gt;= 0);</span>
<span class="line-removed">2828     assert(srcWidth &gt; 0);</span>
<span class="line-removed">2829     assert(srcHeight &gt; 0);</span>
<span class="line-removed">2830     assert(srcBitMapWidth &gt; 0);</span>
<span class="line-removed">2831     assert(srcBitMapHeight &gt; 0);</span>
<span class="line-removed">2832 </span>
<span class="line-removed">2833 </span>
<span class="line-removed">2834     static int alphaMask =  0xff000000;</span>
<span class="line-removed">2835     static int redMask =    0x00ff0000;</span>
<span class="line-removed">2836     static int greenMask =  0x0000ff00;</span>
<span class="line-removed">2837     static int blueMask =   0x000000ff;</span>
<span class="line-removed">2838 </span>
<span class="line-removed">2839     struct {</span>
<span class="line-removed">2840         BITMAPV4HEADER header;</span>
<span class="line-removed">2841         DWORD          masks[256];</span>
<span class="line-removed">2842     } dib;</span>
<span class="line-removed">2843 </span>
<span class="line-removed">2844 </span>
<span class="line-removed">2845 </span>
<span class="line-removed">2846     memset(&amp;dib,0,sizeof(dib));</span>
<span class="line-removed">2847     dib.header.bV4Size = sizeof(dib.header);</span>
<span class="line-removed">2848     dib.header.bV4Width = srcBitMapWidth;</span>
<span class="line-removed">2849     dib.header.bV4Height = -srcBitMapHeight;    // Top down DIB</span>
<span class="line-removed">2850     dib.header.bV4Planes = 1;</span>
<span class="line-removed">2851     dib.header.bV4BitCount = 32;</span>
<span class="line-removed">2852     dib.header.bV4V4Compression = BI_BITFIELDS;</span>
<span class="line-removed">2853     dib.header.bV4SizeImage = 0;        // It&#39;s the default size.</span>
<span class="line-removed">2854     dib.header.bV4XPelsPerMeter = 0;</span>
<span class="line-removed">2855     dib.header.bV4YPelsPerMeter = 0;</span>
<span class="line-removed">2856     dib.header.bV4ClrUsed = 0;</span>
<span class="line-removed">2857     dib.header.bV4ClrImportant = 0;</span>
<span class="line-removed">2858     dib.header.bV4RedMask = redMask;</span>
<span class="line-removed">2859     dib.header.bV4GreenMask = greenMask;</span>
<span class="line-removed">2860     dib.header.bV4BlueMask = blueMask;</span>
<span class="line-removed">2861     dib.header.bV4AlphaMask = alphaMask;</span>
<span class="line-removed">2862     dib.masks[0] = redMask;</span>
<span class="line-removed">2863     dib.masks[1] = greenMask;</span>
<span class="line-removed">2864     dib.masks[2] = blueMask;</span>
<span class="line-removed">2865     dib.masks[3] = alphaMask;</span>
<span class="line-removed">2866 </span>
<span class="line-removed">2867     jint *imageBits = NULL;</span>
<span class="line-removed">2868 </span>
<span class="line-removed">2869     try {</span>
<span class="line-removed">2870         imageBits = (jint *)env-&gt;GetPrimitiveArrayCritical(image, 0);</span>
<span class="line-removed">2871 </span>
<span class="line-removed">2872         if (printDC){</span>
<span class="line-removed">2873             result = ::StretchDIBits( (HDC)printDC,</span>
<span class="line-removed">2874                                       ROUND_TO_LONG(destX),</span>
<span class="line-removed">2875                                       ROUND_TO_LONG(destY),</span>
<span class="line-removed">2876                                       ROUND_TO_LONG(destWidth),</span>
<span class="line-removed">2877                                       ROUND_TO_LONG(destHeight),</span>
<span class="line-removed">2878                                       ROUND_TO_LONG(srcX),</span>
<span class="line-removed">2879                                       ROUND_TO_LONG(srcY),</span>
<span class="line-removed">2880                                       ROUND_TO_LONG(srcWidth),</span>
<span class="line-removed">2881                                       ROUND_TO_LONG(srcHeight),</span>
<span class="line-removed">2882                                       imageBits,</span>
<span class="line-removed">2883                                       (BITMAPINFO *)&amp;dib,</span>
<span class="line-removed">2884                                       DIB_RGB_COLORS,</span>
<span class="line-removed">2885                                       SRCCOPY);</span>
<span class="line-removed">2886 </span>
<span class="line-removed">2887         }</span>
<span class="line-removed">2888     } catch (...) {</span>
<span class="line-removed">2889         if (imageBits != NULL) {</span>
<span class="line-removed">2890             env-&gt;ReleasePrimitiveArrayCritical(image, imageBits, 0);</span>
<span class="line-removed">2891         }</span>
<span class="line-removed">2892         throw;</span>
<span class="line-removed">2893     }</span>
<span class="line-removed">2894 </span>
<span class="line-removed">2895     env-&gt;ReleasePrimitiveArrayCritical(image, imageBits, 0);</span>
<span class="line-removed">2896 </span>
<span class="line-removed">2897 }</span>
<span class="line-removed">2898 #else</span>
<span class="line-removed">2899 </span>
2900 /*
2901  * Class:     sun_awt_windows_WPrinterJob
2902  * Method:    drawDIBImage
2903  * Signature: (J[BFFFFFFFFI[B)V
2904  */
2905 JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_drawDIBImage
2906   (JNIEnv *env, jobject self,
2907    jlong printDC, jbyteArray image,
2908    jfloat destX, jfloat destY,
2909    jfloat destWidth, jfloat destHeight,
2910    jfloat srcX, jfloat srcY,
2911    jfloat srcWidth, jfloat srcHeight,
2912    jint bitCount, jbyteArray bmiColorsArray) {
2913 
2914     int result = 0;
2915 
2916     assert(printDC != NULL);
2917     assert(image != NULL);
2918     assert(srcX &gt;= 0);
2919     assert(srcY &gt;= 0);
</pre>
<hr />
<pre>
2974                                       ROUND_TO_LONG(srcWidth),
2975                                       ROUND_TO_LONG(srcHeight),
2976                                       dibImage,
2977                                       (BITMAPINFO*)(&amp;bmi),
2978                                       DIB_RGB_COLORS,
2979                                       SRCCOPY);
2980           }
2981 
2982           free(dibImage);
2983         } /* if (dibImage != NULL) */
2984     } catch (...) {
2985         if (imageBits != NULL) {
2986             env-&gt;ReleasePrimitiveArrayCritical(image, imageBits, 0);
2987         }
2988         JNU_ThrowInternalError(env, &quot;Problem in WPrinterJob_drawDIBImage&quot;);
2989         return;
2990     }
2991     env-&gt;ReleasePrimitiveArrayCritical(image, imageBits, 0);
2992 
2993 }
<span class="line-removed">2994 #endif</span>
2995 
2996 /*
2997  * An utility function to print passed image byte array to
2998  * the printDC.
2999  * browserPrinting flag controls whether the image array
3000  * used as top-down (browserPrinting == JNI_TRUE) or
3001  * bottom-up (browserPrinting == JNI_FALSE) DIB.
3002  */
3003 static void doPrintBand(JNIEnv *env, jboolean browserPrinting,
3004                         HDC printDC, jbyteArray imageArray,
3005                         jint x, jint y, jint width, jint height) {
3006 
3007     TRY;
3008 
3009     jbyte *image = NULL;
3010     try {
3011         long scanLineStride = J2DRasterBPP * width;
3012         image = (jbyte *)env-&gt;GetPrimitiveArrayCritical(imageArray, 0);
3013         CHECK_NULL(image);
3014         jbyte *startImage;
</pre>
<hr />
<pre>
3042                     bitsToDevice(printDC, endImage, x, y + startY, width,
3043                                  numLines);
3044                 }
3045                 startImage = endImage + scanLineStride;
3046                 startY += numLines;
3047             }
3048         } while (startY &lt; height &amp;&amp; startImage != NULL);
3049 
3050     } catch (...) {
3051         if (image != NULL) {
3052             env-&gt;ReleasePrimitiveArrayCritical(imageArray, image, 0);
3053         }
3054         throw;
3055     }
3056 
3057     env-&gt;ReleasePrimitiveArrayCritical(imageArray, image, 0);
3058 
3059     CATCH_BAD_ALLOC;
3060 
3061 }
<span class="line-modified">3062 static FILE* outfile = NULL;</span>
3063 static int bitsToDevice(HDC printDC, jbyte *image, long destX, long destY,
3064                         long width, long height) {
3065     int result = 0;
3066 
3067     assert(printDC != NULL);
3068     assert(image != NULL);
3069     assert(destX &gt;= 0);
3070     assert(destY &gt;= 0);
3071     assert(width &gt; 0);
3072     /* height could be negative to indicate that this is a top-down DIB */
3073 //      assert(height &gt; 0);
3074 



3075     struct {
3076         BITMAPINFOHEADER bmiHeader;
3077         DWORD*             bmiColors;
3078     } bitMapHeader;
3079 
3080     memset(&amp;bitMapHeader,0,sizeof(bitMapHeader));
3081     bitMapHeader.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
3082     bitMapHeader.bmiHeader.biWidth = width;
3083     bitMapHeader.bmiHeader.biHeight = height; // does -height work ever?
3084     bitMapHeader.bmiHeader.biPlanes = 1;
3085     bitMapHeader.bmiHeader.biBitCount = 24;
3086     bitMapHeader.bmiHeader.biCompression = BI_RGB;
3087     bitMapHeader.bmiHeader.biSizeImage = 0;     // It&#39;s the default size.
3088     bitMapHeader.bmiHeader.biXPelsPerMeter = 0;
3089     bitMapHeader.bmiHeader.biYPelsPerMeter = 0;
3090     bitMapHeader.bmiHeader.biClrUsed = 0;
3091     bitMapHeader.bmiHeader.biClrImportant = 0;
3092     bitMapHeader.bmiColors = NULL;
3093 
3094     height = abs(height);
3095 
3096     // Workaround for drivers/apps that do not support top-down.
3097     // Because we don&#39;t know if they support or not,
3098     // always send bottom-up DIBs
3099     if (bitMapHeader.bmiHeader.biHeight &lt; 0) {
3100       jbyte *dibImage = reverseDIB(image, width, height, 24);
3101       if (dibImage != NULL) {
<span class="line-modified">3102         bitMapHeader.bmiHeader.biWidth = ROUND_TO_LONG(width);</span>
<span class="line-modified">3103         bitMapHeader.bmiHeader.biHeight = ROUND_TO_LONG(height);</span>
<span class="line-modified">3104 </span>
<span class="line-removed">3105         if (printDC){</span>
<span class="line-removed">3106           result = ::SetDIBitsToDevice(printDC,</span>
3107                                 ROUND_TO_LONG(destX),   // left of dest rect
3108                                 ROUND_TO_LONG(destY),   // top of dest rect
3109                                 ROUND_TO_LONG(width),   // width of dest rect
3110                                 ROUND_TO_LONG(height),  // height of dest rect
3111                                 0,      // left of source rect
3112                                 0,      // top of source rect
3113                                 0,      // line number of 1st source scan line
3114                                 ROUND_TO_LONG(height),  // number of scan lines
3115                                 dibImage,       // points to the DIB
3116                                 (BITMAPINFO *)&amp;bitMapHeader,
3117                                 DIB_RGB_COLORS);
<span class="line-modified">3118         }</span>
<span class="line-removed">3119 </span>
<span class="line-removed">3120         free (dibImage);</span>
3121       }
3122     } else {
<span class="line-removed">3123       if (printDC){</span>
3124           result = ::SetDIBitsToDevice(printDC,
3125                                 destX,  // left of dest rect
3126                                 destY,  // top of dest rect
3127                                 width,  // width of dest rect
3128                                 height, // height of dest rect
3129                                 0,      // left of source rect
3130                                 0,      // top of source rect
3131                                 0,      // line number of 1st source scan line
3132                                 height, // number of source scan lines
3133                                 image,  // points to the DIB
3134                                 (BITMAPINFO *)&amp;bitMapHeader,
3135                                 DIB_RGB_COLORS);
<span class="line-modified">3136       }</span>






















3137     }
<span class="line-removed">3138 </span>
3139     return result;
3140 }
3141 
3142 LRESULT CALLBACK PageDialogWndProc(HWND hWnd, UINT message,
3143                                    WPARAM wParam, LPARAM lParam)
3144 {
3145     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
3146 
3147     switch (message) {
3148         case WM_COMMAND: {
3149             if ((LOWORD(wParam) == IDOK) ||
3150                 (LOWORD(wParam) == IDCANCEL))
3151             {
3152                 // If we recieve on of these two notifications, the dialog
3153                 // is about to be closed. It&#39;s time to unblock all the
3154                 // windows blocked by this dialog, as doing so from the
3155                 // WM_DESTROY handler is too late
3156                 jobject peer = (jobject)(::GetProp(hWnd, ModalDialogPeerProp));
3157                 env-&gt;CallVoidMethod(peer, AwtPrintDialog::setHWndMID, (jlong)0);
3158             }
</pre>
</td>
<td>
<hr />
<pre>
1722     }
1723 
1724     HDC hDC = (HDC)theHDC;
1725 
1726     /* The code below is commented out until its proven necessary. In its
1727      * original form of PatBlit(hDC, destX,destY,destWidth, destHeight ..)
1728      * it resulted in the PS driver showing a white fringe, perhaps because
1729      * the PS driver enclosed the specified area rather than filling its
1730      * interior. The code is believed to have been there to prevent such
1731      * artefacts rather than cause them. This may have been related to
1732      * the earlier implementation using findNonWhite(..) and breaking the
1733      * image blit up into multiple blit calls. This currently looks as if
1734      * its unnecessary as the driver performs adequate compression where
1735      * such all white spans exist
1736      */
1737 //     HGDIOBJ oldBrush =
1738 //      ::SelectObject(hDC, AwtBrush::Get(RGB(0xff, 0xff, 0xff))-&gt;GetHandle());
1739 //     ::PatBlt(hDC, destX+1, destY+1, destWidth-2, destHeight-2, PATCOPY);
1740 //     ::SelectObject(hDC, oldBrush);
1741 
<span class="line-added">1742     /* This code is rarely used now. It used to be invoked by Java plugin browser</span>
<span class="line-added">1743      * printing. Today embedded frames are used only when a toolkit such as SWT</span>
<span class="line-added">1744      * needs to embed</span>
<span class="line-added">1745      */</span>
1746     TRY;
1747     jbyte *image = NULL;
1748     try {
<span class="line-modified">1749         int length = env-&gt;GetArrayLength(imageArray);</span>
<span class="line-added">1750         image = new jbyte[length];</span>
1751         CHECK_NULL(image);
<span class="line-added">1752         env-&gt;GetByteArrayRegion(imageArray, 0, length, image);</span>
<span class="line-added">1753 </span>
1754         struct {
1755             BITMAPINFOHEADER bmiHeader;
1756             DWORD*                 bmiColors;
1757         } bitMapHeader;
1758 
1759         memset(&amp;bitMapHeader,0,sizeof(bitMapHeader));
1760         bitMapHeader.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
1761         bitMapHeader.bmiHeader.biWidth = srcWidth;
1762         bitMapHeader.bmiHeader.biHeight = srcHeight;
1763         bitMapHeader.bmiHeader.biPlanes = 1;
1764         bitMapHeader.bmiHeader.biBitCount = 24;
1765         bitMapHeader.bmiHeader.biCompression = BI_RGB;
1766 
1767         int result =
1768             ::StretchDIBits(hDC,
1769                             destX,         // left of dest rect
1770                             destY,         // top of dest rect
1771                             destWidth,     // width of dest rect
1772                             destHeight,    // height of dest rect
1773                             srcX,          // left of source rect
1774                             srcY,          // top of source rect
1775                             srcWidth,      // number of 1st source scan line
1776                             srcHeight,     // number of source scan lines
1777                             image+offset,  // points to the DIB
1778                             (BITMAPINFO *)&amp;bitMapHeader,
1779                             DIB_RGB_COLORS,
1780                             SRCCOPY);
1781 #if DEBUG_PRINTING
1782      FILE *file = fopen(&quot;c:\\plog.txt&quot;, &quot;a&quot;);
1783      fprintf(file,&quot;sh=%d dh=%d sy=%d dy=%d result=%d\n&quot;, srcHeight, destHeight, srcY, destY, result);
1784      fclose(file);
1785 #endif //DEBUG_PRINTING
1786     } catch (...) {
<span class="line-modified">1787         delete[] image;</span>


1788         throw;
1789     }
1790 
<span class="line-modified">1791     delete[] image;</span>
1792 
1793     CATCH_BAD_ALLOC;
1794 }
1795 
1796 /*
1797  * Class:     sun_awt_windows_WPrinterJob
1798  * Method:    printBand
1799  * Signature: ([BIIII)V
1800  */
1801 JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_printBand
1802   (JNIEnv *env, jobject self, jbyteArray imageArray, jint x, jint y,
1803    jint width, jint height) {
1804 
1805     HDC printDC = AwtPrintControl::getPrintDC(env, self);
1806     doPrintBand(env, JNI_FALSE, printDC, imageArray, x, y, width, height);
1807 }
1808 
1809 /*
1810  * Class:     sun_awt_windows_WPrinterJob
1811  * Method:    beginPath
</pre>
<hr />
<pre>
2791             imgWidthByteSz+padBytes, ROUND_TO_LONG(srcHeight));
2792     } catch (std::bad_alloc&amp;) {
2793     }
2794     long newImgSize = (imgWidthByteSz+padBytes) * ROUND_TO_LONG(srcHeight);
2795 
2796     if (alignedImage != NULL) {
2797         memset(alignedImage, 0xff, newImgSize);
2798 
2799         jbyte* imgLinePtr = alignedImage;
2800         for (long i=ROUND_TO_LONG(srcHeight)-1; i&gt;=0; i--) {
2801             memcpy(imgLinePtr, imageBits+(i*imgWidthByteSz),
2802                    imgWidthByteSz);
2803             imgLinePtr += (imgWidthByteSz + padBytes);
2804         }
2805 
2806         return alignedImage;
2807     }
2808     return NULL;
2809 }
2810 






























































































2811 /*
2812  * Class:     sun_awt_windows_WPrinterJob
2813  * Method:    drawDIBImage
2814  * Signature: (J[BFFFFFFFFI[B)V
2815  */
2816 JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_drawDIBImage
2817   (JNIEnv *env, jobject self,
2818    jlong printDC, jbyteArray image,
2819    jfloat destX, jfloat destY,
2820    jfloat destWidth, jfloat destHeight,
2821    jfloat srcX, jfloat srcY,
2822    jfloat srcWidth, jfloat srcHeight,
2823    jint bitCount, jbyteArray bmiColorsArray) {
2824 
2825     int result = 0;
2826 
2827     assert(printDC != NULL);
2828     assert(image != NULL);
2829     assert(srcX &gt;= 0);
2830     assert(srcY &gt;= 0);
</pre>
<hr />
<pre>
2885                                       ROUND_TO_LONG(srcWidth),
2886                                       ROUND_TO_LONG(srcHeight),
2887                                       dibImage,
2888                                       (BITMAPINFO*)(&amp;bmi),
2889                                       DIB_RGB_COLORS,
2890                                       SRCCOPY);
2891           }
2892 
2893           free(dibImage);
2894         } /* if (dibImage != NULL) */
2895     } catch (...) {
2896         if (imageBits != NULL) {
2897             env-&gt;ReleasePrimitiveArrayCritical(image, imageBits, 0);
2898         }
2899         JNU_ThrowInternalError(env, &quot;Problem in WPrinterJob_drawDIBImage&quot;);
2900         return;
2901     }
2902     env-&gt;ReleasePrimitiveArrayCritical(image, imageBits, 0);
2903 
2904 }

2905 
2906 /*
2907  * An utility function to print passed image byte array to
2908  * the printDC.
2909  * browserPrinting flag controls whether the image array
2910  * used as top-down (browserPrinting == JNI_TRUE) or
2911  * bottom-up (browserPrinting == JNI_FALSE) DIB.
2912  */
2913 static void doPrintBand(JNIEnv *env, jboolean browserPrinting,
2914                         HDC printDC, jbyteArray imageArray,
2915                         jint x, jint y, jint width, jint height) {
2916 
2917     TRY;
2918 
2919     jbyte *image = NULL;
2920     try {
2921         long scanLineStride = J2DRasterBPP * width;
2922         image = (jbyte *)env-&gt;GetPrimitiveArrayCritical(imageArray, 0);
2923         CHECK_NULL(image);
2924         jbyte *startImage;
</pre>
<hr />
<pre>
2952                     bitsToDevice(printDC, endImage, x, y + startY, width,
2953                                  numLines);
2954                 }
2955                 startImage = endImage + scanLineStride;
2956                 startY += numLines;
2957             }
2958         } while (startY &lt; height &amp;&amp; startImage != NULL);
2959 
2960     } catch (...) {
2961         if (image != NULL) {
2962             env-&gt;ReleasePrimitiveArrayCritical(imageArray, image, 0);
2963         }
2964         throw;
2965     }
2966 
2967     env-&gt;ReleasePrimitiveArrayCritical(imageArray, image, 0);
2968 
2969     CATCH_BAD_ALLOC;
2970 
2971 }
<span class="line-modified">2972 </span>
2973 static int bitsToDevice(HDC printDC, jbyte *image, long destX, long destY,
2974                         long width, long height) {
2975     int result = 0;
2976 
2977     assert(printDC != NULL);
2978     assert(image != NULL);
2979     assert(destX &gt;= 0);
2980     assert(destY &gt;= 0);
2981     assert(width &gt; 0);
2982     /* height could be negative to indicate that this is a top-down DIB */
2983 //      assert(height &gt; 0);
2984 
<span class="line-added">2985     if (!printDC || height == 0) {</span>
<span class="line-added">2986         return result;</span>
<span class="line-added">2987     }</span>
2988     struct {
2989         BITMAPINFOHEADER bmiHeader;
2990         DWORD*             bmiColors;
2991     } bitMapHeader;
2992 
2993     memset(&amp;bitMapHeader,0,sizeof(bitMapHeader));
2994     bitMapHeader.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
2995     bitMapHeader.bmiHeader.biWidth = width;
2996     bitMapHeader.bmiHeader.biHeight = height; // does -height work ever?
2997     bitMapHeader.bmiHeader.biPlanes = 1;
2998     bitMapHeader.bmiHeader.biBitCount = 24;
2999     bitMapHeader.bmiHeader.biCompression = BI_RGB;
3000     bitMapHeader.bmiHeader.biSizeImage = 0;     // It&#39;s the default size.
3001     bitMapHeader.bmiHeader.biXPelsPerMeter = 0;
3002     bitMapHeader.bmiHeader.biYPelsPerMeter = 0;
3003     bitMapHeader.bmiHeader.biClrUsed = 0;
3004     bitMapHeader.bmiHeader.biClrImportant = 0;
3005     bitMapHeader.bmiColors = NULL;
3006 
3007     height = abs(height);
3008 
3009     // Workaround for drivers/apps that do not support top-down.
3010     // Because we don&#39;t know if they support or not,
3011     // always send bottom-up DIBs
3012     if (bitMapHeader.bmiHeader.biHeight &lt; 0) {
3013       jbyte *dibImage = reverseDIB(image, width, height, 24);
3014       if (dibImage != NULL) {
<span class="line-modified">3015             bitMapHeader.bmiHeader.biWidth = ROUND_TO_LONG(width);</span>
<span class="line-modified">3016             bitMapHeader.bmiHeader.biHeight = ROUND_TO_LONG(height);</span>
<span class="line-modified">3017             result = ::SetDIBitsToDevice(printDC,</span>


3018                                 ROUND_TO_LONG(destX),   // left of dest rect
3019                                 ROUND_TO_LONG(destY),   // top of dest rect
3020                                 ROUND_TO_LONG(width),   // width of dest rect
3021                                 ROUND_TO_LONG(height),  // height of dest rect
3022                                 0,      // left of source rect
3023                                 0,      // top of source rect
3024                                 0,      // line number of 1st source scan line
3025                                 ROUND_TO_LONG(height),  // number of scan lines
3026                                 dibImage,       // points to the DIB
3027                                 (BITMAPINFO *)&amp;bitMapHeader,
3028                                 DIB_RGB_COLORS);
<span class="line-modified">3029             free (dibImage);</span>


3030       }
3031     } else {

3032           result = ::SetDIBitsToDevice(printDC,
3033                                 destX,  // left of dest rect
3034                                 destY,  // top of dest rect
3035                                 width,  // width of dest rect
3036                                 height, // height of dest rect
3037                                 0,      // left of source rect
3038                                 0,      // top of source rect
3039                                 0,      // line number of 1st source scan line
3040                                 height, // number of source scan lines
3041                                 image,  // points to the DIB
3042                                 (BITMAPINFO *)&amp;bitMapHeader,
3043                                 DIB_RGB_COLORS);
<span class="line-modified">3044          if (result == 0) {</span>
<span class="line-added">3045              size_t size = width * height * 3; // Always 24bpp, also DWORD aligned.</span>
<span class="line-added">3046              void *imageData = NULL;</span>
<span class="line-added">3047              try {</span>
<span class="line-added">3048                   imageData = safe_Malloc(size);</span>
<span class="line-added">3049               } catch (std::bad_alloc&amp;) {</span>
<span class="line-added">3050                   return result;</span>
<span class="line-added">3051               }</span>
<span class="line-added">3052               memcpy(imageData, image, size);</span>
<span class="line-added">3053               result = ::SetDIBitsToDevice(printDC,</span>
<span class="line-added">3054                                     destX,  // left of dest rect</span>
<span class="line-added">3055                                     destY,  // top of dest rect</span>
<span class="line-added">3056                                     width,  // width of dest rect</span>
<span class="line-added">3057                                     height, // height of dest rect</span>
<span class="line-added">3058                                     0,      // left of source rect</span>
<span class="line-added">3059                                     0,      // top of source rect</span>
<span class="line-added">3060                                     0,      // line number of 1st source scan line</span>
<span class="line-added">3061                                     height, // number of source scan lines</span>
<span class="line-added">3062                                     imageData,  // points to the DIB</span>
<span class="line-added">3063                                     (BITMAPINFO *)&amp;bitMapHeader,</span>
<span class="line-added">3064                                     DIB_RGB_COLORS);</span>
<span class="line-added">3065               free(imageData);</span>
<span class="line-added">3066          }</span>
3067     }

3068     return result;
3069 }
3070 
3071 LRESULT CALLBACK PageDialogWndProc(HWND hWnd, UINT message,
3072                                    WPARAM wParam, LPARAM lParam)
3073 {
3074     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
3075 
3076     switch (message) {
3077         case WM_COMMAND: {
3078             if ((LOWORD(wParam) == IDOK) ||
3079                 (LOWORD(wParam) == IDCANCEL))
3080             {
3081                 // If we recieve on of these two notifications, the dialog
3082                 // is about to be closed. It&#39;s time to unblock all the
3083                 // windows blocked by this dialog, as doing so from the
3084                 // WM_DESTROY handler is too late
3085                 jobject peer = (jobject)(::GetProp(hWnd, ModalDialogPeerProp));
3086                 env-&gt;CallVoidMethod(peer, AwtPrintDialog::setHWndMID, (jlong)0);
3087             }
</pre>
</td>
</tr>
</table>
<center><a href="awt_Cursor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_TrayIcon.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/windows/native/libawt/java2d/windows/GDIBlitLoops.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../java.base/share/classes/sun/security/provider/JavaKeyStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../windows/awt_Cursor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/windows/native/libawt/java2d/windows/GDIBlitLoops.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  */
 25 
 26 #include &quot;awt.h&quot;
 27 #include &lt;sun_java2d_windows_GDIBlitLoops.h&gt;
 28 #include &quot;gdefs.h&quot;
 29 #include &quot;Trace.h&quot;
 30 #include &quot;GDIWindowSurfaceData.h&quot;
 31 
 32 static RGBQUAD *byteGrayPalette = NULL;
 33 
 34 extern &quot;C&quot; {
 35 
 36 typedef struct tagBitmapheader  {
 37     BITMAPINFOHEADER bmiHeader;
 38     union {
 39         DWORD           dwMasks[3];
 40         RGBQUAD         palette[256];
 41     } colors;
 42 } BmiType;
 43 






























































 44 /*
 45  * Class:     sun_java2d_windows_GDIBlitLoops
 46  * Method:    nativeBlit
 47  * Signature: (Lsun/java2d/SurfaceData;Lsun/java2d/SurfaceData;IIIIIIZ)V
 48  */
 49 JNIEXPORT void JNICALL
 50 Java_sun_java2d_windows_GDIBlitLoops_nativeBlit
 51     (JNIEnv *env, jobject joSelf,
 52      jobject srcData, jobject dstData,
 53      jobject clip,
 54      jint srcx, jint srcy,
 55      jint dstx, jint dsty,
 56      jint width, jint height,
 57      jint rmask, jint gmask, jint bmask,
 58      jboolean needLut)
 59 {
 60     J2dTraceLn(J2D_TRACE_INFO, &quot;GDIBlitLoops_nativeBlit&quot;);
 61 
 62     SurfaceDataRasInfo srcInfo;
 63     SurfaceDataOps *srcOps = SurfaceData_GetOps(env, srcData);
</pre>
<hr />
<pre>
110         // GetRasInfo implicitly calls GetPrimitiveArrayCritical
111         // and since GetDC uses JNI it needs to be called first.
112         HDC hDC = dstOps-&gt;GetDC(env, dstOps, 0, NULL, clip, NULL, 0);
113         if (hDC == NULL) {
114             SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
115             return;
116         }
117         srcOps-&gt;GetRasInfo(env, srcOps, &amp;srcInfo);
118         if (srcInfo.rasBase == NULL) {
119             dstOps-&gt;ReleaseDC(env, dstOps, hDC);
120             SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
121             return;
122         }
123         void *rasBase = ((char *)srcInfo.rasBase) + srcInfo.scanStride * srcy +
124                         srcInfo.pixelStride * srcx;
125 
126         // If scanlines are DWORD-aligned (scanStride is a multiple of 4),
127         // then we can do the work much faster.  This is due to a constraint
128         // in the way DIBs are structured and parsed by GDI
129         jboolean fastBlt = ((srcInfo.scanStride &amp; 0x03) == 0);
<span class="line-removed">130 </span>
131         bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
132         bmi.bmiHeader.biWidth = srcInfo.scanStride/srcInfo.pixelStride;
133         // fastBlt copies whole image in one call; else copy line-by-line
134         LONG dwHeight = srcInfo.bounds.y2 - srcInfo.bounds.y1;
135         bmi.bmiHeader.biHeight = (fastBlt) ? -dwHeight : -1;
136         bmi.bmiHeader.biPlanes = 1;
137         bmi.bmiHeader.biBitCount = (WORD)srcInfo.pixelStride * 8;
138         // 1,3,4 byte use BI_RGB, 2 byte use BI_BITFIELD...
139         // 4 byte _can_ use BI_BITFIELD, but this seems to cause a performance
140         // penalty.  Since we only ever have one format (xrgb) for 32-bit
141         // images that enter this function, just use BI_RGB.
142         // Could do BI_RGB for 2-byte 555 format, but no perceived
143         // performance benefit.
144         bmi.bmiHeader.biCompression = (srcInfo.pixelStride != 2)
145                 ? BI_RGB : BI_BITFIELDS;
146         bmi.bmiHeader.biSizeImage = (bmi.bmiHeader.biWidth * dwHeight *
147                                      srcInfo.pixelStride);
148         bmi.bmiHeader.biXPelsPerMeter = 0;
149         bmi.bmiHeader.biYPelsPerMeter = 0;
150         bmi.bmiHeader.biClrUsed = 0;
</pre>
<hr />
<pre>
173                         byteGrayPalette[i].rgbGreen = i;
174                         byteGrayPalette[i].rgbBlue = i;
175                     }
176                 }
177                 memcpy(bmi.colors.palette, byteGrayPalette, 256 * sizeof(RGBQUAD));
178             }
179         } else if (srcInfo.pixelStride == 2) {
180             // For 16-bit case, init the masks for the pixel depth
181             bmi.colors.dwMasks[0] = rmask;
182             bmi.colors.dwMasks[1] = gmask;
183             bmi.colors.dwMasks[2] = bmask;
184         }
185 
186         if (fastBlt) {
187             // Window could go away at any time, leaving bits on the screen
188             // from this GDI call, so make sure window still exists
189             if (::IsWindowVisible(dstOps-&gt;window)) {
190                 // Could also call StretchDIBits.  Testing showed slight
191                 // performance advantage of SetDIBits instead, so since we
192                 // have no need of scaling, might as well use SetDIBits.
<span class="line-modified">193                 SetDIBitsToDevice(hDC, dstx, dsty, width, height,</span>
194                     0, 0, 0, height, rasBase,
195                     (BITMAPINFO*)&amp;bmi, DIB_RGB_COLORS);
196             }
197         } else {
198             // Source scanlines not DWORD-aligned - copy each scanline individually
199             for (int i = 0; i &lt; height; i += 1) {
200                 if (::IsWindowVisible(dstOps-&gt;window)) {
<span class="line-modified">201                     SetDIBitsToDevice(hDC, dstx, dsty+i, width, 1,</span>
202                         0, 0, 0, 1, rasBase,
203                         (BITMAPINFO*)&amp;bmi, DIB_RGB_COLORS);
204                     rasBase = (void*)((char*)rasBase + srcInfo.scanStride);
205                 } else {
206                     break;
207                 }
208             }
209         }
210         dstOps-&gt;ReleaseDC(env, dstOps, hDC);
211         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
212     }
213     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
214 
215     return;
216 }
217 
218 } // extern &quot;C&quot;
</pre>
</td>
<td>
<hr />
<pre>
 24  */
 25 
 26 #include &quot;awt.h&quot;
 27 #include &lt;sun_java2d_windows_GDIBlitLoops.h&gt;
 28 #include &quot;gdefs.h&quot;
 29 #include &quot;Trace.h&quot;
 30 #include &quot;GDIWindowSurfaceData.h&quot;
 31 
 32 static RGBQUAD *byteGrayPalette = NULL;
 33 
 34 extern &quot;C&quot; {
 35 
 36 typedef struct tagBitmapheader  {
 37     BITMAPINFOHEADER bmiHeader;
 38     union {
 39         DWORD           dwMasks[3];
 40         RGBQUAD         palette[256];
 41     } colors;
 42 } BmiType;
 43 
<span class="line-added"> 44 /*</span>
<span class="line-added"> 45  * Some GDI functions functions will fail if they operate on memory which spans</span>
<span class="line-added"> 46  * virtual allocations as used by modern garbage collectors (ie ZGC).</span>
<span class="line-added"> 47  * So if the call to SetDIBitsToDevice fails, we will re-try it on malloced</span>
<span class="line-added"> 48  * memory rather than the pinned Java heap memory.</span>
<span class="line-added"> 49  * Once Microsoft fix the GDI bug, the small performance penalty of this retry</span>
<span class="line-added"> 50  * will be gone.</span>
<span class="line-added"> 51  */</span>
<span class="line-added"> 52 static void retryingSetDIBitsToDevice(</span>
<span class="line-added"> 53     HDC              hdc,</span>
<span class="line-added"> 54     int              xDest,</span>
<span class="line-added"> 55     int              yDest,</span>
<span class="line-added"> 56     DWORD            w,</span>
<span class="line-added"> 57     DWORD            h,</span>
<span class="line-added"> 58     int              xSrc,</span>
<span class="line-added"> 59     int              ySrc,</span>
<span class="line-added"> 60     UINT             StartScan,</span>
<span class="line-added"> 61     UINT             cLines,</span>
<span class="line-added"> 62     const VOID       *lpvBits,</span>
<span class="line-added"> 63     BITMAPINFO       *lpbmi,</span>
<span class="line-added"> 64     UINT             ColorUse) {</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66 #ifdef DEBUG_PERF</span>
<span class="line-added"> 67     LARGE_INTEGER    ts1, ts2;</span>
<span class="line-added"> 68     QueryPerformanceCounter(&amp;ts1);</span>
<span class="line-added"> 69 #endif</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     int ret =</span>
<span class="line-added"> 72         SetDIBitsToDevice(hdc, xDest, yDest, w, h,</span>
<span class="line-added"> 73                           xSrc, ySrc, StartScan, cLines, lpvBits,</span>
<span class="line-added"> 74                           lpbmi, ColorUse);</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76     if (ret != 0 || h == 0) {</span>
<span class="line-added"> 77 #ifdef DEBUG_PERF</span>
<span class="line-added"> 78          QueryPerformanceCounter(&amp;ts2);</span>
<span class="line-added"> 79          printf(&quot;success time: %zd\n&quot;, (ts2.QuadPart-ts1.QuadPart));</span>
<span class="line-added"> 80 #endif</span>
<span class="line-added"> 81         return;</span>
<span class="line-added"> 82     }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84     size_t size = lpbmi-&gt;bmiHeader.biSizeImage;</span>
<span class="line-added"> 85     void* imageData = NULL;</span>
<span class="line-added"> 86     try {</span>
<span class="line-added"> 87         imageData = safe_Malloc(size);</span>
<span class="line-added"> 88     } catch (std::bad_alloc&amp;) {</span>
<span class="line-added"> 89     }</span>
<span class="line-added"> 90     if (imageData == NULL) {</span>
<span class="line-added"> 91         return;</span>
<span class="line-added"> 92     }</span>
<span class="line-added"> 93     memcpy(imageData, lpvBits, size); // this is the most expensive part.</span>
<span class="line-added"> 94     SetDIBitsToDevice(hdc, xDest, yDest, w, h,</span>
<span class="line-added"> 95                       xSrc, ySrc, StartScan, cLines, imageData,</span>
<span class="line-added"> 96                       lpbmi, ColorUse);</span>
<span class="line-added"> 97     free(imageData);</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99 #ifdef DEBUG_PERF</span>
<span class="line-added">100     QueryPerformanceCounter(&amp;ts2);</span>
<span class="line-added">101     printf(&quot;with retry time: %zd\n&quot;, (ts2.QuadPart-ts1.QuadPart));</span>
<span class="line-added">102 #endif</span>
<span class="line-added">103 </span>
<span class="line-added">104 };</span>
<span class="line-added">105 </span>
106 /*
107  * Class:     sun_java2d_windows_GDIBlitLoops
108  * Method:    nativeBlit
109  * Signature: (Lsun/java2d/SurfaceData;Lsun/java2d/SurfaceData;IIIIIIZ)V
110  */
111 JNIEXPORT void JNICALL
112 Java_sun_java2d_windows_GDIBlitLoops_nativeBlit
113     (JNIEnv *env, jobject joSelf,
114      jobject srcData, jobject dstData,
115      jobject clip,
116      jint srcx, jint srcy,
117      jint dstx, jint dsty,
118      jint width, jint height,
119      jint rmask, jint gmask, jint bmask,
120      jboolean needLut)
121 {
122     J2dTraceLn(J2D_TRACE_INFO, &quot;GDIBlitLoops_nativeBlit&quot;);
123 
124     SurfaceDataRasInfo srcInfo;
125     SurfaceDataOps *srcOps = SurfaceData_GetOps(env, srcData);
</pre>
<hr />
<pre>
172         // GetRasInfo implicitly calls GetPrimitiveArrayCritical
173         // and since GetDC uses JNI it needs to be called first.
174         HDC hDC = dstOps-&gt;GetDC(env, dstOps, 0, NULL, clip, NULL, 0);
175         if (hDC == NULL) {
176             SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
177             return;
178         }
179         srcOps-&gt;GetRasInfo(env, srcOps, &amp;srcInfo);
180         if (srcInfo.rasBase == NULL) {
181             dstOps-&gt;ReleaseDC(env, dstOps, hDC);
182             SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
183             return;
184         }
185         void *rasBase = ((char *)srcInfo.rasBase) + srcInfo.scanStride * srcy +
186                         srcInfo.pixelStride * srcx;
187 
188         // If scanlines are DWORD-aligned (scanStride is a multiple of 4),
189         // then we can do the work much faster.  This is due to a constraint
190         // in the way DIBs are structured and parsed by GDI
191         jboolean fastBlt = ((srcInfo.scanStride &amp; 0x03) == 0);

192         bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
193         bmi.bmiHeader.biWidth = srcInfo.scanStride/srcInfo.pixelStride;
194         // fastBlt copies whole image in one call; else copy line-by-line
195         LONG dwHeight = srcInfo.bounds.y2 - srcInfo.bounds.y1;
196         bmi.bmiHeader.biHeight = (fastBlt) ? -dwHeight : -1;
197         bmi.bmiHeader.biPlanes = 1;
198         bmi.bmiHeader.biBitCount = (WORD)srcInfo.pixelStride * 8;
199         // 1,3,4 byte use BI_RGB, 2 byte use BI_BITFIELD...
200         // 4 byte _can_ use BI_BITFIELD, but this seems to cause a performance
201         // penalty.  Since we only ever have one format (xrgb) for 32-bit
202         // images that enter this function, just use BI_RGB.
203         // Could do BI_RGB for 2-byte 555 format, but no perceived
204         // performance benefit.
205         bmi.bmiHeader.biCompression = (srcInfo.pixelStride != 2)
206                 ? BI_RGB : BI_BITFIELDS;
207         bmi.bmiHeader.biSizeImage = (bmi.bmiHeader.biWidth * dwHeight *
208                                      srcInfo.pixelStride);
209         bmi.bmiHeader.biXPelsPerMeter = 0;
210         bmi.bmiHeader.biYPelsPerMeter = 0;
211         bmi.bmiHeader.biClrUsed = 0;
</pre>
<hr />
<pre>
234                         byteGrayPalette[i].rgbGreen = i;
235                         byteGrayPalette[i].rgbBlue = i;
236                     }
237                 }
238                 memcpy(bmi.colors.palette, byteGrayPalette, 256 * sizeof(RGBQUAD));
239             }
240         } else if (srcInfo.pixelStride == 2) {
241             // For 16-bit case, init the masks for the pixel depth
242             bmi.colors.dwMasks[0] = rmask;
243             bmi.colors.dwMasks[1] = gmask;
244             bmi.colors.dwMasks[2] = bmask;
245         }
246 
247         if (fastBlt) {
248             // Window could go away at any time, leaving bits on the screen
249             // from this GDI call, so make sure window still exists
250             if (::IsWindowVisible(dstOps-&gt;window)) {
251                 // Could also call StretchDIBits.  Testing showed slight
252                 // performance advantage of SetDIBits instead, so since we
253                 // have no need of scaling, might as well use SetDIBits.
<span class="line-modified">254                 retryingSetDIBitsToDevice(hDC, dstx, dsty, width, height,</span>
255                     0, 0, 0, height, rasBase,
256                     (BITMAPINFO*)&amp;bmi, DIB_RGB_COLORS);
257             }
258         } else {
259             // Source scanlines not DWORD-aligned - copy each scanline individually
260             for (int i = 0; i &lt; height; i += 1) {
261                 if (::IsWindowVisible(dstOps-&gt;window)) {
<span class="line-modified">262                     retryingSetDIBitsToDevice(hDC, dstx, dsty+i, width, 1,</span>
263                         0, 0, 0, 1, rasBase,
264                         (BITMAPINFO*)&amp;bmi, DIB_RGB_COLORS);
265                     rasBase = (void*)((char*)rasBase + srcInfo.scanStride);
266                 } else {
267                     break;
268                 }
269             }
270         }
271         dstOps-&gt;ReleaseDC(env, dstOps, hDC);
272         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
273     }
274     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
275 
276     return;
277 }
278 
279 } // extern &quot;C&quot;
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../java.base/share/classes/sun/security/provider/JavaKeyStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../windows/awt_Cursor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
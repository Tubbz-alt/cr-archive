<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/bsd/os_bsd.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_bsd.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux/os_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/bsd/os_bsd.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1862 
1863 int os::signal_wait() {
1864   return check_pending_signals();
1865 }
1866 
1867 ////////////////////////////////////////////////////////////////////////////////
1868 // Virtual Memory
1869 
1870 int os::vm_page_size() {
1871   // Seems redundant as all get out
1872   assert(os::Bsd::page_size() != -1, &quot;must call os::init&quot;);
1873   return os::Bsd::page_size();
1874 }
1875 
1876 // Solaris allocates memory by pages.
1877 int os::vm_allocation_granularity() {
1878   assert(os::Bsd::page_size() != -1, &quot;must call os::init&quot;);
1879   return os::Bsd::page_size();
1880 }
1881 
<span class="line-removed">1882 // Rationale behind this function:</span>
<span class="line-removed">1883 //  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable</span>
<span class="line-removed">1884 //  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get</span>
<span class="line-removed">1885 //  samples for JITted code. Here we create private executable mapping over the code cache</span>
<span class="line-removed">1886 //  and then we can use standard (well, almost, as mapping can change) way to provide</span>
<span class="line-removed">1887 //  info for the reporting script by storing timestamp and location of symbol</span>
<span class="line-removed">1888 void bsd_wrap_code(char* base, size_t size) {</span>
<span class="line-removed">1889   static volatile jint cnt = 0;</span>
<span class="line-removed">1890 </span>
<span class="line-removed">1891   if (!UseOprofile) {</span>
<span class="line-removed">1892     return;</span>
<span class="line-removed">1893   }</span>
<span class="line-removed">1894 </span>
<span class="line-removed">1895   char buf[PATH_MAX + 1];</span>
<span class="line-removed">1896   int num = Atomic::add(&amp;cnt, 1);</span>
<span class="line-removed">1897 </span>
<span class="line-removed">1898   snprintf(buf, PATH_MAX + 1, &quot;%s/hs-vm-%d-%d&quot;,</span>
<span class="line-removed">1899            os::get_temp_directory(), os::current_process_id(), num);</span>
<span class="line-removed">1900   unlink(buf);</span>
<span class="line-removed">1901 </span>
<span class="line-removed">1902   int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);</span>
<span class="line-removed">1903 </span>
<span class="line-removed">1904   if (fd != -1) {</span>
<span class="line-removed">1905     off_t rv = ::lseek(fd, size-2, SEEK_SET);</span>
<span class="line-removed">1906     if (rv != (off_t)-1) {</span>
<span class="line-removed">1907       if (::write(fd, &quot;&quot;, 1) == 1) {</span>
<span class="line-removed">1908         mmap(base, size,</span>
<span class="line-removed">1909              PROT_READ|PROT_WRITE|PROT_EXEC,</span>
<span class="line-removed">1910              MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);</span>
<span class="line-removed">1911       }</span>
<span class="line-removed">1912     }</span>
<span class="line-removed">1913     ::close(fd);</span>
<span class="line-removed">1914     unlink(buf);</span>
<span class="line-removed">1915   }</span>
<span class="line-removed">1916 }</span>
<span class="line-removed">1917 </span>
1918 static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
1919                                     int err) {
1920   warning(&quot;INFO: os::commit_memory(&quot; INTPTR_FORMAT &quot;, &quot; SIZE_FORMAT
1921           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, (intptr_t)addr, size, exec,
1922            os::errno_name(err), err);
1923 }
1924 
1925 // NOTE: Bsd kernel does not really reserve the pages for us.
1926 //       All it does is to check if there are enough free pages
1927 //       left at the time of mmap(). This could be a potential
1928 //       problem.
1929 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
1930   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
1931 #ifdef __OpenBSD__
1932   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
1933   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);
1934   if (::mprotect(addr, size, prot) == 0) {
1935     return true;
1936   }
1937 #else
</pre>
</td>
<td>
<hr />
<pre>
1862 
1863 int os::signal_wait() {
1864   return check_pending_signals();
1865 }
1866 
1867 ////////////////////////////////////////////////////////////////////////////////
1868 // Virtual Memory
1869 
1870 int os::vm_page_size() {
1871   // Seems redundant as all get out
1872   assert(os::Bsd::page_size() != -1, &quot;must call os::init&quot;);
1873   return os::Bsd::page_size();
1874 }
1875 
1876 // Solaris allocates memory by pages.
1877 int os::vm_allocation_granularity() {
1878   assert(os::Bsd::page_size() != -1, &quot;must call os::init&quot;);
1879   return os::Bsd::page_size();
1880 }
1881 




































1882 static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
1883                                     int err) {
1884   warning(&quot;INFO: os::commit_memory(&quot; INTPTR_FORMAT &quot;, &quot; SIZE_FORMAT
1885           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, (intptr_t)addr, size, exec,
1886            os::errno_name(err), err);
1887 }
1888 
1889 // NOTE: Bsd kernel does not really reserve the pages for us.
1890 //       All it does is to check if there are enough free pages
1891 //       left at the time of mmap(). This could be a potential
1892 //       problem.
1893 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
1894   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
1895 #ifdef __OpenBSD__
1896   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
1897   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);
1898   if (::mprotect(addr, size, prot) == 0) {
1899     return true;
1900   }
1901 #else
</pre>
</td>
</tr>
</table>
<center><a href="globals_bsd.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux/os_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
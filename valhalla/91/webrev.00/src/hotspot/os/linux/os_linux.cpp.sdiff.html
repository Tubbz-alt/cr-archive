<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../bsd/os_bsd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows/os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3234       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,
3235                                                libnuma_dlsym(handle, &quot;numa_bitmask_isbitset&quot;)));
3236       set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,
3237                                        libnuma_dlsym(handle, &quot;numa_distance&quot;)));
3238       set_numa_get_membind(CAST_TO_FN_PTR(numa_get_membind_func_t,
3239                                           libnuma_v2_dlsym(handle, &quot;numa_get_membind&quot;)));
3240       set_numa_get_interleave_mask(CAST_TO_FN_PTR(numa_get_interleave_mask_func_t,
3241                                                   libnuma_v2_dlsym(handle, &quot;numa_get_interleave_mask&quot;)));
3242       set_numa_move_pages(CAST_TO_FN_PTR(numa_move_pages_func_t,
3243                                          libnuma_dlsym(handle, &quot;numa_move_pages&quot;)));
3244       set_numa_set_preferred(CAST_TO_FN_PTR(numa_set_preferred_func_t,
3245                                             libnuma_dlsym(handle, &quot;numa_set_preferred&quot;)));
3246 
3247       if (numa_available() != -1) {
3248         set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, &quot;numa_all_nodes&quot;));
3249         set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_all_nodes_ptr&quot;));
3250         set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_nodes_ptr&quot;));
3251         set_numa_interleave_bitmask(_numa_get_interleave_mask());
3252         set_numa_membind_bitmask(_numa_get_membind());
3253         // Create an index -&gt; node mapping, since nodes are not always consecutive
<span class="line-modified">3254         _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, true);</span>
3255         rebuild_nindex_to_node_map();
3256         // Create a cpu -&gt; node mapping
<span class="line-modified">3257         _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, true);</span>
3258         rebuild_cpu_to_node_map();
3259         return true;
3260       }
3261     }
3262   }
3263   return false;
3264 }
3265 
3266 size_t os::Linux::default_guard_size(os::ThreadType thr_type) {
3267   // Creating guard page is very expensive. Java thread has HotSpot
3268   // guard pages, only enable glibc guard page for non-Java threads.
3269   // (Remember: compiler thread is a Java thread, too!)
3270   return ((thr_type == java_thread || thr_type == compiler_thread) ? 0 : page_size());
3271 }
3272 
3273 void os::Linux::rebuild_nindex_to_node_map() {
3274   int highest_node_number = Linux::numa_max_node();
3275 
3276   nindex_to_node()-&gt;clear();
3277   for (int node = 0; node &lt;= highest_node_number; node++) {
</pre>
</td>
<td>
<hr />
<pre>
3234       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,
3235                                                libnuma_dlsym(handle, &quot;numa_bitmask_isbitset&quot;)));
3236       set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,
3237                                        libnuma_dlsym(handle, &quot;numa_distance&quot;)));
3238       set_numa_get_membind(CAST_TO_FN_PTR(numa_get_membind_func_t,
3239                                           libnuma_v2_dlsym(handle, &quot;numa_get_membind&quot;)));
3240       set_numa_get_interleave_mask(CAST_TO_FN_PTR(numa_get_interleave_mask_func_t,
3241                                                   libnuma_v2_dlsym(handle, &quot;numa_get_interleave_mask&quot;)));
3242       set_numa_move_pages(CAST_TO_FN_PTR(numa_move_pages_func_t,
3243                                          libnuma_dlsym(handle, &quot;numa_move_pages&quot;)));
3244       set_numa_set_preferred(CAST_TO_FN_PTR(numa_set_preferred_func_t,
3245                                             libnuma_dlsym(handle, &quot;numa_set_preferred&quot;)));
3246 
3247       if (numa_available() != -1) {
3248         set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, &quot;numa_all_nodes&quot;));
3249         set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_all_nodes_ptr&quot;));
3250         set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_nodes_ptr&quot;));
3251         set_numa_interleave_bitmask(_numa_get_interleave_mask());
3252         set_numa_membind_bitmask(_numa_get_membind());
3253         // Create an index -&gt; node mapping, since nodes are not always consecutive
<span class="line-modified">3254         _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, mtInternal);</span>
3255         rebuild_nindex_to_node_map();
3256         // Create a cpu -&gt; node mapping
<span class="line-modified">3257         _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, mtInternal);</span>
3258         rebuild_cpu_to_node_map();
3259         return true;
3260       }
3261     }
3262   }
3263   return false;
3264 }
3265 
3266 size_t os::Linux::default_guard_size(os::ThreadType thr_type) {
3267   // Creating guard page is very expensive. Java thread has HotSpot
3268   // guard pages, only enable glibc guard page for non-Java threads.
3269   // (Remember: compiler thread is a Java thread, too!)
3270   return ((thr_type == java_thread || thr_type == compiler_thread) ? 0 : page_size());
3271 }
3272 
3273 void os::Linux::rebuild_nindex_to_node_map() {
3274   int highest_node_number = Linux::numa_max_node();
3275 
3276   nindex_to_node()-&gt;clear();
3277   for (int node = 0; node &lt;= highest_node_number; node++) {
</pre>
</td>
</tr>
</table>
<center><a href="../bsd/os_bsd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows/os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>